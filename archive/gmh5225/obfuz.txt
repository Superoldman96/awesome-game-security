Project Path: arc_gmh5225_obfuz_plnxf5x1

Source Tree:

```txt
arc_gmh5225_obfuz_plnxf5x1
├── Editor
│   ├── Conf
│   │   ├── XmlAssemblyTypeMethodRuleParser.cs
│   │   ├── XmlAssemblyTypeMethodRuleParser.cs.meta
│   │   ├── XmlFieldRuleParser.cs
│   │   └── XmlFieldRuleParser.cs.meta
│   ├── Conf.meta
│   ├── ConfigurablePassPolicy.cs
│   ├── ConfigurablePassPolicy.cs.meta
│   ├── ConstValues.cs
│   ├── ConstValues.cs.meta
│   ├── Data
│   │   ├── ConstFieldAllocator.cs
│   │   ├── ConstFieldAllocator.cs.meta
│   │   ├── RvaDataAllocator.cs
│   │   └── RvaDataAllocator.cs.meta
│   ├── Data.meta
│   ├── Emit
│   │   ├── BasicBlockCollection.cs
│   │   ├── BasicBlockCollection.cs.meta
│   │   ├── DefaultMetadataImporter.cs
│   │   ├── DefaultMetadataImporter.cs.meta
│   │   ├── EntityExtensions.cs
│   │   ├── EntityExtensions.cs.meta
│   │   ├── EvalStackCalculator.cs
│   │   ├── EvalStackCalculator.cs.meta
│   │   ├── GroupByModuleEntityManager.cs
│   │   ├── GroupByModuleEntityManager.cs.meta
│   │   ├── LocalVariableAllocator.cs
│   │   └── LocalVariableAllocator.cs.meta
│   ├── Emit.meta
│   ├── EncryptionVM
│   │   ├── EncryptionInstructionWithOpCode.cs
│   │   ├── EncryptionInstructionWithOpCode.cs.meta
│   │   ├── IEncryptionInstruction.cs
│   │   ├── IEncryptionInstruction.cs.meta
│   │   ├── Instructions
│   │   │   ├── AddInstruction.cs
│   │   │   ├── AddInstruction.cs.meta
│   │   │   ├── AddRotateXorInstruction.cs
│   │   │   ├── AddRotateXorInstruction.cs.meta
│   │   │   ├── AddXorRotateInstruction.cs
│   │   │   ├── AddXorRotateInstruction.cs.meta
│   │   │   ├── BitRotateInstruction.cs
│   │   │   ├── BitRotateInstruction.cs.meta
│   │   │   ├── EncryptFunction.cs
│   │   │   ├── EncryptFunction.cs.meta
│   │   │   ├── MultipleInstruction.cs
│   │   │   ├── MultipleInstruction.cs.meta
│   │   │   ├── MultipleRotateXorInstruction.cs
│   │   │   ├── MultipleRotateXorInstruction.cs.meta
│   │   │   ├── MultipleXorRotateInstruction.cs
│   │   │   ├── MultipleXorRotateInstruction.cs.meta
│   │   │   ├── XorAddRotateInstruction.cs
│   │   │   ├── XorAddRotateInstruction.cs.meta
│   │   │   ├── XorInstruction.cs
│   │   │   ├── XorInstruction.cs.meta
│   │   │   ├── XorMultipleRotateInstruction.cs
│   │   │   └── XorMultipleRotateInstruction.cs.meta
│   │   ├── Instructions.meta
│   │   ├── VirtualMachine.cs
│   │   ├── VirtualMachine.cs.meta
│   │   ├── VirtualMachineCodeGenerator.cs
│   │   ├── VirtualMachineCodeGenerator.cs.meta
│   │   ├── VirtualMachineCreator.cs
│   │   ├── VirtualMachineCreator.cs.meta
│   │   ├── VirtualMachineSimulator.cs
│   │   └── VirtualMachineSimulator.cs.meta
│   ├── EncryptionVM.meta
│   ├── GarbageCodeGeneration
│   │   ├── ConfigGarbageCodeGenerator.cs
│   │   ├── ConfigGarbageCodeGenerator.cs.meta
│   │   ├── GarbageCodeGenerator.cs
│   │   ├── GarbageCodeGenerator.cs.meta
│   │   ├── ISpecificGarbageCodeGenerator.cs
│   │   ├── ISpecificGarbageCodeGenerator.cs.meta
│   │   ├── SpecificGarbageCodeGeneratorBase.cs
│   │   ├── SpecificGarbageCodeGeneratorBase.cs.meta
│   │   ├── UIGarbageCodeGenerator.cs
│   │   └── UIGarbageCodeGenerator.cs.meta
│   ├── GarbageCodeGeneration.meta
│   ├── IObfuscationPass.cs
│   ├── IObfuscationPass.cs.meta
│   ├── ObfusPasses
│   │   ├── BasicBlockObfuscationPassBase.cs
│   │   ├── BasicBlockObfuscationPassBase.cs.meta
│   │   ├── CallObfus
│   │   │   ├── CallObfusPass.cs
│   │   │   ├── CallObfusPass.cs.meta
│   │   │   ├── ConfigurableObfuscationPolicy.cs
│   │   │   ├── ConfigurableObfuscationPolicy.cs.meta
│   │   │   ├── DelegateProxyAllocator.cs
│   │   │   ├── DelegateProxyAllocator.cs.meta
│   │   │   ├── DelegateProxyObfuscator.cs
│   │   │   ├── DelegateProxyObfuscator.cs.meta
│   │   │   ├── DispatchProxyAllocator.cs
│   │   │   ├── DispatchProxyAllocator.cs.meta
│   │   │   ├── DispatchProxyObfuscator.cs
│   │   │   ├── DispatchProxyObfuscator.cs.meta
│   │   │   ├── IObfuscationPolicy.cs
│   │   │   ├── IObfuscationPolicy.cs.meta
│   │   │   ├── IObfuscator.cs
│   │   │   ├── IObfuscator.cs.meta
│   │   │   ├── MethodKey.cs
│   │   │   ├── MethodKey.cs.meta
│   │   │   ├── SpecialWhiteListMethodCalculator.cs
│   │   │   └── SpecialWhiteListMethodCalculator.cs.meta
│   │   ├── CallObfus.meta
│   │   ├── CleanUp
│   │   │   ├── CleanUpInstructionPass.cs
│   │   │   ├── CleanUpInstructionPass.cs.meta
│   │   │   ├── RemoveObfuzAttributesPass.cs
│   │   │   └── RemoveObfuzAttributesPass.cs.meta
│   │   ├── CleanUp.meta
│   │   ├── ConstEncrypt
│   │   │   ├── ConfigurableEncryptPolicy.cs
│   │   │   ├── ConfigurableEncryptPolicy.cs.meta
│   │   │   ├── ConstEncryptPass.cs
│   │   │   ├── ConstEncryptPass.cs.meta
│   │   │   ├── DefaultConstEncryptor.cs
│   │   │   ├── DefaultConstEncryptor.cs.meta
│   │   │   ├── IConstEncryptor.cs
│   │   │   ├── IConstEncryptor.cs.meta
│   │   │   ├── IEncryptPolicy.cs
│   │   │   └── IEncryptPolicy.cs.meta
│   │   ├── ConstEncrypt.meta
│   │   ├── ControlFlowObfus
│   │   │   ├── ConfigurableObfuscationPolicy.cs
│   │   │   ├── ConfigurableObfuscationPolicy.cs.meta
│   │   │   ├── ControlFlowObfusPass.cs
│   │   │   ├── ControlFlowObfusPass.cs.meta
│   │   │   ├── DefaultObfuscator.cs
│   │   │   ├── DefaultObfuscator.cs.meta
│   │   │   ├── IObfuscator.cs
│   │   │   ├── IObfuscator.cs.meta
│   │   │   ├── MethodControlFlowCalculator.cs
│   │   │   └── MethodControlFlowCalculator.cs.meta
│   │   ├── ControlFlowObfus.meta
│   │   ├── EvalStackObfus
│   │   │   ├── ConfigurableObfuscationPolicy.cs
│   │   │   ├── ConfigurableObfuscationPolicy.cs.meta
│   │   │   ├── DefaultObfuscator.cs
│   │   │   ├── DefaultObfuscator.cs.meta
│   │   │   ├── EvalStackObfusPass.cs
│   │   │   ├── EvalStackObfusPass.cs.meta
│   │   │   ├── IObfuscator.cs
│   │   │   └── IObfuscator.cs.meta
│   │   ├── EvalStackObfus.meta
│   │   ├── ExprObfus
│   │   │   ├── ConfigurableObfuscationPolicy.cs
│   │   │   ├── ConfigurableObfuscationPolicy.cs.meta
│   │   │   ├── ExprObfusPass.cs
│   │   │   ├── ExprObfusPass.cs.meta
│   │   │   ├── IObfuscator.cs
│   │   │   ├── IObfuscator.cs.meta
│   │   │   ├── Obfuscators
│   │   │   │   ├── AdvancedObfuscator.cs
│   │   │   │   ├── AdvancedObfuscator.cs.meta
│   │   │   │   ├── BasicObfuscator.cs
│   │   │   │   ├── BasicObfuscator.cs.meta
│   │   │   │   ├── MostAdvancedObfuscator.cs
│   │   │   │   └── MostAdvancedObfuscator.cs.meta
│   │   │   └── Obfuscators.meta
│   │   ├── ExprObfus.meta
│   │   ├── FieldEncrypt
│   │   │   ├── ConfigurableEncryptPolicy.cs
│   │   │   ├── ConfigurableEncryptPolicy.cs.meta
│   │   │   ├── DefaultFieldEncryptor.cs
│   │   │   ├── DefaultFieldEncryptor.cs.meta
│   │   │   ├── FieldEncryptPass.cs
│   │   │   ├── FieldEncryptPass.cs.meta
│   │   │   ├── IEncryptPolicy.cs
│   │   │   ├── IEncryptPolicy.cs.meta
│   │   │   ├── IFieldEncryptor.cs
│   │   │   └── IFieldEncryptor.cs.meta
│   │   ├── FieldEncrypt.meta
│   │   ├── Instinct
│   │   │   ├── InstinctPass.cs
│   │   │   └── InstinctPass.cs.meta
│   │   ├── Instinct.meta
│   │   ├── InstructionObfuscationPassBase.cs
│   │   ├── InstructionObfuscationPassBase.cs.meta
│   │   ├── ObfuscationMethodPassBase.cs
│   │   ├── ObfuscationMethodPassBase.cs.meta
│   │   ├── ObfuscationPassBase.cs
│   │   ├── ObfuscationPassBase.cs.meta
│   │   ├── ObfuscationPassType.cs
│   │   ├── ObfuscationPassType.cs.meta
│   │   ├── SymbolObfus
│   │   │   ├── INameMaker.cs
│   │   │   ├── INameMaker.cs.meta
│   │   │   ├── IObfuscationPolicy.cs
│   │   │   ├── IObfuscationPolicy.cs.meta
│   │   │   ├── NameMakers
│   │   │   │   ├── DebugNameMaker.cs
│   │   │   │   ├── DebugNameMaker.cs.meta
│   │   │   │   ├── INameScope.cs
│   │   │   │   ├── INameScope.cs.meta
│   │   │   │   ├── NameMakerBase.cs
│   │   │   │   ├── NameMakerBase.cs.meta
│   │   │   │   ├── NameMakerFactory.cs
│   │   │   │   ├── NameMakerFactory.cs.meta
│   │   │   │   ├── NameScope.cs
│   │   │   │   ├── NameScope.cs.meta
│   │   │   │   ├── NameScopeBase.cs
│   │   │   │   ├── NameScopeBase.cs.meta
│   │   │   │   ├── WordSetNameMaker.cs
│   │   │   │   └── WordSetNameMaker.cs.meta
│   │   │   ├── NameMakers.meta
│   │   │   ├── Policies
│   │   │   │   ├── CacheRenamePolicy.cs
│   │   │   │   ├── CacheRenamePolicy.cs.meta
│   │   │   │   ├── CombineRenamePolicy.cs
│   │   │   │   ├── CombineRenamePolicy.cs.meta
│   │   │   │   ├── ConfigurableRenamePolicy.cs
│   │   │   │   ├── ConfigurableRenamePolicy.cs.meta
│   │   │   │   ├── ObfuscationPolicyBase.cs
│   │   │   │   ├── ObfuscationPolicyBase.cs.meta
│   │   │   │   ├── SupportPassPolicy.cs
│   │   │   │   ├── SupportPassPolicy.cs.meta
│   │   │   │   ├── SystemRenamePolicy.cs
│   │   │   │   ├── SystemRenamePolicy.cs.meta
│   │   │   │   ├── UnityRenamePolicy.cs
│   │   │   │   └── UnityRenamePolicy.cs.meta
│   │   │   ├── Policies.meta
│   │   │   ├── ReflectionCompatibilityDetector.cs
│   │   │   ├── ReflectionCompatibilityDetector.cs.meta
│   │   │   ├── RenameRecordMap.cs
│   │   │   ├── RenameRecordMap.cs.meta
│   │   │   ├── SymbolObfusPass.cs
│   │   │   ├── SymbolObfusPass.cs.meta
│   │   │   ├── SymbolRename.cs
│   │   │   ├── SymbolRename.cs.meta
│   │   │   ├── VirtualMethodGroupCalculator.cs
│   │   │   └── VirtualMethodGroupCalculator.cs.meta
│   │   └── SymbolObfus.meta
│   ├── ObfusPasses.meta
│   ├── ObfuscationMethodWhitelist.cs
│   ├── ObfuscationMethodWhitelist.cs.meta
│   ├── ObfuscationPassContext.cs
│   ├── ObfuscationPassContext.cs.meta
│   ├── Obfuscator.cs
│   ├── Obfuscator.cs.meta
│   ├── ObfuscatorBuilder.cs
│   ├── ObfuscatorBuilder.cs.meta
│   ├── Obfuz.Editor.asmdef
│   ├── Obfuz.Editor.asmdef.meta
│   ├── Pipeline.cs
│   ├── Pipeline.cs.meta
│   ├── Settings
│   │   ├── AssemblySettings.cs
│   │   ├── AssemblySettings.cs.meta
│   │   ├── BuildPipelineSettings.cs
│   │   ├── BuildPipelineSettings.cs.meta
│   │   ├── CallObfuscationSettings.cs
│   │   ├── CallObfuscationSettings.cs.meta
│   │   ├── ConstEncryptionSettings.cs
│   │   ├── ConstEncryptionSettings.cs.meta
│   │   ├── ControlFlowObfuscationSettings.cs
│   │   ├── ControlFlowObfuscationSettings.cs.meta
│   │   ├── EncryptionVMSettings.cs
│   │   ├── EncryptionVMSettings.cs.meta
│   │   ├── EvalStackObfuscationSettings.cs
│   │   ├── EvalStackObfuscationSettings.cs.meta
│   │   ├── ExprObfuscationSettings.cs
│   │   ├── ExprObfuscationSettings.cs.meta
│   │   ├── FieldEncryptionSettings.cs
│   │   ├── FieldEncryptionSettings.cs.meta
│   │   ├── GarbageCodeGenerationSettings.cs
│   │   ├── GarbageCodeGenerationSettings.cs.meta
│   │   ├── ObfuscationLevel.cs
│   │   ├── ObfuscationLevel.cs.meta
│   │   ├── ObfuscationPassSettings.cs
│   │   ├── ObfuscationPassSettings.cs.meta
│   │   ├── ObfuzSettings.cs
│   │   ├── ObfuzSettings.cs.meta
│   │   ├── ObfuzSettingsProvider.cs
│   │   ├── ObfuzSettingsProvider.cs.meta
│   │   ├── PolymorphicDllSettings.cs
│   │   ├── PolymorphicDllSettings.cs.meta
│   │   ├── SecretSettings.cs
│   │   ├── SecretSettings.cs.meta
│   │   ├── SymbolObfuscationSettings.cs
│   │   └── SymbolObfuscationSettings.cs.meta
│   ├── Settings.meta
│   ├── Unity
│   │   ├── LinkXmlProcess.cs
│   │   ├── LinkXmlProcess.cs.meta
│   │   ├── LiteSymbolMappingReader.cs
│   │   ├── LiteSymbolMappingReader.cs.meta
│   │   ├── ObfuscationBeginEventArgs.cs
│   │   ├── ObfuscationBeginEventArgs.cs.meta
│   │   ├── ObfuscationEndEventArgs.cs
│   │   ├── ObfuscationEndEventArgs.cs.meta
│   │   ├── ObfuscationProcess.cs
│   │   ├── ObfuscationProcess.cs.meta
│   │   ├── ObfuzMenu.cs
│   │   ├── ObfuzMenu.cs.meta
│   │   ├── UnityProjectManagedAssemblyResolver.cs
│   │   └── UnityProjectManagedAssemblyResolver.cs.meta
│   ├── Unity.meta
│   ├── Utils
│   │   ├── AssemblyCache.cs
│   │   ├── AssemblyCache.cs.meta
│   │   ├── AssemblyResolverBase.cs
│   │   ├── AssemblyResolverBase.cs.meta
│   │   ├── AssertUtil.cs
│   │   ├── AssertUtil.cs.meta
│   │   ├── BurstCompileComputeCache.cs
│   │   ├── BurstCompileComputeCache.cs.meta
│   │   ├── CachedDictionary.cs
│   │   ├── CachedDictionary.cs.meta
│   │   ├── CollectionExtensions.cs
│   │   ├── CollectionExtensions.cs.meta
│   │   ├── CombinedAssemblyResolver.cs
│   │   ├── CombinedAssemblyResolver.cs.meta
│   │   ├── ConfigUtil.cs
│   │   ├── ConfigUtil.cs.meta
│   │   ├── ConstObfusUtil.cs
│   │   ├── ConstObfusUtil.cs.meta
│   │   ├── DisableTypeDefFindCacheScope.cs
│   │   ├── DisableTypeDefFindCacheScope.cs.meta
│   │   ├── EncryptionUtil.cs
│   │   ├── EncryptionUtil.cs.meta
│   │   ├── FileUtil.cs
│   │   ├── FileUtil.cs.meta
│   │   ├── GenericArgumentContext.cs
│   │   ├── GenericArgumentContext.cs.meta
│   │   ├── HashUtil.cs
│   │   ├── HashUtil.cs.meta
│   │   ├── IAssemblyResolver.cs
│   │   ├── IAssemblyResolver.cs.meta
│   │   ├── IRandom.cs
│   │   ├── IRandom.cs.meta
│   │   ├── KeyGenerator.cs
│   │   ├── KeyGenerator.cs.meta
│   │   ├── MathUtil.cs
│   │   ├── MathUtil.cs.meta
│   │   ├── MetaUtil.cs
│   │   ├── MetaUtil.cs.meta
│   │   ├── NameMatcher.cs
│   │   ├── NameMatcher.cs.meta
│   │   ├── NumberRange.cs
│   │   ├── NumberRange.cs.meta
│   │   ├── ObfuzIgnoreScopeComputeCache.cs
│   │   ├── ObfuzIgnoreScopeComputeCache.cs.meta
│   │   ├── PathAssemblyResolver.cs
│   │   ├── PathAssemblyResolver.cs.meta
│   │   ├── PlatformUtil.cs
│   │   ├── PlatformUtil.cs.meta
│   │   ├── RandomUtil.cs
│   │   ├── RandomUtil.cs.meta
│   │   ├── RandomWithKey.cs
│   │   ├── RandomWithKey.cs.meta
│   │   ├── ReflectionUtil.cs
│   │   ├── ReflectionUtil.cs.meta
│   │   ├── ThisArgType.cs
│   │   ├── ThisArgType.cs.meta
│   │   ├── TypeSigUtil.cs
│   │   └── TypeSigUtil.cs.meta
│   └── Utils.meta
├── Editor.meta
├── LICENSE
├── LICENSE.meta
├── Plugins
│   ├── dnlib.dll
│   └── dnlib.dll.meta
├── Plugins.meta
├── README.md
├── README.md.meta
├── REAME-EN.md
├── REAME-EN.md.meta
├── Runtime
│   ├── AssetUtility.cs
│   ├── AssetUtility.cs.meta
│   ├── ConstUtility.cs
│   ├── ConstUtility.cs.meta
│   ├── EncryptFieldAttribute.cs
│   ├── EncryptFieldAttribute.cs.meta
│   ├── EncryptionScope.cs
│   ├── EncryptionScope.cs.meta
│   ├── EncryptionService.cs
│   ├── EncryptionService.cs.meta
│   ├── EncryptorBase.cs
│   ├── EncryptorBase.cs.meta
│   ├── ExprUtility.cs
│   ├── ExprUtility.cs.meta
│   ├── IEncryptor.cs
│   ├── IEncryptor.cs.meta
│   ├── NullEncryptor.cs
│   ├── NullEncryptor.cs.meta
│   ├── ObfuscationInstincts.cs
│   ├── ObfuscationInstincts.cs.meta
│   ├── ObfuscationTypeMapper.cs
│   ├── ObfuscationTypeMapper.cs.meta
│   ├── Obfuz.Runtime.asmdef
│   ├── Obfuz.Runtime.asmdef.meta
│   ├── ObfuzIgnoreAttribute.cs
│   ├── ObfuzIgnoreAttribute.cs.meta
│   ├── ObfuzScope.cs
│   └── ObfuzScope.cs.meta
├── Runtime.meta
├── package.json
└── package.json.meta

```

`Editor.meta`:

```meta
fileFormatVersion: 2
guid: 2326b426d539e084dbddf7f7c23ed1bd
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Conf.meta`:

```meta
fileFormatVersion: 2
guid: 241df8eaf3a34dc47a0873c37ddb2695
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Conf/XmlAssemblyTypeMethodRuleParser.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Xml;
using UnityEngine;

namespace Obfuz.Conf
{
    public interface IRule<T>
    {
        void InheritParent(T parentRule);
    }


    public interface IMethodRule<R> where R : IRule<R>
    {
        string Name { get; set; }
        NameMatcher NameMatcher { get; set; }

        R Rule { get; set; }
    }

    public abstract class MethodRuleBase<R> : IMethodRule<R> where R : IRule<R>
    {
        public string Name { get; set; }
        public NameMatcher NameMatcher { get; set; }

        public R Rule { get; set; }
    }

    public interface ITypeRule<T, R> where T : IMethodRule<R> where R : IRule<R>
    {
        string Name { get; set; }

        NameMatcher NameMatcher { get; set; }

        R Rule { get; set; }

        List<T> Methods { get; set; }
    }

    public abstract class TypeRuleBase<T, R> : ITypeRule<T, R> where T : IMethodRule<R> where R : IRule<R>
    {
        public string Name { get; set; }

        public NameMatcher NameMatcher { get; set; }

        public R Rule { get; set; }

        public List<T> Methods { get; set; }
    }

    public interface IAssemblyRule<TType, TMethod, TRule> where TType : ITypeRule<TMethod, TRule> where TMethod : IMethodRule<TRule> where TRule : IRule<TRule>
    {
        string Name { get; set; }

        TRule Rule { get; set; }

        List<TType> Types { get; set; }
    }
    public abstract class AssemblyRuleBase<TType, TMethod, TRule> : IAssemblyRule<TType, TMethod, TRule> where TType : ITypeRule<TMethod, TRule> where TMethod : IMethodRule<TRule> where TRule : IRule<TRule>
    {
        public string Name { get; set; }

        public TRule Rule { get; set; }

        public List<TType> Types { get; set; }
    }

    public class XmlAssemblyTypeMethodRuleParser<TAssembly, TType, TMethod, TRule>
        where TMethod : IMethodRule<TRule>, new()
        where TType : ITypeRule<TMethod, TRule>, new()
        where TAssembly : IAssemblyRule<TType, TMethod, TRule>, new()
         where TRule : IRule<TRule>, new()
    {
        private readonly HashSet<string> _toObfuscatedAssemblyNames;
        private readonly Func<string, XmlElement, TRule> _ruleParser;
        private readonly Action<string, XmlElement> _unknownNodeTypeHandler;
        private readonly Dictionary<string, TAssembly> _assemblySpecs = new Dictionary<string, TAssembly>();

        public XmlAssemblyTypeMethodRuleParser(IEnumerable<string> toObfuscatedAssemblyNames, Func<string, XmlElement, TRule> ruleParser, Action<string, XmlElement> unknownNodeTypeHandler)
        {
            _toObfuscatedAssemblyNames = new HashSet<string>(toObfuscatedAssemblyNames);
            _ruleParser = ruleParser;
            _unknownNodeTypeHandler = unknownNodeTypeHandler;
        }

        public Dictionary<string, TAssembly> AssemblySpecs => _assemblySpecs;

        public void LoadConfigs(IEnumerable<string> configFiles)
        {
            foreach (var configFile in configFiles)
            {
                LoadConfig(configFile);
            }
        }

        public void LoadConfig(string configFile)
        {
            if (string.IsNullOrEmpty(configFile))
            {
                throw new Exception($"Invalid xml file {configFile}, file name is empty");
            }
            Debug.Log($"ConfigurableObfuscationPolicy::LoadConfig {configFile}");
            var doc = new XmlDocument();
            doc.Load(configFile);
            var root = doc.DocumentElement;
            if (root.Name != "obfuz")
            {
                throw new Exception($"Invalid xml file {configFile}, root name should be 'obfuz'");
            }
            foreach (XmlNode node in root.ChildNodes)
            {
                if (!(node is XmlElement ele))
                {
                    continue;
                }
                switch (ele.Name)
                {
                    case "assembly":
                    {
                        TAssembly assSpec = ParseAssembly(configFile, ele);
                        _assemblySpecs.Add(assSpec.Name, assSpec);
                        break;
                    }
                    default:
                    {
                        if (_unknownNodeTypeHandler == null)
                        {
                            throw new Exception($"Invalid xml file {configFile}, unknown node {ele.Name}");
                        }
                        _unknownNodeTypeHandler(configFile, ele);
                        break;
                    }
                }
            }
        }

        private TAssembly ParseAssembly(string configFile, XmlElement ele)
        {
            var assemblySpec = new TAssembly();
            string name = ele.GetAttribute("name");
            if (!_toObfuscatedAssemblyNames.Contains(name))
            {
                throw new Exception($"Invalid xml file {configFile}, assembly name {name} isn't in toObfuscatedAssemblyNames");
            }
            if (_assemblySpecs.ContainsKey(name))
            {
                throw new Exception($"Invalid xml file {configFile}, assembly name {name} is duplicated");
            }
            assemblySpec.Name = name;
            assemblySpec.Rule = _ruleParser(configFile, ele);

            var types = new List<TType>();
            assemblySpec.Types = types;
            foreach (XmlNode node in ele.ChildNodes)
            {
                if (!(node is XmlElement childEle))
                {
                    continue;
                }
                switch (childEle.Name)
                {
                    case "type":
                    {
                        types.Add(ParseType(configFile, childEle));
                        break;
                    }
                    default:
                    {
                        throw new Exception($"Invalid xml file, unknown node {childEle.Name}");
                    }
                }
            }
            return assemblySpec;
        }

        private TType ParseType(string configFile, XmlElement element)
        {
            var typeSpec = new TType();

            string name = element.GetAttribute("name");
            typeSpec.Name = name;
            typeSpec.NameMatcher = new NameMatcher(name);
            typeSpec.Rule = _ruleParser(configFile, element);

            var methods = new List<TMethod>();
            typeSpec.Methods = methods;
            foreach (XmlNode node in element.ChildNodes)
            {
                if (!(node is XmlElement ele))
                {
                    continue;
                }
                switch (ele.Name)
                {
                    case "method":
                    {
                        methods.Add(ParseMethod(configFile, ele));
                        break;
                    }
                    default:
                    {
                        throw new Exception($"Invalid xml file, unknown node {ele.Name}");
                    }
                }
            }
            return typeSpec;
        }

        private TMethod ParseMethod(string configFile, XmlElement element)
        {
            var methodSpec = new TMethod();
            string name = element.GetAttribute("name");
            methodSpec.Name = name;
            methodSpec.NameMatcher = new NameMatcher(name);
            methodSpec.Rule = _ruleParser(configFile, element);
            return methodSpec;
        }

        public TRule GetMethodRule(MethodDef method, TRule defaultRule)
        {
            var assemblyName = method.DeclaringType.Module.Assembly.Name;
            if (!_assemblySpecs.TryGetValue(assemblyName, out var assSpec))
            {
                return defaultRule;
            }
            string declaringTypeName = method.DeclaringType.FullName;
            foreach (var typeSpec in assSpec.Types)
            {
                if (typeSpec.NameMatcher.IsMatch(declaringTypeName))
                {
                    foreach (var methodSpec in typeSpec.Methods)
                    {
                        if (methodSpec.NameMatcher.IsMatch(method.Name))
                        {
                            return methodSpec.Rule;
                        }
                    }
                    return typeSpec.Rule;
                }
            }
            return assSpec.Rule;
        }

        public void InheritParentRules(TRule defaultRule)
        {
            foreach (TAssembly assSpec in _assemblySpecs.Values)
            {
                assSpec.Rule.InheritParent(defaultRule);
                foreach (TType typeSpec in assSpec.Types)
                {
                    typeSpec.Rule.InheritParent(assSpec.Rule);
                    foreach (TMethod methodSpec in typeSpec.Methods)
                    {
                        methodSpec.Rule.InheritParent(typeSpec.Rule);
                    }
                }
            }
        }
    }
}

```

`Editor/Conf/XmlAssemblyTypeMethodRuleParser.cs.meta`:

```meta
fileFormatVersion: 2
guid: 36a3e142db81f6d4bb54938525e31973
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Conf/XmlFieldRuleParser.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Xml;

namespace Obfuz.Conf
{



    public class XmlFieldRuleParser<R> where R : class, new()
    {
        private readonly HashSet<string> _toObfuscatedAssemblyNames;
        private readonly Func<string, XmlElement, R> _ruleParser;
        private readonly Action<string, XmlElement> _unknownNodeTypeHandler;
        private readonly Dictionary<string, AssemblySpec> _assemblySpecs = new Dictionary<string, AssemblySpec>();


        private class FieldSpec
        {
            public string Name { get; set; }
            public NameMatcher NameMatcher { get; set; }

            public R Rule { get; set; }
        }

        private class TypeSpec
        {
            public string Name { get; set; }

            public NameMatcher NameMatcher { get; set; }

            public List<FieldSpec> Fields { get; set; }
        }

        private class AssemblySpec
        {
            public string Name { get; set; }

            public List<TypeSpec> Types { get; set; }
        }

        public XmlFieldRuleParser(IEnumerable<string> toObfuscatedAssemblyNames, Func<string, XmlElement, R> ruleParser, Action<string, XmlElement> unknownNodeTypeHandler)
        {
            _toObfuscatedAssemblyNames = new HashSet<string>(toObfuscatedAssemblyNames);
            _ruleParser = ruleParser;
            _unknownNodeTypeHandler = unknownNodeTypeHandler;
        }

        public void LoadConfigs(IEnumerable<string> configFiles)
        {
            foreach (var configFile in configFiles)
            {
                LoadConfig(configFile);
            }
        }

        public void LoadConfig(string configFile)
        {
            if (string.IsNullOrEmpty(configFile))
            {
                throw new Exception($"Invalid xml file {configFile}, file name is empty");
            }
            var doc = new XmlDocument();
            doc.Load(configFile);
            var root = doc.DocumentElement;
            if (root.Name != "obfuz")
            {
                throw new Exception($"Invalid xml file {configFile}, root name should be 'obfuz'");
            }
            foreach (XmlNode node in root.ChildNodes)
            {
                if (!(node is XmlElement ele))
                {
                    continue;
                }
                switch (ele.Name)
                {
                    case "assembly":
                    {
                        AssemblySpec assSpec = ParseAssembly(configFile, ele);
                        _assemblySpecs.Add(assSpec.Name, assSpec);
                        break;
                    }
                    default:
                    {
                        if (_unknownNodeTypeHandler == null)
                        {
                            throw new Exception($"Invalid xml file {configFile}, unknown node {ele.Name}");
                        }
                        _unknownNodeTypeHandler(configFile, ele);
                        break;
                    }
                }
            }
        }

        private AssemblySpec ParseAssembly(string configFile, XmlElement ele)
        {
            var assemblySpec = new AssemblySpec();
            string name = ele.GetAttribute("name");
            if (!_toObfuscatedAssemblyNames.Contains(name))
            {
                throw new Exception($"Invalid xml file {configFile}, assembly name {name} isn't in toObfuscatedAssemblyNames");
            }
            if (_assemblySpecs.ContainsKey(name))
            {
                throw new Exception($"Invalid xml file {configFile}, assembly name {name} is duplicated");
            }
            assemblySpec.Name = name;

            var types = new List<TypeSpec>();
            assemblySpec.Types = types;
            foreach (XmlNode node in ele.ChildNodes)
            {
                if (!(node is XmlElement childEle))
                {
                    continue;
                }
                switch (childEle.Name)
                {
                    case "type":
                    {
                        types.Add(ParseType(configFile, childEle));
                        break;
                    }
                    default:
                    {
                        throw new Exception($"Invalid xml file, unknown node {childEle.Name}");
                    }
                }
            }
            return assemblySpec;
        }

        private TypeSpec ParseType(string configFile, XmlElement element)
        {
            var typeSpec = new TypeSpec();

            string name = element.GetAttribute("name");
            typeSpec.Name = name;
            typeSpec.NameMatcher = new NameMatcher(name);

            var fields = new List<FieldSpec>();
            typeSpec.Fields = fields;
            foreach (XmlNode node in element.ChildNodes)
            {
                if (!(node is XmlElement ele))
                {
                    continue;
                }
                switch (ele.Name)
                {
                    case "field":
                    {
                        fields.Add(ParseField(configFile, ele));
                        break;
                    }
                    default:
                    {
                        throw new Exception($"Invalid xml file, unknown node {ele.Name}");
                    }
                }
            }
            return typeSpec;
        }

        private FieldSpec ParseField(string configFile, XmlElement element)
        {
            var fieldSpec = new FieldSpec();
            string name = element.GetAttribute("name");
            fieldSpec.Name = name;
            fieldSpec.NameMatcher = new NameMatcher(name);
            fieldSpec.Rule = _ruleParser(configFile, element);
            return fieldSpec;
        }

        public R GetFieldRule(FieldDef field)
        {
            var assemblyName = field.DeclaringType.Module.Assembly.Name;
            if (!_assemblySpecs.TryGetValue(assemblyName, out var assSpec))
            {
                return null;
            }
            string declaringTypeName = field.DeclaringType.FullName;
            foreach (var typeSpec in assSpec.Types)
            {
                if (typeSpec.NameMatcher.IsMatch(declaringTypeName))
                {
                    foreach (var fieldSpec in typeSpec.Fields)
                    {
                        if (fieldSpec.NameMatcher.IsMatch(field.Name))
                        {
                            return fieldSpec.Rule;
                        }
                    }
                }
            }
            return null;
        }
    }
}

```

`Editor/Conf/XmlFieldRuleParser.cs.meta`:

```meta
fileFormatVersion: 2
guid: 1578270b9b81e1e4dba84d562c91090f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ConfigurablePassPolicy.cs`:

```cs
using dnlib.DotNet;
using Obfuz.ObfusPasses;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Xml;
using UnityEngine;

namespace Obfuz
{
    public class ConfigurablePassPolicy
    {
        class PassRule
        {
            public ObfuscationPassType? enablePasses;
            public ObfuscationPassType? disablePasses;
            public ObfuscationPassType? addPasses;
            public ObfuscationPassType? removePasses;
            public ObfuscationPassType finalPasses;

            public void InheritParent(PassRule parentRule, ObfuscationPassType globalEnabledPasses)
            {
                finalPasses = parentRule.finalPasses;
                if (enablePasses != null)
                {
                    finalPasses = enablePasses.Value;
                }
                if (disablePasses != null)
                {
                    finalPasses = ~disablePasses.Value;
                }
                if (addPasses != null)
                {
                    finalPasses |= addPasses.Value;
                }
                if (removePasses != null)
                {
                    finalPasses &= ~removePasses.Value;
                }
                finalPasses &= globalEnabledPasses;
            }
        }

        class SpecBase
        {
            public string name;
            public NameMatcher nameMatcher;
            public PassRule rule;
        }

        class MethodSpec : SpecBase
        {
        }

        class FieldSpec : SpecBase
        {
        }

        class PropertySpec : SpecBase
        {
        }

        class EventSpec : SpecBase
        {
        }

        class TypeSpec : SpecBase
        {
            public List<FieldSpec> fields = new List<FieldSpec>();
            public List<MethodSpec> methods = new List<MethodSpec>();
            public List<PropertySpec> properties = new List<PropertySpec>();
            public List<EventSpec> events = new List<EventSpec>();
        }

        class AssemblySpec
        {
            public string name;
            public NameMatcher nameMatcher;
            public PassRule rule;
            public List<TypeSpec> types = new List<TypeSpec>();
        }

        private readonly ObfuscationPassType _enabledPasses;
        private readonly HashSet<string> _toObfuscatedAssemblyNames;
        private readonly List<AssemblySpec> _assemblySpecs = new List<AssemblySpec>();
        private readonly PassRule _defaultPassRule;

        private string _curLoadingConfig;

        public ConfigurablePassPolicy(IEnumerable<string> toObfuscatedAssemblyNames, ObfuscationPassType enabledPasses, List<string> configFiles)
        {
            _toObfuscatedAssemblyNames = new HashSet<string>(toObfuscatedAssemblyNames);
            _enabledPasses = enabledPasses;
            _defaultPassRule = new PassRule { finalPasses = enabledPasses };
            LoadConfigs(configFiles);
            InheritParentRules(enabledPasses);
        }

        private void LoadConfigs(IEnumerable<string> configFiles)
        {
            foreach (var configFile in configFiles)
            {
                LoadConfig(configFile);
            }
        }

        private void InheritParentRules(ObfuscationPassType enablePasses)
        {
            var defaultRule = new PassRule
            {
                enablePasses = enablePasses,
                finalPasses = enablePasses,
            };
            foreach (AssemblySpec assSpec in _assemblySpecs)
            {
                assSpec.rule.InheritParent(defaultRule, enablePasses);
                foreach (TypeSpec typeSpec in assSpec.types)
                {
                    typeSpec.rule.InheritParent(assSpec.rule, enablePasses);
                    foreach (FieldSpec fieldSpec in typeSpec.fields)
                    {
                        fieldSpec.rule.InheritParent(typeSpec.rule, enablePasses);
                    }
                    foreach (MethodSpec methodSpec in typeSpec.methods)
                    {
                        methodSpec.rule.InheritParent(typeSpec.rule, enablePasses);
                    }
                    foreach (PropertySpec propertySpec in typeSpec.properties)
                    {
                        propertySpec.rule.InheritParent(typeSpec.rule, enablePasses);
                    }
                    foreach (EventSpec eventSpec in typeSpec.events)
                    {
                        eventSpec.rule.InheritParent(typeSpec.rule, enablePasses);
                    }
                }
            }
        }

        public void LoadConfig(string configFile)
        {
            if (string.IsNullOrEmpty(configFile))
            {
                throw new Exception($"Invalid xml file {configFile}, file name is empty");
            }
            _curLoadingConfig = configFile;

            Debug.Log($"ConfigurablePassPolicy::LoadConfig {configFile}");
            var doc = new XmlDocument();
            doc.Load(configFile);
            var root = doc.DocumentElement;
            if (root.Name != "obfuz")
            {
                throw new Exception($"Invalid xml file {configFile}, root name should be 'obfuz'");
            }
            foreach (XmlNode node in root.ChildNodes)
            {
                if (!(node is XmlElement ele))
                {
                    continue;
                }
                switch (ele.Name)
                {
                    case "assembly":
                    {
                        AssemblySpec assSpec = ParseAssembly(ele);
                        _assemblySpecs.Add(assSpec);
                        break;
                    }
                    default:
                    {
                        throw new Exception($"Invalid xml file {configFile}, unknown node {ele.Name}");
                    }
                }
            }
        }

        (bool, ObfuscationPassType) ParseObfuscationType(string obfuscationPassTypesStr)
        {
            bool delta = false;
            if (obfuscationPassTypesStr[0] == '+' || obfuscationPassTypesStr[0] == '-')
            {
                delta = true;
                obfuscationPassTypesStr = obfuscationPassTypesStr.Substring(1);
            }
            ObfuscationPassType passType = ObfuscationPassType.None;
            foreach (var passName in obfuscationPassTypesStr.Split('|'))
            {
                if (Enum.TryParse<ObfuscationPassType>(passName, out var pass))
                {
                    passType |= pass;
                }
                else
                {
                    throw new Exception($"Invalid xml file {_curLoadingConfig}, unknown pass type {passName}");
                }
            }
            return (delta, passType);
        }

        private PassRule ParseRule(XmlElement ele)
        {
            var r = new PassRule();
            if (ele.HasAttribute("enable"))
            {
                string enablePassStr = ele.GetAttribute("enable");
                if (string.IsNullOrEmpty(enablePassStr))
                {
                    throw new Exception($"Invalid xml file {_curLoadingConfig}, enable attribute is empty");
                }
                var (delta, passType) = ParseObfuscationType(enablePassStr);
                if (delta)
                {
                    r.addPasses = passType;
                }
                else
                {
                    r.enablePasses = passType;
                }
            }
            if (ele.HasAttribute("disable"))
            {
                string disablePassStr = ele.GetAttribute("disable");
                if (string.IsNullOrEmpty(disablePassStr))
                {
                    throw new Exception($"Invalid xml file {_curLoadingConfig}, disable attribute is empty");
                }
                var (delta, passType) = ParseObfuscationType(disablePassStr);
                if (delta)
                {
                    r.removePasses = passType;
                }
                else
                {
                    r.disablePasses = passType;
                }
            }
            if (r.enablePasses != null && (r.disablePasses != null || r.addPasses != null || r.removePasses != null))
            {
                throw new Exception($"Invalid xml file {_curLoadingConfig}, enable and disable can't be used together");
            }
            if (r.disablePasses != null && (r.enablePasses != null || r.addPasses != null || r.removePasses != null))
            {
                throw new Exception($"Invalid xml file {_curLoadingConfig}, disable and enable can't be used together");
            }
            return r;
        }

        private AssemblySpec ParseAssembly(XmlElement ele)
        {
            var assemblySpec = new AssemblySpec();
            string name = ele.GetAttribute("name");
            if (!_toObfuscatedAssemblyNames.Contains(name))
            {
                throw new Exception($"Invalid xml file {_curLoadingConfig}, assembly name {name} isn't in toObfuscatedAssemblyNames");
            }
            assemblySpec.name = name;
            assemblySpec.nameMatcher = new NameMatcher(name);
            assemblySpec.rule = ParseRule(ele);


            var types = assemblySpec.types;
            foreach (XmlNode node in ele.ChildNodes)
            {
                if (!(node is XmlElement childEle))
                {
                    continue;
                }
                switch (childEle.Name)
                {
                    case "type":
                    {
                        types.Add(ParseType(childEle));
                        break;
                    }
                    default:
                    {
                        throw new Exception($"Invalid xml file, unknown node {childEle.Name}");
                    }
                }
            }
            return assemblySpec;
        }

        private TypeSpec ParseType(XmlElement element)
        {
            var typeSpec = new TypeSpec();

            string name = element.GetAttribute("name");
            typeSpec.name = name;
            typeSpec.nameMatcher = new NameMatcher(name);
            typeSpec.rule = ParseRule(element);

            List<FieldSpec> fields = typeSpec.fields;
            List<MethodSpec> methods = typeSpec.methods;
            List<PropertySpec> properties = typeSpec.properties;
            List<EventSpec> events = typeSpec.events;
            foreach (XmlNode node in element.ChildNodes)
            {
                if (!(node is XmlElement ele))
                {
                    continue;
                }
                switch (ele.Name)
                {
                    case "field":
                    {
                        fields.Add(ParseField(ele));
                        break;
                    }
                    case "method":
                    {
                        methods.Add(ParseMethod(ele));
                        break;
                    }
                    case "property":
                    {
                        properties.Add(ParseProperty(ele));
                        break;
                    }
                    case "event":
                    {
                        events.Add(ParseEvent(ele));
                        break;
                    }
                    default:
                    {
                        throw new Exception($"Invalid xml file, unknown node {ele.Name}");
                    }
                }
            }
            return typeSpec;
        }

        private void ParseSpecObject(XmlElement element, SpecBase obj)
        {
            string name = element.GetAttribute("name");
            obj.name = name;
            obj.nameMatcher = new NameMatcher(name);
            obj.rule = ParseRule(element);
        }

        private FieldSpec ParseField(XmlElement element)
        {
            var fieldSpec = new FieldSpec();
            ParseSpecObject(element, fieldSpec);
            return fieldSpec;
        }

        private MethodSpec ParseMethod(XmlElement element)
        {
            var methodSpec = new MethodSpec();
            ParseSpecObject(element, methodSpec);
            return methodSpec;
        }

        private PropertySpec ParseProperty(XmlElement element)
        {
            var propertySpec = new PropertySpec();
            ParseSpecObject(element, propertySpec);
            return propertySpec;
        }

        private EventSpec ParseEvent(XmlElement element)
        {
            var eventSpec = new EventSpec();
            ParseSpecObject(element, eventSpec);
            return eventSpec;
        }

        private readonly Dictionary<ModuleDef, (AssemblySpec, PassRule)> _modulePassRuleCaches = new Dictionary<ModuleDef, (AssemblySpec, PassRule)>();
        private readonly Dictionary<TypeDef, (TypeSpec, PassRule)> _typePassRuleCaches = new Dictionary<TypeDef, (TypeSpec, PassRule)>();
        private readonly Dictionary<MethodDef, (MethodSpec, PassRule)> _methodPassRuleCaches = new Dictionary<MethodDef, (MethodSpec, PassRule)>();
        private readonly Dictionary<FieldDef, (FieldSpec, PassRule)> _fieldPassRuleCaches = new Dictionary<FieldDef, (FieldSpec, PassRule)>();
        private readonly Dictionary<PropertyDef, (PropertySpec, PassRule)> _propertyPassRuleCaches = new Dictionary<PropertyDef, (PropertySpec, PassRule)>();
        private readonly Dictionary<EventDef, (EventSpec, PassRule)> _eventPassRuleCaches = new Dictionary<EventDef, (EventSpec, PassRule)>();


        private (AssemblySpec, PassRule) GetAssemblySpec(ModuleDef module)
        {
            if (!_modulePassRuleCaches.TryGetValue(module, out var result))
            {
                result = (null, _defaultPassRule);
                string assName = module.Assembly.Name;
                foreach (var ass in _assemblySpecs)
                {
                    if (ass.nameMatcher.IsMatch(assName))
                    {
                        result = (ass, ass.rule);
                        break;
                    }
                }
                _modulePassRuleCaches.Add(module, result);
            }
            return result;
        }

        private (TypeSpec, PassRule) GetTypeSpec(TypeDef type)
        {
            if (!_typePassRuleCaches.TryGetValue(type, out var result))
            {
                var assResult = GetAssemblySpec(type.Module);
                result = (null, assResult.Item2);
                if (assResult.Item1 != null)
                {
                    string typeName = type.FullName;
                    foreach (var typeSpec in assResult.Item1.types)
                    {
                        if (typeSpec.nameMatcher.IsMatch(typeName))
                        {
                            result = (typeSpec, typeSpec.rule);
                            break;
                        }
                    }
                }
                _typePassRuleCaches.Add(type, result);
            }
            return result;
        }

        private (MethodSpec, PassRule) GetMethodSpec(MethodDef method)
        {
            if (!_methodPassRuleCaches.TryGetValue(method, out var result))
            {
                var typeResult = GetTypeSpec(method.DeclaringType);
                result = (null, typeResult.Item2);
                if (typeResult.Item1 != null)
                {
                    string methodName = method.Name;
                    foreach (var methodSpec in typeResult.Item1.methods)
                    {
                        if (methodSpec.nameMatcher.IsMatch(methodName))
                        {
                            result = (methodSpec, methodSpec.rule);
                            break;
                        }
                    }
                }
                _methodPassRuleCaches.Add(method, result);
            }
            return result;
        }

        private (FieldSpec, PassRule) GetFieldSpec(FieldDef field)
        {
            if (!_fieldPassRuleCaches.TryGetValue(field, out var result))
            {
                var typeResult = GetTypeSpec(field.DeclaringType);
                result = (null, typeResult.Item2);
                if (typeResult.Item1 != null)
                {
                    string fieldName = field.Name;
                    foreach (var fieldSpec in typeResult.Item1.fields)
                    {
                        if (fieldSpec.nameMatcher.IsMatch(fieldName))
                        {
                            result = (fieldSpec, fieldSpec.rule);
                            break;
                        }
                    }
                }
                _fieldPassRuleCaches.Add(field, result);
            }
            return result;
        }

        private (PropertySpec, PassRule) GetPropertySpec(PropertyDef property)
        {
            if (!_propertyPassRuleCaches.TryGetValue(property, out var result))
            {
                var typeResult = GetTypeSpec(property.DeclaringType);
                result = (null, typeResult.Item2);
                if (typeResult.Item1 != null)
                {
                    string propertyName = property.Name;
                    foreach (var propertySpec in typeResult.Item1.properties)
                    {
                        if (propertySpec.nameMatcher.IsMatch(propertyName))
                        {
                            result = (propertySpec, propertySpec.rule);
                            break;
                        }
                    }
                }
                _propertyPassRuleCaches.Add(property, result);
            }
            return result;
        }

        private (EventSpec, PassRule) GetEventSpec(EventDef eventDef)
        {
            if (!_eventPassRuleCaches.TryGetValue(eventDef, out var result))
            {
                var typeResult = GetTypeSpec(eventDef.DeclaringType);
                result = (null, typeResult.Item2);
                if (typeResult.Item1 != null)
                {
                    string eventName = eventDef.Name;
                    foreach (var eventSpec in typeResult.Item1.events)
                    {
                        if (eventSpec.nameMatcher.IsMatch(eventName))
                        {
                            result = (eventSpec, eventSpec.rule);
                            break;
                        }
                    }
                }
                _eventPassRuleCaches.Add(eventDef, result);
            }
            return result;
        }


        public ObfuscationPassType GetAssemblyObfuscationPasses(ModuleDef module)
        {
            return GetAssemblySpec(module).Item2.finalPasses;
        }

        public ObfuscationPassType GetTypeObfuscationPasses(TypeDef type)
        {
            return GetTypeSpec(type).Item2.finalPasses;
        }

        public ObfuscationPassType GetMethodObfuscationPasses(MethodDef method)
        {
            return GetMethodSpec(method).Item2.finalPasses;
        }

        public ObfuscationPassType GetFieldObfuscationPasses(FieldDef field)
        {
            return GetFieldSpec(field).Item2.finalPasses;
        }

        public ObfuscationPassType GetPropertyObfuscationPasses(PropertyDef property)
        {
            return GetPropertySpec(property).Item2.finalPasses;
        }

        public ObfuscationPassType GetEventObfuscationPasses(EventDef eventDef)
        {
            return GetEventSpec(eventDef).Item2.finalPasses;
        }
    }
}

```

`Editor/ConfigurablePassPolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: 41044699810a34f4780e14de084bf7d7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ConstValues.cs`:

```cs
using System.Text;

namespace Obfuz.Editor
{
    public static class ConstValues
    {
        public const string ObfuzInternalSymbolNamePrefix = "$Obfuz$";

        public const string ObfuzRuntimeAssemblyName = "Obfuz.Runtime";

        public const string ObfuzIgnoreAttributeFullName = "Obfuz.ObfuzIgnoreAttribute";

        public const string ObfuzScopeFullName = "Obfuz.ObfuzScope";

        public const string EncryptFieldAttributeFullName = "Obfuz.EncryptFieldAttribute";
        public const string GeneratedEncryptionVirtualMachineFullName = "Obfuz.EncryptionVM.GeneratedEncryptionVirtualMachine";

        public const string EmbeddedAttributeFullName = "Microsoft.CodeAnalysis.EmbeddedAttribute";

        public const string MonoPInvokeCallbackAttributeName = "MonoPInvokeCallbackAttribute";

        public const string ZluaLuaInvokeAttributeFullName = "Zlua.LuaInvokeAttribute";
        public const string ZluaLuaCallbackAttributeFullName = "Zlua.LuaCallbackAttribute";
        public const string ZluaLuaMarshalAsAttributeFullName = "Zlua.LuaMarshalAsAttribute";

        public const string BurstCompileFullName = "Unity.Burst.BurstCompileAttribute";
        public const string DOTSCompilerGeneratedAttributeFullName = "Unity.Jobs.DOTSCompilerGeneratedAttribute";

        public const string RuntimeInitializedOnLoadMethodAttributeFullName = "UnityEngine.RuntimeInitializeOnLoadMethodAttribute";
        public const string BlackboardEnumAttributeFullName = "Unity.Behavior.BlackboardEnumAttribute";

        public const string CompilerGeneratedAttributeFullName = "System.Runtime.CompilerServices.CompilerGeneratedAttribute";
    }
}

```

`Editor/ConstValues.cs.meta`:

```meta
fileFormatVersion: 2
guid: aee7817ed523a5e4ea42104013e8a775
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Data.meta`:

```meta
fileFormatVersion: 2
guid: 3319ebe75a42f3d4d996846ca09ed099
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Data/ConstFieldAllocator.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Editor;
using Obfuz.Emit;
using Obfuz.Utils;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.Assertions;

namespace Obfuz.Data
{
    public class ConstFieldAllocator : GroupByModuleEntityBase
    {
        private RandomCreator _randomCreator;
        private IEncryptor _encryptor;

        private TypeDef _holderTypeDef;

        class ConstFieldInfo
        {
            public FieldDef field;
            public object value;
        }

        class AnyComparer : IEqualityComparer<object>
        {
            public new bool Equals(object x, object y)
            {
                if (x is byte[] xBytes && y is byte[] yBytes)
                {
                    return StructuralComparisons.StructuralEqualityComparer.Equals(xBytes, yBytes);
                }
                return x.Equals(y);
            }

            public static int ComputeHashCode(object obj)
            {
                return HashUtil.ComputePrimitiveOrStringOrBytesHashCode(obj);
            }

            public int GetHashCode(object obj)
            {
                return ComputeHashCode(obj);
            }
        }

        private readonly Dictionary<object, ConstFieldInfo> _allocatedFields = new Dictionary<object, ConstFieldInfo>(new AnyComparer());
        private readonly Dictionary<FieldDef, ConstFieldInfo> _field2Fields = new Dictionary<FieldDef, ConstFieldInfo>();

        private readonly List<TypeDef> _holderTypeDefs = new List<TypeDef>();
        private bool _done;


        public ConstFieldAllocator()
        {
        }

        public override void Init()
        {
            _randomCreator = EncryptionScope.localRandomCreator;
            _encryptor = EncryptionScope.encryptor;
        }

        const int maxFieldCount = 1000;


        private TypeSig GetTypeSigOfValue(object value)
        {
            ModuleDef mod = Module;
            if (value is int)
                return mod.CorLibTypes.Int32;
            if (value is long)
                return mod.CorLibTypes.Int64;
            if (value is float)
                return mod.CorLibTypes.Single;
            if (value is double)
                return mod.CorLibTypes.Double;
            if (value is string)
                return mod.CorLibTypes.String;
            if (value is byte[])
                return new SZArraySig(mod.CorLibTypes.Byte);
            throw new NotSupportedException($"Unsupported type: {value.GetType()}");
        }

        private ConstFieldInfo CreateConstFieldInfo(object value)
        {
            ModuleDef mod = Module;
            if (_holderTypeDef == null || _holderTypeDef.Fields.Count >= maxFieldCount)
            {
                using (var scope = new DisableTypeDefFindCacheScope(mod))
                {
                    ITypeDefOrRef objectTypeRef = mod.Import(typeof(object));
                    _holderTypeDef = new TypeDefUser($"{ConstValues.ObfuzInternalSymbolNamePrefix}ConstFieldHolder${_holderTypeDefs.Count}", objectTypeRef);
                    mod.Types.Add(_holderTypeDef);
                    _holderTypeDefs.Add(_holderTypeDef);
                }
            }

            var field = new FieldDefUser($"{ConstValues.ObfuzInternalSymbolNamePrefix}RVA_Value{_holderTypeDef.Fields.Count}", new FieldSig(GetTypeSigOfValue(value)), FieldAttributes.Static | FieldAttributes.Public);
            field.DeclaringType = _holderTypeDef;
            return new ConstFieldInfo
            {
                field = field,
                value = value,
            };
        }

        private FieldDef AllocateAny(object value)
        {
            if (_done)
            {
                throw new Exception("can't Allocate after done");
            }
            if (!_allocatedFields.TryGetValue(value, out var field))
            {
                field = CreateConstFieldInfo(value);
                _allocatedFields.Add(value, field);
                _field2Fields.Add(field.field, field);
            }
            return field.field;
        }

        public FieldDef Allocate(int value)
        {
            return AllocateAny(value);
        }

        public FieldDef Allocate(long value)
        {
            return AllocateAny(value);
        }

        public FieldDef Allocate(float value)
        {
            return AllocateAny(value);
        }

        public FieldDef Allocate(double value)
        {
            return AllocateAny(value);
        }

        public FieldDef Allocate(string value)
        {
            return AllocateAny(value);
        }

        public FieldDef Allocate(byte[] value)
        {
            return AllocateAny(value);
        }


        private void CreateCCtorOfRvaTypeDef(TypeDef type)
        {
            ModuleDef mod = Module;
            var cctor = new MethodDefUser(".cctor",
                MethodSig.CreateStatic(mod.CorLibTypes.Void),
                MethodImplAttributes.IL | MethodImplAttributes.Managed,
                MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName | MethodAttributes.Private);
            cctor.DeclaringType = type;
            var body = new CilBody();
            cctor.Body = body;
            var ins = body.Instructions;


            DefaultMetadataImporter importer = this.GetDefaultModuleMetadataImporter();
            RvaDataAllocator rvaDataAllocator = GetEntity<RvaDataAllocator>();
            // TODO. obfuscate init codes
            foreach (var field in type.Fields)
            {
                ConstFieldInfo constInfo = _field2Fields[field];
                IRandom localRandom = _randomCreator(HashUtil.ComputePrimitiveOrStringOrBytesHashCode(constInfo.value));
                int ops = EncryptionUtil.GenerateEncryptionOpCodes(localRandom, _encryptor, 4);
                int salt = localRandom.NextInt();
                switch (constInfo.value)
                {
                    case int i:
                    {
                        int encryptedValue = _encryptor.Encrypt(i, ops, salt);
                        RvaData rvaData = rvaDataAllocator.Allocate(encryptedValue);
                        ins.Add(Instruction.Create(OpCodes.Ldsfld, rvaData.field));
                        ins.Add(Instruction.CreateLdcI4(rvaData.offset));
                        ins.Add(Instruction.CreateLdcI4(ops));
                        ins.Add(Instruction.CreateLdcI4(salt));
                        ins.Add(Instruction.Create(OpCodes.Call, importer.DecryptFromRvaInt));
                        break;
                    }
                    case long l:
                    {
                        long encryptedValue = _encryptor.Encrypt(l, ops, salt);
                        RvaData rvaData = rvaDataAllocator.Allocate(encryptedValue);
                        ins.Add(Instruction.Create(OpCodes.Ldsfld, rvaData.field));
                        ins.Add(Instruction.CreateLdcI4(rvaData.offset));
                        ins.Add(Instruction.CreateLdcI4(ops));
                        ins.Add(Instruction.CreateLdcI4(salt));
                        ins.Add(Instruction.Create(OpCodes.Call, importer.DecryptFromRvaLong));
                        break;
                    }
                    case float f:
                    {
                        float encryptedValue = _encryptor.Encrypt(f, ops, salt);
                        RvaData rvaData = rvaDataAllocator.Allocate(encryptedValue);
                        ins.Add(Instruction.Create(OpCodes.Ldsfld, rvaData.field));
                        ins.Add(Instruction.CreateLdcI4(rvaData.offset));
                        ins.Add(Instruction.CreateLdcI4(ops));
                        ins.Add(Instruction.CreateLdcI4(salt));
                        ins.Add(Instruction.Create(OpCodes.Call, importer.DecryptFromRvaFloat));
                        break;
                    }
                    case double d:
                    {
                        double encryptedValue = _encryptor.Encrypt(d, ops, salt);
                        RvaData rvaData = rvaDataAllocator.Allocate(encryptedValue);
                        ins.Add(Instruction.Create(OpCodes.Ldsfld, rvaData.field));
                        ins.Add(Instruction.CreateLdcI4(rvaData.offset));
                        ins.Add(Instruction.CreateLdcI4(ops));
                        ins.Add(Instruction.CreateLdcI4(salt));
                        ins.Add(Instruction.Create(OpCodes.Call, importer.DecryptFromRvaDouble));
                        break;
                    }
                    case string s:
                    {
                        byte[] encryptedValue = _encryptor.Encrypt(s, ops, salt);
                        RvaData rvaData = rvaDataAllocator.Allocate(encryptedValue);
                        ins.Add(Instruction.Create(OpCodes.Ldsfld, rvaData.field));
                        ins.Add(Instruction.CreateLdcI4(rvaData.offset));
                        Assert.AreEqual(encryptedValue.Length, rvaData.size);
                        ins.Add(Instruction.CreateLdcI4(encryptedValue.Length));
                        ins.Add(Instruction.CreateLdcI4(ops));
                        ins.Add(Instruction.CreateLdcI4(salt));
                        ins.Add(Instruction.Create(OpCodes.Call, importer.DecryptFromRvaString));
                        break;
                    }
                    case byte[] bs:
                    {
                        byte[] encryptedValue = _encryptor.Encrypt(bs, 0, bs.Length, ops, salt);
                        Assert.AreEqual(encryptedValue.Length, bs.Length);
                        RvaData rvaData = rvaDataAllocator.Allocate(encryptedValue);
                        ins.Add(Instruction.Create(OpCodes.Ldsfld, rvaData.field));
                        ins.Add(Instruction.CreateLdcI4(rvaData.offset));
                        ins.Add(Instruction.CreateLdcI4(bs.Length));
                        ins.Add(Instruction.CreateLdcI4(ops));
                        ins.Add(Instruction.CreateLdcI4(salt));
                        ins.Add(Instruction.Create(OpCodes.Call, importer.DecryptFromRvaBytes));
                        break;
                    }
                    default: throw new NotSupportedException($"Unsupported type: {constInfo.value.GetType()}");
                }
                ins.Add(Instruction.Create(OpCodes.Stsfld, field));
            }
            ins.Add(Instruction.Create(OpCodes.Ret));
        }

        public override void Done()
        {
            if (_done)
            {
                throw new Exception("Already done");
            }
            _done = true;
            foreach (var typeDef in _holderTypeDefs)
            {
                CreateCCtorOfRvaTypeDef(typeDef);
            }
        }
    }
}

```

`Editor/Data/ConstFieldAllocator.cs.meta`:

```meta
fileFormatVersion: 2
guid: e75f5cdfd47370d4ea6c4dee7e55a881
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Data/RvaDataAllocator.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Emit;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using UnityEngine.Assertions;

namespace Obfuz.Data
{
    public struct RvaData
    {
        public readonly FieldDef field;
        public readonly int offset;
        public readonly int size;

        public RvaData(FieldDef field, int offset, int size)
        {
            this.field = field;
            this.offset = offset;
            this.size = size;
        }
    }

    public class RvaDataAllocator : GroupByModuleEntityBase
    {
        const int maxRvaDataSize = 2 * 1024;

        // in HybridCLR version below 8.3.0, the max total static field size of a type is 16KB, so we limit the total size of RVA data to 16KB
        const int maxTotalRvaDataFieldSizeInHybridCLR = 16 * 1024;

        private IRandom _random;

        class RvaField
        {
            public FieldDef holderDataField;
            public FieldDef runtimeValueField;
            public int encryptionOps;
            public uint size;
            public List<byte> bytes;
            public int salt;

            public void FillPaddingToSize(int newSize)
            {
                for (int i = bytes.Count; i < newSize; i++)
                {
                    bytes.Add(0xAB);
                }
            }

            public void FillPaddingToEnd()
            {
                // fill with random value
                for (int i = bytes.Count; i < size; i++)
                {
                    bytes.Add(0xAB);
                }
            }
        }

        private class RvaTypeDefInfo
        {
            public readonly TypeDef typeDef;
            public readonly int index;
            public readonly List<RvaField> rvaFields = new List<RvaField>();

            public RvaTypeDefInfo(TypeDef typeDef, int index)
            {
                this.typeDef = typeDef;
                this.index = index;
            }
        }

        private RvaField _currentField;

        private RvaTypeDefInfo _currentRvaType;
        private readonly List<RvaTypeDefInfo> _rvaTypeDefs = new List<RvaTypeDefInfo>();

        private readonly Dictionary<int, TypeDef> _dataHolderTypeBySizes = new Dictionary<int, TypeDef>();
        private bool _done;

        public RvaDataAllocator()
        {
        }

        public override void Init()
        {
            _random = EncryptionScope.localRandomCreator(HashUtil.ComputeHash(Module.Name));
        }

        private (FieldDef, FieldDef) CreateDataHolderRvaField(TypeDef dataHolderType)
        {
            if (_currentRvaType == null || _currentRvaType.rvaFields.Count >= maxTotalRvaDataFieldSizeInHybridCLR / maxRvaDataSize - 1)
            {
                using (var scope = new DisableTypeDefFindCacheScope(Module))
                {
                    var rvaTypeDef = new TypeDefUser($"$Obfuz$RVA${_rvaTypeDefs.Count}", Module.CorLibTypes.Object.ToTypeDefOrRef());
                    Module.Types.Add(rvaTypeDef);
                    _currentRvaType = new RvaTypeDefInfo(rvaTypeDef, _rvaTypeDefs.Count);
                    _rvaTypeDefs.Add(_currentRvaType);
                }
            }

            var holderField = new FieldDefUser($"$RVA_Data{_currentRvaType.rvaFields.Count}", new FieldSig(dataHolderType.ToTypeSig()), FieldAttributes.InitOnly | FieldAttributes.Static | FieldAttributes.HasFieldRVA);
            holderField.DeclaringType = _currentRvaType.typeDef;

            var runtimeValueField = new FieldDefUser($"$RVA_Value{_currentRvaType.rvaFields.Count}", new FieldSig(new SZArraySig(Module.CorLibTypes.Byte)), FieldAttributes.Static | FieldAttributes.Public);
            runtimeValueField.DeclaringType = _currentRvaType.typeDef;
            return (holderField, runtimeValueField);
        }

        private TypeDef GetDataHolderType(int size)
        {
            size = (size + 15) & ~15; // align to 16 bytes
            if (_dataHolderTypeBySizes.TryGetValue(size, out var type))
                return type;

            using (var scope = new DisableTypeDefFindCacheScope(Module))
            {
                var dataHolderType = new TypeDefUser($"$ObfuzRVA$DataHolder{size}", Module.Import(typeof(ValueType)));
                dataHolderType.Attributes = TypeAttributes.Public | TypeAttributes.Sealed;
                dataHolderType.Layout = TypeAttributes.ExplicitLayout;
                dataHolderType.PackingSize = 1;
                dataHolderType.ClassSize = (uint)size;
                _dataHolderTypeBySizes.Add(size, dataHolderType);
                Module.Types.Add(dataHolderType);
                return dataHolderType;
            }
        }

        private static int AlignTo(int size, int alignment)
        {
            return (size + alignment - 1) & ~(alignment - 1);
        }

        private RvaField CreateRvaField(int size)
        {
            TypeDef dataHolderType = GetDataHolderType(size);
            var (holderDataField, runtimeValueField) = CreateDataHolderRvaField(dataHolderType);
            var newRvaField = new RvaField
            {
                holderDataField = holderDataField,
                runtimeValueField = runtimeValueField,
                size = dataHolderType.ClassSize,
                bytes = new List<byte>((int)dataHolderType.ClassSize),
                encryptionOps = _random.NextInt(),
                salt = _random.NextInt(),
            };
            _currentRvaType.rvaFields.Add(newRvaField);
            return newRvaField;
        }

        private RvaField GetRvaField(int preservedSize, int alignment)
        {
            if (_done)
            {
                throw new Exception("can't GetRvaField after done");
            }
            Assert.IsTrue(preservedSize % alignment == 0);
            // for big size, create a new field
            if (preservedSize >= maxRvaDataSize)
            {
                return CreateRvaField(preservedSize);
            }

            if (_currentField != null)
            {
                int offset = AlignTo(_currentField.bytes.Count, alignment);

                int expectedSize = offset + preservedSize;
                if (expectedSize <= _currentField.size)
                {
                    _currentField.FillPaddingToSize(offset);
                    return _currentField;
                }

                _currentField.FillPaddingToEnd();
            }
            _currentField = CreateRvaField(maxRvaDataSize);
            return _currentField;
        }

        public RvaData Allocate(int value)
        {
            RvaField field = GetRvaField(4, 4);
            int offset = field.bytes.Count;
            Assert.IsTrue(offset % 4 == 0);
            field.bytes.AddRange(BitConverter.GetBytes(value));
            return new RvaData(field.runtimeValueField, offset, 4);
        }

        public RvaData Allocate(long value)
        {
            RvaField field = GetRvaField(8, 8);
            int offset = field.bytes.Count;
            Assert.IsTrue(offset % 8 == 0);
            field.bytes.AddRange(BitConverter.GetBytes(value));
            return new RvaData(field.runtimeValueField, offset, 8);
        }

        public RvaData Allocate(float value)
        {
            RvaField field = GetRvaField(4, 4);
            int offset = field.bytes.Count;
            Assert.IsTrue(offset % 4 == 0);
            field.bytes.AddRange(BitConverter.GetBytes(value));
            return new RvaData(field.runtimeValueField, offset, 4);
        }

        public RvaData Allocate(double value)
        {
            RvaField field = GetRvaField(8, 8);
            int offset = field.bytes.Count;
            Assert.IsTrue(offset % 8 == 0);
            field.bytes.AddRange(BitConverter.GetBytes(value));
            return new RvaData(field.runtimeValueField, offset, 8);
        }

        public RvaData Allocate(string value)
        {
            byte[] bytes = Encoding.UTF8.GetBytes(value);
            return Allocate(bytes);
        }

        public RvaData Allocate(byte[] value)
        {
            RvaField field = GetRvaField(value.Length, 1);
            int offset = field.bytes.Count;
            field.bytes.AddRange(value);
            return new RvaData(field.runtimeValueField, offset, value.Length);
        }


        private void AddVerifyCodes(IList<Instruction> insts, DefaultMetadataImporter importer)
        {
            int verifyIntValue = 0x12345678;
            EncryptionScopeInfo encryptionScope = this.EncryptionScope;
            IRandom verifyRandom = encryptionScope.localRandomCreator(verifyIntValue);
            int verifyOps = EncryptionUtil.GenerateEncryptionOpCodes(verifyRandom, encryptionScope.encryptor, 4);
            int verifySalt = verifyRandom.NextInt();
            int encryptedVerifyIntValue = encryptionScope.encryptor.Encrypt(verifyIntValue, verifyOps, verifySalt);

            insts.Add(Instruction.Create(OpCodes.Ldc_I4, verifyIntValue));
            insts.Add(Instruction.CreateLdcI4(encryptedVerifyIntValue));
            insts.Add(Instruction.CreateLdcI4(verifyOps));
            insts.Add(Instruction.CreateLdcI4(verifySalt));
            insts.Add(Instruction.Create(OpCodes.Call, importer.DecryptInt));
            insts.Add(Instruction.Create(OpCodes.Call, importer.VerifySecretKey));

        }

        private void CreateCCtorOfRvaTypeDef()
        {
            foreach (RvaTypeDefInfo rvaTypeDef in _rvaTypeDefs)
            {
                ModuleDef mod = rvaTypeDef.typeDef.Module;
                var cctorMethod = new MethodDefUser(".cctor",
                    MethodSig.CreateStatic(Module.CorLibTypes.Void),
                    MethodImplAttributes.IL | MethodImplAttributes.Managed,
                    MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName | MethodAttributes.Private);
                cctorMethod.DeclaringType = rvaTypeDef.typeDef;
                //_rvaTypeDef.Methods.Add(cctor);
                var body = new CilBody();
                cctorMethod.Body = body;
                var ins = body.Instructions;

                DefaultMetadataImporter importer = this.GetDefaultModuleMetadataImporter();
                AddVerifyCodes(ins, importer);
                foreach (var field in rvaTypeDef.rvaFields)
                {
                    // ldc
                    // newarr
                    // dup
                    // stsfld
                    // ldtoken
                    // RuntimeHelpers.InitializeArray(array, fieldHandle);
                    ins.Add(Instruction.Create(OpCodes.Ldc_I4, (int)field.size));
                    ins.Add(Instruction.Create(OpCodes.Newarr, field.runtimeValueField.FieldType.Next.ToTypeDefOrRef()));
                    ins.Add(Instruction.Create(OpCodes.Dup));
                    ins.Add(Instruction.Create(OpCodes.Dup));
                    ins.Add(Instruction.Create(OpCodes.Stsfld, field.runtimeValueField));
                    ins.Add(Instruction.Create(OpCodes.Ldtoken, field.holderDataField));
                    ins.Add(Instruction.Create(OpCodes.Call, importer.InitializedArray));

                    // EncryptionService.DecryptBlock(array, field.encryptionOps, field.salt);
                    ins.Add(Instruction.CreateLdcI4(field.encryptionOps));
                    ins.Add(Instruction.Create(OpCodes.Ldc_I4, field.salt));
                    ins.Add(Instruction.Create(OpCodes.Call, importer.DecryptBlock));

                }
                ins.Add(Instruction.Create(OpCodes.Ret));
            }
        }

        private void SetFieldsRVA()
        {
            foreach (var field in _rvaTypeDefs.SelectMany(t => t.rvaFields))
            {
                Assert.IsTrue(field.bytes.Count <= field.size);
                if (field.bytes.Count < field.size)
                {
                    field.FillPaddingToEnd();
                }
                byte[] data = field.bytes.ToArray();
                EncryptionScope.encryptor.EncryptBlock(data, field.encryptionOps, field.salt);
                field.holderDataField.InitialValue = data;
            }
        }

        public override void Done()
        {
            if (_done)
            {
                throw new Exception("can't call Done twice");
            }
            _done = true;
            SetFieldsRVA();
            CreateCCtorOfRvaTypeDef();
        }
    }
}

```

`Editor/Data/RvaDataAllocator.cs.meta`:

```meta
fileFormatVersion: 2
guid: c00ca514f46605645bf40b0135e7e504
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Emit.meta`:

```meta
fileFormatVersion: 2
guid: a513a192808ba5f47b1ef8a3ecf02533
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Emit/BasicBlockCollection.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Obfuz.Emit
{
    public class BasicBlock
    {
        public readonly List<Instruction> instructions = new List<Instruction>();

        public readonly List<BasicBlock> inBlocks = new List<BasicBlock>();

        public readonly List<BasicBlock> outBlocks = new List<BasicBlock>();

        public bool inLoop;

        public void AddTargetBasicBlock(BasicBlock target)
        {
            if (!outBlocks.Contains(target))
            {
                outBlocks.Add(target);
            }
            if (!target.inBlocks.Contains(this))
            {
                target.inBlocks.Add(this);
            }
        }
    }

    public class BasicBlockCollection
    {
        private readonly MethodDef _method;

        private readonly List<BasicBlock> _blocks = new List<BasicBlock>();
        private readonly Dictionary<Instruction, BasicBlock> _inst2BlockMap = new Dictionary<Instruction, BasicBlock>();

        public IList<BasicBlock> Blocks => _blocks;

        public BasicBlockCollection(MethodDef method, bool computeInLoop)
        {
            _method = method;
            HashSet<Instruction> splitPoints = BuildSplitPoint(method);
            BuildBasicBlocks(method, splitPoints);
            BuildInOutGraph(method);
            if (computeInLoop)
            {
                ComputeBlocksInLoop();
            }
        }

        public void ComputeBlocksInLoop()
        {
            var loopBlocks = FindLoopBlocks(_blocks);
            foreach (var block in loopBlocks)
            {
                block.inLoop = true;
            }
        }

        public BasicBlock GetBasicBlockByInstruction(Instruction inst)
        {
            return _inst2BlockMap[inst];
        }

        private HashSet<Instruction> BuildSplitPoint(MethodDef method)
        {
            var insts = method.Body.Instructions;
            var splitPoints = new HashSet<Instruction>();
            foreach (ExceptionHandler eh in method.Body.ExceptionHandlers)
            {
                if (eh.TryStart != null)
                {
                    splitPoints.Add(eh.TryStart);
                }
                if (eh.TryEnd != null)
                {
                    splitPoints.Add(eh.TryEnd);
                }
                if (eh.HandlerStart != null)
                {
                    splitPoints.Add(eh.HandlerStart);
                }
                if (eh.HandlerEnd != null)
                {
                    splitPoints.Add(eh.HandlerEnd);
                }
                if (eh.FilterStart != null)
                {
                    splitPoints.Add(eh.FilterStart);
                }
            }

            for (int i = 0, n = insts.Count; i < n; i++)
            {
                Instruction curInst = insts[i];
                Instruction nextInst = i + 1 < n ? insts[i + 1] : null;
                switch (curInst.OpCode.FlowControl)
                {
                    case FlowControl.Branch:
                    {
                        if (nextInst != null)
                        {
                            splitPoints.Add(nextInst);
                        }
                        splitPoints.Add((Instruction)curInst.Operand);
                        break;
                    }
                    case FlowControl.Cond_Branch:
                    {
                        if (nextInst != null)
                        {
                            splitPoints.Add(nextInst);
                        }
                        if (curInst.Operand is Instruction targetInst)
                        {
                            splitPoints.Add(targetInst);
                        }
                        else if (curInst.Operand is Instruction[] targetInsts)
                        {
                            foreach (var target in targetInsts)
                            {
                                splitPoints.Add(target);
                            }
                        }
                        break;
                    }
                    case FlowControl.Return:
                    {
                        if (nextInst != null)
                        {
                            splitPoints.Add(nextInst);
                        }
                        break;
                    }
                    case FlowControl.Throw:
                    {
                        if (nextInst != null)
                        {
                            splitPoints.Add(nextInst);
                        }
                        break;
                    }
                }
            }
            return splitPoints;
        }


        private void BuildBasicBlocks(MethodDef method, HashSet<Instruction> splitPoints)
        {
            var insts = method.Body.Instructions;


            BasicBlock curBlock = new BasicBlock();
            foreach (Instruction inst in insts)
            {
                if (splitPoints.Contains(inst) && curBlock.instructions.Count > 0)
                {
                    _blocks.Add(curBlock);
                    curBlock = new BasicBlock();
                }
                curBlock.instructions.Add(inst);
                _inst2BlockMap.Add(inst, curBlock);
            }
            if (curBlock.instructions.Count > 0)
            {
                _blocks.Add(curBlock);
            }
        }

        private void BuildInOutGraph(MethodDef method)
        {
            var insts = method.Body.Instructions;
            for (int i = 0, n = _blocks.Count; i < n; i++)
            {
                BasicBlock curBlock = _blocks[i];
                BasicBlock nextBlock = i + 1 < n ? _blocks[i + 1] : null;
                Instruction lastInst = curBlock.instructions.Last();
                switch (lastInst.OpCode.FlowControl)
                {
                    case FlowControl.Branch:
                    {
                        Instruction targetInst = (Instruction)lastInst.Operand;
                        BasicBlock targetBlock = GetBasicBlockByInstruction(targetInst);
                        curBlock.AddTargetBasicBlock(targetBlock);
                        break;
                    }
                    case FlowControl.Cond_Branch:
                    {
                        if (lastInst.Operand is Instruction targetInst)
                        {
                            BasicBlock targetBlock = GetBasicBlockByInstruction(targetInst);
                            curBlock.AddTargetBasicBlock(targetBlock);
                        }
                        else if (lastInst.Operand is Instruction[] targetInsts)
                        {
                            foreach (var target in targetInsts)
                            {
                                BasicBlock targetBlock = GetBasicBlockByInstruction(target);
                                curBlock.AddTargetBasicBlock(targetBlock);
                            }
                        }
                        else
                        {
                            throw new Exception("Invalid operand type for conditional branch");
                        }
                        if (nextBlock != null)
                        {
                            curBlock.AddTargetBasicBlock(nextBlock);
                        }
                        break;
                    }
                    case FlowControl.Call:
                    case FlowControl.Next:
                    {
                        if (nextBlock != null)
                        {
                            curBlock.AddTargetBasicBlock(nextBlock);
                        }
                        break;
                    }
                    case FlowControl.Return:
                    case FlowControl.Throw:
                    {
                        break;
                    }
                    default: throw new NotSupportedException($"Unsupported flow control: {lastInst.OpCode.FlowControl} in method {method.FullName}");
                }
            }
        }

        private static HashSet<BasicBlock> FindLoopBlocks(List<BasicBlock> allBlocks)
        {
            // Tarjan算法找强连通分量
            var sccList = FindStronglyConnectedComponents(allBlocks);

            // 筛选有效循环
            var loopBlocks = new HashSet<BasicBlock>();
            foreach (var scc in sccList)
            {
                // 有效循环需满足以下条件之一：
                // 1. 分量包含多个块
                // 2. 单个块有自环（跳转自己）
                if (scc.Count > 1 ||
                    (scc.Count == 1 && scc[0].outBlocks.Contains(scc[0])))
                {
                    foreach (var block in scc)
                    {
                        loopBlocks.Add(block);
                    }
                }
            }
            return loopBlocks;
        }

        private static List<List<BasicBlock>> FindStronglyConnectedComponents(List<BasicBlock> allBlocks)
        {
            int index = 0;
            var stack = new Stack<BasicBlock>();
            var indexes = new Dictionary<BasicBlock, int>();
            var lowLinks = new Dictionary<BasicBlock, int>();
            var onStack = new HashSet<BasicBlock>();
            var sccList = new List<List<BasicBlock>>();

            foreach (var block in allBlocks.Where(b => !indexes.ContainsKey(b)))
            {
                StrongConnect(block);
            }

            return sccList;

            void StrongConnect(BasicBlock v)
            {
                indexes[v] = index;
                lowLinks[v] = index;
                index++;
                stack.Push(v);
                onStack.Add(v);

                foreach (var w in v.outBlocks)
                {
                    if (!indexes.ContainsKey(w))
                    {
                        StrongConnect(w);
                        lowLinks[v] = System.Math.Min(lowLinks[v], lowLinks[w]);
                    }
                    else if (onStack.Contains(w))
                    {
                        lowLinks[v] = System.Math.Min(lowLinks[v], indexes[w]);
                    }
                }

                if (lowLinks[v] == indexes[v])
                {
                    var scc = new List<BasicBlock>();
                    BasicBlock w;
                    do
                    {
                        w = stack.Pop();
                        onStack.Remove(w);
                        scc.Add(w);
                    } while (!w.Equals(v));
                    sccList.Add(scc);
                }
            }
        }
    }
}

```

`Editor/Emit/BasicBlockCollection.cs.meta`:

```meta
fileFormatVersion: 2
guid: 77c19c023bb7f77489998d994a3be1bd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Emit/DefaultMetadataImporter.cs`:

```cs
using dnlib.DotNet;
using System;
using System.Reflection;
using UnityEngine.Assertions;

namespace Obfuz.Emit
{
    public class EncryptionServiceMetadataImporter
    {
        private readonly ModuleDef _module;
        private readonly Type _encryptionServiceType;

        private IMethod _encryptBlock;
        private IMethod _decryptBlock;
        private IMethod _encryptInt;
        private IMethod _decryptInt;
        private IMethod _encryptLong;
        private IMethod _decryptLong;
        private IMethod _encryptFloat;
        private IMethod _decryptFloat;
        private IMethod _encryptDouble;
        private IMethod _decryptDouble;
        private IMethod _encryptString;
        private IMethod _decryptString;
        private IMethod _encryptBytes;
        private IMethod _decryptBytes;

        private IMethod _decryptFromRvaInt;
        private IMethod _decryptFromRvaLong;
        private IMethod _decryptFromRvaFloat;
        private IMethod _decryptFromRvaDouble;
        private IMethod _decryptFromRvaString;
        private IMethod _decryptFromRvaBytes;

        private IMethod _decryptInitializeArray;

        public IMethod EncryptBlock => _encryptBlock;
        public IMethod DecryptBlock => _decryptBlock;

        public IMethod EncryptInt => _encryptInt;
        public IMethod DecryptInt => _decryptInt;
        public IMethod EncryptLong => _encryptLong;
        public IMethod DecryptLong => _decryptLong;
        public IMethod EncryptFloat => _encryptFloat;
        public IMethod DecryptFloat => _decryptFloat;
        public IMethod EncryptDouble => _encryptDouble;
        public IMethod DecryptDouble => _decryptDouble;
        public IMethod EncryptString => _encryptString;
        public IMethod DecryptString => _decryptString;
        public IMethod EncryptBytes => _encryptBytes;
        public IMethod DecryptBytes => _decryptBytes;

        public IMethod DecryptFromRvaInt => _decryptFromRvaInt;
        public IMethod DecryptFromRvaLong => _decryptFromRvaLong;
        public IMethod DecryptFromRvaFloat => _decryptFromRvaFloat;
        public IMethod DecryptFromRvaDouble => _decryptFromRvaDouble;
        public IMethod DecryptFromRvaBytes => _decryptFromRvaBytes;
        public IMethod DecryptFromRvaString => _decryptFromRvaString;

        public IMethod DecryptInitializeArray => _decryptInitializeArray;

        public EncryptionServiceMetadataImporter(ModuleDef mod, Type encryptionServiceType)
        {
            _module = mod;
            _encryptionServiceType = encryptionServiceType;
            _encryptBlock = mod.Import(encryptionServiceType.GetMethod("EncryptBlock", new[] { typeof(byte[]), typeof(int), typeof(int) }));
            Assert.IsNotNull(_encryptBlock);
            _decryptBlock = mod.Import(encryptionServiceType.GetMethod("DecryptBlock", new[] { typeof(byte[]), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptBlock);
            _encryptInt = mod.Import(encryptionServiceType.GetMethod("Encrypt", new[] { typeof(int), typeof(int), typeof(int) }));
            Assert.IsNotNull(_encryptInt);
            _decryptInt = mod.Import(encryptionServiceType.GetMethod("Decrypt", new[] { typeof(int), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptInt);
            _encryptLong = mod.Import(encryptionServiceType.GetMethod("Encrypt", new[] { typeof(long), typeof(int), typeof(int) }));
            Assert.IsNotNull(_encryptLong);
            _decryptLong = mod.Import(encryptionServiceType.GetMethod("Decrypt", new[] { typeof(long), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptLong);
            _encryptFloat = mod.Import(encryptionServiceType.GetMethod("Encrypt", new[] { typeof(float), typeof(int), typeof(int) }));
            Assert.IsNotNull(_encryptFloat);
            _decryptFloat = mod.Import(encryptionServiceType.GetMethod("Decrypt", new[] { typeof(float), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptFloat);
            _encryptDouble = mod.Import(encryptionServiceType.GetMethod("Encrypt", new[] { typeof(double), typeof(int), typeof(int) }));
            Assert.IsNotNull(_encryptDouble);
            _decryptDouble = mod.Import(encryptionServiceType.GetMethod("Decrypt", new[] { typeof(double), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptDouble);
            _encryptString = mod.Import(encryptionServiceType.GetMethod("Encrypt", new[] { typeof(string), typeof(int), typeof(int) }));
            Assert.IsNotNull(_encryptString);
            _decryptString = mod.Import(encryptionServiceType.GetMethod("DecryptString", new[] { typeof(byte[]), typeof(int), typeof(int), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptString);
            _encryptBytes = mod.Import(encryptionServiceType.GetMethod("Encrypt", new[] { typeof(byte[]), typeof(int), typeof(int), typeof(int), typeof(int) }));
            Assert.IsNotNull(_encryptBytes);
            _decryptBytes = mod.Import(encryptionServiceType.GetMethod("Decrypt", new[] { typeof(byte[]), typeof(int), typeof(int), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptBytes);

            _decryptFromRvaInt = mod.Import(encryptionServiceType.GetMethod("DecryptFromRvaInt", new[] { typeof(byte[]), typeof(int), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptFromRvaInt);
            _decryptFromRvaLong = mod.Import(encryptionServiceType.GetMethod("DecryptFromRvaLong", new[] { typeof(byte[]), typeof(int), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptFromRvaLong);
            _decryptFromRvaFloat = mod.Import(encryptionServiceType.GetMethod("DecryptFromRvaFloat", new[] { typeof(byte[]), typeof(int), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptFromRvaFloat);
            _decryptFromRvaDouble = mod.Import(encryptionServiceType.GetMethod("DecryptFromRvaDouble", new[] { typeof(byte[]), typeof(int), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptFromRvaDouble);
            _decryptFromRvaBytes = mod.Import(encryptionServiceType.GetMethod("DecryptFromRvaBytes", new[] { typeof(byte[]), typeof(int), typeof(int), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptFromRvaBytes);
            _decryptFromRvaString = mod.Import(encryptionServiceType.GetMethod("DecryptFromRvaString", new[] { typeof(byte[]), typeof(int), typeof(int), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptFromRvaString);
            _decryptInitializeArray = mod.Import(encryptionServiceType.GetMethod("DecryptInitializeArray", new[] { typeof(System.Array), typeof(System.RuntimeFieldHandle), typeof(int), typeof(int), typeof(int) }));
            Assert.IsNotNull(_decryptInitializeArray);
        }
    }

    public class DefaultMetadataImporter : GroupByModuleEntityBase
    {
        private EncryptionServiceMetadataImporter _defaultEncryptionServiceMetadataImporter;


        private EncryptionServiceMetadataImporter _staticDefaultEncryptionServiceMetadataImporter;
        private EncryptionServiceMetadataImporter _dynamicDefaultEncryptionServiceMetadataImporter;

        public DefaultMetadataImporter()
        {
        }

        public override void Init()
        {
            ModuleDef mod = Module;

            var constUtilityType = typeof(ConstUtility);

            _castIntAsFloat = mod.Import(constUtilityType.GetMethod("CastIntAsFloat"));
            Assert.IsNotNull(_castIntAsFloat, "CastIntAsFloat not found");
            _castLongAsDouble = mod.Import(constUtilityType.GetMethod("CastLongAsDouble"));
            Assert.IsNotNull(_castLongAsDouble, "CastLongAsDouble not found");
            _castFloatAsInt = mod.Import(constUtilityType.GetMethod("CastFloatAsInt"));
            Assert.IsNotNull(_castFloatAsInt, "CastFloatAsInt not found");
            _castDoubleAsLong = mod.Import(constUtilityType.GetMethod("CastDoubleAsLong"));
            Assert.IsNotNull(_castDoubleAsLong, "CastDoubleAsLong not found");

            _initializeArray = mod.Import(typeof(System.Runtime.CompilerServices.RuntimeHelpers).GetMethod("InitializeArray", new[] { typeof(Array), typeof(RuntimeFieldHandle) }));
            Assert.IsNotNull(_initializeArray);
            _verifySecretKey = mod.Import(typeof(AssetUtility).GetMethod("VerifySecretKey", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_verifySecretKey, "VerifySecretKey not found");

            _obfuscationTypeMapperRegisterType = mod.Import(typeof(ObfuscationTypeMapper).GetMethod("RegisterType", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static, null, new[] { typeof(string) }, null));
            Assert.IsNotNull(_obfuscationTypeMapperRegisterType, "ObfuscationTypeMapper.RegisterType not found");

            var exprUtilityType = typeof(ExprUtility);
            _addInt = mod.Import(exprUtilityType.GetMethod("Add", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_addInt, "ExprUtility.Add(int, int) not found");
            _addLong = mod.Import(exprUtilityType.GetMethod("Add", new[] { typeof(long), typeof(long) }));
            Assert.IsNotNull(_addLong, "ExprUtility.Add(long, long) not found");
            _addFloat = mod.Import(exprUtilityType.GetMethod("Add", new[] { typeof(float), typeof(float) }));
            Assert.IsNotNull(_addFloat, "ExprUtility.Add(float, float) not found");
            _addDouble = mod.Import(exprUtilityType.GetMethod("Add", new[] { typeof(double), typeof(double) }));
            Assert.IsNotNull(_addDouble, "ExprUtility.Add(double, double) not found");
            _addIntPtr = mod.Import(exprUtilityType.GetMethod("Add", new[] { typeof(IntPtr), typeof(IntPtr) }));
            Assert.IsNotNull(_addIntPtr, "ExprUtility.Add(IntPtr, IntPtr) not found");
            _addIntPtrInt = mod.Import(exprUtilityType.GetMethod("Add", new[] { typeof(IntPtr), typeof(int) }));
            Assert.IsNotNull(_addIntPtrInt, "ExprUtility.Add(IntPtr, int) not found");

            _subtractInt = mod.Import(exprUtilityType.GetMethod("Subtract", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_subtractInt, "ExprUtility.Subtract(int, int) not found");
            _subtractLong = mod.Import(exprUtilityType.GetMethod("Subtract", new[] { typeof(long), typeof(long) }));
            Assert.IsNotNull(_subtractLong, "ExprUtility.Subtract(long, long) not found");
            _subtractFloat = mod.Import(exprUtilityType.GetMethod("Subtract", new[] { typeof(float), typeof(float) }));
            Assert.IsNotNull(_subtractFloat, "ExprUtility.Subtract(float, float) not found");
            _subtractDouble = mod.Import(exprUtilityType.GetMethod("Subtract", new[] { typeof(double), typeof(double) }));
            Assert.IsNotNull(_subtractDouble, "ExprUtility.Subtract(double, double) not found");
            _subtractIntPtr = mod.Import(exprUtilityType.GetMethod("Subtract", new[] { typeof(IntPtr), typeof(IntPtr) }));
            Assert.IsNotNull(_subtractIntPtr, "ExprUtility.Subtract(IntPtr, IntPtr) not found");
            _subtractIntPtrInt = mod.Import(exprUtilityType.GetMethod("Subtract", new[] { typeof(IntPtr), typeof(int) }));
            Assert.IsNotNull(_subtractIntPtrInt, "ExprUtility.Subtract(IntPtr, int) not found");

            _multiplyInt = mod.Import(exprUtilityType.GetMethod("Multiply", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_multiplyInt, "ExprUtility.Multiply(int, int) not found");
            _multiplyLong = mod.Import(exprUtilityType.GetMethod("Multiply", new[] { typeof(long), typeof(long) }));
            Assert.IsNotNull(_multiplyLong, "ExprUtility.Multiply(long, long) not found");
            _multiplyFloat = mod.Import(exprUtilityType.GetMethod("Multiply", new[] { typeof(float), typeof(float) }));
            Assert.IsNotNull(_multiplyFloat, "ExprUtility.Multiply(float, float) not found");
            _multiplyDouble = mod.Import(exprUtilityType.GetMethod("Multiply", new[] { typeof(double), typeof(double) }));
            Assert.IsNotNull(_multiplyDouble, "ExprUtility.Multiply(double, double) not found");
            _multiplyIntPtr = mod.Import(exprUtilityType.GetMethod("Multiply", new[] { typeof(IntPtr), typeof(IntPtr) }));
            Assert.IsNotNull(_multiplyIntPtr, "ExprUtility.Multiply(IntPtr, IntPtr) not found");
            _multiplyIntPtrInt = mod.Import(exprUtilityType.GetMethod("Multiply", new[] { typeof(IntPtr), typeof(int) }));
            Assert.IsNotNull(_multiplyIntPtrInt, "ExprUtility.Multiply(IntPtr, int) not found");

            _divideInt = mod.Import(exprUtilityType.GetMethod("Divide", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_divideInt, "ExprUtility.Divide(int, int) not found");
            _divideLong = mod.Import(exprUtilityType.GetMethod("Divide", new[] { typeof(long), typeof(long) }));
            Assert.IsNotNull(_divideLong);
            _divideFloat = mod.Import(exprUtilityType.GetMethod("Divide", new[] { typeof(float), typeof(float) }));
            Assert.IsNotNull(_divideFloat, "ExprUtility.Divide(float, float) not found");
            _divideDouble = mod.Import(exprUtilityType.GetMethod("Divide", new[] { typeof(double), typeof(double) }));
            Assert.IsNotNull(_divideDouble, "ExprUtility.Divide(double, double) not found");
            _divideUnInt = mod.Import(exprUtilityType.GetMethod("DivideUn", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_divideUnInt, "ExprUtility.DivideUn(int, int) not found");
            _divideUnLong = mod.Import(exprUtilityType.GetMethod("DivideUn", new[] { typeof(long), typeof(long) }));
            Assert.IsNotNull(_divideUnLong, "ExprUtility.DivideUn(long, long) not found");
            _remInt = mod.Import(exprUtilityType.GetMethod("Rem", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_remInt, "ExprUtility.Rem(int, int) not found");
            _remLong = mod.Import(exprUtilityType.GetMethod("Rem", new[] { typeof(long), typeof(long) }));
            Assert.IsNotNull(_remLong, "ExprUtility.Rem(long, long) not found");
            _remFloat = mod.Import(exprUtilityType.GetMethod("Rem", new[] { typeof(float), typeof(float) }));
            Assert.IsNotNull(_remFloat, "ExprUtility.Rem(float, float) not found");
            _remDouble = mod.Import(exprUtilityType.GetMethod("Rem", new[] { typeof(double), typeof(double) }));
            Assert.IsNotNull(_remDouble, "ExprUtility.Rem(double, double) not found");
            _remUnInt = mod.Import(exprUtilityType.GetMethod("RemUn", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_remUnInt, "ExprUtility.RemUn(int, int) not found");
            _remUnLong = mod.Import(exprUtilityType.GetMethod("RemUn", new[] { typeof(long), typeof(long) }));
            Assert.IsNotNull(_remUnLong, "ExprUtility.RemUn(long, long) not found");
            _negInt = mod.Import(exprUtilityType.GetMethod("Negate", new[] { typeof(int) }));
            Assert.IsNotNull(_negInt, "ExprUtility.Negate(int) not found");
            _negLong = mod.Import(exprUtilityType.GetMethod("Negate", new[] { typeof(long) }));
            Assert.IsNotNull(_negLong, "ExprUtility.Negate(long) not found");
            _negFloat = mod.Import(exprUtilityType.GetMethod("Negate", new[] { typeof(float) }));
            Assert.IsNotNull(_negFloat, "ExprUtility.Negate(float) not found");
            _negDouble = mod.Import(exprUtilityType.GetMethod("Negate", new[] { typeof(double) }));
            Assert.IsNotNull(_negDouble, "ExprUtility.Negate(double) not found");

            _andInt = mod.Import(exprUtilityType.GetMethod("And", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_andInt, "ExprUtility.And(int, int) not found");
            _andLong = mod.Import(exprUtilityType.GetMethod("And", new[] { typeof(long), typeof(long) }));
            Assert.IsNotNull(_andLong, "ExprUtility.And(long, long) not found");
            _orInt = mod.Import(exprUtilityType.GetMethod("Or", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_orInt, "ExprUtility.Or(int, int) not found");
            _orLong = mod.Import(exprUtilityType.GetMethod("Or", new[] { typeof(long), typeof(long) }));
            Assert.IsNotNull(_orLong, "ExprUtility.Or(long, long) not found");
            _xorInt = mod.Import(exprUtilityType.GetMethod("Xor", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_xorInt, "ExprUtility.Xor(int, int) not found");
            _xorLong = mod.Import(exprUtilityType.GetMethod("Xor", new[] { typeof(long), typeof(long) }));
            Assert.IsNotNull(_xorLong, "ExprUtility.Xor(long, long) not found");
            _notInt = mod.Import(exprUtilityType.GetMethod("Not", new[] { typeof(int) }));
            Assert.IsNotNull(_notInt, "ExprUtility.Not(int) not found");
            _notLong = mod.Import(exprUtilityType.GetMethod("Not", new[] { typeof(long) }));
            Assert.IsNotNull(_notLong, "ExprUtility.Not(long) not found");

            _shlInt = mod.Import(exprUtilityType.GetMethod("ShiftLeft", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_shlInt, "ExprUtility.ShiftLeft(int, int) not found");
            _shlLong = mod.Import(exprUtilityType.GetMethod("ShiftLeft", new[] { typeof(long), typeof(int) }));
            Assert.IsNotNull(_shlLong, "ExprUtility.ShiftLeft(long, int) not found");
            _shrInt = mod.Import(exprUtilityType.GetMethod("ShiftRight", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_shrInt, "ExprUtility.ShiftRight(int, int) not found");
            _shrLong = mod.Import(exprUtilityType.GetMethod("ShiftRight", new[] { typeof(long), typeof(int) }));
            Assert.IsNotNull(_shrLong, "ExprUtility.ShiftRight(long, int) not found");
            _shrUnInt = mod.Import(exprUtilityType.GetMethod("ShiftRightUn", new[] { typeof(int), typeof(int) }));
            Assert.IsNotNull(_shrUnInt, "ExprUtility.ShiftRightUn(int, int) not found");
            _shrUnLong = mod.Import(exprUtilityType.GetMethod("ShiftRightUn", new[] { typeof(long), typeof(int) }));
            Assert.IsNotNull(_shrUnLong, "ExprUtility.ShiftRightUn(long, int) not found");


            _staticDefaultEncryptionServiceMetadataImporter = new EncryptionServiceMetadataImporter(mod, typeof(EncryptionService<DefaultStaticEncryptionScope>));
            _dynamicDefaultEncryptionServiceMetadataImporter = new EncryptionServiceMetadataImporter(mod, typeof(EncryptionService<DefaultDynamicEncryptionScope>));
            if (EncryptionScopeProvider.IsDynamicSecretAssembly(mod))
            {
                _defaultEncryptionServiceMetadataImporter = _dynamicDefaultEncryptionServiceMetadataImporter;
            }
            else
            {
                _defaultEncryptionServiceMetadataImporter = _staticDefaultEncryptionServiceMetadataImporter;
            }
        }

        public override void Done()
        {

        }

        public EncryptionServiceMetadataImporter GetEncryptionServiceMetadataImporterOfModule(ModuleDef mod)
        {
            return EncryptionScopeProvider.IsDynamicSecretAssembly(mod) ? _dynamicDefaultEncryptionServiceMetadataImporter : _staticDefaultEncryptionServiceMetadataImporter;
        }

        private ModuleDef _module;
        private IMethod _castIntAsFloat;
        private IMethod _castLongAsDouble;
        private IMethod _castFloatAsInt;
        private IMethod _castDoubleAsLong;
        private IMethod _initializeArray;
        private IMethod _verifySecretKey;

        private IMethod _obfuscationTypeMapperRegisterType;

        private IMethod _addInt;
        private IMethod _addLong;
        private IMethod _addFloat;
        private IMethod _addDouble;
        private IMethod _addIntPtr;
        private IMethod _addIntPtrInt;
        private IMethod _subtractInt;
        private IMethod _subtractLong;
        private IMethod _subtractFloat;
        private IMethod _subtractDouble;
        private IMethod _subtractIntPtr;
        private IMethod _subtractIntPtrInt;
        private IMethod _multiplyInt;
        private IMethod _multiplyLong;
        private IMethod _multiplyFloat;
        private IMethod _multiplyDouble;
        private IMethod _multiplyIntPtr;
        private IMethod _multiplyIntPtrInt;
        private IMethod _divideInt;
        private IMethod _divideLong;
        private IMethod _divideFloat;
        private IMethod _divideDouble;
        private IMethod _divideUnInt;
        private IMethod _divideUnLong;
        private IMethod _remInt;
        private IMethod _remLong;
        private IMethod _remFloat;
        private IMethod _remDouble;
        private IMethod _remUnInt;
        private IMethod _remUnLong;
        private IMethod _negInt;
        private IMethod _negLong;
        private IMethod _negFloat;
        private IMethod _negDouble;

        private IMethod _andInt;
        private IMethod _andLong;
        private IMethod _orInt;
        private IMethod _orLong;
        private IMethod _xorInt;
        private IMethod _xorLong;
        private IMethod _notInt;
        private IMethod _notLong;

        private IMethod _shlInt;
        private IMethod _shlLong;
        private IMethod _shrInt;
        private IMethod _shrLong;
        private IMethod _shrUnInt;
        private IMethod _shrUnLong;

        public IMethod CastIntAsFloat => _castIntAsFloat;
        public IMethod CastLongAsDouble => _castLongAsDouble;
        public IMethod CastFloatAsInt => _castFloatAsInt;
        public IMethod CastDoubleAsLong => _castDoubleAsLong;

        public IMethod InitializedArray => _initializeArray;

        public IMethod VerifySecretKey => _verifySecretKey;

        public IMethod ObfuscationTypeMapperRegisterType => _obfuscationTypeMapperRegisterType;

        public IMethod EncryptBlock => _defaultEncryptionServiceMetadataImporter.EncryptBlock;
        public IMethod DecryptBlock => _defaultEncryptionServiceMetadataImporter.DecryptBlock;

        public IMethod EncryptInt => _defaultEncryptionServiceMetadataImporter.EncryptInt;
        public IMethod DecryptInt => _defaultEncryptionServiceMetadataImporter.DecryptInt;
        public IMethod EncryptLong => _defaultEncryptionServiceMetadataImporter.EncryptLong;
        public IMethod DecryptLong => _defaultEncryptionServiceMetadataImporter.DecryptLong;
        public IMethod EncryptFloat => _defaultEncryptionServiceMetadataImporter.EncryptFloat;
        public IMethod DecryptFloat => _defaultEncryptionServiceMetadataImporter.DecryptFloat;
        public IMethod EncryptDouble => _defaultEncryptionServiceMetadataImporter.EncryptDouble;
        public IMethod DecryptDouble => _defaultEncryptionServiceMetadataImporter.DecryptDouble;
        public IMethod EncryptString => _defaultEncryptionServiceMetadataImporter.EncryptString;
        public IMethod DecryptString => _defaultEncryptionServiceMetadataImporter.DecryptString;
        public IMethod EncryptBytes => _defaultEncryptionServiceMetadataImporter.EncryptBytes;
        public IMethod DecryptBytes => _defaultEncryptionServiceMetadataImporter.DecryptBytes;

        public IMethod DecryptFromRvaInt => _defaultEncryptionServiceMetadataImporter.DecryptFromRvaInt;
        public IMethod DecryptFromRvaLong => _defaultEncryptionServiceMetadataImporter.DecryptFromRvaLong;
        public IMethod DecryptFromRvaFloat => _defaultEncryptionServiceMetadataImporter.DecryptFromRvaFloat;
        public IMethod DecryptFromRvaDouble => _defaultEncryptionServiceMetadataImporter.DecryptFromRvaDouble;
        public IMethod DecryptFromRvaBytes => _defaultEncryptionServiceMetadataImporter.DecryptFromRvaBytes;
        public IMethod DecryptFromRvaString => _defaultEncryptionServiceMetadataImporter.DecryptFromRvaString;

        public IMethod DecryptInitializeArray => _defaultEncryptionServiceMetadataImporter.DecryptInitializeArray;

        public IMethod AddInt => _addInt;
        public IMethod AddLong => _addLong;
        public IMethod AddFloat => _addFloat;
        public IMethod AddDouble => _addDouble;
        public IMethod AddIntPtr => _addIntPtr;
        public IMethod AddIntPtrInt => _addIntPtrInt;
        public IMethod SubtractInt => _subtractInt;
        public IMethod SubtractLong => _subtractLong;
        public IMethod SubtractFloat => _subtractFloat;
        public IMethod SubtractDouble => _subtractDouble;
        public IMethod SubtractIntPtr => _subtractIntPtr;
        public IMethod SubtractIntPtrInt => _subtractIntPtrInt;

        public IMethod MultiplyInt => _multiplyInt;
        public IMethod MultiplyLong => _multiplyLong;
        public IMethod MultiplyFloat => _multiplyFloat;
        public IMethod MultiplyDouble => _multiplyDouble;
        public IMethod MultiplyIntPtr => _multiplyIntPtr;
        public IMethod MultiplyIntPtrInt => _multiplyIntPtrInt;

        public IMethod DivideInt => _divideInt;
        public IMethod DivideLong => _divideLong;
        public IMethod DivideFloat => _divideFloat;
        public IMethod DivideDouble => _divideDouble;
        public IMethod DivideUnInt => _divideUnInt;
        public IMethod DivideUnLong => _divideUnLong;
        public IMethod RemInt => _remInt;
        public IMethod RemLong => _remLong;
        public IMethod RemFloat => _remFloat;
        public IMethod RemDouble => _remDouble;
        public IMethod RemUnInt => _remUnInt;
        public IMethod RemUnLong => _remUnLong;
        public IMethod NegInt => _negInt;
        public IMethod NegLong => _negLong;
        public IMethod NegFloat => _negFloat;
        public IMethod NegDouble => _negDouble;
        public IMethod AndInt => _andInt;
        public IMethod AndLong => _andLong;
        public IMethod OrInt => _orInt;
        public IMethod OrLong => _orLong;
        public IMethod XorInt => _xorInt;
        public IMethod XorLong => _xorLong;
        public IMethod NotInt => _notInt;
        public IMethod NotLong => _notLong;
        public IMethod ShlInt => _shlInt;
        public IMethod ShlLong => _shlLong;
        public IMethod ShrInt => _shrInt;
        public IMethod ShrLong => _shrLong;
        public IMethod ShrUnInt => _shrUnInt;
        public IMethod ShrUnLong => _shrUnLong;


    }
}

```

`Editor/Emit/DefaultMetadataImporter.cs.meta`:

```meta
fileFormatVersion: 2
guid: 76438ce96146edd469872feada7857ba
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Emit/EntityExtensions.cs`:

```cs
namespace Obfuz.Emit
{
    public static class EntityExtensions
    {
        public static T GetEntity<T>(this IGroupByModuleEntity entity) where T : IGroupByModuleEntity, new()
        {
            return entity.Manager.GetEntity<T>(entity.Module);
        }

        public static DefaultMetadataImporter GetDefaultModuleMetadataImporter(this IGroupByModuleEntity entity)
        {
            return entity.GetEntity<DefaultMetadataImporter>();
        }
    }
}

```

`Editor/Emit/EntityExtensions.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6e9557733f180764692756653eb60f88
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Emit/EvalStackCalculator.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using UnityEngine.Assertions;

namespace Obfuz.Emit
{
    enum EvalDataType
    {
        None,
        Int32,
        Int64,
        Float,
        Double,
        I,
        Ref,
        ValueType,
        Token,
        Unknown,
    }

    struct EvalDataTypeWithSig
    {
        public readonly EvalDataType type;
        public readonly TypeSig typeSig;
        public EvalDataTypeWithSig(EvalDataType type, TypeSig typeSig)
        {
            this.type = type;
            this.typeSig = typeSig;
        }
        public override string ToString()
        {
            return $"{type} ({typeSig})";
        }
    }

    class InstructionParameterInfo
    {
        public readonly EvalDataType op1;
        public readonly EvalDataType op2;
        public readonly EvalDataType retType;
        public InstructionParameterInfo(EvalDataType op1, EvalDataType op2, EvalDataType retType)
        {
            this.op1 = op1;
            this.op2 = op2;
            this.retType = retType;
        }
    }


    class EvalStackState
    {
        public bool visited;

        public readonly List<EvalDataTypeWithSig> inputStackDatas = new List<EvalDataTypeWithSig>();
        public readonly List<EvalDataTypeWithSig> runStackDatas = new List<EvalDataTypeWithSig>();
    }

    class EvalStackCalculator
    {
        private readonly MethodDef _method;
        private readonly BasicBlockCollection _basicBlocks;
        private readonly Dictionary<Instruction, InstructionParameterInfo> _instructionParameterInfos = new Dictionary<Instruction, InstructionParameterInfo>();
        private readonly Dictionary<Instruction, EvalDataType> _evalStackTopDataTypeAfterInstructions = new Dictionary<Instruction, EvalDataType>();
        private readonly Dictionary<BasicBlock, EvalStackState> _blockEvalStackStates;

        public EvalStackCalculator(MethodDef method)
        {
            _method = method;
            _basicBlocks = new BasicBlockCollection(method, false);
            _blockEvalStackStates = _basicBlocks.Blocks.ToDictionary(b => b, b => new EvalStackState());

            SimulateRunAllBlocks();
        }

        public BasicBlockCollection BasicBlockCollection => _basicBlocks;

        public bool TryGetParameterInfo(Instruction inst, out InstructionParameterInfo info)
        {
            return _instructionParameterInfos.TryGetValue(inst, out info);
        }

        public bool TryGetPushResult(Instruction inst, out EvalDataType result)
        {
            return _evalStackTopDataTypeAfterInstructions.TryGetValue(inst, out result);
        }

        public EvalStackState GetEvalStackState(BasicBlock basicBlock)
        {
            return _blockEvalStackStates[basicBlock];
        }

        private void PushStack(List<EvalDataTypeWithSig> datas, TypeSig type)
        {
            type = type.RemovePinnedAndModifiers();
            switch (type.ElementType)
            {
                case ElementType.Void: break;
                case ElementType.Boolean:
                case ElementType.Char:
                case ElementType.I1:
                case ElementType.U1:
                case ElementType.I2:
                case ElementType.U2:
                case ElementType.I4:
                case ElementType.U4:
                datas.Add(new EvalDataTypeWithSig(EvalDataType.Int32, null));
                break;
                case ElementType.I8:
                case ElementType.U8:
                datas.Add(new EvalDataTypeWithSig(EvalDataType.Int64, null));
                break;
                case ElementType.R4:
                datas.Add(new EvalDataTypeWithSig(EvalDataType.Float, null));
                break;
                case ElementType.R8:
                datas.Add(new EvalDataTypeWithSig(EvalDataType.Double, null));
                break;
                case ElementType.I:
                case ElementType.U:
                case ElementType.Ptr:
                case ElementType.FnPtr:
                case ElementType.ByRef:
                datas.Add(new EvalDataTypeWithSig(EvalDataType.I, null));
                break;
                case ElementType.String:
                case ElementType.Class:
                case ElementType.Array:
                case ElementType.SZArray:
                case ElementType.Object:
                datas.Add(new EvalDataTypeWithSig(EvalDataType.Ref, type));
                break;
                case ElementType.ValueType:
                {
                    TypeDef typeDef = type.ToTypeDefOrRef().ResolveTypeDefThrow();
                    if (typeDef.IsEnum)
                    {
                        PushStack(datas, typeDef.GetEnumUnderlyingType());
                    }
                    else
                    {
                        PushStack(datas, new EvalDataTypeWithSig(EvalDataType.ValueType, type));
                    }
                    break;
                }
                case ElementType.GenericInst:
                {
                    GenericInstSig genericInstSig = (GenericInstSig)type;
                    TypeDef typeDef = genericInstSig.GenericType.ToTypeDefOrRef().ResolveTypeDefThrow();
                    if (!typeDef.IsValueType)
                    {
                        PushStack(datas, new EvalDataTypeWithSig(EvalDataType.Ref, type));
                    }
                    else if (typeDef.IsEnum)
                    {
                        PushStack(datas, typeDef.GetEnumUnderlyingType());
                    }
                    else
                    {
                        PushStack(datas, new EvalDataTypeWithSig(EvalDataType.ValueType, type));
                    }
                    break;
                }
                case ElementType.TypedByRef:
                {
                    // TypedByRef is a special type used in dynamic method invocation and reflection.
                    // It is treated as a reference type in the evaluation stack.
                    PushStack(datas, new EvalDataTypeWithSig(EvalDataType.ValueType, type));
                    break;
                }
                case ElementType.Var:
                case ElementType.MVar:
                PushStack(datas, new EvalDataTypeWithSig(EvalDataType.ValueType, type));
                break;
                case ElementType.ValueArray:
                case ElementType.R:
                case ElementType.CModOpt:
                case ElementType.CModReqd:
                case ElementType.Internal:
                case ElementType.Module:
                case ElementType.Sentinel:
                PushStack(datas, EvalDataType.Unknown);
                break;

                default: throw new Exception($"Unsupported type: {type} in method: {_method.FullName}.");
            }
        }

        private void PushStack(List<EvalDataTypeWithSig> datas, ITypeDefOrRef type)
        {
            PushStack(datas, type.ToTypeSig());
        }

        private void PushStack(List<EvalDataTypeWithSig> datas, EvalDataType type)
        {
            Assert.IsTrue(type != EvalDataType.ValueType, "Cannot push EvalDataType.Value without type sig onto the stack.");
            datas.Add(new EvalDataTypeWithSig(type, null));
        }

        private void PushStack(List<EvalDataTypeWithSig> datas, EvalDataTypeWithSig type)
        {
            datas.Add(type);
        }

        private void PushStackObject(List<EvalDataTypeWithSig> datas)
        {
            datas.Add(new EvalDataTypeWithSig(EvalDataType.Ref, _method.Module.CorLibTypes.Object));
        }

        private EvalDataType CalcBasicBinOpRetType(EvalDataType op1, EvalDataType op2)
        {
            switch (op1)
            {
                case EvalDataType.Int32:
                {
                    switch (op2)
                    {
                        case EvalDataType.Int32: return EvalDataType.Int32;
                        case EvalDataType.Int64: return EvalDataType.Int64;
                        case EvalDataType.I: return EvalDataType.I;
                        default: throw new Exception($"Unsupported operand type: {op2} for {op1} in binary operation.");
                    }
                }
                case EvalDataType.Int64:
                {
                    switch (op2)
                    {
                        case EvalDataType.Int32: return EvalDataType.Int64;
                        case EvalDataType.Int64:
                        case EvalDataType.I:
                        return EvalDataType.Int64;
                        default: throw new Exception($"Unsupported operand type: {op2} for {op1} in binary operation.");
                    }
                }
                case EvalDataType.I:
                {
                    switch (op2)
                    {
                        case EvalDataType.Int32: return EvalDataType.I;
                        case EvalDataType.Int64: return EvalDataType.Int64;
                        case EvalDataType.I: return EvalDataType.I;
                        default: throw new Exception($"Unsupported operand type: {op2} for {op1} in binary operation.");
                    }
                }
                case EvalDataType.Float:
                {
                    switch (op2)
                    {
                        case EvalDataType.Float: return EvalDataType.Float;
                        case EvalDataType.Double: return EvalDataType.Double;
                        default: throw new Exception($"Unsupported operand type: {op2} for {op1} in binary operation.");
                    }
                }
                case EvalDataType.Double:
                {
                    switch (op2)
                    {
                        case EvalDataType.Float:
                        case EvalDataType.Double: return EvalDataType.Double;
                        default: throw new Exception($"Unsupported operand type: {op2} for {op1} in binary operation.");
                    }
                }
                default: throw new Exception($"Unsupported operand type: {op1} in binary operation.");
            }
        }

        private void SimulateRunAllBlocks()
        {
            bool methodHasReturnValue = !MetaUtil.IsVoidType(_method.ReturnType);

            CilBody body = _method.Body;
            if (body.HasExceptionHandlers)
            {
                foreach (ExceptionHandler handler in body.ExceptionHandlers)
                {
                    if (handler.IsFilter)
                    {
                        BasicBlock bb = _basicBlocks.GetBasicBlockByInstruction(handler.FilterStart);
                        var inputStackDatas = _blockEvalStackStates[bb].inputStackDatas;
                        if (inputStackDatas.Count == 0)
                        {
                            inputStackDatas.Add(new EvalDataTypeWithSig(EvalDataType.Ref, handler.CatchType.ToTypeSig()));
                        }
                    }
                    if (handler.IsCatch || handler.IsFilter)
                    {
                        BasicBlock bb = _basicBlocks.GetBasicBlockByInstruction(handler.HandlerStart);
                        var inputStackDatas = _blockEvalStackStates[bb].inputStackDatas;
                        if (inputStackDatas.Count == 0)
                        {
                            inputStackDatas.Add(new EvalDataTypeWithSig(EvalDataType.Ref, handler.CatchType.ToTypeSig()));
                        }
                    }
                }
            }

            var newPushedDatas = new List<EvalDataTypeWithSig>();
            IList<TypeSig> methodTypeGenericArgument = _method.DeclaringType.GenericParameters.Count > 0
                ? (IList<TypeSig>)_method.DeclaringType.GenericParameters.Select(p => (TypeSig)new GenericVar(p.Number)).ToList()
                : null;
            IList<TypeSig> methodMethodGenericArgument = _method.GenericParameters.Count > 0
                ? (IList<TypeSig>)_method.GenericParameters.Select(p => (TypeSig)new GenericMVar(p.Number)).ToList()
                : null;
            var gac = new GenericArgumentContext(methodTypeGenericArgument, methodMethodGenericArgument);
            var corLibTypes = _method.Module.CorLibTypes;

            var blockWalkStack = new Stack<BasicBlock>(_basicBlocks.Blocks.Reverse());
            while (blockWalkStack.Count > 0)
            {
                BasicBlock block = blockWalkStack.Pop();
                EvalStackState state = _blockEvalStackStates[block];
                if (state.visited)
                    continue;
                state.visited = true;
                state.runStackDatas.AddRange(state.inputStackDatas);
                List<EvalDataTypeWithSig> stackDatas = state.runStackDatas;
                foreach (var inst in block.instructions)
                {
                    int stackSize = stackDatas.Count;
                    newPushedDatas.Clear();
                    switch (inst.OpCode.Code)
                    {
                        case Code.Nop: break;
                        case Code.Break: break;
                        case Code.Ldarg_0:
                        case Code.Ldarg_1:
                        case Code.Ldarg_2:
                        case Code.Ldarg_3:
                        case Code.Ldarg:
                        case Code.Ldarg_S:
                        {
                            PushStack(newPushedDatas, inst.GetParameter(_method.Parameters).Type);
                            break;
                        }
                        case Code.Ldarga:
                        case Code.Ldarga_S:
                        {
                            PushStack(newPushedDatas, EvalDataType.I);
                            break;
                        }
                        case Code.Ldloc_0:
                        case Code.Ldloc_1:
                        case Code.Ldloc_2:
                        case Code.Ldloc_3:
                        case Code.Ldloc:
                        case Code.Ldloc_S:
                        {
                            PushStack(newPushedDatas, inst.GetLocal(body.Variables).Type);
                            break;
                        }
                        case Code.Ldloca:
                        case Code.Ldloca_S:
                        {
                            PushStack(newPushedDatas, EvalDataType.I);
                            break;
                        }
                        case Code.Stloc_0:
                        case Code.Stloc_1:
                        case Code.Stloc_2:
                        case Code.Stloc_3:
                        case Code.Stloc:
                        case Code.Stloc_S:
                        {
                            Assert.IsTrue(stackSize > 0);
                            break;
                        }
                        case Code.Starg:
                        case Code.Starg_S:
                        {
                            Assert.IsTrue(stackSize > 0);
                            break;
                        }
                        case Code.Ldnull:
                        {
                            PushStackObject(newPushedDatas);
                            break;
                        }
                        case Code.Ldc_I4_M1:
                        case Code.Ldc_I4_0:
                        case Code.Ldc_I4_1:
                        case Code.Ldc_I4_2:
                        case Code.Ldc_I4_3:
                        case Code.Ldc_I4_4:
                        case Code.Ldc_I4_5:
                        case Code.Ldc_I4_6:
                        case Code.Ldc_I4_7:
                        case Code.Ldc_I4_8:
                        case Code.Ldc_I4:
                        case Code.Ldc_I4_S:
                        {
                            PushStack(newPushedDatas, EvalDataType.Int32);
                            break;
                        }
                        case Code.Ldc_I8:
                        {
                            PushStack(newPushedDatas, EvalDataType.Int64);
                            break;
                        }
                        case Code.Ldc_R4:
                        {
                            PushStack(newPushedDatas, EvalDataType.Float);
                            break;
                        }
                        case Code.Ldc_R8:
                        {
                            PushStack(newPushedDatas, EvalDataType.Double);
                            break;
                        }
                        case Code.Dup:
                        {
                            Assert.IsTrue(stackSize > 0);
                            EvalDataTypeWithSig type = stackDatas[stackSize - 1];
                            PushStack(newPushedDatas, type);
                            PushStack(newPushedDatas, type);
                            break;
                        }
                        case Code.Pop:
                        {
                            break;
                        }
                        case Code.Jmp:
                        {
                            break;
                        }
                        case Code.Call:
                        case Code.Callvirt:
                        {
                            IMethod calledMethod = (IMethod)inst.Operand;
                            MethodSig methodSig = MetaUtil.GetInflatedMethodSig(calledMethod, gac);
                            PushStack(newPushedDatas, methodSig.RetType);
                            break;
                        }
                        case Code.Calli:
                        {
                            MethodSig methodSig = (MethodSig)inst.Operand;
                            PushStack(newPushedDatas, methodSig.RetType);
                            break;
                        }
                        case Code.Ret:
                        {
                            break;
                        }
                        case Code.Br:
                        case Code.Br_S:
                        case Code.Brfalse:
                        case Code.Brfalse_S:
                        case Code.Brtrue:
                        case Code.Brtrue_S:
                        case Code.Beq:
                        case Code.Beq_S:
                        case Code.Bge:
                        case Code.Bge_S:
                        case Code.Bge_Un:
                        case Code.Bge_Un_S:
                        case Code.Bgt:
                        case Code.Bgt_S:
                        case Code.Bgt_Un:
                        case Code.Bgt_Un_S:
                        case Code.Ble:
                        case Code.Ble_S:
                        case Code.Ble_Un:
                        case Code.Ble_Un_S:
                        case Code.Blt:
                        case Code.Blt_S:
                        case Code.Blt_Un:
                        case Code.Blt_Un_S:
                        case Code.Bne_Un:
                        case Code.Bne_Un_S:
                        {
                            // Branch instructions do not change the stack.
                            break;
                        }
                        case Code.Ceq:
                        case Code.Cgt:
                        case Code.Cgt_Un:
                        case Code.Clt:
                        case Code.Clt_Un:
                        {
                            Assert.IsTrue(stackSize >= 2);
                            EvalDataType op2 = stackDatas[stackSize - 1].type;
                            EvalDataType op1 = stackDatas[stackSize - 2].type;
                            EvalDataType ret = EvalDataType.Int32;
                            _instructionParameterInfos.Add(inst, new InstructionParameterInfo(op1, op2, ret));
                            PushStack(newPushedDatas, ret);
                            break;
                        }
                        case Code.Switch:
                        {
                            // Switch instruction does not change the stack.
                            break;
                        }
                        case Code.Ldind_I1:
                        case Code.Ldind_U1:
                        case Code.Ldind_I2:
                        case Code.Ldind_U2:
                        case Code.Ldind_I4:
                        case Code.Ldind_U4:
                        {
                            Assert.IsTrue(stackSize > 0);
                            PushStack(newPushedDatas, EvalDataType.Int32);
                            break;
                        }
                        case Code.Ldind_I8:
                        {
                            Assert.IsTrue(stackSize > 0);
                            PushStack(newPushedDatas, EvalDataType.Int64);
                            break;
                        }
                        case Code.Ldind_I:
                        {
                            Assert.IsTrue(stackSize > 0);
                            PushStack(newPushedDatas, EvalDataType.I);
                            break;
                        }
                        case Code.Ldind_Ref:
                        {
                            Assert.IsTrue(stackSize > 0);
                            PushStackObject(newPushedDatas);
                            break;
                        }
                        case Code.Ldind_R4:
                        {
                            Assert.IsTrue(stackSize > 0);
                            PushStack(newPushedDatas, EvalDataType.Float);
                            break;
                        }
                        case Code.Ldind_R8:
                        {
                            Assert.IsTrue(stackSize > 0);
                            PushStack(newPushedDatas, EvalDataType.Double);
                            break;
                        }
                        case Code.Stind_I1:
                        case Code.Stind_I2:
                        case Code.Stind_I4:
                        case Code.Stind_I8:
                        case Code.Stind_I:
                        case Code.Stind_R4:
                        case Code.Stind_R8:
                        case Code.Stind_Ref:
                        {
                            Assert.IsTrue(stackSize >= 2);
                            break;
                        }

                        case Code.Add:
                        case Code.Add_Ovf:
                        case Code.Add_Ovf_Un:
                        case Code.Sub:
                        case Code.Sub_Ovf:
                        case Code.Sub_Ovf_Un:
                        case Code.Mul:
                        case Code.Mul_Ovf:
                        case Code.Mul_Ovf_Un:
                        case Code.Div:
                        case Code.Div_Un:
                        case Code.Rem:
                        case Code.Rem_Un:

                        case Code.And:
                        case Code.Or:
                        case Code.Xor:
                        {
                            Assert.IsTrue(stackSize >= 2);
                            EvalDataType op2 = stackDatas[stackSize - 1].type;
                            EvalDataType op1 = stackDatas[stackSize - 2].type;
                            EvalDataType ret = CalcBasicBinOpRetType(op1, op2);
                            _instructionParameterInfos.Add(inst, new InstructionParameterInfo(op1, op2, ret));
                            PushStack(newPushedDatas, ret);
                            break;
                        }
                        case Code.Shl:
                        case Code.Shr:
                        case Code.Shr_Un:
                        {
                            Assert.IsTrue(stackSize >= 2);
                            EvalDataType op2 = stackDatas[stackSize - 1].type;
                            EvalDataType op1 = stackDatas[stackSize - 2].type;
                            if (op1 != EvalDataType.Int32 && op1 != EvalDataType.Int64 && op1 != EvalDataType.I)
                                throw new Exception($"Unsupported operand type: {op1} in shift operation.");
                            if (op2 != EvalDataType.Int32 && op2 != EvalDataType.Int64)
                                throw new Exception($"Unsupported operand type: {op2} for {op1} in shift operation.");
                            EvalDataType ret = op1;
                            _instructionParameterInfos.Add(inst, new InstructionParameterInfo(op1, op2, ret));
                            PushStack(newPushedDatas, ret);
                            break;
                        }
                        case Code.Neg:
                        {
                            Assert.IsTrue(stackSize > 0);
                            EvalDataType op = stackDatas[stackSize - 1].type;
                            EvalDataType ret = op;
                            switch (op)
                            {
                                case EvalDataType.Int32:
                                case EvalDataType.Int64:
                                case EvalDataType.I:
                                case EvalDataType.Float:
                                case EvalDataType.Double:
                                break;
                                default:
                                throw new Exception($"Unsupported operand type: {op} in unary operation.");
                            }
                            _instructionParameterInfos.Add(inst, new InstructionParameterInfo(op, EvalDataType.None, ret));
                            PushStack(newPushedDatas, ret);
                            break;
                        }
                        case Code.Not:
                        {
                            Assert.IsTrue(stackSize > 0);
                            EvalDataType op = stackDatas[stackSize - 1].type;
                            EvalDataType ret = op;
                            if (op != EvalDataType.Int32 && op != EvalDataType.Int64 && op != EvalDataType.I)
                                throw new Exception($"Unsupported operand type: {op} in unary operation.");
                            _instructionParameterInfos.Add(inst, new InstructionParameterInfo(op, EvalDataType.None, ret));
                            PushStack(newPushedDatas, ret);
                            break;
                        }
                        case Code.Conv_I1:
                        case Code.Conv_U1:
                        case Code.Conv_I2:
                        case Code.Conv_U2:
                        case Code.Conv_I4:
                        case Code.Conv_U4:
                        {
                            PushStack(newPushedDatas, EvalDataType.Int32);
                            break;
                        }
                        case Code.Conv_I8:
                        case Code.Conv_U8:
                        {
                            PushStack(newPushedDatas, EvalDataType.Int64);
                            break;
                        }
                        case Code.Conv_I:
                        case Code.Conv_U:
                        {
                            PushStack(newPushedDatas, EvalDataType.I);
                            break;
                        }
                        case Code.Conv_R4:
                        {
                            PushStack(newPushedDatas, EvalDataType.Float);
                            break;
                        }
                        case Code.Conv_R8:
                        {
                            PushStack(newPushedDatas, EvalDataType.Double);
                            break;
                        }
                        case Code.Conv_Ovf_I1:
                        case Code.Conv_Ovf_I1_Un:
                        case Code.Conv_Ovf_U1:
                        case Code.Conv_Ovf_U1_Un:
                        case Code.Conv_Ovf_I2:
                        case Code.Conv_Ovf_I2_Un:
                        case Code.Conv_Ovf_U2:
                        case Code.Conv_Ovf_U2_Un:
                        case Code.Conv_Ovf_I4:
                        case Code.Conv_Ovf_I4_Un:
                        case Code.Conv_Ovf_U4:
                        case Code.Conv_Ovf_U4_Un:
                        {
                            PushStack(newPushedDatas, EvalDataType.Int32);
                            break;
                        }
                        case Code.Conv_Ovf_I8:
                        case Code.Conv_Ovf_I8_Un:
                        case Code.Conv_Ovf_U8:
                        case Code.Conv_Ovf_U8_Un:
                        {
                            PushStack(newPushedDatas, EvalDataType.Int64);
                            break;
                        }
                        case Code.Conv_Ovf_I:
                        case Code.Conv_Ovf_I_Un:
                        case Code.Conv_Ovf_U:
                        case Code.Conv_Ovf_U_Un:
                        {
                            PushStack(newPushedDatas, EvalDataType.I);
                            break;
                        }
                        case Code.Conv_R_Un:
                        {
                            PushStack(newPushedDatas, EvalDataType.Double);
                            break;
                        }
                        case Code.Cpobj:
                        case Code.Initobj:
                        case Code.Stobj:
                        {
                            break;
                        }
                        case Code.Ldobj:
                        {
                            PushStack(newPushedDatas, (ITypeDefOrRef)inst.Operand);
                            break;
                        }
                        case Code.Ldstr:
                        {
                            PushStack(newPushedDatas, new EvalDataTypeWithSig(EvalDataType.Ref, corLibTypes.String));
                            break;
                        }
                        case Code.Newobj:
                        {
                            IMethod ctor = (IMethod)inst.Operand;
                            PushStack(newPushedDatas, ctor.DeclaringType);
                            break;
                        }
                        case Code.Castclass:
                        {
                            Assert.IsTrue(stackSize > 0);
                            var obj = stackDatas[stackSize - 1];
                            Assert.IsTrue(obj.type == EvalDataType.Ref);
                            PushStack(newPushedDatas, new EvalDataTypeWithSig(EvalDataType.Ref, ((ITypeDefOrRef)inst.Operand).ToTypeSig()));
                            break;
                        }
                        case Code.Isinst:
                        {
                            Assert.IsTrue(stackSize > 0);
                            var obj = stackDatas[stackSize - 1];
                            Assert.IsTrue(obj.type == EvalDataType.Ref);
                            PushStack(newPushedDatas, new EvalDataTypeWithSig(EvalDataType.Ref, ((ITypeDefOrRef)inst.Operand).ToTypeSig()));
                            break;
                        }
                        case Code.Unbox:
                        {
                            Assert.IsTrue(stackSize > 0);
                            PushStack(newPushedDatas, EvalDataType.I);
                            break;
                        }
                        case Code.Unbox_Any:
                        {
                            Assert.IsTrue(stackSize > 0);
                            PushStack(newPushedDatas, (ITypeDefOrRef)inst.Operand);
                            break;
                        }
                        case Code.Box:
                        {
                            Assert.IsTrue(stackSize > 0);
                            PushStackObject(newPushedDatas);
                            break;
                        }
                        case Code.Throw:
                        {
                            // Throw instruction does not change the stack.
                            break;
                        }
                        case Code.Rethrow:
                        {
                            // Rethrow instruction does not change the stack.
                            break;
                        }
                        case Code.Ldfld:
                        case Code.Ldsfld:
                        {
                            IField field = (IField)inst.Operand;
                            TypeSig fieldType = MetaUtil.InflateFieldSig(field, gac);
                            PushStack(newPushedDatas, fieldType);
                            break;
                        }
                        case Code.Ldflda:
                        case Code.Ldsflda:
                        {
                            PushStack(newPushedDatas, EvalDataType.I);
                            break;
                        }
                        case Code.Stfld:
                        case Code.Stsfld:
                        {
                            break;
                        }
                        case Code.Newarr:
                        {
                            Assert.IsTrue(stackSize > 0);
                            PushStack(newPushedDatas, new SZArraySig(((ITypeDefOrRef)inst.Operand).ToTypeSig()));
                            break;
                        }
                        case Code.Ldlen:
                        {
                            Assert.IsTrue(stackSize > 0);
                            PushStack(newPushedDatas, EvalDataType.I);
                            break;
                        }
                        case Code.Ldelema:
                        {
                            Assert.IsTrue(stackSize >= 2);
                            PushStack(newPushedDatas, EvalDataType.I);
                            break;
                        }
                        case Code.Ldelem_I1:
                        case Code.Ldelem_U1:
                        case Code.Ldelem_I2:
                        case Code.Ldelem_U2:
                        case Code.Ldelem_I4:
                        case Code.Ldelem_U4:
                        {
                            Assert.IsTrue(stackSize >= 2);
                            PushStack(newPushedDatas, EvalDataType.Int32);
                            break;
                        }
                        case Code.Ldelem_I8:
                        {
                            Assert.IsTrue(stackSize >= 2);
                            PushStack(newPushedDatas, EvalDataType.Int64);
                            break;
                        }
                        case Code.Ldelem_I:
                        {
                            Assert.IsTrue(stackSize >= 2);
                            PushStack(newPushedDatas, EvalDataType.I);
                            break;
                        }
                        case Code.Ldelem_R4:
                        {
                            Assert.IsTrue(stackSize >= 2);
                            PushStack(newPushedDatas, EvalDataType.Float);
                            break;
                        }
                        case Code.Ldelem_R8:
                        {
                            Assert.IsTrue(stackSize >= 2);
                            PushStack(newPushedDatas, EvalDataType.Double);
                            break;
                        }
                        case Code.Ldelem_Ref:
                        {
                            Assert.IsTrue(stackSize >= 2);
                            PushStackObject(newPushedDatas);
                            break;
                        }
                        case Code.Ldelem:
                        {
                            Assert.IsTrue(stackSize >= 2);
                            PushStack(newPushedDatas, (ITypeDefOrRef)inst.Operand);
                            break;
                        }
                        case Code.Stelem_I1:
                        case Code.Stelem_I2:
                        case Code.Stelem_I4:
                        case Code.Stelem_I8:
                        case Code.Stelem_I:
                        case Code.Stelem_R4:
                        case Code.Stelem_R8:
                        case Code.Stelem_Ref:
                        case Code.Stelem:
                        {
                            Assert.IsTrue(stackSize >= 3);
                            break;
                        }
                        case Code.Mkrefany:
                        {
                            PushStack(newPushedDatas, new EvalDataTypeWithSig(EvalDataType.ValueType, _method.Module.CorLibTypes.TypedReference));
                            break;
                        }
                        case Code.Refanytype:
                        {
                            PushStack(newPushedDatas, EvalDataType.Token);
                            break;
                        }
                        case Code.Refanyval:
                        {
                            Assert.IsTrue(stackSize > 0);
                            PushStack(newPushedDatas, EvalDataType.I);
                            break;
                        }
                        case Code.Ldtoken:
                        {
                            PushStack(newPushedDatas, EvalDataType.Token);
                            break;
                        }
                        case Code.Endfinally:
                        case Code.Leave:
                        case Code.Leave_S:
                        {
                            break;
                        }
                        case Code.Endfilter:
                        {
                            break;
                        }
                        case Code.Arglist:
                        {
                            break;
                        }
                        case Code.Ldftn:
                        case Code.Ldvirtftn:
                        {
                            PushStack(newPushedDatas, EvalDataType.Unknown);
                            break;
                        }
                        case Code.Localloc:
                        {
                            PushStack(newPushedDatas, EvalDataType.I);
                            break;
                        }
                        case Code.Unaligned:
                        case Code.Volatile:
                        case Code.Tailcall:
                        case Code.No:
                        case Code.Readonly:
                        case Code.Constrained:
                        {
                            break;
                        }
                        case Code.Cpblk:
                        case Code.Initblk:
                        {
                            break;
                        }
                        case Code.Sizeof:
                        {
                            PushStack(newPushedDatas, EvalDataType.Int32);
                            break;
                        }
                        default: throw new Exception($"not supported opcode: {inst} in method: {_method.FullName}.");
                    }

                    inst.CalculateStackUsage(methodHasReturnValue, out var pushed, out var pops);
                    if (pushed != newPushedDatas.Count)
                    {
                        throw new Exception($"Instruction {inst} in method {_method.FullName} pushed {newPushedDatas.Count} items, but expected {pushed} items.");
                    }
                    if (pops == -1)
                    {
                        stackDatas.Clear();
                    }
                    else
                    {
                        if (stackSize < pops)
                        {
                            throw new Exception($"Instruction {inst} in method {_method.FullName} pops {pops} items, but only {stackSize} items are available on the stack.");
                        }
                        stackDatas.RemoveRange(stackDatas.Count - pops, pops);
                        stackDatas.AddRange(newPushedDatas);
                        Assert.AreEqual(stackSize + pushed - pops, stackDatas.Count);
                    }
                    if (pushed > 0 && stackDatas.Count > 0)
                    {
                        _evalStackTopDataTypeAfterInstructions[inst] = stackDatas.Last().type;
                    }
                }
                foreach (BasicBlock outBb in block.outBlocks)
                {
                    EvalStackState outState = _blockEvalStackStates[outBb];
                    if (outState.visited)
                    {
                        if (stackDatas.Count != outState.inputStackDatas.Count)
                        {
                            throw new Exception($"Block {block} in method {_method.FullName} has inconsistent stack data. Expected {outState.inputStackDatas.Count}, but got {stackDatas.Count}.");
                        }
                    }
                    else if (outState.inputStackDatas.Count != stackDatas.Count)
                    {
                        if (outState.inputStackDatas.Count > 0)
                        {
                            throw new Exception($"Block {outBb} in method {_method.FullName} has inconsistent stack data. Expected {outState.inputStackDatas.Count}, but got {stackDatas.Count}.");
                        }
                        outState.inputStackDatas.AddRange(stackDatas);
                        blockWalkStack.Push(outBb);
                    }
                }
            }
        }
    }
}

```

`Editor/Emit/EvalStackCalculator.cs.meta`:

```meta
fileFormatVersion: 2
guid: f25425a3077f6db41873dee4223d0abc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Emit/GroupByModuleEntityManager.cs`:

```cs
using dnlib.DotNet;
using System;
using System.Collections.Generic;

namespace Obfuz.Emit
{
    public interface IGroupByModuleEntity
    {
        GroupByModuleEntityManager Manager { get; set; }

        ModuleDef Module { get; set; }

        public EncryptionScopeProvider EncryptionScopeProvider { get; }

        EncryptionScopeInfo EncryptionScope { get; set; }

        void Init();

        void Done();
    }

    public abstract class GroupByModuleEntityBase : IGroupByModuleEntity
    {
        public GroupByModuleEntityManager Manager { get; set; }

        public ModuleDef Module { get; set; }

        public EncryptionScopeInfo EncryptionScope { get; set; }

        public EncryptionScopeProvider EncryptionScopeProvider => Manager.EncryptionScopeProvider;

        public T GetEntity<T>() where T : IGroupByModuleEntity, new()
        {
            return Manager.GetEntity<T>(Module);
        }

        public abstract void Init();

        public abstract void Done();
    }

    public class GroupByModuleEntityManager
    {
        private readonly Dictionary<(ModuleDef, Type), IGroupByModuleEntity> _moduleEntityManagers = new Dictionary<(ModuleDef, Type), IGroupByModuleEntity>();

        public EncryptionScopeProvider EncryptionScopeProvider { get; set; }

        public T GetEntity<T>(ModuleDef mod) where T : IGroupByModuleEntity, new()
        {
            var key = (mod, typeof(T));
            if (_moduleEntityManagers.TryGetValue(key, out var emitManager))
            {
                return (T)emitManager;
            }
            else
            {
                T newEmitManager = new T();
                newEmitManager.Manager = this;
                newEmitManager.Module = mod;
                newEmitManager.EncryptionScope = EncryptionScopeProvider.GetScope(mod);
                newEmitManager.Init();
                _moduleEntityManagers[key] = newEmitManager;
                return newEmitManager;
            }
        }

        public List<T> GetEntities<T>() where T : IGroupByModuleEntity, new()
        {
            var managers = new List<T>();
            foreach (var kv in _moduleEntityManagers)
            {
                if (kv.Key.Item2 == typeof(T))
                {
                    managers.Add((T)kv.Value);
                }
            }
            return managers;
        }

        public void Done<T>() where T : IGroupByModuleEntity, new()
        {
            var managers = GetEntities<T>();
            foreach (var manager in managers)
            {
                manager.Done();
            }
        }
    }
}

```

`Editor/Emit/GroupByModuleEntityManager.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0bfcb2b5a87851f469d201fc8978c109
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Emit/LocalVariableAllocator.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;

namespace Obfuz.Emit
{
    class ScopeLocalVariables : IDisposable
    {
        private readonly LocalVariableAllocator _localVariableAllocator;

        private readonly List<Local> _allocatedVars = new List<Local>();

        public IReadOnlyList<Local> AllocatedLocals => _allocatedVars;


        public ScopeLocalVariables(LocalVariableAllocator localVariableAllocator)
        {
            _localVariableAllocator = localVariableAllocator;
        }

        public Local AllocateLocal(TypeSig type)
        {
            var local = _localVariableAllocator.AllocateLocal(type);
            _allocatedVars.Add(local);
            return local;
        }

        public void Dispose()
        {
            foreach (var local in _allocatedVars)
            {
                _localVariableAllocator.ReturnLocal(local);
            }
        }
    }

    class LocalVariableAllocator
    {
        private readonly MethodDef _method;
        private readonly List<Local> _freeLocals = new List<Local>();

        public LocalVariableAllocator(MethodDef method)
        {
            _method = method;
        }

        public Local AllocateLocal(TypeSig type)
        {
            foreach (var local in _freeLocals)
            {
                if (TypeEqualityComparer.Instance.Equals(local.Type, type))
                {
                    _freeLocals.Remove(local);
                    return local;
                }
            }
            var newLocal = new Local(type);
            // _freeLocals.Add(newLocal);
            _method.Body.Variables.Add(newLocal);
            return newLocal;
        }

        public void ReturnLocal(Local local)
        {
            _freeLocals.Add(local);
        }

        public ScopeLocalVariables CreateScope()
        {
            return new ScopeLocalVariables(this);
        }
    }
}

```

`Editor/Emit/LocalVariableAllocator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 955da34fbde179641a94108ec53405ce
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM.meta`:

```meta
fileFormatVersion: 2
guid: fec4187cc1b96d5439ff908bcecd988f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/EncryptionInstructionWithOpCode.cs`:

```cs
namespace Obfuz.EncryptionVM
{
    public class EncryptionInstructionWithOpCode
    {
        public readonly ushort code;

        public readonly IEncryptionInstruction function;

        public EncryptionInstructionWithOpCode(ushort code, IEncryptionInstruction function)
        {
            this.code = code;
            this.function = function;
        }

        public int Encrypt(int value, int[] secretKey, int salt)
        {
            return function.Encrypt(value, secretKey, salt);
        }

        public int Decrypt(int value, int[] secretKey, int salt)
        {
            return function.Decrypt(value, secretKey, salt);
        }
    }
}

```

`Editor/EncryptionVM/EncryptionInstructionWithOpCode.cs.meta`:

```meta
fileFormatVersion: 2
guid: ca9bd232ed2583f4bb5f330886a329e6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/IEncryptionInstruction.cs`:

```cs
using System.Collections.Generic;

namespace Obfuz.EncryptionVM
{
    public interface IEncryptionInstruction
    {
        int Encrypt(int value, int[] secretKey, int salt);

        int Decrypt(int value, int[] secretKey, int salt);

        void GenerateEncryptCode(List<string> lines, string indent);

        void GenerateDecryptCode(List<string> lines, string indent);
    }

    public abstract class EncryptionInstructionBase : IEncryptionInstruction
    {
        public abstract int Encrypt(int value, int[] secretKey, int salt);
        public abstract int Decrypt(int value, int[] secretKey, int salt);

        public abstract void GenerateEncryptCode(List<string> lines, string indent);
        public abstract void GenerateDecryptCode(List<string> lines, string indent);
    }
}

```

`Editor/EncryptionVM/IEncryptionInstruction.cs.meta`:

```meta
fileFormatVersion: 2
guid: f7b9d087de770a5488a9069ddf697c2f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/Instructions.meta`:

```meta
fileFormatVersion: 2
guid: 981355cf75a9d234883b2a15c446f478
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/Instructions/AddInstruction.cs`:

```cs
using System.Collections.Generic;

namespace Obfuz.EncryptionVM.Instructions
{
    public class AddInstruction : EncryptionInstructionBase
    {
        private readonly int _addValue;
        private readonly int _opKeyIndex;

        public AddInstruction(int addValue, int opKeyIndex)
        {
            _addValue = addValue;
            _opKeyIndex = opKeyIndex;
        }
        public override int Encrypt(int value, int[] secretKey, int salt)
        {
            return ((value + secretKey[_opKeyIndex]) ^ salt) + _addValue;
        }

        public override int Decrypt(int value, int[] secretKey, int salt)
        {
            return ((value - _addValue) ^ salt) - secretKey[_opKeyIndex];
        }

        public override void GenerateEncryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value = ((value + _secretKey[{_opKeyIndex}]) ^ salt) + {_addValue};");
        }

        public override void GenerateDecryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value = ((value  - {_addValue}) ^ salt) - _secretKey[{_opKeyIndex}];");
        }
    }
}

```

`Editor/EncryptionVM/Instructions/AddInstruction.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6bdbdc5fd983f044a87e7b8ab8647aeb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/Instructions/AddRotateXorInstruction.cs`:

```cs
using System.Collections.Generic;

namespace Obfuz.EncryptionVM.Instructions
{
    public class AddRotateXorInstruction : EncryptionInstructionBase
    {
        // x = x + p1 + secretKey[index1];
        // x = Rotate(x, p2)
        // x = x ^ p3 ^ salt;

        private readonly int _addValue;
        private readonly int _index1;
        private readonly int _rotateBitNum;
        private readonly int _xorValue;

        public AddRotateXorInstruction(int addValue, int index1, int rotateBitNum, int xorValue)
        {
            _addValue = addValue;
            _index1 = index1;
            _rotateBitNum = rotateBitNum;
            _xorValue = xorValue;
        }

        public override int Encrypt(int value, int[] secretKey, int salt)
        {
            value += _addValue + secretKey[_index1];
            uint part1 = (uint)value << _rotateBitNum;
            uint part2 = (uint)value >> (32 - _rotateBitNum);
            value = (int)(part1 | part2);
            value ^= _xorValue ^ salt;
            return value;
        }

        public override int Decrypt(int value, int[] secretKey, int salt)
        {
            value ^= _xorValue ^ salt;
            uint value2 = (uint)value >> _rotateBitNum;
            uint part1 = (uint)value << (32 - _rotateBitNum);
            value = (int)(value2 | part1);
            value -= _addValue + secretKey[_index1];
            return value;
        }

        public override void GenerateEncryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value += {_addValue} + _secretKey[{_index1}];");
            lines.Add(indent + $"uint part1 = (uint)value << {_rotateBitNum};");
            lines.Add(indent + $"uint part2 = (uint)value >> (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(part1 | part2);");
            lines.Add(indent + $"value ^= {_xorValue} ^ salt;");
        }

        public override void GenerateDecryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value ^= {_xorValue} ^ salt;");
            lines.Add(indent + $"uint value2 = (uint)value >> {_rotateBitNum};");
            lines.Add(indent + $"uint part1 = (uint)value << (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(value2 | part1);");
            lines.Add(indent + $"value -= {_addValue} + _secretKey[{_index1}];");
        }
    }
}

```

`Editor/EncryptionVM/Instructions/AddRotateXorInstruction.cs.meta`:

```meta
fileFormatVersion: 2
guid: cda67c0dd0cadd24ea02c2988e34281a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/Instructions/AddXorRotateInstruction.cs`:

```cs
using System.Collections.Generic;

namespace Obfuz.EncryptionVM.Instructions
{
    public class AddXorRotateInstruction : EncryptionInstructionBase
    {
        // x = x + p1 + secretKey[index1];
        // x = x ^ p3 ^ salt;
        // x = Rotate(x, p2)

        private readonly int _addValue;
        private readonly int _index1;
        private readonly int _rotateBitNum;
        private readonly int _xorValue;

        public AddXorRotateInstruction(int addValue, int index1, int xorValue, int rotateBitNum)
        {
            _addValue = addValue;
            _index1 = index1;
            _rotateBitNum = rotateBitNum;
            _xorValue = xorValue;
        }

        public override int Encrypt(int value, int[] secretKey, int salt)
        {
            value += _addValue + secretKey[_index1];
            value ^= _xorValue ^ salt;
            uint part1 = (uint)value << _rotateBitNum;
            uint part2 = (uint)value >> (32 - _rotateBitNum);
            value = (int)(part1 | part2);
            return value;
        }

        public override int Decrypt(int value, int[] secretKey, int salt)
        {
            uint value2 = (uint)value >> _rotateBitNum;
            uint part1 = (uint)value << (32 - _rotateBitNum);
            value = (int)(value2 | part1);
            value ^= _xorValue ^ salt;
            value -= _addValue + secretKey[_index1];
            return value;
        }

        public override void GenerateEncryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value += {_addValue} + _secretKey[{_index1}];");
            lines.Add(indent + $"value ^= {_xorValue} ^ salt;");
            lines.Add(indent + $"uint part1 = (uint)value << {_rotateBitNum};");
            lines.Add(indent + $"uint part2 = (uint)value >> (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(part1 | part2);");
        }

        public override void GenerateDecryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"uint part1 = (uint)value >> {_rotateBitNum};");
            lines.Add(indent + $"uint part2 = (uint)value << (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(part1 | part2);");
            lines.Add(indent + $"value ^= {_xorValue} ^ salt;");
            lines.Add(indent + $"value -= {_addValue} + _secretKey[{_index1}];");
        }
    }
}

```

`Editor/EncryptionVM/Instructions/AddXorRotateInstruction.cs.meta`:

```meta
fileFormatVersion: 2
guid: d806305e627be06469fb2d2c2cf98816
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/Instructions/BitRotateInstruction.cs`:

```cs
using System.Collections.Generic;

namespace Obfuz.EncryptionVM.Instructions
{
    public class BitRotateInstruction : EncryptionInstructionBase
    {
        private readonly int _rotateBitNum;
        private readonly int _opKeyIndex;

        public BitRotateInstruction(int rotateBitNum, int opKeyIndex)
        {
            _rotateBitNum = rotateBitNum;
            _opKeyIndex = opKeyIndex;
        }

        public override int Encrypt(int value, int[] secretKey, int salt)
        {
            uint part1 = (uint)value << _rotateBitNum;
            uint part2 = (uint)value >> (32 - _rotateBitNum);
            return ((int)(part1 | part2) ^ secretKey[_opKeyIndex]) + salt;
        }

        public override int Decrypt(int value, int[] secretKey, int salt)
        {
            uint value2 = (uint)((value - salt) ^ secretKey[_opKeyIndex]);
            uint part1 = value2 >> _rotateBitNum;
            uint part2 = value2 << (32 - _rotateBitNum);
            return (int)(part1 | part2);
        }

        public override void GenerateEncryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"uint part1 = (uint)value << {_rotateBitNum};");
            lines.Add(indent + $"uint part2 = (uint)value >> (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = ((int)(part1 | part2) ^ _secretKey[{_opKeyIndex}]) + salt;");
        }

        public override void GenerateDecryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"uint value2 = (uint)((value - salt) ^ _secretKey[{_opKeyIndex}]);");
            lines.Add(indent + $"uint part1 = value2 >> {_rotateBitNum};");
            lines.Add(indent + $"uint part2 = value2 << (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(part1 | part2);");
        }
    }
}

```

`Editor/EncryptionVM/Instructions/BitRotateInstruction.cs.meta`:

```meta
fileFormatVersion: 2
guid: bccff31b9f07fcf4f821cee671f82caf
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/Instructions/EncryptFunction.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Obfuz.EncryptionVM.Instructions
{

    public class EncryptFunction : EncryptionInstructionBase
    {
        private readonly IEncryptionInstruction[] _instructions;

        public EncryptFunction(IEncryptionInstruction[] instructions)
        {
            _instructions = instructions;
        }

        public override int Encrypt(int value, int[] secretKey, int salt)
        {
            foreach (var instruction in _instructions)
            {
                value = instruction.Encrypt(value, secretKey, salt);
            }
            return value;
        }

        public override int Decrypt(int value, int[] secretKey, int salt)
        {
            for (int i = _instructions.Length - 1; i >= 0; i--)
            {
                value = _instructions[i].Decrypt(value, secretKey, salt);
            }
            return value;
        }

        public override void GenerateEncryptCode(List<string> lines, string indent)
        {
            throw new NotImplementedException();
        }

        public override void GenerateDecryptCode(List<string> lines, string indent)
        {
            throw new NotImplementedException();
        }
    }
}

```

`Editor/EncryptionVM/Instructions/EncryptFunction.cs.meta`:

```meta
fileFormatVersion: 2
guid: feafdb30f7b6d5143a89c7659bc16171
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/Instructions/MultipleInstruction.cs`:

```cs
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.EncryptionVM.Instructions
{
    public class MultipleInstruction : EncryptionInstructionBase
    {
        private readonly int _multiValue;
        private readonly int _revertMultiValue;
        private readonly int _opKeyIndex;

        public MultipleInstruction(int addValue, int opKeyIndex)
        {
            _multiValue = addValue;
            _opKeyIndex = opKeyIndex;
            _revertMultiValue = MathUtil.ModInverse32(addValue);
            Verify();
        }

        private void Verify()
        {
            int a = 1122334;
            UnityEngine.Assertions.Assert.AreEqual(a, a * _multiValue * _revertMultiValue);
        }

        public override int Encrypt(int value, int[] secretKey, int salt)
        {
            return value * _multiValue + secretKey[_opKeyIndex] + salt;
        }

        public override int Decrypt(int value, int[] secretKey, int salt)
        {
            return (value - secretKey[_opKeyIndex] - salt) * _revertMultiValue;
        }

        public override void GenerateEncryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value = value *  {_multiValue} + _secretKey[{_opKeyIndex}] + salt;");
        }

        public override void GenerateDecryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value = (value - _secretKey[{_opKeyIndex}] - salt) * {_revertMultiValue};");
        }
    }
}

```

`Editor/EncryptionVM/Instructions/MultipleInstruction.cs.meta`:

```meta
fileFormatVersion: 2
guid: fd5fdfad694e0ae469bf6ca04c913220
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/Instructions/MultipleRotateXorInstruction.cs`:

```cs
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.EncryptionVM.Instructions
{
    public class MultipleRotateXorInstruction : EncryptionInstructionBase
    {
        // x = x * p1 + secretKey[index1];
        // x = Rotate(x, p2)
        // x = x ^ p3 ^ salt;

        private readonly int _multipleValue;
        private readonly int _revertMultipleValue;
        private readonly int _index1;
        private readonly int _rotateBitNum;
        private readonly int _xorValue;

        public MultipleRotateXorInstruction(int multipleValue, int index1, int rotateBitNum, int xorValue)
        {
            _multipleValue = multipleValue;
            _revertMultipleValue = MathUtil.ModInverse32(multipleValue);
            _index1 = index1;
            _rotateBitNum = rotateBitNum;
            _xorValue = xorValue;
        }

        public override int Encrypt(int value, int[] secretKey, int salt)
        {
            value = value * _multipleValue + secretKey[_index1];
            uint part1 = (uint)value << _rotateBitNum;
            uint part2 = (uint)value >> (32 - _rotateBitNum);
            value = (int)(part1 | part2);
            value ^= _xorValue ^ salt;
            return value;
        }

        public override int Decrypt(int value, int[] secretKey, int salt)
        {
            value ^= _xorValue ^ salt;
            uint value2 = (uint)value >> _rotateBitNum;
            uint part1 = (uint)value << (32 - _rotateBitNum);
            value = (int)(value2 | part1);
            value = (value - secretKey[_index1]) * _revertMultipleValue;
            return value;
        }

        public override void GenerateEncryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value = value * {_multipleValue} + _secretKey[{_index1}];");
            lines.Add(indent + $"uint part1 = (uint)value << {_rotateBitNum};");
            lines.Add(indent + $"uint part2 = (uint)value >> (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(part1 | part2);");
            lines.Add(indent + $"value ^= {_xorValue} ^ salt;");
        }

        public override void GenerateDecryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value ^= {_xorValue} ^ salt;");
            lines.Add(indent + $"uint value2 = (uint)value >> {_rotateBitNum};");
            lines.Add(indent + $"uint part1 = (uint)value << (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(value2 | part1);");
            lines.Add(indent + $"value = (value - _secretKey[{_index1}]) * {_revertMultipleValue};");
        }
    }
}

```

`Editor/EncryptionVM/Instructions/MultipleRotateXorInstruction.cs.meta`:

```meta
fileFormatVersion: 2
guid: e3c8b55b35ff1554489fa657a714f485
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/Instructions/MultipleXorRotateInstruction.cs`:

```cs
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.EncryptionVM.Instructions
{
    public class MultipleXorRotateInstruction : EncryptionInstructionBase
    {
        // x = x * p1 + secretKey[index1];
        // x = x ^ p3 ^ salt;
        // x = Rotate(x, p2)

        private readonly int _multipleValue;
        private readonly int _revertMultipleValue;
        private readonly int _index1;
        private readonly int _rotateBitNum;
        private readonly int _xorValue;

        public MultipleXorRotateInstruction(int multipleValue, int index1, int xorValue, int rotateBitNum)
        {
            _multipleValue = multipleValue;
            _revertMultipleValue = MathUtil.ModInverse32(multipleValue);
            _index1 = index1;
            _rotateBitNum = rotateBitNum;
            _xorValue = xorValue;
        }

        public override int Encrypt(int value, int[] secretKey, int salt)
        {
            value = value * _multipleValue + secretKey[_index1];
            value ^= _xorValue ^ salt;
            uint part1 = (uint)value << _rotateBitNum;
            uint part2 = (uint)value >> (32 - _rotateBitNum);
            value = (int)(part1 | part2);
            return value;
        }

        public override int Decrypt(int value, int[] secretKey, int salt)
        {
            uint value2 = (uint)value >> _rotateBitNum;
            uint part1 = (uint)value << (32 - _rotateBitNum);
            value = (int)(value2 | part1);
            value ^= _xorValue ^ salt;
            value = (value - secretKey[_index1]) * _revertMultipleValue;
            return value;
        }

        public override void GenerateEncryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value = value * {_multipleValue} + _secretKey[{_index1}];");
            lines.Add(indent + $"value ^= {_xorValue} ^ salt;");
            lines.Add(indent + $"uint part1 = (uint)value << {_rotateBitNum};");
            lines.Add(indent + $"uint part2 = (uint)value >> (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(part1 | part2);");
        }

        public override void GenerateDecryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"uint value2 = (uint)value >> {_rotateBitNum};");
            lines.Add(indent + $"uint part1 = (uint)value << (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(value2 | part1);");
            lines.Add(indent + $"value ^= {_xorValue} ^ salt;");
            lines.Add(indent + $"value = (value - _secretKey[{_index1}]) * {_revertMultipleValue};");
        }
    }
}

```

`Editor/EncryptionVM/Instructions/MultipleXorRotateInstruction.cs.meta`:

```meta
fileFormatVersion: 2
guid: adc3dcde66795744fa4bdc753a2c599f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/Instructions/XorAddRotateInstruction.cs`:

```cs
using System.Collections.Generic;

namespace Obfuz.EncryptionVM.Instructions
{
    public class XorAddRotateInstruction : EncryptionInstructionBase
    {
        // x = x ^ p3 ^ salt;
        // x = x + p1 + secretKey[index1];
        // x = Rotate(x, p2)

        private readonly int _addValue;
        private readonly int _index1;
        private readonly int _rotateBitNum;
        private readonly int _xorValue;

        public XorAddRotateInstruction(int xorValue, int addValue, int index1, int rotateBitNum)
        {
            _addValue = addValue;
            _index1 = index1;
            _rotateBitNum = rotateBitNum;
            _xorValue = xorValue;
        }

        public override int Encrypt(int value, int[] secretKey, int salt)
        {
            value ^= _xorValue ^ salt;
            value += _addValue + secretKey[_index1];
            uint part1 = (uint)value << _rotateBitNum;
            uint part2 = (uint)value >> (32 - _rotateBitNum);
            value = (int)(part1 | part2);
            return value;
        }

        public override int Decrypt(int value, int[] secretKey, int salt)
        {
            uint value2 = (uint)value >> _rotateBitNum;
            uint part1 = (uint)value << (32 - _rotateBitNum);
            value = (int)(value2 | part1);
            value -= _addValue + secretKey[_index1];
            value ^= _xorValue ^ salt;
            return value;
        }

        public override void GenerateEncryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value ^= {_xorValue} ^ salt;");
            lines.Add(indent + $"value += {_addValue} + _secretKey[{_index1}];");
            lines.Add(indent + $"uint part1 = (uint)value << {_rotateBitNum};");
            lines.Add(indent + $"uint part2 = (uint)value >> (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(part1 | part2);");
        }

        public override void GenerateDecryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"uint value2 = (uint)value >> {_rotateBitNum};");
            lines.Add(indent + $"uint part1 = (uint)value << (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(value2 | part1);");
            lines.Add(indent + $"value -= {_addValue} + _secretKey[{_index1}];");
            lines.Add(indent + $"value ^= {_xorValue} ^ salt;");
        }
    }
}

```

`Editor/EncryptionVM/Instructions/XorAddRotateInstruction.cs.meta`:

```meta
fileFormatVersion: 2
guid: ad8f4dd724d7ff845b0dd65861054d37
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/Instructions/XorInstruction.cs`:

```cs
using System.Collections.Generic;

namespace Obfuz.EncryptionVM.Instructions
{
    public class XorInstruction : EncryptionInstructionBase
    {
        private readonly int _xorValue;
        private readonly int _opKeyIndex;

        public XorInstruction(int xorValue, int opKeyIndex)
        {
            _xorValue = xorValue;
            _opKeyIndex = opKeyIndex;
        }

        public override int Encrypt(int value, int[] secretKey, int salt)
        {
            return ((value ^ secretKey[_opKeyIndex]) + salt) ^ _xorValue;
        }

        public override int Decrypt(int value, int[] secretKey, int salt)
        {
            return ((value ^ _xorValue) - salt) ^ secretKey[_opKeyIndex];
        }

        public override void GenerateEncryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value = ((value ^ _secretKey[{_opKeyIndex}]) + salt) ^ {_xorValue};");
        }

        public override void GenerateDecryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value = ((value ^ {_xorValue}) - salt) ^ _secretKey[{_opKeyIndex}];");
        }
    }
}

```

`Editor/EncryptionVM/Instructions/XorInstruction.cs.meta`:

```meta
fileFormatVersion: 2
guid: 2f16dd868e4473b45bfa9daaf7fabaf8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/Instructions/XorMultipleRotateInstruction.cs`:

```cs
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.EncryptionVM.Instructions
{
    public class XorMultipleRotateInstruction : EncryptionInstructionBase
    {
        // x = x ^ p3 ^ salt;
        // x = x * p1 + secretKey[index1];
        // x = Rotate(x, p2)

        private readonly int _multipleValue;
        private readonly int _revertMultipleValue;
        private readonly int _index1;
        private readonly int _rotateBitNum;
        private readonly int _xorValue;

        public XorMultipleRotateInstruction(int xorValue, int multipleValue, int index1, int rotateBitNum)
        {
            _multipleValue = multipleValue;
            _revertMultipleValue = MathUtil.ModInverse32(multipleValue);
            _index1 = index1;
            _rotateBitNum = rotateBitNum;
            _xorValue = xorValue;
        }

        public override int Encrypt(int value, int[] secretKey, int salt)
        {
            value ^= _xorValue ^ salt;
            value = value * _multipleValue + secretKey[_index1];
            uint part1 = (uint)value << _rotateBitNum;
            uint part2 = (uint)value >> (32 - _rotateBitNum);
            value = (int)(part1 | part2);
            return value;
        }

        public override int Decrypt(int value, int[] secretKey, int salt)
        {
            uint value2 = (uint)value >> _rotateBitNum;
            uint part1 = (uint)value << (32 - _rotateBitNum);
            value = (int)(value2 | part1);
            value = (value - secretKey[_index1]) * _revertMultipleValue;
            value ^= _xorValue ^ salt;
            return value;
        }

        public override void GenerateEncryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"value ^= {_xorValue} ^ salt;");
            lines.Add(indent + $"value = value * {_multipleValue} + _secretKey[{_index1}];");
            lines.Add(indent + $"uint part1 = (uint)value << {_rotateBitNum};");
            lines.Add(indent + $"uint part2 = (uint)value >> (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(part1 | part2);");
        }

        public override void GenerateDecryptCode(List<string> lines, string indent)
        {
            lines.Add(indent + $"uint value2 = (uint)value >> {_rotateBitNum};");
            lines.Add(indent + $"uint part1 = (uint)value << (32 - {_rotateBitNum});");
            lines.Add(indent + $"value = (int)(value2 | part1);");
            lines.Add(indent + $"value = (value - _secretKey[{_index1}]) * {_revertMultipleValue};");
            lines.Add(indent + $"value ^= {_xorValue} ^ salt;");
        }
    }
}

```

`Editor/EncryptionVM/Instructions/XorMultipleRotateInstruction.cs.meta`:

```meta
fileFormatVersion: 2
guid: 3eb7e6d475cfc14459d3850c5964ba52
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/VirtualMachine.cs`:

```cs
namespace Obfuz.EncryptionVM
{
    public class VirtualMachine
    {
        public const int SecretKeyLength = 1024;

        public readonly int version;
        public readonly string codeGenerationSecretKey;
        public readonly EncryptionInstructionWithOpCode[] opCodes;

        public VirtualMachine(int version, string codeGenerationSecretKey, EncryptionInstructionWithOpCode[] opCodes)
        {
            this.codeGenerationSecretKey = codeGenerationSecretKey;
            this.opCodes = opCodes;
        }
    }
}

```

`Editor/EncryptionVM/VirtualMachine.cs.meta`:

```meta
fileFormatVersion: 2
guid: c6970e037654dcb49912783a40f3e1ba
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/VirtualMachineCodeGenerator.cs`:

```cs
using Obfuz.Utils;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Obfuz.EncryptionVM
{
    public class VirtualMachineCodeGenerator
    {
        private readonly int _opCodeCount;
        private readonly int _opCodeBits;
        private readonly VirtualMachine _vm;

        public VirtualMachineCodeGenerator(string vmCodeGenerateSecretKey, int opCodeCount)
        {
            _opCodeCount = opCodeCount;
            _opCodeBits = EncryptionUtil.GetBitCount(opCodeCount - 1);
            _vm = new VirtualMachineCreator(vmCodeGenerateSecretKey).CreateVirtualMachine(opCodeCount);
        }

        public VirtualMachineCodeGenerator(VirtualMachine vm)
        {
            _opCodeCount = vm.opCodes.Length;
            _opCodeBits = EncryptionUtil.GetBitCount(_opCodeCount - 1);
            _vm = vm;
        }


        public bool ValidateMatch(string outputFile)
        {
            if (!File.Exists(outputFile))
            {
                return false;
            }
            string oldCode = NormalizeText(File.ReadAllText(outputFile, Encoding.UTF8));
            string newCode = NormalizeText(GenerateCode());
            return oldCode == newCode;
        }

        private static string NormalizeText(string input)
        {
            return Regex.Replace(input, @"\s+", string.Empty);
        }

        public void Generate(string outputFile)
        {
            FileUtil.CreateParentDir(outputFile);

            string code = GenerateCode();

            File.WriteAllText(outputFile, code, Encoding.UTF8);
            Debug.Log($"Generate EncryptionVM code to {outputFile}");
        }

        private string GenerateCode()
        {
            var lines = new List<string>();
            AppendHeader(lines);
            AppendEncryptCodes(lines);
            AppendDecryptCodes(lines);
            AppendTailer(lines);
            return string.Join("\n", lines);
        }

        private void AppendEncryptCodes(List<string> lines)
        {
            lines.Add(@"
        private int ExecuteEncrypt(int value, int opCode, int salt)
        {
            switch (opCode)
            {");
            foreach (var opCode in _vm.opCodes)
            {
                lines.Add($@"               case {opCode.code}:
                {{
                    // {opCode.function.GetType().Name}");
                AppendEncryptCode(lines, opCode.function);
                lines.Add(@"                    return value;
                }");
            }

            lines.Add(@"
                default:
                    throw new System.Exception($""Invalid opCode:{opCode}"");
            }
        }");
        }

        private void AppendDecryptCodes(List<string> lines)
        {
            lines.Add(@"
        private int ExecuteDecrypt(int value, int opCode, int salt)
        {
            switch (opCode)
            {");
            foreach (var opCode in _vm.opCodes)
            {
                lines.Add($@"               case {opCode.code}:
                {{
                    // {opCode.function.GetType().Name}");
                AppendDecryptCode(lines, opCode.function);
                lines.Add(@"                    return value;
                }");
            }

            lines.Add(@"
                default:
                    throw new System.Exception($""Invalid opCode:{opCode}"");
            }
        }");
        }

        private void AppendHeader(List<string> lines)
        {

            lines.Add($"/// This file is auto-generated by Obfuz. Do not modify it.");
            lines.Add($"///");
            //lines.Add($"/// Created Time: {DateTime.Now}");

            lines.Add($"/// Version: {_vm.version}");
            lines.Add($"/// SecretKey: {_vm.codeGenerationSecretKey}");
            lines.Add($"/// OpCodeCount: {_vm.opCodes.Length}");

            lines.Add(@"
namespace Obfuz.EncryptionVM
{
    public class GeneratedEncryptionVirtualMachine : Obfuz.EncryptorBase
    {");
            lines.Add($@"
        private const int kOpCodeBits = {_opCodeBits};

        private const int kOpCodeCount = {_opCodeCount};

        private const int kOpCodeMask = {_opCodeCount - 1};
");
            lines.Add(@"

        private readonly int[] _secretKey;

        public GeneratedEncryptionVirtualMachine(byte[] secretKey)
        {
            this._secretKey = ConvertToIntKey(secretKey);
        }

        public override int OpCodeCount => kOpCodeCount;

        public override int Encrypt(int value, int opts, int salt)
        {
            uint uopts = (uint)opts;
            uint revertOps = 0;
            while (uopts != 0)
            {
                uint opCode = uopts & kOpCodeMask;
                revertOps <<= kOpCodeBits;
                revertOps |= opCode;
                uopts >>= kOpCodeBits;
            }

            while (revertOps != 0)
            {
                uint opCode = revertOps & kOpCodeMask;
                value = ExecuteEncrypt(value, (int)opCode, salt);
                revertOps >>= kOpCodeBits;
            }
            return value;
        }

        public override int Decrypt(int value, int opts, int salt)
        {
            uint uopts = (uint)opts;
            while (uopts != 0)
            {
                uint opCode = uopts & kOpCodeMask;
                value = ExecuteDecrypt(value, (int)opCode, salt);
                uopts >>= kOpCodeBits;
            }
            return value;
        }
");
        }

        private void AppendTailer(List<string> lines)
        {
            lines.Add(@"
    }
}

");
        }

        private void AppendEncryptCode(List<string> lines, IEncryptionInstruction instruction)
        {
            instruction.GenerateEncryptCode(lines, "                    ");
        }

        private void AppendDecryptCode(List<string> lines, IEncryptionInstruction instruction)
        {
            instruction.GenerateDecryptCode(lines, "                    ");
        }
    }
}

```

`Editor/EncryptionVM/VirtualMachineCodeGenerator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 2246e9d3369eb3c45bc19ae0748d76ba
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/VirtualMachineCreator.cs`:

```cs
using Obfuz.EncryptionVM.Instructions;
using Obfuz.Utils;
using System;
using System.Collections.Generic;

namespace Obfuz.EncryptionVM
{
    public class VirtualMachineCreator
    {
        private readonly string _vmGenerationSecretKey;
        private readonly IRandom _random;

        public const int CodeGenerationSecretKeyLength = 1024;

        public const int VirtualMachineVersion = 1;

        public VirtualMachineCreator(string vmGenerationSecretKey)
        {
            _vmGenerationSecretKey = vmGenerationSecretKey;
            byte[] byteGenerationSecretKey = KeyGenerator.GenerateKey(vmGenerationSecretKey, CodeGenerationSecretKeyLength);
            int[] intGenerationSecretKey = KeyGenerator.ConvertToIntKey(byteGenerationSecretKey);
            _random = new RandomWithKey(intGenerationSecretKey, 0);
        }

        private readonly List<Func<IRandom, int, EncryptionInstructionBase>> _instructionCreators = new List<Func<IRandom, int, EncryptionInstructionBase>>
        {
            (r, len) => new AddInstruction(r.NextInt(), r.NextInt(len)),
            (r, len) => new XorInstruction(r.NextInt(), r.NextInt(len)),
            (r, len) => new BitRotateInstruction(r.NextInt(32), r.NextInt(len)),
            (r, len) => new MultipleInstruction(r.NextInt() | 0x1, r.NextInt(len)),
            (r, len) => new AddRotateXorInstruction(r.NextInt(), r.NextInt(len), r.NextInt(32), r.NextInt()),
            (r, len) => new AddXorRotateInstruction(r.NextInt(), r.NextInt(len), r.NextInt(), r.NextInt(32)),
            (r, len) => new XorAddRotateInstruction(r.NextInt(), r.NextInt(), r.NextInt(len), r.NextInt(32)),
            (r, len) => new MultipleRotateXorInstruction(r.NextInt() | 0x1, r.NextInt(len), r.NextInt(32), r.NextInt()),
            (r, len) => new MultipleXorRotateInstruction(r.NextInt() | 0x1,  r.NextInt(len), r.NextInt(), r.NextInt(32)),
            (r, len) => new XorMultipleRotateInstruction(r.NextInt(), r.NextInt() | 0x1, r.NextInt(len), r.NextInt(32)),
        };

        private IEncryptionInstruction CreateRandomInstruction(int intSecretKeyLength)
        {
            return _instructionCreators[_random.NextInt(_instructionCreators.Count)](_random, intSecretKeyLength);
        }

        private EncryptionInstructionWithOpCode CreateEncryptOpCode(ushort code)
        {
            IEncryptionInstruction inst = CreateRandomInstruction(VirtualMachine.SecretKeyLength / sizeof(int));
            return new EncryptionInstructionWithOpCode(code, inst);
        }

        public VirtualMachine CreateVirtualMachine(int opCodeCount)
        {
            if (opCodeCount < 64)
            {
                throw new System.Exception("OpCode count should be >= 64");
            }
            if ((opCodeCount & (opCodeCount - 1)) != 0)
            {
                throw new System.Exception("OpCode count should be power of 2");
            }
            var opCodes = new EncryptionInstructionWithOpCode[opCodeCount];
            for (int i = 0; i < opCodes.Length; i++)
            {
                opCodes[i] = CreateEncryptOpCode((ushort)i);
            }
            return new VirtualMachine(VirtualMachineVersion, _vmGenerationSecretKey, opCodes);
        }
    }
}

```

`Editor/EncryptionVM/VirtualMachineCreator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 77d95ff5cf0b3aa4e96a055e37c381ba
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/EncryptionVM/VirtualMachineSimulator.cs`:

```cs
using Obfuz.Utils;
using System.Collections.Generic;
using UnityEngine.Assertions;

namespace Obfuz.EncryptionVM
{

    public class VirtualMachineSimulator : EncryptorBase
    {
        private readonly EncryptionInstructionWithOpCode[] _opCodes;
        private readonly int[] _secretKey;

        public override int OpCodeCount => _opCodes.Length;

        public VirtualMachineSimulator(VirtualMachine vm, byte[] byteSecretKey)
        {
            _opCodes = vm.opCodes;
            _secretKey = KeyGenerator.ConvertToIntKey(byteSecretKey);

            VerifyInstructions();
        }

        private void VerifyInstructions()
        {
            int value = 0x11223344;
            for (int i = 0; i < _opCodes.Length; i++)
            {
                int encryptedValue = _opCodes[i].Encrypt(value, _secretKey, i);
                int decryptedValue = _opCodes[i].Decrypt(encryptedValue, _secretKey, i);
                //Debug.Log($"instruction type:{_opCodes[i].function.GetType()}");
                Assert.AreEqual(value, decryptedValue);
            }

            int ops = 11223344;
            int salt = 789;
            Assert.AreEqual(1, Decrypt(Encrypt(1, ops, salt), ops, salt));
            Assert.AreEqual(1L, Decrypt(Encrypt(1L, ops, salt), ops, salt));
            Assert.AreEqual(1.0f, Decrypt(Encrypt(1.0f, ops, salt), ops, salt));
            Assert.AreEqual(1.0, Decrypt(Encrypt(1.0, ops, salt), ops, salt));

            byte[] strBytes = Encrypt("abcdef", ops, salt);
            Assert.AreEqual("abcdef", DecryptString(strBytes, 0, strBytes.Length, ops, salt));
            var arr = new byte[100];
            for (int i = 0; i < arr.Length; i++)
            {
                arr[i] = (byte)i;
            }
            EncryptBlock(arr, ops, salt);
            DecryptBlock(arr, ops, salt);
            for (int i = 0; i < arr.Length; i++)
            {
                Assert.AreEqual(i, arr[i]);
            }
        }

        private List<uint> DecodeOps(uint ops)
        {
            var codes = new List<uint>();
            while (ops != 0)
            {
                uint code = ops % (uint)_opCodes.Length;
                codes.Add(code);
                ops /= (uint)_opCodes.Length;
            }
            return codes;
        }

        public override int Encrypt(int value, int ops, int salt)
        {
            var codes = DecodeOps((uint)ops);
            for (int i = codes.Count - 1; i >= 0; i--)
            {
                var opCode = _opCodes[codes[i]];
                value = opCode.Encrypt(value, _secretKey, salt);
            }
            return value;
        }

        public override int Decrypt(int value, int ops, int salt)
        {
            var codes = DecodeOps((uint)ops);
            foreach (var code in codes)
            {
                var opCode = _opCodes[code];
                value = opCode.Decrypt(value, _secretKey, salt);
            }
            return value;
        }
    }
}

```

`Editor/EncryptionVM/VirtualMachineSimulator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 4f86f4d6faf49764a915d5c675091375
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/GarbageCodeGeneration.meta`:

```meta
fileFormatVersion: 2
guid: f47f2abd9eb7ba8469ba5cb1bb085d33
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/GarbageCodeGeneration/ConfigGarbageCodeGenerator.cs`:

```cs
using Obfuz.Utils;
using System;
using System.Linq;
using System.Text;

namespace Obfuz.GarbageCodeGeneration
{

    public class ConfigGarbageCodeGenerator : SpecificGarbageCodeGeneratorBase
    {

        private readonly string[] _types = new string[]
        {
            "bool",
            "byte",
            "short",
            "int",
            "long",
            "float",
            "double",
        };

        private string CreateRandomType(IRandom random)
        {
            return _types[random.NextInt(_types.Length)];
        }

        private string GetReadMethodNameOfType(string type)
        {
            switch (type)
            {
                case "bool": return "ReadBoolean";
                case "byte": return "ReadByte";
                case "short": return "ReadInt16";
                case "int": return "ReadInt32";
                case "long": return "ReadInt64";
                case "float": return "ReadSingle";
                case "double": return "ReadDouble";
                default: throw new ArgumentException($"Unsupported type: {type}");
            }
        }
        class FieldGenerationInfo
        {
            public int index;
            public string name;
            public string type;
        }

        class MethodGenerationInfo
        {
            public int index;
            public string name;
        }

        protected override object CreateField(int index, IRandom random, GenerationParameters parameters)
        {
            return new FieldGenerationInfo
            {
                index = index,
                name = $"x{index}",
                type = CreateRandomType(random),
            };
        }

        protected override object CreateMethod(int index, IRandom random, GenerationParameters parameters)
        {
            return new MethodGenerationInfo
            {
                index = index,
                name = $"Load{index}",
            };
        }

        protected override void GenerateUsings(StringBuilder result, IClassGenerationInfo cgi)
        {
        }

        protected override void GenerateField(StringBuilder result, IClassGenerationInfo cgi, IRandom random, object field, string indent)
        {
            var fgi = (FieldGenerationInfo)field;
            result.AppendLine($"{indent}public {fgi.type} {fgi.name};");
        }

        protected override void GenerateMethod(StringBuilder result, IClassGenerationInfo cgi, IRandom random, object method, string indent)
        {
            var mgi = (MethodGenerationInfo)method;
            result.AppendLine($"{indent}public void {mgi.name}(BinaryReader reader)");
            result.AppendLine($"{indent}{{");

            string indent2 = indent + "    ";
            result.AppendLine($"{indent2}int a = 0;");
            result.AppendLine($"{indent2}int b = 0;");
            int maxN = 100;
            var shuffledFields = cgi.Fields.ToList();
            RandomUtil.ShuffleList(shuffledFields, random);
            foreach (FieldGenerationInfo fgi in shuffledFields)
            {
                result.AppendLine($"{indent2}this.{fgi.name} = reader.{GetReadMethodNameOfType(fgi.type)}();");
                if (random.NextInPercentage(0.5f))
                {
                    result.AppendLine($"{indent2}a = b * {random.NextInt(maxN)} + reader.ReadInt32();");
                    result.AppendLine($"{indent2}b = a * reader.ReadInt32() + {random.NextInt(maxN)};");
                }
                if (random.NextInPercentage(0.5f))
                {
                    result.AppendLine($"{indent2}a += {random.NextInt(0, 10000)};");
                }
                if (random.NextInPercentage(0.5f))
                {
                    result.AppendLine($"{indent2}b += {random.NextInt(0, 10000)};");
                }
            }

            result.AppendLine($"{indent}}}");
        }
    }
}

```

`Editor/GarbageCodeGeneration/ConfigGarbageCodeGenerator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 327cb4a465ff23944a5fea30bf3beeeb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/GarbageCodeGeneration/GarbageCodeGenerator.cs`:

```cs
using Obfuz.Settings;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Obfuz.GarbageCodeGeneration
{

    public class GarbageCodeGenerator
    {
        private const int CodeGenerationSecretKeyLength = 1024;

        private readonly GarbageCodeGenerationSettings _settings;
        private readonly int[] _intGenerationSecretKey;

        public GarbageCodeGenerator(GarbageCodeGenerationSettings settings)
        {
            _settings = settings;

            byte[] byteGenerationSecretKey = KeyGenerator.GenerateKey(settings.codeGenerationSecret, CodeGenerationSecretKeyLength);
            _intGenerationSecretKey = KeyGenerator.ConvertToIntKey(byteGenerationSecretKey);
        }

        public void Generate()
        {
            GenerateTask(_settings.defaultTask);
            if (_settings.additionalTasks != null && _settings.additionalTasks.Length > 0)
            {
                foreach (var task in _settings.additionalTasks)
                {
                    GenerateTask(task);
                }
            }
        }

        public void CleanCodes()
        {
            Debug.Log($"Cleaning generated garbage codes begin.");
            if (_settings.defaultTask != null)
            {
                FileUtil.RemoveDir(_settings.defaultTask.outputPath, true);
            }
            if (_settings.additionalTasks != null && _settings.additionalTasks.Length > 0)
            {
                foreach (var task in _settings.additionalTasks)
                {
                    FileUtil.RemoveDir(task.outputPath, true);
                }
            }
        }

        private void GenerateTask(GarbageCodeGenerationTask task)
        {
            Debug.Log($"Generating garbage code with seed: {task.codeGenerationRandomSeed}, class count: {task.classCount}, method count per class: {task.methodCountPerClass}, types: {task.garbageCodeType}, output path: {task.outputPath}");

            if (string.IsNullOrWhiteSpace(task.outputPath))
            {
                throw new Exception("outputPath of GarbageCodeGenerationTask is empty!");
            }

            var generator = CreateSpecificCodeGenerator(task.garbageCodeType);

            var parameters = new GenerationParameters
            {
                random = new RandomWithKey(_intGenerationSecretKey, task.codeGenerationRandomSeed),
                classNamespace = task.classNamespace,
                classNamePrefix = task.classNamePrefix,
                classCount = task.classCount,
                methodCountPerClass = task.methodCountPerClass,
                fieldCountPerClass = task.fieldCountPerClass,
                outputPath = task.outputPath,
            };
            generator.Generate(parameters);

            Debug.Log($"Generate garbage code end.");
        }

        private ISpecificGarbageCodeGenerator CreateSpecificCodeGenerator(GarbageCodeType type)
        {
            switch (type)
            {
                case GarbageCodeType.Config: return new ConfigGarbageCodeGenerator();
                case GarbageCodeType.UI: return new UIGarbageCodeGenerator();
                default: throw new NotSupportedException($"Garbage code type {type} is not supported.");
            }
        }
    }
}

```

`Editor/GarbageCodeGeneration/GarbageCodeGenerator.cs.meta`:

```meta
fileFormatVersion: 2
guid: ff64fd1e6f7b8874db5a5228fab159f9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/GarbageCodeGeneration/ISpecificGarbageCodeGenerator.cs`:

```cs
using Obfuz.Settings;
using Obfuz.Utils;

namespace Obfuz.GarbageCodeGeneration
{
    public class GenerationParameters
    {
        public IRandom random;

        public string classNamespace;
        public string classNamePrefix;
        public int classCount;
        public int methodCountPerClass;
        public int fieldCountPerClass;
        public string outputPath;
    }

    public interface ISpecificGarbageCodeGenerator
    {
        void Generate(GenerationParameters parameters);
    }
}

```

`Editor/GarbageCodeGeneration/ISpecificGarbageCodeGenerator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 74a17802b5aab2e40a3c89e0ddbcec0d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/GarbageCodeGeneration/SpecificGarbageCodeGeneratorBase.cs`:

```cs
using Obfuz.Utils;
using System.Collections.Generic;
using System.IO;
using System.Text;
using UnityEngine;

namespace Obfuz.GarbageCodeGeneration
{
    public abstract class SpecificGarbageCodeGeneratorBase : ISpecificGarbageCodeGenerator
    {
        protected interface IClassGenerationInfo
        {
            string Namespace { get; set; }

            string Name { get; set; }

            IList<object> Fields { get; set; }

            IList<object> Methods { get; set; }
        }

        protected class ClassGenerationInfo : IClassGenerationInfo
        {
            public string Namespace { get; set; }
            public string Name { get; set; }
            public IList<object> Fields { get; set; } = new List<object>();
            public IList<object> Methods { get; set; } = new List<object>();
        }

        public virtual void Generate(GenerationParameters parameters)
        {
            FileUtil.RecreateDir(parameters.outputPath);

            for (int i = 0; i < parameters.classCount; i++)
            {
                Debug.Log($"[{GetType().Name}] Generating class {i}");
                var localRandom = new RandomWithKey(((RandomWithKey)parameters.random).Key, parameters.random.NextInt());
                string outputFile = $"{parameters.outputPath}/__GeneratedGarbageClass_{i}.cs";
                var result = new StringBuilder(64 * 1024);
                GenerateClass(i, localRandom, result, parameters);
                File.WriteAllText(outputFile, result.ToString(), Encoding.UTF8);
                Debug.Log($"[{GetType().Name}] Generated class {i} to {outputFile}");
            }
        }

        protected abstract object CreateField(int index, IRandom random, GenerationParameters parameters);

        protected abstract object CreateMethod(int index, IRandom random, GenerationParameters parameters);

        protected virtual IClassGenerationInfo CreateClassGenerationInfo(string classNamespace, string className, IRandom random, GenerationParameters parameters)
        {
            var cgi = new ClassGenerationInfo
            {
                Namespace = classNamespace,
                Name = className,
            };

            for (int i = 0; i < parameters.fieldCountPerClass; i++)
            {
                cgi.Fields.Add(CreateField(i, random, parameters));
            }

            for (int i = 0; i < parameters.methodCountPerClass; i++)
            {
                cgi.Methods.Add(CreateMethod(i, random, parameters));
            }

            return cgi;
        }

        protected virtual void GenerateClass(int classIndex, IRandom random, StringBuilder result, GenerationParameters parameters)
        {
            IClassGenerationInfo cgi = CreateClassGenerationInfo(parameters.classNamespace, $"{parameters.classNamePrefix}{classIndex}", random, parameters);
            result.AppendLine("using System;");
            result.AppendLine("using System.Collections.Generic;");
            result.AppendLine("using System.Linq;");
            result.AppendLine("using System.IO;");
            result.AppendLine("using UnityEngine;");

            GenerateUsings(result, cgi);

            result.AppendLine($"namespace {cgi.Namespace}");
            result.AppendLine("{");
            result.AppendLine($"    public class {cgi.Name}");
            result.AppendLine("    {");

            string indent = "        ";
            foreach (object field in cgi.Fields)
            {
                GenerateField(result, cgi, random, field, indent);
            }
            foreach (object method in cgi.Methods)
            {
                GenerateMethod(result, cgi, random, method, indent);
            }
            result.AppendLine("    }");
            result.AppendLine("}");
        }

        protected abstract void GenerateUsings(StringBuilder result, IClassGenerationInfo cgi);

        protected abstract void GenerateField(StringBuilder result, IClassGenerationInfo cgi, IRandom random, object field, string indent);

        protected abstract void GenerateMethod(StringBuilder result, IClassGenerationInfo cgi, IRandom random, object method, string indent);
    }
}

```

`Editor/GarbageCodeGeneration/SpecificGarbageCodeGeneratorBase.cs.meta`:

```meta
fileFormatVersion: 2
guid: bae18fd49482f00439d37f28a6a78d9b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/GarbageCodeGeneration/UIGarbageCodeGenerator.cs`:

```cs
using Obfuz.Utils;
using System;
using System.Linq;
using System.Text;

namespace Obfuz.GarbageCodeGeneration
{

    public class UIGarbageCodeGenerator : SpecificGarbageCodeGeneratorBase
    {
        /*
         * 
         *         public Button b1;
        public Image b2;
        public RawImage b30;
        public Text b3;
        public Slider b4;
        public ScrollRect b5;
        public Scrollbar b6;
        public Mask b7;
        public RectMask2D b70;
        public Canvas b8;
        public CanvasGroup b9;
        public RectTransform b10;
        public Transform b11;
        public GameObject b12;
         */

        private readonly string[] _types = new string[]
        {
            "Button",
            "Image",
            "RawImage",
            "Text",
            "Slider",
            "ScrollRect",
            "Scrollbar",
            "Mask",
            "RectMask2D",
            "Canvas",
            "CanvasGroup",
            "RectTransform",
            //"Transform",
            //"GameObject",
        };

        private string CreateRandomType(IRandom random)
        {
            return _types[random.NextInt(_types.Length)];
        }

        private string GetReadMethodNameOfType(string type)
        {
            switch (type)
            {
                case "bool": return "ReadBoolean";
                case "byte": return "ReadByte";
                case "short": return "ReadInt16";
                case "int": return "ReadInt32";
                case "long": return "ReadInt64";
                case "float": return "ReadSingle";
                case "double": return "ReadDouble";
                default: throw new ArgumentException($"Unsupported type: {type}");
            }
        }
        class FieldGenerationInfo
        {
            public int index;
            public string name;
            public string type;
        }

        class MethodGenerationInfo
        {
            public int index;
            public string name;
        }

        protected override object CreateField(int index, IRandom random, GenerationParameters parameters)
        {
            return new FieldGenerationInfo
            {
                index = index,
                name = $"x{index}",
                type = CreateRandomType(random),
            };
        }

        protected override object CreateMethod(int index, IRandom random, GenerationParameters parameters)
        {
            return new MethodGenerationInfo
            {
                index = index,
                name = $"Init{index}",
            };
        }

        protected override void GenerateUsings(StringBuilder result, IClassGenerationInfo cgi)
        {
            result.AppendLine("using UnityEngine.UI;");
        }

        protected override void GenerateField(StringBuilder result, IClassGenerationInfo cgi, IRandom random, object field, string indent)
        {
            var fgi = (FieldGenerationInfo)field;
            result.AppendLine($"{indent}public {fgi.type} {fgi.name};");
        }

        protected override void GenerateMethod(StringBuilder result, IClassGenerationInfo cgi, IRandom random, object method, string indent)
        {
            var mgi = (MethodGenerationInfo)method;
            result.AppendLine($"{indent}public void {mgi.name}(GameObject go)");
            result.AppendLine($"{indent}{{");

            string indent2 = indent + "    ";
            result.AppendLine($"{indent2}int a = 0;");
            result.AppendLine($"{indent2}int b = 0;");
            int maxN = 100;
            var shuffledFields = cgi.Fields.ToList();
            RandomUtil.ShuffleList(shuffledFields, random);
            foreach (FieldGenerationInfo fgi in shuffledFields)
            {
                if (random.NextInPercentage(0.5f))
                {
                    result.AppendLine($"{indent2}this.{fgi.name} = go.transform.Find(\"ui/{fgi.name}\").GetComponent<{fgi.type}>();");
                }
                else
                {
                    result.AppendLine($"{indent2}this.{fgi.name} = go.GetComponent<{fgi.type}>();");
                }
                if (random.NextInPercentage(0.5f))
                {
                    result.AppendLine($"{indent2}a = b * {random.NextInt(maxN)} + go.layer;");
                    result.AppendLine($"{indent2}b = a * go.layer + {random.NextInt(maxN)};");
                }
                if (random.NextInPercentage(0.5f))
                {
                    result.AppendLine($"{indent2}a *= {random.NextInt(0, 10000)};");
                }
                if (random.NextInPercentage(0.5f))
                {
                    result.AppendLine($"{indent2}b /= {random.NextInt(0, 10000)};");
                }
                if (random.NextInPercentage(0.5f))
                {
                    result.AppendLine($"{indent2}a = a * b << {random.NextInt(0, 10000)};");
                }
                if (random.NextInPercentage(0.5f))
                {
                    result.AppendLine($"{indent2}b = a / b & {random.NextInt(0, 10000)};");
                }
            }

            result.AppendLine($"{indent}}}");
        }
    }
}

```

`Editor/GarbageCodeGeneration/UIGarbageCodeGenerator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 5071c4b9c7f5aef409f3e7fdb45ecd8d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/IObfuscationPass.cs`:

```cs
using Obfuz.ObfusPasses;

namespace Obfuz
{
    public interface IObfuscationPass
    {
        ObfuscationPassType Type { get; }

        void Start();

        void Stop();

        void Process();
    }
}

```

`Editor/IObfuscationPass.cs.meta`:

```meta
fileFormatVersion: 2
guid: b7003f9503025794b8aa775d9ade335c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses.meta`:

```meta
fileFormatVersion: 2
guid: 120b2dcffd582e84dbb92003240824d1
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/BasicBlockObfuscationPassBase.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Emit;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses
{
    public abstract class BasicBlockObfuscationPassBase : ObfuscationMethodPassBase
    {
        protected virtual bool ComputeBlockInLoop => true;

        protected abstract bool TryObfuscateInstruction(MethodDef callingMethod, Instruction inst, BasicBlock block, int instructionIndex,
            IList<Instruction> globalInstructions, List<Instruction> outputInstructions, List<Instruction> totalFinalInstructions);

        protected override void ObfuscateData(MethodDef method)
        {
            BasicBlockCollection bbc = new BasicBlockCollection(method, ComputeBlockInLoop);

            IList<Instruction> instructions = method.Body.Instructions;

            var outputInstructions = new List<Instruction>();
            var totalFinalInstructions = new List<Instruction>();
            for (int i = 0; i < instructions.Count; i++)
            {
                Instruction inst = instructions[i];
                BasicBlock block = bbc.GetBasicBlockByInstruction(inst);
                outputInstructions.Clear();
                if (TryObfuscateInstruction(method, inst, block, i, instructions, outputInstructions, totalFinalInstructions))
                {
                    // current instruction may be the target of control flow instruction, so we can't remove it directly.
                    // we replace it with nop now, then remove it in CleanUpInstructionPass
                    inst.OpCode = outputInstructions[0].OpCode;
                    inst.Operand = outputInstructions[0].Operand;
                    totalFinalInstructions.Add(inst);
                    for (int k = 1; k < outputInstructions.Count; k++)
                    {
                        totalFinalInstructions.Add(outputInstructions[k]);
                    }
                }
                else
                {
                    totalFinalInstructions.Add(inst);
                }
            }

            instructions.Clear();
            foreach (var obInst in totalFinalInstructions)
            {
                instructions.Add(obInst);
            }
        }
    }
}

```

`Editor/ObfusPasses/BasicBlockObfuscationPassBase.cs.meta`:

```meta
fileFormatVersion: 2
guid: ae83aaf003665614092aabceabff3cf8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CallObfus.meta`:

```meta
fileFormatVersion: 2
guid: cf68e45551825c547b137f6e5189937e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CallObfus/CallObfusPass.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Emit;
using Obfuz.Settings;
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.CallObfus
{
    class ObfusMethodContext
    {
        public MethodDef method;
        public LocalVariableAllocator localVariableAllocator;
        public IRandom localRandom;
        public EncryptionScopeInfo encryptionScope;
    }

    public class CallObfusPass : ObfuscationMethodPassBase
    {
        public static CallObfuscationSettingsFacade CurrentSettings { get; private set; }

        private readonly CallObfuscationSettingsFacade _settings;
        private readonly SpecialWhiteListMethodCalculator _specialWhiteListMethodCache;

        private IObfuscator _dynamicProxyObfuscator;
        private IObfuscationPolicy _dynamicProxyPolicy;

        public override ObfuscationPassType Type => ObfuscationPassType.CallObfus;

        public CallObfusPass(CallObfuscationSettingsFacade settings)
        {
            _settings = settings;
            CurrentSettings = settings;

            _specialWhiteListMethodCache = new SpecialWhiteListMethodCalculator(settings.obfuscateCallToMethodInMscorlib);
        }

        public override void Stop()
        {
            _dynamicProxyObfuscator.Done();
        }

        public override void Start()
        {
            var ctx = ObfuscationPassContext.Current;
            _dynamicProxyObfuscator = CreateObfuscator(ctx, _settings.proxyMode);
            _dynamicProxyPolicy = new ConfigurableObfuscationPolicy(ctx.coreSettings.assembliesToObfuscate, _settings.ruleFiles);
        }

        private IObfuscator CreateObfuscator(ObfuscationPassContext ctx, ProxyMode mode)
        {
            switch (mode)
            {
                case ProxyMode.Dispatch:
                    return new DispatchProxyObfuscator(ctx.moduleEntityManager);
                case ProxyMode.Delegate:
                    return new DelegateProxyObfuscator(ctx.moduleEntityManager);
                default:
                throw new System.NotSupportedException($"Unsupported proxy mode: {mode}");
            }
        }

        protected override void ObfuscateData(MethodDef method)
        {
            BasicBlockCollection bbc = new BasicBlockCollection(method, false);

            IList<Instruction> instructions = method.Body.Instructions;

            var outputInstructions = new List<Instruction>();
            var totalFinalInstructions = new List<Instruction>();

            ObfuscationPassContext ctx = ObfuscationPassContext.Current;
            var encryptionScope = ctx.moduleEntityManager.EncryptionScopeProvider.GetScope(method.Module);
            var localRandom = encryptionScope.localRandomCreator(MethodEqualityComparer.CompareDeclaringTypes.GetHashCode(method));
            var omc = new ObfusMethodContext
            {
                method = method,
                localVariableAllocator = new LocalVariableAllocator(method),
                localRandom = localRandom,
                encryptionScope = encryptionScope,
            };
            Instruction lastInst = null;
            for (int i = 0; i < instructions.Count; i++)
            {
                Instruction inst = instructions[i];
                BasicBlock block = bbc.GetBasicBlockByInstruction(inst);
                outputInstructions.Clear();
                if (TryObfuscateInstruction(method, lastInst, inst, outputInstructions, omc))
                {
                    // current instruction may be the target of control flow instruction, so we can't remove it directly.
                    // we replace it with nop now, then remove it in CleanUpInstructionPass
                    inst.OpCode = outputInstructions[0].OpCode;
                    inst.Operand = outputInstructions[0].Operand;
                    totalFinalInstructions.Add(inst);
                    for (int k = 1; k < outputInstructions.Count; k++)
                    {
                        totalFinalInstructions.Add(outputInstructions[k]);
                    }
                }
                else
                {
                    totalFinalInstructions.Add(inst);
                }
                lastInst = inst;
            }

            instructions.Clear();
            foreach (var obInst in totalFinalInstructions)
            {
                instructions.Add(obInst);
            }
        }

        protected override bool NeedObfuscateMethod(MethodDef method)
        {
            return _dynamicProxyPolicy.NeedObfuscateCallInMethod(method);
        }

        private bool TryObfuscateInstruction(MethodDef callerMethod, Instruction lastInst, Instruction inst, List<Instruction> outputInstructions, ObfusMethodContext ctx)
        {
            IMethod calledMethod = inst.Operand as IMethod;
            if (calledMethod == null || !calledMethod.IsMethod)
            {
                return false;
            }
            if (MetaUtil.ContainsContainsGenericParameter(calledMethod))
            {
                return false;
            }

            bool callVir;
            switch (inst.OpCode.Code)
            {
                case Code.Call:
                {
                    callVir = false;
                    break;
                }
                case Code.Callvirt:
                {
                    if (lastInst != null && lastInst.OpCode.Code == Code.Constrained)
                    {
                        return false;
                    }
                    callVir = true;
                    break;
                }
                default: return false;
            }


            if (_specialWhiteListMethodCache.IsInWhiteList(calledMethod))
            {
                return false;
            }


            if (!_dynamicProxyPolicy.NeedObfuscateCalledMethod(callerMethod, calledMethod, callVir))
            {
                return false;
            }

            return _dynamicProxyObfuscator.Obfuscate(callerMethod, calledMethod, callVir, outputInstructions);
        }
    }
}

```

`Editor/ObfusPasses/CallObfus/CallObfusPass.cs.meta`:

```meta
fileFormatVersion: 2
guid: 112178b770868274fb8119a4997a3420
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CallObfus/ConfigurableObfuscationPolicy.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Conf;
using Obfuz.Settings;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Xml;

namespace Obfuz.ObfusPasses.CallObfus
{
    public class ConfigurableObfuscationPolicy : ObfuscationPolicyBase
    {
        class WhiteListAssembly
        {
            public string name;
            public NameMatcher nameMatcher;
            public bool? obfuscate;
            public List<WhiteListType> types = new List<WhiteListType>();
        }

        class WhiteListType
        {
            public string name;
            public NameMatcher nameMatcher;
            public bool? obfuscate;
            public List<WhiteListMethod> methods = new List<WhiteListMethod>();
        }

        class WhiteListMethod
        {
            public string name;
            public NameMatcher nameMatcher;
            public bool? obfuscate;
        }

        class ObfuscationRule : IRule<ObfuscationRule>
        {
            public ObfuscationLevel? obfuscationLevel;

            public void InheritParent(ObfuscationRule parentRule)
            {
                if (obfuscationLevel == null)
                    obfuscationLevel = parentRule.obfuscationLevel;
            }
        }

        class AssemblySpec : AssemblyRuleBase<TypeSpec, MethodSpec, ObfuscationRule>
        {
        }

        class TypeSpec : TypeRuleBase<MethodSpec, ObfuscationRule>
        {
        }

        class MethodSpec : MethodRuleBase<ObfuscationRule>
        {

        }

        private static readonly ObfuscationRule s_default = new ObfuscationRule()
        {
            obfuscationLevel = ObfuscationLevel.Basic,
        };

        private readonly XmlAssemblyTypeMethodRuleParser<AssemblySpec, TypeSpec, MethodSpec, ObfuscationRule> _configParser;

        private ObfuscationRule _global;
        private readonly List<WhiteListAssembly> _whiteListAssemblies = new List<WhiteListAssembly>();

        private readonly CachedDictionary<IMethod, bool> _whiteListMethodCache;
        private readonly Dictionary<MethodDef, ObfuscationRule> _methodRuleCache = new Dictionary<MethodDef, ObfuscationRule>();

        public ConfigurableObfuscationPolicy(List<string> toObfuscatedAssemblyNames, List<string> xmlConfigFiles)
        {
            _whiteListMethodCache = new CachedDictionary<IMethod, bool>(MethodEqualityComparer.CompareDeclaringTypes, this.ComputeIsInWhiteList);
            _configParser = new XmlAssemblyTypeMethodRuleParser<AssemblySpec, TypeSpec, MethodSpec, ObfuscationRule>(toObfuscatedAssemblyNames,
                ParseObfuscationRule, ParseGlobalElement);
            LoadConfigs(xmlConfigFiles);
        }

        private void LoadConfigs(List<string> configFiles)
        {
            _configParser.LoadConfigs(configFiles);

            if (_global == null)
            {
                _global = s_default;
            }
            else
            {
                _global.InheritParent(s_default);
            }
            _configParser.InheritParentRules(_global);
            InheritWhitelistRules();
        }

        private void InheritWhitelistRules()
        {
            foreach (var ass in _whiteListAssemblies)
            {
                foreach (var type in ass.types)
                {
                    if (type.obfuscate == null)
                    {
                        type.obfuscate = ass.obfuscate;
                    }
                    foreach (var method in type.methods)
                    {
                        if (method.obfuscate == null)
                        {
                            method.obfuscate = type.obfuscate;
                        }
                    }
                }
            }
        }

        private void ParseGlobalElement(string configFile, XmlElement ele)
        {
            switch (ele.Name)
            {
                case "global": _global = ParseObfuscationRule(configFile, ele); break;
                case "whitelist": ParseWhitelist(ele); break;
                default: throw new Exception($"Invalid xml file {configFile}, unknown node {ele.Name}");
            }
        }

        private ObfuscationRule ParseObfuscationRule(string configFile, XmlElement ele)
        {
            var rule = new ObfuscationRule();
            if (ele.HasAttribute("obfuscationLevel"))
            {
                rule.obfuscationLevel = ConfigUtil.ParseObfuscationLevel(ele.GetAttribute("obfuscationLevel"));
            }
            return rule;
        }

        private void ParseWhitelist(XmlElement ruleEle)
        {
            foreach (XmlNode xmlNode in ruleEle.ChildNodes)
            {
                if (!(xmlNode is XmlElement childEle))
                {
                    continue;
                }
                switch (childEle.Name)
                {
                    case "assembly":
                    {
                        var ass = ParseWhiteListAssembly(childEle);
                        _whiteListAssemblies.Add(ass);
                        break;
                    }
                    default: throw new Exception($"Invalid xml file, unknown node {childEle.Name}");
                }
            }
        }

        private WhiteListAssembly ParseWhiteListAssembly(XmlElement element)
        {
            var ass = new WhiteListAssembly();
            ass.name = element.GetAttribute("name");
            ass.nameMatcher = new NameMatcher(ass.name);

            ass.obfuscate = ConfigUtil.ParseNullableBool(element.GetAttribute("obfuscate")) ?? false;

            foreach (XmlNode node in element.ChildNodes)
            {
                if (!(node is XmlElement ele))
                {
                    continue;
                }
                switch (ele.Name)
                {
                    case "type":
                    ass.types.Add(ParseWhiteListType(ele));
                    break;
                    default:
                    throw new Exception($"Invalid xml file, unknown node {ele.Name}");
                }
            }
            return ass;
        }

        private WhiteListType ParseWhiteListType(XmlElement element)
        {
            var type = new WhiteListType();
            type.name = element.GetAttribute("name");
            type.nameMatcher = new NameMatcher(type.name);
            type.obfuscate = ConfigUtil.ParseNullableBool(element.GetAttribute("obfuscate"));

            foreach (XmlNode node in element.ChildNodes)
            {
                if (!(node is XmlElement ele))
                {
                    continue;
                }
                switch (ele.Name)
                {
                    case "method":
                    {
                        type.methods.Add(ParseWhiteListMethod(ele));
                        break;
                    }
                    default: throw new Exception($"Invalid xml file, unknown node {ele.Name}");
                }
            }

            return type;
        }

        private WhiteListMethod ParseWhiteListMethod(XmlElement element)
        {
            var method = new WhiteListMethod();
            method.name = element.GetAttribute("name");
            method.nameMatcher = new NameMatcher(method.name);
            method.obfuscate = ConfigUtil.ParseNullableBool(element.GetAttribute("obfuscate"));
            return method;
        }

        private ObfuscationRule GetMethodObfuscationRule(MethodDef method)
        {
            if (!_methodRuleCache.TryGetValue(method, out var rule))
            {
                rule = _configParser.GetMethodRule(method, _global);
                _methodRuleCache[method] = rule;
            }
            return rule;
        }

        public override bool NeedObfuscateCallInMethod(MethodDef method)
        {
            ObfuscationRule rule = GetMethodObfuscationRule(method);
            return rule.obfuscationLevel != null && rule.obfuscationLevel.Value >= ObfuscationLevel.Basic;
        }

        private bool ComputeIsInWhiteList(IMethod calledMethod)
        {
            ITypeDefOrRef declaringType = calledMethod.DeclaringType;
            TypeSig declaringTypeSig = calledMethod.DeclaringType.ToTypeSig();
            declaringTypeSig = declaringTypeSig.RemovePinnedAndModifiers();
            switch (declaringTypeSig.ElementType)
            {
                case ElementType.ValueType:
                case ElementType.Class:
                {
                    break;
                }
                case ElementType.GenericInst:
                {
                    if (MetaUtil.ContainsContainsGenericParameter(calledMethod))
                    {
                        return true;
                    }
                    break;
                }
                default: return true;
            }

            TypeDef typeDef = declaringType.ResolveTypeDef();

            string assName = typeDef.Module.Assembly.Name;
            string typeFullName = typeDef.FullName;
            string methodName = calledMethod.Name;
            foreach (var ass in _whiteListAssemblies)
            {
                if (!ass.nameMatcher.IsMatch(assName))
                {
                    continue;
                }
                foreach (var type in ass.types)
                {
                    if (!type.nameMatcher.IsMatch(typeFullName))
                    {
                        continue;
                    }
                    foreach (var method in type.methods)
                    {
                        if (method.nameMatcher.IsMatch(methodName))
                        {
                            return !method.obfuscate.Value;
                        }
                    }
                    return !type.obfuscate.Value;
                }
                return !ass.obfuscate.Value;
            }
            return false;
        }

        public override bool NeedObfuscateCalledMethod(MethodDef callerMethod, IMethod calledMethod, bool callVir)
        {
            if (_whiteListMethodCache.GetValue(calledMethod))
            {
                return false;
            }
            return true;
        }
    }
}

```

`Editor/ObfusPasses/CallObfus/ConfigurableObfuscationPolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: d9ea12b16c4b296459db8a60fb1615d6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CallObfus/DelegateProxyAllocator.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Data;
using Obfuz.Emit;
using Obfuz.Settings;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Obfuz.ObfusPasses.CallObfus
{

    struct DelegateProxyMethodData
    {
        public readonly FieldDef delegateInstanceField;
        public readonly MethodDef delegateInvokeMethod;

        public DelegateProxyMethodData(FieldDef delegateInstanceField, MethodDef delegateInvokeMethod)
        {
            this.delegateInstanceField = delegateInstanceField;
            this.delegateInvokeMethod = delegateInvokeMethod;
        }
    }

    class DelegateProxyAllocator : GroupByModuleEntityBase
    {
        private readonly CachedDictionary<MethodSig, TypeDef> _delegateTypes;
        private readonly HashSet<string> _allocatedDelegateNames = new HashSet<string>();

        private TypeDef _delegateInstanceHolderType;
        private bool _done;

        class CallInfo
        {
            public string key1;
            public int key2;
            public IMethod method;
            public bool callVir;

            public int index;
            public TypeDef delegateType;
            public FieldDef delegateInstanceField;
            public MethodDef delegateInvokeMethod;
            public MethodDef proxyMethod;
        }
        private readonly Dictionary<MethodKey, CallInfo> _callMethods = new Dictionary<MethodKey, CallInfo>();

        public DelegateProxyAllocator()
        {
            _delegateTypes = new CachedDictionary<MethodSig, TypeDef>(SignatureEqualityComparer.Instance, CreateDelegateForSignature);
        }

        public override void Init()
        {
            _delegateInstanceHolderType = CreateDelegateInstanceHolderTypeDef();
        }

        private string AllocateDelegateTypeName(MethodSig delegateInvokeSig)
        {
            uint hashCode = (uint)SignatureEqualityComparer.Instance.GetHashCode(delegateInvokeSig);
            string typeName = $"$Obfuz$Delegate_{hashCode}";
            if (_allocatedDelegateNames.Add(typeName))
            {
                return typeName;
            }
            for (int i = 0; ;i++)
            {
                typeName = $"$Obfuz$Delegate_{hashCode}_{i}";
                if (_allocatedDelegateNames.Add(typeName))
                {
                    return typeName;
                }
            }
        }

        private TypeDef CreateDelegateForSignature(MethodSig delegateInvokeSig)
        {
            ModuleDef mod = Module;
            using (var scope = new DisableTypeDefFindCacheScope(mod))
            {

                string typeName = AllocateDelegateTypeName(delegateInvokeSig);
                mod.Import(typeof(MulticastDelegate));

                TypeDef delegateType = new TypeDefUser("", typeName, mod.CorLibTypes.GetTypeRef("System", "MulticastDelegate"));
                delegateType.Attributes = TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.Public;
                mod.Types.Add(delegateType);

                MethodDef ctor = new MethodDefUser(
                    ".ctor",
                    MethodSig.CreateInstance(mod.CorLibTypes.Void, mod.CorLibTypes.Object, mod.CorLibTypes.IntPtr),
                    MethodImplAttributes.Runtime,
                    MethodAttributes.RTSpecialName | MethodAttributes.SpecialName | MethodAttributes.HideBySig | MethodAttributes.Public
                );
                ctor.DeclaringType = delegateType;


                MethodDef invokeMethod = new MethodDefUser(
                    "Invoke",
                    MethodSig.CreateInstance(delegateInvokeSig.RetType, delegateInvokeSig.Params.ToArray()),
                    MethodImplAttributes.Runtime,
                    MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.NewSlot | MethodAttributes.Virtual
                );
                invokeMethod.DeclaringType = delegateType;
                return delegateType;
            }
        }

        private TypeDef CreateDelegateInstanceHolderTypeDef()
        {
            ModuleDef mod = Module;
            using (var scope = new DisableTypeDefFindCacheScope(mod))
            {
                string typeName = "$Obfuz$DelegateInstanceHolder";
                TypeDef holderType = new TypeDefUser("", typeName, mod.CorLibTypes.Object.ToTypeDefOrRef());
                holderType.Attributes = TypeAttributes.Class | TypeAttributes.Public;
                mod.Types.Add(holderType);
                return holderType;
            }
        }

        private string AllocateFieldName(IMethod method, bool callVir)
        {
            uint hashCode = (uint)MethodEqualityComparer.CompareDeclaringTypes.GetHashCode(method);
            string typeName = $"$Obfuz$Delegate$Field_{hashCode}_{callVir}";
            if (_allocatedDelegateNames.Add(typeName))
            {
                return typeName;
            }
            for (int i = 0; ; i++)
            {
                typeName = $"$Obfuz$Delegate$Field_{hashCode}_{callVir}_{i}";
                if (_allocatedDelegateNames.Add(typeName))
                {
                    return typeName;
                }
            }
        }

        private MethodDef CreateProxyMethod(string name, IMethod calledMethod, bool callVir, MethodSig delegateInvokeSig)
        {
            var proxyMethod = new MethodDefUser(name, delegateInvokeSig, MethodImplAttributes.Managed, MethodAttributes.Public | MethodAttributes.Static);
            var body = new CilBody();
            proxyMethod.Body = body;
            var ins = body.Instructions;

            foreach (Parameter param in proxyMethod.Parameters)
            {
                ins.Add(Instruction.Create(OpCodes.Ldarg, param));
            }

            ins.Add(Instruction.Create(callVir ? OpCodes.Callvirt : OpCodes.Call, calledMethod));
            ins.Add(Instruction.Create(OpCodes.Ret));
            return proxyMethod;
        }

        public DelegateProxyMethodData Allocate(IMethod method, bool callVir, MethodSig delegateInvokeSig)
        {
            var key = new MethodKey(method, callVir);
            if (!_callMethods.TryGetValue(key, out var callInfo))
            {
                TypeDef delegateType = _delegateTypes.GetValue(delegateInvokeSig);
                MethodDef delegateInvokeMethod = delegateType.FindMethod("Invoke");
                string fieldName = AllocateFieldName(method, callVir);
                FieldDef delegateInstanceField = new FieldDefUser(fieldName, new FieldSig(delegateType.ToTypeSig()), FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.InitOnly);
                string key1 = $"{method.FullName}_{callVir}";
                callInfo = new CallInfo
                {
                    key1 = key1,
                    key2 = HashUtil.ComputePrimitiveOrStringOrBytesHashCode(key1) * 33445566,
                    method = method,
                    callVir = callVir,
                    delegateType = delegateType,
                    delegateInstanceField = delegateInstanceField,
                    delegateInvokeMethod = delegateInvokeMethod,
                    proxyMethod = CreateProxyMethod($"{fieldName}$Proxy", method, callVir, delegateInvokeSig),
                };
                _callMethods.Add(key, callInfo);
            }
            return new DelegateProxyMethodData(callInfo.delegateInstanceField, callInfo.delegateInvokeMethod);
        }

        public override void Done()
        {
            if (_done)
            {
                throw new Exception("Already done");
            }
            _done = true;

            ModuleDef mod = Module;

            // for stable order, we sort methods by name
            List<CallInfo> callMethodList = _callMethods.Values.ToList();
            callMethodList.Sort((a, b) => a.key1.CompareTo(b.key1));

            var cctor = new MethodDefUser(".cctor",
                MethodSig.CreateStatic(mod.CorLibTypes.Void),
                MethodImplAttributes.IL | MethodImplAttributes.Managed,
                MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName | MethodAttributes.Private);
            cctor.DeclaringType = _delegateInstanceHolderType;
            //_rvaTypeDef.Methods.Add(cctor);
            var body = new CilBody();
            cctor.Body = body;
            var ins = body.Instructions;

            // var arr = new array[];
            // var d = new delegate;
            // arr[index] = d;
            int index = 0;
            ins.Add(Instruction.CreateLdcI4(callMethodList.Count));
            ins.Add(Instruction.Create(OpCodes.Newarr, mod.CorLibTypes.Object));
            foreach (CallInfo ci in callMethodList)
            {
                ci.index = index;
                _delegateInstanceHolderType.Methods.Add(ci.proxyMethod);
                ins.Add(Instruction.Create(OpCodes.Dup));
                ins.Add(Instruction.CreateLdcI4(index));
                ins.Add(Instruction.Create(OpCodes.Ldnull));
                ins.Add(Instruction.Create(OpCodes.Ldftn, ci.proxyMethod));
                MethodDef ctor = ci.delegateType.FindMethod(".ctor");
                UnityEngine.Assertions.Assert.IsNotNull(ctor, $"Delegate type {ci.delegateType.FullName} does not have a constructor.");
                ins.Add(Instruction.Create(OpCodes.Newobj, ctor));
                ins.Add(Instruction.Create(OpCodes.Stelem_Ref));
                ++index;
            }



            List<CallInfo> callMethodList2 = callMethodList.ToList();
            callMethodList2.Sort((a, b) => a.key2.CompareTo(b.key2));

            EncryptionScopeInfo encryptionScope = EncryptionScope;
            DefaultMetadataImporter importer = this.GetDefaultModuleMetadataImporter();
            RvaDataAllocator rvaDataAllocator = this.GetEntity<RvaDataAllocator>();
            foreach (CallInfo ci in callMethodList2)
            {
                _delegateInstanceHolderType.Fields.Add(ci.delegateInstanceField);


                ins.Add(Instruction.Create(OpCodes.Dup));

                IRandom localRandom = encryptionScope.localRandomCreator(HashUtil.ComputePrimitiveOrStringOrBytesHashCode(ci.key1));
                int ops = EncryptionUtil.GenerateEncryptionOpCodes(localRandom, encryptionScope.encryptor, 4);
                int salt = localRandom.NextInt();

                int encryptedValue = encryptionScope.encryptor.Encrypt(ci.index, ops, salt);
                RvaData rvaData = rvaDataAllocator.Allocate(encryptedValue);
                ins.Add(Instruction.Create(OpCodes.Ldsfld, rvaData.field));
                ins.Add(Instruction.CreateLdcI4(rvaData.offset));
                ins.Add(Instruction.CreateLdcI4(ops));
                ins.Add(Instruction.CreateLdcI4(salt));
                ins.Add(Instruction.Create(OpCodes.Call, importer.DecryptFromRvaInt));
                ins.Add(Instruction.Create(OpCodes.Ldelem_Ref));
                ins.Add(Instruction.Create(OpCodes.Stsfld, ci.delegateInstanceField));
            }

            ins.Add(Instruction.Create(OpCodes.Pop));
            ins.Add(Instruction.Create(OpCodes.Ret));
        }
    }
}

```

`Editor/ObfusPasses/CallObfus/DelegateProxyAllocator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 02761bacbed8a8b489ae3e7f49f0f84a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CallObfus/DelegateProxyObfuscator.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Data;
using Obfuz.Emit;
using Obfuz.Settings;
using Obfuz.Utils;
using System.Collections.Generic;
using System.Linq;

namespace Obfuz.ObfusPasses.CallObfus
{

    public class DelegateProxyObfuscator : ObfuscatorBase
    {
        private readonly GroupByModuleEntityManager _entityManager;

        public DelegateProxyObfuscator(GroupByModuleEntityManager moduleEntityManager)
        {
            _entityManager = moduleEntityManager;
        }

        public override void Done()
        {
            _entityManager.Done<DelegateProxyAllocator>();
        }

        private MethodSig CreateProxyMethodSig(ModuleDef module, IMethod method)
        {
            MethodSig methodSig = MetaUtil.ToSharedMethodSig(module.CorLibTypes, MetaUtil.GetInflatedMethodSig(method, null));
            //MethodSig methodSig = MetaUtil.GetInflatedMethodSig(method).Clone();
            //methodSig.Params
            switch (MetaUtil.GetThisArgType(method))
            {
                case ThisArgType.Class:
                {
                    methodSig.Params.Insert(0, module.CorLibTypes.Object);
                    break;
                }
                case ThisArgType.ValueType:
                {
                    methodSig.Params.Insert(0, module.CorLibTypes.IntPtr);
                    break;
                }
            }
            return MethodSig.CreateStatic(methodSig.RetType, methodSig.Params.ToArray());
        }

        public override bool Obfuscate(MethodDef callingMethod, IMethod calledMethod, bool callVir, List<Instruction> obfuscatedInstructions)
        {
            DelegateProxyAllocator allocator = _entityManager.GetEntity<DelegateProxyAllocator>(callingMethod.Module);
            LocalVariableAllocator localVarAllocator = new LocalVariableAllocator(callingMethod);
            MethodSig methodSig = CreateProxyMethodSig(callingMethod.Module, calledMethod);
            DelegateProxyMethodData proxyData = allocator.Allocate(calledMethod, callVir, methodSig);
            bool isVoidReturn = MetaUtil.IsVoidType(methodSig.RetType);

            using (var varScope = localVarAllocator.CreateScope())
            {
                List<Local> localVars = new List<Local>();
                if (!isVoidReturn)
                {
                    varScope.AllocateLocal(methodSig.RetType);
                }
                foreach (var p in methodSig.Params)
                {
                    localVars.Add(varScope.AllocateLocal(p));
                }
                // save args
                for (int i = localVars.Count - 1; i >= 0; i--)
                {
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Stloc, localVars[i]));
                }
                obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, proxyData.delegateInstanceField));
                foreach (var local in localVars)
                {
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldloc, local));
                }
                obfuscatedInstructions.Add(Instruction.Create(OpCodes.Callvirt, proxyData.delegateInvokeMethod));
            }

            return true;
        }
    }
}

```

`Editor/ObfusPasses/CallObfus/DelegateProxyObfuscator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 1102cd9f03de27c4b9fde3d6a87277c7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CallObfus/DispatchProxyAllocator.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Editor;
using Obfuz.Emit;
using Obfuz.Settings;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using MethodImplAttributes = dnlib.DotNet.MethodImplAttributes;
using TypeAttributes = dnlib.DotNet.TypeAttributes;

namespace Obfuz.ObfusPasses.CallObfus
{

    public struct ProxyCallMethodData
    {
        public readonly MethodDef proxyMethod;
        public readonly int encryptOps;
        public readonly int salt;
        public readonly int encryptedIndex;
        public readonly int index;

        public ProxyCallMethodData(MethodDef proxyMethod, int encryptOps, int salt, int encryptedIndex, int index)
        {
            this.proxyMethod = proxyMethod;
            this.encryptOps = encryptOps;
            this.salt = salt;
            this.encryptedIndex = encryptedIndex;
            this.index = index;
        }
    }

    class ModuleDispatchProxyAllocator : GroupByModuleEntityBase
    {
        private bool _done;
        private CallObfuscationSettingsFacade _settings;


        class MethodProxyInfo
        {
            public MethodDef proxyMethod;

            public int index;
            public int encryptedOps;
            public int salt;
            public int encryptedIndex;
        }

        private readonly Dictionary<MethodKey, MethodProxyInfo> _methodProxys = new Dictionary<MethodKey, MethodProxyInfo>();

        class CallInfo
        {
            public string id;
            public IMethod method;
            public bool callVir;
        }

        class DispatchMethodInfo
        {
            public MethodDef methodDef;
            public List<CallInfo> methods = new List<CallInfo>();
        }

        private readonly Dictionary<MethodSig, List<DispatchMethodInfo>> _dispatchMethods = new Dictionary<MethodSig, List<DispatchMethodInfo>>(SignatureEqualityComparer.Instance);


        private TypeDef _proxyTypeDef;

        public ModuleDispatchProxyAllocator()
        {
        }

        public override void Init()
        {
            _settings = CallObfusPass.CurrentSettings;
        }

        private TypeDef CreateProxyTypeDef()
        {
            ModuleDef mod = Module;
            using (var scope = new DisableTypeDefFindCacheScope(mod))
            {
                var typeDef = new TypeDefUser($"{ConstValues.ObfuzInternalSymbolNamePrefix}ProxyCall", mod.CorLibTypes.Object.ToTypeDefOrRef());
                typeDef.Attributes = TypeAttributes.NotPublic | TypeAttributes.Sealed;
                mod.Types.Add(typeDef);
                return typeDef;
            }
        }

        private readonly HashSet<string> _uniqueMethodNames = new HashSet<string>();


        private string ToUniqueMethodName(string originalName)
        {
            if (_uniqueMethodNames.Add(originalName))
            {
                return originalName;
            }
            for (int index = 1; ; index++)
            {
                string uniqueName = $"{originalName}${index}";
                if (_uniqueMethodNames.Add(uniqueName))
                {
                    return uniqueName;
                }
            }
        }

        private string CreateDispatchMethodName(MethodSig methodSig, int index)
        {
            // use a stable name for the dispatch method, so that we can reuse it across different modules
            // this is important for cross-module calls
            return ToUniqueMethodName($"{ConstValues.ObfuzInternalSymbolNamePrefix}Dispatch_{HashUtil.ComputeHash(methodSig.Params) & 0xFFFF}_{HashUtil.ComputeHash(methodSig.RetType) & 0xFFFFFF}");
        }

        private MethodDef CreateDispatchMethodInfo(MethodSig methodSig, int index)
        {
            if (_proxyTypeDef == null)
            {
                _proxyTypeDef = CreateProxyTypeDef();
            }
            MethodDef methodDef = new MethodDefUser(CreateDispatchMethodName(methodSig, index), methodSig,
                MethodImplAttributes.IL | MethodImplAttributes.Managed,
                MethodAttributes.Static | MethodAttributes.Public);
            methodDef.DeclaringType = _proxyTypeDef;
            return methodDef;
        }

        private MethodSig CreateDispatchMethodSig(IMethod method)
        {
            ModuleDef mod = Module;
            MethodSig methodSig = MetaUtil.ToSharedMethodSig(mod.CorLibTypes, MetaUtil.GetInflatedMethodSig(method, null));
            //MethodSig methodSig = MetaUtil.GetInflatedMethodSig(method).Clone();
            //methodSig.Params
            switch (MetaUtil.GetThisArgType(method))
            {
                case ThisArgType.Class:
                {
                    methodSig.Params.Insert(0, mod.CorLibTypes.Object);
                    break;
                }
                case ThisArgType.ValueType:
                {
                    methodSig.Params.Insert(0, mod.CorLibTypes.IntPtr);
                    break;
                }
            }
            // extra param for index
            methodSig.Params.Add(mod.CorLibTypes.Int32);
            return MethodSig.CreateStatic(methodSig.RetType, methodSig.Params.ToArray());
        }

        private int GenerateSalt(IRandom random)
        {
            return random.NextInt();
        }

        private int GenerateEncryptOps(IRandom random)
        {
            return EncryptionUtil.GenerateEncryptionOpCodes(random, EncryptionScope.encryptor, _settings.obfuscationLevel);
        }

        private DispatchMethodInfo GetDispatchMethod(IMethod method)
        {
            MethodSig methodSig = CreateDispatchMethodSig(method);
            if (!_dispatchMethods.TryGetValue(methodSig, out var dispatchMethods))
            {
                dispatchMethods = new List<DispatchMethodInfo>();
                _dispatchMethods.Add(methodSig, dispatchMethods);
            }
            if (dispatchMethods.Count == 0 || dispatchMethods.Last().methods.Count >= _settings.maxProxyMethodCountPerDispatchMethod)
            {
                var newDispatchMethodInfo = new DispatchMethodInfo
                {
                    methodDef = CreateDispatchMethodInfo(methodSig, dispatchMethods.Count),
                };
                dispatchMethods.Add(newDispatchMethodInfo);
            }
            return dispatchMethods.Last();
        }

        private IRandom CreateRandomForMethod(IMethod method, bool callVir)
        {
            int seed = MethodEqualityComparer.CompareDeclaringTypes.GetHashCode(method);
            return EncryptionScope.localRandomCreator(seed);
        }

        public ProxyCallMethodData Allocate(IMethod method, bool callVir)
        {
            if (_done)
            {
                throw new Exception("can't Allocate after done");
            }
            var key = new MethodKey(method, callVir);
            if (!_methodProxys.TryGetValue(key, out var proxyInfo))
            {
                var methodDispatcher = GetDispatchMethod(method);

                int index = methodDispatcher.methods.Count;
                IRandom localRandom = CreateRandomForMethod(method, callVir);
                int encryptOps = GenerateEncryptOps(localRandom);
                int salt = GenerateSalt(localRandom);
                int encryptedIndex = EncryptionScope.encryptor.Encrypt(index, encryptOps, salt);
                proxyInfo = new MethodProxyInfo()
                {
                    proxyMethod = methodDispatcher.methodDef,
                    index = index,
                    encryptedOps = encryptOps,
                    salt = salt,
                    encryptedIndex = encryptedIndex,
                };
                methodDispatcher.methods.Add(new CallInfo { id = $"{method}{(callVir ? "" : "v")}", method = method, callVir = callVir });
                _methodProxys.Add(key, proxyInfo);
            }
            return new ProxyCallMethodData(proxyInfo.proxyMethod, proxyInfo.encryptedOps, proxyInfo.salt, proxyInfo.encryptedIndex, proxyInfo.index);
        }

        public override void Done()
        {
            if (_done)
            {
                throw new Exception("Already done");
            }
            _done = true;
            if (_proxyTypeDef == null)
            {
                return;
            }

            // for stable order, we sort methods by name
            var methodWithNamePairList = _proxyTypeDef.Methods.Select(m => (m, m.ToString())).ToList();
            methodWithNamePairList.Sort((a, b) => a.Item2.CompareTo(b.Item2));
            _proxyTypeDef.Methods.Clear();
            foreach (var methodPair in methodWithNamePairList)
            {
                methodPair.Item1.DeclaringType = _proxyTypeDef;
            }

            foreach (DispatchMethodInfo dispatchMethod in _dispatchMethods.Values.SelectMany(ms => ms))
            {
                var methodDef = dispatchMethod.methodDef;
                var methodSig = methodDef.MethodSig;


                var body = new CilBody();
                methodDef.Body = body;
                var ins = body.Instructions;

                foreach (Parameter param in methodDef.Parameters)
                {
                    ins.Add(Instruction.Create(OpCodes.Ldarg, param));
                }

                var switchCases = new List<Instruction>();
                var switchInst = Instruction.Create(OpCodes.Switch, switchCases);
                ins.Add(switchInst);
                var ret = Instruction.Create(OpCodes.Ret);

                // sort methods by signature to ensure stable order
                //dispatchMethod.methods.Sort((a, b) => a.id.CompareTo(b.id));
                foreach (CallInfo ci in dispatchMethod.methods)
                {
                    var callTargetMethod = Instruction.Create(ci.callVir ? OpCodes.Callvirt : OpCodes.Call, ci.method);
                    switchCases.Add(callTargetMethod);
                    ins.Add(callTargetMethod);
                    ins.Add(Instruction.Create(OpCodes.Br, ret));
                }
                ins.Add(ret);
            }
        }
    }
}

```

`Editor/ObfusPasses/CallObfus/DispatchProxyAllocator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 16b960455f093854d927c2dbd47a4826
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CallObfus/DispatchProxyObfuscator.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Data;
using Obfuz.Emit;
using Obfuz.Settings;
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.CallObfus
{

    public class DispatchProxyObfuscator : ObfuscatorBase
    {
        private readonly GroupByModuleEntityManager _moduleEntityManager;

        public DispatchProxyObfuscator(GroupByModuleEntityManager moduleEntityManager)
        {
            _moduleEntityManager = moduleEntityManager;
        }

        public override void Done()
        {
            _moduleEntityManager.Done<ModuleDispatchProxyAllocator>();
        }

        public override bool Obfuscate(MethodDef callerMethod, IMethod calledMethod, bool callVir, List<Instruction> obfuscatedInstructions)
        {
            ModuleDispatchProxyAllocator proxyCallAllocator = _moduleEntityManager.GetEntity<ModuleDispatchProxyAllocator>(callerMethod.Module);
            MethodSig sharedMethodSig = MetaUtil.ToSharedMethodSig(calledMethod.Module.CorLibTypes, MetaUtil.GetInflatedMethodSig(calledMethod, null));
            ProxyCallMethodData proxyCallMethodData = proxyCallAllocator.Allocate(calledMethod, callVir);
            DefaultMetadataImporter importer = proxyCallAllocator.GetDefaultModuleMetadataImporter();

            //if (needCacheCall)
            //{
            //    FieldDef cacheField = _constFieldAllocator.Allocate(callerMethod.Module, proxyCallMethodData.index);
            //    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, cacheField));
            //}
            //else
            //{
            //    obfuscatedInstructions.Add(Instruction.CreateLdcI4(proxyCallMethodData.encryptedIndex));
            //    obfuscatedInstructions.Add(Instruction.CreateLdcI4(proxyCallMethodData.encryptOps));
            //    obfuscatedInstructions.Add(Instruction.CreateLdcI4(proxyCallMethodData.salt));
            //    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Call, importer.DecryptInt));
            //}

            ConstFieldAllocator constFieldAllocator = proxyCallAllocator.GetEntity<ConstFieldAllocator>();
            FieldDef cacheField = constFieldAllocator.Allocate(proxyCallMethodData.index);
            obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, cacheField));
            obfuscatedInstructions.Add(Instruction.Create(OpCodes.Call, proxyCallMethodData.proxyMethod));
            return true;
        }
    }
}

```

`Editor/ObfusPasses/CallObfus/DispatchProxyObfuscator.cs.meta`:

```meta
fileFormatVersion: 2
guid: e13ba01b03439e049af0e09367825cde
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CallObfus/IObfuscationPolicy.cs`:

```cs
using dnlib.DotNet;

namespace Obfuz.ObfusPasses.CallObfus
{

    public interface IObfuscationPolicy
    {
        bool NeedObfuscateCallInMethod(MethodDef method);

        bool NeedObfuscateCalledMethod(MethodDef callerMethod, IMethod calledMethod, bool callVir);
    }

    public abstract class ObfuscationPolicyBase : IObfuscationPolicy
    {
        public abstract bool NeedObfuscateCallInMethod(MethodDef method);

        public abstract bool NeedObfuscateCalledMethod(MethodDef callerMethod, IMethod calledMethod, bool callVir);
    }
}

```

`Editor/ObfusPasses/CallObfus/IObfuscationPolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6af3cd881fdefd14d9a55b77088dd5a4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CallObfus/IObfuscator.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.CallObfus
{
    public interface IObfuscator
    {
        bool Obfuscate(MethodDef callingMethod, IMethod calledMethod, bool callVir, List<Instruction> obfuscatedInstructions);

        void Done();
    }

    public abstract class ObfuscatorBase : IObfuscator
    {
        public abstract bool Obfuscate(MethodDef callingMethod, IMethod calledMethod, bool callVir, List<Instruction> obfuscatedInstructions);

        public abstract void Done();
    }
}

```

`Editor/ObfusPasses/CallObfus/IObfuscator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 4156317478f8b1d438ef6d5a280d409f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CallObfus/MethodKey.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Utils;
using System;

namespace Obfuz.ObfusPasses.CallObfus
{
    class MethodKey : IEquatable<MethodKey>
    {
        public readonly IMethod _method;
        public readonly bool _callVir;
        private readonly int _hashCode;

        public MethodKey(IMethod method, bool callVir)
        {
            _method = method;
            _callVir = callVir;
            _hashCode = HashUtil.CombineHash(MethodEqualityComparer.CompareDeclaringTypes.GetHashCode(method), callVir ? 1 : 0);
        }

        public override int GetHashCode()
        {
            return _hashCode;
        }

        public bool Equals(MethodKey other)
        {
            return MethodEqualityComparer.CompareDeclaringTypes.Equals(_method, other._method) && _callVir == other._callVir;
        }
    }
}

```

`Editor/ObfusPasses/CallObfus/MethodKey.cs.meta`:

```meta
fileFormatVersion: 2
guid: 1193647b317b56f4b83aa080d0a17f7a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CallObfus/SpecialWhiteListMethodCalculator.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.CallObfus
{
    class SpecialWhiteListMethodCalculator
    {
        private readonly bool _obfuscateCallToMethodInMscorlib;
        private readonly CachedDictionary<IMethod, bool> _specialWhiteListMethodCache;

        public SpecialWhiteListMethodCalculator(bool obfuscateCallToMethodInMscorlib)
        {
            _obfuscateCallToMethodInMscorlib = obfuscateCallToMethodInMscorlib;
            _specialWhiteListMethodCache = new CachedDictionary<IMethod, bool>(MethodEqualityComparer.CompareDeclaringTypes, this.ComputeIsInWhiteList);
        }

        public bool IsInWhiteList(IMethod calledMethod)
        {
            return _specialWhiteListMethodCache.GetValue(calledMethod);
        }

        private static readonly HashSet<string> _specialTypeFullNames = new HashSet<string>
        {
            "System.Enum",
            "System.Delegate",
            "System.MulticastDelegate",
            "Obfuz.EncryptionService`1",
        };

        private static readonly HashSet<string> _specialMethodNames = new HashSet<string>
        {
            "GetEnumerator", // List<T>.Enumerator.GetEnumerator()
            ".ctor", // constructor
        };

        private static readonly HashSet<string> _specialMethodFullNames = new HashSet<string>
        {
            "System.Reflection.MethodBase.GetCurrentMethod",
            "System.Reflection.Assembly.GetCallingAssembly",
            "System.Reflection.Assembly.GetExecutingAssembly",
            "System.Reflection.Assembly.GetEntryAssembly",
        };

        private bool ComputeIsInWhiteList(IMethod calledMethod)
        {
            MethodDef calledMethodDef = calledMethod.ResolveMethodDef();
            // mono has more strict access control, calls non-public method will raise exception.
            if (PlatformUtil.IsMonoBackend())
            {
                if (calledMethodDef != null && (!calledMethodDef.IsPublic || !IsTypeSelfAndParentPublic(calledMethodDef.DeclaringType)))
                {
                    return true;
                }
            }

            ITypeDefOrRef declaringType = calledMethod.DeclaringType;
            TypeSig declaringTypeSig = calledMethod.DeclaringType.ToTypeSig();
            declaringTypeSig = declaringTypeSig.RemovePinnedAndModifiers();
            switch (declaringTypeSig.ElementType)
            {
                case ElementType.ValueType:
                case ElementType.Class:
                {
                    break;
                }
                case ElementType.GenericInst:
                {
                    if (MetaUtil.ContainsContainsGenericParameter(calledMethod))
                    {
                        return true;
                    }
                    break;
                }
                default: return true;
            }

            TypeDef typeDef = declaringType.ResolveTypeDef();

            if (!_obfuscateCallToMethodInMscorlib && typeDef.Module.IsCoreLibraryModule == true)
            {
                return true;
            }

            if (typeDef.IsDelegate || typeDef.IsEnum)
                return true;

            string fullName = typeDef.FullName;
            if (_specialTypeFullNames.Contains(fullName))
            {
                return true;
            }
            //if (fullName.StartsWith("System.Runtime.CompilerServices."))
            //{
            //    return true;
            //}

            string methodName = calledMethod.Name;
            if (_specialMethodNames.Contains(methodName))
            {
                return true;
            }

            string methodFullName = $"{fullName}.{methodName}";
            if (_specialMethodFullNames.Contains(methodFullName))
            {
                return true;
            }
            return false;
        }

        private bool IsTypeSelfAndParentPublic(TypeDef type)
        {
            if (type.DeclaringType != null && !IsTypeSelfAndParentPublic(type.DeclaringType))
            {
                return false;
            }

            return type.IsPublic;
        }
    }
}

```

`Editor/ObfusPasses/CallObfus/SpecialWhiteListMethodCalculator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 904e80c4b98911c40b6a9173ca24f3ee
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CleanUp.meta`:

```meta
fileFormatVersion: 2
guid: 2764442d8fc2b914dbc39dcfa2699698
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CleanUp/CleanUpInstructionPass.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Obfuz.ObfusPasses.CleanUp
{
    public class CleanUpInstructionPass : ObfuscationPassBase
    {
        public override ObfuscationPassType Type => ObfuscationPassType.None;

        public override void Start()
        {
        }

        public override void Stop()
        {

        }

        public override void Process()
        {
            var ctx = ObfuscationPassContext.Current;
            foreach (ModuleDef mod in ctx.modulesToObfuscate)
            {
                foreach (TypeDef type in mod.GetTypes())
                {
                    foreach (MethodDef method in type.Methods)
                    {
                        if (method.HasBody)
                        {
                            CilBody body = method.Body;
                            body.SimplifyBranches();
                            body.OptimizeMacros();
                            body.OptimizeBranches();
                            // TODO remove dup
                        }
                    }
                }
            }
        }
    }
}

```

`Editor/ObfusPasses/CleanUp/CleanUpInstructionPass.cs.meta`:

```meta
fileFormatVersion: 2
guid: 78cc056cd929d70409a0f0737b571a6d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/CleanUp/RemoveObfuzAttributesPass.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Editor;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.CleanUp
{
    public class RemoveObfuzAttributesPass : ObfuscationPassBase
    {
        public override ObfuscationPassType Type => ObfuscationPassType.None;

        public override void Start()
        {
        }

        public override void Stop()
        {

        }


        private void RemoveObfuzAttributes(IHasCustomAttribute provider)
        {
            CustomAttributeCollection customAttributes = provider.CustomAttributes;
            if (customAttributes.Count == 0)
                return;
            var toRemove = new List<CustomAttribute>();
            customAttributes.RemoveAll(ConstValues.ObfuzIgnoreAttributeFullName);
            customAttributes.RemoveAll(ConstValues.EncryptFieldAttributeFullName);
        }

        public override void Process()
        {
            var ctx = ObfuscationPassContext.Current;
            foreach (ModuleDef mod in ctx.modulesToObfuscate)
            {
                RemoveObfuzAttributes(mod);
                foreach (TypeDef type in mod.GetTypes())
                {
                    RemoveObfuzAttributes(type);
                    foreach (FieldDef field in type.Fields)
                    {
                        RemoveObfuzAttributes(field);
                    }
                    foreach (MethodDef method in type.Methods)
                    {
                        RemoveObfuzAttributes(method);
                        foreach (Parameter param in method.Parameters)
                        {
                            if (param.ParamDef != null)
                            {
                                RemoveObfuzAttributes(param.ParamDef);
                            }
                        }
                    }
                    foreach (PropertyDef property in type.Properties)
                    {
                        RemoveObfuzAttributes(property);
                    }
                    foreach (EventDef eventDef in type.Events)
                    {
                        RemoveObfuzAttributes(eventDef);
                    }
                }
            }
        }
    }
}

```

`Editor/ObfusPasses/CleanUp/RemoveObfuzAttributesPass.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6b475010a7656a0439ca8664a3d2dbc0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ConstEncrypt.meta`:

```meta
fileFormatVersion: 2
guid: 18104d0c3c665ea489e566eec67f2aea
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ConstEncrypt/ConfigurableEncryptPolicy.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Conf;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml;

namespace Obfuz.ObfusPasses.ConstEncrypt
{

    public class ConfigurableEncryptPolicy : EncryptPolicyBase
    {
        class ObfuscationRule : IRule<ObfuscationRule>
        {
            public bool? disableEncrypt;
            public bool? encryptInt;
            public bool? encryptLong;
            public bool? encryptFloat;
            public bool? encryptDouble;
            public bool? encryptArray;
            public bool? encryptString;

            public bool? encryptConstInLoop;
            public bool? encryptStringInLoop;

            public bool? cacheConstInLoop;
            public bool? cacheConstNotInLoop;
            public bool? cacheStringInLoop;
            public bool? cacheStringNotInLoop;

            public void InheritParent(ObfuscationRule parentRule)
            {
                if (disableEncrypt == null)
                    disableEncrypt = parentRule.disableEncrypt;
                if (encryptInt == null)
                    encryptInt = parentRule.encryptInt;
                if (encryptLong == null)
                    encryptLong = parentRule.encryptLong;
                if (encryptFloat == null)
                    encryptFloat = parentRule.encryptFloat;
                if (encryptDouble == null)
                    encryptDouble = parentRule.encryptDouble;
                if (encryptArray == null)
                    encryptArray = parentRule.encryptArray;
                if (encryptString == null)
                    encryptString = parentRule.encryptString;

                if (encryptConstInLoop == null)
                    encryptConstInLoop = parentRule.encryptConstInLoop;
                if (encryptStringInLoop == null)
                    encryptStringInLoop = parentRule.encryptStringInLoop;

                if (cacheConstInLoop == null)
                    cacheConstInLoop = parentRule.cacheConstInLoop;
                if (cacheConstNotInLoop == null)
                    cacheConstNotInLoop = parentRule.cacheConstNotInLoop;
                if (cacheStringInLoop == null)
                    cacheStringInLoop = parentRule.cacheStringInLoop;
                if (cacheStringNotInLoop == null)
                    cacheStringNotInLoop = parentRule.cacheStringNotInLoop;
            }
        }

        class MethodSpec : MethodRuleBase<ObfuscationRule>
        {
        }

        class TypeSpec : TypeRuleBase<MethodSpec, ObfuscationRule>
        {
        }

        class AssemblySpec : AssemblyRuleBase<TypeSpec, MethodSpec, ObfuscationRule>
        {
        }

        private static readonly ObfuscationRule s_default = new ObfuscationRule()
        {
            disableEncrypt = false,
            encryptInt = true,
            encryptLong = true,
            encryptFloat = true,
            encryptDouble = true,
            encryptArray = true,
            encryptString = true,
            encryptConstInLoop = true,
            encryptStringInLoop = true,
            cacheConstInLoop = true,
            cacheConstNotInLoop = false,
            cacheStringInLoop = true,
            cacheStringNotInLoop = true,
        };

        private ObfuscationRule _global;

        public HashSet<int> notEncryptInts = new HashSet<int>();
        public HashSet<long> notEncryptLongs = new HashSet<long>();
        public HashSet<string> notEncryptStrings = new HashSet<string>();
        public List<NumberRange<int>> notEncryptIntRanges = new List<NumberRange<int>>();
        public List<NumberRange<long>> notEncryptLongRanges = new List<NumberRange<long>>();
        public List<NumberRange<float>> notEncryptFloatRanges = new List<NumberRange<float>>();
        public List<NumberRange<double>> notEncryptDoubleRanges = new List<NumberRange<double>>();
        public List<NumberRange<int>> notEncryptArrayLengthRanges = new List<NumberRange<int>>();
        public List<NumberRange<int>> notEncryptStringLengthRanges = new List<NumberRange<int>>();

        private readonly XmlAssemblyTypeMethodRuleParser<AssemblySpec, TypeSpec, MethodSpec, ObfuscationRule> _xmlParser;

        private readonly Dictionary<string, AssemblySpec> _assemblySpecs = new Dictionary<string, AssemblySpec>();
        private readonly Dictionary<MethodDef, ObfuscationRule> _methodRuleCache = new Dictionary<MethodDef, ObfuscationRule>();

        public ConfigurableEncryptPolicy(List<string> toObfuscatedAssemblyNames, List<string> xmlConfigFiles)
        {
            _xmlParser = new XmlAssemblyTypeMethodRuleParser<AssemblySpec, TypeSpec, MethodSpec, ObfuscationRule>(
                toObfuscatedAssemblyNames, ParseObfuscationRule, ParseGlobalElement);
            LoadConfigs(xmlConfigFiles);
        }

        private void LoadConfigs(List<string> configFiles)
        {
            _xmlParser.LoadConfigs(configFiles);
            if (_global == null)
            {
                _global = s_default;
            }
            else
            {
                _global.InheritParent(s_default);
            }
            _xmlParser.InheritParentRules(_global);
        }

        private void ParseGlobalElement(string configFile, XmlElement ele)
        {
            switch (ele.Name)
            {
                case "global": _global = ParseObfuscationRule(configFile, ele); break;
                case "whitelist": ParseWhitelist(configFile, ele); break;
                default: throw new Exception($"Invalid xml file {configFile}, unknown node {ele.Name}");
            }
        }

        private ObfuscationRule ParseObfuscationRule(string configFile, XmlElement ele)
        {
            var rule = new ObfuscationRule();
            if (ele.HasAttribute("disableEncrypt"))
            {
                rule.disableEncrypt = ConfigUtil.ParseBool(ele.GetAttribute("disableEncrypt"));
            }
            if (ele.HasAttribute("encryptInt"))
            {
                rule.encryptInt = ConfigUtil.ParseBool(ele.GetAttribute("encryptInt"));
            }
            if (ele.HasAttribute("encryptLong"))
            {
                rule.encryptLong = ConfigUtil.ParseBool(ele.GetAttribute("encryptLong"));
            }
            if (ele.HasAttribute("encryptFloat"))
            {
                rule.encryptFloat = ConfigUtil.ParseBool(ele.GetAttribute("encryptFloat"));
            }
            if (ele.HasAttribute("encryptDouble"))
            {
                rule.encryptDouble = ConfigUtil.ParseBool(ele.GetAttribute("encryptDouble"));
            }
            if (ele.HasAttribute("encryptBytes"))
            {
                rule.encryptArray = ConfigUtil.ParseBool(ele.GetAttribute("encryptArray"));
            }
            if (ele.HasAttribute("encryptString"))
            {
                rule.encryptString = ConfigUtil.ParseBool(ele.GetAttribute("encryptString"));
            }

            if (ele.HasAttribute("encryptConstInLoop"))
            {
                rule.encryptConstInLoop = ConfigUtil.ParseBool(ele.GetAttribute("encryptConstInLoop"));
            }
            if (ele.HasAttribute("encryptStringInLoop"))
            {
                rule.encryptStringInLoop = ConfigUtil.ParseBool(ele.GetAttribute("encryptStringInLoop"));
            }
            if (ele.HasAttribute("cacheConstInLoop"))
            {
                rule.cacheConstInLoop = ConfigUtil.ParseBool(ele.GetAttribute("cacheConstInLoop"));
            }
            if (ele.HasAttribute("cacheConstNotInLoop"))
            {
                rule.cacheConstNotInLoop = ConfigUtil.ParseBool(ele.GetAttribute("cacheConstNotInLoop"));
            }
            if (ele.HasAttribute("cacheStringInLoop"))
            {
                rule.cacheStringInLoop = ConfigUtil.ParseBool(ele.GetAttribute("cacheStringInLoop"));
            }
            if (ele.HasAttribute("cacheStringNotInLoop"))
            {
                rule.cacheStringNotInLoop = ConfigUtil.ParseBool(ele.GetAttribute("cacheStringNotInLoop"));
            }
            return rule;
        }

        private void ParseWhitelist(string configFile, XmlElement childEle)
        {
            string type = childEle.GetAttribute("type");
            if (string.IsNullOrEmpty(type))
            {
                throw new Exception($"Invalid xml file, whitelist type is empty");
            }
            string value = childEle.InnerText;
            switch (type)
            {
                case "int":
                {
                    notEncryptInts.AddRange(value.Split(',').Select(s => int.Parse(s.Trim())));
                    break;
                }
                case "long":
                {
                    notEncryptLongs.AddRange(value.Split(',').Select(s => long.Parse(s.Trim())));
                    break;
                }
                case "string":
                {
                    notEncryptStrings.AddRange(value.Split(',').Select(s => s.Trim()));
                    break;
                }
                case "int-range":
                {
                    var parts = value.Split(',');
                    if (parts.Length != 2)
                    {
                        throw new Exception($"Invalid xml file, int-range {value} is invalid");
                    }
                    notEncryptIntRanges.Add(new NumberRange<int>(ConfigUtil.ParseNullableInt(parts[0]), ConfigUtil.ParseNullableInt(parts[1])));
                    break;
                }
                case "long-range":
                {
                    var parts = value.Split(',');
                    if (parts.Length != 2)
                    {
                        throw new Exception($"Invalid xml file, long-range {value} is invalid");
                    }
                    notEncryptLongRanges.Add(new NumberRange<long>(ConfigUtil.ParseNullableLong(parts[0]), ConfigUtil.ParseNullableLong(parts[1])));
                    break;
                }
                case "float-range":
                {
                    var parts = value.Split(',');
                    if (parts.Length != 2)
                    {
                        throw new Exception($"Invalid xml file, float-range {value} is invalid");
                    }
                    notEncryptFloatRanges.Add(new NumberRange<float>(ConfigUtil.ParseNullableFloat(parts[0]), ConfigUtil.ParseNullableFloat(parts[1])));
                    break;
                }
                case "double-range":
                {
                    var parts = value.Split(',');
                    if (parts.Length != 2)
                    {
                        throw new Exception($"Invalid xml file, double-range {value} is invalid");
                    }
                    notEncryptDoubleRanges.Add(new NumberRange<double>(ConfigUtil.ParseNullableDouble(parts[0]), ConfigUtil.ParseNullableDouble(parts[1])));
                    break;
                }
                case "string-length-range":
                {
                    var parts = value.Split(',');
                    if (parts.Length != 2)
                    {
                        throw new Exception($"Invalid xml file, string-length-range {value} is invalid");
                    }
                    notEncryptStringLengthRanges.Add(new NumberRange<int>(ConfigUtil.ParseNullableInt(parts[0]), ConfigUtil.ParseNullableInt(parts[1])));
                    break;
                }
                case "array-length-range":
                {
                    var parts = value.Split(',');
                    if (parts.Length != 2)
                    {
                        throw new Exception($"Invalid xml file, array-length-range {value} is invalid");
                    }
                    notEncryptArrayLengthRanges.Add(new NumberRange<int>(ConfigUtil.ParseNullableInt(parts[0]), ConfigUtil.ParseNullableInt(parts[1])));
                    break;
                }
                default: throw new Exception($"Invalid xml file, unknown whitelist type {type} in {childEle.Name} node");
            }
        }

        private ObfuscationRule GetMethodObfuscationRule(MethodDef method)
        {
            if (!_methodRuleCache.TryGetValue(method, out var rule))
            {
                rule = _xmlParser.GetMethodRule(method, _global);
                _methodRuleCache[method] = rule;
            }
            return rule;
        }

        public override bool NeedObfuscateMethod(MethodDef method)
        {
            ObfuscationRule rule = GetMethodObfuscationRule(method);
            return rule.disableEncrypt != true;
        }

        public override ConstCachePolicy GetMethodConstCachePolicy(MethodDef method)
        {
            ObfuscationRule rule = GetMethodObfuscationRule(method);
            return new ConstCachePolicy
            {
                cacheConstInLoop = rule.cacheConstInLoop.Value,
                cacheConstNotInLoop = rule.cacheConstNotInLoop.Value,
                cacheStringInLoop = rule.cacheStringInLoop.Value,
                cacheStringNotInLoop = rule.cacheStringNotInLoop.Value,
            };
        }

        public override bool NeedObfuscateInt(MethodDef method, bool currentInLoop, int value)
        {
            ObfuscationRule rule = GetMethodObfuscationRule(method);
            if (rule.encryptInt == false)
            {
                return false;
            }
            if (currentInLoop && rule.encryptConstInLoop == false)
            {
                return false;
            }
            if (notEncryptInts.Contains(value))
            {
                return false;
            }
            foreach (var range in notEncryptIntRanges)
            {
                if (range.min != null && value < range.min)
                {
                    continue;
                }
                if (range.max != null && value > range.max)
                {
                    continue;
                }
                return false;
            }
            return true;
        }

        public override bool NeedObfuscateLong(MethodDef method, bool currentInLoop, long value)
        {
            ObfuscationRule rule = GetMethodObfuscationRule(method);
            if (rule.encryptLong == false)
            {
                return false;
            }
            if (currentInLoop && rule.encryptConstInLoop == false)
            {
                return false;
            }
            if (notEncryptLongs.Contains(value))
            {
                return false;
            }
            foreach (var range in notEncryptLongRanges)
            {
                if (range.min != null && value < range.min)
                {
                    continue;
                }
                if (range.max != null && value > range.max)
                {
                    continue;
                }
                return false;
            }
            return true;
        }

        public override bool NeedObfuscateFloat(MethodDef method, bool currentInLoop, float value)
        {
            ObfuscationRule rule = GetMethodObfuscationRule(method);
            if (rule.encryptFloat == false)
            {
                return false;
            }
            if (currentInLoop && rule.encryptConstInLoop == false)
            {
                return false;
            }
            foreach (var range in notEncryptFloatRanges)
            {
                if (range.min != null && value < range.min)
                {
                    continue;
                }
                if (range.max != null && value > range.max)
                {
                    continue;
                }
                return false;
            }
            return true;
        }

        public override bool NeedObfuscateDouble(MethodDef method, bool currentInLoop, double value)
        {
            ObfuscationRule rule = GetMethodObfuscationRule(method);
            if (rule.encryptDouble == false)
            {
                return false;
            }
            if (currentInLoop && rule.encryptConstInLoop == false)
            {
                return false;
            }
            foreach (var range in notEncryptDoubleRanges)
            {
                if (range.min != null && value < range.min)
                {
                    continue;
                }
                if (range.max != null && value > range.max)
                {
                    continue;
                }
                return false;
            }
            return true;
        }

        public override bool NeedObfuscateString(MethodDef method, bool currentInLoop, string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                return false;
            }
            ObfuscationRule rule = GetMethodObfuscationRule(method);
            if (rule.encryptString == false)
            {
                return false;
            }
            if (currentInLoop && rule.encryptConstInLoop == false)
            {
                return false;
            }
            if (notEncryptStrings.Contains(value))
            {
                return false;
            }
            foreach (var range in notEncryptStringLengthRanges)
            {
                if (range.min != null && value.Length < range.min)
                {
                    continue;
                }
                if (range.max != null && value.Length > range.max)
                {
                    continue;
                }
                return false;
            }
            return true;
        }

        public override bool NeedObfuscateArray(MethodDef method, bool currentInLoop, byte[] array)
        {
            ObfuscationRule rule = GetMethodObfuscationRule(method);
            if (rule.encryptArray == false)
            {
                return false;
            }
            if (currentInLoop && rule.encryptConstInLoop == false)
            {
                return false;
            }
            foreach (var range in notEncryptArrayLengthRanges)
            {
                if (range.min != null && array.Length < range.min)
                {
                    continue;
                }
                if (range.max != null && array.Length > range.max)
                {
                    continue;
                }
                return false;
            }
            return true;
        }
    }
}

```

`Editor/ObfusPasses/ConstEncrypt/ConfigurableEncryptPolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: da25453bc1fda394097c052af7733260
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ConstEncrypt/ConstEncryptPass.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Emit;
using Obfuz.Settings;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.ConstEncrypt
{

    public class ConstEncryptPass : BasicBlockObfuscationPassBase
    {
        private readonly ConstEncryptionSettingsFacade _settings;
        private IEncryptPolicy _dataObfuscatorPolicy;
        private IConstEncryptor _dataObfuscator;
        public override ObfuscationPassType Type => ObfuscationPassType.ConstEncrypt;

        public ConstEncryptPass(ConstEncryptionSettingsFacade settings)
        {
            _settings = settings;
        }

        public override void Start()
        {
            var ctx = ObfuscationPassContext.Current;
            _dataObfuscatorPolicy = new ConfigurableEncryptPolicy(ctx.coreSettings.assembliesToObfuscate, _settings.ruleFiles);
            _dataObfuscator = new DefaultConstEncryptor(ctx.moduleEntityManager, _settings);
        }

        public override void Stop()
        {

        }

        protected override bool NeedObfuscateMethod(MethodDef method)
        {
            return _dataObfuscatorPolicy.NeedObfuscateMethod(method);
        }

        protected override bool TryObfuscateInstruction(MethodDef method, Instruction inst, BasicBlock block, int instructionIndex, IList<Instruction> globalInstructions,
            List<Instruction> outputInstructions, List<Instruction> totalFinalInstructions)
        {
            bool currentInLoop = block.inLoop;
            ConstCachePolicy constCachePolicy = _dataObfuscatorPolicy.GetMethodConstCachePolicy(method);
            bool needCache = currentInLoop ? constCachePolicy.cacheConstInLoop : constCachePolicy.cacheConstNotInLoop;
            switch (inst.OpCode.Code)
            {
                case Code.Ldc_I4:
                case Code.Ldc_I4_S:
                case Code.Ldc_I4_0:
                case Code.Ldc_I4_1:
                case Code.Ldc_I4_2:
                case Code.Ldc_I4_3:
                case Code.Ldc_I4_4:
                case Code.Ldc_I4_5:
                case Code.Ldc_I4_6:
                case Code.Ldc_I4_7:
                case Code.Ldc_I4_8:
                case Code.Ldc_I4_M1:
                {
                    int value = inst.GetLdcI4Value();
                    if (_dataObfuscatorPolicy.NeedObfuscateInt(method, currentInLoop, value))
                    {
                        _dataObfuscator.ObfuscateInt(method, needCache, value, outputInstructions);
                        return true;
                    }
                    return false;
                }
                case Code.Ldc_I8:
                {
                    long value = (long)inst.Operand;
                    if (_dataObfuscatorPolicy.NeedObfuscateLong(method, currentInLoop, value))
                    {
                        _dataObfuscator.ObfuscateLong(method, needCache, value, outputInstructions);
                        return true;
                    }
                    return false;
                }
                case Code.Ldc_R4:
                {
                    float value = (float)inst.Operand;
                    if (_dataObfuscatorPolicy.NeedObfuscateFloat(method, currentInLoop, value))
                    {
                        _dataObfuscator.ObfuscateFloat(method, needCache, value, outputInstructions);
                        return true;
                    }
                    return false;
                }
                case Code.Ldc_R8:
                {
                    double value = (double)inst.Operand;
                    if (_dataObfuscatorPolicy.NeedObfuscateDouble(method, currentInLoop, value))
                    {
                        _dataObfuscator.ObfuscateDouble(method, needCache, value, outputInstructions);
                        return true;
                    }
                    return false;
                }
                case Code.Ldstr:
                {
                    string value = (string)inst.Operand;
                    if (_dataObfuscatorPolicy.NeedObfuscateString(method, currentInLoop, value))
                    {
                        _dataObfuscator.ObfuscateString(method, needCache, value, outputInstructions);
                        return true;
                    }
                    return false;
                }
                case Code.Call:
                {
                    if (((IMethod)inst.Operand).FullName == "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array,System.RuntimeFieldHandle)")
                    {
                        Instruction prevInst = globalInstructions[instructionIndex - 1];
                        if (prevInst.OpCode.Code == Code.Ldtoken)
                        {
                            IField rvaField = (IField)prevInst.Operand;
                            FieldDef ravFieldDef = rvaField.ResolveFieldDefThrow();
                            if (ravFieldDef.Module != method.Module)
                            {
                                return false;
                            }
                            byte[] data = ravFieldDef.InitialValue;
                            if (data != null && data.Length > 0 && _dataObfuscatorPolicy.NeedObfuscateArray(method, currentInLoop, data))
                            {
                                // don't need cache for byte array obfuscation
                                needCache = false;
                                _dataObfuscator.ObfuscateBytes(method, needCache, ravFieldDef, data, outputInstructions);
                                return true;
                            }
                        }
                    }
                    return false;
                }
                default: return false;
            }
        }
    }
}

```

`Editor/ObfusPasses/ConstEncrypt/ConstEncryptPass.cs.meta`:

```meta
fileFormatVersion: 2
guid: aa0e9191126d4e24c92546b6af2c52cf
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ConstEncrypt/DefaultConstEncryptor.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Data;
using Obfuz.Emit;
using Obfuz.Settings;
using Obfuz.Utils;
using System.Collections.Generic;
using System.Text;
using UnityEngine.Assertions;

namespace Obfuz.ObfusPasses.ConstEncrypt
{
    public class DefaultConstEncryptor : IConstEncryptor
    {
        private readonly GroupByModuleEntityManager _moduleEntityManager;
        private readonly ConstEncryptionSettingsFacade _settings;

        public DefaultConstEncryptor(GroupByModuleEntityManager moduleEntityManager, ConstEncryptionSettingsFacade settings)
        {
            _moduleEntityManager = moduleEntityManager;
            _settings = settings;
        }

        private IRandom CreateRandomForValue(EncryptionScopeInfo encryptionScope, int value)
        {
            return encryptionScope.localRandomCreator(value);
        }

        private int GenerateEncryptionOperations(EncryptionScopeInfo encryptionScope, IRandom random)
        {
            return EncryptionUtil.GenerateEncryptionOpCodes(random, encryptionScope.encryptor, _settings.encryptionLevel);
        }

        public int GenerateSalt(IRandom random)
        {
            return random.NextInt();
        }

        private DefaultMetadataImporter GetModuleMetadataImporter(MethodDef method)
        {
            return _moduleEntityManager.GetEntity<DefaultMetadataImporter>(method.Module);
        }

        public void ObfuscateInt(MethodDef method, bool needCacheValue, int value, List<Instruction> obfuscatedInstructions)
        {
            EncryptionScopeInfo encryptionScope = _moduleEntityManager.EncryptionScopeProvider.GetScope(method.Module);
            IRandom random = CreateRandomForValue(encryptionScope, value.GetHashCode());
            ConstFieldAllocator constFieldAllocator = _moduleEntityManager.GetEntity<ConstFieldAllocator>(method.Module);
            RvaDataAllocator rvaDataAllocator = _moduleEntityManager.GetEntity<RvaDataAllocator>(method.Module);
            DefaultMetadataImporter importer = GetModuleMetadataImporter(method);

            switch (random.NextInt(5))
            {
                case 0:
                {
                    // = c = encrypted static field
                    FieldDef cacheField = constFieldAllocator.Allocate(value);
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, cacheField));
                    break;
                }
                case 1:
                {
                    // c = a + b
                    int a = random.NextInt();
                    int b = value - a;
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstTwoInt(a, b, random, constProbability, constFieldAllocator, obfuscatedInstructions);
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Add));
                    break;
                }
                case 2:
                {
                    // c = a * b
                    int a = random.NextInt() | 0x1;
                    int ra = MathUtil.ModInverse32(a);
                    int b = ra * value;
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstTwoInt(a, b, random, constProbability, constFieldAllocator, obfuscatedInstructions);
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Mul));
                    break;
                }
                case 3:
                {
                    // c = a ^ b
                    int a = random.NextInt();
                    int b = a ^ value;
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstTwoInt(a, b, random, constProbability, constFieldAllocator, obfuscatedInstructions);
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Xor));
                    break;
                }
                default:
                {
                    if (needCacheValue)
                    {
                        FieldDef cacheField = constFieldAllocator.Allocate(value);
                        obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, cacheField));
                        return;
                    }
                    int ops = GenerateEncryptionOperations(encryptionScope, random);
                    int salt = GenerateSalt(random);
                    int encryptedValue = encryptionScope.encryptor.Encrypt(value, ops, salt);
                    RvaData rvaData = rvaDataAllocator.Allocate(encryptedValue);
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, rvaData.field));
                    obfuscatedInstructions.Add(Instruction.CreateLdcI4(rvaData.offset));
                    obfuscatedInstructions.Add(Instruction.CreateLdcI4(ops));
                    obfuscatedInstructions.Add(Instruction.CreateLdcI4(salt));
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Call, importer.DecryptFromRvaInt));
                    break;
                }
            }


        }

        public void ObfuscateLong(MethodDef method, bool needCacheValue, long value, List<Instruction> obfuscatedInstructions)
        {
            EncryptionScopeInfo encryptionScope = _moduleEntityManager.EncryptionScopeProvider.GetScope(method.Module);
            IRandom random = CreateRandomForValue(encryptionScope, value.GetHashCode());
            ConstFieldAllocator constFieldAllocator = _moduleEntityManager.GetEntity<ConstFieldAllocator>(method.Module);
            RvaDataAllocator rvaDataAllocator = _moduleEntityManager.GetEntity<RvaDataAllocator>(method.Module);
            DefaultMetadataImporter importer = GetModuleMetadataImporter(method);

            switch (random.NextInt(5))
            {
                case 0:
                {
                    // c = encrypted static field
                    FieldDef cacheField = constFieldAllocator.Allocate(value);
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, cacheField));
                    break;
                }
                case 1:
                {
                    // c = a + b
                    long a = random.NextLong();
                    long b = value - a;
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstTwoLong(a, b, random, constProbability, constFieldAllocator, obfuscatedInstructions);
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Add));
                    break;
                }
                case 2:
                {
                    // c = a * b
                    long a = random.NextLong() | 0x1;
                    long ra = MathUtil.ModInverse64(a);
                    long b = ra * value;
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstTwoLong(a, b, random, constProbability, constFieldAllocator, obfuscatedInstructions);
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Mul));
                    break;
                }
                case 3:
                {
                    // c = a ^ b
                    long a = random.NextLong();
                    long b = a ^ value;
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstTwoLong(a, b, random, constProbability, constFieldAllocator, obfuscatedInstructions);
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Xor));
                    break;
                }
                default:
                {
                    if (needCacheValue)
                    {
                        FieldDef cacheField = constFieldAllocator.Allocate(value);
                        obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, cacheField));
                        return;
                    }

                    int ops = GenerateEncryptionOperations(encryptionScope, random);
                    int salt = GenerateSalt(random);
                    long encryptedValue = encryptionScope.encryptor.Encrypt(value, ops, salt);
                    RvaData rvaData = rvaDataAllocator.Allocate(encryptedValue);

                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, rvaData.field));
                    obfuscatedInstructions.Add(Instruction.CreateLdcI4(rvaData.offset));
                    obfuscatedInstructions.Add(Instruction.CreateLdcI4(ops));
                    obfuscatedInstructions.Add(Instruction.CreateLdcI4(salt));
                    obfuscatedInstructions.Add(Instruction.Create(OpCodes.Call, importer.DecryptFromRvaLong));
                    break;
                }
            }


        }

        public void ObfuscateFloat(MethodDef method, bool needCacheValue, float value, List<Instruction> obfuscatedInstructions)
        {
            EncryptionScopeInfo encryptionScope = _moduleEntityManager.EncryptionScopeProvider.GetScope(method.Module);
            IRandom random = CreateRandomForValue(encryptionScope, value.GetHashCode());
            ConstFieldAllocator constFieldAllocator = _moduleEntityManager.GetEntity<ConstFieldAllocator>(method.Module);
            RvaDataAllocator rvaDataAllocator = _moduleEntityManager.GetEntity<RvaDataAllocator>(method.Module);
            DefaultMetadataImporter importer = GetModuleMetadataImporter(method);

            if (needCacheValue)
            {
                FieldDef cacheField = constFieldAllocator.Allocate(value);
                obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, cacheField));
                return;
            }


            int ops = GenerateEncryptionOperations(encryptionScope, random);
            int salt = GenerateSalt(random);
            float encryptedValue = encryptionScope.encryptor.Encrypt(value, ops, salt);
            RvaData rvaData = rvaDataAllocator.Allocate(encryptedValue);

            obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, rvaData.field));
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(rvaData.offset));
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(ops));
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(salt));
            obfuscatedInstructions.Add(Instruction.Create(OpCodes.Call, importer.DecryptFromRvaFloat));
        }

        public void ObfuscateDouble(MethodDef method, bool needCacheValue, double value, List<Instruction> obfuscatedInstructions)
        {
            EncryptionScopeInfo encryptionScope = _moduleEntityManager.EncryptionScopeProvider.GetScope(method.Module);
            IRandom random = CreateRandomForValue(encryptionScope, value.GetHashCode());
            ConstFieldAllocator constFieldAllocator = _moduleEntityManager.GetEntity<ConstFieldAllocator>(method.Module);
            RvaDataAllocator rvaDataAllocator = _moduleEntityManager.GetEntity<RvaDataAllocator>(method.Module);
            DefaultMetadataImporter importer = GetModuleMetadataImporter(method);

            if (needCacheValue)
            {
                FieldDef cacheField = constFieldAllocator.Allocate(value);
                obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, cacheField));
                return;
            }


            int ops = GenerateEncryptionOperations(encryptionScope, random);
            int salt = GenerateSalt(random);
            double encryptedValue = encryptionScope.encryptor.Encrypt(value, ops, salt);
            RvaData rvaData = rvaDataAllocator.Allocate(encryptedValue);

            obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, rvaData.field));
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(rvaData.offset));
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(ops));
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(salt));
            obfuscatedInstructions.Add(Instruction.Create(OpCodes.Call, importer.DecryptFromRvaDouble));
        }


        class EncryptedRvaDataInfo
        {
            public readonly FieldDef fieldDef;
            public readonly byte[] originalBytes;
            public readonly byte[] encryptedBytes;
            public readonly int opts;
            public readonly int salt;

            public EncryptedRvaDataInfo(FieldDef fieldDef, byte[] originalBytes, byte[] encryptedBytes, int opts, int salt)
            {
                this.fieldDef = fieldDef;
                this.originalBytes = originalBytes;
                this.encryptedBytes = encryptedBytes;
                this.opts = opts;
                this.salt = salt;
            }
        }

        private readonly Dictionary<FieldDef, EncryptedRvaDataInfo> _encryptedRvaFields = new Dictionary<FieldDef, EncryptedRvaDataInfo>();

        private EncryptedRvaDataInfo GetEncryptedRvaData(FieldDef fieldDef)
        {
            if (!_encryptedRvaFields.TryGetValue(fieldDef, out var encryptedRvaData))
            {
                EncryptionScopeInfo encryptionScope = _moduleEntityManager.EncryptionScopeProvider.GetScope(fieldDef.Module);
                IRandom random = CreateRandomForValue(encryptionScope, FieldEqualityComparer.CompareDeclaringTypes.GetHashCode(fieldDef));
                int ops = GenerateEncryptionOperations(encryptionScope, random);
                int salt = GenerateSalt(random);
                byte[] originalBytes = fieldDef.InitialValue;
                byte[] encryptedBytes = (byte[])originalBytes.Clone();
                encryptionScope.encryptor.EncryptBlock(encryptedBytes, ops, salt);
                Assert.AreNotEqual(originalBytes, encryptedBytes, "Original bytes should not be the same as encrypted bytes.");
                encryptedRvaData = new EncryptedRvaDataInfo(fieldDef, originalBytes, encryptedBytes, ops, salt);
                _encryptedRvaFields.Add(fieldDef, encryptedRvaData);
                fieldDef.InitialValue = encryptedBytes;
                byte[] decryptedBytes = (byte[])encryptedBytes.Clone();
                encryptionScope.encryptor.DecryptBlock(decryptedBytes, ops, salt);
                AssertUtil.AreArrayEqual(originalBytes, decryptedBytes, "Decrypted bytes should match the original bytes after encryption and decryption.");
            }
            return encryptedRvaData;
        }


        public void ObfuscateBytes(MethodDef method, bool needCacheValue, FieldDef field, byte[] value, List<Instruction> obfuscatedInstructions)
        {
            EncryptedRvaDataInfo encryptedData = GetEncryptedRvaData(field);
            Assert.AreEqual(value.Length, encryptedData.encryptedBytes.Length);

            DefaultMetadataImporter importer = GetModuleMetadataImporter(method);
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(encryptedData.encryptedBytes.Length));
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(encryptedData.opts));
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(encryptedData.salt));
            obfuscatedInstructions.Add(Instruction.Create(OpCodes.Call, importer.DecryptInitializeArray));
        }

        public void ObfuscateString(MethodDef method, bool needCacheValue, string value, List<Instruction> obfuscatedInstructions)
        {
            EncryptionScopeInfo encryptionScope = _moduleEntityManager.EncryptionScopeProvider.GetScope(method.Module);
            IRandom random = CreateRandomForValue(encryptionScope, value.GetHashCode());
            ConstFieldAllocator constFieldAllocator = _moduleEntityManager.GetEntity<ConstFieldAllocator>(method.Module);
            RvaDataAllocator rvaDataAllocator = _moduleEntityManager.GetEntity<RvaDataAllocator>(method.Module);
            DefaultMetadataImporter importer = GetModuleMetadataImporter(method);

            if (needCacheValue)
            {
                FieldDef cacheField = constFieldAllocator.Allocate(value);
                obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, cacheField));
                return;
            }

            int ops = GenerateEncryptionOperations(encryptionScope, random);
            int salt = GenerateSalt(random);
            int stringByteLength = Encoding.UTF8.GetByteCount(value);
            byte[] encryptedValue = encryptionScope.encryptor.Encrypt(value, ops, salt);
            Assert.AreEqual(stringByteLength, encryptedValue.Length);
            RvaData rvaData = rvaDataAllocator.Allocate(encryptedValue);

            obfuscatedInstructions.Add(Instruction.Create(OpCodes.Ldsfld, rvaData.field));
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(rvaData.offset));
            // should use stringByteLength, can't use rvaData.size, because rvaData.size is align to 4, it's not the actual length.
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(stringByteLength));
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(ops));
            obfuscatedInstructions.Add(Instruction.CreateLdcI4(salt));
            obfuscatedInstructions.Add(Instruction.Create(OpCodes.Call, importer.DecryptFromRvaString));
        }

        public void Done()
        {
        }
    }
}

```

`Editor/ObfusPasses/ConstEncrypt/DefaultConstEncryptor.cs.meta`:

```meta
fileFormatVersion: 2
guid: 4c6a0ecde97527e4694731e4d4de129a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ConstEncrypt/IConstEncryptor.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.ConstEncrypt
{
    public interface IConstEncryptor
    {
        void ObfuscateInt(MethodDef method, bool needCacheValue, int value, List<Instruction> obfuscatedInstructions);

        void ObfuscateLong(MethodDef method, bool needCacheValue, long value, List<Instruction> obfuscatedInstructions);

        void ObfuscateFloat(MethodDef method, bool needCacheValue, float value, List<Instruction> obfuscatedInstructions);

        void ObfuscateDouble(MethodDef method, bool needCacheValue, double value, List<Instruction> obfuscatedInstructions);

        void ObfuscateString(MethodDef method, bool needCacheValue, string value, List<Instruction> obfuscatedInstructions);

        void ObfuscateBytes(MethodDef method, bool needCacheValue, FieldDef field, byte[] value, List<Instruction> obfuscatedInstructions);
    }

    public abstract class ConstEncryptorBase : IConstEncryptor
    {
        public abstract void ObfuscateBytes(MethodDef method, bool needCacheValue, byte[] value, List<Instruction> obfuscatedInstructions);
        public abstract void ObfuscateDouble(MethodDef method, bool needCacheValue, double value, List<Instruction> obfuscatedInstructions);
        public abstract void ObfuscateFloat(MethodDef method, bool needCacheValue, float value, List<Instruction> obfuscatedInstructions);
        public abstract void ObfuscateInt(MethodDef method, bool needCacheValue, int value, List<Instruction> obfuscatedInstructions);
        public abstract void ObfuscateLong(MethodDef method, bool needCacheValue, long value, List<Instruction> obfuscatedInstructions);
        public abstract void ObfuscateString(MethodDef method, bool needCacheValue, string value, List<Instruction> obfuscatedInstructions);
        public abstract void ObfuscateBytes(MethodDef method, bool needCacheValue, FieldDef field, byte[] value, List<Instruction> obfuscatedInstructions);
    }
}

```

`Editor/ObfusPasses/ConstEncrypt/IConstEncryptor.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0ccbcdadf1913b6498eaee53abac5d0b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ConstEncrypt/IEncryptPolicy.cs`:

```cs
using dnlib.DotNet;

namespace Obfuz.ObfusPasses.ConstEncrypt
{
    public struct ConstCachePolicy
    {
        public bool cacheConstInLoop;
        public bool cacheConstNotInLoop;
        public bool cacheStringInLoop;
        public bool cacheStringNotInLoop;
    }

    public interface IEncryptPolicy
    {
        bool NeedObfuscateMethod(MethodDef method);

        ConstCachePolicy GetMethodConstCachePolicy(MethodDef method);

        bool NeedObfuscateInt(MethodDef method, bool currentInLoop, int value);

        bool NeedObfuscateLong(MethodDef method, bool currentInLoop, long value);

        bool NeedObfuscateFloat(MethodDef method, bool currentInLoop, float value);

        bool NeedObfuscateDouble(MethodDef method, bool currentInLoop, double value);

        bool NeedObfuscateString(MethodDef method, bool currentInLoop, string value);

        bool NeedObfuscateArray(MethodDef method, bool currentInLoop, byte[] array);
    }

    public abstract class EncryptPolicyBase : IEncryptPolicy
    {
        public abstract bool NeedObfuscateMethod(MethodDef method);
        public abstract ConstCachePolicy GetMethodConstCachePolicy(MethodDef method);
        public abstract bool NeedObfuscateDouble(MethodDef method, bool currentInLoop, double value);
        public abstract bool NeedObfuscateFloat(MethodDef method, bool currentInLoop, float value);
        public abstract bool NeedObfuscateInt(MethodDef method, bool currentInLoop, int value);
        public abstract bool NeedObfuscateLong(MethodDef method, bool currentInLoop, long value);
        public abstract bool NeedObfuscateString(MethodDef method, bool currentInLoop, string value);
        public abstract bool NeedObfuscateArray(MethodDef method, bool currentInLoop, byte[] array);
    }
}

```

`Editor/ObfusPasses/ConstEncrypt/IEncryptPolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: 18e57864070430a44ac561bdd7d00b2e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ControlFlowObfus.meta`:

```meta
fileFormatVersion: 2
guid: 02fb097cf61874c41923b3ef23fee199
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ControlFlowObfus/ConfigurableObfuscationPolicy.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Conf;
using Obfuz.Settings;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Xml;

namespace Obfuz.ObfusPasses.ControlFlowObfus
{
    struct ObfuscationRuleData
    {
        public readonly ObfuscationLevel obfuscationLevel;
        public ObfuscationRuleData(ObfuscationLevel level)
        {
            obfuscationLevel = level;
        }
    }

    interface IObfuscationPolicy
    {
        bool NeedObfuscate(MethodDef method);

        ObfuscationRuleData GetObfuscationRuleData(MethodDef method);
    }

    abstract class ObfuscationPolicyBase : IObfuscationPolicy
    {
        public abstract bool NeedObfuscate(MethodDef method);

        public abstract ObfuscationRuleData GetObfuscationRuleData(MethodDef method);
    }

    class ConfigurableObfuscationPolicy : ObfuscationPolicyBase
    {
        class ObfuscationRule : IRule<ObfuscationRule>
        {
            public ObfuscationLevel? obfuscationLevel;

            public void InheritParent(ObfuscationRule parentRule)
            {
                if (obfuscationLevel == null)
                    obfuscationLevel = parentRule.obfuscationLevel;
            }
        }

        class MethodSpec : MethodRuleBase<ObfuscationRule>
        {
        }

        class TypeSpec : TypeRuleBase<MethodSpec, ObfuscationRule>
        {
        }

        class AssemblySpec : AssemblyRuleBase<TypeSpec, MethodSpec, ObfuscationRule>
        {
        }

        private static readonly ObfuscationRule s_default = new ObfuscationRule()
        {
            obfuscationLevel = ObfuscationLevel.Basic,
        };

        private ObfuscationRule _global;

        private readonly XmlAssemblyTypeMethodRuleParser<AssemblySpec, TypeSpec, MethodSpec, ObfuscationRule> _xmlParser;

        private readonly Dictionary<MethodDef, ObfuscationRule> _methodRuleCache = new Dictionary<MethodDef, ObfuscationRule>();

        public ConfigurableObfuscationPolicy(List<string> toObfuscatedAssemblyNames, List<string> xmlConfigFiles)
        {
            _xmlParser = new XmlAssemblyTypeMethodRuleParser<AssemblySpec, TypeSpec, MethodSpec, ObfuscationRule>(
                toObfuscatedAssemblyNames, ParseObfuscationRule, ParseGlobal);
            LoadConfigs(xmlConfigFiles);
        }

        private void LoadConfigs(List<string> configFiles)
        {
            _xmlParser.LoadConfigs(configFiles);

            if (_global == null)
            {
                _global = s_default;
            }
            else
            {
                _global.InheritParent(s_default);
            }
            _xmlParser.InheritParentRules(_global);
        }

        private void ParseGlobal(string configFile, XmlElement ele)
        {
            switch (ele.Name)
            {
                case "global": _global = ParseObfuscationRule(configFile, ele); break;
                default: throw new Exception($"Invalid xml file {configFile}, unknown node {ele.Name}");
            }
        }

        private ObfuscationRule ParseObfuscationRule(string configFile, XmlElement ele)
        {
            var rule = new ObfuscationRule();
            if (ele.HasAttribute("obfuscationLevel"))
            {
                rule.obfuscationLevel = ConfigUtil.ParseObfuscationLevel(ele.GetAttribute("obfuscationLevel"));
            }
            return rule;
        }

        private ObfuscationRule GetMethodObfuscationRule(MethodDef method)
        {
            if (!_methodRuleCache.TryGetValue(method, out var rule))
            {
                rule = _xmlParser.GetMethodRule(method, _global);
                _methodRuleCache[method] = rule;
            }
            return rule;
        }

        public override bool NeedObfuscate(MethodDef method)
        {
            ObfuscationRule rule = GetMethodObfuscationRule(method);
            return rule.obfuscationLevel.Value > ObfuscationLevel.None;
        }

        public override ObfuscationRuleData GetObfuscationRuleData(MethodDef method)
        {
            var rule = GetMethodObfuscationRule(method);
            return new ObfuscationRuleData(rule.obfuscationLevel.Value);
        }
    }
}

```

`Editor/ObfusPasses/ControlFlowObfus/ConfigurableObfuscationPolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: f6983877d8859df4882c30f75be7a70e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ControlFlowObfus/ControlFlowObfusPass.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Data;
using Obfuz.Emit;
using Obfuz.Settings;
using Obfuz.Utils;

namespace Obfuz.ObfusPasses.ControlFlowObfus
{
    class ObfusMethodContext
    {
        public MethodDef method;
        public LocalVariableAllocator localVariableAllocator;
        public IRandom localRandom;
        public EncryptionScopeInfo encryptionScope;
        public DefaultMetadataImporter importer;
        public ConstFieldAllocator constFieldAllocator;
        public int minInstructionCountOfBasicBlockToObfuscate;

        public IRandom CreateRandom()
        {
            return encryptionScope.localRandomCreator(MethodEqualityComparer.CompareDeclaringTypes.GetHashCode(method));
        }
    }

    internal class ControlFlowObfusPass : ObfuscationMethodPassBase
    {
        private readonly ControlFlowObfuscationSettingsFacade _settings;

        private IObfuscationPolicy _obfuscationPolicy;
        private IObfuscator _obfuscator;

        public ControlFlowObfusPass(ControlFlowObfuscationSettingsFacade settings)
        {
            _settings = settings;
            _obfuscator = new DefaultObfuscator();
        }

        public override ObfuscationPassType Type => ObfuscationPassType.ControlFlowObfus;

        public override void Start()
        {
            ObfuscationPassContext ctx = ObfuscationPassContext.Current;
            _obfuscationPolicy = new ConfigurableObfuscationPolicy(
                ctx.coreSettings.assembliesToObfuscate,
                _settings.ruleFiles);
        }

        public override void Stop()
        {

        }

        protected override bool NeedObfuscateMethod(MethodDef method)
        {
            return _obfuscationPolicy.NeedObfuscate(method);
        }

        protected override void ObfuscateData(MethodDef method)
        {
            //Debug.Log($"Obfuscating method: {method.FullName} with EvalStackObfusPass");

            ObfuscationPassContext ctx = ObfuscationPassContext.Current;
            GroupByModuleEntityManager moduleEntityManager = ctx.moduleEntityManager;
            var encryptionScope = moduleEntityManager.EncryptionScopeProvider.GetScope(method.Module);
            var ruleData = _obfuscationPolicy.GetObfuscationRuleData(method);
            var localRandom = encryptionScope.localRandomCreator(MethodEqualityComparer.CompareDeclaringTypes.GetHashCode(method));
            var obfusMethodCtx = new ObfusMethodContext
            {
                method = method,
                localVariableAllocator = new LocalVariableAllocator(method),
                encryptionScope = encryptionScope,
                constFieldAllocator = moduleEntityManager.GetEntity<ConstFieldAllocator>(method.Module),
                localRandom = localRandom,
                importer = moduleEntityManager.GetEntity<DefaultMetadataImporter>(method.Module),
                minInstructionCountOfBasicBlockToObfuscate = _settings.minInstructionCountOfBasicBlockToObfuscate,
            };
            _obfuscator.Obfuscate(method, obfusMethodCtx);
        }
    }
}

```

`Editor/ObfusPasses/ControlFlowObfus/ControlFlowObfusPass.cs.meta`:

```meta
fileFormatVersion: 2
guid: cf62db4d3137e6447bd5cb2a65f101d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ControlFlowObfus/DefaultObfuscator.cs`:

```cs
using dnlib.DotNet;
using UnityEngine;

namespace Obfuz.ObfusPasses.ControlFlowObfus
{
    class DefaultObfuscator : ObfuscatorBase
    {
        public override bool Obfuscate(MethodDef method, ObfusMethodContext ctx)
        {
            //Debug.Log($"Obfuscating method: {method.FullName} with ControlFlowObfusPass");
            var mcfc = new MethodControlFlowCalculator(method, ctx.CreateRandom(), ctx.constFieldAllocator, ctx.minInstructionCountOfBasicBlockToObfuscate);
            if (!mcfc.TryObfus())
            {
                //Debug.LogWarning($"not obfuscate method: {method.FullName}");
                return false;
            }
            return true;
        }
    }
}

```

`Editor/ObfusPasses/ControlFlowObfus/DefaultObfuscator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8aa2a2e43fa066541b982dbb63452458
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ControlFlowObfus/IObfuscator.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Emit;

namespace Obfuz.ObfusPasses.ControlFlowObfus
{
    interface IObfuscator
    {
        bool Obfuscate(MethodDef method, ObfusMethodContext ctx);
    }

    abstract class ObfuscatorBase : IObfuscator
    {
        public abstract bool Obfuscate(MethodDef method, ObfusMethodContext ctx);
    }
}

```

`Editor/ObfusPasses/ControlFlowObfus/IObfuscator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 4ada5f6005768f745a18dc8b968e1684
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ControlFlowObfus/MethodControlFlowCalculator.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Data;
using Obfuz.Emit;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Assertions;

namespace Obfuz.ObfusPasses.ControlFlowObfus
{
    class MethodControlFlowCalculator
    {
        class BasicBlockInputOutputArguments
        {
            public readonly List<Local> locals = new List<Local>();

            public BasicBlockInputOutputArguments()
            {
            }

            public BasicBlockInputOutputArguments(MethodDef method, List<EvalDataTypeWithSig> inputStackDatas)
            {
                ICorLibTypes corLibTypes = method.Module.CorLibTypes;
                foreach (var data in inputStackDatas)
                {
                    Local local = new Local(GetLocalTypeSig(corLibTypes, data));
                    locals.Add(local);
                    method.Body.Variables.Add(local);
                }
            }

            private TypeSig GetLocalTypeSig(ICorLibTypes corLibTypes, EvalDataTypeWithSig type)
            {
                switch (type.type)
                {
                    case EvalDataType.Int32: return corLibTypes.Int32;
                    case EvalDataType.Int64: return corLibTypes.Int64;
                    case EvalDataType.Float: return corLibTypes.Single;
                    case EvalDataType.Double: return corLibTypes.Double;
                    case EvalDataType.I: return corLibTypes.IntPtr;
                    case EvalDataType.Ref: Assert.IsNotNull(type.typeSig); return type.typeSig;
                    case EvalDataType.ValueType: Assert.IsNotNull(type.typeSig); return type.typeSig;
                    case EvalDataType.Token: throw new System.NotSupportedException("Token type is not supported in BasicBlockInputOutputArguments");
                    default: throw new System.NotSupportedException("not supported EvalDataType");
                }
            }
        }

        class BasicBlockInfo
        {
            public BlockGroup group;

            //public int order;
            public bool isSaveStackBlock;
            public BasicBlockInfo prev;
            public BasicBlockInfo next;

            public List<Instruction> instructions;
            public List<EvalDataTypeWithSig> inputStackDatas;
            public List<EvalDataTypeWithSig> outputStackDatas;

            public List<BasicBlockInfo> inBasicBlocks = new List<BasicBlockInfo>();
            public List<BasicBlockInfo> outBasicBlocks = new List<BasicBlockInfo>();

            public BasicBlockInputOutputArguments inputArgs;
            public BasicBlockInputOutputArguments outputArgs;

            public Instruction FirstInstruction => instructions[0];

            public Instruction LastInstruction => instructions[instructions.Count - 1];

            public Instruction GroupFirstInstruction => group.basicBlocks[0].FirstInstruction;


            //public void InsertNext(BasicBlockInfo nextBb)
            //{
            //    if (next != null)
            //    {
            //        next.prev = nextBb;
            //        nextBb.next = next;
            //    }
            //    nextBb.prev = this;
            //    next = nextBb;
            //}

            public void InsertBefore(BasicBlockInfo prevBb)
            {
                prev.next = prevBb;
                prevBb.prev = prev;
                prevBb.next = this;
                this.prev = prevBb;
            }

            public void AddOutBasicBlock(BasicBlockInfo outBb)
            {
                if (!outBasicBlocks.Contains(outBb))
                {
                    outBasicBlocks.Add(outBb);
                    outBb.inBasicBlocks.Add(this);
                }
            }

            public void ClearInBasicBlocks()
            {
                foreach (var inBb in inBasicBlocks)
                {
                    inBb.outBasicBlocks.Remove(this);
                }
                inBasicBlocks.Clear();
            }

            public void RetargetInBasicBlocksTo(BasicBlockInfo prevBb, Dictionary<Instruction, BasicBlockInfo> inst2bb)
            {
                var oldInBlocks = new List<BasicBlockInfo>(inBasicBlocks);
                ClearInBasicBlocks();
                foreach (var oldInBb in oldInBlocks)
                {
                    oldInBb.AddOutBasicBlock(prevBb);
                }
                // inBB => saveBb => cur
                foreach (BasicBlockInfo inBb in prevBb.inBasicBlocks)
                {
                    if (inBb.instructions.Count == 0)
                    {
                        // empty block, no need to retarget
                        continue;
                    }
                    Instruction lastInst = inBb.instructions.Last();
                    if (lastInst.Operand is Instruction targetInst)
                    {
                        if (inst2bb.TryGetValue(targetInst, out BasicBlockInfo targetBb) && targetBb == this)
                        {
                            // retarget to prevBb
                            lastInst.Operand = prevBb.FirstInstruction;
                        }
                    }
                    else if (lastInst.Operand is Instruction[] targetInsts)
                    {
                        for (int i = 0; i < targetInsts.Length; i++)
                        {
                            targetInst = targetInsts[i];
                            if (inst2bb.TryGetValue(targetInst, out BasicBlockInfo targetBb) && targetBb == this)
                            {
                                targetInsts[i] = prevBb.FirstInstruction;
                            }
                        }
                    }
                }
            }
        }

        private readonly MethodDef _method;
        private readonly IRandom _random;
        private readonly ConstFieldAllocator _constFieldAllocator;
        private readonly int _minInstructionCountOfBasicBlockToObfuscate;
        private readonly BasicBlockInfo _bbHead;

        public MethodControlFlowCalculator(MethodDef method, IRandom random, ConstFieldAllocator constFieldAllocator, int minInstructionCountOfBasicBlockToObfuscate)
        {
            _method = method;
            _random = random;
            _constFieldAllocator = constFieldAllocator;
            _minInstructionCountOfBasicBlockToObfuscate = minInstructionCountOfBasicBlockToObfuscate;

            _bbHead = new BasicBlockInfo()
            {
                instructions = new List<Instruction>(),
                inputStackDatas = new List<EvalDataTypeWithSig>(),
                outputStackDatas = new List<EvalDataTypeWithSig>(),
            };
        }

        private void BuildBasicBlockLink(EvalStackCalculator evc)
        {
            BasicBlockInfo prev = _bbHead;
            var bb2bb = new Dictionary<BasicBlock, BasicBlockInfo>();
            foreach (BasicBlock bb in evc.BasicBlockCollection.Blocks)
            {
                EvalStackState ess = evc.GetEvalStackState(bb);
                var newBB = new BasicBlockInfo
                {
                    prev = prev,
                    next = null,
                    instructions = bb.instructions,
                    inputStackDatas = ess.inputStackDatas,
                    outputStackDatas = ess.runStackDatas,
                };
                prev.next = newBB;
                prev = newBB;
                bb2bb.Add(bb, newBB);
            }
            foreach (BasicBlock bb in evc.BasicBlockCollection.Blocks)
            {
                BasicBlockInfo bbi = bb2bb[bb];
                foreach (var inBb in bb.inBlocks)
                {
                    bbi.inBasicBlocks.Add(bb2bb[inBb]);
                }
                foreach (var outBb in bb.outBlocks)
                {
                    bbi.outBasicBlocks.Add(bb2bb[outBb]);
                }
            }

            // let _bbHead point to the first basic block
            //_bbHead.instructions.Add(Instruction.Create(OpCodes.Br, _bbHead.next.FirstInstruction));
            _bbHead.next.inBasicBlocks.Add(_bbHead);
            _bbHead.outBasicBlocks.Add(_bbHead.next);
        }

        private bool CheckNotContainsNotSupportedEvalStackData()
        {
            for (BasicBlockInfo cur = _bbHead; cur != null; cur = cur.next)
            {
                foreach (var data in cur.inputStackDatas)
                {
                    if (data.type == EvalDataType.Unknown || data.type == EvalDataType.Token)
                    {
                        Debug.LogError($"NotSupported EvalStackData found in method: {_method.FullName}, type: {data.type}");
                        return false;
                    }
                }
            }
            return true;
        }


        private void WalkInputArgumentGroup(BasicBlockInfo cur, BasicBlockInputOutputArguments inputArgs)
        {
            if (cur.inputArgs != null)
            {
                Assert.AreEqual(cur.inputArgs, inputArgs, "input arguments not match");
                return;
            }
            cur.inputArgs = inputArgs;
            foreach (BasicBlockInfo inputBB in cur.inBasicBlocks)
            {
                if (inputBB.outputArgs != null)
                {
                    Assert.AreEqual(inputBB.outputArgs, inputArgs, $"Input BB {inputBB} outputArgs does not match in method: {_method.FullName}");
                    continue;
                }
                inputBB.outputArgs = cur.inputArgs;
                foreach (var outBB in inputBB.outBasicBlocks)
                {
                    WalkInputArgumentGroup(outBB, inputArgs);
                }
            }
        }

        private readonly BasicBlockInputOutputArguments emptyEvalStackArgs = new BasicBlockInputOutputArguments();

        private void ComputeInputOutputArguments()
        {
            for (BasicBlockInfo cur = _bbHead; cur != null; cur = cur.next)
            {
                if (cur.inputArgs == null)
                {
                    if (cur.inputStackDatas.Count == 0)
                    {
                        cur.inputArgs = emptyEvalStackArgs;
                    }
                    else
                    {
                        var inputArgs = new BasicBlockInputOutputArguments(_method, cur.inputStackDatas);
                        WalkInputArgumentGroup(cur, inputArgs);
                    }
                }
                if (cur.outputArgs == null && cur.outputStackDatas.Count == 0)
                {
                    cur.outputArgs = emptyEvalStackArgs;
                }
            }
            for (BasicBlockInfo cur = _bbHead; cur != null; cur = cur.next)
            {
                if (cur.inputArgs == null)
                {
                    throw new System.Exception($"Input arguments for BasicBlock {cur} in method {_method.FullName} is null");
                }
                if (cur.outputArgs == null)
                {
                    if (cur.instructions.Count > 0)
                    {
                        Code lastInstCode = cur.LastInstruction.OpCode.Code;
                        Assert.IsTrue(lastInstCode == Code.Throw || lastInstCode == Code.Rethrow);
                        cur.outputStackDatas = new List<EvalDataTypeWithSig>();
                    }
                    cur.outputArgs = emptyEvalStackArgs;
                }
            }
        }


        private BasicBlockInfo CreateSaveStackBasicBlock(BasicBlockInfo to)
        {
            if (to.group == null)
            {
                throw new Exception($"BasicBlock {to} in method {_method.FullName} does not belong to any group. This should not happen.");
            }

            var saveLocalBasicBlock = new BasicBlockInfo
            {
                group = to.group,
                isSaveStackBlock = true,
                inputStackDatas = to.inputStackDatas,
                inputArgs = to.inputArgs,
                outputStackDatas = new List<EvalDataTypeWithSig>(),
                outputArgs = emptyEvalStackArgs,
                instructions = new List<Instruction>(),
            };

            var locals = to.inputArgs.locals;
            if (locals.Count > 0)
            {
                to.instructions.InsertRange(0, locals.Select(l => Instruction.Create(OpCodes.Ldloc, l)));

            }
            for (int i = locals.Count - 1; i >= 0; i--)
            {
                saveLocalBasicBlock.instructions.Add(Instruction.Create(OpCodes.Stloc, locals[i]));
            }

            to.inputArgs = emptyEvalStackArgs;
            to.inputStackDatas = new List<EvalDataTypeWithSig>();

            BlockGroup group = to.group;
            group.basicBlocks.Insert(group.basicBlocks.IndexOf(to), saveLocalBasicBlock);
            group.switchMachineCases.Add(new SwitchMachineCase { index = -1, prepareBlock = saveLocalBasicBlock, targetBlock = to});
            saveLocalBasicBlock.instructions.Add(Instruction.Create(OpCodes.Ldsfld, (FieldDef)null));
            saveLocalBasicBlock.instructions.Add(Instruction.Create(OpCodes.Br, group.switchMachineInst));


            return saveLocalBasicBlock;
        }

        private void AdjustInputOutputEvalStack()
        {
            Dictionary<Instruction, BasicBlockInfo> inst2bb = BuildInstructionToBasicBlockInfoDic();
            for (BasicBlockInfo cur = _bbHead.next; cur != null; cur = cur.next)
            {
                if (cur.inputArgs.locals.Count == 0 && cur.instructions.Count < _minInstructionCountOfBasicBlockToObfuscate)
                {
                    // small block, no need to save stack
                    continue;
                }

                BasicBlockInfo saveBb = CreateSaveStackBasicBlock(cur);
                cur.InsertBefore(saveBb);
                cur.RetargetInBasicBlocksTo(saveBb, inst2bb);
                //saveBb.AddOutBasicBlock(cur);
            }
        }

        private void InsertSwitchMachineBasicBlockForGroups(BlockGroup rootGroup)
        {
            Dictionary<Instruction, BasicBlockInfo> inst2bb = BuildInstructionToBasicBlockInfoDic();

             InsertSwitchMachineBasicBlockForGroup(rootGroup, inst2bb);
        }

        //private void ShuffleBasicBlocks0(List<BasicBlockInfo> bbs)
        //{
        //    int n = bbs.Count;
        //    if (n <= 1)
        //    {
        //        return;
        //    }

        //    var firstSection = new List<BasicBlockInfo>() { bbs[0] };
        //    var sectionsExcludeFirstLast = new List<List<BasicBlockInfo>>();
        //    List<BasicBlockInfo> currentSection = firstSection;
        //    for (int i = 1; i < n; i++)
        //    {
        //        BasicBlockInfo cur = bbs[i];
        //        if (cur.inputArgs.locals.Count == 0)
        //        {
        //            currentSection = new List<BasicBlockInfo>() { cur };
        //            sectionsExcludeFirstLast.Add(currentSection);
        //        }
        //        else
        //        {
        //            currentSection.Add(cur);
        //        }
        //    }
        //    if (sectionsExcludeFirstLast.Count <= 1)
        //    {
        //        return;
        //    }
        //    var lastSection = sectionsExcludeFirstLast.Last();
        //    sectionsExcludeFirstLast.RemoveAt(sectionsExcludeFirstLast.Count - 1);


        //    RandomUtil.ShuffleList(sectionsExcludeFirstLast, _random);

        //    bbs.Clear();
        //    bbs.AddRange(firstSection);
        //    bbs.AddRange(sectionsExcludeFirstLast.SelectMany(section => section));
        //    bbs.AddRange(lastSection);
        //    Assert.AreEqual(n, bbs.Count, "Shuffled basic blocks count should be the same as original count");
        //}

        private void ShuffleBasicBlocks(List<BasicBlockInfo> bbs)
        {
            // TODO

            //int n = bbs.Count;
            //BasicBlockInfo groupPrev = bbs[0].prev;
            //BasicBlockInfo groupNext = bbs[n - 1].next;
            ////RandomUtil.ShuffleList(bbs, _random);
            //ShuffleBasicBlocks0(bbs);
            //BasicBlockInfo prev = groupPrev;
            //for (int i = 0; i < n; i++)
            //{
            //    BasicBlockInfo cur = bbs[i];
            //    cur.prev = prev;
            //    prev.next = cur;
            //    prev = cur;
            //}
            //prev.next = groupNext;
            //if (groupNext != null)
            //{
            //    groupNext.prev = prev;
            //}
        }

        private void InsertSwitchMachineBasicBlockForGroup(BlockGroup group, Dictionary<Instruction, BasicBlockInfo> inst2bb)
        {
            if (group.subGroups != null && group.subGroups.Count > 0)
            {
                foreach (var subGroup in group.subGroups)
                {
                    InsertSwitchMachineBasicBlockForGroup(subGroup, inst2bb);
                }
            }
            else if (group.switchMachineCases.Count > 0)
            {
                Assert.IsTrue(group.basicBlocks.Count > 0, "Group should contain at least one basic block");

                BasicBlockInfo firstBlock = group.basicBlocks[0];
                var firstCase = group.switchMachineCases[0];
                //Assert.AreEqual(firstCase.prepareBlock, firstBlock, "First case prepare block should be the first basic block in group");

                Assert.IsTrue(firstCase.targetBlock.inputArgs.locals.Count == 0);
                Assert.IsTrue(firstCase.targetBlock.inputStackDatas.Count == 0);

                var instructions = new List<Instruction>()
                    {
                        Instruction.Create(OpCodes.Ldsfld, (FieldDef)null),
                        group.switchMachineInst,
                        Instruction.Create(OpCodes.Br, firstCase.targetBlock.FirstInstruction),
                    };
                if (firstCase.prepareBlock != firstBlock || firstBlock.inputStackDatas.Count != 0)
                {
                    instructions.Insert(0, Instruction.Create(OpCodes.Br, firstBlock.FirstInstruction));
                }
                
                var switchMachineBb = new BasicBlockInfo()
                {
                    group = group,
                    inputArgs = firstBlock.inputArgs,
                    outputArgs = emptyEvalStackArgs,
                    inputStackDatas = firstBlock.inputStackDatas,
                    outputStackDatas = new List<EvalDataTypeWithSig>(),
                    instructions = instructions,
                };
                firstBlock.InsertBefore(switchMachineBb);
                group.basicBlocks.Insert(0, switchMachineBb);
                ShuffleBasicBlocks(group.basicBlocks);

                List<Instruction> switchTargets = (List<Instruction>)group.switchMachineInst.Operand;

                RandomUtil.ShuffleList(group.switchMachineCases, _random);

                for (int i = 0, n = group.switchMachineCases.Count; i < n; i++)
                {
                    SwitchMachineCase switchMachineCase = group.switchMachineCases[i];
                    switchMachineCase.index = i;
                    List<Instruction> prepareBlockInstructions = switchMachineCase.prepareBlock.instructions;

                    Instruction setBranchIndexInst = prepareBlockInstructions[prepareBlockInstructions.Count - 2];
                    Assert.AreEqual(setBranchIndexInst.OpCode, OpCodes.Ldsfld, "first instruction of prepareBlock should be Ldsfld");
                    //setBranchIndexInst.Operand = i;
                    var indexField = _constFieldAllocator.Allocate(i);
                    setBranchIndexInst.Operand = indexField;
                    switchTargets.Add(switchMachineCase.targetBlock.FirstInstruction);
                }

                // after shuffle
                Assert.IsTrue(instructions.Count == 3 || instructions.Count == 4, "Switch machine basic block should contain 3 or 4 instructions");
                Assert.AreEqual(Code.Ldsfld, instructions[instructions.Count - 3].OpCode.Code, "First instruction should be Ldsfld");
                instructions[instructions.Count - 3].Operand = _constFieldAllocator.Allocate(firstCase.index);
            }
        }

        private bool IsPrevBasicBlockControlFlowNextToThis(BasicBlockInfo cur)
        {
            Instruction lastInst = cur.prev.LastInstruction;
            switch (lastInst.OpCode.FlowControl)
            {
                case FlowControl.Cond_Branch:
                case FlowControl.Call:
                case FlowControl.Next:
                case FlowControl.Break:
                {
                    return true;
                }
                default: return false;
            }
        }

        private void InsertBrInstructionForConjoinedBasicBlocks()
        {
            for (BasicBlockInfo cur = _bbHead.next.next; cur != null; cur = cur.next)
            {
                if (cur.group == cur.prev.group && IsPrevBasicBlockControlFlowNextToThis(cur))
                {
                    cur.prev.instructions.Add(Instruction.Create(OpCodes.Br, cur.FirstInstruction));
                }
            }
        }

        private Dictionary<Instruction, BasicBlockInfo> BuildInstructionToBasicBlockInfoDic()
        {
            var inst2bb = new Dictionary<Instruction, BasicBlockInfo>();
            for (BasicBlockInfo cur = _bbHead.next; cur != null; cur = cur.next)
            {
                foreach (var inst in cur.instructions)
                {
                    inst2bb[inst] = cur;
                }
            }
            return inst2bb;
        }


        private class SwitchMachineCase
        {
            public int index;
            public BasicBlockInfo prepareBlock;
            public BasicBlockInfo targetBlock;
        }

        private class BlockGroup
        {
            public BlockGroup parent;

            public List<Instruction> instructions;

            public List<BlockGroup> subGroups;

            public List<BasicBlockInfo> basicBlocks;

            public Instruction switchMachineInst;
            public List<SwitchMachineCase> switchMachineCases;

            public BlockGroup(List<Instruction> instructions, Dictionary<Instruction, BlockGroup> inst2group)
            {
                this.instructions = instructions;
                UpdateInstructionGroup(inst2group);
            }

            public BlockGroup(BlockGroup parent, List<Instruction> instructions, Dictionary<Instruction, BlockGroup> inst2group)
            {
                this.instructions = instructions;
                UpdateInstructionGroup(parent, inst2group);
            }

            public BlockGroup RootParent => parent == null ? this : parent.RootParent;

            public void SetParent(BlockGroup newParent)
            {
                if (parent != null)
                {
                    Assert.IsTrue(parent != newParent, "Parent group should not be the same as new parent");
                    Assert.IsTrue(parent.subGroups.Contains(this), "Parent group should already contain this group");
                    parent.subGroups.Remove(this);
                }
                parent = newParent;
                if (newParent.subGroups == null)
                {
                    newParent.subGroups = new List<BlockGroup>();
                }
                Assert.IsFalse(newParent.subGroups.Contains(this), "New parent group should not already contain this group");
                newParent.subGroups.Add(this);
            }

            private void UpdateInstructionGroup(Dictionary<Instruction, BlockGroup> inst2group)
            {
                foreach (var inst in instructions)
                {
                    if (inst2group.TryGetValue(inst, out BlockGroup existGroup))
                    {
                        if (this != existGroup)
                        {
                            BlockGroup rootParent = existGroup.RootParent;
                            if (rootParent != this)
                            {
                                rootParent.SetParent(this);
                            }
                        }
                    }
                    else
                    {
                        inst2group[inst] = this;
                    }
                }
            }

            private void UpdateInstructionGroup(BlockGroup parentGroup, Dictionary<Instruction, BlockGroup> inst2group)
            {
                foreach (var inst in instructions)
                {
                    BlockGroup existGroup = inst2group[inst];
                    Assert.AreEqual(parentGroup, existGroup, "Instruction group parent should be the same as parent group");
                    inst2group[inst] = this;
                }
                SetParent(parentGroup);
            }

            public void SplitInstructionsNotInAnySubGroupsToIndividualGroups(Dictionary<Instruction, BlockGroup> inst2group)
            {
                if (subGroups == null || subGroups.Count == 0 || instructions.Count == 0)
                {
                    return;
                }

                foreach (var subGroup in subGroups)
                {
                    subGroup.SplitInstructionsNotInAnySubGroupsToIndividualGroups(inst2group);
                }

                var finalGroupList = new List<BlockGroup>();
                var curGroupInstructions = new List<Instruction>();

                var firstInst2SubGroup = subGroups.ToDictionary(g => g.instructions[0]);
                foreach (var inst in instructions)
                {
                    BlockGroup group = inst2group[inst];
                    if (group == this)
                    {
                        curGroupInstructions.Add(inst);
                    }
                    else
                    {
                        if (curGroupInstructions.Count > 0)
                        {
                            finalGroupList.Add(new BlockGroup(this, curGroupInstructions, inst2group));
                            curGroupInstructions = new List<Instruction>();
                        }
                        if (firstInst2SubGroup.TryGetValue(inst, out var subGroup))
                        {
                            finalGroupList.Add(subGroup);
                        }
                    }
                }
                if (curGroupInstructions.Count > 0)
                {
                    finalGroupList.Add(new BlockGroup(this, curGroupInstructions, inst2group));
                }
                this.subGroups = finalGroupList;
            }

            public void ComputeBasicBlocks(Dictionary<Instruction, BasicBlockInfo> inst2bb)
            {
                if (subGroups == null || subGroups.Count == 0)
                {
                    basicBlocks = new List<BasicBlockInfo>();
                    foreach (var inst in instructions)
                    {
                        BasicBlockInfo block = inst2bb[inst];
                        if (block.group != null)
                        {
                            if (block.group != this)
                            {
                                throw new Exception("BasicBlockInfo group should be the same as this BlockGroup");
                            }
                        }
                        else
                        {
                            block.group = this;
                            basicBlocks.Add(block);
                        }
                    }
                    switchMachineInst = Instruction.Create(OpCodes.Switch, new List<Instruction>());
                    switchMachineCases = new List<SwitchMachineCase>();
                    return;
                }
                foreach (var subGroup in subGroups)
                {
                    subGroup.ComputeBasicBlocks(inst2bb);
                }
            }
        }

        private class TryBlockGroup : BlockGroup
        {
            public TryBlockGroup(List<Instruction> instructions, Dictionary<Instruction, BlockGroup> inst2group) : base(instructions, inst2group)
            {
            }
        }

        private class ExceptionHandlerGroup : BlockGroup
        {
            public readonly ExceptionHandler exceptionHandler;

            public ExceptionHandlerGroup(ExceptionHandler exceptionHandler, List<Instruction> instructions, Dictionary<Instruction, BlockGroup> inst2group) : base(instructions, inst2group)
            {
                this.exceptionHandler = exceptionHandler;
            }
        }

        private class ExceptionFilterGroup : BlockGroup
        {
            public readonly ExceptionHandler exceptionHandler;

            public ExceptionFilterGroup(ExceptionHandler exceptionHandler, List<Instruction> instructions, Dictionary<Instruction, BlockGroup> inst2group) : base(instructions, inst2group)
            {
                this.exceptionHandler = exceptionHandler;
            }
        }

        private class ExceptionHandlerWithFilterGroup : BlockGroup
        {
            public readonly ExceptionHandler exceptionHandler;
            //public readonly ExceptionFilterGroup filterGroup;
            //public readonly ExceptionHandlerGroup handlerGroup;
            public ExceptionHandlerWithFilterGroup(ExceptionHandler exceptionHandler, List<Instruction> filterInstructions, List<Instruction> handlerInstructions, List<Instruction> allInstructions, Dictionary<Instruction, BlockGroup> inst2group) : base(allInstructions, inst2group)
            {
                this.exceptionHandler = exceptionHandler;
                var filterGroup = new ExceptionFilterGroup(exceptionHandler, filterInstructions, inst2group);
                var handlerGroup = new ExceptionHandlerGroup(exceptionHandler, handlerInstructions, inst2group);
            }
        }

        class TryBlockInfo
        {
            public Instruction tryStart;
            public Instruction tryEnd;
            public TryBlockGroup blockGroup;
        }

        private Dictionary<Instruction, int> BuildInstruction2Index()
        {
            IList<Instruction> instructions = _method.Body.Instructions;
            var inst2Index = new Dictionary<Instruction, int>(instructions.Count);
            for (int i = 0; i < instructions.Count; i++)
            {
                Instruction inst = instructions[i];
                inst2Index.Add(inst, i);
            }
            return inst2Index;
        }

        private BlockGroup SplitBasicBlockGroup()
        {
            Dictionary<Instruction, int> inst2Index = BuildInstruction2Index();
            var inst2blockGroup = new Dictionary<Instruction, BlockGroup>();

            List<Instruction> instructions = (List<Instruction>)_method.Body.Instructions;

            var tryBlocks = new List<TryBlockInfo>();
            foreach (var ex in _method.Body.ExceptionHandlers)
            {
                TryBlockInfo tryBlock = tryBlocks.Find(tryBlocks => tryBlocks.tryStart == ex.TryStart && tryBlocks.tryEnd == ex.TryEnd);
                if (tryBlock == null)
                {
                    int startIndex = inst2Index[ex.TryStart];
                    int endIndex = ex.TryEnd != null ? inst2Index[ex.TryEnd] : inst2Index.Count;
                    TryBlockGroup blockGroup = new TryBlockGroup(instructions.GetRange(startIndex, endIndex - startIndex), inst2blockGroup);
                    tryBlock = new TryBlockInfo
                    {
                        tryStart = ex.TryStart,
                        tryEnd = ex.TryEnd,
                        blockGroup = blockGroup,
                    };
                    tryBlocks.Add(tryBlock);
                }
                if (ex.FilterStart != null)
                {
                    int filterStartIndex = inst2Index[ex.FilterStart];
                    int filterEndIndex = ex.HandlerStart != null ? inst2Index[ex.HandlerStart] : inst2Index.Count;
                    int handlerStartIndex = filterEndIndex;
                    int handlerEndIndex = ex.HandlerEnd != null ? inst2Index[ex.HandlerEnd] : inst2Index.Count;
                    var filterHandlerGroup = new ExceptionHandlerWithFilterGroup(ex,
                        instructions.GetRange(filterStartIndex, filterEndIndex - filterStartIndex),
                        instructions.GetRange(handlerStartIndex, handlerEndIndex - handlerStartIndex),
                        instructions.GetRange(filterStartIndex, handlerEndIndex - filterStartIndex), inst2blockGroup);
                }
                else
                {
                    int handlerStartIndex = inst2Index[ex.HandlerStart];
                    int handlerEndIndex = ex.HandlerEnd != null ? inst2Index[ex.HandlerEnd] : inst2Index.Count;
                    ExceptionHandlerGroup handlerGroup = new ExceptionHandlerGroup(ex, instructions.GetRange(handlerStartIndex, handlerEndIndex - handlerStartIndex), inst2blockGroup);
                }
            }
            var rootGroup = new BlockGroup(new List<Instruction>(instructions), inst2blockGroup);
            rootGroup.SplitInstructionsNotInAnySubGroupsToIndividualGroups(inst2blockGroup);

            rootGroup.ComputeBasicBlocks(BuildInstructionToBasicBlockInfoDic());
            return rootGroup;
        }

        private void FixInstructionTargets()
        {
            var inst2bb = BuildInstructionToBasicBlockInfoDic();
            foreach (var ex in _method.Body.ExceptionHandlers)
            {
                if (ex.TryStart != null)
                {
                    ex.TryStart = inst2bb[ex.TryStart].GroupFirstInstruction;
                }
                if (ex.TryEnd != null)
                {
                    ex.TryEnd = inst2bb[ex.TryEnd].GroupFirstInstruction;
                }
                if (ex.HandlerStart != null)
                {
                    ex.HandlerStart = inst2bb[ex.HandlerStart].GroupFirstInstruction;
                }
                if (ex.HandlerEnd != null)
                {
                    ex.HandlerEnd = inst2bb[ex.HandlerEnd].GroupFirstInstruction;
                }
                if (ex.FilterStart != null)
                {
                    ex.FilterStart = inst2bb[ex.FilterStart].GroupFirstInstruction;
                }
            }
            //foreach (var inst in inst2bb.Keys)
            //{
            //    if (inst.Operand is Instruction targetInst)
            //    {
            //        inst.Operand = inst2bb[targetInst].FirstInstruction;
            //    }
            //    else if (inst.Operand is Instruction[] targetInsts)
            //    {
            //        for (int i = 0; i < targetInsts.Length; i++)
            //        {
            //            targetInsts[i] = inst2bb[targetInsts[i]].FirstInstruction;
            //        }
            //    }
            //}
        }

        private void BuildInstructions()
        {
            IList<Instruction> methodInstructions = _method.Body.Instructions;
            methodInstructions.Clear();
            for (BasicBlockInfo cur = _bbHead.next; cur != null; cur = cur.next)
            {
                foreach (Instruction inst in cur.instructions)
                {
                    methodInstructions.Add(inst);
                }
            }
            _method.Body.InitLocals = true;
            //_method.Body.MaxStack = Math.Max(_method.Body.MaxStack , (ushort)1); // TODO: set to a reasonable value
            //_method.Body.KeepOldMaxStack = true;
            //_method.Body.UpdateInstructionOffsets();
        }

        public bool TryObfus()
        {
            // TODO: TEMP
            //if (_method.Body.HasExceptionHandlers)
            //{
            //    return false;
            //}
            var evc = new EvalStackCalculator(_method);
            BuildBasicBlockLink(evc);
            if (!CheckNotContainsNotSupportedEvalStackData())
            {
                Debug.LogError($"Method {_method.FullName} contains unsupported EvalStackData, obfuscation skipped.");
                return false;
            }
            BlockGroup rootGroup = SplitBasicBlockGroup();
            if (rootGroup.basicBlocks != null && rootGroup.basicBlocks.Count == 1)
            {
                return false;
            }
            ComputeInputOutputArguments();
            AdjustInputOutputEvalStack();
            InsertBrInstructionForConjoinedBasicBlocks();
            InsertSwitchMachineBasicBlockForGroups(rootGroup);

            FixInstructionTargets();
            BuildInstructions();
            return true;
        }
    }
}

```

`Editor/ObfusPasses/ControlFlowObfus/MethodControlFlowCalculator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 144b6474de40382498899f8b1c7f92a3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/EvalStackObfus.meta`:

```meta
fileFormatVersion: 2
guid: 4e82ef0b94e10314cbba0daabfdefe32
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/EvalStackObfus/ConfigurableObfuscationPolicy.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Conf;
using Obfuz.Settings;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Xml;

namespace Obfuz.ObfusPasses.EvalStackObfus
{
    struct ObfuscationRuleData
    {
        public readonly ObfuscationLevel obfuscationLevel;
        public readonly float obfuscationPercentage;
        public ObfuscationRuleData(ObfuscationLevel level, float percentage)
        {
            obfuscationLevel = level;
            obfuscationPercentage = percentage;
        }
    }

    interface IObfuscationPolicy
    {
        bool NeedObfuscate(MethodDef method);

        ObfuscationRuleData GetObfuscationRuleData(MethodDef method);
    }

    abstract class ObfuscationPolicyBase : IObfuscationPolicy
    {
        public abstract bool NeedObfuscate(MethodDef method);

        public abstract ObfuscationRuleData GetObfuscationRuleData(MethodDef method);
    }

    class ConfigurableObfuscationPolicy : ObfuscationPolicyBase
    {
        class ObfuscationRule : IRule<ObfuscationRule>
        {
            public ObfuscationLevel? obfuscationLevel;
            public float? obfuscationPercentage;

            public void InheritParent(ObfuscationRule parentRule)
            {
                if (obfuscationLevel == null)
                    obfuscationLevel = parentRule.obfuscationLevel;
                if (obfuscationPercentage == null)
                    obfuscationPercentage = parentRule.obfuscationPercentage;
            }
        }

        class MethodSpec : MethodRuleBase<ObfuscationRule>
        {
        }

        class TypeSpec : TypeRuleBase<MethodSpec, ObfuscationRule>
        {
        }

        class AssemblySpec : AssemblyRuleBase<TypeSpec, MethodSpec, ObfuscationRule>
        {
        }

        private static readonly ObfuscationRule s_default = new ObfuscationRule()
        {
            obfuscationLevel = ObfuscationLevel.Basic,
            obfuscationPercentage = 0.05f,
        };

        private ObfuscationRule _global;

        private readonly XmlAssemblyTypeMethodRuleParser<AssemblySpec, TypeSpec, MethodSpec, ObfuscationRule> _xmlParser;

        private readonly Dictionary<MethodDef, ObfuscationRule> _methodRuleCache = new Dictionary<MethodDef, ObfuscationRule>();

        public ConfigurableObfuscationPolicy(List<string> toObfuscatedAssemblyNames, List<string> xmlConfigFiles)
        {
            _xmlParser = new XmlAssemblyTypeMethodRuleParser<AssemblySpec, TypeSpec, MethodSpec, ObfuscationRule>(
                toObfuscatedAssemblyNames, ParseObfuscationRule, ParseGlobal);
            LoadConfigs(xmlConfigFiles);
        }

        private void LoadConfigs(List<string> configFiles)
        {
            _xmlParser.LoadConfigs(configFiles);

            if (_global == null)
            {
                _global = s_default;
            }
            else
            {
                _global.InheritParent(s_default);
            }
            if (_global.obfuscationPercentage.Value > 0.1f)
            {
                UnityEngine.Debug.LogWarning($"EvalStackObfus significantly increases the size of the obfuscated hot-update DLL. It is recommended to keep the obfuscationPercentage ≤ 0.1 (currently set to {_global.obfuscationPercentage.Value}).");
            }
            _xmlParser.InheritParentRules(_global);
        }

        private void ParseGlobal(string configFile, XmlElement ele)
        {
            switch (ele.Name)
            {
                case "global": _global = ParseObfuscationRule(configFile, ele); break;
                default: throw new Exception($"Invalid xml file {configFile}, unknown node {ele.Name}");
            }
        }

        private ObfuscationRule ParseObfuscationRule(string configFile, XmlElement ele)
        {
            var rule = new ObfuscationRule();
            if (ele.HasAttribute("obfuscationLevel"))
            {
                rule.obfuscationLevel = ConfigUtil.ParseObfuscationLevel(ele.GetAttribute("obfuscationLevel"));
            }
            if (ele.HasAttribute("obfuscationPercentage"))
            {
                rule.obfuscationPercentage = float.Parse(ele.GetAttribute("obfuscationPercentage"));
            }
            return rule;
        }

        private ObfuscationRule GetMethodObfuscationRule(MethodDef method)
        {
            if (!_methodRuleCache.TryGetValue(method, out var rule))
            {
                rule = _xmlParser.GetMethodRule(method, _global);
                _methodRuleCache[method] = rule;
            }
            return rule;
        }

        public override bool NeedObfuscate(MethodDef method)
        {
            ObfuscationRule rule = GetMethodObfuscationRule(method);
            return rule.obfuscationLevel.Value > ObfuscationLevel.None;
        }

        public override ObfuscationRuleData GetObfuscationRuleData(MethodDef method)
        {
            var rule = GetMethodObfuscationRule(method);
            return new ObfuscationRuleData(rule.obfuscationLevel.Value, rule.obfuscationPercentage.Value);
        }
    }
}

```

`Editor/ObfusPasses/EvalStackObfus/ConfigurableObfuscationPolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8a2603d51f31a134d90599d33664f6c7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/EvalStackObfus/DefaultObfuscator.cs`:

```cs
using dnlib.DotNet.Emit;
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.EvalStackObfus
{
    class DefaultObfuscator : ObfuscatorBase
    {
        public override bool ObfuscateInt(Instruction inst, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            IRandom random = ctx.localRandom;
            switch (random.NextInt(4))
            {
                case 0:
                {
                    // x = x + a
                    int a = 0;
                    float constProbability = 0f;
                    ConstObfusUtil.LoadConstInt(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    return true;
                }
                case 1:
                {
                    // x = x * a * ra
                    int a = random.NextInt() | 0x1; // Ensure a is not zero
                    int ra = MathUtil.ModInverse32(a);
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstInt(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstInt(ra, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    return true;
                }
                case 2:
                {
                    // x = (x * a + b) * ra - (b * ra)
                    int a = random.NextInt() | 0x1; // Ensure a is not zero
                    int ra = MathUtil.ModInverse32(a);
                    int b = random.NextInt();
                    int b_ra = -b * ra;
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstInt(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstInt(b, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    ConstObfusUtil.LoadConstInt(ra, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstInt(b_ra, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    return true;
                }
                case 3:
                {
                    // x = ((x + a) * b + c) * rb - (a*b + c) * rb
                    int a = random.NextInt();
                    int b = random.NextInt() | 0x1; // Ensure b is not zero
                    int rb = MathUtil.ModInverse32(b);
                    int c = random.NextInt();
                    int r = -(a * b + c) * rb;
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstInt(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    ConstObfusUtil.LoadConstInt(b, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstInt(c, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    ConstObfusUtil.LoadConstInt(rb, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstInt(r, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    return true;
                }
                default: return false;
            }
        }

        public override bool ObfuscateLong(Instruction inst, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            IRandom random = ctx.localRandom;
            switch (random.NextInt(4))
            {
                case 0:
                {
                    // x = x + a
                    long a = 0;
                    float constProbability = 0f;
                    ConstObfusUtil.LoadConstLong(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    return true;
                }
                case 1:
                {
                    // x = x * a * ra
                    long a = random.NextLong() | 0x1L; // Ensure a is not zero
                    long ra = MathUtil.ModInverse64(a);
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstLong(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstLong(ra, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    return true;
                }
                case 2:
                {
                    // x = (x * a + b) * ra - (b * ra)
                    long a = random.NextLong() | 0x1L; // Ensure a is not zero
                    long ra = MathUtil.ModInverse64(a);
                    long b = random.NextLong();
                    long b_ra = -b * ra;
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstLong(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstLong(b, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    ConstObfusUtil.LoadConstLong(ra, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstLong(b_ra, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    return true;
                }
                case 3:
                {
                    // x = ((x + a) * b + c) * rb - (a*b + c) * rb
                    long a = random.NextLong();
                    long b = random.NextLong() | 0x1L; // Ensure b is not zero
                    long rb = MathUtil.ModInverse64(b);
                    long c = random.NextLong();
                    long r = -(a * b + c) * rb;
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstLong(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    ConstObfusUtil.LoadConstLong(b, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstLong(c, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    ConstObfusUtil.LoadConstLong(rb, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstLong(r, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    return true;
                }
                default: return false;
            }
        }

        public override bool ObfuscateFloat(Instruction inst, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            IRandom random = ctx.localRandom;
            switch (random.NextInt(3))
            {
                case 0:
                {
                    // x = x + 0f
                    float a = 0.0f;
                    float constProbability = 0f;
                    ConstObfusUtil.LoadConstFloat(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    return true;
                }
                case 1:
                {
                    // x = x * 1f;
                    float a = 1.0f;
                    float constProbability = 0f;
                    ConstObfusUtil.LoadConstFloat(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    return true;
                }
                case 2:
                {
                    // x = (x + a) * b; a = 0.0f, b = 1.0f
                    float a = 0.0f;
                    float b = 1.0f;
                    float constProbability = 0f;
                    ConstObfusUtil.LoadConstFloat(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    ConstObfusUtil.LoadConstFloat(b, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    return true;
                }
                default: return false;
            }
        }

        public override bool ObfuscateDouble(Instruction inst, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            IRandom random = ctx.localRandom;
            switch (random.NextInt(3))
            {
                case 0:
                {
                    // x = x + 0.0
                    double a = 0.0;
                    float constProbability = 0f;
                    ConstObfusUtil.LoadConstDouble(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    return true;
                }
                case 1:
                {
                    // x = x * 1.0;
                    double a = 1.0;
                    float constProbability = 0f;
                    ConstObfusUtil.LoadConstDouble(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    return true;
                }
                case 2:
                {
                    // x = (x + a) * b; a = 0.0, b = 1.0
                    double a = 0.0;
                    double b = 1.0;
                    float constProbability = 0f;
                    ConstObfusUtil.LoadConstDouble(a, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    ConstObfusUtil.LoadConstDouble(b, random, constProbability, ctx.constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    return true;
                }
                default: return false;
            }
        }
    }
}

```

`Editor/ObfusPasses/EvalStackObfus/DefaultObfuscator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 5200244f403139c40b578b2e845508f2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/EvalStackObfus/EvalStackObfusPass.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Data;
using Obfuz.Emit;
using Obfuz.Settings;
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.EvalStackObfus
{
    class ObfusMethodContext
    {
        public MethodDef method;
        public EvalStackCalculator evalStackCalculator;
        public LocalVariableAllocator localVariableAllocator;
        public IRandom localRandom;
        public EncryptionScopeInfo encryptionScope;
        public DefaultMetadataImporter importer;
        public ConstFieldAllocator constFieldAllocator;
        public float obfuscationPercentage;
    }

    internal class EvalStackObfusPass : ObfuscationMethodPassBase
    {
        private readonly EvalStackObfuscationSettingsFacade _settings;

        private IObfuscationPolicy _obfuscationPolicy;
        private IObfuscator _obfuscator;

        public EvalStackObfusPass(EvalStackObfuscationSettingsFacade settings)
        {
            _settings = settings;
            _obfuscator = new DefaultObfuscator();
        }

        public override ObfuscationPassType Type => ObfuscationPassType.EvalStackObfus;

        public override void Start()
        {
            ObfuscationPassContext ctx = ObfuscationPassContext.Current;
            _obfuscationPolicy = new ConfigurableObfuscationPolicy(
                ctx.coreSettings.assembliesToObfuscate,
                _settings.ruleFiles);
        }

        public override void Stop()
        {

        }

        protected override bool NeedObfuscateMethod(MethodDef method)
        {
            return _obfuscationPolicy.NeedObfuscate(method);
        }

        protected bool TryObfuscateInstruction(Instruction inst, EvalDataType dataType, List<Instruction> outputInstructions, ObfusMethodContext ctx)
        {
            switch (dataType)
            {
                case EvalDataType.Int32: return _obfuscator.ObfuscateInt(inst, outputInstructions, ctx);
                case EvalDataType.Int64: return _obfuscator.ObfuscateLong(inst, outputInstructions, ctx);
                case EvalDataType.Float: return _obfuscator.ObfuscateFloat(inst, outputInstructions, ctx);
                case EvalDataType.Double: return _obfuscator.ObfuscateDouble(inst, outputInstructions, ctx);
                default: return false;
            }
        }

        protected override void ObfuscateData(MethodDef method)
        {
            //Debug.Log($"Obfuscating method: {method.FullName} with EvalStackObfusPass");
            IList<Instruction> instructions = method.Body.Instructions;
            var outputInstructions = new List<Instruction>();
            var totalFinalInstructions = new List<Instruction>();

            ObfuscationPassContext ctx = ObfuscationPassContext.Current;
            var calc = new EvalStackCalculator(method);

            GroupByModuleEntityManager moduleEntityManager = ctx.moduleEntityManager;
            var encryptionScope = moduleEntityManager.EncryptionScopeProvider.GetScope(method.Module);
            var ruleData = _obfuscationPolicy.GetObfuscationRuleData(method);
            var localRandom = encryptionScope.localRandomCreator(MethodEqualityComparer.CompareDeclaringTypes.GetHashCode(method));
            var obfusMethodCtx = new ObfusMethodContext
            {
                method = method,
                evalStackCalculator = calc,
                localVariableAllocator = new LocalVariableAllocator(method),
                encryptionScope = encryptionScope,
                constFieldAllocator = moduleEntityManager.GetEntity<ConstFieldAllocator>(method.Module),
                localRandom = localRandom,
                importer = moduleEntityManager.GetEntity<DefaultMetadataImporter>(method.Module),
                obfuscationPercentage = ruleData.obfuscationPercentage,
            };
            for (int i = 0; i < instructions.Count; i++)
            {
                Instruction inst = instructions[i];
                totalFinalInstructions.Add(inst);
                if (calc.TryGetPushResult(inst, out EvalDataType dataType) && localRandom.NextInPercentage(ruleData.obfuscationPercentage))
                {
                    outputInstructions.Clear();
                    if (TryObfuscateInstruction(inst, dataType, outputInstructions, obfusMethodCtx))
                    {
                        totalFinalInstructions.AddRange(outputInstructions);
                    }
                }
            }

            instructions.Clear();
            foreach (var obInst in totalFinalInstructions)
            {
                instructions.Add(obInst);
            }
        }
    }
}

```

`Editor/ObfusPasses/EvalStackObfus/EvalStackObfusPass.cs.meta`:

```meta
fileFormatVersion: 2
guid: 9fa7d3313f260794da2cc36dadaf4fb4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/EvalStackObfus/IObfuscator.cs`:

```cs
using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.EvalStackObfus
{
    interface IObfuscator
    {
        bool ObfuscateInt(Instruction inst, List<Instruction> outputInsts, ObfusMethodContext ctx);

        bool ObfuscateLong(Instruction inst, List<Instruction> outputInsts, ObfusMethodContext ctx);

        bool ObfuscateFloat(Instruction inst, List<Instruction> outputInsts, ObfusMethodContext ctx);

        bool ObfuscateDouble(Instruction inst, List<Instruction> outputInsts, ObfusMethodContext ctx);
    }

    abstract class ObfuscatorBase : IObfuscator
    {
        public abstract bool ObfuscateInt(Instruction inst, List<Instruction> outputInsts, ObfusMethodContext ctx);
        public abstract bool ObfuscateLong(Instruction inst, List<Instruction> outputInsts, ObfusMethodContext ctx);
        public abstract bool ObfuscateFloat(Instruction inst, List<Instruction> outputInsts, ObfusMethodContext ctx);
        public abstract bool ObfuscateDouble(Instruction inst, List<Instruction> outputInsts, ObfusMethodContext ctx);
    }
}

```

`Editor/ObfusPasses/EvalStackObfus/IObfuscator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 17a9f3181d9711f4ca1d0cfb9e813bb0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ExprObfus.meta`:

```meta
fileFormatVersion: 2
guid: 9fdb2c243b1ea0f489e67233fda287c9
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ExprObfus/ConfigurableObfuscationPolicy.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Conf;
using Obfuz.Settings;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Xml;

namespace Obfuz.ObfusPasses.ExprObfus
{
    struct ObfuscationRuleData
    {
        public readonly ObfuscationLevel obfuscationLevel;
        public readonly float obfuscationPercentage;
        public ObfuscationRuleData(ObfuscationLevel level, float percentage)
        {
            obfuscationLevel = level;
            obfuscationPercentage = percentage;
        }
    }

    interface IObfuscationPolicy
    {
        bool NeedObfuscate(MethodDef method);

        ObfuscationRuleData GetObfuscationRuleData(MethodDef method);
    }

    abstract class ObfuscationPolicyBase : IObfuscationPolicy
    {
        public abstract bool NeedObfuscate(MethodDef method);

        public abstract ObfuscationRuleData GetObfuscationRuleData(MethodDef method);
    }

    class ConfigurableObfuscationPolicy : ObfuscationPolicyBase
    {
        class ObfuscationRule : IRule<ObfuscationRule>
        {
            public ObfuscationLevel? obfuscationLevel;
            public float? obfuscationPercentage;

            public void InheritParent(ObfuscationRule parentRule)
            {
                if (obfuscationLevel == null)
                    obfuscationLevel = parentRule.obfuscationLevel;
                if (obfuscationPercentage == null)
                    obfuscationPercentage = parentRule.obfuscationPercentage;
            }
        }

        class MethodSpec : MethodRuleBase<ObfuscationRule>
        {
        }

        class TypeSpec : TypeRuleBase<MethodSpec, ObfuscationRule>
        {
        }

        class AssemblySpec : AssemblyRuleBase<TypeSpec, MethodSpec, ObfuscationRule>
        {
        }

        private static readonly ObfuscationRule s_default = new ObfuscationRule()
        {
            obfuscationLevel = ObfuscationLevel.Basic,
            obfuscationPercentage = 0.3f,
        };

        private ObfuscationRule _global;

        private readonly XmlAssemblyTypeMethodRuleParser<AssemblySpec, TypeSpec, MethodSpec, ObfuscationRule> _xmlParser;

        private readonly Dictionary<MethodDef, ObfuscationRule> _methodRuleCache = new Dictionary<MethodDef, ObfuscationRule>();

        public ConfigurableObfuscationPolicy(List<string> toObfuscatedAssemblyNames, List<string> xmlConfigFiles)
        {
            _xmlParser = new XmlAssemblyTypeMethodRuleParser<AssemblySpec, TypeSpec, MethodSpec, ObfuscationRule>(
                toObfuscatedAssemblyNames, ParseObfuscationRule, ParseGlobal);
            LoadConfigs(xmlConfigFiles);
        }

        private void LoadConfigs(List<string> configFiles)
        {
            _xmlParser.LoadConfigs(configFiles);

            if (_global == null)
            {
                _global = s_default;
            }
            else
            {
                _global.InheritParent(s_default);
            }
            _xmlParser.InheritParentRules(_global);
        }

        private void ParseGlobal(string configFile, XmlElement ele)
        {
            switch (ele.Name)
            {
                case "global": _global = ParseObfuscationRule(configFile, ele); break;
                default: throw new Exception($"Invalid xml file {configFile}, unknown node {ele.Name}");
            }
        }

        private ObfuscationRule ParseObfuscationRule(string configFile, XmlElement ele)
        {
            var rule = new ObfuscationRule();
            if (ele.HasAttribute("obfuscationLevel"))
            {
                rule.obfuscationLevel = ConfigUtil.ParseObfuscationLevel(ele.GetAttribute("obfuscationLevel"));
            }
            if (ele.HasAttribute("obfuscationPercentage"))
            {
                rule.obfuscationPercentage = float.Parse(ele.GetAttribute("obfuscationPercentage"));
            }
            return rule;
        }

        private ObfuscationRule GetMethodObfuscationRule(MethodDef method)
        {
            if (!_methodRuleCache.TryGetValue(method, out var rule))
            {
                rule = _xmlParser.GetMethodRule(method, _global);
                _methodRuleCache[method] = rule;
            }
            return rule;
        }

        public override bool NeedObfuscate(MethodDef method)
        {
            ObfuscationRule rule = GetMethodObfuscationRule(method);
            return rule.obfuscationLevel.Value > ObfuscationLevel.None;
        }

        public override ObfuscationRuleData GetObfuscationRuleData(MethodDef method)
        {
            var rule = GetMethodObfuscationRule(method);
            return new ObfuscationRuleData(rule.obfuscationLevel.Value, rule.obfuscationPercentage.Value);
        }
    }
}

```

`Editor/ObfusPasses/ExprObfus/ConfigurableObfuscationPolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: 5f820a225c981b8499016958e6c69747
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ExprObfus/ExprObfusPass.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Data;
using Obfuz.Emit;
using Obfuz.ObfusPasses.ExprObfus.Obfuscators;
using Obfuz.Settings;
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.ExprObfus
{
    class ObfusMethodContext
    {
        public MethodDef method;
        public EvalStackCalculator evalStackCalculator;
        public LocalVariableAllocator localVariableAllocator;
        public IRandom localRandom;
        public EncryptionScopeInfo encryptionScope;
        public DefaultMetadataImporter importer;
        public ConstFieldAllocator constFieldAllocator;
        public float obfuscationPercentage;
    }

    class ExprObfusPass : ObfuscationMethodPassBase
    {
        private readonly ExprObfuscationSettingsFacade _settings;
        private readonly IObfuscator _basicObfuscator;
        private readonly IObfuscator _advancedObfuscator;
        private readonly IObfuscator _mostAdvancedObfuscator;

        private IObfuscationPolicy _obfuscationPolicy;

        public ExprObfusPass(ExprObfuscationSettingsFacade settings)
        {
            _settings = settings;
            _basicObfuscator = new BasicObfuscator();
            _advancedObfuscator = new AdvancedObfuscator();
            _mostAdvancedObfuscator = new MostAdvancedObfuscator();
        }

        public override ObfuscationPassType Type => ObfuscationPassType.ExprObfus;

        public override void Start()
        {
            ObfuscationPassContext ctx = ObfuscationPassContext.Current;
            _obfuscationPolicy = new ConfigurableObfuscationPolicy(
                ctx.coreSettings.assembliesToObfuscate,
                _settings.ruleFiles);
        }

        private IObfuscator GetObfuscator(ObfuscationLevel level)
        {
            switch (level)
            {
                case ObfuscationLevel.None: return null;
                case ObfuscationLevel.Basic: return _basicObfuscator;
                case ObfuscationLevel.Advanced: return _advancedObfuscator;
                case ObfuscationLevel.MostAdvanced: return _mostAdvancedObfuscator;
                default: throw new System.ArgumentOutOfRangeException(nameof(level), level, "Unknown obfuscation level");
            }
        }

        public override void Stop()
        {

        }

        protected override bool NeedObfuscateMethod(MethodDef method)
        {
            return _obfuscationPolicy.NeedObfuscate(method);
        }

        protected bool TryObfuscateInstruction(IObfuscator obfuscator, InstructionParameterInfo pi, Instruction inst, List<Instruction> outputInstructions, ObfusMethodContext ctx)
        {
            //Debug.Log($"Obfuscating instruction: {inst} in method: {ctx.method.FullName}");
            IRandom localRandom = ctx.localRandom;
            float obfuscationPercentage = ctx.obfuscationPercentage;
            switch (inst.OpCode.Code)
            {
                case Code.Neg:
                {
                    return localRandom.NextInPercentage(obfuscationPercentage) && obfuscator.ObfuscateBasicUnaryOp(inst, pi.op1, pi.retType, outputInstructions, ctx);
                }
                case Code.Add:
                case Code.Sub:
                case Code.Mul:
                case Code.Div:
                case Code.Div_Un:
                case Code.Rem:
                case Code.Rem_Un:
                {
                    return localRandom.NextInPercentage(obfuscationPercentage) && obfuscator.ObfuscateBasicBinOp(inst, pi.op1, pi.op2, pi.retType, outputInstructions, ctx);
                }
                case Code.And:
                case Code.Or:
                case Code.Xor:
                {
                    return localRandom.NextInPercentage(obfuscationPercentage) && obfuscator.ObfuscateBinBitwiseOp(inst, pi.op1, pi.op2, pi.retType, outputInstructions, ctx);
                }
                case Code.Not:
                {
                    return localRandom.NextInPercentage(obfuscationPercentage) && obfuscator.ObfuscateUnaryBitwiseOp(inst, pi.op1, pi.retType, outputInstructions, ctx);
                }
                case Code.Shl:
                case Code.Shr:
                case Code.Shr_Un:
                {
                    return localRandom.NextInPercentage(obfuscationPercentage) && obfuscator.ObfuscateBitShiftOp(inst, pi.op1, pi.op2, pi.retType, outputInstructions, ctx);
                }
            }
            return false;
        }

        protected override void ObfuscateData(MethodDef method)
        {
            //Debug.Log($"Obfuscating method: {method.FullName} with ExprObfusPass");
            IList<Instruction> instructions = method.Body.Instructions;
            var outputInstructions = new List<Instruction>();
            var totalFinalInstructions = new List<Instruction>();

            ObfuscationPassContext ctx = ObfuscationPassContext.Current;
            var calc = new EvalStackCalculator(method);

            GroupByModuleEntityManager moduleEntityManager = ctx.moduleEntityManager;
            var encryptionScope = moduleEntityManager.EncryptionScopeProvider.GetScope(method.Module);
            var ruleData = _obfuscationPolicy.GetObfuscationRuleData(method);
            var obfuscator = GetObfuscator(ruleData.obfuscationLevel);
            var obfusMethodCtx = new ObfusMethodContext
            {
                method = method,
                evalStackCalculator = calc,
                localVariableAllocator = new LocalVariableAllocator(method),
                encryptionScope = encryptionScope,
                constFieldAllocator = moduleEntityManager.GetEntity<ConstFieldAllocator>(method.Module),
                localRandom = encryptionScope.localRandomCreator(MethodEqualityComparer.CompareDeclaringTypes.GetHashCode(method)),
                importer = moduleEntityManager.GetEntity<DefaultMetadataImporter>(method.Module),
                obfuscationPercentage = ruleData.obfuscationPercentage,
            };
            for (int i = 0; i < instructions.Count; i++)
            {
                Instruction inst = instructions[i];
                bool add = false;
                if (calc.TryGetParameterInfo(inst, out InstructionParameterInfo pi))
                {
                    outputInstructions.Clear();
                    if (TryObfuscateInstruction(obfuscator, pi, inst, outputInstructions, obfusMethodCtx))
                    {
                        // current instruction may be the target of control flow instruction, so we can't remove it directly.
                        // we replace it with nop now, then remove it in CleanUpInstructionPass
                        inst.OpCode = outputInstructions[0].OpCode;
                        inst.Operand = outputInstructions[0].Operand;
                        totalFinalInstructions.Add(inst);
                        for (int k = 1; k < outputInstructions.Count; k++)
                        {
                            totalFinalInstructions.Add(outputInstructions[k]);
                        }
                        add = true;
                    }
                }
                if (!add)
                {
                    totalFinalInstructions.Add(inst);
                }
            }

            instructions.Clear();
            foreach (var obInst in totalFinalInstructions)
            {
                instructions.Add(obInst);
            }
        }
    }
}

```

`Editor/ObfusPasses/ExprObfus/ExprObfusPass.cs.meta`:

```meta
fileFormatVersion: 2
guid: 477e081ffc0072e4fa1a06100269e4a3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ExprObfus/IObfuscator.cs`:

```cs
using dnlib.DotNet.Emit;
using Obfuz.Emit;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.ExprObfus
{
    interface IObfuscator
    {
        bool ObfuscateBasicUnaryOp(Instruction inst, EvalDataType op, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx);

        bool ObfuscateBasicBinOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx);

        bool ObfuscateUnaryBitwiseOp(Instruction inst, EvalDataType op, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx);

        bool ObfuscateBinBitwiseOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx);

        bool ObfuscateBitShiftOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx);
    }

    abstract class ObfuscatorBase : IObfuscator
    {
        public abstract bool ObfuscateBasicUnaryOp(Instruction inst, EvalDataType op, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx);
        public abstract bool ObfuscateBasicBinOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx);
        public abstract bool ObfuscateUnaryBitwiseOp(Instruction inst, EvalDataType op, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx);
        public abstract bool ObfuscateBinBitwiseOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx);
        public abstract bool ObfuscateBitShiftOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx);
    }
}

```

`Editor/ObfusPasses/ExprObfus/IObfuscator.cs.meta`:

```meta
fileFormatVersion: 2
guid: a88981a87bcd9e84b883e39c81cfbf44
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ExprObfus/Obfuscators.meta`:

```meta
fileFormatVersion: 2
guid: 4c5dc8736831c9f4b934c69f7894a412
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ExprObfus/Obfuscators/AdvancedObfuscator.cs`:

```cs
using dnlib.DotNet.Emit;
using Obfuz.Data;
using Obfuz.Emit;
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.ExprObfus.Obfuscators
{
    class AdvancedObfuscator : BasicObfuscator
    {
        protected bool GenerateIdentityTransformForArgument(Instruction inst, EvalDataType op, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            IRandom random = ctx.localRandom;
            ConstFieldAllocator constFieldAllocator = ctx.constFieldAllocator;
            switch (op)
            {
                case EvalDataType.Int32:
                {
                    //  = x + y = x + (y * a + b) * ra + (-b * ra)
                    int a = random.NextInt() | 0x1;
                    int ra = MathUtil.ModInverse32(a);
                    int b = random.NextInt();
                    int b_ra = -b * ra;
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstInt(a, random, constProbability, constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstInt(b, random, constProbability, constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    ConstObfusUtil.LoadConstInt(ra, random, constProbability, constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstInt(b_ra, random, constProbability, constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    outputInsts.Add(inst.Clone());
                    return true;
                }
                case EvalDataType.Int64:
                {
                    //  = x + y = x + (y * a + b) * ra + (-b * ra)
                    long a = random.NextLong() | 0x1L;
                    long ra = MathUtil.ModInverse64(a);
                    long b = random.NextLong();
                    long b_ra = -b * ra;
                    float constProbability = 0.5f;
                    ConstObfusUtil.LoadConstLong(a, random, constProbability, constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstLong(b, random, constProbability, constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    ConstObfusUtil.LoadConstLong(ra, random, constProbability, constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    ConstObfusUtil.LoadConstLong(b_ra, random, constProbability, constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    outputInsts.Add(inst.Clone());
                    return true;
                }
                case EvalDataType.Float:
                {
                    //  = x + y = x + (y + a) * b; a = 0.0f, b = 1.0f
                    float a = 0.0f;
                    float b = 1.0f;
                    float constProbability = 0f;
                    ConstObfusUtil.LoadConstFloat(a, random, constProbability, constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    ConstObfusUtil.LoadConstFloat(b, random, constProbability, constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    outputInsts.Add(inst.Clone());
                    return true;
                }
                case EvalDataType.Double:
                {
                    //  = x + y = x + (y + a) * b; a = 0.0, b = 1.0
                    double a = 0.0;
                    double b = 1.0;
                    float constProbability = 0f;
                    ConstObfusUtil.LoadConstDouble(a, random, constProbability, constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Add));
                    ConstObfusUtil.LoadConstDouble(b, random, constProbability, constFieldAllocator, outputInsts);
                    outputInsts.Add(Instruction.Create(OpCodes.Mul));
                    outputInsts.Add(inst.Clone());
                    return true;
                }
                default: return false;
            }
        }

        public override bool ObfuscateBasicUnaryOp(Instruction inst, EvalDataType op, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            return GenerateIdentityTransformForArgument(inst, op, outputInsts, ctx) || base.ObfuscateBasicUnaryOp(inst, op, ret, outputInsts, ctx);
        }

        public override bool ObfuscateBasicBinOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            return GenerateIdentityTransformForArgument(inst, op2, outputInsts, ctx) || base.ObfuscateBasicBinOp(inst, op1, op2, ret, outputInsts, ctx);
        }

        public override bool ObfuscateUnaryBitwiseOp(Instruction inst, EvalDataType op, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            return GenerateIdentityTransformForArgument(inst, op, outputInsts, ctx) || base.ObfuscateUnaryBitwiseOp(inst, op, ret, outputInsts, ctx);
        }

        public override bool ObfuscateBinBitwiseOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            return GenerateIdentityTransformForArgument(inst, op2, outputInsts, ctx) || base.ObfuscateBinBitwiseOp(inst, op1, op2, ret, outputInsts, ctx);
        }

        public override bool ObfuscateBitShiftOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            return GenerateIdentityTransformForArgument(inst, op2, outputInsts, ctx) || base.ObfuscateBitShiftOp(inst, op1, op2, ret, outputInsts, ctx);
        }
    }
}

```

`Editor/ObfusPasses/ExprObfus/Obfuscators/AdvancedObfuscator.cs.meta`:

```meta
fileFormatVersion: 2
guid: ef717515402ca2f41a52db7ea1300f32
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ExprObfus/Obfuscators/BasicObfuscator.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Emit;
using System.Collections.Generic;
using UnityEngine;

namespace Obfuz.ObfusPasses.ExprObfus.Obfuscators
{

    class BasicObfuscator : ObfuscatorBase
    {
        private IMethod GetUnaryOpMethod(DefaultMetadataImporter importer, Code code, EvalDataType op1)
        {
            switch (code)
            {
                case Code.Neg:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.NegInt;
                        case EvalDataType.Int64: return importer.NegLong;
                        case EvalDataType.Float: return importer.NegFloat;
                        case EvalDataType.Double: return importer.NegDouble;
                        default: return null;
                    }
                }
                case Code.Not:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.NotInt;
                        case EvalDataType.Int64: return importer.NotLong;
                        default: return null;
                    }
                }
                default: return null;
            }
        }

        private IMethod GetBinaryOpMethod(DefaultMetadataImporter importer, Code code, EvalDataType op1, EvalDataType op2)
        {
            switch (code)
            {
                case Code.Add:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return op2 == op1 ? importer.AddInt : null;
                        case EvalDataType.Int64: return op2 == op1 ? importer.AddLong : null;
                        case EvalDataType.Float: return op2 == op1 ? importer.AddFloat : null;
                        case EvalDataType.Double: return op2 == op1 ? importer.AddDouble : null;
                        case EvalDataType.I:
                        {
                            switch (op2)
                            {
                                case EvalDataType.I: return importer.AddIntPtr;
                                case EvalDataType.Int32: return importer.AddIntPtrInt;
                                default: return null;
                            }
                        }
                        default: return null;
                    }
                }
                case Code.Sub:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return op2 == op1 ? importer.SubtractInt : null;
                        case EvalDataType.Int64: return op2 == op1 ? importer.SubtractLong : null;
                        case EvalDataType.Float: return op2 == op1 ? importer.SubtractFloat : null;
                        case EvalDataType.Double: return op2 == op1 ? importer.SubtractDouble : null;
                        case EvalDataType.I:
                        {
                            switch (op2)
                            {
                                case EvalDataType.I: return importer.SubtractIntPtr;
                                case EvalDataType.Int32: return importer.SubtractIntPtrInt;
                                default: return null;
                            }
                        }
                        default: return null;
                    }
                }
                case Code.Mul:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return op2 == op1 ? importer.MultiplyInt : null;
                        case EvalDataType.Int64: return op2 == op1 ? importer.MultiplyLong : null;
                        case EvalDataType.Float: return op2 == op1 ? importer.MultiplyFloat : null;
                        case EvalDataType.Double: return op2 == op1 ? importer.MultiplyDouble : null;
                        case EvalDataType.I:
                        {
                            switch (op2)
                            {
                                case EvalDataType.I: return importer.MultiplyIntPtr;
                                case EvalDataType.Int32: return importer.MultiplyIntPtrInt;
                                default: return null;
                            }
                        }
                        default: return null;
                    }
                }
                case Code.Div:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.DivideInt;
                        case EvalDataType.Int64: return importer.DivideLong;
                        case EvalDataType.Float: return importer.DivideFloat;
                        case EvalDataType.Double: return importer.DivideDouble;
                        default: return null;
                    }
                }
                case Code.Div_Un:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.DivideUnInt;
                        case EvalDataType.Int64: return importer.DivideUnLong;
                        default: return null;
                    }
                }
                case Code.Rem:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.RemInt;
                        case EvalDataType.Int64: return importer.RemLong;
                        case EvalDataType.Float: return importer.RemFloat;
                        case EvalDataType.Double: return importer.RemDouble;
                        default: return null;
                    }
                }
                case Code.Rem_Un:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.RemUnInt;
                        case EvalDataType.Int64: return importer.RemUnLong;
                        default: return null;
                    }
                }
                case Code.Neg:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.NegInt;
                        case EvalDataType.Int64: return importer.NegLong;
                        case EvalDataType.Float: return importer.NegFloat;
                        case EvalDataType.Double: return importer.NegDouble;
                        default: return null;
                    }
                }
                case Code.And:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.AndInt;
                        case EvalDataType.Int64: return importer.AndLong;
                        default: return null;
                    }
                }
                case Code.Or:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.OrInt;
                        case EvalDataType.Int64: return importer.OrLong;
                        default: return null;
                    }
                }
                case Code.Xor:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.XorInt;
                        case EvalDataType.Int64: return importer.XorLong;
                        default: return null;
                    }
                }
                case Code.Not:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.NotInt;
                        case EvalDataType.Int64: return importer.NotLong;
                        default: return null;
                    }
                }
                case Code.Shl:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.ShlInt;
                        case EvalDataType.Int64: return importer.ShlLong;
                        default: return null;
                    }
                }
                case Code.Shr:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.ShrInt;
                        case EvalDataType.Int64: return importer.ShrLong;
                        default: return null;
                    }
                }
                case Code.Shr_Un:
                {
                    switch (op1)
                    {
                        case EvalDataType.Int32: return importer.ShrUnInt;
                        case EvalDataType.Int64: return importer.ShrUnLong;
                        default: return null;
                    }
                }
                default: return null;
            }
        }

        public override bool ObfuscateBasicUnaryOp(Instruction inst, EvalDataType op, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            IMethod opMethod = GetUnaryOpMethod(ctx.importer, inst.OpCode.Code, op);
            if (opMethod == null)
            {
                Debug.LogWarning($"BasicObfuscator: Cannot obfuscate unary operation {inst.OpCode.Code} with different operand types: op={op}. This is a limitation of the BasicObfuscator.");
                return false;
            }
            outputInsts.Add(Instruction.Create(OpCodes.Call, opMethod));
            return true;
        }

        public override bool ObfuscateBasicBinOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            IMethod opMethod = GetBinaryOpMethod(ctx.importer, inst.OpCode.Code, op1, op2);
            if (opMethod == null)
            {
                Debug.LogWarning($"BasicObfuscator: Cannot obfuscate binary operation {inst.OpCode.Code} with different operand types: op1={op1}, op2={op2}, ret={ret}. This is a limitation of the BasicObfuscator.");
                return false;
            }
            outputInsts.Add(Instruction.Create(OpCodes.Call, opMethod));
            return true;
        }

        public override bool ObfuscateUnaryBitwiseOp(Instruction inst, EvalDataType op, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            IMethod opMethod = GetUnaryOpMethod(ctx.importer, inst.OpCode.Code, op);
            if (opMethod == null)
            {
                Debug.LogWarning($"BasicObfuscator: Cannot obfuscate unary operation {inst.OpCode.Code} with different operand types: op={op}. This is a limitation of the BasicObfuscator.");
                return false;
            }
            outputInsts.Add(Instruction.Create(OpCodes.Call, opMethod));
            return true;
        }

        public override bool ObfuscateBinBitwiseOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            IMethod opMethod = GetBinaryOpMethod(ctx.importer, inst.OpCode.Code, op1, op2);
            if (opMethod == null)
            {
                Debug.LogWarning($"BasicObfuscator: Cannot obfuscate binary operation {inst.OpCode.Code} with different operand types: op1={op1}, op2={op2}, ret={ret}. This is a limitation of the BasicObfuscator.");
                return false;
            }
            outputInsts.Add(Instruction.Create(OpCodes.Call, opMethod));
            return true;
        }

        public override bool ObfuscateBitShiftOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            IMethod opMethod = GetBinaryOpMethod(ctx.importer, inst.OpCode.Code, op1, op2);
            if (opMethod == null)
            {
                Debug.LogWarning($"BasicObfuscator: Cannot obfuscate binary operation {inst.OpCode.Code} with operand type {op2}. This is a limitation of the BasicObfuscator.");
                return false;
            }
            outputInsts.Add(Instruction.Create(OpCodes.Call, opMethod));
            return true;
        }
    }
}

```

`Editor/ObfusPasses/ExprObfus/Obfuscators/BasicObfuscator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 578caeae17526b54c9ff1979d897feb7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ExprObfus/Obfuscators/MostAdvancedObfuscator.cs`:

```cs
using dnlib.DotNet.Emit;
using Obfuz.Emit;
using System.Collections.Generic;
using System.Linq;

namespace Obfuz.ObfusPasses.ExprObfus.Obfuscators
{
    class MostAdvancedObfuscator : AdvancedObfuscator
    {
        private readonly BasicObfuscator _basicObfuscator = new BasicObfuscator();

        public override bool ObfuscateBasicUnaryOp(Instruction inst, EvalDataType op, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            if (!base.ObfuscateBasicUnaryOp(inst, op, ret, outputInsts, ctx))
            {
                return false;
            }
            if (outputInsts.Last().OpCode.Code != inst.OpCode.Code)
            {
                return false;
            }
            outputInsts.RemoveAt(outputInsts.Count - 1);
            return _basicObfuscator.ObfuscateBasicUnaryOp(inst, op, ret, outputInsts, ctx);
        }

        public override bool ObfuscateBasicBinOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            if (!base.ObfuscateBasicBinOp(inst, op1, op2, ret, outputInsts, ctx))
            {
                return false;
            }
            if (outputInsts.Last().OpCode.Code != inst.OpCode.Code)
            {
                return false;
            }
            outputInsts.RemoveAt(outputInsts.Count - 1);
            return _basicObfuscator.ObfuscateBasicBinOp(inst, op1, op2, ret, outputInsts, ctx);
        }

        public override bool ObfuscateUnaryBitwiseOp(Instruction inst, EvalDataType op, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            if (!base.ObfuscateUnaryBitwiseOp(inst, op, ret, outputInsts, ctx))
            {
                return false;
            }

            if (outputInsts.Last().OpCode.Code != inst.OpCode.Code)
            {
                return false;
            }
            outputInsts.RemoveAt(outputInsts.Count - 1);
            return _basicObfuscator.ObfuscateUnaryBitwiseOp(inst, op, ret, outputInsts, ctx);
        }

        public override bool ObfuscateBinBitwiseOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            if (!base.ObfuscateBinBitwiseOp(inst, op1, op2, ret, outputInsts, ctx))
            {
                return false;
            }
            if (outputInsts.Last().OpCode.Code != inst.OpCode.Code)
            {
                return false;
            }
            outputInsts.RemoveAt(outputInsts.Count - 1);
            return _basicObfuscator.ObfuscateBinBitwiseOp(inst, op1, op2, ret, outputInsts, ctx);
        }

        public override bool ObfuscateBitShiftOp(Instruction inst, EvalDataType op1, EvalDataType op2, EvalDataType ret, List<Instruction> outputInsts, ObfusMethodContext ctx)
        {
            if (!base.ObfuscateBitShiftOp(inst, op1, op2, ret, outputInsts, ctx))
            {
                return false;
            }
            if (outputInsts.Last().OpCode.Code != inst.OpCode.Code)
            {
                return false;
            }
            outputInsts.RemoveAt(outputInsts.Count - 1);
            return _basicObfuscator.ObfuscateBitShiftOp(inst, op1, op2, ret, outputInsts, ctx);
        }
    }
}

```

`Editor/ObfusPasses/ExprObfus/Obfuscators/MostAdvancedObfuscator.cs.meta`:

```meta
fileFormatVersion: 2
guid: af5946ac6cb0a8b4fa75321439785133
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/FieldEncrypt.meta`:

```meta
fileFormatVersion: 2
guid: 0b789725c4848bd4fb4b3ce1f2e2a9c9
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/FieldEncrypt/ConfigurableEncryptPolicy.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Conf;
using Obfuz.Utils;
using System.Collections.Generic;
using System.Xml;

namespace Obfuz.ObfusPasses.FieldEncrypt
{
    public class ConfigurableEncryptPolicy : EncryptPolicyBase
    {
        class ObfuscationRule
        {

        }

        private readonly XmlFieldRuleParser<ObfuscationRule> _configParser;
        private readonly ObfuzIgnoreScopeComputeCache _obfuzIgnoreScopeComputeCache;

        public ConfigurableEncryptPolicy(ObfuzIgnoreScopeComputeCache obfuzIgnoreScopeComputeCache, List<string> toObfuscatedAssemblyNames, List<string> configFiles)
        {
            _obfuzIgnoreScopeComputeCache = obfuzIgnoreScopeComputeCache;
            _configParser = new XmlFieldRuleParser<ObfuscationRule>(toObfuscatedAssemblyNames, ParseRule, null);
            _configParser.LoadConfigs(configFiles);
        }

        private ObfuscationRule ParseRule(string configFile, XmlElement ele)
        {
            return new ObfuscationRule();
        }

        public override bool NeedEncrypt(FieldDef field)
        {
            if (MetaUtil.HasEncryptFieldAttribute(field))
            {
                return true;
            }
            if (_obfuzIgnoreScopeComputeCache.HasSelfOrDeclaringOrEnclosingOrInheritObfuzIgnoreScope(field, field.DeclaringType, ObfuzScope.Field))
            {
                return false;
            }
            var rule = _configParser.GetFieldRule(field);
            return rule != null;
        }
    }
}

```

`Editor/ObfusPasses/FieldEncrypt/ConfigurableEncryptPolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6b17fa09ce58526459f2b9e375c31cad
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/FieldEncrypt/DefaultFieldEncryptor.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Emit;
using Obfuz.Settings;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using UnityEngine.Assertions;

namespace Obfuz.ObfusPasses.FieldEncrypt
{
    public class DefaultFieldEncryptor : FieldEncryptorBase
    {
        private readonly GroupByModuleEntityManager _moduleEntityManager;
        private readonly FieldEncryptionSettingsFacade _settings;

        public DefaultFieldEncryptor(GroupByModuleEntityManager moduleEntityManager, FieldEncryptionSettingsFacade settings)
        {
            _moduleEntityManager = moduleEntityManager;
            _settings = settings;
        }

        class FieldEncryptInfo
        {
            public int encryptOps;
            public int salt;
            public ElementType fieldType;
            public long xorValueForZero;
        }

        private readonly Dictionary<FieldDef, FieldEncryptInfo> _fieldEncryptInfoCache = new Dictionary<FieldDef, FieldEncryptInfo>();


        private long CalcXorValueForZero(IEncryptor encryptor, ElementType type, int encryptOps, int salt)
        {
            switch (type)
            {
                case ElementType.I4:
                case ElementType.U4:
                case ElementType.R4:
                return encryptor.Encrypt(0, encryptOps, salt);
                case ElementType.I8:
                case ElementType.U8:
                case ElementType.R8:
                return encryptor.Encrypt(0L, encryptOps, salt);
                default:
                throw new NotSupportedException($"Unsupported field type: {type} for encryption");
            }
        }


        private IRandom CreateRandomForField(RandomCreator randomCreator, FieldDef field)
        {
            return randomCreator(FieldEqualityComparer.CompareDeclaringTypes.GetHashCode(field));
        }

        private int GenerateEncryptionOperations(IRandom random, IEncryptor encryptor)
        {
            return EncryptionUtil.GenerateEncryptionOpCodes(random, encryptor, _settings.encryptionLevel);
        }

        public int GenerateSalt(IRandom random)
        {
            return random.NextInt();
        }

        private FieldEncryptInfo GetFieldEncryptInfo(FieldDef field)
        {
            if (_fieldEncryptInfoCache.TryGetValue(field, out var info))
            {
                return info;
            }
            EncryptionScopeInfo encryptionScope = _moduleEntityManager.EncryptionScopeProvider.GetScope(field.Module);

            IRandom random = CreateRandomForField(encryptionScope.localRandomCreator, field);
            IEncryptor encryptor = encryptionScope.encryptor;
            int encryptOps = GenerateEncryptionOperations(random, encryptor);
            int salt = GenerateSalt(random);
            ElementType fieldType = field.FieldSig.Type.RemovePinnedAndModifiers().ElementType;
            long xorValueForZero = CalcXorValueForZero(encryptor, fieldType, encryptOps, salt);

            info = new FieldEncryptInfo
            {
                encryptOps = encryptOps,
                salt = salt,
                fieldType = fieldType,
                xorValueForZero = xorValueForZero,
            };
            _fieldEncryptInfoCache[field] = info;
            return info;
        }

        public override void Encrypt(MethodDef method, FieldDef field, List<Instruction> outputInstructions, Instruction currentInstruction)
        {
            DefaultMetadataImporter importer = _moduleEntityManager.GetEntity<DefaultMetadataImporter>(method.Module);
            EncryptionServiceMetadataImporter encryptionServiceMetadataImporter = importer.GetEncryptionServiceMetadataImporterOfModule(field.Module);
            FieldEncryptInfo fei = GetFieldEncryptInfo(field);
            if (fei.fieldType == ElementType.I4 || fei.fieldType == ElementType.U4 || fei.fieldType == ElementType.R4)
            {
                // value has been put on stack

                if (fei.fieldType == ElementType.R4)
                {
                    outputInstructions.Add(Instruction.Create(OpCodes.Call, importer.CastFloatAsInt));
                }
                // encrypt
                outputInstructions.Add(Instruction.CreateLdcI4(fei.encryptOps));
                outputInstructions.Add(Instruction.CreateLdcI4(fei.salt));
                outputInstructions.Add(Instruction.Create(OpCodes.Call, encryptionServiceMetadataImporter.EncryptInt));
                // xor
                outputInstructions.Add(Instruction.CreateLdcI4((int)fei.xorValueForZero));
                outputInstructions.Add(Instruction.Create(OpCodes.Xor));

                if (fei.fieldType == ElementType.R4)
                {
                    outputInstructions.Add(Instruction.Create(OpCodes.Call, importer.CastIntAsFloat));
                }
            }
            else if (fei.fieldType == ElementType.I8 || fei.fieldType == ElementType.U8 || fei.fieldType == ElementType.R8)
            {
                // value has been put on stack
                if (fei.fieldType == ElementType.R8)
                {
                    outputInstructions.Add(Instruction.Create(OpCodes.Call, importer.CastDoubleAsLong));
                }

                // encrypt
                outputInstructions.Add(Instruction.CreateLdcI4(fei.encryptOps));
                outputInstructions.Add(Instruction.CreateLdcI4(fei.salt));
                outputInstructions.Add(Instruction.Create(OpCodes.Call, encryptionServiceMetadataImporter.EncryptLong));
                // xor
                outputInstructions.Add(Instruction.Create(OpCodes.Ldc_I8, fei.xorValueForZero));
                outputInstructions.Add(Instruction.Create(OpCodes.Xor));
                if (fei.fieldType == ElementType.R8)
                {
                    outputInstructions.Add(Instruction.Create(OpCodes.Call, importer.CastLongAsDouble));
                }
            }
            else
            {
                Assert.IsTrue(false, $"Unsupported field type: {fei.fieldType} for encryption");
            }

            outputInstructions.Add(currentInstruction.Clone());
        }

        public override void Decrypt(MethodDef method, FieldDef field, List<Instruction> outputInstructions, Instruction currentInstruction)
        {
            outputInstructions.Add(currentInstruction.Clone());
            DefaultMetadataImporter importer = _moduleEntityManager.GetEntity<DefaultMetadataImporter>(method.Module);
            EncryptionServiceMetadataImporter encryptionServiceMetadataImporter = importer.GetEncryptionServiceMetadataImporterOfModule(field.Module);
            FieldEncryptInfo fei = GetFieldEncryptInfo(field);
            if (fei.fieldType == ElementType.I4 || fei.fieldType == ElementType.U4 || fei.fieldType == ElementType.R4)
            {
                // value has been put on stack
                // xor
                if (fei.fieldType == ElementType.R4)
                {
                    outputInstructions.Add(Instruction.Create(OpCodes.Call, importer.CastFloatAsInt));
                }
                outputInstructions.Add(Instruction.CreateLdcI4((int)fei.xorValueForZero));
                outputInstructions.Add(Instruction.Create(OpCodes.Xor));

                // decrypt
                outputInstructions.Add(Instruction.CreateLdcI4(fei.encryptOps));
                outputInstructions.Add(Instruction.CreateLdcI4(fei.salt));
                outputInstructions.Add(Instruction.Create(OpCodes.Call, encryptionServiceMetadataImporter.DecryptInt));

                if (fei.fieldType == ElementType.R4)
                {
                    outputInstructions.Add(Instruction.Create(OpCodes.Call, importer.CastIntAsFloat));
                }
            }
            else if (fei.fieldType == ElementType.I8 || fei.fieldType == ElementType.U8 || fei.fieldType == ElementType.R8)
            {
                // value has been put on stack
                // xor
                if (fei.fieldType == ElementType.R8)
                {
                    outputInstructions.Add(Instruction.Create(OpCodes.Call, importer.CastDoubleAsLong));
                }
                outputInstructions.Add(Instruction.Create(OpCodes.Ldc_I8, fei.xorValueForZero));
                outputInstructions.Add(Instruction.Create(OpCodes.Xor));

                // decrypt
                outputInstructions.Add(Instruction.CreateLdcI4(fei.encryptOps));
                outputInstructions.Add(Instruction.CreateLdcI4(fei.salt));
                outputInstructions.Add(Instruction.Create(OpCodes.Call, encryptionServiceMetadataImporter.DecryptLong));

                if (fei.fieldType == ElementType.R8)
                {
                    outputInstructions.Add(Instruction.Create(OpCodes.Call, importer.CastLongAsDouble));
                }
            }
            else
            {
                Assert.IsTrue(false, $"Unsupported field type: {fei.fieldType} for decryption");
            }
        }
    }
}

```

`Editor/ObfusPasses/FieldEncrypt/DefaultFieldEncryptor.cs.meta`:

```meta
fileFormatVersion: 2
guid: b6707a66ae63e2c498d55088c6e8ef4a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/FieldEncrypt/FieldEncryptPass.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Settings;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.FieldEncrypt
{

    public class FieldEncryptPass : InstructionObfuscationPassBase
    {
        private FieldEncryptionSettingsFacade _settings;
        private IEncryptPolicy _encryptionPolicy;
        private IFieldEncryptor _memoryEncryptor;

        public override ObfuscationPassType Type => ObfuscationPassType.FieldEncrypt;

        public FieldEncryptPass(FieldEncryptionSettingsFacade settings)
        {
            _settings = settings;
        }

        protected override bool ForceProcessAllAssembliesAndIgnoreAllPolicy => true;

        public override void Start()
        {
            var ctx = ObfuscationPassContext.Current;
            _memoryEncryptor = new DefaultFieldEncryptor(ctx.moduleEntityManager, _settings);
            _encryptionPolicy = new ConfigurableEncryptPolicy(ctx.obfuzIgnoreScopeComputeCache, ctx.coreSettings.assembliesToObfuscate, _settings.ruleFiles);
        }

        public override void Stop()
        {

        }

        protected override bool NeedObfuscateMethod(MethodDef method)
        {
            return true;
        }

        private bool IsSupportedFieldType(TypeSig type)
        {
            type = type.RemovePinnedAndModifiers();
            switch (type.ElementType)
            {
                case ElementType.I4:
                case ElementType.I8:
                case ElementType.U4:
                case ElementType.U8:
                case ElementType.R4:
                case ElementType.R8:
                return true;
                default: return false;
            }
        }

        protected override bool TryObfuscateInstruction(MethodDef callingMethod, Instruction inst, IList<Instruction> instructions, int instructionIndex, List<Instruction> outputInstructions, List<Instruction> totalFinalInstructions)
        {
            Code code = inst.OpCode.Code;
            if (!(inst.Operand is IField field) || !field.IsField)
            {
                return false;
            }
            FieldDef fieldDef = field.ResolveFieldDefThrow();
            if (!IsSupportedFieldType(fieldDef.FieldSig.Type) || !_encryptionPolicy.NeedEncrypt(fieldDef))
            {
                return false;
            }
            switch (code)
            {
                case Code.Ldfld:
                {
                    _memoryEncryptor.Decrypt(callingMethod, fieldDef, outputInstructions, inst);
                    break;
                }
                case Code.Stfld:
                {
                    _memoryEncryptor.Encrypt(callingMethod, fieldDef, outputInstructions, inst);
                    break;
                }
                case Code.Ldsfld:
                {
                    _memoryEncryptor.Decrypt(callingMethod, fieldDef, outputInstructions, inst);
                    break;
                }
                case Code.Stsfld:
                {
                    _memoryEncryptor.Encrypt(callingMethod, fieldDef, outputInstructions, inst);
                    break;
                }
                case Code.Ldflda:
                case Code.Ldsflda:
                {
                    throw new System.Exception($"You shouldn't get reference to memory encryption field: {field}");
                }
                default: return false;
            }
            //Debug.Log($"memory encrypt field: {field}");
            return true;
        }
    }
}

```

`Editor/ObfusPasses/FieldEncrypt/FieldEncryptPass.cs.meta`:

```meta
fileFormatVersion: 2
guid: f3da24d0f1f1fc7449cbd0e7ddd03aa2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/FieldEncrypt/IEncryptPolicy.cs`:

```cs
using dnlib.DotNet;

namespace Obfuz.ObfusPasses.FieldEncrypt
{
    public interface IEncryptPolicy
    {
        bool NeedEncrypt(FieldDef field);
    }

    public abstract class EncryptPolicyBase : IEncryptPolicy
    {
        public abstract bool NeedEncrypt(FieldDef field);
    }
}

```

`Editor/ObfusPasses/FieldEncrypt/IEncryptPolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: a48d0500d0737404cad9c9ef23a9467c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/FieldEncrypt/IFieldEncryptor.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.FieldEncrypt
{
    public class MemoryEncryptionContext
    {
        public ModuleDef module;

        public Instruction currentInstruction;
    }

    public interface IFieldEncryptor
    {
        void Encrypt(MethodDef method, FieldDef field, List<Instruction> outputInstructions, Instruction currentInstruction);

        void Decrypt(MethodDef method, FieldDef field, List<Instruction> outputInstructions, Instruction currentInstruction);
    }

    public abstract class FieldEncryptorBase : IFieldEncryptor
    {
        public abstract void Encrypt(MethodDef method, FieldDef field, List<Instruction> outputInstructions, Instruction currentInstruction);
        public abstract void Decrypt(MethodDef method, FieldDef field, List<Instruction> outputInstructions, Instruction currentInstruction);
    }
}

```

`Editor/ObfusPasses/FieldEncrypt/IFieldEncryptor.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8a3ec14fca5169d479529d21b2eeada1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/Instinct.meta`:

```meta
fileFormatVersion: 2
guid: bb4f71e54c6a07341883ba0c642505c1
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/Instinct/InstinctPass.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Editor;
using Obfuz.Emit;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine.Assertions;

namespace Obfuz.ObfusPasses.Instinct
{

    public class InstinctPass : InstructionObfuscationPassBase
    {
        public override ObfuscationPassType Type => ObfuscationPassType.None;

        protected override bool ForceProcessAllAssembliesAndIgnoreAllPolicy => true;

        public InstinctPass()
        {
        }

        public override void Start()
        {
        }

        public override void Stop()
        {

        }

        protected override bool NeedObfuscateMethod(MethodDef method)
        {
            return true;
        }

        private string GetTypeName(TypeSig type)
        {
            type = type.RemovePinnedAndModifiers();
            switch (type.ElementType)
            {
                case ElementType.Class:
                case ElementType.ValueType:
                {
                    return type.ReflectionName;
                }
                case ElementType.GenericInst:
                {
                    type = ((GenericInstSig)type).GenericType;
                    return type.ReflectionName;
                }
                default: return type.ReflectionName;
            }
        }

        private string GetTypeFullName(TypeSig type)
        {
            type = type.RemovePinnedAndModifiers();

            switch (type.ElementType)
            {
                case ElementType.Class:
                case ElementType.ValueType:
                {
                    return type.ReflectionFullName;
                }
                case ElementType.GenericInst:
                {
                    GenericInstSig genericInstSig = (GenericInstSig)type;
                    var typeName = new StringBuilder(genericInstSig.GenericType.ReflectionFullName);
                    typeName.Append("<").Append(string.Join(",", genericInstSig.GenericArguments.Select(GetTypeFullName))).Append(">");
                    return typeName.ToString();
                }
                default: return type.ReflectionFullName;
            }
        }

        protected override bool TryObfuscateInstruction(MethodDef callingMethod, Instruction inst, IList<Instruction> instructions, int instructionIndex, List<Instruction> outputInstructions, List<Instruction> totalFinalInstructions)
        {
            Code code = inst.OpCode.Code;
            if (!(inst.Operand is IMethod method) || !method.IsMethod)
            {
                return false;
            }
            MethodDef methodDef = method.ResolveMethodDef();
            if (methodDef == null || methodDef.DeclaringType.Name != "ObfuscationInstincts" || methodDef.DeclaringType.DefinitionAssembly.Name != ConstValues.ObfuzRuntimeAssemblyName)
            {
                return false;
            }

            ObfuscationPassContext ctx = ObfuscationPassContext.Current;
            var importer = ctx.moduleEntityManager.GetEntity<DefaultMetadataImporter>(callingMethod.Module);

            string methodName = methodDef.Name;
            switch (methodName)
            {
                case "FullNameOf":
                case "NameOf":
                case "RegisterReflectionType":
                {
                    MethodSpec methodSpec = (MethodSpec)method;
                    GenericInstMethodSig gims = methodSpec.GenericInstMethodSig;
                    Assert.AreEqual(1, gims.GenericArguments.Count, "FullNameOf should have exactly one generic argument");
                    TypeSig type = gims.GenericArguments[0];
                    switch (methodName)
                    {
                        case "FullNameOf":
                        {
                            string typeFullName = GetTypeFullName(type);
                            outputInstructions.Add(Instruction.Create(OpCodes.Ldstr, typeFullName));
                            break;
                        }
                        case "NameOf":
                        {
                            string typeName = GetTypeName(type);
                            outputInstructions.Add(Instruction.Create(OpCodes.Ldstr, typeName));
                            break;
                        }
                        case "RegisterReflectionType":
                        {
                            string typeFullName = GetTypeFullName(type);
                            outputInstructions.Add(Instruction.Create(OpCodes.Ldstr, typeFullName));
                            var finalMethod = new MethodSpecUser((IMethodDefOrRef)importer.ObfuscationTypeMapperRegisterType, gims);
                            outputInstructions.Add(Instruction.Create(OpCodes.Call, finalMethod));
                            break;
                        }
                        default: throw new NotSupportedException($"Unsupported instinct method: {methodDef.FullName}");
                    }
                    break;
                }
                default: throw new NotSupportedException($"Unsupported instinct method: {methodDef.FullName}");
            }
            //Debug.Log($"memory encrypt field: {field}");
            return true;
        }
    }
}

```

`Editor/ObfusPasses/Instinct/InstinctPass.cs.meta`:

```meta
fileFormatVersion: 2
guid: 08027d16e09664c40b561715ef9326fc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/InstructionObfuscationPassBase.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses
{
    public abstract class InstructionObfuscationPassBase : ObfuscationMethodPassBase
    {
        protected abstract bool TryObfuscateInstruction(MethodDef callingMethod, Instruction inst, IList<Instruction> instructions, int instructionIndex,
            List<Instruction> outputInstructions, List<Instruction> totalFinalInstructions);

        protected override void ObfuscateData(MethodDef method)
        {
            IList<Instruction> instructions = method.Body.Instructions;
            var outputInstructions = new List<Instruction>();
            var totalFinalInstructions = new List<Instruction>();
            for (int i = 0; i < instructions.Count; i++)
            {
                Instruction inst = instructions[i];
                outputInstructions.Clear();
                if (TryObfuscateInstruction(method, inst, instructions, i, outputInstructions, totalFinalInstructions))
                {
                    // current instruction may be the target of control flow instruction, so we can't remove it directly.
                    // we replace it with nop now, then remove it in CleanUpInstructionPass
                    inst.OpCode = outputInstructions[0].OpCode;
                    inst.Operand = outputInstructions[0].Operand;
                    totalFinalInstructions.Add(inst);
                    for (int k = 1; k < outputInstructions.Count; k++)
                    {
                        totalFinalInstructions.Add(outputInstructions[k]);
                    }
                }
                else
                {
                    totalFinalInstructions.Add(inst);
                }
            }

            instructions.Clear();
            foreach (var obInst in totalFinalInstructions)
            {
                instructions.Add(obInst);
            }
        }
    }
}

```

`Editor/ObfusPasses/InstructionObfuscationPassBase.cs.meta`:

```meta
fileFormatVersion: 2
guid: e0cad4b764050f44f8c9b225056a4f49
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ObfuscationMethodPassBase.cs`:

```cs
using dnlib.DotNet;
using System.Linq;

namespace Obfuz.ObfusPasses
{
    public abstract class ObfuscationMethodPassBase : ObfuscationPassBase
    {
        protected virtual bool ForceProcessAllAssembliesAndIgnoreAllPolicy => false;

        protected abstract bool NeedObfuscateMethod(MethodDef method);

        protected abstract void ObfuscateData(MethodDef method);

        public override void Process()
        {
            var ctx = ObfuscationPassContext.Current;
            var modules = ForceProcessAllAssembliesAndIgnoreAllPolicy ? ctx.allObfuscationRelativeModules : ctx.modulesToObfuscate;
            ObfuscationMethodWhitelist whiteList = ctx.whiteList;
            ConfigurablePassPolicy passPolicy = ctx.passPolicy;
            foreach (ModuleDef mod in modules)
            {
                if (!ForceProcessAllAssembliesAndIgnoreAllPolicy && whiteList.IsInWhiteList(mod))
                {
                    continue;
                }
                // ToArray to avoid modify list exception
                foreach (TypeDef type in mod.GetTypes().ToArray())
                {
                    if (!ForceProcessAllAssembliesAndIgnoreAllPolicy && whiteList.IsInWhiteList(type))
                    {
                        continue;
                    }
                    // ToArray to avoid modify list exception
                    foreach (MethodDef method in type.Methods.ToArray())
                    {
                        if (!method.HasBody || (!ForceProcessAllAssembliesAndIgnoreAllPolicy && (ctx.whiteList.IsInWhiteList(method) || !Support(passPolicy.GetMethodObfuscationPasses(method)) || !NeedObfuscateMethod(method))))
                        {
                            continue;
                        }
                        // TODO if isGeneratedBy Obfuscator, continue
                        ObfuscateData(method);
                    }
                }
            }
        }
    }
}

```

`Editor/ObfusPasses/ObfuscationMethodPassBase.cs.meta`:

```meta
fileFormatVersion: 2
guid: 84b0592af70b0cc41b546cf8ac39f889
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ObfuscationPassBase.cs`:

```cs
namespace Obfuz.ObfusPasses
{
    public abstract class ObfuscationPassBase : IObfuscationPass
    {
        public abstract ObfuscationPassType Type { get; }

        public bool Support(ObfuscationPassType passType)
        {
            return passType.HasFlag(Type);
        }

        public abstract void Start();

        public abstract void Stop();

        public abstract void Process();
    }
}

```

`Editor/ObfusPasses/ObfuscationPassBase.cs.meta`:

```meta
fileFormatVersion: 2
guid: 2f3e7e1d2a3ad3a4fb1a81e97730b5a4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/ObfuscationPassType.cs`:

```cs
using System;

namespace Obfuz.ObfusPasses
{
    [Flags]
    public enum ObfuscationPassType
    {
        None = 0,

        ConstEncrypt = 0x1,
        FieldEncrypt = 0x2,

        SymbolObfus = 0x100,
        CallObfus = 0x200,
        ExprObfus = 0x400,
        ControlFlowObfus = 0x800,
        EvalStackObfus = 0x1000,

        AllObfus = SymbolObfus | CallObfus | ExprObfus | ControlFlowObfus | EvalStackObfus,
        AllEncrypt = ConstEncrypt | FieldEncrypt,

        MethodBodyObfusOrEncrypt = ConstEncrypt | CallObfus | ExprObfus | ControlFlowObfus | EvalStackObfus,

        All = ~0,
    }
}

```

`Editor/ObfusPasses/ObfuscationPassType.cs.meta`:

```meta
fileFormatVersion: 2
guid: 5addd02f6f3dc0a4d888a0f74bd5ce4d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus.meta`:

```meta
fileFormatVersion: 2
guid: b746569f7c0d9754fa6f2925538eddbd
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/INameMaker.cs`:

```cs
using dnlib.DotNet;

namespace Obfuz.ObfusPasses.SymbolObfus
{
    public interface INameMaker
    {
        void AddPreservedName(TypeDef typeDef, string name);

        void AddPreservedNamespace(TypeDef typeDef, string name);

        void AddPreservedName(MethodDef methodDef, string name);

        void AddPreservedName(FieldDef fieldDef, string name);

        void AddPreservedName(PropertyDef propertyDef, string name);

        void AddPreservedName(EventDef eventDef, string name);

        bool IsNamePreserved(VirtualMethodGroup virtualMethodGroup, string name);

        string GetNewName(TypeDef typeDef, string originalName);

        string GetNewNamespace(TypeDef typeDef, string originalNamespace, bool reuse);

        string GetNewName(MethodDef methodDef, string originalName);

        string GetNewName(VirtualMethodGroup virtualMethodGroup, string originalName);

        string GetNewName(ParamDef param, string originalName);

        string GetNewName(FieldDef fieldDef, string originalName);

        string GetNewName(PropertyDef propertyDef, string originalName);

        string GetNewName(EventDef eventDef, string originalName);
    }
}

```

`Editor/ObfusPasses/SymbolObfus/INameMaker.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0c24d29f654d00b44bb6aa3b4bf222dd
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/IObfuscationPolicy.cs`:

```cs
using dnlib.DotNet;

namespace Obfuz.ObfusPasses.SymbolObfus
{
    public interface IObfuscationPolicy
    {
        bool NeedRename(TypeDef typeDef);

        bool NeedRename(MethodDef methodDef);

        bool NeedRename(FieldDef fieldDef);

        bool NeedRename(PropertyDef propertyDef);

        bool NeedRename(EventDef eventDef);
    }
}

```

`Editor/ObfusPasses/SymbolObfus/IObfuscationPolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: bd640b26c1d868544a7a91a0f986fdde
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/NameMakers.meta`:

```meta
fileFormatVersion: 2
guid: c970ffd992fbc154aaa37a2c48c24d5c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/DebugNameMaker.cs`:

```cs
using System.Text;

namespace Obfuz.ObfusPasses.SymbolObfus.NameMakers
{
    public class DebugNameMaker : NameMakerBase
    {
        private class DebugNameScope : INameScope
        {

            public bool AddPreservedName(string name)
            {
                return true;
            }

            public string GetNewName(string originalName, bool reuse)
            {
                return $"${originalName}";
            }

            public bool IsNamePreserved(string name)
            {
                return false;
            }
        }

        protected override INameScope CreateNameScope()
        {
            return new DebugNameScope();
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/DebugNameMaker.cs.meta`:

```meta
fileFormatVersion: 2
guid: abc1adfad5c7754499ceed4d4646eb58
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/INameScope.cs`:

```cs
namespace Obfuz.ObfusPasses.SymbolObfus.NameMakers
{
    public interface INameScope
    {
        bool AddPreservedName(string name);

        bool IsNamePreserved(string name);

        string GetNewName(string originalName, bool reuse);
    }
}

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/INameScope.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6c3884d338faf564eab48d58f02adc39
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/NameMakerBase.cs`:

```cs
using dnlib.DotNet;
using System.Collections.Generic;
using UnityEngine.Assertions;

namespace Obfuz.ObfusPasses.SymbolObfus.NameMakers
{
    public abstract class NameMakerBase : INameMaker
    {

        private readonly Dictionary<object, INameScope> _nameScopes = new Dictionary<object, INameScope>();

        private readonly object _namespaceScope = new object();
        private readonly object _typeNameScope = new object();
        private readonly object _methodNameScope = new object();
        private readonly object _fieldNameScope = new object();

        protected abstract INameScope CreateNameScope();

        protected INameScope GetNameScope(object key)
        {
            if (!_nameScopes.TryGetValue(key, out var nameScope))
            {
                nameScope = CreateNameScope();
                _nameScopes[key] = nameScope;
            }
            return nameScope;
        }

        public void AddPreservedName(TypeDef typeDef, string name)
        {
            GetNameScope(_typeNameScope).AddPreservedName(name);
        }

        public void AddPreservedName(MethodDef methodDef, string name)
        {
            GetNameScope(_methodNameScope).AddPreservedName(name);
        }

        public void AddPreservedName(FieldDef fieldDef, string name)
        {
            GetNameScope(_fieldNameScope).AddPreservedName(name);
        }

        public void AddPreservedName(PropertyDef propertyDef, string name)
        {
            GetNameScope(propertyDef.DeclaringType).AddPreservedName(name);
        }

        public void AddPreservedName(EventDef eventDef, string name)
        {
            GetNameScope(eventDef.DeclaringType).AddPreservedName(name);
        }

        public void AddPreservedNamespace(TypeDef typeDef, string name)
        {
            GetNameScope(_namespaceScope).AddPreservedName(name);
        }

        public bool IsNamePreserved(VirtualMethodGroup virtualMethodGroup, string name)
        {
            var scope = GetNameScope(_methodNameScope);
            return scope.IsNamePreserved(name);
        }

        private string GetDefaultNewName(object scope, string originName)
        {
            return GetNameScope(scope).GetNewName(originName, false);
        }

        public string GetNewNamespace(TypeDef typeDef, string originalNamespace, bool reuse)
        {
            if (string.IsNullOrEmpty(originalNamespace))
            {
                return string.Empty;
            }
            return GetNameScope(_namespaceScope).GetNewName(originalNamespace, reuse);
        }

        public string GetNewName(TypeDef typeDef, string originalName)
        {
            return GetDefaultNewName(_typeNameScope, originalName);
        }

        public string GetNewName(MethodDef methodDef, string originalName)
        {
            Assert.IsFalse(methodDef.IsVirtual);
            return GetDefaultNewName(_methodNameScope, originalName);
        }

        public string GetNewName(VirtualMethodGroup virtualMethodGroup, string originalName)
        {
            var scope = GetNameScope(_methodNameScope);
            return scope.GetNewName(originalName, false);
        }

        public virtual string GetNewName(ParamDef param, string originalName)
        {
            return "1";
        }

        public string GetNewName(FieldDef fieldDef, string originalName)
        {
            return GetDefaultNewName(_fieldNameScope, originalName);
        }

        public string GetNewName(PropertyDef propertyDef, string originalName)
        {
            return GetDefaultNewName(propertyDef.DeclaringType, originalName);
        }

        public string GetNewName(EventDef eventDef, string originalName)
        {
            return GetDefaultNewName(eventDef.DeclaringType, originalName);
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/NameMakerBase.cs.meta`:

```meta
fileFormatVersion: 2
guid: 205da3a8ebfd4ae4ba72d27db4b92d3f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/NameMakerFactory.cs`:

```cs
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.SymbolObfus.NameMakers
{
    public static class NameMakerFactory
    {
        public static INameMaker CreateDebugNameMaker()
        {
            return new DebugNameMaker();
        }

        public static INameMaker CreateNameMakerBaseASCIICharSet(string namePrefix)
        {
            var words = new List<string>();
            for (int i = 0; i < 26; i++)
            {
                words.Add(((char)('a' + i)).ToString());
                words.Add(((char)('A' + i)).ToString());
            }
            return new WordSetNameMaker(namePrefix, words);
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/NameMakerFactory.cs.meta`:

```meta
fileFormatVersion: 2
guid: afa0e87123ec9854b806098330c4980a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/NameScope.cs`:

```cs
using System.Collections.Generic;
using System.Text;

namespace Obfuz.ObfusPasses.SymbolObfus.NameMakers
{

    public class NameScope : NameScopeBase
    {
        private readonly string _namePrefix;
        private readonly List<string> _wordSet;
        private int _nextIndex;

        public NameScope(string namePrefix, List<string> wordSet)
        {
            _namePrefix = namePrefix;
            _wordSet = wordSet;
            _nextIndex = 0;
        }

        protected override void BuildNewName(StringBuilder nameBuilder, string originalName, string lastName)
        {
            nameBuilder.Append(_namePrefix);
            for (int i = _nextIndex++; ;)
            {
                nameBuilder.Append(_wordSet[i % _wordSet.Count]);
                i = i / _wordSet.Count;
                if (i == 0)
                {
                    break;
                }
            }

            // keep generic type name pattern {name}`{n}, if not, il2cpp may raise exception in typeof(G<T>) when G contains a field likes `T a`.
            int index = originalName.LastIndexOf('`');
            if (index != -1)
            {
                nameBuilder.Append(originalName.Substring(index));
            }
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/NameScope.cs.meta`:

```meta
fileFormatVersion: 2
guid: a35c5c4b49c98a84f94b690c26900c33
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/NameScopeBase.cs`:

```cs
using System.Collections.Generic;
using System.Text;

namespace Obfuz.ObfusPasses.SymbolObfus.NameMakers
{
    public abstract class NameScopeBase : INameScope
    {

        private readonly Dictionary<string, string> _nameMap = new Dictionary<string, string>();

        private readonly HashSet<string> _preservedNames = new HashSet<string>();


        public bool AddPreservedName(string name)
        {
            if (!string.IsNullOrEmpty(name))
            {
                return _preservedNames.Add(name);
            }
            return false;
        }

        public bool IsNamePreserved(string name)
        {
            return _preservedNames.Contains(name);
        }


        protected abstract void BuildNewName(StringBuilder nameBuilder, string originalName, string lastName);

        private string CreateNewName(string originalName)
        {
            var nameBuilder = new StringBuilder();
            string lastName = null;
            while (true)
            {
                nameBuilder.Clear();
                BuildNewName(nameBuilder, originalName, lastName);
                string newName = nameBuilder.ToString();
                lastName = newName;
                if (_preservedNames.Add(newName))
                {
                    return newName;
                }
            }
        }

        public string GetNewName(string originalName, bool reuse)
        {
            if (!reuse)
            {
                return CreateNewName(originalName);
            }
            if (_nameMap.TryGetValue(originalName, out var newName))
            {
                return newName;
            }
            newName = CreateNewName(originalName);
            _nameMap[originalName] = newName;
            return newName;
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/NameScopeBase.cs.meta`:

```meta
fileFormatVersion: 2
guid: 26e6ae1f35e7f094c844cf1567b88a19
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/WordSetNameMaker.cs`:

```cs
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.SymbolObfus.NameMakers
{

    public class WordSetNameMaker : NameMakerBase
    {
        private readonly string _namePrefix;
        private readonly List<string> _wordSet;

        public WordSetNameMaker(string namePrefix, List<string> wordSet)
        {
            _namePrefix = namePrefix;
            _wordSet = wordSet;
        }

        protected override INameScope CreateNameScope()
        {
            return new NameScope(_namePrefix, _wordSet);
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/NameMakers/WordSetNameMaker.cs.meta`:

```meta
fileFormatVersion: 2
guid: 47c92aea40a66e34b92f9eb5c0d380ca
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/Policies.meta`:

```meta
fileFormatVersion: 2
guid: 98e496436c90c0a4f82711af059471c7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/Policies/CacheRenamePolicy.cs`:

```cs
using dnlib.DotNet;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.SymbolObfus.Policies
{
    public class CacheRenamePolicy : ObfuscationPolicyBase
    {
        private readonly IObfuscationPolicy _underlyingPolicy;

        private readonly Dictionary<object, bool> _computeCache = new Dictionary<object, bool>();

        public CacheRenamePolicy(IObfuscationPolicy underlyingPolicy)
        {
            _underlyingPolicy = underlyingPolicy;
        }

        public override bool NeedRename(TypeDef typeDef)
        {
            if (!_computeCache.TryGetValue(typeDef, out var value))
            {
                value = _underlyingPolicy.NeedRename(typeDef);
                _computeCache[typeDef] = value;
            }
            return value;
        }

        public override bool NeedRename(MethodDef methodDef)
        {
            if (!_computeCache.TryGetValue(methodDef, out var value))
            {
                value = _underlyingPolicy.NeedRename(methodDef);
                _computeCache[methodDef] = value;
            }
            return value;
        }

        public override bool NeedRename(FieldDef fieldDef)
        {
            if (!_computeCache.TryGetValue(fieldDef, out var value))
            {
                value = _underlyingPolicy.NeedRename(fieldDef);
                _computeCache[fieldDef] = value;
            }
            return value;
        }

        public override bool NeedRename(PropertyDef propertyDef)
        {
            if (!_computeCache.TryGetValue(propertyDef, out var value))
            {
                value = _underlyingPolicy.NeedRename(propertyDef);
                _computeCache[propertyDef] = value;
            }
            return value;
        }

        public override bool NeedRename(EventDef eventDef)
        {
            if (!_computeCache.TryGetValue(eventDef, out var value))
            {
                value = _underlyingPolicy.NeedRename(eventDef);
                _computeCache[eventDef] = value;
            }
            return value;
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/Policies/CacheRenamePolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: c319b2ad62ad8794f9a8bc234c856d7f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/Policies/CombineRenamePolicy.cs`:

```cs
using dnlib.DotNet;
using System.Linq;

namespace Obfuz.ObfusPasses.SymbolObfus.Policies
{
    public class CombineRenamePolicy : IObfuscationPolicy
    {
        private readonly IObfuscationPolicy[] _policies;

        public CombineRenamePolicy(params IObfuscationPolicy[] policies)
        {
            _policies = policies;
        }

        public bool NeedRename(TypeDef typeDef)
        {
            return _policies.All(policy => policy.NeedRename(typeDef));
        }

        public bool NeedRename(MethodDef methodDef)
        {
            return _policies.All(policy => policy.NeedRename(methodDef));
        }

        public bool NeedRename(FieldDef fieldDef)
        {
            return _policies.All(policy => policy.NeedRename(fieldDef));
        }

        public bool NeedRename(PropertyDef propertyDef)
        {
            return _policies.All(policy => policy.NeedRename(propertyDef));
        }

        public bool NeedRename(EventDef eventDef)
        {
            return _policies.All(policy => policy.NeedRename(eventDef));
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/Policies/CombineRenamePolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: 97be4546adeb71947bf644949c3a9e82
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/Policies/ConfigurableRenamePolicy.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using UnityEngine;

namespace Obfuz.ObfusPasses.SymbolObfus.Policies
{

    public class ConfigurableRenamePolicy : ObfuscationPolicyBase
    {
        enum ModifierType
        {
            None = 0x0,
            Private = 0x1,
            Protected = 0x2,
            Public = 0x4,
        }

        class MethodRuleSpec
        {
            public NameMatcher nameMatcher;
            public ModifierType? modifierType;
            public bool? obfuscateName;
        }

        class FieldRuleSpec
        {
            public NameMatcher nameMatcher;
            public ModifierType? modifierType;
            public bool? obfuscateName;
        }

        class PropertyRuleSpec
        {
            public NameMatcher nameMatcher;
            public ModifierType? modifierType;
            public bool? obfuscateName;
            public ObfuzScope? applyToMembers;
        }

        class EventRuleSpec
        {
            public NameMatcher nameMatcher;
            public ModifierType? modifierType;
            public bool? obfuscateName;
            public ObfuzScope? applyToMembers;
        }

        class TypeRuleSpec
        {
            public NameMatcher nameMatcher;
            public ModifierType? modifierType;
            public ClassType? classType;
            public List<string> inheritTypes;
            public List<string> hasCustomAttributes;
            public bool? obfuscateName;
            public ObfuzScope? applyToMembers;
            public bool applyToNestedTypes;

            public List<FieldRuleSpec> fields;
            public List<MethodRuleSpec> methods;
            public List<PropertyRuleSpec> properties;
            public List<EventRuleSpec> events;
        }

        class AssemblyRuleSpec
        {
            public string assemblyName;
            public List<TypeRuleSpec> types;
        }

        private readonly Dictionary<string, List<AssemblyRuleSpec>> _assemblyRuleSpecs = new Dictionary<string, List<AssemblyRuleSpec>>();

        private AssemblyRuleSpec ParseAssembly(XmlElement ele)
        {
            string assemblyName = ele.GetAttribute("name");
            if (string.IsNullOrEmpty(assemblyName))
            {
                throw new Exception($"Invalid xml file, assembly name is empty");
            }
            if (!_obfuscationAssemblyNames.Contains(assemblyName))
            {
                throw new Exception($"unknown assembly name:{assemblyName}, not in ObfuzSettings.obfuscationAssemblyNames");
            }
            var rule = new AssemblyRuleSpec()
            {
                assemblyName = assemblyName,
                types = new List<TypeRuleSpec>(),
            };

            foreach (XmlNode node in ele.ChildNodes)
            {
                if (!(node is XmlElement childElement))
                {
                    continue;
                }
                if (childElement.Name != "type")
                {
                    throw new Exception($"Invalid xml file, unknown node {childElement.Name}");
                }
                TypeRuleSpec type = ParseType(childElement);
                rule.types.Add(type);
            }
            return rule;
        }

        private enum ClassType
        {
            None = 0x0,
            Class = 0x1,
            Struct = 0x2,
            Interface = 0x4,
            Enum = 0x8,
            Delegate = 0x10,
        }

        private ClassType? ParseClassType(string classType)
        {
            if (string.IsNullOrEmpty(classType))
            {
                return null;
            }

            ClassType type = ClassType.None;
            foreach (var s in classType.Split(','))
            {
                switch (s)
                {
                    case "class": type |= ClassType.Class; break;
                    case "struct": type |= ClassType.Struct; break;
                    case "interface": type |= ClassType.Interface; break;
                    case "enum": type |= ClassType.Enum; break;
                    case "delegate": type |= ClassType.Delegate; break;
                    default: throw new Exception($"Invalid class type {s}");
                }
            }
            return type;
        }

        private ModifierType? ParseModifierType(string modifierType)
        {
            if (string.IsNullOrEmpty(modifierType))
            {
                return null;
            }
            ModifierType type = ModifierType.None;
            foreach (var s in modifierType.Split(','))
            {
                switch (s)
                {
                    case "public": type |= ModifierType.Public; break;
                    case "protected": type |= ModifierType.Protected; break;
                    case "private": type |= ModifierType.Private; break;
                    default: throw new Exception($"Invalid modifier type {s}");
                }
            }
            return type;
        }


        private ObfuzScope? ParseApplyToMembersScope(string membersScopeStr)
        {
            if (string.IsNullOrWhiteSpace(membersScopeStr))
            {
                return null;
            }
            ObfuzScope scope = ObfuzScope.None;

            foreach (string s in membersScopeStr.Split(','))
            {
                var s2 = s.Trim().ToLowerInvariant();
                switch (s2)
                {
                    case "none": break;
                    case "field": scope |= ObfuzScope.Field; break;
                    case "eventname": scope |= ObfuzScope.EventName; break;
                    case "eventaddremovefirename": scope |= ObfuzScope.EventAddRemoveFireName; break;
                    case "event": scope |= ObfuzScope.Event; break;
                    case "methodname": scope |= ObfuzScope.MethodName; break;
                    case "method": scope |= ObfuzScope.MethodName; break;
                    case "propertyname": scope |= ObfuzScope.PropertyName; break;
                    case "propertygettersettername": scope |= ObfuzScope.PropertyGetterSetterName; break;
                    case "property": scope |= ObfuzScope.Property; break;
                    case "all":
                    case "*": scope |= ObfuzScope.All; break;
                    default:
                    {
                        throw new Exception($"Invalid applyToMembers scope {s2}");
                    }
                }
            }

            return scope;
        }

        private List<string> ParseTypes(string inheritStr)
        {
            if (string.IsNullOrWhiteSpace(inheritStr))
            {
                return null;
            }
            var inheritTypes = new List<string>();
            foreach (var s in inheritStr.Split(','))
            {
                var trimmed = s.Trim();
                if (!string.IsNullOrEmpty(trimmed))
                {
                    inheritTypes.Add(trimmed);
                }
            }
            return inheritTypes;
        }

        private TypeRuleSpec ParseType(XmlElement element)
        {
            var rule = new TypeRuleSpec();

            rule.nameMatcher = new NameMatcher(element.GetAttribute("name"));
            rule.obfuscateName = ConfigUtil.ParseNullableBool(element.GetAttribute("obName"));
            rule.applyToMembers = ParseApplyToMembersScope(element.GetAttribute("applyToMembers"));
            rule.applyToNestedTypes = ConfigUtil.ParseNullableBool(element.GetAttribute("applyToNestedTypes")) ?? true;
            rule.modifierType = ParseModifierType(element.GetAttribute("modifier"));
            rule.classType = ParseClassType(element.GetAttribute("classType"));
            rule.inheritTypes = ParseTypes(element.GetAttribute("inherit"));
            rule.hasCustomAttributes = ParseTypes(element.GetAttribute("hasCustomAttributes"));

            //rule.nestTypeRuleSpecs = new List<TypeRuleSpec>();
            rule.fields = new List<FieldRuleSpec>();
            rule.methods = new List<MethodRuleSpec>();
            rule.properties = new List<PropertyRuleSpec>();
            rule.events = new List<EventRuleSpec>();
            foreach (XmlNode node in element.ChildNodes)
            {
                if (!(node is XmlElement childElement))
                {
                    continue;
                }
                switch (childElement.Name)
                {
                    case "field":
                    {
                        var fieldRuleSpec = new FieldRuleSpec();
                        fieldRuleSpec.nameMatcher = new NameMatcher(childElement.GetAttribute("name"));
                        fieldRuleSpec.modifierType = ParseModifierType(childElement.GetAttribute("modifier"));
                        fieldRuleSpec.obfuscateName = ConfigUtil.ParseNullableBool(childElement.GetAttribute("obName"));
                        rule.fields.Add(fieldRuleSpec);
                        break;
                    }
                    case "method":
                    {
                        var methodRuleSpec = new MethodRuleSpec();
                        methodRuleSpec.nameMatcher = new NameMatcher(childElement.GetAttribute("name"));
                        methodRuleSpec.modifierType = ParseModifierType(childElement.GetAttribute("modifier"));
                        methodRuleSpec.obfuscateName = ConfigUtil.ParseNullableBool(childElement.GetAttribute("obName"));
                        rule.methods.Add(methodRuleSpec);
                        break;
                    }
                    case "property":
                    {
                        var propertyRulerSpec = new PropertyRuleSpec();
                        propertyRulerSpec.nameMatcher = new NameMatcher(childElement.GetAttribute("name"));
                        propertyRulerSpec.modifierType = ParseModifierType(childElement.GetAttribute("modifier"));
                        propertyRulerSpec.obfuscateName = ConfigUtil.ParseNullableBool(childElement.GetAttribute("obName"));
                        propertyRulerSpec.applyToMembers = ParseApplyToMembersScope(childElement.GetAttribute("applyToMembers"));
                        rule.properties.Add(propertyRulerSpec);
                        break;
                    }
                    case "event":
                    {
                        var eventRuleSpec = new EventRuleSpec();
                        eventRuleSpec.nameMatcher = new NameMatcher(childElement.GetAttribute("name"));
                        eventRuleSpec.modifierType = ParseModifierType(childElement.GetAttribute("modifier"));
                        eventRuleSpec.obfuscateName = ConfigUtil.ParseNullableBool(childElement.GetAttribute("obName"));
                        eventRuleSpec.applyToMembers = ParseApplyToMembersScope(childElement.GetAttribute("applyToMembers"));
                        rule.events.Add(eventRuleSpec);
                        break;
                    }
                    default: throw new Exception($"Invalid xml file, unknown node {childElement.Name} in type node");
                }
            }
            return rule;
        }

        private void LoadXmls(List<string> xmlFiles)
        {
            var rawAssemblySpecElements = new List<XmlElement>();
            foreach (string file in xmlFiles)
            {
                LoadRawXml(file, rawAssemblySpecElements);
            }
            ResolveAssemblySpecs(rawAssemblySpecElements);
        }

        private void ResolveAssemblySpecs(List<XmlElement> rawAssemblySpecElements)
        {
            foreach (XmlElement ele in rawAssemblySpecElements)
            {
                var assemblyRule = ParseAssembly(ele);
                if (!_assemblyRuleSpecs.TryGetValue(assemblyRule.assemblyName, out var existAssemblyRules))
                {
                    existAssemblyRules = new List<AssemblyRuleSpec>();
                    _assemblyRuleSpecs.Add(assemblyRule.assemblyName, existAssemblyRules);
                }
                existAssemblyRules.Add(assemblyRule);
            }
        }

        private void LoadRawXml(string xmlFile, List<XmlElement> rawAssemblyElements)
        {
            Debug.Log($"ObfuscateRule::LoadXml {xmlFile}");
            var doc = new XmlDocument();
            doc.Load(xmlFile);
            var root = doc.DocumentElement;
            if (root.Name != "obfuz")
            {
                throw new Exception($"Invalid xml file {xmlFile}, root name should be 'obfuz'");
            }
            foreach (XmlNode node in root.ChildNodes)
            {
                if (!(node is XmlElement element))
                {
                    continue;
                }
                switch (element.Name)
                {
                    case "assembly":
                    {
                        rawAssemblyElements.Add(element);
                        break;
                    }
                    default:
                    {
                        throw new Exception($"Invalid xml file {xmlFile}, unknown node {element.Name}");
                    }
                }
            }
        }

        private ModifierType ComputeModifierType(TypeAttributes visibility)
        {
            if (visibility == TypeAttributes.NotPublic || visibility == TypeAttributes.NestedPrivate)
            {
                return ModifierType.Private;
            }
            if (visibility == TypeAttributes.Public || visibility == TypeAttributes.NestedPublic)
            {
                return ModifierType.Public;
            }
            return ModifierType.Protected;
        }

        private ModifierType ComputeModifierType(FieldAttributes access)
        {
            if (access == FieldAttributes.Private || access == FieldAttributes.PrivateScope)
            {
                return ModifierType.Private;
            }
            if (access == FieldAttributes.Public)
            {
                return ModifierType.Public;
            }
            return ModifierType.Protected;
        }

        //private ModifierType ComputeModifierType(MethodAttributes access)
        //{
        //    if (access == MethodAttributes.Private || access == MethodAttributes.PrivateScope)
        //    {
        //        return ModifierType.Private;
        //    }
        //    if (access == MethodAttributes.Public)
        //    {
        //        return ModifierType.Public;
        //    }
        //    return ModifierType.Protected;
        //}

        private bool MatchModifier(ModifierType? modifierType, TypeDef typeDef)
        {
            return modifierType == null || (modifierType & ComputeModifierType(typeDef.Visibility)) != 0;
        }

        private bool MatchModifier(ModifierType? modifierType, FieldDef fieldDef)
        {
            return modifierType == null || (modifierType & ComputeModifierType(fieldDef.Access)) != 0;
        }

        private bool MatchModifier(ModifierType? modifierType, MethodDef methodDef)
        {
            return modifierType == null || (modifierType & ComputeModifierType((FieldAttributes)methodDef.Access)) != 0;
        }

        private bool MatchModifier(ModifierType? modifierType, PropertyDef propertyDef)
        {
            return modifierType == null || (modifierType & ComputeModifierType((FieldAttributes)propertyDef.Attributes)) != 0;
        }

        private bool MatchModifier(ModifierType? modifierType, EventDef eventDef)
        {
            return modifierType == null || (modifierType & ComputeModifierType((FieldAttributes)eventDef.Attributes)) != 0;
        }

        private class MethodComputeCache
        {
            public bool obfuscateName = true;
            public bool obfuscateParam = true;
            public bool obfuscateBody = true;
        }

        private class RuleResult
        {
            public bool? obfuscateName;
        }

        private readonly Dictionary<TypeDef, RuleResult> _typeSpecCache = new Dictionary<TypeDef, RuleResult>();
        private readonly Dictionary<MethodDef, RuleResult> _methodSpecCache = new Dictionary<MethodDef, RuleResult>();
        private readonly Dictionary<FieldDef, RuleResult> _fieldSpecCache = new Dictionary<FieldDef, RuleResult>();
        private readonly Dictionary<PropertyDef, RuleResult> _propertySpecCache = new Dictionary<PropertyDef, RuleResult>();
        private readonly Dictionary<EventDef, RuleResult> _eventSpecCache = new Dictionary<EventDef, RuleResult>();


        private readonly HashSet<string> _obfuscationAssemblyNames;
        private readonly List<ModuleDef> _assembliesToObfuscate;

        public ConfigurableRenamePolicy(List<string> obfuscationAssemblyNames, List<ModuleDef> assembliesToObfuscate, List<string> xmlFiles)
        {
            _obfuscationAssemblyNames = new HashSet<string>(obfuscationAssemblyNames);
            _assembliesToObfuscate = assembliesToObfuscate;
            LoadXmls(xmlFiles);
            BuildRuleResultCaches();
        }

        private bool MatchClassType(ClassType? classType, TypeDef typeDef)
        {
            if (classType == null)
            {
                return true;
            }
            if (typeDef.IsInterface && (classType & ClassType.Interface) != 0)
            {
                return true;
            }
            if (typeDef.IsEnum && (classType & ClassType.Enum) != 0)
            {
                return true;
            }
            if (typeDef.IsDelegate && (classType & ClassType.Delegate) != 0)
            {
                return true;
            }
            if (typeDef.IsValueType && !typeDef.IsEnum && (classType & ClassType.Struct) != 0)
            {
                return true;
            }
            if (!typeDef.IsValueType && !typeDef.IsInterface && !typeDef.IsDelegate && (classType & ClassType.Class) != 0)
            {
                return true;
            }
            return false;
        }


        private RuleResult GetOrCreateTypeRuleResult(TypeDef typeDef)
        {
            if (!_typeSpecCache.TryGetValue(typeDef, out var ruleResult))
            {
                ruleResult = new RuleResult();
                _typeSpecCache.Add(typeDef, ruleResult);
            }
            return ruleResult;
        }

        private RuleResult GetOrCreateFieldRuleResult(FieldDef field)
        {
            if (!_fieldSpecCache.TryGetValue(field, out var ruleResult))
            {
                ruleResult = new RuleResult();
                _fieldSpecCache.Add(field, ruleResult);
            }
            return ruleResult;
        }

        private RuleResult GetOrCreateMethodRuleResult(MethodDef method)
        {
            if (!_methodSpecCache.TryGetValue(method, out var ruleResult))
            {
                ruleResult = new RuleResult();
                _methodSpecCache.Add(method, ruleResult);
            }
            return ruleResult;
        }

        private RuleResult GetOrCreatePropertyRuleResult(PropertyDef property)
        {
            if (!_propertySpecCache.TryGetValue(property, out var ruleResult))
            {
                ruleResult = new RuleResult();
                _propertySpecCache.Add(property, ruleResult);
            }
            return ruleResult;
        }

        private RuleResult GetOrCreateEventRuleResult(EventDef eventDef)
        {
            if (!_eventSpecCache.TryGetValue(eventDef, out var ruleResult))
            {
                ruleResult = new RuleResult();
                _eventSpecCache.Add(eventDef, ruleResult);
            }
            return ruleResult;
        }

        private void BuildTypeRuleResult(TypeRuleSpec typeSpec, TypeDef typeDef, RuleResult typeRuleResult)
        {
            string typeName = typeDef.FullName;

            if (typeSpec.obfuscateName != null)
            {
                typeRuleResult.obfuscateName = typeSpec.obfuscateName;
            }

            foreach (var fieldDef in typeDef.Fields)
            {
                RuleResult fieldRuleResult = GetOrCreateFieldRuleResult(fieldDef);
                if (typeSpec.applyToMembers != null && (typeSpec.applyToMembers & ObfuzScope.Field) != 0 && typeSpec.obfuscateName != null)
                {
                    fieldRuleResult.obfuscateName = typeSpec.obfuscateName;
                }
                foreach (var fieldSpec in typeSpec.fields)
                {
                    if (fieldSpec.nameMatcher.IsMatch(fieldDef.Name) && MatchModifier(fieldSpec.modifierType, fieldDef))
                    {
                        if (fieldSpec.obfuscateName != null)
                        {
                            fieldRuleResult.obfuscateName = fieldSpec.obfuscateName;
                        }
                    }
                }
            }

            foreach (MethodDef methodDef in typeDef.Methods)
            {
                RuleResult methodRuleResult = GetOrCreateMethodRuleResult(methodDef);
                if (typeSpec.applyToMembers != null && (typeSpec.applyToMembers & ObfuzScope.Method) != 0 && typeSpec.obfuscateName != null)
                {
                    methodRuleResult.obfuscateName = typeSpec.obfuscateName;
                }
            }

            foreach (var eventDef in typeDef.Events)
            {
                RuleResult eventRuleResult = GetOrCreateEventRuleResult(eventDef);
                if (typeSpec.applyToMembers != null && (typeSpec.applyToMembers & ObfuzScope.EventName) != 0 && typeSpec.obfuscateName != null)
                {
                    eventRuleResult.obfuscateName = typeSpec.obfuscateName;
                }
                foreach (var eventSpec in typeSpec.events)
                {
                    if (!eventSpec.nameMatcher.IsMatch(eventDef.Name) || !MatchModifier(eventSpec.modifierType, eventDef))
                    {
                        continue;
                    }
                    if (typeSpec.obfuscateName != null && typeSpec.applyToMembers != null && (typeSpec.applyToMembers & ObfuzScope.EventAddRemoveFireName) != 0)
                    {
                        if (eventDef.AddMethod != null)
                        {
                            GetOrCreateMethodRuleResult(eventDef.AddMethod).obfuscateName = typeSpec.obfuscateName;
                        }
                        if (eventDef.RemoveMethod != null)
                        {
                            GetOrCreateMethodRuleResult(eventDef.RemoveMethod).obfuscateName = typeSpec.obfuscateName;
                        }
                        if (eventDef.InvokeMethod != null)
                        {
                            GetOrCreateMethodRuleResult(eventDef.InvokeMethod).obfuscateName = typeSpec.obfuscateName;
                        }
                    }
                    if (eventSpec.obfuscateName != null)
                    {
                        eventRuleResult.obfuscateName = eventSpec.obfuscateName;
                        if (eventSpec.applyToMembers != null && (eventSpec.applyToMembers & ObfuzScope.EventAddRemoveFireName) != 0)
                        {
                            if (eventDef.AddMethod != null)
                            {
                                GetOrCreateMethodRuleResult(eventDef.AddMethod).obfuscateName = eventSpec.obfuscateName;
                            }
                            if (eventDef.RemoveMethod != null)
                            {
                                GetOrCreateMethodRuleResult(eventDef.RemoveMethod).obfuscateName = eventSpec.obfuscateName;
                            }
                            if (eventDef.InvokeMethod != null)
                            {
                                GetOrCreateMethodRuleResult(eventDef.InvokeMethod).obfuscateName = eventSpec.obfuscateName;
                            }
                        }
                    }
                }
            }

            foreach (var propertyDef in typeDef.Properties)
            {
                RuleResult propertyRuleResult = GetOrCreatePropertyRuleResult(propertyDef);
                if (typeSpec.applyToMembers != null && (typeSpec.applyToMembers & ObfuzScope.PropertyName) != 0 && typeSpec.obfuscateName != null)
                {
                    propertyRuleResult.obfuscateName = typeSpec.obfuscateName;
                }
                foreach (var propertySpec in typeSpec.properties)
                {
                    if (!propertySpec.nameMatcher.IsMatch(propertyDef.Name) || !MatchModifier(propertySpec.modifierType, propertyDef))
                    {
                        continue;
                    }
                    if (typeSpec.obfuscateName != null && typeSpec.applyToMembers != null && (typeSpec.applyToMembers & ObfuzScope.PropertyGetterSetterName) != 0)
                    {
                        if (propertyDef.GetMethod != null)
                        {
                            GetOrCreateMethodRuleResult(propertyDef.GetMethod).obfuscateName = typeSpec.obfuscateName;
                        }
                        if (propertyDef.SetMethod != null)
                        {
                            GetOrCreateMethodRuleResult(propertyDef.SetMethod).obfuscateName = typeSpec.obfuscateName;
                        }
                    }
                    if (propertySpec.obfuscateName != null)
                    {
                        propertyRuleResult.obfuscateName = propertySpec.obfuscateName;
                        if (propertySpec.applyToMembers != null && (propertySpec.applyToMembers & ObfuzScope.PropertyGetterSetterName) != 0)
                        {
                            if (propertyDef.GetMethod != null)
                            {
                                GetOrCreateMethodRuleResult(propertyDef.GetMethod).obfuscateName = propertySpec.obfuscateName;
                            }
                            if (propertyDef.SetMethod != null)
                            {
                                GetOrCreateMethodRuleResult(propertyDef.SetMethod).obfuscateName = propertySpec.obfuscateName;
                            }
                        }
                    }
                }
            }
            foreach (MethodDef methodDef in typeDef.Methods)
            {
                RuleResult methodRuleResult = GetOrCreateMethodRuleResult(methodDef);
                foreach (MethodRuleSpec methodSpec in typeSpec.methods)
                {
                    if (!methodSpec.nameMatcher.IsMatch(methodDef.Name) || !MatchModifier(methodSpec.modifierType, methodDef))
                    {
                        continue;
                    }
                    if (methodSpec.obfuscateName != null)
                    {
                        methodRuleResult.obfuscateName = methodSpec.obfuscateName;
                    }
                }
            }

            if (typeSpec.applyToNestedTypes)
            {
                foreach (TypeDef nestedType in typeDef.NestedTypes)
                {
                    var nestedRuleResult = GetOrCreateTypeRuleResult(nestedType);
                    BuildTypeRuleResult(typeSpec, nestedType, nestedRuleResult);
                }
            }
        }

        private bool MatchInheritTypes(List<string> inheritTypes, TypeDef typeDef)
        {
            if (inheritTypes == null || inheritTypes.Count == 0)
            {
                return true;
            }
            TypeDef currentType = typeDef;
            while (currentType != null)
            {
                if (inheritTypes.Contains(currentType.FullName))
                {
                    return true;
                }
                foreach (var interfaceType in currentType.Interfaces)
                {
                    if (inheritTypes.Contains(interfaceType.Interface.FullName))
                    {
                        return true;
                    }
                }
                currentType = MetaUtil.GetBaseTypeDef(currentType);
            }
            return false;
        }

        private bool MatchCustomAttributes(List<string> customAttributes, TypeDef typeDef)
        {
            if (customAttributes == null || customAttributes.Count == 0)
            {
                return true;
            }
            foreach (string customAttributeName in customAttributes)
            {
                if (typeDef.CustomAttributes.Find(customAttributeName) != null)
                {
                    return true;
                }
            }
            return false;
        }

        private IEnumerable<TypeDef> GetMatchTypes(ModuleDef mod, List<TypeDef> types, TypeRuleSpec typeSpec)
        {
            if (typeSpec.nameMatcher.IsWildcardPattern)
            {
                foreach (var typeDef in types)
                {
                    if (!typeSpec.nameMatcher.IsMatch(typeDef.FullName)
                        || !MatchModifier(typeSpec.modifierType, typeDef)
                        || !MatchClassType(typeSpec.classType, typeDef)
                        || !MatchInheritTypes(typeSpec.inheritTypes, typeDef)
                        || !MatchCustomAttributes(typeSpec.hasCustomAttributes, typeDef))
                    {
                        continue;
                    }
                    yield return typeDef;
                }
            }
            else
            {
                TypeDef typeDef = mod.FindNormal(typeSpec.nameMatcher.NameOrPattern);
                if (typeDef != null
                    && MatchModifier(typeSpec.modifierType, typeDef)
                    && MatchClassType(typeSpec.classType, typeDef)
                    && MatchInheritTypes(typeSpec.inheritTypes, typeDef)
                    && MatchCustomAttributes(typeSpec.hasCustomAttributes, typeDef))
                {
                    yield return typeDef;
                }
            }
        }

        private void BuildRuleResultCaches()
        {
            foreach (AssemblyRuleSpec assSpec in _assemblyRuleSpecs.Values.SelectMany(arr => arr))
            {
                ModuleDef module = _assembliesToObfuscate.FirstOrDefault(m => m.Assembly.Name == assSpec.assemblyName);
                if (module == null)
                {
                    continue;
                }
                List<TypeDef> types = module.GetTypes().ToList();
                foreach (TypeRuleSpec typeSpec in assSpec.types)
                {
                    foreach (var typeDef in GetMatchTypes(module, types, typeSpec))
                    {
                        var ruleResult = GetOrCreateTypeRuleResult(typeDef);
                        if (typeSpec.obfuscateName != null)
                        {
                            ruleResult.obfuscateName = typeSpec.obfuscateName;
                        }
                        BuildTypeRuleResult(typeSpec, typeDef, ruleResult);
                    }
                }
            }
        }

        public override bool NeedRename(TypeDef typeDef)
        {
            return GetOrCreateTypeRuleResult(typeDef).obfuscateName != false;
        }

        public override bool NeedRename(MethodDef methodDef)
        {
            return GetOrCreateMethodRuleResult(methodDef).obfuscateName != false;
        }

        public override bool NeedRename(FieldDef fieldDef)
        {
            return GetOrCreateFieldRuleResult(fieldDef).obfuscateName != false;
        }

        public override bool NeedRename(PropertyDef propertyDef)
        {
            return GetOrCreatePropertyRuleResult(propertyDef).obfuscateName != false;
        }

        public override bool NeedRename(EventDef eventDef)
        {
            return GetOrCreateEventRuleResult(eventDef).obfuscateName != false;
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/Policies/ConfigurableRenamePolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: 9c063bc949939fe44972c3d99870527e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/Policies/ObfuscationPolicyBase.cs`:

```cs
using dnlib.DotNet;

namespace Obfuz.ObfusPasses.SymbolObfus.Policies
{
    public abstract class ObfuscationPolicyBase : IObfuscationPolicy
    {

        public virtual bool NeedRename(TypeDef typeDef)
        {
            return true;
        }

        public virtual bool NeedRename(MethodDef methodDef)
        {
            return true;
        }

        public virtual bool NeedRename(FieldDef fieldDef)
        {
            return true;
        }

        public virtual bool NeedRename(PropertyDef propertyDef)
        {
            return true;
        }

        public virtual bool NeedRename(EventDef eventDef)
        {
            return true;
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/Policies/ObfuscationPolicyBase.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6ab98107a2ef9624b9b8a53061f682c3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/Policies/SupportPassPolicy.cs`:

```cs
using dnlib.DotNet;

namespace Obfuz.ObfusPasses.SymbolObfus.Policies
{
    internal class SupportPassPolicy : ObfuscationPolicyBase
    {
        private readonly ConfigurablePassPolicy _policy;


        private bool Support(ObfuscationPassType passType)
        {
            return passType.HasFlag(ObfuscationPassType.SymbolObfus);
        }

        public SupportPassPolicy(ConfigurablePassPolicy policy)
        {
            _policy = policy;
        }

        public override bool NeedRename(TypeDef typeDef)
        {
            return Support(_policy.GetTypeObfuscationPasses(typeDef));
        }

        public override bool NeedRename(MethodDef methodDef)
        {
            return Support(_policy.GetMethodObfuscationPasses(methodDef));
        }

        public override bool NeedRename(FieldDef fieldDef)
        {
            return Support(_policy.GetFieldObfuscationPasses(fieldDef));
        }

        public override bool NeedRename(PropertyDef propertyDef)
        {
            return Support(_policy.GetPropertyObfuscationPasses(propertyDef));
        }

        public override bool NeedRename(EventDef eventDef)
        {
            return Support(_policy.GetEventObfuscationPasses(eventDef));
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/Policies/SupportPassPolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: 584dd4d4e9b9fa64090611d84b50980b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/Policies/SystemRenamePolicy.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Editor;
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.SymbolObfus.Policies
{
    public class SystemRenamePolicy : ObfuscationPolicyBase
    {
        private readonly ObfuzIgnoreScopeComputeCache _obfuzIgnoreScopeComputeCache;

        public SystemRenamePolicy(ObfuzIgnoreScopeComputeCache obfuzIgnoreScopeComputeCache)
        {
            _obfuzIgnoreScopeComputeCache = obfuzIgnoreScopeComputeCache;
        }

        private readonly HashSet<string> _fullIgnoreTypeFullNames = new HashSet<string>
        {
            ConstValues.ObfuzIgnoreAttributeFullName,
            ConstValues.ObfuzScopeFullName,
            ConstValues.EncryptFieldAttributeFullName,
            ConstValues.EmbeddedAttributeFullName,
            ConstValues.ZluaLuaInvokeAttributeFullName,
            ConstValues.ZluaLuaCallbackAttributeFullName,
            ConstValues.ZluaLuaMarshalAsAttributeFullName,
            ConstValues.BurstCompileFullName,
        };


        private readonly HashSet<string> _fullIgnoreTypeNames = new HashSet<string>
        {
            ConstValues.MonoPInvokeCallbackAttributeName,
        };

        private bool IsFullIgnoreObfuscatedType(TypeDef typeDef)
        {
            return _fullIgnoreTypeFullNames.Contains(typeDef.FullName) || _fullIgnoreTypeNames.Contains(typeDef.Name) || MetaUtil.HasMicrosoftCodeAnalysisEmbeddedAttribute(typeDef);
        }

        public override bool NeedRename(TypeDef typeDef)
        {
            string name = typeDef.Name;
            if (name == "<Module>")
            {
                return false;
            }
            if (IsFullIgnoreObfuscatedType(typeDef))
            {
                return false;
            }

            if (_obfuzIgnoreScopeComputeCache.HasSelfOrEnclosingOrInheritObfuzIgnoreScope(typeDef, ObfuzScope.TypeName))
            {
                return false;
            }
            return true;
        }

        public override bool NeedRename(MethodDef methodDef)
        {
            if (methodDef.DeclaringType.IsDelegate || IsFullIgnoreObfuscatedType(methodDef.DeclaringType))
            {
                return false;
            }
            if (methodDef.Name == ".ctor" || methodDef.Name == ".cctor")
            {
                return false;
            }

            if (_obfuzIgnoreScopeComputeCache.HasSelfOrInheritPropertyOrEventOrOrTypeDefIgnoreMethodName(methodDef))
            {
                return false;
            }
            return true;
        }

        public override bool NeedRename(FieldDef fieldDef)
        {
            if (fieldDef.DeclaringType.IsDelegate || IsFullIgnoreObfuscatedType(fieldDef.DeclaringType))
            {
                return false;
            }
            if (_obfuzIgnoreScopeComputeCache.HasSelfOrDeclaringOrEnclosingOrInheritObfuzIgnoreScope(fieldDef, fieldDef.DeclaringType, ObfuzScope.Field))
            {
                return false;
            }
            if (fieldDef.DeclaringType.IsEnum && !fieldDef.IsStatic)
            {
                return false;
            }
            return true;
        }

        public override bool NeedRename(PropertyDef propertyDef)
        {
            if (propertyDef.DeclaringType.IsDelegate || IsFullIgnoreObfuscatedType(propertyDef.DeclaringType))
            {
                return false;
            }
            if (_obfuzIgnoreScopeComputeCache.HasSelfOrDeclaringOrEnclosingOrInheritObfuzIgnoreScope(propertyDef, propertyDef.DeclaringType, ObfuzScope.PropertyName))
            {
                return false;
            }
            return true;
        }

        public override bool NeedRename(EventDef eventDef)
        {
            if (eventDef.DeclaringType.IsDelegate || IsFullIgnoreObfuscatedType(eventDef.DeclaringType))
            {
                return false;
            }
            if (_obfuzIgnoreScopeComputeCache.HasSelfOrDeclaringOrEnclosingOrInheritObfuzIgnoreScope(eventDef, eventDef.DeclaringType, ObfuzScope.EventName))
            {
                return false;
            }
            return true;
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/Policies/SystemRenamePolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: 7b7b98f2ff075c04aa9bd989f8797f00
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/Policies/UnityRenamePolicy.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Utils;
using System.Collections.Generic;
using System.Linq;

namespace Obfuz.ObfusPasses.SymbolObfus.Policies
{

    public class UnityRenamePolicy : ObfuscationPolicyBase
    {
        private static HashSet<string> s_monoBehaviourEvents = new HashSet<string> {

            // MonoBehaviour events
    "Awake",
    "FixedUpdate",
    "LateUpdate",
    "OnAnimatorIK",

    "OnAnimatorMove",
    "OnApplicationFocus",
    "OnApplicationPause",
    "OnApplicationQuit",
    "OnAudioFilterRead",

    "OnBecameVisible",
    "OnBecameInvisible",

    "OnCollisionEnter",
    "OnCollisionEnter2D",
    "OnCollisionExit",
    "OnCollisionExit2D",
    "OnCollisionStay",
    "OnCollisionStay2D",
    "OnConnectedToServer",
    "OnControllerColliderHit",

    "OnDrawGizmos",
    "OnDrawGizmosSelected",
    "OnDestroy",
    "OnDisable",
    "OnDisconnectedFromServer",

    "OnEnable",

    "OnFailedToConnect",
    "OnFailedToConnectToMasterServer",

    "OnGUI",

    "OnJointBreak",
    "OnJointBreak2D",

    "OnMasterServerEvent",
    "OnMouseDown",
    "OnMouseDrag",
    "OnMouseEnter",
    "OnMouseExit",
    "OnMouseOver",
    "OnMouseUp",
    "OnMouseUpAsButton",

    "OnNetworkInstantiate",

    "OnParticleSystemStopped",
    "OnParticleTrigger",
    "OnParticleUpdateJobScheduled",
    "OnPlayerConnected",
    "OnPlayerDisconnected",
    "OnPostRender",
    "OnPreCull",
    "OnPreRender",
    "OnRenderImage",
    "OnRenderObject",

    "OnSerializeNetworkView",
    "OnServerInitialized",

    "OnTransformChildrenChanged",
    "OnTransformParentChanged",
    "OnTriggerEnter",
    "OnTriggerEnter2D",
    "OnTriggerExit",
    "OnTriggerExit2D",
    "OnTriggerStay",
    "OnTriggerStay2D",

    "OnValidate",
    "OnWillRenderObject",
    "Reset",
    "Start",
    "Update",

    // Animator/StateMachineBehaviour
    "OnStateEnter",
    "OnStateExit",
    "OnStateMove",
    "OnStateUpdate",
    "OnStateIK",
    "OnStateMachineEnter",
    "OnStateMachineExit",

    // ParticleSystem
    "OnParticleTrigger",
    "OnParticleCollision",
    "OnParticleSystemStopped",

    // UGUI/EventSystems
    "OnPointerClick",
    "OnPointerDown",
    "OnPointerUp",
    "OnPointerEnter",
    "OnPointerExit",
    "OnDrag",
    "OnBeginDrag",
    "OnEndDrag",
    "OnDrop",
    "OnScroll",
    "OnSelect",
    "OnDeselect",
    "OnMove",
    "OnSubmit",
    "OnCancel",
};

        private readonly CachedDictionary<TypeDef, bool> _computeDeclaringTypeDisableAllMemberRenamingCache;
        private readonly CachedDictionary<TypeDef, bool> _isSerializableCache;
        private readonly CachedDictionary<TypeDef, bool> _isInheritFromMonoBehaviourCache;
        private readonly CachedDictionary<TypeDef, bool> _isScriptOrSerializableTypeCache;

        public UnityRenamePolicy()
        {
            _computeDeclaringTypeDisableAllMemberRenamingCache = new CachedDictionary<TypeDef, bool>(ComputeDeclaringTypeDisableAllMemberRenaming);
            _isSerializableCache = new CachedDictionary<TypeDef, bool>(MetaUtil.IsSerializableType);
            _isInheritFromMonoBehaviourCache = new CachedDictionary<TypeDef, bool>(MetaUtil.IsInheritFromMonoBehaviour);
            _isScriptOrSerializableTypeCache = new CachedDictionary<TypeDef, bool>(MetaUtil.IsScriptOrSerializableType);
        }

        private bool IsUnitySourceGeneratedAssemblyType(TypeDef typeDef)
        {
            if (typeDef.Name.StartsWith("UnitySourceGeneratedAssemblyMonoScriptTypes_"))
            {
                return true;
            }
            if (typeDef.FullName == "Unity.Entities.CodeGeneratedRegistry.AssemblyTypeRegistry")
            {
                return true;
            }
            if (typeDef.Name.StartsWith("__JobReflectionRegistrationOutput"))
            {
                return true;
            }
            if (MetaUtil.HasDOTSCompilerGeneratedAttribute(typeDef))
            {
                return true;
            }
            if (typeDef.DeclaringType != null)
            {
                return IsUnitySourceGeneratedAssemblyType(typeDef.DeclaringType);
            }
            return false;
        }

        private bool ComputeDeclaringTypeDisableAllMemberRenaming(TypeDef typeDef)
        {
            if (typeDef.IsEnum && MetaUtil.HasBlackboardEnumAttribute(typeDef))
            {
                return true;
            }
            if (IsUnitySourceGeneratedAssemblyType(typeDef))
            {
                return true;
            }
            if (MetaUtil.IsInheritFromDOTSTypes(typeDef))
            {
                return true;
            }
            return false;
        }

        public override bool NeedRename(TypeDef typeDef)
        {
            if (_isScriptOrSerializableTypeCache.GetValue(typeDef))
            {
                return false;
            }
            if (_computeDeclaringTypeDisableAllMemberRenamingCache.GetValue(typeDef))
            {
                return false;
            }
            if (MetaUtil.HasBurstCompileAttribute(typeDef))
            {
                return false;
            }
            if (typeDef.Methods.Any(m => MetaUtil.HasRuntimeInitializeOnLoadMethodAttribute(m)))
            {
                return false;
            }
            return true;
        }

        public override bool NeedRename(MethodDef methodDef)
        {
            TypeDef typeDef = methodDef.DeclaringType;
            if (s_monoBehaviourEvents.Contains(methodDef.Name) && _isInheritFromMonoBehaviourCache.GetValue(typeDef))
            {
                return false;
            }
            if (_computeDeclaringTypeDisableAllMemberRenamingCache.GetValue(typeDef))
            {
                return false;
            }
            if (MetaUtil.HasRuntimeInitializeOnLoadMethodAttribute(methodDef))
            {
                return false;
            }
            if (MetaUtil.HasBurstCompileAttribute(methodDef) || MetaUtil.HasBurstCompileAttribute(methodDef.DeclaringType) || MetaUtil.HasDOTSCompilerGeneratedAttribute(methodDef))
            {
                return false;
            }
            return true;
        }

        public override bool NeedRename(FieldDef fieldDef)
        {
            TypeDef typeDef = fieldDef.DeclaringType;
            if (_isScriptOrSerializableTypeCache.GetValue(typeDef))
            {
                if (typeDef.IsEnum)
                {
                    return false;
                }
                if (fieldDef.IsPublic && !fieldDef.IsStatic)
                {
                    return false;
                }
                if (!fieldDef.IsStatic && MetaUtil.IsSerializableField(fieldDef))
                {
                    return false;
                }
            }
            if (_computeDeclaringTypeDisableAllMemberRenamingCache.GetValue(typeDef))
            {
                return false;
            }
            return true;
        }

        public override bool NeedRename(PropertyDef propertyDef)
        {
            TypeDef typeDef = propertyDef.DeclaringType;
            if (_isSerializableCache.GetValue(typeDef))
            {
                bool isGetterPublic = propertyDef.GetMethod != null && propertyDef.GetMethod.IsPublic && !propertyDef.GetMethod.IsStatic;
                bool isSetterPublic = propertyDef.SetMethod != null && propertyDef.SetMethod.IsPublic && !propertyDef.SetMethod.IsStatic;

                if (isGetterPublic || isSetterPublic)
                {
                    return false;
                }
            }
            return true;
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/Policies/UnityRenamePolicy.cs.meta`:

```meta
fileFormatVersion: 2
guid: 4357f35c667599246b2481b093f41f04
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/ReflectionCompatibilityDetector.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Obfuz.ObfusPasses.SymbolObfus
{
    public class ReflectionCompatibilityDetector
    {
        private readonly HashSet<ModuleDef> _assembliesToObfuscate;
        private readonly List<ModuleDef> _obfuscatedAndNotObfuscatedModules;
        private readonly IObfuscationPolicy _renamePolicy;

        public ReflectionCompatibilityDetector(List<ModuleDef> assembliesToObfuscate, List<ModuleDef> obfuscatedAndNotObfuscatedModules, IObfuscationPolicy renamePolicy)
        {
            _assembliesToObfuscate = new HashSet<ModuleDef>(assembliesToObfuscate);
            _obfuscatedAndNotObfuscatedModules = obfuscatedAndNotObfuscatedModules;
            _renamePolicy = renamePolicy;
        }

        public void Analyze()
        {
            foreach (ModuleDef mod in _obfuscatedAndNotObfuscatedModules)
            {
                foreach (TypeDef type in mod.GetTypes())
                {
                    foreach (MethodDef method in type.Methods)
                    {
                        AnalyzeMethod(method);
                    }
                }
            }
        }

        private MethodDef _curCallingMethod;
        private IList<Instruction> _curInstructions;
        private int _curInstIndex;

        private void AnalyzeMethod(MethodDef method)
        {
            if (!method.HasBody)
            {
                return;
            }
            _curCallingMethod = method;
            _curInstructions = method.Body.Instructions;
            _curInstIndex = 0;
            for (int n = _curInstructions.Count; _curInstIndex < n; _curInstIndex++)
            {
                var inst = _curInstructions[_curInstIndex];
                switch (inst.OpCode.Code)
                {
                    case Code.Call:
                    {
                        AnalyzeCall(inst.Operand as IMethod);
                        break;
                    }
                    case Code.Callvirt:
                    {
                        ITypeDefOrRef constrainedType = null;
                        if (_curInstIndex > 0)
                        {
                            var prevInst = _curInstructions[_curInstIndex - 1];
                            if (prevInst.OpCode.Code == Code.Constrained)
                            {
                                constrainedType = prevInst.Operand as ITypeDefOrRef;
                            }
                        }
                        AnalyzeCallvir(inst.Operand as IMethod, constrainedType);
                        break;
                    }
                }
            }
        }

        private ITypeDefOrRef FindLatestTypeOf(int backwardFindInstructionCount)
        {
            // find sequence ldtoken <type>; 
            for (int i = 2; i <= backwardFindInstructionCount; i++)
            {
                int index = _curInstIndex - i;
                if (index < 0)
                {
                    return null;
                }
                Instruction inst1 = _curInstructions[index];
                Instruction inst2 = _curInstructions[index + 1];
                if (inst1.OpCode.Code == Code.Ldtoken && inst2.OpCode.Code == Code.Call)
                {
                    if (!(inst1.Operand is ITypeDefOrRef typeDefOrRef))
                    {
                        continue;
                    }
                    IMethod method = inst2.Operand as IMethod;
                    if (method.Name == "GetTypeFromHandle" && method.DeclaringType.FullName == "System.Type")
                    {
                        // Ldtoken <type>; Call System.Type.GetTypeFromHandle(System.RuntimeTypeHandle handle)
                        return typeDefOrRef;
                    }
                }
            }
            return null;
        }

        private void AnalyzeCall(IMethod calledMethod)
        {
            TypeDef callType = calledMethod.DeclaringType.ResolveTypeDef();
            if (callType == null)
            {
                return;
            }
            switch (callType.FullName)
            {
                case "System.Enum":
                {
                    AnalyzeEnum(calledMethod, callType);
                    break;
                }
                case "System.Type":
                {
                    AnalyzeGetType(calledMethod, callType);
                    break;
                }
                case "System.Reflection.Assembly":
                {
                    if (calledMethod.Name == "GetType")
                    {
                        AnalyzeGetType(calledMethod, callType);
                    }
                    break;
                }
            }
        }


        private bool IsAnyEnumItemRenamed(TypeDef typeDef)
        {
            return _assembliesToObfuscate.Contains(typeDef.Module) && typeDef.Fields.Any(f => _renamePolicy.NeedRename(f));
        }

        private void AnalyzeCallvir(IMethod calledMethod, ITypeDefOrRef constrainedType)
        {
            TypeDef callType = calledMethod.DeclaringType.ResolveTypeDef();
            if (callType == null)
            {
                return;
            }
            string calledMethodName = calledMethod.Name;
            switch (callType.FullName)
            {
                case "System.Object":
                {
                    if (calledMethodName == "ToString")
                    {
                        if (constrainedType != null)
                        {
                            TypeDef enumTypeDef = constrainedType.ResolveTypeDef();
                            if (enumTypeDef != null && enumTypeDef.IsEnum && IsAnyEnumItemRenamed(enumTypeDef))
                            {
                                Debug.LogError($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: {enumTypeDef.FullName}.ToString() the enum members are renamed.");
                            }
                        }
                    }
                    break;
                }
                case "System.Type":
                {
                    AnalyzeGetType(calledMethod, callType);
                    break;
                }
            }
        }

        private TypeSig GetMethodGenericParameter(IMethod method)
        {
            if (method is MethodSpec ms)
            {
                return ms.GenericInstMethodSig.GenericArguments.FirstOrDefault();
            }
            else
            {
                return null;
            }
        }

        private void AnalyzeEnum(IMethod method, TypeDef typeDef)
        {
            const int extraSearchInstructionCount = 3;
            TypeSig parseTypeSig = GetMethodGenericParameter(method);
            TypeDef parseType = parseTypeSig?.ToTypeDefOrRef().ResolveTypeDef();
            switch (method.Name)
            {
                case "Parse":
                {
                    if (parseTypeSig != null)
                    {
                        // Enum.Parse<T>(string name) or Enum.Parse<T>(string name, bool caseInsensitive)
                        if (parseType != null)
                        {
                            if (IsAnyEnumItemRenamed(parseType))
                            {
                                Debug.LogError($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: Enum.Parse<T> field of T:{parseType.FullName} is renamed.");
                            }
                        }
                        else
                        {
                            Debug.LogWarning($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: Enum.Parse<T> field of T should not be renamed.");
                        }
                    }
                    else
                    {
                        // Enum.Parse(Type type, string name) or Enum.Parse(Type type, string name, bool ignoreCase)
                        TypeDef enumType = FindLatestTypeOf(method.GetParamCount() + extraSearchInstructionCount)?.ResolveTypeDef();
                        if (enumType != null && enumType.IsEnum && IsAnyEnumItemRenamed(enumType))
                        {
                            Debug.LogError($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: Enum.Parse field of argument type:{enumType.FullName} is renamed.");
                        }
                        else
                        {
                            Debug.LogWarning($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: Enum.Parse field of argument `type` should not be renamed.");
                        }
                    }
                    break;
                }
                case "TryParse":
                {
                    if (parseTypeSig != null)
                    {
                        // Enum.TryParse<T>(string name, out T result) or Enum.TryParse<T>(string name, bool ignoreCase, out T result)
                        if (parseType != null)
                        {
                            if (IsAnyEnumItemRenamed(parseType))
                            {
                                Debug.LogError($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: Enum.TryParse<T> field of T:{parseType.FullName} is renamed.");
                            }
                        }
                        else
                        {
                            Debug.LogWarning($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: Enum.TryParse<T> field of T should not be renamed.");
                        }
                    }
                    else
                    {
                        throw new Exception("impossible");
                    }
                    break;
                }
                case "GetName":
                {
                    // Enum.GetName(Type type, object value)
                    TypeDef enumType = FindLatestTypeOf(method.GetParamCount() + extraSearchInstructionCount)?.ResolveTypeDef();
                    if (enumType != null && enumType.IsEnum && IsAnyEnumItemRenamed(enumType))
                    {
                        Debug.LogError($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: Enum.GetName field of type:{enumType.FullName} is renamed.");
                    }
                    else
                    {
                        Debug.LogWarning($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: Enum.GetName field of argument `type` should not be renamed.");
                    }
                    break;
                }
                case "GetNames":
                {
                    // Enum.GetNames(Type type)
                    TypeDef enumType = FindLatestTypeOf(method.GetParamCount() + extraSearchInstructionCount)?.ResolveTypeDef();
                    if (enumType != null && enumType.IsEnum && IsAnyEnumItemRenamed(enumType))
                    {
                        Debug.LogError($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: Enum.GetNames field of type:{enumType.FullName} is renamed.");
                    }
                    else
                    {
                        Debug.LogWarning($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: Enum.GetNames field of argument `type` should not be renamed.");
                    }
                    break;
                }
            }
        }

        private void AnalyzeGetType(IMethod method, TypeDef declaringType)
        {
            switch (method.Name)
            {
                case "GetType":
                {
                    Debug.LogWarning($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: Type.GetType argument `typeName` should not be renamed.");
                    break;
                }
                case "GetField":
                case "GetFields":
                case "GetMethod":
                case "GetMethods":
                case "GetProperty":
                case "GetProperties":
                case "GetEvent":
                case "GetEvents":
                case "GetMembers":
                {
                    Debug.LogWarning($"[ReflectionCompatibilityDetector] Reflection compatibility issue in {_curCallingMethod}: called method:{method} the members of type should not be renamed.");
                    break;
                }
            }
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/ReflectionCompatibilityDetector.cs.meta`:

```meta
fileFormatVersion: 2
guid: b98c97a4d1db5d945bce0fdd2bd09202
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/RenameRecordMap.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using UnityEngine;
using UnityEngine.Assertions;

namespace Obfuz.ObfusPasses.SymbolObfus
{

    public class RenameRecordMap
    {
        private enum RenameStatus
        {
            NotRenamed,
            Renamed,
        }

        private class RenameRecord
        {
            public RenameStatus status;
            public string signature;
            public string oldName;
            public string newName;
            public string oldStackTraceSignature; // only for MethodDef
            public object renameMappingData;
        }

        private class RenameMappingField
        {
            public RenameStatus status;
            public string signature;
            public string newName;
        }

        private class RenameMappingMethod
        {
            public RenameStatus status;
            public string signature;
            public string newName;
            public string oldStackTraceSignature;
            public string newStackTraceSignature;
        }

        private class RenameMappingMethodParam
        {
            public RenameStatus status;
            public int index;
            public string newName;
        }

        private class RenameMappingProperty
        {
            public RenameStatus status;
            public string signature;
            public string newName;
        }

        private class RenameMappingEvent
        {
            public RenameStatus status;
            public string signature;
            public string newName;
        }

        private class RenameMappingType
        {
            public RenameStatus status;
            public string oldFullName;
            public string newFullName;

            public Dictionary<string, RenameMappingField> fields = new Dictionary<string, RenameMappingField>();
            public Dictionary<string, RenameMappingMethod> methods = new Dictionary<string, RenameMappingMethod>();
            public Dictionary<string, RenameMappingProperty> properties = new Dictionary<string, RenameMappingProperty>();
            public Dictionary<string, RenameMappingEvent> events = new Dictionary<string, RenameMappingEvent>();
        }

        private class RenameMappingAssembly
        {
            public string assName;

            public Dictionary<string, RenameMappingType> types = new Dictionary<string, RenameMappingType>();
        }

        private readonly string _mappingFile;
        private readonly bool _debug;
        private readonly bool _keepUnknownSymbolInSymbolMappingFile;
        private readonly Dictionary<string, RenameMappingAssembly> _assemblies = new Dictionary<string, RenameMappingAssembly>();


        private readonly Dictionary<ModuleDef, RenameRecord> _modRenames = new Dictionary<ModuleDef, RenameRecord>();
        private readonly Dictionary<TypeDef, RenameRecord> _typeRenames = new Dictionary<TypeDef, RenameRecord>();
        private readonly Dictionary<MethodDef, RenameRecord> _methodRenames = new Dictionary<MethodDef, RenameRecord>();
        private readonly Dictionary<FieldDef, RenameRecord> _fieldRenames = new Dictionary<FieldDef, RenameRecord>();
        private readonly Dictionary<PropertyDef, RenameRecord> _propertyRenames = new Dictionary<PropertyDef, RenameRecord>();
        private readonly Dictionary<EventDef, RenameRecord> _eventRenames = new Dictionary<EventDef, RenameRecord>();
        private readonly Dictionary<VirtualMethodGroup, RenameRecord> _virtualMethodGroups = new Dictionary<VirtualMethodGroup, RenameRecord>();


        public RenameRecordMap(string mappingFile, bool debug, bool keepUnknownSymbolInSymbolMappingFile)
        {
            _mappingFile = mappingFile;
            _debug = debug;
            _keepUnknownSymbolInSymbolMappingFile = keepUnknownSymbolInSymbolMappingFile;
        }

        public void Init(List<ModuleDef> assemblies, INameMaker nameMaker)
        {
            LoadXmlMappingFile(_mappingFile);
            foreach (ModuleDef mod in assemblies)
            {
                string name = mod.Assembly.Name;

                RenameMappingAssembly rma = _assemblies.GetValueOrDefault(name);

                _modRenames.Add(mod, new RenameRecord
                {
                    status = RenameStatus.NotRenamed,
                    signature = name,
                    oldName = name,
                    newName = null,
                    renameMappingData = rma,
                });

                foreach (TypeDef type in mod.GetTypes())
                {
                    nameMaker.AddPreservedName(type, name);
                    nameMaker.AddPreservedNamespace(type, type.Namespace);
                    string fullTypeName = type.FullName;
                    RenameMappingType rmt = rma?.types.GetValueOrDefault(fullTypeName);
                    if (rmt != null && rmt.status == RenameStatus.Renamed)
                    {
                        var (newNamespace, newName) = MetaUtil.SplitNamespaceAndName(rmt.newFullName);
                        nameMaker.AddPreservedNamespace(type, newNamespace);
                        nameMaker.AddPreservedName(type, newName);
                    }

                    _typeRenames.Add(type, new RenameRecord
                    {
                        status = RenameStatus.NotRenamed,
                        signature = fullTypeName,
                        oldName = fullTypeName,
                        newName = null,
                        renameMappingData = rmt,
                    });
                    foreach (MethodDef method in type.Methods)
                    {
                        nameMaker.AddPreservedName(method, method.Name);
                        string methodSig = TypeSigUtil.ComputeMethodDefSignature(method);

                        RenameMappingMethod rmm = rmt?.methods.GetValueOrDefault(methodSig);
                        if (rmm != null && rmm.status == RenameStatus.Renamed)
                        {
                            nameMaker.AddPreservedName(method, rmm.newName);
                        }
                        _methodRenames.Add(method, new RenameRecord
                        {
                            status = RenameStatus.NotRenamed,
                            signature = methodSig,
                            oldName = method.Name,
                            newName = null,
                            renameMappingData = rmm,
                            oldStackTraceSignature = MetaUtil.CreateMethodDefIl2CppStackTraceSignature(method),
                        });
                    }
                    foreach (FieldDef field in type.Fields)
                    {
                        nameMaker.AddPreservedName(field, field.Name);
                        string fieldSig = TypeSigUtil.ComputeFieldDefSignature(field);
                        RenameMappingField rmf = rmt?.fields.GetValueOrDefault(fieldSig);
                        if (rmf != null && rmf.status == RenameStatus.Renamed)
                        {
                            nameMaker.AddPreservedName(field, rmf.newName);
                        }
                        _fieldRenames.Add(field, new RenameRecord
                        {
                            status = RenameStatus.NotRenamed,
                            signature = fieldSig,
                            oldName = field.Name,
                            newName = null,
                            renameMappingData = rmf,
                        });
                    }
                    foreach (PropertyDef property in type.Properties)
                    {
                        nameMaker.AddPreservedName(property, property.Name);
                        string propertySig = TypeSigUtil.ComputePropertyDefSignature(property);
                        RenameMappingProperty rmp = rmt?.properties.GetValueOrDefault(propertySig);
                        if (rmp != null && rmp.status == RenameStatus.Renamed)
                        {
                            nameMaker.AddPreservedName(property, rmp.newName);
                        }
                        _propertyRenames.Add(property, new RenameRecord
                        {
                            status = RenameStatus.NotRenamed,
                            signature = propertySig,
                            oldName = property.Name,
                            newName = null,
                            renameMappingData = rmp,
                        });
                    }
                    foreach (EventDef eventDef in type.Events)
                    {
                        nameMaker.AddPreservedName(eventDef, eventDef.Name);
                        string eventSig = TypeSigUtil.ComputeEventDefSignature(eventDef);
                        RenameMappingEvent rme = rmt?.events.GetValueOrDefault(eventSig);
                        if (rme != null && rme.status == RenameStatus.Renamed)
                        {
                            nameMaker.AddPreservedName(eventDef, rme.newName);
                        }
                        _eventRenames.Add(eventDef, new RenameRecord
                        {
                            status = RenameStatus.NotRenamed,
                            signature = eventSig,
                            oldName = eventDef.Name,
                            newName = null,
                            renameMappingData = rme,
                        });
                    }
                }
            }
        }

        private void LoadXmlMappingFile(string mappingFile)
        {
            if (string.IsNullOrEmpty(mappingFile) || !File.Exists(mappingFile))
            {
                return;
            }
            if (_debug)
            {
                Debug.Log($"skip loading debug mapping file: {Path.GetFullPath(mappingFile)}");
                return;
            }
            var doc = new XmlDocument();
            doc.Load(mappingFile);
            var root = doc.DocumentElement;
            foreach (XmlNode node in root.ChildNodes)
            {
                if (!(node is XmlElement element))
                {
                    continue;
                }
                LoadAssemblyMapping(element);
            }
        }

        private void LoadAssemblyMapping(XmlElement ele)
        {
            if (ele.Name != "assembly")
            {
                throw new System.Exception($"Invalid node name: {ele.Name}. Expected 'assembly'.");
            }

            var assemblyName = ele.Attributes["name"].Value;
            var rma = new RenameMappingAssembly
            {
                assName = assemblyName,
            };
            foreach (XmlNode node in ele.ChildNodes)
            {
                if (!(node is XmlElement element))
                {
                    continue;
                }
                if (element.Name != "type")
                {
                    throw new System.Exception($"Invalid node name: {element.Name}. Expected 'type'.");
                }
                LoadTypeMapping(element, rma);
            }
            _assemblies.Add(assemblyName, rma);
        }

        private void LoadTypeMapping(XmlElement ele, RenameMappingAssembly ass)
        {
            var typeName = ele.Attributes["fullName"].Value;
            var newTypeName = ele.Attributes["newFullName"].Value;
            var rmt = new RenameMappingType
            {
                oldFullName = typeName,
                newFullName = newTypeName,
                status = (RenameStatus)System.Enum.Parse(typeof(RenameStatus), ele.Attributes["status"].Value),
            };
            foreach (XmlNode node in ele.ChildNodes)
            {
                if (!(node is XmlElement c))
                {
                    continue;
                }
                switch (node.Name)
                {
                    case "field": LoadFieldMapping(c, rmt); break;
                    case "event": LoadEventMapping(c, rmt); break;
                    case "property": LoadPropertyMapping(c, rmt); break;
                    case "method": LoadMethodMapping(c, rmt); break;
                    default: throw new System.Exception($"Invalid node name:{node.Name}");
                }
            }
            ass.types.Add(typeName, rmt);
        }

        private void LoadMethodMapping(XmlElement ele, RenameMappingType type)
        {
            string signature = ele.Attributes["signature"].Value;
            string newName = ele.Attributes["newName"].Value;
            string oldStackTraceSignature = ele.Attributes["oldStackTraceSignature"].Value;
            string newStackTraceSignature = ele.Attributes["newStackTraceSignature"].Value;
            var rmm = new RenameMappingMethod
            {
                signature = signature,
                newName = newName,
                status = RenameStatus.Renamed,
                oldStackTraceSignature = oldStackTraceSignature,
                newStackTraceSignature = newStackTraceSignature,
            };
            type.methods.Add(signature, rmm);
        }

        private void LoadFieldMapping(XmlElement ele, RenameMappingType type)
        {
            string signature = ele.Attributes["signature"].Value;
            string newName = ele.Attributes["newName"].Value;
            var rmf = new RenameMappingField
            {
                signature = signature,
                newName = newName,
                status = RenameStatus.Renamed,
            };
            type.fields.Add(signature, rmf);
        }

        private void LoadPropertyMapping(XmlElement ele, RenameMappingType type)
        {
            string signature = ele.Attributes["signature"].Value;
            string newName = ele.Attributes["newName"].Value;
            var rmp = new RenameMappingProperty
            {
                signature = signature,
                newName = newName,
                status = RenameStatus.Renamed,
            };
            type.properties.Add(signature, rmp);
        }

        private void LoadEventMapping(XmlElement ele, RenameMappingType type)
        {
            string signature = ele.Attributes["signature"].Value;
            string newName = ele.Attributes["newName"].Value;
            var rme = new RenameMappingEvent
            {
                signature = signature,
                newName = newName,
                status = RenameStatus.Renamed,
            };
            type.events.Add(signature, rme);
        }

        private List<V> GetSortedValueList<K, V>(Dictionary<K, V> dic, Comparison<V> comparer)
        {
            var list = dic.Values.ToList();
            list.Sort(comparer);
            return list;
        }

        public void WriteXmlMappingFile()
        {
            if (string.IsNullOrEmpty(_mappingFile))
            {
                return;
            }
            var doc = new XmlDocument();
            var root = doc.CreateElement("mapping");
            doc.AppendChild(root);

            var totalAssNames = new HashSet<string>(_modRenames.Keys.Select(m => m.Assembly.Name.ToString()).Concat(_assemblies.Keys)).ToList();
            totalAssNames.Sort((a, b) => a.CompareTo(b));
            foreach (string assName in totalAssNames)
            {
                ModuleDef mod = _modRenames.Keys.FirstOrDefault(m => m.Assembly.Name == assName);
                var assemblyNode = doc.CreateElement("assembly");
                assemblyNode.SetAttribute("name", assName);
                root.AppendChild(assemblyNode);
                if (mod != null)
                {
                    var types = mod.GetTypes().ToDictionary(t => _typeRenames.TryGetValue(t, out var rec) ? rec.oldName : t.FullName, t => t);
                    if (_assemblies.TryGetValue(assName, out var ass))
                    {
                        var totalTypeNames = new HashSet<string>(types.Keys.Concat(ass.types.Keys)).ToList();
                        totalTypeNames.Sort((a, b) => a.CompareTo((b)));
                        foreach (string typeName in totalTypeNames)
                        {
                            if (types.TryGetValue(typeName, out TypeDef typeDef))
                            {
                                WriteTypeMapping(assemblyNode, typeDef);
                            }
                            else if (_keepUnknownSymbolInSymbolMappingFile)
                            {
                                WriteTypeMapping(assemblyNode, typeName, ass.types[typeName]);
                            }
                        }
                    }
                    else
                    {
                        var sortedTypes = new SortedDictionary<string, TypeDef>(types);
                        foreach (TypeDef type in sortedTypes.Values)
                        {
                            WriteTypeMapping(assemblyNode, type);
                        }
                    }
                }
                else
                {
                    RenameMappingAssembly ass = _assemblies[assName];

                    var sortedTypes = GetSortedValueList(ass.types, (a, b) => a.oldFullName.CompareTo(b.oldFullName));
                    foreach (var type in sortedTypes)
                    {
                        WriteTypeMapping(assemblyNode, type.oldFullName, type);
                    }
                }
            }
            Directory.CreateDirectory(Path.GetDirectoryName(_mappingFile));
            doc.Save(_mappingFile);
            Debug.Log($"Mapping file saved to {Path.GetFullPath(_mappingFile)}");
        }

        private void WriteTypeMapping(XmlElement assNode, TypeDef type)
        {
            _typeRenames.TryGetValue(type, out var record);
            var typeNode = assNode.OwnerDocument.CreateElement("type");
            typeNode.SetAttribute("fullName", record?.signature ?? type.FullName);
            typeNode.SetAttribute("newFullName", record != null && record.status == RenameStatus.Renamed ? record.newName : "");
            typeNode.SetAttribute("status", record != null ? record.status.ToString() : RenameStatus.NotRenamed.ToString());
            if (record != null && record.status == RenameStatus.Renamed)
            {
                Assert.IsFalse(string.IsNullOrWhiteSpace(record.newName), "New name for type cannot be null or empty when status is Renamed.");
            }

            foreach (FieldDef field in type.Fields)
            {
                WriteFieldMapping(typeNode, field);
            }
            foreach (PropertyDef property in type.Properties)
            {
                WritePropertyMapping(typeNode, property);
            }
            foreach (EventDef eventDef in type.Events)
            {
                WriteEventMapping(typeNode, eventDef);
            }
            foreach (MethodDef method in type.Methods)
            {
                WriteMethodMapping(typeNode, method);
            }
            if ((record != null && record.status == RenameStatus.Renamed) || typeNode.ChildNodes.Count > 0)
            {
                assNode.AppendChild(typeNode);
            }
        }

        private void WriteTypeMapping(XmlElement assNode, string fullName, RenameMappingType type)
        {
            var typeNode = assNode.OwnerDocument.CreateElement("type");
            typeNode.SetAttribute("fullName", fullName);
            typeNode.SetAttribute("newFullName", type.status == RenameStatus.Renamed ? type.newFullName : "");
            typeNode.SetAttribute("status", type.status.ToString());

            foreach (var e in type.fields)
            {
                string signature = e.Key;
                RenameMappingField field = e.Value;
                WriteFieldMapping(typeNode, e.Key, e.Value);
            }
            foreach (var e in type.properties)
            {
                WritePropertyMapping(typeNode, e.Key, e.Value);
            }
            foreach (var e in type.events)
            {
                WriteEventMapping(typeNode, e.Key, e.Value);
            }
            foreach (var e in type.methods)
            {
                WriteMethodMapping(typeNode, e.Key, e.Value);
            }

            assNode.AppendChild(typeNode);
        }

        private void WriteFieldMapping(XmlElement typeEle, FieldDef field)
        {
            if (!_fieldRenames.TryGetValue(field, out var record) || record.status == RenameStatus.NotRenamed)
            {
                return;
            }
            var fieldNode = typeEle.OwnerDocument.CreateElement("field");
            fieldNode.SetAttribute("signature", record?.signature);
            fieldNode.SetAttribute("newName", record.newName);
            //fieldNode.SetAttribute("status", record.status.ToString());
            typeEle.AppendChild(fieldNode);
        }

        private void WriteFieldMapping(XmlElement typeEle, string signature, RenameMappingField field)
        {
            var fieldNode = typeEle.OwnerDocument.CreateElement("field");
            fieldNode.SetAttribute("signature", signature);
            fieldNode.SetAttribute("newName", field.newName);
            //fieldNode.SetAttribute("status", record.status.ToString());
            typeEle.AppendChild(fieldNode);
        }

        private void WritePropertyMapping(XmlElement typeEle, PropertyDef property)
        {
            if (!_propertyRenames.TryGetValue(property, out var record) || record.status == RenameStatus.NotRenamed)
            {
                return;
            }
            var propertyNode = typeEle.OwnerDocument.CreateElement("property");
            propertyNode.SetAttribute("signature", record.signature);
            propertyNode.SetAttribute("newName", record.newName);
            //propertyNode.SetAttribute("status", record.status.ToString());
            typeEle.AppendChild(propertyNode);
        }

        private void WritePropertyMapping(XmlElement typeEle, string signature, RenameMappingProperty property)
        {
            var propertyNode = typeEle.OwnerDocument.CreateElement("property");
            propertyNode.SetAttribute("signature", signature);
            propertyNode.SetAttribute("newName", property.newName);
            //propertyNode.SetAttribute("status", record.status.ToString());
            typeEle.AppendChild(propertyNode);
        }

        private void WriteEventMapping(XmlElement typeEle, EventDef eventDef)
        {
            if (!_eventRenames.TryGetValue(eventDef, out var record) || record.status == RenameStatus.NotRenamed)
            {
                return;
            }
            var eventNode = typeEle.OwnerDocument.CreateElement("event");
            eventNode.SetAttribute("signature", record.signature);
            eventNode.SetAttribute("newName", record.newName);
            typeEle.AppendChild(eventNode);
        }

        private void WriteEventMapping(XmlElement typeEle, string signature, RenameMappingEvent eventDef)
        {
            var eventNode = typeEle.OwnerDocument.CreateElement("event");
            eventNode.SetAttribute("signature", signature);
            eventNode.SetAttribute("newName", eventDef.newName);
            typeEle.AppendChild(eventNode);
        }

        private void WriteMethodMapping(XmlElement typeEle, MethodDef method)
        {
            if (!_methodRenames.TryGetValue(method, out var record) || record.status == RenameStatus.NotRenamed)
            {
                return;
            }
            var methodNode = typeEle.OwnerDocument.CreateElement("method");
            methodNode.SetAttribute("signature", record.signature);
            methodNode.SetAttribute("newName", record.newName);
            methodNode.SetAttribute("oldStackTraceSignature", record.oldStackTraceSignature);
            methodNode.SetAttribute("newStackTraceSignature", MetaUtil.CreateMethodDefIl2CppStackTraceSignature(method));
            //methodNode.SetAttribute("status", record != null ? record.status.ToString() : RenameStatus.NotRenamed.ToString());
            typeEle.AppendChild(methodNode);
        }

        private void WriteMethodMapping(XmlElement typeEle, string signature, RenameMappingMethod method)
        {
            var methodNode = typeEle.OwnerDocument.CreateElement("method");
            methodNode.SetAttribute("signature", signature);
            methodNode.SetAttribute("newName", method.newName);
            methodNode.SetAttribute("oldStackTraceSignature", method.oldStackTraceSignature);
            methodNode.SetAttribute("newStackTraceSignature", method.newStackTraceSignature);
            typeEle.AppendChild(methodNode);
        }

        public void AddRename(ModuleDef mod, string newName)
        {
            RenameRecord record = _modRenames[mod];
            record.status = RenameStatus.Renamed;
            record.newName = newName;
        }

        public void AddRename(TypeDef type, string newName)
        {
            RenameRecord record = _typeRenames[type];
            record.status = RenameStatus.Renamed;
            record.newName = newName;
        }

        public void AddRename(MethodDef method, string newName)
        {
            if (_methodRenames.TryGetValue(method, out RenameRecord record))
            {
                record.status = RenameStatus.Renamed;
                record.newName = newName;
                return;
            }
            else
            {
                string methodSig = TypeSigUtil.ComputeMethodDefSignature(method);
                _methodRenames.Add(method, new RenameRecord
                {
                    status = RenameStatus.Renamed,
                    signature = methodSig,
                    oldName = method.Name,
                    newName = newName,
                    renameMappingData = null,
                    oldStackTraceSignature = MetaUtil.CreateMethodDefIl2CppStackTraceSignature(method),
                });
            }
        }

        public void InitAndAddRename(VirtualMethodGroup methodGroup, string newName)
        {
            RenameRecord methodRecord = methodGroup.methods.Where(m => _methodRenames.ContainsKey(m)).Select(m => _methodRenames[m]).FirstOrDefault();
            MethodDef firstMethod = methodGroup.methods[0];
            _virtualMethodGroups.Add(methodGroup, new RenameRecord
            {
                status = RenameStatus.Renamed,
                signature = methodRecord != null ? methodRecord.signature : TypeSigUtil.ComputeMethodDefSignature(firstMethod),
                oldName = methodRecord != null ? methodRecord.oldName : (string)firstMethod.Name,
                newName = newName,
            });
        }

        public void AddRename(FieldDef field, string newName)
        {
            RenameRecord record = _fieldRenames[field];
            record.status = RenameStatus.Renamed;
            record.newName = newName;
        }

        public void AddRename(PropertyDef property, string newName)
        {
            RenameRecord record = _propertyRenames[property];
            record.status = RenameStatus.Renamed;
            record.newName = newName;
        }

        public void AddRename(EventDef eventDef, string newName)
        {
            RenameRecord record = _eventRenames[eventDef];
            record.status = RenameStatus.Renamed;
            record.newName = newName;
        }

        public bool TryGetExistRenameMapping(TypeDef type, out string newNamespace, out string newName)
        {
            if (_typeRenames.TryGetValue(type, out var record) && record.renameMappingData != null)
            {
                var rmt = (RenameMappingType)record.renameMappingData;
                if (rmt.status == RenameStatus.Renamed)
                {
                    Assert.IsFalse(string.IsNullOrWhiteSpace(rmt.newFullName));
                    (newNamespace, newName) = MetaUtil.SplitNamespaceAndName(rmt.newFullName);
                    return true;
                }
            }
            newNamespace = null;
            newName = null;
            return false;
        }

        public bool TryGetExistRenameMapping(MethodDef method, out string newName)
        {
            if (_methodRenames.TryGetValue(method, out var record) && record.renameMappingData != null)
            {
                RenameMappingMethod rmm = (RenameMappingMethod)record.renameMappingData;
                if (rmm.status == RenameStatus.Renamed)
                {
                    newName = ((RenameMappingMethod)record.renameMappingData).newName;
                    return true;
                }
            }
            newName = null;
            return false;
        }

        public bool TryGetExistRenameMapping(FieldDef field, out string newName)
        {
            if (_fieldRenames.TryGetValue(field, out var record) && record.renameMappingData != null)
            {
                RenameMappingField rmm = (RenameMappingField)record.renameMappingData;
                if (rmm.status == RenameStatus.Renamed)
                {
                    newName = ((RenameMappingField)record.renameMappingData).newName;
                    return true;
                }
            }
            newName = null;
            return false;
        }

        public bool TryGetExistRenameMapping(PropertyDef property, out string newName)
        {
            if (_propertyRenames.TryGetValue(property, out var record) && record.renameMappingData != null)
            {
                RenameMappingProperty rmm = (RenameMappingProperty)record.renameMappingData;
                if (rmm.status == RenameStatus.Renamed)
                {
                    newName = ((RenameMappingProperty)record.renameMappingData).newName;
                    return true;
                }
            }
            newName = null;
            return false;
        }

        public bool TryGetExistRenameMapping(EventDef eventDef, out string newName)
        {
            if (_eventRenames.TryGetValue(eventDef, out var record) && record.renameMappingData != null)
            {
                RenameMappingEvent rmm = (RenameMappingEvent)record.renameMappingData;
                if (rmm.status == RenameStatus.Renamed)
                {
                    newName = ((RenameMappingEvent)record.renameMappingData).newName;
                    return true;
                }
            }
            newName = null;
            return false;
        }

        public bool TryGetRename(VirtualMethodGroup group, out string newName)
        {
            if (_virtualMethodGroups.TryGetValue(group, out var record))
            {
                newName = record.newName;
                return true;
            }
            newName = null;
            return false;
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/RenameRecordMap.cs.meta`:

```meta
fileFormatVersion: 2
guid: a3ffbd28624d87c4382f62eb4fc19c70
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/SymbolObfusPass.cs`:

```cs
using Obfuz.Settings;

namespace Obfuz.ObfusPasses.SymbolObfus
{
    public class SymbolObfusPass : ObfuscationPassBase
    {
        private SymbolRename _symbolRename;

        public override ObfuscationPassType Type => ObfuscationPassType.SymbolObfus;

        public SymbolObfusPass(SymbolObfuscationSettingsFacade settings)
        {
            _symbolRename = new SymbolRename(settings);
        }

        public override void Start()
        {
            _symbolRename.Init();
        }

        public override void Stop()
        {
            _symbolRename.Save();
        }

        public override void Process()
        {
            _symbolRename.Process();
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/SymbolObfusPass.cs.meta`:

```meta
fileFormatVersion: 2
guid: a4c9a37b51ade6b46a299be7ad2155d6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/SymbolRename.cs`:

```cs
using dnlib.DotNet;
using Obfuz.ObfusPasses.SymbolObfus.NameMakers;
using Obfuz.ObfusPasses.SymbolObfus.Policies;
using Obfuz.Settings;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;
using UnityEngine.Assertions;

namespace Obfuz.ObfusPasses.SymbolObfus
{
    public class SymbolRename
    {
        private readonly bool _useConsistentNamespaceObfuscation;
        private readonly bool _detectReflectionCompatibility;
        private readonly List<string> _obfuscationRuleFiles;
        private readonly string _mappingXmlPath;

        private AssemblyCache _assemblyCache;

        private List<ModuleDef> _toObfuscatedModules;
        private List<ModuleDef> _obfuscatedAndNotObfuscatedModules;
        private HashSet<ModuleDef> _toObfuscatedModuleSet;
        private HashSet<ModuleDef> _nonObfuscatedButReferencingObfuscatedModuleSet;
        private IObfuscationPolicy _renamePolicy;
        private INameMaker _nameMaker;
        private readonly Dictionary<ModuleDef, List<CustomAttributeInfo>> _customAttributeArgumentsWithTypeByMods = new Dictionary<ModuleDef, List<CustomAttributeInfo>>();
        private readonly RenameRecordMap _renameRecordMap;
        private readonly VirtualMethodGroupCalculator _virtualMethodGroupCalculator;
        private readonly List<IObfuscationPolicy> _customPolicies = new List<IObfuscationPolicy>();

        class CustomAttributeInfo
        {
            public CustomAttributeCollection customAttributes;
            public int index;
            public List<CAArgument> arguments;
            public List<CANamedArgument> namedArguments;
        }

        public SymbolRename(SymbolObfuscationSettingsFacade settings)
        {
            _useConsistentNamespaceObfuscation = settings.useConsistentNamespaceObfuscation;
            _detectReflectionCompatibility = settings.detectReflectionCompatibility;
            _mappingXmlPath = settings.symbolMappingFile;
            _obfuscationRuleFiles = settings.ruleFiles.ToList();
            _renameRecordMap = new RenameRecordMap(settings.symbolMappingFile, settings.debug, settings.keepUnknownSymbolInSymbolMappingFile);
            _virtualMethodGroupCalculator = new VirtualMethodGroupCalculator();
            _nameMaker = settings.debug ? NameMakerFactory.CreateDebugNameMaker() : NameMakerFactory.CreateNameMakerBaseASCIICharSet(settings.obfuscatedNamePrefix);

            foreach (var customPolicyType in settings.customRenamePolicyTypes)
            {
                if (Activator.CreateInstance(customPolicyType, new object[] { this }) is IObfuscationPolicy customPolicy)
                {
                    _customPolicies.Add(customPolicy);
                }
                else
                {
                    Debug.LogWarning($"Custom rename policy type {customPolicyType} is not a valid IObfuscationPolicy");
                }
            }
        }

        public void Init()
        {
            var ctx = ObfuscationPassContext.Current;
            _assemblyCache = ctx.assemblyCache;
            _toObfuscatedModules = ctx.modulesToObfuscate;
            _obfuscatedAndNotObfuscatedModules = ctx.allObfuscationRelativeModules;
            _toObfuscatedModuleSet = new HashSet<ModuleDef>(ctx.modulesToObfuscate);
            _nonObfuscatedButReferencingObfuscatedModuleSet = new HashSet<ModuleDef>(ctx.allObfuscationRelativeModules.Where(m => !_toObfuscatedModuleSet.Contains(m)));

            var obfuscateRuleConfig = new ConfigurableRenamePolicy(ctx.coreSettings.assembliesToObfuscate, ctx.modulesToObfuscate, _obfuscationRuleFiles);
            var totalRenamePolicies = new List<IObfuscationPolicy>
            {
                new SupportPassPolicy(ctx.passPolicy),
                new SystemRenamePolicy(ctx.obfuzIgnoreScopeComputeCache),
                new UnityRenamePolicy(),
                obfuscateRuleConfig,
            };
            totalRenamePolicies.AddRange(_customPolicies);

            _renamePolicy = new CacheRenamePolicy(new CombineRenamePolicy(totalRenamePolicies.ToArray()));
            BuildCustomAttributeArguments();
        }

        private void CollectCArgumentWithTypeOf(IHasCustomAttribute meta, List<CustomAttributeInfo> customAttributes)
        {
            int index = 0;
            foreach (CustomAttribute ca in meta.CustomAttributes)
            {
                List<CAArgument> arguments = null;
                if (ca.ConstructorArguments.Any(a => MetaUtil.MayRenameCustomDataType(a.Type.ElementType)))
                {
                    arguments = ca.ConstructorArguments.ToList();
                }
                List<CANamedArgument> namedArguments = ca.NamedArguments.Count > 0 ? ca.NamedArguments.ToList() : null;
                if (arguments != null || namedArguments != null)
                {
                    customAttributes.Add(new CustomAttributeInfo
                    {
                        customAttributes = meta.CustomAttributes,
                        index = index,
                        arguments = arguments,
                        namedArguments = namedArguments
                    });
                }
                ++index;
            }
        }

        private void BuildCustomAttributeArguments()
        {
            foreach (ModuleDef mod in _obfuscatedAndNotObfuscatedModules)
            {
                var customAttributes = new List<CustomAttributeInfo>();
                CollectCArgumentWithTypeOf(mod, customAttributes);
                foreach (TypeDef type in mod.GetTypes())
                {
                    CollectCArgumentWithTypeOf(type, customAttributes);
                    foreach (FieldDef field in type.Fields)
                    {
                        CollectCArgumentWithTypeOf(field, customAttributes);
                    }
                    foreach (MethodDef method in type.Methods)
                    {
                        CollectCArgumentWithTypeOf(method, customAttributes);
                        foreach (Parameter param in method.Parameters)
                        {
                            if (param.ParamDef != null)
                            {
                                CollectCArgumentWithTypeOf(param.ParamDef, customAttributes);
                            }
                        }
                    }
                    foreach (PropertyDef property in type.Properties)
                    {
                        CollectCArgumentWithTypeOf(property, customAttributes);
                    }
                    foreach (EventDef eventDef in type.Events)
                    {
                        CollectCArgumentWithTypeOf(eventDef, customAttributes);
                    }
                }

                _customAttributeArgumentsWithTypeByMods.Add(mod, customAttributes);
            }
        }

        private void PrecomputeNeedRename()
        {
            foreach (ModuleDef mod in _toObfuscatedModules)
            {
                foreach (TypeDef type in mod.GetTypes())
                {
                    _renamePolicy.NeedRename(type);
                    foreach (var field in type.Fields)
                    {
                        _renamePolicy.NeedRename(field);
                    }
                    foreach (var method in type.Methods)
                    {
                        _renamePolicy.NeedRename(method);
                    }
                    foreach (var property in type.Properties)
                    {
                        _renamePolicy.NeedRename(property);
                    }
                    foreach (var eventDef in type.Events)
                    {
                        _renamePolicy.NeedRename(eventDef);
                    }
                }
            }
        }

        public void Process()
        {
            _renameRecordMap.Init(_toObfuscatedModules, _nameMaker);
            PrecomputeNeedRename();
            if (_detectReflectionCompatibility)
            {
                var reflectionCompatibilityDetector = new ReflectionCompatibilityDetector(_toObfuscatedModules, _obfuscatedAndNotObfuscatedModules, _renamePolicy);
                reflectionCompatibilityDetector.Analyze();
            }
            RenameTypes();
            RenameFields();
            RenameMethods();
            RenameProperties();
            RenameEvents();
        }

        class RefTypeDefMetas
        {
            public readonly List<TypeRef> typeRefs = new List<TypeRef>();

            public readonly List<CustomAttribute> customAttributes = new List<CustomAttribute>();
        }

        private void BuildRefTypeDefMetasMap(Dictionary<TypeDef, RefTypeDefMetas> refTypeDefMetasMap)
        {
            foreach (ModuleDef mod in _obfuscatedAndNotObfuscatedModules)
            {
                foreach (TypeRef typeRef in mod.GetTypeRefs())
                {
                    if (typeRef.DefinitionAssembly.IsCorLib())
                    {
                        continue;
                    }
                    TypeDef typeDef = typeRef.ResolveThrow();
                    if (!refTypeDefMetasMap.TryGetValue(typeDef, out var typeDefMetas))
                    {
                        typeDefMetas = new RefTypeDefMetas();
                        refTypeDefMetasMap.Add(typeDef, typeDefMetas);
                    }
                    typeDefMetas.typeRefs.Add(typeRef);
                }
            }

            foreach (CustomAttributeInfo cai in _customAttributeArgumentsWithTypeByMods.Values.SelectMany(cas => cas))
            {
                CustomAttribute ca = cai.customAttributes[cai.index];
                TypeDef typeDef = MetaUtil.GetTypeDefOrGenericTypeBaseThrowException(ca.Constructor.DeclaringType);
                if (!refTypeDefMetasMap.TryGetValue(typeDef, out var typeDefMetas))
                {
                    typeDefMetas = new RefTypeDefMetas();
                    refTypeDefMetasMap.Add(typeDef, typeDefMetas);
                }
                typeDefMetas.customAttributes.Add(ca);
            }
        }

        private void RetargetTypeRefInCustomAttributes()
        {
            foreach (CustomAttributeInfo cai in _customAttributeArgumentsWithTypeByMods.Values.SelectMany(cas => cas))
            {
                CustomAttribute ca = cai.customAttributes[cai.index];
                bool anyChange = false;
                if (cai.arguments != null)
                {
                    for (int i = 0; i < cai.arguments.Count; i++)
                    {
                        CAArgument oldArg = cai.arguments[i];
                        if (MetaUtil.TryRetargetTypeRefInArgument(oldArg, out CAArgument newArg))
                        {
                            anyChange = true;
                            cai.arguments[i] = newArg;
                        }
                    }
                }
                if (cai.namedArguments != null)
                {
                    for (int i = 0; i < cai.namedArguments.Count; i++)
                    {
                        if (MetaUtil.TryRetargetTypeRefInNamedArgument(cai.namedArguments[i]))
                        {
                            anyChange = true;
                        }
                    }
                }
                if (anyChange)
                {
                    cai.customAttributes[cai.index] = new CustomAttribute(ca.Constructor,
                        cai.arguments != null ? cai.arguments : ca.ConstructorArguments,
                        cai.namedArguments != null ? cai.namedArguments : ca.NamedArguments);
                }
            }
        }

        private readonly Dictionary<TypeDef, RefTypeDefMetas> _refTypeRefMetasMap = new Dictionary<TypeDef, RefTypeDefMetas>();

        private void RenameTypes()
        {
            //Debug.Log("RenameTypes begin");

            RetargetTypeRefInCustomAttributes();

            BuildRefTypeDefMetasMap(_refTypeRefMetasMap);
            _assemblyCache.EnableTypeDefCache = false;

            foreach (ModuleDef mod in _toObfuscatedModules)
            {
                foreach (TypeDef type in mod.GetTypes())
                {
                    if (_renamePolicy.NeedRename(type))
                    {
                        Rename(type, _refTypeRefMetasMap.GetValueOrDefault(type));
                    }
                }
            }

            // clean cache
            _assemblyCache.EnableTypeDefCache = true;
            //Debug.Log("Rename Types end");
        }


        class RefFieldMetas
        {
            public readonly List<MemberRef> fieldRefs = new List<MemberRef>();
            public readonly List<CustomAttribute> customAttributes = new List<CustomAttribute>();
        }


        private void BuildHierarchyFields(TypeDef type, List<FieldDef> fields)
        {
            while (type != null)
            {
                fields.AddRange(type.Fields);
                type = MetaUtil.GetBaseTypeDef(type);
            }
        }

        private IEnumerable<T> WalkAllMethodInstructionOperand<T>(ModuleDef mod)
        {
            foreach (TypeDef type in mod.GetTypes())
            {
                foreach (MethodDef method in type.Methods)
                {
                    if (!method.HasBody)
                    {
                        continue;
                    }
                    foreach (var instr in method.Body.Instructions)
                    {
                        if (instr.Operand is T memberRef)
                        {
                            yield return memberRef;
                        }
                    }
                }
            }
        }

        private void BuildRefFieldMetasMap(Dictionary<FieldDef, RefFieldMetas> refFieldMetasMap)
        {
            foreach (ModuleDef mod in _obfuscatedAndNotObfuscatedModules)
            {
                foreach (MemberRef memberRef in WalkAllMethodInstructionOperand<MemberRef>(mod))
                {
                    IMemberRefParent parent = memberRef.Class;
                    TypeDef parentTypeDef = MetaUtil.GetMemberRefTypeDefParentOrNull(parent);
                    if (parentTypeDef == null)
                    {
                        continue;
                    }
                    foreach (FieldDef field in parentTypeDef.Fields)
                    {
                        if (field.Name == memberRef.Name && TypeEqualityComparer.Instance.Equals(field.FieldSig.Type, memberRef.FieldSig.Type))
                        {
                            if (!refFieldMetasMap.TryGetValue(field, out var fieldMetas))
                            {
                                fieldMetas = new RefFieldMetas();
                                refFieldMetasMap.Add(field, fieldMetas);
                            }
                            fieldMetas.fieldRefs.Add(memberRef);
                            break;
                        }
                    }
                }
            }
            foreach (var e in _refTypeRefMetasMap)
            {
                TypeDef typeDef = e.Key;
                var hierarchyFields = new List<FieldDef>();
                BuildHierarchyFields(typeDef, hierarchyFields);
                RefTypeDefMetas typeDefMetas = e.Value;
                foreach (CustomAttribute ca in typeDefMetas.customAttributes)
                {
                    foreach (var arg in ca.NamedArguments)
                    {
                        if (arg.IsProperty)
                        {
                            continue;
                        }
                        foreach (FieldDef field in hierarchyFields)
                        {
                            // FIXME. field of Generic Base Type may not be same
                            if (field.Name == arg.Name && TypeEqualityComparer.Instance.Equals(field.FieldType, arg.Type))
                            {
                                if (!refFieldMetasMap.TryGetValue(field, out var fieldMetas))
                                {
                                    fieldMetas = new RefFieldMetas();
                                    refFieldMetasMap.Add(field, fieldMetas);
                                }
                                fieldMetas.customAttributes.Add(ca);
                                break;
                            }
                        }
                    }
                }
            }
        }

        private void RenameFields()
        {
            //Debug.Log("Rename fields begin");
            var refFieldMetasMap = new Dictionary<FieldDef, RefFieldMetas>();
            BuildRefFieldMetasMap(refFieldMetasMap);

            foreach (ModuleDef mod in _toObfuscatedModules)
            {
                foreach (TypeDef type in mod.GetTypes())
                {
                    foreach (FieldDef field in type.Fields)
                    {
                        if (_renamePolicy.NeedRename(field))
                        {
                            Rename(field, refFieldMetasMap.GetValueOrDefault(field));
                        }
                    }
                }
            }
            //Debug.Log("Rename fields end");
        }

        class RefMethodMetas
        {
            public readonly List<MemberRef> memberRefs = new List<MemberRef>();
        }

        private void RenameMethodRef(MemberRef memberRef, Dictionary<MethodDef, RefMethodMetas> refMethodMetasMap)
        {
            if (!memberRef.IsMethodRef)
            {
                return;
            }

            IMemberRefParent parent = memberRef.Class;
            TypeDef parentTypeDef = MetaUtil.GetMemberRefTypeDefParentOrNull(parent);
            if (parentTypeDef == null)
            {
                return;
            }
            foreach (MethodDef methodDef in parentTypeDef.Methods)
            {
                if (methodDef.Name == memberRef.Name && new SigComparer(default).Equals(methodDef.MethodSig, memberRef.MethodSig))
                {
                    if (!refMethodMetasMap.TryGetValue(methodDef, out var refMethodMetas))
                    {
                        refMethodMetas = new RefMethodMetas();
                        refMethodMetasMap.Add(methodDef, refMethodMetas);
                    }
                    refMethodMetas.memberRefs.Add(memberRef);
                    break;
                }
            }
        }


        private void RenameMethodRefOrMethodSpec(IMethod method, Dictionary<MethodDef, RefMethodMetas> refMethodMetasMap)
        {
            if (method is MemberRef memberRef)
            {
                RenameMethodRef(memberRef, refMethodMetasMap);
            }
            else if (method is MethodSpec methodSpec)
            {
                if (methodSpec.Method is MemberRef memberRef2)
                {
                    RenameMethodRef(memberRef2, refMethodMetasMap);
                }
            }
        }

        private void BuildRefMethodMetasMap(Dictionary<MethodDef, RefMethodMetas> refMethodMetasMap)
        {
            foreach (ModuleDef mod in _obfuscatedAndNotObfuscatedModules)
            {
                foreach (IMethod method in WalkAllMethodInstructionOperand<IMethod>(mod))
                {
                    RenameMethodRefOrMethodSpec(method, refMethodMetasMap);
                }

                foreach (var type in mod.GetTypes())
                {
                    foreach (MethodDef method in type.Methods)
                    {
                        if (method.HasOverrides)
                        {
                            foreach (MethodOverride methodOverride in method.Overrides)
                            {
                                RenameMethodRefOrMethodSpec(methodOverride.MethodDeclaration, refMethodMetasMap);
                                RenameMethodRefOrMethodSpec(methodOverride.MethodBody, refMethodMetasMap);
                            }
                        }
                    }
                }
                foreach (var e in _refTypeRefMetasMap)
                {
                    TypeDef typeDef = e.Key;
                    var hierarchyFields = new List<FieldDef>();
                    BuildHierarchyFields(typeDef, hierarchyFields);
                    RefTypeDefMetas typeDefMetas = e.Value;
                    foreach (CustomAttribute ca in typeDefMetas.customAttributes)
                    {
                        if (ca.Constructor is IMethod method)
                        {
                            RenameMethodRefOrMethodSpec(method, refMethodMetasMap);
                        }
                    }
                }
            }
        }

        private void RenameMethods()
        {
            //Debug.Log("Rename methods begin");
            //Debug.Log("Rename not virtual methods begin");
            var virtualMethods = new List<MethodDef>();
            var refMethodMetasMap = new Dictionary<MethodDef, RefMethodMetas>();
            BuildRefMethodMetasMap(refMethodMetasMap);
            foreach (ModuleDef mod in _toObfuscatedModules)
            {
                foreach (TypeDef type in mod.GetTypes())
                {
                    foreach (MethodDef method in type.Methods)
                    {
                        if (method.IsVirtual)
                        {
                            continue;
                        }
                        if (_renamePolicy.NeedRename(method))
                        {
                            Rename(method, refMethodMetasMap.GetValueOrDefault(method));
                        }
                    }
                }
            }

            foreach (ModuleDef mod in _obfuscatedAndNotObfuscatedModules)
            {
                foreach (TypeDef type in mod.GetTypes())
                {
                    _virtualMethodGroupCalculator.CalculateType(type);
                    foreach (MethodDef method in type.Methods)
                    {
                        if (method.IsVirtual)
                        {
                            virtualMethods.Add(method);
                        }
                    }
                }
            }

            //Debug.Log("Rename not virtual methods end");


            //Debug.Log("Rename virtual methods begin");
            var visitedVirtualMethods = new HashSet<MethodDef>();
            var groupNeedRenames = new Dictionary<VirtualMethodGroup, bool>();
            foreach (var method in virtualMethods)
            {
                if (!visitedVirtualMethods.Add(method))
                {
                    continue;
                }
                VirtualMethodGroup group = _virtualMethodGroupCalculator.GetMethodGroup(method);
                if (!groupNeedRenames.TryGetValue(group, out var needRename))
                {
                    var rootBeInheritedTypes = group.GetRootBeInheritedTypes();
                    // - if the group contains no obfuscated methods
                    // - if the group contains method defined in non-obfuscated module but referencing obfuscated module and virtual method in obfuscated type overrides virtual method from non-obfuscated type
                    if (!group.methods.Any(m => _toObfuscatedModuleSet.Contains(m.DeclaringType.Module)) || group.methods.Any(m => _nonObfuscatedButReferencingObfuscatedModuleSet.Contains(m.Module) && rootBeInheritedTypes.Contains(m.DeclaringType)))
                    {
                        needRename = false;
                    }
                    else
                    {
                        needRename = group.methods.All(m => _obfuscatedAndNotObfuscatedModules.Contains(m.Module) && _renamePolicy.NeedRename(m));
                    }
                    groupNeedRenames.Add(group, needRename);
                    if (needRename)
                    {
                        bool conflict = false;
                        string newVirtualMethodName = null;
                        foreach (MethodDef m in group.methods)
                        {
                            if (_renameRecordMap.TryGetExistRenameMapping(m, out var existVirtualMethodName))
                            {
                                if (newVirtualMethodName == null)
                                {
                                    newVirtualMethodName = existVirtualMethodName;
                                }
                                else if (newVirtualMethodName != existVirtualMethodName)
                                {
                                    Debug.LogWarning($"Virtual method rename conflict. {m} => {existVirtualMethodName} != {newVirtualMethodName}");
                                    conflict = true;
                                    break;
                                }
                            }
                        }
                        if (newVirtualMethodName == null || conflict /*|| _nameMaker.IsNamePreserved(group, newVirtualMethodName)*/)
                        {
                            newVirtualMethodName = _nameMaker.GetNewName(group, method.Name);
                        }
                        _renameRecordMap.InitAndAddRename(group, newVirtualMethodName);
                    }
                }
                if (!needRename)
                {
                    continue;
                }
                if (_renameRecordMap.TryGetRename(group, out var newName))
                {
                    Rename(method, refMethodMetasMap.GetValueOrDefault(method), newName);
                }
                else
                {
                    throw new Exception($"group:{group} method:{method} not found in rename record map");
                }
            }
            //Debug.Log("Rename virtual methods end");
            //Debug.Log("Rename methods end");
        }

        class RefPropertyMetas
        {
            public List<CustomAttribute> customAttributes = new List<CustomAttribute>();
        }

        private void BuildHierarchyProperties(TypeDef type, List<PropertyDef> properties)
        {
            while (type != null)
            {
                properties.AddRange(type.Properties);
                type = MetaUtil.GetBaseTypeDef(type);
            }
        }

        private void BuildRefPropertyMetasMap(Dictionary<PropertyDef, RefPropertyMetas> refPropertyMetasMap)
        {
            foreach (var e in _refTypeRefMetasMap)
            {
                TypeDef typeDef = e.Key;
                var hierarchyProperties = new List<PropertyDef>();
                BuildHierarchyProperties(typeDef, hierarchyProperties);
                RefTypeDefMetas typeDefMetas = e.Value;
                foreach (CustomAttribute ca in typeDefMetas.customAttributes)
                {
                    foreach (var arg in ca.NamedArguments)
                    {
                        if (arg.IsField)
                        {
                            continue;
                        }
                        foreach (PropertyDef field in hierarchyProperties)
                        {
                            // FIXME. field of Generic Base Type may not be same
                            if (field.Name == arg.Name && TypeEqualityComparer.Instance.Equals(arg.Type, field.PropertySig.RetType))
                            {
                                if (!refPropertyMetasMap.TryGetValue(field, out var fieldMetas))
                                {
                                    fieldMetas = new RefPropertyMetas();
                                    refPropertyMetasMap.Add(field, fieldMetas);
                                }
                                fieldMetas.customAttributes.Add(ca);
                                break;
                            }
                        }
                    }
                }
            }
        }

        private void RenameProperties()
        {
            //Debug.Log("Rename properties begin");
            var refPropertyMetasMap = new Dictionary<PropertyDef, RefPropertyMetas>();
            BuildRefPropertyMetasMap(refPropertyMetasMap);
            foreach (ModuleDef mod in _toObfuscatedModules)
            {
                foreach (TypeDef type in mod.GetTypes())
                {
                    foreach (PropertyDef property in type.Properties)
                    {
                        if (_renamePolicy.NeedRename(property))
                        {
                            Rename(property, refPropertyMetasMap.GetValueOrDefault(property));
                        }
                    }
                }
            }
            //Debug.Log("Rename properties end");
        }

        private void RenameEvents()
        {
            //Debug.Log("Rename events begin");
            foreach (ModuleDef mod in _toObfuscatedModules)
            {
                foreach (TypeDef type in mod.GetTypes())
                {
                    foreach (EventDef eventDef in type.Events)
                    {
                        if (_renamePolicy.NeedRename(eventDef))
                        {
                            Rename(eventDef);
                        }
                    }
                }
            }
            //Debug.Log("Rename events begin");
        }

        private void Rename(TypeDef type, RefTypeDefMetas refTypeDefMeta)
        {
            string moduleName = MetaUtil.GetModuleNameWithoutExt(type.Module.Name);
            string oldFullName = type.FullName;
            string oldNamespace = type.Namespace;

            string oldName = type.Name;

            string newNamespace;
            string newName;
            if (_renameRecordMap.TryGetExistRenameMapping(type, out var nns, out var nn))
            {
                newNamespace = nns;
                newName = nn;
            }
            else
            {
                newNamespace = _nameMaker.GetNewNamespace(type, oldNamespace, _useConsistentNamespaceObfuscation);
                newName = _nameMaker.GetNewName(type, oldName);
            }

            if (refTypeDefMeta != null)
            {
                foreach (TypeRef typeRef in refTypeDefMeta.typeRefs)
                {
                    Assert.AreEqual(typeRef.FullName, oldFullName);
                    Assert.IsTrue(typeRef.DefinitionAssembly.Name == moduleName);
                    if (!string.IsNullOrEmpty(oldNamespace))
                    {
                        typeRef.Namespace = newNamespace;
                    }
                    typeRef.Name = newName;
                    //Debug.Log($"rename assembly:{typeRef.Module.Name} reference {oldFullName} => {typeRef.FullName}");
                }
            }
            type.Name = newName;
            type.Namespace = newNamespace;
            string newFullName = type.FullName;
            _renameRecordMap.AddRename(type, newFullName);
            //Debug.Log($"rename typedef. assembly:{type.Module.Name} oldName:{oldFullName} => newName:{newFullName}");
        }

        private void Rename(FieldDef field, RefFieldMetas fieldMetas)
        {
            string oldName = field.Name;
            string newName = _renameRecordMap.TryGetExistRenameMapping(field, out var nn) ? nn : _nameMaker.GetNewName(field, oldName);
            if (fieldMetas != null)
            {
                foreach (var memberRef in fieldMetas.fieldRefs)
                {
                    memberRef.Name = newName;
                    //Debug.Log($"rename assembly:{memberRef.Module.Name} reference {field.FullName} => {memberRef.FullName}");
                }
                foreach (var ca in fieldMetas.customAttributes)
                {
                    foreach (var arg in ca.NamedArguments)
                    {
                        if (arg.Name == oldName)
                        {
                            arg.Name = newName;
                        }
                    }
                }
            }
            //Debug.Log($"rename field. {field} => {newName}");
            _renameRecordMap.AddRename(field, newName);
            field.Name = newName;

        }

        private void Rename(MethodDef method, RefMethodMetas refMethodMetas)
        {
            string oldName = method.Name;
            string newName = _renameRecordMap.TryGetExistRenameMapping(method, out var nn) ? nn : _nameMaker.GetNewName(method, oldName);
            Rename(method, refMethodMetas, newName);
        }

        private void Rename(MethodDef method, RefMethodMetas refMethodMetas, string newName)
        {
            ModuleDefMD mod = (ModuleDefMD)method.DeclaringType.Module;
            RenameMethodParams(method);
            RenameMethodBody(method);
            if (refMethodMetas != null)
            {
                foreach (MemberRef memberRef in refMethodMetas.memberRefs)
                {
                    string oldMethodFullName = memberRef.ToString();
                    memberRef.Name = newName;
                    //Debug.Log($"rename assembly:{memberRef.Module.Name} method:{oldMethodFullName} => {memberRef}");
                }
            }
            _renameRecordMap.AddRename(method, newName);
            method.Name = newName;
        }

        private void RenameMethodBody(MethodDef method)
        {
            if (method.Body == null)
            {
                return;
            }
        }

        private void RenameMethodParams(MethodDef method)
        {
            foreach (Parameter param in method.Parameters)
            {
                if (param.ParamDef != null)
                {
                    Rename(param.ParamDef);
                }
            }
        }

        private void Rename(ParamDef param)
        {
            string newName = _nameMaker.GetNewName(param, param.Name);
            param.Name = newName;
        }

        private void Rename(EventDef eventDef)
        {
            string oldName = eventDef.Name;
            string newName = _renameRecordMap.TryGetExistRenameMapping(eventDef, out var nn) ? nn : _nameMaker.GetNewName(eventDef, eventDef.Name);
            _renameRecordMap.AddRename(eventDef, newName);
            eventDef.Name = newName;
        }

        private void Rename(PropertyDef property, RefPropertyMetas refPropertyMetas)
        {
            string oldName = property.Name;
            string newName = _renameRecordMap.TryGetExistRenameMapping(property, out var nn) ? nn : _nameMaker.GetNewName(property, oldName);

            if (refPropertyMetas != null)
            {
                foreach (var ca in refPropertyMetas.customAttributes)
                {
                    foreach (var arg in ca.NamedArguments)
                    {
                        if (arg.Name == oldName)
                        {
                            arg.Name = newName;
                        }
                    }
                }
            }
            _renameRecordMap.AddRename(property, newName);
            property.Name = newName;
        }

        public void Save()
        {
            Directory.CreateDirectory(Path.GetDirectoryName(_mappingXmlPath));
            _renameRecordMap.WriteXmlMappingFile();
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/SymbolRename.cs.meta`:

```meta
fileFormatVersion: 2
guid: ec29be12f08e90741a59970f029c2eec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfusPasses/SymbolObfus/VirtualMethodGroupCalculator.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz.ObfusPasses.SymbolObfus
{

    public class VirtualMethodGroup
    {
        public List<MethodDef> methods;

        private HashSet<TypeDef> _nameScopes;

        private HashSet<TypeDef> _rootNameScope;

        public HashSet<TypeDef> GetNameConflictTypeScopes()
        {
            if (_nameScopes != null)
            {
                return _nameScopes;
            }

            _nameScopes = new HashSet<TypeDef>();
            foreach (var method in methods)
            {
                TypeDef cur = method.DeclaringType;
                while (cur != null)
                {
                    _nameScopes.Add(cur);
                    cur = MetaUtil.GetBaseTypeDef(cur);
                }
            }
            return _nameScopes;
        }

        public HashSet<TypeDef> GetRootBeInheritedTypes()
        {
            if (_rootNameScope != null)
            {
                return _rootNameScope;
            }
            _rootNameScope = new HashSet<TypeDef>();
            var nameScopes = GetNameConflictTypeScopes();
            foreach (var type in nameScopes)
            {
                TypeDef parentType = MetaUtil.GetBaseTypeDef(type);
                if (parentType == null || !nameScopes.Contains(parentType))
                {
                    _rootNameScope.Add(type);
                }
            }
            return _rootNameScope;
        }

        public IEnumerable<TypeDef> GetNameDeclaringTypeScopes()
        {
            foreach (var method in methods)
            {
                yield return method.DeclaringType;
            }
        }
    }

    public class VirtualMethodGroupCalculator
    {

        private class TypeFlatMethods
        {
            public HashSet<MethodDef> flatMethods = new HashSet<MethodDef>();


            private bool IsFinalTypeSig(TypeSig type)
            {
                switch (type.ElementType)
                {
                    case ElementType.Void:
                    case ElementType.Boolean:
                    case ElementType.Char:
                    case ElementType.I1:
                    case ElementType.I2:
                    case ElementType.I4:
                    case ElementType.I8:
                    case ElementType.U1:
                    case ElementType.U2:
                    case ElementType.U4:
                    case ElementType.U8:
                    case ElementType.R4:
                    case ElementType.R8:
                    case ElementType.String:
                    case ElementType.Object:
                    case ElementType.Class:
                    case ElementType.ValueType:
                    return true;
                    default: return false;
                }
            }

            private bool IsVarType(TypeSig t)
            {
                return t.ElementType == ElementType.MVar || t.ElementType == ElementType.Var;
            }

            private bool IsClassOrValueType(TypeSig t)
            {
                return t.ElementType == ElementType.Class || t.ElementType == ElementType.ValueType;
            }

            private bool IsLooseTypeSigMatch(TypeSig t1, TypeSig t2)
            {
                t1 = t1.RemovePinnedAndModifiers();
                t2 = t2.RemovePinnedAndModifiers();

                if (t1.ElementType != t2.ElementType)
                {
                    return IsVarType(t1) || IsVarType(t2);
                }

                switch (t1.ElementType)
                {
                    case ElementType.Void:
                    case ElementType.Boolean:
                    case ElementType.Char:
                    case ElementType.I1:
                    case ElementType.I2:
                    case ElementType.I4:
                    case ElementType.I8:
                    case ElementType.U1:
                    case ElementType.U2:
                    case ElementType.U4:
                    case ElementType.U8:
                    case ElementType.R4:
                    case ElementType.R8:
                    case ElementType.I:
                    case ElementType.U:
                    case ElementType.R:
                    case ElementType.String:
                    case ElementType.Object:
                    case ElementType.TypedByRef:
                    return true;
                    case ElementType.Class:
                    case ElementType.ValueType:
                    {
                        return t1.AssemblyQualifiedName == t2.AssemblyQualifiedName;
                    }
                    case ElementType.Ptr:
                    case ElementType.ByRef:
                    case ElementType.SZArray:
                    {
                        break;
                    }
                    case ElementType.Array:
                    {
                        var a1 = (ArraySig)t1;
                        var a2 = (ArraySig)t2;
                        if (a1.Rank != a2.Rank)
                        {
                            return false;
                        }
                        break;
                    }
                    case ElementType.Var:
                    case ElementType.MVar:
                    {
                        //var v1 = (GenericSig)t1;
                        //var v2 = (GenericSig)t2;
                        //return v1.Number == v2.Number;
                        return true;
                    }
                    default: return true;
                }
                if (t1.Next != null && t2.Next != null)
                {
                    return IsLooseTypeSigMatch(t1.Next, t2.Next);
                }
                return true;
            }

            private bool IsLooseMatch(MethodDef method1, MethodDef method2)
            {
                if (method1.Name != method2.Name)
                {
                    return false;
                }
                if (method1.GetParamCount() != method2.GetParamCount())
                {
                    return false;
                }
                if (!IsLooseTypeSigMatch(method1.ReturnType, method2.ReturnType))
                {
                    return false;
                }
                for (int i = 0, n = method1.GetParamCount(); i < n; i++)
                {
                    if (!IsLooseTypeSigMatch(method1.GetParam(i), method2.GetParam(i)))
                    {
                        return false;
                    }
                }

                return true;
            }

            public bool TryFindMatchVirtualMethod(MethodDef method, out MethodDef matchMethodDef)
            {
                foreach (var parentOrInterfaceMethod in flatMethods)
                {
                    if (IsLooseMatch(method, parentOrInterfaceMethod))
                    {
                        matchMethodDef = parentOrInterfaceMethod;
                        return true;
                    }
                }
                matchMethodDef = null;
                return false;
            }
        }


        private readonly Dictionary<MethodDef, VirtualMethodGroup> _methodGroups = new Dictionary<MethodDef, VirtualMethodGroup>();
        private readonly Dictionary<TypeDef, TypeFlatMethods> _visitedTypes = new Dictionary<TypeDef, TypeFlatMethods>();



        public VirtualMethodGroup GetMethodGroup(MethodDef methodDef)
        {
            if (_methodGroups.TryGetValue(methodDef, out var group))
            {
                return group;
            }
            return null;
        }

        public void CalculateType(TypeDef typeDef)
        {
            if (_visitedTypes.ContainsKey(typeDef))
            {
                return;
            }

            var typeMethods = new TypeFlatMethods();

            var interfaceMethods = new List<MethodDef>();
            if (typeDef.BaseType != null)
            {
                TypeDef baseTypeDef = MetaUtil.GetTypeDefOrGenericTypeBaseThrowException(typeDef.BaseType);
                CalculateType(baseTypeDef);
                typeMethods.flatMethods.AddRange(_visitedTypes[baseTypeDef].flatMethods);
                foreach (var intfType in typeDef.Interfaces)
                {
                    TypeDef intfTypeDef = MetaUtil.GetTypeDefOrGenericTypeBaseThrowException(intfType.Interface);
                    CalculateType(intfTypeDef);
                    //typeMethods.flatMethods.AddRange(_visitedTypes[intfTypeDef].flatMethods);
                    interfaceMethods.AddRange(_visitedTypes[intfTypeDef].flatMethods);
                }
            }
            foreach (MethodDef method in interfaceMethods)
            {
                if (typeMethods.TryFindMatchVirtualMethod(method, out var matchMethodDef))
                {
                    // merge group
                    var group = _methodGroups[matchMethodDef];
                    var matchGroup = _methodGroups[method];
                    if (group != matchGroup)
                    {
                        foreach (var m in matchGroup.methods)
                        {
                            group.methods.Add(m);
                            _methodGroups[m] = group;
                        }
                    }
                }
                typeMethods.flatMethods.Add(method);
            }

            foreach (MethodDef method in typeDef.Methods)
            {
                if (!method.IsVirtual)
                {
                    continue;
                }
                if (typeMethods.TryFindMatchVirtualMethod(method, out var matchMethodDef))
                {
                    var group = _methodGroups[matchMethodDef];
                    group.methods.Add(method);
                    _methodGroups.Add(method, group);
                }
                else
                {
                    _methodGroups.Add(method, new VirtualMethodGroup() { methods = new List<MethodDef> { method } });
                }
                if (method.IsNewSlot)
                {
                    typeMethods.flatMethods.Add(method);
                }
            }
            _visitedTypes.Add(typeDef, typeMethods);
        }
    }
}

```

`Editor/ObfusPasses/SymbolObfus/VirtualMethodGroupCalculator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 649aeb6306500a04f8b7a3e01f5aaf0d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfuscationMethodWhitelist.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Editor;
using Obfuz.Utils;
using System.Linq;
using UnityEngine;

namespace Obfuz
{
    public class ObfuscationMethodWhitelist
    {
        private readonly ObfuzIgnoreScopeComputeCache _obfuzComputeCache;
        private readonly BurstCompileComputeCache _burstCompileComputeCache;

        public ObfuscationMethodWhitelist(ObfuzIgnoreScopeComputeCache obfuzComputeCache, BurstCompileComputeCache burstCompileComputeCache)
        {
            _obfuzComputeCache = obfuzComputeCache;
            _burstCompileComputeCache = burstCompileComputeCache;
        }

        public bool IsInWhiteList(ModuleDef module)
        {
            string modName = module.Assembly.Name;
            if (modName == ConstValues.ObfuzRuntimeAssemblyName)
            {
                return true;
            }
            //if (MetaUtil.HasObfuzIgnoreScope(module))
            //{
            //    return true;
            //}
            return false;
        }

        private bool DoesMethodContainsRuntimeInitializeOnLoadMethodAttributeAndLoadTypeGreaterEqualAfterAssembliesLoaded(MethodDef method)
        {
            CustomAttribute ca = method.CustomAttributes.Find(ConstValues.RuntimeInitializedOnLoadMethodAttributeFullName);
            if (ca != null && ca.ConstructorArguments.Count > 0)
            {
                RuntimeInitializeLoadType loadType = (RuntimeInitializeLoadType)ca.ConstructorArguments[0].Value;
                if (loadType >= RuntimeInitializeLoadType.AfterAssembliesLoaded)
                {
                    return true;
                }
            }
            return false;
        }

        public bool IsInWhiteList(MethodDef method)
        {
            TypeDef typeDef = method.DeclaringType;
            //if (IsInWhiteList(typeDef))
            //{
            //    return true;
            //}
            if (method.Name.StartsWith(ConstValues.ObfuzInternalSymbolNamePrefix))
            {
                return true;
            }
            if (_obfuzComputeCache.HasSelfOrDeclaringOrEnclosingOrInheritObfuzIgnoreScope(method, typeDef, ObfuzScope.MethodBody))
            {
                return true;
            }
            CustomAttribute ca = method.CustomAttributes.Find(ConstValues.RuntimeInitializedOnLoadMethodAttributeFullName);
            if (DoesMethodContainsRuntimeInitializeOnLoadMethodAttributeAndLoadTypeGreaterEqualAfterAssembliesLoaded(method))
            {
                return true;
            }
            if (method.CustomAttributes.Find(ConstValues.BurstCompileFullName) != null || _burstCompileComputeCache.IsBurstCompileMethodOrReferencedByBurstCompileMethod(method))
            {
                return true;
            }

            // don't obfuscate cctor when it has RuntimeInitializeOnLoadMethodAttribute with load type AfterAssembliesLoaded
            if (method.IsStatic && method.Name == ".cctor" && typeDef.Methods.Any(m => DoesMethodContainsRuntimeInitializeOnLoadMethodAttributeAndLoadTypeGreaterEqualAfterAssembliesLoaded(m)))
            {
                return true;
            }
            return false;
        }

        public bool IsInWhiteList(TypeDef type)
        {
            if (type.Name.StartsWith(ConstValues.ObfuzInternalSymbolNamePrefix))
            {
                return true;
            }
            if (IsInWhiteList(type.Module))
            {
                return true;
            }
            if (type.CustomAttributes.Find(ConstValues.BurstCompileFullName) != null)
            {
                return true;
            }
            if (_obfuzComputeCache.HasSelfOrDeclaringOrEnclosingOrInheritObfuzIgnoreScope(type, type.DeclaringType, ObfuzScope.TypeName))
            {
                return true;
            }
            //if (type.DeclaringType != null && IsInWhiteList(type.DeclaringType))
            //{
            //    return true;
            //}
            if (type.FullName == ConstValues.GeneratedEncryptionVirtualMachineFullName)
            {
                return true;
            }
            return false;
        }
    }
}

```

`Editor/ObfuscationMethodWhitelist.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8824d47fdc31cef41a899294491c8844
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfuscationPassContext.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Data;
using Obfuz.Emit;
using Obfuz.Utils;
using System.Collections.Generic;

namespace Obfuz
{
    public delegate IRandom RandomCreator(int seed);

    public class EncryptionScopeInfo
    {
        public readonly IEncryptor encryptor;
        public readonly RandomCreator localRandomCreator;

        public EncryptionScopeInfo(IEncryptor encryptor, RandomCreator localRandomCreator)
        {
            this.encryptor = encryptor;
            this.localRandomCreator = localRandomCreator;
        }
    }

    public class EncryptionScopeProvider
    {
        private readonly EncryptionScopeInfo _defaultStaticScope;
        private readonly EncryptionScopeInfo _defaultDynamicScope;
        private readonly HashSet<string> _dynamicSecretAssemblyNames;

        public EncryptionScopeProvider(EncryptionScopeInfo defaultStaticScope, EncryptionScopeInfo defaultDynamicScope, HashSet<string> dynamicSecretAssemblyNames)
        {
            _defaultStaticScope = defaultStaticScope;
            _defaultDynamicScope = defaultDynamicScope;
            _dynamicSecretAssemblyNames = dynamicSecretAssemblyNames;
        }

        public EncryptionScopeInfo GetScope(ModuleDef module)
        {
            if (_dynamicSecretAssemblyNames.Contains(module.Assembly.Name))
            {
                return _defaultDynamicScope;
            }
            else
            {
                return _defaultStaticScope;
            }
        }

        public bool IsDynamicSecretAssembly(ModuleDef module)
        {
            return _dynamicSecretAssemblyNames.Contains(module.Assembly.Name);
        }
    }

    public class ObfuscationPassContext
    {
        public static ObfuscationPassContext Current { get; set; }

        public CoreSettingsFacade coreSettings;

        public GroupByModuleEntityManager moduleEntityManager;

        public AssemblyCache assemblyCache;
        public List<ModuleDef> modulesToObfuscate;
        public List<ModuleDef> allObfuscationRelativeModules;
        public ObfuzIgnoreScopeComputeCache obfuzIgnoreScopeComputeCache;

        public ObfuscationMethodWhitelist whiteList;
        public ConfigurablePassPolicy passPolicy;
    }
}

```

`Editor/ObfuscationPassContext.cs.meta`:

```meta
fileFormatVersion: 2
guid: 196d07f0366ce4b46bf0333fa4918d40
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Obfuscator.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Data;
using Obfuz.Emit;
using Obfuz.EncryptionVM;
using Obfuz.ObfusPasses.CleanUp;
using Obfuz.ObfusPasses.Instinct;
using Obfuz.ObfusPasses.SymbolObfus;
using Obfuz.Unity;
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;

namespace Obfuz
{

    public class Obfuscator
    {
        private readonly CoreSettingsFacade _coreSettings;
        private readonly List<string> _allObfuscationRelativeAssemblyNames;
        private readonly HashSet<string> _assembliesUsingDynamicSecretKeys;
        private readonly CombinedAssemblyResolver _assemblyResolver;

        private readonly ConfigurablePassPolicy _passPolicy;

        private readonly Pipeline _pipeline1 = new Pipeline();
        private readonly Pipeline _pipeline2 = new Pipeline();

        private ObfuscationPassContext _ctx;

        public Obfuscator(ObfuscatorBuilder builder)
        {
            CheckSettings(builder.CoreSettingsFacade);
            _coreSettings = builder.CoreSettingsFacade;

            _allObfuscationRelativeAssemblyNames = _coreSettings.assembliesToObfuscate
                .Concat(_coreSettings.nonObfuscatedButReferencingObfuscatedAssemblies)
                .ToList();
            _assembliesUsingDynamicSecretKeys = new HashSet<string>(_coreSettings.assembliesUsingDynamicSecretKeys);

            _assemblyResolver = new CombinedAssemblyResolver(new PathAssemblyResolver(_coreSettings.assemblySearchPaths.ToArray()), new UnityProjectManagedAssemblyResolver(_coreSettings.buildTarget));
            _passPolicy = new ConfigurablePassPolicy(_coreSettings.assembliesToObfuscate, _coreSettings.enabledObfuscationPasses, _coreSettings.obfuscationPassRuleConfigFiles);

            _pipeline1.AddPass(new InstinctPass());
            foreach (var pass in _coreSettings.obfuscationPasses)
            {
                if (pass is SymbolObfusPass symbolObfusPass)
                {
                    _pipeline2.AddPass(pass);
                }
                else
                {
                    _pipeline1.AddPass(pass);
                }
            }
            _pipeline1.AddPass(new CleanUpInstructionPass());
            _pipeline2.AddPass(new RemoveObfuzAttributesPass());
        }

        private void CheckSettings(CoreSettingsFacade settings)
        {
            var totalAssemblies = new HashSet<string>();
            foreach (var assName in settings.assembliesToObfuscate)
            {
                if (string.IsNullOrWhiteSpace(assName))
                {
                    throw new Exception($"the name of some assembly in assembliesToObfuscate is empty! Please check your settings.");
                }
                if (!totalAssemblies.Add(assName))
                {
                    throw new Exception($"the name of assembly `{assName}` in assembliesToObfuscate is duplicated! Please check your settings.");
                }
            }
            foreach (var assName in settings.nonObfuscatedButReferencingObfuscatedAssemblies)
            {
                if (string.IsNullOrWhiteSpace(assName))
                {
                    throw new Exception($"the name of some assembly in nonObfuscatedButReferencingObfuscatedAssemblies is empty! Please check your settings.");
                }
                if (!totalAssemblies.Add(assName))
                {
                    throw new Exception($"the name of assembly `{assName}` in nonObfuscatedButReferencingObfuscatedAssemblies is duplicated! Please check your settings.");
                }
            }
        }

        public void Run()
        {
            Debug.Log($"Obfuscator begin");
            var sw = new System.Diagnostics.Stopwatch();
            sw.Start();
            FileUtil.RecreateDir(_coreSettings.obfuscatedAssemblyOutputPath);
            FileUtil.RecreateDir(_coreSettings.obfuscatedAssemblyTempOutputPath);
            RunPipeline(_pipeline1);
            _assemblyResolver.InsertFirst(new PathAssemblyResolver(_coreSettings.obfuscatedAssemblyTempOutputPath));
            RunPipeline(_pipeline2);
            FileUtil.CopyDir(_coreSettings.obfuscatedAssemblyTempOutputPath, _coreSettings.obfuscatedAssemblyOutputPath, true);
            sw.Stop();
            Debug.Log($"Obfuscator end. cost time: {sw.ElapsedMilliseconds} ms");
        }

        private void RunPipeline(Pipeline pipeline)
        {
            if (pipeline.Empty)
            {
                return;
            }
            OnPreObfuscation(pipeline);
            DoObfuscation(pipeline);
            OnPostObfuscation(pipeline);
        }

        private IEncryptor CreateEncryptionVirtualMachine(byte[] secretKey)
        {
            var vmCreator = new VirtualMachineCreator(_coreSettings.encryptionVmGenerationSecretKey);
            var vm = vmCreator.CreateVirtualMachine(_coreSettings.encryptionVmOpCodeCount);
            var vmGenerator = new VirtualMachineCodeGenerator(vm);

            string encryptionVmCodeFile = _coreSettings.encryptionVmCodeFile;
            if (!File.Exists(encryptionVmCodeFile))
            {
                throw new Exception($"EncryptionVm CodeFile:`{encryptionVmCodeFile}` not exists! Please run `Obfuz/GenerateVm` to generate it!");
            }
            if (!vmGenerator.ValidateMatch(encryptionVmCodeFile))
            {
                throw new Exception($"EncryptionVm CodeFile:`{encryptionVmCodeFile}` not match with encryptionVM settings! Please run `Obfuz/GenerateVm` to update it!");
            }
            var vms = new VirtualMachineSimulator(vm, secretKey);

            var generatedVmTypes = ReflectionUtil.FindTypesInCurrentAppDomain("Obfuz.EncryptionVM.GeneratedEncryptionVirtualMachine");
            if (generatedVmTypes.Count == 0)
            {
                throw new Exception($"class Obfuz.EncryptionVM.GeneratedEncryptionVirtualMachine not found in any assembly! Please run `Obfuz/GenerateVm` to generate it!");
            }
            if (generatedVmTypes.Count > 1)
            {
                throw new Exception($"class Obfuz.EncryptionVM.GeneratedEncryptionVirtualMachine found in multiple assemblies! Please retain only one!");
            }

            var gvmInstance = (IEncryptor)Activator.CreateInstance(generatedVmTypes[0], new object[] { secretKey });

            VerifyVm(vm, vms, gvmInstance);

            return vms;
        }

        private void VerifyVm(VirtualMachine vm, VirtualMachineSimulator vms, IEncryptor gvm)
        {
            int testInt = 11223344;
            long testLong = 1122334455667788L;
            float testFloat = 1234f;
            double testDouble = 1122334455.0;
            string testString = "hello,world";
            for (int i = 0; i < vm.opCodes.Length; i++)
            {
                int ops = i * vm.opCodes.Length + i;
                //int salt = i;
                //int ops = -1135538782;
                int salt = -879409147;
                {
                    int encryptedIntOfVms = vms.Encrypt(testInt, ops, salt);
                    int decryptedIntOfVms = vms.Decrypt(encryptedIntOfVms, ops, salt);
                    if (decryptedIntOfVms != testInt)
                    {
                        throw new Exception($"VirtualMachineSimulator decrypt failed! opCode:{i}, originalValue:{testInt} decryptedValue:{decryptedIntOfVms}");
                    }
                    int encryptedValueOfGvm = gvm.Encrypt(testInt, ops, salt);
                    int decryptedValueOfGvm = gvm.Decrypt(encryptedValueOfGvm, ops, salt);
                    if (encryptedValueOfGvm != encryptedIntOfVms)
                    {
                        throw new Exception($"encryptedValue not match! opCode:{i}, originalValue:{testInt} encryptedValue VirtualMachineSimulator:{encryptedIntOfVms} GeneratedEncryptionVirtualMachine:{encryptedValueOfGvm}");
                    }
                    if (decryptedValueOfGvm != testInt)
                    {
                        throw new Exception($"GeneratedEncryptionVirtualMachine decrypt failed! opCode:{i}, originalValue:{testInt} decryptedValue:{decryptedValueOfGvm}");
                    }
                }
                {
                    long encryptedLongOfVms = vms.Encrypt(testLong, ops, salt);
                    long decryptedLongOfVms = vms.Decrypt(encryptedLongOfVms, ops, salt);
                    if (decryptedLongOfVms != testLong)
                    {
                        throw new Exception($"VirtualMachineSimulator decrypt long failed! opCode:{i}, originalValue:{testLong} decryptedValue:{decryptedLongOfVms}");
                    }
                    long encryptedValueOfGvm = gvm.Encrypt(testLong, ops, salt);
                    long decryptedValueOfGvm = gvm.Decrypt(encryptedValueOfGvm, ops, salt);
                    if (encryptedValueOfGvm != encryptedLongOfVms)
                    {
                        throw new Exception($"encryptedValue not match! opCode:{i}, originalValue:{testLong} encryptedValue VirtualMachineSimulator:{encryptedLongOfVms} GeneratedEncryptionVirtualMachine:{encryptedValueOfGvm}");
                    }
                    if (decryptedValueOfGvm != testLong)
                    {
                        throw new Exception($"GeneratedEncryptionVirtualMachine decrypt long failed! opCode:{i}, originalValue:{testLong} decryptedValue:{decryptedValueOfGvm}");
                    }
                }
                {
                    float encryptedFloatOfVms = vms.Encrypt(testFloat, ops, salt);
                    float decryptedFloatOfVms = vms.Decrypt(encryptedFloatOfVms, ops, salt);
                    if (decryptedFloatOfVms != testFloat)
                    {
                        throw new Exception("encryptedFloat not match");
                    }
                    float encryptedValueOfGvm = gvm.Encrypt(testFloat, ops, salt);
                    float decryptedValueOfGvm = gvm.Decrypt(encryptedFloatOfVms, ops, salt);
                    if (encryptedFloatOfVms != encryptedValueOfGvm)
                    {
                        throw new Exception($"encryptedValue not match! opCode:{i}, originalValue:{testFloat} encryptedValue");
                    }
                    if (decryptedValueOfGvm != testFloat)
                    {
                        throw new Exception($"GeneratedEncryptionVirtualMachine decrypt float failed! opCode:{i}, originalValue:{testFloat}");
                    }
                }
                {
                    double encryptedFloatOfVms = vms.Encrypt(testDouble, ops, salt);
                    double decryptedFloatOfVms = vms.Decrypt(encryptedFloatOfVms, ops, salt);
                    if (decryptedFloatOfVms != testDouble)
                    {
                        throw new Exception("encryptedFloat not match");
                    }
                    double encryptedValueOfGvm = gvm.Encrypt(testDouble, ops, salt);
                    double decryptedValueOfGvm = gvm.Decrypt(encryptedFloatOfVms, ops, salt);
                    if (encryptedFloatOfVms != encryptedValueOfGvm)
                    {
                        throw new Exception($"encryptedValue not match! opCode:{i}, originalValue:{testDouble} encryptedValue");
                    }
                    if (decryptedValueOfGvm != testDouble)
                    {
                        throw new Exception($"GeneratedEncryptionVirtualMachine decrypt float failed! opCode:{i}, originalValue:{testDouble}");
                    }
                }

                {
                    byte[] encryptedStrOfVms = vms.Encrypt(testString, ops, salt);
                    string decryptedStrOfVms = vms.DecryptString(encryptedStrOfVms, 0, encryptedStrOfVms.Length, ops, salt);
                    if (decryptedStrOfVms != testString)
                    {
                        throw new Exception($"VirtualMachineSimulator decrypt string failed! opCode:{i}, originalValue:{testString} decryptedValue:{decryptedStrOfVms}");
                    }
                    byte[] encryptedStrOfGvm = gvm.Encrypt(testString, ops, salt);
                    string decryptedStrOfGvm = gvm.DecryptString(encryptedStrOfGvm, 0, encryptedStrOfGvm.Length, ops, salt);
                    if (!encryptedStrOfGvm.SequenceEqual(encryptedStrOfVms))
                    {
                        throw new Exception($"encryptedValue not match! opCode:{i}, originalValue:{testString} encryptedValue VirtualMachineSimulator:{encryptedStrOfVms} GeneratedEncryptionVirtualMachine:{encryptedStrOfGvm}");
                    }
                    if (decryptedStrOfGvm != testString)
                    {
                        throw new Exception($"GeneratedEncryptionVirtualMachine decrypt string failed! opCode:{i}, originalValue:{testString} decryptedValue:{decryptedStrOfGvm}");
                    }
                }
            }
        }

        private EncryptionScopeInfo CreateEncryptionScope(byte[] byteSecret)
        {
            int[] intSecretKey = KeyGenerator.ConvertToIntKey(byteSecret);
            IEncryptor encryption = CreateEncryptionVirtualMachine(byteSecret);
            RandomCreator localRandomCreator = (seed) => new RandomWithKey(intSecretKey, _coreSettings.randomSeed ^ seed);
            return new EncryptionScopeInfo(encryption, localRandomCreator);
        }

        private EncryptionScopeProvider CreateEncryptionScopeProvider()
        {
            var defaultStaticScope = CreateEncryptionScope(_coreSettings.defaultStaticSecretKey);
            var defaultDynamicScope = CreateEncryptionScope(_coreSettings.defaultDynamicSecretKey);
            foreach (string dynamicAssName in _assembliesUsingDynamicSecretKeys)
            {
                if (!_coreSettings.assembliesToObfuscate.Contains(dynamicAssName))
                {
                    throw new Exception($"Dynamic secret assembly `{dynamicAssName}` should be in the assembliesToObfuscate list!");
                }
            }
            return new EncryptionScopeProvider(defaultStaticScope, defaultDynamicScope, _assembliesUsingDynamicSecretKeys);
        }

        private void OnPreObfuscation(Pipeline pipeline)
        {
            AssemblyCache assemblyCache = new AssemblyCache(_assemblyResolver);
            List<ModuleDef> modulesToObfuscate = new List<ModuleDef>();
            List<ModuleDef> allObfuscationRelativeModules = new List<ModuleDef>();
            LoadAssemblies(assemblyCache, modulesToObfuscate, allObfuscationRelativeModules);

            EncryptionScopeProvider encryptionScopeProvider = CreateEncryptionScopeProvider();
            var moduleEntityManager = new GroupByModuleEntityManager()
            {
                EncryptionScopeProvider = encryptionScopeProvider,
            };
            var obfuzIgnoreScopeComputeCache = new ObfuzIgnoreScopeComputeCache();
            _ctx = new ObfuscationPassContext
            {
                coreSettings = _coreSettings,
                assemblyCache = assemblyCache,
                modulesToObfuscate = modulesToObfuscate,
                allObfuscationRelativeModules = allObfuscationRelativeModules,

                moduleEntityManager = moduleEntityManager,

                obfuzIgnoreScopeComputeCache = obfuzIgnoreScopeComputeCache,

                whiteList = new ObfuscationMethodWhitelist(obfuzIgnoreScopeComputeCache, new BurstCompileComputeCache(modulesToObfuscate, allObfuscationRelativeModules)),
                passPolicy = _passPolicy,
            };
            ObfuscationPassContext.Current = _ctx;
            pipeline.Start();
        }

        private void LoadAssemblies(AssemblyCache assemblyCache, List<ModuleDef> modulesToObfuscate, List<ModuleDef> allObfuscationRelativeModules)
        {
            foreach (string assName in _allObfuscationRelativeAssemblyNames)
            {
                ModuleDefMD mod = assemblyCache.TryLoadModule(assName);
                if (mod == null)
                {
                    Debug.Log($"assembly: {assName} not found! ignore.");
                    continue;
                }
                if (_coreSettings.assembliesToObfuscate.Contains(assName))
                {
                    modulesToObfuscate.Add(mod);
                }
                allObfuscationRelativeModules.Add(mod);
            }
        }

        private void WriteAssemblies()
        {
            foreach (ModuleDef mod in _ctx.allObfuscationRelativeModules)
            {
                string assNameWithExt = mod.Name;
                string outputFile = $"{_coreSettings.obfuscatedAssemblyTempOutputPath}/{assNameWithExt}";
                mod.Write(outputFile);
                Debug.Log($"save module. name:{mod.Assembly.Name} output:{outputFile}");
            }
        }

        private void DoObfuscation(Pipeline pipeline)
        {
            pipeline.Run();
        }

        private void OnPostObfuscation(Pipeline pipeline)
        {
            pipeline.Stop();

            _ctx.moduleEntityManager.Done<ConstFieldAllocator>();
            _ctx.moduleEntityManager.Done<RvaDataAllocator>();
            WriteAssemblies();
        }
    }
}

```

`Editor/Obfuscator.cs.meta`:

```meta
fileFormatVersion: 2
guid: ca9c4e108bde2184885e599f2bd19a00
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/ObfuscatorBuilder.cs`:

```cs
using Obfuz.EncryptionVM;
using Obfuz.ObfusPasses;
using Obfuz.ObfusPasses.CallObfus;
using Obfuz.ObfusPasses.ConstEncrypt;
using Obfuz.ObfusPasses.ControlFlowObfus;
using Obfuz.ObfusPasses.EvalStackObfus;
using Obfuz.ObfusPasses.ExprObfus;
using Obfuz.ObfusPasses.FieldEncrypt;
using Obfuz.ObfusPasses.SymbolObfus;
using Obfuz.Settings;
using Obfuz.Utils;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;

namespace Obfuz
{

    public class CoreSettingsFacade
    {
        public BuildTarget buildTarget;

        public byte[] defaultStaticSecretKey;
        public byte[] defaultDynamicSecretKey;
        public List<string> assembliesUsingDynamicSecretKeys;
        public int randomSeed;

        public string encryptionVmGenerationSecretKey;
        public int encryptionVmOpCodeCount;
        public string encryptionVmCodeFile;

        public List<string> assembliesToObfuscate;
        public List<string> nonObfuscatedButReferencingObfuscatedAssemblies;
        public List<string> assemblySearchPaths;
        public string obfuscatedAssemblyOutputPath;
        public string obfuscatedAssemblyTempOutputPath;

        public ObfuscationPassType enabledObfuscationPasses;
        public List<string> obfuscationPassRuleConfigFiles;
        public List<IObfuscationPass> obfuscationPasses;
    }

    public class ObfuscatorBuilder
    {
        private CoreSettingsFacade _coreSettingsFacade;

        public CoreSettingsFacade CoreSettingsFacade => _coreSettingsFacade;

        public void InsertTopPriorityAssemblySearchPaths(List<string> assemblySearchPaths)
        {
            _coreSettingsFacade.assemblySearchPaths.InsertRange(0, assemblySearchPaths);
        }

        public ObfuscatorBuilder AddPass(IObfuscationPass pass)
        {
            _coreSettingsFacade.obfuscationPasses.Add(pass);
            return this;
        }

        public Obfuscator Build()
        {
            return new Obfuscator(this);
        }

        public static List<string> BuildUnityAssemblySearchPaths(bool searchPathIncludeUnityEditorDll = false)
        {
            string applicationContentsPath = EditorApplication.applicationContentsPath;
            var searchPaths = new List<string>
                {
#if UNITY_2021_1_OR_NEWER
#if UNITY_STANDALONE_WIN || (UNITY_EDITOR_WIN && UNITY_SERVER) || UNITY_WSA || UNITY_LUMIN
                "MonoBleedingEdge/lib/mono/unityaot-win32",
                "MonoBleedingEdge/lib/mono/unityaot-win32/Facades",
#elif UNITY_STANDALONE_OSX || (UNITY_EDITOR_OSX && UNITY_SERVER) || UNITY_IOS || UNITY_TVOS
                "MonoBleedingEdge/lib/mono/unityaot-macos",
                "MonoBleedingEdge/lib/mono/unityaot-macos/Facades",
#else
                "MonoBleedingEdge/lib/mono/unityaot-linux",
                "MonoBleedingEdge/lib/mono/unityaot-linux/Facades",
#endif
#else
                "MonoBleedingEdge/lib/mono/unityaot",
                "MonoBleedingEdge/lib/mono/unityaot/Facades",
#endif

#if UNITY_STANDALONE_WIN || (UNITY_EDITOR_WIN && UNITY_SERVER)
                "PlaybackEngines/windowsstandalonesupport/Variations/il2cpp/Managed",
#elif UNITY_STANDALONE_OSX || (UNITY_EDITOR_OSX && UNITY_SERVER)
                "PlaybackEngines/MacStandaloneSupport/Variations/il2cpp/Managed",
#elif UNITY_STANDALONE_LINUX || (UNITY_EDITOR_LINUX && UNITY_SERVER)
                "PlaybackEngines/LinuxStandaloneSupport/Variations/il2cpp/Managed",
#elif UNITY_ANDROID
                "PlaybackEngines/AndroidPlayer/Variations/il2cpp/Managed",
#elif UNITY_IOS
                "PlaybackEngines/iOSSupport/Variations/il2cpp/Managed",
#elif UNITY_MINIGAME || UNITY_WEIXINMINIGAME
#if TUANJIE_1_1_OR_NEWER
                "PlaybackEngines/WeixinMiniGameSupport/Variations/il2cpp/nondevelopment/Data/Managed",
#else
                "PlaybackEngines/WeixinMiniGameSupport/Variations/nondevelopment/Data/Managed",
#endif
#elif UNITY_OPENHARMONY
                "PlaybackEngines/OpenHarmonyPlayer/Variations/il2cpp/Managed",
#elif UNITY_WEBGL
                "PlaybackEngines/WebGLSupport/Variations/nondevelopment/Data/Managed",
#elif UNITY_TVOS
                "PlaybackEngines/AppleTVSupport/Variations/il2cpp/Managed",
#elif UNITY_WSA
                "PlaybackEngines/WSASupport/Variations/il2cpp/Managed",
#elif UNITY_LUMIN
                "PlaybackEngines/LuminSupport/Variations/il2cpp/Managed",
#else
#error "Unsupported platform, please report to us"
#endif
                };

            if (searchPathIncludeUnityEditorDll)
            {
                searchPaths.Add("Managed/UnityEngine");
            }

                var resultPaths = new List<string>();
            foreach (var path in searchPaths)
            {
                string candidatePath1 = Path.Combine(applicationContentsPath, path);
                if (Directory.Exists(candidatePath1))
                {
                    resultPaths.Add(candidatePath1);
                }
                if (path.StartsWith("PlaybackEngines"))
                {
                    string candidatePath2 = Path.Combine(Path.GetDirectoryName(Path.GetDirectoryName(applicationContentsPath)), path);
                    if (Directory.Exists(candidatePath2))
                    {
                        resultPaths.Add(candidatePath2);
                    }
                }
            }
            return resultPaths;
        }

        public static ObfuscatorBuilder FromObfuzSettings(ObfuzSettings settings, BuildTarget target, bool searchPathIncludeUnityEditorInstallLocation, bool searchPathIncludeUnityEditorDll = false)
        {
            List<string> searchPaths = searchPathIncludeUnityEditorInstallLocation ?
                BuildUnityAssemblySearchPaths(searchPathIncludeUnityEditorDll).Concat(settings.assemblySettings.additionalAssemblySearchPaths).ToList()
                : settings.assemblySettings.additionalAssemblySearchPaths.ToList();
            foreach (var path in searchPaths)
            {
                bool exists = Directory.Exists(path);
                UnityEngine.Debug.Log($"search path:{path} exists:{exists}");
            }
            var builder = new ObfuscatorBuilder
            {
                _coreSettingsFacade = new CoreSettingsFacade()
                {
                    buildTarget = target,
                    defaultStaticSecretKey = KeyGenerator.GenerateKey(settings.secretSettings.defaultStaticSecretKey, VirtualMachine.SecretKeyLength),
                    defaultDynamicSecretKey = KeyGenerator.GenerateKey(settings.secretSettings.defaultDynamicSecretKey, VirtualMachine.SecretKeyLength),
                    assembliesUsingDynamicSecretKeys = settings.secretSettings.assembliesUsingDynamicSecretKeys.ToList(),
                    randomSeed = settings.secretSettings.randomSeed,
                    encryptionVmGenerationSecretKey = settings.encryptionVMSettings.codeGenerationSecretKey,
                    encryptionVmOpCodeCount = settings.encryptionVMSettings.encryptionOpCodeCount,
                    encryptionVmCodeFile = settings.encryptionVMSettings.codeOutputPath,
                    assembliesToObfuscate = settings.assemblySettings.GetAssembliesToObfuscate(),
                    nonObfuscatedButReferencingObfuscatedAssemblies = settings.assemblySettings.nonObfuscatedButReferencingObfuscatedAssemblies.ToList(),
                    assemblySearchPaths = searchPaths,
                    obfuscatedAssemblyOutputPath = settings.GetObfuscatedAssemblyOutputPath(target),
                    obfuscatedAssemblyTempOutputPath = settings.GetObfuscatedAssemblyTempOutputPath(target),
                    enabledObfuscationPasses = settings.obfuscationPassSettings.enabledPasses,
                    obfuscationPassRuleConfigFiles = settings.obfuscationPassSettings.ruleFiles?.ToList() ?? new List<string>(),
                    obfuscationPasses = new List<IObfuscationPass>(),
                },
            };
            ObfuscationPassType obfuscationPasses = settings.obfuscationPassSettings.enabledPasses;
            if (obfuscationPasses.HasFlag(ObfuscationPassType.ConstEncrypt))
            {
                builder.AddPass(new ConstEncryptPass(settings.constEncryptSettings.ToFacade()));
            }
            if (obfuscationPasses.HasFlag(ObfuscationPassType.ExprObfus))
            {
                builder.AddPass(new ExprObfusPass(settings.exprObfusSettings.ToFacade()));
            }
            if (obfuscationPasses.HasFlag(ObfuscationPassType.EvalStackObfus))
            {
                builder.AddPass(new EvalStackObfusPass(settings.evalStackObfusSettings.ToFacade()));
            }
            if (obfuscationPasses.HasFlag(ObfuscationPassType.FieldEncrypt))
            {
                builder.AddPass(new FieldEncryptPass(settings.fieldEncryptSettings.ToFacade()));
            }
            if (obfuscationPasses.HasFlag(ObfuscationPassType.CallObfus))
            {
                builder.AddPass(new CallObfusPass(settings.callObfusSettings.ToFacade()));
            }
            if (obfuscationPasses.HasFlag(ObfuscationPassType.ControlFlowObfus))
            {
                builder.AddPass(new ControlFlowObfusPass(settings.controlFlowObfusSettings.ToFacade()));
            }
            if (obfuscationPasses.HasFlag(ObfuscationPassType.SymbolObfus))
            {
                builder.AddPass(new SymbolObfusPass(settings.symbolObfusSettings.ToFacade()));
            }
            return builder;
        }
    }
}

```

`Editor/ObfuscatorBuilder.cs.meta`:

```meta
fileFormatVersion: 2
guid: 77e279242d764ed4d996db96f35e8570
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Obfuz.Editor.asmdef`:

```asmdef
{
    "name": "Obfuz.Editor",
    "rootNamespace": "",
    "references": [
        "GUID:4140bd2e2764f1f47ab93125ecb61942"
    ],
    "includePlatforms": [
        "Editor"
    ],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}
```

`Editor/Obfuz.Editor.asmdef.meta`:

```meta
fileFormatVersion: 2
guid: 66e09fc524ec6594b8d6ca1d91aa1a41
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Pipeline.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics;

namespace Obfuz
{
    public class Pipeline
    {
        private readonly List<IObfuscationPass> _passes = new List<IObfuscationPass>();

        public bool Empty => _passes.Count == 0;

        public Pipeline AddPass(IObfuscationPass pass)
        {
            _passes.Add(pass);
            return this;
        }

        public void Start()
        {
            foreach (var pass in _passes)
            {
                pass.Start();
            }
        }

        public void Stop()
        {

            foreach (var pass in _passes)
            {
                pass.Stop();
            }
        }

        public void Run()
        {
            var sw = new Stopwatch();
            foreach (var pass in _passes)
            {
                sw.Restart();
                pass.Process();
                sw.Stop();
                UnityEngine.Debug.Log($"Pass: {pass.GetType().Name} process cost time: {sw.ElapsedMilliseconds}ms");
            }
        }
    }
}

```

`Editor/Pipeline.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0915452219e923d428b9a408cf413844
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings.meta`:

```meta
fileFormatVersion: 2
guid: 4939d1f80df50b34c85ffc8fbe530887
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/AssemblySettings.cs`:

```cs
using Obfuz.Editor;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Obfuz.Settings
{
    [Serializable]
    public class AssemblySettings
    {

        [Tooltip("name of assemblies to obfuscate, please don't add 'Obfuz.Runtime'")]
        public string[] assembliesToObfuscate;

        [Tooltip("name of assemblies not obfuscated but reference assemblies to obfuscated ")]
        public string[] nonObfuscatedButReferencingObfuscatedAssemblies;

        [Tooltip("additional assembly search paths")]
        public string[] additionalAssemblySearchPaths;

        [Tooltip("obfuscate Obfuz.Runtime")]
        public bool obfuscateObfuzRuntime = true;

        public List<string> GetAssembliesToObfuscate()
        {
            var asses = new List<string>(assembliesToObfuscate ?? Array.Empty<string>());
            if (obfuscateObfuzRuntime && !asses.Contains(ConstValues.ObfuzRuntimeAssemblyName))
            {
                asses.Add(ConstValues.ObfuzRuntimeAssemblyName);
            }
            return asses;
        }

        public List<string> GetObfuscationRelativeAssemblyNames()
        {
            var asses = GetAssembliesToObfuscate();
            asses.AddRange(nonObfuscatedButReferencingObfuscatedAssemblies ?? Array.Empty<string>());
            return asses;
        }
    }
}

```

`Editor/Settings/AssemblySettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: 735c01fddc6f0c54a83e1feb9a60e13a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/BuildPipelineSettings.cs`:

```cs
using System;
using UnityEngine;

namespace Obfuz.Settings
{
    [Serializable]
    public class BuildPipelineSettings
    {
        [Tooltip("enable Obfuz")]
        public bool enable = true;

        [Tooltip("callback order of LinkXmlProcessor")]
        public int linkXmlProcessCallbackOrder = 10000;

        [Tooltip("callback order of ObfuscationProcess")]
        public int obfuscationProcessCallbackOrder = 10000;
    }
}

```

`Editor/Settings/BuildPipelineSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: 68737b215ecfe344a93d56007e186432
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/CallObfuscationSettings.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Obfuz.Settings
{
    public enum ProxyMode
    {
        Dispatch,
        Delegate,
    }

    public class CallObfuscationSettingsFacade
    {
        public ProxyMode proxyMode;
        public int obfuscationLevel;
        public int maxProxyMethodCountPerDispatchMethod;
        public bool obfuscateCallToMethodInMscorlib;
        public List<string> ruleFiles;
    }

    [Serializable]
    public class CallObfuscationSettings
    {
        public ProxyMode proxyMode = ProxyMode.Dispatch;

        [Tooltip("The obfuscation level for the obfuscation. Higher levels provide more security but may impact performance.")]
        [Range(1, 4)]
        public int obfuscationLevel = 1;

        [Tooltip("The maximum number of proxy methods that can be generated per dispatch method. This helps to limit the complexity of the generated code and improve performance.")]
        public int maxProxyMethodCountPerDispatchMethod = 100;

        [Tooltip("Whether to obfuscate calls to methods in mscorlib. Enable this option will impact performance.")]
        public bool obfuscateCallToMethodInMscorlib;

        [Tooltip("rule config xml files")]
        public string[] ruleFiles;

        public CallObfuscationSettingsFacade ToFacade()
        {
            return new CallObfuscationSettingsFacade
            {
                proxyMode = proxyMode,
                obfuscationLevel = obfuscationLevel,
                maxProxyMethodCountPerDispatchMethod = maxProxyMethodCountPerDispatchMethod,
                obfuscateCallToMethodInMscorlib = obfuscateCallToMethodInMscorlib,
                ruleFiles = ruleFiles?.ToList() ?? new List<string>(),
            };
        }
    }
}

```

`Editor/Settings/CallObfuscationSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: ae4ddc19ecf8d9940b444f5b66c23efa
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/ConstEncryptionSettings.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Obfuz.Settings
{
    public class ConstEncryptionSettingsFacade
    {
        public int encryptionLevel;
        public List<string> ruleFiles;
    }

    [Serializable]
    public class ConstEncryptionSettings
    {
        [Tooltip("The encryption level for the obfuscation. Higher levels provide more security but may impact performance.")]
        [Range(1, 4)]
        public int encryptionLevel = 1;

        [Tooltip("config xml files")]
        public string[] ruleFiles;

        public ConstEncryptionSettingsFacade ToFacade()
        {
            return new ConstEncryptionSettingsFacade
            {
                ruleFiles = ruleFiles?.ToList() ?? new List<string>(),
                encryptionLevel = encryptionLevel,
            };
        }
    }
}

```

`Editor/Settings/ConstEncryptionSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: 2b189f76d7da58e4b9403b4fe87265b4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/ControlFlowObfuscationSettings.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Obfuz.Settings
{

    public class ControlFlowObfuscationSettingsFacade
    {
        public int minInstructionCountOfBasicBlockToObfuscate;
        public List<string> ruleFiles;
    }

    [Serializable]
    public class ControlFlowObfuscationSettings
    {
        public int minInstructionCountOfBasicBlockToObfuscate = 3;

        [Tooltip("rule config xml files")]
        public string[] ruleFiles;

        public ControlFlowObfuscationSettingsFacade ToFacade()
        {
            return new ControlFlowObfuscationSettingsFacade
            {
                minInstructionCountOfBasicBlockToObfuscate = minInstructionCountOfBasicBlockToObfuscate,
                ruleFiles = new List<string>(ruleFiles ?? Array.Empty<string>()),
            };
        }
    }
}

```

`Editor/Settings/ControlFlowObfuscationSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: d40d2fb33f081b2458505c7566b1bc8f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/EncryptionVMSettings.cs`:

```cs
using System;
using UnityEngine;

namespace Obfuz.Settings
{
    [Serializable]
    public class EncryptionVMSettings
    {
        [Tooltip("secret key for generating encryption virtual machine source code")]
        public string codeGenerationSecretKey = "Obfuz";

        [Tooltip("encryption OpCode count, should be power of 2 and >= 64")]
        public int encryptionOpCodeCount = 256;

        [Tooltip("encryption virtual machine source code output path")]
        public string codeOutputPath = "Assets/Obfuz/GeneratedEncryptionVirtualMachine.cs";
    }
}

```

`Editor/Settings/EncryptionVMSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: f0e626d510710c540bdc36b4dca93340
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/EvalStackObfuscationSettings.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Obfuz.Settings
{

    public class EvalStackObfuscationSettingsFacade
    {
        public List<string> ruleFiles;
    }

    [Serializable]
    public class EvalStackObfuscationSettings
    {
        [Tooltip("rule config xml files")]
        public string[] ruleFiles;

        public EvalStackObfuscationSettingsFacade ToFacade()
        {
            return new EvalStackObfuscationSettingsFacade
            {
                ruleFiles = new List<string>(ruleFiles ?? Array.Empty<string>()),
            };
        }
    }
}

```

`Editor/Settings/EvalStackObfuscationSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: 3c985896b3a4ef84292cb0cfbc79dc10
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/ExprObfuscationSettings.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Obfuz.Settings
{

    public class ExprObfuscationSettingsFacade
    {
        public List<string> ruleFiles;
    }

    [Serializable]
    public class ExprObfuscationSettings
    {
        [Tooltip("rule config xml files")]
        public string[] ruleFiles;

        public ExprObfuscationSettingsFacade ToFacade()
        {
            return new ExprObfuscationSettingsFacade
            {
                ruleFiles = new List<string>(ruleFiles ?? Array.Empty<string>()),
            };
        }
    }
}

```

`Editor/Settings/ExprObfuscationSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: d63d19f2b1a9f7c4b9812577d215c367
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/FieldEncryptionSettings.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Obfuz.Settings
{
    public class FieldEncryptionSettingsFacade
    {
        public int encryptionLevel;
        public List<string> ruleFiles;
    }

    [Serializable]
    public class FieldEncryptionSettings
    {
        [Tooltip("The encryption level for the obfuscation. Higher levels provide more security but may impact performance.")]
        [Range(1, 4)]
        public int encryptionLevel = 1;

        [Tooltip("rule config xml files")]
        public string[] ruleFiles;

        public FieldEncryptionSettingsFacade ToFacade()
        {
            return new FieldEncryptionSettingsFacade
            {
                ruleFiles = ruleFiles?.ToList() ?? new List<string>(),
                encryptionLevel = encryptionLevel,
            };
        }
    }
}

```

`Editor/Settings/FieldEncryptionSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: 56cff1f5683d9114e8f13cee917ea582
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/GarbageCodeGenerationSettings.cs`:

```cs
using System;

namespace Obfuz.Settings
{
    public enum GarbageCodeType
    {
        None,
        Config,
        UI,
    }

    [Serializable]
    public class GarbageCodeGenerationTask
    {
        public int codeGenerationRandomSeed;

        public string classNamespace = "__GarbageCode";

        public string classNamePrefix = "__GeneratedGarbageClass";

        public int classCount = 100;

        public int methodCountPerClass = 10;

        public int fieldCountPerClass = 50;

        public GarbageCodeType garbageCodeType = GarbageCodeType.Config;

        public string outputPath = "Assets/Obfuz/GarbageCode";
    }

    [Serializable]
    public class GarbageCodeGenerationSettings
    {
        public string codeGenerationSecret = "Garbage Code";

        public GarbageCodeGenerationTask defaultTask;

        public GarbageCodeGenerationTask[] additionalTasks;
    }
}

```

`Editor/Settings/GarbageCodeGenerationSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: 220b44e477cfa2848bd287c38db4fd21
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/ObfuscationLevel.cs`:

```cs
namespace Obfuz.Settings
{
    public enum ObfuscationLevel
    {
        None = 0,
        Basic = 1,
        Advanced = 2,
        MostAdvanced = 3
    }
}

```

`Editor/Settings/ObfuscationLevel.cs.meta`:

```meta
fileFormatVersion: 2
guid: dd8e1281c6c9bcd419fecc67980cb673
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/ObfuscationPassSettings.cs`:

```cs
using Obfuz.ObfusPasses;
using System;
using UnityEngine;

namespace Obfuz.Settings
{
    [Serializable]
    public class ObfuscationPassSettings
    {
        [Tooltip("enable obfuscation pass")]
        public ObfuscationPassType enabledPasses = ObfuscationPassType.All;

        [Tooltip("rule config xml files")]
        public string[] ruleFiles;
    }
}

```

`Editor/Settings/ObfuscationPassSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: 9cb41a6fb7293ce47807e432d80f2b2a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/ObfuzSettings.cs`:

```cs
using System.IO;
using UnityEditor;
using UnityEditorInternal;
using UnityEngine;

namespace Obfuz.Settings
{

    public class ObfuzSettings : ScriptableObject
    {
        [Tooltip("build pipeline settings")]
        public BuildPipelineSettings buildPipelineSettings;

        [Tooltip("assembly settings")]
        public AssemblySettings assemblySettings;

        [Tooltip("obfuscation pass settings")]
        public ObfuscationPassSettings obfuscationPassSettings;

        [Tooltip("secret settings")]
        public SecretSettings secretSettings;

        [Tooltip("encryption virtual machine settings")]
        public EncryptionVMSettings encryptionVMSettings;

        [Tooltip("symbol obfuscation settings")]
        public SymbolObfuscationSettings symbolObfusSettings;

        [Tooltip("const encryption settings")]
        public ConstEncryptionSettings constEncryptSettings;

        [Tooltip("eval stack obfuscation settings")]
        public EvalStackObfuscationSettings evalStackObfusSettings;

        [Tooltip("field encryption settings")]
        public FieldEncryptionSettings fieldEncryptSettings;

        [Tooltip("call obfuscation settings")]
        public CallObfuscationSettings callObfusSettings;

        [Tooltip("expression obfuscation settings")]
        public ExprObfuscationSettings exprObfusSettings;

        [Tooltip("control flow obfuscation settings")]
        public ControlFlowObfuscationSettings controlFlowObfusSettings;

        [Tooltip("garbage code generator settings")]
        public GarbageCodeGenerationSettings garbageCodeGenerationSettings;

        [Tooltip("polymorphic dll settings")]
        public PolymorphicDllSettings polymorphicDllSettings;

        public string ObfuzRootDir => $"Library/Obfuz";

        public string GetObfuscatedAssemblyOutputPath(BuildTarget target)
        {
            return $"{ObfuzRootDir}/{target}/ObfuscatedAssemblies";
        }

        public string GetOriginalAssemblyBackupDir(BuildTarget target)
        {
            return $"{ObfuzRootDir}/{target}/OriginalAssemblies";
        }

        public string GetObfuscatedAssemblyTempOutputPath(BuildTarget target)
        {
            return $"{ObfuzRootDir}/{target}/TempObfuscatedAssemblies";
        }

        public string GetObfuscatedLinkXmlPath(BuildTarget target)
        {
            return $"{ObfuzRootDir}/{target}/link.xml";
        }

        private static ObfuzSettings s_Instance;

        public static ObfuzSettings Instance
        {
            get
            {
                if (!s_Instance)
                {
                    LoadOrCreate();
                }
                return s_Instance;
            }
        }

        protected static string SettingsPath => "ProjectSettings/Obfuz.asset";

        private static ObfuzSettings LoadOrCreate()
        {
            string filePath = SettingsPath;
            var arr = InternalEditorUtility.LoadSerializedFileAndForget(filePath);
            //Debug.Log($"typeof arr:{arr?.GetType()} arr[0]:{(arr != null && arr.Length > 0 ? arr[0].GetType(): null)}");

            if (arr != null && arr.Length > 0 && arr[0] is ObfuzSettings obfuzSettings)
            {
                s_Instance = obfuzSettings;
            }
            else
            {
                s_Instance = s_Instance ?? CreateInstance<ObfuzSettings>();
            }
            return s_Instance;
        }

        public static void Save()
        {
            if (!s_Instance)
            {
                return;
            }

            string filePath = SettingsPath;
            string directoryName = Path.GetDirectoryName(filePath);
            Directory.CreateDirectory(directoryName);
            UnityEngine.Object[] obj = new ObfuzSettings[1] { s_Instance };
            InternalEditorUtility.SaveToSerializedFileAndForget(obj, filePath, true);
        }
    }
}

```

`Editor/Settings/ObfuzSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: c414eef017e565c4db1442ec64ec52fe
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/ObfuzSettingsProvider.cs`:

```cs
using UnityEditor;
using UnityEngine.UIElements;

namespace Obfuz.Settings
{
    public class ObfuzSettingsProvider : SettingsProvider
    {

        private static ObfuzSettingsProvider s_provider;

        [SettingsProvider]
        public static SettingsProvider CreateMyCustomSettingsProvider()
        {
            if (s_provider == null)
            {
                s_provider = new ObfuzSettingsProvider();
                using (var so = new SerializedObject(ObfuzSettings.Instance))
                {
                    s_provider.keywords = GetSearchKeywordsFromSerializedObject(so);
                }
            }
            return s_provider;
        }


        private SerializedObject _serializedObject;
        private SerializedProperty _buildPipelineSettings;

        private SerializedProperty _assemblySettings;
        private SerializedProperty _obfuscationPassSettings;
        private SerializedProperty _secretSettings;
        private SerializedProperty _encryptionVMSettings;

        private SerializedProperty _symbolObfusSettings;
        private SerializedProperty _constEncryptSettings;
        private SerializedProperty _evalStackObfusSettings;
        private SerializedProperty _fieldEncryptSettings;
        private SerializedProperty _callObfusSettings;
        private SerializedProperty _exprObfusSettings;
        private SerializedProperty _controlFlowObfusSettings;

        private SerializedProperty _garbageCodeGenerationSettings;

        private SerializedProperty _polymorphicDllSettings;

        public ObfuzSettingsProvider() : base("Project/Obfuz", SettingsScope.Project)
        {
        }

        public override void OnActivate(string searchContext, VisualElement rootElement)
        {
            InitGUI();
        }

        public override void OnDeactivate()
        {
            base.OnDeactivate();
            ObfuzSettings.Save();
        }

        private void InitGUI()
        {
            var setting = ObfuzSettings.Instance;
            _serializedObject?.Dispose();
            _serializedObject = new SerializedObject(setting);
            _buildPipelineSettings = _serializedObject.FindProperty("buildPipelineSettings");

            _assemblySettings = _serializedObject.FindProperty("assemblySettings");
            _obfuscationPassSettings = _serializedObject.FindProperty("obfuscationPassSettings");
            _secretSettings = _serializedObject.FindProperty("secretSettings");

            _encryptionVMSettings = _serializedObject.FindProperty("encryptionVMSettings");

            _symbolObfusSettings = _serializedObject.FindProperty("symbolObfusSettings");
            _constEncryptSettings = _serializedObject.FindProperty("constEncryptSettings");
            _evalStackObfusSettings = _serializedObject.FindProperty("evalStackObfusSettings");
            _exprObfusSettings = _serializedObject.FindProperty("exprObfusSettings");
            _fieldEncryptSettings = _serializedObject.FindProperty("fieldEncryptSettings");
            _callObfusSettings = _serializedObject.FindProperty("callObfusSettings");
            _controlFlowObfusSettings = _serializedObject.FindProperty("controlFlowObfusSettings");

            _garbageCodeGenerationSettings = _serializedObject.FindProperty("garbageCodeGenerationSettings");

            _polymorphicDllSettings = _serializedObject.FindProperty("polymorphicDllSettings");
        }

        public override void OnGUI(string searchContext)
        {
            if (_serializedObject == null || !_serializedObject.targetObject)
            {
                InitGUI();
            }
            _serializedObject.Update();
            EditorGUI.BeginChangeCheck();

            EditorGUILayout.PropertyField(_buildPipelineSettings);

            EditorGUILayout.PropertyField(_assemblySettings);
            EditorGUILayout.PropertyField(_obfuscationPassSettings);
            EditorGUILayout.PropertyField(_secretSettings);

            EditorGUILayout.PropertyField(_encryptionVMSettings);

            EditorGUILayout.PropertyField(_symbolObfusSettings);
            EditorGUILayout.PropertyField(_constEncryptSettings);
            EditorGUILayout.PropertyField(_evalStackObfusSettings);
            EditorGUILayout.PropertyField(_exprObfusSettings);
            EditorGUILayout.PropertyField(_fieldEncryptSettings);
            EditorGUILayout.PropertyField(_callObfusSettings);
            EditorGUILayout.PropertyField(_controlFlowObfusSettings);

            EditorGUILayout.PropertyField(_garbageCodeGenerationSettings);

            EditorGUILayout.PropertyField(_polymorphicDllSettings);

            if (EditorGUI.EndChangeCheck())
            {
                _serializedObject.ApplyModifiedProperties();
                ObfuzSettings.Save();
            }
        }
    }
}
```

`Editor/Settings/ObfuzSettingsProvider.cs.meta`:

```meta
fileFormatVersion: 2
guid: 9f020d09993a1aa41bae3258ec33d5fc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/PolymorphicDllSettings.cs`:

```cs
using System;
using UnityEngine;

namespace Obfuz.Settings
{
    [Serializable]
    public class PolymorphicDllSettings
    {
        [Tooltip("enable polymorphic DLL generation")]
        public bool enable = true;

        [Tooltip("secret key for generating polymorphic DLL source code")]
        public string codeGenerationSecretKey = "obfuz-polymorphic-key";

        [Tooltip("disable load standard dotnet dll")]
        public bool disableLoadStandardDll = false;
    }
}

```

`Editor/Settings/PolymorphicDllSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: ecab9aab707d08949b2d602a4d61084a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/SecretSettings.cs`:

```cs
using System;
using UnityEngine;

namespace Obfuz.Settings
{
    [Serializable]
    public class SecretSettings
    {

        [Tooltip("default static secret key")]
        public string defaultStaticSecretKey = "Code Philosophy-Static";

        [Tooltip("default dynamic secret key")]
        public string defaultDynamicSecretKey = "Code Philosophy-Dynamic";

        [Tooltip("default static secret key output path")]
        public string staticSecretKeyOutputPath = $"Assets/Resources/Obfuz/defaultStaticSecretKey.bytes";

        [Tooltip("default dynamic secret key output path")]
        public string dynamicSecretKeyOutputPath = $"Assets/Resources/Obfuz/defaultDynamicSecretKey.bytes";

        [Tooltip("random seed")]
        public int randomSeed = 0;

        [Tooltip("name of assemblies those use dynamic secret key")]
        public string[] assembliesUsingDynamicSecretKeys;
    }
}

```

`Editor/Settings/SecretSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: 7ac4fe2a6df113444b67412254452a00
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Settings/SymbolObfuscationSettings.cs`:

```cs
using Obfuz.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Obfuz.Settings
{
    public class SymbolObfuscationSettingsFacade
    {
        public bool debug;
        public string obfuscatedNamePrefix;
        public bool useConsistentNamespaceObfuscation;
        public bool detectReflectionCompatibility;
        public bool keepUnknownSymbolInSymbolMappingFile;
        public string symbolMappingFile;
        public List<string> ruleFiles;
        public List<Type> customRenamePolicyTypes;
    }

    [Serializable]
    public class SymbolObfuscationSettings
    {
        public bool debug;

        [Tooltip("prefix for obfuscated name to avoid name confliction with original name")]
        public string obfuscatedNamePrefix = "$";

        [Tooltip("obfuscate same namespace to one name")]
        public bool useConsistentNamespaceObfuscation = true;

        [Tooltip("detect reflection compatibility, if true, will detect if the obfuscated name is compatibility with reflection, such as Type.GetType(), Enum.Parse(), etc.")]
        public bool detectReflectionCompatibility = true;

        [Tooltip("keep unknown symbol in symbol mapping file, if false, unknown symbol will be removed from mapping file")]
        public bool keepUnknownSymbolInSymbolMappingFile = true;

        [Tooltip("symbol mapping file path")]
        public string symbolMappingFile = "Assets/Obfuz/SymbolObfus/symbol-mapping.xml";

        [Tooltip("debug symbol mapping file path, used for debugging purposes")]
        public string debugSymbolMappingFile = "Assets/Obfuz/SymbolObfus/symbol-mapping-debug.xml";

        [Tooltip("rule files")]
        public string[] ruleFiles;

        [Tooltip("custom rename policy types")]
        public string[] customRenamePolicyTypes;

        public string GetSymbolMappingFile()
        {
            return debug ? debugSymbolMappingFile : symbolMappingFile;
        }

        public SymbolObfuscationSettingsFacade ToFacade()
        {
            return new SymbolObfuscationSettingsFacade
            {
                debug = debug,
                obfuscatedNamePrefix = obfuscatedNamePrefix,
                useConsistentNamespaceObfuscation = useConsistentNamespaceObfuscation,
                detectReflectionCompatibility = detectReflectionCompatibility,
                keepUnknownSymbolInSymbolMappingFile = keepUnknownSymbolInSymbolMappingFile,
                symbolMappingFile = GetSymbolMappingFile(),
                ruleFiles = ruleFiles?.ToList() ?? new List<string>(),
                customRenamePolicyTypes = customRenamePolicyTypes?.Select(typeName => ReflectionUtil.FindUniqueTypeInCurrentAppDomain(typeName)).ToList() ?? new List<Type>(),
            };
        }
    }
}

```

`Editor/Settings/SymbolObfuscationSettings.cs.meta`:

```meta
fileFormatVersion: 2
guid: 2484a8a12a689df46b5eb7fc4ccac81f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Unity.meta`:

```meta
fileFormatVersion: 2
guid: bc9b206fbf6a69f4c99a6ec9b0b27c69
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Unity/LinkXmlProcess.cs`:

```cs
using Obfuz.Settings;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using UnityEditor;
using UnityEditor.Build;
using UnityEditor.Build.Reporting;
using UnityEditor.UnityLinker;
using UnityEngine;
using FileUtil = Obfuz.Utils.FileUtil;

namespace Obfuz.Unity
{
    public class LinkXmlProcess : IUnityLinkerProcessor
    {
        public int callbackOrder => ObfuzSettings.Instance.buildPipelineSettings.linkXmlProcessCallbackOrder;

        public string GenerateAdditionalLinkXmlFile(BuildReport report, UnityLinkerBuildPipelineData data)
        {
            return GenerateAdditionalLinkXmlFile(data.target);
        }

#if !UNITY_2021_2_OR_NEWER

        public void OnBeforeRun(BuildReport report, UnityLinkerBuildPipelineData data)
        {

        }

        public void OnAfterRun(BuildReport report, UnityLinkerBuildPipelineData data)
        {

        }
#endif

        public static string GenerateAdditionalLinkXmlFile(BuildTarget target)
        {
            ObfuzSettings settings = ObfuzSettings.Instance;
            if (!settings.buildPipelineSettings.enable)
            {
                Debug.Log("Obfuscation is disabled. Skipping link.xml generation.");
                return null;
            }
            string symbolMappingFile = settings.symbolObfusSettings.GetSymbolMappingFile();
            if (!File.Exists(symbolMappingFile))
            {
                Debug.LogWarning($"Symbol mapping file not found: {symbolMappingFile}. Skipping link.xml generation.");
                return null;
            }
            string linkXmlPath = settings.GetObfuscatedLinkXmlPath(target);
            FileUtil.CreateParentDir(linkXmlPath);

            var writer = System.Xml.XmlWriter.Create(linkXmlPath,
                new System.Xml.XmlWriterSettings { Encoding = Encoding.UTF8, Indent = true });
            try
            {
                var symbolMapping = new LiteSymbolMappingReader(symbolMappingFile);
                string[] linkGuids = AssetDatabase.FindAssets("t:TextAsset");
                var linkXmlPaths = linkGuids.Select(guid => AssetDatabase.GUIDToAssetPath(guid))
                    .Where(f => Path.GetFileName(f) == "link.xml")
                    .ToArray();

                var assembliesToObfuscated = new HashSet<string>(settings.assemblySettings.GetAssembliesToObfuscate());

                writer.WriteStartDocument();
                writer.WriteStartElement("linker");

                // Preserve Obfuz.Runtime assembly
                writer.WriteStartElement("assembly");
                writer.WriteAttributeString("fullname", "Obfuz.Runtime");
                writer.WriteAttributeString("preserve", "all");
                writer.WriteEndElement();

                foreach (string linkPath in linkXmlPaths)
                {
                    TransformLinkXml(linkPath, symbolMapping, assembliesToObfuscated, writer);
                }
                writer.WriteEndElement();
                writer.WriteEndDocument();
            }
            finally
            {
                writer.Close();
            }
            Debug.Log($"LinkXmlProcess write {Path.GetFullPath(linkXmlPath)}");
            return Path.GetFullPath(linkXmlPath);
        }

        private static void TransformLinkXml(string xmlFile, LiteSymbolMappingReader symbolMapping, HashSet<string> assembliesToObfuscated, XmlWriter writer)
        {
            Debug.Log($"LinkXmlProcess transform link.xml:{xmlFile}");
            var doc = new XmlDocument();
            doc.Load(xmlFile);
            var root = doc.DocumentElement;
            foreach (XmlNode assNode in root.ChildNodes)
            {
                if (!(assNode is XmlElement assElement))
                {
                    continue;
                }
                if (assElement.Name == "assembly")
                {
                    string assemblyName = assElement.GetAttribute("fullname");
                    if (string.IsNullOrEmpty(assemblyName))
                    {
                        throw new Exception($"Invalid node name: {assElement.Name}. attribute 'fullname' missing.");
                    }
                    if (!assembliesToObfuscated.Contains(assemblyName))
                    {
                        continue; // Skip assemblies that are not to be obfuscated
                    }
                    writer.WriteStartElement("assembly");
                    writer.WriteAttributeString("fullname", assemblyName);
                    if (assElement.HasAttribute("preserve"))
                    {
                        writer.WriteAttributeString("preserve", assElement.GetAttribute("preserve"));
                    }

                    foreach (XmlNode typeNode in assElement.ChildNodes)
                    {
                        if (typeNode is XmlElement typeElement)
                        {
                            if (typeElement.Name == "type")
                            {
                                string typeName = typeElement.GetAttribute("fullname");
                                if (string.IsNullOrEmpty(typeName))
                                {
                                    throw new Exception($"Invalid node name: {typeElement.Name}. attribute 'fullname' missing.");
                                }
                                if (!symbolMapping.TryGetNewTypeName(assemblyName, typeName, out string newTypeName))
                                {
                                    continue;
                                }

                                writer.WriteStartElement("type");
                                writer.WriteAttributeString("fullname", newTypeName);
                                if (typeElement.HasAttribute("preserve"))
                                {
                                    writer.WriteAttributeString("preserve", typeElement.GetAttribute("preserve"));
                                }
                                writer.WriteEndElement();
                            }
                        }
                    }

                    writer.WriteEndElement();
                }
            }
        }
    }
}

```

`Editor/Unity/LinkXmlProcess.cs.meta`:

```meta
fileFormatVersion: 2
guid: 66881cca1e4a78c44b4c9fcd7f8b4fb9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Unity/LiteSymbolMappingReader.cs`:

```cs

using System.Collections.Generic;
using System.Xml;

namespace Obfuz.Unity
{

    public class LiteSymbolMappingReader
    {
        class TypeMappingInfo
        {
            public string oldFullName;
            public string newFullName;

            //public Dictionary<string, string> MethodMappings = new Dictionary<string, string>();
        }

        class AssemblyMappingInfo
        {
            public Dictionary<string, string> TypeMappings = new Dictionary<string, string>();
            public Dictionary<string, string> MethodMappings = new Dictionary<string, string>();
        }

        private readonly Dictionary<string, AssemblyMappingInfo> _assemblies = new Dictionary<string, AssemblyMappingInfo>();

        public LiteSymbolMappingReader(string mappingFile)
        {
            LoadXmlMappingFile(mappingFile);
        }

        private void LoadXmlMappingFile(string mappingFile)
        {
            var doc = new XmlDocument();
            doc.Load(mappingFile);
            var root = doc.DocumentElement;
            foreach (XmlNode node in root.ChildNodes)
            {
                if (!(node is XmlElement element))
                {
                    continue;
                }
                LoadAssemblyMapping(element);
            }
        }

        private void LoadAssemblyMapping(XmlElement ele)
        {
            if (ele.Name != "assembly")
            {
                throw new System.Exception($"Invalid node name: {ele.Name}. Expected 'assembly'.");
            }
            string assName = ele.GetAttribute("name");
            if (string.IsNullOrEmpty(assName))
            {
                throw new System.Exception($"Invalid node name: {ele.Name}. attribute 'name' missing.");
            }
            if (!_assemblies.TryGetValue(assName, out var assemblyMappingInfo))
            {
                assemblyMappingInfo = new AssemblyMappingInfo();
                _assemblies[assName] = assemblyMappingInfo;
            }

            foreach (XmlNode node in ele.ChildNodes)
            {
                if (!(node is XmlElement element))
                {
                    continue;
                }
                if (element.Name == "type")
                {
                    LoadTypeMapping(element, assemblyMappingInfo);
                }
            }
        }

        private void LoadTypeMapping(XmlElement ele, AssemblyMappingInfo assemblyMappingInfo)
        {
            string oldFullName = ele.GetAttribute("fullName");
            string newFullName = ele.GetAttribute("newFullName");
            string status = ele.GetAttribute("status");
            if (status == "Renamed")
            {
                if (string.IsNullOrEmpty(oldFullName) || string.IsNullOrEmpty(newFullName))
                {
                    throw new System.Exception($"Invalid node name: {ele.Name}. attributes 'fullName' or 'newFullName' missing.");
                }
                assemblyMappingInfo.TypeMappings[oldFullName] = newFullName;
            }
            //foreach (XmlNode node in ele.ChildNodes)
            //{
            //    if (!(node is XmlElement c))
            //    {
            //        continue;
            //    }
            //    if (node.Name == "method")
            //    {
            //        LoadMethodMapping(c);
            //    }
            //}
        }

        public bool TryGetNewTypeName(string assemblyName, string oldFullName, out string newFullName)
        {
            newFullName = null;
            if (_assemblies.TryGetValue(assemblyName, out var assemblyMappingInfo))
            {
                if (assemblyMappingInfo.TypeMappings.TryGetValue(oldFullName, out newFullName))
                {
                    return true;
                }
            }
            return false;
        }

    }
}

```

`Editor/Unity/LiteSymbolMappingReader.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8429e75dcc6a7e742a3cabaa3e8491c5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Unity/ObfuscationBeginEventArgs.cs`:

```cs
namespace Obfuz.Unity
{
    public class ObfuscationBeginEventArgs
    {
        public string scriptAssembliesPath;
        public string obfuscatedScriptAssembliesPath;
    }
}

```

`Editor/Unity/ObfuscationBeginEventArgs.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8e3d38018839d4844bf1e15631946e65
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Unity/ObfuscationEndEventArgs.cs`:

```cs
namespace Obfuz.Unity
{
    public class ObfuscationEndEventArgs
    {
        public bool success;
        public string originalScriptAssembliesPath;
        public string obfuscatedScriptAssembliesPath;
    }
}

```

`Editor/Unity/ObfuscationEndEventArgs.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6b198ad99d0a9c145b1bc2b29b25b8ac
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Unity/ObfuscationProcess.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Settings;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEditor.Build;
using UnityEditor.Build.Reporting;
using UnityEngine;
using FileUtil = Obfuz.Utils.FileUtil;

namespace Obfuz.Unity
{

#if UNITY_2019_1_OR_NEWER
    public class ObfuscationProcess : IPostBuildPlayerScriptDLLs
    {
        public int callbackOrder => ObfuzSettings.Instance.buildPipelineSettings.obfuscationProcessCallbackOrder;

        public static event Action<ObfuscationBeginEventArgs> OnObfuscationBegin;

        public static event Action<ObfuscationEndEventArgs> OnObfuscationEnd;

        public void OnPostBuildPlayerScriptDLLs(BuildReport report)
        {
#if !UNITY_2022_1_OR_NEWER
            RunObfuscate(report.files);
#else
            RunObfuscate(report.GetFiles());
#endif
        }

        private static void BackupOriginalDlls(string srcDir, string dstDir, HashSet<string> dllNames)
        {
            FileUtil.RecreateDir(dstDir);
            foreach (string dllName in dllNames)
            {
                string srcFile = Path.Combine(srcDir, dllName + ".dll");
                string dstFile = Path.Combine(dstDir, dllName + ".dll");
                if (File.Exists(srcFile))
                {
                    File.Copy(srcFile, dstFile, true);
                    Debug.Log($"BackupOriginalDll {srcFile} -> {dstFile}");
                }
            }
        }

        public static void ValidateReferences(string stagingAreaTempManagedDllDir, HashSet<string> assembliesToObfuscated, HashSet<string> obfuscationRelativeAssemblyNames)
        {
            var modCtx = ModuleDef.CreateModuleContext();
            var asmResolver = (AssemblyResolver)modCtx.AssemblyResolver;

            foreach (string assFile in Directory.GetFiles(stagingAreaTempManagedDllDir, "*.dll", SearchOption.AllDirectories))
            {
                ModuleDefMD mod = ModuleDefMD.Load(File.ReadAllBytes(assFile), modCtx);
                string modName = mod.Assembly.Name;
                foreach (AssemblyRef assRef in mod.GetAssemblyRefs())
                {
                    string refAssName = assRef.Name;
                    if (assembliesToObfuscated.Contains(refAssName) && !obfuscationRelativeAssemblyNames.Contains(modName))
                    {
                        throw new BuildFailedException($"assembly:{modName} references to obfuscated assembly:{refAssName}, but it's not been added to ObfuzSettings.AssemblySettings.NonObfuscatedButReferencingObfuscatedAssemblies.");
                    }
                }
                mod.Dispose();
            }
        }

        private static void RunObfuscate(BuildFile[] files)
        {
            ObfuzSettings settings = ObfuzSettings.Instance;
            if (!settings.buildPipelineSettings.enable)
            {
                Debug.Log("Obfuscation is disabled.");
                return;
            }

            Debug.Log("Obfuscation begin...");
            var buildTarget = EditorUserBuildSettings.activeBuildTarget;

            var obfuscationRelativeAssemblyNames = new HashSet<string>(settings.assemblySettings.GetObfuscationRelativeAssemblyNames());
            string stagingAreaTempManagedDllDir = Path.GetDirectoryName(files.First(file => file.path.EndsWith(".dll")).path);
            string backupPlayerScriptAssembliesPath = settings.GetOriginalAssemblyBackupDir(buildTarget);
            BackupOriginalDlls(stagingAreaTempManagedDllDir, backupPlayerScriptAssembliesPath, obfuscationRelativeAssemblyNames);

            string applicationContentsPath = EditorApplication.applicationContentsPath;

            var obfuscatorBuilder = ObfuscatorBuilder.FromObfuzSettings(settings, buildTarget, false);

            var assemblySearchDirs = new List<string>
                {
                   stagingAreaTempManagedDllDir,
                };
            obfuscatorBuilder.InsertTopPriorityAssemblySearchPaths(assemblySearchDirs);

            ValidateReferences(stagingAreaTempManagedDllDir, new HashSet<string>(obfuscatorBuilder.CoreSettingsFacade.assembliesToObfuscate), obfuscationRelativeAssemblyNames);


            OnObfuscationBegin?.Invoke(new ObfuscationBeginEventArgs
            {
                scriptAssembliesPath = stagingAreaTempManagedDllDir,
                obfuscatedScriptAssembliesPath = obfuscatorBuilder.CoreSettingsFacade.obfuscatedAssemblyOutputPath,
            });
            bool succ = false;

            try
            {
                Obfuscator obfuz = obfuscatorBuilder.Build();
                obfuz.Run();

                foreach (var dllName in obfuscationRelativeAssemblyNames)
                {
                    string src = $"{obfuscatorBuilder.CoreSettingsFacade.obfuscatedAssemblyOutputPath}/{dllName}.dll";
                    string dst = $"{stagingAreaTempManagedDllDir}/{dllName}.dll";

                    if (!File.Exists(src))
                    {
                        Debug.LogWarning($"obfuscation assembly not found! skip copy. path:{src}");
                        continue;
                    }
                    File.Copy(src, dst, true);
                    Debug.Log($"obfuscate dll:{dst}");
                }
                succ = true;
            }
            catch (Exception e)
            {
                succ = false;
                Debug.LogException(e);
                Debug.LogError($"Obfuscation failed.");
            }
            OnObfuscationEnd?.Invoke(new ObfuscationEndEventArgs
            {
                success = succ,
                originalScriptAssembliesPath = backupPlayerScriptAssembliesPath,
                obfuscatedScriptAssembliesPath = stagingAreaTempManagedDllDir,
            });

            Debug.Log("Obfuscation end.");
        }
    }
#endif
}

```

`Editor/Unity/ObfuscationProcess.cs.meta`:

```meta
fileFormatVersion: 2
guid: fc7a8b1e20c66164699de44d0a302cb7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Unity/ObfuzMenu.cs`:

```cs
using Obfuz.EncryptionVM;
using Obfuz.GarbageCodeGeneration;
using Obfuz.Settings;
using Obfuz.Utils;
using System.IO;
using UnityEditor;
using UnityEngine;
using FileUtil = Obfuz.Utils.FileUtil;

namespace Obfuz.Unity
{
    public static class ObfuzMenu
    {

        [MenuItem("Obfuz/Settings...", priority = 1)]
        public static void OpenSettings() => SettingsService.OpenProjectSettings("Project/Obfuz");

        [MenuItem("Obfuz/GenerateEncryptionVM", priority = 62)]
        public static void GenerateEncryptionVM()
        {
            EncryptionVMSettings settings = ObfuzSettings.Instance.encryptionVMSettings;
            var generator = new VirtualMachineCodeGenerator(settings.codeGenerationSecretKey, settings.encryptionOpCodeCount);
            generator.Generate(settings.codeOutputPath);
            AssetDatabase.Refresh();
        }

        [MenuItem("Obfuz/GenerateSecretKeyFile", priority = 63)]
        public static void SaveSecretFile()
        {
            SecretSettings settings = ObfuzSettings.Instance.secretSettings;

            var staticSecretBytes = KeyGenerator.GenerateKey(settings.defaultStaticSecretKey, VirtualMachine.SecretKeyLength);
            SaveKey(staticSecretBytes, settings.staticSecretKeyOutputPath);
            Debug.Log($"Save static secret key to {settings.staticSecretKeyOutputPath}");
            var dynamicSecretBytes = KeyGenerator.GenerateKey(settings.defaultDynamicSecretKey, VirtualMachine.SecretKeyLength);
            SaveKey(dynamicSecretBytes, settings.dynamicSecretKeyOutputPath);
            Debug.Log($"Save dynamic secret key to {settings.dynamicSecretKeyOutputPath}");
            AssetDatabase.Refresh();
        }

        [MenuItem("Obfuz/GarbageCode/GenerateCodes", priority = 100)]
        public static void GenerateGarbageCodes()
        {
            Debug.Log($"Generating garbage codes begin.");
            GarbageCodeGenerationSettings settings = ObfuzSettings.Instance.garbageCodeGenerationSettings;
            var generator = new GarbageCodeGenerator(settings);
            generator.Generate();
            AssetDatabase.Refresh();
            Debug.Log($"Generating garbage codes end.");
        }

        [MenuItem("Obfuz/GarbageCode/CleanGeneratedCodes", priority = 101)]
        public static void CleanGeneratedGarbageCodes()
        {
            Debug.Log($"Clean generated garbage codes begin.");
            GarbageCodeGenerationSettings settings = ObfuzSettings.Instance.garbageCodeGenerationSettings;
            var generator = new GarbageCodeGenerator(settings);
            generator.CleanCodes();
            AssetDatabase.Refresh();
            Debug.Log($"Clean generated garbage codes end.");
        }

        private static void SaveKey(byte[] secret, string secretOutputPath)
        {
            FileUtil.CreateParentDir(secretOutputPath);
            File.WriteAllBytes(secretOutputPath, secret);
        }

        [MenuItem("Obfuz/Documents/Quick Start")]
        public static void OpenQuickStart() => Application.OpenURL("https://www.obfuz.com/docs/beginner/quickstart");

        [MenuItem("Obfuz/Documents/FAQ")]
        public static void OpenFAQ() => Application.OpenURL("https://www.obfuz.com/docs/help/faq");

        [MenuItem("Obfuz/Documents/Common Errors")]
        public static void OpenCommonErrors() => Application.OpenURL("https://www.obfuz.com/docs/help/commonerrors");

        [MenuItem("Obfuz/Documents/Bug Report")]
        public static void OpenBugReport() => Application.OpenURL("https://www.obfuz.com/docs/help/issue");

        [MenuItem("Obfuz/Documents/GitHub")]
        public static void OpenGitHub() => Application.OpenURL("https://github.com/focus-creative-games/obfuz");

        [MenuItem("Obfuz/Documents/About")]
        public static void OpenAbout() => Application.OpenURL("https://www.obfuz.com/docs/intro");
    }

}
```

`Editor/Unity/ObfuzMenu.cs.meta`:

```meta
fileFormatVersion: 2
guid: ce8d804a6c4640e45a3d5c98b30c0c31
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Unity/UnityProjectManagedAssemblyResolver.cs`:

```cs
using Obfuz.Utils;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Obfuz.Unity
{
    public class UnityProjectManagedAssemblyResolver : AssemblyResolverBase
    {
        private readonly Dictionary<string, string> _managedAssemblyNameToPaths = new Dictionary<string, string>();

        public UnityProjectManagedAssemblyResolver(BuildTarget target)
        {
            string[] dllGuids = AssetDatabase.FindAssets("t:DefaultAsset");
            var dllPaths = dllGuids.Select(guid => AssetDatabase.GUIDToAssetPath(guid))
                .Where(f => f.EndsWith(".dll"))
                .Where(dllPath =>
                {
                    PluginImporter importer = AssetImporter.GetAtPath(dllPath) as PluginImporter;
                    if (importer == null || importer.isNativePlugin)
                    {
                        return false;
                    }
                    if (!importer.GetCompatibleWithAnyPlatform() && !importer.GetCompatibleWithPlatform(target))
                    {
                        return false;
                    }
                    return true;
                }).ToArray();

            foreach (string dllPath in dllPaths)
            {
                Debug.Log($"UnityProjectManagedAssemblyResolver find managed dll:{dllPath}");
                string assName = Path.GetFileNameWithoutExtension(dllPath);
                if (_managedAssemblyNameToPaths.TryGetValue(assName, out var existAssPath))
                {
                    Debug.LogWarning($"UnityProjectManagedAssemblyResolver find duplicate assembly1:{existAssPath} assembly2:{dllPath}");
                }
                else
                {
                    _managedAssemblyNameToPaths.Add(Path.GetFileNameWithoutExtension(dllPath), dllPath);
                }
            }
        }

        public override string ResolveAssembly(string assemblyName)
        {
            if (_managedAssemblyNameToPaths.TryGetValue(assemblyName, out string assemblyPath))
            {
                return assemblyPath;
            }
            return null;
        }
    }
}

```

`Editor/Unity/UnityProjectManagedAssemblyResolver.cs.meta`:

```meta
fileFormatVersion: 2
guid: 20abbffaf6419c448883ffaa21949753
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils.meta`:

```meta
fileFormatVersion: 2
guid: ade28aaad1116b143a4027071e71010f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/AssemblyCache.cs`:

```cs
using dnlib.DotNet;
using System.Collections.Generic;
using System.IO;

namespace Obfuz.Utils
{

    public class AssemblyCache
    {
        private readonly IAssemblyResolver _assemblyPathResolver;
        private readonly ModuleContext _modCtx;
        private readonly AssemblyResolver _asmResolver;
        private bool _enableTypeDefCache;


        public ModuleContext ModCtx => _modCtx;

        public Dictionary<string, ModuleDefMD> LoadedModules { get; } = new Dictionary<string, ModuleDefMD>();

        public AssemblyCache(IAssemblyResolver assemblyResolver)
        {
            _enableTypeDefCache = true;
            _assemblyPathResolver = assemblyResolver;
            _modCtx = ModuleDef.CreateModuleContext();
            _asmResolver = (AssemblyResolver)_modCtx.AssemblyResolver;
            _asmResolver.EnableTypeDefCache = _enableTypeDefCache;
            _asmResolver.UseGAC = false;
        }

        public bool EnableTypeDefCache
        {
            get => _enableTypeDefCache;
            set
            {
                _enableTypeDefCache = value;
                _asmResolver.EnableTypeDefCache = value;
                foreach (var mod in LoadedModules.Values)
                {
                    mod.EnableTypeDefFindCache = value;
                }
            }
        }


        public ModuleDefMD TryLoadModule(string moduleName)
        {
            string dllPath = _assemblyPathResolver.ResolveAssembly(moduleName);
            if (string.IsNullOrEmpty(dllPath))
            {
                return null;
            }
            return LoadModule(moduleName);
        }

        public ModuleDefMD LoadModule(string moduleName)
        {
            // Debug.Log($"load module:{moduleName}");
            if (LoadedModules.TryGetValue(moduleName, out var mod))
            {
                return mod;
            }
            string assemblyPath = _assemblyPathResolver.ResolveAssembly(moduleName);
            if (string.IsNullOrEmpty(assemblyPath))
            {
                throw new FileNotFoundException($"Assembly {moduleName} not found");
            }
            mod = DoLoadModule(assemblyPath);
            LoadedModules.Add(moduleName, mod);


            foreach (var refAsm in mod.GetAssemblyRefs())
            {
                LoadModule(refAsm.Name);
            }

            return mod;
        }

        private ModuleDefMD DoLoadModule(string dllPath)
        {
            //Debug.Log($"do load module:{dllPath}");
            ModuleDefMD mod = ModuleDefMD.Load(File.ReadAllBytes(dllPath), _modCtx);
            mod.EnableTypeDefFindCache = _enableTypeDefCache;
            _asmResolver.AddToCache(mod);
            return mod;
        }
    }
}

```

`Editor/Utils/AssemblyCache.cs.meta`:

```meta
fileFormatVersion: 2
guid: ce64ad992f9807d4994d4f41a54b170b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/AssemblyResolverBase.cs`:

```cs
namespace Obfuz.Utils
{
    public abstract class AssemblyResolverBase : IAssemblyResolver
    {
        public abstract string ResolveAssembly(string assemblyName);
    }
}

```

`Editor/Utils/AssemblyResolverBase.cs.meta`:

```meta
fileFormatVersion: 2
guid: c7332848ca18498459e6248d06bc5b31
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/AssertUtil.cs`:

```cs
using UnityEngine.Assertions;

namespace Obfuz.Utils
{
    public static class AssertUtil
    {
        private static bool IsArrayEqual(byte[] a, byte[] b)
        {
            if (a.Length != b.Length)
            {
                return false;
            }
            for (int i = 0; i < a.Length; i++)
            {
                if (a[i] != b[i])
                {
                    return false;
                }
            }
            return true;
        }

        public static void AreArrayEqual(byte[] expected, byte[] actual, string message)
        {
            Assert.IsTrue(IsArrayEqual(expected, actual), message);
        }
    }
}

```

`Editor/Utils/AssertUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: aba0c82c527b6494ab5c9c67c25656ed
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/BurstCompileComputeCache.cs`:

```cs
using dnlib.DotNet;
using System.Collections.Generic;

namespace Obfuz.Utils
{
    public class BurstCompileComputeCache
    {
        private readonly List<ModuleDef> _modulesToObfuscate;
        private readonly List<ModuleDef> _allObfuscationRelativeModules;

        private readonly HashSet<MethodDef> _burstCompileMethods = new HashSet<MethodDef>();
        private readonly HashSet<MethodDef> _burstCompileRelativeMethods = new HashSet<MethodDef>();
        public BurstCompileComputeCache(List<ModuleDef> modulesToObfuscate, List<ModuleDef> allObfuscationRelativeModules)
        {
            _modulesToObfuscate = modulesToObfuscate;
            _allObfuscationRelativeModules = allObfuscationRelativeModules;
            Build();
        }


        private void BuildBurstCompileMethods()
        {
            foreach (var module in _allObfuscationRelativeModules)
            {
                foreach (var type in module.GetTypes())
                {
                    bool hasBurstCompileAttribute = MetaUtil.HasBurstCompileAttribute(type);
                    foreach (var method in type.Methods)
                    {
                        if (hasBurstCompileAttribute || MetaUtil.HasBurstCompileAttribute(method))
                        {
                            _burstCompileMethods.Add(method);
                        }
                    }
                }
            }
        }

        private void CollectBurstCompileReferencedMethods()
        {
            var modulesToObfuscateSet = new HashSet<ModuleDef>(_modulesToObfuscate);
            var allObfuscationRelativeModulesSet = new HashSet<ModuleDef>(_allObfuscationRelativeModules);

            var pendingWalking = new Queue<MethodDef>(_burstCompileMethods);
            var visitedMethods = new HashSet<MethodDef>();
            while (pendingWalking.Count > 0)
            {
                var method = pendingWalking.Dequeue();

                if (!visitedMethods.Add(method))
                {
                    continue; // Skip already visited methods
                }
                if (modulesToObfuscateSet.Contains(method.Module))
                {
                    _burstCompileRelativeMethods.Add(method);
                }
                if (!method.HasBody)
                {
                    continue;
                }
                // Check for calls to other methods
                foreach (var instruction in method.Body.Instructions)
                {
                    if (instruction.OpCode.Code == dnlib.DotNet.Emit.Code.Call ||
                        instruction.OpCode.Code == dnlib.DotNet.Emit.Code.Callvirt)
                    {
                        MethodDef calledMethod = ((IMethod)instruction.Operand).ResolveMethodDef();
                        if (calledMethod == null || !allObfuscationRelativeModulesSet.Contains(calledMethod.Module) || visitedMethods.Contains(calledMethod))
                        {
                            continue; // Skip if the method could not be resolved
                        }
                        pendingWalking.Enqueue(calledMethod);
                    }
                }
            }
        }

        private void Build()
        {
            BuildBurstCompileMethods();
            CollectBurstCompileReferencedMethods();
        }

        public bool IsBurstCompileMethodOrReferencedByBurstCompileMethod(MethodDef method)
        {
            return _burstCompileRelativeMethods.Contains(method);
        }
    }
}

```

`Editor/Utils/BurstCompileComputeCache.cs.meta`:

```meta
fileFormatVersion: 2
guid: 37efeee0ad0b5c34e84bd1b7b401672a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/CachedDictionary.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Obfuz.Utils
{
    public class CachedDictionary<K, V>
    {
        private readonly Func<K, V> _valueFactory;
        private readonly Dictionary<K, V> _cache;

        public CachedDictionary(Func<K, V> valueFactory)
        {
            _cache = new Dictionary<K, V>();
            _valueFactory = valueFactory;
        }

        public CachedDictionary(IEqualityComparer<K> equalityComparer, Func<K, V> valueFactory)
        {
            _cache = new Dictionary<K, V>(equalityComparer);
            _valueFactory = valueFactory;
        }

        public V GetValue(K key)
        {
            if (!_cache.TryGetValue(key, out var value))
            {
                value = _valueFactory(key);
                _cache[key] = value;
            }
            return value;
        }
    }
}

```

`Editor/Utils/CachedDictionary.cs.meta`:

```meta
fileFormatVersion: 2
guid: 66494da674feeb741b889590cb663d4e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/CollectionExtensions.cs`:

```cs
using System.Collections.Generic;

namespace Obfuz.Utils
{
    public static class CollectionExtensions
    {
        public static void AddRange<T>(this HashSet<T> values, IEnumerable<T> newValues)
        {
            foreach (var value in newValues)
            {
                values.Add(value);
            }
        }

        public static V GetValueOrDefault<K, V>(this Dictionary<K, V> dic, K key)
        {
            return dic.TryGetValue(key, out V v) ? v : default(V);
        }
    }
}

```

`Editor/Utils/CollectionExtensions.cs.meta`:

```meta
fileFormatVersion: 2
guid: 58fc4438f86bc174aba662f1d7058f45
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/CombinedAssemblyResolver.cs`:

```cs
using System.Collections.Generic;
using System.Linq;

namespace Obfuz.Utils
{
    public class CombinedAssemblyResolver : AssemblyResolverBase
    {
        private readonly List<IAssemblyResolver> _resolvers;

        public CombinedAssemblyResolver(params IAssemblyResolver[] resolvers)
        {
            _resolvers = resolvers.ToList();
        }

        public override string ResolveAssembly(string assemblyName)
        {
            foreach (var resolver in _resolvers)
            {
                var assemblyPath = resolver.ResolveAssembly(assemblyName);
                if (assemblyPath != null)
                {
                    return assemblyPath;
                }
            }
            return null;
        }

        public void InsertFirst(IAssemblyResolver resolver)
        {
            _resolvers.Insert(0, resolver);
        }
    }
}

```

`Editor/Utils/CombinedAssemblyResolver.cs.meta`:

```meta
fileFormatVersion: 2
guid: 1576f3534f31509458104d2a7ebcd9cc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/ConfigUtil.cs`:

```cs
using Obfuz.Settings;
using System;

namespace Obfuz.Utils
{
    public static class ConfigUtil
    {

        public static bool ParseBool(string str)
        {
            switch (str.ToLowerInvariant())
            {
                case "1":
                case "true": return true;
                case "0":
                case "false": return false;
                default: throw new Exception($"Invalid bool value {str}");
            }
        }

        public static bool? ParseNullableBool(string str)
        {
            if (string.IsNullOrEmpty(str))
            {
                return null;
            }
            switch (str.ToLowerInvariant())
            {
                case "1":
                case "true": return true;
                case "0":
                case "false": return false;
                default: throw new Exception($"Invalid bool value {str}");
            }
        }

        public static int? ParseNullableInt(string str)
        {
            if (string.IsNullOrEmpty(str))
            {
                return null;
            }
            return int.Parse(str);
        }

        public static long? ParseNullableLong(string str)
        {
            if (string.IsNullOrEmpty(str))
            {
                return null;
            }
            return long.Parse(str);
        }

        public static float? ParseNullableFloat(string str)
        {
            if (string.IsNullOrEmpty(str))
            {
                return null;
            }
            return float.Parse(str);
        }

        public static double? ParseNullableDouble(string str)
        {
            if (string.IsNullOrEmpty(str))
            {
                return null;
            }
            return double.Parse(str);
        }

        public static ObfuscationLevel ParseObfuscationLevel(string str)
        {
            return (ObfuscationLevel)Enum.Parse(typeof(ObfuscationLevel), str);
        }
    }
}

```

`Editor/Utils/ConfigUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: ff35a8e07f37adf4483eaf5cc5da5c78
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/ConstObfusUtil.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuz.Data;
using System.Collections.Generic;

namespace Obfuz.Utils
{
    internal static class ConstObfusUtil
    {
        public static void LoadConstInt(int a, IRandom random, float constProbability, ConstFieldAllocator constFieldAllocator, List<Instruction> outputInsts)
        {
            Instruction inst;
            if (random.NextInPercentage(constProbability))
            {
                inst = Instruction.Create(OpCodes.Ldc_I4, a);
            }
            else
            {
                FieldDef field = constFieldAllocator.Allocate(a);
                inst = Instruction.Create(OpCodes.Ldsfld, field);
            }
            outputInsts.Add(inst);
        }

        public static void LoadConstLong(long a, IRandom random, float constProbability, ConstFieldAllocator constFieldAllocator, List<Instruction> outputInsts)
        {
            Instruction inst;
            if (random.NextInPercentage(constProbability))
            {
                inst = Instruction.Create(OpCodes.Ldc_I8, a);
            }
            else
            {
                FieldDef field = constFieldAllocator.Allocate(a);
                inst = Instruction.Create(OpCodes.Ldsfld, field);
            }
            outputInsts.Add(inst);
        }

        public static void LoadConstFloat(float a, IRandom random, float constProbability, ConstFieldAllocator constFieldAllocator, List<Instruction> outputInsts)
        {
            Instruction inst;
            if (random.NextInPercentage(constProbability))
            {
                inst = Instruction.Create(OpCodes.Ldc_R4, a);
            }
            else
            {
                FieldDef field = constFieldAllocator.Allocate(a);
                inst = Instruction.Create(OpCodes.Ldsfld, field);
            }
            outputInsts.Add(inst);
        }

        public static void LoadConstDouble(double a, IRandom random, float constProbability, ConstFieldAllocator constFieldAllocator, List<Instruction> outputInsts)
        {
            Instruction inst;
            if (random.NextInPercentage(constProbability))
            {
                inst = Instruction.Create(OpCodes.Ldc_R8, a);
            }
            else
            {
                FieldDef field = constFieldAllocator.Allocate(a);
                inst = Instruction.Create(OpCodes.Ldsfld, field);
            }
            outputInsts.Add(inst);
        }


        public static void LoadConstTwoInt(int a, int b, IRandom random, float constProbability, ConstFieldAllocator constFieldAllocator, List<Instruction> outputInsts)
        {
            if (random.NextInPercentage(constProbability))
            {
                outputInsts.Add(Instruction.Create(OpCodes.Ldc_I4, a));

                // at most one ldc instruction
                FieldDef field = constFieldAllocator.Allocate(b);
                outputInsts.Add(Instruction.Create(OpCodes.Ldsfld, field));
            }
            else
            {
                FieldDef field = constFieldAllocator.Allocate(a);
                outputInsts.Add(Instruction.Create(OpCodes.Ldsfld, field));

                if (random.NextInPercentage(constProbability))
                {
                    // at most one ldc instruction
                    outputInsts.Add(Instruction.Create(OpCodes.Ldc_I4, b));
                }
                else
                {
                    field = constFieldAllocator.Allocate(b);
                    outputInsts.Add(Instruction.Create(OpCodes.Ldsfld, field));
                }
            }
        }

        public static void LoadConstTwoLong(long a, long b, IRandom random, float constProbability, ConstFieldAllocator constFieldAllocator, List<Instruction> outputInsts)
        {
            if (random.NextInPercentage(constProbability))
            {
                outputInsts.Add(Instruction.Create(OpCodes.Ldc_I8, a));
                // at most one ldc instruction
                FieldDef field = constFieldAllocator.Allocate(b);
                outputInsts.Add(Instruction.Create(OpCodes.Ldsfld, field));
            }
            else
            {
                FieldDef field = constFieldAllocator.Allocate(a);
                outputInsts.Add(Instruction.Create(OpCodes.Ldsfld, field));
                if (random.NextInPercentage(constProbability))
                {
                    // at most one ldc instruction
                    outputInsts.Add(Instruction.Create(OpCodes.Ldc_I8, b));
                }
                else
                {
                    field = constFieldAllocator.Allocate(b);
                    outputInsts.Add(Instruction.Create(OpCodes.Ldsfld, field));
                }
            }
        }

        public static void LoadConstTwoFloat(float a, float b, IRandom random, float constProbability, ConstFieldAllocator constFieldAllocator, List<Instruction> outputInsts)
        {
            if (random.NextInPercentage(constProbability))
            {
                outputInsts.Add(Instruction.Create(OpCodes.Ldc_R4, a));
                // at most one ldc instruction
                FieldDef field = constFieldAllocator.Allocate(b);
                outputInsts.Add(Instruction.Create(OpCodes.Ldsfld, field));
            }
            else
            {
                FieldDef field = constFieldAllocator.Allocate(a);
                outputInsts.Add(Instruction.Create(OpCodes.Ldsfld, field));
                if (random.NextInPercentage(constProbability))
                {
                    // at most one ldc instruction
                    outputInsts.Add(Instruction.Create(OpCodes.Ldc_R4, b));
                }
                else
                {
                    field = constFieldAllocator.Allocate(b);
                    outputInsts.Add(Instruction.Create(OpCodes.Ldsfld, field));
                }
            }
        }

        public static void LoadConstTwoDouble(double a, double b, IRandom random, float constProbability, ConstFieldAllocator constFieldAllocator, List<Instruction> outputInsts)
        {
            if (random.NextInPercentage(constProbability))
            {
                outputInsts.Add(Instruction.Create(OpCodes.Ldc_R8, a));
                // at most one ldc instruction
                FieldDef field = constFieldAllocator.Allocate(b);
                outputInsts.Add(Instruction.Create(OpCodes.Ldsfld, field));
            }
            else
            {
                FieldDef field = constFieldAllocator.Allocate(a);
                outputInsts.Add(Instruction.Create(OpCodes.Ldsfld, field));
                if (random.NextInPercentage(constProbability))
                {
                    // at most one ldc instruction
                    outputInsts.Add(Instruction.Create(OpCodes.Ldc_R8, b));
                }
                else
                {
                    field = constFieldAllocator.Allocate(b);
                    outputInsts.Add(Instruction.Create(OpCodes.Ldsfld, field));
                }
            }
        }
    }
}

```

`Editor/Utils/ConstObfusUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: 4330e358b953be54c9f1ada2ff34156d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/DisableTypeDefFindCacheScope.cs`:

```cs
using dnlib.DotNet;
using System;

namespace Obfuz.Utils
{
    public class DisableTypeDefFindCacheScope : IDisposable
    {
        private readonly ModuleDef _module;

        public DisableTypeDefFindCacheScope(ModuleDef module)
        {
            _module = module;
            _module.EnableTypeDefFindCache = false;
        }

        public void Dispose()
        {
            _module.EnableTypeDefFindCache = true;
        }
    }
}

```

`Editor/Utils/DisableTypeDefFindCacheScope.cs.meta`:

```meta
fileFormatVersion: 2
guid: 89640cb831c78f8429c861fb49bae0e7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/EncryptionUtil.cs`:

```cs
using System;
using UnityEngine;

namespace Obfuz.Utils
{
    public static class EncryptionUtil
    {
        public static int GetBitCount(int value)
        {
            int count = 0;
            while (value > 0)
            {
                count++;
                value >>= 1;
            }
            return count;
        }

        public static int GenerateEncryptionOpCodes(IRandom random, IEncryptor encryptor, int encryptionLevel)
        {
            if (encryptionLevel <= 0 || encryptionLevel > 4)
            {
                throw new ArgumentException($"Invalid encryption level: {encryptionLevel}, should be in range [1,4]");
            }
            int vmOpCodeCount = encryptor.OpCodeCount;
            long ops = 0;
            for (int i = 0; i < encryptionLevel; i++)
            {
                long newOps = ops * vmOpCodeCount;
                // don't use 0
                int op = random.NextInt(1, vmOpCodeCount);
                newOps |= (uint)op;
                if (newOps > uint.MaxValue)
                {
                    Debug.LogWarning($"OpCode overflow. encryptionLevel:{encryptionLevel}, vmOpCodeCount:{vmOpCodeCount}");
                }
                else
                {
                    ops = newOps;
                }
            }
            return (int)ops;
        }
    }
}

```

`Editor/Utils/EncryptionUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0b8fc4c92fa6f0b40a9734b347cd265c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/FileUtil.cs`:

```cs
using System;
using System.IO;
using System.Threading;

namespace Obfuz.Utils
{
    public static class FileUtil
    {
        public static void CreateParentDir(string path)
        {
            Directory.CreateDirectory(Path.GetDirectoryName(path));
        }

        public static void RemoveDir(string dir, bool log = false)
        {
            if (log)
            {
                UnityEngine.Debug.Log($"removeDir dir:{dir}");
            }

            int maxTryCount = 5;
            for (int i = 0; i < maxTryCount; ++i)
            {
                try
                {
                    if (!Directory.Exists(dir))
                    {
                        return;
                    }
                    foreach (var file in Directory.GetFiles(dir))
                    {
                        File.SetAttributes(file, FileAttributes.Normal);
                        File.Delete(file);
                    }
                    foreach (var subDir in Directory.GetDirectories(dir))
                    {
                        RemoveDir(subDir);
                    }
                    Directory.Delete(dir, true);
                    break;
                }
                catch (Exception e)
                {
                    UnityEngine.Debug.LogError($"removeDir:{dir} with exception:{e}. try count:{i}");
                    Thread.Sleep(100);
                }
            }
        }

        public static void RecreateDir(string dir)
        {
            if (Directory.Exists(dir))
            {
                RemoveDir(dir, true);
            }
            Directory.CreateDirectory(dir);
        }

        private static void CopyWithCheckLongFile(string srcFile, string dstFile)
        {
            var maxPathLength = 255;
#if UNITY_EDITOR_OSX
            maxPathLength = 1024;
#endif
            if (srcFile.Length > maxPathLength)
            {
                UnityEngine.Debug.LogError($"srcFile:{srcFile} path is too long. skip copy!");
                return;
            }
            if (dstFile.Length > maxPathLength)
            {
                UnityEngine.Debug.LogError($"dstFile:{dstFile} path is too long. skip copy!");
                return;
            }
            File.Copy(srcFile, dstFile);
        }

        public static void CopyDir(string src, string dst, bool log = false)
        {
            if (log)
            {
                UnityEngine.Debug.Log($"copyDir {src} => {dst}");
            }
            RemoveDir(dst);
            Directory.CreateDirectory(dst);
            foreach (var file in Directory.GetFiles(src))
            {
                CopyWithCheckLongFile(file, $"{dst}/{Path.GetFileName(file)}");
            }
            foreach (var subDir in Directory.GetDirectories(src))
            {
                CopyDir(subDir, $"{dst}/{Path.GetFileName(subDir)}");
            }
        }
    }
}

```

`Editor/Utils/FileUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: b6385af8bd061b142a3d7dcf41ab7e79
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/GenericArgumentContext.cs`:

```cs
using dnlib.DotNet;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Obfuz.Utils
{
    public sealed class GenericArgumentContext
    {
        public readonly List<TypeSig> typeArgsStack;
        public readonly List<TypeSig> methodArgsStack;

        public GenericArgumentContext(IList<TypeSig> typeArgsStack, IList<TypeSig> methodArgsStack)
        {
            this.typeArgsStack = typeArgsStack?.ToList();
            this.methodArgsStack = methodArgsStack?.ToList();
        }

        public TypeSig Resolve(TypeSig typeSig)
        {
            if (!typeSig.ContainsGenericParameter)
            {
                return typeSig;
            }
            typeSig = typeSig.RemovePinnedAndModifiers();
            switch (typeSig.ElementType)
            {
                case ElementType.Ptr: return new PtrSig(Resolve(typeSig.Next));
                case ElementType.ByRef: return new ByRefSig(Resolve(typeSig.Next));

                case ElementType.SZArray: return new SZArraySig(Resolve(typeSig.Next));
                case ElementType.Array:
                {
                    var ara = (ArraySig)typeSig;
                    return new ArraySig(Resolve(typeSig.Next), ara.Rank, ara.Sizes, ara.LowerBounds);
                }

                case ElementType.Var:
                {
                    GenericVar genericVar = (GenericVar)typeSig;
                    var newSig = Resolve(typeArgsStack, genericVar.Number);
                    if (newSig == null)
                    {
                        throw new Exception();
                    }
                    return newSig;
                }

                case ElementType.MVar:
                {
                    GenericMVar genericVar = (GenericMVar)typeSig;
                    var newSig = Resolve(methodArgsStack, genericVar.Number);
                    if (newSig == null)
                    {
                        throw new Exception();
                    }
                    return newSig;
                }
                case ElementType.GenericInst:
                {
                    var gia = (GenericInstSig)typeSig;
                    return new GenericInstSig(gia.GenericType, gia.GenericArguments.Select(ga => Resolve(ga)).ToList());
                }

                case ElementType.FnPtr:
                {
                    var fptr = (FnPtrSig)typeSig;
                    var cs = fptr.Signature;
                    CallingConventionSig ccs;
                    switch (cs)
                    {
                        case MethodSig ms:
                        {
                            ccs = new MethodSig(ms.GetCallingConvention(), ms.GenParamCount, Resolve(ms.RetType), ms.Params.Select(p => Resolve(p)).ToList());
                            break;
                        }
                        case PropertySig ps:
                        {
                            ccs = new PropertySig(ps.HasThis, Resolve(ps.RetType));
                            break;
                        }
                        case GenericInstMethodSig gims:
                        {
                            ccs = new GenericInstMethodSig(gims.GenericArguments.Select(ga => Resolve(ga)).ToArray());
                            break;
                        }
                        default: throw new NotSupportedException(cs.ToString());
                    }
                    return new FnPtrSig(ccs);
                }

                case ElementType.ValueArray:
                {
                    var vas = (ValueArraySig)typeSig;
                    return new ValueArraySig(Resolve(vas.Next), vas.Size);
                }
                default: return typeSig;
            }
        }

        private TypeSig Resolve(List<TypeSig> args, uint number)
        {
            if (args == null)
            {
                throw new ArgumentNullException(nameof(args));
            }
            return args[(int)number];
        }
    }

}

```

`Editor/Utils/GenericArgumentContext.cs.meta`:

```meta
fileFormatVersion: 2
guid: cdefb4e144f6a98418c7bd02eab51039
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/HashUtil.cs`:

```cs
using dnlib.DotNet;
using System.Collections;
using System.Collections.Generic;

namespace Obfuz.Utils
{
    public static class HashUtil
    {
        public static int CombineHash(int hash1, int hash2)
        {
            return hash1 * 1566083941 + hash2;
        }

        public static int ComputeHash(TypeSig sig)
        {
            return TypeEqualityComparer.Instance.GetHashCode(sig);
        }

        public static int ComputeHash(IList<TypeSig> sigs)
        {
            int hash = 135781321;
            TypeEqualityComparer tc = TypeEqualityComparer.Instance;
            foreach (var sig in sigs)
            {
                hash = hash * 1566083941 + tc.GetHashCode(sig);
            }
            return hash;
        }

        public static unsafe int ComputeHash(string s)
        {
            fixed (char* ptr = s)
            {
                int num = 352654597;
                int num2 = num;
                int* ptr2 = (int*)ptr;
                int num3;
                for (num3 = s.Length; num3 > 2; num3 -= 4)
                {
                    num = ((num << 5) + num + (num >> 27)) ^ *ptr2;
                    num2 = ((num2 << 5) + num2 + (num2 >> 27)) ^ ptr2[1];
                    ptr2 += 2;
                }

                if (num3 > 0)
                {
                    num = ((num << 5) + num + (num >> 27)) ^ *ptr2;
                }

                return num + num2 * 1566083941;
            }
        }

        public static int ComputePrimitiveOrStringOrBytesHashCode(object obj)
        {
            if (obj is byte[] bytes)
            {
                return StructuralComparisons.StructuralEqualityComparer.GetHashCode(bytes);
            }
            if (obj is string s)
            {
                return HashUtil.ComputeHash(s);
            }
            return obj.GetHashCode();
        }
    }
}

```

`Editor/Utils/HashUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0b4cd05dd413bfa4ebb9fcbe591b1486
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/IAssemblyResolver.cs`:

```cs
namespace Obfuz.Utils
{
    public interface IAssemblyResolver
    {
        string ResolveAssembly(string assemblyName);
    }
}

```

`Editor/Utils/IAssemblyResolver.cs.meta`:

```meta
fileFormatVersion: 2
guid: e0254d9726a78e146af99a61641b47d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/IRandom.cs`:

```cs
namespace Obfuz.Utils
{
    public interface IRandom
    {
        int NextInt(int min, int max);

        int NextInt(int max);

        int NextInt();

        long NextLong();

        float NextFloat();

        bool NextInPercentage(float percentage);
    }
}

```

`Editor/Utils/IRandom.cs.meta`:

```meta
fileFormatVersion: 2
guid: 959c821ff51056c4ebca3f89aeeff03d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/KeyGenerator.cs`:

```cs
using System;
using System.Security.Cryptography;
using System.Text;

namespace Obfuz.Utils
{
    public static class KeyGenerator
    {
        public static byte[] GenerateKey(string initialString, int keyLength)
        {
            byte[] initialBytes = Encoding.UTF8.GetBytes(initialString);
            using (var sha512 = SHA512.Create())
            {
                byte[] hash = sha512.ComputeHash(initialBytes);
                byte[] key = new byte[keyLength];
                int bytesCopied = 0;
                while (bytesCopied < key.Length)
                {
                    if (bytesCopied > 0)
                    {
                        // 再次哈希之前的哈希值以生成更多数据
                        hash = sha512.ComputeHash(hash);
                    }
                    int bytesToCopy = Math.Min(hash.Length, key.Length - bytesCopied);
                    Buffer.BlockCopy(hash, 0, key, bytesCopied, bytesToCopy);
                    bytesCopied += bytesToCopy;
                }
                return key;
            }
        }

        public static int[] ConvertToIntKey(byte[] key)
        {
            return EncryptorBase.ConvertToIntKey(key);
        }
    }
}

```

`Editor/Utils/KeyGenerator.cs.meta`:

```meta
fileFormatVersion: 2
guid: 5441ac16fd88a8848af862be23bd2ecb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/MathUtil.cs`:

```cs
using System;

namespace Obfuz.Utils
{

    internal static class MathUtil
    {
        //public static int ModInverseOdd32(int sa)
        //{
        //    uint a = (uint)sa;
        //    if (a % 2 == 0)
        //        throw new ArgumentException("Input must be an odd number.", nameof(a));

        //    uint x = 1; // 初始解：x₀ = 1 (mod 2)
        //    for (int i = 0; i < 5; i++) // 迭代5次（2^1 → 2^32）
        //    {
        //        int shift = 2 << i;        // 当前模数为 2^(2^(i+1))
        //        ulong mod = 1UL << shift; // 使用 ulong 避免溢出
        //        ulong ax = (ulong)a * x;  // 计算 a*x（64位避免截断）
        //        ulong term = (2 - ax) % mod;
        //        x = (uint)((x * term) % mod); // 更新 x，结果截断为 uint
        //    }
        //    return (int)x; // 最终解为 x₅ mod 2^32
        //}

        public static int ModInverse32(int sa)
        {
            uint x = (uint)sa;
            if ((x & 1) == 0)
                throw new ArgumentException("x must be odd (coprime with 2^32)");

            uint inv = x;
            inv = inv * (2 - x * inv); // 1
            inv = inv * (2 - x * inv); // 2
            inv = inv * (2 - x * inv); // 3
            inv = inv * (2 - x * inv); // 4
            inv = inv * (2 - x * inv); // 5
            return (int)inv;
        }

        public static long ModInverse64(long sx)
        {
            ulong x = (ulong)sx;
            if ((x & 1) == 0)
                throw new ArgumentException("x must be odd (coprime with 2^64)");

            ulong inv = x;
            inv *= 2 - x * inv; // 1
            inv *= 2 - x * inv; // 2
            inv *= 2 - x * inv; // 3
            inv *= 2 - x * inv; // 4
            inv *= 2 - x * inv; // 5
            inv *= 2 - x * inv; // 6

            return (long)inv;
        }
    }
}

```

`Editor/Utils/MathUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: 8d5962b5e88adac40a2b1c65a8d304bc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/MetaUtil.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Editor;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine.Assertions;

namespace Obfuz.Utils
{

    public static class MetaUtil
    {
        public static string GetModuleNameWithoutExt(string moduleName)
        {
            return Path.GetFileNameWithoutExtension(moduleName);
        }

        public static (string, string) SplitNamespaceAndName(string fullName)
        {
            int index = fullName.LastIndexOf('/');
            if (index == -1)
            {
                int index2 = fullName.IndexOf('.');
                return index2 >= 0 ? (fullName.Substring(0, index2), fullName.Substring(index2 + 1)) : ("", fullName);
            }
            return ("", fullName.Substring(index + 1));
        }

        public static bool IsVoidType(TypeSig type)
        {
            return type.RemovePinnedAndModifiers().ElementType == ElementType.Void;
        }

        public static TypeDef GetBaseTypeDef(TypeDef type)
        {
            ITypeDefOrRef baseType = type.BaseType;
            if (baseType == null)
            {
                return null;
            }
            TypeDef baseTypeDef = baseType.ResolveTypeDef();
            if (baseTypeDef != null)
            {
                return baseTypeDef;
            }
            if (baseType is TypeSpec baseTypeSpec)
            {
                GenericInstSig genericIns = baseTypeSpec.TypeSig.ToGenericInstSig();
                return genericIns.GenericType.TypeDefOrRef.ResolveTypeDefThrow();
            }
            else
            {
                throw new Exception($"GetBaseTypeDef: {type} fail");
            }
        }

        public static TypeDef GetTypeDefOrGenericTypeBaseThrowException(ITypeDefOrRef type)
        {
            if (type.IsTypeDef)
            {
                return (TypeDef)type;
            }
            if (type.IsTypeRef)
            {
                return type.ResolveTypeDefThrow();
            }
            if (type.IsTypeSpec)
            {
                GenericInstSig gis = type.TryGetGenericInstSig();
                return gis.GenericType.ToTypeDefOrRef().ResolveTypeDefThrow();
            }
            throw new NotSupportedException($"{type}");
        }

        public static TypeDef GetTypeDefOrGenericTypeBaseOrNull(ITypeDefOrRef type)
        {
            if (type.IsTypeDef)
            {
                return (TypeDef)type;
            }
            if (type.IsTypeRef)
            {
                return type.ResolveTypeDefThrow();
            }
            if (type.IsTypeSpec)
            {
                GenericInstSig gis = type.TryGetGenericInstSig();
                if (gis == null)
                {
                    return null;
                }
                return gis.GenericType.ToTypeDefOrRef().ResolveTypeDefThrow();
            }
            return null;
        }

        public static TypeDef GetMemberRefTypeDefParentOrNull(IMemberRefParent parent)
        {
            if (parent is TypeDef typeDef)
            {
                return typeDef;
            }
            if (parent is TypeRef typeRef)
            {
                return typeRef.ResolveTypeDefThrow();
            }
            if (parent is TypeSpec typeSpec)
            {
                GenericInstSig gis = typeSpec.TryGetGenericInstSig();
                if (gis == null)
                {
                    return null;
                }
                return gis.GenericType.TypeDefOrRef.ResolveTypeDefThrow();
            }
            return null;
        }

        public static bool IsInheritFromDOTSTypes(TypeDef typeDef)
        {
            TypeDef cur = typeDef;
            while (true)
            {
                if (cur.Namespace.StartsWith("Unity.Entities") ||
                    //cur.Namespace.StartsWith("Unity.Jobs") ||
                    cur.Namespace.StartsWith("Unity.Burst"))
                {
                    return true;
                }
                foreach (var interfaceType in cur.Interfaces)
                {
                    TypeDef interfaceTypeDef = interfaceType.Interface.ResolveTypeDef();
                    if (interfaceTypeDef != null && (interfaceTypeDef.Namespace.StartsWith("Unity.Entities") ||
                        //interfaceTypeDef.Namespace.StartsWith("Unity.Jobs") ||
                        interfaceTypeDef.Namespace.StartsWith("Unity.Burst")))
                    {
                        return true;
                    }
                }

                cur = GetBaseTypeDef(cur);
                if (cur == null)
                {
                    return false;
                }
            }
        }

        public static bool IsInheritFromMonoBehaviour(TypeDef typeDef)
        {
            TypeDef cur = typeDef;
            while (true)
            {
                cur = GetBaseTypeDef(cur);
                if (cur == null)
                {
                    return false;
                }
                if (cur.Name == "MonoBehaviour" && cur.Namespace == "UnityEngine" && cur.Module.Name == "UnityEngine.CoreModule.dll")
                {
                    return true;
                }
            }
        }


        public static bool IsScriptType(TypeDef type)
        {
            for (TypeDef parentType = GetBaseTypeDef(type); parentType != null; parentType = GetBaseTypeDef(parentType))
            {
                if ((parentType.Name == "MonoBehaviour" || parentType.Name == "ScriptableObject")
                    && parentType.Namespace == "UnityEngine"
                    && parentType.Module.Assembly.Name == "UnityEngine.CoreModule")
                {
                    return true;
                }
            }

            return false;
        }

        public static bool IsSerializableType(TypeDef type)
        {
            return type.IsSerializable;
        }

        public static bool IsScriptOrSerializableType(TypeDef type)
        {
            return type.IsSerializable || IsScriptType(type);
        }

        public static bool IsSerializableTypeSig(TypeSig typeSig)
        {
            typeSig = typeSig.RemovePinnedAndModifiers();
            switch (typeSig.ElementType)
            {
                case ElementType.Boolean:
                case ElementType.Char:
                case ElementType.I1:
                case ElementType.U1:
                case ElementType.I2:
                case ElementType.U2:
                case ElementType.I4:
                case ElementType.U4:
                case ElementType.I8:
                case ElementType.U8:
                case ElementType.R4:
                case ElementType.R8:
                case ElementType.String:
                return true;
                case ElementType.Class:
                return IsScriptOrSerializableType(typeSig.ToTypeDefOrRef().ResolveTypeDefThrow());
                case ElementType.ValueType:
                {
                    TypeDef typeDef = typeSig.ToTypeDefOrRef().ResolveTypeDefThrow();
                    if (typeDef.IsEnum)
                    {
                        return true;
                    }
                    return typeDef.IsSerializable;
                }
                case ElementType.GenericInst:
                {
                    GenericInstSig genericIns = typeSig.ToGenericInstSig();
                    TypeDef typeDef = genericIns.GenericType.ToTypeDefOrRef().ResolveTypeDefThrow();
                    return typeDef.FullName == "System.Collections.Generic.List`1" && IsSerializableTypeSig(genericIns.GenericArguments[0]);
                }
                case ElementType.SZArray:
                {
                    return IsSerializableTypeSig(typeSig.RemovePinnedAndModifiers().Next);
                }
                default:
                return false;
            }
        }

        public static bool IsSerializableField(FieldDef field)
        {
            if (field.IsStatic)
            {
                return false;
            }
            var fieldSig = field.FieldSig.Type;
            if (field.IsPublic)
            {
                return IsSerializableTypeSig(fieldSig);
            }
            if (field.CustomAttributes.Any(c => c.TypeFullName == "UnityEngine.SerializeField"))
            {
                //UnityEngine.Debug.Assert(IsSerializableTypeSig(fieldSig));
                return true;
            }
            return false;
        }

        public static bool MayRenameCustomDataType(ElementType type)
        {
            return type == ElementType.Class || type == ElementType.ValueType || type == ElementType.Object || type == ElementType.SZArray;
        }

        public static TypeSig RetargetTypeRefInTypeSig(TypeSig type)
        {
            TypeSig next = type.Next;
            TypeSig newNext = next != null ? RetargetTypeRefInTypeSig(next) : null;
            if (type.IsModifier || type.IsPinned)
            {
                if (next == newNext)
                {
                    return type;
                }
                if (type is CModReqdSig cmrs)
                {
                    return new CModReqdSig(cmrs.Modifier, newNext);
                }
                if (type is CModOptSig cmos)
                {
                    return new CModOptSig(cmos.Modifier, newNext);
                }
                if (type is PinnedSig ps)
                {
                    return new PinnedSig(newNext);
                }
                throw new System.NotSupportedException(type.ToString());
            }
            switch (type.ElementType)
            {
                case ElementType.Ptr:
                {
                    if (next == newNext)
                    {
                        return type;
                    }
                    return new PtrSig(newNext);
                }
                case ElementType.ValueType:
                case ElementType.Class:
                {
                    var vts = type as ClassOrValueTypeSig;
                    if (vts.TypeDefOrRef is TypeDef typeDef)
                    {
                        return type;
                    }
                    TypeRef typeRef = (TypeRef)vts.TypeDefOrRef;
                    if (typeRef.DefinitionAssembly.IsCorLib())
                    {
                        return type;
                    }
                    typeDef = typeRef.ResolveTypeDefThrow();
                    return type.IsClassSig ? (TypeSig)new ClassSig(typeDef) : new ValueTypeSig(typeDef);
                }
                case ElementType.Array:
                {
                    if (next == newNext)
                    {
                        return type;
                    }
                    return new ArraySig(newNext);
                }
                case ElementType.SZArray:
                {
                    if (next == newNext)
                    {
                        return type;
                    }
                    return new SZArraySig(newNext);
                }
                case ElementType.GenericInst:
                {
                    var gis = type as GenericInstSig;
                    ClassOrValueTypeSig genericType = gis.GenericType;
                    ClassOrValueTypeSig newGenericType = (ClassOrValueTypeSig)RetargetTypeRefInTypeSig(genericType);
                    bool anyChange = genericType != newGenericType;
                    var genericArgs = new List<TypeSig>();
                    foreach (var arg in gis.GenericArguments)
                    {
                        TypeSig newArg = RetargetTypeRefInTypeSig(arg);
                        anyChange |= newArg != arg;
                        genericArgs.Add(newArg);
                    }
                    if (!anyChange)
                    {
                        return type;
                    }
                    return new GenericInstSig(newGenericType, genericArgs);
                }
                case ElementType.FnPtr:
                {
                    var fp = type as FnPtrSig;
                    MethodSig methodSig = fp.MethodSig;
                    TypeSig newReturnType = RetargetTypeRefInTypeSig(methodSig.RetType);
                    bool anyChange = newReturnType != methodSig.RetType;
                    var newArgs = new List<TypeSig>();
                    foreach (TypeSig arg in methodSig.Params)
                    {
                        TypeSig newArg = RetargetTypeRefInTypeSig(arg);
                        anyChange |= newArg != newReturnType;
                    }
                    if (!anyChange)
                    {
                        return type;
                    }
                    var newParamsAfterSentinel = new List<TypeSig>();
                    foreach (TypeSig arg in methodSig.ParamsAfterSentinel)
                    {
                        TypeSig newArg = RetargetTypeRefInTypeSig(arg);
                        anyChange |= newArg != arg;
                        newParamsAfterSentinel.Add(newArg);
                    }

                    var newMethodSig = new MethodSig(methodSig.CallingConvention, methodSig.GenParamCount, newReturnType, newArgs, newParamsAfterSentinel);
                    return new FnPtrSig(newMethodSig);
                }
                case ElementType.ByRef:
                {
                    if (next == newNext)
                    {
                        return type;
                    }
                    return new ByRefSig(newNext);
                }
                default:
                {
                    return type;
                }
            }
        }


        public static object RetargetTypeRefInTypeSigOfValue(object oldValue)
        {
            if (oldValue == null)
            {
                return null;
            }
            string typeName = oldValue.GetType().FullName;
            if (oldValue.GetType().IsPrimitive)
            {
                return oldValue;
            }
            if (oldValue is string || oldValue is UTF8String)
            {
                return oldValue;
            }
            if (oldValue is TypeSig typeSig)
            {
                return RetargetTypeRefInTypeSig(typeSig);
            }
            if (oldValue is CAArgument caValue)
            {
                TypeSig newType = RetargetTypeRefInTypeSig(caValue.Type);
                object newValue = RetargetTypeRefInTypeSigOfValue(caValue.Value);
                if (newType != caValue.Type || newValue != caValue.Value)
                {
                    return new CAArgument(newType, newValue);
                }
                return oldValue;
            }
            if (oldValue is List<CAArgument> oldArr)
            {
                bool anyChange = false;
                var newArr = new List<CAArgument>();
                foreach (CAArgument oldArg in oldArr)
                {
                    if (TryRetargetTypeRefInArgument(oldArg, out var newArg))
                    {
                        anyChange = true;
                        newArr.Add(newArg);
                    }
                    else
                    {
                        newArr.Add(oldArg);
                    }
                }
                return anyChange ? newArr : oldArr;
            }
            throw new NotSupportedException($"type:{oldValue.GetType()} value:{oldValue}");
        }



        public static bool TryRetargetTypeRefInArgument(CAArgument oldArg, out CAArgument newArg)
        {
            TypeSig newType = RetargetTypeRefInTypeSig(oldArg.Type);
            object newValue = RetargetTypeRefInTypeSigOfValue(oldArg.Value);
            if (newType != oldArg.Type || oldArg.Value != newValue)
            {
                newArg = new CAArgument(newType, newValue);
                return true;
            }
            newArg = default;
            return false;
        }

        public static bool TryRetargetTypeRefInNamedArgument(CANamedArgument arg)
        {
            bool anyChange = false;
            TypeSig newType = RetargetTypeRefInTypeSig(arg.Type);
            if (newType != arg.Type)
            {
                anyChange = true;
                arg.Type = newType;
            }
            if (TryRetargetTypeRefInArgument(arg.Argument, out var newArg))
            {
                arg.Argument = newArg;
                anyChange = true;
            }
            return anyChange;
        }

        //public static bool ContainsContainsGenericParameter1(MethodDef method)
        //{
        //    Assert.IsTrue(!(method.DeclaringType.ContainsGenericParameter || method.MethodSig.ContainsGenericParameter));
        //    return false;
        //}

        public static bool ContainsContainsGenericParameter1(MethodSpec methodSpec)
        {
            if (methodSpec.GenericInstMethodSig.ContainsGenericParameter)
            {
                return true;
            }
            IMethodDefOrRef method = methodSpec.Method;
            if (method.IsMethodDef)
            {
                return false;// ContainsContainsGenericParameter1((MethodDef)method);
            }
            if (method.IsMemberRef)
            {
                return ContainsContainsGenericParameter1((MemberRef)method);
            }
            throw new Exception($"unknown method: {method}");
        }

        public static bool ContainsContainsGenericParameter1(MemberRef memberRef)
        {
            IMemberRefParent parent = memberRef.Class;
            if (parent is TypeSpec typeSpec)
            {
                return typeSpec.ContainsGenericParameter;
            }
            return false;
        }

        public static bool ContainsContainsGenericParameter(IMethod method)
        {
            Assert.IsTrue(method.IsMethod);
            if (method is MethodDef methodDef)
            {
                return false;
            }

            if (method is MethodSpec methodSpec)
            {
                return ContainsContainsGenericParameter1(methodSpec);
            }
            if (method is MemberRef memberRef)
            {
                return ContainsContainsGenericParameter1(memberRef);
            }
            throw new Exception($"unknown method: {method}");
        }



        public static TypeSig Inflate(TypeSig sig, GenericArgumentContext ctx)
        {
            if (ctx == null || !sig.ContainsGenericParameter)
            {
                return sig;
            }
            return ctx.Resolve(sig);
        }

        public static IList<TypeSig> TryInflate(IList<TypeSig> sig, GenericArgumentContext ctx)
        {
            if (sig == null || ctx == null)
            {
                return sig;
            }
            return sig.Select(s => Inflate(s, ctx)).ToList() ?? null;
        }


        public static MethodSig InflateMethodSig(MethodSig methodSig, GenericArgumentContext genericArgumentContext)
        {
            var newReturnType = Inflate(methodSig.RetType, genericArgumentContext);
            var newParams = new List<TypeSig>();
            foreach (var param in methodSig.Params)
            {
                newParams.Add(Inflate(param, genericArgumentContext));
            }
            var newParamsAfterSentinel = new List<TypeSig>();
            if (methodSig.ParamsAfterSentinel != null)
            {
                throw new NotSupportedException($"methodSig.ParamsAfterSentinel is not supported: {methodSig}");
                //foreach (var param in methodSig.ParamsAfterSentinel)
                //{
                //    newParamsAfterSentinel.Add(Inflate(param, genericArgumentContext));
                //}
            }
            return new MethodSig(methodSig.CallingConvention, methodSig.GenParamCount, newReturnType, newParams, null);
        }

        public static IList<TypeSig> GetGenericArguments(IMemberRefParent type)
        {
            if (type is TypeDef typeDef)
            {
                return null;
            }
            if (type is TypeRef typeRef)
            {
                return null;
            }
            if (type is TypeSpec typeSpec)
            {
                GenericInstSig genericInstSig = typeSpec.TypeSig.ToGenericInstSig();
                return genericInstSig?.GenericArguments;
            }
            throw new NotSupportedException($"type:{type}");
        }

        public static GenericArgumentContext GetInflatedMemberRefGenericArgument(IMemberRefParent type, GenericArgumentContext ctx)
        {
            if (type is TypeDef typeDef)
            {
                return null;
            }
            if (type is TypeRef typeRef)
            {
                return null;
            }
            if (type is TypeSpec typeSpec)
            {
                GenericInstSig genericInstSig = typeSpec.TypeSig.ToGenericInstSig();
                if (genericInstSig == null)
                {
                    return ctx;
                }
                return new GenericArgumentContext(TryInflate(genericInstSig.GenericArguments, ctx), null);
            }
            throw new NotSupportedException($"type:{type}");
        }

        public static MethodSig GetInflatedMethodSig(IMethod method, GenericArgumentContext ctx)
        {
            if (method is MethodDef methodDef)
            {
                return methodDef.MethodSig;
            }
            if (method is MemberRef memberRef)
            {
                return InflateMethodSig(memberRef.MethodSig, GetInflatedMemberRefGenericArgument(memberRef.Class, ctx));
            }
            if (method is MethodSpec methodSpec)
            {
                var genericInstMethodSig = methodSpec.GenericInstMethodSig;
                if (methodSpec.Method is MethodDef methodDef2)
                {
                    return InflateMethodSig(methodDef2.MethodSig, new GenericArgumentContext(null, TryInflate(genericInstMethodSig.GenericArguments, ctx)));
                }
                if (methodSpec.Method is MemberRef memberRef2)
                {
                    return InflateMethodSig(memberRef2.MethodSig, new GenericArgumentContext(
                        GetInflatedMemberRefGenericArgument(memberRef2.Class, ctx)?.typeArgsStack,
                        TryInflate(genericInstMethodSig.GenericArguments, ctx)));
                }

            }
            throw new NotSupportedException($" method: {method}");
        }

        public static TypeSig InflateFieldSig(IField field, GenericArgumentContext ctx)
        {
            if (field is FieldDef fieldDef)
            {
                return fieldDef.FieldType;
            }
            if (field is MemberRef memberRef)
            {
                return Inflate(memberRef.FieldSig.Type, new GenericArgumentContext(TryInflate(GetGenericArguments(memberRef.Class), ctx), null));
            }

            throw new Exception($"unknown field:{field}");
        }

        public static ThisArgType GetThisArgType(IMethod method)
        {
            if (!method.MethodSig.HasThis)
            {
                return ThisArgType.None;
            }
            if (method is MethodDef methodDef)
            {
                return methodDef.DeclaringType.IsValueType ? ThisArgType.ValueType : ThisArgType.Class;
            }
            if (method is MemberRef memberRef)
            {
                TypeDef typeDef = MetaUtil.GetMemberRefTypeDefParentOrNull(memberRef.Class);
                if (typeDef == null)
                {
                    return ThisArgType.Class;
                }
                return typeDef.IsValueType ? ThisArgType.ValueType : ThisArgType.Class;
            }
            if (method is MethodSpec methodSpec)
            {
                return GetThisArgType(methodSpec.Method);
            }
            throw new NotSupportedException($" method: {method}");
        }

        public static MethodSig ToSharedMethodSig(ICorLibTypes corTypes, MethodSig methodSig)
        {
            var newReturnType = methodSig.RetType;
            var newParams = new List<TypeSig>();
            foreach (var param in methodSig.Params)
            {
                newParams.Add(ToShareTypeSig(corTypes, param));
            }
            if (methodSig.ParamsAfterSentinel != null)
            {
                //foreach (var param in methodSig.ParamsAfterSentinel)
                //{
                //    newParamsAfterSentinel.Add(ToShareTypeSig(corTypes, param));
                //}
                throw new NotSupportedException($"methodSig.ParamsAfterSentinel is not supported: {methodSig}");
            }
            return new MethodSig(methodSig.CallingConvention, methodSig.GenParamCount, newReturnType, newParams, null);
        }

        public static TypeSig ToShareTypeSig(ICorLibTypes corTypes, TypeSig typeSig)
        {
            var a = typeSig.RemovePinnedAndModifiers();
            switch (a.ElementType)
            {
                case ElementType.Void: return corTypes.Void;
                case ElementType.Boolean: return corTypes.Byte;
                case ElementType.Char: return corTypes.UInt16;
                case ElementType.I1: return corTypes.SByte;
                case ElementType.U1: return corTypes.Byte;
                case ElementType.I2: return corTypes.Int16;
                case ElementType.U2: return corTypes.UInt16;
                case ElementType.I4: return corTypes.Int32;
                case ElementType.U4: return corTypes.UInt32;
                case ElementType.I8: return corTypes.Int64;
                case ElementType.U8: return corTypes.UInt64;
                case ElementType.R4: return corTypes.Single;
                case ElementType.R8: return corTypes.Double;
                case ElementType.String: return corTypes.Object;
                case ElementType.TypedByRef: return corTypes.TypedReference;
                case ElementType.I: return corTypes.IntPtr;
                case ElementType.U: return corTypes.UIntPtr;
                case ElementType.Object: return corTypes.Object;
                case ElementType.Sentinel: return typeSig;
                case ElementType.Ptr: return corTypes.UIntPtr;
                case ElementType.ByRef: return corTypes.UIntPtr;
                case ElementType.SZArray: return typeSig;
                case ElementType.Array: return typeSig;
                case ElementType.ValueType:
                {
                    TypeDef typeDef = a.ToTypeDefOrRef().ResolveTypeDef();
                    if (typeDef == null)
                    {
                        throw new Exception($"type:{a} definition could not be found");
                    }
                    if (typeDef.IsEnum)
                    {
                        return ToShareTypeSig(corTypes, typeDef.GetEnumUnderlyingType());
                    }
                    return typeSig;
                }
                case ElementType.Var:
                case ElementType.MVar:
                case ElementType.Class: return corTypes.Object;
                case ElementType.GenericInst:
                {
                    var gia = (GenericInstSig)a;
                    TypeDef typeDef = gia.GenericType.ToTypeDefOrRef().ResolveTypeDef();
                    if (typeDef == null)
                    {
                        throw new Exception($"type:{a} definition could not be found");
                    }
                    if (typeDef.IsEnum)
                    {
                        return ToShareTypeSig(corTypes, typeDef.GetEnumUnderlyingType());
                    }
                    if (!typeDef.IsValueType)
                    {
                        return corTypes.Object;
                    }
                    // il2cpp will raise error when try to share generic value type
                    return typeSig;
                    //return new GenericInstSig(gia.GenericType, gia.GenericArguments.Select(ga => ToShareTypeSig(corTypes, ga)).ToList());
                }
                case ElementType.FnPtr: return corTypes.UIntPtr;
                case ElementType.ValueArray: return typeSig;
                case ElementType.Module: return typeSig;
                default:
                throw new NotSupportedException(typeSig.ToString());
            }
        }


        public static void AppendIl2CppStackTraceNameOfTypeSig(StringBuilder sb, TypeSig typeSig)
        {
            typeSig = typeSig.RemovePinnedAndModifiers();

            switch (typeSig.ElementType)
            {
                case ElementType.Void: sb.Append("Void"); break;
                case ElementType.Boolean: sb.Append("Boolean"); break;
                case ElementType.Char: sb.Append("Char"); break;
                case ElementType.I1: sb.Append("SByte"); break;
                case ElementType.U1: sb.Append("Byte"); break;
                case ElementType.I2: sb.Append("Int16"); break;
                case ElementType.U2: sb.Append("UInt16"); break;
                case ElementType.I4: sb.Append("Int32"); break;
                case ElementType.U4: sb.Append("UInt32"); break;
                case ElementType.I8: sb.Append("Int64"); break;
                case ElementType.U8: sb.Append("UInt64"); break;
                case ElementType.R4: sb.Append("Single"); break;
                case ElementType.R8: sb.Append("Double"); break;
                case ElementType.String: sb.Append("String"); break;
                case ElementType.Ptr: AppendIl2CppStackTraceNameOfTypeSig(sb, typeSig.Next); sb.Append("*"); break;
                case ElementType.ByRef: AppendIl2CppStackTraceNameOfTypeSig(sb, typeSig.Next); sb.Append("&"); break;
                case ElementType.ValueType:
                case ElementType.Class:
                {
                    var classOrValueTypeSig = (ClassOrValueTypeSig)typeSig;
                    TypeDef typeDef = classOrValueTypeSig.TypeDefOrRef.ResolveTypeDef();
                    if (typeDef == null)
                    {
                        throw new Exception($"type:{classOrValueTypeSig} definition could not be found");
                    }
                    sb.Append(typeDef.Name);
                    break;
                }
                case ElementType.GenericInst:
                {
                    var genericInstSig = (GenericInstSig)typeSig;
                    AppendIl2CppStackTraceNameOfTypeSig(sb, genericInstSig.GenericType);
                    break;
                }
                case ElementType.Var:
                case ElementType.MVar:
                {
                    var varSig = (GenericSig)typeSig;
                    sb.Append(varSig.GenericParam.Name);
                    break;
                }
                case ElementType.I: sb.Append("IntPtr"); break;
                case ElementType.U: sb.Append("UIntPtr"); break;
                case ElementType.FnPtr: sb.Append("IntPtr"); break;
                case ElementType.Object: sb.Append("Object"); break;
                case ElementType.SZArray:
                {
                    var szArraySig = (SZArraySig)typeSig;
                    AppendIl2CppStackTraceNameOfTypeSig(sb, szArraySig.Next);
                    sb.Append("[]");
                    break;
                }
                case ElementType.Array:
                {
                    var arraySig = (ArraySig)typeSig;
                    AppendIl2CppStackTraceNameOfTypeSig(sb, arraySig.Next);
                    sb.Append("[");
                    for (int i = 0; i < arraySig.Rank - 1; i++)
                    {
                        sb.Append(",");
                    }
                    sb.Append("]");
                    break;
                }
                case ElementType.TypedByRef: sb.Append("TypedReference"); break;
                default:
                throw new NotSupportedException(typeSig.ToString());
            }
        }

        public static TypeDef GetRootDeclaringType(TypeDef type)
        {
            TypeDef cur = type;
            while (true)
            {
                TypeDef declaringType = cur.DeclaringType;
                if (declaringType == null)
                {
                    return cur;
                }
                cur = declaringType;
            }
        }

        public static string CreateMethodDefIl2CppStackTraceSignature(MethodDef method)
        {
            var result = new StringBuilder();
            TypeDef declaringType = method.DeclaringType;

            string namespaze = GetRootDeclaringType(declaringType).Namespace;
            if (!string.IsNullOrEmpty(namespaze))
            {
                result.Append(namespaze);
                result.Append(".");
            }
            result.Append(declaringType.Name);
            result.Append(":");
            result.Append(method.Name);
            result.Append("(");

            int index = 0;
            foreach (TypeSig p in method.GetParams())
            {
                if (index > 0)
                {
                    result.Append(", ");
                }
                AppendIl2CppStackTraceNameOfTypeSig(result, p);
                ++index;
            }
            result.Append(")");
            return result.ToString();
        }

        public static bool HasCompilerGeneratedAttribute(IHasCustomAttribute obj)
        {
            return obj.CustomAttributes.Find(ConstValues.CompilerGeneratedAttributeFullName) != null;
        }

        public static bool HasEncryptFieldAttribute(IHasCustomAttribute obj)
        {
            return obj.CustomAttributes.Find(ConstValues.EncryptFieldAttributeFullName) != null;
        }

        public static bool HasRuntimeInitializeOnLoadMethodAttribute(MethodDef method)
        {
            return method.CustomAttributes.Find(ConstValues.RuntimeInitializedOnLoadMethodAttributeFullName) != null;
        }

        public static bool HasBlackboardEnumAttribute(TypeDef typeDef)
        {
            return typeDef.CustomAttributes.Find(ConstValues.BlackboardEnumAttributeFullName) != null;
        }

        public static bool HasBurstCompileAttribute(IHasCustomAttribute obj)
        {
            return obj.CustomAttributes.Find(ConstValues.BurstCompileFullName) != null;
        }

        public static bool HasDOTSCompilerGeneratedAttribute(IHasCustomAttribute obj)
        {
            return obj.CustomAttributes.Find(ConstValues.DOTSCompilerGeneratedAttributeFullName) != null;
        }

        public static bool HasMicrosoftCodeAnalysisEmbeddedAttribute(IHasCustomAttribute obj)
        {
            return obj.CustomAttributes.Find(ConstValues.EmbeddedAttributeFullName) != null;
        }
    }
}

```

`Editor/Utils/MetaUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: ded544371a7eb524caa1ccef3daebe55
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/NameMatcher.cs`:

```cs
using System.Text.RegularExpressions;

namespace Obfuz.Utils
{
    public class NameMatcher
    {
        private readonly string _str;
        private readonly Regex _regex;

        public string NameOrPattern => _str;

        public bool IsWildcardPattern => _regex != null;

        public NameMatcher(string nameOrPattern)
        {
            if (string.IsNullOrEmpty(nameOrPattern))
            {
                nameOrPattern = "*";
            }
            _str = nameOrPattern;
            _regex = nameOrPattern.Contains("*") || nameOrPattern.Contains("?") ? new Regex(WildcardToRegex(nameOrPattern)) : null;
        }

        public static string WildcardToRegex(string pattern)
        {
            return "^" + Regex.Escape(pattern).
            Replace("\\*", ".*").
            Replace("\\?", ".") + "$";
        }

        public bool IsMatch(string name)
        {
            if (_regex != null)
            {
                return _regex.IsMatch(name);
            }
            else
            {
                return _str == name;
            }
        }
    }
}

```

`Editor/Utils/NameMatcher.cs.meta`:

```meta
fileFormatVersion: 2
guid: c3a646fe086ecbd4a8dbf36a395ada71
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/NumberRange.cs`:

```cs
namespace Obfuz.Utils
{
    public class NumberRange<T> where T : struct
    {
        public readonly T? min;
        public readonly T? max;

        public NumberRange(T? min, T? max)
        {
            this.min = min;
            this.max = max;
        }
    }
}

```

`Editor/Utils/NumberRange.cs.meta`:

```meta
fileFormatVersion: 2
guid: 4d147a6853ce57c4d88529fb73823435
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/ObfuzIgnoreScopeComputeCache.cs`:

```cs
using dnlib.DotNet;
using Obfuz.Editor;
using System.Linq;

namespace Obfuz.Utils
{
    public class ObfuzIgnoreScopeComputeCache
    {
        private readonly CachedDictionary<IHasCustomAttribute, ObfuzScope?> _selfObfuzIgnoreScopeCache;
        private readonly CachedDictionary<TypeDef, ObfuzScope?> _enclosingObfuzIgnoreScopeCache;
        private readonly CachedDictionary<TypeDef, ObfuzScope?> _selfObfuzIgnoreApplyToChildTypesScopeCache;
        private readonly CachedDictionary<TypeDef, ObfuzScope?> _inheritedObfuzIgnoreScopeCache;

        public ObfuzIgnoreScopeComputeCache()
        {
            _selfObfuzIgnoreScopeCache = new CachedDictionary<IHasCustomAttribute, ObfuzScope?>(GetObfuzIgnoreScope);
            _enclosingObfuzIgnoreScopeCache = new CachedDictionary<TypeDef, ObfuzScope?>(GetEnclosingObfuzIgnoreScope);
            _selfObfuzIgnoreApplyToChildTypesScopeCache = new CachedDictionary<TypeDef, ObfuzScope?>(GetObfuzIgnoreScopeApplyToChildTypes);
            _inheritedObfuzIgnoreScopeCache = new CachedDictionary<TypeDef, ObfuzScope?>(GetInheritObfuzIgnoreScope);
        }

        private ObfuzScope? GetObfuzIgnoreScope(IHasCustomAttribute obj)
        {
            var ca = obj.CustomAttributes.FirstOrDefault(c => c.AttributeType.FullName == ConstValues.ObfuzIgnoreAttributeFullName);
            if (ca == null)
            {
                return null;
            }
            var scope = (ObfuzScope)ca.ConstructorArguments[0].Value;
            return scope;
        }

        private ObfuzScope? GetEnclosingObfuzIgnoreScope(TypeDef typeDef)
        {
            TypeDef cur = typeDef.DeclaringType;
            while (cur != null)
            {
                var ca = cur.CustomAttributes?.FirstOrDefault(c => c.AttributeType.FullName == ConstValues.ObfuzIgnoreAttributeFullName);
                if (ca != null)
                {
                    var scope = (ObfuzScope)ca.ConstructorArguments[0].Value;
                    CANamedArgument inheritByNestedTypesArg = ca.GetNamedArgument("ApplyToNestedTypes", false);
                    bool inheritByNestedTypes = inheritByNestedTypesArg == null || (bool)inheritByNestedTypesArg.Value;
                    return inheritByNestedTypes ? (ObfuzScope?)scope : null;
                }
                cur = cur.DeclaringType;
            }
            return null;
        }

        private ObfuzScope? GetObfuzIgnoreScopeApplyToChildTypes(TypeDef cur)
        {
            if (cur.Module.IsCoreLibraryModule == true)
            {
                return null;
            }
            var ca = cur.CustomAttributes?.FirstOrDefault(c => c.AttributeType.FullName == ConstValues.ObfuzIgnoreAttributeFullName);
            if (ca != null)
            {
                var scope = (ObfuzScope)ca.ConstructorArguments[0].Value;
                CANamedArgument inheritByChildTypesArg = ca.GetNamedArgument("ApplyToChildTypes", false);
                bool inheritByChildTypes = inheritByChildTypesArg != null && (bool)inheritByChildTypesArg.Value;
                if (inheritByChildTypes)
                {
                    return scope;
                }
            }
            return null;
        }

        private ObfuzScope? GetInheritObfuzIgnoreScope(TypeDef typeDef)
        {
            TypeDef cur = typeDef;
            for (; cur != null; cur = MetaUtil.GetBaseTypeDef(cur))
            {
                ObfuzScope? scope = _selfObfuzIgnoreApplyToChildTypesScopeCache.GetValue(cur);
                if (scope != null)
                {
                    return scope;
                }
                foreach (var interfaceType in cur.Interfaces)
                {
                    TypeDef interfaceTypeDef = interfaceType.Interface.ResolveTypeDef();
                    if (interfaceTypeDef != null)
                    {
                        ObfuzScope? interfaceScope = _selfObfuzIgnoreApplyToChildTypesScopeCache.GetValue(interfaceTypeDef);
                        if (interfaceScope != null)
                        {
                            return interfaceScope;
                        }
                    }
                }
            }
            return null;
        }

        //private ObfuzScope? GetSelfOrDeclaringOrEnclosingOrInheritObfuzIgnoreScope((IHasCustomAttribute obj, TypeDef declaringType) objAndDeclaringType, ObfuzScope targetScope)
        //{
        //    ObfuzScope? scope = _selfObfuzIgnoreScopeCache.GetValue(objAndDeclaringType.obj);
        //    if (scope != null)
        //    {
        //        return scope;
        //    }
        //    if (objAndDeclaringType.declaringType == null)
        //    {
        //        return null;
        //    }
        //    ObfuzScope? declaringOrEnclosingScope = _selfObfuzIgnoreScopeCache.GetValue(declaringType) ?? _enclosingObfuzIgnoreScopeCache.GetValue(declaringType) ?? _inheritedObfuzIgnoreScopeCache.GetValue(declaringType);
        //    return declaringOrEnclosingScope != null && (declaringOrEnclosingScope & targetScope) != 0;
        //}

        //private bool HasObfuzIgnoreScope(IHasCustomAttribute obj, ObfuzScope targetScope)
        //{
        //    ObfuzScope? objScope = _selfObfuzIgnoreScopeCache.GetValue(obj);
        //    return objScope != null && (objScope & targetScope) != 0;
        //}

        //private bool HasDeclaringOrEnclosingOrInheritObfuzIgnoreScope(TypeDef typeDef, ObfuzScope targetScope)
        //{
        //    if (typeDef == null)
        //    {
        //        return false;
        //    }
        //    ObfuzScope? declaringOrEnclosingScope = _selfObfuzIgnoreScopeCache.GetValue(typeDef) ?? _enclosingObfuzIgnoreScopeCache.GetValue(typeDef) ?? _inheritedObfuzIgnoreScopeCache.GetValue(typeDef);
        //    return declaringOrEnclosingScope != null && (declaringOrEnclosingScope & targetScope) != 0;
        //}

        public ObfuzScope? GetSelfOrDeclaringOrEnclosingOrInheritObfuzIgnoreScope(IHasCustomAttribute obj, TypeDef declaringType)
        {
            ObfuzScope? scope = _selfObfuzIgnoreScopeCache.GetValue(obj);
            if (scope != null)
            {
                return scope;
            }
            if (declaringType == null)
            {
                return null;
            }
            ObfuzScope? declaringOrEnclosingScope = _selfObfuzIgnoreScopeCache.GetValue(declaringType) ?? _enclosingObfuzIgnoreScopeCache.GetValue(declaringType) ?? _inheritedObfuzIgnoreScopeCache.GetValue(declaringType);
            return declaringOrEnclosingScope;
        }

        public bool HasSelfOrEnclosingOrInheritObfuzIgnoreScope(TypeDef typeDef, ObfuzScope targetScope)
        {
            ObfuzScope? scope = _selfObfuzIgnoreScopeCache.GetValue(typeDef) ?? _enclosingObfuzIgnoreScopeCache.GetValue(typeDef) ?? _inheritedObfuzIgnoreScopeCache.GetValue(typeDef);
            return scope != null && (scope & targetScope) != 0;
        }

        public bool HasSelfOrDeclaringOrEnclosingOrInheritObfuzIgnoreScope(IHasCustomAttribute obj, TypeDef declaringType, ObfuzScope targetScope)
        {
            ObfuzScope? scope = _selfObfuzIgnoreScopeCache.GetValue(obj);
            if (scope != null)
            {
                return (scope & targetScope) != 0;
            }
            if (declaringType == null)
            {
                return false;
            }
            ObfuzScope? declaringOrEnclosingScope = _selfObfuzIgnoreScopeCache.GetValue(declaringType) ?? _enclosingObfuzIgnoreScopeCache.GetValue(declaringType) ?? _inheritedObfuzIgnoreScopeCache.GetValue(declaringType);
            return declaringOrEnclosingScope != null && (declaringOrEnclosingScope & targetScope) != 0;
        }

        public bool HasSelfOrInheritPropertyOrEventOrOrTypeDefObfuzIgnoreScope(MethodDef obj, ObfuzScope targetScope)
        {
            ObfuzScope? scope = _selfObfuzIgnoreScopeCache.GetValue(obj);
            if (scope != null && (scope & targetScope) != 0)
            {
                return true;
            }

            TypeDef declaringType = obj.DeclaringType;
            ObfuzScope? declaringOrEnclosingScope = _selfObfuzIgnoreScopeCache.GetValue(declaringType) ?? _enclosingObfuzIgnoreScopeCache.GetValue(declaringType) ?? _inheritedObfuzIgnoreScopeCache.GetValue(declaringType);

            foreach (var propertyDef in declaringType.Properties)
            {
                if (propertyDef.GetMethod == obj || propertyDef.SetMethod == obj)
                {
                    ObfuzScope? finalScope = _selfObfuzIgnoreScopeCache.GetValue(propertyDef);
                    if (finalScope != null && (finalScope & targetScope) != 0)
                    {
                        return true;
                    }
                    break;
                }
            }

            foreach (var eventDef in declaringType.Events)
            {
                if (eventDef.AddMethod == obj || eventDef.RemoveMethod == obj)
                {
                    ObfuzScope? finalScope = _selfObfuzIgnoreScopeCache.GetValue(eventDef);
                    if (finalScope != null && (finalScope & targetScope) != 0)
                    {
                        return true;
                    }
                    break;
                }
            }

            return declaringOrEnclosingScope != null && (declaringOrEnclosingScope & targetScope) != 0;
        }

        public bool HasSelfOrInheritPropertyOrEventOrOrTypeDefIgnoreMethodName(MethodDef obj)
        {
            ObfuzScope? scope = _selfObfuzIgnoreScopeCache.GetValue(obj);
            if (scope != null && (scope & ObfuzScope.MethodName) != 0)
            {
                return true;
            }

            TypeDef declaringType = obj.DeclaringType;

            foreach (var propertyDef in declaringType.Properties)
            {
                if (propertyDef.GetMethod == obj || propertyDef.SetMethod == obj)
                {
                    ObfuzScope? finalScope = GetObfuzIgnoreScope(propertyDef);
                    if (finalScope != null && (finalScope & ObfuzScope.PropertyGetterSetterName) != 0)
                    {
                        return true;
                    }
                    break;
                }
            }

            foreach (var eventDef in declaringType.Events)
            {
                if (eventDef.AddMethod == obj || eventDef.RemoveMethod == obj)
                {
                    ObfuzScope? finalScope = GetObfuzIgnoreScope(eventDef);
                    if (finalScope != null && (finalScope & ObfuzScope.EventAddRemoveFireName) != 0)
                    {
                        return true;
                    }
                    break;
                }
            }

            return HasSelfOrEnclosingOrInheritObfuzIgnoreScope(declaringType, ObfuzScope.MethodName | ObfuzScope.PropertyGetterSetterName | ObfuzScope.EventAddRemoveFireName);
        }
    }
}

```

`Editor/Utils/ObfuzIgnoreScopeComputeCache.cs.meta`:

```meta
fileFormatVersion: 2
guid: 2f64b9a72981c0e45a03501db02e6538
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/PathAssemblyResolver.cs`:

```cs
using System.IO;

namespace Obfuz.Utils
{
    public class PathAssemblyResolver : AssemblyResolverBase
    {
        private readonly string[] _searchPaths;

        public PathAssemblyResolver(params string[] searchPaths)
        {
            _searchPaths = searchPaths;
        }

        public override string ResolveAssembly(string assemblyName)
        {
            foreach (var path in _searchPaths)
            {
                string assPath = Path.Combine(path, assemblyName + ".dll");
                if (File.Exists(assPath))
                {
                    //Debug.Log($"resolve {assemblyName} at {assPath}");
                    return assPath;
                }
            }
            return null;
        }
    }
}

```

`Editor/Utils/PathAssemblyResolver.cs.meta`:

```meta
fileFormatVersion: 2
guid: 5a7681737885f604e885ee39d0bedd74
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/PlatformUtil.cs`:

```cs
using UnityEditor;

namespace Obfuz.Utils
{
    public static class PlatformUtil
    {
        public static bool IsMonoBackend()
        {
            return PlayerSettings.GetScriptingBackend(EditorUserBuildSettings.selectedBuildTargetGroup)
                == ScriptingImplementation.Mono2x;
        }
    }
}

```

`Editor/Utils/PlatformUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: 85d01014c084c56498d292d3b16351d2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/RandomUtil.cs`:

```cs
using System.Collections.Generic;

namespace Obfuz.Utils
{
    static class RandomUtil
    {
        public static void ShuffleList<T>(List<T> list, IRandom random)
        {
            int n = list.Count;
            for (int i = n - 1; i > 0; i--)
            {
                int j = random.NextInt(i + 1);
                T temp = list[i];
                list[i] = list[j];
                list[j] = temp;
            }
        }
    }
}

```

`Editor/Utils/RandomUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: d482c078394711d428e627843d2481d7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/RandomWithKey.cs`:

```cs
namespace Obfuz.Utils
{
    public class RandomWithKey : IRandom
    {
        private const long a = 1664525;
        private const long c = 1013904223;
        private const long m = 4294967296; // 2^32

        private readonly int[] _key;

        private int _nextIndex;

        private int _seed;

        public RandomWithKey(int[] key, int seed)
        {
            _key = key;
            _seed = seed;
        }

        public int[] Key => _key;

        public int NextInt(int min, int max)
        {
            return min + NextInt(max - min);
        }

        public int NextInt(int max)
        {
            return (int)((uint)NextInt() % (uint)max);
        }

        private int GetNextSalt()
        {
            if (_nextIndex >= _key.Length)
            {
                _nextIndex = 0;
            }
            return _key[_nextIndex++];
        }

        public int NextInt()
        {
            _seed = (int)((a * _seed + c) % m);
            return _seed ^ GetNextSalt();
        }

        public long NextLong()
        {
            return ((long)NextInt() << 32) | (uint)NextInt();
        }

        public float NextFloat()
        {
            return (float)((double)(uint)NextInt() / uint.MaxValue);
        }

        public bool NextInPercentage(float percentage)
        {
            return NextFloat() < percentage;
        }
    }
}

```

`Editor/Utils/RandomWithKey.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6e16d7eb75fe2354d96eca5bb01358a4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/ReflectionUtil.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Obfuz.Utils
{
    public static class ReflectionUtil
    {
        public static List<Type> FindTypesInCurrentAppDomain(string fullName)
        {
            return AppDomain.CurrentDomain.GetAssemblies()
                .Select(assembly => assembly.GetType(fullName))
                .Where(type => type != null)
                .ToList();
        }

        public static Type FindUniqueTypeInCurrentAppDomain(string fullName)
        {
            var foundTypes = FindTypesInCurrentAppDomain(fullName);
            if (foundTypes.Count == 0)
            {
                throw new Exception($"class {fullName} not found in any assembly!");
            }
            if (foundTypes.Count > 1)
            {
                throw new Exception($"class {fullName} found in multiple assemblies! Please retain only one!");
            }
            return foundTypes[0];
        }
    }
}

```

`Editor/Utils/ReflectionUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: 6fac8216afeffb746b1b67d1f16883b8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/ThisArgType.cs`:

```cs
namespace Obfuz.Utils
{
    public enum ThisArgType
    {
        None,
        ValueType,
        Class,
    }
}

```

`Editor/Utils/ThisArgType.cs.meta`:

```meta
fileFormatVersion: 2
guid: 5d5a6303cdb66374f95187ca31b5e82f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Editor/Utils/TypeSigUtil.cs`:

```cs
using dnlib.DotNet;
using System;
using System.Collections.Generic;
using System.Text;

namespace Obfuz.Utils
{
    public static class TypeSigUtil
    {
        public static string ComputeTypeDefSignature(TypeDef type)
        {
            return type.FullName;
        }

        public static string ComputeMethodDefSignature(MethodDef method)
        {
            var result = new StringBuilder();
            ComputeTypeSigName(method.MethodSig.RetType, result);
            result.Append(" ");
            result.Append(method.DeclaringType.FullName);
            result.Append("::");
            if (method.IsStatic)
            {
                result.Append("@");
            }
            result.Append(method.Name);
            if (method.HasGenericParameters)
            {
                result.Append($"`{method.GenericParameters.Count}");
            }
            result.Append("(");
            for (int i = 0; i < method.Parameters.Count; i++)
            {
                if (i > 0)
                {
                    result.Append(", ");
                }
                ComputeTypeSigName(method.Parameters[i].Type, result);
            }
            result.Append(")");
            return result.ToString();
        }

        public static string ComputeFieldDefSignature(FieldDef field)
        {
            var result = new StringBuilder();
            ComputeTypeSigName(field.FieldSig.Type, result);
            result.Append(" ");
            result.Append(field.Name);
            return result.ToString();
        }

        public static string ComputePropertyDefSignature(PropertyDef property)
        {
            var result = new StringBuilder();

            PropertySig propertySig = property.PropertySig;
            ComputeTypeSigName(propertySig.RetType, result);
            result.Append(" ");
            result.Append(property.Name);

            IList<TypeSig> parameters = propertySig.Params;
            if (parameters.Count > 0)
            {
                result.Append("(");

                for (int i = 0; i < parameters.Count; i++)
                {
                    if (i > 0)
                    {
                        result.Append(", ");
                    }
                    ComputeTypeSigName(parameters[i], result);
                }
                result.Append(")");
            }

            return result.ToString();
        }

        public static string ComputeEventDefSignature(EventDef eventDef)
        {
            var result = new StringBuilder();
            ComputeTypeSigName(eventDef.EventType.ToTypeSig(), result);
            result.Append(" ");
            result.Append(eventDef.Name);
            return result.ToString();
        }

        public static string ComputeMethodSpecSignature(TypeSig type)
        {
            var sb = new StringBuilder();
            ComputeTypeSigName(type, sb);
            return sb.ToString();
        }

        public static void ComputeTypeSigName(TypeSig type, StringBuilder result)
        {
            type = type.RemovePinnedAndModifiers();
            switch (type.ElementType)
            {
                case ElementType.Void: result.Append("void"); break;
                case ElementType.Boolean: result.Append("bool"); break;
                case ElementType.Char: result.Append("char"); break;
                case ElementType.I1: result.Append("sbyte"); break;
                case ElementType.U1: result.Append("byte"); break;
                case ElementType.I2: result.Append("short"); break;
                case ElementType.U2: result.Append("ushort"); break;
                case ElementType.I4: result.Append("int"); break;
                case ElementType.U4: result.Append("uint"); break;
                case ElementType.I8: result.Append("long"); break;
                case ElementType.U8: result.Append("ulong"); break;
                case ElementType.R4: result.Append("float"); break;
                case ElementType.R8: result.Append("double"); break;
                case ElementType.String: result.Append("string"); break;
                case ElementType.Ptr:
                ComputeTypeSigName(((PtrSig)type).Next, result);
                result.Append("*");
                break;
                case ElementType.ByRef:
                ComputeTypeSigName(((ByRefSig)type).Next, result);
                result.Append("&");
                break;
                case ElementType.ValueType:
                case ElementType.Class:
                {
                    var valueOrClassType = type.ToClassOrValueTypeSig();
                    var typeDef = valueOrClassType.ToTypeDefOrRef().ResolveTypeDefThrow();
                    if (typeDef.Module.IsCoreLibraryModule != true)
                    {
                        result.Append($"[{typeDef.Module.Assembly.Name}]");
                    }
                    result.Append(typeDef.FullName);
                    break;
                }
                case ElementType.GenericInst:
                {
                    var genInst = (GenericInstSig)type;
                    ComputeTypeSigName(genInst.GenericType, result);
                    result.Append("<");
                    for (int i = 0; i < genInst.GenericArguments.Count; i++)
                    {
                        if (i > 0)
                        {
                            result.Append(",");
                        }
                        ComputeTypeSigName(genInst.GenericArguments[i], result);
                    }
                    result.Append(">");
                    break;
                }
                case ElementType.SZArray:
                ComputeTypeSigName(((SZArraySig)type).Next, result);
                result.Append("[]");
                break;
                case ElementType.Array:
                {
                    var arraySig = (ArraySig)type;
                    ComputeTypeSigName(arraySig.Next, result);
                    result.Append("[");
                    for (int i = 0; i < arraySig.Rank; i++)
                    {
                        if (i > 0)
                        {
                            result.Append(",");
                        }
                        //result.Append(arraySig.Sizes[i]);
                    }
                    result.Append("]");
                    break;
                }
                case ElementType.FnPtr:
                {
                    var fnPtr = (FnPtrSig)type;
                    result.Append("(");
                    MethodSig ms = fnPtr.MethodSig;
                    ComputeTypeSigName(ms.RetType, result);
                    result.Append("(");
                    for (int i = 0; i < ms.Params.Count; i++)
                    {
                        if (i > 0)
                        {
                            result.Append(",");
                        }
                        ComputeTypeSigName(ms.Params[i], result);
                    }
                    result.Append(")*");
                    break;
                }
                case ElementType.TypedByRef:
                result.Append("typedref");
                break;
                case ElementType.I:
                result.Append("nint");
                break;
                case ElementType.U:
                result.Append("nuint");
                break;
                case ElementType.Object:
                result.Append("object");
                break;
                case ElementType.Var:
                {
                    var var = (GenericVar)type;
                    result.Append($"!{var.Number}");
                    break;
                }
                case ElementType.MVar:
                {
                    var mvar = (GenericMVar)type;
                    result.Append($"!!{mvar.Number}");
                    break;
                }
                default: throw new NotSupportedException($"[ComputeTypeSigName] not support :{type}");

            }
        }
    }
}

```

`Editor/Utils/TypeSigUtil.cs.meta`:

```meta
fileFormatVersion: 2
guid: 83e1214102577b449a933438c41c97bf
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 Code Philosophy(代码哲学)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`LICENSE.meta`:

```meta
fileFormatVersion: 2
guid: 4431597180c05fb46839ded925d40a19
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Plugins.meta`:

```meta
fileFormatVersion: 2
guid: f98a5dd310a82a64c9cc45cc139773dc
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Plugins/dnlib.dll.meta`:

```meta
fileFormatVersion: 2
guid: 355f9a0beb9535e4792b15e532d17460
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 1
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      : Any
    second:
      enabled: 0
      settings:
        Exclude Editor: 0
        Exclude Linux64: 1
        Exclude OSXUniversal: 1
        Exclude Win: 1
        Exclude Win64: 1
  - first:
      Any: 
    second:
      enabled: 0
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 1
      settings:
        CPU: AnyCPU
        DefaultValueInitialized: true
        OS: AnyOS
  - first:
      Standalone: Linux64
    second:
      enabled: 0
      settings:
        CPU: None
  - first:
      Standalone: OSXUniversal
    second:
      enabled: 0
      settings:
        CPU: None
  - first:
      Standalone: Win
    second:
      enabled: 0
      settings:
        CPU: None
  - first:
      Standalone: Win64
    second:
      enabled: 0
      settings:
        CPU: None
  - first:
      Windows Store Apps: WindowsStoreApps
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`README.md`:

```md
# Obfuz

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Unity Version](https://img.shields.io/badge/Unity-2019%2B-blue)](https://unity.com/)

Obfuz 是一款开源、强大、易用及稳定可靠的充分满足商业化游戏项目需求的Unity代码混淆和加固解决方案。

[English](./README-EN.md) | [中文](./README.md)

[Github](https://github.com/focus-creative-games/obfuz) | [Gitee](https://gitee.com/focus-creative-games/obfuz)

---

## 为什么选择 Obfuz？

- **功能强大**：提供媲美商业工具的强大混淆和代码加固功能。
- **与Unity深度集成**：为Unity工作流深度优化，自动化处理除了反射以外所有需要特殊处理的情况（如MonoBehaviour名不能混淆），默认不需要配置任何混淆规则即可良好工作。
- **快速集成**：只需配置哪些程序集需要被混淆，三分钟即可集成代码混淆功能。
- **稳定可靠**：有全面的自动化测试项目，成功通过3000个多个测试用例，几乎覆盖所有常见的代码用例。
- **支持热更新**：支持HybridCLR、xlua之类最流行的代码热更新方案。
- **敏捷开发**：快速响应开发者需求、迅速修复bug，及时跟进Unity及团结引擎的最新改动
- **开源免费**：基于 MIT 协议，免费使用和修改。

## 功能特性

- **多态DLL文件**：自定义的结构随机化的DLL文件格式，每次发布时的DLL结构都不一样，有效对抗破解和篡改
- **符号混淆**：支持丰富的配置规则和增量混淆，灵活高效地保护代码。
- **常量混淆**：混淆 `int`、`long`、`float`、`double`、`string`、数组 等常量，防止逆向工程。
- **变量内存加密**：加密内存中的变量，提升运行时安全。
- **执行栈混淆**：混淆执行栈中变量，提高逆向难度。
- **表达式混淆**：混淆add、sub之类的绝大多数常见运算。
- **函数调用混淆**：打乱函数调用结构，增加破解难度。
- **控制流混淆**：控制流平坦化，打乱代码执行流程，显著增加逆向难度。
- **随机加密虚拟机**：生成随机化虚拟机，有效抵御反编译和破解工具。
- **静态与动态解密**：结合静态和动态解密，防止离线静态分析。
- **混淆多态化**：通过配置不同的生成密钥和随机化种子，生成不同的混淆代码。
- **垃圾代码生成**：支持多种垃圾代码生成，提高App Store和Google Play审核通过率。
- **深度 Unity 集成**：与 Unity 工作流无缝衔接，简单配置即可使用。
- **热更新支持**：全面兼容 HybridCLR、xLua 等热更新框架，确保动态代码更新顺畅。
- **兼容DOTS**：兼容DOTS各个版本，无需配置即可正常工作。

## 支持的Unity版本与平台

- 支持Unity 2019+
- 支持团结引擎
- 支持Unity和团结引擎支持的所有平台
- 支持il2cpp和mono backend

## 文档

- [文档](https://www.obfuz.com/)
- [快速上手](https://www.obfuz.com/docs/beginner/quick-start)
- [示例项目](https://github.com/focus-creative-games/obfuz-samples)

## 未来计划

Obfuz 正在持续开发中，即将推出的功能包括：

- **代码水印**：嵌入可追踪的水印。
- **反内存转储与反调试**：防止内存转储和调试行为。
- **代码虚拟化**：将代码转化为虚拟化指令，提供最高级别安全。

## 许可证

Obfuz 采用 MIT 许可证发布，欢迎自由使用、修改和分发。

## 联系我们

如有问题、建议或错误报告，请在用以下方式联系我们：

- GitHub 上提交 Issue
- 邮件联系维护者：`obfuz#code-philosophy.com`
- QQ群 **Obfuz交流群**： 1048396510
- discord频道 `https://discord.gg/bFXhmrUw8c`

```

`README.md.meta`:

```meta
fileFormatVersion: 2
guid: 4a7745e765ea87042b47ad24b6516c57
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`REAME-EN.md`:

```md
# Obfuz

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Unity Version](https://img.shields.io/badge/Unity-2019%2B-blue)](https://unity.com/)

**Obfuz** is an open-source, powerful, easy-to-use, and highly reliable Unity code obfuscation and protection solution that fully meets the demands of commercial game projects.

[English](./README-EN.md) | [中文](./README.md)

[Github](https://github.com/focus-creative-games/obfuz) | [Gitee](https://gitee.com/focus-creative-games/obfuz)

---

## Why Choose Obfuz?

- **Open Source & Free**: Licensed under MIT, free to use and modify.  
- **Powerful Features**: Delivers obfuscation and code protection comparable to commercial tools.  
- **Unity-First Design**: Deeply optimized for Unity workflows. Automatically handles all edge cases (e.g., preserving `MonoBehaviour` names) except reflection (due to technical limitations). Near-zero configuration required.  
- **Battle-Tested**: Verified by 3,000+ automated test cases covering virtually all common code patterns.  
- **Hot Reload Ready**: Fully compatible with leading hot-reload solutions like HybridCLR and xLua.  
- **Agile Development**: Rapid bug fixes, prompt feature updates, and immediate support for the latest Unity/Unity Engine changes.  

## Features

- **Polymorphic DLL Files**: Custom DLL file format with randomized structure, varying with each release, effectively countering cracking and tampering.
- **Symbol Obfuscation**: Supports comprehensive configuration rules and incremental obfuscation for flexible and efficient code protection.
- **Constant Obfuscation**: Obfuscates constants such as `int`, `long`, `float`, `double`, `string` and `array` to prevent reverse engineering.
- **Variable Memory Encryption**: Encrypts variables in memory to enhance runtime security.
- **Eval stack Obfuscation**: Obfuscates eval stack variable to prevent reverse engineering.
- **Expression Obfuscation**: Obfuscate complex expressions for enhanced protection.
- **Function Call Obfuscation**: Scrambles function call structures to increase cracking difficulty.
- **Control Flow Obfuscation**: Disrupt code flow to deter reverse engineering.
- **Randomized Encryption VM**: Generates randomized virtual machines to thwart decompilation and cracking tools.
- **Static and Dynamic Decryption**: Combines static and dynamic decryption to resist offline static analysis.
 **Obfuscation Polymorphism**: Generates different obfuscated code by configuring different generation keys and randomization seeds.
- **Garbage Code Generation**​​: Supports various types of low-quality code generation to improve App Store and Google Play review pass rates
- **Seamless Unity Integration**: Deeply integrated with Unity workflows, requiring minimal configuration to get started.
- **Hot Update Compatibility**: Fully supports hot update frameworks like HybridCLR, xLua, and Puerts, ensuring compatibility with dynamic code updates.
- **DOTS Compatibility**: Works seamlessly across all DOTS versions with zero configuration required.

## Supported Unity Versions & Platforms

- Unity 2019 and later versions
- Tuanjie 1.0.0 and later versions
- All platforms supported by Unity and Tuanjie
- il2cpp and mono backend

## Planned Features

Obfuz is actively evolving. Upcoming features include:

- **Code Watermarking**: Embed traceable watermarks in your code.
- **Anti-Memory Dumping and Anti-Debugging**: Prevent memory dumps and debugging attempts.
- **Code Virtualization**: Transform code into virtualized instructions for maximum security.

## Documentation

- [Document](https://www.obfuz.com/)
- [Quick Start](https://www.obfuz.com/docs/beginner/quick-start)
- [Samples](https://github.com/focus-creative-games/obfuz-samples)

## License

Obfuz is released under the MIT License. Feel free to use, modify, and distribute it as needed.

## Contact

For questions, suggestions, or bug reports, please reach us through:

- Submit an Issue on GitHub
- Email the maintainer: `obfuz#code-philosophy.com`
- Obfuz QQ Group: 1048396510
- Discord channel: `https://discord.gg/bFXhmrUw8c`

```

`REAME-EN.md.meta`:

```meta
fileFormatVersion: 2
guid: 462f7b98432032e4ba509274c1e90b1d
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime.meta`:

```meta
fileFormatVersion: 2
guid: cd1451b864839ad41b5463274b1d171c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/AssetUtility.cs`:

```cs
using System;

namespace Obfuz
{
    public static class AssetUtility
    {
        public static void VerifySecretKey(int expectedValue, int actualValue)
        {
            if (expectedValue != actualValue)
            {
                throw new Exception($"VerifySecretKey failed. Your secret key is unmatched with secret key used by current assembly in obfuscation");
            }
        }
    }
}

```

`Runtime/AssetUtility.cs.meta`:

```meta
fileFormatVersion: 2
guid: 72fb691c46a883f4ea3b3dfe7d2280f3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/ConstUtility.cs`:

```cs
using System;
using System.Text;
using UnityEngine.Assertions;

namespace Obfuz
{
    public static class ConstUtility
    {
        public static int GetInt(byte[] data, int offset)
        {
            return BitConverter.ToInt32(data, offset);
        }

        public static long GetLong(byte[] data, int offset)
        {
            return BitConverter.ToInt64(data, offset);
        }

        public static float GetFloat(byte[] data, int offset)
        {
            return BitConverter.ToSingle(data, offset);
        }

        public static double GetDouble(byte[] data, int offset)
        {
            return BitConverter.ToDouble(data, offset);
        }

        public static string GetString(byte[] data, int offset, int length)
        {
            return Encoding.UTF8.GetString(data, offset, length);
        }

        public static byte[] GetBytes(byte[] data, int offset, int length)
        {
            byte[] result = new byte[length];
            Array.Copy(data, offset, result, 0, length);
            return result;
        }

        public static int[] GetInts(byte[] data, int offset, int byteLength)
        {
            Assert.IsTrue(byteLength % 4 == 0);
            int[] result = new int[byteLength >> 2];
            Buffer.BlockCopy(data, offset, result, 0, byteLength);
            return result;
        }

        public static void InitializeArray(Array array, byte[] data, int offset, int length)
        {
            Buffer.BlockCopy(data, offset, array, 0, length);
        }

        public static unsafe int CastFloatAsInt(float value)
        {
            int* intValue = (int*)&value;
            return *intValue;
        }

        public static unsafe float CastIntAsFloat(int value)
        {
            float* floatValue = (float*)&value;
            return *floatValue;
        }

        public static unsafe long CastDoubleAsLong(double value)
        {
            long* longValue = (long*)&value;
            return *longValue;
        }

        public static unsafe double CastLongAsDouble(long value)
        {
            double* doubleValue = (double*)&value;
            return *doubleValue;
        }
    }
}

```

`Runtime/ConstUtility.cs.meta`:

```meta
fileFormatVersion: 2
guid: 48bd592d1a1339643be1fafe4b97c941
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/EncryptFieldAttribute.cs`:

```cs
using System;

namespace Obfuz
{
    [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
    public class EncryptFieldAttribute : Attribute
    {
    }
}

```

`Runtime/EncryptFieldAttribute.cs.meta`:

```meta
fileFormatVersion: 2
guid: 30f22110938816d4cb7e9cc9a176fd1e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/EncryptionScope.cs`:

```cs
namespace Obfuz
{
    public interface IEncryptionScope
    {

    }

    public abstract class EncryptionScopeBase : IEncryptionScope
    {
        public void ForcePreserveAOT()
        {
            EncryptionService<EncryptionScopeBase>.Encrypt(0, 0, 0);
        }
    }

    public struct DefaultDynamicEncryptionScope : IEncryptionScope
    {
        public void ForcePreserveAOT()
        {
            EncryptionService<DefaultDynamicEncryptionScope>.Encrypt(0, 0, 0);
        }
    }

    public struct DefaultStaticEncryptionScope : IEncryptionScope
    {
        public void ForcePreserveAOT()
        {
            EncryptionService<DefaultStaticEncryptionScope>.Encrypt(0, 0, 0);
        }
    }
}

```

`Runtime/EncryptionScope.cs.meta`:

```meta
fileFormatVersion: 2
guid: 1d729fe7cb7d0bc43a69f1ba09f99061
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/EncryptionService.cs`:

```cs
using System;

namespace Obfuz
{

    public static class EncryptionService<T> where T : IEncryptionScope
    {
        // for compatibility with Mono because Mono will raise FieldAccessException when try access private field
        public static IEncryptor _encryptor;

        public static IEncryptor Encryptor
        {
            get => _encryptor;
            set { _encryptor = value; }
        }

        public static void EncryptBlock(byte[] data, int ops, int salt)
        {
            _encryptor.EncryptBlock(data, ops, salt);
        }

        public static void DecryptBlock(byte[] data, int ops, int salt)
        {
            _encryptor.DecryptBlock(data, ops, salt);
        }

        public static int Encrypt(int value, int opts, int salt)
        {
            return _encryptor.Encrypt(value, opts, salt);
        }

        public static int Decrypt(int value, int opts, int salt)
        {
            return _encryptor.Decrypt(value, opts, salt);
        }

        public static long Encrypt(long value, int opts, int salt)
        {
            return _encryptor.Encrypt(value, opts, salt);
        }

        public static long Decrypt(long value, int opts, int salt)
        {
            return _encryptor.Decrypt(value, opts, salt);
        }

        public static float Encrypt(float value, int opts, int salt)
        {
            return _encryptor.Encrypt(value, opts, salt);
        }

        public static float Decrypt(float value, int opts, int salt)
        {
            return _encryptor.Decrypt(value, opts, salt);
        }

        public static double Encrypt(double value, int opts, int salt)
        {
            return _encryptor.Encrypt(value, opts, salt);
        }

        public static double Decrypt(double value, int opts, int salt)
        {
            return _encryptor.Decrypt(value, opts, salt);
        }

        public static byte[] Encrypt(byte[] value, int offset, int length, int opts, int salt)
        {
            return _encryptor.Encrypt(value, offset, length, opts, salt);
        }

        public static byte[] Decrypt(byte[] value, int offset, int byteLength, int ops, int salt)
        {
            return _encryptor.Decrypt(value, offset, byteLength, ops, salt);
        }

        public static byte[] Encrypt(string value, int ops, int salt)
        {
            return _encryptor.Encrypt(value, ops, salt);
        }

        public static string DecryptString(byte[] value, int offset, int stringBytesLength, int ops, int salt)
        {
            return _encryptor.DecryptString(value, offset, stringBytesLength, ops, salt);
        }


        public static int DecryptFromRvaInt(byte[] data, int offset, int ops, int salt)
        {
            int encryptedValue = BitConverter.ToInt32(data, offset);
            return Decrypt(encryptedValue, ops, salt);
        }

        public static long DecryptFromRvaLong(byte[] data, int offset, int ops, int salt)
        {
            long encryptedValue = BitConverter.ToInt64(data, offset);
            return Decrypt(encryptedValue, ops, salt);
        }

        public static float DecryptFromRvaFloat(byte[] data, int offset, int ops, int salt)
        {
            float encryptedValue = BitConverter.ToSingle(data, offset);
            return Decrypt(encryptedValue, ops, salt);
        }

        public static double DecryptFromRvaDouble(byte[] data, int offset, int ops, int salt)
        {
            double encryptedValue = BitConverter.ToDouble(data, offset);
            return Decrypt(encryptedValue, ops, salt);
        }

        public static string DecryptFromRvaString(byte[] data, int offset, int length, int ops, int salt)
        {
            return DecryptString(data, offset, length, ops, salt);
        }

        public static byte[] DecryptFromRvaBytes(byte[] data, int offset, int bytesLength, int ops, int salt)
        {
            return Decrypt(data, offset, bytesLength, ops, salt);
        }

        public static void DecryptInitializeArray(System.Array arr, System.RuntimeFieldHandle field, int length, int ops, int salt)
        {
            _encryptor.DecryptInitializeArray(arr, field, length, ops, salt);
        }
    }
}

```

`Runtime/EncryptionService.cs.meta`:

```meta
fileFormatVersion: 2
guid: bbbeb7501a0d84542828cb1aa7103d1b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/EncryptorBase.cs`:

```cs
using System;
using System.Runtime.CompilerServices;
using System.Text;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine.Assertions;

namespace Obfuz
{
    public abstract class EncryptorBase : IEncryptor
    {
        public abstract int OpCodeCount { get; }

        public static int[] ConvertToIntKey(byte[] key)
        {
            Assert.AreEqual(0, key.Length % 4);
            int align4Length = key.Length / 4;
            int[] intKey = new int[align4Length];
            Buffer.BlockCopy(key, 0, intKey, 0, key.Length);
            return intKey;
        }

        public abstract int Encrypt(int value, int opts, int salt);
        public abstract int Decrypt(int value, int opts, int salt);

        public virtual long Encrypt(long value, int opts, int salt)
        {
            int low = (int)value;
            int high = (int)(value >> 32);
            int encryptedLow = Encrypt(low, opts, salt);
            int encryptedHigh = Encrypt(high, opts, salt);
            return ((long)encryptedHigh << 32) | (uint)encryptedLow;
        }

        public virtual long Decrypt(long value, int opts, int salt)
        {
            int low = (int)value;
            int high = (int)(value >> 32);
            int decryptedLow = Decrypt(low, opts, salt);
            int decryptedHigh = Decrypt(high, opts, salt);
            return ((long)decryptedHigh << 32) | (uint)decryptedLow;
        }

        public virtual unsafe float Encrypt(float value, int opts, int salt)
        {
            if (float.IsNaN(value) || float.IsInfinity(value))
            {
                return value;
            }
            ref int intValue = ref *(int*)&value;
            int xorValue = ((1 << 23) - 1) & Decrypt(0xABCD, opts, salt);
            intValue ^= xorValue;
            return value;
        }

        public virtual unsafe float Decrypt(float value, int opts, int salt)
        {
            if (float.IsNaN(value) || float.IsInfinity(value))
            {
                return value;
            }
            ref int intValue = ref *(int*)&value;
            int xorValue = ((1 << 23) - 1) & Decrypt(0xABCD, opts, salt);
            intValue ^= xorValue;
            return value;
        }

        public virtual unsafe double Encrypt(double value, int opts, int salt)
        {
            if (double.IsNaN(value) || double.IsInfinity(value))
            {
                return value;
            }
            ref long longValue = ref *(long*)&value;
            long xorValue = ((1L << 52) - 1) & Decrypt(0xAABBCCDDL, opts, salt);
            longValue ^= xorValue;
            return value;
        }

        public virtual unsafe double Decrypt(double value, int opts, int salt)
        {
            if (double.IsNaN(value) || double.IsInfinity(value))
            {
                return value;
            }
            ref long longValue = ref *(long*)&value;
            long xorValue = ((1L << 52) - 1) & Decrypt(0xAABBCCDDL, opts, salt);
            longValue ^= xorValue;
            return value;
        }

        public virtual unsafe byte[] Encrypt(byte[] value, int offset, int length, int ops, int salt)
        {
            if (length == 0)
            {
                return Array.Empty<byte>();
            }

            var encryptedBytes = new byte[length];
            int intArrLength = length >> 2;

            // align to 4
            if ((offset & 0x3) != 0)
            {
                Buffer.BlockCopy(value, offset, encryptedBytes, 0, length);

                // encrypt int

                fixed (byte* dstBytePtr = &encryptedBytes[0])
                {
                    int* dstIntPtr = (int*)dstBytePtr;
                    int last = 0;
                    for (int i = 0; i < intArrLength; i++)
                    {
                        last ^= Encrypt(dstIntPtr[i], ops, salt);
                        dstIntPtr[i] = last;
                    }
                }
                for (int i = intArrLength * 4; i < length; i++)
                {
                    encryptedBytes[i] = (byte)(encryptedBytes[i] ^ salt);
                }
            }
            else
            {
                // encrypt int
                fixed (byte* srcBytePtr = &value[offset])
                {
                    fixed (byte* dstBytePtr = &encryptedBytes[0])
                    {
                        int* srcIntPtr = (int*)srcBytePtr;
                        int* dstIntPtr = (int*)dstBytePtr;

                        int last = 0;
                        for (int i = 0; i < intArrLength; i++)
                        {
                            last ^= Encrypt(srcIntPtr[i], ops, salt);
                            dstIntPtr[i] = last;
                        }
                    }
                }
                for (int i = intArrLength * 4; i < length; i++)
                {
                    encryptedBytes[i] = (byte)(value[offset + i] ^ salt);
                }
            }
            return encryptedBytes;
        }

        public unsafe virtual byte[] Decrypt(byte[] value, int offset, int length, int ops, int salt)
        {
            if (length == 0)
            {
                return Array.Empty<byte>();
            }
            var decryptedBytes = new byte[length];
            int intArrLength = length >> 2;

            // align to 4
            if ((offset & 0x3) != 0)
            {
                Buffer.BlockCopy(value, offset, decryptedBytes, 0, length);

                // encrypt int

                fixed (byte* dstBytePtr = &decryptedBytes[0])
                {
                    int* dstIntPtr = (int*)dstBytePtr;
                    int last = 0;
                    for (int i = 0; i < intArrLength; i++)
                    {
                        int oldLast = last;
                        last = dstIntPtr[i];
                        dstIntPtr[i] = Decrypt(last ^ oldLast, ops, salt);
                    }
                }
                for (int i = intArrLength * 4; i < length; i++)
                {
                    decryptedBytes[i] = (byte)(decryptedBytes[i] ^ salt);
                }
            }
            else
            {
                // encrypt int
                fixed (byte* srcBytePtr = &value[offset])
                {
                    fixed (byte* dstBytePtr = &decryptedBytes[0])
                    {
                        int* srcIntPtr = (int*)srcBytePtr;
                        int* dstIntPtr = (int*)dstBytePtr;
                        int last = 0;
                        for (int i = 0; i < intArrLength; i++)
                        {
                            int oldLast = last;
                            last = srcIntPtr[i];
                            dstIntPtr[i] = Decrypt(last ^ oldLast, ops, salt);
                        }
                    }
                }
                for (int i = intArrLength * 4; i < length; i++)
                {
                    decryptedBytes[i] = (byte)(value[offset + i] ^ salt);
                }
            }
            return decryptedBytes;
        }

        public virtual byte[] Encrypt(string value, int ops, int salt)
        {
            if (value.Length == 0)
            {
                return Array.Empty<byte>();
            }
            byte[] bytes = Encoding.UTF8.GetBytes(value);
            return Encrypt(bytes, 0, bytes.Length, ops, salt);
        }

        public virtual string DecryptString(byte[] value, int offset, int length, int ops, int salt)
        {
            if (length == 0)
            {
                return string.Empty;
            }
            byte[] bytes = Decrypt(value, offset, length, ops, salt);
            return Encoding.UTF8.GetString(bytes);
        }

        public virtual unsafe void EncryptBlock(byte[] data, int ops, int salt)
        {
            int length = data.Length;
            int intArrLength = length >> 2;

            fixed (byte* dstBytePtr = &data[0])
            {
                int* dstIntPtr = (int*)dstBytePtr;
                int last = 0;
                for (int i = 0; i < intArrLength; i++)
                {
                    last ^= Encrypt(dstIntPtr[i], ops, salt);
                    dstIntPtr[i] = last;
                }
            }
            for (int i = intArrLength * 4; i < length; i++)
            {
                data[i] = (byte)(data[i] ^ salt);
            }
        }

        public virtual unsafe void DecryptBlock(byte[] data, int ops, int salt)
        {
            fixed (byte* dataPtr = &data[0])
            {
                DecryptBlock(dataPtr, data.Length, ops, salt);
            }
        }

        private unsafe void DecryptBlock(byte* data, int length, int ops, int salt)
        {
            int intArrLength = length >> 2;

            int* dstIntPtr = (int*)data;
            int last = 0;
            for (int i = 0; i < intArrLength; i++)
            {
                int oldLast = last;
                last = dstIntPtr[i];
                dstIntPtr[i] = Decrypt(oldLast ^ last, ops, salt);
            }
            for (int i = intArrLength * 4; i < length; i++)
            {
                data[i] = (byte)(data[i] ^ salt);
            }
        }

        public virtual unsafe void DecryptInitializeArray(System.Array arr, System.RuntimeFieldHandle field, int length, int ops, int salt)
        {
            //Assert.AreEqual(Marshal.SizeOf(arr.GetType().GetElementType()), arr.Length);
            RuntimeHelpers.InitializeArray(arr, field);
            if (arr is byte[] byteArr)
            {
                fixed (byte* dataPtr = &byteArr[0])
                {
                    DecryptBlock(dataPtr, length, ops, salt);
                }
            }
            else if (arr is int[] intArr)
            {
                fixed (int* dataPtr = &intArr[0])
                {
                    DecryptBlock((byte*)dataPtr, length, ops, salt);
                }
            }
            else if (arr is long[] longArr)
            {
                fixed (long* dataPtr = &longArr[0])
                {
                    DecryptBlock((byte*)dataPtr, length, ops, salt);
                }
            }
            else if (arr is sbyte[] sbyteArr)
            {
                fixed (sbyte* dataPtr = &sbyteArr[0])
                {
                    DecryptBlock((byte*)dataPtr, length, ops, salt);
                }
            }
            else if (arr is short[] shortArr)
            {
                fixed (short* dataPtr = &shortArr[0])
                {
                    DecryptBlock((byte*)dataPtr, length, ops, salt);
                }
            }
            else if (arr is ushort[] ushortArr)
            {
                fixed (ushort* dataPtr = &ushortArr[0])
                {
                    DecryptBlock((byte*)dataPtr, length, ops, salt);
                }
            }
            else if (arr is uint[] uintArr)
            {
                fixed (uint* dataPtr = &uintArr[0])
                {
                    DecryptBlock((byte*)dataPtr, length, ops, salt);
                }
            }
            else if (arr is ulong[] ulongArr)
            {
                fixed (ulong* dataPtr = &ulongArr[0])
                {
                    DecryptBlock((byte*)dataPtr, length, ops, salt);
                }
            }
            else if (arr is float[] floatArr)
            {
                fixed (float* dataPtr = &floatArr[0])
                {
                    DecryptBlock((byte*)dataPtr, length, ops, salt);
                }
            }
            else if (arr is double[] doubleArr)
            {
                fixed (double* dataPtr = &doubleArr[0])
                {
                    DecryptBlock((byte*)dataPtr, length, ops, salt);
                }
            }
            else
            {
                void* dataPtr = UnsafeUtility.PinGCArrayAndGetDataAddress(arr, out ulong handle);
                try
                {
                    DecryptBlock((byte*)dataPtr, length, ops, salt);
                }
                finally
                {
                    UnsafeUtility.ReleaseGCObject(handle);
                }
            }
        }
    }
}

```

`Runtime/EncryptorBase.cs.meta`:

```meta
fileFormatVersion: 2
guid: d1d4c5725e7ad624ba8e55ecb63bb440
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/ExprUtility.cs`:

```cs
using System;

namespace Obfuz
{
    public static class ExprUtility
    {
        public static int Add(int a, int b)
        {
            return a + b;
        }

        public static long Add(long a, long b)
        {
            return a + b;
        }

        public static float Add(float a, float b)
        {
            return a + b;
        }

        public static double Add(double a, double b)
        {
            return a + b;
        }

        public static IntPtr Add(IntPtr a, IntPtr b)
        {
            return (IntPtr)((long)a + (long)b);
        }

        public static IntPtr Add(IntPtr a, int b)
        {
            return a + b;
        }

        public static int Subtract(int a, int b)
        {
            return a - b;
        }

        public static long Subtract(long a, long b)
        {
            return a - b;
        }

        public static float Subtract(float a, float b)
        {
            return a - b;
        }

        public static double Subtract(double a, double b)
        {
            return a - b;
        }

        public static IntPtr Subtract(IntPtr a, IntPtr b)
        {
            return (IntPtr)((long)a - (long)b);
        }

        public static IntPtr Subtract(IntPtr a, int b)
        {
            return a - b;
        }

        public static int Multiply(int a, int b)
        {
            return a * b;
        }

        public static long Multiply(long a, long b)
        {
            return a * b;
        }

        public static float Multiply(float a, float b)
        {
            return a * b;
        }

        public static double Multiply(double a, double b)
        {
            return a * b;
        }

        public static IntPtr Multiply(IntPtr a, IntPtr b)
        {
            return (IntPtr)((long)a * (long)b);
        }

        public static IntPtr Multiply(IntPtr a, int b)
        {
            return (IntPtr)((long)a * b);
        }

        public static int Divide(int a, int b)
        {
            return a / b;
        }

        public static long Divide(long a, long b)
        {
            return a / b;
        }

        public static float Divide(float a, float b)
        {
            return a / b;
        }

        public static double Divide(double a, double b)
        {
            return a / b;
        }

        public static int DivideUn(int a, int b)
        {
            return (int)((uint)a / (uint)b);
        }

        public static long DivideUn(long a, long b)
        {
            return (long)((ulong)a / (ulong)b);
        }

        public static int Rem(int a, int b)
        {
            return a % b;
        }

        public static long Rem(long a, long b)
        {
            return a % b;
        }

        public static float Rem(float a, float b)
        {
            return a % b;
        }

        public static double Rem(double a, double b)
        {
            return a % b;
        }

        public static int RemUn(int a, int b)
        {
            return (int)((uint)a % (uint)b);
        }

        public static long RemUn(long a, long b)
        {
            return (long)((ulong)a % (ulong)b);
        }

        public static int Negate(int a)
        {
            return -a;
        }

        public static long Negate(long a)
        {
            return -a;
        }

        public static float Negate(float a)
        {
            return -a;
        }

        public static double Negate(double a)
        {
            return -a;
        }

        public static int And(int a, int b)
        {
            return a & b;
        }

        public static long And(long a, long b)
        {
            return a & b;
        }

        public static int Or(int a, int b)
        {
            return a | b;
        }

        public static long Or(long a, long b)
        {
            return a | b;
        }

        public static int Xor(int a, int b)
        {
            return a ^ b;
        }

        public static long Xor(long a, long b)
        {
            return a ^ b;
        }

        public static int Not(int a)
        {
            return ~a;
        }

        public static long Not(long a)
        {
            return ~a;
        }

        public static int ShiftLeft(int a, int b)
        {
            return a << b;
        }

        public static long ShiftLeft(long a, int b)
        {
            return a << b;
        }

        public static int ShiftRight(int a, int b)
        {
            return a >> b;
        }

        public static long ShiftRight(long a, int b)
        {
            return a >> b;
        }

        public static int ShiftRightUn(int a, int b)
        {
            return (int)((uint)a >> b);
        }

        public static long ShiftRightUn(long a, int b)
        {
            return (long)((ulong)a >> b);
        }
    }
}

```

`Runtime/ExprUtility.cs.meta`:

```meta
fileFormatVersion: 2
guid: 9aba5050818a0224696fcf73752fb225
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/IEncryptor.cs`:

```cs
namespace Obfuz
{
    public interface IEncryptor
    {
        int OpCodeCount { get; }

        void EncryptBlock(byte[] data, int ops, int salt);
        void DecryptBlock(byte[] data, int ops, int salt);

        int Encrypt(int value, int opts, int salt);
        int Decrypt(int value, int opts, int salt);

        long Encrypt(long value, int opts, int salt);
        long Decrypt(long value, int opts, int salt);

        float Encrypt(float value, int opts, int salt);
        float Decrypt(float value, int opts, int salt);

        double Encrypt(double value, int opts, int salt);
        double Decrypt(double value, int opts, int salt);

        byte[] Encrypt(byte[] value, int offset, int length, int opts, int salt);
        byte[] Decrypt(byte[] value, int offset, int byteLength, int ops, int salt);

        byte[] Encrypt(string value, int ops, int salt);
        string DecryptString(byte[] value, int offset, int stringBytesLength, int ops, int salt);

        void DecryptInitializeArray(System.Array arr, System.RuntimeFieldHandle field, int length, int ops, int salt);
    }
}

```

`Runtime/IEncryptor.cs.meta`:

```meta
fileFormatVersion: 2
guid: 3078fa59ff0af6b4cbbee25e20bc41c1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/NullEncryptor.cs`:

```cs
using System;
using System.Text;

namespace Obfuz
{
    public class NullEncryptor : EncryptorBase
    {
        private readonly byte[] _key;

        public override int OpCodeCount => 256;

        public NullEncryptor(byte[] key)
        {
            _key = key;
        }

        public override int Encrypt(int value, int opts, int salt)
        {
            return value;
        }

        public override int Decrypt(int value, int opts, int salt)
        {
            return value;
        }

        public override long Encrypt(long value, int opts, int salt)
        {
            return value;
        }

        public override long Decrypt(long value, int opts, int salt)
        {
            return value;
        }

        public override float Encrypt(float value, int opts, int salt)
        {
            return value;
        }

        public override float Decrypt(float value, int opts, int salt)
        {
            return value;
        }

        public override double Encrypt(double value, int opts, int salt)
        {
            return value;
        }

        public override double Decrypt(double value, int opts, int salt)
        {
            return value;
        }

        public override byte[] Encrypt(byte[] value, int offset, int length, int opts, int salt)
        {
            if (length == 0)
            {
                return Array.Empty<byte>();
            }
            var encryptedBytes = new byte[length];
            Buffer.BlockCopy(value, offset, encryptedBytes, 0, length);
            return encryptedBytes;
        }

        public override byte[] Decrypt(byte[] value, int offset, int length, int ops, int salt)
        {
            if (length == 0)
            {
                return Array.Empty<byte>();
            }
            byte[] byteArr = new byte[length];
            Buffer.BlockCopy(value, 0, byteArr, 0, length);
            return byteArr;
        }

        public override byte[] Encrypt(string value, int ops, int salt)
        {
            return Encoding.UTF8.GetBytes(value);
        }

        public override string DecryptString(byte[] value, int offset, int length, int ops, int salt)
        {
            return Encoding.UTF8.GetString(value, offset, length);
        }
    }
}

```

`Runtime/NullEncryptor.cs.meta`:

```meta
fileFormatVersion: 2
guid: c53481f2ec513be4783a5ae2f76dc6e7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/ObfuscationInstincts.cs`:

```cs
namespace Obfuz
{
    public static class ObfuscationInstincts
    {
        /// <summary>
        /// Returns the original full name before obfuscated of the type T
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public static string FullNameOf<T>()
        {
            return typeof(T).FullName;
        }

        /// <summary>
        /// Returns the original name before obfuscated of the type T
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public static string NameOf<T>()
        {
            return typeof(T).Name;
        }

        /// <summary>
        /// register original type name to type mapping.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        public static void RegisterReflectionType<T>()
        {
            ObfuscationTypeMapper.RegisterType<T>(typeof(T).FullName);
        }
    }
}

```

`Runtime/ObfuscationInstincts.cs.meta`:

```meta
fileFormatVersion: 2
guid: 84320ab4adc4cbc49bf5e8f4009b4a96
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/ObfuscationTypeMapper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Reflection;

namespace Obfuz
{
    public static class ObfuscationTypeMapper
    {
        private static readonly Dictionary<Type, string> _type2OriginalFullName = new Dictionary<Type, string>();
        private static readonly Dictionary<Assembly, Dictionary<string, Type>> _originalFullName2Types = new Dictionary<Assembly, Dictionary<string, Type>>();

        internal static void RegisterType<T>(string originalFullName)
        {
            RegisterType(typeof(T), originalFullName);
        }

        internal static void RegisterType(Type type, string originalFullName)
        {
            if (_type2OriginalFullName.ContainsKey(type))
            {
                throw new ArgumentException($"Type '{type.FullName}' is already registered with original name '{_type2OriginalFullName[type]}'.");
            }
            _type2OriginalFullName.Add(type, originalFullName);
            Assembly assembly = type.Assembly;
            if (!_originalFullName2Types.TryGetValue(assembly, out var originalFullName2Types))
            {
                originalFullName2Types = new Dictionary<string, Type>();
                _originalFullName2Types[assembly] = originalFullName2Types;
            }
            if (originalFullName2Types.ContainsKey(originalFullName))
            {
                throw new ArgumentException($"Original full name '{originalFullName}' is already registered with type '{originalFullName2Types[originalFullName].FullName}'.");
            }
            originalFullName2Types.Add(originalFullName, type);
        }

        public static string GetOriginalTypeFullName(Type type)
        {
            return _type2OriginalFullName.TryGetValue(type, out string originalFullName)
                ? originalFullName
                : throw new KeyNotFoundException($"Type '{type.FullName}' not found in the obfuscation mapping.");
        }

        public static string GetOriginalTypeFullNameOrCurrent(Type type)
        {
            if (_type2OriginalFullName.TryGetValue(type, out string originalFullName))
            {
                return originalFullName;
            }
            return type.FullName;
        }

        public static Type GetTypeByOriginalFullName(Assembly assembly, string originalFullName)
        {
            if (_originalFullName2Types.TryGetValue(assembly, out var n2t))
            {
                if (n2t.TryGetValue(originalFullName, out Type type))
                {
                    return type;
                }
            }
            return null;
        }

        public static void Clear()
        {
            _type2OriginalFullName.Clear();
            _originalFullName2Types.Clear();
        }
    }

}

```

`Runtime/ObfuscationTypeMapper.cs.meta`:

```meta
fileFormatVersion: 2
guid: db6168acedd85984fa2c197fee1b0c15
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/Obfuz.Runtime.asmdef`:

```asmdef
{
    "name": "Obfuz.Runtime",
    "rootNamespace": "",
    "references": [],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}
```

`Runtime/Obfuz.Runtime.asmdef.meta`:

```meta
fileFormatVersion: 2
guid: 4140bd2e2764f1f47ab93125ecb61942
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/ObfuzIgnoreAttribute.cs`:

```cs
using System;

namespace Obfuz
{

    [AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = false)]
    public class ObfuzIgnoreAttribute : Attribute
    {
        public ObfuzScope Scope { get; set; }

        public bool ApplyToNestedTypes { get; set; } = true;

        public bool ApplyToChildTypes { get; set; } = false;

        public ObfuzIgnoreAttribute(ObfuzScope scope = ObfuzScope.All)
        {
            this.Scope = scope;
        }
    }
}

```

`Runtime/ObfuzIgnoreAttribute.cs.meta`:

```meta
fileFormatVersion: 2
guid: c2b4cf04729157b4dab504167ab5f703
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Runtime/ObfuzScope.cs`:

```cs
using System;

namespace Obfuz
{
    [Flags]
    public enum ObfuzScope
    {
        None = 0x0,
        TypeName = 0x1,
        Field = 0x2,
        MethodName = 0x4,
        MethodParameter = 0x8,
        MethodBody = 0x10,
        Method = MethodName | MethodParameter | MethodBody,
        PropertyName = 0x20,
        PropertyGetterSetterName = 0x40,
        Property = PropertyName | PropertyGetterSetterName,
        EventName = 0x100,
        EventAddRemoveFireName = 0x200,
        Event = EventName | PropertyGetterSetterName,
        Module = 0x1000,
        All = TypeName | Field | Method | Property | Event,
    }
}

```

`Runtime/ObfuzScope.cs.meta`:

```meta
fileFormatVersion: 2
guid: 3c7e51fe12f206347b08a4b0be48605d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`package.json`:

```json
{
  "name": "com.code-philosophy.obfuz",
  "version": "3.0.0-beta",
  "displayName": "Obfuz",
  "description": "Obfuz is an open-source Unity code obfuscation tool designed to provide Unity developers with a powerful, secure, and user-friendly code protection solution.",
  "category": "Scripting",
  "documentationUrl": "https://www.obfuz.com",
  "changelogUrl": "https://github.com/focus-creative-games/obfuz/commits/main/",
  "licensesUrl": "https://github.com/focus-creative-games/obfuz/blob/main/com.code-philosophy.obfuz/LICENSE",
  "keywords": [
    "obfuz",
    "obfuscation",
    "obfuscator",
    "confuser",
    "code-philosophy"
  ],
  "author": {
    "name": "Code Philosophy",
    "email": "obfuz@code-philosophy.com",
    "url": "https://code-philosophy.com"
  }
}
```

`package.json.meta`:

```meta
fileFormatVersion: 2
guid: 63433d029d2e08c46abd56175e308a15
PackageManifestImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```