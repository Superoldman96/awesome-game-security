Project Path: arc_gmh5225_Bloom-Anticheat_mwyzzl_c

Source Tree:

```txt
arc_gmh5225_Bloom-Anticheat_mwyzzl_c
├── AntiCheat
│   ├── AntiCheat.vcxproj
│   ├── AntiCheat.vcxproj.filters
│   ├── AntiCheat.vcxproj.user
│   ├── Source.cpp
│   ├── driver.cpp
│   ├── driver.h
│   ├── error.cpp
│   ├── error.h
│   ├── includes.h
│   ├── injection.cpp
│   ├── injection.h
│   ├── util.cpp
│   └── util.h
├── AntiCheat.sln
├── AnticheatDLL
│   ├── anticheat_x64.vcxproj
│   ├── anticheat_x64.vcxproj.filters
│   ├── anticheat_x64.vcxproj.user
│   ├── debugger.cpp
│   ├── debugger.h
│   ├── dllmain.cpp
│   ├── hook.cpp
│   ├── hook.h
│   ├── iat.cpp
│   ├── iat.h
│   ├── includes.h
│   ├── integrity.cpp
│   ├── integrity.h
│   ├── memory.cpp
│   ├── memory.h
│   ├── overlay.cpp
│   ├── overlay.h
│   ├── report.cpp
│   ├── report.h
│   ├── thread.cpp
│   └── thread.h
├── AnticheatDriver
│   ├── AnticheatDriver.inf
│   ├── AnticheatDriver.vcxproj
│   ├── AnticheatDriver.vcxproj.filters
│   ├── AnticheatDriver.vcxproj.user
│   ├── IOCTL.c
│   ├── IOCTL.h
│   ├── callbacks.c
│   ├── callbacks.h
│   ├── driver.c
│   └── includes.h
└── README.md

```

`AntiCheat.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31829.152
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AntiCheat", "AntiCheat\AntiCheat.vcxproj", "{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AnticheatDLL", "AnticheatDLL\anticheat_x64.vcxproj", "{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AnticheatDriver", "AnticheatDriver\AnticheatDriver.vcxproj", "{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}.Debug|ARM.ActiveCfg = Debug|Win32
		{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}.Debug|ARM64.ActiveCfg = Debug|Win32
		{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}.Debug|x64.ActiveCfg = Debug|x64
		{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}.Debug|x64.Build.0 = Debug|x64
		{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}.Debug|x86.ActiveCfg = Debug|Win32
		{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}.Debug|x86.Build.0 = Debug|Win32
		{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}.Release|ARM.ActiveCfg = Release|Win32
		{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}.Release|ARM64.ActiveCfg = Release|Win32
		{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}.Release|x64.ActiveCfg = Release|x64
		{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}.Release|x64.Build.0 = Release|x64
		{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}.Release|x86.ActiveCfg = Release|Win32
		{2E6C13D0-2E54-4096-ADC9-0D77D1B6FC5F}.Release|x86.Build.0 = Release|Win32
		{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}.Debug|ARM.ActiveCfg = Debug|Win32
		{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}.Debug|ARM64.ActiveCfg = Debug|Win32
		{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}.Debug|x64.ActiveCfg = Debug|x64
		{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}.Debug|x64.Build.0 = Debug|x64
		{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}.Debug|x86.ActiveCfg = Debug|Win32
		{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}.Debug|x86.Build.0 = Debug|Win32
		{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}.Release|ARM.ActiveCfg = Release|Win32
		{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}.Release|ARM64.ActiveCfg = Release|Win32
		{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}.Release|x64.ActiveCfg = Release|x64
		{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}.Release|x64.Build.0 = Release|x64
		{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}.Release|x86.ActiveCfg = Release|Win32
		{7701F9CD-1D73-4CBD-8DE9-A753F9AA16E4}.Release|x86.Build.0 = Release|Win32
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Debug|ARM.ActiveCfg = Debug|ARM
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Debug|ARM.Build.0 = Debug|ARM
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Debug|ARM.Deploy.0 = Debug|ARM
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Debug|ARM64.Build.0 = Debug|ARM64
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Debug|x64.ActiveCfg = Debug|x64
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Debug|x64.Build.0 = Debug|x64
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Debug|x64.Deploy.0 = Debug|x64
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Debug|x86.ActiveCfg = Debug|Win32
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Debug|x86.Build.0 = Debug|Win32
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Debug|x86.Deploy.0 = Debug|Win32
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Release|ARM.ActiveCfg = Release|ARM
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Release|ARM.Build.0 = Release|ARM
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Release|ARM.Deploy.0 = Release|ARM
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Release|ARM64.ActiveCfg = Release|ARM64
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Release|ARM64.Build.0 = Release|ARM64
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Release|ARM64.Deploy.0 = Release|ARM64
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Release|x64.ActiveCfg = Release|x64
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Release|x64.Build.0 = Release|x64
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Release|x64.Deploy.0 = Release|x64
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Release|x86.ActiveCfg = Release|Win32
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Release|x86.Build.0 = Release|Win32
		{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F0781CA6-502A-4EC1-801E-B8754839223F}
	EndGlobalSection
EndGlobal

```

`AntiCheat/AntiCheat.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{2e6c13d0-2e54-4096-adc9-0d77d1b6fc5f}</ProjectGuid>
    <RootNamespace>AntiCheat</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="driver.cpp" />
    <ClCompile Include="error.cpp" />
    <ClCompile Include="injection.cpp" />
    <ClCompile Include="Source.cpp" />
    <ClCompile Include="util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h" />
    <ClInclude Include="error.h" />
    <ClInclude Include="includes.h" />
    <ClInclude Include="injection.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`AntiCheat/AntiCheat.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="error.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="injection.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="error.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="injection.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`AntiCheat/AntiCheat.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`AntiCheat/Source.cpp`:

```cpp
#include "includes.h"
#include "memory.h"


FILE* f;
GLOBALS Globals;

//Make sure to change all the paths to where your actual driver file and dll are located, otherwise you will recieve errors
//The main purpose of this module is just to communicate with the driver, for all usermode detections take a look at the DLL

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR nCmdLine, int nCmdShow)
{
	//Allocate a console that can take input to debug errors, the file pointer will be stored globally

	AllocConsole();
	freopen_s(&f, "conout$", "w", stdout);
	freopen_s(&f, "conin$", "r", stdin);
	system("Color 0B");
	std::cout << "[+] Anticheat Initializing..." << std::endl;

	std::wstring consoleName = L"Anticheat currently protecting: ";
	consoleName += PROTECTED_PROCESS;
	SetConsoleTitleW(consoleName.c_str());

	//Wait for the process to be running, if it isnt the error handler will print a message saying to start the process

	while (!Util::isProcessRunning(PROTECTED_PROCESS))
	{
		Handler::TroubleshootError(PROCESS_NOT_RUNNING);
		Sleep(500);
	}
	std::cout << "\n[+] Process Found" << std::endl;


	//Obtain the protected ProcessId

	if (!Util::getRunningProcessId(PROTECTED_PROCESS))
	{
		if (!Handler::TroubleshootError(PROCESS_INVALID_PROCESSID))
		{
			Handler::ExitWithError(PROCESS_INVALID_PROCESSID);
			return 0;
		}
	}

	//Store some of our variables globally since we will need them to monitor the protected process
	Globals.processProcID = Util::getRunningProcessId(PROTECTED_PROCESS);
	Globals.hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Globals.processProcID);


	//Make sure valid handle has been established

	if (Globals.hProcess == INVALID_HANDLE_VALUE)
	{
		if (!Handler::TroubleshootError(PROCESS_INVALID_HANDLE))
		{
			Handler::ExitWithError(PROCESS_INVALID_HANDLE);
			return 0;
		}
	}
	std::wstring updateString = L"[+] Attached to ";
	updateString += PROTECTED_PROCESS;
	updateString += L": Process ID: ";
	std::wcout << updateString.c_str() << Globals.processProcID << std::endl;


	//Create a registry path and load the driver using the undocumented NtLoadDriver(). Test signing MUST be enabled unless your driver is signed
	//If you are not interested in using the driver just inject the DLL manually and do not worry about this module

	if (!Driver::LoadDriver())
	{
		if (!Handler::TroubleshootError(DRIVER_INVALID_LOAD))
		{
			Handler::ExitWithError(DRIVER_INVALID_LOAD);
			return 0;
		}
	}

	//Create a driver interface and establish communication with driver
	DriverObject KernelDriver = DriverObject();
	if (!KernelDriver.isConnected())
	{
		Handler::TroubleshootError(DRIVER_CONNECTION_ERROR);

		if (!KernelDriver.isConnected())
		{
			Handler::ExitWithError(DRIVER_CONNECTION_ERROR);
		}
	}

	ULONG ProcessIDs[2] = { GetCurrentProcessId(), Globals.processProcID };
	if (!KernelDriver.protectProcesses(ProcessIDs))
	{
		Handler::TroubleshootError(DRIVER_CANT_PROTECT);

		if (!KernelDriver.protectProcesses(ProcessIDs))
		{
			Handler::ExitWithError(DRIVER_CANT_PROTECT);
		}
	}
	

	//Inject dll to target process via a simple loadlibraryA injector. This is where all the usermode detection vectors are. This is critical in ensuring
	//usermode detection of cheats. We will pass through the already created handle since ObRegisterCallbacks will be stripping at this point

	if (!InjectDLL(Globals.hProcess))
	{
		if (!Handler::TroubleshootError(DLL_CANT_LOAD))
		{
			Handler::ExitWithError(DLL_CANT_LOAD);
			return 0;
		}
	}

	std::cout << "\n ===================================================" << std::endl;
	std::cout << " ================ Anticheat Running ================" << std::endl;
	std::cout << " ===================================================" << std::endl;

	while (Util::isProcessRunning(PROTECTED_PROCESS))
	{

		Sleep(6000);
	}
	system("CLS");
	std::cout << "[+] Cleaning up..." << std::endl;

	KernelDriver.Shutdown();
	Driver::Cleanup();

	std::cout << "[+] Closing..." << std::endl;
	Sleep(3000);
	return 0;
}
```

`AntiCheat/driver.cpp`:

```cpp
#include "includes.h"

#pragma comment(lib, "ntdll.lib")


tNtQuerySystemInformation oNtQuerySystemInformation;
tNtQueryObject oNtQueryObject;

tNtLoadDriver oNtLoadDriver;
tNtUnloadDriver oNtUnloadDriver;

LPCSTR driverPath = "\\SystemRoot\\System32\\drivers\\AnticheatDriver.sys";
std::wstring registryPath = L"System\\CurrentControlSet\\Services\\anticheatdriver";

//Create a new registry key for the driver so windows knows how to load the driver

bool Driver::CreateRegistry()
{	
	HKEY hKey;
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, registryPath.c_str(), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		//This would indicate the registry key already exists, so we can just return true
		return true;
	}

	if (RegCreateKeyW(HKEY_LOCAL_MACHINE, registryPath.c_str(), &hKey) != ERROR_SUCCESS)
	{
		//Key was not created
		return false;
	}

	DWORD dwData = 1;
	RegSetValueExA(hKey, "Type", 0, REG_DWORD, (BYTE*)&dwData, 4u);
	RegSetValueExA(hKey, "ErrorControl", 0, REG_DWORD, (BYTE*)&dwData, 4u);

	dwData = 3;
	RegSetValueExA(hKey, "Start", 0, REG_DWORD, (BYTE*)&dwData, 4u);
	RegSetValueExA(hKey, "ImagePath", 0, REG_SZ, (const BYTE*)driverPath, strlen(driverPath) + 1);

	return true;
}

//Start the new service by using NtLoadDriver. There are other methods but im using this since it works well
bool Driver::LoadDriver()
{
	if (!Util::EscalatePrivelages())
	{
		Handler::ExitWithError(CANT_ESCALATE_PRIV);
	}

	if (!PathFileExistsA("C:\\Windows\\System32\\drivers\\AnticheatDriver.sys"))
	{
		Handler::ExitWithError(DRIVER_BAD_PATH);
	}

	if (!Driver::CreateRegistry())
	{
		Handler::ExitWithError(CANT_ESCALATE_PRIV);
	}

	std::cout << "[+] Loading Driver..." << std::endl;

	HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");
	if (hNtdll == INVALID_HANDLE_VALUE || hNtdll == 0)
		return 0;

	//Cast the address of NtLoadDriver to our function pointer so we can call it
	oNtLoadDriver = (tNtLoadDriver)GetProcAddress(hNtdll, "NtLoadDriver");
	oNtUnloadDriver = (tNtUnloadDriver)GetProcAddress(hNtdll, "NtUnloadDriver");
	
	oNtQuerySystemInformation = (tNtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
	oNtQueryObject = (tNtQueryObject)GetProcAddress(hNtdll, "NtQueryObject");

	if (Driver::IsDriverAlreadyLoaded())
	{
		std::cout << "[+] Driver already loaded..." << std::endl;
		return true;
	}

	std::wstring loadRegPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\anticheatdriver";

	UNICODE_STRING regPath;
	RtlInitUnicodeString(&regPath, loadRegPath.c_str());

	if (!NT_SUCCESS(oNtLoadDriver(&regPath)))
	{
		return false;
	}

	Sleep(1000);
	std::cout << "[+] Driver Loaded!" << std::endl;

	return true;
}

bool Driver::IsDriverAlreadyLoaded()
{
	NTSTATUS Status;
	ULONG size;

	Status = oNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)11, NULL, 0, &size);
	if (Status != STATUS_INFO_LENGTH_MISMATCH)
	{
		//Error
	}

	PRTL_PROCESS_MODULES Modules = (PRTL_PROCESS_MODULES)VirtualAlloc(0, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (!Modules)
		return false;

	if (NT_SUCCESS(oNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)11, Modules, size, &size)))
	{
		for (int i = 0; i < Modules->NumberOfModules; i++)
		{
			if (strstr((char*)Modules->Modules[i].FullPathName, "AnticheatDriver.sys"))
			{
				VirtualFree(Modules, 0, MEM_RELEASE);
				return true;
			}
		}
	}

	if (Modules)
		VirtualFree(Modules, 0, MEM_RELEASE);

	return false;
}

bool Driver::Cleanup()
{
	std::wstring loadRegPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\anticheatdriver";

	UNICODE_STRING regPath;
	RtlInitUnicodeString(&regPath, loadRegPath.c_str());

	if (NT_SUCCESS(oNtUnloadDriver(&regPath)))
		std::cout << "[+] Driver unloaded" << std::endl;;

	HKEY hKey;
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, registryPath.c_str(), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		SHDeleteKeyW(HKEY_LOCAL_MACHINE, registryPath.c_str());
	}
	std::cout << "[+] Registry paths cleaned..." << std::endl;

	return true;
}


//==============================================================================================================================


//Default Constructor for the driver interface takes the service RegistryPath in which to establish communication 
DriverObject::DriverObject()
{
	hDriver = CreateFileA("\\\\.\\acDriverDevice", GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
}

//Check communication with the driver by sending a request and recieving the correct key back
BOOL DriverObject::isConnected()
{
	KERNEL_REQUEST Request;
	ZeroMemory(&Request, sizeof(KERNEL_REQUEST));
	Request.Buffer = 0;

	if (DeviceIoControl(this->hDriver, IO_STARTUPREQUEST, &Request, sizeof(Request), &Request, sizeof(Request), NULL, NULL))
	{
		if (Request.Buffer == 4)
		{
			std::cout << "[+] Driver connection established..." << std::endl;
			return TRUE;
		}
		else return FALSE;
	}
	else return FALSE;
}

//Cleanup the driver before unloading it
void DriverObject::Shutdown()
{
	
}

//Send a message to the driver telling it to use ObRegisterCallbacks on any handle created for that process
BOOL DriverObject::protectProcesses(ULONG ProcessIDS[2])
{
	KERNEL_REQUEST Request;
	ZeroMemory(&Request, sizeof(KERNEL_REQUEST));
	Request.ProcessIDs[0] = ProcessIDS[0];
	Request.ProcessIDs[1] = ProcessIDS[1];

	if (DeviceIoControl(this->hDriver, IO_PROTECTEDPROCESSINFO, &Request, sizeof(Request), &Request, sizeof(Request), NULL, NULL))
	{
		if (Request.Buffer == 1)
		{
			this->isProcessProtected = TRUE;
			std::cout << "[+] Processes protected by ObRegisterCallbacks!" << std::endl;
			return TRUE;
		}
		else return FALSE;
	}
	else return FALSE;

}

//Checks to see if there are any privelaged open handles with the game process and anticheat process that should not be there
BOOL DriverObject::areProcessesProtected()
{
	return this->isProcessProtected;

	if (!oNtQuerySystemInformation)
		return FALSE;

	PSYSTEM_HANDLE_INFORMATION HandleInfo;
	ULONG infoSize = 0x40000;

	HandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(infoSize);

	if (NT_SUCCESS(oNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0x10, HandleInfo, infoSize, NULL)))
	{
		for (int i = 0; i < HandleInfo->HandleCount; i++)
		{
			SYSTEM_HANDLE_TABLE_ENTRY_INFO currHandle = HandleInfo->Handles[i];

			if (currHandle.ProcessId != Globals.processProcID)
				continue;

			if ((currHandle.GrantedAccess & PROCESS_ALL_ACCESS) == 0 || (currHandle.GrantedAccess & PROCESS_VM_OPERATION) == 0)
				continue;

			POBJECT_TYPE_INFORMATION TypeInfo;
			
		}
	}

	free(HandleInfo);
	return TRUE;
}

//Grabs any report structures that have been filled out by the driver. Will exit if the number of reports reaches 3
BOOL DriverObject::QueryReports()
{
	KERNEL_QUERY Reports;
	ZeroMemory(&Reports, sizeof(KERNEL_QUERY));
	static int violationCount = 0;

	if (DeviceIoControl(this->hDriver, IO_QUERYREPORTS, NULL, NULL, &Reports, sizeof(Reports), NULL, NULL))
	{
		for (int i = 0; i < Reports.NumOfReports; i++)
		{
			if (Reports.Reports[i] == NULL)
				continue;

			violationCount++;
			if (violationCount >= 3)
				Handler::ExitWithError(DRIVER_TOO_MANY_VIOLATIONS);

			switch (Reports.Reports[i]->ReportID)
			{
				case KERNEL_HOOK:
				{
					std::cout << "[*] Anticheat has detected a hook in the kernel, violation number: " << violationCount << std::endl;
				}
			}
		}

		return TRUE;
	}

	return FALSE;
}
```

`AntiCheat/driver.h`:

```h
#include <Windows.h>
#include <mbstring.h>

#ifndef _DRIVER_INFO
#define _DRIVER_INFO

#include <windef.h>

//Define the IO Control codes
#define IO_STARTUPREQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1003, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IO_PROTECTEDPROCESSINFO CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1004, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IO_QUERYREPORTS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1005, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IO_CLEANUP CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1006, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

#define STATUS_INFO_LENGTH_MISMATCH 0x4

#endif

typedef NTSTATUS(*tNtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
typedef NTSTATUS(*tNtQueryObject)(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);

//Create a function pointer for the functions needed to work with a driver
typedef NTSTATUS(*tNtLoadDriver)(PUNICODE_STRING DriverServiceName);
typedef NTSTATUS(*tNtUnloadDriver)(PUNICODE_STRING DriverServiceName);

extern LPCSTR driverPath;
extern std::wstring registryPath;

//Loading and unloading the driver
namespace Driver
{
	bool CreateRegistry();
	bool LoadDriver();
	bool IsDriverAlreadyLoaded();
	bool Cleanup();
}


//Create an interface to communicate with the driver. This will handle all driver requests for us and will be called through the object
class DriverObject
{
private:
	HANDLE hDriver;
	BOOL isProcessProtected = FALSE;

public:

	DriverObject();

	BOOL isConnected();
	void Shutdown();

	BOOL protectProcesses(ULONG ProcessIDS[2]);
	BOOL areProcessesProtected();
	BOOL QueryReports();
};

enum KernelReports
{
	BLACKLISTED_MODULE_LOAD = 1,
	VULNERABLE_DRIVER_LOAD,
	KERNEL_HOOK,
	INVALID_RIP,
};

//Communication Structure with Kernel
typedef struct _KERNEL_REQUEST
{
	ULONG ProcessIDs[2];
	ULONG Buffer;
}KERNEL_REQUEST, * PKERNEL_REQUEST;

typedef struct _KERNEL_REPORT
{
	DWORD ReportID;
}KERNEL_REPORT, *PKERNEL_REPORT;

typedef struct _KERNEL_QUERY
{
	ULONG NumOfReports;
	PKERNEL_REPORT Reports[ANYSIZE_ARRAY];
}KERNEL_QUERY, * PKERNEL_QUERY;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	ULONG ProcessId;
	BYTE ObjectTypeNumber;
	BYTE Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
}SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
	ULONG HandleCount;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION {
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_ALL_TYPES_INFORMATION {
	ULONG NumberOfObjectTypes;
	OBJECT_TYPE_INFORMATION ObjectTypeInformation[1];
} OBJECT_ALL_TYPES_INFORMATION, * POBJECT_ALL_TYPES_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;
```

`AntiCheat/error.cpp`:

```cpp
#include "includes.h"


//Try and deal with all errors before exiting the process and shutting down the driver

BOOL Handler::TroubleshootError(DWORD errorNum)
{
	//If we can handle these cases without shutting down it will be much easier

	switch (errorNum)
	{
		case PROCESS_NOT_RUNNING:
		{
			std::wstring processNotRunningStr = L"[-] Please start ";
			processNotRunningStr += PROTECTED_PROCESS;

			std::wcout << processNotRunningStr.c_str() << "\r";
			break;
		}
		case PROCESS_INVALID_PROCESSID:
		{
			//Check again to make sure the process is actually running, and grab the processID. This error should never occur

			if (Util::isProcessRunning(PROTECTED_PROCESS))
			{
				DWORD procID = Util::getRunningProcessId(PROTECTED_PROCESS);

				if (procID)
					return TRUE;
				else return FALSE;
			}
			else return FALSE;
		}
		case PROCESS_INVALID_HANDLE:
		{
			if (OpenProcess(PROCESS_VM_READ, FALSE, Globals.processProcID) == INVALID_HANDLE_VALUE)
				return FALSE;
			else return TRUE;
		}
		case DLL_INVALID_PATH:
		{
			//Ask for a new dll path and if it is invalid exit with an error

			std::cout << "\nDLL must be in the same directory as the anticheat exe, enter the new path: ";
			std::string newPath;
			std::cin >> newPath;

			if (!PathFileExistsA(newPath.c_str()))
			{
				Handler::ExitWithError(DLL_INVALID_PATH);
			}
			else
			{
				dllPath = newPath;
				return TRUE;
			}
		}
		case DRIVER_INVALID_LOAD:
		{
			std::cout << "[-] Driver load failed, trying again..." << std::endl;
			if (Driver::Cleanup())
			{
				if (Driver::LoadDriver())
					return TRUE;
			}

			break;
		}
		case DLL_CANT_LOAD:
		{
			break;
		}
	}

	return FALSE;
}

//Provide the reason for failure and exit
void Handler::ExitWithError(DWORD errorNum)
{
	//State the reason for error, sleep 4 seconds, then shutdown

	switch (errorNum)
	{
		case PROCESS_NOT_RUNNING:
		{
			std::cout << "\n\n==========================================================================================\n" << std::endl;
			std::cout << "		Was unable to find the target process, shutting down..." << std::endl;
			break;
		}
		case PROCESS_INVALID_PROCESSID:
		{
			std::cout << "\n\n==========================================================================================\n" << std::endl;
			std::cout << "		Was unable to find the target process ID, shutting down..." << std::endl;
			break;
		}
		case CANT_ESCALATE_PRIV:
		{
			std::cout << "\n\n==========================================================================================\n" << std::endl;
			std::cout << "		Was unable to escalate privelages to load driver, shutting down" << std::endl;
			break;
		}
		case DLL_INVALID_PATH:
		{
			std::cout << "\n\n==========================================================================================\n" << std::endl;
			std::cout << "		Anticheat DLL path was invalid, shutting down..." << std::endl;
			break;
		}
		case DRIVER_BAD_PATH:
		{
			std::cout << "\n\n==========================================================================================\n" << std::endl;
			std::cout << "		Driver was not found inside System32/drivers directory, shutting down..." << std::endl;
			break;
		}
		case DRIVER_INVALID_LOAD:
		{
			std::cout << "\n\n==========================================================================================\n" << std::endl;
			std::cout << "		Could not load driver, make sure test signing is enabled" << std::endl;
			break;
		}
		case DLL_CANT_LOAD:
		{
			std::cout << "\n\n==========================================================================================\n" << std::endl;
			std::cout << "		Could not load the DLL into the target process. Try again" << std::endl;
			break;
		}
		case DRIVER_TOO_MANY_VIOLATIONS:
		{
			std::cout << "\n\n==========================================================================================\n" << std::endl;
			std::cout << "		Driver has likely detected a cheat, closing..." << std::endl;
			break;
		}
	}

	Sleep(5000);
	ExitProcess(0);
}
```

`AntiCheat/error.h`:

```h
#include <Windows.h>
#include <iostream>


//The main error handling system
namespace Handler
{
	BOOL TroubleshootError(DWORD errorNum);
	void ExitWithError(DWORD errorNum);
}

//Enum of all possible errors the Anticheat may encounter, used to troubleshoot
enum ERRORS
{
	PROCESS_NOT_RUNNING = 0,
	CANT_ESCALATE_PRIV,
	DRIVER_CONNECTION_ERROR,
	PROCESS_INVALID_PROCESSID,
	PROCESS_INVALID_HANDLE,
	PROCESS_FAULTY_START,
	ANTICHEAT_FAULT_START,
	DLL_INVALID_PATH,
	DLL_CANT_LOAD,
	DLL_INVALID_LOAD,
	DRIVER_BAD_PATH,
	DRIVER_INVALID_LOAD,
	DRIVER_NO_COMMUNICATION,
	DRIVER_CANT_PROTECT,
	DRIVER_TOO_MANY_VIOLATIONS,
};
```

`AntiCheat/includes.h`:

```h
#define _CRT_SECURE_NO_WARNINGS
#define _WIN32_LEAN_AND_MEAN

//Define needed headers and libraries
#include <Windows.h>
#include <iostream>
#include <winternl.h>
#include <thread>
#include <string>
#include <Shlwapi.h>

#pragma comment(lib, "Shlwapi.lib")

#include "util.h"
#include "driver.h"
#include "injection.h"
#include "error.h"

#define PROTECTED_PROCESS	L"notepad.exe"

extern tNtQuerySystemInformation oNtQuerySystemInformation;

//Global information that will be needed for the process
typedef struct GLOBALS
{
	HANDLE hProcess;
	DWORD processProcID;
	BOOL isInjected;
	int error;
};

//Define the globals
extern GLOBALS Globals;
extern FILE* f;

```

`AntiCheat/injection.cpp`:

```cpp
#include "includes.h"


//Anticheat dll file path here
std::string dllPath;
BOOL injectDLL = TRUE;


//Using a handle that was created before ObRegisterCallbacks began stripping, we will inject our DLL into the target process, which
//will handle its own integrity checks

BOOL InjectDLL(HANDLE hProc)
{
	if (!injectDLL)
		return TRUE;

	CHAR pathBuff[MAX_PATH] = { 0 };
	GetCurrentDirectoryA(MAX_PATH, pathBuff);

	//Path of anticheat_x64.dll, not relative
	dllPath = pathBuff;
	dllPath += "\\anticheatDLL.dll";

	//If the given dll path is not valid
	if (!PathFileExistsA(dllPath.c_str()))
	{
		if (!Handler::TroubleshootError(DLL_INVALID_PATH))
		{
			Handler::ExitWithError(DLL_INVALID_PATH);
		}
	}

	if (hProc == INVALID_HANDLE_VALUE)
		return FALSE;

	//Allocate memory for the dll path in the target process
	PVOID memAllocation = VirtualAllocEx(hProc, 0, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!memAllocation)
		return FALSE;

	//Write the dll path to the allocated memory
	if (!WriteProcessMemory(hProc, memAllocation, dllPath.c_str(), strlen(dllPath.c_str()) + 1, NULL))
		return FALSE;

	//Create a thread on LoadLibraryA and pass through the dllpath to load the new module
	HANDLE hThread = CreateRemoteThread(hProc, 0, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, memAllocation, 0, 0);
	if (hThread == INVALID_HANDLE_VALUE || hThread == 0)
		return FALSE;

	WaitForSingleObject(hThread, INFINITE);

	if (hThread)
		CloseHandle(hThread);

	std::cout << "[+] Anticheat DLL injected" << std::endl;
	return TRUE;
}

BOOL InjectLSASS()
{

}

BOOL InjectCSRSS()
{

}
```

`AntiCheat/injection.h`:

```h
#include <Windows.h>
#include <iostream>


//information needed for the injector
extern std::string dllPath;
extern BOOL injectDLL;

//All DLL related functions
BOOL InjectDLLs(DWORD ProtectedProcessID);
BOOL InjectDLL(HANDLE hProc);


//Both LSASS and CSRSS need handles to the game, meaning someone could inject into them and create a handle from within the process, then do there stuff. By
//Injecting into both of these, we can proxy the Read and Write process memory calls and prevent these types of calls to our protected process. Our driver will
//Handle all other processes VIA ObRegisterCallbacks().

BOOL InjectLSASS();
BOOL InjectCSRSS();
```

`AntiCheat/util.cpp`:

```cpp
#include "util.h"


BOOL Util::RespawnAsChild(LPCWSTR ProcessName)
{
	DWORD ProcID = Util::getRunningProcessId(ProcessName);
	if (!ProcID)
		return FALSE;

	HANDLE hFirstInstance = OpenProcess(PROCESS_TERMINATE, FALSE, ProcID);

	if (!TerminateProcess(hFirstInstance, 0))
		return FALSE;

	STARTUPINFOA StartupInfo;
	PROCESS_INFORMATION ProcessInfo;
	ZeroMemory(&StartupInfo, sizeof(STARTUPINFOA));
	ZeroMemory(&ProcessInfo, sizeof(PROCESS_INFORMATION));

	if (CreateProcessA("C:\\Windows\\notepad.exe", NULL, NULL, NULL, FALSE, 0, NULL, NULL, &StartupInfo, &ProcessInfo))
		return TRUE;
	else return FALSE;
}

BOOL Util::EscalatePrivelages()
{
	HANDLE tokenHandle;
	TOKEN_PRIVILEGES tp;
	LUID luid;

	if (!LookupPrivilegeValue(NULL, SE_LOAD_DRIVER_NAME, &luid))
		return FALSE;

	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &tokenHandle))
		return FALSE;

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	if (!AdjustTokenPrivileges(tokenHandle, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL))
		return FALSE;

	CloseHandle(tokenHandle);
	return TRUE;
}


//Check if process is running
BOOL Util::isProcessRunning(LPCWSTR processName)
{
	//Use ToolHelp32 to enumerate all running processes on the system
	HANDLE hSnap;
	PROCESSENTRY32 procEntry;

	hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	procEntry.dwSize = sizeof(PROCESSENTRY32);

	if (Process32First(hSnap, &procEntry))
	{
		if (lstrcmp(procEntry.szExeFile, processName) == 0)
			return true;
	}

	while (Process32Next(hSnap, &procEntry))
	{
		if (lstrcmp(procEntry.szExeFile, processName) == 0)
			return true;
	}

	return false;
}

//Obtain a process ID for a given process
DWORD Util::getRunningProcessId(LPCWSTR processName)
{
	HANDLE hSnap;
	PROCESSENTRY32 procEntry;

	hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	procEntry.dwSize = sizeof(PROCESSENTRY32);

	if (Process32First(hSnap, &procEntry))
	{
		if (lstrcmp(procEntry.szExeFile, processName) == 0)
		{
			return procEntry.th32ProcessID;
		}
	}

	while (Process32Next(hSnap, &procEntry))
	{
		if (lstrcmp(procEntry.szExeFile, processName) == 0)
		{
			return procEntry.th32ProcessID;
		}
	}

	return 0;
}

```

`AntiCheat/util.h`:

```h
#include <Windows.h>
#include <TlHelp32.h>


//Utility functions that will be used to initialize
namespace Util
{
	BOOL RespawnAsChild(LPCWSTR ProcessName);
	BOOL EscalatePrivelages();
	BOOL isProcessRunning(LPCWSTR processName);
	DWORD getRunningProcessId(LPCWSTR processName);
}
```

`AnticheatDLL/anticheat_x64.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7701f9cd-1d73-4cbd-8de9-a753f9aa16e4}</ProjectGuid>
    <RootNamespace>anticheatx64</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>AnticheatDLL</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;ANTICHEATX64_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;ANTICHEATX64_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;ANTICHEATX64_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;ANTICHEATX64_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>dbghelp.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="debugger.cpp" />
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="hook.cpp" />
    <ClCompile Include="iat.cpp" />
    <ClCompile Include="integrity.cpp" />
    <ClCompile Include="overlay.cpp" />
    <ClCompile Include="report.cpp" />
    <ClCompile Include="memory.cpp" />
    <ClCompile Include="thread.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="debugger.h" />
    <ClInclude Include="hook.h" />
    <ClInclude Include="iat.h" />
    <ClInclude Include="includes.h" />
    <ClInclude Include="integrity.h" />
    <ClInclude Include="overlay.h" />
    <ClInclude Include="report.h" />
    <ClInclude Include="memory.h" />
    <ClInclude Include="thread.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`AnticheatDLL/anticheat_x64.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="debugger.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="report.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="thread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="overlay.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="integrity.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="iat.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="includes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="debugger.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="report.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="thread.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="overlay.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="integrity.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="iat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`AnticheatDLL/anticheat_x64.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`AnticheatDLL/debugger.cpp`:

```cpp
#include "includes.h"

//Define certain debugger flags

#define FLG_HEAP_ENABLE_TAIL_CHECK   0x10
#define FLG_HEAP_ENABLE_FREE_CHECK   0x20
#define FLG_HEAP_VALIDATE_PARAMETERS 0x40
#define NT_GLOBAL_FLAG_CHECK (FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)

typedef NTSTATUS(WINAPI* tNtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
typedef NTSTATUS(WINAPI* tNtSetInformationThread)(HANDLE ThreadHandle, THREADINFOCLASS ThreadInfoClass, PVOID ThreadInformation, ULONG ThreadInformationLength);

//Compilation of many different methods to detect/prevent debuggers. Some of these can throw false positives, but most
//of them will work only on the case of a debugger. This will detect VEH debuggers, and can be quite useful. As already stated, feel free to alter these and disable/add new 
//protections

//You could use the FindWindow function and constantly search for things like cheat engine, memory-viewer, and x64dbgg however this is not a professional solution to debugging,
//its more of a hack. We want to keep this as less invasive as we can


tNtQuerySystemInformation oNtQuerySystemInformation;
tNtSetInformationThread oNtSetInformationThread;
PPEB pPeb = (PPEB)__readgsqword(0x60);

void Debugger::DebuggerThread()
{
	//Obtain the address and cast to a function pointer the ntdll export NtSetInformationThread()
	HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");
	if (hNtdll)
	{
		oNtQuerySystemInformation = (tNtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
		oNtSetInformationThread = (tNtSetInformationThread)GetProcAddress(hNtdll, "NtSetInformationThread");
	}

	while (true)
	{
		//Create the exception handlers and keep registering to beat VEH debuggers
		PVOID exceptionHandle = AddVectoredExceptionHandler(1, (PVECTORED_EXCEPTION_HANDLER)Debugger::HandleExceptions);

		if (Debugger::ReadPEBForDebugger() || Debugger::SpawnedUnderDebugger() || Debugger::CheckDebugString())
		{
			Report::SendReport(DEBUGGER_DETECTED);
		}

		SYSTEM_KERNEL_DEBUGGER_INFORMATION SysInfo;
		if (NT_SUCCESS(oNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0x23, &SysInfo, sizeof(SysInfo), NULL)))
		{
			if (SysInfo.DebuggerEnabled || !SysInfo.DebuggerNotPresent)
				Report::SendReport(KERNEL_DEBUGGING_ENABLED);
		}

		Sleep(4000);

		//Destroy the handler to re-register a new one as top priority
		if (exceptionHandle)
			RemoveVectoredExceptionHandler(exceptionHandle);
	}
}


//====================================================================================================================


BOOL Debugger::ReadPEBForDebugger()
{
	//Maually doing what IsDebuggerPresent() does
	if (pPeb->BeingDebugged)
	{
		return TRUE;
	}

	//Check process debug port via NtQueryInformationProcess()
	BOOL isDebugger = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &isDebugger);

	return isDebugger;
}

//Will see if the current process was started under a debugger, such as IDA or x64dbg
BOOL Debugger::SpawnedUnderDebugger()
{
	DWORD ntGlobalFlag = *(DWORD*)((PBYTE)pPeb + 0xBC);

	if (ntGlobalFlag & NT_GLOBAL_FLAG_CHECK)
		return TRUE;
	else return FALSE;
}

//If a debugger is attached, OutputDebugString will register an error
BOOL Debugger::CheckDebugString()
{
	SetLastError(0);
	OutputDebugString(L"Hello Debugger!");

	if (GetLastError() != 0)
		return TRUE;

	return FALSE;
}

//Check all the debug registers if a debug exception is thrown
LONG Debugger::HandleExceptions(PEXCEPTION_POINTERS exceptionInfo)
{
	//if a single step exception is thrown
	if (exceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_SINGLE_STEP)
	{
		if (exceptionInfo->ContextRecord->Dr0 != 0 || exceptionInfo->ContextRecord->Dr1 != 0
			|| exceptionInfo->ContextRecord->Dr2 != 0 || exceptionInfo->ContextRecord->Dr3 != 0
			|| exceptionInfo->ContextRecord->Dr6 != 0 || exceptionInfo->ContextRecord->Dr7 != 0)
		{
			//Debug registers are in use
			Report::SendReport(DEBUGGER_DETECTED);
		}
	}
	else if (exceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT)
	{
		//This would indicate a breakpoint has been set and hit
		Report::SendReport(DEBUGGER_DETECTED);
	}
	else if (exceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_DEBUG_EVENT)
	{
		Report::SendReport(DEBUGGER_DETECTED);
	}
	else if (exceptionInfo->ExceptionRecord->ExceptionCode == STATUS_GUARD_PAGE_VIOLATION)
	{
		//This could throw false positives but most of the time this will be effective in detecting GUARD_PAGE hooks
		Report::SendReport(DEBUGGER_DETECTED);
	}

	return EXCEPTION_CONTINUE_SEARCH;
}
```

`AnticheatDLL/debugger.h`:

```h
#include <Windows.h>


namespace Debugger
{
	//The continuous thread that will check our detection techniques and try and spot a debugger
	void DebuggerThread();

	//Debugger detections as well as the exception handler
	BOOL ReadPEBForDebugger();
	BOOL SpawnedUnderDebugger();
	BOOL CheckDebugString();
	LONG HandleExceptions(PEXCEPTION_POINTERS exceptionInfo);
}

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
	BOOLEAN DebuggerEnabled;
	BOOLEAN DebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION;
```

`AnticheatDLL/dllmain.cpp`:

```cpp
#include "includes.h"


//Defining main EXE PE header
PIMAGE_DOS_HEADER DosHeader;
PIMAGE_NT_HEADERS NtHeader;
PIMAGE_FILE_HEADER FileHeader;

FILE* f;

DWORD WINAPI StartupThread(HMODULE hModule)
{
    //Allocate a console for troubleshooting, this should be commented out when you are not debugging as the Report system
    //will create its own console and output there. This is just to check certain values
    
    AllocConsole();
    freopen_s(&f, "conout$", "w", stdout);
    SetConsoleTitleA("Debug");

    //Obtain information on the PE header of the executable. This will be used to traverse the module list
    //and gather other information stored in the PE header such as imports

    PVOID baseAddress = GetModuleHandle(NULL);
    DosHeader = (PIMAGE_DOS_HEADER)baseAddress;
    NtHeader = (PIMAGE_NT_HEADERS)((UINT_PTR)baseAddress + DosHeader->e_lfanew);
    FileHeader = (PIMAGE_FILE_HEADER)&NtHeader->FileHeader;


    //Install all of our hooks on commonly used API's such as GetAsyncKeyState. We can also block blacklisted modules from
    //being loaded by hooking LoadLibraryA

    if (!Hooks::InstallHooks())
    {
        Report::SendReport(INVALID_ANTICHEAT_START);
    }

    //Create threads for each of the detection loops to have efficiency as well as keep everything nice and neat. If a handle is invalid
    //the thread did not start which will not execute that set of detection techniques so we must throw an error

    HANDLE hDebuggerThread = CreateThread(0, 0, (PTHREAD_START_ROUTINE)Debugger::DebuggerThread, 0, 0, 0);
    HANDLE hMemoryThread = CreateThread(0, 0, (PTHREAD_START_ROUTINE)Memory::ScanMemory, 0, 0, 0);
    HANDLE hThreadMonitor = CreateThread(0, 0, (PTHREAD_START_ROUTINE)Thread::MonitorThreads, 0, 0, 0);
    HANDLE hOverlayThread = CreateThread(0, 0, (PTHREAD_START_ROUTINE)Overlay::OverlayThread, 0, 0, 0);
    HANDLE hIntegrityThread = CreateThread(0, 0, (PTHREAD_START_ROUTINE)Integrity::IntegrityThread, 0, 0, 0);

    if (hDebuggerThread == INVALID_HANDLE_VALUE || hMemoryThread == INVALID_HANDLE_VALUE || hThreadMonitor == INVALID_HANDLE_VALUE || hOverlayThread == INVALID_HANDLE_VALUE || hIntegrityThread == INVALID_HANDLE_VALUE)
    {
        Report::SendReport(INVALID_ANTICHEAT_START);
    }


    //Constant DLL main loop, any other checks you want to do that arent related to the other detection methods should
    //be done inside this loop for efficiency

    while (true)
    {
        if (GetAsyncKeyState(VK_F4) & 1)
        {
        }

        Sleep(6000);
    }

    return 0;
}

//Dll entry point, always best practice to create a new thread and then close the handle

BOOL APIENTRY DllMain( HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        CloseHandle(CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartupThread, hModule, 0, 0));
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


```

`AnticheatDLL/hook.cpp`:

```cpp
#include "includes.h"


//The hooks on this page will consist of a trampoline to restore the functionality of the original functions
//As long as you pass through an appropriate length for the hook, the below functions will take care of any BYTE restoring
// and redirects. This gives us total control flow over subsequent functions.

//There are many other functions that may be beneficial to hook, but im going to keep it basic in this example. It is CRUCIAL
//that inside of our integrity check thread we are constantly making sure our hook is in place and the address is pointing
//to our module, to make sure an attacker did not overwrite our hook to jump to their own version of the function


//Declare the function pointers as well as our functions we want to hook, and our blacklisted modules

tHLoadLibraryA oLoadLibraryA = nullptr;
tHLoadLibraryW oLoadLibraryW = nullptr;
tHKeyAsyncKeyState oGetAsyncKeyState = nullptr;
tNtQueryInformationProcess oNtQueryInformationProcess = nullptr;
tCreateWindowExA oCreateWindowExA = nullptr;

const char* FuncsToHook[] =
{
	"LoadLibraryA", "LoadLibraryW",
	"NtQueryVirtualMemory",
	"GetAsyncKeyState"
	"Direct3DCreate9"
};

const char* BlacklistedModules[] =
{
	"cheat.dll", "aimbot.dll", "esp.dll", "hack.dll"
	"dll.dll", "csgo.dll", "ac.dll", "battleye.dll"
};


//=============================================================================================================


//Place all of our hooks and redirect them to our version of the function. The only thing here that you will need to change
//Will be the length of the hook. Make sure you do not cut off the middle of an instruction or the process will crash

BOOL Hooks::InstallHooks()
{
	HMODULE hNtll =		GetModuleHandle(L"ntdll.dll");
	HMODULE hKernel32 = GetModuleHandle(L"kernel32.dll");
	HMODULE hKernelBase = GetModuleHandle(L"kernelbase.dll");
	HMODULE hUser32 = GetModuleHandle(L"user32.dll");

	if (hNtll && hKernel32 && hKernelBase && hUser32)
	{
		oLoadLibraryA = (tHLoadLibraryA)Hooks::Hook((BYTE*)GetProcAddress(hKernelBase, "LoadLibraryA"), (BYTE*)Hooks::hkLoadLibraryA, 5);
		oLoadLibraryW = (tHLoadLibraryW)Hooks::Hook((BYTE*)GetProcAddress(hKernelBase, "LoadLibraryW"), (BYTE*)Hooks::hkLoadLibraryW, 5);
		oGetAsyncKeyState = (tHKeyAsyncKeyState)Hooks::Hook((BYTE*)GetProcAddress(hUser32, "GetAsyncKeyState"), (BYTE*)Hooks::hkGetAsyncKeyState, 5);
		//oNtQueryInformationProcess = (tNtQueryInformationProcess)Hooks::Hook((BYTE*)GetProcAddress(hNtll, "NtQueryInformationProcess"), (BYTE*)Hooks::hkNtQueryInformationProcess, 8);
		//oCreateWindowExA = (tCreateWindowExA)Hooks::Hook((BYTE*)GetProcAddress(hUser32, "CreateWindowExA"), (BYTE*)Hooks::hkCreateWindowExA, 5);
	}
	else return FALSE;

	return TRUE;
}

void* Hooks::Hook(BYTE* src, BYTE* dst, size_t size)
{
	//Create a trampoline hook to automatically restore stolen bytes
	BYTE* newAlloc = (BYTE*)VirtualAlloc(0, size + 10, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!newAlloc)
		return NULL;

	uintptr_t newAddr = (uintptr_t)(src + size);
	DWORD relAddr = (DWORD)(dst - src - 5);

	DWORD gatewayProtect;
	if (VirtualProtect(newAlloc, size, PAGE_EXECUTE_READWRITE, &gatewayProtect))
	{
		memcpy(newAlloc, src, size);
		memcpy((BYTE*)(newAlloc + size), (BYTE*)"\x48\xBA", 2);
		memcpy((BYTE*)(newAlloc + size + 2), &newAddr, 8);
		memcpy((BYTE*)(newAlloc + size + 10), (BYTE*)"\xFF\xE2", 2);
		VirtualProtect(newAlloc, size, gatewayProtect, &gatewayProtect);
	}

	DWORD oldProtect;
	if (VirtualProtect(src, size, PAGE_EXECUTE_READWRITE, &oldProtect))
	{
		*src = 0xE9;
		*(DWORD*)(src + 1) = relAddr;
		VirtualProtect(src, size, oldProtect, &oldProtect);
	}

	return newAlloc;
}


//=================================================================================================


//Check the ASCI version of LoadLibrary to scan for blacklisted modules trying to load

HMODULE Hooks::hkLoadLibraryA(LPCSTR lpLibFileName)
{
	//Check if the module attempting to load is a blacklisted one
	for (int i = 0; i < sizeof(BlacklistedModules) / sizeof(BlacklistedModules[0]); i++)
	{
		if (strstr(lpLibFileName, BlacklistedModules[i]))
		{
			Report::SendReport(BLACKLISTED_DLL_DETECTED);
			break;
		}
	}

	return oLoadLibraryA(lpLibFileName);
}


//Check the WIDE version of LoadLibrary to scan for blacklisted modules trying to load

HMODULE Hooks::hkLoadLibraryW(LPCWSTR lpLibFileName)
{
	for (int i = 0; i < sizeof(BlacklistedModulesW) / sizeof(BlacklistedModulesW[0]); i++)
	{
		if (wcsstr(lpLibFileName, BlacklistedModulesW[i]))
		{
			Report::SendReport(BLACKLISTED_DLL_DETECTED);
			break;
		}
	}

	return oLoadLibraryW(lpLibFileName);
}


//Many cheats use GetAsyncKeyState to handle input since it is easy and they dont want to hijack the windows message handler. This can easily
//catch cheaters. Dont use this if your game uses this function as it will throw a false positive. 

SHORT Hooks::hkGetAsyncKeyState(int vKey)
{
	if (!Thread::WalkStack(GetCurrentThread()))
		Report::SendReport(MANUALMAPPED_MODULE);

	if (vKey == VK_INSERT || vKey == VK_F3)
		Report::SendReport(ODD_BAHAVIOR);

	return oGetAsyncKeyState(vKey);
}


//You can play around with this and spoof certain information, really not necessary though since you are already inside the protected process

NTSTATUS Hooks::hkNtQueryInformationProcess(HANDLE ProcessHandle, PROCESS_INFORMATION_CLASS InfoClass, PVOID ProcessInformation, ULONG ProcessInfoLength, PULONG ReturnLength)
{
	return oNtQueryInformationProcess(ProcessHandle, InfoClass, ProcessInformation, ProcessInfoLength, ReturnLength);
}


//A lot of cheat developers that are internal are too lazy to hijack the current window and create their overlay, so they instead create their own window
//within the context of the process to avoid anticheats from enumerating it. By hooking the create window functions, we can monitor any suspicous windows
//that may have been created from within our protected process

HWND Hooks::hkCreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int x, int y, int width, int height, HWND nHwndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
	if (!ProcessMainWindow)
		goto exit;

	//check to see the extended window values
	if ((dwExStyle & WS_EX_TRANSPARENT && dwExStyle & WS_EX_LAYERED) || dwExStyle & WS_EX_TOPMOST)
	{
		RECT rect = { 0 };
		GetWindowRect(ProcessMainWindow, &rect);

		//Check if the window being created is around the same size as the main window
		if (width >= (int)((rect.right - rect.left) * .9) && height >= (int)((rect.bottom - rect.top) * .9))
		{
			Report::SendReport(OVERLAY_DETECTED);
		}
	}

exit:
	return oCreateWindowExA(dwExStyle, lpClassName, lpWindowName, dwStyle, x, y, width, height, nHwndParent, hMenu, hInstance, lpParam);
}

```

`AnticheatDLL/hook.h`:

```h
#include <Windows.h>


//Function pointers to hooked functions
typedef HMODULE(APIENTRY* tHLoadLibraryA)(LPCSTR lpLibFileName);
typedef HMODULE(APIENTRY* tHLoadLibraryW)(LPCWSTR lpLibFileName);
typedef SHORT(APIENTRY* tHKeyAsyncKeyState)(int vKey);
typedef NTSTATUS(*tNtQueryInformationProcess)(HANDLE ProcessHandle, PROCESS_INFORMATION_CLASS InfoClass, PVOID ProcessInformation, ULONG ProcessInfoLength, PULONG ReturnLength);
typedef HWND(APIENTRY* tCreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int x, int y, int width, int height, HWND nHwndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);

//string arrays
extern const char* FuncsToHook[];
extern const char* BlacklistedModules[];
inline const wchar_t* BlacklistedModulesW[] = { L"cheat.dll", L"aimbot.dll", L"esp.dll", L"hack.dll", L"Cheat.exe"};

namespace Hooks
{
	//Functions that do our hooking
	BOOL InstallHooks();
	void* Hook(BYTE* src, BYTE* dst, size_t size);

	//Hooked functions
	HMODULE hkLoadLibraryA(LPCSTR lpLibFileName);
	HMODULE hkLoadLibraryW(LPCWSTR lpLibFileName);
	SHORT hkGetAsyncKeyState(int vKey);
	NTSTATUS hkNtQueryInformationProcess(HANDLE ProcessHandle, PROCESS_INFORMATION_CLASS InfoClass, PVOID ProcessInformation, ULONG ProcessInfoLength, PULONG ReturnLength);
	HWND hkCreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int x, int y, int width, int height, HWND nHwndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
}



```

`AnticheatDLL/iat.cpp`:

```cpp
#include "includes.h"


PIMAGE_DOS_HEADER DllDosHeader;
PIMAGE_NT_HEADERS DllNtHeader;

//Walk through the Import Address table of a given module and compare all function addresses to the actual address.
//Since we will use GetProcAddress to manually resolve the address, it is important that GetProcAddress itself is
//not hooked so we will check for this first
//
// @param base of the module whos IAT will be checked
// @return was an IAT hook found
//
BOOL IAT::ScanForIATHook(PVOID ImageBase)
{
	if (!DllDosHeader || !DllNtHeader)
	{
		DllDosHeader = (PIMAGE_DOS_HEADER)ImageBase;
		DllNtHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)ImageBase + DllDosHeader->e_lfanew);
	}

	IMAGE_DATA_DIRECTORY DataDirectory = DllNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)ImageBase + DataDirectory.VirtualAddress);

	LPCSTR libraryName = NULL;
	PIMAGE_IMPORT_BY_NAME functionName = NULL;

	if (!pImportDescriptor)
		return NULL;
	
	while (pImportDescriptor->Name != NULL)
	{
		libraryName = (LPCSTR)((ULONG_PTR)ImageBase + pImportDescriptor->Name);

		if (!GetModuleHandleA(libraryName))
		{
			pImportDescriptor++;
			continue;
		}

		PIMAGE_THUNK_DATA FirstThunk, OriginalThunk;
		FirstThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)ImageBase + pImportDescriptor->FirstThunk);
		OriginalThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)ImageBase + pImportDescriptor->OriginalFirstThunk);

		while (OriginalThunk->u1.AddressOfData != NULL)
		{
			functionName = (PIMAGE_IMPORT_BY_NAME)((ULONG_PTR)ImageBase + OriginalThunk->u1.AddressOfData);

			if (IAT::ManuallyResolveImports(functionName->Name, libraryName) != (PVOID)FirstThunk->u1.Function)
				return TRUE;

			++OriginalThunk;
			++FirstThunk;
		}

		++pImportDescriptor;
	}

	return FALSE;
}


//This will check to make sure the address of GetProcAddress in the IAT is inside of KERNEL32.dll. If someone were to
//IAT hook GetProcAddress they could redirect all functions resolved manually to their own implementation which would
//defeat the purpose of checking the IAT in the first place
//
// @param base of the module to check IAT's GetProcAddress function
// @return does the GetProcAddress import point to the proper location
//
BOOL IAT::IsGetProcAddressValid(PVOID ImageBase)
{
	if (!DllDosHeader || !DllNtHeader)
	{
		DllDosHeader = (PIMAGE_DOS_HEADER)ImageBase;
		DllNtHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)ImageBase + DllDosHeader->e_lfanew);
	}

	IMAGE_DATA_DIRECTORY DataDirectory = DllNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)ImageBase + DataDirectory.VirtualAddress);

	LPCSTR libraryName = NULL;
	PIMAGE_IMPORT_BY_NAME functionName = NULL;

	if (!pImportDescriptor)
		return NULL;

	while (pImportDescriptor->Name != NULL)
	{
		libraryName = (LPCSTR)((ULONG_PTR)ImageBase + pImportDescriptor->Name);

		if (strcmp(libraryName, "KERNEL32.dll"))
		{
			pImportDescriptor++;
			continue;
		}

		PIMAGE_THUNK_DATA FirstThunk, OriginalThunk;
		FirstThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)ImageBase + pImportDescriptor->FirstThunk);
		OriginalThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)ImageBase + pImportDescriptor->OriginalFirstThunk);

		while (OriginalThunk->u1.AddressOfData != NULL)
		{
			functionName = (PIMAGE_IMPORT_BY_NAME)((ULONG_PTR)ImageBase + OriginalThunk->u1.AddressOfData);

			if (strcmp(functionName->Name, "GetProcAddress") == 0)
			{
				PVOID checkAddr = (PVOID)FirstThunk->u1.Function;
				PVOID kernel32Base = GetModuleHandle(L"KERNEL32.dll");
				if (!kernel32Base)
					return FALSE;

				MODULEINFO mInfo;
				if (GetModuleInformation(GetCurrentProcess(), (HMODULE)kernel32Base, &mInfo, sizeof(MODULEINFO)))
				{
					if (checkAddr >= kernel32Base && (ULONG_PTR)checkAddr <= (ULONG_PTR)kernel32Base + mInfo.SizeOfImage)
						return TRUE;
					else return FALSE;
				}
				else return FALSE;
			}

			++OriginalThunk;
			++FirstThunk;
		}

		++pImportDescriptor;
	}

	return FALSE;
}


//Manually get the address of a function using GetProcAddress, first checking to make sure GetProcAddress is legit and not IAT hooked
//
// @param function name to resolve
// @param library which the function is located
// @return address of the function requested
//
PVOID IAT::ManuallyResolveImports(LPCSTR FuncName, LPCSTR libraryName)
{
	PVOID currModBase = GetModuleHandle(L"AnticheatDLL.dll");
	if (!currModBase)
		return NULL;

	static HMODULE hKernel32dll = GetModuleHandle(L"KERNEL32.dll");
	static HMODULE hUser32dll = GetModuleHandle(L"user32.dll");

	HMODULE currLibrary = GetModuleHandleA(libraryName);
	if (!currLibrary)
		return NULL;

	if (!IAT::IsGetProcAddressValid(currModBase))
		return FALSE;

	return GetProcAddress(currLibrary, FuncName);
}


//We wont use this but in case we wanted to monitor function calls from a specific module this would be the ideal way to do it

BOOL IAT::IatHook(PVOID ImageBase, LPCSTR RoutineName, PVOID hkFunc)
{

}


//============================================================================================================
```

`AnticheatDLL/iat.h`:

```h
#include <windows.h>

#ifndef _IAT_HEADER
#define _IAT_HEADER


#endif


namespace IAT
{
	BOOL ScanForIATHook(PVOID ImageBase);
	BOOL IsGetProcAddressValid(PVOID ImageBase);
	PVOID ManuallyResolveImports(LPCSTR FuncName, LPCSTR libraryName);
	BOOL IatHook(PVOID ImageBase, LPCSTR RoutineName, PVOID hkFunc);
}
```

`AnticheatDLL/includes.h`:

```h
#define WIN32_LEAN_AND_MEAN
#define _CRT_SECURE_NO_WARNINGS


//This project was put together as a compilation of the knowledge I have learned from not only developing cheats, but analyzing software on windows platforms.
//If you plan on implementing this into your application or game, I highly recommend obfuscating strings, packing this executable(VMProtect ideally), and not
//allowing this module to even touch disk. The "framework" I have made for this anticheat easily allows changes, and additions. The only real weakness I
//can personally see from within this module is the weak integrity check I have implemented. I will probably improve it over time but it will keep away
//most. All real external detections(excluding overlays) will be handled by the driver, and by the module our main .exe injects into CSRSS and LSASS that
//proxies all ReadProcessMemory and WriteProcessMemory calls ;)

#ifndef MAIN_HEADERS
#define MAIN_HEADERS

#include <iostream>
#include <stdio.h>
#include <Windows.h>
#include <TlHelp32.h>
#include <intrin.h>
#include <Psapi.h>
#include <winternl.h>
#include <string>
#include <thread>

#endif

#include "memory.h"
#include "thread.h"
#include "overlay.h"
#include "hook.h"
#include "report.h"
#include "integrity.h"
#include "iat.h"
#include "debugger.h"


//Header information of main executable image
extern PIMAGE_DOS_HEADER DosHeader;
extern PIMAGE_NT_HEADERS NtHeader;
extern PIMAGE_FILE_HEADER FileHeader;

extern FILE* f;




```

`AnticheatDLL/integrity.cpp`:

```cpp
#include "includes.h"


const char* hookedFuns[] = {"GetAsyncKeyState", "LoadLibraryA", "LoadLibraryW"};


VOID Integrity::IntegrityThread()
{
	while (true)
	{
		if (Integrity::AreHooksInPlace() != TRUE)
		{
			Report::SendReport(INTEGRITY_CHECK_VIOLATION);
		}

		if (Integrity::AreFunctionsSpoofed() == TRUE)
		{
			Report::SendReport(INTEGRITY_CHECK_VIOLATION);
		}

		if (IAT::ScanForIATHook(GetModuleHandle(L"AnticheatDLL.dll")))
		{
			Report::SendReport(IAT_HOOK_DETECTED);
		}

		Sleep(10000);
	}
}


//=======================================================================================================


//Check to see if the hooks we placed on initialization are still in place. If they arent, something has purposely overwritten
//them and action should be taken. We could also replace our hooks everytime this function is called as a counter measure.
//
BOOL Integrity::AreHooksInPlace()
{
	static HMODULE hUser32 = GetModuleHandle(L"user32.dll");
	if (hUser32 == INVALID_HANDLE_VALUE)
		return TRUE;

	BYTE* funcStart = (BYTE*)GetProcAddress(hUser32, "GetAsyncKeyState");

	if (*funcStart != 0xE9)
	{
		return FALSE;
	}

	return TRUE;
}


//Are any of our functions hooked or spoofed. Someone could hook isValidModuleAddr to always return true which will prevent
//our primary detection of suspicious threads and manually mapped modules
//
BOOL Integrity::AreFunctionsSpoofed()
{
	//An address we know will be vacant, should return FALSE unless someone hooks it
	if (Memory::isValidModuleAddr(0x2000) == TRUE)
	{
		return TRUE;
	}

	return FALSE;
}
```

`AnticheatDLL/integrity.h`:

```h
#include <Windows.h>

#ifndef _MODULE_INTEGRITY
#define _MODULE_INTEGRITY



#endif


namespace Integrity
{
	VOID IntegrityThread();
	BOOL AreHooksInPlace();
	BOOL AreFunctionsSpoofed();
}
```

`AnticheatDLL/memory.cpp`:

```cpp
#include "includes.h"


//Loop to check the memory detections and look for manually mapped modules. This will be effective if a blacklisted module is
//loaded before the anticheat is loaded, and it will also look for executable pages outside a valid module, indicating
//that a DLL or shellcode has been put in place

void Memory::ScanMemory()
{
    HANDLE hThread = GetCurrentThread();

    while (true)
    {
        if (Memory::isBlacklistedModuleFound())
        {
            Report::SendReport(BLACKLISTED_DLL_DETECTED);
            break;
        }
        
        Sleep(7000);
    }
}


//================================================================================================================


//Scan through the PEB loaded module list looking for blacklisted modules

BOOL Memory::isBlacklistedModuleFound()
{
    HANDLE hSnap;
    MODULEENTRY32 modEntry;
    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, GetCurrentProcessId());

    if (hSnap == INVALID_HANDLE_VALUE)
        return FALSE;

    modEntry.dwSize = sizeof(MODULEENTRY32);

    if (!Module32First(hSnap, &modEntry))
    {
        return FALSE;
    }

    for (int i = 0; i < sizeof(BlacklistedModulesW) / sizeof(BlacklistedModulesW[0]); i++)
    {
        if (wcsstr(modEntry.szModule, BlacklistedModulesW[i]))
            return TRUE;
    }

    while (Module32Next(hSnap, &modEntry))
    {
        for (int i = 0; i < sizeof(BlacklistedModulesW) / sizeof(BlacklistedModulesW[0]); i++)
        {
            if (wcsstr(modEntry.szModule, BlacklistedModulesW[i]))
                return TRUE;
        }
    }

    return FALSE;
}


//use VirtualQuery to scan through all memory pages within the process and find anomalies

BOOL Memory::ScanForExecutablePages()
{
    AllocConsole();
    FILE* f;
    freopen_s(&f, "conout$", "w", stdout);

    MEMORY_BASIC_INFORMATION memInfo;
    VirtualQuery(0, &memInfo, 4096);

    return TRUE;
}


//Pattern scan for known cheat images. I made this at like 2am so it probably is very inneficient but it should only
//return an addr when the full pattern is fine
//
// @param Pattern of bytes to search
// @param Mask of the pattern
// @return Address of the found pattern, NULL if not found
//
void* Memory::patternScan(const char* pattern, const char* mask)
{
    if (strlen(pattern) != strlen(mask) || mask[0] == '?')
        return NULL;

    BYTE* modBegin = (BYTE*)GetModuleHandle(0);
    MODULEINFO ModInfo;
    
    if (!GetModuleInformation(GetCurrentProcess(), GetModuleHandle(0), &ModInfo, sizeof(ModInfo)))
        return NULL;

    if (ModInfo.lpBaseOfDll != modBegin)
        return NULL;

    for (int i = 0; i < ModInfo.SizeOfImage; i++)
    {
        if (*(char*)(modBegin + i) == pattern[0])
        {
            for (int j = 1; j < strlen(pattern); j++)
            {
                if (mask[j] == '?')
                    continue;

                if (*(char*)(modBegin + i + j) != pattern[j])
                    break;

                if (j == strlen(pattern) - 1)
                    return (void*)(modBegin + i);
            }
        }
    }

    return NULL;
}


//Is the address given inside of a valid module 

bool Memory::isValidModuleAddr(uintptr_t address)
{
    MODULEENTRY32 modEntry;
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, GetCurrentProcessId());

    if (hSnap == INVALID_HANDLE_VALUE)
        return false;

    modEntry.dwSize = sizeof(MODULEENTRY32);

    if (!Module32First(hSnap, &modEntry))
    {
        return false;
    }

    if (address >= (uintptr_t)modEntry.modBaseAddr && address <= (uintptr_t)modEntry.modBaseAddr + (uintptr_t)modEntry.modBaseSize)
        return true;

    while (Module32Next(hSnap, &modEntry))
    {
        if (address >= (uintptr_t)modEntry.modBaseAddr && address <= (uintptr_t)modEntry.modBaseAddr + (uintptr_t)modEntry.modBaseSize)
            return true;
    }

    return false;
}
```

`AnticheatDLL/memory.h`:

```h
#include <Windows.h>


namespace Memory
{
	//Continous loop to execute the below functions and loop for manually mapped modules or blacklisted modules
	void ScanMemory();

	BOOL isBlacklistedModuleFound();
	BOOL ScanForExecutablePages();
	void* patternScan(const char* pattern, const char* mask);
	bool isValidModuleAddr(uintptr_t address);
}
```

`AnticheatDLL/overlay.cpp`:

```cpp
#include "includes.h"


//Detecting overlays is crucial in preventing external cheats relying on ReadProcessMemory and WriteProcessMemory. By enumerating all
//windows currently running, we can check the size of them and compare to the size of our application window. If a window has the same
//Size as our main process window and is not a well known module, we can report this for further analysis

//Any window with WS_EX_TOPMOST, WS_EX_TRANSPARENT, or WS_EX_LAYERED should be looked at more in detail since these are a basic need to
//have a transparent external overlay. After we confirm this, we simply compare the size and location on the screen to our window

HWND ProcessMainWindow = NULL;
char windowName[255];
int windowWidth, windowHeight, windowX, windowY;

const char* blacklistedWindowNames[] = { "CheatOverlay", "ESP window", "ESP"};

//Constantly enumerate all windows on the system and look for suspicious ones

void Overlay::OverlayThread()
{
	while (true)
	{
		EnumWindows(Overlay::EnumerateWindows, NULL);

		for (const char* currWindow : blacklistedWindowNames)
		{
			if (FindWindowA(NULL, currWindow))
				Report::SendReport(OVERLAY_DETECTED);
		}

		Sleep(5000);
	}
}

//Our function that will recieve the windows callback and decide what to do with the HWND
//
BOOL CALLBACK Overlay::EnumerateWindows(HWND hwnd, LPARAM lParam)
{
	DWORD procId = 0;
	GetWindowThreadProcessId(hwnd, &procId);

	//If its our window from our process we need to update its data
	if (procId == GetCurrentProcessId())
	{
		Overlay::GetMainWindowInfo(hwnd);
		return TRUE;
	}

	//If the window is suspicious we will stop the enumeration
	if (Overlay::IsSuspiciousWindow(hwnd))
		Report::SendReport(OVERLAY_DETECTED);

	return TRUE;
}
 

//============================================================================================================


//Checks the extended window attributes as well as the size and location of the window to decide if it should report
//
// @param handle to the window to check
// @return is the window suspicious
//
BOOL Overlay::IsSuspiciousWindow(HWND hwnd)
{
	if (!ProcessMainWindow)
	{
		return FALSE;
	}

	//Make sure its not our window
	DWORD procId;
	GetWindowThreadProcessId(hwnd, &procId);
	if (procId == GetCurrentProcessId())
		return FALSE;

	char currWindowName[255];
	GetWindowTextA(hwnd, currWindowName, 255);

	//If the current window is the NVIDIA Geforce overlay we will return FALSE since its always running transparent and full screen
	if (strcmp(currWindowName, "NVIDIA GeForce Overlay") == 0)
		return FALSE;

	RECT rect;
	GetWindowRect(hwnd, &rect);
	int currWidth = rect.right - rect.left;
	int currHeight = rect.bottom - rect.top;
	int currX = rect.left;
	int currY = rect.top;

	DWORD currExtendedStyle = GetWindowLong(hwnd, GWL_EXSTYLE);

	if ((currExtendedStyle & WS_EX_TOPMOST) != 0 || ((currExtendedStyle & WS_EX_TRANSPARENT) != 0 && (currExtendedStyle & WS_EX_LAYERED) != 0))
	{
		if ((currWidth == 1920 && currHeight == 1080) || (currWidth == GetSystemMetrics(SM_CXSCREEN) && currHeight == GetSystemMetrics(SM_CYSCREEN)))
		{
			if (Overlay::GatherMoreWindowInfo(hwnd, &rect) == WINDOW_SUSPICIOUS)
				return TRUE;
			else return FALSE;
		}
		if (currWidth == windowWidth && currHeight == windowHeight)
			return TRUE;
	}

	return FALSE;
}

//Constantly update the information regarding our processes main window just so that the data being compared in the IsSuspiciousWindow function
//is up to date and not returning false positives
//
// @param handle to the main protected process window
//
void Overlay::GetMainWindowInfo(HWND mainWindow)
{
	if (!mainWindow)
		return;

	ProcessMainWindow = mainWindow;

	RECT rect;
	GetWindowRect(ProcessMainWindow, &rect);
	if (rect.right == 0 || rect.bottom == 0)
		return;

	windowWidth = rect.right - rect.left;
	windowHeight = rect.bottom - rect.top;
	windowX = rect.left;
	windowY = rect.top;

	if (!GetWindowTextA(mainWindow, windowName, 255))
		return;
}


//This function will check to see if the owner of the window is a blacklisted process. It will open a handle, grab
//basic window info, and then perform a search to see if any blacklisted executables match the owner
// 
// @param handle to the window to check
// @param pointer to a RECT of the window dimensions
// @return status of what the function found
//
DWORD Overlay::GatherMoreWindowInfo(HWND hwnd, PRECT winDimensions)
{
	int currWidth = winDimensions->right - winDimensions->left;
	int currHeight = winDimensions->bottom - winDimensions->top;

	char windowName[255];
	GetWindowTextA(hwnd, windowName, sizeof(windowName));

	for (const char* currBlacklistedWindow : blacklistedWindowNames)
	{
		if (strcmp(windowName, currBlacklistedWindow) == 0)
			return WINDOW_SUSPICIOUS;
	}

	DWORD procID;
	GetWindowThreadProcessId(hwnd, &procID);

	HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procID);
	if (hProc == INVALID_HANDLE_VALUE)
		return WINDOW_SUSPICIOUS;
	
	wchar_t ProcessName[255];
	if (GetModuleFileNameExW(hProc, NULL, ProcessName, sizeof(ProcessName)))
	{
		for (const wchar_t* currProcess : BlacklistedModulesW)
		{
			if (currProcess == NULL || !wcsstr(currProcess, L".exe"))
				continue;

			if (wcsstr(ProcessName, currProcess))
			{
				return WINDOW_SUSPICIOUS;
			}
		}
	}

	CloseHandle(hProc);
	return WINDOW_OK;
}
```

`AnticheatDLL/overlay.h`:

```h
#include <Windows.h>

#ifndef _OVERLAY_DETECTION
#define _OVERLAY_DETECTION

//Nvidia should be whitelisted since its always on top and transparent
#define NVIDIAOVERLAY	"NVIDIA Geforce Experience"

//We will look for WS_EX_TOPMOST, WS_EX_LAYERED, and WS_EX_TRANSPARENT in the windows then check the dimensions

#endif // !_OVERLAY_DETECTION


//Store information on our processes main window so we can compare other external windows
extern HWND ProcessMainWindow;
extern char windowName[255];
extern int windowWidth, windowHeight, windowX, windowY;

namespace Overlay
{
	void OverlayThread();
	BOOL IsSuspiciousWindow(HWND hwnd);
	void GetMainWindowInfo(HWND mainWindow);
	BOOL CALLBACK EnumerateWindows(HWND hwnd, LPARAM lParam);
	DWORD GatherMoreWindowInfo(HWND hwnd, PRECT winDimensions);
}

enum SuspiciousWindow
{
	WINDOW_SUSPICIOUS = 1,
	WINDOW_OK
};
```

`AnticheatDLL/report.cpp`:

```cpp
#include "includes.h"


#define FLAGS_TO_BAN 7

//Anything you wish to do once an anomaly is found, such as uploading the file to the server, should be done here. 
//Ideally, the game/process would not close and you would instead flag/ban the user. In one of the switch cases I will
//create a struct containing info on the current user such as HWID info, and an example of uploading that to the server

//As stated before, some of the detection vectors used in this anticheat may throw false positives in specific cases, but
//of them have been tested and I feel confortable including them in this project


uint8_t flags = 0;

void Report::SendReport(DWORD reportCode)
{
	AllocConsole();
	freopen_s(&f, "conout$", "w", stdout);
	system("Color 0C");
	SetConsoleTitleA("Attention!");

	std::cout << "Anticheat has encountered the following issue(s):\n " << std::endl;

	switch (reportCode)
	{
		case INVALID_ANTICHEAT_START:
		{
			std::cout << "[*] Anticheat DLL failed to initialize correctly, closing..." << std::endl;
			break;
		}
		case INTEGRITY_CHECK_VIOLATION:
		{
			std::cout << "[*] One or more integrity checks have failed, closing..." << std::endl;
			break;
		}
		case CANNOT_QUEUE_APCS:
		{
			std::cout << "[*] Anticheat was unable to queue APC's to process thread, closing..." << std::endl;
			break;
		}
		case MANUALMAPPED_MODULE:
		{
			std::cout << "[*] Manually maped module detected, closing..." << std::endl;
			break;
		}
		case HOOK_DETECTED:
		{
			std::cout << "[*] Hook has been detected, closing..." << std::endl;
			break;
		}
		case IAT_HOOK_DETECTED:
		{
			std::cout << "[*] An IAT Hook has been detected in AnticheatDLL.dll, shutting down..." << std::endl;
			break;
		}
		case DEBUGGER_DETECTED:
		{
			std::cout << "[*] Debugger was detected, closing..." << std::endl;
			break;
		}
		case KERNEL_DEBUGGING_ENABLED:
		{
			std::cout << "[*] Please disable kernel debugging" << std::endl;
			break;
		}
		case BLACKLISTED_DLL_DETECTED:
		{
			std::cout << "[*] Blacklisted DLL attempted to load, closing..." << std::endl;
			break;
		}
		case ODD_BAHAVIOR:
		{
			std::cout << "[*] Odd process bahavior, possible Manually Mapped module..." << std::endl;
			break;
		}
		case OVERLAY_DETECTED:
		{
			std::cout << "[*] Suspicious overlay found above game process, closing..." << std::endl;
			break;
		}
		case RIP_OUTSIDE_VALID_MODULE:
		{
			std::cout << "[*] Instruction Pointer has been detected outside a valid module" << std::endl;
			break;
		}
	}

	Sleep(5000);
	ExitProcess(0);
}
```

`AnticheatDLL/report.h`:

```h
#include <Windows.h>


//This is a good place to add other functions to gather HWID info and upload information to your server

namespace Report
{
	void SendReport(DWORD reportCode);
}

//Our report structure to fill out so we can return info

typedef struct newReport
{
	DWORD reason;
	HANDLE hApplication, hThread;
	LPCSTR dllName;
	HWND hWindow;
	LPCSTR windowName;
};

//Anything you want to report for should be thrown into the enum and handled inside the Report::SendReport handler

enum reports
{
	INVALID_ANTICHEAT_START = 1,
	INTEGRITY_CHECK_VIOLATION,
	CANNOT_QUEUE_APCS,
	MANUALMAPPED_MODULE,
	HOOK_DETECTED,
	IAT_HOOK_DETECTED,
	DEBUGGER_DETECTED,
	KERNEL_DEBUGGING_ENABLED,
	BLACKLISTED_DLL_DETECTED,
	ODD_BAHAVIOR,
	OVERLAY_DETECTED,
	RIP_OUTSIDE_VALID_MODULE
};
```

`AnticheatDLL/thread.cpp`:

```cpp
#include "includes.h"


//One good way of monitoring code execution is by Queueing Asynchronous Procedure Calls to every thread running in a process.
//By doing this we can have our own function execute inside the context of every single thread, which makes it easier for us 
//to run a stack trace or analyze the stack frames. We must continuously queue APC's every few seconds

DWORD processThreads[100];


//This thread is in charge of running our checks and constantly gathering thread information. We create a thread to execute this function
//inside the dllmain. Any other checks you want to run on threads should be initialized in here

void Thread::MonitorThreads()
{
	static BOOL isValid = TRUE;

	while (true)
	{
		//Make sure all threads are up to date
		GetProcessThreads();

		//Check the instruction pointer of all threads before queuing an APC. For malicious threads that dont enter an alertable state,
		//this will eventually catch them executing their logic

		for (DWORD currThreadId : processThreads)
		{
			if (!currThreadId)
				continue;

			HANDLE hCurrThread = OpenThread(THREAD_ALL_ACCESS, FALSE, currThreadId);
			if (hCurrThread == INVALID_HANDLE_VALUE)
				continue;

			Thread::isRipValid(hCurrThread, &isValid);

			CloseHandle(hCurrThread);
		}
		if (!isValid)
			Report::SendReport(RIP_OUTSIDE_VALID_MODULE);
		

		//Queue the APCS to all the threads
		if (QueueApcs((PAPCFUNC)ApcFunction) != SUCCESSFULLY_QUEUED)
			std::cout << "Failed to queue APCS" << std::endl;

		Sleep(7000);
	}
}


//===========================================================================================================


//Apc function to be executed on every thread that enters an alertable state. Some threads may never execute this
//however our function that checks RIP should eventually catch them
//
PAPCFUNC ApcFunction(ULONG_PTR Arg)
{
	HANDLE hThread = GetCurrentThread();

	//This will check where each thread came from, if outside of a valid module it will submit a report
	if (!Thread::WalkStack(GetCurrentThread()))
	{
		Report::SendReport(RIP_OUTSIDE_VALID_MODULE);
	}

	CloseHandle(hThread);
	return 0;
}
 
// Queue the apcs to every thread in the process
//
// @param Address of our APC function
// @return status of the APC queue
//
DWORD QueueApcs(PAPCFUNC func)
{
	if (!processThreads)
		return NO_THREAD_INFORMATION;

	for (DWORD currThread : processThreads)
	{
		if (!currThread)
			continue;

		HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, currThread);
		if (hThread == INVALID_HANDLE_VALUE || hThread == 0)
			continue;
		
		if (!QueueUserAPC(func, hThread, 0))
			return FAILED_TO_QUEUE;

		CloseHandle(hThread);
	}

	return SUCCESSFULLY_QUEUED;
}


//========================================================================================================


//Checks if the instruction pointer of a given thread is currently in a valid module. If unsigned code is
//Being executed this will return false and we will know shellcode has been injected, or a manually mapped module
//
// @param handle of the thread to grab context
// @param pointer to a BOOLEAN which holds if RIP has been outside a valid module
// @return was the thread context successfully captured
//
bool Thread::isRipValid(HANDLE hThread, PBOOL isValid)
{
	STACKFRAME64 sFrame;
	CONTEXT sContext;
	ZeroMemory(&sFrame, sizeof(STACKFRAME64));
	ZeroMemory(&sContext, sizeof(CONTEXT));
	sContext.ContextFlags = CONTEXT_CONTROL;

	if (GetThreadId(hThread) == GetCurrentThreadId())
		RtlCaptureContext(&sContext);
	else
	{
		SuspendThread(hThread);
		GetThreadContext(hThread, &sContext);
		ResumeThread(hThread);
	}

	sFrame.AddrPC.Offset = sContext.Rip;
	sFrame.AddrPC.Mode = AddrModeFlat;
	sFrame.AddrStack.Offset = sContext.Rsp;
	sFrame.AddrStack.Mode = AddrModeFlat;
	sFrame.AddrFrame.Offset = sContext.Rbp;
	sFrame.AddrFrame.Mode = AddrModeFlat;
	
	//This isnt necessary but good practice because it obtains a full stack trace of the given thread
	if (StackWalk64(FileHeader->Machine, GetCurrentProcess(), hThread, &sFrame, &sContext, NULL, NULL, NULL, NULL))
	{
		if (Memory::isValidModuleAddr((uintptr_t)sFrame.AddrPC.Offset))
		{
			*isValid = TRUE;
			return true;
		}
	}
	else return false;

	*isValid = FALSE;
	return true;
}

bool Thread::checkPrevAddr(HANDLE hThread)
{
	PVOID stackTrace[1] = { 0 };

	if (RtlCaptureStackBackTrace(0, 1, stackTrace, NULL))
	{
		if (!Memory::isValidModuleAddr((uintptr_t)stackTrace[0]))
			return false;
	}

	return true;
}


//Will initiate a stack trace and log up to the previous 10 stack frames. If any of the return addresses are not from a valid module,
//the function will return false and a report will be submitted for RIP_OUTSIDE_VALID_MODULE
//
//this is EXTREMELY efficient in catching manually mapped modules as at some point, the cheat thread will call a function and we can
//immidiately catch the return address as being outside a valid module. To do further checks, you could VirtualQuery the address and
//upload the whole module or function to your server
//
// @param Handle to the thread to stackwalk
// @return if the thread has been outside a valid module
//
bool Thread::WalkStack(HANDLE hThread)
{
	PVOID stackTrace[10] = { 0 };

	if (RtlCaptureStackBackTrace(0, 10, stackTrace, NULL))
	{
		for (PVOID currRetAddr : stackTrace)
		{
			if (!currRetAddr)
				continue;

			if (!Memory::isValidModuleAddr((uintptr_t)currRetAddr))
				return false;
		}
	}

	return true;
}


//=====================================================================================================================


//Obtain all of the threads currently running in the process using Tlhelp32 THREADENTRY32
//
// @return are threads updated
//
BOOL GetProcessThreads()
{
	THREADENTRY32 threadEntry;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (hSnap == INVALID_HANDLE_VALUE)
		return FALSE;

	threadEntry.dwSize = sizeof(THREADENTRY32);

	if (!Thread32First(hSnap, &threadEntry))
		return FALSE;

	int curr = 0;
	while (Thread32Next(hSnap, &threadEntry))
	{
		if (threadEntry.th32OwnerProcessID == GetCurrentProcessId())
		{
			if (!threadEntry.th32ThreadID)
				continue;

			if (curr >= 100)
				break;

			processThreads[curr] = threadEntry.th32ThreadID;
			curr++;
		}
	}

	CloseHandle(hSnap);
	return TRUE;
}

```

`AnticheatDLL/thread.h`:

```h
#include <Windows.h>
#include <winnt.h>
#include <DbgHelp.h>

#define MAX_TRACE_DEPTH 10

extern DWORD processThreads[100];

//Apc handler and function to queue
PAPCFUNC ApcFunction(ULONG_PTR Arg);
DWORD QueueApcs(PAPCFUNC func);

//Obtain all threads in current process
BOOL GetProcessThreads();

namespace Thread
{
	bool isRipValid(HANDLE hThread, PBOOL isValid);
	bool checkPrevAddr(HANDLE hThread);
	bool WalkStack(HANDLE hThread);

	//Thread in charge of queueing apcs and checking RIP
	void MonitorThreads();
}

enum APCQUEUE
{
	SUCCESSFULLY_QUEUED,
	NO_THREAD_INFORMATION,
	FAILED_TO_QUEUE
};

```

`AnticheatDriver/AnticheatDriver.inf`:

```inf
;
; AnticheatDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=asd ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD9171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=AnticheatDriver.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
AnticheatDriver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
AnticheatDriver.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%AnticheatDriver.DeviceDesc%=AnticheatDriver_Device, Root\AnticheatDriver ; TODO: edit hw-id

[AnticheatDriver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
AnticheatDriver.sys

;-------------- Service installation
[AnticheatDriver_Device.NT.Services]
AddService = AnticheatDriver,%SPSVCINST_ASSOCSERVICE%, AnticheatDriver_Service_Inst

; -------------- AnticheatDriver driver install sections
[AnticheatDriver_Service_Inst]
DisplayName    = %AnticheatDriver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\AnticheatDriver.sys

;
;--- AnticheatDriver_Device Coinstaller installation ------
;

[AnticheatDriver_Device.NT.CoInstallers]
AddReg=AnticheatDriver_Device_CoInstaller_AddReg
CopyFiles=AnticheatDriver_Device_CoInstaller_CopyFiles

[AnticheatDriver_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[AnticheatDriver_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[AnticheatDriver_Device.NT.Wdf]
KmdfService =  AnticheatDriver, AnticheatDriver_wdfsect
[AnticheatDriver_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "AnticheatDriver Installation Disk"
AnticheatDriver.DeviceDesc = "AnticheatDriver Device"
AnticheatDriver.SVCDESC = "AnticheatDriver Service"

```

`AnticheatDriver/AnticheatDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{AE9F319D-3B1B-4F8B-8E70-93D30AB1D0D2}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>AnticheatDriver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="callbacks.c" />
    <ClCompile Include="driver.c" />
    <ClCompile Include="IOCTL.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="callbacks.h" />
    <ClInclude Include="includes.h" />
    <ClInclude Include="IOCTL.h" />
  </ItemGroup>
  <ItemGroup>
    <Inf Include="AnticheatDriver.inf" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`AnticheatDriver/AnticheatDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="callbacks.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IOCTL.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="callbacks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IOCTL.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="AnticheatDriver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
</Project>
```

`AnticheatDriver/AnticheatDriver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`AnticheatDriver/IOCTL.c`:

```c
#include "includes.h"


ULONG ProtectedProcessIDs[2];
PEPROCESS ProtectedProcesses[2];

//All of our device major functions to deal with our IOCTL Requests will be put in here. Create call and close call are used per every call, while
//IoControl is what decides what to do with the given code. In this function we will handle all IOCTL codes

NTSTATUS CreateCall(PDEVICE_OBJECT pDeviceObject, PIRP Irp)
{
	UNREFERENCED_PARAMETER(pDeviceObject);
	UNREFERENCED_PARAMETER(Irp);

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS CloseCall(PDEVICE_OBJECT pDeviceObject, PIRP Irp)
{
	UNREFERENCED_PARAMETER(pDeviceObject);
	UNREFERENCED_PARAMETER(Irp);

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS IoControl(PDEVICE_OBJECT pDeviceObject, PIRP Irp)
{
	UNREFERENCED_PARAMETER(pDeviceObject);
	UNREFERENCED_PARAMETER(Irp);

	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	ULONG BytesIo = 0;

	PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG ControlCode = Stack->Parameters.DeviceIoControl.IoControlCode;

	//Handle our IOCTL codes here
	if (ControlCode == IO_STARTUPREQUEST)
	{
		PKERNEL_REQUEST Request = (PKERNEL_REQUEST)Irp->AssociatedIrp.SystemBuffer;

		//Send the number 4 to the buffer so the usermode application knows the driver is operation normally
		Request->Buffer = 4;

		Status = STATUS_SUCCESS;
		BytesIo = sizeof(KERNEL_REQUEST);
	}
	else if (ControlCode == IO_PROTECTEDPROCESSINFO)
	{
		PKERNEL_REQUEST Request = (PKERNEL_REQUEST)Irp->AssociatedIrp.SystemBuffer;
		if (NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)Request->ProcessIDs[0], &ProtectedProcesses[0])) && NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)Request->ProcessIDs[1], &ProtectedProcesses[1])))
		{
			//If we are updating the processes to protect we dont want to create a new callback
			DbgPrintEx(0, 0, "[Bloom Anticheat] Process IDS %i %i", Request->ProcessIDs[0], Request->ProcessIDs[1]);
			if (!ObRegistrationHandle)
				RegisterObCallbacks();
	
			Request->Buffer = 1;
		}
		else Request->Buffer = 0;

		Status = STATUS_SUCCESS;
		BytesIo = sizeof(KERNEL_REQUEST);
	}

	Irp->IoStatus.Status = Status;
	Irp->IoStatus.Information = BytesIo;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
```

`AnticheatDriver/IOCTL.h`:

```h
#ifndef _DRIVER_INCLUDES
#define _DRIVER_INCLUDES

#include <ntifs.h>
#include <ntddk.h>
#include <ntdef.h>
#include <fltKernel.h>

#endif

//Define all IOCTL codes here
#define IO_STARTUPREQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1003, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IO_PROTECTEDPROCESSINFO CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1004, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IO_QUERYREPORTS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1005, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IO_CLEANUP CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1006, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)


//Protected Process information
extern ULONG ProtectedProcessIDs[2];
extern PEPROCESS ProtectedProcesses[2];

//Major functions
NTSTATUS CreateCall(PDEVICE_OBJECT pDeviceObject, PIRP Irp);
NTSTATUS CloseCall(PDEVICE_OBJECT pDeviceObject, PIRP Irp);
NTSTATUS IoControl(PDEVICE_OBJECT pDeviceObject, PIRP Irp);


//Communication Structure with usermode
typedef struct _KERNEL_REQUEST
{
	ULONG ProcessIDs[2];
	ULONG Buffer;
}KERNEL_REQUEST, *PKERNEL_REQUEST;
```

`AnticheatDriver/callbacks.c`:

```c
#include "includes.h"


//Driver manual mappers set the name of the driver to nothing, which in turn will bypass MmUnloadedDrivers. The 
//rest of these are known vulnerable drivers that someone may be abusing, this list could be much longer
WCHAR* blacklistedModules[20] = { L"iqvw64e.sys", L"AsUpIO64.sys", L"BS_Flash64.sys", L"Phymemx64.sys", L"kdmapper.exe"};

//Define variables and structures we will need for ObRegisterCallbacks()
OB_OPERATION_REGISTRATION OperationRegistration;
OB_CALLBACK_REGISTRATION CallbackRegistration;
PVOID ObRegistrationHandle;


//One of the greatest things about having a driver is the abillity to register callbacks ranging from dealing with Non-maskable interupts, to
//image loading of any type. The main functionality of our driver will be held within our callbacks. We will call ObRegisterCallbacks on our
//protected process, as well as our AntiCheat process to prevent anyone in usermode from tampering with them. We will also check for any abused
//drivers being loaded on the system while the driver is running :)

//Setup the callback registration structs and call ObRegisterCallbacks. Here we will define a callback for Process handles but
//you can create another one to monitor thread(this may be added in the future)

NTSTATUS RegisterObCallbacks()
{
	RtlSecureZeroMemory(&OperationRegistration, sizeof(OB_OPERATION_REGISTRATION));
	RtlSecureZeroMemory(&CallbackRegistration, sizeof(OB_CALLBACK_REGISTRATION));

	UNICODE_STRING callbackAltitude;
	RtlInitUnicodeString(&callbackAltitude, L"1986");

	OperationRegistration.ObjectType = PsProcessType;
	OperationRegistration.Operations |= OB_OPERATION_HANDLE_CREATE;
	OperationRegistration.Operations |= OB_OPERATION_HANDLE_DUPLICATE;
	OperationRegistration.PreOperation = PreOperationCallback;
	OperationRegistration.PostOperation = NULL;

	CallbackRegistration.Version = OB_FLT_REGISTRATION_VERSION;
	CallbackRegistration.Altitude = callbackAltitude;
	CallbackRegistration.OperationRegistrationCount = 1;
	CallbackRegistration.RegistrationContext = NULL;
	CallbackRegistration.OperationRegistration = &OperationRegistration;

	return ObRegisterCallbacks(&CallbackRegistration, &ObRegistrationHandle);
}


//Our callback function that will be called everytime something tries to create a handle. We will filter this out to only monitor the processes
//we care about and want to protect

OB_PREOP_CALLBACK_STATUS PreOperationCallback(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OpInfo)
{ 
	UNREFERENCED_PARAMETER(RegistrationContext);
	ASSERT(OpInfo->CallContext == NULL);

	ACCESS_MASK BitsToClear = 0;
	ACCESS_MASK BitsToSet = 0;
	PACCESS_MASK DesiredAccess = NULL;

	if (OpInfo->ObjectType == *PsProcessType)
	{
		if (ProtectedProcesses[0] == NULL || (ProtectedProcesses[0] != NULL && OpInfo->Object != ProtectedProcesses[0]) && (ProtectedProcesses[1] != NULL && OpInfo->Object != ProtectedProcesses[1]))
			return OB_PREOP_SUCCESS;

		if (OpInfo->Object == PsGetCurrentProcess || PsGetCurrentProcess() == ProtectedProcesses[0] || PsGetCurrentProcess() == ProtectedProcesses[1])
		{
			return OB_PREOP_SUCCESS;
		}

		//Clear out PROCESS_ALL_ACCESS as well as PROCESS_VM_OPERATION
		BitsToClear = PROCESS_ALL_ACCESS | 0x8;
		BitsToSet = DELETE;
	}
	else if (OpInfo->ObjectType == *PsThreadType)
	{
		HANDLE ThreadProcID = PsGetThreadProcessId((PETHREAD)OpInfo->Object);
		PEPROCESS TargetProcess;
		if (!NT_SUCCESS(PsLookupProcessByProcessId(ThreadProcID, &TargetProcess)))
			return OB_PREOP_SUCCESS;

		if (ProtectedProcesses[0] == NULL || (ProtectedProcesses[0] != NULL && TargetProcess != ProtectedProcesses[0]) && (ProtectedProcesses[1] != NULL && TargetProcess != ProtectedProcesses[1]))
			return OB_PREOP_SUCCESS;

		if (TargetProcess == PsGetCurrentProcess || PsGetCurrentProcess() == ProtectedProcesses[0] || PsGetCurrentProcess() == ProtectedProcesses[1])
		{
			return OB_PREOP_SUCCESS;
		}

		BitsToClear = THREAD_ALL_ACCESS;
		BitsToSet = DELETE;
	}
	else return OB_PREOP_SUCCESS;

	switch (OpInfo->Operation)
	{
		case OB_OPERATION_HANDLE_CREATE:
		{
			DesiredAccess = &OpInfo->Parameters->CreateHandleInformation.DesiredAccess;
			break;
		}
		case OB_OPERATION_HANDLE_DUPLICATE:
		{
			DesiredAccess = &OpInfo->Parameters->DuplicateHandleInformation.DesiredAccess;
			break;
		}
		default:
			ASSERT(FALSE);
			break;
	}

	//IF the handle is being created in the kernel, ignore it, otherwise strip it of PROCESS_ALL_ACCESS
	if (OpInfo->KernelHandle != 1)
	{
		*DesiredAccess &= ~BitsToClear;
		*DesiredAccess |= BitsToSet;
	}

	return OB_PREOP_SUCCESS;
}


//=======================================================================================================================================


//This callback will be executed on any image load. We can see if any blacklisted modules are loaded such as commonly abused drivers

PLOAD_IMAGE_NOTIFY_ROUTINE ImageLoadCallback(PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO ImageInfo)
{
	UNREFERENCED_PARAMETER(FullImageName);
	UNREFERENCED_PARAMETER(ProcessId);
	UNREFERENCED_PARAMETER(ImageInfo);

	//If our anticheat is loaded again(should be handled in usermode but just in case)
	if (wcsstr(FullImageName->Buffer, L"AntiCheat.exe"))
	{
		PEPROCESS pEprocess;
		KAPC_STATE State;

		if (NT_SUCCESS(PsLookupProcessByProcessId(ProcessId, &pEprocess)))
		{
			KeStackAttachProcess(pEprocess, &State);
			ZwTerminateProcess(NULL, 0);
			KeUnstackDetachProcess(&State);
		}
	}

	//Loop through all our blacklisted modules and prevent loading
	for (int i = 0; i < sizeof(blacklistedModules) / sizeof(blacklistedModules[0]); i++)
	{
		if (blacklistedModules[i] == NULL)
			continue;

		if (wcsstr(FullImageName->Buffer, blacklistedModules[i]))
		{
			DbgPrintEx(0, 0, "[Bloom Anticheat] Vulnerable driver or blacklisted module loaded %ls\n", FullImageName->Buffer);
		}
	}
	
	return STATUS_SUCCESS;
}

PCREATE_PROCESS_NOTIFY_ROUTINE ProcessCreateCallback(HANDLE ParentID, HANDLE ProcessID, BOOLEAN Create)
{
	UNREFERENCED_PARAMETER(ParentID);
	UNREFERENCED_PARAMETER(ProcessID);
	UNREFERENCED_PARAMETER(Create);

	return STATUS_SUCCESS;
}
```

`AnticheatDriver/callbacks.h`:

```h
#ifndef _DRIVER_INCLUDES
#define _DRIVER_INCLUDES

#include <ntifs.h>
#include <ntddk.h>
#include <ntdef.h>
#include <fltKernel.h>

#endif


//Variables
WCHAR* blacklistedModules[20];
extern PVOID ObRegistrationHandle;

//ObRegisterCallback functions
NTSTATUS RegisterObCallbacks();
OB_PREOP_CALLBACK_STATUS PreOperationCallback(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OpInfo);


//Image load callback functions
PLOAD_IMAGE_NOTIFY_ROUTINE ImageLoadCallback(PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO ImageInfo);
PCREATE_PROCESS_NOTIFY_ROUTINE ProcessCreateCallback(HANDLE ParentID, HANDLE ProcessID, BOOLEAN Create);

```

`AnticheatDriver/driver.c`:

```c
#include "includes.h"


UNICODE_STRING Dev, Dos;
PDEVICE_OBJECT DeviceObject;

NTSTATUS UnloadDriver(PDRIVER_OBJECT pDriverObject);
HANDLE hThread;


NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath)
{
	UNREFERENCED_PARAMETER(pDriverObject);
	UNREFERENCED_PARAMETER(pRegistryPath);

	RtlInitUnicodeString(&Dev, L"\\Device\\acDriverDevice");
	RtlInitUnicodeString(&Dos, L"\\DosDevices\\acDriverDevice");

	IoCreateDevice(pDriverObject, 0, &Dev, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &DeviceObject);
	IoCreateSymbolicLink(&Dos, &Dev);

	pDriverObject->MajorFunction[IRP_MJ_CREATE] = CreateCall;
	pDriverObject->MajorFunction[IRP_MJ_CLOSE] = CloseCall;
	pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IoControl;
	pDriverObject->DriverUnload = UnloadDriver;
	
	if (DeviceObject)
	{
		DeviceObject->Flags |= DO_DIRECT_IO;
		DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
	}

	//PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)kPrint, DeviceObject);

	PsSetLoadImageNotifyRoutine((PLOAD_IMAGE_NOTIFY_ROUTINE)ImageLoadCallback);
	PsSetCreateProcessNotifyRoutine((PCREATE_PROCESS_NOTIFY_ROUTINE)ProcessCreateCallback, FALSE);
	
	DbgPrintEx(0, 0, "[Bloom Anticheat] Driver Initialized\n");

	return STATUS_SUCCESS;
}

NTSTATUS UnloadDriver(PDRIVER_OBJECT pDriverObject)
{
	UNREFERENCED_PARAMETER(pDriverObject);

	IoDeleteDevice(DeviceObject);
	IoDeleteSymbolicLink(&Dos);

	if (ObRegistrationHandle)
		ObUnRegisterCallbacks(ObRegistrationHandle);

	PsRemoveLoadImageNotifyRoutine((PLOAD_IMAGE_NOTIFY_ROUTINE)ImageLoadCallback);
	PsSetCreateProcessNotifyRoutine((PCREATE_PROCESS_NOTIFY_ROUTINE)ProcessCreateCallback, TRUE);

	return STATUS_SUCCESS;
}
```

`AnticheatDriver/includes.h`:

```h
#pragma warning(disable : 4024 4047)

#ifndef _DRIVER_INCLUDES
#define _DRIVER_INCLUDES

#include <ntifs.h>
#include <ntddk.h>
#include <ntdef.h>
#include <fltKernel.h>

#endif

#include "callbacks.h"
#include "IOCTL.h"


//Our main IOCTL Device for communication with usermode
extern PDEVICE_OBJECT DeviceObject;


typedef struct _KERNEL_MODULE_INFO
{
	PVOID ModuleBase;
	ULONG ModuleSize;
	LPCWSTR ModuleName;
}KERNEL_MODULE_INFO, * PKERNEL_MODULE_INFO;
```

`README.md`:

```md
# Bloom Anticheat


![Animation](https://user-images.githubusercontent.com/45408021/164273282-2c4d67a9-8c49-46ee-8002-055aed0387da.gif)

This Anticheat can be used on any windows x64 process. It is currently configured to protect notepad, but changing the macro to the desired process is all you will need to do to change it. The main executable has a basic error handler and should be good enough for debugging.

Once loaded, the driver will use ObRegisterCallbacks() to protect both the anticheat and target process, and begin registering its callbacks.

For those looking for a simple usermode solution, injecting just the DLL will work as it is not reliant on the other modules. Make sure you LoadLibrary inject however, as manual mapping it will result in it detecting itself.

IMPORTANT: the driver binary must be put inside your System32\drivers folder(an error will be outputted if not).

To build:
in visual studio, select Batch build and build x64 release for each of the three projects

```