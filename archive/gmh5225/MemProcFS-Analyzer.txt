Project Path: arc_gmh5225_MemProcFS-Analyzer_4xr3lchm

Source Tree:

```txt
arc_gmh5225_MemProcFS-Analyzer_4xr3lchm
├── LICENSE
├── MemProcFS-Analyzer.ps1
├── README.md
├── Rules
│   └── LNK.yar
├── Screenshots
│   ├── 01.png
│   ├── 02.png
│   ├── 03.png
│   ├── 04.png
│   ├── 05.png
│   ├── 06.png
│   ├── 07.png
│   ├── 08.png
│   ├── 09.png
│   ├── 10.png
│   ├── 11.png
│   ├── 12.png
│   ├── 13.png
│   ├── 14.png
│   ├── 15.png
│   ├── 16.png
│   ├── 17.png
│   ├── 18.png
│   ├── 19.png
│   ├── 20.png
│   ├── 21.png
│   ├── 22.png
│   ├── 23.png
│   ├── 24.png
│   ├── 25.png
│   └── Wiki
│       ├── Elasticsearch
│       │   ├── Configure-Elastic.png
│       │   ├── Dashboards.png
│       │   ├── ELK-Import.png
│       │   ├── Starting-Elasticsearch.png
│       │   ├── Starting-Kibana.png
│       │   └── mp_timeline.png
│       ├── LNK
│       │   ├── LNK.yar.png
│       │   └── Main.png
│       ├── ProcessTree
│       │   ├── 01.jpg
│       │   ├── 02.jpg
│       │   ├── 03.jpg
│       │   ├── 04.jpg
│       │   ├── 05.jpg
│       │   └── 06.png
│       └── UserAssist
│           ├── Analyzing-UserAssist-Artifacts.png
│           ├── UserAssist-Plugin.png
│           └── UserAssist-Stats.png
├── Scripts
│   ├── 1768
│   │   ├── 1768.json
│   │   └── 1768.py
│   ├── Get-ProcessTree
│   │   └── Get-ProcessTree.ps1
│   └── Measure-DamerauLevenshteinDistance
│       └── Measure-DamerauLevenshteinDistance.cs
└── Tools
    ├── 7-Zip
    │   └── 7za.exe
    └── RECmd_BatchFiles
        ├── AdobeRecentFiles.reb
        ├── BAM.reb
        ├── Kroll_Batch.reb
        ├── MUICache.reb
        ├── RecentDocs.reb
        ├── RegistryASEPs.reb
        ├── SysCache.reb
        ├── TrustedDocuments.reb
        └── UserAssist.reb

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`MemProcFS-Analyzer.ps1`:

```ps1
# MemProcFS-Analyzer v0.8
#
# @author:    Martin Willing
# @copyright: Copyright (c) 2021-2023 Martin Willing. All rights reserved.
# @contact:   Any feedback or suggestions are always welcome and much appreciated - mwilling@lethal-forensics.com
# @url:		  https://lethal-forensics.com/
# @date:	  2023-01-22
#
#
# ██╗     ███████╗████████╗██╗  ██╗ █████╗ ██╗      ███████╗ ██████╗ ██████╗ ███████╗███╗   ██╗███████╗██╗ ██████╗███████╗
# ██║     ██╔════╝╚══██╔══╝██║  ██║██╔══██╗██║      ██╔════╝██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔════╝██║██╔════╝██╔════╝
# ██║     █████╗     ██║   ███████║███████║██║█████╗█████╗  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████╗██║██║     ███████╗
# ██║     ██╔══╝     ██║   ██╔══██║██╔══██║██║╚════╝██╔══╝  ██║   ██║██╔══██╗██╔══╝  ██║╚██╗██║╚════██║██║██║     ╚════██║
# ███████╗███████╗   ██║   ██║  ██║██║  ██║███████╗ ██║     ╚██████╔╝██║  ██║███████╗██║ ╚████║███████║██║╚██████╗███████║
# ╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝ ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝╚══════╝
#
#
# Dependencies:
# 7-Zip 22.01 Standalone Console (2022-07-15)
# https://www.7-zip.org/download.html
#
# AmcacheParser v1.5.1.0 (.NET 6)
# https://ericzimmerman.github.io/
#
# AppCompatCacheParser v1.5.0.0 (.NET 6)
# https://ericzimmerman.github.io/
#
# ClamAV - Download --> Windows --> clamav-1.0.0.win.x64.msi (2022-11-23)
# https://www.clamav.net/downloads
# https://docs.clamav.net/manual/Usage/Configuration.html#windows --> First Time Set-Up
# https://blog.clamav.net/
#
# Dokany Library Bundle v2.0.6.1000 (2022-10-02)
# https://github.com/dokan-dev/dokany/releases/latest --> DokanSetup.exe
#
# Elasticsearch 8.6.0 (2023-01-10)
# https://www.elastic.co/downloads/elasticsearch
#
# entropy v1.0 (2022-02-04)
# https://github.com/merces/entropy
#
# EvtxECmd v1.0.0.1 (.NET 6)
# https://ericzimmerman.github.io/
#
# ImportExcel v7.8.4 (2022-12-11)
# https://github.com/dfinke/ImportExcel
#
# IPinfo CLI 2.10.0 (2022-09-28)
# https://github.com/ipinfo/cli
#
# jq v1.6 (2019-11-02)
# https://github.com/stedolan/jq
#
# Kibana 8.6.0 (2023-01-10)
# https://www.elastic.co/downloads/kibana
#
# lnk_parser v0.2.0 (2022-08-10)
# https://github.com/AbdulRhmanAlfaifi/lnk_parser
#
# MemProcFS v5.3.0 - The Memory Process File System (2023-01-19)
# https://github.com/ufrisk/MemProcFS
#
# RECmd v2.0.0.0 (.NET 6)
# https://ericzimmerman.github.io/
#
# SBECmd v2.0.0.0 (.NET 6)
# https://ericzimmerman.github.io/
#
# xsv v0.13.0 (2018-05-12)
# https://github.com/BurntSushi/xsv
#
# YARA v4.2.3 (2022-08-09)
# https://virustotal.github.io/yara/
#
# Zircolite v2.9.7 (2022-10-08)
# https://github.com/wagga40/Zircolite
#
#
# Changelog:
# Version 0.1
# Release Date: 2021-05-15
# Initial Release
#
# Version 0.2
# Release Date: 2021-05-26
# Added: IPinfo CLI
# Added: Collecting Registry Hives
# Added: AmcacheParser
# Added: AppCompatCacheParser (ShimCache)
# Added: PowerShell module 'ImportExcel'
# Added: Collection of PE_INJECT (PW: infected)
# Added: Hunting for suspicious Services
# Added: Hunting for suspicious Scheduled Tasks
# Fixed: Other minor fixes and improvements
#
# Version 0.3
# Release Date: 2021-06-17
# Added: OS Fingerprinting
# Added: Registry Explorer/RECmd
# Added: UserAssist
# Added: Syscache
# Added: ShellBags Explorer/SBECmd
# Added: Registry ASEPs (Auto-Start Extensibility Points)
# Fixed: Other minor fixes and improvements
#
# Version 0.4
# Release Date: 2022-07-27
# Added: Web Browser History
# Added: Forensic Timeline (CSV, XLSX)
# Added: JSON to CSV and XLSX output (including Handles)
# Added: Collecting output of pypykatz and regsecrets (MemProcFS Plugins)
# Added: RecentDocs
# Added: Office Trusted Documents
# Added: Adobe RecentDocs
# Added: Startup Folders
# Fixed: Other minor fixes and improvements
#
# Version 0.5
# Release Date: 2022-09-06
# Added: BitLocker Plugin
# Added: Kroll RECmd Batch File v1.20 (2022-06-01)
# Added: FS_Forensic_CSV + XLSX
# Added: FS_SysInfo_Users
# Added: Windows Shortcut Files (LNK)
# Added: Process Modules (Metadata)
# Added: Number of Sub-Processes (proc.csv, Processes.xlsx, and RunningandExited.xlsx)
# Added: Colorized Running and Exited Processes (RunningandExited.xlsx)
# Fixed: Other minor fixes and improvements
#
# Version 0.6
# Release Date: 2022-10-10
# Added: Process Tree (TreeView)
# Added: Unusual Number of Process Instances
# Added: Process Path Masquerading
# Added: Process Name Masquerading (Damerau Levenshtein Distance)
# Added: Suspicious Port Numbers
# Fixed: Other minor fixes and improvements
#
# Version 0.7
# Release Date: 2022-11-21
# Added: User Interface
# Added: Pagefile Support
# Added: Zircolite - A standalone SIGMA-based detection tool for EVTX
# Added: Event Log Overview
# Added: Checking for Processes w/ Unusual User Context
# Added: Process Tree: Properties View
# Added: Searching for Cobalt Strike Beacons Configuration(s) w/ 1768.py (needs to be installed manually, disabled by default)
# Added: Simple Prefetch View (based on Forensic Timeline)
# Fixed: Other minor fixes and improvements
#
# Version 0.8
# Release Date: 2023-01-23
# Added: MUICache
# Added: Windows Background Activity Moderator (BAM)
# Added: Check if it's a Domain Controller
# Added: Check if it's a Microsoft Exchange Server
# Added: jq - Command-line JSON processor
# Added: Checking for processes spawned from suspicious folder locations
# Added: Checking for suspicious processes without any command-line arguments
# Added: Checking for suspicious process lineage
# Added: Checking for processes with suspicious command-line arguments
# Added: Parent Name (proc.csv, Processes.xlsx, and RunningandExited.xlsx)
# Added: Listing of MiniDumps
# Added: Status Bar (User Interface)
# Fixed: Other minor fixes and improvements
#
#
# Tested on Windows 10 Pro (x64) Version 22H2 (10.0.19045.2486) and PowerShell 5.1 (5.1.19041.2364)
#
#
#############################################################################################################################################################################################
#############################################################################################################################################################################################

<#
.SYNOPSIS
  MemProcFS-Analyzer v0.8 - Automated Forensic Analysis of Windows Memory Dumps for DFIR

.DESCRIPTION
  MemProcFS-Analyzer.ps1 is a PowerShell script utilized to simplify the usage of MemProcFS and to assist with the memory analysis workflow.

.EXAMPLE
  PS> .\MemProcFS-Analyzer.ps1

.NOTES
  Author - Martin Willing

.LINK
  https://github.com/evild3ad/MemProcFS-Analyzer
#>

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Declarations

# Declarations

# Script Root
if ($PSVersionTable.PSVersion.Major -gt 2)
{
    # PowerShell 3+
    $script:SCRIPT_DIR = $PSScriptRoot
}
else
{
    # PowerShell 2
    $script:SCRIPT_DIR = Split-Path -Parent $MyInvocation.MyCommand.Definition
}

# Analysis date (ISO 8601)
$script:Date = [datetime]::Now.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss") # YYYY-MM-DDThh:mm:ss
$script:Timestamp = $Date -replace ":", "" # YYYY-MM-DDThhmmss

# Drive Letter (Mount Point)
$script:DriveLetter = "X:"

# Tools

# 7-Zip
$script:7za = "$SCRIPT_DIR\Tools\7-Zip\7za.exe"

# AmcacheParser
$script:AmcacheParser = "$SCRIPT_DIR\Tools\AmcacheParser\AmcacheParser.exe"

# AppCompatCacheParser
$script:AppCompatCacheParser = "$SCRIPT_DIR\Tools\AppCompatCacheParser\AppCompatCacheParser.exe"

# ClamAV
$script:freshclam = "C:\Program Files\ClamAV\freshclam.exe"
$script:clamscan = "C:\Program Files\ClamAV\clamscan.exe"
$script:clamd = "C:\Program Files\ClamAV\clamd.exe"
$script:clamdscan = "C:\Program Files\ClamAV\clamdscan.exe"

# Elasticsearch
$script:Elasticsearch = "$SCRIPT_DIR\Tools\Elasticsearch\bin\elasticsearch.bat"

# entropy
$script:entropy = "$SCRIPT_DIR\Tools\entropy\entropy.exe"

# EvtxECmd
$script:EvtxECmd = "$SCRIPT_DIR\Tools\EvtxECmd\EvtxECmd.exe"

# IPinfo CLI
$script:IPinfo = "$SCRIPT_DIR\Tools\IPinfo\ipinfo.exe"

# jq
$script:jq = "$SCRIPT_DIR\Tools\jq\jq-win64.exe"

# Kibana
$script:Kibana = "$SCRIPT_DIR\Tools\Kibana\bin\kibana.bat"

# lnk_parser
$script:lnk_parser = "$SCRIPT_DIR\Tools\lnk_parser\lnk_parser_x86_64.exe"

# MemProcFS
$script:MemProcFS = "$SCRIPT_DIR\Tools\MemProcFS\MemProcFS.exe"

# RECmd
$script:RECmd = "$SCRIPT_DIR\Tools\RECmd\RECmd.exe"

# SBECmd
$script:SBECmd = "$SCRIPT_DIR\Tools\SBECmd\SBECmd.exe"

# xsv
$script:xsv = "$SCRIPT_DIR\Tools\xsv\xsv.exe"

# YARA
$script:yara64 = "$SCRIPT_DIR\Tools\YARA\yara64.exe"

# Zircolite
$script:zircolite = "$SCRIPT_DIR\Tools\Zircolite\zircolite_win10.exe"

# Archive Password
$script:PASSWORD = "MemProcFS"

#endregion Declarations

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Initialisations

# Set Progress Preference to Silently Continue
$OriginalProgressPreference = $Global:ProgressPreference
$Global:ProgressPreference = 'SilentlyContinue'

#endregion Initialisations

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Header

Function Header {

# Windows Title
$script:DefaultWindowsTitle = $Host.UI.RawUI.WindowTitle
$Host.UI.RawUI.WindowTitle = "MemProcFS-Analyzer v0.8 - Automated Forensic Analysis of Windows Memory Dumps for DFIR"

# Check if the PowerShell script is being run with admin rights
if (!([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))
{
    Write-Host "[Error] This PowerShell script must be run with admin rights." -ForegroundColor Red
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Requirements

# Dokany File System Library
$Dokany = "$env:SystemDrive\Windows\System32\dokan2.dll"
if (!(Test-Path "$Dokany"))
{
    Write-Host "[Error] Dokany File System Library NOT found." -ForegroundColor Red
    Write-Host "        Please download/install the latest release of Dokany File System Library manually:" -ForegroundColor Red
    Write-Host "        https://github.com/dokan-dev/dokany/releases/latest (DokanSetup.exe)" -ForegroundColor Red
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# EZTools
if (Get-Command -CommandType Application dotnet -ErrorAction SilentlyContinue)
{
    # TargetFramework (.NET 6)
    if (!(dotnet --list-runtimes | Select-String -Pattern "^Microsoft\.WindowsDesktop\.App" -Quiet))
    {
        Write-Host "[Error] Please download/install at least .NET 6.0 or newer manually:" -ForegroundColor Red
        Write-Host "        https://dotnet.microsoft.com/en-us/download/dotnet/6.0 (Recommended: .NET Desktop Runtime)" -ForegroundColor Red
        $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
        Exit
    }
}
else
{
    Write-Host "[Error] Please download/install at least .NET 6.0 or newer manually:" -ForegroundColor Red
    Write-Host "        https://dotnet.microsoft.com/en-us/download/dotnet/6.0 (Recommended: .NET Desktop Runtime)" -ForegroundColor Red
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Function Get-FileSize
Function script:Get-FileSize {
Param ([long]$Size)
If ($Size -gt 1TB) {[string]::Format("{0:0.00} TB", $Size / 1TB)}
ElseIf ($Size -gt 1GB) {[string]::Format("{0:0.00} GB", $Size / 1GB)}
ElseIf ($Size -gt 1MB) {[string]::Format("{0:0.00} MB", $Size / 1MB)}
ElseIf ($Size -gt 1KB) {[string]::Format("{0:0.00} KB", $Size / 1KB)}
ElseIf ($Size -gt 0) {[string]::Format("{0:0.00} Bytes", $Size)}
Else {""}
}

# Add the required MessageBox class (Windows PowerShell)
Add-Type -AssemblyName System.Windows.Forms

#############################################################################################################################################################################################

# User Interface

Function Show-UserInterface
{
    # Import Assemblies
    [void][reflection.assembly]::Load('System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
    [void][reflection.assembly]::Load('System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
    [void][reflection.assembly]::Load('System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')

    # Form Objects
    [System.Windows.Forms.Application]::EnableVisualStyles()
    $FormMemProcFSAnalyzer = New-Object 'System.Windows.Forms.Form'
    $StatusBar = New-Object 'System.Windows.Forms.StatusBar'
    $StatusBarPanel1 = New-Object 'System.Windows.Forms.StatusBarPanel'
	$LabelMemoryDump = New-Object 'System.Windows.Forms.Label'
	$LabelPageFile = New-Object 'System.Windows.Forms.Label'
    $ButtonBrowse1 = New-Object 'System.Windows.Forms.Button'
	$ButtonBrowse2 = New-Object 'System.Windows.Forms.Button'
	$TextBoxFile1 = New-Object 'System.Windows.Forms.TextBox'
    $TextBoxFile2 = New-Object 'System.Windows.Forms.TextBox'
    $OpenFileDialog1 = New-Object 'System.Windows.Forms.OpenFileDialog'
	$OpenFileDialog2 = New-Object 'System.Windows.Forms.OpenFileDialog'
	$ButtonStart = New-Object 'System.Windows.Forms.Button'
    $ButtonExit = New-Object 'System.Windows.Forms.Button'
    $LinkLabel = New-Object 'System.Windows.Forms.LinkLabel'
	$ToolTip1 = New-Object 'System.Windows.Forms.ToolTip'
    $MenuStrip1 = New-Object 'System.Windows.Forms.MenuStrip'
    $FileToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $CheckForUpdatesToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $ExitToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $HelpToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $WikiToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $MemProcFSToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $SANSFOR532ToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$AboutToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $GitHubToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'

    $ButtonBrowseMemory_Click={
	
        if($OpenFileDialog1.ShowDialog() -eq 'OK')
        {
            $TextBoxFile1.Text = $OpenFileDialog1.FileName
            $ButtonStart.Enabled =$true
            $StatusBar.Text = "Ready"
        }
    }

    $ButtonBrowsePagefile_Click={
	
        if($OpenFileDialog2.ShowDialog() -eq 'OK')
        {
            $TextBoxFile2.Text = $OpenFileDialog2.FileName
        }
    }

    $LinkLabel_LinkClicked=[System.Windows.Forms.LinkLabelLinkClickedEventHandler]{
        Start-Process "https://github.com/evild3ad/MemProcFS-Analyzer"
    }

    $ButtonExit_Click={
		$FormMemProcFSAnalyzer.Close()
	}

    $ExitToolStripMenuItem_Click={
		$FormMemProcFSAnalyzer.Close()
	}

    $CheckForUpdatesToolStripMenuItem_Click={

        $CurrentVersion = "0.8"

        $StatusBar.Text = "Checking latest release on GitHub ..."

        # Check for latest release on GitHub
        $Repository = "evild3ad/MemProcFS-Analyzer"
        $Releases = "https://api.github.com/repos/$Repository/releases"
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        if (Test-Connection -ComputerName 8.8.8.8 -Count 1 -Quiet -ErrorAction SilentlyContinue)
		{
            $Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing -TimeoutSec 30 | ConvertFrom-Json)[0]
            $Tag = $Response.tag_name
            $LatestRelease = $Tag.Substring(1)

            # Outdated
            if ($CurrentVersion -lt $LatestRelease)
            {
                $MessageBody = "Latest Release: MemProcFS-Analyzer v$LatestRelease`n`nNote: You will be automatically redirected."
                $MessageTitle = "MemProcFS-Analyzer v$CurrentVersion - Update available"
                $ButtonType = "OKCancel"
                $MessageIcon = "Warning"
                $StatusBar.Text = "Latest Version: MemProcFS-Analyzer v$LatestRelease"
                $Result = [System.Windows.Forms.MessageBox]::Show($MessageBody, $MessageTitle, $ButtonType, $MessageIcon)

                if ($Result -eq "OK")
                {
                    Start-Process "https://github.com/evild3ad/MemProcFS-Analyzer/releases/latest"
                }
            }
            
            # Up-To-Date
            if ($CurrentVersion -eq $LatestRelease)
            {
                $MessageBody = "MemProcFS-Analyzer v$CurrentVersion`nCopyright (c) 2021-2023 Martin Willing`n`nYou are using the latest version of MemProcFS-Analyzer."
                $MessageTitle = "MemProcFS-Analyzer"
                $ButtonType = "OK"
                $MessageIcon = "Info"
                $StatusBar.Text = "Latest Version: MemProcFS-Analyzer v$LatestRelease"
                [System.Windows.Forms.MessageBox]::Show($MessageBody, $MessageTitle, $ButtonType, $MessageIcon)
            }

            # Beta-Tester
            if ($CurrentVersion -gt $LatestRelease)
            {
                $MessageBody = "MemProcFS-Analyzer v$CurrentVersion`nCopyright (c) 2021-2023 Martin Willing`n`nHello Beta-Tester. Happy Testing! ;-)"
                $MessageTitle = "MemProcFS-Analyzer"
                $ButtonType = "OK"
                $MessageIcon = "Info"
                $StatusBar.Text = "Latest Version: MemProcFS-Analyzer v$LatestRelease"
                [System.Windows.Forms.MessageBox]::Show($MessageBody, $MessageTitle, $ButtonType, $MessageIcon)

                if(Test-Path $TextBoxFile1.Text)
                {
                    $StatusBar.Text = "Ready"
                }
                else
                {
                    $StatusBar.Text = ""
                }
            }
        }
        else
        {
            $StatusBar.Text = "Session Timeout"
        }
    }
	
	$GitHubToolStripMenuItem_Click = {
		Start-Process "https://github.com/evild3ad/MemProcFS-Analyzer"
	}
	
	$WikiToolStripMenuItem_Click={
		Start-Process "https://github.com/evild3ad/MemProcFS-Analyzer/wiki"
	}

    $MemProcFSToolStripMenuItem_Click = {
		Start-Process "https://github.com/ufrisk/MemProcFS"
	}
	
	$SANSFOR532ToolStripMenuItem_Click = {
		Start-Process "https://www.sans.org/cyber-security-courses/enterprise-memory-forensics-in-depth/"
	}

    $AboutToolStripMenuItem_Click = {
        $MessageBody = "MemProcFS-Analyzer v0.8`nCopyright (c) 2021-2023 Martin Willing"
        $MessageTitle = "MemProcFS-Analyzer"
        $ButtonType = "OK"
        $MessageIcon = "Info"
        [System.Windows.Forms.MessageBox]::Show($MessageBody, $MessageTitle, $ButtonType, $MessageIcon)
	}

    # Events

    $Form_StateCorrection_Load =
    {
        $FormMemProcFSAnalyzer.WindowState = $InitialFormWindowState
    }

    $Form_StoreValues_Closing=
    {
        $script:MemoryDump = $TextBoxFile1.Text
        $script:Pagefile = $TextBoxFile2.Text
    }

    $Form_Cleanup_FormClosed=
    {
        try
        {
            $ButtonBrowse1.remove_Click($ButtonBrowseMemory_Click)
		    $ButtonBrowse2.remove_Click($ButtonBrowsePagefile_Click)
		    $ButtonStart.remove_MouseClick($ButtonStart_Click)
		    $ButtonExit.remove_MouseClick($ButtonExit_Click)
            $LinkLabel.remove_LinkClicked($LinkLabel_LinkClicked)
		    $FormMemProcFSAnalyzer.remove_Load($FormMemProcFSAnalyzer_Load)
            $CheckForUpdatesToolStripMenuItem.remove_Click($checkForUpdatesToolStripMenuItem_Click)
            $ExitToolStripMenuItem.remove_Click($exitToolStripMenuItem_Click)
			$WikiToolStripMenuItem.remove_Click($wikiToolStripMenuItem_Click)
            $MemProcFSToolStripMenuItem.remove_Click($MemProcFSToolStripMenuItem_Click)
			$SANSFOR532ToolStripMenuItem.remove_Click($SANSFOR532ToolStripMenuItem_Click)
			$AboutToolStripMenuItem.remove_Click($AboutToolStripMenuItem_Click)
			$GitHubToolStripMenuItem.remove_Click($GitHubToolStripMenuItem_Click)
		    $FormMemProcFSAnalyzer.remove_Load($Form_StateCorrection_Load)
		    $FormMemProcFSAnalyzer.remove_Closing($Form_StoreValues_Closing)
		    $FormMemProcFSAnalyzer.remove_FormClosed($Form_Cleanup_FormClosed)
        }
        catch { Out-Null }
    }

    # Form Code
    $FormMemProcFSAnalyzer.SuspendLayout()
    $MenuStrip1.SuspendLayout()

    # FormMemProcFSAnalyzer
    $FormMemProcFSAnalyzer.Controls.Add($StatusBar)
	$FormMemProcFSAnalyzer.Controls.Add($LabelMemoryDump)
	$FormMemProcFSAnalyzer.Controls.Add($LabelPageFile)
    $FormMemProcFSAnalyzer.Controls.Add($ButtonBrowse1)
	$FormMemProcFSAnalyzer.Controls.Add($ButtonBrowse2)
    $FormMemProcFSAnalyzer.Controls.Add($TextBoxFile1)
	$FormMemProcFSAnalyzer.Controls.Add($TextBoxFile2)
	$FormMemProcFSAnalyzer.Controls.Add($ButtonStart)
    $FormMemProcFSAnalyzer.Controls.Add($ButtonExit)
    $FormMemProcFSAnalyzer.Controls.Add($LinkLabel)
    $FormMemProcFSAnalyzer.Controls.Add($MenuStrip1)
	$FormMemProcFSAnalyzer.AutoScaleDimensions = New-Object System.Drawing.SizeF(6, 13)
	$FormMemProcFSAnalyzer.AutoScaleMode = 'Font'
	$FormMemProcFSAnalyzer.ClientSize = New-Object System.Drawing.Size(626, 262)
	$FormMemProcFSAnalyzer.FormBorderStyle = 'FixedDialog'
    $FormMemProcFSAnalyzer.MainMenuStrip = $Menustrip1
	$FormMemProcFSAnalyzer.MaximizeBox = $False
	$FormMemProcFSAnalyzer.MinimizeBox = $False
	$FormMemProcFSAnalyzer.Name = 'FormMemProcFSAnalyzer'
	$FormMemProcFSAnalyzer.StartPosition = 'CenterScreen'
	$FormMemProcFSAnalyzer.Text = 'MemProcFS-Analyzer v0.8 - Automated Forensic Analysis of Windows Memory Dumps for DFIR'
    $FormMemProcFSAnalyzer.TopLevel = $True
    $FormMemProcFSAnalyzer.TopMost = $True
    $FormMemProcFSAnalyzer.Add_Shown({$FormMemProcFSAnalyzer.Activate()})

    # Status Bar
    $StatusBar.Location = New-Object System.Drawing.Point(0, 240)
	$StatusBar.Name = 'StatusBar'
    [void]$StatusBar.Panels.Add($StatusBarPanel1)
	$StatusBar.Size = New-Object System.Drawing.Size(626, 22)
	$StatusBar.SizingGrip = $False
	$StatusBar.TabIndex = 0

    # LabelMemoryDump
    $LabelMemoryDump.AutoSize = $True
    $LabelMemoryDump.Location = New-Object System.Drawing.Point(12, 38)
    $LabelMemoryDump.Name = 'LabelMemoryDump'
    $LabelMemoryDump.Size = New-Object System.Drawing.Size(78, 13)
    $LabelMemoryDump.TabIndex = 4
    $LabelMemoryDump.Text = 'Memory Dump:'

    # LabelPageFile
    $LabelPageFile.AutoSize = $True
    $LabelPageFile.Location = New-Object System.Drawing.Point(36, 87)
    $LabelPageFile.Name = 'LabelPageFile'
    $LabelPageFile.Size = New-Object System.Drawing.Size(54, 13)
    $LabelPageFile.TabIndex = 3
    $LabelPageFile.Text = 'Page File:'

    # ButtonBrowse1
    $ButtonBrowse1.Location = New-Object System.Drawing.Point(539, 33)
    $ButtonBrowse1.Name = 'ButtonBrowse1'
    $ButtonBrowse1.Size = New-Object System.Drawing.Size(75, 23)
    $ButtonBrowse1.TabIndex = 0
    $ButtonBrowse1.Text = 'Browse'
    $ButtonBrowse1.UseVisualStyleBackColor = $True
    $ButtonBrowse1.add_Click($ButtonBrowseMemory_Click)
    $ToolTip1.SetToolTip($ButtonBrowse1, 'Select your Raw Physical Memory Dump')

    # ButtonBrowse2
    $ButtonBrowse2.Location = New-Object System.Drawing.Point(539, 84)
    $ButtonBrowse2.Name = 'ButtonBrowse2'
    $ButtonBrowse2.Size = New-Object System.Drawing.Size(75, 23)
    $ButtonBrowse2.TabIndex = 1
    $ButtonBrowse2.Text = 'Browse'
    $ButtonBrowse2.UseVisualStyleBackColor = $True
    $ButtonBrowse2.add_Click($ButtonBrowsePagefile_Click)
    $ToolTip1.SetToolTip($ButtonBrowse2, 'Select your pagefile.sys (Optional)')

    # TextBoxFile1
    $TextBoxFile1.AccessibleRole = 'None'
    $TextBoxFile1.AutoCompleteMode = 'SuggestAppend'
    $TextBoxFile1.AutoCompleteSource = 'FileSystem'
    $TextBoxFile1.BackColor = [System.Drawing.SystemColors]::Window 
    $TextBoxFile1.Cursor = 'Default'
    $TextBoxFile1.ForeColor = [System.Drawing.SystemColors]::WindowText 
    $TextBoxFile1.Location = New-Object System.Drawing.Point(96, 35)
    $TextBoxFile1.Name = 'TextBoxFile'
    $TextBoxFile1.ReadOnly = $True
    $TextBoxFile1.ShortcutsEnabled = $False
    $TextBoxFile1.Size = New-Object System.Drawing.Size(437, 20)
    $TextBoxFile1.TabIndex = 4
    $TextBoxFile1.TabStop = $False
    $TextBoxFile1.Text = 'Select your Raw Physical Memory Dump'
    $ToolTip1.SetToolTip($TextBoxFile1, 'Select your Raw Physical Memory Dump')

    # TextBoxFile2
    $TextBoxFile2.AccessibleRole = 'None'
    $TextBoxFile2.AutoCompleteMode = 'SuggestAppend'
    $TextBoxFile2.AutoCompleteSource = 'FileSystem'
    $TextBoxFile2.BackColor = [System.Drawing.SystemColors]::Window 
    $TextBoxFile2.Cursor = 'Default'
    $TextBoxFile2.ForeColor = [System.Drawing.SystemColors]::WindowText 
    $TextBoxFile2.Location = New-Object System.Drawing.Point(96, 84)
    $TextBoxFile2.Name = 'TextBoxFile2'
    $TextBoxFile2.ReadOnly = $True
    $TextBoxFile2.Size = New-Object System.Drawing.Size(437, 20)
    $TextBoxFile2.TabIndex = 5
    $TextBoxFile2.TabStop = $False
    $TextBoxFile2.Text = 'Select your pagefile.sys (Optional)'
    $ToolTip1.SetToolTip($TextBoxFile2, 'Select your pagefile.sys (Optional)')

    # OpenFileDialog1
    $OpenFileDialog1.Filter = 'Memory Dump Files (*.001;*.bin;*.img;*.mem;*.raw;*.vmem)|*.001;*.bin;*.img;*.mem;*.raw;*.vmem|All Files (*.*)|*.*'
    $OpenFileDialog1.InitialDirectory = "::{20D04FE0-3AEA-1069-A2D8-08002B30309D}" # MyComputer
    $OpenFileDialog1.ReadOnlyChecked = $True
    $OpenFileDialog1.Title = 'MemProcFS-Analyzer v0.8 - Select your Raw Physical Memory Dump'

    # OpenFileDialog2
    $OpenFileDialog2.Filter = 'Page Files (*.sys)|*.sys|All Files (*.*)|*.*'
    $OpenFileDialog2.ReadOnlyChecked = $True
    $OpenFileDialog2.Title = 'MemProcFS-Analyzer v0.8 - Select your pagefile.sys (Optional)'

    # ButtonStart
    $ButtonStart.DialogResult = 'OK'
    $ButtonStart.Enabled = $False
    $ButtonStart.Location = New-Object System.Drawing.Point(446, 202) # 227
    $ButtonStart.Name = 'ButtonStart'
    $ButtonStart.Size = New-Object System.Drawing.Size(75, 23)
    $ButtonStart.TabIndex = 2
    $ButtonStart.Text = 'Start'
    $ButtonStart.UseCompatibleTextRendering = $True
    $ButtonStart.UseVisualStyleBackColor = $True
    $ButtonStart.Add_Click($ButtonStart_Click)
    $ToolTip1.SetToolTip($ButtonStart, 'Start')

    # ButtonExit
    $ButtonExit.DialogResult = 'Cancel'
    $ButtonExit.Location = New-Object System.Drawing.Point(539, 202) # 227
    $ButtonExit.Name = 'ButtonExit'
    $ButtonExit.Size = New-Object System.Drawing.Size(75, 23)
    $ButtonExit.TabIndex = 3
    $ButtonExit.Text = 'Exit'
    $ButtonExit.UseCompatibleTextRendering = $True
    $ButtonExit.UseVisualStyleBackColor = $True
    $ButtonExit.Add_MouseClick($ButtonExit_Click)
    $ToolTip1.SetToolTip($ButtonExit, 'Exit')

    # LinkLabel
    $LinkLabel.Location = New-Object System.Drawing.Point(12, 204) # 227
    $LinkLabel.Name = 'LinkLabel'
    $LinkLabel.Size = New-Object System.Drawing.Size(269, 23)
    $LinkLabel.TabIndex = 7
    $LinkLabel.TabStop = $True
    $LinkLabel.Text = 'https://github.com/evild3ad/MemProcFS-Analyzer'
    $LinkLabel.Add_LinkClicked($linklabel_LinkClicked)

    # MenuStrip1
    [void]$MenuStrip1.Items.Add($FileToolStripMenuItem)
	[void]$MenuStrip1.Items.Add($HelpToolStripMenuItem)
	$MenuStrip1.Location = New-Object System.Drawing.Point(0, 0)
	$MenuStrip1.Name = 'MenuStrip1'
	$MenuStrip1.Size = New-Object System.Drawing.Size(626, 24)
	$MenuStrip1.TabIndex = 8
	$MenuStrip1.Text = 'MenuStrip1'

    # FileToolStripMenuItem
    [void]$fileToolStripMenuItem.DropDownItems.Add($CheckForUpdatesToolStripMenuItem)
	[void]$FileToolStripMenuItem.DropDownItems.Add($ExitToolStripMenuItem)
	$FileToolStripMenuItem.Name = 'FileToolStripMenuItem'
	$FileToolStripMenuItem.Size = New-Object System.Drawing.Size(37, 20)
	$FileToolStripMenuItem.Text = 'File'

    # HelpToolStripMenuItem
	[void]$HelpToolStripMenuItem.DropDownItems.Add($GitHubToolStripMenuItem)
	[void]$HelpToolStripMenuItem.DropDownItems.Add($WikiToolStripMenuItem)
    [void]$HelpToolStripMenuItem.DropDownItems.Add($MemProcFSToolStripMenuItem)
	[void]$HelpToolStripMenuItem.DropDownItems.Add($SANSFOR532ToolStripMenuItem)
	[void]$HelpToolStripMenuItem.DropDownItems.Add($AboutToolStripMenuItem)
	$HelpToolStripMenuItem.Name = 'HelpToolStripMenuItem'
	$HelpToolStripMenuItem.Size = New-Object System.Drawing.Size(44, 20)
	$HelpToolStripMenuItem.Text = 'Help'

    # CheckForUpdatesToolStripMenuItem
	$CheckForUpdatesToolStripMenuItem.Name = 'CheckForUpdatesToolStripMenuItem'
	$CheckForUpdatesToolStripMenuItem.Size = New-Object System.Drawing.Size(180, 22)
	$CheckForUpdatesToolStripMenuItem.Text = 'Check for Updates...'
	$CheckForUpdatesToolStripMenuItem.ToolTipText = 'Check for Updates...'
	$CheckForUpdatesToolStripMenuItem.add_Click($CheckForUpdatesToolStripMenuItem_Click)

    # ExitToolStripMenuItem
	$ExitToolStripMenuItem.Name = 'ExitToolStripMenuItem'
	$ExitToolStripMenuItem.Size = New-Object System.Drawing.Size(180, 22)
	$ExitToolStripMenuItem.Text = 'Exit'
	$ExitToolStripMenuItem.ToolTipText = 'Exit'
	$ExitToolStripMenuItem.Add_Click($ExitToolStripMenuItem_Click)

    # GitHubToolStripMenuItem
	$GitHubToolStripMenuItem.Name = 'GitHubToolStripMenuItem'
	$GitHubToolStripMenuItem.Size = New-Object System.Drawing.Size(152, 22)
	$GitHubToolStripMenuItem.Text = 'GitHub'
	$GitHubToolStripMenuItem.ToolTipText = 'GitHub'
	$GitHubToolStripMenuItem.Add_Click($GitHubToolStripMenuItem_Click)

    # WikiToolStripMenuItem
	$WikiToolStripMenuItem.Name = 'WikiToolStripMenuItem'
	$WikiToolStripMenuItem.Size = New-Object System.Drawing.Size(152, 22)
	$WikiToolStripMenuItem.Text = 'GitHub Wiki'
	$WikiToolStripMenuItem.ToolTipText = 'GitHub Wiki'
	$WikiToolStripMenuItem.Add_Click($WikiToolStripMenuItem_Click)

    # MemProcFSToolStripMenuItem
	$MemProcFSToolStripMenuItem.Name = 'MemProcFSToolStripMenuItem'
	$MemProcFSToolStripMenuItem.Size = New-Object System.Drawing.Size(152, 22)
	$MemProcFSToolStripMenuItem.Text = 'MemProcFS'
	$MemProcFSToolStripMenuItem.ToolTipText = 'MemProcFS - The Memory Process File System'
	$MemProcFSToolStripMenuItem.Add_Click($MemProcFSToolStripMenuItem_Click)

    # SANSFOR532ToolStripMenuItem
	$SANSFOR532ToolStripMenuItem.Name = 'SANSFOR532ToolStripMenuItem'
	$SANSFOR532ToolStripMenuItem.Size = New-Object System.Drawing.Size(152, 22)
	$SANSFOR532ToolStripMenuItem.Text = 'SANS FOR532'
	$SANSFOR532ToolStripMenuItem.ToolTipText = 'FOR532: Enterprise Memory Forensics In-Depth'
	$SANSFOR532ToolStripMenuItem.Add_Click($SANSFOR532ToolStripMenuItem_Click)

    # AboutToolStripMenuItem
	$AboutToolStripMenuItem.Name = 'AboutToolStripMenuItem'
	$AboutToolStripMenuItem.Size = New-Object System.Drawing.Size(152, 22)
	$AboutToolStripMenuItem.Text = 'About'
	$AboutToolStripMenuItem.ToolTipText = 'About'
	$AboutToolStripMenuItem.Add_Click($AboutToolStripMenuItem_Click)

    $MenuStrip1.ResumeLayout()
    $FormMemProcFSAnalyzer.ResumeLayout()

    # Save the initial state of the form
    $InitialFormWindowState = $FormMemProcFSAnalyzer.WindowState
    $FormMemProcFSAnalyzer.Add_Load($Form_StateCorrection_Load)
    $FormMemProcFSAnalyzer.Add_FormClosed($Form_Cleanup_FormClosed)
    $FormMemProcFSAnalyzer.Add_Closing($Form_StoreValues_Closing)
    return $FormMemProcFSAnalyzer.ShowDialog((New-Object System.Windows.Forms.Form -Property @{TopMost = $true}))
}

$Result = Show-UserInterface

if($Result -eq "OK")
{
    if ($Pagefile -eq "Select your pagefile.sys (Optional)")
    {
        $script:Pagefile = $null
    }
}
else
{
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

#############################################################################################################################################################################################

# FileName
$script:FileName = $MemoryDump.Split('\')[-1] | ForEach-Object{($_ -replace "\..*","")}

# Output Directory
$script:OUTPUT_FOLDER = "$SCRIPT_DIR\$Timestamp-$FileName"

# Create a record of your PowerShell session to a text file
Start-Transcript -Path "$SCRIPT_DIR\$Timestamp-$FileName.txt"

# Get Start Times
$script:StartTime_Processing = (Get-Date)
$script:StartTime_Analysis = (Get-Date)

# Logo
$Logo = @"
██╗     ███████╗████████╗██╗  ██╗ █████╗ ██╗      ███████╗ ██████╗ ██████╗ ███████╗███╗   ██╗███████╗██╗ ██████╗███████╗
██║     ██╔════╝╚══██╔══╝██║  ██║██╔══██╗██║      ██╔════╝██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔════╝██║██╔════╝██╔════╝
██║     █████╗     ██║   ███████║███████║██║█████╗█████╗  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████╗██║██║     ███████╗
██║     ██╔══╝     ██║   ██╔══██║██╔══██║██║╚════╝██╔══╝  ██║   ██║██╔══██╗██╔══╝  ██║╚██╗██║╚════██║██║██║     ╚════██║
███████╗███████╗   ██║   ██║  ██║██║  ██║███████╗ ██║     ╚██████╔╝██║  ██║███████╗██║ ╚████║███████║██║╚██████╗███████║
╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝ ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝╚══════╝
"@

Write-Host ""
Write-Host "$Logo"

# Header
Write-Output ""
Write-Output "MemProcFS-Analyzer v0.8 - Automated Forensic Analysis of Windows Memory Dumps for DFIR"
Write-Output "(c) 2021-2023 Martin Willing at Lethal-Forensics (https://lethal-forensics.com/)"
Write-Output ""

# Analysis date (ISO 8601)
$AnalysisDate = $Date -replace "T", " " # YYYY-MM-DD hh:mm:ss
Write-Output "Analysis date: $AnalysisDate UTC"
Write-Output ""

}

#endregion Header

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Updater

Function Updater {

Function InternetConnectivityCheck {

# Internet Connectivity Check (Vista+)
$NetworkListManager = [Activator]::CreateInstance([Type]::GetTypeFromCLSID([Guid]‘{DCB00C01-570F-4A9B-8D69-199FDBA5723B}’)).IsConnectedToInternet

# Offline
if (!($NetworkListManager -eq "True"))
{
    Write-Host "[Error] Your computer is NOT connected to the Internet." -ForegroundColor Red
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Online
if ($NetworkListManager -eq "True")
{
    # Check if GitHub is reachable
    if (!(Test-NetConnection -ComputerName github.com -Port 443).TcpTestSucceeded)
    {
        Write-Host "[Error] github.com is NOT reachable. Please check your network connection and try again." -ForegroundColor Red
        $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
        Exit
    }

    # Check if Backblaze B2 Platform is reachable
    if (!(Test-Connection -ComputerName f001.backblazeb2.com -Count 1 -Quiet))
    {
        Write-Host "[Error] f001.backblazeb2.com is NOT reachable. Please check your network connection and try again." -ForegroundColor Red
        $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
        Exit
    }
}

}

#############################################################################################################################################################################################

Function Get-MemProcFS {

# Check Current Version of MemProcFS
if (Test-Path "$MemProcFS")
{
    if (Test-Path "$SCRIPT_DIR\Tools\MemProcFS\Version.txt")
    {
        $CurrentVersion = Get-Content "$SCRIPT_DIR\Tools\MemProcFS\Version.txt"
        Write-Output "[Info]  Current Version: MemProcFS v$CurrentVersion"
    }
}
else
{
    Write-Output "[Info]  MemProcFS NOT found."
    $CurrentVersion = ""
}

# Determining latest release on GitHub
$Repository = "ufrisk/MemProcFS"
$Releases = "https://api.github.com/repos/$Repository/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)[0]
$Published = $Response.published_at
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "win_x64" | Out-String).Trim()
$ReleaseDate = $Published.split('T')[0]
$Version = $Download | ForEach-Object{($_ -split "_")[4]} | ForEach-Object{($_ -split "-")[0]}

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  MemProcFS $Version ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: MemProcFS $Version ($ReleaseDate)"
}

# Check if MemProcFS needs to be downloaded/updated
$LatestRelease = $Version.Substring(1)
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Zip = "MemProcFS.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\$Zip"

    if (Test-Path "$SCRIPT_DIR\$Zip")
    {
        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\MemProcFS" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\$Zip" -Force

        # New Version
        $CurrentVersion = ([System.Diagnostics.FileVersionInfo]::GetVersionInfo($MemProcFS).FileVersion).SubString(0,5)
        & $MemProcFS | Out-File "$SCRIPT_DIR\Tools\MemProcFS\help.txt"
        (Get-Content "$SCRIPT_DIR\Tools\MemProcFS\help.txt" | Select-String -Pattern "COMMAND LINE REFERENCE" | ForEach-Object{($_ -split "\s+")[6]}).Substring(1) | Out-File "$SCRIPT_DIR\Tools\MemProcFS\Version.txt"
    } 
}
else
{
    Write-Host "[Info]  You are running the most recent version of MemProcFS." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-Dokany {

# Check Current Version of Dokany File System Library
$Dokany = "$env:SystemDrive\Windows\System32\dokan2.dll"
if (Test-Path "$Dokany")
{
    $CurrentVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($Dokany).FileVersion
    $LastWriteTime = ((Get-Item $Dokany).LastWriteTime).ToString("yyyy-MM-dd")
    Write-Output "[Info]  Current Version: Dokany File System Library v$CurrentVersion ($LastWriteTime)"
}
else
{
    Write-Output "[Info]  Dokany File System Library NOT found."
    $CurrentVersion = ""
}

# Determining latest release of DokanSetup.exe on GitHub
# Note: Needs possibly a restart of the computer.
$Repository = "dokan-dev/dokany"
$Releases = "https://api.github.com/repos/$Repository/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)[0]
$Tag = $Response.tag_name
$Published = $Response.published_at
$ReleaseDate = $Published.split('T')[0]

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  Dokany File System Library $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: Dokany File System Library $Tag ($ReleaseDate)"
}

# Check if Dokany File System Library needs to be downloaded/updated
$LatestRelease = $Tag.Substring(1)
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    Write-Host "[Error] Please download/install the latest release of Dokany File System Library manually:" -ForegroundColor Red
    Write-Host "        https://github.com/dokan-dev/dokany/releases/latest (DokanSetup.exe)" -ForegroundColor Red
}
else
{
    Write-Host "[Info]  You are running the most recent version of Dokany File System Library." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-Elasticsearch {

# Elasticsearch
# https://github.com/elastic/elasticsearch

# Check Current Version of Elasticsearch
if (Test-Path "$Elasticsearch")
{
    $CurrentVersion = & $Elasticsearch --version | ForEach-Object{($_ -split "\s+")[1]} | ForEach-Object{($_ -replace ",","")}
    Write-Output "[Info]  Current Version: Elasticsearch v$CurrentVersion"
    Start-Sleep 1
}
else
{
    Write-Output "[Info]  Elasticsearch NOT found."
    $CurrentVersion = ""
}

# Determining latest release of Elasticsearch on GitHub
$Repository = "elastic/elasticsearch"
$Releases = "https://api.github.com/repos/$Repository/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)
$Latest = $Response.tag_name | Where-Object{($_ -notmatch "-rc")} | ForEach-Object{($_ -replace "v","")} | Sort-Object -Descending | Select-Object -First 1
$Item = $Response | Where-Object{($_.tag_name -eq "v$Latest")}
$Tag = $Item.tag_name
$Published = $Item.published_at
$ReleaseDate = $Published.split('T')[0]

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  Elasticsearch $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: Elasticsearch $Tag ($ReleaseDate)"
}

# Check if Elasticsearch needs to be downloaded/updated
$LatestRelease = $Tag.Substring(1)
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    # Download latest release from elastic.co
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Download = "https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-$LatestRelease-windows-x86_64.zip"
    $Zip = "Elasticsearch.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\Elasticsearch")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\Elasticsearch" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\Elasticsearch" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\Tools\$Zip" -DestinationPath "$SCRIPT_DIR\Tools" -Force

        # Rename Unpacked Directory
        Start-Sleep 10
        Rename-Item "$SCRIPT_DIR\Tools\elasticsearch-$LatestRelease" "$SCRIPT_DIR\Tools\Elasticsearch" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    } 
}
else
{
    Write-Host "[Info]  You are running the most recent version of Elasticsearch." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-Kibana {

# Kibana
# https://github.com/elastic/kibana

# Check Current Version of Kibana
if (Test-Path "$Kibana")
{
    $CurrentVersion = & $Kibana --version
    Write-Output "[Info]  Current Version: Kibana v$CurrentVersion"
    Start-Sleep 1
}
else
{
    Write-Output "[Info]  Kibana NOT found."
    $CurrentVersion = ""
}

# Determining latest release of Kibana on GitHub
$Repository = "elastic/kibana"
$Releases = "https://api.github.com/repos/$Repository/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)
$Latest = $Response.tag_name | Where-Object{($_ -notmatch "-rc")} | ForEach-Object{($_ -replace "v","")} | Sort-Object -Descending | Select-Object -First 1
$Item = $Response | Where-Object{($_.tag_name -eq "v$Latest")}
$Tag = $Item.tag_name
$Published = $Item.published_at
$ReleaseDate = $Published.split('T')[0]

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  Kibana $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: Kibana $Tag ($ReleaseDate)"
}

# Check if Kibana needs to be downloaded/updated
$LatestRelease = $Tag.Substring(1)
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    # Download latest release from elastic.co
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Download = "https://artifacts.elastic.co/downloads/kibana/kibana-$LatestRelease-windows-x86_64.zip"
    $Zip = "Kibana.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\Kibana")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\Kibana" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\Kibana" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        if (Test-Path "$7za")
        {
            $DestinationPath = "$SCRIPT_DIR\Tools"
            & $7za x "$SCRIPT_DIR\Tools\$Zip" "-o$DestinationPath" > $null 2>&1
        }
        else
        {
            Write-Host "[Error] 7za.exe NOT found." -ForegroundColor Red
            Stop-Transcript
            $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
            Exit
        }

        # Rename Unpacked Directory
        Start-Sleep 10
        Rename-Item "$SCRIPT_DIR\Tools\kibana-$LatestRelease" "$SCRIPT_DIR\Tools\Kibana" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    } 
}
else
{
    Write-Host "[Info]  You are running the most recent version of Kibana." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-AmcacheParser {

# AmcacheParser (.NET 6)
# https://ericzimmerman.github.io

# Check Current Version and SHA1 of AmcacheParser
if (Test-Path "$AmcacheParser")
{
    # Current Version
    $CurrentVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($AmcacheParser).FileVersion
    Write-Output "[Info]  Current Version: AmcacheParser v$CurrentVersion"

    # SHA1
    if (Test-Path "$SCRIPT_DIR\Tools\AmcacheParser\SHA1.txt")
    {
        $CurrentSHA1 = Get-Content "$SCRIPT_DIR\Tools\AmcacheParser\SHA1.txt"
    }
    else
    {
        $CurrentSHA1 = ""
    }

    # Determining latest release of AmcacheParser
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://f001.backblazeb2.com/file/EricZimmermanTools/net6/AmcacheParser.zip"
    $Headers = (Invoke-WebRequest -Uri $URL -UseBasicParsing -Method Head).Headers
    $LatestSHA1 = $Headers["x-bz-content-sha1"]
}
else
{
    Write-Output "[Info]  AmcacheParser NOT found."
    $CurrentSHA1 = ""
}

if ($null -eq $CurrentSHA1 -or $CurrentSHA1 -ne $LatestSHA1)
{
    # Download latest release from Backblaze
    Write-Output "[Info]  Dowloading Latest Release ..."
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://f001.backblazeb2.com/file/EricZimmermanTools/net6/AmcacheParser.zip"
    $Zip = "AmcacheParser.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $URL -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\AmcacheParser")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\AmcacheParser" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\AmcacheParser" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\Tools\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\AmcacheParser" -Force

        # Calculate SHA1 of AmcacheParser.zip
        Start-Sleep 5
        (Get-FileHash -Path "$SCRIPT_DIR\Tools\$Zip" -Algorithm SHA1).Hash | Out-File "$SCRIPT_DIR\Tools\AmcacheParser\SHA1.txt"

        # Remove Downloaded Archive
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of AmcacheParser." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-AppCompatCacheParser {

# AppCompatCacheParser (.NET 6)
# https://ericzimmerman.github.io

# Check Current Version and SHA1 of AppCompatCacheParser
if (Test-Path "$AppCompatCacheParser")
{
    # Current Version
    $CurrentVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($AppCompatCacheParser).FileVersion
    Write-Output "[Info]  Current Version: AppCompatCacheParser v$CurrentVersion"

    # SHA1
    if (Test-Path "$SCRIPT_DIR\Tools\AppCompatCacheParser\SHA1.txt")
    {
        $CurrentSHA1 = Get-Content "$SCRIPT_DIR\Tools\AppCompatCacheParser\SHA1.txt"
    }
    else
    {
        $CurrentSHA1 = ""
    }

    # Determining latest release of AppCompatCacheParser
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://f001.backblazeb2.com/file/EricZimmermanTools/net6/AppCompatCacheParser.zip"
    $Headers = (Invoke-WebRequest -Uri $URL -UseBasicParsing -Method Head).Headers
    $LatestSHA1 = $Headers["x-bz-content-sha1"]
}
else
{
    Write-Output "[Info]  AppCompatCacheParser NOT found."
    $CurrentSHA1 = ""
}

if ($null -eq $CurrentSHA1 -or $CurrentSHA1 -ne $LatestSHA1)
{
    # Download latest release from Backblaze
    Write-Output "[Info]  Dowloading Latest Release ..."
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://f001.backblazeb2.com/file/EricZimmermanTools/net6/AppCompatCacheParser.zip"
    $Zip = "AppCompatCacheParser.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $URL -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\AppCompatCacheParser")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\AppCompatCacheParser" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\AppCompatCacheParser" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\Tools\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\AppCompatCacheParser" -Force

        # Calculate SHA1 of AppCompatCacheParser.zip
        Start-Sleep 5
        (Get-FileHash -Path "$SCRIPT_DIR\Tools\$Zip" -Algorithm SHA1).Hash | Out-File "$SCRIPT_DIR\Tools\AppCompatCacheParser\SHA1.txt"

        # Remove Downloaded Archive
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of AppCompatCacheParser." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-Entropy {

# entropy
# https://github.com/merces/entropy

# Check Current Version of entropy.exe
if (Test-Path "$entropy")
{
    # Current Version
    if (Test-Path "$SCRIPT_DIR\Tools\entropy\Version.txt")
    {
        $CurrentVersion = Get-Content "$SCRIPT_DIR\Tools\entropy\Version.txt"
        $LastWriteTime = ((Get-Item $entropy).LastWriteTime).ToString("yyyy-MM-dd")
        Write-Output "[Info]  Current Version: entropy v$CurrentVersion ($LastWriteTime)"
    }
    else
    {
        $CurrentVersion = ""
    }
}
else
{
    Write-Output "[Info]  entropy.exe NOT found."
    $CurrentVersion = ""
}

# Determining latest release on GitHub
$Repository = "merces/entropy"
$Latest = "https://api.github.com/repos/$Repository/releases/latest"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Latest -UseBasicParsing | ConvertFrom-Json)[0]
$Tag = $Response.tag_name
$Published = $Response.published_at
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "-win64" | Out-String).Trim()
$ReleaseDate = $Published.split('T')[0]
$LatestRelease = $Tag.Substring(1)

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  entropy $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: entropy $Tag ($ReleaseDate)"
}

# Check if entropy.exe needs to be downloaded/updated
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Zip = "entropy.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\$Zip"

    if (Test-Path "$SCRIPT_DIR\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\entropy")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\entropy" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\entropy" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\$Zip" -DestinationPath "$SCRIPT_DIR\Tools" -Force

        # Rename Unpacked Directory
        Start-Sleep 5
        Rename-Item "$SCRIPT_DIR\Tools\entropy-$LatestRelease-win64" "$SCRIPT_DIR\Tools\entropy" -Force

        # Version
        Write-Output "$LatestRelease" | Out-File "$SCRIPT_DIR\Tools\entropy\Version.txt"

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of entropy." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-EvtxECmd {

# EvtxECmd (.NET 6)
# https://ericzimmerman.github.io

# Check Current Version and SHA1 of EvtxECmd
if (Test-Path "$EvtxECmd")
{
    # Current Version
    $CurrentVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($EvtxECmd).FileVersion
    Write-Output "[Info]  Current Version: EvtxECmd v$CurrentVersion"

    # SHA1
    if (Test-Path "$SCRIPT_DIR\Tools\EvtxECmd\SHA1.txt")
    {
        $CurrentSHA1 = Get-Content "$SCRIPT_DIR\Tools\EvtxECmd\SHA1.txt"
    }
    else
    {
        $CurrentSHA1 = ""
    }

    # Determining latest release of EvtxECmd
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://f001.backblazeb2.com/file/EricZimmermanTools/net6/EvtxECmd.zip"
    $Headers = (Invoke-WebRequest -Uri $URL -UseBasicParsing -Method Head).Headers
    $LatestSHA1 = $Headers["x-bz-content-sha1"]
}
else
{
    Write-Output "[Info]  EvtxECmd NOT found."
    $CurrentSHA1 = ""
}

if ($null -eq $CurrentSHA1 -or $CurrentSHA1 -ne $LatestSHA1)
{
    # Download latest release from Backblaze
    Write-Output "[Info]  Dowloading Latest Release ..."
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://f001.backblazeb2.com/file/EricZimmermanTools/net6/EvtxECmd.zip"
    $Zip = "EvtxECmd.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $URL -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\EvtxECmd")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\EvtxECmd" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\EvtxECmd" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\Tools\$Zip" -DestinationPath "$SCRIPT_DIR\Tools" -Force

        # Calculate SHA1 of EvtxECmd.zip
        Start-Sleep 5
        (Get-FileHash -Path "$SCRIPT_DIR\Tools\$Zip" -Algorithm SHA1).Hash | Out-File "$SCRIPT_DIR\Tools\EvtxECmd\SHA1.txt"

        # Remove Downloaded Archive
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of EvtxECmd." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-ImportExcel {

# ImportExcel
# https://github.com/dfinke/ImportExcel

# Check if PowerShell module 'ImportExcel' exists
if (Get-Module -ListAvailable -Name ImportExcel) 
{
    # Check if multiple versions of PowerShell module 'ImportExcel' exist
    $Modules = (Get-Module -ListAvailable -Name ImportExcel | Measure-Object).Count

    if ($Modules -eq "1")
    {
        # Check Current Version
        $CurrentVersion = (Get-Module -ListAvailable -Name ImportExcel).Version.ToString()
        Write-Output "[Info]  Current Version: ImportExcel v$CurrentVersion"
    }
    else
    {
        Write-Host "[Info]  Multiple installed versions of PowerShell module 'ImportExcel' found. Uninstalling ..."
        Uninstall-Module -Name ImportExcel -AllVersions -ErrorAction SilentlyContinue
        $CurrentVersion = $null
    }
}
else
{
    Write-Output "[Info]  PowerShell module 'ImportExcel' NOT found."
    $CurrentVersion = $null
}

# Determining latest release on GitHub
$Repository = "dfinke/ImportExcel"
$Releases = "https://api.github.com/repos/$Repository/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)[0]
$Tag = $Response.tag_name
$Published = $Response.published_at
$ReleaseDate = $Published.split('T')[0]
$LatestRelease = $Tag.Substring(1)

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  ImportExcel $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: ImportExcel $Tag ($ReleaseDate)"
}

# Check if ImportExcel needs to be installed
if ($null -eq $CurrentVersion)
{
    Write-Output "[Info]  Installing ImportExcel v$LatestRelease ..."
    Install-Module -Name ImportExcel -Scope CurrentUser -Repository PSGallery -Force
    $CurrentVersion = (Get-Module -ListAvailable -Name ImportExcel).Version.ToString()
}

# Check if ImportExcel needs to be updated
if ($CurrentVersion -ne $LatestRelease)
{
    # Update PowerShell module 'ImportExcel'
    try
    {
        Write-Output "[Info]  Updating PowerShell module 'ImportExcel' ..."
        Update-Module -Name ImportExcel -Force -ErrorAction SilentlyContinue
    }
    catch
    {
        Write-Output "PowerShell module 'ImportExcel' is in use. Please close PowerShell session, and run MemProcFS-Analyzer.ps1 again."
    }   
}
else
{
    Write-Host "[Info]  You are running the most recent version of ImportExcel." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-IPinfo {

# IPinfo CLI
# https://github.com/ipinfo/cli

# Check Current Version of IPinfo CLI
if (Test-Path "$IPinfo")
{
    $CurrentVersion = & $IPinfo version
    $LastWriteTime = ((Get-Item $IPinfo).LastWriteTime).ToString("yyyy-MM-dd")
    Write-Output "[Info]  Current Version: IPinfo CLI v$CurrentVersion ($LastWriteTime)"
}
else
{
    Write-Output "[Info]  IPinfo CLI NOT found."
    $CurrentVersion = ""
}

# Determining latest release on GitHub
$Repository = "ipinfo/cli"
$Releases = "https://api.github.com/repos/$Repository/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)

$Asset=0
while($true) {
  $Asset++
  $Check = $Response[$Asset].assets | Select-Object @{Name="browser_download_orl"; Expression={$_.browser_download_url}} | Select-String -Pattern "ipinfo_" -Quiet
  if ($Check -eq "True" )
  {
    Break
  }
}

$TagName = $Response[$Asset].tag_name
$Tag = $TagName.Split("-")[1] 
$Published = $Response[$Asset].published_at
$Download = ($Response[$Asset].assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "windows_amd64" | Out-String).Trim()
$ReleaseDate = $Published.split('T')[0]

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  IPinfo CLI v$Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: IPinfo CLI v$Tag ($ReleaseDate)"
}

# Check if IPinfo CLI needs to be downloaded/updated
if ($CurrentVersion -ne $Tag -Or $null -eq $CurrentVersion)
{
    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Zip = "IPinfo.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\$Zip"

    if (Test-Path "$SCRIPT_DIR\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\IPinfo")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\IPinfo" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\IPinfo" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\IPinfo" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\$Zip" -Force

        # Rename Executable
        if (Test-Path "$SCRIPT_DIR\Tools\IPinfo\ipinfo_*")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\IPinfo\ipinfo_*.exe" | Rename-Item -NewName {"ipinfo.exe"}
        }
    } 
}
else
{
    Write-Host "[Info]  You are running the most recent version of IPinfo CLI." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-jq {

# jq - Command-line JSON processor
# https://github.com/stedolan/jq

# Check Current Version of jq
if (Test-Path "$jq")
{
    $CurrentVersion = & $jq --version | ForEach-Object{($_ -split "-")[1]}
    Write-Output "[Info]  Current Version: jq v$CurrentVersion"
}
else
{
    Write-Output "[Info]  jq-win64.exe NOT found."
    $CurrentVersion = ""
}

# Determining latest stable release on GitHub
$Repository = "stedolan/jq"
$Latest = "https://api.github.com/repos/$Repository/releases/latest"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Latest -UseBasicParsing | ConvertFrom-Json)[0]
$Tag = $Response.tag_name | ForEach-Object{($_ -split "-")[1]}
$Published = $Response.published_at
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "jq-win64.exe" | Out-String).Trim()
$ReleaseDate = $Published.split('T')[0]

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  jq v$Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: jq v$Tag ($ReleaseDate)"
}

# Check if jq needs to be downloaded/updated
if ($CurrentVersion -ne $Tag -Or $null -eq $CurrentVersion)
{
    if (Test-Path "$SCRIPT_DIR\Tools\jq\jq-win64.exe")
    {
        Get-ChildItem -Path "$SCRIPT_DIR\Tools\jq" -Recurse | Remove-Item -Force -Recurse
    }
    else
    {
        New-Item "$SCRIPT_DIR\Tools\jq" -ItemType Directory -Force | Out-Null
    }

    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $EXE = "jq-win64.exe"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\Tools\jq\$EXE"
}
else
{
    Write-Host "[Info]  You are running the most recent version of jq." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-lnk_parser {

# lnk_parser
# https://github.com/AbdulRhmanAlfaifi/lnk_parser

# Check Current Version of lnk_parser
if (Test-Path "$lnk_parser")
{
    $CurrentVersion = & $lnk_parser --version | ForEach-Object{($_ -split "\s+")[1]}
    $LastWriteTime = ((Get-Item $lnk_parser).LastWriteTime).ToString("yyyy-MM-dd")
    Write-Output "[Info]  Current Version: lnk_parser v$CurrentVersion ($LastWriteTime)"
}
else
{
    Write-Output "[Info]  lnk_parser_x86_64.exe NOT found."
    $CurrentVersion = ""
}

# Determining latest release on GitHub
$Repository = "AbdulRhmanAlfaifi/lnk_parser"
$Latest = "https://api.github.com/repos/$Repository/releases/latest"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Latest -UseBasicParsing | ConvertFrom-Json)[0]
$Tag = $Response.tag_name
$Published = $Response.published_at
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "lnk_parser_x86_64.exe" | Out-String).Trim()
$ReleaseDate = $Published.split('T')[0]

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  lnk_parser $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: lnk_parser $Tag ($ReleaseDate)"
}

# Check if lnk_parser needs to be downloaded/updated
$LatestRelease = $Tag.Substring(1)
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    if (Test-Path "$SCRIPT_DIR\Tools\lnk_parser\lnk_parser_x86_64.exe")
    {
        Get-ChildItem -Path "$SCRIPT_DIR\Tools\lnk_parser" -Recurse | Remove-Item -Force -Recurse
    }
    else
    {
        New-Item "$SCRIPT_DIR\Tools\lnk_parser" -ItemType Directory -Force | Out-Null
    }
    
    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $EXE = "lnk_parser_x86_64.exe"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\Tools\lnk_parser\$EXE"
}
else
{
    Write-Host "[Info]  You are running the most recent version of lnk_parser." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-RECmd {

# RECmd (.NET 6)
# https://ericzimmerman.github.io

# Check Current Version and SHA1 of RECmd
if (Test-Path "$RECmd")
{
    # Current Version
    $CurrentVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($RECmd).FileVersion
    Write-Output "[Info]  Current Version: RECmd v$CurrentVersion"

    # SHA1
    if (Test-Path "$SCRIPT_DIR\Tools\RECmd\SHA1.txt")
    {
        $CurrentSHA1 = Get-Content "$SCRIPT_DIR\Tools\RECmd\SHA1.txt"
    }
    else
    {
        $CurrentSHA1 = ""
    }

    # Determining latest release of RECmd
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://f001.backblazeb2.com/file/EricZimmermanTools/net6/RECmd.zip"
    $Headers = (Invoke-WebRequest -Uri $URL -UseBasicParsing -Method Head).Headers
    $LatestSHA1 = $Headers["x-bz-content-sha1"]
}
else
{
    Write-Output "[Info]  RECmd NOT found."
    $CurrentSHA1 = ""
}

if ($null -eq $CurrentSHA1 -or $CurrentSHA1 -ne $LatestSHA1)
{
    # Download latest release from Backblaze
    Write-Output "[Info]  Dowloading Latest Release ..."
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://f001.backblazeb2.com/file/EricZimmermanTools/net6/RECmd.zip"
    $Zip = "RECmd.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $URL -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\RECmd")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\RECmd" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\RECmd" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\Tools\$Zip" -DestinationPath "$SCRIPT_DIR\Tools" -Force

        # Calculate SHA1 of RECmd.zip
        Start-Sleep 5
        (Get-FileHash -Path "$SCRIPT_DIR\Tools\$Zip" -Algorithm SHA1).Hash | Out-File "$SCRIPT_DIR\Tools\RECmd\SHA1.txt"

        # Remove Downloaded Archive
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of RECmd." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-SBECmd {

# SBECmd (.NET 6)
# https://ericzimmerman.github.io

# Check Current Version and SHA1 of SBECmd
if (Test-Path "$SBECmd")
{
    # Current Version
    $CurrentVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($SBECmd).FileVersion
    Write-Output "[Info]  Current Version: SBECmd v$CurrentVersion"

    # SHA1
    if (Test-Path "$SCRIPT_DIR\Tools\SBECmd\SHA1.txt")
    {
        $CurrentSHA1 = Get-Content "$SCRIPT_DIR\Tools\SBECmd\SHA1.txt"
    }
    else
    {
        $CurrentSHA1 = ""
    }

    # Determining latest release of SBECmd
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://f001.backblazeb2.com/file/EricZimmermanTools/net6/SBECmd.zip"
    $Headers = (Invoke-WebRequest -Uri $URL -UseBasicParsing -Method Head).Headers
    $LatestSHA1 = $Headers["x-bz-content-sha1"]
}
else
{
    Write-Output "[Info]  SBECmd NOT found."
    $CurrentSHA1 = ""
}

if ($null -eq $CurrentSHA1 -or $CurrentSHA1 -ne $LatestSHA1)
{
    # Download latest release from Backblaze
    Write-Output "[Info]  Dowloading Latest Release ..."
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://f001.backblazeb2.com/file/EricZimmermanTools/net6/SBECmd.zip"
    $Zip = "SBECmd.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $URL -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\SBECmd")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\SBECmd" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\SBECmd" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\Tools\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\SBECmd" -Force

        # Calculate SHA1 of SBECmd.zip
        Start-Sleep 5
        (Get-FileHash -Path "$SCRIPT_DIR\Tools\$Zip" -Algorithm SHA1).Hash | Out-File "$SCRIPT_DIR\Tools\SBECmd\SHA1.txt"

        # Remove Downloaded Archive
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of SBECmd." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-XSV {

# xsv
# https://github.com/BurntSushi/xsv

# Check Current Version of xsv
if (Test-Path "$xsv")
{
    $CurrentVersion = & $xsv --version
    $LastWriteTime = ((Get-Item $xsv).LastWriteTime).ToString("yyyy-MM-dd")
    Write-Output "[Info]  Current Version: xsv v$CurrentVersion ($LastWriteTime)"
}
else
{
    Write-Output "[Info]  xsv.exe NOT found."
    $CurrentVersion = ""
}

# Determining latest release on GitHub
$Repository = "BurntSushi/xsv"
$Releases = "https://api.github.com/repos/$Repository/releases/latest"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)
$Tag = $Response.tag_name
$Published = $Response.published_at
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "-x86_64-pc-windows-msvc" | Out-String).Trim()
$ReleaseDate = $Published.split('T')[0]

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  xsv v$Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: xsv v$Tag ($ReleaseDate)"
}

# Check if xsv needs to be downloaded/updated
if ($CurrentVersion -ne $Tag -Or $null -eq $CurrentVersion)
{
    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Zip = "xsv.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\$Zip"

    if (Test-Path "$SCRIPT_DIR\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\xsv")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\xsv" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\xsv" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\xsv" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of xsv." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-Yara {

# YARA
# https://github.com/VirusTotal/yara

# Check Current Version of YARA
if (Test-Path "$yara64")
{
    $CurrentVersion = & $yara64 --version
    $LastWriteTime = ((Get-Item $yara64).LastWriteTime).ToString("yyyy-MM-dd")
    Write-Output "[Info]  Current Version: YARA v$CurrentVersion ($LastWriteTime)"
}
else
{
    Write-Output "[Info]  yara64.exe NOT found."
    $CurrentVersion = ""
}

# Determining latest release on GitHub
$Repository = "VirusTotal/yara"
$Latest = "https://api.github.com/repos/$Repository/releases/latest"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Latest -UseBasicParsing | ConvertFrom-Json)[0]
$Tag = $Response.tag_name
$Published = $Response.published_at
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "-win64" | Out-String).Trim()
$ReleaseDate = $Published.split('T')[0]

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  YARA $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: YARA $Tag ($ReleaseDate)"
}

# Check if YARA needs to be downloaded/updated
$LatestRelease = $Tag.Substring(1)
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Zip = "yara64.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\$Zip"

    if (Test-Path "$SCRIPT_DIR\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\YARA")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\YARA" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\YARA" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\YARA" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of YARA." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-Zircolite {

# Check Current Version of Zircolite
if (Test-Path "$Zircolite")
{
    $MyLocation = $pwd
    Set-Location "$SCRIPT_DIR\Tools\Zircolite"
    $CurrentVersion = (& $Zircolite --version 2>&1 | Select-String -Pattern "Zircolite -" | ForEach-Object{($_ -split "\s+")[-1]}).Substring(1)
    Set-Location "$MyLocation"
    Write-Output "[Info]  Current Version: Zircolite v$CurrentVersion"

    # zircolite.log
    if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\zircolite.log")
    {
        Remove-Item -Path "$SCRIPT_DIR\Tools\Zircolite\zircolite.log" -Force
    }
}
else
{
    Write-Output "[Info]  Zircolite NOT found."
    $CurrentVersion = ""
}

# Determining latest stable release on GitHub
$Repository = "https://api.github.com/repos/wagga40/Zircolite/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

$Release=0
while($false) {
    $Release++
    $Check = (Invoke-WebRequest -Uri $Repository -UseBasicParsing | ConvertFrom-Json)[$Release].prerelease
    if ($Check -eq "False" )
    {
        $Release
        Break
    }
}
    
$Response = (Invoke-WebRequest -Uri $Repository -UseBasicParsing | ConvertFrom-Json)[$Release]
$Tag = $Response.tag_name
$Published = $Response.published_at
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "zircolite_win10_x64" | Out-String).Trim()
$LatestRelease = $Published.split('T')[0]

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  Zircolite v$Tag ($LatestRelease)"
}
else
{
    Write-Output "[Info]  Latest Release: Zircolite v$Tag ($LatestRelease)"
}

# Check if Zircolite needs to be updated
if ($CurrentVersion -ne $Tag -Or $null -eq $CurrentVersion)
{
    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $7Zip = "Zircolite.7z"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\Tools\$7Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$7Zip")
    {
        # Unblock Archive File
        Unblock-File -Path "$SCRIPT_DIR\Tools\$7Zip"

        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\Zircolite")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\Zircolite" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\Zircolite" -Force
        }

        # Unpacking Archive File
        if (Test-Path "$7za")
        {
            Write-Output "[Info]  Extracting Files ..."
            & $7za x "$SCRIPT_DIR\Tools\$7Zip" "-o$SCRIPT_DIR\Tools" 2>&1 | Out-Null
        }
        else
        {
            Write-Output "[Info]  7-Zip is NOT installed."
        }

        # Rename Unpacked Directory
        Start-Sleep 5
        Rename-Item "$SCRIPT_DIR\Tools\zircolite_win10" "$SCRIPT_DIR\Tools\Zircolite" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\Tools\$7Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of Zircolite." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

# Installer/Updater
InternetConnectivityCheck
Get-MemProcFS
Get-Dokany
Get-Elasticsearch
Get-Kibana
Get-AmcacheParser
Get-AppCompatCacheParser
Get-Entropy
Get-EvtxECmd
Get-ImportExcel
Get-IPinfo
Get-jq
Get-lnk_parser
Get-RECmd
Get-SBECmd
Get-XSV
Get-Yara
Get-Zircolite

}

#endregion Updater

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Elasticsearch

Function Elasticsearch {

# Launch Elasticsearch (PowerShell.exe)
Write-Output "[Info]  Starting Elasticsearch ... "
$Elasticsearch_Process = Start-Process powershell.exe "& $Elasticsearch" -WindowStyle Minimized -PassThru
$Elasticsearch_Id = $Elasticsearch_Process.Id
$script:Elasticsearch_Termination = Get-Process | Where-Object {$_.Id -eq $Elasticsearch_Id}
$ProgressPreference = 'SilentlyContinue'
do {
  Start-Sleep 3
  $ProgressPreference = 'SilentlyContinue'
} until( Test-NetConnection 127.0.0.1 -Port 9200 -InformationLevel Quiet -ErrorAction SilentlyContinue -WarningAction SilentlyContinue)

# Launch Kibana (PowerShell.exe)
Write-Output "[Info]  Starting Kibana ... "
$Kibana_Process = Start-Process powershell.exe "& $Kibana" -WindowStyle Minimized -PassThru
$Kibana_Id = $Kibana_Process.Id
$script:Kibana_Termination = Get-Process | Where-Object {$_.Id -eq $Kibana_Id}
$ProgressPreference = 'SilentlyContinue'
do {
  Start-Sleep 3
  $ProgressPreference = 'SilentlyContinue'
} until(Test-NetConnection localhost -Port 5601 -InformationLevel Quiet -ErrorAction SilentlyContinue -WarningAction SilentlyContinue)

Start-Sleep 2

}

#endregion Elasticsearch

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region MemProcFS

Function MemProcFS {

# MemProcFS
# https://github.com/ufrisk/MemProcFS

# Mount the physical memory dump file with a corresponding Pagefile and enable forensic mode
if (Test-Path "$MemProcFS")
{
    if (Test-Path "$MemoryDump")
    {
        if ($Pagefile)
        {
            if (Test-Path "$Pagefile")
            {
                Write-Output "[Info]  Mounting the Physical Memory Dump file with a corresponding Pagefile as $DriveLetter ..."

                $MemorySize = Get-FileSize((Get-Item "$MemoryDump").Length)
                Write-Output "[Info]  Physical Memory Dump File Size: $MemorySize"

                $PagefileSize = Get-FileSize((Get-Item "$Pagefile").Length)
                Write-Output "[Info]  Pagefile Size: $PagefileSize"

                Write-Output "[Info]  MemProcFS Forensic Analysis initiated ..."
                Write-Output "[Info]  Processing $MemoryDump incl. Pagefile [approx. 10-45 min] ..."
                New-Item "$OUTPUT_FOLDER" -ItemType Directory -Force | Out-Null
                $Mount = $DriveLetter -replace ":", ""
                $StartTime_MemProcFS = (Get-Date)
                Start-Process -FilePath "$MemProcFS" -ArgumentList "-mount $Mount -device `"$MemoryDump`" -pagefile0 `"$Pagefile`" -forensic 4"

                # Check if successfully mounted
                while (!(Test-Path "$DriveLetter"))
                {
                    Start-Sleep -Seconds 2
                }

                # Check forensic mode processing
                while (!(Select-String -Pattern "100" -Path "$DriveLetter\forensic\progress_percent.txt" -Quiet))
                {
                    Start-Sleep -Seconds 2
                }

                $EndTime_MemProcFS = (Get-Date)
                $Time_MemProcFS = ($EndTime_MemProcFS-$StartTime_MemProcFS)
                ('MemProcFS Processing duration: {0} h {1} min {2} sec' -f $Time_MemProcFS.Hours, $Time_MemProcFS.Minutes, $Time_MemProcFS.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"
            }
        }
    }

    # Mount the physical memory dump file and enable forensic mode
    if ((Test-Path "$MemoryDump") -and (!("$Pagefile")))
    {
        Write-Output "[Info]  Mounting the Physical Memory Dump file as $DriveLetter ..."

        $MemorySize = Get-FileSize((Get-Item "$MemoryDump").Length)
        Write-Output "[Info]  Physical Memory Dump File Size: $MemorySize"

        Write-Output "[Info]  MemProcFS Forensic Analysis initiated ..."
        Write-Output "[Info]  Processing $MemoryDump [approx. 1-10 min] ..."
        New-Item "$OUTPUT_FOLDER" -ItemType Directory -Force | Out-Null
        $Mount = $DriveLetter -replace ":", ""
        $StartTime_MemProcFS = (Get-Date)
        Start-Process -FilePath "$MemProcFS" -ArgumentList "-mount $Mount -device `"$MemoryDump`" -forensic 4"

        # Check if successfully mounted
        while (!(Test-Path "$DriveLetter"))
        {
            Start-Sleep -Seconds 2
        }

        # Check forensic mode processing
        while (!(Select-String -Pattern "100" -Path "$DriveLetter\forensic\progress_percent.txt" -Quiet))
        {
            Start-Sleep -Seconds 2
        }

        $EndTime_MemProcFS = (Get-Date)
        $Time_MemProcFS = ($EndTime_MemProcFS-$StartTime_MemProcFS)
        ('MemProcFS Processing duration: {0} h {1} min {2} sec' -f $Time_MemProcFS.Hours, $Time_MemProcFS.Minutes, $Time_MemProcFS.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"
    }

    # Check if Mount Point exists
    if (Test-Path "$DriveLetter\forensic\*")
    {
        # CurrentControlSet
        $RegistryValue = "$DriveLetter\registry\HKLM\SYSTEM\Select\Current.txt"

        if (Test-Path "$RegistryValue")
        {
            $CurrentControlSet = Get-Content "$RegistryValue" | Select-Object -Skip 2 | ForEach-Object {$_ -replace "^0+", ""}
        }

        # ComputerName
        $RegistryValue = "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\ComputerName\ComputerName\ComputerName.txt"

        if (Test-Path "$RegistryValue")
        {
            $ComputerName = Get-Content "$RegistryValue" | Select-Object -Skip 2
            Write-Output "[Info]  Host Name: $ComputerName"
        }

        # ProductName
        if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProductName.txt")
        {
            $ProductName = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProductName.txt" | Select-Object -Skip 2
        }

        # OSArchitecture
        if (Test-Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\Session Manager\Environment\PROCESSOR_ARCHITECTURE.txt")
        {
            $PROCESSOR_ARCHITECTURE = Get-Content "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\Session Manager\Environment\PROCESSOR_ARCHITECTURE.txt" | Select-Object -Skip 2

            # AMD64 (x64)
            if ($PROCESSOR_ARCHITECTURE -match "AMD64")
            {
                $OSArchitecture = "x64"
            }

            # x86
            if ($PROCESSOR_ARCHITECTURE -match "x86")
            {
                $OSArchitecture = "x86"
            }

            # ARM64
            if ($PROCESSOR_ARCHITECTURE -match "ARM64")
            {
                $OSArchitecture = "ARM64"
            }
        }
        else
        {
            Write-Output "[Info]  Processor Architecture: UNKNOWN"
        }

        # CSDVersion
        if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CSDVersion.txt")
        {
            $OSVersion = (Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CSDVersion.txt" | Select-Object -Skip 2) -creplace '(?s)^.*Service Pack ', ''
        }

        # Windows 10
        if ($ProductName -like "*Windows 10*")
        {
            # Major
            $CurrentMajorVersionNumber = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentMajorVersionNumber.txt" | Select-Object -Skip 2
            $Major = [Convert]::ToInt64("$CurrentMajorVersionNumber",16)

            # Minor
            $CurrentMinorVersionNumber = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentMinorVersionNumber.txt" | Select-Object -Skip 2
            $Minor = [Convert]::ToInt64("$CurrentMinorVersionNumber",16)
        }
        else 
        {
            # CurrentVersion
            $CurrentVersion = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentVersion.txt" | Select-Object -Skip 2

            # Major
            $Major = $CurrentVersion.split('.')[0]

            # Minor
            $Minor = $CurrentVersion.split('.')[1]
        }

        # Windows 10, Windows 11, Windows Server 2016, Windows Server 2019, and Windows Server 2022
        if (($ProductName -like "*Windows 10*") -Or ($ProductName -like "*Windows Server 2016*") -Or ($ProductName -like "*Windows Server 2019*") -Or ($ProductName -like "*Windows Server 2022*"))
        {
            # DisplayVersion
            if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DisplayVersion.txt")
            {
                $DisplayVersion = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DisplayVersion.txt" | Select-Object -Skip 2
            }

            # ReleaseID
            $ReleaseID = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ReleaseId.txt" | Select-Object -Skip 2
    
            # CurrentBuildNumber
            [int]$CurrentBuildNumber = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentBuildNumber.txt" | Select-Object -Skip 2

            # UBR
            if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\UBR.txt")
            {
                $Hex = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\UBR.txt" | Select-Object -Skip 2
                $UBR = [uint32]"0x$Hex"
            }

            # Windows 11 (CurrentBuildNumber + Update Build Revision)
            # Windows 11 Build 21996 --> First Developer Preview
            # Windows 11 Build 22000 --> First Public Preview
            if ($CurrentBuildNumber -ge "21996")
            {
                $ProductName = $ProductName | ForEach-Object{($_ -replace "10","11")}
                $Hex = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\UBR.txt" | Select-Object -Skip 2
                $UBR = [uint32]"0x$Hex"
                Write-Output "[Info]  OS: $ProductName ($OSArchitecture), Version: $DisplayVersion ($Major.$Minor.$CurrentBuildNumber.$UBR)"
            }
            else
            {
                if ($DisplayVersion)
                {
                    Write-Output "[Info]  OS: $ProductName ($OSArchitecture), Version: $ReleaseID / $DisplayVersion ($Major.$Minor.$CurrentBuildNumber.$UBR)"
                }
                else
                {
                    Write-Output "[Info]  OS: $ProductName ($OSArchitecture), Version: $ReleaseID ($Major.$Minor.$CurrentBuildNumber.$UBR)"
                }
            }
        }
        else
        {
            # CurrentBuildNumber
            $CurrentBuildNumber = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentBuildNumber.txt" | Select-Object -Skip 2

            # Revision Number
            if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\BuildLabEx.txt")
            {
                # BuildLabEx
                $BuildLabEx = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\BuildLabEx.txt" | Select-Object -Skip 2
                $RevisionNumber = $BuildLabEx.split('.')[1]
            }
            else
            {
                if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\BuildLab.txt")
                {
                    # BuildLab
                    $BuildLab = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\BuildLab.txt" | Select-Object -Skip 2
                    $RevisionNumber = $BuildLab.split('-')[1]
                }
            }

            if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CSDVersion.txt")
            {
                Write-Output "[Info]  OS: $ProductName ($OSArchitecture), Service Pack $OSVersion ($Major.$Minor.$CurrentBuildNumber.$RevisionNumber)"
            }
            else
            {
                Write-Output "[Info]  OS: $ProductName ($OSArchitecture), Version: $Major.$Minor (Build: $CurrentBuildNumber.$RevisionNumber)"
            }
        }

        # InstallDate (ISO 8601)
        $RegistryValue = "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\InstallDate.txt"

        if (Test-Path "$RegistryValue")
        {
            $HexadecimalBigEndian = Get-Content "$RegistryValue" | Select-Object -Skip 2
            $UnixSeconds = [Convert]::ToInt64("$HexadecimalBigEndian",16)
            $InstallDate = ((Get-Date 01.01.1970).AddSeconds($UnixSeconds)).ToString("yyyy-MM-dd HH:mm:ss")
            Write-Output "[Info]  InstallDate: $InstallDate UTC"
        }

        # RegisteredOrganization
        $RegisteredOrganization = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\RegisteredOrganization.txt" -ErrorAction SilentlyContinue | Select-Object -Skip 2
        if ($null -ne $RegisteredOrganization)
        {
            Write-Output "[Info]  RegisteredOrganization: $RegisteredOrganization"
        } 
        else 
        {
            Write-Output "[Info]  RegisteredOrganization: --"
        }

        # RegisteredOwner
        $RegisteredOwner = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\RegisteredOwner.txt" | Select-Object -Skip 2
        if ($null -ne $RegisteredOwner)
        {
            Write-Output "[Info]  RegisteredOwner: $RegisteredOwner"
        }
        else
        {
            Write-Output "[Info]  RegisteredOwner: --"
        }

        # Check if it's a Domain Controller (Active Directory)
        # HKLM\System\ControlSet00$CurrentControlSet\Services\ADWS (Active Directory Domain Services)
        # HKLM\System\ControlSet00$CurrentControlSet\Services\NTDS (Windows NT Directory Services)
        if ((Get-ChildItem -Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\services" | Select-Object -ExpandProperty FullName | Select-String -Pattern "\\ADWS" -Quiet) -And (Get-ChildItem -Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\services" | Select-Object -ExpandProperty FullName | Select-String -Pattern "\\NTDS" -Quiet))
        {
            # ProductType
            # WinNT - Windows Client / Windows NT Workstation
            # LanmanNT – Domain Controller
            # ServerNT – Member Server / ServerNT - Windows NT Server Standalone
            if (Get-Content -Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\ProductOptions\ProductType.txt" | Select-Object -Skip 2 | Select-String -Pattern "LanmanNT" -Quiet)
            {
                $ProductType = Get-Content -Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\ProductOptions\ProductType.txt" | Select-Object -Skip 2
                Write-Output "[Info]  Product Type: Domain Controller ($ProductType)"
            }

            # ProductSuite
            $ProductSuite = Get-Content -Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\ProductOptions\ProductSuite.txt" | Select-Object -Skip 2
            if ($ProductSuite)
            {
                Write-Output "[Info]  Product Suite: $ProductSuite"
            }
        }

        # Check if it's a Microsoft Exchange Server
        if (Get-ChildItem -Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" -ErrorAction SilentlyContinue | Select-Object FullName | Select-String -Pattern "Microsoft Exchange*" -Quiet)
        {
            $SubDirectory = (Get-ChildItem -Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" | Select-Object FullName).FullName | Select-String -Pattern "Microsoft Exchange*" | ForEach-Object{($_ -split "\\")[-1]}
            $DisplayName = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\$SubDirectory\DisplayName.txt" | Select-Object -Skip 2
            $DisplayVersion = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\$SubDirectory\DisplayVersion.txt" | Select-Object -Skip 2
            $InstallLocation = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\$SubDirectory\InstallLocation.txt" | Select-Object -Skip 2
            Write-Output "[Info]  $DisplayName ($DisplayVersion)"
            Write-Output "[Info]  Install Location: $InstallLocation"
        }

        # Timezone Information
        if (Test-Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation")
        {
            if (Test-Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation\TimeZoneKeyName.txt")
            {
                $TimeZoneKeyName = Get-Content "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation\TimeZoneKeyName.txt" | Select-Object -Skip 2 | ForEach-Object{($_ -replace "\.\..*$","")}
            }
            else
            {
                if (Test-Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation\StandardName.txt")
                {
                    $TimeZoneKeyName = Get-Content "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation\StandardName.txt" | Select-Object -Skip 2 | ForEach-Object{($_ -replace "\.\..*$","")}
                }
            }

            $LastWriteTime = Get-Content "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation\(_Key_).txt" | Select-Object -Skip 3
            $ActiveTimeBias = Get-Content "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation\ActiveTimeBias.txt" | Select-Object -Skip 2
            $UTC = '{0:d2}' -f -([int]"0x$ActiveTimeBias" / 60)

            if ($UTC -like "*-*" )
            {
                Write-Output "[Info]  Timezone Information: $TimeZoneKeyName (UTC$UTC`:00)"
                Write-Output "[Info]  Last Written Time: $LastWriteTime"
            }
            else
            {
                Write-Output "[Info]  Timezone Information: $TimeZoneKeyName (UTC+$UTC`:00)"
                Write-Output "[Info]  Last Written Time: $LastWriteTime"
            }
        }
        else
        {
            Write-Host "[Error] TimeZoneInformation Registry Subkey does NOT exist." -ForegroundColor Red
        }

        # LastLoggedOnUser
        $RegistryValue = "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\LastLoggedOnUser.txt"

        if (Test-Path "$RegistryValue")
        {
            $LastLoggedOnUser = (Get-Content "$RegistryValue" | Select-Object -Skip 2) -creplace '(?s)^.*\\', ''
            Write-Output "[Info]  Last Logged On User: $LastLoggedOnUser"
        }

        # Last Boot Up Time (ISO 8601)
        if (Test-Path "$DriveLetter\sys\time-boot.txt")
        {
            $LastBoot = Get-Content -Path "$DriveLetter\sys\time-boot.txt"
            Write-Output "[Info]  Last Boot: $LastBoot"
        }

        # Memory Acquisition Time (ISO 8601)
        if (Test-Path "$DriveLetter\sys\time-current.txt")
        {
            $Current = Get-Content -Path "$DriveLetter\sys\time-current.txt"
            Write-Output "[Info]  Memory Acquisition Time: $Current"
        }

        # Collecting Evidence Files
        Write-Output "[Info]  Collecting Evidence Files ..."

        # FS_FindEvil
        # https://github.com/ufrisk/MemProcFS/wiki/FS_FindEvil
        #
        # Indicators of Evil
        # PE_INJECT      PE_INJECT locates malware by scanning for valid .DLLs and .EXEs with executable pages in their page tables located in a private (non-image) virtual address descriptor.
        # PEB_MASQ       PEB_MASQ will flag PEB Masquerading attempts. If PEB_MASQ is detected please investigate further in /sys/proc/proc-v.txt
        # PEB_BAD_LDR    BAD_PEB_LDR will flag if no in-process modules are enumerated from the PEB/LDR_DATA structures.
        # PROC_BAD_DTB   PROC_BAD_DTB will flag active processes with an invalid DirectoryTableBase (DTB) in the kernel _EPROCESS object.
        # PROC_NOLINK    PROC_NOLINK will flag if the process does not exist in the kernel _EPROCESS linked list.
        # PROC_PARENT    PROC_PARENT will flag if a well known process has a bad parent process.
        # PROC_USER      PROC_USER may trigger if well known processes are executing as a strange user. Example cmd.exe as SYSTEM.
        # PE_NOLINK      PE_NOLINK locates malware in image virtual address descriptors which is not linked from the in-process PEB/Ldr lists.
        # PE_PATCHED     PE_PATCHED locates malware in image virtual address descriptors which executable pages (in the page tables) differs from kernel prototype memory.
        # DRIVER_PATH    DRIVER_PATH flag kernel drivers that are loaded from a non-standard path. DRIVER_PATH also flag if no corresponding module could be located.
        # PRIVATE_RWX    PRIVATE_RWX locates malware with read/write/execute (RWX) pages in the page table which belongs to a private memory virtual address descriptor.
        # NOIMAGE_RWX    NOIMAGE_RWX locates malware with read/write/execute (RWX) pages in the page table which does not belong to image (module) virtual address descriptors.
        # PRIVATE_RX     PRIVATE_RX locates malware with read/execute (RX) pages in the page table which belongs to a private memory virtual address descriptor.
        # NOIMAGE_RX     NOIMAGE_RX locates malware with read/execute (RX) pages in the page table which does not belong to image (module) virtual address descriptors.

        # FS_FindEvil
        if (Test-Path "$DriveLetter\forensic\findevil\findevil.txt")
        {
            New-Item "$OUTPUT_FOLDER\forensic\findevil" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\forensic\findevil\findevil.txt" -Destination "$OUTPUT_FOLDER\forensic\findevil\findevil.txt"

            # CSV
            if (Test-Path "$DriveLetter\forensic\json\general.json")
            {
                $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "evil" }

                $Data | Foreach-Object {

                $proc = $_ | Select-Object -ExpandProperty proc
                $procid = $_ | Select-Object -ExpandProperty pid

                $addr = $_ | Select-Object -ExpandProperty addr -ErrorAction SilentlyContinue
                if ($addr)
                {
                    $Address = $addr.PadLeft(16,"0")
                }
                else
                {
                    $Address = "0000000000000000"
                }

                $desc = $_ | Select-Object -ExpandProperty desc
                $desc2 = $_ | Select-Object -ExpandProperty desc2

                New-Object -TypeName PSObject -Property @{
                    "Process Name" = $proc
	                "PID" = $procid
	                "Address" = $Address
	                "Type" = $desc
                    "Description" = $desc2
                    }
                } | Select-Object "Process Name","PID","Type","Address","Description" | Export-Csv -Path "$OUTPUT_FOLDER\forensic\findevil\findevil.csv" -Delimiter "`t" -NoTypeInformation
            }

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\forensic\findevil\findevil.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\forensic\findevil\findevil.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\findevil\findevil.csv" -Delimiter "`t"
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\findevil\findevil.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "FindEvil" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-D
                        $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
        }

        # Find Evil
        if (Test-Path "$OUTPUT_FOLDER\forensic\findevil\findevil.csv")
        {
            # PE_INJECT (Injected Modules)
            $Data = Import-Csv "$OUTPUT_FOLDER\forensic\findevil\findevil.csv" -Delimiter "`t" | Where-Object { $_.Type -like "*PE_INJECT*" }
            $Count = ($Data | Measure-Object).Count
            if ($Count -gt 0)
            {
                New-Item "$OUTPUT_FOLDER\forensic\findevil\PE_INJECT" -ItemType Directory -Force | Out-Null
                ($Data | Select-Object PID,"Process Name",Type,Address,Description | Format-Table -HideTableHeaders | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\forensic\findevil\PE_INJECT\PE_INJECT.txt"
                Write-Host "[Alert] PE_INJECT found ($Count)" -ForegroundColor Red
                (Get-Content "$OUTPUT_FOLDER\forensic\findevil\PE_INJECT\PE_INJECT.txt") -replace "^", "        "  | Write-Host -ForegroundColor Red
            }

            # Collecting PE_INJECT (Injected Modules)
            if (Test-Path "$7za")
            {
                if (Test-Path "$OUTPUT_FOLDER\forensic\findevil\PE_INJECT\PE_INJECT.txt")
                {
                    $PE_INJECTS = Get-Content "$OUTPUT_FOLDER\forensic\findevil\PE_INJECT\PE_INJECT.txt"
                    ForEach( $PE_INJECT in $PE_INJECTS )
                    {
                        $ProcessID = $PE_INJECT | ForEach-Object{($_ -split "\s+")[0]}
                        $InjectedModuleList = (Get-ChildItem -Recurse -Force "$DriveLetter\pid\$ProcessID\files\modules\*" | Where-Object {($_.FullName -match "_INJECTED*")} | Foreach-Object FullName)

                        ForEach( $InjectedModule in $InjectedModuleList )
                        {
                            $INFECTED = "infected"
                            $ArchiveName = $InjectedModule | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "_INJECTED-")[-1]}
                            & $7za a -mx5 -mhe "-p$INFECTED" -t7z "$OUTPUT_FOLDER\forensic\findevil\PE_INJECT\$ProcessID-$ArchiveName.7z" "$InjectedModule" > $null 2>&1
                        }
                    }
                }
            }

            # PEB_MASQ (PEB Masquerading)
            $Data = Import-Csv "$OUTPUT_FOLDER\forensic\findevil\findevil.csv" -Delimiter "`t" | Where-Object { $_.Type -like "*PEB_MASQ*" }
            $Count = ($Data | Measure-Object).Count
            if ($Count -gt 0)
            {
                New-Item "$OUTPUT_FOLDER\forensic\findevil\PEB_MASQ" -ItemType Directory -Force | Out-Null
                ($Data | Select-Object PID,"Process Name",Type,Address,Description | Format-Table -HideTableHeaders | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\forensic\findevil\PEB_MASQ\PEB_MASQ.txt"
                Write-Host "[Alert] PEB_MASQ found ($Count)" -ForegroundColor Red
                (Get-Content "$OUTPUT_FOLDER\forensic\findevil\PEB_MASQ\PEB_MASQ.txt") -replace "^", "        "  | Write-Host -ForegroundColor Red
            }
        }
        else
        {
            Write-Output "[Info]  Your Operating System is NOT supported by FindEvil."
            Write-Output "        Note: FindEvil is only available on 64-bit Windows 11, 10 and 8.1."
        }

        # FS_Forensic_CSV
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_CSV
        if (Test-Path "$DriveLetter\forensic\csv\*.csv")
        {
            New-Item "$OUTPUT_FOLDER\forensic\csv" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\forensic\csv\*.csv" -Destination "$OUTPUT_FOLDER\forensic\csv"
        }

        # FS_Forensic_XLSX
        if (Test-Path "$OUTPUT_FOLDER\forensic\csv\*.csv")
        {
            New-Item "$OUTPUT_FOLDER\forensic\xlsx" -ItemType Directory -Force | Out-Null

            # drivers.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\drivers.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\drivers.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\drivers.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\drivers.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Drivers" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-E
                    $WorkSheet.Cells["B:E"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # handles.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\handles.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\handles.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\handles.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\handles.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Handles" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:I1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-H
                    $WorkSheet.Cells["A:H"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # modules.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\modules.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\modules.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\modules.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\modules.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Modules" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:W1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-J and N-W
                    $WorkSheet.Cells["A:J"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["N:W"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # process.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\process.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\process.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\process.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\process.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Processes" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:R1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-C and F-O
                    $WorkSheet.Cells["A:C"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:O"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # services.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\services.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\services.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\services.csv" -Delimiter "," | Sort-Object PID
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\services.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Services" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:L1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-B and E-J
                    $WorkSheet.Cells["A:B"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["E:J"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # tasks.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\tasks.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\tasks.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\tasks.csv" -Delimiter "," | Sort-Object { $_.TimeCreate -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\tasks.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Tasks" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, D-E and H-K
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # threads.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\threads.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\threads.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\threads.csv" -Delimiter "," | Sort-Object PID # or CreateTime???
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\threads.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Threads" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:T1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-T
                    $WorkSheet.Cells["A:T"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_all.csv --> \forensic\timeline\timeline-reverse.csv

            # timeline_kernelobject.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_kernelobject.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_kernelobject.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_kernelobject.csv" -Delimiter "," | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_kernelobject.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_kernelobject" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_net.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_net.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_net.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_net.csv" -Delimiter "," | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_net.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_net" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_ntfs.csv --> \forensic\timeline\timeline-reverse.csv

            # timeline_process.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_process.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_process.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_process.csv" -Delimiter "," | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_process.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_process" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_registry.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_registry.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_registry.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_registry.csv" -Delimiter "," | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_registry.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_registry" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_task.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_task.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_task.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_task.csv" -Delimiter "," | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_task.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_task" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_thread.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_thread.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_thread.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_thread.csv" -Delimiter "," | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_thread.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_thread" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_web
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_web.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_web.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_web.csv" -Delimiter "," | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_web.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_web" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # unloaded_modules.csv
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\unloaded_modules.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\unloaded_modules.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\unloaded_modules.csv" -Delimiter "," | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\unloaded_modules.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "unloaded_modules" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and 
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # FS_Forensic_JSON
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_JSON
        if (Test-Path "$DriveLetter\forensic\json\*.json")
        {
            New-Item "$OUTPUT_FOLDER\forensic\json" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\forensic\json\*.json" -Destination "$OUTPUT_FOLDER\forensic\json"
        }

        # FS_Forensic_Ntfs
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_Ntfs
        if (Test-Path "$DriveLetter\forensic\ntfs\ntfs_files.txt")
        {
            New-Item "$OUTPUT_FOLDER\forensic\ntfs" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\forensic\ntfs\ntfs_files.txt" -Destination "$OUTPUT_FOLDER\forensic\ntfs\ntfs_files.txt"
        }

        # FS_Forensic_Timeline
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_Timeline
        if (Test-Path "$DriveLetter\forensic\timeline\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\forensic\timeline" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\forensic\timeline\*.txt" -Destination "$OUTPUT_FOLDER\forensic\timeline"
        }

        # FS_SysInfo
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo
        if (Test-Path "$DriveLetter\sys\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\sys\*.txt" -Destination "$OUTPUT_FOLDER\sys"
        }

        # FS_SysInfo_Users
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_Users
        if (Test-Path "$DriveLetter\sys\users\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\users" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\sys\users\*.txt" -Destination "$OUTPUT_FOLDER\sys\users"
        }

        # FS_SysInfo_Certificates
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_Certificates
        if (Test-Path "$DriveLetter\sys\certificates\certificates.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\certificates" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\sys\certificates\certificates.txt" -Destination "$OUTPUT_FOLDER\sys\certificates\certificates.txt"

            # SHA1
            Get-Content "$OUTPUT_FOLDER\sys\certificates\certificates.txt" | Select-String -Pattern "[A-Za-z0-9]{32}" -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value } | Sort-Object -Unique | Out-File "$OUTPUT_FOLDER\sys\certificates\SHA1.txt"

            # Count
            $Total = (Get-Content "$OUTPUT_FOLDER\sys\certificates\certificates.txt" | Measure-Object).Count
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\certificates\SHA1.txt" | Measure-Object).Count
            Write-Output "[Info]  $Count Certificates found ($Total)"

            # CSV
            if (Test-Path "$DriveLetter\forensic\json\general.json")
            {
                $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "certificate" }

                $Data | Foreach-Object {

                $desc = $_ | Select-Object -ExpandProperty desc
                $store = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="store"; Expression={ForEach-Object{($_ -split "store:")[1]} | ForEach-Object{($_ -split "thumbprint:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $thumbprint = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="thumbprint"; Expression={ForEach-Object{($_ -split "thumbprint:")[1]} | ForEach-Object{($_ -split "issuer:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $issuer  = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="issuer"; Expression={ForEach-Object{($_ -split "issuer:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}

                New-Object -TypeName PSObject -Property @{
	                "Description" = $desc
	                "Store" = $store.store
	                "Thumbprint (SHA1)" = $thumbprint.thumbprint
	                "Issuer" = $issuer.issuer
                    }
                } | Select-Object "Description","Store","Thumbprint (SHA1)","Issuer" | Export-Csv -Path "$OUTPUT_FOLDER\sys\certificates\certificates.csv" -Delimiter "`t" -NoTypeInformation
            }

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\certificates\certificates.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\certificates\certificates.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\certificates\certificates.csv" -Delimiter "`t"
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\certificates\certificates.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Certificates" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-C
                        $WorkSheet.Cells["B:C"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
        }

        # FS_Sys_Drivers
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Sys_Drivers
        if (Test-Path "$DriveLetter\sys\drivers\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\drivers" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\sys\drivers\*.txt" -Destination "$OUTPUT_FOLDER\sys\drivers"

            # CSV
            if (Test-Path "$DriveLetter\forensic\json\general.json")
            {
                $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "driver" }

                $Data | Foreach-Object {

                $obj = $_ | Select-Object -ExpandProperty obj
                $desc = $_ | Select-Object -ExpandProperty desc
                $size = $_ | Select-Object -ExpandProperty size -ErrorAction SilentlyContinue
                $addr = $_ | Select-Object -ExpandProperty addr -ErrorAction SilentlyContinue
                $addr2 = $_ | Select-Object -ExpandProperty addr2 -ErrorAction SilentlyContinue
                $svc = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="svc"; Expression={ForEach-Object{($_ -split "svc:")[1]} | ForEach-Object{($_ -split "path:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $path = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="path"; Expression={ForEach-Object{($_ -split "path:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}

                New-Object -TypeName PSObject -Property @{
                    "Object Address" = $obj
                    "Driver" = $desc
                    "Size" = $size
                    "Start" = $addr
                    "End" = $addr2
                    "Service Key" = $svc.svc
                    "Driver Name" = $path.path
                    }
                } | Select-Object "Object Address","Driver","Size","Start","End","Service Key","Driver Name" | Export-Csv -Path "$OUTPUT_FOLDER\sys\drivers\drivers.csv" -Delimiter "`t" -NoTypeInformation
            }

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\drivers\drivers.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\drivers\drivers.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\drivers\drivers.csv" -Delimiter "`t"
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\drivers\drivers.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Drivers" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A, D-E
                        $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                        # HorizontalAlignment "Right" of column C
                        $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Right"
                        # HorizontalAlignment "Center" of header of column C
                        $WorkSheet.Cells["C1:C1"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
        }

        # FS_SysInfo_Network
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_Network
        if (Test-Path "$DriveLetter\sys\net\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\net" -ItemType Directory -Force | Out-Null

            # netstat.txt
            if (Test-Path "$DriveLetter\sys\net\netstat.txt")
            { 
                Copy-Item "$DriveLetter\sys\net\netstat.txt" -Destination "$OUTPUT_FOLDER\sys\net\netstat.txt"

                # IPv4
                # https://ipinfo.io/bogon
                New-Item "$OUTPUT_FOLDER\sys\net\IPv4" -ItemType Directory -Force | Out-Null
                $IPv4 = "(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
                $Private = "^(192\.168|10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.)"
                $Special = "^(0\.0\.0\.0|127\.0\.0\.1|169\.254\.|224\.0\.0)"
                Get-Content "$OUTPUT_FOLDER\sys\net\netstat.txt" | Select-String -Pattern $IPv4 -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value } | Sort-Object -Unique -Property { [System.Version]$_ } | Out-File "$OUTPUT_FOLDER\sys\net\IPv4\IPv4-All.txt"
                Get-Content "$OUTPUT_FOLDER\sys\net\netstat.txt" | Select-String -Pattern $IPv4 -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value } | Sort-Object -Unique -Property { [System.Version]$_ } | Where-Object {$_ -notmatch $Private} | Where-Object {$_ -notmatch $Special} | Out-File "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt"

                # Count
                $Total = (Get-Content "$OUTPUT_FOLDER\sys\net\IPv4\IPv4-All.txt" | Measure-Object).Count
                $Count = (Get-Content "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt" | Measure-Object).Count
                Write-Output "[Info]  $Count IPv4 addresses found ($Total)"

                # CSV
                if (Test-Path "$DriveLetter\forensic\json\general.json")
                {
                    New-Item "$OUTPUT_FOLDER\sys\net\CSV" -ItemType Directory -Force | Out-Null
                    
                    $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "net" }

                    $Data | Foreach-Object {

                    $proc = $_ | Select-Object -ExpandProperty proc -ErrorAction SilentlyContinue
                    $procid = $_ | Select-Object -ExpandProperty pid -ErrorAction SilentlyContinue
                    $obj = $_ | Select-Object -ExpandProperty obj
                    $desc = $_ | Select-Object -ExpandProperty desc
                    $time = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="time"; Expression={ForEach-Object{($_ -split "time:")[1]} | ForEach-Object{($_ -split "path:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                    $path = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="path"; Expression={ForEach-Object{($_ -split "path:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                    
                    New-Object -TypeName PSObject -Property @{
                        "Process" = $proc
                        "PID" = $procid
                        "Protocol" = $desc | ForEach-Object{($_ -split "\s+")[0]}
                        "State" = $desc | ForEach-Object{($_ -split "\s+")[1]}
                        "Source" = $desc | ForEach-Object{($_ -split "\s+")[2]}
                        "Destination" = $desc | ForEach-Object{($_ -split "\s+")[3]}
                        "Time" = $time.time
                        "Object Address" = $obj
                        "Process Path" = $path.path
                        }
                    } | Select-Object "Process","PID","Protocol","State","Source","Destination","Time","Object Address","Process Path" | Export-Csv -Path "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" -NoTypeInformation
                }

                # Custom CSV
                if (Test-Path "$DriveLetter\forensic\json\general.json")
                {
                    New-Item "$OUTPUT_FOLDER\sys\net\CSV" -ItemType Directory -Force | Out-Null
                    
                    $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "net" }

                    $Data | Foreach-Object {

                    $proc = $_ | Select-Object -ExpandProperty proc -ErrorAction SilentlyContinue
                    $procid = $_ | Select-Object -ExpandProperty pid -ErrorAction SilentlyContinue
                    $obj = $_ | Select-Object -ExpandProperty obj
                    $desc = $_ | Select-Object -ExpandProperty desc
                    $time = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="time"; Expression={ForEach-Object{($_ -split "time:")[1]} | ForEach-Object{($_ -split "path:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                    $path = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="path"; Expression={ForEach-Object{($_ -split "path:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                    
                    New-Object -TypeName PSObject -Property @{
                        "Process" = $proc
                        "PID" = $procid
                        "Protocol" = $desc | ForEach-Object{($_ -split "\s+")[0]}
                        "State" = $desc | ForEach-Object{($_ -split "\s+")[1]}
                        "Source" = ($desc | ForEach-Object{($_ -split "\s+")[2]} | Select-Object @{Name="Source"; Expression={ ForEach-Object{($_ -replace ":\d+$","")}}}).Source
                        "SrcPort" = ($desc | ForEach-Object{($_ -split "\s+")[2]} | Select-Object @{Name="SrcPort"; Expression={ ForEach-Object{($_ -split ":")[-1]} | ForEach-Object{($_ -replace "\*\*\*","")}}}).SrcPort
                        "Destination" = ($desc | ForEach-Object{($_ -split "\s+")[3]} | Select-Object @{Name="Destination"; Expression={ ForEach-Object{($_ -replace ":\d+$","")}}}).Destination
                        "DstPort" = ($desc | ForEach-Object{($_ -split "\s+")[3]} | Select-Object @{Name="DstPort"; Expression={ ForEach-Object{($_ -split ":")[-1]} | ForEach-Object{($_ -replace "\*\*\*","")}}}).DstPort
                        "Time" = $time.time
                        "Object Address" = $obj
                        "Process Path" = $path.path
                        }
                    } | Select-Object "Process","PID","Protocol","State","Source","SrcPort","Destination","DstPort","Time","Object Address","Process Path" | Export-Csv -Path "$OUTPUT_FOLDER\sys\net\CSV\net-custom.csv" -Delimiter "`t" -NoTypeInformation
                }

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\sys\net\CSV\net.csv")
                    {
                        if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\net\CSV\net.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\sys\net\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t"
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\net\XLSX\net.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Network" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:I1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-H
                            $WorkSheet.Cells["B:H"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }

                # Custom XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\sys\net\CSV\net-custom.csv")
                    {
                        if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\net\CSV\net-custom.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\sys\net\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net-custom.csv" -Delimiter "`t"
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\net\XLSX\net-custom.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Network" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-J
                            $WorkSheet.Cells["B:J"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }

                # IPinfo CLI (50000 requests per month)
                if (Test-Path "$IPinfo")
                {
                    if (Test-Path "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt")
                    {
                        if ((Get-Item "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt").Length -gt 0kb)
                        {
                            # Internet Connectivity Check (Vista+)
                            $NetworkListManager = [Activator]::CreateInstance([Type]::GetTypeFromCLSID([Guid]‘{DCB00C01-570F-4A9B-8D69-199FDBA5723B}’)).IsConnectedToInternet

                            if (!($NetworkListManager -eq "True"))
                            {
                                Write-Host "[Error] Your computer is NOT connected to the Internet. IP addresses cannot be checked via IPinfo API." -ForegroundColor Red
                            }
                            else
                            {
                                # Check if IPinfo.io is reachable
                                if (!(Test-Connection -ComputerName ipinfo.io -Count 1 -Quiet))
                                {
                                    Write-Host "[Error] ipinfo.io is NOT reachable. IP addresses cannot be checked via IPinfo API." -ForegroundColor Red
                                }
                                else
                                {
                                    New-Item "$OUTPUT_FOLDER\sys\net\IPv4\IPinfo\TXT" -ItemType Directory -Force | Out-Null
                                    New-Item "$OUTPUT_FOLDER\sys\net\IPv4\IPinfo\JSON" -ItemType Directory -Force | Out-Null

                                    $List = Get-Content "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt"

                                    ForEach ($IPv4 in $List)
                                    {
                                        # TXT
                                        & $IPinfo "$IPv4" | Out-File "$OUTPUT_FOLDER\sys\net\IPv4\IPinfo\TXT\$IPv4.txt"

                                        # JSON
                                        & $IPinfo "$IPv4" --json | Out-File "$OUTPUT_FOLDER\sys\net\IPv4\IPinfo\JSON\$IPv4.json"
                                    }

                                    # Map IPs
                                    # https://ipinfo.io/map
                                    Get-Content "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt" | & $IPinfo map | Out-Null

                                    # Access Token
                                    # https://ipinfo.io/signup?ref=cli
                                    $Token = "access_token" # Please insert your Access Token here

                                    if (!("$Token" -eq "access_token"))
                                    {
                                        # Summarize IPs
                                        # https://ipinfo.io/summarize-ips
                                        Get-Content "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt" | & $IPinfo summarize -t $Token | Out-File "$OUTPUT_FOLDER\sys\net\IPv4\IPinfo\Summary.txt"

                                        # JSON
                                        Get-Content "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt" | & $IPinfo --json -t $Token | Out-File "$OUTPUT_FOLDER\sys\net\IPv4\IPinfo\IPinfo.json"

                                        # CSV
                                        Get-Content "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt" | & $IPinfo --csv -t $Token | Out-File "$OUTPUT_FOLDER\sys\net\IPv4\IPinfo\IPinfo.csv"

                                        # XLSX
                                        if (Get-Module -ListAvailable -Name ImportExcel)
                                        {
                                            if (Test-Path "$OUTPUT_FOLDER\sys\net\IPv4\IPinfo\IPinfo.csv")
                                            {
                                                if([int](& $xsv count "$OUTPUT_FOLDER\sys\net\IPv4\IPinfo\IPinfo.csv") -gt 0)
                                                {
                                                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\net\IPv4\IPinfo\IPinfo.csv" -Delimiter "," | Sort-Object {$_.ip -as [Version]}
                                                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\net\IPv4\IPinfo\IPinfo.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "IPinfo" -CellStyleSB {
                                                    param($WorkSheet)
                                                    # BackgroundColor and FontColor for specific cells of TopRow
                                                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                                    Set-Format -Address $WorkSheet.Cells["A1:AI1"] -BackgroundColor $BackgroundColor -FontColor White
                                                    # HorizontalAlignment "Center" of columns A-I and K-AI
                                                    $WorkSheet.Cells["A:I"].Style.HorizontalAlignment="Center"
                                                    $WorkSheet.Cells["K:AI"].Style.HorizontalAlignment="Center"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    Write-Output "[Info]  ipinfo.exe NOT found."
                }

                # IPv6
                # IPv6 Bogon Ranges --> https://ipinfo.io/bogon
                New-Item "$OUTPUT_FOLDER\sys\net\IPv6" -ItemType Directory -Force | Out-Null
                $IPv6 = ":(?::[a-f\d]{1,4}){0,5}(?:(?::[a-f\d]{1,4}){1,2}|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}|:)|(?::(?:[a-f\d]{1,4})?|(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[a-f\d]{1,4}(?::[a-f\d]{1,4})?|))|(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[a-f\d]{1,4}(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[a-f\d]{1,4}){0,2})|:))|(?:(?::[a-f\d]{1,4}){0,2}(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[a-f\d]{1,4}){1,2})|:))|(?:(?::[a-f\d]{1,4}){0,3}(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[a-f\d]{1,4}){1,2})|:))|(?:(?::[a-f\d]{1,4}){0,4}(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[a-f\d]{1,4}){1,2})|:))"
                $Bogon = "^(::1|::ffff:0:0|100::|2001:10::|2001:db8::|fc00::|fe80::|fec0::|ff00::)"
                Get-Content "$OUTPUT_FOLDER\sys\net\netstat.txt" | Select-String -Pattern $IPv6 -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value } | Sort-Object -Unique | Out-File "$OUTPUT_FOLDER\sys\net\IPv6\IPv6-All.txt"
                Get-Content "$OUTPUT_FOLDER\sys\net\netstat.txt" | ForEach-Object{($_ -split "\s+")[5]} | Select-String -Pattern $IPv6 -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value } | Sort-Object -Unique | Where-Object {$_ -notmatch $Bogon} | Out-File "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt"

                # Count
                $Total = (Get-Content "$OUTPUT_FOLDER\sys\net\IPv6\IPv6-All.txt" | Measure-Object).Count
                $Count = (Get-Content "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt" | Measure-Object).Count
                Write-Output "[Info]  $Count IPv6 addresses found ($Total)"

                # IPinfo CLI (50000 requests per month)
                if (Test-Path "$IPinfo")
                {
                    if (Test-Path "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt")
                    {
                        if ((Get-Item "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt").Length -gt 0kb)
                        {
                            # Internet Connectivity Check (Vista+)
                            $NetworkListManager = [Activator]::CreateInstance([Type]::GetTypeFromCLSID([Guid]‘{DCB00C01-570F-4A9B-8D69-199FDBA5723B}’)).IsConnectedToInternet

                            if (!($NetworkListManager -eq "True"))
                            {
                                Write-Host "[Error] Your computer is NOT connected to the Internet. IP addresses cannot be checked via IPinfo API." -ForegroundColor Red
                            }
                            else
                            {
                                # Check if IPinfo.io is reachable
                                if (!(Test-Connection -ComputerName ipinfo.io -Count 1 -Quiet))
                                {
                                    Write-Host "[Error] ipinfo.io is NOT reachable. IP addresses cannot be checked via IPinfo API." -ForegroundColor Red
                                }
                                else
                                {
                                    New-Item "$OUTPUT_FOLDER\sys\net\IPv6\IPinfo\TXT" -ItemType Directory -Force | Out-Null
                                    New-Item "$OUTPUT_FOLDER\sys\net\IPv6\IPinfo\JSON" -ItemType Directory -Force | Out-Null

                                    $List = Get-Content "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt"

                                    $Index = 0

                                    ForEach ($IPv6 in $List)
                                    {
                                        # TXT
                                        & $IPinfo "$IPv6" | Out-File "$OUTPUT_FOLDER\sys\net\IPv6\IPinfo\TXT\$Index.txt"

                                        # JSON
                                        & $IPinfo "$IPv6" --json | Out-File "$OUTPUT_FOLDER\sys\net\IPv6\IPinfo\JSON\$Index.json"

                                        $Index++
                                    }

                                    # Map IPs
                                    # https://ipinfo.io/map
                                    Get-Content "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt" | & $IPinfo map | Out-Null

                                    if (!("$Token" -eq "access_token"))
                                    {
                                        # Summarize IPs
                                        # https://ipinfo.io/summarize-ips
                                        Get-Content "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt" | & $IPinfo summarize -t $Token | Out-File "$OUTPUT_FOLDER\sys\net\IPv6\IPinfo\Summary.txt"

                                        # JSON
                                        Get-Content "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt" | & $IPinfo --json -t $Token | Out-File "$OUTPUT_FOLDER\sys\net\IPv6\IPinfo\IPinfo.json"

                                        # CSV
                                        Get-Content "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt" | & $IPinfo --csv -t $Token | Out-File "$OUTPUT_FOLDER\sys\net\IPv6\IPinfo\IPinfo.csv"

                                        # XLSX
                                        if (Get-Module -ListAvailable -Name ImportExcel)
                                        {
                                            if (Test-Path "$OUTPUT_FOLDER\sys\net\IPv6\IPinfo\IPinfo.csv")
                                            {
                                                if([int](& $xsv count "$OUTPUT_FOLDER\sys\net\IPv6\IPinfo\IPinfo.csv") -gt 0)
                                                {
                                                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\net\IPv6\IPinfo\IPinfo.csv" -Delimiter "," | Sort-Object ip
                                                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\net\IPv6\IPinfo\IPinfo.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "IPinfo" -CellStyleSB {
                                                    param($WorkSheet)
                                                    # BackgroundColor and FontColor for specific cells of TopRow
                                                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                                    Set-Format -Address $WorkSheet.Cells["A1:AI1"] -BackgroundColor $BackgroundColor -FontColor White
                                                    # HorizontalAlignment "Center" of columns A-I and K-AI
                                                    $WorkSheet.Cells["A:I"].Style.HorizontalAlignment="Center"
                                                    $WorkSheet.Cells["K:AI"].Style.HorizontalAlignment="Center"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    Write-Output "[Info]  ipinfo.exe NOT found."
                }
            }

            # netstat-v.txt
            if (Test-Path "$DriveLetter\sys\net\netstat-v.txt")
            {
                Copy-Item "$DriveLetter\sys\net\netstat-v.txt" -Destination "$OUTPUT_FOLDER\sys\net\netstat-v.txt"
            }

            # State
            if ((Test-Path "$OUTPUT_FOLDER\sys\net\CSV\net.csv") -And ([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\net\CSV\net.csv") -gt 0))
            {
                $CLOSED      = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "CLOSED" }).Count
                $CLOSING     = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "CLOSING" }).Count
                $CLOSE_WAIT  = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "CLOSE_WAIT" }).Count
                $ESTABLISHED = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "ESTABLISHED" }).Count
                $FIN_WAIT_1  = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "FIN_WAIT_1" }).Count
                $FIN_WAIT_2  = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "FIN_WAIT_2" }).Count
                $LAST_ACK    = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "LAST_ACK" }).Count
                $LISTENING   = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "LISTENING" }).Count
                $SYN_RCVD    = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "SYN_RCVD" }).Count
                $SYN_SENT    = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "SYN_SENT" }).Count
                $TIME_WAIT   = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "TIME_WAIT" }).Count

                Write-Output "CLOSED      : $CLOSED" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "CLOSING     : $CLOSING" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "CLOSE_WAIT  : $CLOSE_WAIT" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "ESTABLISHED : $ESTABLISHED" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "FIN_WAIT_1  : $FIN_WAIT_1" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "FIN_WAIT_2  : $FIN_WAIT_2" | Out-File "$OUTPUT_FOLDER\sys\net\Stats.txt" -Append
                Write-Output "LAST_ACK    : $LAST_ACK" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "LISTENING   : $LISTENING" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "SYN_RCVD    : $SYN_RCVD" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "SYN_SENT    : $SYN_SENT" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "TIME_WAIT   : $TIME_WAIT" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
            }

            # Stats
            if ((Test-Path "$OUTPUT_FOLDER\sys\net\State.txt") -And ((Get-Item "$OUTPUT_FOLDER\sys\net\State.txt").length -gt 0kb))
            {
                $Stats = Get-Content "$OUTPUT_FOLDER\sys\net\State.txt" | ForEach-Object{($_ -replace ":","")} | ConvertFrom-String -PropertyNames State, Count | Sort-Object Count -Descending
                ($Stats | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\net\Stats.txt"
            }

            # CLOSED        Closed. The socket is not being used.
            # CLOSING       Closed, then remote shutdown; awaiting acknowledgment.
            # CLOSE_WAIT    Remote shutdown; waiting for the socket to close.
            # ESTABLISHED   Connection has been established.
            # FIN_WAIT_1    Socket closed; shutting down connection.
            # FIN_WAIT_2    Socket closed; waiting for shutdown from remote.
            # LAST_ACK      Remote shutdown, then closed; awaiting acknowledgment.
            # LISTENING     Listening for incoming connections.
            # SYN_RCVD      Active/initiate synchronization received and the connection under way.
            # SYN_SENT      Actively trying to establish connection.
            # TIME_WAIT     Wait after close for remote shutdown retransmission.
                
            # Suspicious Port Numbers

            # Source

            # TCP on Source Port 3262 --> This rule detects events that may indicate use of encrypted traffic on TCP port 3262 (F-Response)
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Source -like "*:3262" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Output "[Info]  TCP on Source Port 3262 detected - May indicates use of encrypted traffic by F-Response ($Count)"
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Source-Port-3262.txt"
            }

            # TCP on Source Port 3389 --> This rule detects events that may indicate incoming Remote Desktop Protocol (RDP) activity on TCP port 3389 - Incoming
            # Note: proc.xlsx --> CommandLine: C:\Windows\System32\svchost.exe -k termsvc
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Source -match ":3389$" } | Where-Object { $_.Process -eq "svchost.exe" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Source Port 3389 detected - May indicates incoming Remote Desktop Protocol (RDP) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Source-Port-3389.txt"
            }

            # TCP on Source Port 4444 --> This rule detects events that may indicate a Meterpreter session (Reverse Shell)
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.State -eq "LISTENING" } | Where-Object { $_.Source -match ":4444$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Source Port 4444 detected - May indicates use of Meterpreter Reverse Shell ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Source-Port-4444.txt"
            }

            # TCP on Source Port 4899 --> This rule detects events that may indicate incoming Radmin-Server (Remote Desktop) activity on TCP port 4899 - Incoming (rserver3.exe)
            # Note: Radmin by Famatech Corp. (e.g. Advanced IP Scanner)
            # https://www.radmin.com/
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Source -match ":4899$" }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Source Port 4899 detected - May indicates incoming Radmin-Server (Remote Desktop) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Source-Port-4899.txt"
            }

            # Destination

            # TCP on Destination Port 20 --> This rule detects events that may indicate outgoing File Transfer Protocol (FTP) activity over port 20
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":20$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 20 detected - May indicates  File Transfer Protocol (FTP) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-20.txt"
            }

            # TCP on Destination Port 21 --> This rule detects events that may indicate outgoing File Transfer Protocol (FTP) activity over port 21
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":21$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 21 detected - May indicates outgoing File Transfer Protocol (FTP) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-21.txt"
            }

            # TCP on Destination Port 3389 --> This rule detects events that may indicate outgoing Remote Desktop Protocol (RDP) activity on TCP port 3389 - Outgoing
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":3389$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 3389 detected - May indicates outgoing Remote Desktop Protocol (RDP) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-3389.txt"
            }

            # TCP on Destination Port 4899 --> This rule detects events that may indicate outgoing Radmin Viewer (Remote Desktop) activity on TCP port 4899 - Outgoing (Radmin.exe)
            # Note: Radmin by Famatech Corp. (e.g. Advanced IP Scanner)
            # https://www.radmin.com/
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":4899$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 4899 detected - May indicates outgoing Radmin-Viewer (Remote Desktop) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-4899.txt"
            }

            # TCP on Destination Port 17301 --> This rule detects events that may indicate outgoing Radmin-VPN (RvControlSvc.exe) activity on TCP port 17301 - Outgoing
            # Note: Radmin VPN by Famatech Corp. (e.g. Advanced IP Scanner)
            # https://www.radmin-vpn.com/
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":17301$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 17301 detected - May indicates outgoing Radmin-VPN activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-17301.txt"
            }

            # TCP on Destination Port 8080 --> This rule detects events that may indicate Command-and-Control (C2) activity over port 8080
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":8080$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 8080 detected - May indicates Command-and-Control (C2) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-8080.txt"
            }

            # TCP on Destination Port 8081 --> This rule detects events that may indicate Command-and-Control (C2) activity over port 8081
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":8081$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 8081 detected - May indicates Command-and-Control (C2) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-8081.txt"
            }

            # TCP on Destination Port 9001 --> This rule detects events that may indicate use of Tor client on TCP port 9001
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":9001$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 9001 detected - May indicates Tor activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-9001.txt"
            }

            # TCP on Destination Port 9030 --> This rule detects events that may indicate Tor activity on TCP port 9030
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":9030$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 9030 detected - May indicates Tor activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-9030.txt"
            }

            # TCP on Destination Port 9150 --> This rule detects events that may indicate use of Tor client on TCP port 9150
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -eq "127.0.0.1:9150" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 9150 detected - May indicates Tor activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-9150.txt"
            }
        }

        # FS_SysInfo_Process
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_Process
        if (Test-Path "$DriveLetter\sys\proc\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\proc\TXT" -ItemType Directory -Force | Out-Null
            Add-Content -Path "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" -Encoding utf8 -Value (Get-Content -Path "$DriveLetter\sys\proc\proc.txt")
            Add-Content -Path "$OUTPUT_FOLDER\sys\proc\TXT\proc-v.txt" -Encoding utf8 -Value (Get-Content -Path "$DriveLetter\sys\proc\proc-v.txt")

            # Count Processes
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Measure-Object).Count -2
            Write-Output "[Info]  Processing $Count Processes ..."

            # Flags
            # 32 - Process is 32-bit on 64-bit Windows.
            # E  - Process is NOT found in EPROCESS list (memory corruption, drift or unlink)
            # T  - Process is terminated
            # U  - Process is user-account (non-system user)
            # *  - Process is outside standard paths.

            # CSV
            if (Test-Path "$DriveLetter\forensic\json\general.json")
            {
                New-Item "$OUTPUT_FOLDER\sys\proc\CSV" -ItemType Directory -Force | Out-Null

                $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "process" }

                $Data | Foreach-Object {

                $proc = $_ | Select-Object -ExpandProperty proc

                # Replace empty "Process Name" fields
                if ($proc -eq "")
                {
                    $proc = "<unknown>"        
                }

                $procid = $_ | Select-Object -ExpandProperty pid
                $obj = $_ | Select-Object -ExpandProperty obj
                $parentid = $_ | Select-Object -ExpandProperty num -ErrorAction SilentlyContinue
                $parentproc = $Data | Where-Object { $_.pid -eq "$parentid" } | Select-Object -ExpandProperty proc
                $hex = $_ | Select-Object -ExpandProperty hex -ErrorAction SilentlyContinue
                $hex2 = $_ | Select-Object -ExpandProperty hex2 -ErrorAction SilentlyContinue
                $desc = $_ | Select-Object -ExpandProperty desc
                $flags = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="flags"; Expression={ForEach-Object{($_ -split "flags:")[1]} | ForEach-Object{($_ -split "user:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $user = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="user"; Expression={ForEach-Object{($_ -split "user:")[1]} | ForEach-Object{($_ -split "upath:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $upath = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="upath"; Expression={ForEach-Object{($_ -split "upath:")[1]} | ForEach-Object{($_ -split "cmd:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $cmd = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="cmd"; Expression={ForEach-Object{($_ -split "cmd:")[1]} | ForEach-Object{($_ -split "createtime:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $createtime = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="createtime"; Expression={ForEach-Object{($_ -split "createtime:")[1]} | ForEach-Object{($_ -split "integrity:")[0]} | ForEach-Object{($_ -split "exittime:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $exittime = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="exittime"; Expression={ForEach-Object{($_ -split "exittime:")[1]} | ForEach-Object{($_ -split "integrity:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $integrity = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="integrity"; Expression={ForEach-Object{($_ -split "integrity:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $SubProcesses = ($Data | Where-Object { $_.num -eq $procid } | Measure-Object).Count

                New-Object -TypeName PSObject -Property @{
                    "Create Time" = $createtime.createtime
	                "Process Name" = $proc
	                "PID" = $procid
	                "obj " = $obj
                    "Parent Name" = $parentproc
	                "PPID" = $parentid
                    "hex" = $hex
                    "hex2" = $hex2
                    "Device Path" = $desc
                    "Flags" = $flags.flags
                    "User" = $user.user
                    "File Path" = $upath.upath
                    "CommandLine" = $cmd.cmd
                    "Integrity" = $integrity.integrity
                    "Exit Time" = $exittime.exittime
                    "Sub-Processes" = $SubProcesses
                    }
                } | Select-Object "Create Time","Process Name","PID","Parent Name","PPID","Sub-Processes","Device Path","Flags","User","File Path","CommandLine","Integrity","Exit Time" | Export-Csv -Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" -NoTypeInformation
            }

            # XLSX

            # Default
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\sys\proc\XLSX" -ItemType Directory -Force | Out-Null
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Sort-Object "Create Time" -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\XLSX\Processes.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Processes" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                        $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
            
            # Process Tree (TreeView)
            if (Test-Path "$SCRIPT_DIR\Scripts\Get-ProcessTree\Get-ProcessTree.ps1")
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
                    {
                        Write-Output "[Info]  Launching Process Tree (TreeView) ... "
                        Start-Process -FilePath "powershell" -NoNewWindow -ArgumentList "-NoProfile", "-File", "$SCRIPT_DIR\Scripts\Get-ProcessTree\Get-ProcessTree.ps1", "-CSVPath", "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv"
                        Start-Sleep -Seconds 3
                        $Host.UI.RawUI.WindowTitle = "MemProcFS-Analyzer v0.8 - Automated Forensic Analysis of Windows Memory Dumps for DFIR"
                    }
                }
            }

            # Running and Exited Processes
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\sys\proc\XLSX" -ItemType Directory -Force | Out-Null
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Sort-Object "Create Time" -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\XLSX\RunningAndExited.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Processes" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:L1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                        $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"

                        # Exited Processes
                        $ExitedColor = [System.Drawing.Color]::FromArgb(255,0,0) # Red
                        Add-ConditionalFormatting -Address $WorkSheet.Dimension.Address -WorkSheet $WorkSheet -RuleType 'Expression' '=NOT(OR($M1="", $M1="Exit Time"))' -BackgroundColor $ExitedColor

                        # Running Processes
                        $RunningColor = [System.Drawing.Color]::FromArgb(0,255,0) # Green
                        Add-ConditionalFormatting -Address $WorkSheet.Dimension.Address -WorkSheet $WorkSheet -RuleType 'Expression' '=($M1="")' -BackgroundColor $RunningColor
                        }
                    }
                }
            }

            # Unusual Parent-Child Relationships

            # 01. Unusual Parent-Child Relationship (csrss.exe)
            $Pid_smss = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "smss.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Pid_svchost = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "svchost.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "csrss.exe" | Where-Object{($_ -notmatch "$Pid_smss|$Pid_svchost")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: csrss.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "csrss.exe" | Where-Object{($_ -notmatch "$Pid_smss|$Pid_svchost")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\csrss.exe.txt"
            }

            # 02. Unusual Parent-Child Relationship (LogonUI.exe)
            $Pid_wininit = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "wininit.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Pid_winlogon = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "winlogon.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "LogonUI.exe" | Where-Object{($_ -notmatch "$Pid_wininit|$Pid_winlogon")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: LogonUI.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "LogonUI.exe" | Where-Object{($_ -notmatch "$Pid_wininit|$Pid_winlogon")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\LogonUI.exe.txt"
            }

            # 03. Unusual Parent-Child Relationship (lsass.exe)
            $Pid_wininit = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "wininit.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "lsass.exe" | Where-Object{($_ -notmatch $Pid_wininit)} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: lsass.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "lsass.exe" | Where-Object{($_ -notmatch "$Pid_wininit")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\lsass.exe.txt"
            }

            # 04. Unusual Parent-Child Relationship (services.exe)
            $Pid_wininit = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "wininit.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "services.exe" | Where-Object{($_ -notmatch $Pid_wininit)} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: services.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "services.exe" | Where-Object{($_ -notmatch "$Pid_wininit")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\services.exe.txt"
            }

            # 05. Unusual Parent-Child Relationship (smss.exe)
            $Pid_System = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "System " -CaseSensitive | ForEach-Object{($_ -split "\s+")[2]}
            $Pid_smss = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "smss.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "smss.exe" | Where-Object{($_ -notmatch "$Pid_System|$Pid_smss")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: smss.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "smss.exe" | Where-Object{($_ -notmatch "$Pid_System|$Pid_smss")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\smss.exe.txt"
            }

            # 06. Unusual Parent-Child Relationship (spoolsv.exe)
            $Pid_services = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "services.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "spoolsv.exe" | Where-Object{($_ -notmatch $Pid_services)} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: spoolsv.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "spoolsv.exe" | Where-Object{($_ -notmatch "$Pid_services")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\spoolsv.exe.txt"
            }

            # 07. Unusual Parent-Child Relationship (svchost.exe)
            $Pid_services = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "services.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Pid_MsMpEng = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "MsMpEng.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "svchost.exe" | Where-Object{($_ -notmatch "$Pid_services|$Pid_MsMpEng")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: svchost.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "svchost.exe" | Where-Object{($_ -notmatch "$Pid_services|$Pid_MsMpEng")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\svchost.exe.txt"
            }

            # 08. Unusual Parent-Child Relationship (taskhost.exe)
            $Pid_services = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "services.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Pid_svchost = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "svchost.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "taskhost.exe" | Where-Object{($_ -notmatch "$Pid_services|$Pid_svchost")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: taskhost.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "taskhost.exe" | Where-Object{($_ -notmatch "$Pid_services|$Pid_svchost")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\taskhost.exe.txt"
            }

            # 09. Unusual Parent-Child Relationship (taskhostw.exe)
            $Pid_services = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "services.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Pid_svchost = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "svchost.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "taskhostw.exe" | Where-Object{($_ -notmatch "$Pid_services|$Pid_svchost")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: taskhostw.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "taskhostw.exe" | Where-Object{($_ -notmatch "$Pid_services|$Pid_svchost")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\taskhostw.exe.txt"
            }

            # 10. Unusual Parent-Child Relationship (userinit.exe)
            $Pid_dwm = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "dwm.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Pid_winlogon = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "winlogon.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "userinit.exe" | Where-Object{($_ -notmatch "$Pid_dwm|$Pid_winlogon")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: userinit.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "userinit.exe" | Where-Object{($_ -notmatch "$Pid_dwm|$Pid_winlogon")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\userinit.exe.txt"
            }

            # 11. Unusual Parent-Child Relationship (wininit.exe)
            $Pid_smss = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "smss.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "wininit.exe" | Where-Object{($_ -notmatch $Pid_smss)} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: wininit.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "wininit.exe" | Where-Object{($_ -notmatch "$Pid_smss")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\wininit.exe.txt"
            }

            # 12. Unusual Parent-Child Relationship (winlogon.exe)
            $Pid_smss = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "smss.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "winlogon.exe" | Where-Object{($_ -notmatch $Pid_smss)} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: winlogon.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "winlogon.exe" | Where-Object{($_ -notmatch "$Pid_smss")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\winlogon.exe.txt"
            }

            # Unusual Number of Process Instances
            if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
            {
                if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
                {
                    $RunningProcs = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Exit Time" -eq "" }

                    # Unusual Number of Process Instances (lsaiso.exe)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "lsaiso.exe" } | Measure-Object).Count
                    if ($Count -ne 0 -and $Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: lsaiso.exe ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "lsaiso.exe" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\lsaiso.exe.txt"
                    }

                    # Unusual Number of Process Instances (lsass.exe)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "lsass.exe" } | Measure-Object).Count
                    if ($Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: lsass.exe ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "lsass.exe" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\lsass.exe.txt"
                    }

                    # Unusual Number Process of Instances (lsm.exe)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "lsm.exe" } | Measure-Object).Count
                    if ($Count -ne 0 -and $Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: lsm.exe ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "lsm.exe" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\lsm.exe.txt"
                    }

                    # Unusual Number Process of Instances (Memory Compression)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "MemCompression" } | Measure-Object).Count
                    if ($Count -ne 0 -and $Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: MemCompression ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "MemCompression" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\MemCompression.txt"
                    }

                    # Unusual Number Process of Instances (Registry)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "Registry" } | Measure-Object).Count
                    if ($Count -ne 0 -and $Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: Registry ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "Registry" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\Registry.txt"
                    }

                    # Unusual Number of Process Instances (services.exe)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "services.exe" } | Measure-Object).Count
                    if ($Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: services.exe ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "services.exe" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\services.exe.txt"
                    }

                    # Unusual Number of Process Instances (System)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "System" } | Measure-Object).Count
                    if ($Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: System ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "System" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\System.txt"
                    }

                    # Unusual Number of Process Instances (wininit.exe)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "wininit.exe" } | Measure-Object).Count
                    if ($Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: wininit.exe ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "wininit.exe" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\wininit.exe.txt"
                    }
                }
            }
        }

        # Process Masquerading
        # https://attack.mitre.org/techniques/T1036/
        # https://car.mitre.org/analytics/CAR-2021-04-001/
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                # Process Path Masquerading - Looks for mismatches between process names and their image paths
                # https://attack.mitre.org/techniques/T1036/005/
                Write-Output "[Info]  Checking for Process Path Masquerading ..."

                # Masquerading Client/Server Runtime Subsystem (csrss.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "csrss.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\csrss\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Client/Server Runtime Subsystem (csrss.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\csrss.exe.txt"
                }

                # Masquerading Windows Explorer (explorer.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "explorer.exe" -and $_."Device Path" -notmatch "\\Windows\\explorer\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Windows Explorer (explorer.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\explorer.exe.txt"
                }

                # Masquerading Local Security Authority Server Service (lsass.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "lsass.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\lsass\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Local Security Authority Server Service (lsass.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\lsass.exe.txt"
                }

                # Masquerading Local Session Manager Service (lsm.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "lsm.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\lsm\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Local Session Manager Service (lsm.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\lsm.exe.txt"
                }

                # Masquerading Windows Services Control Manager (services.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "services.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\services\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Windows Services Control Manager (services.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\services.exe.txt"
                }

                # Masquerading Windows Session Manager Subsystem (smss.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "smss.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\smss\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Windows Session Manager Subsystem (smss.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\smss.exe.txt"
                }

                # Masquerading Windows Service Host (svchost.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "svchost.exe" -and ($_."Device Path" -notmatch "\\Windows\\System32\\svchost\.exe" -and $_."Device Path" -notmatch "\\Windows\\SysWOW64\\svchost\.exe") }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Windows Service Host (svchost.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\svchost.exe.txt"
                }

                # Masquerading Host Process for Windows Tasks (taskhost.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "taskhost.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\taskhost\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Host Process for Windows Tasks (taskhost.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\taskhost.exe.txt"
                }

                # Masquerading Host Process for Windows Tasks (taskhostw.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "taskhostw.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\taskhostw\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Host Process for Windows Tasks (taskhostw.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\taskhostw.exe.txt"
                }

                # Masquerading Windows Start-Up Application (wininit.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "wininit.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\wininit\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Windows Start-Up Application (wininit.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\wininit.exe.txt"
                }

                # Masquerading Windows Logon (winlogon.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "winlogon.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\winlogon\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Windows Logon (winlogon.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\winlogon.exe.txt"
                }

                # Process Name Masquerading - Measures the edit distance between used Process Name and Original Windows Process Name (Damerau–Levenshtein Distance)
                # https://en.wikipedia.org/wiki/Damerau-Levenshtein_distance
                Write-Output "[Info]  Checking Damerau–Levenshtein Distance of common System Processes ..."
                
                if (Test-Path "$SCRIPT_DIR\Scripts\Measure-DamerauLevenshteinDistance\Measure-DamerauLevenshteinDistance.cs")
                {
                    Add-Type -Path "$SCRIPT_DIR\Scripts\Measure-DamerauLevenshteinDistance\Measure-DamerauLevenshteinDistance.cs" | Out-Null

                    $ProcessList = (Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -ne "" } | Select-Object PID | Sort-Object @{Expression={$_.PID -as [int]}}).PID

                    ForEach( $ProcessID in $ProcessList )
                    {
                        $ProcessName = (Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."PID" -eq "$ProcessID" } | Select-Object "Process Name")."Process Name"

                        # Masquerading Client/Server Runtime Subsystem (csrss.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("csrss.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: csrss.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading COM Surrogate (dllhost.exe) --> Microsoft Component Object Model (COM)
                        [int]$Distance = [LevenshteinDistance]::Measure("dllhost.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: dllhost.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Windows Explorer (explorer.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("explorer.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: explorer.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Internet Explorer (iexplore.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("iexplore.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: iexplore.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Local Security Authority Server Service (lsass.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("lsass.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: lsass.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Shell Infrastructure Host (sihost.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("sihost.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: sihost.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Windows Session Manager Subsystem (smss.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("smss.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: smss.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Windows Service Host (svchost.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("svchost.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: svchost.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Windows Logon (winlogon.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("winlogon.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: winlogon.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }
                    }
                }
                else
                {
                    Write-Host "[Error] Measure-DamerauLevenshteinDistance.cs NOT found." -ForegroundColor Red
                }
            }
        }

#############################################################################################################################################################################################
        
        Function Get-ProcessesWithUnusualUserContext {

        # Processes w/ Unusual User Context
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                Write-Output "[Info]  Checking for Processes w/ Unusual User Context ..."

                # Windows Service Host (svchost.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "svchost.exe" } | Where-Object { $_.User -notmatch "SYSTEM|LOCAL SERVICE|NETWORK SERVICE" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Windows Service Host (svchost.exe) detected: Running under unusual user context (Count: $Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_User-Context" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_User-Context\svchost.exe.txt"
                }

                # svchost.exe is supposed to run in Session 0 under one of 3 users: SYSTEM, LOCAL SERVICE or NETWORK SERVICE.
                # If svchost.exe is ran by SYSTEM, NETWORK SERVICE or LOCAL SERVICE, then it should be legitmate, but if it is ran under an user account, 
                # then you need to investigate if the svchost.exe file is from another location than "C:\Windows\System32".
            }
        }

        }

        Get-ProcessesWithUnusualUserContext

#############################################################################################################################################################################################
        
        Function Get-ProcessesFromSuspiciousFolders {

        # Checking for processes spawned from suspicious folder locations
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                Write-Output "[Info]  Checking for Processes Spawned From Suspicious Folder Locations ..."

                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Device Path" -ne "" } | Sort-Object @{Expression={$_.PID -as [int]}}

                # Desktop (incl. subdirectories) - The onscreen work area provided by Microsoft Windows that represents the kinds of objects one might find on top of a physical desk
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Users\\.*\\Desktop\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\Desktop\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\Desktop.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Desktop" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Downloads (incl. subdirectories) - Default location to save all downloaded content
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Users\\.*\\Downloads\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\Downloads\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\Downloads.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Downloads" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Documents (incl. subdirectories) - Default location for all user created documents
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Users\\.*\\Documents\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\Documents\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\Documents.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Documents" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # PUBLIC (incl. subdirectories) - The Public folder is located in "%SystemDrive%\Users\Public", in all Windows versions. All user accounts registered in Windows have access to it. That's why it is named Public. Any file and folder found in "C:\Users\Public" is completely accessible to all users.
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Users\\Public\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\Public\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\PUBLIC.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "PUBLIC" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Temp (incl. subdirectories) - Temporary Files created by the User (when running any software)
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Users\\.*\\AppData\\Local\\Temp\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\AppData\Local\Temp\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\TEMP.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "TEMP" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Temp - Root Directory (incl. subdirectories)
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Device\\HarddiskVolume[0-9]\\Temp\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Temp\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\Temp-Root.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Temp" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # ALLUSERSPROFILE (incl. subdirectories)
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Device\\HarddiskVolume[0-9]\\ProgramData\\" } | Where-Object { $_."Device Path" -notmatch "\\Microsoft\\Windows Defender\\Platform\\.*\\[MsMpEng.exe|MpCopyAccelerator.exe]" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\ProgramData\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\ALLUSERSPROFILE.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "ALLUSERSPROFILE" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # SystemDrive (Root Directory) --> [A-Za-z0-9_]*
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Device\\HarddiskVolume[0-9]\\\w+$" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\SystemDrive.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "SystemDrive" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # LOCALAPPDATA (incl. subdirectories) - Default location of temporary files of applications (Vista+)
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Device\\HarddiskVolume[0-9]\\Users\\*\\AppData\\Local\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\AppData\Local\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\LOCALAPPDATA.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "LOCALAPPDATA" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # LocalLow (incl. subdirectories) - like LOCALAPPDATA, but with a lower integrity level
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Device\\HarddiskVolume[0-9]\\Users\\*\\AppData\\LocalLow\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\AppData\LocalLow\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\LocalLow.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "LocalLow" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # APPDATA (incl. subdirectories) - Default location for user application data and binaries
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Device\\HarddiskVolume[0-9]\\Users\\*\\AppData\\Roaming\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\AppData\Roaming\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\APPDATA.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "APPDATA" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }
            }
        }

        }

        Get-ProcessesFromSuspiciousFolders

#############################################################################################################################################################################################
        
        # Checking for suspicious process lineage
        # https://d3fend.mitre.org/technique/d3f:ProcessLineageAnalysis/

        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Sort-Object @{Expression={$_.PID -as [int]}}

                Write-Output "[Info]  Checking for Suspicious Process Lineage ..."

                # Checking for suspicious parent processes

                # System Binary Proxy Execution: rundll32.exe
                # https://attack.mitre.org/techniques/T1218/011/

                # rundll32.exe spawns conhost.exe
                # Note: With the introduction of Windows Terminal in May 2020, conhost.exe can act as an execution proxy. Attackers may abuse this feature to execute malicious files and evade detection.
                $Data = $Import | Where-Object { $_."Process Name" -eq "conhost.exe" } | Where-Object { $_."Parent Name" -eq "rundll32.exe" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Windows Console Host (conhost.exe) spawned by suspicious parent process: rundll32.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Parent-Processes" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Parent-Processes\rundll32.exe_spawns_conhost.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "conhost.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["D2:D$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # svchost.exe spawns cmd.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "cmd.exe" } | Where-Object { $_."Parent Name" -eq "svchost.exe" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)
  
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Windows Command Shell (cmd.exe) spawned by suspicious parent process: svchost.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Parent-Processes" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Parent-Processes\svchost.exe_spawns_cmd.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "cmd.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["D2:D$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Checking for suspicious child processes

                # WINWORD.EXE spawns cmd.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "cmd.exe" } | Where-Object { $_."Parent Name" -eq "WINWORD.EXE" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Child Process of Microsoft Word detected: cmd.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes\winword.exe_spawns_cmd.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "cmd.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["D2:D$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # WINWORD.EXE spawns powershell.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "powershell.exe" } | Where-Object { $_."Parent Name" -eq "WINWORD.EXE" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Child Process of Microsoft Word detected: powershell.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes\winword.exe_spawns_powershell.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "powershell.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["D2:D$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # WINWORD.EXE spawns mshta.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "mshta.exe" } | Where-Object { $_."Parent Name" -eq "WINWORD.EXE" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Child Process of Microsoft Word detected: mshta.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes\winword.exe_spawns_mshta.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "mshta.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["D2:D$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # WINWORD.EXE spawns regsvr32.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "regsvr32.exe" } | Where-Object { $_."Parent Name" -eq "WINWORD.EXE" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Child Process of Microsoft Word detected: regsvr32.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes\winword.exe_spawns_regsvr32.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "regsvr32.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["D2:D$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }
            }
        }

#############################################################################################################################################################################################

        Function Get-ProcessesWithSuspiciousCommandLineArguments {

        # Checking for processes with suspicious command-line arguments
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Sort-Object @{Expression={$_.PID -as [int]}}

                Write-Output "[Info]  Checking for Processes with Suspicious Command Line Arguments ..."

                # powershell.exe
                $powershell = $Import | Where-Object { $_."Process Name" -eq "powershell.exe" } 

                # Encoded Command (indicates the following chunk of text is a base64 encoded command)
                # https://attack.mitre.org/techniques/T1027/
                $EncodedCommand = $powershell | Where-Object {($_.CommandLine -match "-EncodedCommand") -or ($_.CommandLine -match "-Enc") -or ($_.CommandLine -match "-en ") -or ($_.CommandLine -match "-e ")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($EncodedCommand | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Encoded Command ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $EncodedCommand | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Encoded-Command.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Encoded Command" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Base64 Encoding
                # https://attack.mitre.org/techniques/T1027/
                $Base64Encoding = $powershell | Where-Object {($_.CommandLine -match "base64")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($Base64Encoding | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Base64 Encoding ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $Base64Encoding | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Base64-Encoding.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Base64 Encoding" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # WindowStyle Hidden (indicates that the PowerShell session window should be started in a hidden manner)
                # https://attack.mitre.org/techniques/T1564/003/
                $WindowStyleHidden = $powershell | Where-Object {($_.CommandLine -match "-WindowStyle Hidden") -or ($_.CommandLine -match "-W Hidden")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($WindowStyleHidden | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: WindowStyle Hidden ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $WindowStyleHidden | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\WindowStyle-Hidden.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "WindowStyle Hidden" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Execution Policy Bypass (disables the execution policy for the current PowerShell session)
                # https://attack.mitre.org/techniques/T1059/001/
                $ExecutionPolicyBypass = $powershell | Where-Object {($_.CommandLine -match "-ExecutionPolicy Bypass") -or ($_.CommandLine -match "-Exec Bypass") -or ($_.CommandLine -match "-EP ByPass")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($ExecutionPolicyBypass | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Execution Policy Bypass ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $ExecutionPolicyBypass | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Execution-Policy-Bypass.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Execution Policy Bypass" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Profile Bypass (indicates that the current user’s profile setup script should not be executed when the PowerShell engine starts)
                $ProfileBypass = $powershell | Where-Object {($_.CommandLine -match "-NoProfile") -or ($_.CommandLine -match "-nop ")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($ProfileBypass | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Profile Bypass ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $ProfileBypass | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Profile-Bypass.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Profile Bypass" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # NonInteractive Mode (meaning an interactive prompt to the user will not be presented)
                $NonInteractive = $powershell | Where-Object {($_.CommandLine -match "-NonInteractive") -or ($_.CommandLine -match "-NonI")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($NonInteractive | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: NonInteractive Mode ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $NonInteractive | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\NonInteractive-Mode.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "NonInteractive" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Download (remotely download and execute arbitrary code and binaries)
                # https://attack.mitre.org/techniques/T1059/001/
                $Download = $powershell | Where-Object {($_.CommandLine -match "invoke-webrequest") -or ($_.CommandLine -match "iwr") -or ($_.CommandLine -match "http") -or ($_.CommandLine -match "DownloadString") -or ($_.CommandLine -match "WebClient") -or ($_.CommandLine -match "downloadfile") -or ($_.CommandLine -match "wget") -or ($_.CommandLine -match "cURL")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($Download | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Remote Download ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $Download | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Download-and-Execution.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Download" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Invoke-Expression (executes the command provided on the local machine)
                # https://attack.mitre.org/techniques/T1059/001/
                $Invoke = $powershell | Where-Object {($_.CommandLine -match "Invoke-Expression") -or ($_.CommandLine -match "IEX")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($Invoke | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Invoke-Expression ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $Invoke | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Invoke-Expression.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Invoke-Expression" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Start-Process
                # https://attack.mitre.org/techniques/T1059/001/
                $Execute = $powershell | Where-Object {($_.CommandLine -match "Start-Process")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($Execute | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Start-Process ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $Execute | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Start-Process.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Start-Process" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # cmd.exe
                $cmd = $Import | Where-Object { $_."Process Name" -eq "cmd.exe" } 

                # CommandLine Flags
                # https://attack.mitre.org/techniques/T1059/003/
                $CommandLineFlags = $cmd | Where-Object {($_.CommandLine -match "/c") -or ($_.CommandLine -match "/q") -or ($_.CommandLine -match "/k")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($CommandLineFlags | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Windows Command Shell Parameter detected: CommandLine Flags ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\cmd.exe" -ItemType Directory -Force | Out-Null
                    $CommandLineFlags | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\cmd.exe\CommandLine-Flags.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "CommandLine Flags" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,255,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(0,0,0)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # /c = The /c parameter is used to terminate the shell after command completion.
                # /q = The /q parameter is used to turn echo off.
                # /k = The /k parameter is used to run a command and then remain open (e.g. whoami).

                # Windows Command Shell + Execution of Batch Script
                # https://attack.mitre.org/techniques/T1059/003/
                $CommandShellBatchScript = $cmd | Where-Object {(($_.CommandLine -match "/c") -or ($_.CommandLine -match "/q") -or ($_.CommandLine -match "/k")) -and (($_.CommandLine -match "\.bat") -or ($_.CommandLine -match "\.cmd"))} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($CommandShellBatchScript | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Windows Command Shell Parameter detected: Execution of Batch Script ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\cmd.exe" -ItemType Directory -Force | Out-Null
                    $CommandShellBatchScript | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\cmd.exe\Execution-of-Batch-Script.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Batch Script" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # mshta.exe
                $mshta = $Import | Where-Object { $_."Process Name" -eq "mshta.exe" }
                
                # Suspicious Execution
                # https://attack.mitre.org/techniques/T1059/007/
                # https://attack.mitre.org/techniques/T1218/005/
                $MshtaExecution = $mshta | Where-Object {(($_.CommandLine -match "\.hta") -or ($_.CommandLine -match "\.htm") -or ($_.CommandLine -match "http") -or ($_.CommandLine -match "javascript") -or ($_.CommandLine -match "vbscript"))} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($MshtaExecution | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Microsoft HTML Application Host Parameter detected: Execution of HTA File (and Javascript or VBScript) ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\mshta.exe" -ItemType Directory -Force | Out-Null
                    $MshtaExecution | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\mshta.exe\Suspicious-Execution.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Suspicious Execution" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }  
            }
        }

        }

        Get-ProcessesWithSuspiciousCommandLineArguments

#############################################################################################################################################################################################
        
        Function Get-SuspiciousProcessesWithoutCommandLineArguments {

        # Checking for suspicious processes without any command-line arguments
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                Write-Output "[Info]  Checking for Suspicious Processes without any Command Line Arguments ..."

                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Sort-Object @{Expression={$_.PID -as [int]}}

                # Process Injection
                # https://attack.mitre.org/techniques/T1055/

                # svchost.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "svchost.exe" } | Where-Object { $_."CommandLine" -eq " " }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Windows Service Host (svchost.exe) detected: No CommandLine value available ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Processes-Without-CommandLine-Arguments" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Processes-Without-CommandLine-Arguments\T1055_svchost.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "svchost.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # System Binary Proxy Execution
                # https://attack.mitre.org/techniques/T1218/011/

                # rundll32.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "rundll32.exe" } | Where-Object { $_."CommandLine" -eq " " }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious System Binary Proxy Execution (rundll32.exe) detected: No CommandLine value available ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Processes-Without-CommandLine-Arguments" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Processes-Without-CommandLine-Arguments\T1218.011_rundll32.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "rundll32.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }
            }
        }

        }

        Get-SuspiciousProcessesWithoutCommandLineArguments

#############################################################################################################################################################################################

        Function Get-MiniDumps {
        
        # MiniDumps
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                New-Item "$OUTPUT_FOLDER\sys\proc\MiniDumps" -ItemType Directory -Force | Out-Null
                $ProcessList = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -ne "" } | Select-Object "Process Name", PID | Sort-Object @{Expression={$_.PID -as [int]}}

                # TXT
                ForEach( $Process in $ProcessList )
                {
                    $ProcessID = ($Process | Select-Object PID).PID
                    $FilePath  = "$DriveLetter\pid\$ProcessID\minidump\minidump.dmp"
                    $FilePath | Out-File "$OUTPUT_FOLDER\sys\proc\MiniDumps\MiniDumps.txt" -Append
                }

                # CSV
                $ProcessList | Foreach-Object {
                    
                    $ProcessName = $_ | Select-Object -ExpandProperty "Process Name"
                    $ProcessID   = $_ | Select-Object -ExpandProperty PID
                    $FilePath    = "$DriveLetter\pid\$ProcessID\minidump\minidump.dmp"
                    $FileInfo    = Get-Item "$FilePath" -Force -ErrorAction SilentlyContinue
                    $Length      = $FileInfo.Length

                    if ($Length -eq "0")
                    {
                        $FileSize = "0"
                    }
                    else
                    {
                        $FileSize = Get-FileSize($Length)
                    }

                    New-Object -TypeName PSObject -Property @{
                        "ProcessName" = $ProcessName
                        "PID"         = $ProcessID
                        "FilePath"    = $FilePath
                        "Bytes"       = $Length
                        "FileSize"    = $FileSize
                        }
                } | Select-Object "ProcessName","PID","FilePath","Bytes","FileSize" | Export-Csv -Path "$OUTPUT_FOLDER\sys\proc\MiniDumps\MiniDumps.csv" -Delimiter "," -NoTypeInformation

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\sys\proc\MiniDumps\MiniDumps.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\sys\proc\MiniDumps\MiniDumps.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\proc\MiniDumps\MiniDumps.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\MiniDumps\MiniDumps.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "MiniDumps" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of column B
                            $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                            # HorizontalAlignment "Right" of columns D-E
                            $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Right"
                            # HorizontalAlignment "Center" of header of columns D-E
                            $WorkSheet.Cells["D1:E1"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
        }
        
        }

        Get-MiniDumps

#############################################################################################################################################################################################

        # FS_SysInfo_Services
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_Services
        if (Test-Path "$DriveLetter\sys\services\services.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\services" -ItemType Directory -Force | Out-Null

            # All Services
            Add-Content -Path "$OUTPUT_FOLDER\sys\services\services.txt" -Encoding utf8 -Value (Get-Content -Path "$DriveLetter\sys\services\services.txt")

            # Running Services
            Write-Output "   #    PID Start Type   State      Type Type    Obj Address  Name / Display Name                                              User                         Image Path                                          Object Name / Command Line   " | Out-File "$OUTPUT_FOLDER\sys\services\services-running.txt"
            Write-Output "----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------" | Out-File "$OUTPUT_FOLDER\sys\services\services-running.txt" -Append
            Get-Content "$OUTPUT_FOLDER\sys\services\services.txt" | Select-String -Pattern "RUNNING" -CaseSensitive | Add-Content "$OUTPUT_FOLDER\sys\services\services-running.txt" -Encoding utf8

            # Stopped Services
            Write-Output "   #    PID Start Type   State      Type Type    Obj Address  Name / Display Name                                              User                         Image Path                                          Object Name / Command Line   " | Out-File "$OUTPUT_FOLDER\sys\services\services-stopped.txt"
            Write-Output "----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------" | Out-File "$OUTPUT_FOLDER\sys\services\services-stopped.txt" -Append
            Get-Content "$OUTPUT_FOLDER\sys\services\services.txt" | Select-String -Pattern "STOPPED" -CaseSensitive | Add-Content "$OUTPUT_FOLDER\sys\services\services-stopped.txt" -Encoding utf8

            # Count Services
            $Total = (Get-Content "$OUTPUT_FOLDER\sys\services\services.txt" | Measure-Object).Count -2
            $Running = (Get-Content "$OUTPUT_FOLDER\sys\services\services-running.txt" | Measure-Object).Count
            Write-Output "[Info]  Processing $Total Services (Running Services: $Running) ..."

            # CSV
            if (Test-Path "$DriveLetter\forensic\json\general.json")
            {
                $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "service" }

                $Data | Foreach-Object {

                $procid = $_ | Select-Object -ExpandProperty pid -ErrorAction SilentlyContinue
                $obj = $_ | Select-Object -ExpandProperty obj
                $desc = $_ | Select-Object -ExpandProperty desc
                $start = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="start"; Expression={ForEach-Object{($_ -split "start:")[1]} | ForEach-Object{($_ -split "state:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $state = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="state"; Expression={ForEach-Object{($_ -split "state:")[1]} | ForEach-Object{($_ -split "type:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $type = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="type"; Expression={ForEach-Object{($_ -split "type:")[1]} | ForEach-Object{($_ -split "user:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $user = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="user"; Expression={ForEach-Object{($_ -split "user:")[1]} | ForEach-Object{($_ -split "image:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $image = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="image"; Expression={ForEach-Object{($_ -split "image:")[1]} | ForEach-Object{($_ -split "path:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $path = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="path"; Expression={ForEach-Object{($_ -split "path:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}

                New-Object -TypeName PSObject -Property @{
                    "PID" = $procid
                    "Start Type" = $start.start
                    "State" = $state.state
                    "Type" = $type.type
	                "Object Address" = $obj
	                "Name / Display Name" = $desc
                    "User" = $user.user
                    "Image Path" = $image.image
                    "Object Name / Command Line" = $path.path
                    }
                } | Select-Object "PID","Start Type","State","Type","Object Address","Name / Display Name","User","Image Path","Object Name / Command Line" | Export-Csv -Path "$OUTPUT_FOLDER\sys\services\services.csv" -Delimiter "`t" -NoTypeInformation
            }

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\services\services.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\services\services.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\services\services.csv" -Delimiter "`t"
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\services\services.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Services" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:I1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A-E and G
                        $WorkSheet.Cells["A:E"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
            
            # Service running from a suspicious folder location: C:\Users\*\AppData\Local\Temp\*
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\services\services.txt" | Select-String -Pattern "[A-Z]{1}:\\Users\\.*\\AppData\\Local\\Temp\\" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Service running from a suspicious folder location: C:\Users\*\AppData\Local\Temp\* ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\services\Suspicious-Services" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\services\services.txt" | Select-String -Pattern "[A-Z]{1}:\\Users\\.*\\AppData\\Local\\Temp\\" | Out-String).Trim() | Set-Content "$OUTPUT_FOLDER\sys\services\Suspicious-Services\AppData-Local-Temp.txt" -Encoding utf8
            }
        }

#############################################################################################################################################################################################

        # FS_SysInfo_ScheduledTasks
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_ScheduledTasks
        # Note: A scheduled task can be used by an adversary to establish persistence, move laterally, and/or escalate privileges.
        if (Test-Path "$DriveLetter\sys\tasks\tasks.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\tasks" -ItemType Directory -Force | Out-Null
            Add-Content -Path "$OUTPUT_FOLDER\sys\tasks\tasks.txt" -Encoding utf8 -Value (Get-Content -Path "$DriveLetter\sys\tasks\tasks.txt")

            # Count Scheduled Tasks
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Measure-Object).Count -2
            Write-Output "[Info]  Processing $Count ScheduledTasks ..."

            # CSV
            if (Test-Path "$DriveLetter\forensic\json\general.json")
            {
                $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "shtask" }

                $Data | Foreach-Object {

                $desc = $_ | Select-Object -ExpandProperty desc
                $user = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="user"; Expression={ForEach-Object{($_ -split "user:")[1]} | ForEach-Object{($_ -split "cmd:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $cmd = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="cmd"; Expression={ForEach-Object{($_ -split "cmd:")[1]} | ForEach-Object{($_ -split "param:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $param = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="param"; Expression={ForEach-Object{($_ -split "param:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}

                New-Object -TypeName PSObject -Property @{
	                "Task Name" = $desc
	                "User" = $user.user
	                "Command Line" = $cmd.cmd
	                "Parameters" = $param.param
                    }
                } | Select-Object "Task Name","User","Command Line","Parameters" | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\tasks.csv" -Delimiter "`t" -NoTypeInformation
            }

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\tasks\tasks.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\tasks\tasks.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\tasks\tasks.csv" -Delimiter "`t"
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\tasks.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Tasks" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of column B
                        $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }

            # Threat Hunting: Scheduled Tasks
            # https://attack.mitre.org/techniques/T1053/

            # a) Task Scheduler running from a suspicious folder location (False Positives: MEDIUM)

            # Task Scheduler running from a suspicious folder location: C:\Users\*
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "[A-Z]{1}:\\Users\\" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running from a suspicious folder location: C:\Users\* ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "[A-Z]{1}:\\Users\\" | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\Users.txt"
            }

            # Task Scheduler running from a suspicious folder location: C:\ProgramData\*
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "[A-Z]{1}:\\ProgramData\\" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running from a suspicious folder location: C:\ProgramData\* ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "[A-Z]{1}:\\ProgramData\\" | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\ProgramData.txt"
            }

            # Task Scheduler running from a suspicious folder location: C:\Windows\Temp\*
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "[A-Z]{1}:\\Windows\\Temp\\" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running from a suspicious folder location: C:\Windows\Temp\* ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "[A-Z]{1}:\\Windows\\Temp\\" | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\Temp.txt"
            }

            # Task Scheduler running from a suspicious folder location: C:\TMP\*
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\tasks.csv" -Delimiter "`t" | Where-Object {($_."Command Line" -match "[A-Z]{1}:\\TMP\\")}
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running from a suspicious folder location: C:\TMP\* ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\TMP.txt"
            }

            # b) Task Scheduler running using suspicious Scripting Utilities (False Positives: MEDIUM)

            # Task Scheduler running using suspicious Scripting Utility: cmd.exe
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "cmd" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: cmd.exe ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "cmd" | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\cmd.txt"
            }

            # Task Scheduler running using suspicious Scripting Utility: csript.exe
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "csript" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: csript.exe ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "csript" | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\csript.txt"
            }

            # Task Scheduler running using suspicious Scripting Utility: mshta.exe
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "mshta" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: mshta.exe ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "mshta" | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\mshta.txt"
            }

            # Task Scheduler running using suspicious Scripting Utility: powershell.exe
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "powershell" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: powershell.exe ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "powershell" | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\powershell.txt"
            }

            # Task Scheduler running using suspicious Scripting Utility: regsvr32.exe
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "regsvr32" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: regsvr32.exe ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "regsvr32" | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\regsvr32.txt"
            }

            # Task Scheduler running using suspicious Scripting Utility: rundll32.exe
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "rundll32" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: rundll32.exe ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "rundll32" | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\rundll32.txt"
            }

            # Task Scheduler running using suspicious Scripting Utility: wmic.exe
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "wmic" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: wmic.exe ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "wmic" | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\wmic.txt"
            }

            # Task Scheduler running using suspicious Scripting Utility: wscript.exe
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "wscript" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: wscript.exe ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "wscript" | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\wscript.txt"
            }

            # Parameters
            
            # Task Scheduler running malicious command line argument: sekurlsa::LogonPasswords --> OS Credential Dumping: LSASS Memory [T1003.001] --> mimikatz
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\tasks.csv" -Delimiter "`t" | Where-Object {($_.Parameters -match "sekurlsa::LogonPasswords")}
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running malicious command line argument: sekurlsa::LogonPasswords ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\sekurlsa_LogonPasswords.txt"
            }

            # Task Scheduler running suspicious command line argument: -WindowStyle Hidden
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\tasks.csv" -Delimiter "`t" | Where-Object {($_.Parameters -match "-WindowStyle Hidden")}
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running malicious command line argument: -WindowStyle Hidden ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\WindowStyle_Hidden.txt"
            }

            # Task Scheduler running suspicious command line argument: -nop
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\tasks.csv" -Delimiter "`t" | Where-Object {($_.Parameters -match "-nop")}
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running malicious command line argument: -nop ($Count)" -ForegroundColor Yellow
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\nop.txt"
            }

            # Custom

            # Task Scheduler running from a suspicious folder location executes an EXE: 'C:\Users\*\AppData\Roaming\*' + EXE
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "AppData\\Roaming" | Select-String -Pattern "\.exe" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Task Scheduler running from a suspicious folder location executes an EXE: 'C:\Users\*\AppData\Roaming\*' + EXE ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\tasks\tasks.txt" | Select-String -Pattern "AppData\\Roaming" | Select-String -Pattern "\.exe" | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\APPDATA-EXE.txt"
            }
        }

#############################################################################################################################################################################################

        # FS_Process_Handles
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Process_Handles
        New-Item "$OUTPUT_FOLDER\sys\handles" -ItemType Directory -Force | Out-Null
        
        # CSV
        if (Test-Path "$DriveLetter\forensic\json\general.json")
        {
            $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "handle" }

            $Data | Foreach-Object {

                $proc = $_ | Select-Object -ExpandProperty proc
                $procid = $_ | Select-Object -ExpandProperty pid
                $handle = $_ | Select-Object -ExpandProperty hex
                $obj = $_ | Select-Object -ExpandProperty obj
                $access = $_ | Select-Object -ExpandProperty hex2 -ErrorAction SilentlyContinue
                $type = $_ | Select-Object -ExpandProperty desc
                $desc = $_ | Select-Object -ExpandProperty desc2
            
                New-Object -TypeName PSObject -Property @{
                "Process" = $proc
                "PID" = $procid
                "Handle" = $handle
                "Object Address" = $obj
                "Access" = $access
                "Type" = $type
                "Details" = $desc
                }

            } | Select-Object "Process","PID","Handle","Object Address","Access","Type","Details" | Export-Csv -Path "$OUTPUT_FOLDER\sys\handles\handles.csv" -Delimiter "`t" -NoTypeInformation
        }

        # XLSX
        if (Get-Module -ListAvailable -Name ImportExcel)
        {
            if (Test-Path "$OUTPUT_FOLDER\sys\handles\handles.csv")
            {
                if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\handles\handles.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\handles\handles.csv" -Delimiter "`t"
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\handles\handles.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Handles" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-F
                    $WorkSheet.Cells["B:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

#############################################################################################################################################################################################

        # FS_Web (Web Browser History: Google Chrome, Microsoft Edge and Firefox)
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Web
        if (Test-Path "$DriveLetter\misc\web\web.txt")
        {
            New-Item "$OUTPUT_FOLDER\misc\web" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\misc\web\web.txt" -Destination "$OUTPUT_FOLDER\misc\web\web-draft.txt"
            Add-Content -Path "$OUTPUT_FOLDER\misc\web\web.txt" -Encoding utf8 -Value (Get-Content -Path "$OUTPUT_FOLDER\misc\web\web-draft.txt")
            Remove-Item -Path "$OUTPUT_FOLDER\misc\web\web-draft.txt" -Force

            # Count URL (w/ thousands separators)
            $Count = (Get-Content "$OUTPUT_FOLDER\misc\web\web.txt" | Measure-Object).Count -2
            $URL = '{0:N0}' -f $Count
            Write-Output "[Info]  Processing Web History Information (Records: $URL) ..."

            if ($Count -gt 0)
            {
                # CSV
                if (Test-Path "$DriveLetter\forensic\json\general.json")
                {
                    $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "web" }

                    $Data | Foreach-Object {

                        $index     = $_ | Select-Object -ExpandProperty i
                        $proc      = $_ | Select-Object -ExpandProperty proc
                        $procid    = $_ | Select-Object -ExpandProperty pid
                        $url       = $_ | Select-Object -ExpandProperty desc
                        $type      = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="type"; Expression={ForEach-Object{($_ -split "type:")[1]} | ForEach-Object{($_ -split "time:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                        $time      = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="time"; Expression={ForEach-Object{($_ -split "time:")[1]} | ForEach-Object{($_ -split "info:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                        $info      = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="info"; Expression={ForEach-Object{($_ -split "info:")[1]} | ForEach-Object{($_ -split "info:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}

                        New-Object -TypeName PSObject -Property @{
                        "Index"        = $index
                        "Process Name" = $proc
                        "PID"          = $procid
                        "URL"          = $url
                        "Type"         = $type.type
                        "Timestamp"    = $time.time
                        "Info"         = $info.info
                        }

                    } | Select-Object "Index","Timestamp","Process Name","PID","Type","URL","Info" | Export-Csv -Path "$OUTPUT_FOLDER\misc\web\web.csv" -Delimiter "," -NoTypeInformation -Encoding UTF8
                }

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\misc\web\web.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\misc\web\web.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\misc\web\web.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\misc\web\web.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Web History" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-E
                            $WorkSheet.Cells["A:E"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
        }

#############################################################################################################################################################################################

        # FS_BitLocker
        # https://github.com/ufrisk/MemProcFS/wiki/FS_BitLocker
        if (Test-Path "$DriveLetter\misc\bitlocker\*.fvek")
        {
            # Collection
            New-Item "$OUTPUT_FOLDER\misc\bitlocker" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\misc\bitlocker\*" -Destination "$OUTPUT_FOLDER\misc\bitlocker"

            # Count BitLocker Full Volume Encryption Key(s)
            $Count = (Get-ChildItem -Path "$OUTPUT_FOLDER\misc\bitlocker" -Filter "*.fvek" | Measure-Object).Count
            Write-Output "[Info]  $Count BitLocker Full Volume Encryption Key(s) found"
        }

#############################################################################################################################################################################################

        # Forensic Timeline
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_Timeline
        if (Test-Path "$OUTPUT_FOLDER\forensic\json\timeline.json")
        {
            Write-Output "[Info]  Creating Forensic Timeline ... "

            # CSV --> Timeline Explorer (TLE)
            New-Item "$OUTPUT_FOLDER\forensic\timeline\CSV" -ItemType Directory -Force | Out-Null
            Get-Content "$DriveLetter\forensic\json\timeline.json" | ConvertFrom-Json | Export-Csv -Path "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv" -Delimiter "," -NoTypeInformation

            # File Size (CSV)
            if (Test-Path "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv")
            {
                $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv").Length)
                Write-Output "[Info]  File Size (CSV): $Size"
            }

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel) 
            {
                if (Test-Path "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\forensic\timeline\XLSX" -ItemType Directory -Force | Out-Null

                        # Count rows of CSV (w/ thousands separators)
                        [int]$Count = & $xsv count "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv"
                        $Rows = '{0:N0}' -f $Count
                        Write-Output "[Info]  Total Lines (CSV): $Rows"

                        if ($Count -gt "1048576")
                        {
                            Write-Output "[Info]  ImportExcel: timeline.csv will be splitted ..."
                            & $xsv sort -R -s "date" "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv" --delimiter "," -o "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline-reverse.csv"
                            & $xsv split -s 1000000 "$OUTPUT_FOLDER\forensic\timeline\CSV" --filename "timeline-{}.csv" --delimiter "," "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline-reverse.csv"

                            [array]$Files = (Get-ChildItem -Path "$OUTPUT_FOLDER\forensic\timeline\CSV" | Where-Object {$_.Name -match "timeline-[0-9].*\.csv"}).FullName

                            ForEach( $File in $Files )
                            {
                                $FileName = $File | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.")[0]}
                                $IMPORT = Import-Csv "$File" -Delimiter "," | Select-Object @{Name='Timestamp [UTC]';Expression={([datetime]$_.date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='Type';Expression={$_.type}},@{Name='Action';Expression={$_.action}},@{Name='PID';Expression={$_.pid}},@{Name='Number';Expression={$_.num}},@{Name='Description';Expression={$_.desc}} | Sort-Object { $_."Timestamp [UTC]" -as [datetime] } -Descending
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\timeline\XLSX\$FileName.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Timeline" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A-E
                                $WorkSheet.Cells["A:E"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }
                        else
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv" -Delimiter "," | Select-Object @{Name='Timestamp [UTC]';Expression={([datetime]$_.date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='Type';Expression={$_.type}},@{Name='Action';Expression={$_.action}},@{Name='PID';Expression={$_.pid}},@{Name='Number';Expression={$_.num}},@{Name='Description';Expression={$_.desc}} | Sort-Object { $_."Timestamp [UTC]" -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\timeline\XLSX\timeline.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Timeline" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-E
                            $WorkSheet.Cells["A:E"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
        }

#############################################################################################################################################################################################
        
        Function Get-Prefetch {

        # Prefetch Files
        if (Test-Path "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv") 
        {
            Write-Output "[Info]  Extracting Prefetch File Information from Forensic Timeline ..."
            New-Item "$OUTPUT_FOLDER\Prefetch" -ItemType Directory -Force | Out-Null

            # CSV
            Import-Csv "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv" -Delimiter "," | Where-Object { $_.desc -match "\.pf$" } | Export-Csv "$OUTPUT_FOLDER\Prefetch\Prefetch.csv" -NoTypeInformation -Encoding UTF8

            # File Size (CSV)
            if (Test-Path "$OUTPUT_FOLDER\Prefetch\Prefetch.csv")
            {
                $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\Prefetch\Prefetch.csv").Length)
                Write-Output "[Info]  File Size (CSV): $Size"
            }

            # Count rows of CSV (w/ thousands separators)
            [int]$Count = & $xsv count "$OUTPUT_FOLDER\Prefetch\Prefetch.csv"
            $Rows = '{0:N0}' -f $Count
            Write-Output "[Info]  Total Lines (CSV): $Rows"

            # MOD - Last Write Time
            # CRE - Creation Time
            # RD  - Last Access Time

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel) 
            {
                if (Test-Path "$OUTPUT_FOLDER\Prefetch\Prefetch.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\Prefetch\Prefetch.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\Prefetch\Prefetch.csv" -Delimiter "," | Select-Object @{Name='Timestamp [UTC]';Expression={([datetime]$_.date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='Name';Expression={$_.desc | ForEach-Object{($_ -split "\\")[-1]} }},@{Name='Type';Expression={$_.type}},@{Name='Action';Expression={$_.action}},@{Name='File Path';Expression={$_.desc}} | Sort-Object { $_."Timestamp [UTC]" -as [datetime] } -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Prefetch\Prefetch.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Prefetch" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A and C-D
                        $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
        }

        }

        Get-Prefetch

#############################################################################################################################################################################################
        
        Function Get-EventLogs {

        # Windows XML Event Log (EVTX)
        if (Test-Path "$DriveLetter\name\svchost.exe-*\files\handles\*.evtx") 
        {
            Write-Output "[Info]  Collecting Windows Event Logs (EVTX) ... "
            New-Item "$OUTPUT_FOLDER\EventLogs\EventLogs" -ItemType Directory -Force | Out-Null
            Get-ChildItem -Recurse -Force "$DriveLetter\name\svchost.exe-*\files\handles\*.evtx" | Foreach-Object FullName | Out-File "$OUTPUT_FOLDER\EventLogs\EventLog-List.txt"
            Copy-Item -Recurse -Force "$DriveLetter\name\svchost.exe-*\files\handles\*.evtx" "$OUTPUT_FOLDER\EventLogs\EventLogs" 2>&1 | Out-Null

            # Rename Event Logs
            (Get-ChildItem "$OUTPUT_FOLDER\EventLogs\EventLogs") | Rename-Item -NewName { $_.Name.Substring(17) }

            # Count EVTX Files
            $Count = (Get-ChildItem -Path "$OUTPUT_FOLDER\EventLogs\EventLogs" -Filter "*.evtx" | Measure-Object).Count
            $InputSize = Get-FileSize((Get-ChildItem -Path "$OUTPUT_FOLDER\EventLogs\EventLogs" -Filter "*.evtx" | Measure-Object Length -Sum).Sum)
            Write-Output "[Info]  Processing $Count EVTX Files ($InputSize) ..."
        }

        }

        Get-EventLogs

#############################################################################################################################################################################################

        # EvtxECmd

        Function Update-EvtxECmd {

        # Internet Connectivity Check (Vista+)
        $NetworkListManager = [Activator]::CreateInstance([Type]::GetTypeFromCLSID([Guid]‘{DCB00C01-570F-4A9B-8D69-199FDBA5723B}’)).IsConnectedToInternet

        if (!($NetworkListManager -eq "True"))
        {
            Write-Host "[Error] Your computer is NOT connected to the Internet. Event Log Maps cannot be updated." -ForegroundColor Red
        }
        else
        {
            # Check if GitHub is reachable
            #$global:ProgressPreference = "SilentlyContinue"
            if (!(Test-NetConnection -ComputerName github.com -Port 443).TcpTestSucceeded)
            {
                Write-Host "[Error] github.com is NOT reachable. Event Log Maps cannot be updated." -ForegroundColor Red
            }
            else
            {
                Write-Output "[Info]  Updating Event Log Maps ... "

                # Flush
                if (Test-Path "$SCRIPT_DIR\Tools\EvtxECmd\Maps")
                {
                    Get-ChildItem -Path "$SCRIPT_DIR\Tools\EvtxECmd\Maps" -Recurse | Remove-Item -Force -Recurse
                }

                # Sync for EvtxECmd Maps with GitHub
                if (Test-Path "$EvtxECmd")
                {
                    & $EvtxECmd --sync > "$SCRIPT_DIR\Tools\EvtxECmd\Maps.log" 2> $null
                }
                else
                {
                    Write-Host "[Error] EvtxECmd.exe NOT found." -ForegroundColor Red
                }
            }
            #$global:ProgressPreference = "Continue"
        }

        }

        Update-EvtxECmd

        Function Invoke-EvtxECmd {

        # EvtxECmd --> Timeline Explorer
        if (Test-Path "$EvtxECmd")
        {
            $Count = (Get-ChildItem "$SCRIPT_DIR\Tools\EvtxECmd\Maps\*" -Include *.map | Measure-Object).Count
            Write-Output "[Info]  $Count Event Log Maps will be initiated by EvtxECmd ..."

            if (Test-Path "$OUTPUT_FOLDER\EventLogs\EventLogs\*.evtx") 
            {
                New-Item "$OUTPUT_FOLDER\EventLogs\EvtxECmd" -ItemType Directory -Force | Out-Null
                & $EvtxECmd -d "$OUTPUT_FOLDER\EventLogs\EventLogs" --csv "$OUTPUT_FOLDER\EventLogs\EvtxECmd" --csvf "EventLogs.csv" > "$OUTPUT_FOLDER\EventLogs\EvtxECmd\EvtxECmd.log" 2> $null

                # File Size (CSV)
                if (Test-Path "$OUTPUT_FOLDER\EventLogs\EvtxECmd\EventLogs.csv")
                {
                    $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\EventLogs\EvtxECmd\EventLogs.csv").Length)
                    Write-Output "[Info]  File Size (CSV): $Size"
                }

                # Windows Title (Default)
                $Host.UI.RawUI.WindowTitle = "MemProcFS-Analyzer v0.8 - Automated Forensic Analysis of Windows Memory Dumps for DFIR"
            }
        }
        else
        {
            Write-Host "[Error] EvtxECmd.exe NOT found." -ForegroundColor Red
        }

        }

        Invoke-EvtxECmd

#############################################################################################################################################################################################

        Function Update-ZircoliteRules {

        # Zircolite
        if (Test-Path "$Zircolite")
        {
            # Update
            Write-Output "[Info]  Updating SIGMA Rulesets ... "
            New-Item "$OUTPUT_FOLDER\EventLogs\Zircolite" -ItemType Directory -Force | Out-Null
            $MyLocation = $pwd
            Set-Location "$SCRIPT_DIR\Tools\Zircolite"
            & $Zircolite --update-rules 2>&1 | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Update-draft.txt"
            Set-Location "$MyLocation"

            # No newer rulesets found
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Update-draft.txt")
            {
                if (Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Update-draft.txt" | Select-String -Patter "No newer rulesets found" -Quiet)
                {
                    Write-Output "[Info]  No newer rulesets found"
                }
            }

            # Updated
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Update-draft.txt")
            {
                if (Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Update-draft.txt" | Select-String -Patter "Updated :" -Quiet)
                {
                    Write-Output "[Info]  SIGMA Rulesets updated."
                }
            }

            # Remove ANSI Control Characters
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Update-draft.txt")
            {
                Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Update-draft.txt" | ForEach-Object { $_ -replace "\x1b\[[0-9;]*m" } | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Update.txt"
                Remove-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Update-draft.txt"
            }

            # Remove empty lines and add line breaks where needed
            $Clean = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Update.txt" | ForEach-Object{($_ -replace "^   ","")} | Where-Object {$_.Trim()} | ForEach-Object {($_ -replace "Finished in", "`nFinished in")} | ForEach-Object {($_ -replace "Sysmon Linux =-", "Sysmon Linux =-`n")}
            @("") + ($Clean) | Set-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Update.txt"

            # Cleaning up
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Update.txt")
            {
                $Filter = @("^zircolite_win10\.exe","MemProcFS-Analyzer-v.*\.ps1","^\+","\+ CategoryInfo          : NotSpecified:","\+ FullyQualifiedErrorId : NativeCommandError","^tmp-rules-")
                $Clean = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Update.txt" | Select-String -Pattern $Filter -NotMatch 
                $Clean | Set-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Update.txt"
            }

            # zircolite.log
            if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\zircolite.log")
            {
                Remove-Item -Path "$SCRIPT_DIR\Tools\Zircolite\zircolite.log" -Force
            }
        }

        }

        Update-ZircoliteRules

#############################################################################################################################################################################################

        Function Invoke-Zircolite {

        # Zircolite
        if (Test-Path "$Zircolite")
        {
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\EventLogs\*.evtx") 
            {
                Write-Output "[Info]  Processing Windows Event Logs w/ Zircolite ... "

                $StartTime_Zircolite = (Get-Date)

                # Check if InputSize is greater than 500 MB
                $Bytes = ((Get-ChildItem -Path "$OUTPUT_FOLDER\EventLogs\EventLogs" -Filter "*.evtx" | Measure-Object Length -Sum).Sum)

                if ($Bytes -gt 524288000)
                {
                    # JSON
                    New-Item "$OUTPUT_FOLDER\EventLogs" -ItemType Directory -Force | Out-Null
                    $ScanPath = "$OUTPUT_FOLDER\EventLogs\EventLogs"
                    $Ruleset = "rules\rules_windows_generic_full.json"
                    $TempDir = "$OUTPUT_FOLDER\EventLogs\JSONL"
                    $MyLocation = $pwd
                    Set-Location "$SCRIPT_DIR\Tools\Zircolite"
                    & $Zircolite --evtx $ScanPath --ruleset $Ruleset --noexternal --tmpdir $TempDir --keeptmp 2>&1 | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite-draft.txt"
                    Set-Location "$MyLocation"
                }
                else
                {
                    $MyLocation = $pwd
                    Set-Location "$SCRIPT_DIR\Tools\Zircolite"

                    # JSON + Mini-GUI
                    Write-Output "[Info]  Creating JSON output and ZircoGui package ..."
                    New-Item "$OUTPUT_FOLDER\EventLogs" -ItemType Directory -Force | Out-Null
                    $ScanPath = "$OUTPUT_FOLDER\EventLogs\EventLogs"
                    $Ruleset = "rules\rules_windows_generic_full.json"
                    $TempDir = "$OUTPUT_FOLDER\EventLogs\JSONL"
                    & $Zircolite --evtx $ScanPath --ruleset $Ruleset --noexternal --package --tmpdir $TempDir --keeptmp 2>&1 | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite-draft.txt"

                    # Remove ANSI Control Characters
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite-draft.txt")
                    {
                        Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite-draft.txt" | ForEach-Object { $_ -replace "\x1b\[[0-9;]*m" } | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt"
                        Remove-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite-draft.txt"
                    }

                    # Remove empty lines and add line breaks where needed
                    $Clean = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Where-Object {$_.Trim()} | ForEach-Object {($_ -replace "Finished in", "`nFinished in")} | ForEach-Object {($_ -replace "Sysmon Linux =-", "Sysmon Linux =-`n")}
                    @("") + ($Clean) | Set-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt"

                    # Cleaning up
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt")
                    {
                        $Filter = @("^zircolite_win10\.exe","MemProcFS-Analyzer-v.*\.ps1","^\+","\+ CategoryInfo          : NotSpecified:","\+ FullyQualifiedErrorId : NativeCommandError","%\|","^tmp-rules-")
                        $Clean = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern $Filter -NotMatch 
                        $Clean | Set-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt"
                    }

                    # Executed Ruleset
                    Start-Sleep 3
                    if (Test-Path "$pwd\zircolite.log")
                    {
                        [int]$Count = Get-Content "$pwd\zircolite.log" | Select-String -Pattern "Executing ruleset" | Select-Object -First 1 | ForEach-Object{($_ -split "\s+")[-2]}
                        $Rules = '{0:N0}' -f $Count
                        Write-Output "[Info]  Executed ruleset - $Rules rules"
                    }

                    # zircolite.log
                    if (Test-Path "$pwd\zircolite.log")
                    {
                        Remove-Item -Path "$pwd\zircolite.log" -Force
                    }

                    # JSON
                    if (Test-Path "$pwd\detected_events.json")
                    {
                        New-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON" -ItemType Directory -Force | Out-Null
                        Move-Item -Path "$pwd\detected_events.json" -Destination "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON\detected_events.json"
                    }

                    # File Size (JSON)
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON\detected_events.json")
                    {
                        $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON\detected_events.json").Length)
                        Write-Output "[Info]  File Size (JSON): $Size"
                    }

                    # ZircoGui
                    if (Test-Path "$pwd\zircogui-output-*.zip")
                    {
                        New-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Package" -ItemType Directory -Force | Out-Null
                        New-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Mini-GUI" -ItemType Directory -Force | Out-Null
                        Move-Item -Path "$pwd\zircogui-output-*.zip" -Destination "$OUTPUT_FOLDER\EventLogs\Zircolite\Package"

                        # Unzip ZircoGui Package
                        if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Package\zircogui-output-*.zip")
                        {
                            Expand-Archive "$OUTPUT_FOLDER\EventLogs\Zircolite\Package\zircogui-output-*.zip" -DestinationPath "$OUTPUT_FOLDER\EventLogs\Zircolite\Mini-GUI"
                        }

                        # Open ZircoGui
                        if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Mini-GUI\index.html")
                        {
                            # Check if Google Chrome is installed
                            if (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe")
                            {
                                # Open ZircoGui w/ Google Chrome
                                $Chrome = ((Get-Item (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe")."(Default)").VersionInfo).FileName
                                Start-Process -FilePath $Chrome -ArgumentList "--start-fullscreen $OUTPUT_FOLDER\EventLogs\Zircolite\Mini-GUI\index.html"
                            }
                            else
                            {
                                # Open ZircoGui in your Default Browser
                                Start-Process "$OUTPUT_FOLDER\EventLogs\Zircolite\Mini-GUI\index.html"
                            }
                        }
                    }

                    Set-Location "$MyLocation"

                    # Stats
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt")
                    {
                        if (Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " -Quiet)
                        {
                            # Count triggered Sigma Rules
                            $Rules = (Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Measure-Object).Count

                            if ($Rules -gt 0)
                            {
                                # Count Events (w/ thousands separators)
                                [int]$Count = (Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | ForEach-Object{($_ -split "\s+")[-2]} | Measure-Object -Sum).Sum
                                $Events = '{0:N0}' -f $Count

                                Write-Host "[Alert] $Rules Detection(s) found ($Events events)" -ForegroundColor Red

                                # Sort A-Z
                                Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | ForEach-Object{($_ -replace "    - ","")} | Sort-Object | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections.txt"

                                # SIGMA Rule Level (critical, high, medium, low)

                                # Critical
                                $Critical = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Select-String -Pattern "\[critical\]" | ForEach-Object{($_ -replace "    - ","        ")} | Sort-Object
                                $CriticalAlerts = ($Critical | Measure-Object).Count
                                if ($CriticalAlerts -gt 0)
                                { 
                                    $Critical.Trim() | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections-Critical.txt" 
                                }

                                # High
                                $High = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Select-String -Pattern "\[high\]" | ForEach-Object{($_ -replace "    - ","        ")} | Sort-Object
                                $HighAlerts = ($High | Measure-Object).Count
                                if ($HighAlerts -gt 0)
                                { 
                                    $High.Trim() | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections-High.txt"
                                }

                                # Medium
                                $Medium = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Select-String -Pattern "\[medium\]" | ForEach-Object{($_ -replace "    - ","        ")} | Sort-Object
                                $MediumAlerts = ($Medium | Measure-Object).Count
                                if ($MediumAlerts -gt 0)
                                { 
                                    $Medium.Trim() | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections-Medium.txt"
                                }

                                # Low
                                $Low = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Select-String -Pattern "\[low\]" | ForEach-Object{($_ -replace "    - ","        ")} | Sort-Object
                                $LowAlerts = ($Low | Measure-Object).Count
                                if ($LowAlerts -gt 0)
                                { 
                                    $Low.Trim() | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections-Low.txt"
                                }
                            
                                # Informational
                                $Informational = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Select-String -Pattern "\[informational\]" | ForEach-Object{($_ -replace "    - ","        ")} | Sort-Object
                                $InformationalAlerts = ($Informational | Measure-Object).Count
                                if ($InformationalAlerts -gt 0)
                                { 
                                    $Informational.Trim() | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections-Informational.txt"
                                }
                
                                # Unknown
                                $Unknown = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Select-String -Pattern "\[unknown\]" | ForEach-Object{($_ -replace "    - ","        ")} | Sort-Object
                                $UnknownAlerts = ($Unknown | Measure-Object).Count
                                if ($UnknownAlerts -gt 0)
                                { 
                                    $Unknown.Trim() | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections-Unknown.txt"
                                }

                                # Stats (Alerts by Sigma Rules Level)
                                Write-Output "$Rules Alerts ($Events events)" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt"
                                Write-Output "" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "Alerts by Sigma Rule Level" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "Critical: $CriticalAlerts" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "High:     $HighAlerts" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "Medium:   $MediumAlerts" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "Low:      $LowAlerts" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "Info:     $InformationalAlerts" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "Unknown:  $UnknownAlerts" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                
                                $Critical | Write-Host -ForegroundColor Red
                                $High | Write-Host -ForegroundColor Yellow
                                $Medium | Write-Host -ForegroundColor DarkCyan
                                $Low | Write-Host -ForegroundColor DarkGreen
                                $Informational | Write-Host -ForegroundColor Gray
                            }
                        }
                        else
                        {
                            Write-Host "[Info]  0 Detections found"
                        }
                    }
                }
            }
        }
        else
        {
            Write-Host "[Error] zircolite_win10.exe NOT found." -ForegroundColor Red
        }

        # Results
        if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON\detected_events.json")
        {
            if((Get-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON\detected_events.json").length -gt 1kb)
            {
                # Import JSON Data
                $Data = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON\detected_events.json" | ConvertFrom-Json

                # Alerts by Sigma Rules Level
                $Events = ($Data | Select-Object count | Measure-Object Count -Sum).Sum
                $Critical = ($Data | Where-Object { $_.rule_level -eq "critical" } | Select-Object count | Measure-Object Count -Sum).Sum
                $High = ($Data | Where-Object { $_.rule_level -eq "high" } | Select-Object count | Measure-Object Count -Sum).Sum
                $Medium = ($Data | Where-Object { $_.rule_level -eq "medium" } | Select-Object count | Measure-Object Count -Sum).Sum
                $Low = ($Data | Where-Object { $_.rule_level -eq "low" } | Select-Object count | Measure-Object Count -Sum).Sum
                $Informational = ($Data | Where-Object { $_.rule_level -eq "informational" } | Select-Object count | Measure-Object Count -Sum).Sum
                $Unknown = ($Data | Where-Object { $_.rule_level -eq "unknown" } | Select-Object count | Measure-Object Count -Sum).Sum

                # Array
                $Array = @()

                # Critical
                if ($Critical)
                {
                    $Array += @{Level = "Critical"; Description = "Highly relevant event that indicates an incident. Critical events should be reviewed immediately."; Count = "$Critical"}
                }
                else
                {
                    $Array += @{Level = "Critical"; Description = "Highly relevant event that indicates an incident. Critical events should be reviewed immediately."; Count = "0"}
                }

                # High
                if ($High)
                {
                    $Array += @{Level = "High"; Description = "Relevant event that should trigger an internal alert and requires a prompt review."; Count = "$High"}
                }
                else
                {
                    $Array += @{Level = "High"; Description = "Relevant event that should trigger an internal alert and requires a prompt review."; Count = "0"}
                }

                # Medium
                if ($Medium)
                {
                    $Array += @{Level = "Medium"; Description = "Relevant event that should be reviewed manually on a more frequent basis."; Count = "$Medium"}
                }
                else
                {
                    $Array += @{Level = "Medium"; Description = "Relevant event that should be reviewed manually on a more frequent basis."; Count = "0"}
                }

                # Low
                if ($Low)
                {
                    $Array += @{Level = "Low"; Description = "Notable event but rarely an incident. Low rated events can be relevant in high numbers or combination with others. Immediate reaction shouldn't be necessary, but a regular review is recommended."; Count = "$Low"}
                }
                else
                {
                    $Array += @{Level = "Low"; Description = "Notable event but rarely an incident. Low rated events can be relevant in high numbers or combination with others. Immediate reaction shouldn't be necessary, but a regular review is recommended."; Count = "0"}
                }

                # Informational
                if ($Informational)
                {
                    $Array += @{Level = "Informational"; Description = "Rule is intended for enrichment of events, e.g. by tagging them. No case or alerting should be triggered by such rules because it is expected that a huge amount of events will match these rules."; Count = "$Informational"}
                }
                else
                {
                    $Array += @{Level = "Informational"; Description = "Rule is intended for enrichment of events, e.g. by tagging them. No case or alerting should be triggered by such rules because it is expected that a huge amount of events will match these rules."; Count = "0"}
                }

                # Unknown
                if ($Unknown)
                {
                    $Array += @{Level = "Unknown"; Description = "Unknown"; Count = "$Unknown"}
                }
                else
                {
                    $Array += @{Level = "Unknown"; Description = "Unknown"; Count = "0"}
                }

                # CSV
                $Array | ForEach-Object { New-Object PSObject -Property $_ } |  Export-Csv "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Sigma-Rule-Level.csv" -NoTypeInformation

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Sigma-Rule-Level.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Sigma-Rule-Level.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Sigma-Rule-Level.csv" -Delimiter "," | Sort-Object { $_.FileKeyLastWriteTimestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Sigma-Rule-Level.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "SIGMA Rule Level" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:C1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A and C
                            $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }

                # Alerts by MITRE ATT&CK Tactics
                # https://attack.mitre.org/tactics/enterprise/

                # Array
                $Array = @()

                # Reconnaissance - The adversary is trying to gather information they can use to plan future operations [TA0043]
                $Reconnaissance = ($Data | Where-Object { $_.tags -like "attack.reconnaissance" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Reconnaissance)
                {
                    $Array += @{ID = "TA0043"; Name = "Reconnaissance"; Description = "The adversary is trying to gather information they can use to plan future operations."; Count = "$Reconnaissance"}
                }
                else
                {
                    $Array += @{ID = "TA0043"; Name = "Reconnaissance"; Description = "The adversary is trying to gather information they can use to plan future operations."; Count = "0"}
                }

                # Resource Development - The adversary is trying to establish resources they can use to support operations [TA0042]
                $ResourceDevelopment = ($Data | Where-Object { $_.tags -like "attack.resource_development" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($ResourceDevelopment)
                {
                    $Array += @{ID = "TA0042"; Name = "Resource Development"; Description = "The adversary is trying to establish resources they can use to support operations."; Count = "$ResourceDevelopment"}
                }
                else
                {
                    $Array += @{ID = "TA0042"; Name = "Resource Development"; Description = "The adversary is trying to establish resources they can use to support operations."; Count = "0"}
                }

                # Initial Access - The adversary is trying to get into your network [TA0001]
                $InitialAccess = ($Data | Where-Object { $_.tags -like "attack.initial_access" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($InitialAccess)
                {
                    $Array += @{ID = "TA0001"; Name = "Initial Access"; Description = "The adversary is trying to get into your network."; Count = "$InitialAccess"}
                }
                else
                {
                    $Array += @{ID = "TA0001"; Name = "Initial Access"; Description = "The adversary is trying to get into your network."; Count = "0"}
                }

                # Execution - The adversary is trying to run malicious code [TA0002]
                $Execution = ($Data | Where-Object { $_.tags -like "attack.execution" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Execution)
                {
                    $Array += @{ID = "TA0002"; Name = "Execution"; Description = "The adversary is trying to run malicious code."; Count = "$Execution"}
                }
                else
                {
                    $Array += @{ID = "TA0002"; Name = "Execution"; Description = "The adversary is trying to run malicious code."; Count = "0"}
                }

                # Persistence - The adversary is trying to maintain their foothold [TA0003]
                $Persistence = ($Data | Where-Object { $_.tags -like "attack.persistence" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Persistence)
                {
                    $Array += @{ID = "TA0003"; Name = "Persistence"; Description = "The adversary is trying to maintain their foothold."; Count = "$Persistence"}
                }
                else
                {
                    $Array += @{ID = "TA0003"; Name = "Persistence"; Description = "The adversary is trying to maintain their foothold."; Count = "0"}
                }

                # Privilege Escalation - The adversary is trying to gain higher-level permissions [TA0004]
                $PrivilegeEscalation = ($Data | Where-Object { $_.tags -like "attack.privilege_escalation" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($PrivilegeEscalation)
                {
                    $Array += @{ID = "TA0004"; Name = "Privilege Escalation"; Description = "The adversary is trying to gain higher-level permissions."; Count = "$PrivilegeEscalation"}
                }
                else
                {
                    $Array += @{ID = "TA0004"; Name = "Privilege Escalation"; Description = "The adversary is trying to gain higher-level permissions."; Count = "0"}
                }

                # Defense Evasion - The adversary is trying to avoid being detected [TA0005]
                $DefenseEvasion = ($Data | Where-Object { $_.tags -like "attack.defense_evasion" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($DefenseEvasion)
                {
                    $Array += @{ID = "TA0005"; Name = "Defense Evasion"; Description = "The adversary is trying to avoid being detected."; Count = "$DefenseEvasion"}
                }
                else
                {
                    $Array += @{ID = "TA0005"; Name = "Defense Evasion"; Description = "The adversary is trying to avoid being detected."; Count = "0"}
                }

                # Credential Access - The adversary is trying to steal account names and passwords [TA0006]
                $CredentialAccess = ($Data | Where-Object { $_.tags -like "attack.credential_access" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($CredentialAccess)
                {
                    $Array += @{ID = "TA0006"; Name = "Credential Access"; Description = "The adversary is trying to steal account names and passwords."; Count = "$CredentialAccess"}
                }
                else
                {
                    $Array += @{ID = "TA0006"; Name = "Credential Access"; Description = "The adversary is trying to steal account names and passwords."; Count = "0"}
                }

                # Discovery - The adversary is trying to figure out your environment [TA0007]
                $Discovery = ($Data | Where-Object { $_.tags -like "attack.discovery" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Discovery)
                {
                    $Array += @{ID = "TA0007"; Name = "Discovery"; Description = "The adversary is trying to figure out your environment."; Count = "$Discovery"}
                }
                else
                {
                    $Array += @{ID = "TA0007"; Name = "Discovery"; Description = "The adversary is trying to figure out your environment."; Count = "0"}
                }

                # Lateral Movement - The adversary is trying to move through your environment [TA0008]
                $LateralMovement = ($Data | Where-Object { $_.tags -like "attack.lateral_movement" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($LateralMovement)
                {
                    $Array += @{ID = "TA0008"; Name = "Lateral Movement"; Description = "The adversary is trying to move through your environment."; Count = "$LateralMovement"}
                }
                else
                {
                    $Array += @{ID = "TA0008"; Name = "Lateral Movement"; Description = "The adversary is trying to move through your environment."; Count = "0"}
                }

                # Collection - The adversary is trying to gather data of interest to their goal [TA0009]
                $Collection = ($Data | Where-Object { $_.tags -like "attack.collection" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Collection)
                {
                    $Array += @{ID = "TA0009"; Name = "Collection"; Description = "The adversary is trying to gather data of interest to their goal."; Count = "$Collection"}
                }
                else
                {
                    $Array += @{ID = "TA0009"; Name = "Collection"; Description = "The adversary is trying to gather data of interest to their goal."; Count = "0"}
                }

                # Command and Control - The adversary is trying to communicate with compromised systems to control them [TA0011]
                $CommandAndControl = ($Data | Where-Object { $_.tags -like "attack.commandandcontrol" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($CommandAndControl)
                {
                    $Array += @{ID = "TA0011"; Name = "Command and Control"; Description = "The adversary is trying to communicate with compromised systems to control them."; Count = "$CommandAndControl"}
                }
                else
                {
                    $Array += @{ID = "TA0011"; Name = "Command and Control"; Description = "The adversary is trying to communicate with compromised systems to control them."; Count = "0"}
                }

                # Exfiltration - The adversary is trying to steal data [TA0010]
                $Exfiltration = ($Data | Where-Object { $_.tags -like "attack.exfiltration" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Exfiltration)
                {
                    $Array += @{ID = "TA0010"; Name = "Exfiltration"; Description = "The adversary is trying to steal data."; Count = "$Exfiltration"}
                }
                else
                {
                    $Array += @{ID = "TA0010"; Name = "Exfiltration"; Description = "The adversary is trying to steal data."; Count = "0"}
                }

                # Impact - The adversary is trying to manipulate, interrupt, or destroy your systems and data [TA0040]
                $Impact = ($Data | Where-Object { $_.tags -like "attack.impact" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Impact)
                {
                    $Array += @{ID = "TA0040"; Name = "Impact"; Description = "The adversary is trying to manipulate, interrupt, or destroy your systems and data."; Count = "$Impact"}
                }
                else
                {
                    $Array += @{ID = "TA0040"; Name = "Impact"; Description = "The adversary is trying to manipulate, interrupt, or destroy your systems and data."; Count = "0"}
                }

                # Uncategorized
                $Uncategorized = ($Data | Where-Object { $_.tags -like "attack.uncategorized" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Uncategorized)
                {
                    $Array += @{ID = "Uncategorized"; Name = "Uncategorized"; Description = "Uncategorized"; Count = "$Uncategorized"}
                }
                else
                {
                    $Array += @{ID = "Uncategorized"; Name = "Uncategorized"; Description = "Uncategorized"; Count = "0"}
                }

                # CSV
                $Array | ForEach-Object { New-Object PSObject -Property $_ } |  Export-Csv "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Tactics.csv" -NoTypeInformation

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Tactics.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Tactics.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Tactics.csv" -Delimiter "," | Sort-Object { $_.FileKeyLastWriteTimestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Tactics.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "MITRE ATT&CK Tactics" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of column D
                            $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }

                # Alerts by Channel

                # CSV
                ($Data | Select-Object matches).matches | Group-Object Channel | Select-Object Name, Count | Sort-Object Name | Export-Csv "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Channel.csv" -NoTypeInformation

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Channel.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Channel.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Channel.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Channel.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Alerts by Channel" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:B1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of column B
                            $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }

        $EndTime_Zircolite = (Get-Date)
        $Time_Zircolite = ($EndTime_Zircolite-$StartTime_Zircolite)
        ('Zircolite Processing duration: {0} h {1} min {2} sec' -f $Time_Zircolite.Hours, $Time_Zircolite.Minutes, $Time_Zircolite.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

        }

        }

        Invoke-Zircolite

#############################################################################################################################################################################################

        Function Get-EventLogOverview {

        # Event Log Overview
        if (Test-Path "$OUTPUT_FOLDER\EventLogs\JSONL\*.json")
        {
            Write-Output "[Info]  Parsing Event Record Information from JSON Files ..."
            $EventLogs = (Get-ChildItem -Path "$OUTPUT_FOLDER\EventLogs\JSONL" -Filter "*.json").FullName

            $StartTime_EventLogOverview = (Get-Date)

            $EventArray = @()
            ForEach($EventLog in $EventLogs)
            {
                $LogName = $EventLog | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.evtx-")[0]}
                [int64]$LogSize = (Get-Item -Path $EventLog).Length
                $Row = New-Object PSObject
                $Row | Add-Member -Name Name -MemberType NoteProperty -Value ("$LogName" + ".evtx")
                $Row | Add-Member -Name RecordCount -MemberType NoteProperty -Value ((& $jq -c '.Event.System.EventID' $EventLog | Measure-Object).Count)
                if ($LogSize -ne "0")
                {
                    $Row | Add-Member -Name "Oldest [UTC]" -MemberType NoteProperty -Value (& $jq -r '.Event.System.TimeCreated | .[]?.SystemTime' $EventLog | Sort-Object | Select-Object -First 1 | ForEach-Object{($_ -replace "T"," ")} | ForEach-Object{($_ -split "\.")[0]})
                    $Row | Add-Member -Name "Newest [UTC]" -MemberType NoteProperty -Value (& $jq -r '.Event.System.TimeCreated | .[]?.SystemTime' $EventLog | Sort-Object | Select-Object -Last 1 | ForEach-Object{($_ -replace "T"," ")} | ForEach-Object{($_ -split "\.")[0]})
                    $Row | Add-Member -Name Bytes -MemberType NoteProperty -Value ((Get-Item -Path $EventLog).Length)
                    $Row | Add-Member -Name FileSize -MemberType NoteProperty -Value (Get-FileSize (Get-Item -Path $EventLog).Length)
                }
                else
                {
                    $Row | Add-Member -Name Bytes -MemberType NoteProperty -Value ("0")
                    $Row | Add-Member -Name FileSize -MemberType NoteProperty -Value ("0")
                }
                $Row | Add-Member -Name FilePath -MemberType NoteProperty -Value ($EventLog)
                $EventArray  += $Row
            }

            # EventLogOverview.csv
            $EventArray  | Export-Csv "$OUTPUT_FOLDER\EventLogs\EventLogOverview.csv" -NoTypeInformation

            # EventLogOverview.xlsx
            if (Get-Module -ListAvailable -Name ImportExcel) 
            {
                if (Test-Path "$OUTPUT_FOLDER\EventLogs\EventLogOverview.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\EventLogs\EventLogOverview.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\EventLogs\EventLogOverview.csv" -Delimiter ","
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\EventLogs\EventLogOverview.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "EventLogOverview" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-D
                        $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                        # HorizontalAlignment "Right" of columns E-F
                        $WorkSheet.Cells["E:F"].Style.HorizontalAlignment="Right"
                        # HorizontalAlignment "Center" of header of columns E-F
                        $WorkSheet.Cells["E1:F1"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }

        $EndTime_EventLogOverview = (Get-Date)
        $Time_EventLogOverview = ($EndTime_EventLogOverview-$StartTime_EventLogOverview)
        ('EventLogOverview duration:     {0} h {1} min {2} sec' -f $Time_EventLogOverview.Hours, $Time_EventLogOverview.Minutes, $Time_EventLogOverview.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

        }

        }

        Get-EventLogOverview

#############################################################################################################################################################################################

        Function Get-Timesketch {

        # Timesketch
        if (Test-Path "$Zircolite")
        {
            Write-Output "[Info]  Creating Timesketch output ..."
            New-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch" -ItemType Directory -Force | Out-Null

            $script:MyLocation = $pwd
            Set-Location "$SCRIPT_DIR\Tools\Zircolite"

            $StartTime_Timesketch = (Get-Date)

            # Zircolite
            $Ruleset = "rules\rules_windows_generic_full.json"
            $Template = "templates\exportForTimesketch.tmpl"
            $TemplateOutput = "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Timesketch_MemProcFS-Analyzer.csv"
            $OutFile = "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\detected_events.json"
            $LogFile = "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\zircolite.log"

            # Check if JSONL Files already exist
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\JSONL\*.json")
            {
                # JSONL
                $ScanPath = "$OUTPUT_FOLDER\EventLogs\JSONL"
                & $Zircolite --evtx $ScanPath --ruleset $Ruleset --jsononly --template $Template --templateOutput $TemplateOutput --outfile $OutFile --logfile $LogFile 2>&1 | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite-draft.txt"
            }
            else
            {
                # EVTX
                $ScanPath = "$OUTPUT_FOLDER\EventLogs\EventLogs"
                & $Zircolite --evtx $ScanPath --ruleset $Ruleset --noexternal --template $Template --templateOutput $TemplateOutput --outfile $OutFile --logfile $LogFile 2>&1 | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite-draft.txt"
            }
            
            Set-Location "$MyLocation"

            # zircolite.log
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\zircolite.log")
            {
                Remove-Item -Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\zircolite.log" -Force
            }

            # Remove ANSI Control Characters
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite-draft.txt")
            {
                Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite-draft.txt" | ForEach-Object { $_ -replace "\x1b\[[0-9;]*m" } | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt"
                Remove-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite-draft.txt"
            }

            # Cleaning up
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt")
            {
                $Filter = @("^zircolite_win10\.exe","MemProcFS-Analyzer-v0.*\.ps1","^\+","\+ CategoryInfo          : NotSpecified:","\+ FullyQualifiedErrorId : NativeCommandError","%\|")
                $Clean = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt" | Select-String -Pattern $Filter -NotMatch 
                $Clean | Set-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt"
            }

            # Remove empty lines and add line breaks where needed
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt")
            {
                $Clean = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt" | Where-Object {$_.Trim()} | ForEach-Object {($_ -replace "Finished in", "`nFinished in")} | ForEach-Object {($_ -replace "Sysmon Linux =-", "Sysmon Linux =-`n")}
                @("") + ($Clean) | Set-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt"
            }

            # File Size (CSV)
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Timesketch_MemProcFS-Analyzer.csv")
            {
                $FileSize = Get-FileSize((Get-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Timesketch_MemProcFS-Analyzer.csv").Length)
                Write-Output "[Info]  File Size (CSV): $FileSize"
            }

            $EndTime_Timesketch = (Get-Date)
            $Time_Timesketch = ($EndTime_Timesketch-$StartTime_Timesketch)
            ('Timesketch Output duration:    {0} h {1} min {2} sec' -f $Time_Timesketch.Hours, $Time_Timesketch.Minutes, $Time_Timesketch.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"
        }
        else
        {
            Write-Host "[Error] zircolite_win10.exe NOT found." -ForegroundColor Red
        }

        }

        #Get-Timesketch

#############################################################################################################################################################################################
        
        Function Get-RegistryHives {

        # Registry Hives
        if (Test-Path "$DriveLetter\registry\hive_files\*.reghive") 
        {
            Write-Output "[Info]  Collecting Registry Hives ... "
            New-Item "$OUTPUT_FOLDER\Registry\Registry" -ItemType Directory -Force 2>&1 | Out-Null
            Get-ChildItem "$DriveLetter\registry\hive_files\*.reghive" -Exclude "*ActivationStoredat*","*settingsdat*" | Foreach-Object FullName | Out-File "$OUTPUT_FOLDER\Registry\Hives.txt"
            Copy-Item "$DriveLetter\registry\hive_files\*.reghive" -Exclude "*ActivationStoredat*","*settingsdat*" "$OUTPUT_FOLDER\Registry\Registry" 2>&1 | Out-Null
        }

        # Count Registry Hives
        $Count = (Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\Registry" | Measure-Object).Count
        $InputSize = Get-FileSize((Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\Registry" | Measure-Object Length -Sum).Sum)
        Write-Output "[Info]  $Count Registry Hives ($InputSize) found"

        }

        Get-RegistryHives

#############################################################################################################################################################################################
        
        Function Get-Amcache {

        # AmcacheParser
        if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*Amcache*.reghive") 
        {
            if (Test-Path "$AmcacheParser")
            {
                Write-Output "[Info]  Analyzing Amcache Hive ... "

                # Collecting Amcache.hve
                New-Item "$OUTPUT_FOLDER\Amcache\Amcache" -ItemType Directory -Force 2>&1 | Out-Null
                Copy-Item "$DriveLetter\registry\hive_files\0x*Amcachehve-*.reghive" "$OUTPUT_FOLDER\Amcache\Amcache\Amcache.hve"
                
                # CSV
                New-Item "$OUTPUT_FOLDER\Amcache\CSV" -ItemType Directory -Force | Out-Null
                $AmcacheHive = "$OUTPUT_FOLDER\Amcache\Amcache\Amcache.hve"
                & $AmcacheParser -f "$AmcacheHive" -i --csv "$OUTPUT_FOLDER\Amcache\CSV" --csvf AmcacheParser.csv > "$OUTPUT_FOLDER\Amcache\AmcacheParser.log" 2> $null

                # Stats
                if (Test-Path "$OUTPUT_FOLDER\Amcache\AmcacheParser.log")
                {
                    $Total = Get-Content "$OUTPUT_FOLDER\Amcache\AmcacheParser.log" | Select-String -Pattern "unassociated file entries"
                    if ($Total) 
                    { 
                        Write-Output "[Info]  $Total"
                    }
                    else
                    {
                        Write-Output "[Info]  Amcache Hive seems to be partially corrupt."
                    }
                }

                # XLSX
                # Note: The output of Windows 10 and Win 7 looks different --> optimized for Windows 10 only
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    # AssociatedFileEntries
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_AssociatedFileEntries.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_AssociatedFileEntries.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_AssociatedFileEntries.csv" -Delimiter "," | Sort-Object { $_.FileKeyLastWriteTimestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_AssociatedFileEntries.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "AssociatedFileEntries" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:U1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-E and G-U
                            $WorkSheet.Cells["A:E"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["G:U"].Style.HorizontalAlignment="Center"
                            # HorizontalAlignment "Center" of header of column F
                            $WorkSheet.Cells["F1:F1"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # DeviceContainers
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DeviceContainers.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DeviceContainers.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DeviceContainers.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_DeviceContainers.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DeviceContainers" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:Q1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-Q
                            $WorkSheet.Cells["B:Q"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # DevicePnps
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DevicePnps.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DevicePnps.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DevicePnps.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_DevicePnps.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DevicePnps" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:Y1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-E and G-Y
                            $WorkSheet.Cells["B:E"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["G:Y"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # DriveBinaries
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DriveBinaries.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DriveBinaries.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DriveBinaries.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_DriveBinaries.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DriveBinaries" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:T1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-T
                            $WorkSheet.Cells["B:T"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # DriverPackages
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DriverPackages.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DriverPackages.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DriverPackages.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_DriverPackages.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DriverPackages" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:L1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-D and -L
                            $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["F:L"].Style.HorizontalAlignment="Center"
                            # HorizontalAlignment "Center" of header of column E
                            $WorkSheet.Cells["E1:E1"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # ProgramEntries
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_ProgramEntries.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_ProgramEntries.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_ProgramEntries.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_ProgramEntries.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "ProgramEntries" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:Z1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-J, L-N, P-S, V-X and Z
                            $WorkSheet.Cells["A:J"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["L:N"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["P:S"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["V:X"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["Z:Z"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # ShortCuts
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_ShortCuts.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_ShortCuts.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_ShortCuts.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_ShortCuts.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "ShortCuts" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:C1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A and C
                            $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # UnassociatedFileEntries
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_UnassociatedFileEntries.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_UnassociatedFileEntries.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_UnassociatedFileEntries.csv" -Delimiter "," -Encoding UTF8 | Sort-Object { $_.FileKeyLastWriteTimestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_UnassociatedFileEntries.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "UnassociatedFileEntries" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:U1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-E and G-T
                            $WorkSheet.Cells["A:E"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["G:T"].Style.HorizontalAlignment="Center"
                            # HorizontalAlignment "Center" of header of column F
                            $WorkSheet.Cells["F1:F1"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
                else
                {
                    Write-Output "[Info]  PowerShell module 'ImportExcel' NOT found."
                }

                # Amcache Scan --> Check SHA1 File Hashes on VirusTotal
                if ((Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_UnassociatedFileEntries.csv") -And ([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_UnassociatedFileEntries.csv") -gt 0))
                {
                    New-Item "$OUTPUT_FOLDER\Amcache\SHA1" -ItemType Directory -Force | Out-Null
                    Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_UnassociatedFileEntries.csv" -Delimiter "," | Select-Object -Property Name, ProductName, ApplicationName, FullPath, SHA1 | Sort-Object -Property SHA1 -Unique | Export-Csv "$OUTPUT_FOLDER\Amcache\SHA1\SHA1-draft.csv" -Delimiter "," -NoTypeInformation
                    Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_AssociatedFileEntries.csv" -Delimiter "," | Select-Object -Property Name, ProductName, ApplicationName, FullPath, SHA1 | Sort-Object -Property SHA1 -Unique | Export-Csv "$OUTPUT_FOLDER\Amcache\SHA1\SHA1-draft.csv" -Delimiter "," -NoTypeInformation -Append
                    Import-Csv "$OUTPUT_FOLDER\Amcache\SHA1\SHA1-draft.csv" -Delimiter "," | Where-Object {$_.SHA1 -ne ""} | Sort-Object -Property SHA1 -Unique | Export-Csv "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.csv" -Delimiter "," -NoTypeInformation
                    (Import-Csv "$OUTPUT_FOLDER\Amcache\SHA1\SHA1-draft.csv" -Delimiter "," | Where-Object {$_.SHA1 -ne ""} | Sort-Object -Property SHA1 -Unique).SHA1 | Out-File "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.txt" -Encoding ascii
                    Remove-Item "$OUTPUT_FOLDER\Amcache\SHA1\SHA1-draft.csv"

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.csv" -Delimiter ","
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "SHA1" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of column E
                                $WorkSheet.Cells["E:E"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }
                    }
                
                    # Count SHA1 File Hashes
                    $Count = [string]::Format('{0:N0}',(Get-Content "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.txt" | Measure-Object).Count)
                    Write-Output "[Info]  $Count SHA1 hash value(s) of executables found"
                }
            }
        }

        }

        Get-Amcache

#############################################################################################################################################################################################
        
        Function Get-ShimCache {

        # AppCompatCacheParser (ShimCache)
        if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*SYSTEM*.reghive") 
        {
            if (Test-Path "$AppCompatCacheParser")
            {
                Write-Output "[Info]  Analyzing Application Compatibility Cache aka ShimCache ... "

                # CSV
                New-Item "$OUTPUT_FOLDER\Registry\ShimCache\CSV" -ItemType Directory -Force | Out-Null
                $SYSTEM = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Foreach-Object FullName | Select-String -Pattern "SYSTEM" -CaseSensitive | Out-String).Trim()
                & $AppCompatCacheParser -f "$SYSTEM" --csv "$OUTPUT_FOLDER\Registry\ShimCache\CSV" --csvf AppCompatCacheParser.csv -t > "$OUTPUT_FOLDER\Registry\ShimCache\AppCompatCacheParser.log" 2> $null

                # Stats
                if (Test-Path "$OUTPUT_FOLDER\Registry\ShimCache\AppCompatCacheParser.log")
                {
                    $Total = Get-Content "$OUTPUT_FOLDER\Registry\ShimCache\AppCompatCacheParser.log" | Select-String -Pattern "cache entries"
                    if ($Total)
                    {
                        Write-Output "[Info]  $Total"
                    }
                    else
                    {
                        Write-Output "[Info]  SYSTEM Hive seems to be partially corrupt."
                    }
                }

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\Registry\ShimCache\CSV\AppCompatCacheParser.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Registry\ShimCache\CSV\AppCompatCacheParser.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Registry\ShimCache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\ShimCache\CSV\AppCompatCacheParser.csv" -Delimiter "," | Sort-Object { $_.LastModifiedTimeUTC -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\ShimCache\XLSX\AppCompatCacheParser.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "ShimCache" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-B and D-F
                            $WorkSheet.Cells["A:B"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["D:F"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] AppCompatCacheParser.exe NOT found." -ForegroundColor Red
            }
        }

        }

        Get-ShimCache

#############################################################################################################################################################################################

        # Syscache

        Function Get-Syscache {

        # Check if Syscache hive exists
        if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*Syscachehve*.reghive") 
        {
            # Check if RECmd.exe exists
            if (Test-Path "$RECmd")
            {
                Write-Output "[Info]  Analyzing Syscache Hive ... "

                # CSV
                New-Item "$OUTPUT_FOLDER\Syscache\CSV" -ItemType Directory -Force | Out-Null
                $Syscachehve = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "Syscachehve")} | Foreach-Object FullName)
                & $RECmd -f "$Syscachehve" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\SysCache.reb" --csv "$OUTPUT_FOLDER\Syscache\CSV" --csvf "Syscache.csv" > "$OUTPUT_FOLDER\Syscache\Syscache.log" 2> $null

                # Stats
                if (Test-Path "$OUTPUT_FOLDER\Syscache\Syscache.log")
                {
                    $Total = Get-Content "$OUTPUT_FOLDER\Syscache\Syscache.log" | Select-String -Pattern "key/value pairs"
                    Write-Output "[Info]  $Total"
                }

                # SHA1 --> Check SHA1 hashes on VirusTotal
                if ((Test-Path "$OUTPUT_FOLDER\Syscache\CSV\Syscache.csv") -And ([int](& $xsv count "$OUTPUT_FOLDER\Syscache\CSV\Syscache.csv") -gt 0))
                {
                    (Import-Csv "$OUTPUT_FOLDER\Syscache\CSV\Syscache.csv" | Select-Object -Property "ValueData2" | Sort-Object -Property "ValueData2" -Unique).ValueData2 | ForEach-Object{($_ -split "SHA-1: ")[1]} | Select-Object -Skip 1 | Out-File "$OUTPUT_FOLDER\Syscache\SHA1.txt" -Encoding ascii

                    # Count SHA1 hashes
                    $Count = [string]::Format('{0:N0}',(Get-Content "$OUTPUT_FOLDER\Syscache\SHA1.txt" | Measure-Object).Count)
                    Write-Output "[Info]  $Count SHA1 hash value(s) of executables found"
                }

                # XLSX

                # Syscache.csv
                if (Test-Path "$OUTPUT_FOLDER\Syscache\CSV\Syscache.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\Syscache\CSV\Syscache.csv") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\Syscache\XLSX" -ItemType Directory -Force | Out-Null
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\Syscache\CSV\Syscache.csv" -Delimiter "," | Sort-Object { $_.LastWriteTimestamp -as [datetime] } -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Syscache\XLSX\Syscache.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "SysCache" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-N
                        $WorkSheet.Cells["B:N"].Style.HorizontalAlignment="Center"
                        }
                    }
                }

                # Syscache_SyscacheObjectTable.csv
                if (Test-Path "$OUTPUT_FOLDER\Syscache\CSV\*\Syscache_SyscacheObjectTable.csv")
                {
                    $FilePath = Get-ChildItem -Path "$OUTPUT_FOLDER\Syscache\CSV\*\Syscache_SyscacheObjectTable.csv" | ForEach-Object FullName
                    if([int](& $xsv count "$FilePath") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\Syscache\XLSX" -ItemType Directory -Force | Out-Null
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\Syscache\CSV\*\Syscache_SyscacheObjectTable.csv" -Delimiter "," | Sort-Object { $_.LastWriteTime -as [datetime] } -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Syscache\XLSX\Syscache_SyscacheObjectTable.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "SysCache (Plugin)" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:L1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-L
                        $WorkSheet.Cells["B:L"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["D:L"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Info]  Syscache.hve not found."
        }

        }

        Get-Syscache

#############################################################################################################################################################################################

        # UserAssist

        Function Get-UserAssist {

        # Check if RECmd.exe exists
        if (Test-Path "$RECmd")
        {
            # Check if batch processing file exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\UserAssist.reb")
            {
                # Check if Registry Plugin exists
                if (Test-Path "$SCRIPT_DIR\Tools\RECmd\Plugins\RegistryPlugin.UserAssist.dll")
                {
                    # Analyzing UserAssist Artifacts
                    Write-Output "[Info]  Analyzing UserAssist Artifacts ..."
                    New-Item "$OUTPUT_FOLDER\Registry\UserAssist\CSV" -ItemType Directory -Force | Out-Null
                    New-Item "$OUTPUT_FOLDER\Registry\UserAssist\XLSX" -ItemType Directory -Force | Out-Null

                    $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat")} | Foreach-Object FullName)

                    ForEach( $FilePath in $FilePathList )
                    {
                        $FileName = $FilePath | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.")[0]}
                        $SID = $FileName | ForEach-Object{($_ -split "_")[1]}

                        # Check if UserAssist key exists
                        if (Test-Path "$DriveLetter\registry\by-hive\$FileName\ROOT\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\UserAssist")
                        {
                            # CSV
                            & $RECmd -f "$FilePath" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\UserAssist.reb" --csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV" --csvf "$SID-UserAssist.csv" > "$OUTPUT_FOLDER\Registry\UserAssist\$SID-UserAssist.log" 2> $null

                            if (Test-Path "$OUTPUT_FOLDER\Registry\UserAssist\CSV\*\$SID-UserAssist_UserAssist.csv")
                            {
                                Move-Item -Path "$OUTPUT_FOLDER\Registry\UserAssist\CSV\*\$SID-UserAssist_UserAssist.csv" -Destination "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist_PluginDetailFile.csv"
                                Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\UserAssist\CSV\*" -Directory | ForEach-Object FullName | Remove-Item -Force -Recurse
                            }

                            # Stats
                            if (Test-Path "$OUTPUT_FOLDER\Registry\UserAssist\$SID-UserAssist.log")
                            {
                                # Check for parsing error
                                if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\UserAssist\$SID-UserAssist.log" | Select-String -Pattern "parse error" -Quiet))
                                {
                                    # Check if key/value pairs were found
                                    if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\UserAssist\$SID-UserAssist.log" | Select-String -Pattern "Found 0 key/value pairs across 1 file" -Quiet))
                                    {
                                        # Count
                                        $Total = Get-Content "$OUTPUT_FOLDER\Registry\UserAssist\$SID-UserAssist.log" | Select-String -Pattern "key/value pairs"
                                        Write-Host "[Info]  $Total ($SID)"

                                        # Array
                                        $Array = @()

                                        # Total Entries
                                        $TotalEntries = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Total Entries"; Count = "$TotalEntries"}

                                        # Toral Entries w/ Run Count
                                        $TotalRunCount = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Where-Object { $_.ValueData3 -match "Run count:" } | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Total Entries with Run Count"; Count = "$TotalRunCount"}

                                        # Entries with "Run count: 0"
                                        $RunCount0 = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Where-Object { $_.ValueData3 -match "Run count: 0" } | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Entries with Run Count 0"; Count = "$RunCount0"}

                                        # Entries with "Last executed" field populated
                                        $LastExecutedPopulated = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Where-Object { $_.ValueData2 -match "Last executed: 2" } | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Entries with 'Last executed' field populated"; Count = "$LastExecutedPopulated"}

                                        # Entries with "Last executed" field not populated
                                        $LastExecutedEmpty = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Where-Object { $_.ValueData2 -match "Last executed: $" } | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Entries with 'Last executed' field not populated"; Count = "$LastExecutedEmpty"}

                                        # Executable File Execution (GUID)
                                        $ExecutableFileExecution = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Where-Object { $_.KeyPath -match "{CEBFF5CD-ACE2-4F4F-9178-9926F41749EA}\\Count" } | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Executable File Execution"; Count = "$ExecutableFileExecution"}

                                        # Shortcut File Execution (GUID)
                                        $ShortcutFileExecution = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Where-Object { $_.KeyPath -match "{F4E57C4B-2036-45F0-A9AB-443BCFE33D9F}\\Count" } | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Shortcut File Execution"; Count = "$ShortcutFileExecution"}
                                        
                                        # CSV
                                        $Array | ForEach-Object { New-Object PSObject -Property $_ } |  Export-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist-Stats.csv" -NoTypeInformation
                                    }
                                    else
                                    {
                                        Write-Host "[Info]  Found 0 key/value pairs across 1 file ($SID)"
                                    }
                                }
                            }

                            # XLSX
                            if (Test-Path "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv")
                            {
                                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv") -gt 0)
                                {
                                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Sort-Object { $_.LastWriteTimestamp -as [datetime] } -Descending
                                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\UserAssist\XLSX\$SID-UserAssist.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "UserAssist" -CellStyleSB {
                                    param($WorkSheet)
                                    # BackgroundColor and FontColor for specific cells of TopRow
                                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                    Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                                    # HorizontalAlignment "Center" of columns B-D, G and J-N
                                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                                    $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                                    $WorkSheet.Cells["J:N"].Style.HorizontalAlignment="Center"
                                    }
                                }
                            }

                            # XLSX (PluginDetailFile)
                            if (Test-Path "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist_PluginDetailFile.csv")
                            {
                                if((Get-Item "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist_PluginDetailFile.csv").length -gt 0kb)
                                {
                                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist_PluginDetailFile.csv" -Delimiter "," | Sort-Object { $_.LastExecuted -as [datetime] } -Descending
                                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\UserAssist\XLSX\$SID-UserAssist_PluginDetailFile.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "UserAssist (Plugin)" -CellStyleSB {
                                    param($WorkSheet)
                                    # BackgroundColor and FontColor for specific cells of TopRow
                                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                                    # HorizontalAlignment "Center" of columns D-G
                                    $WorkSheet.Cells["D:G"].Style.HorizontalAlignment="Center"
                                    }
                                }
                            }

                            # XLSX (Stats)
                            if (Test-Path "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist-Stats.csv")
                            {
                                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist-Stats.csv") -gt 0)
                                {
                                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist-Stats.csv" -Delimiter ","
                                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\UserAssist\XLSX\$SID-UserAssist-Stats.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "UserAssist (Stats)" -CellStyleSB {
                                    param($WorkSheet)
                                    # BackgroundColor and FontColor for specific cells of TopRow
                                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                    Set-Format -Address $WorkSheet.Cells["A1:B1"] -BackgroundColor $BackgroundColor -FontColor White
                                    # HorizontalAlignment "Center" of column B
                                    $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    Write-Host "[Error] RegistryPlugin.UserAssist.dll NOT found." -ForegroundColor Red
                }
            }
            else
            {
                Write-Host "[Error] UserAssist.reb NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
        }

        }

        Get-UserAssist

#############################################################################################################################################################################################

        # Windows Background Activity Moderator (BAM)
        
        Function Get-BAM {

        # Check if RECmd.exe exists
        if (Test-Path "$RECmd")
        {
            # Check if batch processing file exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\BAM.reb")
            {
                # Check if Background Activity Moderator Driver exists
                if (Test-Path "$DriveLetter\sys\services\services.txt")
                {
                    if (Get-Content "$DriveLetter\sys\services\services.txt" | Select-String -Pattern "Background Activity Moderator Driver" -Quiet)
                    {
                        # Analyzing Windows Background Activity Moderator (BAM) Artifacts
                        Write-Output "[Info]  Analyzing Windows Background Activity Moderator (BAM) Artifacts ... "
                        New-Item "$OUTPUT_FOLDER\Registry\BAM\CSV" -ItemType Directory -Force | Out-Null
                        New-Item "$OUTPUT_FOLDER\Registry\BAM\XLSX" -ItemType Directory -Force | Out-Null

                        # CSV
                        $SYSTEM = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | ForEach-Object Name | Select-String -Pattern "SYSTEM" -CaseSensitive | Out-String).Trim()
                        & $RECmd -f "$OUTPUT_FOLDER\Registry\Registry\$SYSTEM" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\BAM.reb" --csv "$OUTPUT_FOLDER\Registry\BAM\CSV" --csvf "BAM.csv" 2>&1 | Out-File "$OUTPUT_FOLDER\Registry\BAM\BAM.log"

                        if (Test-Path "$OUTPUT_FOLDER\Registry\BAM\CSV\*\BAM_BamDam.csv")
                        {
                            Move-Item -Path "$OUTPUT_FOLDER\Registry\BAM\CSV\*\BAM_BamDam.csv" -Destination "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM_PluginDetailFile.csv"
                            Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\BAM\CSV\*" -Directory | ForEach-Object FullName | Remove-Item -Force -Recurse
                        }

                        # Stats
                        if (Test-Path "$OUTPUT_FOLDER\Registry\BAM\BAM.log")
                        {
                            # Check if key/value pairs were found
                            if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\BAM\BAM.log" | Select-String -Pattern "Found 0 key/value pairs across 1 file" -Quiet))
                            {
                                # Count
                                $Count = Get-Content "$OUTPUT_FOLDER\Registry\BAM\BAM.log" | Select-String -Pattern "key/value pairs"
                                Write-Output "[Info]  $Count"
                            }
                            else
                            {
                                Write-Output "[Info]  Found 0 key/value pairs across 1 file"
                            }
                        }

                        # XLSX
                        if (Test-Path "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM.csv" -Delimiter ","
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\BAM\XLSX\BAM.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "BAM" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns B-D, G and I-N
                                $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["I:N"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }

                        # XLSX (PluginDetailFile)
                        if (Test-Path "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM_PluginDetailFile.csv")
                        {
                            if((Get-Item "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM_PluginDetailFile.csv").length -gt 0kb)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM_PluginDetailFile.csv" -Delimiter "," | Sort-Object { $_.ExecutionTime -as [datetime] } -Descending
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\BAM\XLSX\BAM_PluginDetailFile.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "BAM (Plugin)" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of column C
                                $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }
                    }
                }
            }
        }

        }

        Get-BAM

#############################################################################################################################################################################################

        # MUICache (Multi-Lingual User Interface)

        Function Get-MUICache {

        # Check if RECmd.exe exists
        if (Test-Path "$RECmd")
        {
            # Check if batch processing file exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\MUICache.reb")
            {
                # Analyzing MUICache Artifacts
                Write-Output "[Info]  Analyzing MUICache Artifacts ... "
                New-Item "$OUTPUT_FOLDER\Registry\MUICache\CSV" -ItemType Directory -Force | Out-Null
                New-Item "$OUTPUT_FOLDER\Registry\MUICache\XLSX" -ItemType Directory -Force | Out-Null

                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "UsrClassdat")} | Foreach-Object FullName)

                ForEach( $FilePath in $FilePathList )
                {
                    $FileName = $FilePath | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.")[0]}
                    $SID = $FileName | ForEach-Object{($_ -split "_")[1]}

                    # Check if MUICache key exists (Vista+)
                    if (Test-Path "$DriveLetter\registry\by-hive\$FileName\ROOT\Local Settings\Software\Microsoft\Windows\Shell\MuiCache")
                    {
                        # CSV
                        & $RECmd -f "$FilePath" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\MUICache.reb" --csv "$OUTPUT_FOLDER\Registry\MUICache\CSV" --csvf "$SID-MUICache.csv" > "$OUTPUT_FOLDER\Registry\MUICache\$SID-MUICache.log" 2> $null

                        # Stats
                        if (Test-Path "$OUTPUT_FOLDER\Registry\MUICache\$SID-MUICache.log")
                        {
                            # Check if key/value pairs were found
                            if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\MUICache\$SID-MUICache.log" | Select-String -Pattern "Found 0 key/value pairs across 1 file" -Quiet))
                            {
                                # Count
                                $Total = Get-Content "$OUTPUT_FOLDER\Registry\MUICache\$SID-MUICache.log" | Select-String -Pattern "key/value pairs"
                                Write-Host "[Info]  $Total ($SID)"
                            }
                        }

                        # XLSX
                        if (Test-Path "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache.csv" -Delimiter ","
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\MUICache\XLSX\$SID-MUICache.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "MUICache" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns B-D, G and I-O
                                $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["I:O"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }

                        # Custom CSV
                        if (Test-Path "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache.csv") -gt 0)
                            {
                                $Import = Import-Csv "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache.csv" -Delimiter "," | Where-Object { $_.ValueType -eq "RegSz" }

                                $Counter=0

                                $Import | Foreach-Object {

                                    $Counter++

                                    if ($_.ValueName -like "*ApplicationCompany*")
                                    {
                                        $FileName = $_ | Select-Object -ExpandProperty ValueName | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object { $_ -replace "\.ApplicationCompany$" }
                                        $FilePath = $_ | Select-Object -ExpandProperty ValueName | Split-Path 
                                        $ApplicationCompany = $_ | Select-Object -ExpandProperty ValueData
                                        $HivePath = $_ | Select-Object -ExpandProperty HivePath
                                        $LastWriteTimestamp = $_ | Select-Object -ExpandProperty LastWriteTimestamp
                                    }

                                    if ($_.ValueName -like "*FriendlyAppName*")
                                    {
                                        $FriendlyAppName = $_ | Select-Object -ExpandProperty ValueData
                                    }

                                    if($Counter -eq 2)
                                    {  
                                        New-Object -TypeName PSObject -Property @{

                                            "FileName"          = $FileName
                                            "FilePath"          = $FilePath
                                            "ApplicationCompany" = $ApplicationCompany # Company Name
                                            "FriendlyAppName"    = $FriendlyAppName # File Description
                                            "HivePath"          = $HivePath
                                            "LastWriteTimestamp" = $LastWriteTimestamp
                                            "SID"                = $SID
                                            "UserName"           = Get-Content "$OUTPUT_FOLDER\sys\users\users.txt" | Select-String -Pattern "$SID" | ForEach-Object{($_ -split "\s+")[1]}
                                            }

                                        $Counter=0
                                    }

                                } | Select-Object "FileName","FilePath","ApplicationCompany","FriendlyAppName","UserName","SID","HivePath","LastWriteTimestamp" | Export-Csv -Path "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv" -Delimiter "," -NoTypeInformation -Encoding UTF8   
                            }
                        }

                        # Stats
                        if (Test-Path "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv")
                        {
                            # Count
                            $Unique = (Import-Csv -Path "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv" | Select-Object "File Name" | Sort-Object { [string]$_."File Name" } -Unique | Measure-Object).Count
                            $Total = & $xsv count "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv"
                            Write-Output "[Info]  $Unique GUI-based executable(s) found ($Total)"
                        }

                        # XLSX
                        if (Test-Path "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv" -Delimiter "," -Encoding UTF8
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\MUICache\XLSX\$SID-MUICache_Custom.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "MUICache" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns C, E-F and H
                                $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["E:F"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:H"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] MUICache.reb NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
        }

        }

        Get-MUICache

#############################################################################################################################################################################################

        # SBECCmd

        Function Get-ShellBags {

        # Check ShellBags Location
        if ((Test-Path "$OUTPUT_FOLDER\Registry\Registry\*ntuserdat*") -or (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*UsrClassdat*"))
        {
            if (Test-Path "$SBECmd")
            {
                Write-Output "[Info]  Analyzing ShellBags Artifacts ... "
                New-Item "$OUTPUT_FOLDER\Registry\ShellBags\CSV" -ItemType Directory -Force | Out-Null
                New-Item "$OUTPUT_FOLDER\Registry\ShellBags\XLSX" -ItemType Directory -Force | Out-Null

                # ShellBags are stored in both NTUSER.DAT and USRCLASS.DAT
                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat|UsrClassdat")} | Foreach-Object FullName)

                # Rename Registry Hives temporarily...SBECCmd requires .dat file extension
                Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat|UsrClassdat")} | Rename-Item -NewName {$_.Name -replace "\.reghive$",".dat"}

                # CSV
                & $SBECmd -d "$OUTPUT_FOLDER\Registry\Registry" --csv "$OUTPUT_FOLDER\Registry\ShellBags\CSV" --csvf "SBECmd.csv" > "$OUTPUT_FOLDER\Registry\ShellBags\SBECmd.log" 2> $null
                
                # Rename Registry Hives
                Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat|UsrClassdat")} | Rename-Item -NewName {$_.Name -replace "\.dat$",".reghive"}

                # Stats
                if (Get-Content "$OUTPUT_FOLDER\Registry\ShellBags\SBECmd.log" | Select-String -Pattern "^Total ShellBags found:" -Quiet)
                {
                    # Error
                    if (Get-Content "$OUTPUT_FOLDER\Registry\ShellBags\SBECmd.log" | Select-String -Pattern "Error processing hbin" -Quiet)
                    {
                        Write-Output "[Info]  ShellBags Artifacts seem to be partially corrupt."
                    }

                    # Total
                    $Total = (Get-Content "$OUTPUT_FOLDER\Registry\ShellBags\SBECmd.log" | Select-String -Pattern "Total ShellBags found:" | Select-Object -Last 1 | Out-String).Trim()
                    Write-Output "[Info]  $Total"
                }

                # XLSX
                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\ShellBags\CSV" | Where-Object {($_.Extension -eq ".csv")} | Foreach-Object FullName)

                ForEach( $FilePath in $FilePathList )
                {
                    $FileName = $FilePath | ForEach-Object{($_ -split "-USER_")[1]} | ForEach-Object{($_ -split "\.csv")[0]}

                    if (Test-Path "$FilePath")
                    {
                        if([int](& $xsv count "$FilePath") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Registry\ShellBags\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$FilePath" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\ShellBags\XLSX\$FileName.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "ShellBags" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:S1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-D, F and H-S
                            $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["H:S"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] SBECCmd.exe NOT found." -ForegroundColor Red
            }
        }

        }

        Get-ShellBags

#############################################################################################################################################################################################

        # Registry ASEPs (Auto-Start Extensibility Points)
        if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*.reghive") 
        {
            if (Test-Path "$RECmd")
            {
                # Check if batch processing file exists
                if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\RegistryASEPs.reb")
                {
                    Write-Output "[Info]  Extracting Auto-Start Extensibility Points (ASEPs) ... "

                    # CSV
                    New-Item "$OUTPUT_FOLDER\Registry\RegistryASEPs\CSV" -ItemType Directory -Force | Out-Null
                    Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuse")} | Rename-Item -NewName {$_.Name -replace "\.reghive$","ntuser.dat"}
                    Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "UsrClas")} | Rename-Item -NewName {$_.Name -replace "\.reghive$","UsrClass.dat"}
                    & $RECmd -d "$OUTPUT_FOLDER\Registry\Registry" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\RegistryASEPs.reb" --csv "$OUTPUT_FOLDER\Registry\RegistryASEPs\CSV" --csvf "RegistryASEPs.csv" > "$OUTPUT_FOLDER\Registry\RegistryASEPs\RegistryASEPs.log" 2> $null
                    Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuse")} | Rename-Item -NewName {$_.Name -replace "ntuser\.dat$",".reghive"}
                    Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "UsrClas")} | Rename-Item -NewName {$_.Name -replace "UsrClass\.dat$",".reghive"}

                    # Stats
                    if (Test-Path "$OUTPUT_FOLDER\Registry\RegistryASEPs\RegistryASEPs.log")
                    {
                        $Total = Get-Content "$OUTPUT_FOLDER\Registry\RegistryASEPs\RegistryASEPs.log" | Select-String -Pattern "key/value pairs"
                        Write-Output "[Info]  $Total"
                    }

                    # XSLX
                    New-Item "$OUTPUT_FOLDER\Registry\RegistryASEPs\XLSX" -ItemType Directory -Force | Out-Null
                    if (Test-Path "$OUTPUT_FOLDER\Registry\RegistryASEPs\CSV\RegistryASEPs.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Registry\RegistryASEPs\CSV\RegistryASEPs.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\RegistryASEPs\CSV\RegistryASEPs.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\RegistryASEPs\XLSX\RegistryASEPs.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "RegistryASEPs" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-D, G and L-O
                            $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["L:O"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
                else
                {
                    Write-Host "[Error] RegistryASEPs.reb NOT found." -ForegroundColor Red
                }
            }
            else
            {
                Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
            }
        }

        # Startup Folders
        if (Test-Path "$DriveLetter\forensic\timeline\timeline_ntfs.txt")
        {
            New-Item "$OUTPUT_FOLDER\Persistence" -ItemType Directory -Force | Out-Null
            $StartupFolders = (Get-Content "$DriveLetter\forensic\timeline\timeline_ntfs.txt" | Select-String -Pattern "\\Start Menu\\Programs\\Startup\\" | Where-Object {$_ -notmatch "desktop.ini"} | Out-String).Trim()
            $StartupFolders | Out-File "$OUTPUT_FOLDER\Persistence\Startup-Folders.txt"
        }

        # SQLite Database
        if (Test-Path "$DriveLetter\forensic\database.txt")
        {
            # Collecting SQLite Database
            $DatabasePath = (Get-Content "$DriveLetter\forensic\database.txt" | Select-String -Pattern "vmm.sqlite3" | Out-String).Trim()
            Write-Output "[Info]  SQLite Database: $DatabasePath"
            Write-Output "[Info]  Collecting SQLite Database ..."
            New-Item "$OUTPUT_FOLDER\database" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DatabasePath" -Destination "$OUTPUT_FOLDER\database\vmm.sqlite3"

            # File Size (SQLite3)
            if (Test-Path "$OUTPUT_FOLDER\database\vmm.sqlite3")
            {
                $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\database\vmm.sqlite3").Length)
                Write-Output "[Info]  File Size (SQLite3): $Size"
            }
        }

        # MemProcFS Plugins
        # https://github.com/ufrisk/MemProcFS-plugins

        # pypykatz
        # https://github.com/skelsec/pypykatz
        if (Test-Path "$DriveLetter\py\secrets\*")
        {
            Write-Output "[Info]  Collecting pypykatz ... "
            New-Item "$OUTPUT_FOLDER\MemProcFS-Plugins\pypykatz" -ItemType Directory -Force | Out-Null
            Copy-Item -Recurse -Force "$DriveLetter\py\secrets\*" "$OUTPUT_FOLDER\MemProcFS-Plugins\pypykatz" 2>&1 | Out-Null
        }

        # regsecrets
        # https://github.com/skelsec/pypykatz
        if (Test-Path "$DriveLetter\py\regsecrets\*")
        {
            Write-Output "[Info]  Collecting regsecrets ... "
            New-Item "$OUTPUT_FOLDER\MemProcFS-Plugins\regsecrets" -ItemType Directory -Force | Out-Null
            Copy-Item -Recurse -Force "$DriveLetter\py\regsecrets\*" "$OUTPUT_FOLDER\MemProcFS-Plugins\regsecrets" 2>&1 | Out-Null
        }
    }
    else
    {
        Write-Host "[Error] Forensic Directory doesn't exist." -ForegroundColor Red
    }
}
else
{
    Write-Host "[Error] MemProcFS.exe NOT found." -ForegroundColor Red
    Stop-Transcript
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

}

#endregion MemProcFS

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region ELKImport

Function ELKImport {

# Elastic-Import
if (Test-Path "$DriveLetter\forensic\json\elastic_import.ps1")
{
    # Copy elastic_import.ps1 to a trusted location (to avoid security warning)
    Copy-Item -Path "$DriveLetter\forensic\json\elastic_import.ps1" -Destination "$SCRIPT_DIR\elastic_import.ps1"

    # ELK Import
    Write-Output "[Info]  Importing JSON data to Elasticsearch [approx. 1-5 min] ... "
    $Elastic_Import = "$SCRIPT_DIR\elastic_import.ps1"
    $Argument = $DriveLetter.TrimEnd(":")
    Start-Process -FilePath "powershell" -Verb RunAs -Wait -ArgumentList "-File $Elastic_Import", "$Argument"

    # Cleaning up
    if (Test-Path "$Elastic_Import")
    {
        Remove-Item "$Elastic_Import" -Force
    }

    try 
    {
        # Open Kibana w/ Google Chrome
        $Chrome = ((Get-Item (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe")."(Default)").VersionInfo).FileName
        Start-Process -FilePath $Chrome -ArgumentList "http://localhost:5601"
    }
    catch 
    {
        # Open Kibana in your Default Browser
        Start-Process "http://localhost:5601"
    }
}

}

#endregion ELKImport

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region MicrosoftDefender

Function MicrosoftDefender {

# Turning Microsoft Defender AntiVirus off (Real-Time Protection)

# Real-Time Protection Activation Status
# Note: Tamper Protection must be disabled.
$DisableRealtimeMonitoring = ((Get-MpPreference | Select-Object DisableRealtimeMonitoring).DisableRealtimeMonitoring | Out-String).Trim()

# Disable Real-Time Protection
if ($DisableRealtimeMonitoring -eq "False")
{
    Write-Output "[Info]  Microsoft Defender (Real-Time Protection) will be disabled temporarily ..."
    Set-MpPreference -DisableRealtimeMonitoring $true
    Start-Sleep 10
}

}

#endregion MicrosoftDefender

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region ClamAVUpdate

Function ClamAVUpdate {

# ClamAVUpdate
New-Item "$OUTPUT_FOLDER\ClamAV" -ItemType Directory -Force | Out-Null

# freshclam.conf
if (!(Test-Path "C:\Program Files\ClamAV\freshclam.conf"))
{
    Write-Host "[Error] freshclam.conf is missing." -ForegroundColor Red
    Write-Host "        https://docs.clamav.net/manual/Usage/Configuration.html#windows --> First Time Set-Up" -ForegroundColor Red
    Stop-Transcript
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# clamd.conf
if (!(Test-Path "C:\Program Files\ClamAV\clamd.conf"))
{
    Write-Host "[Error] clamd.conf is missing." -ForegroundColor Red
    Write-Host "        https://docs.clamav.net/manual/Usage/Configuration.html#windows --> First Time Set-Up" -ForegroundColor Red
    Stop-Transcript
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Update
if (Test-Path "$freshclam")
{
    # Internet Connectivity Check (Vista+)
    $NetworkListManager = [Activator]::CreateInstance([Type]::GetTypeFromCLSID([Guid]‘{DCB00C01-570F-4A9B-8D69-199FDBA5723B}’)).IsConnectedToInternet

    if (!($NetworkListManager -eq "True"))
    {
        Write-Host "[Error] Your computer is NOT connected to the Internet. ClamAV cannot check for any updates." -ForegroundColor Red
    }
    else
    {
        # Check if clamav.net is reachable
        if (!(Test-Connection -ComputerName clamav.net -Count 1 -Quiet))
        {
            Write-Host "[Error] clamav.net is NOT reachable. ClamAV cannot check for any updates." -ForegroundColor Red
        }
        else
        {
            Write-Output "[Info]  Checking for ClamAV Updates ..."
            & $freshclam > "$OUTPUT_FOLDER\ClamAV\Update.txt" 2> "$OUTPUT_FOLDER\ClamAV\Warning.txt"

            # Update ClamAV Engine
            if (Select-String -Pattern "WARNING: Your ClamAV installation is OUTDATED!" -Path "$OUTPUT_FOLDER\ClamAV\Warning.txt" -Quiet)
            {
                Write-Host "[Info]  WARNING: Your ClamAV installation is OUTDATED!" -ForegroundColor Red

                if (Select-String -Pattern "Recommended version:" -Path "$OUTPUT_FOLDER\ClamAV\Warning.txt" -Quiet)
                {
                    $WARNING = Get-Content "$OUTPUT_FOLDER\ClamAV\Warning.txt" | Select-String -Pattern "Recommended version:"
                    Write-Host "[Info]  $WARNING" -ForegroundColor Red
                }
            }

            # Update Signature Databases
            $Count = (Get-Content "$OUTPUT_FOLDER\ClamAV\Update.txt" | Select-String -Pattern "is up to date" | Measure-Object).Count
            if ($Count -match "3")
            {
                Write-Output "[Info]  All ClamAV Virus Databases (CVD) are up-to-date."
            }
            else
            {
                Write-Output "[Info]  Updating ClamAV Virus Databases (CVD) ... "
            }
        }
    }
}
else
{
    Write-Host "[Error] freshclam.exe NOT found." -ForegroundColor Red
}

# Engine Version
if (Test-Path "$clamscan")
{
    $Version = & $clamscan -V
    $EngineVersion = $Version.Split('/')[0]
    $Patch = $Version.Split('/')[1]
    Write-Output "[Info]  Engine Version: $EngineVersion (#$Patch)"
    $Version | Out-File "$OUTPUT_FOLDER\ClamAV\Version.txt"
}
else
{
    Write-Host "[Error] clamscan.exe NOT found." -ForegroundColor Red
}

}

#endregion ClamAVUpdate

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region ClamAV

Function ClamAV {

# ClamAV

# Custom Scan
# Note: By default ClamAV will not scan files larger than 100MB.
$ScanPath = "$DriveLetter\name"

# Drive Letter Scan Mode
if ((Get-Item $ScanPath) -is [System.IO.DirectoryInfo])
{
    if ($ScanPath -match ":$")
    {
        Write-Output "[Info]  Custom scan w/ ClamAV is running ($ScanPath) ..."
        Write-Output "[Info]  Drive Letter Scan Mode enabled [time-consuming task] ..."
    }
}

# Directory Scan Mode
if ((Get-Item $ScanPath) -is [System.IO.DirectoryInfo])
{
    if (!($ScanPath -match ":$"))
    {
        Write-Output "[Info]  Custom scan w/ ClamAV is running ($ScanPath) ..."
        Write-Output "[Info]  Directory Scan Mode enabled [time-consuming task] ..."
    }
}

# File Scan Mode
if ((Get-Item $ScanPath) -is [System.IO.FileInfo])
{
    Write-Output "[Info]  Custom scan w/ ClamAV is running ($ScanPath) ..."
    Write-Output "[Info]  File Scan Mode enabled"
}

# Start ClamAV Daemon
if (Test-Path "$clamd")
{
    if (Test-Path "$clamdscan")
    {
        Write-Output "[Info]  Starting ClamAV Daemon ..."
        Start-Process powershell.exe -FilePath "$clamd" -WindowStyle Minimized
        $ProgressPreference = 'SilentlyContinue'
        do {
          Start-Sleep -Seconds 5
        } until (Test-NetConnection 127.0.0.1 -Port 3310 -InformationLevel Quiet -WarningAction SilentlyContinue )
        Write-Output "[Info]  ClamAV Daemon is running ... "

        # Get Start Time
        $StartTime_ClamAV = (Get-Date)

        # ClamAV Daemon Scan (Multi-Threaded)
        $LogFile = "$OUTPUT_FOLDER\ClamAV\LogFile.txt"
        Start-Process -FilePath "$clamdscan" -ArgumentList "$ScanPath --quiet --multiscan --log=$LogFile" -WindowStyle Minimized -Wait
        Stop-Process -Name "clamdscan" -ErrorAction SilentlyContinue
        Stop-Process -Name "clamd" -ErrorAction SilentlyContinue

        # Get End Time
        $EndTime_ClamAV = (Get-Date)

        # Scan Duration
        $Time_ClamAV = ($EndTime_ClamAV-$StartTime_ClamAV)
        ('ClamAV Scan duration:          {0} h {1} min {2} sec' -f $Time_ClamAV.Hours, $Time_ClamAV.Minutes, $Time_ClamAV.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

        # ClamAV Detection(s)

        # FOUND (Infected Files)
        New-Item "$OUTPUT_FOLDER\ClamAV\Infected" -ItemType Directory -Force | Out-Null
        $InfectedFilesCount = (Get-Content $LogFile | Select-String -Pattern "FOUND" -CaseSensitive | Select-String -Pattern "Heuristics.Encrypted.* FOUND" -NotMatch | Measure-Object).Count
        $InfectedFilesMatches = Get-Content $LogFile | Select-String -Pattern "FOUND" -CaseSensitive | Select-String -Pattern "Heuristics.Encrypted.* FOUND" -NotMatch
        if ($InfectedFilesCount -eq "0")
        {
            Write-Host "[Info]  0 infected file(s) found" -ForegroundColor Green
        }
        else
        {
            ($InfectedFilesMatches | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\ClamAV\Infected\InfectedFiles.txt"
            Get-Content "$OUTPUT_FOLDER\ClamAV\Infected\InfectedFiles.txt" | Where-Object {$_ -notmatch "MsMpEng.exe"} | Out-File "$OUTPUT_FOLDER\ClamAV\Infected\InfectedFiles-filtered.txt"
    
            $FilteredCount = (Get-Content "$OUTPUT_FOLDER\ClamAV\Infected\InfectedFiles-filtered.txt" | Measure-Object).Count
            Write-Host "[Alert] $FilteredCount infected file(s) found ($InfectedFilesCount)" -ForegroundColor Red
        }

        # Collect Infected Files
        if (Test-Path "$OUTPUT_FOLDER\ClamAV\Infected\InfectedFiles-filtered.txt")
        {
            $InfectedFiles = Get-Content "$OUTPUT_FOLDER\ClamAV\Infected\InfectedFiles-filtered.txt" | ForEach-Object{($_ -split ": ")[0]}
            New-Item "$OUTPUT_FOLDER\ClamAV\Infected\Infected" -ItemType Directory -Force | Out-Null

            ForEach( $InfectedFile in $InfectedFiles )
            {
                $ProcessID = $InfectedFile | ForEach-Object{($_ -split "\\")[2]} | ForEach-Object{($_ -split "-")[-1]}
                $INFECTED = "infected"
                $ArchiveName = $InfectedFile | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "_INJECTED-")[-1]}
                & $7za a -mx5 -mhe "-p$INFECTED" -t7z "$OUTPUT_FOLDER\ClamAV\Infected\Infected\$ProcessID-$ArchiveName.7z" "$InfectedFile" > $null 2>&1
            }
        }

        # Stop ClamAV Daemon
        Stop-Process -Name "clamd" -ErrorAction SilentlyContinue
    }
    else
    {
        Write-Host "[Error] clamdscan.exe NOT found." -ForegroundColor Red
    }
}
else
{
    Write-Host "[Error] clamd.exe NOT found." -ForegroundColor Red
}

}

#endregion ClamAV

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Documents

Function Documents {

# RecentDocs
if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*.reghive") 
{
    if (Test-Path "$RECmd")
    {
        # Check if batch processing file exists
        if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\RecentDocs.reb")
        {
            # Check if Registry Plugin exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd\Plugins\RegistryPlugin.RecentDocs.dll")
            {
                # Analyzing RecentDocs Artifacts
                Write-Output "[Info]  Analyzing RecentDocs Artifacts ... "
                New-Item "$OUTPUT_FOLDER\Registry\RecentDocs\CSV" -ItemType Directory -Force | Out-Null
                New-Item "$OUTPUT_FOLDER\Registry\RecentDocs\XLSX" -ItemType Directory -Force | Out-Null

                # CSV
                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat")} | Foreach-Object FullName)

                ForEach( $FilePath in $FilePathList )
                {
                    $FileName = $FilePath | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.reghive$")[0]}
                    $SID = $FileName | ForEach-Object{($_ -split "_")[1]}

                    # Check if RecentDocs key exists
                    if (Test-Path "$DriveLetter\registry\by-hive\$FileName\ROOT\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs")
                    {
                        & $RECmd -f "$FilePath" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\RecentDocs.reb" --csv "$OUTPUT_FOLDER\Registry\RecentDocs\CSV" --csvf "$SID-RecentDocs.csv" > "$OUTPUT_FOLDER\Registry\RecentDocs\$SID-RecentDocs.log" 2> $null
                    }

                    # Stats
                    if (Test-Path "$OUTPUT_FOLDER\Registry\RecentDocs\$SID-RecentDocs.log")
                    {
                        # Check for parsing error
                        if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\RecentDocs\$SID-RecentDocs.log" | Select-String -Pattern "parse error" -Quiet))
                        {
                            # Check if key/value pairs were found
                            if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\RecentDocs\$SID-RecentDocs.log" | Select-String -Pattern "Found 0 key/value pairs across 1 file" -Quiet))
                            {
                                $Total = Get-Content "$OUTPUT_FOLDER\Registry\RecentDocs\$SID-RecentDocs.log" | Select-String -Pattern "key/value pairs"
                                Write-Host "[Info]  $Total ($SID)"
                            }
                            else
                            {
                                if ($SID)
                                {
                                    Write-Output "[Info]  Found 0 key/value pairs across 1 file ($SID)"
                                }
                                else
                                {
                                    Write-Output "[Info]  Found 0 key/value pairs across 1 file"
                                }
                            }
                        }
                    }
                    
                    # XLSX
                    if (Test-Path "$OUTPUT_FOLDER\Registry\RecentDocs\CSV\$SID-RecentDocs.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Registry\RecentDocs\CSV\$SID-RecentDocs.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\RecentDocs\CSV\$SID-RecentDocs.csv" -Delimiter "," | Sort-Object { $_.LastWriteTimestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\RecentDocs\XLSX\$SID-RecentDocs.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "RecentDocs" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B, D, F-G and J-N
                            $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["F:G"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["J:N"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # RecentDocs_RecentDocs.csv
                    if (Test-Path "$OUTPUT_FOLDER\Registry\RecentDocs\CSV\*\$SID-RecentDocs_RecentDocs.csv")
                    {
                        if((Get-Item "$OUTPUT_FOLDER\Registry\RecentDocs\CSV\*\$SID-RecentDocs_RecentDocs.csv").length -gt 0kb)
                        {
                            New-Item "$OUTPUT_FOLDER\Registry\RecentDocs\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\RecentDocs\CSV\*\$SID-RecentDocs_RecentDocs.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\RecentDocs\XLSX\$SID-RecentDocs_RecentDocs.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "RecentDocs (Plugin)" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:I1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A, C-D and G-I
                            $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["G:I"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] RegistryPlugin.RecentDocs.dll NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Error] RecentDocs.reb NOT found." -ForegroundColor Red
        }
    }
    else
    {
        Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
    }
}

# Office Trusted Documents
if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*.reghive") 
{
    if (Test-Path "$RECmd")
    {
        # Check if batch processing file exists
        if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\TrustedDocuments.reb")
        {
            # Check if Registry Plugin exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd\Plugins\RegistryPlugin.TrustedDocuments.dll")
            {
                # Analyzing Trusted Documents Artifacts
                Write-Output "[Info]  Analyzing Trusted Documents Artifacts ... "
                New-Item "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV" -ItemType Directory -Force | Out-Null
                New-Item "$OUTPUT_FOLDER\Registry\TrustedDocuments\XLSX" -ItemType Directory -Force | Out-Null

                # CSV
                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat")} | Foreach-Object FullName)

                ForEach( $FilePath in $FilePathList )
                {
                    $FileName = $FilePath | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.reghive$")[0]}
                    $SID = $FileName | ForEach-Object{($_ -split "_")[1]}

                    # Check if TrustedDocuments key exists
                    if (Test-Path "$DriveLetter\registry\by-hive\$FileName\ROOT\SOFTWARE\Microsoft\Office\*\*\Security\Trusted Documents\TrustRecords")
                    {
                        & $RECmd -f "$FilePath" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\TrustedDocuments.reb" --csv "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV" --csvf "$SID-TrustedDocuments.csv" > "$OUTPUT_FOLDER\Registry\TrustedDocuments\$SID-TrustedDocuments.log" 2> $null
                    }

                    # Stats
                    if (Test-Path "$OUTPUT_FOLDER\Registry\TrustedDocuments\$SID-TrustedDocuments.log")
                    {
                        $Total = Get-Content "$OUTPUT_FOLDER\Registry\TrustedDocuments\$SID-TrustedDocuments.log" | Select-String -Pattern "key/value pair"
                        Write-Host "[Info]  $Total ($SID)"
                    }
                    else
                    {
                        if ($SID)
                        {
                            Write-Output "[Info]  Found 0 key/value pairs across 1 file ($SID)"
                        }
                        else
                        {
                            Write-Output "[Info]  Found 0 key/value pairs across 1 file"
                        }
                    }

                    # XLSX
                    if (Test-Path "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV\$SID-TrustedDocuments.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV\$SID-TrustedDocuments.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV\$SID-TrustedDocuments.csv" -Delimiter "," | Sort-Object { $_.LastWriteTimestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\TrustedDocuments\XLSX\$SID-TrustedDocuments.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "TrustedDocuments" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B, D, F-G and J-N
                            $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["F:G"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["J:N"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # TrustedDocuments_TrustedDocuments.csv
                    if (Test-Path "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV\*\$SID-TrustedDocuments_TrustedDocuments.csv")
                    {
                        $FilePath = Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV\*\$SID-TrustedDocuments_TrustedDocuments.csv" | Foreach-Object FullName
                        if([int](& $xsv count "$FilePath") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Registry\TrustedDocuments\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV\*\$SID-TrustedDocuments_TrustedDocuments.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\TrustedDocuments\XLSX\$SID-TrustedDocuments_TrustedDocuments.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "TrustedDocuments (Plugin)" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A, C, and F
                            $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] RegistryPlugin.TrustedDocuments.dll NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Error] TrustedDocuments.reb NOT found." -ForegroundColor Red
        }
    }
    else
    {
        Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
    }
}

}

#endregion Documents

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Kroll_Batch

Function KrollBatch {

# Kroll RECmd Batch File v1.20 (2022-06-01)
# https://github.com/EricZimmerman/RECmd/blob/master/BatchExamples/Kroll_Batch.md
# https://github.com/EricZimmerman/RECmd/blob/master/BatchExamples/Kroll_Batch.reb
if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*.reghive") 
{
    if (Test-Path "$RECmd")
    {
        # Check if batch processing file exists
        if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\Kroll_Batch.reb")
        {
            # Analyzing Registry Hives w/ RECmd (Kroll Batch)
            Write-Output "[Info]  Analyzing Registry Hives w/ RECmd (Kroll Batch) ... "
            New-Item "$OUTPUT_FOLDER\Registry\Kroll\CSV" -ItemType Directory -Force | Out-Null

            # CSV
            Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuse")} | Rename-Item -NewName {$_.Name -replace "\.reghive$","ntuser.dat"}
            Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "UsrClas")} | Rename-Item -NewName {$_.Name -replace "\.reghive$","UsrClass.dat"}
            Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Rename-Item -NewName {$_.Name -replace "\.reghive$",""}
            & $RECmd -d "$OUTPUT_FOLDER\Registry\Registry" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\Kroll_Batch.reb" --csv "$OUTPUT_FOLDER\Registry\Kroll\CSV" --csvf "Kroll.csv" > "$OUTPUT_FOLDER\Registry\Kroll\Kroll_Batch.log" 2> $null
            Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuse")} | Rename-Item -NewName {$_.Name -replace "ntuser\.dat$",".reghive"}
            Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "UsrClas")} | Rename-Item -NewName {$_.Name -replace "UsrClass\.dat$",".reghive"}
            Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -notmatch "\.reghive$")} | Rename-Item -NewName { $PSItem.Name + ".reghive" }

            # Rename PluginDetailFiles Directory
            $Directory = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Kroll\CSV" -Directory | Select-Object FullName).FullName
            if ($Directory)
            {
                if (Test-Path "$Directory")
                {
                    Rename-Item -Path "$Directory" -NewName "PluginDetailFiles" -Force
                }
            }

            # Stats
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\Kroll_Batch.log")
            {
                $Total = Get-Content "$OUTPUT_FOLDER\Registry\Kroll\Kroll_Batch.log" | Select-String -Pattern "key/value pairs"
                Write-Host "[Info]  $Total"
            }

            # XLSX

            # Kroll.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\Kroll.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\Kroll.csv") -gt 0)
                {
                    New-Item "$OUTPUT_FOLDER\Registry\Kroll\XLSX" -ItemType Directory -Force | Out-Null
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\Kroll.csv" -Delimiter "," | Sort-Object { $_.LastWriteTimestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\Kroll.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_Batch" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, G and L-N
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:N"].Style.HorizontalAlignment="Center"
                    # HorizontalAlignment "Left" of columns H-J
                    $WorkSheet.Cells["H:J"].Style.HorizontalAlignment="Left"
                    }
                }
            }

            # PluginDetailFiles
            New-Item "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles" -ItemType Directory -Force | Out-Null

            # Kroll_Adobe.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_Adobe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_Adobe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_Adobe.csv" -Delimiter "," | Sort-Object { $_.LastOpened -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_Adobe.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_Adobe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:J1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, C-D, F and I-J
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["I:J"].Style.HorizontalAlignment="Center"
                    # HorizontalAlignment "Right" of column H
                    $WorkSheet.Cells["H:H"].Style.HorizontalAlignment="Right"
                    # HorizontalAlignment "Center" of header of column H
                    $WorkSheet.Cells["H1:H1"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_AppCompatFlags2.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_AppCompatFlags2.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_AppCompatFlags2.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_AppCompatFlags2.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_AppCompatFlags2.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_AppCompatFlags2" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:C1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of column C
                    $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_AppPaths.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_AppPaths.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_AppPaths.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_AppPaths.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_AppPaths.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_AppPaths" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A nd D
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_BamDam.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_BamDam.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_BamDam.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_BamDam.csv" -Delimiter "," | Sort-Object { $_.ExecutionTime -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_BamDam.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_BamDam" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of column C
                    $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_CIDSizeMRU.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_CIDSizeMRU.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_CIDSizeMRU.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_CIDSizeMRU.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_CIDSizeMRU.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_CIDSizeMRU" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns C-E
                    $WorkSheet.Cells["C:E"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_DeviceClasses.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_DeviceClasses.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_DeviceClasses.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_DeviceClasses.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_DeviceClasses.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_DeviceClasses" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-G
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_FileExts.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_FileExts.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_FileExts.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_FileExts.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_FileExts.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_FileExts" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns D-F
                    $WorkSheet.Cells["D:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_FirstFolder.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_FirstFolder.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_FirstFolder.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_FirstFolder.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_FirstFolder.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_FirstFolder" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns C-F
                    $WorkSheet.Cells["C:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_JumplistData.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_JumplistData.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_JumplistData.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_JumplistData.csv" -Delimiter "," | Sort-Object { $_.ExecutedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_JumplistData.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_JumplistData" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of column C
                    $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_KnownNetworks.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_KnownNetworks.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_KnownNetworks.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_KnownNetworks.csv" -Delimiter "," | Sort-Object { $_.LastConnectedLOCAL -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_KnownNetworks.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_KnownNetworks" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-K
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:K"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_LastVisitedPidlMRU.csv --> No Excel Support

            # Kroll_MountedDevices.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_MountedDevices.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_MountedDevices.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_MountedDevices.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_MountedDevices.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_MountedDevices" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                    }
                }
            }

            # Kroll_NetworkAdapters.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_NetworkAdapters.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_NetworkAdapters.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_NetworkAdapters.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_NetworkAdapters.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_NetworkAdapters" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and D-G
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_OpenSavePidlMRU.csv --> No Excel Support

            # Kroll_Products.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_Products.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_Products.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_Products.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_Products.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_Products" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and D-H 
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:H"].Style.HorizontalAlignment="Center"

                    }
                }
            }

            # Kroll_ProfileList.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_ProfileList.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_ProfileList.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_ProfileList.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_ProfileList.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_ProfileList" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and D
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_RecentDocs.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_RecentDocs.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_RecentDocs.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_RecentDocs.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_RecentDocs.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_RecentDocs" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:I1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, C-D and F-I
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:I"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_Services.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_Services.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_Services.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_Services.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_Services.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_Services" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B, D and F-J
                    $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:J"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_Taskband.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_Taskband.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_Taskband.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_Taskband.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_Taskband.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_Taskband" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns D-E
                    $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_TaskCache.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_TaskCache.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_TaskCache.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_TaskCache.csv" -Delimiter "," | Sort-Object { $_.CreatedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_TaskCache.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_TaskCache" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-D and F-J
                    $WorkSheet.Cells["A:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:J"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_TimeZoneInfo.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_TimeZoneInfo.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_TimeZoneInfo.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_TimeZoneInfo.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_TimeZoneInfo.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_TimeZoneInfo" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of column D
                    $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                    # HorizontalAlignment "Left" of columnc C and E
                    $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Left"
                    $WorkSheet.Cells["E:E"].Style.HorizontalAlignment="Left"
                    }
                }
            }

            # Kroll_TrustedDocuments.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_TrustedDocuments.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_TrustedDocuments.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_TrustedDocuments.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_TrustedDocuments.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_TrustedDocuments" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, C and F
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_TypedURLs.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_TypedURLs.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_TypedURLs.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_TypedURLs.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_TypedURLs.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_TypedURLs" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and D-E
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_UnInstall.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_UnInstall.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_UnInstall.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_UnInstall.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_UnInstall.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_UnInstall" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, D and F-H
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:H"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_USB.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_USB.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_USB.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_USB.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_USB.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_USB" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and D-H
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:H"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_USBSTOR.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_USBSTOR.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_USBSTOR.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_USBSTOR.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_USBSTOR.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_USBSTOR" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-M
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:M"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_UserAccounts.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_UserAccounts.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_UserAccounts.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_UserAccounts.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_UserAccounts.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_UserAccounts" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:AE1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, C-O and Q-AE
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:O"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["Q:AE"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_UserAssist.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_UserAssist.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_UserAssist.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_UserAssist.csv" -Delimiter "," | Sort-Object { $_.LastExecuted -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_UserAssist.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_UserAssist" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns D-G
                    $WorkSheet.Cells["D:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_VolumeInfoCache.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_VolumeInfoCache.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_VolumeInfoCache.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_VolumeInfoCache.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_VolumeInfoCache.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_VolumeInfoCache" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-F
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_WindowsPortableDevices.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_WindowsPortableDevices.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_WindowsPortableDevices.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_WindowsPortableDevices.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_WindowsPortableDevices.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_WindowsPortableDevices" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-G
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # Kroll_WordWheelQuery.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_WordWheelQuery.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_WordWheelQuery.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\Kroll\CSV\PluginDetailFiles\Kroll_WordWheelQuery.csv" -Delimiter "," | Sort-Object { $_.LastWriteTimestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\Kroll\XLSX\PluginDetailFiles\Kroll_WordWheelQuery.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kroll_WordWheelQuery" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-F
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }
    }
    else
    {
        Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
    }
}

}

#endregion Kroll_Batch

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region LNK

Function LNK {

# Check if YARA exists
if (Test-Path "$yara64")
{
    # Get Start Time
    $StartTime_YARA = (Get-Date)

    # Simple YARA Scanner
    Write-Output "[Info]  Scanning for Windows Shortcut Files (LNK) w/ YARA [time-consuming task] ... "
    New-Item "$OUTPUT_FOLDER\LNK" -ItemType Directory -Force | Out-Null
    $LNKRule = "$SCRIPT_DIR\Rules\LNK.yar"
    & $yara64 -p 4 -r -f -w -N "$LNKRule" "$DriveLetter\forensic\ntfs" > "$OUTPUT_FOLDER\LNK\stdout.txt" 2> $null

    # -N   do not follow symlinks when scanning
    # -p   use the specified NUMBER of threads to scan a directory
    # -r   recursive search directories (follows symlinks)
    # -f   fast matching mode
    # -w   disable warnings

    # Get End Time
    $EndTime_YARA = (Get-Date)

    # Scan Duration
    $Time_YARA = ($EndTime_YARA-$StartTime_YARA)
    '[Info]  YARA scan duration: {0:hh} h {0:mm} min {0:ss} sec' -f ($Time_YARA)
    
    ('YARA Scan duration:            {0} h {1} min {2} sec' -f $Time_YARA.Hours, $Time_YARA.Minutes, $Time_YARA.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

    # Stats
    if ((Test-Path "$OUTPUT_FOLDER\LNK\stdout.txt") -And ((Get-Item "$OUTPUT_FOLDER\LNK\stdout.txt").length -gt 0kb))
    {
        Get-Content "$OUTPUT_FOLDER\LNK\stdout.txt" | ForEach-Object{($_ -split "LNK ")[-1]} > "$OUTPUT_FOLDER\LNK\LNK-Files.txt"
        Remove-Item "$OUTPUT_FOLDER\LNK\stdout.txt" -Force
        $Count = [string]::Format('{0:N0}',(Get-Content "$OUTPUT_FOLDER\LNK\LNK-Files.txt" | Measure-Object –Line).Lines)
        Write-Host "[Info]  $Count SHLLINK artifacts found"
    }

    # lnk_parser
    if (Test-Path "$lnk_parser")
    {
        if (Test-Path "$entropy")
        {
            Write-Output "[Info]  Parsing SHLLINK artifacts (LNK) w/ lnk_parser ... "
            New-Item "$OUTPUT_FOLDER\LNK\lnk_parser\CSV" -ItemType Directory -Force | Out-Null
            $LNK_LIST = Get-Content "$OUTPUT_FOLDER\LNK\LNK-Files.txt"

            # Add CSV Header
            Write-Output '"target_full_path","target_modification_time","target_access_time","target_creation_time","target_size","target_hostname","lnk_full_path","lnk_modification_time","lnk_access_time","lnk_creation_time"' | Out-File "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser.csv"

            ForEach( $LNK_FILE in $LNK_LIST )
            {
                & $lnk_parser -p $LNK_FILE --output-format csv --no-headers | Out-File "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser.csv" -Append
            }

            # Custom CSV (for Hunting Malicious LNK Files)
            $LNK_LIST | Foreach-Object {

                $File = $_
                $MD5 = Get-FileHash "$File" -Algorithm MD5 -ErrorAction SilentlyContinue
                $SHA1 = Get-FileHash "$File" -Algorithm SHA1 -ErrorAction SilentlyContinue
                $SHA256 = Get-FileHash "$File" -Algorithm SHA256 -ErrorAction SilentlyContinue
                $FileInfo = Get-Item -Force "$File" -ErrorAction SilentlyContinue
                $LNK_PARSER_JSON = (& $lnk_parser -p $File --output-format json | ConvertFrom-Json)
                $full_path = $LNK_PARSER_JSON | Select-Object @{Name="full_path"; Expression={$_.lnk_file_metadata.full_path}}
                $lnk_modification_time = $LNK_PARSER_JSON | Select-Object @{Name="lnk_modification_time"; Expression={$_.lnk_file_metadata.mtime}}
                $lnk_access_time = $LNK_PARSER_JSON | Select-Object @{Name="lnk_access_time"; Expression={$_.lnk_file_metadata.atime}}
                $lnk_creation_time = $LNK_PARSER_JSON | Select-Object @{Name="lnk_creation_time"; Expression={$_.lnk_file_metadata.ctime}}
                $LocalBasePath = $LNK_PARSER_JSON | Select-Object @{Name="local_base_path"; Expression={$_.link_info.local_base_path}}
                $HotKey = $LNK_PARSER_JSON | Select-Object @{Name="hot_key"; Expression={$_.shell_link_header.hot_key}}
                $FileEntropy = & $entropy "$File" | ForEach-Object{($_ -split "\s+")[0]}

                New-Object -TypeName PSObject -Property @{
                    "LNK Full Path" = $full_path.full_path
                    "LNK Modification Time" = $lnk_modification_time.lnk_modification_time
                    "LNK Access Time" = $lnk_access_time.lnk_access_time
                    "LNK Creation Time" = $lnk_creation_time.lnk_creation_time
                    "Target Full Path" = $LNK_PARSER_JSON.target_full_path
                    "Working Directory" = $LNK_PARSER_JSON.working_dir
                    "Arguments" = $LNK_PARSER_JSON.command_line_arguments
                    "Relative Path" = $LNK_PARSER_JSON.relative_path
                    "Icon Location" = $LNK_PARSER_JSON.icon_location
                    "Local Base Path" = $LocalBasePath.local_base_path
                    "Shortcut Key" = $HotKey.hot_key
                    "LNK Size" = $FileInfo.Length
                    MD5 = $MD5.Hash
                    SHA1 = $SHA1.Hash
                    SHA256 = $SHA256.Hash
                    Entropy = $FileEntropy
                }
            } | Select-Object "LNK Full Path","LNK Modification Time","LNK Access Time","LNK Creation Time","Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | ConvertTo-Csv -NoTypeInformation -Delimiter "," | Out-File "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv"

            # XLSX

            # Check if PowerShell module 'ImportExcel' exists
            if (Get-Module -ListAvailable -Name ImportExcel) 
            {
                # lnk_parser.csv
                if (Test-Path "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser.csv") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\LNK\lnk_parser\XLSX" -ItemType Directory -Force | Out-Null
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser.csv" -Delimiter "," | Select-Object "target_full_path",@{Name='target_modification_time';Expression={([datetime]$_."target_modification_time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='target_access_time';Expression={([datetime]$_."target_access_time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='target_creation_time';Expression={([datetime]$_."target_creation_time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},target_size,target_hostname,lnk_full_path,@{Name='lnk_modification_time';Expression={([datetime]$_."lnk_modification_time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='lnk_access_time';Expression={([datetime]$_."lnk_access_time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='lnk_creation_time';Expression={([datetime]$_."lnk_creation_time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}}
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\lnk_parser\XLSX\lnk_parser.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "lnk_parser" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:J1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-D, F and H-J
                        $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["H:J"].Style.HorizontalAlignment="Center"
                        # HorizontalAlignment "Center" of header of column E
                        $WorkSheet.Cells["E1:E1"].Style.HorizontalAlignment="Center"
                        }
                    }
                }

                # lnk_parser-hunt.csv
                # https://attack.mitre.org/techniques/T1547/009/
                if (Test-Path "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\LNK\lnk_parser\XLSX" -ItemType Directory -Force | Out-Null
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\lnk_parser\XLSX\lnk_parser-hunt.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "lnk_parser-hunt" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-D, K and L-P
                        $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
        }
        else
        {
            Write-Host "[Error] entropy.exe NOT found." -ForegroundColor Red
        }
    }
    else
    {
        Write-Host "[Error] lnk_parser_x86_64.exe NOT found." -ForegroundColor Red
    }
}
else
{
    Write-Host "[Error] yara64.exe NOT found." -ForegroundColor Red
}

}

Function LNK_Hunt {

# Hunting Malicious LNK Files
# https://attack.mitre.org/techniques/T1547/009/
if (Test-Path "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv")
{
    if([int](& $xsv count "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv") -gt 0)
    {
        New-Item "$OUTPUT_FOLDER\LNK\Hunt\CSV" -ItemType Directory -Force | Out-Null
        New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX" -ItemType Directory -Force | Out-Null

        # Target Full Path (lnk_parser)

        # Target Full Path: C:\Google\AutoIt3.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Google\\AutoIt3\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using AutoIt3.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-AutoIt3.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-AutoIt3.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-AutoIt3.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-AutoIt3.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-AutoIt3.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "AutoIt3.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }
 
        # Target Full Path: C:\Windows\System32\cmd.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\cmd\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using cmd.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-cmd.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-cmd.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-cmd.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-cmd.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-cmd.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "cmd.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Target FUll Path: C:\Windows\System32\mshta.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\mshta\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using mshta.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-mshta.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-mshta.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-mshta.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-mshta.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-mshta.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "mshta.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Target Full Path: C:\Windows\System32\msiexec.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\msiexec\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
        
        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using msiexec.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-msiexec.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-msiexec.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-msiexec.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-msiexec.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-msiexec.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "msiexec.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Target Full Path: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\WindowsPowerShell\\v1\.0\\powershell\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using powershell.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-powershell.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-powershell.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-powershell.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-powershell.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-powershell.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "powershell.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Target Full Path: C:\Windows\System32\rundll32.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\rundll32\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using rundll32.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-rundll32.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-rundll32.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-rundll32.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-rundll32.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-rundll32.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "rundll32.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Target Full Path: C:\Windows\System32\schtasks.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\schtasks\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using schtasks.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-schtasks.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-schtasks.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-schtasks.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-schtasks.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-schtasks.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "schtasks.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Target Full Path: C:\Windows\System32\wscript.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\wscript\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using wscript.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-wscript.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-wscript.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-wscript.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-wscript.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-wscript.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "wscript.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Arguments

        # Long Argument (more than 50 characters)
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {(($_."Arguments").Length -gt "50")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) w/ Long Argument detected [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Argument.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Argument.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Argument.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Argument.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments\Arguments-Long-Argument.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Long Argument" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Long Whitespace (more than 3 characters)
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Arguments" -match "\s{3,}")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) w/ Long Whitespace detected [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Whitespace.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Whitespace.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Whitespace.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Whitespace.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments\Arguments-Long-Whitespace.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Long Whitespace" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Windows shortcut file (LNK) contains suspicious strings: http://
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Arguments" -match "http://")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Windows shortcut file (LNK) contains suspicious strings: http:// [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-http.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-http.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-http.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-http.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments\Arguments-Suspicious-Strings-CommandLine-http.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "http" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Windows shortcut file (LNK) contains suspicious strings: https://
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Arguments" -match "https://")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Windows shortcut file (LNK) contains suspicious strings: https:// [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-https.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-https.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-https.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-https.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments\Arguments-Suspicious-Strings-CommandLine-https.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "https" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Relative Path

        # Long Relative Path
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Relative Path" -match "\.\.\\\.\.\\\.\.\\\.\.\\\.\.\\")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) w/ Long Relative Path detected [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\RelativePath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\RelativePath-Long-Relative-Path.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\RelativePath-Long-Relative-Path.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\RelativePath-Long-Relative-Path.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\RelativePath-Long-Relative-Path.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\RelativePath\RelativePath-Long-Relative-Path.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Long Relative Path" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Misc

        # Suspicious LNK Size
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {([int]$_."LNK Size" -gt "1000")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File Size detected [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Misc" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-LNK-Size.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-LNK-Size.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-LNK-Size.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-LNK-Size.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Misc\Misc-Suspicious-LNK-Size.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Suspicious LNK Size" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Suspicious High Entropy (equal or higher than 6.5)
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {([int]$_."Entropy" -ge "6.5")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) w/ High Entropy detected [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Misc" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-High-Entropy.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-High-Entropy.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-High-Entropy.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-High-Entropy.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Misc\Misc-Suspicious-High-Entropy.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "High Entropy" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }
    }
}

}

#endregion LNK

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Modules

# Status: Experimental
# The recovered files are often partial. Often the metadata isn't yet read into memory (it's read on-demand on first use from disk) or paged out. File hashes are more or less useless since you'll never recover the whole file from memory.
# But it seems that in some cases it's working better than expected and helps you to find evil.

# https://github.com/ufrisk/MemProcFS/wiki/FS_Process_Modules

Function Modules {

# Get Start Time
$StartTime_Modules = (Get-Date)

# Modules
Write-Host "[Info]  Analyzing Reconstructed Process Modules ... "
New-Item "$OUTPUT_FOLDER\sys\modules\CSV" -ItemType Directory -Force | Out-Null

if (!(Test-Path "$entropy"))
{
    Write-Host "[Error] entropy.exe NOT found." -ForegroundColor Red
}

$Modules = Get-ChildItem -Path "$DriveLetter\pid\*\modules\*.exe\pefile.dll" | ForEach-Object { $_.FullName } # lsass.exe.exe --> StackOverflowException (themida.img)
$Modules | Out-File "$OUTPUT_FOLDER\sys\modules\Modules-List.txt"

$Modules | Foreach-Object {

    $File = $_
    $FileInfo = Get-Item -Force "$File" -ErrorAction SilentlyContinue
    $Length = $FileInfo.Length

    if ($Length -ne "0")
    {
        $MD5 = Get-FileHash "$File" -Algorithm MD5 -ErrorAction SilentlyContinue
        $SHA1 = Get-FileHash "$File" -Algorithm SHA1 -ErrorAction SilentlyContinue
        $SHA256 = Get-FileHash "$File" -Algorithm SHA256 -ErrorAction SilentlyContinue
    }
    else
    {
        $MD5 = ""
        $SHA1 = ""
        $SHA256 = ""
    }

    $ProcessId = $File | ForEach-Object{($_ -split "\\")[2]}
    $FullPath = $File.Replace("pefile.dll", "fullname.txt")
    $ImagePath = Get-Content -Path $FullPath
    $FileName = Split-Path $ImagePath -Leaf
    $InternalName = $FileInfo.VersionInfo.InternalName
    $OriginalFileName = $FileInfo.VersionInfo.OriginalFileName
    $FileDescription = $FileInfo.VersionInfo.FileDescription
    $CompanyName = $FileInfo.VersionInfo.CompanyName
    $FileVersion = $FileInfo.VersionInfo.FileVersion
    $Language = $FileInfo.VersionInfo.Language
    $ProductName = $FileInfo.VersionInfo.ProductName

    if (Test-Path "$entropy")
    {
        $FileEntropy = & $entropy "$File" | ForEach-Object{($_ -split "\s+")[0]}
    }
    else
    {
        $FileEntropy = ""
    }

    $LastAccessTimeUtc = $FileInfo.LastAccessTimeUtc

    # CSV
    New-Object -TypeName PSObject -Property @{
        "File Name"         = $FileName
        "PID"               = $ProcessId
        "Internal Name"     = $InternalName
        "Original FileName" = $OriginalFileName
        "File Description"  = $FileDescription
        "Image Path"        = $ImagePath
        "File Version"      = $FileVersion
        "Company Name"      = $CompanyName
        "Product Name"      = $ProductName
        "Language"          = $Language
        "Bytes"             = $Length
        "File Size"         = Get-FileSize($Length)
        "File Path"         = $File
        "MD5"               = $MD5.Hash
        "SHA1"              = $SHA1.Hash
        "SHA256"            = $SHA256.Hash
        "Entropy"           = $FileEntropy
        "Last Access Time"  = $LastAccessTimeUtc
    }
} | Select-Object "File Name","PID","Internal Name","Original FileName","File Description","Image Path","File Version","Company Name","Product Name","Language","Bytes","File Size","File Path","Entropy","Last Access Time","MD5","SHA1","SHA256" | ConvertTo-Csv -NoTypeInformation -Delimiter "," | Out-File "$OUTPUT_FOLDER\sys\modules\CSV\modules-untouched.csv" -Encoding UTF8

# Whitelist
if (Test-Path "$OUTPUT_FOLDER\sys\modules\CSV\modules-untouched.csv")
{
    if([int](& $xsv count "$OUTPUT_FOLDER\sys\modules\CSV\modules-untouched.csv") -gt 0)
    {
        # Exclude 0-Byte Files
        $Data = Get-Content "$OUTPUT_FOLDER\sys\modules\CSV\modules-untouched.csv" | ConvertFrom-Csv
        $Data | Where-Object {$_."Image Path" -notmatch  "\\SystemRoot\\system32\\ntoskrnl\.exe"} | Where-Object {$_."Bytes" -notmatch  "^0"} | Export-Csv "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv" -NoTypeInformation -Encoding UTF8

        # Count
        [int]$Total = & $xsv count "$OUTPUT_FOLDER\sys\modules\CSV\modules-untouched.csv"
        [int]$Cleaned = & $xsv count "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv"
        Write-Output "[Info]  $Cleaned Reconstructed Process Modules found ($Total)"
    }
    else
    {
        Write-Output "[Info]  No Reconstructed Process Modules found"
    }
}

# Check if PowerShell module 'ImportExcel' exists
if (Get-Module -ListAvailable -Name ImportExcel) 
{
    # XLSX
    if (Test-Path "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv")
    {
        if((Get-Item "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv").length -gt 0kb)
        {
            New-Item "$OUTPUT_FOLDER\sys\modules\XLSX" -ItemType Directory -Force | Out-Null
            $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv" -Delimiter ","
            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\modules\XLSX\modules.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Modules" -CellStyleSB {
            param($WorkSheet)
            # BackgroundColor and FontColor for specific cells of TopRow
            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
            Set-Format -Address $WorkSheet.Cells["A1:R1"] -BackgroundColor $BackgroundColor -FontColor White
            # HorizontalAlignment "Center" of columns A-B, G-J and N-R
            $WorkSheet.Cells["A:B"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["G:J"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["N:R"].Style.HorizontalAlignment="Center"
            # HorizontalAlignment "Right" of columns K-L
            $WorkSheet.Cells["K:L"].Style.HorizontalAlignment="Right"
            # HorizontalAlignment "Center" of header of columns K-L
            $WorkSheet.Cells["K1:L1"].Style.HorizontalAlignment="Center"

            # Threat Hunting

            # Fields are missing / empty (W/ Rule Priority)

            # "Internal Name" and "Original FileName" and "File Description" and "Company Name" --> Red
            $HighColor = [System.Drawing.Color]::FromArgb(255,0,0)
            Add-ConditionalFormatting -Address $WorkSheet.Dimension.Address -WorkSheet $WorkSheet -RuleType 'Expression' '=AND($C1="",$D1="",$E1="",$H1="")' -BackgroundColor $HighColor
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv" -Delimiter "," | Where-Object {(($_."Internal Name" -eq "") -and ($_."Original FileName" -eq "") -and ($_."File Description" -eq "") -and ($_."Company Name" -eq ""))}
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Missing Internal Name, Original FileName, File Description, and Company Name detected [Modules] (Count: $Count)" -ForegroundColor Red
            }

            # "File Description" or "Company Name": Empty --> Orange
            $MediumColor = [System.Drawing.Color]::FromArgb(255,192,0)
            Add-ConditionalFormatting -Address $WorkSheet.Dimension.Address -WorkSheet $WorkSheet -RuleType 'Expression' '=OR($E1="",$H1="")' -BackgroundColor $MediumColor
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv" -Delimiter "," | Where-Object {(($_."File Description" -eq "") -or ($_."Company Name" -eq ""))}
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Missing File Description and/or Company Name detected [Modules] (Count: $Count)" -ForegroundColor Yellow
            }

            # "Internal Name" or "Original FileName": Empty --> Yellow
            $LowColor = [System.Drawing.Color]::FromArgb(255,255,0)
            Add-ConditionalFormatting -Address $WorkSheet.Dimension.Address -WorkSheet $WorkSheet -RuleType 'Expression' '=OR($C1="",$D1="")' -BackgroundColor $LowColor
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv" -Delimiter "," | Where-Object {(($_."Internal Name" -eq "") -or ($_."Original FileName" -eq ""))}
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Missing Internal Name and/or Original FileName detected [Modules] (Count: $Count)" -ForegroundColor Yellow
            }

            # Mismatch on Original FileName
            $LowColor = [System.Drawing.Color]::FromArgb(255,255,0)
            $LastRow = $WorkSheet.Dimension.End.Row
            Add-ConditionalFormatting -Address $WorkSheet.Cells["D2:D$LastRow"] -WorkSheet $WorkSheet -RuleType 'Expression' -ConditionValue '=$A2<>$D2' -BackgroundColor $LowColor
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv" -Delimiter "," | Where-Object {($_."File Name" -notlike $_."Original FileName")}
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Mismatch on Original FileName detected [Modules] (Count: $Count)" -ForegroundColor Yellow
            }

            }
        }
    }
}

# Get End Time
$EndTime_Modules = (Get-Date)

# Processing Duration
$Time_Modules = ($EndTime_Modules-$StartTime_Modules)
('Modules Analysis duration:     {0} h {1} min {2} sec' -f $Time_Modules.Hours, $Time_Modules.Minutes, $Time_Modules.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

}

#endregion Modules

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region CobaltStrike

Function Invoke-1768 {

# 1768.py v.0.0.16 (2022-08-27)
# https://blog.didierstevens.com/?s=1768.py
if ((Test-Path "$SCRIPT_DIR\Scripts\1768\1768.py") -and (Test-Path "$SCRIPT_DIR\Scripts\1768\1768.json"))
{
    # Current version
    New-Item "$OUTPUT_FOLDER\CobaltStrike\1768" -ItemType Directory -Force | Out-Null
    python "$SCRIPT_DIR\Scripts\1768\1768.py" --version > "$OUTPUT_FOLDER\CobaltStrike\1768\Version.txt" 2> $null

    # Get Start Time
    $StartTime_1768 = (Get-Date)

    # Searching for Cobalt Strike Beacons Configuration(s) w/ 1768.py
    Write-Output "[Info]  Searching for Cobalt Strike Beacons Configuration(s) w/ 1768.py ..."
    python "$SCRIPT_DIR\Scripts\1768\1768.py" -S $MemoryDump -o "$OUTPUT_FOLDER\CobaltStrike\1768\1768.txt" 2> $null

    # Get End Time
    $EndTime_1768 = (Get-Date)

    # Scan Duration
    $Time_1768 = ($EndTime_1768-$StartTime_1768)
    ('1768 Scan duration:            {0} h {1} min {2} sec' -f $Time_1768.Hours, $Time_1768.Minutes, $Time_1768.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

    if (Test-Path "$OUTPUT_FOLDER\CobaltStrike\1768\1768.txt")
    {
        if (Get-Content -Path "$OUTPUT_FOLDER\CobaltStrike\1768\1768.txt" | Select-String -Pattern "Sanity check Cobalt Strike config: OK" -Quiet)
        {
            Write-Host "[Alert] Cobalt Strike Beacons Configuration found" -ForegroundColor Red
        }
    }
}

}

#endregion CobaltStrike

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region SecureArchive

Function SecureArchive {

# Get End Time
$EndTime_Processing = (Get-Date)

# Total Processing Duration
$Time_Processing = ($EndTime_Processing-$StartTime_Processing)
('Total Processing duration:     {0} h {1} min {2} sec' -f $Time_Processing.Hours, $Time_Processing.Minutes, $Time_Processing.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

# Creating Secure Archive
if (Test-Path "$7za") 
{
    if (Test-Path "$OUTPUT_FOLDER") 
    {
        Write-Output "[Info]  Preparing Secure Archive Container ... "
        & $7za a -mx5 -mhe "-p$PASSWORD" -t7z "$OUTPUT_FOLDER.7z" "$OUTPUT_FOLDER\*" > $null 2>&1
    }

    # Archive Size
    $Length = (Get-Item -Path "$OUTPUT_FOLDER.7z").Length
    $Size = Get-FileSize($Length)
    Write-Output "[Info]  Archive Size: $Size"

    # Cleaning up
    if (Test-Path "$OUTPUT_FOLDER")
    {
        Get-ChildItem -Path "$OUTPUT_FOLDER" -Recurse | Remove-Item -Force -Recurse
        Remove-Item "$OUTPUT_FOLDER" -Force
    }
}
else
{
    Write-Host "[Error] 7za.exe NOT found." -ForegroundColor Red
}

}

#endregion SecureArchive

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Footer

Function Footer {

# Shutting Down (Unmount)
if (Get-Process -Name "MemProcFS" -ErrorAction SilentlyContinue)
{
    # MessageBox UI
    $Form = New-Object System.Windows.Forms.Form
    $Form.TopMost = $true
    $MessageBody = "Happy Hunting!`n`nMemProcFS - The Memory Process File System by Ulf Frisk`nhttps://github.com/ufrisk/MemProcFS`n`nPress OK to shutdown virtual file system (Unmount)`n`nNote: Elasticsearch will also be stopped."
    $MessageTitle = "MemProcFS-Analyzer.ps1 (https://lethal-forensics.com/)"
    $ButtonType = "OK"
    $MessageIcon = "Info"
    $Result = [System.Windows.Forms.MessageBox]::Show($Form, $MessageBody, $MessageTitle, $ButtonType, $MessageIcon)

    if ($Result -eq "OK" ) 
    {
        Write-Output "[Info]  Shutting Down (Unmount) ..."
        Start-Sleep -Seconds 1

        # MemProcFS
        [void][System.Reflection.Assembly]::LoadWithPartialName("'Microsoft.VisualBasic")
        [void][System.Reflection.Assembly]::LoadWithPartialName("'System.Windows.Forms")
        $Process = Get-Process | Where-Object {$_.Name -eq "MemProcFS"}
        [Microsoft.VisualBasic.Interaction]::AppActivate($Process.Id)
        [System.Windows.Forms.SendKeys]::SendWait("^{c}")

        # Kibana
        if ($Kibana_Termination)
        {
            $Kibana_Termination.CloseMainWindow() > $null
        }

        # Elasticsearch
        if ($Elasticsearch_Termination)
        {
            $Elasticsearch_Termination.CloseMainWindow() > $null
        }

        # Wait for MemProcFS to shut down properly before exiting MemProcFS-Analyzer
        while(@(Get-Process | Where-Object {$_.Name -eq "MemProcFS"}).Count -gt 0) {
            Start-Sleep -Milliseconds 100
        }

        Start-Sleep -Seconds 1
    }
}

# Get End Time
$EndTime_Analysis = (Get-Date)

# Overall Analysis Duration
Write-Output ""
Write-Output "FINISHED!"
$Time_Analysis = ($EndTime_Analysis-$StartTime_Analysis)
$ElapsedTime_Analysis = ('Overall analysis duration: {0} h {1} min {2} sec' -f $Time_Analysis.Hours, $Time_Analysis.Minutes, $Time_Analysis.Seconds)
Write-Output "$ElapsedTime_Analysis"

# Stop logging
Write-Output ""
Stop-Transcript

# Reset Progress Preference
$Global:ProgressPreference = $OriginalProgressPreference

# Set Windows Title back to default
$Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"

}

#endregion Footer

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Main

# Main
Header
Updater
#Elasticsearch
MicrosoftDefender
MemProcFS
#ELKImport
ClamAVUpdate
ClamAV
Documents
KrollBatch
#LNK
#LNK_Hunt
Modules
#Invoke-1768
SecureArchive
Footer

#endregion Main
```

`README.md`:

```md
# MemProcFS-Analyzer
MemProcFS-Analyzer.ps1 is a PowerShell script utilized to simplify the usage of MemProcFS and to optimize your memory analysis workflow.

MemProcFS - The Memory Process File System by [Ulf Frisk](https://twitter.com/ulffrisk)  
https://github.com/ufrisk/MemProcFS  

Features:
* Fast and easy memory analysis!
* You can mount a Raw Physical Memory Dump like a disk image and handle the memory compression feature on Windows
* Auto-Install of MemProcFS, AmcacheParser, AppCompatCacheParser, Elasticsearch, entropy, EvtxECmd, ImportExcel, IPinfo CLI, jq, Kibana, lnk_parser, RECmd, SBECmd, xsv, YARA, and Zircolite  
* Auto-Update of MemProcFS, AmcacheParser, AppCompatCacheParser, Elasticsearch, entropy, EvtxECmd (incl. Maps), ImportExcel, IPinfo CLI, jq, Kibana, lnk_parser, RECmd, SBECmd, xsv, YARA, and Zircolite   
* Update-Info when there's a new version of ClamAV or a new Dokany File System Library Bundle available  
* Pagefile Support
* OS Fingerprinting  
* Multi-Threaded scan w/ ClamAV for Windows  
* Collection of infected files detected by ClamAV for further analysis (PW: infected)
* Collection of injected modules detected by MemProcFS PE_INJECT for further analysis (PW: infected)
* Extracting IPv4/IPv6  
* IP2ASN Mapping and GeoIP w/ [IPinfo CLI](https://github.com/ipinfo/cli) &#8594; Get your token for free at [https://ipinfo.io/signup](https://ipinfo.io/signup)  
* Checking for Suspicious Port Numbers
* [Process Tree](https://github.com/evild3ad/MemProcFS-Analyzer/wiki/Process-Tree) (TreeView) including complete Process Call Chain (Special thanks to [Dominik Schmidt](https://github.com/DaFuqs))
* Checking Processes for Unusual Parent-Child Relationships and Number of Instances  
* Checking Processes for Unusual User Context
* Checking for Process Path Masquerading and Process Name Masquerading (Damerau Levenshtein Distance)
* Web Browser History (Google Chrome, Microsoft Edge and Firefox) 
* Extracting Windows Event Log Files and processing w/ EvtxECmd &#8594; Timeline Explorer ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman) 
* Event Log Overview  
* Processing Windows Event Logs w/ [Zircolite](https://github.com/wagga40/Zircolite) - A standalone SIGMA-based detection tool for EVTX
* Analyzing extracted Amcache.hve w/ Amcacheparser ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Analyzing Application Compatibility Cache aka ShimCache w/ AppCompatcacheParser ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Analyzing Syscache w/ RECmd ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Analyzing UserAssist Artifacts w/ RECmd ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Analyzing ShellBags Artifacts w/ RECmd ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Simple Prefetch View (based on Forensic Timeline)  
* Analyzing Auto-Start Extensibility Points (ASEPs) w/ RECmd ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Analyzing RecentDocs, Office Trusted Document w/ RECmd ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Analyzing Registry w/ Kroll RECmd Batch File ([Kroll Batch File](https://github.com/EricZimmerman/RECmd/projects/1) by Andrew Rathbun)  
* Analyzing Metadata of Recovered Process Modules (experimental)  
* Extracting Windows Shortcut Files (LNK)  
* Hunting Malicious Windows Shortcut Files (LNK)
* Integration of PowerShell module [ImportExcel](https://github.com/dfinke/ImportExcel) by Doug Finke
* CSV output data for analysis w/ Timeline Explorer (e.g. timeline-reverse.csv, findevil.csv, web.csv)  
* Collecting Evidence Files (Secure Archive Container &#8594; PW: MemProcFS)  
* and much more

## Download 
Download the latest version of **MemProcFS-Analyzer** from the [Releases](https://github.com/evild3ad/MemProcFS-Analyzer/releases) section.  

## Usage  
Launch Windows PowerShell (or Windows PowerShell ISE or Visual Studio Code w/ PSVersion: 5.1) as Administrator and open/run MemProcFS-Analyzer.ps1. 

![File-Browser](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/01.png)  
**Fig 1:** Select your Raw Physical Memory Dump and select your pagefile.sys (Optional)

![Auto-Install](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/02.png)  
**Fig 2:** MemProcFS-Analyzer auto-installs dependencies (First Run)

![Microsoft-Internet-Symbol-Store](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/03.png)  
**Fig 3:** Accept Terms of Use (First Run)  

![MemProcFS](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/04.png)  
**Fig 4:** If you find MemProcFS useful, please become a sponsor at: https://github.com/sponsors/ufrisk  

![Mounted](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/05.png)  
**Fig 5:** You can investigate the mounted memory dump by exploring drive letter X:

![Auto-Update](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/06.png)  
**Fig 6:** MemProcFS-Analyzer checks for updates (Second Run) 

Note: It's recommended to uncomment/disable the "Updater" function after installation. Check out the "Main" in the bottom of the script.

![FindEvil](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/07.png)  
**Fig 7:** FindEvil feature and additional analytics

![Processes](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/08.png)  
**Fig 8:** Processes

![RunningAndExited](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/09.png)  
**Fig 9:** Running and Exited Processes

![ProcessTree](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/10.png)  
**Fig 10:** Process Tree (GUI)

![ProcessTreeSearch](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/11.png)  
**Fig 11:** Checking Process Tree (to find anomalies)

![ProcessTreeAlerts](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/12.png)  
**Fig 12:** Process Tree: Alert Messages w/ Process Call Chain

![PropertiesView](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/13.png)  
**Fig 13:** Process Tree: Properties View &#8594; Double-Click on a process or alert message

![IPinfo](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/14.png)  
**Fig 14:** GeoIP w/ IPinfo.io

![MapReport](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/15.png)  
**Fig 15:** Map IPs w/ IPinfo.io

![EVTX](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/16.png)  
**Fig 16:** Processing Windows Event Logs (EVTX)

![Zircolite](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/17.png)  
**Fig 17:** Zircolite - A standalone SIGMA-based detection tool for EVTX (Mini-GUI)

![Amcache](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/18.png)  
**Fig 18:** Processing extracted Amcache.hve &#8594; XLSX  

![ShimCache](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/19.png)  
**Fig 19:** Processing ShimCache &#8594; XLSX  

![Timeline-Explorer](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/20.png)  
**Fig 20:** Analyze CSV output w/ Timeline Explorer (TLE)

![ELK-Import](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/21.png)  
**Fig 21:** ELK Import

![ELK-Timeline](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/22.png)  
**Fig 22:** Happy ELK Hunting!

![Secure-Archive-Container](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/23.png)  
**Fig 23:** Multi-Threaded ClamAV Scan to help you finding evil! ;-)

![Message-Box](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/24.png)  
**Fig 24:** Press **OK** to shutdown MemProcFS and Elastisearch/Kibana

![Output](https://github.com/evild3ad/MemProcFS-Analyzer/blob/8ff585672b7bbe689ad10080555f62dce2b0c06d/Screenshots/25.png)  
**Fig 25:** Secure Archive Container (PW: MemProcFS)  

## Introduction MemProcFS and Memory Forensics  
Check out [Super Easy Memory Forensics](https://www.slideshare.net/IIJ_PR/super-easy-memory-forensics) by [Hiroshi Suzuki](https://twitter.com/herosi_t) and [Hisao Nashiwa](https://twitter.com/unk0unk0).

## Prerequisites 
1. Download and install the latest Dokany Library Bundle &#8594; DokanSetup.exe  
https://github.com/dokan-dev/dokany/releases/latest  

2. Download and install the latest .NET 6 Desktop Runtime (Requirement for [EZTools](https://ericzimmerman.github.io/))  
https://dotnet.microsoft.com/en-us/download/dotnet/6.0   

3. Download and install the latest Windows package of ClamAV.  
https://www.clamav.net/downloads#otherversions 

4. First Time Set-Up of ClamAV  
Launch Windows PowerShell console as Administrator.  
`cd "C:\Program Files\ClamAV"`  
`copy .\conf_examples\freshclam.conf.sample .\freshclam.conf`  
`copy .\conf_examples\clamd.conf.sample .\clamd.conf`  
`write.exe .\freshclam.conf`  &#8594; Comment or remove the line that says "Example".  
`write.exe .\clamd.conf` &#8594; Comment or remove the line that says "Example".  
https://docs.clamav.net/manual/Usage/Configuration.html#windows  

5. Optimize ClamAV scan speed performance (30% faster)    
Open "C:\Program Files\ClamAV\clamd.conf" with your text editor and search for: "Don't scan files and directories matching regex"  
`ExcludePath "\\heaps\\"`  
`ExcludePath "\\handles\\"`  
`ExcludePath "\\memmap\\vad-v\\"`  
`ExcludePath "\\sys\\pool\\"`  

6. Create your free IPinfo account [approx. 1-2 min]  
https://ipinfo.io/signup?ref=cli  
Open "MemProcFS-Analyzer.ps1" with your text editor, search for "Please insert your Access Token here" and copy/paste your access token.

7. Install the NuGet package provider for PowerShell  
Check if NuGet is available in the package providers by running the following command:  
`Get-PackageProvider -ListAvailable`  
If NuGet is not installed on your system yet, you have to install it.  
`Install-PackageProvider -Name NuGet -Force`  

8. Done! :smiley:   

Notes: 
- Turn off your antivirus protection temporarily or better exclude your MemProcFS-Analyzer directory from scanning.  
- [Elasticsearch Tips](https://github.com/evild3ad/MemProcFS-Analyzer/wiki/Elasticsearch)

## Dependencies
7-Zip 22.01 Standalone Console (2022-07-15)  
https://www.7-zip.org/download.html  

AmcacheParser v1.5.1.0 (.NET 6)  
https://ericzimmerman.github.io/  

AppCompatCacheParser v1.5.0.0 (.NET 6)  
https://ericzimmerman.github.io/  

ClamAV - Download &#8594; Windows &#8594; clamav-1.0.0.win.x64.msi (2022-11-23)  
https://www.clamav.net/downloads    

Dokany Library Bundle v2.0.6.1000 (2022-10-02)  
https://github.com/dokan-dev/dokany/releases/latest &#8594; DokanSetup.exe  

Elasticsearch 8.6.0 (2023-01-10)  
https://www.elastic.co/downloads/elasticsearch  

entropy v1.0 (2022-02-04)  
https://github.com/merces/entropy  

EvtxECmd v1.0.0.1 (.NET 6)  
https://ericzimmerman.github.io/  

ImportExcel v7.8.4 (2022-12-11)  
https://github.com/dfinke/ImportExcel  

IPinfo CLI 2.10.0 (2022-09-28)  
https://github.com/ipinfo/cli  

jq v1.6 (2019-11-02)  
https://github.com/stedolan/jq  

Kibana 8.6.0 (2023-01-10)  
https://www.elastic.co/downloads/kibana  

lnk_parser v0.2.0 (2022-08-10)  
https://github.com/AbdulRhmanAlfaifi/lnk_parser  

MemProcFS v5.3.0 - The Memory Process File System (2023-01-19)  
https://github.com/ufrisk/MemProcFS  

RECmd v2.0.0.0 (.NET 6)  
https://ericzimmerman.github.io/  

SBECmd v2.0.0.0 (.NET 6)  
https://ericzimmerman.github.io/  

xsv v0.13.0 (2018-05-12)  
https://github.com/BurntSushi/xsv  

YARA v4.2.3 (2022-08-09)  
https://virustotal.github.io/yara/  

Zircolite v2.9.7 (2022-10-08)  
https://github.com/wagga40/Zircolite  

## Links
[MemProcFS](https://github.com/ufrisk/MemProcFS)  
[Demo of MemProcFS with Elasticsearch](https://www.youtube.com/watch?v=JcIlowlrvyI)  
[Sponsor MemProcFS Project](https://github.com/sponsors/ufrisk)  
[MemProcFS-Plugins](https://github.com/ufrisk/MemProcFS-Plugins)  
[SANS FOR532 - Enterprise Memory Forensics In-Depth](https://www.sans.org/cyber-security-courses/enterprise-memory-forensics-in-depth/)  

```

`Rules/LNK.yar`:

```yar
rule LNK
{
	meta:
		author = "Martin Willing (https://evild3ad.com)"
		description = "Detects Windows Shortcut File (LNK)"
		date = "2021-04-05"
		filetype = "File System Scan"

	condition:
	 	uint16(0) == 0x004c and uint32(4) == 0x00021401 // Header Magic (LNK)
        and filesize < 2MB
}
```

`Scripts/1768/1768.json`:

```json
{
    "dLookupValues": {
                         "LASTUPDATE": "2022/08/27",
                         "URL": "https://www.cobaltstrike.com/help-authorization-files",
                         "37": {
																	"0": "trial or pirated? - Stats uniques -> ips/hostnames: 676 publickeys: 410",
																	"1": "Finspy - Stats uniques -> ips/hostnames: 26 publickeys: 19",
																	"100000": "Stats uniques -> ips/hostnames: 11 publickeys: 11",
																	"1011266395": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"1061821957": "Stats uniques -> ips/hostnames: 4 publickeys: 1",
																	"1083092832": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
																	"1200302529": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"1225345476": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"1234567890": "Stats uniques -> ips/hostnames: 178 publickeys: 152",
																	"1293900656": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"1330515036": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
																	"1359593325": "TrickBot/SmokeLoader/Nobelium/APT29 - Stats uniques -> ips/hostnames: 228 publickeys: 160",
																	"1360912112": "Stats uniques -> ips/hostnames: 3 publickeys: 3",
																	"1453642741": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"1485646134": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"153163702": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"1548680553": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"1580103814": "APT27/Qbot/IcedID/DarkSide/Conti/Hancitor/WizardSpider - Stats uniques -> ips/hostnames: 80 publickeys: 34",
																	"1580103824": "Stats uniques -> ips/hostnames: 210 publickeys: 92",
																	"1616449647": "Stats uniques -> ips/hostnames: 3 publickeys: 2",
																	"1628610335": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
																	"16777216": "Ryuk - Stats uniques -> ips/hostnames: 19 publickeys: 19",
																	"1711276032": "Stats uniques -> ips/hostnames: 18 publickeys: 15",
																	"1807886020": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
																	"1857223080": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"1873433027": "TA511/Hancitor - Stats uniques -> ips/hostnames: 35 publickeys: 28",
																	"1880445158": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"1895490765": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"1914732777": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"2002705334": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
																	"206546002": "Stats uniques -> ips/hostnames: 45 publickeys: 23",
																	"2091175951": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
																	"289336829": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"294598720": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
																	"305419776": "Stats uniques -> ips/hostnames: 49 publickeys: 19",
																	"305419896": "Ryuk/TrickBot/Maze/EvilCorp/Pyxie/APT41 - Stats uniques -> ips/hostnames: 269 publickeys: 172",
																	"388888888": "Stats uniques -> ips/hostnames: 5 publickeys: 5",
																	"401466503": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"426352781": "Stats uniques -> ips/hostnames: 267 publickeys: 207",
																	"472168751": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
																	"475294171": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"508419252": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
																	"540231004": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"555758901": "Stats uniques -> ips/hostnames: 3 publickeys: 2",
																	"571338205": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"582298219": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"6": "Stats uniques -> ips/hostnames: 13 publickeys: 12",
																	"666": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
																	"666104495": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"666666": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
																	"680943040": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
																	"697620223": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"707557615": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"775423106": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"77771151": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
																	"804449981": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
																	"863200806": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"8848": "Stats uniques -> ips/hostnames: 8 publickeys: 8",
																	"9527": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
																	"96906161": "Stats uniques -> ips/hostnames: 4 publickeys: 1",
																	"452436291": "REvil/Sodin/Sodinokibi - No stats",
																	"3": "Cobalt Group - No stats",
																	"849087011": "SolarStorm - No stats",
																	"892810033": "Teardrop/SolarStorm - No stats"
                               },
                         "7": {
                                  "30819f300d06092a864886f70d010101050003818d003081890281810080fa8dc59ec39b73d49523c640c1cdfabbb0f0b15e943f2429c0c360862c938fb474523a0116f2ea71877f24218fc85cd959017cd0f987ec443a731a4d29a7a8fe1312d2edace8a736515d120c8f7b5e0008b7403ee3511435367f223c474ec2c0913c1dede6c1124b5089dc2aec3ef37ce24009a590ef4b8398f52e75c1f2ed020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820275020100300d06092a864886f70d01010105000482025f3082025b0201000281810080fa8dc59ec39b73d49523c640c1cdfabbb0f0b15e943f2429c0c360862c938fb474523a0116f2ea71877f24218fc85cd959017cd0f987ec443a731a4d29a7a8fe1312d2edace8a736515d120c8f7b5e0008b7403ee3511435367f223c474ec2c0913c1dede6c1124b5089dc2aec3ef37ce24009a590ef4b8398f52e75c1f2ed02030100010281800d789de81f1df515930584b8073976c7126577ae3edfa2fca6f3c0344baf4a363f35cb04cdea54b2d1eac207c70d9a72c02cc0b005af9a57be0490d3156e1d59ac7837c74987a296671f4264781050d39ccc16f5f5024699fe6f3aad9b77e874117e213b369ef6c58c43a4423585db42eb022251914f3110b52532620fe82dad024100f6c00bf6a8e14566029cfdfef39a77c50511056f235a0dc71b46c5d5b17b6494c290496a3d76635d5ae21f615bc5e04e2a2a2001957fec6b3ce88c0ca9a36aaf02410085d04e59788f32150b4039fc0140fa06a66181cb463cdec2d573111e8904fd4aadffa63e8f2f2063c7e212bef5981c1ed2ff6f1163a04662d483067658ceb32302403b44035b9a528935a83906f4be9402626b061c95061bb2257992b51fcf8240b54e4a13a815dd229ea09ea144e42311ee14488be9757c054ff8902e5b383f8cf702407fcd78d74926f2bd58968a0adf23b0e8a30623d2028e666f8d2fae1d0cdec010106947dd1e21f37c794eb97abad4019f8b043d8f4d28a9b100a8f78616c1ac2302403e247b8970b1e457b2c82759d3427a24edfa7d309a4a619ebfcab16cb2593a67564fe7c4d68b73958f856831e9fe1d4ba2ec4281234a2a903b4b07a50084b3d5"},
                                  "30819f300d06092a864886f70d010101050003818d003081890281810084a5630da30447225f084704e282f6bea8bbb0a7043c30d0a85a0ab530d500ab7eb4e76eb6625ff6d65aae874aec7d2e5d2328fec7facabbec4d7d95e90276e6067f35aff4eb50285dcfd9a507a72c7d2e1e759ad171e55cf1b54a65584fd6dff42cd225b75ce08a1eac05b73b8a908e83a5d4784059d41434be80a37909255b020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820275020100300d06092a864886f70d01010105000482025f3082025b0201000281810084a5630da30447225f084704e282f6bea8bbb0a7043c30d0a85a0ab530d500ab7eb4e76eb6625ff6d65aae874aec7d2e5d2328fec7facabbec4d7d95e90276e6067f35aff4eb50285dcfd9a507a72c7d2e1e759ad171e55cf1b54a65584fd6dff42cd225b75ce08a1eac05b73b8a908e83a5d4784059d41434be80a37909255b02030100010281805ee3fd874cde0b914010a8d58ac10b88fb2641ca4912520d82d1df251d88d310dbf4c837004c41c05039d0eec21f89b1b83925e395e60850054cae11a6fdf755abed6e9075ffecb741a2b08e111b330e4f0531432c7645e1901d203ee48659d5695ceb3491bd060db77909524f6137fc703ffc38bb770b6726990eba5aa89c71024100e0983b76c4750d60e3a6b03e011514eba3a102f32a0d415463e7f96ebc6465d687abe2f13da3494f2b3cb0e56f32100f871320d11fb6885f652e5c72bbf684a30241009731b07dff8a44f22cf4db024016ce65783bb132432075d6dd420d5e7099db11747c25e1fdb04f2786805075d1c3d72bbdd344b88adc3b67eadbc4225bf5afe902403d472bca3ed5d4fd9f7f464cd48cc4f579e29f646b0fccc852ade32f64755c17c9528b8bd88e699d1125f0f9d879e749e547c1c76d08a772a7af9b87ae63175302404dbc07711094679457d6e04f4ce22ce5f0a648197e77cefe54ade42fbd16ed9210e0cf9d5c906c71f6ee3bf0079478298e24743da96f47bfcaf988e2dd82f9190240010485538c262473c0220bdf626974992fc8936be653e02433cd288e87ca0d707ce5feccdded153b9db8933dc2551048611885cb276dfbafe92421df2245664b"},
                                  "30819f300d06092a864886f70d010101050003818d003081890281810093fad989ca301e1c35ea388ed3e0f8d103d7a021ee7dfc75d7084c7bcdf6a799fb4f0f8f008202f7b2c529632bf63572d2dc5029b7857790c5d2006d480100679c29bbfef2a021ad88fb6a0e26d3cd5bd7f6ddd620390cd4748f95ca11b86b641973a1a9b6cde3fa10987911a9ff4a57e4af084f810d40cef98ceb8956e6eb23020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820276020100300d06092a864886f70d0101010500048202603082025c0201000281810093fad989ca301e1c35ea388ed3e0f8d103d7a021ee7dfc75d7084c7bcdf6a799fb4f0f8f008202f7b2c529632bf63572d2dc5029b7857790c5d2006d480100679c29bbfef2a021ad88fb6a0e26d3cd5bd7f6ddd620390cd4748f95ca11b86b641973a1a9b6cde3fa10987911a9ff4a57e4af084f810d40cef98ceb8956e6eb23020301000102818043b630fc5fcc0cbb13e08ce8ae02ef5794ce81b385119907c2d1454e113ca00c517627c463931a108578ba2b6ade4a2eb455a348b3751af4dfcfebea155c7ff633aadced7fb5e0a06d1e1b9bfdd0e619e2eb2913510b195f76f87eea9211b9ca52c6f6ae9fe97e46df01b7c795b69552f684a9e63e08549bdaadbdfc40e0df81024100eb1ecc1f525fc2784e7a7dfe9f247d2a4128afdce4d2234567c95f53cc4572e93eed600fad25e6cf41e718792abcbd25b24c4b901085a0a3db1260cc7e458353024100a11f02a6bb4d1b196243620e03f028baeb69a6a0bd354f6e7882244505dd68728d116d4bda6550b8c795d4c0ace55f644ab39803d629d5e14ca1bcad7d614ef1024069ed681d3c69741deb8d78323cd49da769cfc0db8e23b64c50a402d4a81529de37c18e23c1e86f8234b8bee7e7ff3c603d61ee312ba0686d2a07afa0b1caf38d02401fa036a5039edef2dc96dd6862dd81212f944d60bfc2f7147813138b78db3ce53f4b6c68b735abe2994a8fb84237c3c1abe814aeac1b0a206f2a501ebdbd9c01024100c09a42f14aca7b3ee139f78eaa24b77e173c23ec3aa1a9c2d081c12455f69d1e703ee8c70e834e5545dceb5b5917d2678b102da29873d28e8b16fe6e70cc153b"},
                                  "30819f300d06092a864886f70d010101050003818d0030818902818100a0c19b6be56991586a976ba6f176a4035268fe5d4faf038ccad9becd7f3ab8ab2d78df8e7cb9fc5789d38c8e848b54fdc1ab226059a99dd0a618ed8b776c39856d66ac862edff8e61d5a90cd8b177902f70638ecd085284467fd14cfc086fe073df6cc32b2c9f1b3460183d1e46b85a1d2e7f13bcf4a480a6e2de80b1398b5fd020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820278020100300d06092a864886f70d0101010500048202623082025e02010002818100a0c19b6be56991586a976ba6f176a4035268fe5d4faf038ccad9becd7f3ab8ab2d78df8e7cb9fc5789d38c8e848b54fdc1ab226059a99dd0a618ed8b776c39856d66ac862edff8e61d5a90cd8b177902f70638ecd085284467fd14cfc086fe073df6cc32b2c9f1b3460183d1e46b85a1d2e7f13bcf4a480a6e2de80b1398b5fd020301000102818100878691942605990e745691e05d834b04adee6c3b989910a21ac5f5f0e3494b34ad12514e9be264561c9127d762f0e0474a860f66315129062571b09a3aa517dc09e2f06d9880e04590ea3aa9dd556778238b64b5512b4f7f6ff752c18f77c24f2002da73a0c15b5d0b2f2a2ad5a3c5538fbe881511dbad711d864a23033e6401024100ce7bf0fe9d175383ebd8a43bda2abacf7f9d0cad5cff56c29447c6ae83094a9b819daf7398d9ee924bc25d8cb503503af8ce739833641d93a73fcf34680c0cfd024100c74e6ebe0c9f4ed0d1d099e77821c71cf9d1eecf707af590bfbfa722248657db2ae3213f77fdb2e060497e86faf9030441eb7440f0e535c2db8f8b77aca41d010240791c69766e5dc8369097397d81b19e7126c0cf36c05d645e2ceb0cb63f55abd51a698b079a97f93f0600b32e5cdddca93a569da6a03e10bb1256730aa21caf610241009a5019e23ff7a09881bb174e666f10b158a3b8591867bb760560a85101229b27703f4760d2d0b50c90c0969c7ff908e2e4ff1e95a16e767f966bbfba3b0b1e01024100b24befa0618f4dd1c6a1ecd3fe2e153276749cef1fb3e13772a9a8bb117e46abb2fa19d707361f81ece7a413648f0032722992a83e909c8a9896458cb3534718"},
                                  "30819f300d06092a864886f70d010101050003818d0030818902818100a2e105c86c51aa20f5acde04b49423b30951600b0741533cd4e31fb0e24cf86b88c4b0e6596663d2425dcfd37dfe743146b06396b2bad828e9461c03cb052b71e5bb7cb17d2afc459007870a5d445ee3dadb5d267a197451e79fd4159347128e9de84da54bb32981042cf637fae69bf71f48046c0f63f49f95cb9af96d7aa611020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820276020100300d06092a864886f70d0101010500048202603082025c02010002818100a2e105c86c51aa20f5acde04b49423b30951600b0741533cd4e31fb0e24cf86b88c4b0e6596663d2425dcfd37dfe743146b06396b2bad828e9461c03cb052b71e5bb7cb17d2afc459007870a5d445ee3dadb5d267a197451e79fd4159347128e9de84da54bb32981042cf637fae69bf71f48046c0f63f49f95cb9af96d7aa61102030100010281802559ff0e803096182adeb2a75795e53de8741dd74999a471fdcbfbf77f5df1560fae33770fa7585ade574f128c012f3a21a0cfa5be64f4af2517abd2fedab7a46f6d183d2b99400c0cc6edfaf848a0aa47bd7d37d15ad30d09896a1ae66a8a7f36a9c2bad29ff176ea059da23d296edfe1294c88d8c393c62ad1a0a3c3a472b1024100e9b2948230a1788bdaeb0d782694d10a50b1e63b123f696b13ad31b23560386b19cf498d9137ea394534042fd7791706919d27a333c19d18acc2baedb6b42af5024100b26c49989f0ef67e5d6c02705cf34c5293131539d1b8f4c6f6feda86a6dde4d2b48ac71162c75a36889bd84bd9d90065149f67671447f80193c010affb85152d024100a5bb54a083766fb3d71bece07194062f678cd236c039223ca2a6a7e0b703b6df155db0cee9d69a8fe4e8ffb321ff28fa2a9825fd127e5337a5852fe5d7352c6502403e9001ee663794ef124b013fed17d2b751a2eb5a6ed36fe1245290c58e55581b19fb5f7a152cd9d12d6d981660b8da8e97009dfd62fb2957443ba09e548f81b1024006a17a330302d8142084c6c28dce3c6b252af8b8291443d3be98c60ce7d2a2c45ffb5228201875f345b5bd1fc621f90ae63804908afc2b2a503a74ea27a5c5aa"},
                                  "30819f300d06092a864886f70d010101050003818d0030818902818100a70991d69d816a601ffa80976473830f0d3b41276d2790401ddedb18e2d3cab3c315e3222325be42b65adb2878f33f5a03ff5010b23e842a510c1482ad6a42f1e7e5726eb31813e7437640ed7879955f401e172c34d3517241596dd41f8e48d3d1b1c288e6c8752ff65dc27acccba4ba9cd6d0e4de6196cea4da480d3b99d0ed020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820276020100300d06092a864886f70d0101010500048202603082025c02010002818100a70991d69d816a601ffa80976473830f0d3b41276d2790401ddedb18e2d3cab3c315e3222325be42b65adb2878f33f5a03ff5010b23e842a510c1482ad6a42f1e7e5726eb31813e7437640ed7879955f401e172c34d3517241596dd41f8e48d3d1b1c288e6c8752ff65dc27acccba4ba9cd6d0e4de6196cea4da480d3b99d0ed02030100010281807f61a2dfe1b9619ff0831e31559f6960bf1c62f1682275b50f9275cf229b94c7458c996bdd15d96412a072e50867a7f6437a1e5abd3343a2e9afa6ac8906b2097c61cf5b2bd95418bfc05b2a24405f1a18be182745e9e8669f8c97aa32ef0a13c2245ea7bb3556ea719963ccc01f1e19ec9e90204d5a3466e3b43b094e3d0999024100f56507e3fe143670ddce758e67687958f1747c4e92b7073dfb87d6a3c99634ca1f9e48f28adf26a17f53f931cd949d094f1087d883524435b62ec6aa17ca30db024100ae419e625e48545440bfc30a3ec134a3c961684578a27b265488a9f922a5e1a41c25a506065d3e4a11ed0095933531f4c29c548c64ec374a48e0995220a22bd7024039b361e19832c4825185645af1b1bd26cecfa7130aa882c96e458890c6abcd09e1d96429b3c1b8e1ac80e04d779b8439561ffaf14c1fa1ee47424470665ba295024026250310b166cfdee99590924b8e6b8176f1b5ab8f6eb1da8022b26270ed32e983a7d1e9f1b6b38def429c2021eb41163d0b8f8e740129513f86bac9398f865d024100cd1ce32d491348455d3ecd6462b7ed583d04ce74a8802142d36bb87e8e67ff86fb6d6b5a33ff183d987bf9ad787f5f0b468f74b3d210f10bd0266b504306e47c"},
                                  "30819f300d06092a864886f70d010101050003818d0030818902818100a738cde75f1fbb1c18646c377e03016b162b12ba72bdf7dc36b4cd2e4e9bae12205a95c26170bf908105ad7fa4bbccfa798632261bed9870f975f20794e1fe499523d71f08a56cae0315bfde3d6c8a16386b03b7a6551aa1336d50325a3500db27d78ad8fd13b6a73b9fb7c3fb4d7a088e323f07618656ecd83595fa5f823613020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820276020100300d06092a864886f70d0101010500048202603082025c02010002818100a738cde75f1fbb1c18646c377e03016b162b12ba72bdf7dc36b4cd2e4e9bae12205a95c26170bf908105ad7fa4bbccfa798632261bed9870f975f20794e1fe499523d71f08a56cae0315bfde3d6c8a16386b03b7a6551aa1336d50325a3500db27d78ad8fd13b6a73b9fb7c3fb4d7a088e323f07618656ecd83595fa5f823613020301000102818059eb70c54ee078341665c1cf61426a7bd412db62491b1ff259b48574b62e7ebf1e88b7692c0e7de44d8ce90bef60514c0b16ff5680c415aa026acaf80ab62f8f30698c7132530ddd46a44b7777387037312e49c59dc5a00e20967435f74cac6703a201ec3431b86008e0d973fa775799bc7b8863037270a33829c081e6cbaa11024100e25d4778e0d1e1e5cb65be3836f5d64af06d054ec6e3b03f78f6bde89ef2d9e4b932b735fc264a5c7a3d2a7c66d00187c3dca51c3ef758fdfde70564c1c2e8e9024100bd1d5576d0e8569d711d5aca42fd808c1f7085c5ced215180360adabd6c553414fdf4ccd9b91d6995c35886636cb14e6f453bff341f56cbae67218c17077099b0240620f127514bf16e29af7da2d33f1cf00eba1ee98afa3d6a7c858eaefa85b7f748b9da2ac2a2cd42db76e63c73c2a835f32c3946ae603f47322d83f07e4bff07102402d2e19e1e5ecebec773ea51717440af6eef7e9eda50889a3900303dabed7ab9939e4c62b84d425a9c3dec2347138b948a7ec6e3a4672c4c42e13ea1824af3bab024100bd154581c5d399c838f476b75482886fcdf194d8419d6564a8dc8b9c074e044359519e3bf6868fc3b4a5f8dd120f5e53813db9fb83fa3ca1fc404ea1c02fe0e5"},
                                  "30819f300d06092a864886f70d010101050003818d0030818902818100a8b144135b042b57a1ca2048f5e0c624b98352933d53ca67003f97e8c3639898674b74a4de9406e05f85678a2ac13b653e7ab4fadf94e771d97ba2ee0dbe5876be50255f00404e094aecbc3ed3b286ac81f9b26a1e26df2c0363d4859e63d4c178d00e3228785f87e48623e64baa0624b88f8c969fd0be4f0e009edc107de509020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820276020100300d06092a864886f70d0101010500048202603082025c02010002818100a8b144135b042b57a1ca2048f5e0c624b98352933d53ca67003f97e8c3639898674b74a4de9406e05f85678a2ac13b653e7ab4fadf94e771d97ba2ee0dbe5876be50255f00404e094aecbc3ed3b286ac81f9b26a1e26df2c0363d4859e63d4c178d00e3228785f87e48623e64baa0624b88f8c969fd0be4f0e009edc107de50902030100010281806090f9334b4adbb4d27cee7655aa5242fb9f5d49c4358f0bdf6c87fd4abc5cc2017f844a4ccfd80fe11e70e2fb0e9a7d9e8287cf84e5ac87d3c39ec53f40d34a578e4d83754c27cf1dfb128f3f6be73f2a62118a46d0558c9023129196320c27689f1f5d805f622b78ba72aa8777f249c7e9db10301f37d0728cc3672b515931024100e077b061144d5b1ec755d409edfa45fdd313d57da203c3b9c111dc526993efc20f7b33ee7671fadaba6324fb6315184817b6b386dc6b92cd442381a4c94d88fb024100c063ca70c9885ab25b1f91cd5396866d6fdd82e00935109aa4e98c306abfe23423e02a9de14440f47e77188a7ce9cdff2b353f9f5036d9c9b8d9c553907ff2cb024100c4e71938bf8770041ad5e64fe38ae474d9011008c9e345811fa4dc410ace33c666b02b88e62bebe28d17c56c23a97088650ce684c9bc2fa5923d174f872a559b02407835a207291566be2c8ba4396c32105a8edc146b51b573637d09648bd8177f0a5f2430dca7255384b1044f3430ea91c90f415d3879115cb15b2bceccf0ebd153024051dc4bc183d0828850189fb54a62b6f49c1c781cfbe4963356c7703c5825ba322eba5e2e1368b62ab414393d371c8f5df6b8966b621aed933fc469ff4ef3517d"},
                                  "30819f300d06092a864886f70d010101050003818d0030818902818100b22ee1f895f1d872618c1090316c5f5be9488c11056503b8c77fc2969850fe63f6fcd32708e8a5e49095c04526d73a509a46c4351640ce94598a4005d9b0af3b454e0b572002f524f88c34b5d3fbe2ec6508b7dbd6528b340d7fa6bf9a4529635e97845e0329b343b3e6d290665cc3fe852ac135524e7c0a08ab6830a0b01057020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820277020100300d06092a864886f70d0101010500048202613082025d02010002818100b22ee1f895f1d872618c1090316c5f5be9488c11056503b8c77fc2969850fe63f6fcd32708e8a5e49095c04526d73a509a46c4351640ce94598a4005d9b0af3b454e0b572002f524f88c34b5d3fbe2ec6508b7dbd6528b340d7fa6bf9a4529635e97845e0329b343b3e6d290665cc3fe852ac135524e7c0a08ab6830a0b01057020301000102818100a664f3af21cf9c528c57b16c064b6eedb4f7839dad8cfca1c4e3c142c2f0f7ef404a2fa14747830be41d8454cf85b4366b2be4b4b2984891eee01513a18bc6c6a1c6d21895cc26039f6acbcaa985d2aa08cf5b2155bebf0f4305f960f0d2b123ac6827d932170b7651a26f618ec72b0fd246e9c8ff9528fa95533a3b168b74e9024100e6b53acbc441cbc411b8815c9d959971356e8088477519524e0bf3d77d6d8b71e86d765b72042acb0e590ee1c7ffddaa9c63ed69592e615067c89c72247ac925024100c5b78e39f3553142982f9b730ebc230a641ae2302bc2218e8c82da19e6bdddf0cd756f340c161aa6a11bbbb59ec3fe3aa7cccdf30b5ff9bb2dd6d4919a6b50cb024100e0888b439bab498c768eb26018026c0711308da9949a33ddb595ce68f06ab7e751858f466a8e01b4042fcadb1512418375978f8d133d9f7a68b7870353dba87d024002ec60dcf87d14fa6017ac1bba670bb9969b5326d52ecca237efa35be8ae7bfe987b1906d2faecaff407ddf1a4844f58fcac298b636aaadd9aa2e787b399cc9b02406a5e97f4947b15e3b7feb6160b85228686d0099f3e99938dfd9535b09951b97d35bb6870789ae31f67794be4e2f7919d104e0610346ee7f174580e0da81cf3db"},
                                  "30819f300d06092a864886f70d010101050003818d00308189028181009e74b364b72cadae5c942c0bce6e32aeb5b808bd83887e8842c966b9e4ec43407fcf622be9f0d7f9e67d1853d63a2f82ff8ab0e80e172625b82835e0dc2bb23cf4f466a790cecd1155004c8ab05f8005421e8283372bd79cd0134243fb744f70d66e67ee79597dbb019786d825454bfa61620a2398a1048f47705722e206b19b020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820277020100300d06092a864886f70d0101010500048202613082025d020100028181009e74b364b72cadae5c942c0bce6e32aeb5b808bd83887e8842c966b9e4ec43407fcf622be9f0d7f9e67d1853d63a2f82ff8ab0e80e172625b82835e0dc2bb23cf4f466a790cecd1155004c8ab05f8005421e8283372bd79cd0134243fb744f70d66e67ee79597dbb019786d825454bfa61620a2398a1048f47705722e206b19b020301000102818022ae58354b0234615d51f0f2049489f34342ac670e4ae9a6d9374b8c945641c1f43767bd44ceb9f6b043e0f7388433b1f04c62bbe7999977d7feb50c2a2446364900b77ff478242a75e17c82ed14eb012e18bb27cc2eb2597138f90ed19f67a7ef84a84402a1f70a7b8025a973111cb943467c0b256814143e5f46ca02896441024100d3af83fee62d4a3fe92824a2507ec602e70785ffb2d8db4eca5e38c550b5e67814dbf252750efdbab5e625d775d4aa29f8cd3e6ef08818418bbbd91f591e40ad024100bfa08a1ff528b5be40a7b62d97d971831f16d23dfeff338ea3013d53a4a2d4c7cc575a78454a785ac56f651d5ede25699bd7c54068eea2691a4dbe3d9f1edc670240013f2d65d8f13758bd04d1826b3af3eb9c74bce34ea85c52507ad196c7ecea5896b6dcec8367fd329653aeb1602e4a7a48cedca9469d66972c3d84ffdc448359024100b39a937b4a7b828433f33d03d4ac200126756c4e611eee42c532d738fb3906b7d1251a8d595c681ba3ab3999629e51707f79a7ce2bcb667b9e04b9c6e5c9b6070241009eeeb0c3a299a2a997dcc20452dd8f6e402b7f3b56062371c40a9f89eeee9dd060ed5b4ff82961381de2a8efeb086b0b22f4b38654aaa3983b9be4cb18398d73"}
                              }
                     }
}

```

`Scripts/1768/1768.py`:

```py
#!/usr/bin/env python

from __future__ import print_function

__description__ = 'Analyze Cobalt Strike beacons'
__author__ = 'Didier Stevens'
__version__ = '0.0.16'
__date__ = '2022/08/20'

"""
Source code put in the public domain by Didier Stevens, no Copyright
https://DidierStevens.com
Use at your own risk

History:
  2019/05/15: start
  2019/05/18: continue
  2019/05/25: continue
  2019/12/06: continue
  2019/12/07: continue
  2019/12/17: continue
  2020/02/03: 0.0.2 some changes for CS4: xor key is '.' in stead of 'i'
  2020/10/11: 0.0.3 Python 3 fixes
  2020/10/17: improve parsing
  2020/10/18: updated some config identifiers: found https://github.com/JPCERTCC/aa-tools https://github.com/sysopfb/malware_decoders/tree/master/cs_beacon https://github.com/Sentinel-One/CobaltStrikeParser
  2020/10/21: Python 3 fix in cBinaryFile
  2020/10/28: refactoring
  2020/10/29: man
  2020/11/04: added xor chain decoding
  2020/11/07: 0.0.4 updated shellcode analysis
  2020/11/12: updated shellcode analysis
  2020/11/16: added option -l
  2020/11/17: continue
  2020/11/29: added rule_shellcode_00_end
  2021/02/13: 0.0.5 updated shellcode analysis (+ Python 3 fix); added XORChain analysis for PE sections; remove duplicate configs when dumping raw
  2021/03/06: added option -c
  2021/03/25: 0.0.6 fix for provided sample
  2021/04/06: fix
  2021/04/28: added option -J
  2021/04/30: CS version guessing
  2021/05/02: fix
  2021/05/15: continue JSON output
  2021/06/14: updated man with 1768.json info
  2021/10/10: 0.0.8 1768.json improvements
  2021/10/17: 0.0.9 added malleable instructions decoding
  2021/11/01: refactoring instructions decoding
  2021/11/05: 0.0.10 cOutput replacements
  2021/11/07: added FinalTests
  2021/11/14: added DNS fields
  2021/11/17: added missing field names (ebook FINDING BEACONS IN THE DARK)
  2021/12/12: 0.0.11 added 1768b.json support
  2022/02/22: 0.0.12 added private key to 1768.json (provided by alexzorila); fix json output; pyzipper support
  2022/04/15: 0.0.13 added option -H and IdentifyShellcode
  2022/04/16: continue IdentifyShellcode
  2022/05/20: 0.0.14 skipping 0x20 bytes
  2022/07/31: 0.0.15 update class cAPIOptions
  2022/08/17: added option --sanitycheck; refactored FinalTests
  2022/08/20: 0.0.16 added output instructions to JSON output

Todo:

"""

import optparse
import sys
import os
import binascii
import random
import gzip
import collections
import glob
import textwrap
import re
import struct
import string
import math
import fnmatch
import json
import time
import hashlib
try:
    import pyzipper as zipfile
except ImportError:
    import zipfile
if sys.version_info[0] >= 3:
    from io import BytesIO as DataIO
else:
    from cStringIO import StringIO as DataIO
if sys.version_info[0] >= 3:
    from io import StringIO
else:
    from cStringIO import StringIO
try:
    import pefile
    import peutils
except ImportError:
    print('Missing pefile and/or peutils Python module, please check if it is installed.')
    sys.exit()

def PrintManual():
    manual = r'''
Manual:

1768 Kelvin is the melting point of the metal cobalt.

This tool decrypts and dumps the configuration of Cobalt Strike Windows beacons (PE files), shellcode and memory dumps.

Option -s (--select) can be used to select a particular configuration item (by decimal of hexadecimal number) for more information. For the moment, this option displays the complete item's data (hexadecimal in cleartext, encoded with 'i' (0x69) and encoded with '.' (0x2e). These hexadecimal values  can be used to create detection rules, like YARA rules.

Option -l (--licenseid) is used to generate YARA rules to detect a beacon or shellcode with the given license ID. The id can be provided as an integer or an hexadecimal value (prefixed by 0x).
More than one license id can be provided: separate them by commas (,).
Each license id can be previded by a name for the license is (use : as a separator).
Example : 1768.py -l ATP_1:12345678,pentester_2:87654321

Option -c (--csv) is used to output the config parameters in CSV format.

Option -J (--jsonoutput) is used to output the config parameters in JSON format.

Use option -H to display the hashes of the analyzed file.

Option -S (--sanitycheck) performs a sanity check on the extracted configuration, and ignores the extracted configuration when it does not pass a sanity check.
The sanity check checks for the presence of config values 1 and 7, and check if their values are plausible:
1 -> known payload type
7 -> public key starts with 308

Option -V (--verbose) produces more output:
- verbosity for config values (like the private key for leaked keys)
- hex/ascii dump of found signatures

A JSON file with name 1768.json placed in the same directory as 1768.py will be used to enhance fields with information, like the license-id field.

It reads one or more files or stdin. This tool is very versatile when it comes to handling files, later full details will be provided.

This Python script was first developed with Python 2.7 and tested with Python 2.7 and 3.7, now it is developed with Python 3.9 and tested with Python 3.9.

As stated at the beginning of this manual, this tool is very versatile when it comes to handling files. This will be explained now.

This tool reads files in binary mode. It can read files from disk, from standard input (stdin) and from "generated" files via the command line.
It can also partially read files (this is done with the cut operator).

If no file arguments are provided to this tool, it will read data from standard input (stdin). This way, this tool can be used in a piped chain of commands, like this:

oledump.py -s 4 -d sample.doc.vir | tool.py

When one or more file arguments are provided to this tool, it will read the files and process the content.
How the files are read, depends on the type of file arguments that are provided. File arguments that start with character @ or # have special meaning, and will be explained later.

If a file argument does not start with @ or #, it is considered to be a file on disk and the content will be read from disk.
If the file is not a compressed file, the binary content of the file is read from disk for processing.
Compressed files are solely recognized based on their extension: .zip and .gz.
It uses built-in Python module zipfile, unless module pyzipper is installed. Module pyzipper adds AES support, and can be installed with pip (Python 3 only).
If a file argument with extension .gz is provided, the tool will decompress the gzip file in memory and process the decompressed content. No checks are made to ensure that the file with extension .gz is an actual gzip compressed file.
If a file argument with extension .zip is provided and it contains a single file, the tool will extract the file from the ZIP file in memory and process the decompressed content. No checks are made to ensure that the file with extension .zip is an actual ZIP compressed file.
Password protected ZIP files can be processed too. The tool uses password 'infected' (without quotes) as default password. A different password can be provided using option --password.

Example:

tool.py sample.zip

To prevent the tool from decompressing .zip or .gz files, but to process the compressed file itself, use option --noextraction.

File arguments that start with character @ ("here files"), are read as text files that contain file arguments (one per line) to be processed.
For example, we take a text file with filename list.txt and following content:

sample-1.bin
sample-5.bin
sample-7.bin

When using this file (list.txt) in the following command:

tool.py @list.txt

the tool will process the following files: sample-1.bin, sample-5.bin and sample-7.bin.
A single @ character as filename is a here file read from stdin.

Wildcards are supported too. The classic *, ? and [] wildcard characters are supported. For example, use the following command to process all .exe and .dll files in the Windows directory:

tool.py C:\Windows\*.exe C:\Windows\*.dll

To prevent the tool from processing file arguments with wildcard characters or special initial characters (@ and #) differently, but to process them as normal files, use option --literalfilenames.

The content of folders can be processed too: use option --recursedir and provide folder names as argument. Wildcards and here files (for folder names) can be used too.

File arguments that start with character # have special meaning. These are not processed as actual files on disk (except when option --literalfilenames is used), but as file arguments that specify how to "generate" the file content.

File arguments that start with #, #h#, #b# or #e# are used to "generate" the file content.
Arguments that start with #c# are not file arguments, but cut operators (explained later).
Arguments that start with #f# are not file arguments, but flags (explained later).

Generating the file content with a # file argument means that the file content is not read from disk, but generated in memory based on the characteristics provided via the file argument.

When a file argument starts with # (and not with #h#, #b#, #e# or #c#), all characters that follow the # character specify the content of the generated file.
For example, file argument #ABCDE specifies a file containing exactly 5 bytes: ASCII characters A, B, C, D and E.
Thus the following command:

tool.py #ABCDE

will make the tool process data with binary content ABCDE. #ABCDE is not an actual file written on disk, but it is a notational convention to provide data via the command line.

Since this notation can not be used to specify all possible byte values, hexadecimal encoding (#h#) and BASE64 encoding (#b#) notation is supported too.
For example, #h#4142434445 is an hexadecimal notation that generates data ABCDE. Hexadecimal notation allows the generation of non-printable characters for example, like NULL bytes: #h#00
File argument #b#QUJDREU= is another example, this time BASE64 notation, that generates data ABCDE.

File arguments that start with #e# are a notational convention to use expressions to generate data. An expression is a single function/string or the concatenation of several functions/strings (using character + as concatenation operator).
Strings can be characters enclosed by single quotes ('example') or hexadecimal strings prefixed by 0x (0xBEEF).
4 functions are available: random, loremipsum, repeat and chr.

Function random takes exactly one argument: an integer (with value 1 or more). Integers can be specified using decimal notation or hexadecimal notation (prefix 0x).
The random function generates a sequence of bytes with a random value (between 0 and 255), the argument specifies how many bytes need to be generated. Remark that the random number generator that is used is just the Python random number generator, not a cryptographic random number generator.

Example:

tool.py #e#random(100)

will make the tool process data consisting of a sequence of 100 random bytes.

Function loremipsum takes exactly one argument: an integer (with value 1 or more).
The loremipsum function generates "lorem ipsum" text (fake latin), the argument specifies the number of sentences to generate.

Example: #e#loremipsum(2) generates this text:
Ipsum commodo proin pulvinar hac vel nunc dignissim neque eget odio erat magna lorem urna cursus fusce facilisis porttitor congue eleifend taciti. Turpis duis suscipit facilisi tristique dictum praesent natoque sem mi egestas venenatis per dui sit sodales est condimentum habitasse ipsum phasellus non bibendum hendrerit.

Function chr takes one argument or two arguments.
chr with one argument takes an integer between 0 and 255, and generates a single byte with the value specified by the integer.
chr with two arguments takes two integers between 0 and 255, and generates a byte sequence with the values specified by the integers.
For example #e#chr(0x41,0x45) generates data ABCDE.

Function repeat takes two arguments: an integer (with value 1 or more) and a byte sequence. This byte sequence can be a quoted string of characters (single quotes), like 'ABCDE' or an hexadecimal string prefixed with 0x, like 0x4142434445.
The repeat function will create a sequence of bytes consisting of the provided byte sequence (the second argument) repeated as many times as specified by the first argument.
For example, #e#repeat(3, 'AB') generates byte sequence ABABAB.

When more than one function needs to be used, the byte sequences generated by the functions can be concatenated with the + operator.
For example, #e#repeat(10,0xFF)+random(100) will generate a byte sequence of 10 FF bytes followed by 100 random bytes.

The cut argument (or cut operator) allows for the partial selection of the content of a file. This argument starts with #c# followed by a "cut-expression". Use this expression to "cut out" part of the content.
The cut-argument must be put in front of a file argument, like in this example:

tool.py #c#0:100l data.bin

With these arguments, tool.py will only process the first 100 bytes (0:100l) of file data.bin.

A cut argument is applied to all file arguments that follow it. Example:

tool.py #c#0:100l data-1.bin data-2.bin

With these arguments, tool.py will only process the first 100 bytes (0:100l) of file data-1.bin and the first 100 bytes file data-2.bin.

More than one cut argument can be used, like in this example:

tool.py #c#0:100l data-1.bin #c#0:200l data-2.bin

With these arguments, tool.py will only process the first 100 bytes (0:100l) of file data-1.bin and the first 200 bytes (0:200l) of file data-2.bin.

A cut-expression is composed of 2 terms separated by a colon (:), like this:
termA:termB
termA and termB can be:
- nothing (an empty string)
- a positive decimal number; example: 10
- an hexadecimal number (to be preceded by 0x); example: 0x10
- a case sensitive ASCII string to search for (surrounded by square brackets and single quotes); example: ['MZ']
- a case sensitive UNICODE string to search for (surrounded by square brackets and single quotes prefixed with u); example: [u'User']
- an hexadecimal string to search for (surrounded by square brackets); example: [d0cf11e0]
If termA is nothing, then the cut section of bytes starts with the byte at position 0.
If termA is a number, then the cut section of bytes starts with the byte at the position given by the number (first byte has index 0).
If termA is a string to search for, then the cut section of bytes starts with the byte at the position where the string is first found. If the string is not found, the cut is empty (0 bytes).
If termB is nothing, then the cut section of bytes ends with the last byte.
If termB is a number, then the cut section of bytes ends with the byte at the position given by the number (first byte has index 0).
When termB is a number, it can have suffix letter l. This indicates that the number is a length (number of bytes), and not a position.
termB can also be a negative number (decimal or hexademical): in that case the position is counted from the end of the file. For example, :-5 selects the complete file except the last 5 bytes.
If termB is a string to search for, then the cut section of bytes ends with the last byte at the position where the string is first found. If the string is not found, the cut is empty (0 bytes).
No checks are made to assure that the position specified by termA is lower than the position specified by termB. This is left up to the user.
Search string expressions (ASCII, UNICODE and hexadecimal) can be followed by an instance (a number equal to 1 or greater) to indicate which instance needs to be taken. For example, ['ABC']2 will search for the second instance of string 'ABC'. If this instance is not found, then nothing is selected.
Search string expressions (ASCII, UNICODE and hexadecimal) can be followed by an offset (+ or - a number) to add (or substract) an offset to the found instance. This number can be a decimal or hexadecimal (prefix 0x) value. For example, ['ABC']+3 will search for the first instance of string 'ABC' and then select the bytes after ABC (+ 3).
Finally, search string expressions (ASCII, UNICODE and hexadecimal) can be followed by an instance and an offset.
Examples:
This cut-expression can be used to dump the first 256 bytes of a PE file located inside the file content: ['MZ']:0x100l
This cut-expression can be used to dump the OLE file located inside the file content: [d0cf11e0]:

A flag argument starts with #f# and is passed on for all files that are provided after the flag argument. It can be used to change the behavior of the tool for certain files.
Example:

tool.py data-1.bin #f#-l data-2.bin

data-2.bin will be processed differently (using flag option -l) than file data-1.bin.

With option --jsoninput, the tool will parse the output produced by another tool using option --jsonoutput.
Example:
zipdump.py --jsonoutput Book1.xlsm | file-magic.py --jsoninput
[Content_Types].xml XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
_rels/.rels XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/_rels/workbook.xml.rels  XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/workbook.xml XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/drawings/drawing1.xml  XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/worksheets/_rels/sheet1.xml.rels XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/theme/theme1.xml XML 1.0 document, UTF-8 Unicode text, with very long lines, with CRLF line terminators
xl/styles.xml XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/worksheets/sheet1.xml  XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/vbaProject.bin Composite Document File V2 Document, Cannot read section info
xl/drawings/vmlDrawing1.vml ASCII text, with CRLF line terminators
docProps/app.xml  XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/ctrlProps/ctrlProp1.xml  XML 1.0 document, ASCII text, with CRLF line terminators
docProps/core.xml XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators

In this example, zipdump is used to produce JSON data with the content of each file contained inside file Book1.xlsm (a ZIP container), which is then consumed by file-magic.py to identify (libmagic) the type of each file.

With option --ignoreprocessingerrors, the tool will continue processing the next file when an error occurs while processing the current file. Files that can not be opened will always be skipped to move to the next file.

Option --logfile direct the tool to create a logfile, and option --logcomment can be used to add a comment to the log file. The log file will contain metadata and a list of processed files, it does not contain processing results.
It is best to use this option when option --ignoreprocessingerrors is used, to have a record of file processing errors.

The lines are written to standard output, except when option -o is used. When option -o is used, the lines are written to the filename specified by option -o.
Filenames used with option -o starting with # have special meaning.
#c#example.txt will write output both to the console (stdout) and file example.txt.
#g# will write output to a file with a filename generated by the tool like this: toolname-date-time.txt.
#g#KEYWORD will write output to a file with a filename generated by the tool like this: toolname-KEYWORD-date-time.txt.
Use #p#filename to display execution progress.
To process several files while creating seperate output files for each input file, use -o #s#%f%.result *.
This will create output files with the name of the inputfile and extension .result.
There are several variables available when creating separate output files:
 %f% is the full filename (with directory if present)
 %b% is the base name: the filename without directory
 %d% is the directory
 %r% is the root: the filename without extension
 %ru% is the root made unique by appending a counter (if necessary)
 %e% is the extension
#h# is like the head command: only the first 10 lines will be outputed.
#t# is like the tail command: only the last 10 lines will be outputed.
Most options can be combined, like #ps# for example.
#l# is used for literal filenames: if the output filename has to start with # (#example.txt for example), use filename #l##example.txt for example.

'''
    for line in manual.split('\n'):
        print(textwrap.fill(line, 79))

DEFAULT_SEPARATOR = ','
QUOTE = '"'

START_CONFIG_I = b'ihihik'
START_CONFIG_DOT = b'././.,'

ERROR_NO_CONFIG = 'Error: config not found'
ERROR_SANITY_CHECK = 'Error: config does not pass sanity check'

def PrintError(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

#Convert 2 Bytes If Python 3
def C2BIP3(string):
    if sys.version_info[0] > 2:
        return bytes([ord(x) for x in string])
    else:
        return string

#Convert 2 String If Python 3
def C2SIP3(bytes):
    if sys.version_info[0] > 2:
        return ''.join([chr(byte) for byte in bytes])
    else:
        return bytes

#Convert 2 Integer If Python 2
def C2IIP2(data):
    if sys.version_info[0] > 2:
        return data
    else:
        return ord(data)

def P23Ord(value):
    if type(value) == int:
        return value
    else:
        return ord(value)

# CIC: Call If Callable
def CIC(expression):
    if callable(expression):
        return expression()
    else:
        return expression

# IFF: IF Function
def IFF(expression, valueTrue, valueFalse):
    if expression:
        return CIC(valueTrue)
    else:
        return CIC(valueFalse)

#-BEGINCODE cBinaryFile------------------------------------------------------------------------------
#import random
#import binascii
#import zipfile
#import gzip
#import sys
#if sys.version_info[0] >= 3:
#    from io import BytesIO as DataIO
#else:
#    from cStringIO import StringIO as DataIO

def LoremIpsumSentence(minimum, maximum):
    words = ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipiscing', 'elit', 'etiam', 'tortor', 'metus', 'cursus', 'sed', 'sollicitudin', 'ac', 'sagittis', 'eget', 'massa', 'praesent', 'sem', 'fermentum', 'dignissim', 'in', 'vel', 'augue', 'scelerisque', 'auctor', 'libero', 'nam', 'a', 'gravida', 'odio', 'duis', 'vestibulum', 'vulputate', 'quam', 'nec', 'cras', 'nibh', 'feugiat', 'ut', 'vitae', 'ornare', 'justo', 'orci', 'varius', 'natoque', 'penatibus', 'et', 'magnis', 'dis', 'parturient', 'montes', 'nascetur', 'ridiculus', 'mus', 'curabitur', 'nisl', 'egestas', 'urna', 'iaculis', 'lectus', 'maecenas', 'ultrices', 'velit', 'eu', 'porta', 'hac', 'habitasse', 'platea', 'dictumst', 'integer', 'id', 'commodo', 'mauris', 'interdum', 'malesuada', 'fames', 'ante', 'primis', 'faucibus', 'accumsan', 'pharetra', 'aliquam', 'nunc', 'at', 'est', 'non', 'leo', 'nulla', 'sodales', 'porttitor', 'facilisis', 'aenean', 'condimentum', 'rutrum', 'facilisi', 'tincidunt', 'laoreet', 'ultricies', 'neque', 'diam', 'euismod', 'consequat', 'tempor', 'elementum', 'lobortis', 'erat', 'ligula', 'risus', 'donec', 'phasellus', 'quisque', 'vivamus', 'pellentesque', 'tristique', 'venenatis', 'purus', 'mi', 'dictum', 'posuere', 'fringilla', 'quis', 'magna', 'pretium', 'felis', 'pulvinar', 'lacinia', 'proin', 'viverra', 'lacus', 'suscipit', 'aliquet', 'dui', 'molestie', 'dapibus', 'mollis', 'suspendisse', 'sapien', 'blandit', 'morbi', 'tellus', 'enim', 'maximus', 'semper', 'arcu', 'bibendum', 'convallis', 'hendrerit', 'imperdiet', 'finibus', 'fusce', 'congue', 'ullamcorper', 'placerat', 'nullam', 'eros', 'habitant', 'senectus', 'netus', 'turpis', 'luctus', 'volutpat', 'rhoncus', 'mattis', 'nisi', 'ex', 'tempus', 'eleifend', 'vehicula', 'class', 'aptent', 'taciti', 'sociosqu', 'ad', 'litora', 'torquent', 'per', 'conubia', 'nostra', 'inceptos', 'himenaeos']
    sample = random.sample(words, random.randint(minimum, maximum))
    sample[0] = sample[0].capitalize()
    return ' '.join(sample) + '.'

def LoremIpsum(sentences):
    return ' '.join([LoremIpsumSentence(15, 30) for i in range(sentences)])

STATE_START = 0
STATE_IDENTIFIER = 1
STATE_STRING = 2
STATE_SPECIAL_CHAR = 3
STATE_ERROR = 4

FUNCTIONNAME_REPEAT = 'repeat'
FUNCTIONNAME_RANDOM = 'random'
FUNCTIONNAME_CHR = 'chr'
FUNCTIONNAME_LOREMIPSUM = 'loremipsum'

def Tokenize(expression):
    result = []
    token = ''
    state = STATE_START
    while expression != '':
        char = expression[0]
        expression = expression[1:]
        if char == "'":
            if state == STATE_START:
                state = STATE_STRING
            elif state == STATE_IDENTIFIER:
                result.append([STATE_IDENTIFIER, token])
                state = STATE_STRING
                token = ''
            elif state == STATE_STRING:
                result.append([STATE_STRING, token])
                state = STATE_START
                token = ''
        elif char >= '0' and char <= '9' or char.lower() >= 'a' and char.lower() <= 'z':
            if state == STATE_START:
                token = char
                state = STATE_IDENTIFIER
            else:
                token += char
        elif char == ' ':
            if state == STATE_IDENTIFIER:
                result.append([STATE_IDENTIFIER, token])
                token = ''
                state = STATE_START
            elif state == STATE_STRING:
                token += char
        else:
            if state == STATE_IDENTIFIER:
                result.append([STATE_IDENTIFIER, token])
                token = ''
                state = STATE_START
                result.append([STATE_SPECIAL_CHAR, char])
            elif state == STATE_STRING:
                token += char
            else:
                result.append([STATE_SPECIAL_CHAR, char])
                token = ''
    if state == STATE_IDENTIFIER:
        result.append([state, token])
    elif state == STATE_STRING:
        result = [[STATE_ERROR, 'Error: string not closed', token]]
    return result

def ParseFunction(tokens):
    if len(tokens) == 0:
        print('Parsing error')
        return None, tokens
    if tokens[0][0] == STATE_STRING or tokens[0][0] == STATE_IDENTIFIER and tokens[0][1].startswith('0x'):
        return [[FUNCTIONNAME_REPEAT, [[STATE_IDENTIFIER, '1'], tokens[0]]], tokens[1:]]
    if tokens[0][0] != STATE_IDENTIFIER:
        print('Parsing error')
        return None, tokens
    function = tokens[0][1]
    tokens = tokens[1:]
    if len(tokens) == 0:
        print('Parsing error')
        return None, tokens
    if tokens[0][0] != STATE_SPECIAL_CHAR or tokens[0][1] != '(':
        print('Parsing error')
        return None, tokens
    tokens = tokens[1:]
    if len(tokens) == 0:
        print('Parsing error')
        return None, tokens
    arguments = []
    while True:
        if tokens[0][0] != STATE_IDENTIFIER and tokens[0][0] != STATE_STRING:
            print('Parsing error')
            return None, tokens
        arguments.append(tokens[0])
        tokens = tokens[1:]
        if len(tokens) == 0:
            print('Parsing error')
            return None, tokens
        if tokens[0][0] != STATE_SPECIAL_CHAR or (tokens[0][1] != ',' and tokens[0][1] != ')'):
            print('Parsing error')
            return None, tokens
        if tokens[0][0] == STATE_SPECIAL_CHAR and tokens[0][1] == ')':
            tokens = tokens[1:]
            break
        tokens = tokens[1:]
        if len(tokens) == 0:
            print('Parsing error')
            return None, tokens
    return [[function, arguments], tokens]

def Parse(expression):
    tokens = Tokenize(expression)
    if len(tokens) == 0:
        print('Parsing error')
        return None
    if tokens[0][0] == STATE_ERROR:
        print(tokens[0][1])
        print(tokens[0][2])
        print(expression)
        return None
    functioncalls = []
    while True:
        functioncall, tokens = ParseFunction(tokens)
        if functioncall == None:
            return None
        functioncalls.append(functioncall)
        if len(tokens) == 0:
            return functioncalls
        if tokens[0][0] != STATE_SPECIAL_CHAR or tokens[0][1] != '+':
            print('Parsing error')
            return None
        tokens = tokens[1:]

def InterpretInteger(token):
    if token[0] != STATE_IDENTIFIER:
        return None
    try:
        return int(token[1])
    except:
        return None

def Hex2Bytes(hexadecimal):
    if len(hexadecimal) % 2 == 1:
        hexadecimal = '0' + hexadecimal
    try:
        return binascii.a2b_hex(hexadecimal)
    except:
        return None

def InterpretHexInteger(token):
    if token[0] != STATE_IDENTIFIER:
        return None
    if not token[1].startswith('0x'):
        return None
    bytes = Hex2Bytes(token[1][2:])
    if bytes == None:
        return None
    integer = 0
    for byte in bytes:
        integer = integer * 0x100 + C2IIP2(byte)
    return integer

def InterpretNumber(token):
    number = InterpretInteger(token)
    if number == None:
        return InterpretHexInteger(token)
    else:
        return number

def InterpretBytes(token):
    if token[0] == STATE_STRING:
        return token[1]
    if token[0] != STATE_IDENTIFIER:
        return None
    if not token[1].startswith('0x'):
        return None
    return Hex2Bytes(token[1][2:])

def CheckFunction(functionname, arguments, countarguments, maxcountarguments=None):
    if maxcountarguments == None:
        if countarguments == 0 and len(arguments) != 0:
            print('Error: function %s takes no arguments, %d are given' % (functionname, len(arguments)))
            return True
        if countarguments == 1 and len(arguments) != 1:
            print('Error: function %s takes 1 argument, %d are given' % (functionname, len(arguments)))
            return True
        if countarguments != len(arguments):
            print('Error: function %s takes %d arguments, %d are given' % (functionname, countarguments, len(arguments)))
            return True
    else:
        if len(arguments) < countarguments or len(arguments) > maxcountarguments:
            print('Error: function %s takes between %d and %d arguments, %d are given' % (functionname, countarguments, maxcountarguments, len(arguments)))
            return True
    return False

def CheckNumber(argument, minimum=None, maximum=None):
    number = InterpretNumber(argument)
    if number == None:
        print('Error: argument should be a number: %s' % argument[1])
        return None
    if minimum != None and number < minimum:
        print('Error: argument should be minimum %d: %d' % (minimum, number))
        return None
    if maximum != None and number > maximum:
        print('Error: argument should be maximum %d: %d' % (maximum, number))
        return None
    return number

def Interpret(expression):
    functioncalls = Parse(expression)
    if functioncalls == None:
        return None
    decoded = ''
    for functioncall in functioncalls:
        functionname, arguments = functioncall
        if functionname == FUNCTIONNAME_REPEAT:
            if CheckFunction(functionname, arguments, 2):
                return None
            number = CheckNumber(arguments[0], minimum=1)
            if number == None:
                return None
            bytes = InterpretBytes(arguments[1])
            if bytes == None:
                print('Error: argument should be a byte sequence: %s' % arguments[1][1])
                return None
            decoded += number * bytes
        elif functionname == FUNCTIONNAME_RANDOM:
            if CheckFunction(functionname, arguments, 1):
                return None
            number = CheckNumber(arguments[0], minimum=1)
            if number == None:
                return None
            decoded += ''.join([chr(random.randint(0, 255)) for x in range(number)])
        elif functionname == FUNCTIONNAME_LOREMIPSUM:
            if CheckFunction(functionname, arguments, 1):
                return None
            number = CheckNumber(arguments[0], minimum=1)
            if number == None:
                return None
            decoded += LoremIpsum(number)
        elif functionname == FUNCTIONNAME_CHR:
            if CheckFunction(functionname, arguments, 1, 2):
                return None
            number = CheckNumber(arguments[0], minimum=1, maximum=255)
            if number == None:
                return None
            if len(arguments) == 1:
                decoded += chr(number)
            else:
                number2 = CheckNumber(arguments[1], minimum=1, maximum=255)
                if number2 == None:
                    return None
                if number < number2:
                    decoded += ''.join([chr(n) for n in range(number, number2 + 1)])
                else:
                    decoded += ''.join([chr(n) for n in range(number, number2 - 1, -1)])
        else:
            print('Error: unknown function: %s' % functionname)
            return None
    return decoded

FCH_FILENAME = 0
FCH_DATA = 1
FCH_ERROR = 2

def FilenameCheckHash(filename, literalfilename):
    if literalfilename:
        return FCH_FILENAME, filename
    elif filename.startswith('#h#'):
        result = Hex2Bytes(filename[3:])
        if result == None:
            return FCH_ERROR, 'hexadecimal'
        else:
            return FCH_DATA, result
    elif filename.startswith('#b#'):
        try:
            return FCH_DATA, binascii.a2b_base64(filename[3:])
        except:
            return FCH_ERROR, 'base64'
    elif filename.startswith('#e#'):
        result = Interpret(filename[3:])
        if result == None:
            return FCH_ERROR, 'expression'
        else:
            return FCH_DATA, result
    elif filename.startswith('#'):
        return FCH_DATA, C2BIP3(filename[1:])
    else:
        return FCH_FILENAME, filename

def AnalyzeFileError(filename):
    PrintError('Error opening file %s' % filename)
    PrintError(sys.exc_info()[1])
    try:
        if not os.path.exists(filename):
            PrintError('The file does not exist')
        elif os.path.isdir(filename):
            PrintError('The file is a directory')
        elif not os.path.isfile(filename):
            PrintError('The file is not a regular file')
    except:
        pass

def CreateZipFileObject(arg1, arg2):
    if 'AESZipFile' in dir(zipfile):
        return zipfile.AESZipFile(arg1, arg2)
    else:
        return zipfile.ZipFile(arg1, arg2)

class cBinaryFile:
    def __init__(self, filename, zippassword='infected', noextraction=False, literalfilename=False):
        self.filename = filename
        self.zippassword = zippassword
        self.noextraction = noextraction
        self.literalfilename = literalfilename
        self.oZipfile = None
        self.extracted = False
        self.fIn = None

        fch, data = FilenameCheckHash(self.filename, self.literalfilename)
        if fch == FCH_ERROR:
            line = 'Error %s parsing filename: %s' % (data, self.filename)
            raise Exception(line)

        try:
            if self.filename == '':
                if sys.platform == 'win32':
                    import msvcrt
                    msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
                self.fIn = sys.stdin
            elif fch == FCH_DATA:
                self.fIn = DataIO(data)
            elif not self.noextraction and self.filename.lower().endswith('.zip'):
                self.oZipfile = CreateZipFileObject(self.filename, 'r')
                if len(self.oZipfile.infolist()) == 1:
                    self.fIn = self.oZipfile.open(self.oZipfile.infolist()[0], 'r', self.zippassword)
                    self.extracted = True
                else:
                    self.oZipfile.close()
                    self.oZipfile = None
                    self.fIn = open(self.filename, 'rb')
            elif not self.noextraction and self.filename.lower().endswith('.gz'):
                self.fIn = gzip.GzipFile(self.filename, 'rb')
                self.extracted = True
            else:
                self.fIn = open(self.filename, 'rb')
        except:
            AnalyzeFileError(self.filename)
            raise

    def close(self):
        if self.fIn != sys.stdin and self.fIn != None:
            self.fIn.close()
        if self.oZipfile != None:
            self.oZipfile.close()

    def read(self, size=None):
        try:
            fRead = self.fIn.buffer
        except:
            fRead = self.fIn
        if size == None:
            return fRead.read()
        else:
            return fRead.read(size)

    def Data(self):
        data = self.read()
        self.close()
        return data

#-ENDCODE cBinaryFile--------------------------------------------------------------------------------

def File2Strings(filename):
    try:
        if filename == '':
            f = sys.stdin
        else:
            f = open(filename, 'r')
    except:
        return None
    try:
        return map(lambda line:line.rstrip('\n'), f.readlines())
    except:
        return None
    finally:
        if f != sys.stdin:
            f.close()

def File2String(filename):
    try:
        f = open(filename, 'rb')
    except:
        return None
    try:
        return f.read()
    except:
        return None
    finally:
        f.close()

def ProcessAt(argument):
    if argument.startswith('@'):
        strings = File2Strings(argument[1:])
        if strings == None:
            raise Exception('Error reading %s' % argument)
        else:
            return strings
    else:
        return [argument]

def Glob(filename):
    filenames = glob.glob(filename)
    if len(filenames) == 0:
        return [filename]
    else:
        return filenames

class cExpandFilenameArguments():
    def __init__(self, filenames, literalfilenames=False, recursedir=False, checkfilenames=False, expressionprefix=None, flagprefix=None):
        self.containsUnixShellStyleWildcards = False
        self.warning = False
        self.message = ''
        self.filenameexpressionsflags = []
        self.expressionprefix = expressionprefix
        self.flagprefix = flagprefix
        self.literalfilenames = literalfilenames

        expression = ''
        flag = ''
        if len(filenames) == 0:
            self.filenameexpressionsflags = [['', '', '']]
        elif literalfilenames:
            self.filenameexpressionsflags = [[filename, '', ''] for filename in filenames]
        elif recursedir:
            for dirwildcard in filenames:
                if expressionprefix != None and dirwildcard.startswith(expressionprefix):
                    expression = dirwildcard[len(expressionprefix):]
                elif flagprefix != None and dirwildcard.startswith(flagprefix):
                    flag = dirwildcard[len(flagprefix):]
                else:
                    if dirwildcard.startswith('@'):
                        for filename in ProcessAt(dirwildcard):
                            self.filenameexpressionsflags.append([filename, expression, flag])
                    elif os.path.isfile(dirwildcard):
                        self.filenameexpressionsflags.append([dirwildcard, expression, flag])
                    else:
                        if os.path.isdir(dirwildcard):
                            dirname = dirwildcard
                            basename = '*'
                        else:
                            dirname, basename = os.path.split(dirwildcard)
                            if dirname == '':
                                dirname = '.'
                        for path, dirs, files in os.walk(dirname):
                            for filename in fnmatch.filter(files, basename):
                                self.filenameexpressionsflags.append([os.path.join(path, filename), expression, flag])
        else:
            for filename in list(collections.OrderedDict.fromkeys(sum(map(self.Glob, sum(map(ProcessAt, filenames), [])), []))):
                if expressionprefix != None and filename.startswith(expressionprefix):
                    expression = filename[len(expressionprefix):]
                elif flagprefix != None and filename.startswith(flagprefix):
                    flag = filename[len(flagprefix):]
                else:
                    self.filenameexpressionsflags.append([filename, expression, flag])
            self.warning = self.containsUnixShellStyleWildcards and len(self.filenameexpressionsflags) == 0
            if self.warning:
                self.message = "Your filename argument(s) contain Unix shell-style wildcards, but no files were matched.\nCheck your wildcard patterns or use option literalfilenames if you don't want wildcard pattern matching."
                return
        if self.filenameexpressionsflags == [] and (expression != '' or flag != ''):
            self.filenameexpressionsflags = [['', expression, flag]]
        if checkfilenames:
            self.CheckIfFilesAreValid()

    def Glob(self, filename):
        if not ('?' in filename or '*' in filename or ('[' in filename and ']' in filename)):
            return [filename]
        self.containsUnixShellStyleWildcards = True
        return glob.glob(filename)

    def CheckIfFilesAreValid(self):
        valid = []
        doesnotexist = []
        isnotafile = []
        for filename, expression, flag in self.filenameexpressionsflags:
            hashfile = False
            try:
                hashfile = FilenameCheckHash(filename, self.literalfilenames)[0] == FCH_DATA
            except:
                pass
            if filename == '' or hashfile:
                valid.append([filename, expression, flag])
            elif not os.path.exists(filename):
                doesnotexist.append(filename)
            elif not os.path.isfile(filename):
                isnotafile.append(filename)
            else:
                valid.append([filename, expression, flag])
        self.filenameexpressionsflags = valid
        if len(doesnotexist) > 0:
            self.warning = True
            self.message += 'The following files do not exist and will be skipped: ' + ' '.join(doesnotexist) + '\n'
        if len(isnotafile) > 0:
            self.warning = True
            self.message += 'The following files are not regular files and will be skipped: ' + ' '.join(isnotafile) + '\n'

    def Filenames(self):
        if self.expressionprefix == None:
            return [filename for filename, expression, flag in self.filenameexpressionsflags]
        else:
            return self.filenameexpressionsflags

def CheckJSON(stringJSON):
    try:
        object = json.loads(stringJSON)
    except:
        print('Error parsing JSON')
        print(sys.exc_info()[1])
        return None
    if not isinstance(object, dict):
        print('Error JSON is not a dictionary')
        return None
    if not 'version' in object:
        print('Error JSON dictionary has no version')
        return None
    if object['version'] != 2:
        print('Error JSON dictionary has wrong version')
        return None
    if not 'id' in object:
        print('Error JSON dictionary has no id')
        return None
    if object['id'] != 'didierstevens.com':
        print('Error JSON dictionary has wrong id')
        return None
    if not 'type' in object:
        print('Error JSON dictionary has no type')
        return None
    if object['type'] != 'content':
        print('Error JSON dictionary has wrong type')
        return None
    if not 'fields' in object:
        print('Error JSON dictionary has no fields')
        return None
    if not 'name' in object['fields']:
        print('Error JSON dictionary has no name field')
        return None
    if not 'content' in object['fields']:
        print('Error JSON dictionary has no content field')
        return None
    if not 'items' in object:
        print('Error JSON dictionary has no items')
        return None
    for item in object['items']:
        item['content'] = binascii.a2b_base64(item['content'])
    return object['items']

CUTTERM_NOTHING = 0
CUTTERM_POSITION = 1
CUTTERM_FIND = 2
CUTTERM_LENGTH = 3

def Replace(string, dReplacements):
    if string in dReplacements:
        return dReplacements[string]
    else:
        return string

def ParseInteger(argument):
    sign = 1
    if argument.startswith('+'):
        argument = argument[1:]
    elif argument.startswith('-'):
        argument = argument[1:]
        sign = -1
    if argument.startswith('0x'):
        return sign * int(argument[2:], 16)
    else:
        return sign * int(argument)

def ParseCutTerm(argument):
    if argument == '':
        return CUTTERM_NOTHING, None, ''
    oMatch = re.match(r'\-?0x([0-9a-f]+)', argument, re.I)
    if oMatch == None:
        oMatch = re.match(r'\-?(\d+)', argument)
    else:
        value = int(oMatch.group(1), 16)
        if argument.startswith('-'):
            value = -value
        return CUTTERM_POSITION, value, argument[len(oMatch.group(0)):]
    if oMatch == None:
        oMatch = re.match(r'\[([0-9a-f]+)\](\d+)?([+-](?:0x[0-9a-f]+|\d+))?', argument, re.I)
    else:
        value = int(oMatch.group(1))
        if argument.startswith('-'):
            value = -value
        return CUTTERM_POSITION, value, argument[len(oMatch.group(0)):]
    if oMatch == None:
        oMatch = re.match(r"\[u?\'(.+?)\'\](\d+)?([+-](?:0x[0-9a-f]+|\d+))?", argument)
    else:
        if len(oMatch.group(1)) % 2 == 1:
            raise Exception("Uneven length hexadecimal string")
        else:
            return CUTTERM_FIND, (binascii.a2b_hex(oMatch.group(1)), int(Replace(oMatch.group(2), {None: '1'})), ParseInteger(Replace(oMatch.group(3), {None: '0'}))), argument[len(oMatch.group(0)):]
    if oMatch == None:
        return None, None, argument
    else:
        if argument.startswith("[u'"):
            # convert ascii to unicode 16 byte sequence
            searchtext = oMatch.group(1).decode('unicode_escape').encode('utf16')[2:]
        else:
            searchtext = oMatch.group(1)
        return CUTTERM_FIND, (searchtext, int(Replace(oMatch.group(2), {None: '1'})), ParseInteger(Replace(oMatch.group(3), {None: '0'}))), argument[len(oMatch.group(0)):]

def ParseCutArgument(argument):
    type, value, remainder = ParseCutTerm(argument.strip())
    if type == CUTTERM_NOTHING:
        return CUTTERM_NOTHING, None, CUTTERM_NOTHING, None
    elif type == None:
        if remainder.startswith(':'):
            typeLeft = CUTTERM_NOTHING
            valueLeft = None
            remainder = remainder[1:]
        else:
            return None, None, None, None
    else:
        typeLeft = type
        valueLeft = value
        if typeLeft == CUTTERM_POSITION and valueLeft < 0:
            return None, None, None, None
        if typeLeft == CUTTERM_FIND and valueLeft[1] == 0:
            return None, None, None, None
        if remainder.startswith(':'):
            remainder = remainder[1:]
        else:
            return None, None, None, None
    type, value, remainder = ParseCutTerm(remainder)
    if type == CUTTERM_POSITION and remainder == 'l':
        return typeLeft, valueLeft, CUTTERM_LENGTH, value
    elif type == None or remainder != '':
        return None, None, None, None
    elif type == CUTTERM_FIND and value[1] == 0:
        return None, None, None, None
    else:
        return typeLeft, valueLeft, type, value

def Find(data, value, nth, startposition=-1):
    position = startposition
    while nth > 0:
        position = data.find(value, position + 1)
        if position == -1:
            return -1
        nth -= 1
    return position

def CutData(stream, cutArgument):
    if cutArgument == '':
        return [stream, None, None]

    typeLeft, valueLeft, typeRight, valueRight = ParseCutArgument(cutArgument)

    if typeLeft == None:
        return [stream, None, None]

    if typeLeft == CUTTERM_NOTHING:
        positionBegin = 0
    elif typeLeft == CUTTERM_POSITION:
        positionBegin = valueLeft
    elif typeLeft == CUTTERM_FIND:
        positionBegin = Find(stream, valueLeft[0], valueLeft[1])
        if positionBegin == -1:
            return ['', None, None]
        positionBegin += valueLeft[2]
    else:
        raise Exception("Unknown value typeLeft")

    if typeRight == CUTTERM_NOTHING:
        positionEnd = len(stream)
    elif typeRight == CUTTERM_POSITION and valueRight < 0:
        positionEnd = len(stream) + valueRight
    elif typeRight == CUTTERM_POSITION:
        positionEnd = valueRight + 1
    elif typeRight == CUTTERM_LENGTH:
        positionEnd = positionBegin + valueRight
    elif typeRight == CUTTERM_FIND:
        positionEnd = Find(stream, valueRight[0], valueRight[1], positionBegin)
        if positionEnd == -1:
            return ['', None, None]
        else:
            positionEnd += len(valueRight[0])
        positionEnd += valueRight[2]
    else:
        raise Exception("Unknown value typeRight")

    return [stream[positionBegin:positionEnd], positionBegin, positionEnd]

#-BEGINCODE cDump------------------------------------------------------------------------------------
#import binascii
#import sys
#if sys.version_info[0] >= 3:
#    from io import StringIO
#else:
#    from cStringIO import StringIO

class cDump():
    def __init__(self, data, prefix='', offset=0, dumplinelength=16):
        self.data = data
        self.prefix = prefix
        self.offset = offset
        self.dumplinelength = dumplinelength

    def HexDump(self):
        oDumpStream = self.cDumpStream(self.prefix)
        hexDump = ''
        for i, b in enumerate(self.data):
            if i % self.dumplinelength == 0 and hexDump != '':
                oDumpStream.Addline(hexDump)
                hexDump = ''
            hexDump += IFF(hexDump == '', '', ' ') + '%02X' % self.C2IIP2(b)
        oDumpStream.Addline(hexDump)
        return oDumpStream.Content()

    def CombineHexAscii(self, hexDump, asciiDump):
        if hexDump == '':
            return ''
        countSpaces = 3 * (self.dumplinelength - len(asciiDump))
        if len(asciiDump) <= self.dumplinelength / 2:
            countSpaces += 1
        return hexDump + '  ' + (' ' * countSpaces) + asciiDump

    def HexAsciiDump(self, rle=False):
        oDumpStream = self.cDumpStream(self.prefix)
        position = ''
        hexDump = ''
        asciiDump = ''
        previousLine = None
        countRLE = 0
        for i, b in enumerate(self.data):
            b = self.C2IIP2(b)
            if i % self.dumplinelength == 0:
                if hexDump != '':
                    line = self.CombineHexAscii(hexDump, asciiDump)
                    if not rle or line != previousLine:
                        if countRLE > 0:
                            oDumpStream.Addline('* %d 0x%02x' % (countRLE, countRLE * self.dumplinelength))
                        oDumpStream.Addline(position + line)
                        countRLE = 0
                    else:
                        countRLE += 1
                    previousLine = line
                position = '%08X:' % (i + self.offset)
                hexDump = ''
                asciiDump = ''
            if i % self.dumplinelength == self.dumplinelength / 2:
                hexDump += ' '
            hexDump += ' %02X' % b
            asciiDump += IFF(b >= 32 and b < 128, chr(b), '.')
        if countRLE > 0:
            oDumpStream.Addline('* %d 0x%02x' % (countRLE, countRLE * self.dumplinelength))
        oDumpStream.Addline(self.CombineHexAscii(position + hexDump, asciiDump))
        return oDumpStream.Content()

    def Base64Dump(self, nowhitespace=False):
        encoded = binascii.b2a_base64(self.data)
        if nowhitespace:
            return encoded
        encoded = encoded.strip()
        oDumpStream = self.cDumpStream(self.prefix)
        length = 64
        for i in range(0, len(encoded), length):
            oDumpStream.Addline(encoded[0+i:length+i])
        return oDumpStream.Content()

    class cDumpStream():
        def __init__(self, prefix=''):
            self.oStringIO = StringIO()
            self.prefix = prefix

        def Addline(self, line):
            if line != '':
                self.oStringIO.write(self.prefix + line + '\n')

        def Content(self):
            return self.oStringIO.getvalue()

    @staticmethod
    def C2IIP2(data):
        if sys.version_info[0] > 2:
            return data
        else:
            return ord(data)
#-ENDCODE cDump--------------------------------------------------------------------------------------

def IfWIN32SetBinary(io):
    if sys.platform == 'win32':
        import msvcrt
        msvcrt.setmode(io.fileno(), os.O_BINARY)

#Fix for http://bugs.python.org/issue11395
def StdoutWriteChunked(data):
    if sys.version_info[0] > 2:
        sys.stdout.buffer.write(data)
    else:
        while data != '':
            sys.stdout.write(data[0:10000])
            try:
                sys.stdout.flush()
            except IOError:
                return
            data = data[10000:]

class cVariables():
    def __init__(self, variablesstring='', separator=DEFAULT_SEPARATOR):
        self.dVariables = {}
        if variablesstring == '':
            return
        for variable in variablesstring.split(separator):
            name, value = VariableNameValue(variable)
            self.dVariables[name] = value

    def SetVariable(self, name, value):
        self.dVariables[name] = value

    def Instantiate(self, astring):
        for key, value in self.dVariables.items():
            astring = astring.replace('%' + key + '%', value)
        return astring

class cOutput():
    def __init__(self, filenameOption=None):
        self.starttime = time.time()
        self.filenameOption = filenameOption
        self.separateFiles = False
        self.progress = False
        self.console = False
        self.head = False
        self.headCounter = 0
        self.tail = False
        self.tailQueue = []
        self.fOut = None
        self.rootFilenames = {}
        if self.filenameOption:
            if self.ParseHash(self.filenameOption):
                if not self.separateFiles and self.filename != '':
                    self.fOut = open(self.filename, 'w')
            elif self.filenameOption != '':
                self.fOut = open(self.filenameOption, 'w')

        self.dReplacements = {}

    def Replace(self, line):
        for key, value in self.dReplacements.items():
            line = line.replace(key, value)
        return line

    def ParseHash(self, option):
        if option.startswith('#'):
            position = self.filenameOption.find('#', 1)
            if position > 1:
                switches = self.filenameOption[1:position]
                self.filename = self.filenameOption[position + 1:]
                for switch in switches:
                    if switch == 's':
                        self.separateFiles = True
                    elif switch == 'p':
                        self.progress = True
                    elif switch == 'c':
                        self.console = True
                    elif switch == 'l':
                        pass
                    elif switch == 'g':
                        if self.filename != '':
                            extra = self.filename + '-'
                        else:
                            extra = ''
                        self.filename = '%s-%s%s.txt' % (os.path.splitext(os.path.basename(sys.argv[0]))[0], extra, self.FormatTime())
                    elif switch == 'h':
                        self.head = True
                    elif switch == 't':
                        self.tail = True
                    else:
                        return False
                return True
        return False

    @staticmethod
    def FormatTime(epoch=None):
        if epoch == None:
            epoch = time.time()
        return '%04d%02d%02d-%02d%02d%02d' % time.localtime(epoch)[0:6]

    def RootUnique(self, root):
        if not root in self.rootFilenames:
            self.rootFilenames[root] = None
            return root
        iter = 1
        while True:
            newroot = '%s_%04d' % (root, iter)
            if not newroot in self.rootFilenames:
                self.rootFilenames[newroot] = None
                return newroot
            iter += 1

    def LineSub(self, line, eol):
        line = self.Replace(line)
        if self.fOut == None or self.console:
            try:
                print(line, end=eol)
            except UnicodeEncodeError:
                encoding = sys.stdout.encoding
                print(line.encode(encoding, errors='backslashreplace').decode(encoding), end=eol)
#            sys.stdout.flush()
        if self.fOut != None:
            self.fOut.write(line + '\n')
            self.fOut.flush()

    def Line(self, line, eol='\n'):
        if self.head:
            if self.headCounter < 10:
                self.LineSub(line, eol)
            elif self.tail:
                self.tailQueue = self.tailQueue[-9:] + [[line, eol]]
            self.headCounter += 1
        elif self.tail:
            self.tailQueue = self.tailQueue[-9:] + [[line, eol]]
        else:
            self.LineSub(line, eol)

    def LineTimestamped(self, line):
        self.Line('%s: %s' % (self.FormatTime(), line))

    def Filename(self, filename, index, total):
        self.separateFilename = filename
        if self.progress:
            if index == 0:
                eta = ''
            else:
                seconds = int(float((time.time() - self.starttime) / float(index)) * float(total - index))
                eta = 'estimation %d seconds left, finished %s ' % (seconds, self.FormatTime(time.time() + seconds))
            PrintError('%d/%d %s%s' % (index + 1, total, eta, self.separateFilename))
        if self.separateFiles and self.filename != '':
            oFilenameVariables = cVariables()
            oFilenameVariables.SetVariable('f', self.separateFilename)
            basename = os.path.basename(self.separateFilename)
            oFilenameVariables.SetVariable('b', basename)
            oFilenameVariables.SetVariable('d', os.path.dirname(self.separateFilename))
            root, extension = os.path.splitext(basename)
            oFilenameVariables.SetVariable('r', root)
            oFilenameVariables.SetVariable('ru', self.RootUnique(root))
            oFilenameVariables.SetVariable('e', extension)

            self.Close()
            self.fOut = open(oFilenameVariables.Instantiate(self.filename), 'w')

    def Close(self):
        if self.head and self.tail and len(self.tailQueue) > 0:
            self.LineSub('...', '\n')

        for line, eol in self.tailQueue:
            self.LineSub(line, eol)

        self.headCounter = 0
        self.tailQueue = []

        if self.fOut != None:
            self.fOut.close()
            self.fOut = None

def ToString(value):
    if isinstance(value, str):
        return value
    else:
        return str(value)

def Quote(value, separator, quote):
    value = ToString(value)
    if len(value) > 1 and value[0] == quote and value[-1] == quote:
        return value
    if separator in value or value == '':
        return quote + value + quote
    else:
        return value

def MakeCSVLine(row, separator=',', quote='"'):
    return separator.join([Quote(value, separator, quote) for value in row])

class cLogfile():
    def __init__(self, keyword, comment):
        self.starttime = time.time()
        self.errors = 0
        if keyword == '':
            self.oOutput = None
        else:
            self.oOutput = cOutput('%s-%s-%s.log' % (os.path.splitext(os.path.basename(sys.argv[0]))[0], keyword, self.FormatTime()))
        self.Line('Start')
        self.Line('UTC', '%04d%02d%02d-%02d%02d%02d' % time.gmtime(time.time())[0:6])
        self.Line('Comment', comment)
        self.Line('Args', repr(sys.argv))
        self.Line('Version', __version__)
        self.Line('Python', repr(sys.version_info))
        self.Line('Platform', sys.platform)
        self.Line('CWD', repr(os.getcwd()))

    @staticmethod
    def FormatTime(epoch=None):
        if epoch == None:
            epoch = time.time()
        return '%04d%02d%02d-%02d%02d%02d' % time.localtime(epoch)[0:6]

    def Line(self, *line):
        if self.oOutput != None:
            self.oOutput.Line(MakeCSVLine((self.FormatTime(), ) + line, DEFAULT_SEPARATOR, QUOTE))

    def LineError(self, *line):
        self.Line('Error', *line)
        self.errors += 1

    def Close(self):
        if self.oOutput != None:
            self.Line('Finish', '%d error(s)' % self.errors, '%d second(s)' % (time.time() - self.starttime))
            self.oOutput.Close()

def CalculateByteStatistics(dPrevalence=None, data=None):
    averageConsecutiveByteDifference = None
    if dPrevalence == None:
        dPrevalence = {iter: 0 for iter in range(0x100)}
        sumDifferences = 0.0
        previous = None
        if len(data) > 1:
            for byte in data:
                byte = C2IIP2(byte)
                dPrevalence[byte] += 1
                if previous != None:
                    sumDifferences += abs(byte - previous)
                previous = byte
            averageConsecutiveByteDifference = sumDifferences /float(len(data)-1)
    sumValues = sum(dPrevalence.values())
    countNullByte = dPrevalence[0]
    countControlBytes = 0
    countWhitespaceBytes = 0
    countUniqueBytes = 0
    for iter in range(1, 0x21):
        if chr(iter) in string.whitespace:
            countWhitespaceBytes += dPrevalence[iter]
        else:
            countControlBytes += dPrevalence[iter]
    countControlBytes += dPrevalence[0x7F]
    countPrintableBytes = 0
    for iter in range(0x21, 0x7F):
        countPrintableBytes += dPrevalence[iter]
    countHighBytes = 0
    for iter in range(0x80, 0x100):
        countHighBytes += dPrevalence[iter]
    countHexadecimalBytes = 0
    countBASE64Bytes = 0
    for iter in range(0x30, 0x3A):
        countHexadecimalBytes += dPrevalence[iter]
        countBASE64Bytes += dPrevalence[iter]
    for iter in range(0x41, 0x47):
        countHexadecimalBytes += dPrevalence[iter]
    for iter in range(0x61, 0x67):
        countHexadecimalBytes += dPrevalence[iter]
    for iter in range(0x41, 0x5B):
        countBASE64Bytes += dPrevalence[iter]
    for iter in range(0x61, 0x7B):
        countBASE64Bytes += dPrevalence[iter]
    countBASE64Bytes += dPrevalence[ord('+')] + dPrevalence[ord('/')] + dPrevalence[ord('=')]
    entropy = 0.0
    for iter in range(0x100):
        if dPrevalence[iter] > 0:
            prevalence = float(dPrevalence[iter]) / float(sumValues)
            entropy += - prevalence * math.log(prevalence, 2)
            countUniqueBytes += 1
    return sumValues, entropy, countUniqueBytes, countNullByte, countControlBytes, countWhitespaceBytes, countPrintableBytes, countHighBytes, countHexadecimalBytes, countBASE64Bytes, averageConsecutiveByteDifference

def GetChunk(position, data):
    return [data[:position], data[position:]]

def InstantiateCOutput(options):
    filenameOption = None
    if options.output != '':
        filenameOption = options.output
    return cOutput(filenameOption)

def Unpack(format, data):
    size = struct.calcsize(format)
    result = list(struct.unpack(format, data[:size]))
    result.append(data[size:])
    return result

def Represent(data):
    if sum([ord(c) for c in data]) == 0:
        return '(NULL ...)'
    else:
        return repr(data.rstrip('\x00'))

def PrefixIfNeeded(string, prefix=' '):
    if string == '':
        return string
    else:
        return prefix + string

def Xor(data, key):
    data = C2SIP3(data)
    key = C2SIP3(key)
    return C2BIP3(''.join(chr(ord(data[i]) ^ ord(key[i % len(key)])) for i in range(len(data))))

def FindAll(data, sub):
    result = []
    start = 0
    while True:
        position = data.find(sub, start)
        if position == -1:
            return result
        result.append(position)
        start = position + 1

def FindAllList(data, searches):
    result = []
    for element in searches:
        result.extend(FindAll(data, element))
    return sorted(list(set(result)))

def DecodeSectionnameIfNeeded(name):
    if len(name) == 0 or name.startswith('.'):
        return name
    xorkey = ord(name[0]) ^ ord('.')
    newname = ''.join([chr(ord(c) ^ xorkey) for c in name]).rstrip('\x00')
    return newname

def GetDataSection(data):
    sectionnames = []
    try:
        oPE = pefile.PE(data=data)
    except Exception as e:
        return e.value, None
    for section in oPE.sections:
        if sys.version_info[0] >= 3:
            sectionname = ''.join(filter(lambda c:c != '\0', str(section.Name.decode('unicode_escape'))))
        else:
            sectionname = ''.join(filter(lambda c:c != '\0', section.Name))
        sectionnames.append(repr(sectionname))
        if DecodeSectionnameIfNeeded(sectionname) == '.data':
            return None, section.get_data()
    return '.data section not found: ' + ' '.join(sectionnames), None

def GetXorChainSection(data):
    try:
        oPE = pefile.PE(data=data)
    except Exception as e:
        return None, e.value
    for section in oPE.sections:
        extracted, messages = TryXORChainDecoding(section.get_data())
        if messages != []:
            return extracted, messages
    return None, None

def StatisticalSearch(payloadsectiondata, key):
    start = None
    end = None
    position = 0
    while len(payloadsectiondata) > 8:
        block, payloadsectiondata = GetChunk(8, payloadsectiondata)
        if sum([IFF(c == key, 1, 0) for c in block]) > 2:
            if start == None:
                start = position
                end = position + 7
            else:
                end = position + 7
        position += 8
    return start, end

def Bytes2IPv4(data):
    return '%d.%d.%d.%d' % (P23Ord(data[0]), P23Ord(data[1]), P23Ord(data[2]), P23Ord(data[3]))

def FindAF_INET_PORT(operand):
    if P23Ord(operand[0]) != 2:
        return ''
    if P23Ord(operand[1]) != 0:
        return ''
    return '%d' % struct.unpack('>H', operand[2:4])[0]

def IdentifyShellcode(shellcode):
    if hashlib.sha256(shellcode[:346]).hexdigest() == '946af5a23e5403ea1caccb2e0988ec1526b375a3e919189f16491eeabc3e7d8c':
        return 'CS psexec psh x86 shellcode, opens named pipe'
    elif hashlib.sha256(shellcode[:191]).hexdigest() == '02fd615831f5cc22d83ad681d33159d232afc3b18b69f647f1726280e2d7e3f3':
        return 'CS reverse http x86 shellcode'
    elif hashlib.sha256(shellcode[:271]).hexdigest() == 'bf413ba9b63b6777c4765581bf42c1fdb119f1ed22836cfaa80e616e2a3bf795':
        return 'CS reverse http x64 shellcode'
    elif hashlib.sha256(shellcode[:196]).hexdigest() == '52230666746fa8c9ec635083b05943d02bfe516fc45ea9c87eef300b9cd064e8':
        return 'CS reverse https x86 shellcode'
    elif hashlib.sha256(shellcode[:274]).hexdigest() == 'acffe4f9fd8f82044772627a4174f14abf873a8e783c31353bf094118f3c1706':
        return 'CS reverse https x64 shellcode'
    elif hashlib.sha256(shellcode[:330]).hexdigest() == 'a82872e2d839cd2ee1b0c2324b83f2686284ebe3eef5e9fb0c9e97db8d86cbf4':
        return 'CS DNS x86 shellcode'
    return ''

def AnalyzeShellcode(shellcode, oOutput):
    dInstructions = {b'\x68': 'push', b'\xB8': 'mov eax'}
    dJSONData = GetJSONData()
    dLookupValues = dJSONData.get('dLookupValues', {})

    identification = IdentifyShellcode(shellcode)
    if identification != '':
        oOutput.Line('Identification: %s' % identification)
    position = shellcode.rfind(b'\xFF\xFF')
    if position != -1:
        parameters = shellcode[position+2:]
        position00 = parameters.find(b'\x00')
        remainder = b''
        if position00 != -1:
            remainder = parameters[position00 + 1:]
            parameters = parameters[:position00]
        oOutput.Line('Parameter: %d %s' % (position, repr(parameters)))
        if len(remainder) == 4:
            licenseid = struct.unpack('>I',remainder)[0]
            info = 'license-id: %d %d' % (position + position00 + 1, licenseid)
            info += LookupValue("37", '%d' % licenseid, dLookupValues)
            oOutput.Line(info)
    for pushPosition in FindAllList(shellcode, dInstructions.keys()):
        if pushPosition + 5 <= len(shellcode):
            if position == -1:
                operand = shellcode[pushPosition + 1:pushPosition + 5]
                oOutput.Line('%-10s: %5d %10d %5s %-16s %s' % (dInstructions[shellcode[pushPosition:pushPosition+1]], pushPosition, struct.unpack('<I', operand)[0], FindAF_INET_PORT(operand), Bytes2IPv4(operand), repr(shellcode[pushPosition:pushPosition + 5])))
            elif shellcode[pushPosition + 3:pushPosition + 5] == b'\x00\x00':
                oOutput.Line('%-10s: %5d %10d %s' % (dInstructions[shellcode[pushPosition:pushPosition+1]], pushPosition, struct.unpack('<H', shellcode[pushPosition + 1:pushPosition + 3])[0], repr(shellcode[pushPosition:pushPosition + 5])))

    for str in ExtractStringsASCII(shellcode):
        if len(str) == 5 and str.startswith(b'/') or str.startswith(b'User-Agent: ') or str.startswith(b'Mozilla/'):
            positions = FindAll(shellcode, str)
            oOutput.Line('String: %s %s' % (','.join(['%d' % position for position in positions]),str))

REGEX_STANDARD = b'[\x09\x20-\x7E]'

def ExtractStringsASCII(data):
    regex = REGEX_STANDARD + b'{%d,}'
    return re.findall(regex % 1, data)

def LookupConfigValue(id, value):
    dConfigValues = {
        0x0001: {
            0: 'windows-beacon_http-reverse_http',
            1: 'windows-beacon_dns-reverse_http',
            2: 'windows-beacon_smb-bind_pipz',
            8: 'windows-beacon_https-reverse_https',
            16: 'windows-beacon_tcp-bind_tcp',
        },
        0x0023: {
            1: 'no proxy',
            2: 'IE settings',
            4: 'hardcoded proxy',
        },
        0x002b: {
            0x01: 'PAGE_NOACCESS',
            0x02: 'PAGE_READONLY',
            0x04: 'PAGE_READWRITE',
            0x08: 'PAGE_WRITECOPY',
            0x10: 'PAGE_EXECUTE',
            0x20: 'PAGE_EXECUTE_READ',
            0x40: 'PAGE_EXECUTE_READWRITE',
            0x80: 'PAGE_EXECUTE_WRITECOPY',
        },
    }
    return PrefixIfNeeded(dConfigValues[id].get(value, ''))

def ConvertIntToIPv4(value):
    return ' %d.%d.%d.%d' % (C2IIP2(value[0]), C2IIP2(value[1]), C2IIP2(value[2]), C2IIP2(value[3]))

def ToHexadecimal(value):
    return binascii.b2a_hex(value).decode()

def LookupValue(number, value, dInfo, verbose=False):
    lookup = ''
    if number in dInfo:
        lookup = dInfo[number].get(value, '')
    if isinstance(lookup, dict):
        message = lookup['normal']
        if verbose:
            message += ' (%s)' % lookup['verbose']
        lookup = message
    return PrefixIfNeeded(lookup)

def InterpretValue(info, number, value, dConfigValueInterpreter):
    interpreted = ''
    if number in dConfigValueInterpreter:
        interpreted = dConfigValueInterpreter[number](value)
    return info + interpreted

def GetScriptPath():
    if getattr(sys, 'frozen', False):
        return os.path.dirname(sys.executable)
    else:
        return os.path.dirname(sys.argv[0])

def DetermineCSVersionFromConfig(dJSON):
    maximumID = max(map(int, dJSON.keys()))
    if maximumID < 55:
        return ('3', maximumID)
    elif maximumID == 55:
        return ('4.0', maximumID)
    elif maximumID > 55 and maximumID < 58:
        return ('4.1', maximumID)
    elif maximumID == 58:
        return ('4.2', maximumID)
    elif maximumID == 70:
        return ('4.3', maximumID)
    else:
        return ('4.4', maximumID)

def SanityCheckExtractedConfig(dJSON):
    if not 1 in dJSON:
        return False
    if not 8 in dJSON:
        return False
    if LookupConfigValue(1, dJSON[1]['rawvalue']) == '':
        return False
    if not dJSON[7]['rawvalue'].startswith('308'):
        return False
    return True

def GetJSONData():
    filename = os.path.join(GetScriptPath(), '1768b.json')
    if os.path.isfile(filename):
        return json.load(open(filename, 'r'))
    filename = os.path.join(GetScriptPath(), '1768.json')
    if os.path.isfile(filename):
        return json.load(open(filename, 'r'))
    return {}

class cStruct(object):
    def __init__(self, data):
        self.data = data
        self.originaldata = data

    def Unpack(self, format):
        formatsize = struct.calcsize(format)
        if len(self.data) < formatsize:
            raise Exception('Not enough data')
        tounpack = self.data[:formatsize]
        self.data = self.data[formatsize:]
        result = struct.unpack(format, tounpack)
        if len(result) == 1:
            return result[0]
        else:
            return result

    def Truncate(self, length):
        self.data = self.data[:length]

    def GetBytes(self, length=None):
        if length == None:
            length = len(self.data)
        result = self.data[:length]
        self.data = self.data[length:]
        return result

    def GetString(self, format):
        stringLength = self.Unpack(format)
        return self.GetBytes(stringLength)

    def Length(self):
        return len(self.data)

# https://www.usualsuspect.re/article/cobalt-strikes-malleable-c2-under-the-hood
INSTRUCTION_TYPE_MALLEABLE_C2 = 1
INSTRUCTION_TYPE_GET = 2
INSTRUCTION_TYPE_POST = 3

INSTRUCTION_NONE = 0
INSTRUCTION_APPEND = 1
INSTRUCTION_PREPEND = 2
INSTRUCTION_BASE64 = 3
INSTRUCTION_PRINT = 4
INSTRUCTION_PARAMETER = 5
INSTRUCTION_HEADER = 6
INSTRUCTION_BUILD = 7
INSTRUCTION_NETBIOS = 8
INSTRUCTION_CONST_PARAMETER = 9
INSTRUCTION_CONST_HEADER = 10
INSTRUCTION_NETBIOSU = 11
INSTRUCTION_URI_APPEND = 12
INSTRUCTION_BASE64URL = 13
INSTRUCTION_STRREP = 14
INSTRUCTION_MASK = 15
INSTRUCTION_CONST_HOST_HEADER = 16

def DecodeInstructions(value, instructionsType):
    oStruct = cStruct(value)
    instructions = []
    opcodes = []
    buildFlag = False
    while oStruct.Length() >= 4:
        opcode = oStruct.Unpack('>I')
        if buildFlag and opcode in [0, 6, 7, 10, 16]:
            instructions.append('Build End')
            opcodes.append(['7', 'End'])
            buildFlag = False
        if opcode == INSTRUCTION_NONE:
            break
        if opcode == INSTRUCTION_APPEND:
            if instructionsType == INSTRUCTION_TYPE_MALLEABLE_C2:
                operand = oStruct.Unpack('>I')
                instructions.append('Remove %d bytes from end' % operand)
                opcodes.append([str(opcode), str(operand)])
            else:
                operand = oStruct.GetString('>I').decode('latin')
                instructions.append('Append %s' % operand)
                opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_PREPEND:
            if instructionsType == INSTRUCTION_TYPE_MALLEABLE_C2:
                operand = oStruct.Unpack('>I')
                instructions.append('Remove %d bytes from begin' % operand)
                opcodes.append([str(opcode), str(operand)])
            else:
                operand = oStruct.GetString('>I').decode('latin')
                instructions.append('Prepend %s' % operand)
                opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_BASE64:
            instructions.append('BASE64')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_PRINT:
            instructions.append('Print')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_PARAMETER:
            operand = oStruct.GetString('>I').decode('latin')
            instructions.append('Parameter %s' % operand)
            opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_HEADER:
            operand = oStruct.GetString('>I').decode('latin')
            instructions.append('Header %s' % operand)
            opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_BUILD:
            buildFlag = True
            operand = oStruct.Unpack('>I')
            if instructionsType == INSTRUCTION_TYPE_POST:
                if operand == 0:
                    operand = 'SessionId'
                else:
                    operand = 'Output'
            else:
                operand = 'Metadata'
            instructions.append('Build %s' % operand)
            opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_NETBIOS:
            instructions.append('NETBIOS lowercase')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_CONST_PARAMETER:
            operand = oStruct.GetString('>I').decode('latin')
            instructions.append('Const_parameter %s' % operand)
            opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_CONST_HEADER:
            operand = oStruct.GetString('>I').decode('latin')
            instructions.append('Const_header %s' % operand)
            opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_NETBIOSU:
            instructions.append('NETBIOS uppercase')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_URI_APPEND:
            instructions.append('Uri_append')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_BASE64URL:
            instructions.append('BASE64 URL')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_STRREP:
            operand1 = oStruct.GetString('>I').decode('latin')
            operand2 = oStruct.GetString('>I').decode('latin')
            instructions.append('STRREP %s %s' % (operand1, operand2))
            opcodes.append([str(opcode), operand1, operand2])
        elif opcode == INSTRUCTION_MASK:
            instructions.append('XOR with 4-byte random key')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_CONST_HOST_HEADER:
            operand = oStruct.GetString('>I').decode('latin')
            instructions.append('Const_host_header %s' % operand)
            opcodes.append([str(opcode), operand])
        else:
            instructions.append('Unknown instruction: 0x%02x' % opcode)
            opcodes.append([str(opcode)])

    result = []
    buildFlag = False
    for instruction in instructions:
        if instruction == 'Build End':
            result.append(build)
        elif instruction.startswith('Build '):
            build = [instruction]
            buildFlag= True
        elif buildFlag:
            build.append(instruction)
        else:
            result.append(instruction)
    instructions = result

    result = []
    buildFlag = False
    for opcode in opcodes:
        if opcode == ['7', 'End']:
            result.append(build)
        elif opcode[0] == '7':
            build = [opcode]
            buildFlag= True
        elif buildFlag:
            build.append(opcode)
        else:
            result.append(opcode)
    opcodes = result

    if instructionsType == INSTRUCTION_TYPE_MALLEABLE_C2:
        instructions = [['Transform Input'] + instructions]
        opcodes = [[['7', 'Input']] + opcodes]
    return [instructions, opcodes]

def DecodeMalleableC2Instructions(parameter):
    instructions, opcodes = DecodeInstructions(parameter, INSTRUCTION_TYPE_MALLEABLE_C2)
    buildOpcodes = ','.join([item for opcode in opcodes for item in opcode])
    return 'Instructions: ' + ','.join(instructions) + ' [7,Input,' + buildOpcodes + ']'

def AnalyzeEmbeddedPEFileSub(payloadsectiondata, options):
    result = []
    dJSON = {}
    xorKey = b'i'
    config, startconfig, endconfig = CutData(Xor(payloadsectiondata, xorKey), '[000100010002]:')
    if len(config) == 0:
        xorKey = b'.'
        config, startconfig, endconfig = CutData(Xor(payloadsectiondata, xorKey), '[000100010002]:')
    if len(config) == 0:
        xorKey = b'i'
        startconfig, endconfig = StatisticalSearch(payloadsectiondata, xorKey)
        if startconfig == None:
            xorKey = b'.'
            startconfig, endconfig = StatisticalSearch(payloadsectiondata, xorKey)
        if startconfig == None:
            result.append(ERROR_NO_CONFIG)
            return [result, dJSON]
        else:
            result.append('Config found (statistical): xorkey %s 0x%08x 0x%08x' % (xorKey, startconfig, endconfig))
            result.append(cDump(Xor(payloadsectiondata[startconfig:endconfig + 1], xorKey)).HexAsciiDump(rle=True))
            return [result, dJSON]
#                result.append('Config found: 0x%08x 0x%08x %s' % (startconfig, endconfig, ' '.join(['0x%08x' % position for position in FindAll(payloadsectiondata, '\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF')])))
#                result.append('Config found: 0x%08x 0x%08x %s' % (startconfig, endconfig, ' '.join(['0x%08x' % position for position in FindAll(payloadsectiondata, '\x90\x01\x00\x00')])))
    result.append('Config found: xorkey %s 0x%08x 0x%08x' % (xorKey, startconfig, endconfig))
    data = config
    dConfigIdentifiers = {
        0x0001: 'payload type',
        0x0002: 'port',
        0x0003: 'sleeptime',
        0x0004: 'maxgetsize', #
        0x0005: 'jitter',
        0x0006: 'maxdns',
        0x0007: 'publickey',
        0x0008: 'server,get-uri',
        0x0009: 'useragent',
        0x000a: 'post-uri',
        0x000b: 'Malleable_C2_Instructions', #
        0x000c: 'http_get_header',
        0x000d: 'http_post_header',
        0x000e: 'SpawnTo', #
        0x000f: 'pipename',
        0x0010: 'killdate_year', #
        0x0011: 'killdate_month', #
        0x0012: 'killdate_day', #
        0x0013: 'DNS_Idle', #
        0x0014: 'DNS_Sleep', #
        0x0015: 'SSH_HOST', #
        0x0016: 'SSH_PORT', #
        0x0017: 'SSH_USER-NAME', #
        0x0018: 'SSH_PASSWORD', #
        0x0019: 'SSH_PUBKEY', #
        0x001a: 'get-verb',
        0x001b: 'post-verb',
        0x001c: 'HttpPostChunk', #
        0x001d: 'spawnto_x86',
        0x001e: 'spawnto_x64',
        0x001f: 'CryptoScheme', #
        0x0020: 'proxy',
        0x0021: 'proxy_username',
        0x0022: 'proxy_password',
        0x0023: 'proxy_type',
        0x0024: 'deprecated', #
        0x0025: 'license-id',
        0x0026: 'bStageCleanup', #
        0x0027: 'bCFGCaution', #
        0x0028: 'killdate',
        0x0029: 'textSectionEnd', #
        0x002a: 'ObfuscateSectionsInfo', #
        0x002b: 'process-inject-start-rwx',
        0x002c: 'process-inject-use-rwx',
        0x002d: 'process-inject-min_alloc',
        0x002e: 'process-inject-transform-x86',
        0x002f: 'process-inject-transform-x64',
        0x0030: 'DEPRECATED_PROCINJ_ALLOWED',
        0x0031: 'BIND_HOST',
        0x0032: 'UsesCookies',
        0x0033: 'process-inject-execute',
        0x0034: 'process-inject-allocation-method',
        0x0035: 'process-inject-stub',
        0x0036: 'HostHeader',
        0x0037: 'EXIT_FUNK',
        0x0038: 'SSH_BANNER',
        0x0039: 'SMB_FRAME_HEADER',
        0x003a: 'TCP_FRAME_HEADER',
        0x003b: 'HEADERS_TO_REMOVE',
        0x003c: 'DNS_beacon',
        0x003d: 'DNS_A',
        0x003e: 'DNS_AAAA',
        0x003f: 'DNS_TXT',
        0x0040: 'DNS_metadata',
        0x0041: 'DNS_output',
        0x0042: 'DNS_resolver',
        0x0043: 'DNS_STRATEGY',
        0x0044: 'DNS_STRATEGY_ROTATE_SECONDS',
        0x0045: 'DNS_STRATEGY_FAIL_X',
        0x0046: 'DNS_STRATEGY_FAIL_SECONDS',
        0x0047: 'MAX_RETRY_STRATEGY_ATTEMPTS',
        0x0048: 'MAX_RETRY_STRATEGY_INCREASE',
        0x0049: 'MAX_RETRY_STRATEGY_DURATION',
    }
    dConfigValueInterpreter = {
        0x0001: lambda value: LookupConfigValue(0x0001, value),
        0x0007: ToHexadecimal,
        0x000b: DecodeMalleableC2Instructions,
        0x0013: ConvertIntToIPv4,
        0x0023: lambda value: LookupConfigValue(0x0023, value),
        0x002b: lambda value: LookupConfigValue(0x002b, value),
        0x002c: lambda value: LookupConfigValue(0x002b, value),
    }
    dJSONData = GetJSONData()
    dLookupValues = dJSONData.get('dLookupValues', {})

    while len(data) >= 2:
        formatNumber = '>H'
        formatTypeLength = '>HH'
        ntlBytes = data[0:struct.calcsize(formatNumber) + struct.calcsize(formatTypeLength)]
        number, data = Unpack(formatNumber, data)
        if number == 0:
            result.append('0x%04x' % number)
            break
        type, length, data = Unpack(formatTypeLength, data)
        parameter, data = GetChunk(length, data)
        info = ''
        rawvalue = None
        if type == 1 and length == 2:
            identifier = struct.unpack('>H', parameter)[0]
            rawvalue = identifier
            info = InterpretValue('%d' % identifier, number, identifier, dConfigValueInterpreter)
        elif type == 2 and length == 4:
            if number in [0x44, 0x45, 0x46]:
                rawvalue = struct.unpack('>i', parameter)[0]
            else:
                rawvalue = struct.unpack('>I', parameter)[0]
            value = '%d' % rawvalue
            info = InterpretValue(value, number, parameter[0:4], dConfigValueInterpreter)
            info += LookupValue(str(number), value, dLookupValues, options.verbose)
        elif type == 3 and not number in [0x0b, 0x0c, 0x0d]:
            info = InterpretValue('', number, parameter, dConfigValueInterpreter)
            rawvalue = binascii.b2a_hex(parameter).decode()
            if info == '':
                info = Represent(C2SIP3(parameter))
            info += LookupValue(str(number), rawvalue, dLookupValues, options.verbose)

        resultNumber = '0x%04x' % number
        resultType = '0x%04x' % type
        resultLength = '0x%04x' % length
        resultID = dConfigIdentifiers.get(number, '')
        dJSON[number] = {'id': resultID, 'type': resultType, 'info': info, 'rawvalue': rawvalue}
        if options.csv:
            result.append(MakeCSVLine((resultNumber, resultID, resultType, resultLength, info)))
        else:
            resultID = ('%-' + str(max([len(value) for value in dConfigIdentifiers.values()])) + 's') % resultID
            result.append('%s %s %s %s%s' % (resultNumber, resultID, resultType, resultLength, PrefixIfNeeded(info)))
        if type == 3 and number in [0x0b, 0x0c, 0x0d]:
            instructions, opcodes = DecodeInstructions(parameter, {0x0b: INSTRUCTION_TYPE_MALLEABLE_C2, 0x0c: INSTRUCTION_TYPE_GET, 0x0d: INSTRUCTION_TYPE_POST}[number])
            for index, instruction in enumerate(instructions):
                if isinstance(instruction, str):
                    if options.csv:
                        result.append(MakeCSVLine(('', '', '', '', instruction)))
                    else:
                        result.append('  %s' % instruction)
                else:
                    buildOpcodes = ','.join([':'.join(opcode) for opcode in opcodes[index]])
                    if number in dJSON:
                        if dJSON[number]['info'] == '':
                            dJSON[number]['info'] = buildOpcodes
                        else:
                            dJSON[number]['info'] += ';' + buildOpcodes
                    else:
                        dJSON[number] = {'id': resultID, 'type': resultType, 'info': buildOpcodes, 'rawvalue': binascii.b2a_hex(parameter).decode()}
                    if options.csv:
                        result.append(MakeCSVLine(('', '', '', '', '%s:[%s]' % (instruction[0], buildOpcodes))))
                    else:
                        result.append('  %s: [%s]' % (instruction[0], buildOpcodes))
                    for buildStep in instruction[1:]:
                        if options.csv:
                            result.append(MakeCSVLine(('', '', '', '', buildStep)))
                        else:
                            result.append('   %s' % buildStep)
#            for string in ExtractStringsASCII(parameter):
#                if options.csv:
#                    result.append(MakeCSVLine(('', '', '', '', string.decode('utf8', 'surrogateescape')), ',', '"'))
#                else:
#                    result.append('  %s' % string.decode('utf8', 'surrogateescape'))

        if options.select != '':
            select = ParseInteger(options.select)
            if number == select:
                result.append(' Decoded:     %s' % ToHexadecimal(ntlBytes + parameter))
                result.append(" 'i'-encoded: %s" % ToHexadecimal(Xor(ntlBytes + parameter, b'i')))
                result.append(" '.'-encoded: %s" % ToHexadecimal(Xor(ntlBytes + parameter, b'.')))
    result.append('Guessing Cobalt Strike version: %s (max 0x%04x)' % DetermineCSVersionFromConfig(dJSON))
    sanityCheck = SanityCheckExtractedConfig(dJSON)
    result.append('Sanity check Cobalt Strike config: %s' % ('OK' if sanityCheck else 'NOK'))
    if options.sanitycheck and not sanityCheck:
        return [[ERROR_SANITY_CHECK], {}]
    return [result, dJSON]

def AnalyzeEmbeddedPEFile(payloadsectiondata, oOutput, options):
    result, dJSON = AnalyzeEmbeddedPEFileSub(payloadsectiondata, options)
    oOutput.JSON(dJSON)
    for line in result:
        oOutput.Line(line)

def DetectPEFile(data):
    if len(data) < 40:
        return False
    if data[0:2] != b'MZ':
        return False
    offsetbytes = data[0x3C:0x3C + 4]
    if len(offsetbytes) != 4:
        return False
    offset = struct.unpack('<I', offsetbytes)[0]
    if data[offset:offset + 2] != b'PE':
        return False
    return True

def StripLeadingNOPs(data):
    return data.lstrip(b'\x90')

def XORChainSlow(iKey, encodedData):
    decodedData = b''
    xorkey = iKey
    while len(encodedData) >= 4:
        encoded = struct.unpack('<I', encodedData[0:4])[0]
        decodedData += struct.pack('<I', encoded ^ xorkey)
        xorkey = encoded
        encodedData = encodedData[4:]
    return decodedData

def XORChainFast(iKey, encodedData):
    oDATA = DataIO()
    xorkey = iKey
    index = 0
    format = '<I'
    formatLength = struct.calcsize(format)
    while True:
        bytesInteger = encodedData[index:index + formatLength]
        if len(bytesInteger) != formatLength:
            break
        encoded = struct.unpack(format, bytesInteger)[0]
        oDATA.write(struct.pack(format, encoded ^ xorkey))
        xorkey = encoded
        index += formatLength
    return oDATA.getvalue()

def XORChain(iKey, encodedData):
    fast = XORChainFast(iKey, encodedData)
    return fast
    slow = XORChainSlow(iKey, encodedData)
    if slow != fast:
        raise Exception('slow != fast')
    return fast

def TryXORChainDecoding(data):
    if len(data) < 0x100:
        return data, []
    formatstring = '<II'
    formatLength = struct.calcsize(formatstring)
    startLength = 16
    for iIter in range(1, 0x1000):
        bytesValues = data[iIter:iIter + formatLength + startLength]
        if len(bytesValues) != formatLength + startLength:
            return data, []
        xorKey, xorEncodedLength = struct.unpack(formatstring, bytesValues[:formatLength])
        decodedLength = xorKey ^ xorEncodedLength
        decodedStart = XORChain(xorKey, bytesValues[formatLength:])
        if StripLeadingNOPs(decodedStart)[0:2] == b'MZ':
            decodedData = StripLeadingNOPs(XORChain(xorKey, data[iIter + formatLength:iIter + formatLength + decodedLength]))
            if DetectPEFile(decodedData):
                return decodedData, ['xorkey(chain): 0x%08x' % xorKey, 'length: 0x%08x' % decodedLength]
        if b'MZRE' in decodedStart or b'MZAR' in decodedStart:
            decodedData = XORChain(xorKey, data[iIter + formatLength:iIter + formatLength + decodedLength])
            if START_CONFIG_I in decodedData or START_CONFIG_DOT in decodedData:
                return decodedData, ['xorkey(chain): 0x%08x' % xorKey, 'length: 0x%08x' % decodedLength]

    return data, []

def TryExtractDecode(data):
    if DetectPEFile(data):
        return data, []
    extracted = StripLeadingNOPs(data)
    if DetectPEFile(extracted):
        return extracted, ['leading NOPs: 0x%04x' % (len(data) - len(extracted))]
    extracted, messages = TryXORChainDecoding(data)
    if DetectPEFile(extracted):
        return extracted, messages
    if START_CONFIG_I in extracted or START_CONFIG_DOT in extracted:
        return extracted, messages
    return data, []

def TestShellcodeHeuristic(data):
    return b'hwini' in data[:0x1000] or b'hws2_' in data[:0x1000] or (data[0:1] == b'\xFC' and len(data) < 0x1000)

def FinalTests(data, options, oOutput):
    dSignatures = {
        # https://www.elastic.co/blog/detecting-cobalt-strike-with-memory-signatures
        'Sleep mask 64-bit 4.2 deobfuscation routine': b'\x4C\x8B\x53\x08\x45\x8B\x0A\x45\x8B\x5A\x04\x4D\x8D\x52\x08\x45\x85\xC9\x75\x05\x45\x85\xDB\x74\x33\x45\x3B\xCB\x73\xE6\x49\x8B\xF9\x4C\x8B\x03',
        'Sleep mask 32-bit 4.2 deobfuscation routine': b'\x8B\x46\x04\x8B\x08\x8B\x50\x04\x83\xC0\x08\x89\x55\x08\x89\x45\x0C\x85\xC9\x75\x04\x85\xD2\x74\x23\x3B\xCA\x73\xE6\x8B\x06\x8D\x3C\x08\x33\xD2',
    }

    for name, signature in dSignatures.items():
        for position in FindAll(data, signature):
            oOutput.Line('%s found: 0x%08x' % (name, position))
            if options.verbose:
                oOutput.Line(cDump(data[position-0x100:position], '  ', position-0x100).HexAsciiDump(rle=True), eol='')
                oOutput.Line('  ... signature ...')
                oOutput.Line(cDump(data[position+len(signature):position+len(signature)+0x100], '  ', position+len(signature)).HexAsciiDump(rle=True), eol='')

#a# this is a kludge, to fix later when I have time
def ProcessBinaryFileSub(sectiondata, data, oOutput, options):
    payloadType, payloadSize, intxorkey, id2, sectiondata = Unpack('<IIII', sectiondata)
    oOutput.Line('payloadType: 0x%08x' % payloadType)
    oOutput.Line('payloadSize: 0x%08x' % payloadSize)
    oOutput.Line('intxorkey: 0x%08x' % intxorkey)
    oOutput.Line('id2: 0x%08x' % id2)
    payload = Xor(sectiondata[:payloadSize], struct.pack('<I', intxorkey))
    if payloadSize > len(sectiondata):
        oOutput.Line('Error: payload size too large: 0x%08x' % payloadSize)
        oOutput.Line('.data section size: 0x%08x' % len(sectiondata))
        return False
    error, payloadsectiondata = GetDataSection(payload)
    if error != None:
        positionMZ = payload.find(b'MZ')
        if positionMZ != 0:
            if START_CONFIG_I in sectiondata or START_CONFIG_DOT in sectiondata:
                AnalyzeEmbeddedPEFile(data, oOutput, options)
            elif TestShellcodeHeuristic(payload):
                if IdentifyShellcode(payload) == '':
                    oOutput.Line('Probably found shellcode:')
                else:
                    oOutput.Line('Found shellcode:')
                AnalyzeShellcode(payload, oOutput)
                oOutput.Line(cDump(payload).HexAsciiDump(rle=False))
            elif positionMZ >= 0 and positionMZ < 0x20:
                oOutput.Line('MZ header found position %d' % positionMZ)
                AnalyzeEmbeddedPEFile(payload[positionMZ:], oOutput, options)
            elif len(payload) == 0:
                return False
            else:
                oOutput.Line('MZ header not found, truncated dump:')
                oOutput.Line(cDump(payload[:0x1000]).HexAsciiDump(rle=True))
                return False
        else:
            oOutput.Line('Error: embedded PE file error: %s' % error)
            return False
    else:
        AnalyzeEmbeddedPEFile(payloadsectiondata, oOutput, options)
    FinalTests(payload, options, oOutput)
    return True

def ProcessBinaryFile(filename, content, cutexpression, flag, oOutput, oLogfile, options):
    if content == None:
        try:
            oBinaryFile = cBinaryFile(filename, C2BIP3(options.password), options.noextraction, options.literalfilenames)
        except:
            oLogfile.LineError('Opening file %s %s' % (filename, repr(sys.exc_info()[1])))
            return
        oLogfile.Line('Success', 'Opening file %s' % filename)
        try:
            data = oBinaryFile.read()
        except:
            oLogfile.LineError('Reading file %s %s' % (filename, repr(sys.exc_info()[1])))
            return
        data = CutData(data, cutexpression)[0]
        oBinaryFile.close()
        oOutput.Line('File: %s%s' % (filename, IFF(oBinaryFile.extracted, ' (extracted)', '')))
    else:
        data = content
        oOutput.Line('File: %s' % (filename))

    if options.hash:
        oOutput.Line('MD5   : %s' % hashlib.md5(data).hexdigest())
        oOutput.Line('SHA1  : %s' % hashlib.sha1(data).hexdigest())
        oOutput.Line('SHA256: %s' % hashlib.sha256(data).hexdigest())
    try:
        # ----- Put your data processing code here -----
        data, messages = TryExtractDecode(data)
        for message in messages:
            oOutput.Line(message)
        if data[0:2] == b'MZ' and not options.raw:
            extracted, messages = GetXorChainSection(data)
            if extracted != None:
                resultChain, dJSON = AnalyzeEmbeddedPEFileSub(extracted, options)
                if resultChain != [ERROR_NO_CONFIG]:
                    oOutput.JSON(dJSON)
                    for message in messages:
                        oOutput.Line(message)
                    for message in resultChain:
                        oOutput.Line(message)
                    FinalTests(extracted, options, oOutput)
                else:
                    extracted = None
            if extracted == None:
                error, sectiondata = GetDataSection(data)
                if error != None:
                    oOutput.Line('Error: PE file error: %s' % error)
                elif len(sectiondata) < 16:
                    oOutput.Line('Error: section .data too small: %d' % len(sectiondata))
                elif ProcessBinaryFileSub(sectiondata, data, oOutput, options):
                    pass
                else:
                    bytesToSkip = 0x20
                    oOutput.Line('Skipping %d bytes' % bytesToSkip)
                    ProcessBinaryFileSub(sectiondata[bytesToSkip:], data, oOutput, options)
        elif TestShellcodeHeuristic(data):
            if IdentifyShellcode(data) == '':
                oOutput.Line('Probably found shellcode:')
            else:
                oOutput.Line('Found shellcode:')
            AnalyzeShellcode(data, oOutput)
            oOutput.Line(cDump(data).HexAsciiDump(rle=False))
            FinalTests(data, options, oOutput)
        else:
            dConfigs = {}
            for position in FindAll(data, START_CONFIG_I) + FindAll(data, START_CONFIG_DOT):
                result, dJSON = AnalyzeEmbeddedPEFileSub(data[position:position+0x10000], options)
                configSha256 = hashlib.sha256(''.join(result).encode()).hexdigest()
                if not configSha256 in dConfigs:
                    dConfigs[configSha256] = True
                    if result != [ERROR_SANITY_CHECK]:
                        oOutput.JSON(dJSON)
                        for line in result:
                            oOutput.Line(line)
            FinalTests(data, options, oOutput)
        # ----------------------------------------------
    except:
        oLogfile.LineError('Processing file %s %s' % (filename, repr(sys.exc_info()[1])))
        if not options.ignoreprocessingerrors:
            raise

def FormatTime(epoch=None):
    if epoch == None:
        epoch = time.time()
    return '%04d%02d%02d-%02d%02d%02d' % time.localtime(epoch)[0:6]

def SpaceEvery2Characters(string):
    result = []
    while string != '':
        result.append(string[0:2])
        string = string[2:]
    return ' '.join(result)

def ProcessLicenseIDs(oOutput, oLogfile, options):
    rule_config = '''rule cs_%s_licenseid {
  meta:
    license_name = "%s"
    license_id = "%d"
    info = "rule generated by 1768.py on %s"
  strings:
    $a = { %s }
  condition:
    $a
}
'''

    rule_config_i = '''rule cs_%s_licenseid_i {
  meta:
    license_name = "%s"
    license_id = "%d"
    info = "rule generated by 1768.py on %s"
  strings:
    $a = { %s }
  condition:
    $a
}
'''

    rule_config_dot = '''rule cs_%s_licenseid_dot {
  meta:
    license_name = "%s"
    license_id = "%d"
    info = "rule generated by 1768.py on %s"
  strings:
    $a = { %s }
  condition:
    $a
}
'''

    rule_shellcode = '''rule cs_%s_licenseid_shellcode {
  meta:
    license_name = "%s"
    license_id = "%d"
    info = "rule generated by 1768.py on %s"
  strings:
    $a = { %s }
  condition:
    $a and filesize < 10000
}
'''

    rule_shellcode_00 = '''rule cs_%s_licenseid_shellcode_00 {
  meta:
    license_name = "%s"
    license_id = "%d"
    info = "rule generated by 1768.py on %s"
  strings:
    $a = { %s }
  condition:
    $a and filesize < 10000
}
'''

    rule_shellcode_00_end = '''rule cs_%s_licenseid_shellcode_00_end {
  meta:
    license_name = "%s"
    license_id = "%d"
    info = "rule generated by 1768.py on %s"
  strings:
    $a = { %s }
  condition:
    $a and filesize < 10000 and $a at (filesize - 5)
}
'''

    for licenseid in options.licenseids.split(','):
        result = licenseid.split(':', 1)
        if len(result) == 1:
            idInteger = ParseInteger(licenseid)
            bytes = struct.pack('>I', idInteger)
            idName = binascii.b2a_hex(bytes).decode()
        else:
            idInteger = ParseInteger(result[1])
            bytes = struct.pack('>I', idInteger)
            idName = result[0]
        prefix = b'\x00\x25\x00\x02\x00\x04'
        oOutput.Line(rule_config % (idName, idName, idInteger, FormatTime(), SpaceEvery2Characters(binascii.b2a_hex(prefix + bytes).decode())))
        oOutput.Line(rule_config_i % (idName, idName, idInteger, FormatTime(), SpaceEvery2Characters(binascii.b2a_hex(Xor(prefix + bytes, b'i')).decode())))
        oOutput.Line(rule_config_dot % (idName, idName, idInteger, FormatTime(), SpaceEvery2Characters(binascii.b2a_hex(Xor(prefix + bytes, b'.')).decode())))
        oOutput.Line(rule_shellcode % (idName, idName, idInteger, FormatTime(), SpaceEvery2Characters(binascii.b2a_hex(bytes).decode())))
        oOutput.Line(rule_shellcode_00 % (idName, idName, idInteger, FormatTime(), SpaceEvery2Characters(binascii.b2a_hex(b'\x00' + bytes).decode())))
        oOutput.Line(rule_shellcode_00_end % (idName, idName, idInteger, FormatTime(), SpaceEvery2Characters(binascii.b2a_hex(b'\x00' + bytes).decode())))

class cOutputJSON(object):
    def __init__(self, oOutput, options):
        self.oOutput = oOutput
        self.options = options
        self.messages = []
        self.filename = ''
        self.JSONs = []

    def JSON(self, dJSON):
        self.JSONs.append(dJSON)

    def Line(self, line, eol='\n'):
        if self.options.jsonoutput:
            self.messages.append(line)
        else:
            self.oOutput.Line(line, eol)

    def Filename(self, filename, index, total):
        self.oOutput.Filename(filename, index, total)
        self.filename = filename

class cAPIOptions(object):
    def __init__(self):
        self.csv = False
        self.select = ''
        self.ignoreprocessingerrors = False
        self.raw = False
        self.verbose = False
        self.hash = False
        self.sanitycheck = False

class cAPIOutput(object):
    def __init__(self):
        self.messages = []
        self.JSONs = []

    def JSON(self, dJSON):
        self.JSONs.append(dJSON)

    def Line(self, line):
        self.messages.append(line)

    def LineError(self, line):
        pass

def APIAnalyze(data):
    oOutput = cAPIOutput()
    ProcessBinaryFile('', data, ':', '', oOutput, cAPIOutput(), cAPIOptions())
    return oOutput.JSONs

def ProcessBinaryFiles(filenames, oLogfile, options):
    oOutput = cOutputJSON(InstantiateCOutput(options), options)
    index = 0
    if options.jsoninput:
        items = CheckJSON(sys.stdin.read())
        if items == None:
            return
        for item in items:
            oOutput.Filename(item['name'], index, len(items))
            index += 1
            ProcessBinaryFile(item['name'], item['content'], '', '', oOutput, oLogfile, options)
            if options.jsonoutput:
                oOutput.oOutput.Line(json.dumps({'filename': oOutput.filename, 'messages': oOutput.messages, 'config': oOutput.JSONs[0]}))
    elif options.licenseids != '':
        ProcessLicenseIDs(oOutput, oLogfile, options)
    else:
        for filename, cutexpression, flag in filenames:
            oOutput.Filename(filename, index, len(filenames))
            index += 1
            ProcessBinaryFile(filename, None, cutexpression, flag, oOutput, oLogfile, options)
            if options.jsonoutput:
                oOutput.oOutput.Line(json.dumps({'filename': oOutput.filename, 'messages': oOutput.messages, 'config': oOutput.JSONs[0]}))

def Main():
    moredesc = '''

Source code put in the public domain by Didier Stevens, no Copyright
Use at your own risk
https://DidierStevens.com'''

    oParser = optparse.OptionParser(usage='usage: %prog [options] [[@]file|cut-expression|flag-expression ...]\n' + __description__ + moredesc, version='%prog ' + __version__, epilog='This tool also accepts flag arguments (#f#), read the man page (-m) for more info.')
    oParser.add_option('-m', '--man', action='store_true', default=False, help='Print manual')
    oParser.add_option('-r', '--raw', action='store_true', default=False, help='Search through the file as a binary file, do not parse as a PE file')
    oParser.add_option('-s', '--select', default='', help='Field to select')
    oParser.add_option('-S', '--sanitycheck', action='store_true', default=False, help='Exclude configs that do not pass sanity check')
    oParser.add_option('-o', '--output', type=str, default='', help='Output to file (# supported)')
    oParser.add_option('-l', '--licenseids', default='', help='License ID(s)/Watermark(s) to generate YARA rules for')
    oParser.add_option('-c', '--csv', action='store_true', default=False, help='Output config in CSV format')
    oParser.add_option('-p', '--password', default='infected', help='The ZIP password to be used (default infected)')
    oParser.add_option('-n', '--noextraction', action='store_true', default=False, help='Do not extract from archive file')
    oParser.add_option('-H', '--hash', action='store_true', default=False, help='Include hashes of file content')
    oParser.add_option('--literalfilenames', action='store_true', default=False, help='Do not interpret filenames')
    oParser.add_option('--recursedir', action='store_true', default=False, help='Recurse directories (wildcards and here files (@...) allowed)')
    oParser.add_option('--checkfilenames', action='store_true', default=False, help='Perform check if files exist prior to file processing')
    oParser.add_option('-j', '--jsoninput', action='store_true', default=False, help='Consume JSON from stdin')
    oParser.add_option('-J', '--jsonoutput', action='store_true', default=False, help='Output JSON')
    oParser.add_option('-V', '--verbose', action='store_true', default=False, help='Verbose output')
    oParser.add_option('--logfile', type=str, default='', help='Create logfile with given keyword')
    oParser.add_option('--logcomment', type=str, default='', help='A string with comments to be included in the log file')
    oParser.add_option('--ignoreprocessingerrors', action='store_true', default=False, help='Ignore errors during file processing')
    (options, args) = oParser.parse_args()

    if options.man:
        oParser.print_help()
        PrintManual()
        return

    if len(args) != 0 and options.jsoninput:
        print('Error: option -j can not be used with files')
        return

    oLogfile = cLogfile(options.logfile, options.logcomment)
    oExpandFilenameArguments = cExpandFilenameArguments(args, options.literalfilenames, options.recursedir, options.checkfilenames, '#c#', '#f#')
    oLogfile.Line('FilesCount', str(len(oExpandFilenameArguments.Filenames())))
    oLogfile.Line('Files', repr(oExpandFilenameArguments.Filenames()))
    if oExpandFilenameArguments.warning:
        PrintError('\nWarning:')
        PrintError(oExpandFilenameArguments.message)
        oLogfile.Line('Warning', repr(oExpandFilenameArguments.message))

    ProcessBinaryFiles(oExpandFilenameArguments.Filenames(), oLogfile, options)

    if oLogfile.errors > 0:
        PrintError('Number of errors: %d' % oLogfile.errors)
    oLogfile.Close()

if __name__ == '__main__':
    Main()

```

`Scripts/Get-ProcessTree/Get-ProcessTree.ps1`:

```ps1
<#
.SYNOPSIS
    Shows a process history tree with data extracted from a MemProcFS-Analyzer process overview CSV
.EXAMPLE
    PS> Get-ProcessTree.ps1 -CSVPath "~\Desktop\proc.csv"
    Shows the process tree using data from the given CSV
.AUTHOR
	Dominik Schmidt @ https://github.com/DaFuqs
.VERSION
    1.4
.VERSION_HISTORY
    1.4: - Nodes to not expand / subtract on double click anymore. This action is already used for opening the properties window
    1.3: - Use a compiled version of DamerauLevenshteinDistance for increased performance
         - Orphaned processes get that listed in the "Suspicious" tag
         - New Switch Param: NoSuspiciousChecks: for when you just want a quick process tree without automatic checks for suspicious entries
         - Right click menu for the popup process properties window to copy selected/all values
    1.2: - Fixed hang when pid<=>parent PPIDs result in a ppid loop (like when PIDs have been reused). Findings will be reported
         - 4 new process masquerading checks:
             - processes with unusual parents
             - processes in unusual paths
             - processes with an unusual number of instances
             - similarly named processes to known-good ones
    1.1: - Double Clicking an Entry brings up a property view
         - Suspicious Entries get colored red and list their suspicion hits in their tooltip + properties view
    1.0: Public release
#>

[CmdletBinding()]

Param (
    # Path to the input CSV file
    [Parameter(Mandatory=$false, ValueFromPipeline=$true)]
	[ValidateScript({try { Test-Path -Path $_ -PathType Leaf } catch { throw "No file at `"$_`"" }})] # test if there is a file at given location
    [string] $CSVPath = ".\proc.csv",
    
    # Process names of script interpreters
    # Will be matched 1:1
    [Parameter(Mandatory=$false)]
    $ScriptInterpreters = @("powershell.exe", "cmd.exe", "wscript.exe", "cscript.exe", "python.exe"),

    [Parameter(Mandatory=$false)]
    $LateralMovementPrograms =  @("*psexec*", "mstsc.exe", "putty.exe", "winscp.exe", "scp.exe"),

    # https://attack.mitre.org/techniques/T1218/
    [Parameter(Mandatory=$false)]
    $SuspiciousPrograms =  @("*certutil.exe", "ping.exe", "msconfig.exe", "nslookup.exe", "ipconfig.exe", "systeminfo.exe", "nltest.exe", "net.exe", "chcp.exe", "bitsadmin.exe", "WSreset.exe", "mshta.exe", 
    "regsvr32.exe", "rundll32.exe", "mavinject.exe", "sc.exe", "tasklist.exe", 
    "msbuild.exe" # https://attack.mitre.org/techniques/T1127/001/
    "adfind.exe" # https://attack.mitre.org/techniques/T1087/002/
    ),

    # 
    [Parameter(Mandatory=$false)]
    $SuspiciousParameters = @(
        [Tuple]::Create("powershell.exe", "-Enc")
        [Tuple]::Create("powershell.exe", "Webclient")
        [Tuple]::Create("powershell.exe", "Hidden")  # T1564.003
        [Tuple]::Create("powershell.exe", "Bypass")
        [Tuple]::Create("wscript.exe", "PubPrn") # https://attack.mitre.org/techniques/T1216/001/
        [Tuple]::Create("cscript.exe", "PubPrn") # https://attack.mitre.org/techniques/T1216/001
    ),

    #  [T1036.007]
    $DoubleFileExtensions,

    # Names of folders where process launch should be noted as suspicious
    # Will be matched via -like (use * as wildcard at start and end)
    [Parameter(Mandatory=$false)]
    $SuspiciousFolders =  @("*\appdata\*", "*\temp\*"),

    # Parent Process Name => File Path
    # Process names will be matched 1:1
    # File Paths will be matched via -like (use * as wildcard at start and end)
    [Parameter(Mandatory=$false)]
    $UnusualRelationships = @(
        [Tuple]::Create("Excel.exe", "*.exe")
        [Tuple]::Create("Word.exe", "*.exe")
        [Tuple]::Create("Outlook.exe", "*.exe")
        [Tuple]::Create("MSEdge.exe", "*.exe")
        [Tuple]::Create("Chrome.exe", "*.exe")
        [Tuple]::Create("Firefox.exe", "*.exe")
        [Tuple]::Create("Schtasks.exe", "powershell.exe")
        [Tuple]::Create("Schtasks.exe", "cmd.exe")
        [Tuple]::Create("Schtasks.exe", "C:\Users\*")
        [Tuple]::Create("Schtasks.exe", "C:\ProgramData\*")
        [Tuple]::Create("Schtasks.exe", "rundll32.exe")
        [Tuple]::Create("userinit.exe", "*exp*")
        [Tuple]::Create("powershell.exe", "*")
        [Tuple]::Create("WMIPrvSE.exe", "*")
        [Tuple]::Create("rundll32.exe", "C:\Users\*")
    ),

    # Known windows processes and their usual parents
    [Parameter(Mandatory=$false)]
    $ExpectedRelationships = @{
        "csrss.exe" = @("smss.exe", "svchost.exe")
        "LogonUI.exe" = @("wininit.exe", "winlogon.exe")
        "lsass.exe" = @("wininit.exe")
        "services.exe" = @("wininit.exe")
        "smss.exe" = @("System", "smss.exe")
        "spoolsv.exe" = @("services.exe")
        "svchost.exe" = @("services.exe", "MsMpEng.exe", "svchost.exe")
        "taskhost.exe" = @("services.exe", "svchost.exe")
        "taskhostw.exe" = @("services.exe", "svchost.exe")
        "userinit.exe" = @("dwm.exe", "winlogon.exe")
        "wininit.exe" = @("smss.exe")
        "winlogon.exe" = @("smss.exe")
    },

    # They will be matched using regex
    [Parameter(Mandatory=$false)]
    $ExpectedProcessPaths = @{
        "csrss.exe" = "\\Windows\\System32\\csrss\.exe"
        "explorer.exe" = "\\Windows\\explorer\.exe"
        "lsass.exe" = "\\Windows\\System32\\lsass\.exe"
        "lsm.exe" = "\\Windows\\System32\\lsm\.exe"
        "services.exe" = "\\Windows\\System32\\services\.exe"
        "smss.exe" = "\\Windows\\System32\\smss\.exe"
        "svchost.exe" = "\\Windows\\(System32)?(SysWOW64)?\\svchost\.exe"
        "taskhost.exe" = "\\Windows\\System32\\taskhost\.exe"
        "taskhostw.exe" = "\\Windows\\System32\\taskhostw\.exe"
        "wininit.exe" = "\\Windows\\System32\\wininit\.exe"
        "winlogon.exe" = "\\Windows\\System32\\winlogon\.exe"
    },

    [Parameter(Mandatory=$false)]
    $ExpectedProcessInstanceCounts = @{
        "lsaiso.exe" = 1
        "lsass.exe" = 1
        "lsm.exe" = 1
        "services.exe" = 1
        "wininit.exe" = 1
    },

    [Parameter(Mandatory=$false)]
    $ProcessesToSearchSimilarNames = @("csrss.exe", "dllhost.exe", "explorer.exe", "iexplore.exe", "lsass.exe", "sihost.exe", "smss.exe", "svchost.exe", "winlogon.exe"),

    # Directly display not only process names, but also PIDs
    [Parameter(Mandatory=$false)]
    [switch] $VisualPIDs = $true,
    
    # Skips all checks of suspicous entries, making the GUI display much faster
    [Parameter(Mandatory=$false)]
    [switch] $NoSuspiciousChecks
)

[void][System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms")
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Drawing")
[void][System.Reflection.Assembly]::LoadWithPartialName("PresentationFramework")
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Drawing")
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Windows")


# querying the entries of the csv file
$csvEntries = @(Import-CSV -Path $CSVPath -Delimiter "`t")


####################################
#region    DOTNET-SHENANIGANS      #
####################################


try {
    [LevenshteinDistance]::new() -as [Type] | Out-Null
} catch {
    Add-Type -Path (Join-Path $PSScriptRoot -ChildPath "..\Measure-DamerauLevenshteinDistance\Measure-DamerauLevenshteinDistance.cs") | Out-Null
}


# Fuse of
# https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.treeview.treeviewnodesorter
# https://www.dotnetperls.com/alphanumeric-sorting
try {
    [TreeNodeAlphanumComparator] -as [Type] | Out-Null
} catch {
    Add-Type @"
using System;
using System.Collections;
using System.Windows.Forms;
public class TreeNodeAlphanumComparator : IComparer {
    public int Compare(object x, object y) {
        TreeNode tx = x as TreeNode;
        TreeNode ty = y as TreeNode;
        if (tx == null) {
            return 0;
        }
        if (ty == null) {
            return 0;
        }
        string s1 = tx.Text;
        if (s1 == null) {
            return 0;
        }
        string s2 = ty.Text;
        if (s2 == null) {
            return 0;
        }
        
        int len1 = s1.Length;
        int len2 = s2.Length;
        int marker1 = 0;
        int marker2 = 0;
        
        // Walk through two the strings with two markers.
        while (marker1 < len1 && marker2 < len2) {
            char ch1 = s1[marker1];
            char ch2 = s2[marker2];
            
            // Some buffers we can build up characters in for each chunk.
            char[] space1 = new char[len1];
            int loc1 = 0;
            char[] space2 = new char[len2];
            int loc2 = 0;
            
            // Walk through all following characters that are digits or
            // characters in BOTH strings starting at the appropriate marker.
            // Collect char arrays.
            do {
                space1[loc1++] = ch1;
                marker1++;
                
                if (marker1 < len1) {
                    ch1 = s1[marker1];
                } else {
                    break;
                }
            } while (char.IsDigit(ch1) == char.IsDigit(space1[0]));
            
            do {
                space2[loc2++] = ch2;
                marker2++;
                
                if (marker2 < len2) {
                    ch2 = s2[marker2];
                } else {
                    break;
                }
            } while (char.IsDigit(ch2) == char.IsDigit(space2[0]));
            
            // If we have collected numbers, compare them numerically.
            // Otherwise, if we have strings, compare them alphabetically.
            string str1 = new string(space1);
            string str2 = new string(space2);
            
            int result;
            
            if (char.IsDigit(space1[0]) && char.IsDigit(space2[0])) {
                int thisNumericChunk = int.Parse(str1);
                int thatNumericChunk = int.Parse(str2);
                result = thisNumericChunk.CompareTo(thatNumericChunk);
            } else {
                result = str1.CompareTo(str2);
            }
            
            if (result != 0) {
                return result;
            }
        }
        return len1 - len2;
    }
}
"@ -ReferencedAssemblies System.Windows.Forms | Out-Null
}

####################################
#endregion DOTNET-SHENANIGANS      #
####################################


####################################
#region    HELPER FUNCTIONS        #
####################################

# huge thanks to
# https://nasbench.medium.com/demystifying-the-svchost-exe-process-and-its-command-line-options-508e9114e747
# for the great writeup!
function Get-SVCHostData($k, $s) {
    $values = @((Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost\").$k)
    if($s) {
        if($values -contains($s)) {
            return "[$s]"
        } else {
            return "[???]"
        }
    }
    return "[" + ($values -join ", ") + "]"
}

function Is-Match($Text, $SearchText, $SearchMode) {
    if($searchMode -eq 0) { # plaintext
        if($text -and $Text.toLower().Contains($SearchText.toLower())) {
            return $true
        }
    } elseif($searchMode -eq 1) { # extended
        if($Text -like $SearchText) {
            return $true
        }
    } else { # regex
        if($Text -match $SearchText) {
            return $true
        }
    }
    $false
}

function Show-EntryWindow($entry) {
    # create form for displaying the folder tree
    $entryForm = New-Object System.Windows.Forms.Form
    $entryForm.Text = $entry."Process Name" + ": " + $entry.PID + " - Properties"
    $entryForm.Size = New-Object System.Drawing.Size(500, 395)
    $entryForm.Icon = $icon

    $alternateCellStyle = New-Object System.Windows.Forms.DataGridViewCellStyle
    $alternateCellStyle.BackColor = [System.Drawing.SystemColors]::ControlLight
    
    $script:dataGridView = New-Object System.Windows.Forms.DataGridView
    $dataGridView.Name = "EntryPropertiesGridView"
    $dataGridView.AllowUserToAddRows = $false
    $dataGridView.AllowUserToDeleteRows = $false
    $dataGridView.AllowUserToOrderColumns = $false
    $dataGridView.AllowUserToResizeRows = $false
    $dataGridView.ColumnHeadersHeightSizeMode = [System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode]::DisableResizing
    $dataGridView.RowHeadersVisible = $false
    $dataGridView.ReadOnly = $true
    $dataGridView.ColumnCount = 2
    $dataGridView.Columns[0].Name = "Property"
    $dataGridView.Columns[0].AutoSizeMode = [System.Windows.Forms.DataGridViewAutoSizeColumnMode]::AllCells
    $dataGridView.Columns[1].Name = "Value"
    $dataGridView.Columns[1].AutoSizeMode = [System.Windows.Forms.DataGridViewAutoSizeColumnMode]::Fill
    $dataGridView.AlternatingRowsDefaultCellStyle = $alternateCellStyle
    $dataGridView.SelectionMode = [System.Windows.Forms.DataGridViewSelectionMode]::FullRowSelect
    $dataGridView.Dock = [System.Windows.Forms.DockStyle]::Fill

    $contextMenuStrip = New-Object System.Windows.Forms.ContextMenuStrip
    $contextMenuStrip.Items.Add("Copy highlighted rows").add_Click({
        $sb = New-Object System.Text.StringBuilder
        foreach($row in $dataGridView.SelectedRows) {
            $sb.AppendLine($row.Cells[0].Value + " " + $row.Cells[1].Value)
        }
        [System.Windows.Forms.Clipboard]::SetText($sb.ToString())
    })
    $contextMenuStrip.Items.Add("Copy all rows").add_Click({
        $sb = New-Object System.Text.StringBuilder
        foreach($row in $dataGridView.Rows) {
            $sb.AppendLine($row.Cells[0].Value + " " + $row.Cells[1].Value)
        }
        [System.Windows.Forms.Clipboard]::SetText($sb.ToString())
    })
    $dataGridView.ContextMenuStrip = $contextMenuStrip

    foreach($property in $entry.psobject.Properties) {
        $dataGridView.Rows.Add($property.Name + ":", $property.Value)
    }

    $entryForm.BackColor = [System.Drawing.SystemColors]::ControlLight
    $entryForm.Controls.Add($dataGridView)
    $entryForm.Show()
}

function Note-Suspicious($Node, $Description) {
    if($Node.Tag.Suspicious) {
        $Node.Tag.Suspicious = $Node.Tag.Suspicious + ", " + $Description
    } else {
        $Node.Tag.Suspicious = $Description
    }
    $Node.ForeColor = [System.Drawing.Color]::Red
    $Node.ToolTipText = ($Node.Tag | Out-String).Trim() -replace " *:", ":"
}

function Set-Suspicious($Node, $ParentID, $Description, $ShortId) {
    Note-Suspicious -Node $node -Description $Description
    New-Node -ID $($Node.Tag.PID + "_" + $ShortId) -Text $process."Call Chain" -Tooltip $node.ToolTipText -Parent $ParentID -Tag $Node.Tag
}

####################################
#endregion HELPER FUNCTIONS        #
####################################


####################################
#region    GUI                     #
####################################

# create form for displaying the folder tree
$Form = New-Object System.Windows.Forms.Form
$Form.Text = "MemProcFS-Analyzer - Process Tree"
$Form.Size = New-Object System.Drawing.Size(800, 600)

# the icon (base 64 encoded png, converted and set as icon)
$base64Icon = "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABgAAAAYADwa0LPAAAAxElEQVRIx+3TsWoCQRCA4Y8kNkklnCRVEB/gGh/ZB8gTCJo6zYGtiJ0vYH0pMsJiItzpRBt/WLid5f6Znd3lzq15TPY94wM7bLKLfcESLVZ4uEQ2xiykx/JNrP+i7TAOLGK+xGsXed8E45C12HeRn8M71iHfYpIpL3eyyK78KtT4xFsRG8VuphkJ5n5636CK0URsnpGgFDZH39Wpn/pcUxjiq1j7U37Jc37CoJgPIpbCWS3qw78fch2istoqYnVWm+7k8A1FT08gOQfCGwAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMi0wOS0wNVQxMjoyMTozMSswMDowMOTTZSwAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjItMDktMDVUMTI6MjE6MzErMDA6MDCVjt2QAAAAAElFTkSuQmCC"
$bitmap = New-Object System.Windows.Media.Imaging.BitmapImage
$bitmap.BeginInit()
$bitmap.StreamSource = [System.IO.MemoryStream][System.Convert]::FromBase64String($base64Icon)
$bitmap.EndInit()
$bitmap.Freeze()
$image = [System.Drawing.Bitmap][System.Drawing.Image]::FromStream($bitmap.StreamSource)
$icon = [System.Drawing.Icon]::FromHandle($image.GetHicon())
$Form.Icon = $icon

# the main tree
$TreeView = New-Object System.Windows.Forms.TreeView
$TreeView.Dock = [System.Windows.Forms.DockStyle]::Fill
$TreeView.TreeViewNodeSorter = New-Object -TypeName TreeNodeAlphanumComparator
$TreeView.ShowNodeToolTips = $true
$Form.Controls.Add($TreeView)

# top "search" strip
$MenuStrip = New-Object System.Windows.Forms.MenuStrip
$MenuStrip.ShowItemToolTips = $true
$MenuStrip.Dock = [System.Windows.Forms.DockStyle]::Top

$ExpandButton = New-Object System.Windows.Forms.ToolStripButton
$ExpandButton.Text = "+"
$ExpandButton.ToolTipText = "Expand All"
$ExpandButton.Add_Click({
    $TreeView.ExpandAll()
})

$CollapseButton = New-Object System.Windows.Forms.ToolStripButton
$CollapseButton.Text = "-"
$CollapseButton.ToolTipText = "Collapse All"
$CollapseButton.Add_Click({
    $TreeView.CollapseAll()
})
$ButtonSeparator = New-Object System.Windows.Forms.ToolStripSeparator

# Search
$SearchTextStrip = New-Object System.Windows.Forms.ToolStripStatusLabel
$SearchTextStrip.Text = "Search:"

$SearchBox = New-Object System.Windows.Forms.ToolStripTextBox
$SearchBox.Size = New-Object System.Drawing.Size(250, $SearchBox.Size.Height)
$SearchBox.Add_TextChanged({
    Search-Nodes
})

$SearchTextStrip2 = New-Object System.Windows.Forms.ToolStripStatusLabel
$SearchTextStrip2.Text = "Mode:"

$SearchModeDropDownButton = New-Object System.Windows.Forms.ToolStripDropDownButton
$SearchModeDropDown = New-Object System.Windows.Forms.ToolStripDropDown
[void] $SearchModeDropDown.Items.Add("Plaintext")
[void] $SearchModeDropDown.Items.Add("Extended")
[void] $SearchModeDropDown.Items.Add("RegEx")
$SearchModeDropDownButton.Text = $SearchModeDropDown.Items[0]
$SearchModeDropDownButton.DropDown = $SearchModeDropDown

$SearchModeDropDown.Add_ItemClicked({
    $SearchModeDropDownButton.Text = $_.ClickedItem.Text
    Search-Nodes
})

$SearchTextStrip3 = New-Object System.Windows.Forms.ToolStripStatusLabel
$SearchTextStrip3.Text = "Filter:"

$SearchLocationDropDownButton = New-Object System.Windows.Forms.ToolStripDropDownButton
$SearchLocationDropDown = New-Object System.Windows.Forms.ToolStripDropDown
[void] $SearchLocationDropDown.Items.Add("Everywhere")
[void] $SearchLocationDropDown.Items.Add("Call Chain")
$blacklistedSearchEntries = @("Sub-Processes")
foreach($property in $csvEntries[0].PSObject.Properties | Sort-Object) {
    if($property.Name -notin $blacklistedSearchEntries) {
        [void] $SearchLocationDropDown.Items.Add($property.Name)
    }
}
$SearchLocationDropDownButton.Text = $SearchLocationDropDown.Items[0]
$SearchLocationDropDownButton.DropDown = $SearchLocationDropDown

$SearchLocationDropDown.Add_ItemClicked({
    $SearchLocationDropDownButton.Text = $_.ClickedItem.Text
    Search-Nodes
})

# Dispay Mode Selection
$DisplayModeSeparator = New-Object System.Windows.Forms.ToolStripSeparator
$DisplayModeTextStrip = New-Object System.Windows.Forms.ToolStripStatusLabel
$DisplayModeTextStrip.Text = "Display Mode:"

$DisplayModeDropDown = New-Object System.Windows.Forms.ToolStripDropDown
[void] $DisplayModeDropDown.Items.Add("PID: Name")
[void] $DisplayModeDropDown.Items.Add("Name")

$DisplayModeDropDownButton = New-Object System.Windows.Forms.ToolStripDropDownButton
if($VisualPIDs) {
    $DisplayModeDropDownButton.Text = $DisplayModeDropDown.Items[0]
} else {
    $DisplayModeDropDownButton.Text = $DisplayModeDropDown.Items[1]
}
$DisplayModeDropDownButton.DropDown = $DisplayModeDropDown

$DisplayModeDropDown.Add_ItemClicked({
    $newValue = $_.ClickedItem.Text
    $currentValue = $DisplayModeDropDownButton.Text
    if($newValue -ne $currentValue) {
        $DisplayModeDropDownButton.Text = $newValue
        if($newValue -eq "PID: Name") {
            $VisualPIDs = $true
        } else {
            $VisualPIDs = $false
        }

        Fill-GUIData
    }
})

$MenuStrip.Items.AddRange($ExpandButton)
$MenuStrip.Items.AddRange($CollapseButton)
$MenuStrip.Items.AddRange($ButtonSeparator)

$MenuStrip.Items.AddRange($SearchTextStrip)
$MenuStrip.Items.AddRange($SearchBox)
$MenuStrip.Items.AddRange($SearchTextStrip2)
$MenuStrip.Items.AddRange($SearchModeDropDownButton)
$MenuStrip.Items.AddRange($SearchTextStrip3)
$MenuStrip.Items.AddRange($SearchLocationDropDownButton)

$MenuStrip.Items.AddRange($DisplayModeSeparator)
$MenuStrip.Items.AddRange($DisplayModeTextStrip)
$MenuStrip.Items.AddRange($DisplayModeDropDownButton)
$Form.Controls.Add($MenuStrip)

# bottom "statistics" strip
$StatusStrip = New-Object System.Windows.Forms.StatusStrip
$StatusStrip.Dock = [System.Windows.Forms.DockStyle]::Bottom
$StatusStrip.LayoutStyle = [System.Windows.Forms.ToolStripLayoutStyle]::HorizontalStackWithOverflow

# text block that lists the count of found elements in the bottom strip
$ElementCountLabel = New-Object System.Windows.Forms.ToolStripStatusLabel

$OSStartLabel = New-Object System.Windows.Forms.ToolStripStatusLabel
$OSStartLabel.Alignment = [System.Windows.Forms.ToolStripItemAlignment]::Right
$OSStartLabel.BorderStyle = [System.Windows.Forms.Border3DStyle]::Raised

$StatusStrip.Items.AddRange($ElementCountLabel)
$StatusStrip.Items.AddRange($OSStartLabel)
$Form.Controls.Add($StatusStrip)

####################################
#endregion GUI                     #
####################################


####################################
#region    DISPLAY                 #
####################################

$script:dataInitialised = $false

function Search-Nodes {
    $expandSet = [System.Collections.Generic.HashSet[System.Windows.Forms.TreeNode]]@()

    # iterate through all nodes in the treeview
    # and expand / collapse them according to the search
    $searchText = $SearchBox.Text
    $clear = $searchtext -eq ""
    $searchLocation = $SearchLocationDropDownButton.Text

    # Map search mode to an int (faster than string compare every time)
    # ideally use an enum here, but that's a newer PS feature
    [int] $searchMode = 0
    switch ($SearchModeDropDownButton.Text) {
        'PlainText' { $searchMode = 0}
        'Extended' { $searchMode = 1 }
        Default { # regex
            $searchMode = 2
            try {
                [regex] $searchText
            } catch {
                # current serach text is not valid regex
                return
            }
        }
    }

    $TreeView.BeginUpdate() # do not redraw the tree view everytime a property changes
   
    $queue = New-Object System.Collections.Queue
    foreach($node in $TreeView.Nodes) {
        $queue.Enqueue($node)
    }

    while($queue.Count -gt 0) {
        $node = $queue.Dequeue()
        foreach($childNode in $node.Nodes) {
            $queue.Enqueue($childNode)
        }

        $node.Collapse()
        $node.BackColor = [System.Drawing.Color]::Transparent

        if(!$clear) {
            $element = $node.Tag
            $match = $false
            if($null -eq $element) {
                # node without element. Never matches
            } if($searchLocation -eq "Everywhere") {
                foreach($property in $element.PSObject.Properties) {
                    if($property.Name -eq "Call Chain") {
                        continue
                    }
                    if(Is-Match -Text $property.Value -SearchText $searchText -SearchMode $searchMode) {
                        $match = $true
                        break
                    }
                }
            } else {
                $match = Is-Match -Text $element.$searchLocation -SearchText $searchText -SearchMode $searchMode
            }

            if($match) {
                $node.BackColor = [System.Drawing.Color]::Yellow

                # note this node and all of it's parents to expand later
                $currentNode = $node
                do {
                    $expandSet.Add($currentNode)
                    $currentNode = $currentNode.Parent
                } while ($null -ne $currentNode)
            }
        }
    }

    foreach($expandEntry in $expandSet) {
        $expandEntry.expand()
    }
    $TreeView.EndUpdate()
}

function New-Node($ID, $Text, $Tooltip, $Parent, $Tag, [switch] $AddToMap) {
    $newNode = New-Object System.Windows.Forms.TreeNode
    $newNode.Name = $ID
    $newNode.Text = if($Text) { $Text } else { "<unknown>" }
    $newNode.ToolTipText = $Tooltip
    if($AddToMap) {
        $nodesMap[$ID] = $newNode
    }
    if($Tag) {
        $newNode.Tag = $Tag
    }
    if($Parent) {
        [void] $nodesMap[$Parent].Nodes.Add($newNode)
    } else {
        [void] $TreeView.Nodes.Add($newNode)
    }
}

function Set-Nodes($Root, $Depth, $Collapsed) {
    $TreeView.BeginUpdate() # do not redraw the tree view everytime a property changes
    $queue = New-Object System.Collections.Queue
    $queue.Enqueue([Tuple]::Create($Root, 0))

    while($queue.Count -gt 0) {
        $entry = $queue.Dequeue()
        $node = $entry.Item1
        $currentDepth = $entry.Item2

        if($currentDepth -lt $Depth) {
            foreach($childNode in $node.Nodes) {
                $queue.Enqueue([Tuple]::Create($childNode, $currentDepth + 1))
            }
        }

        if($collapsed) {
            $node.Collapse()
        } else {
            $node.Expand()
        }
   }
   $TreeView.EndUpdate()
}

<#
    In the tree view, we want nodes that are double clicked on, to show a properties view popup.
    Since by default, tree nodes have an event mapped to double click already (namely expanding / collapsing the node),
    we have to check if it's a double click in BeforeExpand() and BeforeCollapse() and cancel this default behavior
    so it does not interfere with the opening of our new properties window
    The user is still able to nagigate the tree via keyboard, or as usual, by using the +/- buttons on each node
#>
$script:CancelNodeExpanding = $false

function Fill-GUIData {
    $TreeView.BeginUpdate()
    $TreeView.Nodes.Clear()
    $TreeView.Add_KeyDown({
        # Ctrl+C override
        # If there is a better event handler please enlighten me
        # it makes the annoying "warning" sound, for whatever reason
        if($_.Control -and $_.KeyCode -eq "C") {
            $node = $TreeView.SelectedNode
            if($node -and $node.TooltipText) {
                [System.Windows.Forms.Clipboard]::SetDataObject($node.TooltipText)
            }
        }
    })
    $TreeView.Add_MouseDown({
        $script:CancelNodeExpanding = $_.Clicks -gt 1
    })
    $TreeView.Add_BeforeExpand({
        $_.Cancel = $script:CancelNodeExpanding
    })
    $TreeView.Add_BeforeCollapse({
        $_.Cancel = $script:CancelNodeExpanding
    })
    
    $TreeView.Add_NodeMouseDoubleClick({
        if($_.Node.Tag) {
            if(-not $_.Node.IsExpanded) {
                $_.Node.Expand()
            } else {
                $_.Node.Collapse();
            }

            Show-EntryWindow($_.Node.Tag)
            return $false
        }
    })
    $nodesMap = @{}
    
    $TotalProcesses = ($csvEntries).Count
    $RunningProcesses = ($csvEntries | Where-Object { $_."Exit Time" -eq "" }).Count
    $ExitedProcesses = ($csvEntries | Where-Object { $_."Exit Time" -ne "" }).Count
    $ElementCountLabel.Text = "Total Processes: $TotalProcesses | Running Processes: $RunningProcesses | Exited Processes: $ExitedProcesses"

    # a list of dedicated (root) nodes for special case handling
    $orphanID = $((New-Guid).Guid)
    New-Node -ID $orphanID -Text "Orphan Processes" -Tooltip "Processes where parent processes could not be found anymore" -AddToMap

    $notableID = $((New-Guid).Guid)
    New-Node -ID $notableID -Text "Alert Messages" -Tooltip "Common low hanging fruits" -AddToMap

    # LP_Windows Processes Suspicious Parent Directory Detected
    # Trigger Condition: Suspicious parent processes of Windows processes are detected.
    # ATT&CK Category: Defense Evasion
    # ATT&CK Tag: Masquerading
    $unusualRelationShipsID = $((New-Guid).Guid)
    New-Node -ID $unusualRelationShipsID -Text "Suspicious Parent-Child Relationships [T1036]" -Tooltip "Processes called from an unusual parent process" -Parent $notableID -AddToMap

    $scriptInterpretersID = $((New-Guid).Guid)
    New-Node -ID $scriptInterpretersID -Text "Command and Scripting Interpreters [T1059]" -Tooltip "CMD, Python, VB, Powershell, you name it" -Parent $notableID -AddToMap

    $suspiciousFoldersID = $((New-Guid).Guid)
    New-Node -ID $suspiciousFoldersID -Text "Suspicious Process File Path [T1543]" -Tooltip "Process Execution from an Unusual Directory" -Parent $notableID -AddToMap

    $lateralMovementProgramsID = $((New-Guid).Guid)
    New-Node -ID $lateralMovementProgramsID -Text "Lateral Movement Tools [TA0008]" -Tooltip "Process Execution from an Unusual Directory" -Parent $notableID -AddToMap

    $suspiciousProgramsID = $((New-Guid).Guid)
    New-Node -ID $suspiciousProgramsID -Text "Suspicious Program Execution [T1218, T1127.001, T1087.002]" -Tooltip "All kinds of suspicious Programs, usually used for Discovery, Privilege Escalation to Proxy Execution" -Parent $notableID -AddToMap

    $doubleFileExtensionsID = $((New-Guid).Guid)
    New-Node -ID $doubleFileExtensionsID -Text "Double File Extensions [T1036.007]" -Tooltip "Processes spawned from execuables using a double file extension, most often in a way to deceive users to execute malicious payloads, like 'invoice.doc.exe'" -Parent $notableID -AddToMap

    $suspiciousParametersID = $((New-Guid).Guid)
    New-Node -ID $suspiciousParametersID -Text "Suspicious Command Line Parameters" -Tooltip "Command Line Parameters that are oftentimes used my malware" -Parent $notableID -AddToMap

    $expectedRelationshipDiscrepancyID = $((New-Guid).Guid)
    New-Node -ID $expectedRelationshipDiscrepancyID -Text "Processes with different Parent than usual [T1036.005]" -Tooltip "The process loading chain of system processes is mostly fixed, like lsass.exe always getting started via wininit.exe. Are there discrepancies, chances are they got started for means of process injection, or by giving a malicious payload the same name as a known good process, but in a different path." -Parent $notableID -AddToMap
    
    $expectedProcessPathDiscrepancyID = $((New-Guid).Guid)
    New-Node -ID $expectedProcessPathDiscrepancyID -Text "Known Process Names in different Path [T1036.005]" -Tooltip "System processes have a dedicated path where their executables are stored (such as in %windir%). If a process with a well known name runs in a different folder, chances are it is malicious and the name was chosen to fly under the radar" -Parent $notableID -AddToMap
    
    $expectedProcessInstanceDiscrepancyID = $((New-Guid).Guid)
    New-Node -ID $expectedProcessInstanceDiscrepancyID -Text "Process instance count mismatch [T1036.005]" -Tooltip "Lots of system processes have a fixed number of instances runnung simultaneously - most often 1. If there are more, chances are they got started for means of process injection, or by giving a malicious payload the same name as a known good process, but in a different path." -Parent $notableID -AddToMap
    
    $ProcessNameMasqueradingID = $((New-Guid).Guid)
    New-Node -ID $ProcessNameMasqueradingID -Text "Process Name Masquerading [T1036.005]" -Tooltip "Attackers name their payloads similar to known system processes to avoid detection. Something like 'lsaas.exe' closely resembles the legitimate 'lsass.exe' on first glance." -Parent $notableID -AddToMap

    $runningInUNCNetworkPathID = $((New-Guid).Guid)
    New-Node -ID $runningInUNCNetworkPathID -Text "Processes running from UNC Network Paths" -Tooltip "Processes running in UNC paths can hint to remote execution through file shares without having to copy malicious files to the local system" -Parent $notableID -AddToMap

    # create nodes, but not attach them yet. It will make parent search possible.
    foreach ($csvEntry in $csvEntries) {
        # Add a "Suspicious" attribute
        Add-Member -InputObject $csvEntry -MemberType NoteProperty -Name "Suspicious" -Value ""

        $newNode = New-Object System.Windows.Forms.TreeNode
        if($VisualPIDs) {
            $newNode.Text = $(if($csvEntry.PID) { $csvEntry.PID } else { "???" }) + ": " + $(if($csvEntry."Process Name") { $csvEntry."Process Name" } else { "<unknown>" })
        } else {
            $newNode.Text = if($csvEntry."Process Name") { $csvEntry."Process Name" } else { "<unknown>" }
        }

        # custom handling for svchost.exe
        # add command line parameters to displayed node
        if($csvEntry."Process Name" -eq "svchost.exe") {
            $newText = $newNode.Text
            $svcHostS = $null
            $svcHostK = $null
            if($csvEntry.CommandLine -match "-s (\w+)") {
                $svcHostS = $Matches[0] -replace "-s ", ""
            }
            if($csvEntry.CommandLine -match "-k (\w+)") {
                $svcHostK = $Matches[0] -replace "-k ", ""
            }
            if($svcHostK) {
                $newNode.Text = $newText + " " + (Get-SVCHostData -K $svcHostK -S $svcHostS)
            }
        }

        $newNode.Name = $csvEntry.PID
        $newNode.Tag = $csvEntry
        $newNode.ToolTipText = ($csvEntry | Out-String).Trim() -replace " *:", ":"
        $nodesMap[$csvEntry.PID] = $newNode
    }

    # iterate all nodes and attach each node to its parent
    foreach ($entry in $nodesMap.GetEnumerator()) {
        # skip nodes without tag (root tags)
        if($null -eq $entry.Value.Tag) {
            continue
        }
    
        $currPID = $entry.Key
        $currNode = $entry.Value
        $currProcess = $entry.Value.Tag
    
        # PID 4 is the known PID of the system process
        # this is where the system started up. Note startup time in the entry
        # this entry will be used as root, therefore it does not need
        # to get attached to an other element
        if ($currProcess.PID -eq 4) {
            $OSStartLabel.Text = "Windows Start: " + $currProcess."Create Time"
            [void] $TreeView.Nodes.Add($nodesMap[$currPID])
            continue
        }

        # entries who PPID does not exist get attached to the ORPHANS node instead
        $parentNode = $nodesMap[$currProcess.PPID]
        if ($null -eq $parentNode) {
            $parentNode = $orphanNode
            $currProcess.Suspicious = "Orphaned"
        }
    
        # attach this node to the element with matching PID => PPID
        $cyclicalPIDRelationship = $false
        $cyclicalParent = $false
        $PIDTreeList = New-Object System.Collections.ArrayList

        $checkProcess = $currProcess
        $checkNode = $currNode
        $orphanNode = $nodesMap[$orphanID]
        Write-Verbose "Starting with $($checkProcess.PID)"
        while($checkProcess) {
            if($checkNode.Parent -eq $orphanNode) {
                Write-Verbose ".......PID $($checkProcess.PID) is already known having a cyclical PID relationship. Aborting."
                $cyclicalParent = $true
                break
            }
            [void] $PIDTreeList.Add($checkProcess.PID)
            $checkNode = $nodesMap[$checkProcess.PPID]
            $checkProcess = $checkNode.Tag
            Write-Verbose "...checking $($checkProcess.PID) (Tree: $($PIDTreeList))"
            if($PIDTreeList.Contains($checkProcess.PID)) {
                Write-Verbose "......cyclical pid<=>ppid relationship found: PID $($checkProcess.PID)"
                $cyclicalPIDRelationship = $true
                break
            }
        }

        if($cyclicalPIDRelationship) {
            if(-not $orphanNode.Nodes.Contains($checkNode)) {
                Note-Suspicious -Node $checkNode -Description "Cyclical PID Relationship (Process with PID $($checkProcess.PPID) is a child process of this)"
                [void] $orphanNode.Nodes.Add($checkNode)
            }
        }

        if($cyclicalParent -and $checkProcess -eq $currProcess) {
            Write-Verbose "NOT ADDING $($currProcess.PID) to node with PID $($nodesMap[$currProcess.PPID].Tag.PID) - currently already: $($nodesMap[$currProcess.PPID].Nodes.Tag.PID)"
        } else {
            Write-Verbose "Adding $($currProcess.PID) to node with PID $($nodesMap[$currProcess.PPID].Tag.PID) - currently already: $($nodesMap[$currProcess.PPID].Nodes.Tag.PID)"
            [void] $parentNode.Nodes.Add($currNode)
        }
    }

    # one last iteration: add a full path property to all nodes
    foreach ($node in @($nodesMap.Values)) {
        $process = $node.Tag
        if($null -ne $process) {        
            # Add a "Call Chain" attribute
            $processTree = $node.Text
            $currentNode = $node
            while($null -ne $currentNode.Parent -and $null -ne $currentNode.Parent.Tag) {
                $parentNode = $currentNode.Parent
                $processTree = $parentNode.Tag.'Process Name' + " → " + $processTree
                $currentNode = $parentNode
            }

            if($script:dataInitialised) {
                $process."Call Chain" = $processTree
            } else {
                Add-Member -InputObject $process -MemberType NoteProperty -Name "Call Chain" -Value $processTree
            }

            $node.ToolTipText = ($process | Out-String).Trim() -replace " *:", ":"
        }

        if(-not $NoSuspiciousChecks) {
            # enumerate each process and search if they match any notable criteria
            # script interpreters
            if($null -ne $process.'Process Name') {
                # script interpreters
                if ($process.'Process Name' -in $scriptInterpreters) {
                    Set-Suspicious -Node $node -ParentID $scriptInterpretersID -Description "Script Interpreter" -ShortId "in"
                }

                # lateral movement programs
                if($process.'Process Name' -in $LateralMovementPrograms) {
                    Set-Suspicious -Node $node -ParentID $lateralMovementProgramsID -Description "Lateral Movement Program" -ShortId "lm"
                }

                # suspicious programs
                if($process.'Process Name' -in $SuspiciousPrograms) {
                    Set-Suspicious -Node $node -ParentID $suspiciousProgramsID -Description "Suspicious Program" -ShortId "sp"
                }

                # double file extensions
                if($process.'Process Name') {
                    $dotCount = ($process.'Process Name'.ToCharArray() | Where-Object {$_ -eq '.'} | Measure-Object).Count
                    if($dotCount -gt 1) {
                        Set-Suspicious -Node $node -ParentID $doubleFileExtensionsID -Description "Double File Extension" -ShortId "dfe"
                    }
                }

                # suspicious parameters
                if($process.CommandLine) {
                    foreach($suspiciousParameter in $SuspiciousParameters) {
                        if($process.'Process Name' -like $suspiciousParameter.Item1 -and $process.CommandLine -like $suspiciousParameter.Item2) {
                            Set-Suspicious -Node $node -ParentID $suspiciousParametersID -Description "Suspicious Command Line Parameters" -ShortId "sparam"
                        }
                    }
                }

                # known good processes but with unusual parent
                if($ExpectedRelationships.ContainsKey($process.'Process Name')) {
                    $acceptableParents = $ExpectedRelationships[$process.'Process Name']
                    $parentProcessNode = $nodesMap[$process.PPID]
                    if($null -ne $parentProcessNode -and $null -ne $parentProcessNode.Tag) {
                        if($parentProcessNode.Tag.'Process Name' -notin $acceptableParents) {
                            Set-Suspicious -Node $node -ParentID $expectedRelationshipDiscrepancyID -Description $("Parent process mismatch. Should match one of: " + $acceptableParents -join ", ") -ShortId "accp"
                        }
                    }
                }

                # check the number of running instances with the same process name.
                # does the found count match the expected count?
                if($ExpectedProcessInstanceCounts.ContainsKey($process.'Process Name')) {
                    $expectedInstances = $ExpectedProcessInstanceCounts[$process.'Process Name']
                    [int] $runningInstances = 0 # the upcoming loop also counts this instance, so we start at 0 instead of 1
                    foreach($mapNode in $nodesMap.Values) {
                        if($null -ne $mapNode.Tag -and $process.'Process Name' -eq $mapNode.Tag.'Process Name') {
                            $runningInstances++
                        }
                    }
                    if($expectedInstances -ne $runningInstances) {
                        Set-Suspicious -Node $node -ParentID $expectedProcessInstanceDiscrepancyID -Description $("Found " + $runningInstances + " running instances instead of the expected " + $expectedInstances) -ShortId "eicm"
                    }
                }

                # check if this process name is typed very similar than known good ones
                foreach($similarName in $ProcessesToSearchSimilarNames) {
                    [int] $distance = [LevenshteinDistance]::Measure($process.'Process Name', $similarName)
                    if($distance -eq 1) {
                        Set-Suspicious -Node $node -ParentID $ProcessNameMasqueradingID -Description $("Name " + $process.'Process Name' + " is very similar to known " + $similarName) -ShortId "pnm"
                    }
                }
            }

            if($null -ne $process.'File Path') {
                # unusual file locations
                foreach($suspiciousFolder in $suspiciousFolders) {
                    if($process.'File Path' -like $suspiciousFolder) {
                        Set-Suspicious -Node $node -ParentID $suspiciousFoldersID -Description "Running in Suspicious Folder" -ShortId "sf"
                        break
                    }
                }
        
                # unusual parent <=> child relationship
                if($node.Tag.PID -and $nodesMap.ContainsKey($node.Tag.PID)) {
                    $parentNode = $nodesMap[$node.Tag.PID]
                    if($null -ne $parentNode -and $null -ne $parentNode.Tag -and $null -ne $parentNode.Tag.'Process Name') {
                        $parentProcess = $parent.Tag
                        foreach($unusualRelationShip in $unusualRelationShips) {
                            if($parentProcess.'Process Name' -like $unusualRelationShip.Item1 -and $process.'File Path' -like $unusualRelationShip.Item2) {
                                Set-Suspicious -Node $node -ParentID $unusualRelationShipsID -Description "Unusual Parent<=>Child Relationship" -ShortId "ur"
                                break
                            }
                        }
                    }
                }

                # known good programs, but in unusual path
                if($null -ne $process.'Process Name' -and $ExpectedProcessPaths.ContainsKey($process.'Process Name')) {
                    $knownPath = $ExpectedProcessPaths[$process.'Process Name']
                    if($process.'Device Path' -notmatch $knownPath) {
                        Set-Suspicious -Node $node -ParentID $expectedProcessPathDiscrepancyID -Description $("Process Path mismatch. Should match: '" + $knownPath + "'") -ShortId "kppm"
                    }
                }

                # running in unc path
                if($process.'File Path'.StartsWith("\\")) {
                    Set-Suspicious -Node $node -ParentID $runningInUNCNetworkPathID -Description $("Running in UNC network path") -ShortId "unc"
                }

            }
        }

    }

    $TreeView.Sort()

    $systemNode = $nodesMap["4"]
    if($systemNode) {
        Set-Nodes -Root $systemNode -Depth 3 -Collapsed $false
    }

    $TreeView.EndUpdate()

    $script:dataInitialised = $true
}


####################################
#endregion DISPLAY                 #
####################################

Fill-GUIData

$Form.Add_Shown( { $Form.Activate() })
[system.windows.forms.application]::run($Form)
```

`Scripts/Measure-DamerauLevenshteinDistance/Measure-DamerauLevenshteinDistance.cs`:

```cs
using System;
using System.Linq;

// Original by Jared Atkinson (@jaredcatkinson)
// ported to C# by https://github.com/DaFuqs
public class LevenshteinDistance {

	public static int Measure(string original, string modified) {
		if (original == modified) {
			return 0;
        }

		int lorig = original.Length;
		int ldiff = modified.Length;
		if (lorig == 0 || ldiff == 0) {
			return lorig == 0 ? ldiff : lorig;
        }

		var matrix = new int[lorig + 1, ldiff + 1];

		for (int i = 1; i <= lorig; i++) {
			matrix[i, 0] = i;
			for (int j = 1; j <= ldiff; j++) {
				int cost = modified[j - 1] == original[i - 1] ? 0 : 1;
				if (i == 1)
					matrix[0, j] = j;

				int[] vals = new int[] {
					matrix[i - 1, j    ] + 1,
					matrix[i    , j - 1] + 1,
					matrix[i - 1, j - 1] + cost
				};
				matrix[i,j] = vals.Min();
				if (i > 1 && j > 1 && original[i - 1] == modified[j - 2] && original[i - 2] == modified[j - 1])
					matrix[i,j] = Math.Min (matrix[i,j], matrix[i - 2, j - 2] + cost);
			}
		}
		return matrix[lorig, ldiff];
	}
}
```

`Tools/RECmd_BatchFiles/AdobeRecentFiles.reb`:

```reb
Description: Adobe RecentFiles - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13eb5f-11db-5cdc-c3df-88ec86dc18
Keys:
    -
        Description: Historical information of files accessed by Adobe Reader.
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Adobe\Acrobat Reader\DC\AVGeneral\cRecentFolders\*
        Recursive: false
```

`Tools/RECmd_BatchFiles/BAM.reb`:

```reb
Description: BAM/DAM - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13eb6f-31db-5cdc-83df-88ec86dc17
Keys:
    -
        Description: Windows Background Activity Moderator (BAM)
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet*\Services\bam\State\UserSettings\*
        Recursive: false
    -
        Description: Windows Background Activity Moderator (BAM)
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet*\Services\bam\UserSettings\*
        Recursive: false
    -
        Description: Windows Desktop Activity Moderator (DAM)
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet*\Services\dam\State\UserSettings\*
        Recursive: false
    -
        Description: Windows Desktop Activity Moderator (DAM)
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet*\Services\dam\UserSettings\*
        Recursive: false
```

`Tools/RECmd_BatchFiles/Kroll_Batch.reb`:

```reb
Description: Kroll RECmd Batch File
Author: Andrew Rathbun
Version: 1.20
Id: ecc582d5-a1b1-4256-ae64-ca2263b8f971
Keys:
#
# Kroll_Batch README: https://github.com/EricZimmerman/RECmd/blob/master/BatchExamples/Kroll_Batch.md
#  => Add changelog in this readme after additions.
#
# --------------------
# TABLE OF CONTENTS
# --------------------
#
# System Info
# Devices
# Network Shares
# User Accounts
# Program Execution
# User Activity
# Autoruns
# Third Party Applications
# Cloud Storage
# Services
# Event Logs
# Microsoft Office/Office 365
# Microsoft Exchange
# Web Browsers
# Installed Software
# Volume Shadow Copies
# Threat Hunting
#
# --------------------
# SYSTEM INFO
# --------------------

# System Info -> Basic System Info

    -
        Description: WinLogon
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion\WinLogon
        ValueName: LastUsedUsername
        Recursive: false
        Comment: "Displays the username of the last user logged in to this system"

# https://windowsir.blogspot.com/2013/04/plugin-winlogon.html

    -
        Description: WinLogon
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion\WinLogon
        ValueName: AutoLogonSID
        Recursive: false
        Comment: "Displays the SID of the user who is set to auto login to Windows"

# https://windowsir.blogspot.com/2013/04/plugin-winlogon.html

    -
        Description: WinLogon
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion\WinLogon
        ValueName: AutoAdminLogon
        Recursive: false
        Comment: "Displays whether the system will automatically login a user as Admin, 0 = Disabled, 1 = Enabled"
    -
        Description: WinLogon
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion\WinLogon
        ValueName: DefaultUserName
        Recursive: false
        Comment: "Displays the default username the system will log in as"
    -
        Description: WinLogon
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion\WinLogon
        ValueName: DefaultPassword
        Recursive: false
        Comment: "Displays the password to be used for the account specified in DefaultUserName"
    -
        Description: LogonUI
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows\CurrentVersion\Authentication\LogonUI
        ValueName: LastLoggedOnUser
        Recursive: false
        Comment: "Displays the last logged on SAM user"
    -
        Description: LogonUI
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows\CurrentVersion\Authentication\LogonUI
        ValueName: LastLoggedOnSAMUser
        Recursive: false
        Comment: "Displays the last logged on user"
    -
        Description: LogonUI
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows\CurrentVersion\Authentication\LogonUI
        ValueName: LastLoggedOnDisplayName
        Recursive: false
        Comment: "Displays the last logged on user's display name"
    -
        Description: LogonUI
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows\CurrentVersion\Authentication\LogonUI
        ValueName: SelectedUserSID
        Recursive: false
        Comment: "Displays the selected user's SID"
    -
        Description: LogonUI
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows\CurrentVersion\Authentication\LogonUI
        ValueName: LastLoggedOnUserSID
        Recursive: false
        Comment: "Displays the last logged on user's SID"
    -
        Description: Windows Boot Volume
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup
        ValueName: SystemPartition
        Recursive: false
        Comment: "Identifies the system volume where Windows booted from"

# https://www.microsoftpressstore.com/articles/article.aspx?p=2201310
# https://stackoverflow.com/questions/15361617/retrieve-the-partition-number-of-bootmgr-on-windows-vista-and-later

    -
        Description: ControlSet Configuration
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Select
        ValueName: Current
        Recursive: false
        Comment: "Displays value for the current ControlSet"

# https://what-when-how.com/windows-forensic-analysis/registry-analysis-windows-forensic-analysis-part-3/
# https://msirevolution.wordpress.com/2012/03/31/what-is-currentcontrolset001-in-windows-registry/

    -
        Description: ControlSet Configuration
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Select
        ValueName: Default
        Recursive: false
        Comment: "Displays value for the default ControlSet"

# https://what-when-how.com/windows-forensic-analysis/registry-analysis-windows-forensic-analysis-part-3/
# https://msirevolution.wordpress.com/2012/03/31/what-is-currentcontrolset001-in-windows-registry/

    -
        Description: ControlSet Configuration
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Select
        ValueName: Failed
        Recursive: false
        Comment: "Displays value for the ControlSet that was unable to boot Windows successfully"

# https://what-when-how.com/windows-forensic-analysis/registry-analysis-windows-forensic-analysis-part-3/
# https://msirevolution.wordpress.com/2012/03/31/what-is-currentcontrolset001-in-windows-registry/

    -
        Description: ControlSet Configuration
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Select
        ValueName: LastKnownGood
        Recursive: false
        Comment: "Displays value for the last known good ControlSet"

# https://what-when-how.com/windows-forensic-analysis/registry-analysis-windows-forensic-analysis-part-3/
# https://msirevolution.wordpress.com/2012/03/31/what-is-currentcontrolset001-in-windows-registry/

    -
        Description: Shutdown Time
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet00*\Control\Windows
        ValueName: ShutdownTime
        Recursive: false
        IncludeBinary: true
        BinaryConvert: FILETIME
        Comment: "Last system shutdown time"

# https://www.winhelponline.com/blog/how-to-determine-the-last-shutdown-date-and-time-in-windows/

    -
        Description: Windows OS Language
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Control\Nls\Language
        ValueName: InstallLanguage
        Recursive: false
        Comment: "Default OS Language, 0409 is English"

# https://serverfault.com/questions/957167/windows-10-1809-region-language-registry-keys
# https://www.itprotoday.com/windows-78/where-registry-language-setting-each-user-stored

    -
        Description: Virtual Memory Pagefile Encryption Status
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Control\FileSystem
        ValueName: NtfsEncryptPagingFile
        Recursive: false
        Comment: "Virtual Memory Pagefile Encryption, 0 = Disabled, 1 = Enabled"

# https://www.tenforums.com/tutorials/77782-enable-disable-virtual-memory-pagefile-encryption-windows-10-a.html

    -
        Description: TRIM Status
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Control\FileSystem
        ValueName: DisableDeleteNotification
        Recursive: false
        Comment: "TRIM, 0 = Enabled, 1 = Disabled"

# https://www.howtogeek.com/257196/how-to-check-if-trim-is-enabled-for-your-ssd-and-enable-it-if-it-isnt/

    -
        Description: NTFS File Compression Status
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Control\FileSystem
        ValueName: NtfsDisableCompression
        Recursive: false
        Comment: "NTFS File Compression, 0 = Enabled, 1 = Disabled"

# https://thegeekpage.com/enable-disable-ntfs-compression-windows-improve-performance/
# https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/fsutil-behavior

    -
        Description: NTFS File Encryption Status
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Control\FileSystem
        ValueName: NtfsDisableEncryption
        Recursive: false
        Comment: "NTFS File Encryption, 0 = Enabled, 1 = Disabled"

# https://www.tenforums.com/tutorials/97782-enable-disable-ntfs-file-encryption-windows.html
# https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/fsutil-behavior

    -
        Description: NTFS LastAccess Timestamp Status
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Control\FileSystem
        ValueName: NtfsDisableLastAccessUpdate
        Recursive: false
        Comment: "NTFS LastAccess Timestamp, 2147483650 = Enabled, 1 = Disabled"

# https://dfir.ru/2018/12/08/the-last-access-updates-are-almost-back/
# https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/fsutil-behavior

    -
        Description: Long Paths Enabled
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Control\FileSystem
        ValueName: LongPathsEnabled
        Recursive: false
        Comment: "NTFS Long Paths, 0 = Disabled, 1 = Enabled"

# https://www.howtogeek.com/266621/how-to-make-windows-10-accept-file-paths-over-260-characters/

    -
        Description: Prefetch Status
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet00*\Control\Session Manager\Memory Management\PrefetchParameters
        ValueName: EnablePrefetcher
        Recursive: false
        Comment: "0 = Disabled, 1 = Application Prefetching Enabled, 2 = Boot Prefetching Enabled, 3 = Application and Boot Prefetching Enabled"

# https://www.thewindowsclub.com/disable-superfetch-prefetch-ssd
# https://youtu.be/f4RAtR_3zcs
# https://resources.infosecinstitute.com/topic/windows-systems-artifacts-digital-forensics-part-iii-prefetch-files/
# https://www.hackingarticles.in/forensic-investigation-prefetch-file/
# https://countuponsecurity.com/2016/05/16/digital-forensics-prefetch-artifacts/
# https://or10nlabs.tech/prefetch-forensics/

    -
        Description: Clear Page File at Shutdown Status
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet00*\Control\Session Manager\Memory Management
        ValueName: ClearPageFileAtShutdown
        Recursive: false
        Comment: "0 = Disabled, 1 = Enabled"

# https://tweaks.com/windows/37350/clear-pagefile-111n-shutdown/
# https://www.majorgeeks.com/content/page/clear_page_file.html
# https://docs.microsoft.com/en-us/windows/client-management/introduction-page-file

    -
        Description: System Time Zone Information
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet00*\Control\TimeZoneInformation
        Recursive: false
        Comment: "Displays the current Time Zone configuration for this system"

# TimeZoneInfo plugin

# https://kb.digital-detective.net/display/BF/Identification+of+Time+Zone+Settings+on+Suspect+Computer

    -
        Description: Network Connections
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion\NetworkList
        Recursive: false
        Comment: "Displays list of network connections"

# KnownNetworks plugin
# https://www.forensafe.com/blogs/wirelessnetworks.html

    -
        Description: Device Classes
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Control\DeviceClasses
        Recursive: false
        Comment: "Displays a list of PnP devices (Plug and Play) that were connected to this system"

# DeviceClasses plugin
# https://docs.microsoft.com/en-us/windows-hardware/drivers/usbcon/usb-device-specific-registry-settings
# https://www.hecfblog.com/2013/08/daily-blog-67-understanding-artifacts.html

# System Info -> System Info (Current)

    -
        Description: System Info (Current)
        HiveType: NTUSER
        Category: System Info
        KeyPath: Software\Microsoft\Windows Media\WMSDK\General
        ValueName: ComputerName
        Recursive: false
        Comment: "Name of computer used by the user"
    -
        Description: System Info (Current)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet00*\Control\ComputerName\ComputerName
        ValueName: ComputerName
        Recursive: false
        Comment: "Name of computer used by the user"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: SystemRoot
        Recursive: false
        Comment: "Current location of %SystemRoot% Environment Variable"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: RegisteredOwner
        Recursive: false
        Comment: "Current registered owner"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: RegisteredOrganization
        Recursive: false
        Comment: "Current registered organization"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: DisplayVersion
        Recursive: false
        Comment: "Current milestone update version"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: InstallTime
        IncludeBinary: true
        BinaryConvert: FILETIME
        Recursive: false
        Comment: "Current OS install time"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: ProductName
        Recursive: false
        Comment: "Current OS name"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: InstallDate
        IncludeBinary: true
        BinaryConvert: EPOCH
        Recursive: false
        Comment: "Current OS install date"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: InstallationType
        Recursive: false
        Comment: "Current OS installation type"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: EditionID
        Recursive: false
        Comment: "Current OS version and install info"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: CurrentMajorVersionNumber
        Recursive: false
        Comment: "Current OS version and install info"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: CurrentBuildNumber
        Recursive: false
        Comment: "Current OS version and install info"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: CurrentBuild
        Recursive: false
        Comment: "Current OS build information"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: CompositionEditionID
        Recursive: false
        Comment: "Current OS license type"
    -
        Description: System Info (Current)
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\Windows NT\CurrentVersion
        ValueName: BuildLab
        Recursive: false
        Comment: "Current OS build information"

# System Info -> System Info (Historical)

    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: SystemRoot
        Recursive: false
        Comment: "Historical location of %SystemRoot% Environment Variable"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: RegisteredOwner
        Recursive: false
        Comment: "Historical registered owner"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: RegisteredOrganization
        Recursive: false
        Comment: "Historical registered organization"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: DisplayVersion
        Recursive: false
        Comment: "Historical milestone update version"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: InstallTime
        IncludeBinary: true
        BinaryConvert: FILETIME
        Recursive: false
        Comment: "Historical OS install time"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: ProductName
        Recursive: false
        Comment: "Historical OS name"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: InstallDate
        IncludeBinary: true
        BinaryConvert: EPOCH
        Recursive: false
        Comment: "Historical OS install date"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: InstallationType
        Recursive: false
        Comment: "Historical OS installation type"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: EditionID
        Recursive: false
        Comment: "Historical OS version and install info"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: CurrentMajorVersionNumber
        Recursive: false
        Comment: "Historical OS version and install info"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: CurrentBuildNumber
        Recursive: false
        Comment: "Historical OS version and install info"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: CurrentBuild
        Recursive: false
        Comment: "Historical OS build information"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: CompositionEditionID
        Recursive: false
        Comment: "Historical OS license type"
    -
        Description: System Info (Historical)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: Setup\Source OS*
        ValueName: BuildLab
        Recursive: false
        Comment: "Historical OS build information"

# https://az4n6.blogspot.com/2017/02/when-windows-lies.html
# https://www.nextofwindows.com/when-was-my-windows-10-originally-installed

# System Info -> Network Configuration (IPv4)

# DHCPNetworkHints plugin not used

    -
        Description: Network Adapters
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Control\Class\{4d36e972-e325-11ce-bfc1-08002be10318}
        Recursive: false
        Comment: "Displays list of network adapters connected to this system"

# NetworkAdapters plugin

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: AddressType
        Recursive: false
        Comment: ""
    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: DhcpConnForceBroadcastFlag
        Recursive: false
        Comment: "DHCP Broadcast, 0 = Disabled, 1 = Enabled"

# https://support.microsoft.com/en-us/topic/windows-vista-can-t-get-an-ip-address-from-certain-routers-or-dhcp-servers-ee61b030-e749-878b-9725-247d8bd95c5e

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: DhcpDefaultGateway
        Recursive: false
        Comment: "Displays the ordered list of gateways that can be used as the default gateway for this system."

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc959606(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: DhcpDomain
        Recursive: false
        Comment: "Specifies the Domain Name System (DNS) domain name of the interface, as provided by the Dynamic Host Configuration Protocol (DHCP)"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962456(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: DhcpDomainSearchList
        Recursive: false
        Comment: ""
    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: DhcpGatewayHardware
        IncludeBinary: true
        Recursive: false
        Comment: ""
    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: DhcpGatewayHardwareCount
        Recursive: false
        Comment: ""
    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: DhcpIPAddress
        Recursive: false
        Comment: "Specifies the IP addresses of the interface, as configured by Dynamic Host Configuration Protocol (DHCP)"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962469(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: DhcpNameServer
        Recursive: false
        Comment: "Stores a list of Domain Name System (DNS) servers to which Windows Sockets sends queries when it resolves names for the interface"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962470(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: DhcpServer
        Recursive: false
        Comment: "Stores the IP address of the Dynamic Host Configuration Protocol (DHCP) server that granted the lease to the IP address stored in the value of the DhcpIPAddress entry"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962473(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: DhcpSubnetMask
        Recursive: false
        Comment: "Specifies the subnet mask for the IP address specified in the value of either the IPAddress entry or the DhcpIPAddress entry"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962474(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: DhcpSubnetMaskOpt
        Recursive: false
        Comment: "Specifies the subnet mask associated with a Dynamic Host Configuration Protocol (DHCP) option"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962475(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: Domain
        Recursive: false
        Comment: "Specifies the Domain Name System (DNS) domain name of the interface, as provided by the Dynamic Host Configuration Protocol (DHCP)"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962476(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: EnableDHCP
        Recursive: false
        Comment: "DHCP status, 0 = Disabled, 1 = Enabled"

# https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mscs/enabledhcp

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: EnableMulticast
        Recursive: false
        Comment: "Multicast status, 0 = Disabled, 1 = Enabled"

# https://www.microsoftpressstore.com/articles/article.aspx?p=2217263&seqNum=8

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: IPAddress
        Recursive: false
        Comment: "Specifies the IP addresses of the interface"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc938245(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: IsServerNapAware
        Recursive: false
        Comment: ""
    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: Lease
        Recursive: false
        Comment: "Specifies how long the lease on the IP address for this interface is valid"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc978464(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: LeaseObtainedTime
        Recursive: false
        IncludeBinary: true
        BinaryConvert: EPOCH
        Comment: "Stores the time that the interface acquired the lease on its IP address"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc978465(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: LeaseTerminatesTime
        Recursive: false
        IncludeBinary: true
        BinaryConvert: EPOCH
        Comment: "Stores the time when the lease on the interfaces' IP address expires"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc978467(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: NameServer
        Recursive: false
        Comment: "Stores a list of Domain Name System (DNS) servers to which Windows Sockets sends queries when it resolves names for this interface"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc978468(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: RegisterAdapterName
        Recursive: false
        Comment: ""
    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: RegistrationEnabled
        Recursive: false
        Comment: "Dynamic DNS registration for a specific network interface controller (NIC)"

# https://www.serverbrain.org/networking-guide-2003/configuring-dynamic-dns-registration-problem.html

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: SubnetMask
        Recursive: false
        Comment: "Specifies the subnet mask for the IP address specified in the value of IPAddress or DhcpIPAddress"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc938248(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: T1
        Recursive: false
        Comment: "Displays time that the DHCP client stores for when the service will try to renew its IP address lease"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc978470(v=technet.10)

    -
        Description: Network Configuration (IPv4)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip\Parameters\Interfaces\*
        ValueName: T2
        Recursive: false
        Comment: "Displays time that the DHCP client stores for when the service will try to broadcast a renewal request"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc978471(v=technet.10)?redirectedfrom=MSDN

# System Info - Network Configuration (IPv6)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: AddressType
        Recursive: false
        Comment: ""
    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: DhcpConnForceBroadcastFlag
        Recursive: false
        Comment: "DHCP Broadcast, 0 = Disabled, 1 = Enabled"

# https://support.microsoft.com/en-us/topic/windows-vista-can-t-get-an-ip-address-from-certain-routers-or-dhcp-servers-ee61b030-e749-878b-9725-247d8bd95c5e

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: DhcpDefaultGateway
        Recursive: false
        Comment: "Displays the ordered list of gateways that can be used as the default gateway for this system."

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc959606(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: DhcpDomain
        Recursive: false
        Comment: "Specifies the Domain Name System (DNS) domain name of the interface, as provided by the Dynamic Host Configuration Protocol (DHCP)"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962456(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: DhcpDomainSearchList
        Recursive: false
        Comment: ""
    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: DhcpGatewayHardware
        Recursive: false
        Comment: ""
    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: DhcpGatewayHardwareCount
        Recursive: false
        Comment: ""
    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: DhcpIPAddress
        Recursive: false
        Comment: "Specifies the IP addresses of the interface, as configured by Dynamic Host Configuration Protocol (DHCP)"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962469(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: DhcpNameServer
        Recursive: false
        Comment: "Stores a list of Domain Name System (DNS) servers to which Windows Sockets sends queries when it resolves names for the interface"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962470(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: DhcpServer
        Recursive: false
        Comment: "Stores the IP address of the Dynamic Host Configuration Protocol (DHCP) server that granted the lease to the IP address stored in the value of the DhcpIPAddress entry"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962473(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: DhcpSubnetMask
        Recursive: false
        Comment: "Specifies the subnet mask for the IP address specified in the value of either the IPAddress entry or the DhcpIPAddress entry"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962474(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: DhcpSubnetMaskOpt
        Recursive: false
        Comment: "Specifies the subnet mask associated with a Dynamic Host Configuration Protocol (DHCP) option"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962475(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: Domain
        Recursive: false
        Comment: "Specifies the Domain Name System (DNS) domain name of the interface, as provided by the Dynamic Host Configuration Protocol (DHCP)"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc962476(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: EnableDHCP
        Recursive: false
        Comment: "DHCP status, 0 = Disabled, 1 = Enabled"

# https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mscs/enabledhcp

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: EnableMulticast
        Recursive: false
        Comment: "Multicast status, 0 = Disabled, 1 = Enabled"

# https://www.microsoftpressstore.com/articles/article.aspx?p=2217263&seqNum=8

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: IPAddress
        Recursive: false
        Comment: "Specifies the IP addresses of the interface"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc938245(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: IsServerNapAware
        Recursive: false
        Comment: ""
    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: Lease
        Recursive: false
        Comment: "Specifies how long the lease on the IP address for this interface is valid"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc978464(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: LeaseObtainedTime
        Recursive: false
        IncludeBinary: true
        BinaryConvert: EPOCH
        Comment: "Stores the time that the interface acquired the lease on its IP address"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc978465(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: LeaseTerminatesTime
        Recursive: false
        IncludeBinary: true
        BinaryConvert: EPOCH
        Comment: "Stores the time when the lease on the interfaces' IP address expires"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc978467(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: NameServer
        Recursive: false
        Comment: "Stores a list of Domain Name System (DNS) servers to which Windows Sockets sends queries when it resolves names for this interface"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc978468(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: RegisterAdapterName
        Recursive: false
        Comment: ""
    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: RegistrationEnabled
        Recursive: false
        Comment: "Dynamic DNS registration for a specific network interface controller (NIC)"

# https://www.serverbrain.org/networking-guide-2003/configuring-dynamic-dns-registration-problem.html

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: SubnetMask
        Recursive: false
        Comment: "Specifies the subnet mask for the IP address specified in the value of IPAddress or DhcpIPAddress"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc938248(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: T1
        Recursive: false
        Comment: "Displays time that the DHCP client stores for when the service will try to renew its IP address lease"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc978470(v=technet.10)

    -
        Description: Network Configuration (IPv6)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Services\Tcpip6\Parameters\Interfaces\*
        ValueName: T2
        Recursive: false
        Comment: "Displays time that the DHCP client stores for when the service will try to broadcast a renewal request"

# https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc978471(v=technet.10)?redirectedfrom=MSDN

    -
        Description: Windows 10 Timeline Status
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Policies\Microsoft\Windows\System
        ValueName: EnableActivityFeed
        Recursive: false
        Comment: "Windows 10 Activity Timeline status, 0 = Disabled, 1 = Enabled"

# https://www.majorgeeks.com/content/page/how_to_disable_or_enable_timeline_in_windows_10.html

    -
        Description: Windows 10 Timeline Status
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\PolicyManager\default\Privacy\EnableActivityFeed
        ValueName: value
        Recursive: false
        Comment: "Windows 10 Activity Timeline status, 0 = Disabled, 1 = Enabled"

# The above location is where this value exists on my personal machine. Adding it in case the other one doesn't get a hit.

    -
        Description: Clipboard History Status
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\PolicyManager\default\Privacy
        ValueName: EnableClipboardHistory
        Recursive: False
        Comment: "Displays the status of Clipboard History, 0 = Disabled, 1 = Enabled"

# The above location is where this value exists on my personal machine. Adding it in case the other one doesn't get a hit.

    -
        Description: Clipboard History Status
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Software\Policies\Microsoft\Windows\System
        ValueName: AllowCrossDeviceClipboard
        Recursive: False
        Comment: "Displays the status of Clipboard Sync Across Devices, 0 = Disabled, 1 = Enabled"

# https://www.tenforums.com/tutorials/110048-enable-disable-clipboard-sync-across-devices-windows-10-a.html

    -
        Description: Clipboard History Status
        HiveType: SOFTWARE
        Category: System Info
        KeyPath: Microsoft\PolicyManager\default\Privacy\AllowCrossDeviceClipboard
        ValueName: value
        Recursive: False
        Comment: "Displays the status of Clipboard Sync Across Devices, 0 = Disabled, 1 = Enabled"

# The above location is where this value exists on my personal machine. Adding it in case the other one doesn't get a hit.

# System Info - SUM Database\User Access Logging

    -
        Description: User Access Logging (SUM DB)
        HiveType: SYSTEM
        Category: System Info
        KeyPath: ControlSet*\Control\WMI\Autologger\SUM
        ValueName: PollingInterval
        Recursive: False
        Comment: "Displays the updating interval for the SUM DB. Default is 24 hours. 60000 = 60 seconds, for example."

# https://youtu.be/p4XI8-ldE5o?t=627


# --------------------
# DEVICES
# --------------------

    -
        Description: Microphone
        HiveType: SOFTWARE
        Category: Devices
        KeyPath: Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\microphone
        ValueName: LastUsedTimeStart
        IncludeBinary: true
        BinaryConvert: FILETIME
        Recursive: true
        Comment: "Displays the timestamp of when a microphone started being used with a given application"
    -
        Description: Microphone
        HiveType: SOFTWARE
        Category: Devices
        KeyPath: Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\microphone
        ValueName: LastUsedTimeStop
        IncludeBinary: true
        BinaryConvert: FILETIME
        Recursive: true
        Comment: "Displays the timestamp of when a microphone stopped being used with a given application"
    -
        Description: Webcam
        HiveType: SOFTWARE
        Category: Devices
        KeyPath: Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\webcam\*\*
        ValueName: LastUsedTimeStart
        IncludeBinary: true
        BinaryConvert: FILETIME
        Recursive: true
        Comment: "Displays the timestamp of when a webcam started being used with a given application"
    -
        Description: Webcam
        HiveType: SOFTWARE
        Category: Devices
        KeyPath: Microsoft\Windows\CurrentVersion\CapabilityAccessManager\ConsentStore\webcam\*\*
        ValueName: LastUsedTimeStop
        IncludeBinary: true
        BinaryConvert: FILETIME
        Recursive: true
        Comment: "Displays the timestamp of when a webcam stopped being used with a given application"
    -
        Description: Bluetooth Devices
        HiveType: SYSTEM
        Category: Devices
        KeyPath: ControlSet*\Services\BTHPORT\Parameters\Devices
        Recursive: false
        Comment: "Displays the Bluetooth devices that have been connected to this computer"

# BTHPORT plugin

    -
        Description: Volume Info Cache
        HiveType: SOFTWARE
        Category: Devices
        KeyPath: Microsoft\Windows Search\VolumeInfoCache
        Recursive: false
        Comment: "2 = Removable, 3 = Fixed, 4 = Network, 5 = Optical, 6 = RAM disk, 0 = Unknown"

# VolumeInfoCache plugin
# https://docs.microsoft.com/en-us/dotnet/api/system.io.drivetype?view=net-5.0

# Devices -> USBSTOR

    -
        Description: USBSTOR
        HiveType: SYSTEM
        Category: Devices
        KeyPath: ControlSet*\Enum\USBSTOR
        Recursive: false
        Comment: "Displays list of USB devices that have been plugged into this system. If & is second character within serial number, serial number is only unique on the system"

# USBSTOR plugin
# https://www.jaiminton.com/cheatsheet/DFIR/#usb-information-1
# https://www.13cubed.com/downloads/dfir_cheat_sheet.pdf
# https://www.swiftforensics.com/2013/11/windows-8-new-registry-artifacts-part-1.html
# https://www.tristiansforensicsecurity.com/2018/11/28/basic-usb-forensics-in-windows/

    -
        Description: USB
        HiveType: SYSTEM
        Category: Devices
        KeyPath: ControlSet*\Enum\USB
        Recursive: false
        Comment: "Provides VID and PID numbers of USB devices. Match serial number from USBSTOR and search for VID and PID across the system"

# USB plugin
# https://www.tristiansforensicsecurity.com/2018/11/28/basic-usb-forensics-in-windows/

    -
        Description: MountPoints2
        HiveType: NTUSER
        Category: Devices
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2
        Recursive: true
        Comment: "Mount Points - NTUSER"

# https://www.sans.org/security-resources/posters/windows-forensic-analysis/170/download
# https://eforensicsmag.com/investigating-usb-drives-using-mount-points-not-drive-letters-by-ali-hadi/
# https://www.andreafortuna.org/2017/10/18/windows-registry-in-forensic-analysis/
# https://www.forensicfocus.com/articles/forensic-analysis-of-the-windows-registry/

    -
        Description: Mounted Devices
        HiveType: SYSTEM
        Category: Devices
        KeyPath: MountedDevices
        Recursive: false
        Comment: "Last Write Timestamp is for entire key, not each individual value"

# MountedDevices plugin
# https://what-when-how.com/windows-forensic-analysis/registry-analysis-windows-forensic-analysis-part-6/
# https://hatsoffsecurity.com/2014/12/04/mounted-devices-key/
# https://www.forensicfocus.com/articles/forensic-analysis-of-the-windows-registry/
# https://www.andreafortuna.org/2017/10/18/windows-registry-in-forensic-analysis/
# https://www.binary-zone.com/2020/04/03/no-drive-letter-no-usb-think-again/
# https://windowsir.blogspot.com/2004/12/mounted-devices.html

    -
        Description: Windows Portable Devices
        HiveType: SOFTWARE
        Category: Devices
        KeyPath: Microsoft\Windows Portable Devices
        Recursive: false
        Comment: "Displays list of USB devices previously connected to this system"

# WindowsPortableDevices plugin
# https://df-stream.com/2017/10/amcache-and-usb-device-tracking/

# --------------------
# NETWORK SHARES
# --------------------

# Network Shares -> Network Shares
    -
        Description: Network Shares
        HiveType: NTUSER
        Category: Network Shares
        KeyPath: Network
        ValueName: RemotePath
        Recursive: true
        Comment: "Displays the UNC path for a mounted network share"
    -
        Description: Network Shares
        HiveType: NTUSER
        Category: Network Shares
        KeyPath: Network
        ValueName: UserName
        Recursive: true
        Comment: "Displays the user account associated with the mounted network share"
    -
        Description: Network Shares
        HiveType: NTUSER
        Category: Network Shares
        KeyPath: Network
        ValueName: ProviderName
        Recursive: true
        Comment: "Displays the provider of the mounted network share"

# https://social.technet.microsoft.com/Forums/ie/en-US/65eb8a2f-988f-40a7-b6ff-616a050c8efc/list-all-mapped-drives-for-all-users-that-have-logged-into-a-computer?forum=ITCG

    -
        Description: Network Drive MRU
        HiveType: NTUSER
        Category: Network Shares
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\Map Network Drive MRU
        Recursive: false
        Comment: "Displays drives that were mapped by the user"

# https://community.spiceworks.com/topic/137045-remove-previously-mapped-network-drive-paths
# https://answers.microsoft.com/en-us/windows/forum/windows_7-networking/cleanup-network-drives-list/1247aca3-deb6-493d-b937-24b40087cbc7?auth=1

    -
        Description: Network Shares
        HiveType: SYSTEM
        Category: Network Shares
        KeyPath: ControlSet00*\Services\LanmanServer\Shares
        Recursive: true
        Comment: "Displays the share names and permissions of network shares"

# https://www.coretechnologies.com/blog/windows-services/lanmanserver/
# https://docs.microsoft.com/en-us/troubleshoot/windows-client/networking/saving-restoring-existing-windows-shares

# --------------------
# USER ACCOUNTS
# --------------------

    -
        Description: User Accounts (SAM)
        HiveType: SAM
        Category: User Accounts
        KeyPath: SAM\Domains\Account\Users
        Recursive: false
        Comment: "User accounts in SAM hive"

# UserAccounts plugin
# https://www.forensafe.com/blogs/useraccounts.html

    -
        Description: User Accounts (SOFTWARE)
        HiveType: SOFTWARE
        Category: User Accounts
        KeyPath: Microsoft\Windows NT\CurrentVersion\ProfileList
        Recursive: false
        Comment: "User accounts in SOFTWARE hive"

# ProfileList plugin
# https://content-calpoly-edu.s3.amazonaws.com/cci/1/documents/ccic_forensics_manual/CCIC%20Chapter%204%20-%20Understanding%20the%20Registry.pdf

    -
        Description: User Accounts (SECURITY)
        HiveType: SECURITY
        Category: User Accounts
        KeyPath: Policy\Accounts\*
        IncludeBinary: true
        Recursive: false
        Comment: "Built-in accounts in SECURITY hive"

# https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/security-identifiers-in-windows

# --------------------
# PROGRAM EXECUTION
# --------------------

# Porgram Execution -> Windows Sysinternals

    -
        Description: Sysinternals
        HiveType: NTUSER
        Category: Installed Software
        KeyPath: SOFTWARE\Sysinternals\*
        ValueName: EulaAccepted
        Recursive: false
        Comment: "Displays all SysInternals Tools that had the EULA accepted, indicating either execution of the tool or the Registry values were added intentionally prior to execution"

# https://docs.microsoft.com/en-us/sysinternals/
# https://hahndorf.eu/blog/post/2010/03/07/WorkAroundSysinternalsLicensePopups
# https://twitter.com/JohnLaTwC/status/1414207856220463105

    -
        Description: JumplistData
        HiveType: NTUSER
        Category: Program Execution
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Search\JumplistData
        Recursive: false
        Comment: "Displays last execution time of a program"

# JumplistData plugin
# https://twitter.com/sv2hui/status/1005763370186891269?lang=en

    -
        Description: RecentApps
        HiveType: NTUSER
        Category: Program Execution
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Search\RecentApps
        Recursive: true
        Comment: "RecentApps"

# RecentApps plugin

    -
        Description: RunMRU
        HiveType: NTUSER
        Category: Program Execution
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU
        Recursive: false
        Comment: "Tracks commands from the Run box in the Start menu, lower MRU # (Value Data3) = more recent"

# RunMRU plugin
# https://digitalf0rensics.wordpress.com/2014/01/17/windows-registry-and-forensics-part2/
# https://www.andreafortuna.org/2017/10/18/windows-registry-in-forensic-analysis/
# https://silo.tips/download/a-forensic-analysis-of-the-windows-registry
# https://www.forensafe.com/blogs/runmru.html

    -
        Description: AppCompatCache
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet00*\Control\Session Manager\AppCompatCache
        ValueName: AppCompatCache
        Recursive: false
        Comment: "AKA ShimCache, data is only written to this value at reboot by winlogon.exe"

# AppCompat plugin
# https://medium.com/@bromiley/windows-wednesday-shim-cache-1997ba8b13e7
# https://www.youtube.com/watch?v=ZKlyu-HOvxY
# https://www.fireeye.com/blog/threat-research/2015/06/caching_out_the_val.html
# https://www.andreafortuna.org/2017/10/16/amcache-and-shimcache-in-forensic-analysis/
# https://www.sans.org/blog/mass-triage-part-4-processing-returned-files-appcache-shimcache/
# https://countuponsecurity.com/tag/shimcache/
# https://techcommunity.microsoft.com/t5/ask-the-performance-team/demystifying-shims-or-using-the-app-compat-toolkit-to-make-your/ba-p/374947

    -
        Description: AppCompatFlags
        HiveType: NTUSER
        Category: Program Execution
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags
        Recursive: false
        Comment: "Displays programs that are configured to run in Compatibility Mode in Windows"

# AppCompatFlags2 plugin
# https://journeyintoir.blogspot.com/2013/12/revealing-program-compatibility.html

    -
        Description: CIDSizeMRU
        HiveType: NTUSER
        Category: Program Execution
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\CIDSizeMRU
        Recursive: false
        Comment: "Recently ran applications, lower MRU # (Value Data3) = more recent"

# CIDSizeMRU plugin
# https://windowsir.blogspot.com/2013/07/howto-determine-user-access-to-files.html
# https://windowsir.blogspot.com/2013/07/howto-determine-program-execution.html

# Program Execution -> BAM/DAM

    -
        Description: Background Activity Moderator (BAM)
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet*\Services\BAM\State\UserSettings\*
        Recursive: false
        Comment: "Displays the last execution time of a program"

# BamDam plugin
# https://www.andreafortuna.org/2018/05/23/forensic-artifacts-evidences-of-program-execution-on-windows-systems/
# https://www.cellebrite.com/en/analyzing-program-execution-windows-artifacts/
# https://www.linkedin.com/pulse/alternative-prefetch-bam-costas-katsavounidis/

    -
        Description: Background Activity Moderator (BAM)
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet*\Services\BAM\UserSettings\*
        Recursive: false
        Comment: "Displays the last execution time of a program"

# BamDam plugin
# https://www.andreafortuna.org/2018/05/23/forensic-artifacts-evidences-of-program-execution-on-windows-systems/
# https://www.cellebrite.com/en/analyzing-program-execution-windows-artifacts/
# https://www.linkedin.com/pulse/alternative-prefetch-bam-costas-katsavounidis/

    -
        Description: Desktop Activity Moderator (DAM)
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet*\Services\DAM\State\UserSettings\*
        Recursive: false
        Comment: "DAM"

# BamDam plugin
# https://www.cellebrite.com/en/analyzing-program-execution-windows-artifacts/

    -
        Description: Desktop Activity Moderator (DAM)
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet*\Services\DAM\UserSettings\*
        Recursive: false
        Comment: "DAM"

# BamDam plugin
# https://www.cellebrite.com/en/analyzing-program-execution-windows-artifacts/

    -
        Description: Regedit.exe Last Run
        HiveType: NTUSER
        Category: Program Execution
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Applets\Regedit
        Recursive: false
        Comment: "Displays the last key opened with RegEdit"

# https://www.thewindowsclub.com/jump-to-any-registry-key-windows
# https://renenyffenegger.ch/notes/Windows/registry/tree/HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Applets/Regedit/index

    -
        Description: UserAssist
        HiveType: NTUSER
        Category: Program Execution
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist\*\Count
        Recursive: false
        Comment: "GUI-based programs launched from the desktop"

# UserAssist plugin
# https://www.sans.org/security-resources/posters/windows-forensic-analysis/170/download
# https://blog.didierstevens.com/programs/userassist/
# https://www.andreafortuna.org/2018/05/23/forensic-artifacts-evidences-of-program-execution-on-windows-systems/
# https://countuponsecurity.com/tag/userassist/
# https://www.cellebrite.com/en/analyzing-program-execution-windows-artifacts/

    -
        Description: MuiCache (Vista+)
        HiveType: UsrClass
        Category: Program Execution
        KeyPath: Local Settings\Software\Microsoft\Windows\Shell\MuiCache
        Recursive: false
        Comment: "Displays new applications that have been executed within Windows"

# https://www.nirsoft.net/utils/muicache_view.html
# https://windowsir.blogspot.com/2005/12/mystery-of-muicachesolved.html
# https://www.fireeye.com/blog/threat-research/2013/08/execute.html

    -
        Description: MuiCache (2000/XP/2003)
        HiveType: UsrClass
        Category: Program Execution
        KeyPath: Software\Microsoft\Windows\ShellNoRoam\MUICache
        Recursive: false
        Comment: "Displays new applications that have been executed within Windows"

# https://www.nirsoft.net/utils/muicache_view.html
# https://windowsir.blogspot.com/2005/12/mystery-of-muicachesolved.html
# https://www.fireeye.com/blog/threat-research/2013/08/execute.html

# --------------------
# USER ACTIVITY
# --------------------

    -
        Description: Pinned Taskbar Items
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\TaskBand
        ValueName: Favorites
        Recursive: false
        Comment: "Displays pinned Taskbar items"

# TaskBand plugin
# https://tzworks.net/prototype_page.php?proto_id=19

    -
        Description: TypedPaths
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\TypedPaths
        Recursive: false
        Comment: "Displays paths that were typed by the user in Windows Explorer"

# https://www.hecfblog.com/2018/09/daily-blog-483-typed-paths-amnesia.html
# http://windowsir.blogspot.com/2013/07/howto-determine-user-access-to-files.html
# https://www.forensafe.com/blogs/typedpaths.html

    -
        Description: TypedURLs
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Internet Explorer\TypedURLs
        Recursive: false
        Comment: "Internet Explorer/Edge Typed URLs"

# TypedURLs plugin
# https://crucialsecurity.wordpress.com/2011/03/14/typedurls-part-1/
# https://www.andreafortuna.org/2017/10/18/windows-registry-in-forensic-analysis/
# https://tzworks.net/prototype_page.php?proto_id=19
# https://www.forensafe.com/blogs/typedurls.html

    -
        Description: Microsoft Office MRU
        HiveType: NTUSER
        Category: User Activity
        KeyPath: SOFTWARE\Microsoft\Office\*\*\User MRU\*\File MRU
        Recursive: false
        Comment: "Microsoft Office Recent Files, lower Item value (Value Name) = more recent"

# OfficeMRU plugin
# https://www.eshlomo.us/windows-forensics-analysis-evidence/
# https://www.sans.org/security-resources/posters/windows-forensic-analysis/170/download
# https://www.andreafortuna.org/2017/10/18/windows-registry-in-forensic-analysis/
# https://df-stream.com/category/microsoft-office-forensics/

    -
        Description: WordWheelQuery
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\WordWheelQuery
        Recursive: true
        Comment: "User Searches"

# https://www.sans.org/security-resources/posters/windows-forensic-analysis/170/download
# https://tzworks.net/prototype_page.php?proto_id=19
# https://www.forensicfocus.com/forums/general/how-to-check-what-words-have-been-searched-in-computer/

    -
        Description: FirstFolder
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\FirstFolder
        Recursive: true
        Comment: "FirstFolder, tracks the application's first folder that is presented to the user during an Open or Save As operation"

# FirstFolder plugin
# https://research.ijcaonline.org/cognition2015/number4/cog2174.pdf
# https://www.sans.org/blog/opensavemru-and-lastvisitedmru/

    -
        Description: OpenSavePidlMRU
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePidlMRU
        Recursive: false
        Comment: "Tracks files that have been opened or saved within a Windows shell dialog box"

# OpenSavePidlMRU plugin
# https://www.sans.org/blog/opensavemru-and-lastvisitedmru/

    -
        Description: LastVisitedPidlMRU
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU
        Recursive: false
        Comment: "Tracks the specific executable used by an application to open the files documented in OpenSavePidlMRU"

# LastVisitedPidlMRU plugin
# https://www.sans.org/blog/opensavemru-and-lastvisitedmru
# https://digitalf0rensics.wordpress.com/2014/01/17/windows-registry-and-forensics-part2/
# https://www.eshlomo.us/windows-forensics-analysis-evidence/
# https://lifars.com/wp-content/uploads/2020/05/NTUSER-Technical-Guide.pdf
# https://www.forensafe.com/blogs/opensavemru.html

    -
        Description: LastVisitedPidlMRU
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRULegacy
        Recursive: false
        Comment: "Tracks the specific executable used by an application to open the files documented in OpenSavePidlMRU"

# LastVisitedPidlMRU plugin
# https://www.sans.org/blog/opensavemru-and-lastvisitedmru
# https://digitalf0rensics.wordpress.com/2014/01/17/windows-registry-and-forensics-part2/
# https://www.eshlomo.us/windows-forensics-analysis-evidence/
# https://lifars.com/wp-content/uploads/2020/05/NTUSER-Technical-Guide.pdf
# https://www.forensafe.com/blogs/opensavemru.html

    -
        Description: RecentDocs
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs
        Recursive: true
        Comment: "Files recently opened from Windows Explorer"

# RecentDocs plugin
# https://forensic4cast.com/2019/03/the-recentdocs-key-in-windows-10/
# https://www.andreafortuna.org/2017/10/18/windows-registry-in-forensic-analysis/
# https://digitalf0rensics.wordpress.com/2014/01/17/windows-registry-and-forensics-part2/
# https://www.sans.org/security-resources/posters/windows-forensic-analysis/170/download
# https://www.forensafe.com/blogs/recentDocs.html

    -
        Description: Recent File List
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\*\*\Recent File List
        Recursive: false
        Comment: "Displays recent files accessed by the user with an application"

# https://www.forensafe.com/blogs/paintmru.html

    -
        Description: Recent Folder List
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\*\*\Recent Folder List
        Recursive: false
        Comment: ""
    -
        Description: Recent Document List
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\*\*\Settings\Recent Document List
        Recursive: false
        Comment: ""
    -
        Description: Recent
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\*\*\Recent
        Recursive: false
        Comment: ""
    -
        Description: RecentFind
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\*\*\RecentFind
        Recursive: false
        Comment: ""
    -
        Description: Recent File List
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\*\Recent File List
        Recursive: false
        Comment: ""
    -
        Description: User Shell Folders
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders
        Recursive: false
        Comment: "Displays where a user's Shell folders are mapped to"

# User Activity -> FeatureUsage

    -
        Description: FeatureUsage
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage\AppBadgeUpdated
        Recursive: true
        Comment: "Displays the number of times the user has received a notification for an application"

# https://www.group-ib.com/blog/featureusage
# https://www.crowdstrike.com/blog/how-to-employ-featureusage-for-windows-10-taskbar-forensics/

    -
        Description: FeatureUsage
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage\AppLaunch
        Recursive: true
        Comment: "Displays the number of times a pinned application was launched from the taskbar"

# https://www.group-ib.com/blog/featureusage
# https://www.crowdstrike.com/blog/how-to-employ-featureusage-for-windows-10-taskbar-forensics/

    -
        Description: FeatureUsage
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage\AppSwitched
        Recursive: true
        Comment: "Displays the number of times an application switched focus (i.e. minimized, maximized, etc)"

# https://www.group-ib.com/blog/featureusage
# https://www.crowdstrike.com/blog/how-to-employ-featureusage-for-windows-10-taskbar-forensics/

    -
        Description: FeatureUsage
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage\ShowJumpView
        Recursive: true
        Comment: "Displays the number of times an application was right-clicked"

# https://www.group-ib.com/blog/featureusage
# https://www.crowdstrike.com/blog/how-to-employ-featureusage-for-windows-10-taskbar-forensics/

    -
        Description: FeatureUsage
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage\TrayButtonClicked
        ValueName: StartButton
        Recursive: true
        Comment: "Displays the number of times the Start button was clicked"

# https://www.group-ib.com/blog/featureusage
# https://www.crowdstrike.com/blog/how-to-employ-featureusage-for-windows-10-taskbar-forensics/

    -
        Description: FeatureUsage
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage\TrayButtonClicked
        ValueName: ClockButton
        Recursive: true
        Comment: "Displays the number of times the Clock button was clicked"

# https://www.group-ib.com/blog/featureusage
# https://www.crowdstrike.com/blog/how-to-employ-featureusage-for-windows-10-taskbar-forensics/

    -
        Description: FeatureUsage
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage\TrayButtonClicked
        ValueName: MultitaskingButton
        Recursive: true
        Comment: "Displays the number of times the Multitasking button was clicked"

# https://www.group-ib.com/blog/featureusage
# https://www.crowdstrike.com/blog/how-to-employ-featureusage-for-windows-10-taskbar-forensics/

    -
        Description: FeatureUsage
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage\TrayButtonClicked
        ValueName: NotificationCenterButton
        Recursive: true
        Comment: "Displays the number of times the Notification Center button was clicked"

# https://www.group-ib.com/blog/featureusage
# https://www.crowdstrike.com/blog/how-to-employ-featureusage-for-windows-10-taskbar-forensics/

    -
        Description: FeatureUsage
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage\TrayButtonClicked
        ValueName: SearchButton
        Recursive: true
        Comment: "Displays the number of times the Search button was clicked"

# https://www.group-ib.com/blog/featureusage
# https://www.crowdstrike.com/blog/how-to-employ-featureusage-for-windows-10-taskbar-forensics/

    -
        Description: FeatureUsage
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage\TrayButtonClicked
        ValueName: SearchBox
        Recursive: true
        Comment: "Displays the number of times the Search box was clicked"

# https://www.group-ib.com/blog/featureusage
# https://www.crowdstrike.com/blog/how-to-employ-featureusage-for-windows-10-taskbar-forensics/

    -
        Description: FeatureUsage
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage\TrayButtonClicked
        ValueName: ShowDesktopButton
        Recursive: true
        Comment: "Displays the number of times the Show Desktop button was clicked"

# https://www.group-ib.com/blog/featureusage
# https://www.crowdstrike.com/blog/how-to-employ-featureusage-for-windows-10-taskbar-forensics/

# User Activity -> Terminal Server Client (RDP)

    -
        Description: Terminal Server Client (RDP)
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Terminal Server Client
        Recursive: false
        Comment: "Displays the IP addresses/hostnames of devices this system has connected to (Outbound RDP)"

# TerminalServerClient plugin
# Default subkey stores previous RDP connection entries the user has connected to
# UsernameHint value stores the username used on remote machine during RDP session
# https://jpcertcc.github.io/ToolAnalysisResultSheet/details/mstsc.htm
# https://docs.microsoft.com/en-us/troubleshoot/windows-server/remote/remove-entries-from-remote-desktop-connection-computer
# https://www.cyberfox.blog/tag/rdp-mru/
# https://ir3e.com/chapter-14-other-applications/

# --------------------
# AUTORUNS
# --------------------

# https://www.microsoftpressstore.com/articles/article.aspx?p=2762082

    -
        Description: Run (Group Policy)
        HiveType: SOFTWARE
        Category: Autoruns
        KeyPath: Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
        Recursive: false
        Comment: "Group Policy Run Key"
    -
        Description: Run (NTUSER)
        HiveType: NTUSER
        Category: Autoruns
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: "Program execution upon successful user logon"

# https://docs.microsoft.com/en-us/windows/win32/setupapi/run-and-runonce-registry-keys
# https://www.andreafortuna.org/2017/10/18/windows-registry-in-forensic-analysis/

    -
        Description: RunOnce (NTUSER)
        HiveType: NTUSER
        Category: Autoruns
        KeyPath: Software\Microsoft\Windows\CurrentVersion\RunOnce
        Recursive: false
        Comment: "Program execution upon successful user logon"

# https://docs.microsoft.com/en-us/windows/win32/setupapi/run-and-runonce-registry-keys

    -
        Description: Run (SYSTEM)
        HiveType: SOFTWARE
        Category: Autoruns
        KeyPath: Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: "Program execution upon successful user logon"

# https://docs.microsoft.com/en-us/windows/win32/setupapi/run-and-runonce-registry-keys

    -
        Description: RunOnce (SYSTEM)
        HiveType: SOFTWARE
        Category: Autoruns
        KeyPath: Microsoft\Windows\CurrentVersion\RunOnce
        Recursive: false
        Comment: "Program execution upon successful user logon"

# https://docs.microsoft.com/en-us/windows/win32/setupapi/run-and-runonce-registry-keys

# Autoruns -> Startup Programs (SOFTWARE\NTUSER)

    -
        Description: Startup Programs
        HiveType: NTUSER
        Category: Autoruns
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run
        IncludeBinary: true
        Recursive: true
        Comment: "Displays list of programs that start up upon system boot"
    -
        Description: Startup Programs
        HiveType: NTUSER
        Category: Autoruns
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run32
        IncludeBinary: true
        Recursive: true
        Comment: "Displays list of programs that start up upon system boot"
    -
        Description: Startup Programs
        HiveType: NTUSER
        Category: Autoruns
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\StartupFolder
        IncludeBinary: true
        Recursive: true
        Comment: "Displays list of programs that start up upon system boot"
    -
        Description: Startup Programs
        HiveType: SOFTWARE
        Category: Autoruns
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run
        IncludeBinary: true
        Recursive: true
        Comment: "Displays list of programs that start up upon system boot"
    -
        Description: Startup Programs
        HiveType: SOFTWARE
        Category: Autoruns
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\Run32
        IncludeBinary: true
        Recursive: true
        Comment: "Displays list of programs that start up upon system boot"
    -
        Description: Startup Programs
        HiveType: SOFTWARE
        Category: Autoruns
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\StartupFolder
        IncludeBinary: true
        Recursive: true
        Comment: "Displays list of programs that start up upon system boot"

# https://www.hexacorn.com/blog/2019/02/23/beyond-good-ol-run-key-part-104/

    -
        Description: Scheduled Tasks (TaskCache)
        HiveType: Software
        Category: Autoruns
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        Recursive: false
        Comment: "Displays Scheduled Tasks and their last start/stop time"

# TaskCache plugin
# https://digital-forensics.sans.org/media/DFPS_FOR508_v4.4_1-19.pdf
# https://www.jaiminton.com/cheatsheet/DFIR/#t1060-registry-run-keys--startup-folder
# https://jpcertcc.github.io/ToolAnalysisResultSheet/details/schtasks.htm
# https://dfirtnt.wordpress.com/registry-persistence-paths/
# https://www.forensafe.com/blogs/taskscheduler.html

# --------------------
# THIRD PARTY APPLICATIONS
# --------------------

# Do not include anything in NTUSER or SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall as that is covered already by Installed Software entries
# Sometimes, there are values for third party applications not covered under the standard DisplayVersion, Publisher, InstallLocation, InstallDate, and DisplayName entries. I've seen Inno Setup: User, Inno Setup: Language, and Inno Setup: App Path
# For this section, please include a subheader and a URL, even if its only one entry per program

# Third Party Applications -> VNC Viewer - https://www.realvnc.com/en/connect/download/viewer/

    -
        Description: VNC Viewer
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\RealVNC\vncviewer
        Recursive: true
        Comment: "Displays artifactrs relating to VNC Viewer"

# Third Party Applications -> QNAP QFinder - https://www.qnap.com/en-us/utilities/essentials

    -
        Description: QNAP QFinder
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: SOFTWARE\QNAP\Qfinder\WOL\*
        ValueName: SvrName
        Recursive: false
        Comment: "Displays the name of the QNAP as it was assigned by the user"
    -
        Description: QNAP QFinder
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: SOFTWARE\QNAP\Qfinder\WOL\*
        ValueName: SvrIPAddr
        Recursive: false
        Comment: "Displays the IP Address of the QNAP as it was assigned by the user"
    -
        Description: QNAP QFinder
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: SOFTWARE\QNAP\Qfinder\WOL\*
        ValueName: SvrVersion
        Recursive: false
        Comment: "Displays the current firmware version of the QNAP"
    -
        Description: QNAP QFinder
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: SOFTWARE\QNAP\Qfinder\WOL\*
        ValueName: SvrType
        Recursive: false
        Comment: "Displays the type of the QNAP device"
    -
        Description: QNAP QFinder
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: SOFTWARE\QNAP\Qfinder\WOL\*
        ValueName: SvrModel
        Recursive: false
        Comment: "Displays the model of the QNAP device"
    -
        Description: QNAP QFinder
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: SOFTWARE\QNAP\Qfinder
        ValueName: InstallDate
        Recursive: false
        Comment: "Displays the install date of QNAP QFinder"

# Third Party Applications -> Total Commander - https://www.ghisler.com/

    -
        Description: Total Commander
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: Ghisler\Total Commander
        Recursive: false
        Comment: "Total Commander Registry artifacts"
    -
        Description: Total Commander
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: WOW6432Node\Ghisler\Total Commander
        Recursive: false
        Comment: "Total Commander Registry artifacts"

# Third Party Applications -> TeamViewer - https://www.teamviewer.com/en-us/

    -
        Description: TeamViewer
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\TeamViewer
        ValueName: Meeting_UserName
        Recursive: false
        Comment: "Windows username of logged in user"
    -
        Description: TeamViewer
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\TeamViewer
        ValueName: BuddyLoginName
        Recursive: false
        Comment: "User's email associated with TeamViewer"
    -
        Description: TeamViewer
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\TeamViewer
        ValueName: BuddyDisplayName
        Recursive: false
        Comment: "User specified TeamViewer display name"
    -
        Description: TeamViewer
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: WOW6432Node\TeamViewer
        ValueName: OwningManagerAccountName
        Recursive: false
        Comment: "Displays the name of the user logged into TeamViewer"
    -
        Description: TeamViewer
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: WOW6432Node\TeamViewer
        ValueName: PermanentPasswordDate
        Recursive: false
        Comment: "Displays the date the password was last set for the user within TeamViewer"

# Third Party Applications -> Adobe - https://www.adobe.com/

    -
        Description: Adobe cRecentFiles
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\Adobe
        Recursive: false
        Comment: "Displays files which were opened Adobe Reader by the user"

# Adobe plugin
# https://www.forensafe.com/blogs/adobeacrobatreader.html

    -
        Description: Adobe cRecentFolders
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\Adobe\Acrobat Reader\DC\AVGeneral\cRecentFolders\*
        ValueName: tDIText
        Recursive: false
        Comment: "Displays folders where Adobe Reader opened a PDF file from"

# Third Party Applications -> Visual Studio - https://visualstudio.microsoft.com/

    -
        Description: VisualStudio FileMRUList
        HiveType: NtUser
        Category: User Activity
        KeyPath: Software\Microsoft\VisualStudio\*\FileMRUList
        Recursive: false
        Comment: ""
    -
        Description: VisualStudio MRUItems
        HiveType: NtUser
        Category: User Activity
        KeyPath: Software\Microsoft\VisualStudio\*\MRUItems\*\Items
        Recursive: false
        Comment: ""
    -
        Description: VisualStudio MRUSettings
        HiveType: NtUser
        Category: User Activity
        KeyPath: Software\Microsoft\VisualStudio\*\NewProjectDialog\MRUSettingsLocalProjectLocationEntries
        Recursive: false
        Comment: ""

# Third Party Applications -> 7-Zip - https://www.7-zip.org/

    -
        Description: 7-Zip
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\7-Zip\Compression
        ValueName: ArcHistory
        Recursive: false
        Comment: "Displays list of files and folders that were used with 7-Zip"

# SevenZip plugin

# Third Party Applications -> WinRAR - https://www.rarlab.com/

    -
        Description: WinRAR
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\WinRAR
        Recursive: false
        Comment: "Displays history of archives that were used with WinRAR"

# WinRAR plugin

# Third Party Applications -> Eraser - https://eraser.heidi.ie/

    -
        Description: Eraser
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\Eraser
        Recursive: true
        Comment: "Potential evidence of anti-forensics"

# Third Party Applications -> LogMeIn - https://www.logmein.com/home2/v4

    -
        Description: LogMeIn
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\LogMeIn
        Recursive: true
        Comment: "LogMeIn GoToMeeting"

# Third Party Applications -> Macrium Reflect - https://www.macrium.com/

    -
        Description: Macrium Reflect
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\Macrium\Reflect\Recent Folders\Image\*
        Recursive: false
        Comment: "Macrium Reflect image storage directory"
    -
        Description: Macrium Reflect
        HiveType: SYSTEM
        Category: Third Party Applications
        KeyPath: ControlSet*\Control\BackupRestore\FilesNotToSnapshotMacriumImage
        Recursive: true
        Comment: "Displays files that are not to be included in Macrium Reflect images"
    -
        Description: Macrium Reflect
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: Macrium
        ValueName: LastRun
        Recursive: true
        Comment: "Command last ran by user"
    -
        Description: Macrium Reflect
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: Macrium
        ValueName: Licensee
        Recursive: true
        Comment: "registered user"
    -
        Description: Macrium Reflect
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: Macrium\Reflect\CBT\Sequence
        IncludeBinary: true
        BinaryConvert: FILETIME
        Recursive: true
        Comment: "Displays timestamps related to Macrium Reflect's CBT feature"

# https://knowledgebase.macrium.com/display/KNOW72/Macrium+Changed+Block+Tracker
# https://forum.macrium.com/PrintTopic35786.aspx

    -
        Description: Macrium Reflect
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: Macrium\Reflect\Defaults
        Recursive: true
        Comment: "Displays default settings associated with Macrium Reflect on this computer"
    -
        Description: Macrium Reflect
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: Macrium\Reflect\ImageGuardian
        Recursive: false
        Comment: "Displays Macrium Image Guardian status"
    -
        Description: Macrium Reflect
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: Macrium\Reflect\Security
        ValueName: SID
        Recursive: true
        Comment: "Displays SID associated with Macrium Reflect on this computer"
    -
        Description: Macrium Reflect
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: Macrium\Reflect\Security
        ValueName: App Path
        Recursive: true
        Comment: "Displays the application path associated with Macrium Reflect on this computer"
    -
        Description: Macrium Reflect
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: Macrium\Reflect\MIG\Verified
        Recursive: true
        Comment: "Macrium Image Guardian Status, 1 = protected"
    -
        Description: Macrium Reflect
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: Macrium\Reflect\VSS
        Recursive: true
        Comment: "Displays settings related to Macrium Reflect's interaction with VSS"

# Third Party Applications -> WinSCP - https://winscp.net/eng/index.php

    -
        Description: WinSCP
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\Martin Prikryl
        Recursive: true
        Comment: "WinSCP"
    -
        Description: WinSCP
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: WOW6432Node\Martin Prikryl
        Recursive: true
        Comment: "WinSCP"

# Third Party Applications -> Ares - https://www.ares.net/

    -
        Description: Ares
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: Ares
        Recursive: true
        Comment: "Displays information relating to Ares"

# Ares plugin

# Third Party Applications -> Soulseek - https://www.slsknet.org/news/

    -
        Description: Soulseek
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\{8A4E1646-488C-4E5B-AC31-F784400E8D2D}_is1
        ValueName: "Inno Setup: User"
        Recursive: true
        Comment: "Displays the name of the user who installed Soulseek"
    -
        Description: Soulseek
        HiveType: SOFTWARE
        Category: Third Party Applications
        KeyPath: WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\{8A4E1646-488C-4E5B-AC31-F784400E8D2D}_is1
        ValueName: "Inno Setup: Language"
        Recursive: true
        Comment: "Displays the language for which Soulseek was installed"

# Third Party Applications -> Signal - https://signal.org/en/

    -
        Description: Signal
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\7d96caee-06e6-597c-9f2f-c7bb2e0948b4
        ValueName: InstallLocation
        Recursive: true
        Comment: "Displays the location where Signal is installed on the user's computer"

# Third Party Applications -> Stardock Fences - https://www.stardock.com/products/fences/

    -
        Description: Stardock Fences
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\Stardock\Fences\InitialSnapshot
        Recursive: true
        Comment: "Displays a list of links the user had on their desktop at the time of installation"
    -
        Description: Stardock Fences
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\Stardock\Fences\Icons
        Recursive: true
        Comment: "Displays a list of icons on the user's desktop"
    -
        Description: Stardock Fences
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\Stardock\Fences\Settings
        ValueName: ResolutionLast
        Recursive: true
        Comment: "Displays a list of connected monitors to the user's computer"
    -
        Description: Stardock Fences
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: Software\Stardock\Fences\Settings
        ValueName: PrimaryMonitorLast
        Recursive: true
        Comment: "Displays the user's primary monitor"

# Third Party Applications -> 4K Video Downloader - https://www.4kdownload.com/products/videodownloader/1

    -
        Description: 4K Video Downloader
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: SOFTWARE\4kdownload.com\4K Video Downloader\Notification
        ValueName: runCount
        Recursive: false
        Comment: "Displays the run count for 4K Video Downloader"
    -
        Description: 4K Video Downloader
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: SOFTWARE\4kdownload.com\4K Video Downloader\Notification
        ValueName: lastVersion
        Recursive: false
        Comment: "Displays the last version of 4K Video Downloader installed on this system"
    -
        Description: 4K Video Downloader
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: SOFTWARE\4kdownload.com\4K Video Downloader\Limits
        ValueName: dayDownloadDate
        IncludeBinary: true
        BinaryConvert: EPOCH
        Recursive: false
        Comment: "Displays the date that 4K Video Downloader was installed"
    -
        Description: 4K Video Downloader
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: SOFTWARE\4kdownload.com\4K Video Downloader\Limits
        ValueName: dayDownloadCount
        Recursive: false
        Comment: "Displays the amount of times 4K Video Downloaded was downloaded"
    -
        Description: 4K Video Downloader
        HiveType: NTUSER
        Category: Third Party Applications
        KeyPath: SOFTWARE\4kdownload.com\4K Video Downloader\Download
        ValueName: downloadedItemsDb
        Recursive: false
        Comment: "Displays the location of the SQLite database associated with 4K Video Downloader"

# --------------------
# CLOUD STORAGE
# --------------------

# Cloud Storage -> OneDrive

    -
        Description: OneDrive
        HiveType: NTUSER
        Category: Cloud Storage
        KeyPath: Software\Microsoft\Office\*\Common\Internet\Server*\http*\*
        Recursive: false
        Comment: "Displays folders present within a user's OneDrive"
    -
        Description: OneDrive
        HiveType: NTUSER
        Category: Cloud Storage
        KeyPath: Environment
        ValueName: OneDriveConsumer
        Recursive: false
        Comment: "Displays the user's (check HivePath) specified storage location for OneDrive"
    -
        Description: OneDrive
        HiveType: SOFTWARE
        Category: Cloud Storage
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\SyncRootManager\OneDrive*\UserSyncRoots
        Recursive: true
        Comment: "Displays the user's specified storage location for OneDrive"
    -
        Description: OneDrive
        HiveType: NTUSER
        Category: Cloud Storage
        KeyPath: Software\SyncEngines\Providers\OneDrive\*\
        ValueName: LastModifiedTime
        Recursive: true
        Comment: "Displays the Last Modified time for the OneDrive Registry key"
    -
        Description: OneDrive
        HiveType: NTUSER
        Category: Cloud Storage
        KeyPath: Software\SyncEngines\Providers\OneDrive\*\
        ValueName: MountPoint
        Recursive: true
        Comment: "Displays where the OneDrive folder is mounted"
    -
        Description: OneDrive
        HiveType: NTUSER
        Category: Cloud Storage
        KeyPath: Software\SyncEngines\Providers\OneDrive\*\
        ValueName: UrlNamespace
        Recursive: true
        Comment: "Displays the URL Namespace for OneDrive"
    -
        Description: OneDrive
        HiveType: NTUSER
        Category: Cloud Storage
        KeyPath: Software\SyncEngines\Providers\OneDrive\*\
        ValueName: IsOfficeSyncIntegrationEnabled
        Recursive: true
        Comment: "Office Sync Integration, 0 = Disabled, 1 = Enabled"
    -
        Description: OneDrive
        HiveType: NTUSER
        Category: Cloud Storage
        KeyPath: Software\SyncEngines\Providers\OneDrive\*\
        ValueName: LibraryType
        Recursive: true
        Comment: ""
    -
        Description: OneDrive
        HiveType: NTUSER
        Category: Cloud Storage
        KeyPath: Software\Microsoft\OneDrive\*\
        ValueName: InstallPath
        Recursive: true
        Comment: "Displays the installation path from the user's AppData folder for OneDrive"
    -
        Description: OneDrive
        HiveType: NTUSER
        Category: Cloud Storage
        KeyPath: Software\Microsoft\OneDrive\Accounts
        ValueName: LastUpdate
        IncludeBinary: true
        BinaryConvert: EPOCH
        Recursive: true
        Comment: "Displays the last update time of the Accounts OneDrive Registry key"

# Cloud Storage -> Dropbox

    -
        Description: Dropbox
        HiveType: SOFTWARE
        Category: Cloud Storage
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\SyncRootManager\Dropbox*\UserSyncRoots
        Recursive: true
        Comment: "Displays the user's specified storage location for Dropbox"

# --------------------
# SERVICES
# --------------------

    -
        Description: Services
        HiveType: SYSTEM
        Category: Services
        KeyPath: ControlSet*\Services
        Recursive: false
        Comment: "Displays list of services running on this computer"

# Services plugin
# https://www.forensafe.com/blogs/windowsservices.html

# --------------------
# EVENT LOGS
# --------------------

    -
        Description: Event Logs Logging Status
        HiveType: SOFTWARE
        Category: Event Logs
        KeyPath: Microsoft\Windows\CurrentVersion\WINEVT\Channels
        ValueName: Enabled
        Recursive: true
        Comment: "Displays the status of Windows Event Log Channels (Key Path) on this system, 0 = Disabled, 1 - Enabled"

# https://www.ibm.com/mysupport/s/question/0D50z000062kolQ/how-to-monitor-custom-event-log?language=en_US
# SYSTEM\\ControlSet00*\Services\EventLog\* will display the Provider GUID for each Event Log channel listed here. This recursive key is not enabled here

# --------------------
# MICROSOFT OFFICE/OFFICE 365
# --------------------

#    -
#        Description: Microsoft Office
#        HiveType: NTUSER
#        Category: Microsoft Office
#        KeyPath: Software\Microsoft\Office
#        Recursive: true
#        Comment: "Microsoft Office Registry artifacts"
#
# Uncomment this if you want ALL Registry artifacts for Microsoft Office. Be sure to comment out the below values since you won't need them anymore. On my system, recursive on the entire MS Office key returned 16,000+ lines.

    -
        Description: Microsoft Office
        HiveType: NTUSER
        Category: Microsoft Office
        KeyPath: Software\Microsoft\Office\*\Common\Identity\Identities\*
        ValueName: EmailAddresses
        Recursive: false
        Comment: "Lists email addresses registered to Microsoft Office on the user's system"
    -
        Description: Microsoft Office
        HiveType: NTUSER
        Category: Microsoft Office
        KeyPath: Software\Microsoft\Office\*\Common\Identity\Identities\*
        ValueName: EmailAddress
        Recursive: false
        Comment: "Lists email address registered to Microsoft Office on the user's system"
    -
        Description: Microsoft Office
        HiveType: NTUSER
        Category: Microsoft Office
        KeyPath: Software\Microsoft\Office\*\Common\Identity\Identities\*
        ValueName: FirstName
        Recursive: false
        Comment: "Lists first name for the registered Microsoft Office user"
    -
        Description: Microsoft Office
        HiveType: NTUSER
        Category: Microsoft Office
        KeyPath: Software\Microsoft\Office\*\Common\Identity\Identities\*
        ValueName: LastName
        Recursive: false
        Comment: "Lists last name for the registered Microsoft Office user"
    -
        Description: Microsoft Office
        HiveType: NTUSER
        Category: Microsoft Office
        KeyPath: Software\Microsoft\Office\*\Common\Identity\Identities\*
        ValueName: FriendlyName
        Recursive: false
        Comment: "Lists full name for the registered Microsoft Office user"
    -
        Description: Microsoft Office
        HiveType: NTUSER
        Category: Microsoft Office
        KeyPath: Software\Microsoft\Office\*\Common\Identity\Identities\*
        ValueName: Initials
        Recursive: false
        Comment: "Lists initials for the registered Microsoft Office user"
    -
        Description: Microsoft Office
        HiveType: NTUSER
        Category: Microsoft Office
        KeyPath: Software\Microsoft\Office\*\Common\Identity\Identities\*\AuthHistory
        Recursive: true
        IncludeBinary: true
        BinaryConvert: FILETIME
        Comment: "Displays time user was authenticated to the system's instance of Microsoft 365 for the first time"
    -
        Description: Microsoft Office
        HiveType: NTUSER
        Category: Microsoft Office
        KeyPath: Software\Microsoft\Office\*\Common\Identity\Profiles\*
        Recursive: true
        Comment: "Displays time user was authenticated to the system's instance of Microsoft 365 for the first time"
    -
        Description: Microsoft Office Trusted Documents
        HiveType: NTUSER
        Category: Microsoft Office
        KeyPath: Software\Microsoft\Office\*\*\Security\Trusted Documents\TrustRecords
        Recursive: true
        Comment: "Displays list of Office documents where the user may have clicked Enable Editing, Enable Macro, or Enable Content"

# TrustedDocuments plugin

# --------------------
# MICROSOFT EXCHANGE
# --------------------

# Microsoft Exchange -> Microsoft Exchange Patch Status

    -
        Description: Microsoft Exchange Patch Status
        HiveType: SOFTWARE
        Category: Microsoft Exchange
        KeyPath: Microsoft\Updates\Exchange*\KB*
        Recursive: false
        ValueName: InstalledDate
        Comment: "Displays the date the patch was installed on this host"
    -
        Description: Microsoft Exchange Patch Status
        HiveType: SOFTWARE
        Category: Microsoft Exchange
        KeyPath: Microsoft\Updates\Exchange*\KB*
        Recursive: false
        ValueName: PackageName
        Comment: "Displays the name of the patch installed on this host"
    -
        Description: Microsoft Exchange Patch Status
        HiveType: SOFTWARE
        Category: Microsoft Exchange
        KeyPath: Microsoft\Updates\Exchange*\SP*\KB*
        Recursive: false
        ValueName: InstalledDate
        Comment: "Displays the date the patch was installed on this host"
    -
        Description: Microsoft Exchange Patch Status
        HiveType: SOFTWARE
        Category: Microsoft Exchange
        KeyPath: Microsoft\Updates\Exchange*\SP*\KB*
        Recursive: false
        ValueName: PackageName
        Comment: "Displays the name of the patch installed on this host"

# https://support.microsoft.com/en-us/topic/description-of-the-security-update-for-microsoft-exchange-server-2019-2016-and-2013-march-2-2021-kb5000871-9800a6bb-0a21-4ee7-b9da-fa85b3e1d23b

# --------------------
# WEB BROWSERS
# --------------------

    -
        Description: Google Chrome
        HiveType: NTUSER
        Category: Web Browsers
        KeyPath: Software\Google\Chrome
        Recursive: true
        Comment: "Google Chrome Registry artifacts"
    -
        Description: Internet Explorer
        HiveType: NTUSER
        Category: Web Browsers
        KeyPath: Software\Microsoft\Internet Explorer\Main
        IncludeBinary: true
        Recursive: false
        Comment: "Internet Explorer Registry artifacts"
    -
        Description: Internet Explorer
        HiveType: NTUSER
        Category: Web Browsers
        KeyPath: Software\Microsoft\Internet Explorer
        ValueName: Download Directory
        Recursive: false
        Comment: "Internet Explorer Registry artifacts"
    -
        Description: Internet Explorer
        HiveType: NTUSER
        Category: Web Browsers
        KeyPath: Software\Microsoft\Internet Explorer\NewWindows
        Recursive: false
        Comment: "Internet Explorer Registry artifacts"
    -
        Description: Internet Explorer
        HiveType: NTUSER
        Category: Web Browsers
        KeyPath: Software\Microsoft\Internet Explorer\Suggested Sites\*
        IncludeBinary: true
        Recursive: false
        Comment: "Internet Explorer Registry artifacts"
    -
        Description: Internet Explorer
        HiveType: NTUSER
        Category: Web Browsers
        KeyPath: Software\Microsoft\Internet Explorer\ProtocolExecute\*
        Recursive: false
        Comment: "Internet Explorer Registry artifacts"
    -
        Description: Internet Explorer
        HiveType: NTUSER
        Category: Web Browsers
        KeyPath: Software\Microsoft\Internet Explorer\LowRegistry\IEShims
        Recursive: true
        Comment: "Internet Explorer Registry artifacts"
    -
        Description: Internet Explorer
        HiveType: NTUSER
        Category: Web Browsers
        KeyPath: Software\Microsoft\Internet Explorer\Main\WindowsSearch
        Recursive: true
        Comment: "Internet Explorer Registry artifacts"
    -
        Description: Internet Explorer
        HiveType: NTUSER
        Category: Web Browsers
        KeyPath: Software\Microsoft\Internet Explorer\Main\WindowsSearch
        IncludeBinary: true
        Recursive: false
        Comment: "Internet Explorer Registry artifacts"
    -
        Description: Microsoft Edge
        HiveType: NTUSER
        Category: Web Browsers
        KeyPath: Software\Microsoft\Edge
        Recursive: true
        Comment: "Microsoft Edge Registry artifacts"
    -
        Description: CCleaner Browser
        HiveType: SOFTWARE
        Category: Web Browsers
        KeyPath: WOW6432Node\Piriform\Browser
        IncludeBinary: true
        Recursive: true
        Comment: "CCleaner Browser Registry artifacts"

# --------------------
# INSTALLED SOFTWARE
# --------------------

    -
        Description: App Paths
        HiveType: SOFTWARE
        Category: Installed Software
        KeyPath: Microsoft\Windows\CurrentVersion\App Paths
        Recursive: false
        Comment: "Displays list of installed software and the associated application paths"

# AppPaths plugin

    -
        Description: File Extensions
        HiveType: NTUSER
        Category: Installed Software
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts
        Recursive: false
        Comment: "Tracks programs associated with file extensions"

# FileExts plugin
# https://www.marshall.edu/forensics/files/Brewer-PosterFinal.pdf
# https://digital-forensics.sans.org/summit-archives/2012/taking-registry-analysis-to-the-next-level.pdf

# Installed Software -> Add/Remove Program Entries
    -
        Description: Add/Remove Programs Entries
        HiveType: SOFTWARE
        Category: Installed Software
        KeyPath: Microsoft\Windows\CurrentVersion\Uninstall
        Recursive: false
        Comment: "Displays installed software"

# Uninstall plugin
# https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/find-installed-software

    -
        Description: Add/Remove Programs Entries
        HiveType: SOFTWARE
        Category: Installed Software
        KeyPath: WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall
        Recursive: false
        Comment: "Displays installed software"

# Uninstall plugin
# https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/find-installed-software

    -
        Description: Add/Remove Programs Entries
        HiveType: NTUSER
        Category: Installed Software
        KeyPath: SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall
        Recursive: false
        Comment: "Displays installed software"

# Uninstall plugin
# https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/find-installed-software
# https://www.advancedinstaller.com/user-guide/registry-wow6432-node.html
# https://docs.microsoft.com/en-us/windows/win32/sysinfo/32-bit-and-64-bit-application-data-in-the-registry

    -
        Description: Products
        HiveType: SOFTWARE
        Category: Installed Software
        KeyPath: Microsoft\Windows\CurrentVersion\Installer\UserData\*\Products
        Recursive: false
        Comment: "Displays all installed software packages"

# Products plugin
# https://www.nirsoft.net/utils/installed_packages_view.html

# --------------------
# VOLUME SHADOW COPIES
# --------------------

# https://docs.microsoft.com/en-us/windows/win32/vss/volume-shadow-copy-service-portal

    -
        Description: VSS
        HiveType: SYSTEM
        Category: Volume Shadow Copies
        KeyPath: ControlSet*\Control\BackupRestore\FilesNotToSnapshot
        Recursive: true
        Comment: "Displays files to be deleted from newly created shadow copies"

# https://medium.com/@bromiley/windows-wednesday-volume-shadow-copies-d20b60997c22#.11p1cb258
# https://docs.microsoft.com/en-us/windows/win32/backup/registry-keys-for-backup-and-restore#filesnottosnapshot

    -
        Description: VSS
        HiveType: SYSTEM
        Category: Volume Shadow Copies
        KeyPath: ControlSet*\Control\BackupRestore\FilesNotToSnapshotSave
        Recursive: true
        Comment: "Displays files to be deleted from newly created shadow copies"

# https://medium.com/@bromiley/windows-wednesday-volume-shadow-copies-d20b60997c22#.11p1cb258
# https://docs.microsoft.com/en-us/windows/win32/backup/registry-keys-for-backup-and-restore

    -
        Description: VSS
        HiveType: SYSTEM
        Category: Volume Shadow Copies
        KeyPath: ControlSet*\Control\BackupRestore\KeysNotToRestore
        Recursive: true
        Comment: "Displays the names of the Registry subkeys and values that backup applications should not restore"

# https://medium.com/@bromiley/windows-wednesday-volume-shadow-copies-d20b60997c22#.11p1cb258
# https://docs.microsoft.com/en-us/windows/win32/backup/registry-keys-for-backup-and-restore#keysnottorestore

    -
        Description: VSS
        HiveType: SYSTEM
        Category: Volume Shadow Copies
        KeyPath: ControlSet*\Control\BackupRestore\FilesNotToBackup
        Recursive: true
        Comment: "Displays the names of the files and directories that backup applications should not backup or restore"

# https://medium.com/@bromiley/windows-wednesday-volume-shadow-copies-d20b60997c22#.11p1cb258
# https://docs.microsoft.com/en-us/windows/win32/backup/registry-keys-for-backup-and-restore#filesnottobackup

# --------------------
# THREAT HUNTING
# --------------------

    -
        Description: Shadow RDP Sessions
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Policies\Microsoft\Windows NT\Terminal Services
        ValueName: Shadow
        Recursive: true
        Comment: "Shadow RDP sessions, 0 = Disabled, 1 = Full Control with user's permission, 2 = Full Control without user's permission, 3 = View Session with user's permission, 4 = View Session without user's permission"

# https://twitter.com/inversecos/status/1380006149479559170
# https://bitsadm.in/blog/spying-on-users-using-rdp-shadowing

    -
        Description: RDP Connections Status
        HiveType: SYSTEM
        Category: Threat Hunting
        KeyPath: ControlSet*\Control\Terminal Server
        ValueName: fDenyTSConnections
        Recursive: true
        Comment: "Displays the status of whether the system can accept Terminal Server (RDP) connections, 0 = Disabled (Inbound RDP enabled), 1 = Enabled (Inbound RDP disabled)"

# https://docs.microsoft.com/en-us/windows-hardware/customize/desktop/unattend/microsoft-windows-terminalservices-localsessionmanager-fdenytsconnections

    -
        Description: RDP User Authentication Status
        HiveType: SYSTEM
        Category: Threat Hunting
        KeyPath: ControlSet*\Control\Terminal Server\WinStations\RDP-Tcp
        ValueName: UserAuthentication
        Recursive: true
        Comment: "Displays whether a Network-Level user authentication is required before a remote desktop connection is established. 0 = Disabled (no authentication required), 1 = Enabled (authentication required)"

# https://docs.microsoft.com/en-us/windows-hardware/customize/desktop/unattend/microsoft-windows-terminalservices-rdp-winstationextensions-userauthentication

    -
        Description: Windows Defender Status
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Policies\Microsoft\Windows Defender
        ValueName: DisableAntiSpyware
        Recursive: true
        Comment: "Displays the status of whether Windows Defender AntiSpyware is enabled or not. 0 = Enabled, 1 = Disabled"

# https://docs.microsoft.com/en-us/windows-hardware/customize/desktop/unattend/security-malware-windows-defender-disableantispyware
# https://answers.microsoft.com/en-us/protect/forum/all/how-to-kill-antimalware-service-executable/b5ce5b46-a65b-460c-b4cd-e2cca50358cf
# https://gist.github.com/MHaggis/a955f1351a7d07592b90ab605e3b02d9

    -
        Description: Windows Defender Status
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Policies\Microsoft\Windows Defender
        ValueName: DisableAntiVirus
        Recursive: true
        Comment: "Displays the status of whether Windows Defender AntiVirus is enabled or not. 0 = Enabled, 1 = Disabled"

# https://docs.microsoft.com/en-us/windows-hardware/customize/desktop/unattend/security-malware-windows-defender-disableantispyware
# https://answers.microsoft.com/en-us/protect/forum/all/how-to-kill-antimalware-service-executable/b5ce5b46-a65b-460c-b4cd-e2cca50358cf
# https://gist.github.com/MHaggis/a955f1351a7d07592b90ab605e3b02d9

    -
        Description: Windows Defender
        HiveType: SOFTWARE
        Category: Antivirus
        KeyPath: Microsoft\Windows Defender\SpyNet
        ValueName: DisableBlockAtFirstSeen
        Recursive: false
        Comment: "Windows Defender DisableBlockAtFirstSeen Status, 0 = Disabled, 1 = Enabled"

# https://gist.github.com/MHaggis/a955f1351a7d07592b90ab605e3b02d9

    -
        Description: Windows Defender
        HiveType: SOFTWARE
        Category: Antivirus
        KeyPath: Microsoft\Windows Defender\SpyNet
        ValueName: SpynetReporting
        Recursive: false
        Comment: "Windows Defender SpynetReporting Status, 0 = Disabled, 1 = Enabled"

# https://gist.github.com/MHaggis/a955f1351a7d07592b90ab605e3b02d9

    -
        Description: Windows Defender
        HiveType: SOFTWARE
        Category: Antivirus
        KeyPath: Microsoft\Windows Defender\SpyNet
        ValueName: SubmitSamplesConsent
        Recursive: false
        Comment: "Windows Defender SubmitSamplesConsent Status, 0 = Disabled, 1 = Enabled"

# https://gist.github.com/MHaggis/a955f1351a7d07592b90ab605e3b02d9

    -
        Description: PortProxy Configuration
        HiveType: SYSTEM
        Category: Threat Hunting
        KeyPath: ControlSet*\Services\PortProxy\v4tov4\tcp
        Recursive: true
        Comment: "Displays current port proxy configuration"

# https://www.fireeye.com/blog/threat-research/2019/01/bypassing-network-restrictions-through-rdp-tunneling.html
# https://adepts.of0x.cc/netsh-portproxy-code/
# https://www.dfirnotes.net/portproxy_detection/

    -
        Description: Exefile Shell Open Command
        HiveType: Software
        Category: Threat Hunting
        KeyPath: Classes\Exefile\Shell\Open\Command
        ValueName: (default)
        Recursive: false
        Comment: Exefile hijack shows e.g. path to a binary

    -
        Description: Exefile Shell Open Command
        HiveType: usrclass
        Category: Threat Hunting
        KeyPath: Exefile\Shell\Open\Command
        ValueName: (default)
        Recursive: false
        Comment: Exefile hijack shows e.g. path to a binary

# https://twitter.com/swisscom_csirt/status/1461686311769759745
# https://attack.mitre.org/techniques/T1546/001/

# Threat Hunting -> Hades - Located within a PowerShell script associated with this group

    -
        Description: Hades IOCs
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Policies\Microsoft\Windows\System
        ValueName: UseAdvancedStartup
        Recursive: false
        Comment: "0 = Disabled, 1 = Enabled"
    -
        Description: Hades IOCs
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Policies\Microsoft\Windows\System
        ValueName: EnableBDEWithNoTPM
        Recursive: false
        Comment: "1 = Default, 0 = Disabled, 1 = Enabled"
    -
        Description: Hades IOCs
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Policies\Microsoft\Windows\System
        ValueName: UseTPM
        Recursive: false
        Comment: "0 = Do Not Allow TPM, 1 = Require TPM, 2 = Allow TPM"
    -
        Description: Hades IOCs
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Policies\Microsoft\Windows\System
        ValueName: UseTPMKey
        Recursive: false
        Comment: "0 = Do not allow startup key with TPM, 1 = Require startup key with TPM, 2 = Allow startup key with TPM"
    -
        Description: Hades IOCs
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Policies\Microsoft\Windows\System
        ValueName: UseTPMKeyPIN
        Recursive: false
        Comment: "0 = Do not allow startup key and PIN with TPM, 1 = Require startup key and PIN with TPM, 2 = Allow startup key and PIN with TPM"
    -
        Description: Hades IOCs
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Policies\Microsoft\Windows\System
        ValueName: RecoveryKeyMessage
        Recursive: false
        Comment: "Displays the Recovery Key message set by the Threat Actor group"
    -
        Description: Hades IOCs
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Policies\Microsoft\Windows\System
        ValueName: RecoveryKeyMessageSource
        Recursive: false
        Comment: "2 is set by the Hades group"
    -
        Description: Hades IOCs
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Policies\Microsoft\Windows\System
        ValueName: UseTPMPIN
        Recursive: false
        Comment: "0 = Do not allow startup PIN with TPM, 1 = Require startup PIN with TPM, 2 = Allow startup PIN with TPM"

# https://admx.help/?Category=Windows_10_2016&Policy=Microsoft.Policies.VolumeEncryption::ConfigureAdvancedStartup_Name

# Threat Hunting -> Kaseya (REvil - July 2021) - Located within Registry hives from an infected system

    -
        Description: REvil IOCs
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Wow6432Node\BlackLivesMatter
        Recursive: true
        Comment: "REvil/Kaseya Ransomware attack from July 2021"

# https://community.sophos.com/b/security-blog/posts/active-ransomware-attack-on-kaseya-customers
# https://www.huntress.com/blog/rapid-response-kaseya-vsa-mass-msp-ransomware-incident
# https://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/kaseya-ransomware-supply-chain

# Threat Hunting -> Lockbit 2.0 - Located within Registry hives from an infected system

    -
        Description: PowerShell Info
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Microsoft\PowerShell\info
        Recursive: false
        Comment: Cobalt Strike Reflection Attack - Lockbit 2.0

    -
        Description: Restricted Admin Status
        HiveType: SYSTEM
        Category: Threat Hunting
        KeyPath: ControlSet*\Control\Lsa
        ValueName: DisableRestrictedAdmin
        Recursive: false
        Comment: "Displays the status of Restricted Admin mode"

# https://twitter.com/JohnLaTwC/status/1413510338880839686
# https://labs.f-secure.com/blog/undisable/
# https://blog.ahasayen.com/restricted-admin-mode-for-rdp/
# https://docs.microsoft.com/en-us/windows/security/identity-protection/remote-credential-guard

# Threat Hunting -> Antivirus

    -
        Description: Windows Defender
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Microsoft\Windows Defender\Real-Time Protection
        Recursive: false
        Comment: "Windows Defender Real-Time Protection Status, 0 = Enabled, 1 = Disabled"

# https://www.windowsphoneinfo.com/threads/cannot-open-security-dashboard-for-windows-defender.114537/
# https://gist.github.com/MHaggis/a955f1351a7d07592b90ab605e3b02d9

    -
        Description: Symantec Endpoint Protection
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: WOW6432Node\Symantec\Symantec Endpoint Protection\AV\Quarantine\QRecords\*
        ValueName: FName
        Recursive: false
        Comment: "Displays a list of filenames that have been quarantined by Symantec Endpoint Protection"
    -
        Description: Windows Defender
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Microsoft\Windows Defender\Reporting
        Recursive: false
        Comment: "Windows Defender Real-Time Protection Status, 0 = Enabled, 1 = Disabled"
    -
        Description: Windows Defender
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Microsoft\Windows Defender
        ValueName: fDenyTSConnections
        Recursive: false
        Comment: "Windows Defender Real-Time Protection Status, 0 = Enabled, 1 = Disabled"
    -
        Description: Windows Defender
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Policies\Microsoft\Windows Defender\Exclusions\
        Recursive: true
        Comment: "Windows Defender Exclusions through Group Policies (GPOs)"
    -
        Description: Windows Defender
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Microsoft\Windows Defender\Exclusions\
        Recursive: true
        Comment: "Windows Defender Exclusions"
    -
        Description: Image File Execution Options Injection
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Microsoft\Windows NT\CurrentVersion\Image File Execution Options\*
        ValueName: Debugger
        Recursive: false
        Comment: "See documentation in Batch File for further information"

# https://attack.mitre.org/techniques/T1546/012/

    -
        Description: Image File Execution Options Injection
        HiveType: SOFTWARE
        Category: Threat Hunting
        KeyPath: Microsoft\Windows NT\CurrentVersion\SilentProcessExit\*
        Recursive: false
        Comment: "See documentation in Batch File for further information"

# https://attack.mitre.org/techniques/T1546/012/

# Threat Hunting -> Office

    -
        Description: Connections Made By MS Office
        HiveType: NTUSER
        Category: Threat Hunting
        KeyPath: Software\Microsoft\Office\16.0\Common\Internet\Server Cache
        Recursive: true
        Comment: "Displays the connections made by MS Office - IOCs found here for CVE-2022-30190"

# https://twitter.com/RoxpinTeddy/status/1531726171292983297?t=yan4rRk3w1epMk2Vxncfxw&s=19
# https://businessinsights.bitdefender.com/technical-advisory-cve-2022-30190-zero-day-vulnerability-follina-in-microsoft-support-diagnostic-tool

# More to come...stay tuned!
```

`Tools/RECmd_BatchFiles/MUICache.reb`:

```reb
Description: MUICache - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13d65f-31db-5cdc-83df-88ec83dc17
Keys:
    -
        Description: MuiCache (Vista+)
        HiveType: UsrClass
        Category: Program Execution
        KeyPath: Local Settings\Software\Microsoft\Windows\Shell\MuiCache
        Recursive: false

    -
        Description: MuiCache (2000/XP/2003)
        HiveType: UsrClass
        Category: Program Execution
        KeyPath: Software\Microsoft\Windows\ShellNoRoam\MUICache
        Recursive: false
```

`Tools/RECmd_BatchFiles/RecentDocs.reb`:

```reb
Description: RecentDocs - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13eb5f-31db-5cdc-83df-88ec86dc18
Keys:
    -
        Description: Registry Key that will track the last files and folders opened and is used to populate data in "Recent" menus of the Start menu. 
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs
        Recursive: true
```

`Tools/RECmd_BatchFiles/RegistryASEPs.reb`:

```reb
Description: Registry ASEPs
Author: Troy Larson
Version: 1
Id: d6b50e3a-291c-4d8a-afbc-4dd05d252742
Keys:
    -
        Description: Select ControlSet
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: Select
        Recursive: false
        Comment:
    -
        Description: ServiceControlManagerExtension
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control
        ValueName: ServiceControlManagerExtension
        Recursive: false
        Comment:
    -
        Description: BootVerificationProgram
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\BootVerificationProgram
        ValueName: Imagepath
        Recursive: false
        Comment:
    -
        Description: LSA Authentication Packages
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\LSA
        ValueName: Authentication Packages
        Recursive: false
        Comment: 
    -
        Description: LSA Notification Packages
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\LSA
        ValueName: Notification Packages
        Recursive: false
        Comment: 
    -
        Description: LSA Security Packages
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\LSA
        ValueName: Security Packages
        Recursive: false
        Comment: 
    -
        Description: LSA OsConfig
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\LSA\OsConfig
        ValueName: Security Packages
        Recursive: false
        Comment: 
    -
        Description: NetworkProvider Order
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: \ControlSet*\Control\NetworkProvider\*
        ValueName: ProviderOrder
        Recursive: true
        Comment: 
    -
        Description: Print Driver
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Print\Monitors\*
        ValueName: Driver
        Recursive: true
        Comment: 
    -
        Description: Print Providers
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Print\Providers\*
        ValueName: Name
        Recursive: true
        Comment: 
    -
        Description: SafeBoot
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: \ControlSet*\Control\SafeBoot
        ValueName: AlternateShell
        Recursive: false
        Comment: 
    -
        Description: SafeBoot Minimal
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\SafeBoot\Minimal\*
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: SafeBoot Network
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\SafeBoot\Network\*
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: SecurityProviders
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\SecurityProviders
        ValueName: SecurityProviders
        Recursive: false
        Comment: 
    -
        Description: Session Manager BootExecute
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: BootExecute
        Recursive: false
        Comment: 
    -
        Description: Session Manager BootShell
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: BootShell
        Recursive: false
        Comment: 
    -
        Description: Session Manager Execute
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: Execute
        Recursive: false
        Comment: 
    -
        Description: Session Manager InitialCommand
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: InitialCommand
        Recursive: false
        Comment: 
    -
        Description: Session Manager InitialCommand
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: "*InitialCommand"
        Recursive: false
        Comment: 
    -
        Description: Session Manager PendingFileRenameOperations
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: PendingFileRenameOperations
        Recursive: false
        Comment: 
    -
        Description: Session Manager PendingFileRenameOperations*
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: PendingFileRenameOperations*
        Recursive: false
        Comment: 
    -
        Description: Session Manager SETUPEXECUTE
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: SetUpExecute
        Recursive: false
        Comment: 
    -
        Description: Session Manager KnownDLLs
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager\KnownDLLs
        Recursive: false
        Comment: 
    -
        Description: Session Manager SubSystems
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager\SubSystems
        Recursive: false
        Comment: 
    -
        Description: Terminal Server StartupPrograms
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Terminal Server\Wds\rdpwd
        ValueName: StartupPrograms
        Recursive: false
        Comment: 
    -
        Description: Terminal Server WinStations RDP-Tcp
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: \ControlSet*\Control\Terminal Server\WinStations\RDP-Tcp\TSMMRemotingAllowedApps
        Recursive: false
        Comment: 
    -
        Description: WOW KnownDLLs
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\WOW
        ValueName: KnownDLLs
        Recursive: false
        Comment: 
    -
        Description: Services AutoRun
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: AutoRun
        Recursive: true
        Comment: 
    -
        Description: Services BootFlags
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: BootFlags
        Recursive: true
        Comment: 
    -
        Description: Services DelayedAutoStart
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: DelayedAutoStart
        Recursive: true
        Comment: 
    -
        Description: Services DependOnService
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: DependOnService
        Recursive: true
        Comment: 
    -
        Description: Services Description
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: Description
        Recursive: true
        Comment: 
    -
        Description: Services DisplayName
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: Services ErrorControl
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ErrorControl
        Recursive: true
        Comment: 
    -
        Description: Services Group
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: Group
        Recursive: true
        Comment: 
    -
        Description: Services ImagePath
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ImagePath
        Recursive: true
        Comment: 
    -
        Description: Services Library
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: Library
        Recursive: true
        Comment: 
    -
        Description: Services ObjectName
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ObjectName
        Recursive: true
        Comment: 
    -
        Description: Services ProviderPath
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ProviderPath
        Recursive: true
        Comment: 
    -
        Description: Services ProxyDllFile
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ProxyDllFile
        Recursive: true
        Comment: 
    -
        Description: Services RequiredPrivileges
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: RequiredPrivileges
        Recursive: true
        Comment: 
    -
        Description: Services ServiceDll
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ServiceDll
        Recursive: true
        Comment: 
    -
        Description: Services ServiceMain
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ServiceMain
        Recursive: true
        Comment: 
    -
        Description: Services ServiceSidType
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ServiceSidType
        Recursive: true
        Comment: 
    -
        Description: Services Start
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: Start
        Recursive: true
        Comment: 
    -
        Description: Services Type
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: Type
        Recursive: true
        Comment: 
    -
        Description: WinSock2 AppId_Catalog AppFullPath
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\AppId_Catalog\*
        ValueName: AppFullPath
        Recursive: false
        Comment: 
    -
        Description: WinSock2 AppId_Catalog AppArgs
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\AppId_Catalog\*
        ValueName: AppArgs
        Recursive: false
        Comment: 
    -
        Description: WinSock2 NameSpace_Catalog5 DisplayString
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\NameSpace_Catalog5\Catalog_Entries\*
        ValueName: DisplayString
        Recursive: false
        Comment: 
    -
        Description: WinSock2 NameSpace_Catalog5 Enabled
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\NameSpace_Catalog5\Catalog_Entries\*
        ValueName: Enabled
        Recursive: false
        Comment: 
    -
        Description: WinSock2 NameSpace_Catalog5 LibraryPath
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\NameSpace_Catalog5\Catalog_Entries\*
        ValueName: LibraryPath
        Recursive: false
        Comment: 
    -
        Description: WinSock2 NameSpace_Catalog5 64 DisplayString
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\NameSpace_Catalog5\Catalog_Entries64\*
        ValueName: DisplayString
        Recursive: false
        Comment: 
    -
        Description: WinSock2 NameSpace_Catalog5 64 Enabled
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\NameSpace_Catalog5\Catalog_Entries64\*
        ValueName: Enabled
        Recursive: false
        Comment: 
    -
        Description: WinSock2 NameSpace_Catalog5 64 LibraryPath
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\NameSpace_Catalog5\Catalog_Entries64\*
        ValueName: LibraryPath
        Recursive: false
        Comment: 
    -
        Description: WinSock2 Protocol_Catalog9 ProtocolName
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\Protocol_Catalog9\Catalog_Entries\*
        ValueName: ProtocolName
        Recursive: false
        Comment: 
    -
        Description: WinSock2 Protocol_Catalog9 64 ProtocolName
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\Protocol_Catalog9\Catalog_Entries64\*
        ValueName: ProtocolName
        Recursive: false
        Comment: 
    -
        Description: Setup
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: Setup
        ValueName: CmdLine
        Recursive: false
        Comment: 
    -
        Description: .cmd
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\.cmd
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: .cmd PersistentHandler
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\.cmd\PersistentHandler
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: .exe
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\.exe
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: .exe PersistentHandler
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\.exe\PersistentHandler
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: shell Open Command
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\shell
        ValueName: DelegateExecute
        Recursive: true
        Comment:
    -
        Description: shell Runas command
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\shell
        ValueName: IsolatedCommand
        Recursive: true
        Comment: 
    -
        Description: ShellEx ColumnHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\*\ShellEx\ColumnHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx ContextMenuHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\*\ShellEx\ContextMenuHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: shellex ContextMenuHandlers InstallFont
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\shellex\ContextMenuHandlers\InstallFont
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: shellex ContextMenuHandlers Open With
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\shellex\ContextMenuHandlers\Open With
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: shellex ContextMenuHandlers Open With EncryptionMenu
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\shellex\ContextMenuHandlers\Open With EncryptionMenu
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx ContextMenuHandlers OpenContainingFolderMenu
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\ShellEx\ContextMenuHandlers\OpenContainingFolderMenu
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: shellex ContextMenuHandlers PlayTo
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\shellex\ContextMenuHandlers\PlayTo
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx CopyHookHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\*\ShellEx\CopyHookHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx DragDropHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\*\ShellEx\DragDropHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx ExtShellFolderViews
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\*\ShellEx\ExtShellFolderViews
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEX IconHandler
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\ShellEX\IconHandler
        Recursive: false
        Comment: 
    -
        Description: ShellEx PropertySheetHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\*\ShellEx\PropertySheetHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID InprocServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\InprocServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID InprocServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\InprocServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: CLSID Instance CLSID
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\Instance
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: CLSID Instance FriendlyName
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\Instance
        ValueName: FriendlyName
        Recursive: true
        Comment: 
    -
        Description: CLSID LocalServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\LocalServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID LocalServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\LocalServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: CLSID PersistentHandler
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\PersistentHandler
        Recursive: false
        Comment: 
    -
        Description: CLSID TypeLib
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\TypeLib
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: cmdfile shell open command
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\cmdfile\shell\open\command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Directory background shellex ContextMenuHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Directory\background\shellex\ContextMenuHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Directory shellex CopyHookHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Directory\shellex\CopyHookHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Directory shellex DragDropHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Directory\shellex\DragDropHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Directory shellex PropertySheetHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Directory\shellex\PropertySheetHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Drive shellex ContextMenuHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Drive\shellex\ContextMenuHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Exefile Shell Open Command
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Exefile\Shell\Open\Command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Classes Filter
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Filter
        Recursive: true
        Comment: 
    -
        Description: Folder shellex ContextMenuHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Folder\shellex\ContextMenuHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Folder shellex DragDropHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Folder\shellex\DragDropHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Folder shellex PropertySheetHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Folder\shellex\PropertySheetHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: htmlfile shell open command
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\htmlfile\shell\open\command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Interface ProxyStubClsid32
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Interface\*\ProxyStubClsid32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Interface TypeLib
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Interface\*\TypeLib
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Protocols Filter
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Protocols\Filter\*
        ValueName: CLSID
        Recursive: false
        Comment: 
    -
        Description: Protocols Handler
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Protocols\Handler\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Protocols Handler
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Protocols\Handler\*
        ValueName: CLSID
        Recursive: false
        Comment: 
    -
        Description: Protocols Name-Space Handler
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Protocols\Name-Space Handler\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Protocols Name-Space Handler
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Protocols\Name-Space Handler\*
        ValueName: CLSID
        Recursive: false
        Comment: 
    -
        Description: SystemFileAssociations ShellEx ContextMenuHandlers ShellImagePreview
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\SystemFileAssociations\*\ShellEx\ContextMenuHandlers\ShellImagePreview
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: TypeLib win32
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\TypeLib\*\*\*\win32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: TypeLib win64
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\TypeLib\*\*\*\win64
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 shell Open Command
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\shell
        ValueName: DelegateExecute
        Recursive: true
        Comment:
    -
        Description: Wow6432 shell Runas command
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\shell
        ValueName: IsolatedCommand
        Recursive: true
        Comment: 
    -
        Description: Wow6432 ShellEx ColumnHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\*\ShellEx\ColumnHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEx ContextMenuHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\*\ShellEx\ContextMenuHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 shellex ContextMenuHandlers InstallFont
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\shellex\ContextMenuHandlers\InstallFont
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 shellex ContextMenuHandlers Open With
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\shellex\ContextMenuHandlers\Open With
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 shellex ContextMenuHandlers Open With EncryptionMenu
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\shellex\ContextMenuHandlers\Open With EncryptionMenu
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEx ContextMenuHandlers OpenContainingFolderMenu
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\ShellEx\ContextMenuHandlers\OpenContainingFolderMenu
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 shellex ContextMenuHandlers PlayTo
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\shellex\ContextMenuHandlers\PlayTo
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEx CopyHookHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\*\ShellEx\CopyHookHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEx DragDropHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\*\ShellEx\DragDropHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEx ExtShellFolderViews
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\*\ShellEx\ExtShellFolderViews
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEX IconHandler
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\ShellEX\IconHandler
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEx PropertySheetHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\*\ShellEx\PropertySheetHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 CLSID InprocServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\InprocServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 CLSID InprocServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\InprocServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: Wow6432 CLSID Instance CLSID
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\Instance
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: Wow6432 CLSID Instance FriendlyName
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\Instance
        ValueName: FriendlyName
        Recursive: true
        Comment: 
    -
        Description: Wow6432 CLSID LocalServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\LocalServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 CLSID LocalServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\LocalServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: Wow6432 CLSID PersistentHandler
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\PersistentHandler
        Recursive: false
        Comment: 
    -
        Description: Wow6432 CLSID TypeLib
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\TypeLib
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Directory background shellex ContextMenuHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Directory\background\shellex\ContextMenuHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Directory shellex CopyHookHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Directory\shellex\CopyHookHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Directory shellex DragDropHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Directory\shellex\DragDropHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Directory shellex PropertySheetHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Directory\shellex\PropertySheetHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Drive shellex ContextMenuHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Drive\shellex\ContextMenuHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Classes Filter
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Filter
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Folder shellex ContextMenuHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Folder\shellex\ContextMenuHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Folder shellex DragDropHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Folder\shellex\DragDropHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Folder shellex PropertySheetHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Folder\shellex\PropertySheetHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Interface ProxyStubClsid32
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Interface\*\ProxyStubClsid32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Interface TypeLib
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Interface\*\TypeLib
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 TypeLib win32
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\TypeLib\*\*\*\win32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 TypeLib win64
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\TypeLib\*\*\*\win64
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: StartMenuInternet shell open command
        HiveType: Software
        Category: ASEP
        KeyPath: Clients\StartMenuInternet\*\shell\open\command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: StartMenuInternet shell naom command
        HiveType: Software
        Category: ASEP
        KeyPath: Clients\StartMenuInternet\*\shell\naom\command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: StartMenuInternet Shell RunAs Command
        HiveType: Software
        Category: ASEP
        KeyPath: Clients\StartMenuInternet\*\Shell\RunAs\Command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Chrome Extensions
        HiveType: Software
        Category: ASEP
        KeyPath: Google\Chrome\Extensions
        Recursive: true
        Comment: 
    -
        Description: Google Update
        HiveType: Software
        Category: ASEP
        KeyPath: Google\Update
        ValueName: path
        Recursive: false
        Comment: 
    -
        Description: .NETFramework
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\.NETFramework
        ValueName: DbgManagedDebugger
        Recursive: false
        Comment: 
    -
        Description: Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Active Setup\Installed Components\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Active Setup\Installed Components\*
        ValueName: LocalizedName
        Recursive: false
        Comment: 
    -
        Description: Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Active Setup\Installed Components\*
        ValueName: ShellComponent
        Recursive: false
        Comment: 
    -
        Description: Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Active Setup\Installed Components\*
        ValueName: StubPath
        Recursive: false
        Comment: 
    -
        Description: Command Processor
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Command Processor
        ValueName: autorun
        Recursive: false
        Comment: 
    -
        Description: Cryptography Offload
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Cryptography\Offload
        ValueName: ExpoOffload
        Recursive: true
        Comment: 
    -
        Description: Ctf LangBarAddin
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Ctf\LangBarAddin
        ValueName: Filepath
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Approved Extensions
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Approved Extensions
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Explorer Bars
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Explorer Bars\*
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Extension Validation
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Extension Validation
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Extensions
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Extensions
        ValueName: ClsidExtension
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Low Rights DragDrop
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Low Rights\DragDrop
        ValueName: AppName
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Low Rights DragDrop
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Low Rights\DragDrop
        ValueName: AppPath
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Low Rights ElevationPolicy
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Low Rights\ElevationPolicy
        ValueName: AppName
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Low Rights ElevationPolicy
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Low Rights\ElevationPolicy
        ValueName: AppPath
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Low Rights ElevationPolicy
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Low Rights\ElevationPolicy
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Plugins Extension
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Plugins\Extension
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Toolbar
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Toolbar
        Recursive: false
        Comment: 
    -
        Description: Internet Explorer Toolbar ShellBrowser
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Toolbar\ShellBrowser
        Recursive: false
        Comment: 
    -
        Description: Internet Explorer Toolbar WebBrowser
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Toolbar\WebBrowser
        Recursive: false
        Comment: 
    -
        Description: Internet Explorer URLSearchHooks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\URLSearchHooks
        Recursive: false
        Comment: 
    -
        Description: Office Addins
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Office\*\Addins
        ValueName: Description
        Recursive: true
        Comment: 
    -
        Description: Office Addins
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Office\*\Addins
        ValueName: FriendlyName
        Recursive: true
        Comment: 
    -
        Description: Office Addins
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Office\*\Addins
        ValueName: LoadBehavior
        Recursive: true
        Comment: 
    -
        Description: Authentication Credential Provider Filters
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Authentication\Credential Provider Filters
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Authentication Credential Providers
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Authentication\Credential Providers
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Authentication PLAP Providers
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Authentication\PLAP Providers
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Explorer Browser Helper Objects
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects
        Recursive: true
        Comment: 
    -
        Description: Explorer FindExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\FindExtensions
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Explorer FindExtensions Static
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\FindExtensions\Static
        Recursive: true
        Comment: 
    -
        Description: Explorer SharedTaskScheduler
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\SharedTaskScheduler
        Recursive: false
        Comment: 
    -
        Description: Explorer ShellExecuteHooks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\ShellExecuteHooks
        Recursive: true
        Comment: 
    -
        Description: Explorer ShellIconOverlayIdentifiers
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Explorer ShellServiceObjects
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\ShellServiceObjects
        ValueName: autostart
        Recursive: true
        Comment: 
    -
        Description: Ext PreApproved
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Ext\PreApproved
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Shutdown
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Shutdown
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Startup
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Startup
        Recursive: true
        Comment: 
    -
        Description: Internet Settings
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Internet Settings
        ValueName: AutoConfigURL
        Recursive: false
        Comment: 
    -
        Description: Explorer Run
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
        Recursive: false
        Comment: 
    -
        Description: Policies System
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Policies\System
        ValueName: Shell
        Recursive: false
        Comment: 
    -
        Description: Policies System
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Policies\System
        ValueName: UIHost
        Recursive: false
        Comment: 
    -
        Description: Policies System
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Policies\System
        ValueName: Userinit
        Recursive: false
        Comment: 
    -
        Description: Run
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: RunOnce
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Runonce
        Recursive: false
        Comment: 
    -
        Description: RunOnce Setup
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Runonce\Setup
        Recursive: false
        Comment: 
    -
        Description: RunOnceEx
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\RunOnceEx
        Recursive: false
        Comment: 
    -
        Description: RunServices
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\RunServices
        Recursive: false
        Comment: 
    -
        Description: RunServicesOnce
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\RunServicesOnce
        Recursive: false
        Comment: 
    -
        Description: SharedDLLs
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Shareddlls
        Recursive: false
        Comment: 
    -
        Description: Shell Extensions Approved
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Shell Extensions\Approved
        Recursive: false
        Comment: 
    -
        Description: ShellServiceObjectDelayLoad
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad
        Recursive: false
        Comment: 
    -
        Description: Installed SDB
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Uninstall\*.sdb
        ValueName: InstallDate
        Recursive: true
        Comment: 
    -
        Description: Installed SDB
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Uninstall\*.sdb
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: AeDebug
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AeDebug
        ValueName: auto
        Recursive: true
        Comment: 
    -
        Description: AeDebug
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AeDebug
        ValueName: Debugger
        Recursive: true
        Comment: 
    -
        Description: AeDebug
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AeDebug
        ValueName: UserDebuggerHotKey
        Recursive: true
        Comment: 
    -
        Description: AppCompatFlags Custom
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom
        Recursive: true
        Comment: 
    -
        Description: AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabaseDescription
        Recursive: true
        Comment: 
    -
        Description: AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabaseInstallTimeStamp
        Recursive: true
        Comment: 
    -
        Description: AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabasePath
        Recursive: true
        Comment: 
    -
        Description: AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabaseType
        Recursive: true
        Comment: 
    -
        Description: AppCompatFlags Layers
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\Current Version\AppCompatFlags\Layers
        Recursive: false
        Comment: 
    -
        Description: Drivers
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Drivers
        Recursive: false
        Comment: 
    -
        Description: Drivers32
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Drivers32
        Recursive: false
        Comment: 
    -
        Description: Font Drivers 
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Font Drivers
        Recursive: true
        Comment: 
    -
        Description: Image File Execution Options
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Image File Execution Options
        ValueName: GlobalFlag
        Recursive: true
        Comment: 
    -
        Description: Image File Execution Options
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Image File Execution Options
        ValueName: Debugger
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Boot
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Boot
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Logon
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Logon
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Maintenance
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Maintenance
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Plain
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Plain
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Actions
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Author
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Description
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: DynamicInfo
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Hash
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Path
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Schema
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: SecurityDescriptor
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Source
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Triggers
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: URI
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Version
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tree
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree
        ValueName: Id
        Recursive: true
        Comment: 
    -
        Description: SilentProcessExit
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\SilentProcessExit
        ValueName: ReportingMode
        Recursive: true
        Comment: 
    -
        Description: SilentProcessExit
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\SilentProcessExit
        ValueName: MonitorProcess
        Recursive: true
        Comment: 
    -
        Description: Microsoft Windows NT SvcHost
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\SvcHost
        Recursive: true
        Comment: 
    -
        Description: Microsoft Windows NT Terminal Server Run
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Terminal Server\install\Software\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: Microsoft Windows NT Terminal Server Runonce
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Terminal Server\install\Software\Microsoft\Windows\CurrentVersion\Runonce
        Recursive: false
        Comment: 
    -
        Description: Microsoft Windows NT Terminal Server Runonceex
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Terminal Server\install\Software\Microsoft\Windows\CurrentVersion\Runonceex
        Recursive: false
        Comment: 
    -
        Description: Microsoft Windows NT OsImagesFolder
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Virtualization\LayerRootLocations
        Recursive: true
        Comment: Looking for OsImagesFolder.
    -
        Description: Windows NT CV Windows AppInitDlls
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: AppInit_Dlls
        Recursive: false
        Comment: 
    -
        Description: Windows NT CV Windows IconServiceLib
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: IconServiceLib
        Recursive: false
        Comment: 
    -
        Description: Windows NT CV Windows Load
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: Load
        Recursive: false
        Comment: 
    -
        Description: Windows NT CV Windows RequireSignedAppInit_DLLs
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: RequireSignedAppInit_DLLs
        Recursive: false
        Comment: 
    -
        Description: Windows NT CV Windows Run
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: Run
        Recursive: false
        Comment: 
    -
        Description: Winlogon GinaDLL
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Ginadll
        Recursive: false
        Comment: 
    -
        Description: Winlogon Userinit
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Userinit
        Recursive: false
        Comment: 
    -
        Description: Winlogon VMApplet
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: VMApplet
        Recursive: false
        Comment: 
    -
        Description: Winlogon AppSetup
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: AppSetup
        Recursive: false
        Comment: 
    -
        Description: Winlogon Shell
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Shell
        Recursive: false
        Comment: 
    -
        Description: Winlogon System
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: System
        Recursive: false
        Comment: 
    -
        Description: Winlogon Taskman
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Taskman
        Recursive: false
        Comment: 
    -
        Description: Winlogon UIHost
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: UIHost
        Recursive: false
        Comment: 
    -
        Description: Winlogon AlternateShells AvailableShells
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon\AlternateShells\AvailableShells
        Recursive: false
        Comment: 
    -
        Description: Winlogon GPExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Winlogon GPExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: Winlogon GPExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
        ValueName: dllname
        Recursive: true
        Comment: 
    -
        Description: Winlogon Notify
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon\Notify
        ValueName: dllname
        Recursive: true
        Comment: 
    -
        Description: MozillaPlugins
        HiveType: Software
        Category: ASEP
        KeyPath: MozillaPlugins\*
        ValueName: path
        Recursive: false
        Comment: 
    -
        Description: Policies Scripts Logoff
        HiveType: Software
        Category: ASEP
        KeyPath: Policies\Microsoft\Windows\System\Scripts\Logoff
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Policies Scripts Logon
        HiveType: Software
        Category: ASEP
        KeyPath: Policies\Microsoft\Windows\System\Scripts\Logon
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Policies Scripts Shutdown
        HiveType: Software
        Category: ASEP
        KeyPath: Policies\Microsoft\Windows\System\Scripts\Shutdown
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Policies Scripts Startup
        HiveType: Software
        Category: ASEP
        KeyPath: Policies\Microsoft\Windows\System\Scripts\Startup
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Google Update
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Google\Update
        ValueName: path
        Recursive: false
        Comment: 
    -
        Description: WOW6432 .NETFramework
        HiveType: Software
        Category: ASEP
        KeyPath: WOW6432Node\Microsoft\.NETFramework
        ValueName: DbgManagedDebugger
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Active Setup\Installed Components\*
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Active Setup\Installed Components\*
        ValueName: ShellComponent
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Active Setup\Installed Components\*
        ValueName: StubPath
        Recursive: true
        Comment: 
    -
        Description: WOW6432 Command Processor Autorun
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Command Processor
        ValueName: Autorun
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Ctf LangBarAddin
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Ctf\LangBarAddin
        ValueName: Filepath
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Approved Extensions
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Approved Extensions
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Explorer Bars
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Explorer Bars\*
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Extension Validation
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Extension Validation
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Extensions
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Extensions
        ValueName: ClsidExtension
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Low Rights DragDrop
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Low Rights\DragDrop
        ValueName: AppName
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Low Rights DragDrop
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Low Rights\DragDrop
        ValueName: AppPath
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Low Rights ElevationPolicy AppName
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Low Rights\ElevationPolicy
        ValueName: AppName
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Low Rights ElevationPolicy AppPath
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Low Rights\ElevationPolicy
        ValueName: AppPath
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Low Rights ElevationPolicy CLSID
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Low Rights\ElevationPolicy
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Plugins Extension
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Plugins\Extension
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Toolbar
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Toolbar
        Recursive: false
        Comment: 
    -
        Description: Wow6432 IE Toolbar ShellBrowser
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Toolbar\ShellBrowser
        Recursive: false
        Comment: 
    -
        Description: Wow6432 IE Toolbar WebBrowser
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Toolbar\WebBrowser
        Recursive: false
        Comment: 
    -
        Description: Wow6432 IE URLSearchHooks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\URLSearchHooks
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Office Addins
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Office\*\Addins
        ValueName: Description
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Office Addins
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Office\*\Addins
        ValueName: FriendlyName
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Office Addins
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Office\*\Addins
        ValueName: LoadBehavior
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Authentication Credential Provider Filters
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Authentication\Credential Provider Filters
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Authentication Credential Providers
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Authentication\Credential Providers
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Authentication PLAP Providers
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Authentication\PLAP Providers
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Explorer Browser Helper Objects
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Explorer FindExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\FindExtensions
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Explorer FindExtensions Static
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\FindExtensions\Static
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Explorer SharedTaskScheduler
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\SharedTaskScheduler
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Explorer ShellExecuteHooks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\ShellExecuteHooks
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Explorer ShellIconOverlayIdentifiers
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Explorer ShellServiceObjects
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\ShellServiceObjects
        ValueName: autostart
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Ext PreApproved
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Ext\PreApproved
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Internet Settings
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Internet Settings
        ValueName: AutoConfigURL
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Run
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: Wow6432 RunOnce
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Runonce
        Recursive: false
        Comment: 
    -
        Description: Wow6432 RunOnce Setup
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Runonce\Setup
        Recursive: false
        Comment: 
    -
        Description: Wow6432 RunOnceEx
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnceEx
        Recursive: false
        Comment: 
    -
        Description: Wow6432 RunServices
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\RunServices
        Recursive: false
        Comment: 
    -
        Description: Wow6432 RunServicesOnce
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\RunServicesOnce
        Recursive: false
        Comment: 
    -
        Description: Wow6432 SharedDLLs
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Shareddlls
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Shell Extensions Approved
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellServiceObjectDelayLoad
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Installed SDB
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*.sdb
        ValueName: InstallDate
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Installed SDB
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*.sdb
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AeDebug
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug
        ValueName: auto
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AeDebug
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug
        ValueName: Debugger
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AeDebug
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug
        ValueName: UserDebuggerHotKey
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabaseDescription
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabaseInstallTimeStamp
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabasePath
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabaseType
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AppCompatFlags Layers
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\Current Version\AppCompatFlags\Layers
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Drivers
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Drivers
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Drivers32
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Drivers32
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Font Drivers 
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Font Drivers
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Image File Execution Options
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Image File Execution Options
        ValueName: GlobalFlag
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Image File Execution Options
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Image File Execution Options
        ValueName: Debugger
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Boot
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Boot
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Logon
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Logon
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Maintenance
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Maintenance
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Plain
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Plain
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Actions
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Author
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Description
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: DynamicInfo
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Hash
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Path
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Schema
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: SecurityDescriptor
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Source
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Triggers
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: URI
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Version
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tree
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree
        ValueName: Id
        Recursive: true
        Comment: 
    -
        Description: Wow6432 SilentProcessExit
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\SilentProcessExit
        ValueName: ReportingMode
        Recursive: true
        Comment: 
    -
        Description: Wow6432 SilentProcessExit
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\SilentProcessExit
        ValueName: MonitorProcess
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Microsoft Windows NT SvcHost
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\SvcHost
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Microsoft Windows NT Terminal Server Run
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Terminal Server\install\Software\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Microsoft Windows NT Terminal Server Runonce
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Terminal Server\install\Software\Microsoft\Windows\CurrentVersion\Runonce
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Microsoft Windows NT Terminal Server Runonceex
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Terminal Server\install\Software\Microsoft\Windows\CurrentVersion\Runonceex
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Microsoft Windows NT OsImagesFolder
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Virtualization\LayerRootLocations
        Recursive: true
        Comment: Looking for OsImagesFolder.
    -
        Description: Wow6432 Microsoft Windows NT CurrentVersion Windows
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: AppInit_Dlls
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Windows NT CV Windows IconServiceLib
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: IconServiceLib
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Windows NT CV Windows Load
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: Load
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Windows NT CV Windows RequireSignedAppInit_DLLs
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: RequireSignedAppInit_DLLs
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Windows NT CV Windows Run
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: Run
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon GinaDLL
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Ginadll
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon Userinit
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Userinit
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon VMApplet
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: VMApplet
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon AppSetup
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: AppSetup
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon Shell
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Shell
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon System
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: System
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon Taskman
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Taskman
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon UIHost
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: UIHost
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon AlternateShells AvailableShells
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon\AlternateShells\AvailableShells
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon GPExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Winlogon GPExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Winlogon GPExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
        ValueName: dllname
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Winlogon Notify
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify
        ValueName: dllname
        Recursive: true
        Comment: 
    -
        Description: Wow6432 MozillaPlugins
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\MozillaPlugins\*
        ValueName: path
        Recursive: false
        Comment: 
    -
        Description: Desktop Wallpaper
        HiveType: ntuser
        Category: ASEP
        KeyPath: Control Panel\DeskTop
        ValueName: ConvertedWallpaper
        Recursive: false
        Comment: 
    -
        Description: Desktop Wallpaper
        HiveType: ntuser
        Category: ASEP
        KeyPath: Control Panel\DeskTop
        ValueName: OriginalWallpaper
        Recursive: false
        Comment: 
    -
        Description: Desktop Wallpaper
        HiveType: ntuser
        Category: ASEP
        KeyPath: Control Panel\DeskTop
        ValueName: WallPaper
        Recursive: false
        Comment: 
    -
        Description: Desktop Screensaver
        HiveType: ntuser
        Category: ASEP
        KeyPath: Control Panel\DeskTop
        ValueName: scrnsave.exe
        Recursive: false
        Comment: 
    -
        Description: Environment Logon Script
        HiveType: ntuser
        Category: ASEP
        KeyPath: Environment
        ValueName: UserInitMprLogonScript
        Recursive: false
        Comment: 
    -
        Description: Chrome Extensions
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Google\Chrome\Extensions
        ValueName: path
        Recursive: true
        Comment: 
    -
        Description: Active Setup
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Active Setup\Installed Components
        Recursive: true
        Comment: 
    -
        Description: Command Processor
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Command Processor
        ValueName: autorun
        Recursive: false
        Comment: 
    -
        Description: Ctf LangBarAddin
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Ctf
        ValueName: LangBarAddin
        Recursive: false
        Comment: 
    -
        Description: IE Approved Extensions
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Approved Extensions
        Recursive: false
        Comment: 
    -
        Description: IE DeskTop Components
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\DeskTop\Components
        Recursive: true
        Comment: 
    -
        Description: IE BackupWallpaper
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Desktop\General
        ValueName: BackupWallpaper
        Recursive: false
        Comment: 
    -
        Description: IE wallpapersource
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Desktop\General
        ValueName: wallpapersource
        Recursive: false
        Comment: 
    -
        Description: IE Explorer Bars
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Explorer Bars
        Recursive: true
        Comment: 
    -
        Description: IE Extension Validation
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Extension Validation
        Recursive: true
        Comment: 
    -
        Description: IE Extensions
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Extensions
        Recursive: true
        Comment: 
    -
        Description: IE MenuExt
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\MenuExt
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: IE Toolbar ShellBrowser
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Toolbar\ShellBrowser
        Recursive: false
        Comment: 
    -
        Description: IE Toolbar WebBrowser
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Toolbar\WebBrowser
        Recursive: false
        Comment: 
    -
        Description: IE URLSearchHooks
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\URLSearchHooks
        Recursive: false
        Comment: 
    -
        Description: Office Addins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Office\*\Addins
        Recursive: false
        Comment: 
    -
        Description: Office Addins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Office\*\Addins\*
        Recursive: false
        Comment: 
    -
        Description: Explorer Browser Helper Objects
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects
        Recursive: true
        Comment: 
    -
        Description: Explorer SharedTaskScheduler
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\SharedTaskScheduler
        Recursive: true
        Comment: 
    -
        Description: Explorer ShellIconOverlayIdentifiers
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers
        Recursive: true
        Comment: 
    -
        Description: Explorer ShellServiceObjects
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\ShellServiceObjects
        Recursive: true
        Comment: 
    -
        Description: Ext Settings
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Ext\Settings
        Recursive: true
        Comment: 
    -
        Description: Ext Stats
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Ext\Stats
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: ExecTime
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: FileSysPath
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: GPO-ID
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: IsPowershell
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: Parameters
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: PSScriptOrder
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: SOM-ID
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: ExecTime
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: FileSysPath
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: GPO-ID
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon*
        ValueName: IsPowershell
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: Parameters
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: PSScriptOrder
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: SOM-ID
        Recursive: true
        Comment: 
    -
        Description: Internet Settings AutoConfigProxy
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Internet Settings
        ValueName: AutoConfigProxy
        Recursive: false
        Comment: 
    -
        Description: Internet Settings AutoConfigURL
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Internet Settings
        ValueName: AutoConfigURL
        Recursive: false
        Comment: 
    -
        Description: Policies Explorer NoDriveTypeAutoRun
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Policies\Explorer
        ValueName: NoDriveTypeAutoRun
        Recursive: false
        Comment: 
    -
        Description: Policies Explorer Run
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
        Recursive: false
        Comment: 
    -
        Description: Policies System Shell
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Policies\System
        ValueName: Shell
        Recursive: false
        Comment: 
    -
        Description: Policies System
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Policies\System
        ValueName: UserInit
        Recursive: false
        Comment: 
    -
        Description: Run
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: RunOnce
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\RunOnce
        Recursive: false
        Comment: 
    -
        Description: RunOnceEx
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\RunOnceEx
        Recursive: false
        Comment: 
    -
        Description: RunServices
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\RunServices
        Recursive: false
        Comment: 
    -
        Description: RunServicesOnce
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\RunServicesOnce
        Recursive: false
        Comment: 
    -
        Description: Shell Extensions Approved
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved
        Recursive: true
        Comment: 
    -
        Description: ShellServiceObjectDelayLoad
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad
        Recursive: true
        Comment: 
    -
        Description: Drivers
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\drivers
        Recursive: false
        Comment: 
    -
        Description: Drivers32
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\drivers32
        Recursive: false
        Comment: 
    -
        Description: Terminal Server Run
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Terminal Server\Install\Software\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: Terminal Server RunOnce
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Terminal Server\Install\Software\Microsoft\Windows\CurrentVersion\RunOnce
        Recursive: false
        Comment: 
    -
        Description: Terminal Server RunOnceEx
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Terminal Server\Install\Software\Microsoft\Windows\CurrentVersion\RunOnceEx
        Recursive: false
        Comment: 
    -
        Description: Load
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: Load
        Recursive: false
        Comment: 
    -
        Description: Run
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: Run
        Recursive: false
        Comment: 
    -
        Description: Winlogon Shell
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Shell
        Recursive: false
        Comment: 
    -
        Description: Winlogon Userinit
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: userinit
        Recursive: false
        Comment: 
    -
        Description: Winlogon VMapplet
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: VMapplet
        Recursive: false
        Comment: 
    -
        Description: Mozilla Components, Extensions, & Plugins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Mozilla\*\Components
        Recursive: true
        Comment: 
    -
        Description: Mozilla Components, Extensions, & Plugins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Mozilla\*\Extensions\Components
        Recursive: true
        Comment: 
    -
        Description: Mozilla Components, Extensions, & Plugins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Mozilla\*\Extensions\Plugins
        Recursive: true
        Comment: 
    -
        Description: Mozilla Components, Extensions, & Plugins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Mozilla\*\Plugins
        Recursive: true
        Comment: 
    -
        Description: Mozilla Components, Extensions, & Plugins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\MozillaPlugins
        Recursive: true
        Comment: 
    -
        Description: Policies Desktop Screensaver
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Policies\Microsoft\Windows\Control Panel\Desktop
        ValueName: Scrnsave.exe
        Recursive: false
        Comment: 
    -
        Description: Policies Logoff Script
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Policies\Microsoft\Windows\System\Scripts\Logoff
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Policies Logon Script
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Policies\Microsoft\Windows\System\Scripts\Logon
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Domain Profile Authorized Applications
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Policies\Microsoft\WindowsFirewall\DomainProfile\AuthorizedApplications
        Recursive: true
        Comment: 
    -
        Description: Standard Profile Authorized Applications
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Policies\Microsoft\WindowsFirewall\StandardProfile\AuthorizedApplications
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Active Setup
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Active Setup\Installed Components
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Command Processor
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Command Processor
        ValueName: autorun
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Internet Explorer Explorer Bars
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Internet Explorer\Explorer Bars
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Internet Explorer Extension
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Internet Explorer\Extension
        Recursive: false
        Comment: 
    -
        Description: WOW6432Node Office Addins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Office\*\Addins
        Recursive: false
        Comment: 
    -
        Description: WOW6432Node Office Addins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Office\*\Addins\*
        Recursive: false
        Comment: 
    -
        Description: WOW6432Node Drivers32
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Drivers32
        Recursive: true
        Comment: 
    -
        Description: WOW6432Node Run
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: WOW6432Node RunOnce
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce
        Recursive: false
        Comment: 
    -
        Description: .cmd
        HiveType: usrclass
        Category: ASEP
        KeyPath: .cmd
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: .cmd PersistentHandler
        HiveType: usrclass
        Category: ASEP
        KeyPath: .cmd\PersistentHandler
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: .exe
        HiveType: usrclass
        Category: ASEP
        KeyPath: .exe
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: .exe PersistentHandler
        HiveType: usrclass
        Category: ASEP
        KeyPath: .exe\PersistentHandler
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: cmdfile
        HiveType: usrclass
        Category: ASEP
        KeyPath: cmdfile
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: exefile
        HiveType: usrclass
        Category: ASEP
        KeyPath: exefile
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Htmlfile Open
        HiveType: usrclass
        Category: ASEP
        KeyPath: Htmlfile\Shell\Open\Command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx ColumnHandlers
        HiveType: usrclass
        Category: ASEP
        KeyPath: '*\ShellEx\ColumnHandlers'
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx ContextMenuHandlers
        HiveType: usrclass
        Category: ASEP
        KeyPath: '*\ShellEx\ContextMenuHandlers'
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx CopyHookHandlers
        HiveType: usrclass
        Category: ASEP
        KeyPath: '*\ShellEx\CopyHookHandlers'
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx DragDropHandlers
        HiveType: usrclass
        Category: ASEP
        KeyPath: '*\ShellEx\DragDropHandlers'
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx ExtShellFolderViews
        HiveType: usrclass
        Category: ASEP
        KeyPath: '*\ShellEx\ExtShellFolderViews'
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx PropertySheetHandlers
        HiveType: usrclass
        Category: ASEP
        KeyPath: '*\ShellEx\PropertySheetHandlers'
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Directory Background ContextMenuHandlers
        HiveType: usrclass
        Category: ASEP
        KeyPath: Directory\Background\ShellEx\ContextMenuHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID InprocServer32
        HiveType: usrclass
        Category: ASEP
        KeyPath: CLSID\*\InprocServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID InprocServer32
        HiveType: usrclass
        Category: ASEP
        KeyPath: CLSID\*\InprocServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: CLSID LocalServer32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: CLSID\*\LocalServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID LocalServer32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: CLSID\*\LocalServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: CLSID PersistentHandler
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: CLSID\*\PersistentHandler
        Recursive: false
        Comment: 
    -
        Description: CLSID TypeLib
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: CLSID\*\TypeLib
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID Instance CLSID
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: CLSID\*\Instance
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: CLSID Instance FriendlyName
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: CLSID\*\Instance
        ValueName: FriendlyName
        Recursive: true
        Comment: 
    -
        Description: Interface ProxyStubClsid32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Interface\*\ProxyStubClsid32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Protocols CLSID
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Protocols\Filter\*
        ValueName: CLSID
        Recursive: false
        Comment: 
    -
        Description: Protocols Handler
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Protocols\Handler\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Protocols Handler CLSID
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Protocols\Handler\*
        ValueName: CLSID
        Recursive: false
        Comment: 
    -
        Description: Protocols Name-Space Handler
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Protocols\Name-Space Handler\*
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: ProtocolsName-Space Handler CLSID
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Protocols\Name-Space Handler\*
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: TypeLib
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: TypeLib\*\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: TypeLib Win32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: TypeLib\*\*\*\win32
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: TypeLib Win64
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: TypeLib{*\*\*\win64
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432Node CLSID InprocServer32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\InprocServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432Node CLSID InprocServer32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\InprocServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: Wow6432Node CLSID LocalServer32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\LocalServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432Node CLSID LocalServer32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\LocalServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: Wow6432Node CLSID PersistentHandler
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\PersistentHandler
        Recursive: false
        Comment: 
    -
        Description: Wow6432Node CLSID TypeLib
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\TypeLib
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432Node CLSID Instance CLSID
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\Instance
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: Wow6432Node CLSID Instance FriendlyName
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\Instance
        ValueName: FriendlyName
        Recursive: true
        Comment: 
    -
        Description: Wow6432Node Interface ProxyStubClsid32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\Interface\*\ProxyStubClsid32
        ValueName: (default)
        Recursive: false
        Comment: 

```

`Tools/RECmd_BatchFiles/SysCache.reb`:

```reb
Description: SYSCACHE
Author: Eric Zimmerman
Version: 1
Id: ab14eb5f-31db-5cdc-83df-88ec83dc7a
Keys:
    -
        Description: SYSCACHE
        HiveType: Syscache
        Category: Execution
        KeyPath: DefaultObjectStore\ObjectTable
        Recursive: true
        Comment: SYSCACHE

```

`Tools/RECmd_BatchFiles/TrustedDocuments.reb`:

```reb
Description: TrustedDocuments - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13eb5f-31db-5cdc-83df-81ec83dc15
Keys:
    -
        Description: This registry key contains a list of Microsoft Office document file locations for which a user has explicitly enabled editing and macros.
        HiveType: NTUSER
        Category: Office Documents
        KeyPath: Software\Microsoft\Office\*\*\Security\Trusted Documents\TrustRecords
        Recursive: true
```

`Tools/RECmd_BatchFiles/UserAssist.reb`:

```reb
Description: UserAssist - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13eb5f-31db-5cdc-83df-88ec83dc17
Keys:
    -
        Description: GUI-based programs launched from the desktop are tracked in the launcher on a Windows system.
        HiveType: NTUSER
        Category: Program Execution
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist
        Recursive: true
```