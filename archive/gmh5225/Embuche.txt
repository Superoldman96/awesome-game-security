Project Path: arc_gmh5225_Embuche_f7y8x1ze

Source Tree:

```txt
arc_gmh5225_Embuche_f7y8x1ze
├── README.md
├── class_embuche
│   ├── __pycache__
│   │   ├── embuche.cpython-36.pyc
│   │   └── embuche.cpython-38.pyc
│   ├── c_toolbox
│   │   ├── anti_debug.c
│   │   ├── anti_debug.h
│   │   └── xor_string.h
│   ├── cmake_bakery
│   │   ├── __pycache__
│   │   │   ├── cmake_bakery.cpython-36.pyc
│   │   │   └── cmake_bakery.cpython-38.pyc
│   │   ├── cmake_bakery.py
│   │   ├── hellf_scripts
│   │   │   ├── endianness_changer.py
│   │   │   ├── flip_sections_flags.py
│   │   │   ├── flip_sections_flags_and_hide_entry_point.py
│   │   │   ├── hide_entry_point.py
│   │   │   ├── mixing_symbols_table.py
│   │   │   └── remove_sections.py
│   │   ├── packer
│   │   │   ├── includes
│   │   │   │   ├── consts.h
│   │   │   │   ├── cryptage.h
│   │   │   │   └── utils.h
│   │   │   ├── scripts
│   │   │   │   ├── depack.py
│   │   │   │   ├── do_aes.py
│   │   │   │   └── packer.py
│   │   │   └── src
│   │   │       ├── cryptage.c
│   │   │       ├── layout.lds
│   │   │       ├── utils.c
│   │   │       └── v0_packer.c
│   │   └── templates
│   │       ├── CMakeLists_embuche.txt.Jinja
│   │       ├── CMakeLists_packer.txt.Jinja
│   │       └── fragments
│   │           ├── endianness.Jinja
│   │           ├── flip_sections_flags.Jinja
│   │           ├── flip_sections_flags_and_hide_entry_point.Jinja
│   │           ├── hide_entry_point.Jinja
│   │           ├── mixing_symbols.Jinja
│   │           └── remove_section_header.Jinja
│   └── embuche.py
├── conf.yaml
├── docs
│   ├── compiler-options.md
│   ├── conf_file.md
│   ├── detect-debug.md
│   ├── file-format-hacks.md
│   ├── img
│   │   ├── diagramme.drawio
│   │   ├── diagramme.png
│   │   ├── ida_good_entrypoint.png
│   │   ├── ida_right_symbols.png
│   │   ├── ida_wrong_entrypoint.png
│   │   ├── ida_wrong_symbols.png
│   │   ├── indirect_references.png
│   │   ├── logo.png
│   │   ├── packer.gif
│   │   ├── pointer_functions.png
│   │   ├── poster.png
│   │   └── readelf.png
│   ├── index.md
│   ├── obstructing-code-analysis.md
│   └── packer.md
├── embuche.py
├── example
│   └── crackme
│       ├── CMakeLists.txt
│       ├── bin
│       │   └── crackme
│       ├── build
│       │   ├── CMakeCache.txt
│       │   ├── CMakeFiles
│       │   │   ├── 3.16.8
│       │   │   │   ├── CMakeCCompiler.cmake
│       │   │   │   ├── CMakeCXXCompiler.cmake
│       │   │   │   ├── CMakeDetermineCompilerABI_C.bin
│       │   │   │   ├── CMakeDetermineCompilerABI_CXX.bin
│       │   │   │   ├── CMakeSystem.cmake
│       │   │   │   ├── CompilerIdC
│       │   │   │   │   ├── CMakeCCompilerId.c
│       │   │   │   │   └── a.out
│       │   │   │   └── CompilerIdCXX
│       │   │   │       ├── CMakeCXXCompilerId.cpp
│       │   │   │       └── a.out
│       │   │   ├── CMakeDirectoryInformation.cmake
│       │   │   ├── CMakeOutput.log
│       │   │   ├── Makefile.cmake
│       │   │   ├── Makefile2
│       │   │   ├── TargetDirectories.txt
│       │   │   ├── cmake.check_cache
│       │   │   ├── crackme.dir
│       │   │   │   ├── C.includecache
│       │   │   │   ├── DependInfo.cmake
│       │   │   │   ├── build.make
│       │   │   │   ├── cmake_clean.cmake
│       │   │   │   ├── depend.internal
│       │   │   │   ├── depend.make
│       │   │   │   ├── flags.make
│       │   │   │   ├── link.txt
│       │   │   │   ├── progress.make
│       │   │   │   └── src
│       │   │   │       ├── anti_debug.c.o
│       │   │   │       └── crackme.c.o
│       │   │   └── progress.marks
│       │   ├── Makefile
│       │   └── cmake_install.cmake
│       ├── packer
│       │   ├── CMakeLists.txt
│       │   ├── includes
│       │   │   ├── consts.h
│       │   │   ├── cryptage.h
│       │   │   └── utils.h
│       │   ├── scripts
│       │   │   ├── depack.py
│       │   │   ├── do_aes.py
│       │   │   └── packer.py
│       │   └── src
│       │       ├── cryptage.c
│       │       ├── layout.lds
│       │       ├── utils.c
│       │       └── v0_packer.c
│       └── src
│           ├── anti_debug.c
│           ├── anti_debug.h
│           ├── crackme.c
│           └── xor_string.h
├── requirements.txt
├── snippets
│   ├── always_follow_conditionnals.c
│   ├── early_return.c
│   ├── indirect_call.c
│   ├── int3.c
│   ├── overlapping_instructions.c
│   └── xor_stack_string.c
└── tools
    ├── c_xor.py
    ├── main.c
    ├── program_init_helper.py
    └── test
        └── src
            ├── anti_debug.c
            ├── anti_debug.h
            ├── main.c
            └── xor_string.h

```

`README.md`:

```md
# Embuche - Anti-reverse compilation

<p align="center">
  <img src="./docs/img/logo.png">
</p>

Embuche is a tool that allows you to implement anti-reversing techniques during the different steps of the creation of an executable.

> Check out our poster [here](./docs/img/poster.png)!

## Summary

- [What is Embuche](./README.md#what-is-embuche)
- [Requirements and installation](./README.md#requirements-and-installation)
  - [Requirements](./README.md#requirements)
  - [Installation](./README.md#installation)
- [Usage](./README.md#usage)
  - [Project structure](./README.md#project-structure)
  - [Configuration](./README.md#configuration)
  - [Techniques dependencies](./README.md#techniques-dependencies)
  - [Run](./README.md#run)
- [Techniques](./README.md#techniques)
  - [Obstructing code analysis](./README.md#obstructing-code-analysis)
  - [Detecting debuggers](./README.md#detecting-debuggers)
  - [GCC options](./README.md#gcc-options)
  - [File format hacks](./README.md#file-format-hacks)
  - [Packer](./README.md#packer)
- [Docs](./docs/index.md)
- [Authors](./README.md#authors)

## What is Embuche

The main goal of Embuche is to implement a collection of anti-reversing techniques in order to make the task of a reverser harder and painful.

Embuche is designed for ELF files and C99.

Embuche will not make your program impossible to reverse, it will just increase the amount of time spent to reverse it.

Embuche is a collection of techniques and tools meant to make your program harder to reverse, you'll find:

- C snippets to obstruct code analysis
- Debugger detections
- A metamorphic packer
- Scripts to alter an ELF file
- Cmake generator

Embuche takes a C program and compiles it with GCC. It creates *CMake* files and *make* files that will be used for the compilation.

Inside these *CMake* files, there's the standard compilation process and some custom scripts that will modify the final ELF (depending on the options you've set).

Embuche is also a collection of C snippets (*snippets/*) to use in your program while creating it and a bunch of C functions to detect debugging.

Here's a schema on how Embuche works:

![Diagramme](./docs/img/diagramme.png)

## Requirements and installation

Embuche was tested on Ubuntu 18.04, Arch 5.6.15 & Debian 10.

### Requirements

In order to use Embuche you need:

- gcc (7.5.0)
- cmake (3.16.8)
- make (4.1)
- Python (3.8)
- musl-tools (1.1.19-1)
- musl-dev (1.1.19-1)
- openssl (1.1.1)

You can install these packages with:

```
sudo add-apt-repository ppa:deadsnakes/ppa
sudo apt-get update
sudo apt install gcc musl-tools musl-dev cmake python3.8 python3.8-venv python3.8-dev libsasl2-dev python-dev libldap2-dev libssl-dev
```

## Installation

If the previous requirements are installed, you can clone this repo.

```bash
mkdir embuche && cd embuche
git clone git@github.com:magnussen7/Embuche.git .
```

You'll need the python project [Hellf](https://github.com/0xswitch/Hellf).

```bash
git clone git@github.com:0xswitch/Hellf.git
export PYTHONPATH=$PYTHONPATH:$(pwd)
```

The following python packages are also needed:

- pyOpenSSL==19.1.0
- Jinja2==2.11.2
- huepy==1.2.1
- pycryptodome==3.9.7
- PyYAML==5.3.1
- secrets==1.0.2

You can install them with:

```
python3.8 -m pip install -r requirements.txt
```

## Usage

### Project Structure

In order to use Embuche on a project, you have to follow this directory. structure:

```bash
myproject/
├── bin
├── build
└── src
    └── myprogram.c
```

Inside the `src` directory you'll have all your source code, the `build` directory will be used for the compilation and the `bin` directory will be the directory with your compiled program.

> I always forget the structure of a new project. Can you help me?

Well, if you don't have the time or energy to create this project structure you can simply use :

```
./tools/program_init_helper.py path/to/my/new/project
```

This script will create the structure of the project and create an empty c file (main.c) and some anti-debugging files you can use if you want.

### Configuration

Embuche uses a YAML configuration file. Here's an example of configuration (conf.yaml):

```yaml
source_code: "./example/crackme/src/crackme.c"
files:
  - "anti_debug.c"
options:
  compilation_options:
    strip:
      description: "Remove .symtab section (symbols on disk)"
      value: true
    symbols_hidden:
      description: "Hide .dynsym section (symbols at runtime)"
      value: true
    optimize:
      description: "Optimize code (O3)"
      value: true
    unroll_loops:
      description: "Unroll loop structure"
      value: true
    static:
      description: "Use static dependencies (musl)"
      value: true
    custom:
      description: "Add custom GCC flags"
      value:
        - "fstack-protector-all"
  file_format:
    endianness:
      description: "Switch endianness to big endian"
      value: true
    remove_section_header:
      description: "Remove section header"
      value: true
    flip_sections_flags:
      description: "Flip sections flags (RX to RW & RW to RX)"
      value: true
    hide_entry_point:
      description: "Hide entry point with fake oversized section"
      value: true
    mixing_symbols:
      description: "Mix the name of symbols in .dynsym"
      value: false
  packer:
    packer:
      description: "Cipher the final binary and insert it in a program that will unciphered it at start."
      value: true
    packer_embuche:
      description: "Modify the packed binary with: endianness, remove_section_header, flip_sections_flags and hide_entry_point"
      value: true
```

With this configuration we will compile *crackme.c* with the file it needs (*anti_debug.c*), then we will:

- Strip the binary
- Hide the symbol section
- Optimize the code
- Undo loop structure
- Use static libraries (musl) instead of libc.
- Add a GCC flag, `fstack-protector-all` (Stack Smashing Protection).
- Modify the endianness of the final ELF.
- Remove the section header table in the final ELF.
- Create fake *.data* and *.text* sections with wrong flags in the final ELF.
- Oversize the fake *.data* section to overflow the entrypoint in the final ELF.
- Pack the ELF file with the packer.
- Modify the endianness of the pack ELF.
- Remove the section header table in the packed ELF.
- Create fake *.data* and *.text* sections with wrong flags in the packed ELF.
- Oversize the fake *.data* section to overflow the entrypoint in the packed ELF.

[More on options](./docs/conf_file.md)

### Techniques dependencies

Some of the techniques are exclusive and can't be use with other techniques or some required an other techniques. Here's the dependencies between the techniques:

> Note: When *Dependency* the other option must be set to use it, when *Exclusion* the other options must not be set.

|                                 |symbols_hidden|static   |remove_section_header|flip_sections_flags|hide_entry_point|mixing_symbols|INT3 snippets|Ptrace (embuche_checker)|file_descriptor (embuche_checker)|packer   |
|---------------------------------|--------------|---------|---------------------|-------------------|----------------|--------------|-------------|------------------------|---------------------------------|---------|
|symbols_hidden                   |              |         |                     |                   |                |Exclusion     |             |                        |                                 |         |
|static                           |              |         |                     |                   |                |Exclusion     |             |                        |                                 |         |
|remove_section_header            |              |         |                     |Dependency         |Dependency      |Exclusion     |             |                        |                                 |         |
|flip_sections_flags              |              |         |                     |                   |                |Exclusion     |             |                        |                                 |         |
|hide_entry_point                 |              |         |                     |                   |                |Exclusion     |             |                        |                                 |         |
|mixing_symbols                   |Exclusion     |Exclusion|Exclusion            |Exclusion          |Exclusion       |              |             |                        |                                 |         |
|INT3 snippets                    |              |         |                     |                   |                |              |             |Exclusion               |                                 |         |
|Ptrace (embuche_checker)         |              |         |                     |                   |                |              |Exclusion    |                        |                                 |         |
|file_descriptor (embuche_checker)|              |         |                     |                   |                |              |             |                        |                                 |Exclusion|
|packer                           |              |         |                     |                   |                |              |             |                        |Exclusion                        |         |


### Run

Once you've setup your configuration file, you just have to have run Embuche like this:

```bash
./embuche.py conf.yaml
```

Embuche will create the CMake files and Make files and run the compilation.

Your binary will be available in the `bin` folder of your project.

## Techniques

You can learn more about this techniques in the [doc](./docs/index.md).

### Obstructing code analysis

Current snippets:

- **Jump over invalid bytes** (`always_follow_conditionnals.c`): Write some assembly that will be interpreted by the dissassembler but won't be executed by our program, this invalid bytes will be processed by the disassembler and mess with the disassembly it produces.  [MORE](./docs/obstructing-code-analysis.md#jump-over-invalid-bytes)
- **Early return** (`early_return.c`): Trick the disassembler and prevent it to disassemble a function by forcing it to exit a function earlier. [MORE](./docs/obstructing-code-analysis.md#early-return)
- **Indirect call** (`indirect_call.c`): Indirect call to function to limit cross-references in disassemblers.  [MORE](./docs/obstructing-code-analysis.md#pointer-function-calls)
- **INT3** (`int3.c`): Stop the debugger if there's one attached. [MORE](./docs/obstructing-code-analysis.md#int3)
- **Overlapping instructions** (`overlapping_instructions.c`): Write code that is executed twice but represents two different instructions.  [MORE](./docs/obstructing-code-analysis.md#overlapping-instructions)
- **Xor stacked string** (`xor_stack_string.c`): Create xor stacked strings to prevent `strings`.
You can use `tools/c_xor.py.` to generate the C code. [MORE](./docs/obstructing-code-analysis.md#prevent-strings)

### Detecting Debuggers

Here's the techniques used to detect debugging:

- **dumpable**: Disable process memory dump. [MORE](./docs/detect-debug.md#disable-core-dump)
- **ptrace**: Check if *ptrace* is already attached or not. **CAUTION: DON'T USE THIS OPTIONS IF YOU'VE IMPLEMENTED INT3 TECHNIQUE**. [MORE](./docs/detect-debug.md#attach-to-ptrace)
- **file_descriptor**: Count the number of file descriptor to check if GDB is used. **CAUTION: THIS OPTIONS CANNOT BE SET WITH THE PACKER**. [MORE](./docs/detect-debug.md#file-descriptor)
- **pid**: Check the process name to see if it's GDB. [MORE](./docs/detect-debug.md#detect-GDB-by-its-pid)
- **ppid**: Check the name of the parent process to see if it's GDB. [MORE](./docs/detect-debug.md#check-the-parent-name)
- **ld_preload**: Check the environment variables to detect LD_PRELOAD. [MORE](./docs/detect-debug.md#detect-ld_preload)

### GCC Options

Here's the list of GCC flags in Embuche by default:

- **Wall**: Show all warnings.
- **Wextra**: Show extra warnings (unused etc).
- **Wshadow**: Show local variable or type declaration that shadows other variables.
- **g0**: Disable debug informations. [MORE](./docs/compiler-options.md#debugging-information)
- **std=gnu11**: C language dialect.

Available options for compilation:

- **strip** (-s): Remove `.symtab` section. [MORE](./docs/compiler-options.md#delete-the-symbol-table-strip)
- **symbols_hidden** (-fvisibility=hidden): Hide `.dynsym` section. [MORE](./docs/compiler-options.md#hide-symbol)
- **optimize** (-O3): Optimize code (level 3). [MORE](./docs/compiler-options.md#optimization)
- **unroll_loops** (-funroll-all-loops): Undo loop structures. [MORE](./docs/compiler-options.md#unroll-loops)
- **static** (-s): Use static dependencies instead of external ones (musl). [MORE](./docs/compiler-options.md#static-compilation)

### File Format Hacks

Here's the techniques available:

- **endianness** (`endianness_changer.py`): Change the endianness in the ELF header from little to big endian. [MORE](./docs/file-format-hacks.md#change-the-endianness)
- **remove_section_header** (`remove_sections.py`): Remove the section header table. [MORE](./docs/file-format-hacks.md#remove-section-header-table)
- **flip_sections_flags** (`flip_sections_flags.py`): Create a fake *.text* section with *RX* instead of *RW* and fake *.data* section with *RW* instead of *RX*. [MORE](./docs/file-format-hacks.md#create-fake-sections)
- **hide_entry_point** (`hide_entry_point.py`): Create a fake *.data* section that override the entry point. [MORE](./docs/file-format-hacks.md#hide-the-entry-point)
- **mixing_symbols** (`mixing_symbols_table.py`): Create a fake *.dynsym* section and mix symbols names. [MORE](./docs/file-format-hacks.md#mix-symbol-table)


### Packer

A metamorphic packer is available in Embuche. This packer will load your binary and cipher it (AES 256 bits CBC).

If you decide to use the packer, your program will be ciphered and stored in a section of our packer. When you will execute your program the packer will copy itself in memory, unciphered your program and write it on the disk for execution.

Beside cipher your binary, the packer will also ensure its integrity. The encryption keys used for the encryption are based on the SHA sum of the `.text` section, so if the packer or your program is being debugged the SHA sum will be different of the one used for decryption.

The ELF of the packer can be modified with the `packer_embuche` options.
If this options is set the following techniques will be applied on the packer that contains your program:

- **endianness**: Change the endianness in the ELF header from little to big endian.
- **remove_section_header**: Remove the section header table.
- **flip_sections_flags**: Create a fake *.text* section with *RX* instead of *RW* and fake *.data* section with *RW* instead of *RX*.
- **hide_entry_point**: Create a fake *.data* section that override the entry point.

[MORE](./docs/packer.md)

## Authors

- [Bookie](https://twitter.com/bookiem4n)
- [LX6](https://github.com/LX-6)
- [Magnussen](https://www.magnussen.funcmylife.fr)
- [Switch](https://0xswitch.fr)

```

`class_embuche/c_toolbox/anti_debug.c`:

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/prctl.h>

typedef int bool;
#define true 1
#define false 0

#define check_strings(str_buff) (strstr(str_buff, "gdb") || strstr(str_buff, "ltrace") || strstr(str_buff, "strace") || (strstr(str_buff, "radare2")) || (strstr(str_buff, "ida")))

char* calc_addr(char* p_addr);
void embuche_checker();
int check_ptrace();
int dbg_file_descriptor();
int dbg_cmdline();
int dbg_getppid_name();
int various_ldpreload();

extern char* __executable_start;

char* calc_addr(char* p_addr)
{
    return p_addr + (unsigned long)&__executable_start;
}

void __attribute__((optimize("O1"))) embuche_checker(int dumpable, int ptrace, int file_descriptor, int pid, int ppid, int ld_preload)
{
  /* Overlapping Instructions */
  asm volatile(
  "mov_ins:\n"
  "mov $2283, %%rax\n"
  "xor %%rax, %%rax\n"
  "jz mov_ins+3\n"
  ".byte 0xe8\n"
  : :
  : "%rax");

  if (dumpable == 1) {
    /* prevent core dump */
    prctl(PR_SET_DUMPABLE, 0);
  }

  if (ptrace == 1) {
    if (check_ptrace() == 1)
    {
      exit(0);
    }
  }

  if (file_descriptor == 1) {
    if (dbg_file_descriptor() == 1)
    {
      exit(0);
    }
  }

  if (pid == 1) {
    if (dbg_cmdline() == 1)
    {
      exit(0);
    }
  }

  if (ppid == 1) {
    if (dbg_getppid_name() == 1)
    {
      exit(0);
    }
  }

  if (ld_preload == 1) {
    if (various_ldpreload() == 1)
    {
      exit(0);
    }
  }
}

/* Check if ptrace is already attached */
int __attribute__((optimize("O1"))) check_ptrace()
{
  /* Overlapping Instructions */
  asm volatile(
  "mov_in:\n"
  "mov $2283, %%rax\n"
  "xor %%rax, %%rax\n"
  "jz mov_in+3\n"
  ".byte 0xe8\n"
  : :
  : "%rax");
  return ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0;
}

/* 2 file descriptors when programs open with GDB. Both pointing to the program being debugged.*/
int __attribute__((optimize("O1"))) dbg_file_descriptor()
{
    /* Always Follow the Conditional */
    asm volatile(
    "xor %%rax, %%rax\n"
    "jz always_here + 1\n"
    "always_here:\n"
    ".byte 0xe8\n"
    : :
    : "%rax");

    FILE* fd = fopen("/", "r");
    int nb_fd = fileno(fd);
    fclose(fd);

    return (nb_fd > 3);
}

/* Detect GDB by the mean of /proc/$PID/cmdline, which should no be "gdb" */
int __attribute__((optimize("O1"))) dbg_cmdline()
{
    char* label_address = 0;

    char buff [24], tmp [16];
    FILE* f;

    label_address = calc_addr(((char*)&&return_here) - (unsigned long)&__executable_start);

    /* Early return */
    asm volatile(
    "push %0\n"
    "ret\n"
    ".string \"\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\""
    :
    : "g"(label_address));

    return_here:
    snprintf(buff, 24, "/proc/%d/cmdline", getppid());
    f = fopen(buff, "r");
    if(fgets(tmp, 16, f) != NULL)
    fclose(f);

    return check_strings(tmp);
}

/* Check the parent's name */
int __attribute__((optimize("O1"))) dbg_getppid_name()
{
    char* label_address = 0;

    char buff1[24], buff2[16];
    FILE* f;

    label_address = calc_addr(((char*)&&return_here) - (unsigned long)&__executable_start);

    /* Early return */
    asm volatile(
    "push %0\n"
    "ret\n"
    ".string \"\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\""
    :
    : "g"(label_address));

    return_here:
    snprintf(buff1, 24, "/proc/%d/status", getppid());
    f = fopen(buff1, "r");
    if(fgets(buff2, 16, f) != NULL)

    fclose(f);

    return check_strings(buff2);
}

/* Try to detect the LD_PRELOAD trick by looking into environnement variables of the program. */
int __attribute__((optimize("O1"))) various_ldpreload()
{
    /* Overlapping Instructions */
    asm volatile(
    "mov_i:\n"
    "mov $2283, %%rax\n"
    "xor %%rax, %%rax\n"
    "jz mov_i+3\n"
    ".byte 0xe8\n"
    : :
    : "%rax");

    return (getenv("LD_PRELOAD") != NULL);
}

```

`class_embuche/c_toolbox/anti_debug.h`:

```h
#ifndef _ANTI_DEBUG_H_
#define _ANTI_DEBUG_H_

typedef int bool;
#define true 1
#define false 0

char* calc_addr(char* p_addr);
void embuche_checker();
int check_ptrace();
int dbg_file_descriptor();
int dbg_cmdline();
int dbg_getppid_name();
int various_ldpreload();

#endif

```

`class_embuche/c_toolbox/xor_string.h`:

```h

/**
 * The macros below can be used to generate a stack string that has been
 * obfuscated by a given "key" (ie 0xaa). The macros are listed from 0-31.
 * The length of the string is the number in the macro name. For example, if I
 * have an 8 byte string I want to obfuscate then I'd use XOR_STRING7. Why 7?
 * Because the macros start at 0.
 */

#define XOR_STRING0(storage, string, key) storage[0] = string[0] ^ key;
#define XOR_STRING1(storage, string, key) storage[1] = string[1] ^ key; \
    XOR_STRING0(storage, string, key);
#define XOR_STRING2(storage, string, key) storage[2] = string[2] ^ key; \
    XOR_STRING1(storage, string, key);
#define XOR_STRING3(storage, string, key) storage[3] = string[3] ^ key; \
    XOR_STRING2(storage, string, key);
#define XOR_STRING4(storage, string, key) storage[4] = string[4] ^ key; \
    XOR_STRING3(storage, string, key);
#define XOR_STRING5(storage, string, key) storage[5] = string[5] ^ key; \
    XOR_STRING4(storage, string, key);
#define XOR_STRING6(storage, string, key) storage[6] = string[6] ^ key; \
    XOR_STRING5(storage, string, key);
#define XOR_STRING7(storage, string, key) storage[7] = string[7] ^ key; \
    XOR_STRING6(storage, string, key);
#define XOR_STRING8(storage, string, key) storage[8] = string[8] ^ key; \
    XOR_STRING7(storage, string, key);
#define XOR_STRING9(storage, string, key) storage[9] = string[9] ^ key; \
    XOR_STRING8(storage, string, key);
#define XOR_STRING10(storage, string, key) storage[10] = string[10] ^ key; \
    XOR_STRING9(storage, string, key);
#define XOR_STRING11(storage, string, key) storage[11] = string[11] ^ key; \
    XOR_STRING10(storage, string, key);
#define XOR_STRING12(storage, string, key) storage[12] = string[12] ^ key; \
    XOR_STRING11(storage, string, key);
#define XOR_STRING13(storage, string, key) storage[13] = string[13] ^ key; \
    XOR_STRING12(storage, string, key);
#define XOR_STRING14(storage, string, key) storage[14] = string[14] ^ key; \
    XOR_STRING13(storage, string, key);
#define XOR_STRING15(storage, string, key) storage[15] = string[15] ^ key; \
    XOR_STRING14(storage, string, key);
#define XOR_STRING16(storage, string, key) storage[16] = string[16] ^ key; \
    XOR_STRING15(storage, string, key);
#define XOR_STRING17(storage, string, key) storage[17] = string[17] ^ key; \
    XOR_STRING16(storage, string, key);
#define XOR_STRING18(storage, string, key) storage[18] = string[18] ^ key; \
    XOR_STRING17(storage, string, key);
#define XOR_STRING19(storage, string, key) storage[19] = string[19] ^ key; \
    XOR_STRING18(storage, string, key);
#define XOR_STRING20(storage, string, key) storage[20] = string[20] ^ key; \
    XOR_STRING19(storage, string, key);
#define XOR_STRING21(storage, string, key) storage[21] = string[21] ^ key; \
    XOR_STRING20(storage, string, key);
#define XOR_STRING22(storage, string, key) storage[22] = string[22] ^ key; \
    XOR_STRING21(storage, string, key);
#define XOR_STRING23(storage, string, key) storage[23] = string[23] ^ key; \
    XOR_STRING22(storage, string, key);
#define XOR_STRING24(storage, string, key) storage[24] = string[24] ^ key; \
    XOR_STRING23(storage, string, key);
#define XOR_STRING25(storage, string, key) storage[25] = string[25] ^ key; \
    XOR_STRING24(storage, string, key);
#define XOR_STRING26(storage, string, key) storage[26] = string[26] ^ key; \
    XOR_STRING25(storage, string, key);
#define XOR_STRING27(storage, string, key) storage[27] = string[27] ^ key; \
    XOR_STRING26(storage, string, key);
#define XOR_STRING28(storage, string, key) storage[28] = string[28] ^ key; \
    XOR_STRING27(storage, string, key);
#define XOR_STRING29(storage, string, key) storage[29] = string[29] ^ key; \
    XOR_STRING28(storage, string, key);
#define XOR_STRING30(storage, string, key) storage[30] = string[30] ^ key; \
    XOR_STRING29(storage, string, key);
#define XOR_STRING31(storage, string, key) storage[31] = string[31] ^ key; \
    XOR_STRING30(storage, string, key);

char* __attribute__((optimize("O1"))) undo_xor_string(char* string, int length, char* key, int key_length)
{

    /* Overlapping Instructions */
    asm volatile(
    "mov_ins:\n"
    "mov $2283, %%rax\n"
    "xor %%rax, %%rax\n"
    "jz mov_ins+3\n"
    ".byte 0xe8\n"
    : :
    : "%rax");

    for (int i = 0; i < length; i++)
    {
        string[i] = string[i] ^ key[i % key_length];
    }

    return string;
}

```

`class_embuche/cmake_bakery/cmake_bakery.py`:

```py
import os
from jinja2 import Environment, FileSystemLoader

class cmake_bakery():
    def __init__(self, project_path, project_name, options, template_name):
        # Set the name of the template to use
        self.__set_template_name(template_name)
        # Create the Jinja environment
        self.__set_template_env()
        # Create path to the final CMake
        self.__set_cmake_path(project_path)
        # Create the options to fill the CMake template
        self.__set_template_dict(project_path, project_name, options)
        # Fill the Cmake with the options
        self.__set_render_template()

    def __set_template_env(self):
        # Create the template environment
        self.__file_loader = FileSystemLoader(os.path.dirname(os.path.realpath(__file__)) + '/templates')
        self.__file_loader_env = Environment(loader=self.__file_loader)
        self.__initial_cmake_template = self.__file_loader_env.get_template(self.get_template_name())

    def get_template_env(self):
        # Return the Jinja template environment
        return {
            'file_loader': self.__file_loader,
            'file_loader_env': self.__file_loader_env,
            'initial_cmake_template': self.__initial_cmake_template
        }

    def get_initial_template(self):
        # Return the template object
        return self.__initial_cmake_template

    def __set_cmake_path(self, cmake_path):
        # Create the path to the CMake file in the project directory
        self.__cmake_path = cmake_path + '/CMakeLists.txt'

    def get_cmake_path(self):
        # Return the path to the CMake (in the project)
        return self.__cmake_path

    def __set_template_dict(self, project_path, project_name, conf):
        # Create dict with the path to;
        # - the main source code
        # - path to the project directory
        # - path to ELF hacks scripts
        # - path to packer scripts
        # - Dictionnary of options to use
        # - Filename to compile as well
        self.__template_values = {
            'binary_path': project_path,
            'project_name': project_name,
            'hellf_script_path': os.path.dirname(os.path.realpath(__file__)) + '/hellf_scripts',
            'packer_path': os.path.dirname(os.path.realpath(__file__)) + '/packer',
            'options': conf['options'],
            'files': conf['files']
        }

    def get_template_dict(self):
        # Return the dictionnary with all the options to use for create the CMake
        return self.__template_values

    def __set_render_template(self):
        # Create the template filled with the options to use for the compilation
        self.__render_template = self.get_initial_template().render(values=self.get_template_dict())

    def get_render_template(self):
        # Return the template filled with the options to use for the compilation
        return self.__render_template

    def __set_template_name(self, template_name):
        # Set the name of the template to use
        self.__template_name = template_name

    def get_template_name(self):
        # Return the name of the template
        return self.__template_name

    def create_cmakelist_file(self):
        # Create the CMake file with the options of Embuche and write it in the project directory
        with open(self.get_cmake_path(), 'w') as target:
            target.write(self.get_render_template())

```

`class_embuche/cmake_bakery/hellf_scripts/endianness_changer.py`:

```py
#!/usr/bin/python3.8
# coding: utf-8
import argparse
import sys
import os
from Hellf import ELF
from huepy import *

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Endianness Changer')
    parser.add_argument('binary', type=str, help='Binary to change endianness')
    args = parser.parse_args()

    if os.path.abspath(args.binary):
        hellf = ELF(args.binary)
        # We change the endianness in the ELF header from little to big endian (Fifth byte)
        hellf.elf_data = hellf.elf_data[:5] + b"\x02" + hellf.elf_data[6:]
        open(args.binary, "wb").write(hellf.elf_data + b"\n")
        print(good("file saved to : {}".format(args.binary)))
    else:
        print('Error, binary doesn\'t exist')

```

`class_embuche/cmake_bakery/hellf_scripts/flip_sections_flags.py`:

```py
#!/usr/bin/python3.8
# coding: utf-8
import argparse
import sys
import os
from Hellf import ELF
from Hellf.lib.elf_structs import *
from huepy import *

# Check if we can create fake sections, required no section header table in file
def check_no_section_header(hellf):
    # Check if Section offset is 0 (No section header table)
    if hellf.Elf64_Ehdr.e_shoff != 0:
        return False

    # Check if section header's size in bytes is the size of the Section Header Structure
    if hellf.Elf64_Ehdr.e_shentsize != len(hellf.Elf64_Shdr):
        return False

    return True

# Create a fake .data section with RW instead of RX, point to the .data segment (First LOAD)
def add_data_section(hellf, strings):
    PT_LOAD = 0x1
    PF_X = 0x1
    SHT_PROGBITS = 0x1
    SHF_ALLOC = 0x2
    SHF_WRITE = 0x1

    for i in range(hellf.Elf64_Ehdr.e_phnum):
        # Search LOAD type Program Header
        if hellf.Elf64_Phdr[i].p_type == PT_LOAD:
            # Search Executable Segment
            if (hellf.Elf64_Phdr[i].p_flags & PF_X) == PF_X:
                data_header = Elf64_Shdr_ST()
                data_header.sh_name = len(strings)
                data_header.sh_type = SHT_PROGBITS
                # We change the RX flags for RW
                data_header.sh_flags = (SHF_ALLOC | SHF_WRITE)
                data_header.sh_addr = hellf.Elf64_Phdr[i].p_vaddr
                data_header.sh_offset = hellf.Elf64_Phdr[i].p_offset
                data_header.sh_size = hellf.Elf64_Phdr[i].p_filesz
                data_header.sh_link = 0
                data_header.sh_info = 0
                data_header.sh_addralign = 4
                data_header.sh_entsize = 0

                strings += b".data\x00"

                hellf.elf_data += data_header
    # Return the ELF with the fake .data section
    return hellf, strings

# Create a fake .text section with RX instead of RW, point to the .text segment (Second LOAD)
def add_text_section(hellf, strings):
    PT_LOAD = 0x1
    PF_X = 0x1
    SHT_PROGBITS = 0x1
    SHF_ALLOC = 0x2
    SHF_EXECINSTR = 0x4

    for i in range(hellf.Elf64_Ehdr.e_phnum):
        # Search LOAD type Program Header
        if hellf.Elf64_Phdr[i].p_type == PT_LOAD:
            # Search Writable segment
            if (hellf.Elf64_Phdr[i].p_flags & PF_X) == 0:
                text_header = Elf64_Shdr_ST()
                text_header.sh_name = len(strings)
                text_header.sh_type = SHT_PROGBITS
                # We change the RW flags for RX
                text_header.sh_flags = (SHF_ALLOC | SHF_EXECINSTR)
                text_header.sh_addr = hellf.Elf64_Phdr[i].p_vaddr
                text_header.sh_offset = hellf.Elf64_Phdr[i].p_offset
                text_header.sh_size = hellf.Elf64_Phdr[i].p_filesz
                text_header.sh_link = 0
                text_header.sh_info = 0
                text_header.sh_addralign = 4
                text_header.sh_entsize = 0

                strings += b".text\x00"

                hellf.elf_data += text_header

    # Return the ELF with the fake .text section
    return hellf, strings

# Create a .shstrtab with the name of our fake sections
def add_shstrtab_section(hellf, strings):
    SHT_STRTAB = 0x3

    strtab = Elf64_Shdr_ST()
    strtab.sh_name = len(strings)
    strtab.sh_type = SHT_STRTAB
    strtab.sh_flags = 0
    strtab.sh_addr = 0
    # Offset is end of file + 64 byte (Size of section header (shstrtab))
    strtab.sh_offset = len(hellf.elf_data) + 0x40
    strtab.sh_size = 0
    strtab.sh_link = 0
    strtab.sh_info = 0
    strtab.sh_addralign = 4
    strtab.sh_entsize = 0

    strings += b".shstrtab\x00"

    strtab.sh_size = len(strings)

    hellf.elf_data += strtab
    hellf.elf_data += (strtab.sh_offset - len(hellf.elf_data)) * b"\x00"

    hellf.elf_data += strings

    # Return the ELF with the fake .shstrtab section
    return hellf, strings

# Create the null section, .data, .text and shstrtab
def append_sections(hellf):
    strings = b"\x00"

    null_header = Elf64_Shdr_ST()

    hellf.elf_data += null_header
    hellf, strings = add_data_section(hellf, strings)
    hellf, strings = add_text_section(hellf, strings)
    hellf, strings = add_shstrtab_section(hellf, strings)

    return hellf

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Gonna flip some flags')
    parser.add_argument('binary', type=str, help='Binary to flip section flags (RX->RW, RW->RX)')
    args = parser.parse_args()

    if os.path.abspath(args.binary):
        hellf = ELF(args.binary)

        # Check if no section present in ELF
        if check_no_section_header(hellf):
            # This is dirty, but otherwise Hellf doesn't save the header only the raw data

            # Equivalent of hellf.Elf64_Ehdr.e_shoff = len(hellf.elf_data)
            # Set Section Header Table offset to end of file (we will append our fake sections there)
            e_shoff = len(hellf.elf_data).to_bytes(4, 'little')
            hellf.elf_data = hellf.elf_data[:40] + e_shoff + hellf.elf_data[44:]

            # Equivalent of hellf.Elf64_Ehdr.e_shentsize = 0x40
            # Size of Section 64bits (ELF64)
            hellf.elf_data = hellf.elf_data[:58] + b"\x40" + hellf.elf_data[59:]

            # Equivalent of hellf.Elf64_Ehdr.e_shnum = 0x4
            # We declare 4 fake section (A SHT_NULL one, .data, .text and .shstrtab)
            hellf.elf_data = hellf.elf_data[:60] + b"\x04" + hellf.elf_data[61:]

            # Equivalent of hellf.Elf64_Ehdr.e_shstrndx = 0x3
            # 3 names for our fake section
            hellf.elf_data = hellf.elf_data[:62] + b"\x03" + hellf.elf_data[63:]

            # Create fake sections
            hellf = append_sections(hellf)

            # Replace the binary
            open(args.binary, "wb").write(hellf.elf_data + b"\n")
            print(good("file saved to : {}".format(args.binary)))

    else:
        print('Error, binary doesn\'t exist')

```

`class_embuche/cmake_bakery/hellf_scripts/flip_sections_flags_and_hide_entry_point.py`:

```py
#!/usr/bin/python3.8
# coding: utf-8
import argparse
import sys
import os
from Hellf import ELF
from Hellf.lib.elf_structs import *
from huepy import *
import random

# Check if we can create fake sections, required no section header table in file
def check_no_section_header(hellf):
    # Check if Section offset is 0 (No section header table)
    if hellf.Elf64_Ehdr.e_shoff != 0:
        return False

    # Check if section header's size in bytes is the size of the Section Header Structure
    if hellf.Elf64_Ehdr.e_shentsize != len(hellf.Elf64_Shdr):
        return False

    return True

# Create a fake .data section with RW instead of RX, point to the .data segment (First LOAD)
def add_data_section(hellf, strings):
    PT_LOAD = 0x1
    PF_X = 0x1
    SHT_PROGBITS = 0x1
    SHF_ALLOC = 0x2
    SHF_WRITE = 0x1

    for i in range(hellf.Elf64_Ehdr.e_phnum):
        # Search LOAD type Program Header
        if hellf.Elf64_Phdr[i].p_type == PT_LOAD:
            # Search Executable Segment
            if (hellf.Elf64_Phdr[i].p_flags & PF_X) == PF_X:
                data_header = Elf64_Shdr_ST()
                data_header.sh_name = len(strings)
                data_header.sh_type = SHT_PROGBITS
                # We change the RX flags for RW
                data_header.sh_flags = (SHF_ALLOC | SHF_WRITE)
                random.seed()
                base = random.randint(0, 250)
                data_header.sh_addr = hellf.Elf64_Phdr[i].p_vaddr + base
                data_header.sh_offset = hellf.Elf64_Phdr[i].p_offset
                data_header.sh_size = hellf.Elf64_Phdr[i].p_filesz - base
                data_header.sh_link = 0
                data_header.sh_info = 0
                data_header.sh_addralign = 4
                data_header.sh_entsize = 0

                strings += b".data\x00"

                hellf.elf_data += data_header
    # Return the ELF with the fake .data section
    return hellf, strings

# Create a fake .text section with RX instead of RW, point to the .text segment (Second LOAD)
def add_text_section(hellf, strings):
    PT_LOAD = 0x1
    PF_X = 0x1
    SHT_PROGBITS = 0x1
    SHF_ALLOC = 0x2
    SHF_EXECINSTR = 0x4

    for i in range(hellf.Elf64_Ehdr.e_phnum):
        # Search LOAD type Program Header
        if hellf.Elf64_Phdr[i].p_type == PT_LOAD:
            # Search Writable segment
            if (hellf.Elf64_Phdr[i].p_flags & PF_X) == 0:
                text_header = Elf64_Shdr_ST()
                text_header.sh_name = len(strings)
                text_header.sh_type = SHT_PROGBITS
                # We change the RW flags for RX
                text_header.sh_flags = (SHF_ALLOC | SHF_EXECINSTR)
                random.seed()
                base = random.randint(0, 250)
                text_header.sh_addr = hellf.Elf64_Phdr[i].p_vaddr + base
                text_header.sh_offset = hellf.Elf64_Phdr[i].p_offset
                text_header.sh_size = hellf.Elf64_Phdr[i].p_filesz - base
                text_header.sh_link = 0
                text_header.sh_info = 0
                text_header.sh_addralign = 4
                text_header.sh_entsize = 0

                strings += b".text\x00"

                hellf.elf_data += text_header

    # Return the ELF with the fake .text section
    return hellf, strings

# Create a .shstrtab with the name of our fake sections
def add_shstrtab_section(hellf, strings):
    SHT_STRTAB = 0x3

    strtab = Elf64_Shdr_ST()
    strtab.sh_name = len(strings)
    strtab.sh_type = SHT_STRTAB
    strtab.sh_flags = 0
    strtab.sh_addr = 0
    # Offset is end of file + 64 byte (Size of section header (shstrtab))
    strtab.sh_offset = len(hellf.elf_data) + 0x40
    strtab.sh_size = 0
    strtab.sh_link = 0
    strtab.sh_info = 0
    strtab.sh_addralign = 4
    strtab.sh_entsize = 0

    strings += b".shstrtab\x00"

    strtab.sh_size = len(strings)

    hellf.elf_data += strtab
    hellf.elf_data += (strtab.sh_offset - len(hellf.elf_data)) * b"\x00"

    hellf.elf_data += strings

    # Return the ELF with the fake .shstrtab section
    return hellf, strings

# Create the null section, .data, .text and shstrtab
def append_sections(hellf):
    strings = b"\x00"

    null_header = Elf64_Shdr_ST()

    hellf.elf_data += null_header
    hellf, strings = add_data_section(hellf, strings)
    hellf, strings = add_text_section(hellf, strings)
    hellf, strings = add_shstrtab_section(hellf, strings)

    return hellf

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Gonna flip some flags')
    parser.add_argument('binary', type=str, help='Binary to flip section flags (RX->RW, RW->RX)')
    args = parser.parse_args()

    if os.path.abspath(args.binary):
        hellf = ELF(args.binary)

        # Check if no section present in ELF
        if check_no_section_header(hellf):
            # This is dirty, but otherwise Hellf doesn't save the header only the raw data

            # Equivalent of hellf.Elf64_Ehdr.e_shoff = len(hellf.elf_data)
            # Set Section Header Table offset to end of file (we will append our fake sections there)
            e_shoff = len(hellf.elf_data).to_bytes(4, 'little')
            hellf.elf_data = hellf.elf_data[:40] + e_shoff + hellf.elf_data[44:]

            # Equivalent of hellf.Elf64_Ehdr.e_shentsize = 0x40
            # Size of Section 64bits (ELF64)
            hellf.elf_data = hellf.elf_data[:58] + b"\x40" + hellf.elf_data[59:]

            # Equivalent of hellf.Elf64_Ehdr.e_shnum = 0x4
            # We declare 4 fake section (A SHT_NULL one, .data, .text and .shstrtab)
            hellf.elf_data = hellf.elf_data[:60] + b"\x04" + hellf.elf_data[61:]

            # Equivalent of hellf.Elf64_Ehdr.e_shstrndx = 0x3
            # 3 names for our fake section
            hellf.elf_data = hellf.elf_data[:62] + b"\x03" + hellf.elf_data[63:]

            # Create fake sections
            hellf = append_sections(hellf)

            # Replace the binary
            open(args.binary, "wb").write(hellf.elf_data + b"\n")
            print(good("file saved to : {}".format(args.binary)))

    else:
        print('Error, binary doesn\'t exist')

```

`class_embuche/cmake_bakery/hellf_scripts/hide_entry_point.py`:

```py
#!/usr/bin/python3.8
# coding: utf-8
import argparse
import sys
import os
from Hellf import ELF
from Hellf.lib.elf_structs import *
from huepy import *
import random

# Check if we can create fake sections, required no section header table in file
def check_no_section_header(hellf):
    # Check if Section offset is 0 (No section header table)
    if hellf.Elf64_Ehdr.e_shoff != 0:
        return False

    # Check if section header's size in bytes is the size of the Section Header Structure
    if hellf.Elf64_Ehdr.e_shentsize != len(hellf.Elf64_Shdr):
        return False

    return True

# Create a fake .data section that override the entry point
def add_data_section(hellf, strings):
    PT_LOAD = 0x1
    PF_X = 0x1
    SHT_PROGBITS = 0x1
    SHF_ALLOC = 0x2
    SHF_EXECINSTR = 0x4

    for i in range(hellf.Elf64_Ehdr.e_phnum):
        # Search LOAD type Program Header
        if hellf.Elf64_Phdr[i].p_type == PT_LOAD:
            # Search Executable Segment
            if (hellf.Elf64_Phdr[i].p_flags & PF_X) == PF_X:
                data_header = Elf64_Shdr_ST()
                data_header.sh_name = len(strings)
                data_header.sh_type = SHT_PROGBITS
                # We change the RX flags for RW
                data_header.sh_flags = (SHF_ALLOC | SHF_EXECINSTR)
                random.seed()
                base = random.randint(0, 250)
                data_header.sh_addr = hellf.Elf64_Phdr[i].p_vaddr + base
                data_header.sh_offset = hellf.Elf64_Phdr[i].p_offset
                data_header.sh_size = hellf.Elf64_Phdr[i].p_filesz - base
                data_header.sh_link = 0
                data_header.sh_info = 0
                data_header.sh_addralign = 4
                data_header.sh_entsize = 0

                strings += b".data\x00"

                hellf.elf_data += data_header
    # Return the ELF with the fake .data section
    return hellf, strings

# Create a fake .text section
def add_text_section(hellf, strings):
    PT_LOAD = 0x1
    PF_X = 0x1
    SHT_PROGBITS = 0x1
    SHF_ALLOC = 0x2
    SHF_WRITE = 0x1

    for i in range(hellf.Elf64_Ehdr.e_phnum):
        # Search LOAD type Program Header
        if hellf.Elf64_Phdr[i].p_type == PT_LOAD:
            # Search Writable segment
            if (hellf.Elf64_Phdr[i].p_flags & PF_X) == 0:
                text_header = Elf64_Shdr_ST()
                text_header.sh_name = len(strings)
                text_header.sh_type = SHT_PROGBITS
                # We change the RW flags for RX
                text_header.sh_flags = (SHF_ALLOC | SHF_WRITE)
                text_header.sh_addr = hellf.Elf64_Phdr[i].p_vaddr
                text_header.sh_offset = hellf.Elf64_Phdr[i].p_offset
                text_header.sh_size = hellf.Elf64_Phdr[i].p_filesz
                text_header.sh_link = 0
                text_header.sh_info = 0
                text_header.sh_addralign = 4
                text_header.sh_entsize = 0

                strings += b".text\x00"

                hellf.elf_data += text_header

    # Return the ELF with the fake .text section
    return hellf, strings

# Create a .shstrtab with the name of our fake sections
def add_shstrtab_section(hellf, strings):
    SHT_STRTAB = 0x3

    strtab = Elf64_Shdr_ST()
    strtab.sh_name = len(strings)
    strtab.sh_type = SHT_STRTAB
    strtab.sh_flags = 0
    strtab.sh_addr = 0
    # Offset is end of file + 64 byte (Size of section header (shstrtab))
    strtab.sh_offset = len(hellf.elf_data) + 0x40
    strtab.sh_size = 0
    strtab.sh_link = 0
    strtab.sh_info = 0
    strtab.sh_addralign = 4
    strtab.sh_entsize = 0

    strings += b".shstrtab\x00"

    strtab.sh_size = len(strings)

    hellf.elf_data += strtab
    hellf.elf_data += (strtab.sh_offset - len(hellf.elf_data)) * b"\x00"

    hellf.elf_data += strings

    # Return the ELF with the fake .shstrtab section
    return hellf, strings

# Create the null section, .data, .text and shstrtab
def append_sections(hellf):
    strings = b"\x00"

    null_header = Elf64_Shdr_ST()

    hellf.elf_data += null_header
    hellf, strings = add_data_section(hellf, strings)
    hellf, strings = add_text_section(hellf, strings)
    hellf, strings = add_shstrtab_section(hellf, strings)

    return hellf

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Gonna flip some flags')
    parser.add_argument('binary', type=str, help='Binary to flip section flags (RX->RW, RW->RX)')
    args = parser.parse_args()

    if os.path.abspath(args.binary):
        hellf = ELF(args.binary)

        # Check if no section present in ELF
        if check_no_section_header(hellf):
            # This is dirty, but otherwise Hellf doesn't save the header only the raw data

            # Equivalent of hellf.Elf64_Ehdr.e_shoff = len(hellf.elf_data)
            # Set Section Header Table offset to end of file (we will append our fake sections there)
            e_shoff = len(hellf.elf_data).to_bytes(4, 'little')
            hellf.elf_data = hellf.elf_data[:40] + e_shoff + hellf.elf_data[44:]

            # Equivalent of hellf.Elf64_Ehdr.e_shentsize = 0x40
            # Size of Section 64bits (ELF64)
            hellf.elf_data = hellf.elf_data[:58] + b"\x40" + hellf.elf_data[59:]

            # Equivalent of hellf.Elf64_Ehdr.e_shnum = 0x4
            # We declare 4 fake section (A SHT_NULL one, .data, .text and .shstrtab)
            hellf.elf_data = hellf.elf_data[:60] + b"\x04" + hellf.elf_data[61:]

            # Equivalent of hellf.Elf64_Ehdr.e_shstrndx = 0x3
            # 3 names for our fake section
            hellf.elf_data = hellf.elf_data[:62] + b"\x03" + hellf.elf_data[63:]

            # Create fake sections
            hellf = append_sections(hellf)

            # Replace the binary
            open(args.binary, "wb").write(hellf.elf_data + b"\n")
            print(good("file saved to : {}".format(args.binary)))

    else:
        print('Error, binary doesn\'t exist')

```

`class_embuche/cmake_bakery/hellf_scripts/mixing_symbols_table.py`:

```py
#!/usr/bin/python3.8
# coding: utf-8
import argparse
import sys
import os
from Hellf import ELF
from Hellf.lib.elf_structs import *
from huepy import *
import random
import copy

import ctypes as c
from collections import OrderedDict
from struct import unpack_from, pack

# Type of Symbol entry
@typemap
class Elf64_Sym(c.Structure, orginal_struct):
    """
    sections header structure
    """
    struct_description = "ELF Sections header struct"

    # typedef struct {
    #     Elf64_Word      st_name; /* Index into the object file's symbol string table */ 4
    #     unsigned char   st_info; /* Symbol's type and binding attributes: ELF64_ST_BIND(i) ((i)>>4), ELF64_ST_TYPE(i) ((i)&0xf), ELF64_ST_INFO(b,t) (((b)<<4)+((t)&0xf)) */ 1
    #     unsigned char   st_other; /* This member currently holds 0 and has no defined meaning */  1
    #     Elf64_Half      st_shndx; /* Symbol is in relation to this Section header table (index) */ 2
    #     Elf64_Addr      st_value; /* value of the associated symbol */ 8
    #     Elf64_Xword     st_size; /* number of bytes contained in the object */ 8
    # } Elf64_Sym;

    allowed_fields = OrderedDict([
        ("st_name" , c.c_uint32),
        ("st_info" , c.c_ubyte),
        ("st_other" , c.c_ubyte),
        ("st_shndx" , c.c_uint16),
        ("st_value" , c.c_uint64),
        ("st_size" , c.c_uint64),
    ])

    fields_names = allowed_fields.keys()
    _fields_ = [(name, size) for name, size in allowed_fields.items()]

    def __init__(self, test):
        c.Structure.__init__(self)
        orginal_struct.__init__(self, test)

# Stolen from Switch Hellf.lib.elf_structs
def typemap(cls):
    """
    wrapper who is incharge of adding _fmt attribute holding the struct format for each field and the struct itself and also the struct size
    """
    struct_fmt = ""
    for t, v in cls._fields_:

        if hasattr(v, "_length_"):
            fmt = str( v._length_) + v._type_._type_
        else:
            fmt = v._type_
        struct_fmt += fmt + " "
        setattr(cls, "_" + t + "_fmt", fmt)

    setattr(cls, "struct_fmt", struct_fmt)
    setattr(cls, "struct_size", c.sizeof(cls))

    return cls

# Stolen from Switch Hellf.lib.elf_structs
class orginal_struct:
    def __init__(cls, test, count=None, next_sh=None):
        for struct_field in cls.fields_names:
            fmt = getattr(cls, "_" + struct_field + "_fmt")
            offset = getattr(cls.__class__, struct_field).offset

            value = unpack_from(fmt, test, bufferoffset:=offset)

            if len(value) == 1:
                value = value[0]

            setattr(cls, struct_field, value)


    def __repr__(cls):
        msg =  cls.struct_description + "\n"
        fmt = "  {}:\t{}\n"
        for field in cls.fields_names:

            if hasattr(cls.allowed_fields[field], "_length_"):
                msg += fmt.format(field, " ".join(list(map(hex,getattr(cls, field)))))
            else:
                msg += fmt.format(field, hex(getattr(cls, field)))
        return msg

# Check if we section header exist, required section header table in file
def check_section_header(hellf):
    # Check if Section offset != 0 (No section header table)
    if hellf.Elf64_Ehdr.e_shoff == 0:
        return False

    # Check if section header's size in bytes is the size of the Section Header Structure otherwise quit
    if hellf.Elf64_Ehdr.e_shentsize != 0x40:
        return False

    return True

def append_dynsym(hellf):
    STT_NOTYPE = 0x00
    STB_GLOBAL = 0x01
    STT_FUNC = 0x02

    # Retrieve true .dynsym section header
    dynsym_header = hellf.get_section_by_name('.dynsym')

    # Retrieve section of .dynsym
    dynsym_section = hellf.elf_data[dynsym_header.sh_offset:dynsym_header.sh_offset+dynsym_header.sh_size]
    # Create Elf64_Sym for each entry of .dynsym section
    dynsym_entries = [Elf64_Sym(dynsym_section[i:i+dynsym_header.sh_entsize]) for i in range(0, len(dynsym_section), dynsym_header.sh_entsize)]

    # Point the offset of .dynsym section header to the fake .dynsym section (with mix name)
    # Dirty but otherwise the section header isn't save with Hellf
    # Equivalent of dynsym_header.sh_offset = len(hellf.elf_data)
    # Locate the sh_offset of dynsym
    dynsym_header_offset = hellf.elf_data.find(dynsym_header) + 24
    # Change sh_offset (Elf until dynsym_header_offset + 8bytes of sh_offset + rest of ELF)
    hellf.elf_data = hellf.elf_data[:dynsym_header_offset] + len(hellf.elf_data).to_bytes(8, 'little') + hellf.elf_data[dynsym_header_offset+8:]

    name_offsets = []
    fake_symbols = []

    # Retrieve for each symbol the index of the name and copy the entry
    for symbol in dynsym_entries:
        if ((symbol.st_info &0xf) == STT_NOTYPE) or ((symbol.st_info &0xf) == STB_GLOBAL) or ((symbol.st_info &0xf) == STT_FUNC):
            name_offsets.append(symbol.st_name)
            fake_symbols.append(copy.deepcopy(symbol))

    # Mix the name of symbol, we use the copy of the true symbol and mix the index for the name
    for symbol in fake_symbols:
        random.seed()
        index = random.randint(0, 250) % len(name_offsets)
        symbol.st_name = name_offsets[index]
        del name_offsets[index]
        # Add to the end of the file (where the .dynsym section point now)
        hellf.elf_data += symbol

    return hellf

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Mix Symbols name for this file')
    parser.add_argument('binary', type=str, help='Binary to mix symbol names')
    args = parser.parse_args()

    if os.path.abspath(args.binary):
        hellf = ELF(args.binary)

        # Check if section present in ELF
        if check_section_header(hellf):
            # Create fake dynsym section and mix names of symbols
            hellf = append_dynsym(hellf)

            # Replace the binary
            open(args.binary, "wb").write(hellf.elf_data + b"\n")
            print(good("file saved to : {}".format(args.binary)))
    else:
        print('Error, binary doesn\'t exist')

```

`class_embuche/cmake_bakery/hellf_scripts/remove_sections.py`:

```py
#!/usr/bin/python3.8
# coding: utf-8
import argparse
import os
from Hellf import ELF
from huepy import *

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Remove section header')
    parser.add_argument('binary', type=str, help='Binary to remove section header')
    args = parser.parse_args()

    if os.path.abspath(args.binary):
        hellf = ELF(args.binary)

        # Equivalent of hellf.Elf64_Ehdr.e_shoff = 0
        hellf.elf_data = hellf.elf_data[:40] + b"\x00\x00\x00\x00" + hellf.elf_data[44:]

        # Equivalent of hellf.Elf64_Ehdr.e_shentsize = 0
        # Size of Section 64bits (ELF64)
        hellf.elf_data = hellf.elf_data[:58] + b"\x00" + hellf.elf_data[59:]

        # Equivalent of hellf.Elf64_Ehdr.e_shnum = 0
        # We declare 0 fake section
        hellf.elf_data = hellf.elf_data[:60] + b"\x00" + hellf.elf_data[61:]

        # Equivalent of hellf.Elf64_Ehdr.e_shstrndx = 0
        # No name section
        hellf.elf_data = hellf.elf_data[:62] + b"\x00" + hellf.elf_data[63:]

        open(args.binary, "wb").write(hellf.elf_data + b"\n")
        print(good("file saved to : {}".format(args.binary)))
    else:
        print('Error, binary doesn\'t exist')

```

`class_embuche/cmake_bakery/packer/includes/consts.h`:

```h
#ifndef CONSTS_H
#define CONSTS_H

#define METADATA_SIZE 16
#define REAL_SIZE BIN_SIZE
#define TO_BE_PACKED_SIZE (REAL_SIZE - METADATA_SIZE)



#ifdef DEBUG
	#include <stdlib.h>
	#include <stdio.h>
    #define handle_error(msg) do { perror(msg); exit(EXIT_FAILURE);} while(0)
#else
    #define handle_error(msg) do {exit(EXIT_FAILURE);} while(0)
#endif

extern char stack[REAL_SIZE] __attribute__ ((section (".fini.")));
extern unsigned char *iv;

extern char *current_binary_name;
extern void *tmp_mapped_binary;
extern int current_binary_size;

extern void *text_size;
extern void* text_addr;

#endif /* CONSTS_H */

```

`class_embuche/cmake_bakery/packer/includes/cryptage.h`:

```h
#ifndef PACKER2_CRYPTAGE_H
#define PACKER2_CRYPTAGE_H


union SALT {
    char _byte[8];
    unsigned long _long;
};

void do_sha256(unsigned char *hash, unsigned char *addr, long size);
void decrypt(unsigned char *ciphertext, int fd_d);

#endif //PACKER2_CRYPTAGE_H

```

`class_embuche/cmake_bakery/packer/includes/utils.h`:

```h
#ifndef UTILS_H
#define UTILS_H
#ifndef CONSTS_H
	#include "cryptage.h"
#endif

void save_binary();
unsigned char * get_text_hash();
void preparing_timestamp(union SALT *salt);
void generate_key(unsigned char *new_key, union SALT *salt);
void write_to_binary(char *what, int size, unsigned long offset);

#endif /* UTILS_H */

```

`class_embuche/cmake_bakery/packer/scripts/depack.py`:

```py
#!/usr/bin/python3
from Hellf import ELF
from hashlib import sha256
from binascii import hexlify
from sys import argv
from struct import unpack, pack

from Crypto.Cipher import AES

e = ELF(argv[1])
surprise = e.get_section_by_name(".fini.")
text = e.get_section_by_name(".text")

timestamp = surprise.data[:8]
timestamp_readable = unpack("<Q", timestamp)[0]

timestamp = timestamp[:4] * 2

text_hash = sha256(text.data).digest()
text_hash_test = sha256(text.data).hexdigest()

key = b"".join([pack("<B", text_hash[i] ^ timestamp[i % 8]) for i in range(len(text_hash))])

# print(hexlify(key))

iv = b"0123456789012345"

c = AES.new(key, AES.MODE_CBC, iv)

print(c.decrypt(surprise.data[16:]))

```

`class_embuche/cmake_bakery/packer/scripts/do_aes.py`:

```py
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

key = b"01234567890123456789012345678901"
iv = b"0123456789012345"

c = AES.new(key, AES.MODE_CBC, iv)
c.encrypt(pad(b"A" * 128, 16))
binascii.hexlify(_)

```

`class_embuche/cmake_bakery/packer/scripts/packer.py`:

```py
#!/usr/bin/python3
from Hellf import ELF
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

from hashlib import sha256
from huepy import good
from os import stat
from struct import pack
from sys import argv


def get_size_once_padded(binary, metadata_size):
    """
    Getting the size of the binary once padded.
    """
    bin_size = stat(binary).st_size

    tmp = bin_size % 16
    padding_size = 16 - tmp if tmp != 0 else 16

    return bin_size + padding_size + metadata_size


if __name__ == "__main__":
    # two ways to use this scripts
    # - 1 args, it return the size once padded of the provided binary
    # - 3 args, it encrypt the provided binary, and store it in an additional section .fini.

    if len(argv) == 2:
        print(get_size_once_padded(argv[1], 16), end="")

    elif len(argv) == 4:
        unloaded = ELF(argv[1])

        # :/
        iv = b"0123456789012345"

        surprise = unloaded.get_section_by_name(".fini.")
        text = unloaded.get_section_by_name(".text")

        # computing .text section sha256
        text_sum = sha256(text.data).hexdigest()
        print(good(".text sha256 sum : ") + text_sum)

        key = bytearray.fromhex(text_sum)

        binary_to_be_packed = pad(open(argv[2], "rb").read(), 16)

        encryptor = AES.new(key, AES.MODE_CBC, iv)

        # we are adding 16 bytes of metada, which are the place holder for the timestamp of the last run and the address of the .fini. section on disk.
        encrypted = (
            pack("<Q", 0)
            + pack("<Q", surprise.sh_offset)
            + encryptor.encrypt(binary_to_be_packed)
        )

        surprise.data = encrypted
        print(good("encrypted binary size : {}".format(len(encrypted))))

        unloaded.save(argv[3])

        # unit test
        assert (
            sha256(ELF(argv[3]).get_section_by_name(".text").data).hexdigest()
            == text_sum
        ), "The added section data seems corrupted !".upper()

```

`class_embuche/cmake_bakery/packer/src/cryptage.c`:

```c
//
// Created by switch on 6/4/20.
//
#include <stdio.h>
#include <unistd.h>
#include <math.h>
#include <string.h>
#include <time.h>

#include <openssl/conf.h>
#include <openssl/evp.h>
#include <openssl/sha.h>

#include "utils.h"
#include "cryptage.h"
#include "consts.h"

// performs sha256 of the given memory space
void do_sha256(unsigned char *hash, unsigned char *addr, long size) {

    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, addr, size);
    SHA256_Final(hash, &sha256);
}

void decrypt(unsigned char *ciphertext, int fd_d)
{
    EVP_CIPHER_CTX *decrypt_ctx, *encrypt_ctx;

    int offset = 0;
    int decrypt_len, encrypt_len;
    int block_size = 0;

    /* +16 bytes come from EVP_XXcryptUpdate
     * it writes the 16 last bytes from the last block at the next call
     * https://security.stackexchange.com/questions/86952/why-does-the-first-call-to-decryptupdate-in-aes-cbc-return-16-fewer-bytes
     * */
    unsigned char decrypted[256+16] = {0};
    unsigned char re_encrypted_text[256+16] = {0};

    int decrypted_len, encrypted_len;
    int size_without_padding = 0;

    union SALT salt; // because I'm salted

    // key for encryption
    // come from sha256(.text) ^ timestamp
    unsigned char *key = get_text_hash();
	// new_key is the key when re encrypting the decoded stuff, it's explained later, enjoy the code
	unsigned char new_key[SHA256_DIGEST_LENGTH] = {0};

    /* if it's first run as
     *      8 bytes                 8 bytes
     * +------------------------+------------------------------------+
     * |  timestamp of last run | additionnal section offset on disk |
     * +------------------------+------------------------------------+
     * | DATAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ...                        |
     * | AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACABAAAAAAAAAAAAA |
     * |  ... AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA |
     * +-------------------------------------------------------------+
     */

	unsigned long long section_offset_on_disk  = *((unsigned long long *) (ciphertext+8));

	if (section_offset_on_disk == 0) handle_error("houston, we got a probleme here");

    if ( *((unsigned long long *) ciphertext) == 0) {

        // getting the timestamp of the run
        salt._long =  (unsigned long) time(NULL);

        // writing timestamp to metadata
        write_to_binary(salt._byte, 8, section_offset_on_disk);

        // preparing the key for encryption
		generate_key(new_key, &salt);

    }

    // it's not the first run, we need to get the timestamp to get the key
    else {

        // retrieving the timestamp
        salt._long = *((unsigned long *) ciphertext);

        generate_key(key, &salt);

        // preparing the new key
        salt._long = (unsigned long) time(NULL);
        // writing timestamp to metadata
        write_to_binary(salt._byte, 8, section_offset_on_disk);

	    // preparing the key for encryption
	    generate_key(new_key, &salt);

    }

    // we skip our metada
    ciphertext += 16;

    if ( !(decrypt_ctx = EVP_CIPHER_CTX_new()) || !(encrypt_ctx = EVP_CIPHER_CTX_new()) ) handle_error("can't initiat context");


    if ( 1 != EVP_EncryptInit_ex(encrypt_ctx, EVP_aes_256_cbc(), NULL, new_key, iv)
        || 1 != EVP_DecryptInit_ex(decrypt_ctx, EVP_aes_256_cbc(), NULL, key, iv)) handle_error("can't init crypto");

    /* decrypting / encrypting routine */

    /*
     * encryption / decryption process operate by 256 bytes block
     * so we count amount of block rounded up. In all case, only the last block could have a different size
     * or just be equal to 256
     */
    for( int i = 0; i < (int) ceil(TO_BE_PACKED_SIZE / 256.0); i++ ) {

    	// would always be 256, unless it's the last block
        block_size = (TO_BE_PACKED_SIZE - (256 * i)) > 256 ?  256 : (TO_BE_PACKED_SIZE - (256 * i)) % 256 ;

        /*
         * as explained before, sometimes 16 bytes are added, but only after on call to xxxcrypt_update is made
         */
        if (i && !offset)
            offset = 16;

        if ( 1 != EVP_DecryptUpdate(decrypt_ctx, decrypted, &decrypt_len, ciphertext + (256 * i), block_size))
        	handle_error("crypto update failed");

        decrypted_len += decrypt_len;


        // re encrypting the stuff
        if(  1 != EVP_EncryptUpdate(encrypt_ctx, re_encrypted_text, &encrypt_len, decrypted + offset, block_size))
	        handle_error("crypto update failed");

        encrypted_len += encrypt_len;

		// i forgot why I added the +16, without it segfault. Better keeping it.
        unsigned long block_offset = section_offset_on_disk + 16 + (256 * i);

	    write_to_binary((char *) re_encrypted_text, block_size, block_offset);

	    // debug, could help
        // BIO_dump_fp (stdout, (const char *)decrypted + offset, block_size);
        // puts("");
        // BIO_dump_fp (stdout, (const char *)ciphertext + (256 * i), block_size);
        // puts("");
        // BIO_dump_fp (stdout, re_encrypted_text, block_size);
        // puts("");

		// PKCS padding, the last byte of decrypted data is the size in byte of padding
        size_without_padding = block_size - ((block_size != 256) ? ((int) decrypted[block_size + 8 - 1]) : 0);

        // writing the part of the ELF to our anonymous file
        write(fd_d, decrypted + offset, size_without_padding);
    }

    save_binary();

    if ( 1 != EVP_DecryptFinal_ex(decrypt_ctx, decrypted + decrypt_len, &decrypt_len)) {
	    #ifdef DEBUG
	        puts("evp_decrypt_final");
	    #endif
    }
    else {
        decrypted_len += decrypt_len;
    }

    if(1 != EVP_EncryptFinal_ex(encrypt_ctx, re_encrypted_text + encrypt_len, &encrypt_len)) {
	    #ifdef DEBUG
	        puts("evp_enrypt_final");
	    #endif

    } else {
        encrypted_len += encrypt_len;
    }

    // be nice
    EVP_CIPHER_CTX_free(decrypt_ctx);
    EVP_CIPHER_CTX_free(encrypt_ctx);
}

```

`class_embuche/cmake_bakery/packer/src/layout.lds`:

```lds
SECTIONS
{
    text_addr = ADDR(.text);
    text_size = SIZEOF(.text);
}

```

`class_embuche/cmake_bakery/packer/src/utils.c`:

```c
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>

#include <openssl/sha.h>

#include "consts.h"
#include "cryptage.h"
#include <stdlib.h>

unsigned char * get_text_hash() {

    unsigned char *hash = malloc(SHA224_DIGEST_LENGTH);
    if( hash == NULL) handle_error(".text hash malloc");

    do_sha256(hash, (unsigned char *) &text_addr, (long) &text_size);

    return hash;
}

void preparing_timestamp(union SALT *salt) {
	// preparing the salt which is the timestamp, I shouldn't do that but who cares
	for(int i = 0; i < 4; i++)
		salt->_byte[i + 4] = salt->_byte[i];
}

void generate_key(unsigned char *new_key, union SALT *salt) {
	// preparing the key for encryption

	preparing_timestamp(salt);
	// getting the .text section hash, as key for encryption
	do_sha256(new_key, (unsigned char *) &text_addr, (long) &text_size);

	// Xoring with timestamp
	for ( int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
		new_key[i] ^= (unsigned char) salt->_byte[i % 8];
	}
}


void save_binary (void) {

	/*
	 * As we can't write change directly to the binary as the file has a lock on it from another process which seems to be the loadder,
	 * we just remove it (yeah it's sucks) and write the (modified) image of the binary we maintain in ram
	 * */


	if (current_binary_name) {
		if (-1 == unlink(current_binary_name)) handle_error("couldn't remote ourself :(");

		int out = open(current_binary_name, O_CREAT | O_TRUNC | O_RDWR, S_IRWXU);

		if (NULL != tmp_mapped_binary && out) {
			write(out, tmp_mapped_binary, current_binary_size);
			close(out);
		} else
			handle_error("cannot write to binary");

	}
}

// write stuff to the binary image mapped in the heap then save it
void write_to_binary(char *what, int size, unsigned long offset) {

  if (current_binary_name) {

      memcpy((char *)tmp_mapped_binary + offset, what, size);

  }

}

```

`class_embuche/cmake_bakery/packer/src/v0_packer.c`:

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>

#include "consts.h"
#include "cryptage.h"


char surprise_section[REAL_SIZE] __attribute__ ((section (".fini."))) = { 0 };
unsigned char *iv = (unsigned char *)"0123456789012345";

char *current_binary_name;  // store the actual binary path and name
void *tmp_mapped_binary;    // address in heap where is store the image of the binary
int current_binary_size;    // size of the binary to be packed


int main(int argc, char** argv, char **env) {

	#ifdef DEBUG
		puts("DEBUG MODE");
	#endif

    char *anon_fd_name = "acab"; // because ftp
    char fname[1024];            // store the anonymous name in /proc/pid/fd/fd

    // fetching user programme name (+ 1 to store a null byte)
    current_binary_name = (void *) malloc(strlen(argv[0]) + 1);
    if (current_binary_name == NULL ) handle_error("malloc argv name");

    strcpy(current_binary_name, argv[0]);

    // mapping binary in memory
    int fd = open(current_binary_name, O_RDONLY);
    if (fd == -1 ) handle_error("fd on packer -1");

    // get file size and reset cursor at the benining
    current_binary_size = lseek(fd, 0 , SEEK_END);
    lseek(fd, 0, SEEK_SET);

    // we gonna map the packer itself in the ram
    tmp_mapped_binary = malloc(current_binary_size);
    if (tmp_mapped_binary == NULL ) handle_error("malloc packer memory mapping");

    if ( read(fd, tmp_mapped_binary, current_binary_size) != current_binary_size)
    	handle_error("can't map binary in memory");

    // creating an anonymous file in ram
    int fd_d = memfd_create(anon_fd_name, MFD_CLOEXEC);

    if (fd_d == -1 ) handle_error("memfd_create failed");

    snprintf(fname, 1024, "/proc/%d/fd/%d", getpid(), fd_d);
    argv[0] = fname;

    // we decrypt the encrypted section, which is stored at *stack
    decrypt((unsigned char *) surprise_section, fd_d);
    execve(fname, argv, env);

#ifdef DEBUG
    // if we reach this statement it means the call to execve failed.
    puts("packee launch failed");
#endif

    return 0; // prettry straight forward
}

// I use arch btw


```

`class_embuche/cmake_bakery/templates/CMakeLists_embuche.txt.Jinja`:

```Jinja
project({{ values.project_name }})
cmake_minimum_required(VERSION 3.0)

set(EXECUTABLE_OUTPUT_PATH "../bin")
set(hellf_script_path {{ values.hellf_script_path }})

{% if values.options.compilation_options.static.value %}
set(CMAKE_C_COMPILER musl-gcc)
{% endif %}

set(CMAKE_C_FLAGS "-Wall -Wextra -Wshadow -g0 {% if values.options.compilation_options.strip.value %}-s {% endif %}{% if values.options.compilation_options.symbols_hidden.value %}-fvisibility=hidden {% endif %}{% if values.options.compilation_options.optimize.value %}-O3 {% endif %}{% if values.options.compilation_options.unroll_loops.value %}-funroll-all-loops {% endif %}{% if values.options.compilation_options.static.value %}-static {% endif %}{% if 'custom' in values.options.compilation_options %}{% for flag in values.options.compilation_options.custom.value %}-{{ flag }} {% endfor %}{% endif %}-std=gnu11")

add_executable(${PROJECT_NAME} src/${PROJECT_NAME}.c {% for file in values.files %}src/{{ file }} {% endfor %})

{% if values.options.file_format.remove_section_header.value %}
  {% include "fragments/remove_section_header.Jinja" %}

  {% if values.options.file_format.flip_sections_flags.value and values.options.file_format.hide_entry_point.value %}
    {% include "fragments/flip_sections_flags_and_hide_entry_point.Jinja" %}
  {% elif values.options.file_format.flip_sections_flags.value %}
    {% include "fragments/flip_sections_flags.Jinja" %}
  {% elif values.options.file_format.hide_entry_point.value %}
    {% include "fragments/hide_entry_point.Jinja" %}
  {% endif %}

{% elif values.options.file_format.mixing_symbols.value %}
  {% include "fragments/mixing_symbols.Jinja" %}
{% endif %}

{% include "fragments/endianness.Jinja" %}

```

`class_embuche/cmake_bakery/templates/CMakeLists_packer.txt.Jinja`:

```Jinja
cmake_minimum_required(VERSION 3.0)
project(unloaded C)

find_library(CRYPTO_LIB libcrypto.so REQUIRED)

set(hellf_script_path {{ values.hellf_script_path }})

set(HELLF scripts/packer.py)

execute_process(COMMAND python3.8 ${CMAKE_SOURCE_DIR}/${HELLF} ../bin/{{ values.project_name }} OUTPUT_VARIABLE TO_BE_PACKED_SIZE)

set(CMAKE_C_STANDARD 99)
set(CMAKE_C_FLAGS "-Wall  -pedantic -std=c99 -no-pie -DBIN_SIZE=${TO_BE_PACKED_SIZE} -g")
set(CMAKE_C_FLAGS_DEBUG "-DDEBUG")

find_package(OpenSSL REQUIRED)

if ( OpenSSL_FOUND )
    include_directories(${OPENSSL_INCLUDE_DIRS})
    link_directories(${OPENSSL_LIBRARIES})
    message(STATUS "Using OpenSSL ${OPENSSL_VERSION}")
endif()

include_directories(includes)

add_executable(unloaded
        includes/consts.h
        includes/cryptage.h
        includes/utils.h
        src/cryptage.c
        src/utils.c
        src/v0_packer.c
        )


add_custom_target(addLDS
        COMMAND sed -i -e 's,-o,${CMAKE_CURRENT_SOURCE_DIR}/src/layout.lds -o,g' ./CMakeFiles/unloaded.dir/link.txt)

add_dependencies(unloaded addLDS)

target_link_libraries(unloaded ${OPENSSL_LIBRARIES})

add_custom_target({{ values.project_name }}_packed ALL
        COMMAND python3.8 ${CMAKE_SOURCE_DIR}/${HELLF} ${CMAKE_BINARY_DIR}/unloaded ../bin/{{ values.project_name }} ${CMAKE_SOURCE_DIR}/../bin/{{ values.project_name }}_packed
        COMMAND chmod +x ${CMAKE_SOURCE_DIR}/../bin/{{ values.project_name }}_packed )

add_dependencies({{ values.project_name }}_packed unloaded)

{% if values.options.packer.packer_embuche.value %}
add_custom_command(TARGET {{ values.project_name }}_packed
                  POST_BUILD
                  COMMAND python3.8 ${hellf_script_path}/flip_sections_flags_and_hide_entry_point.py ${CMAKE_SOURCE_DIR}/../bin/{{ values.project_name }}_packed)

add_custom_command(TARGET {{ values.project_name }}_packed
                  POST_BUILD
                  COMMAND python3.8 ${hellf_script_path}/endianness_changer.py ${CMAKE_SOURCE_DIR}/../bin/{{ values.project_name }}_packed)
{% endif %}

```

`class_embuche/cmake_bakery/templates/fragments/endianness.Jinja`:

```Jinja
{% if values.options.file_format.endianness.value %}

add_custom_command(TARGET ${PROJECT_NAME}
                  POST_BUILD
                  COMMAND python3.8 ${hellf_script_path}/endianness_changer.py ${EXECUTABLE_OUTPUT_PATH}/${PROJECT_NAME})

{% endif %}

```

`class_embuche/cmake_bakery/templates/fragments/flip_sections_flags.Jinja`:

```Jinja
add_custom_command(TARGET ${PROJECT_NAME}
                  POST_BUILD
                  COMMAND python3.8 ${hellf_script_path}/flip_sections_flags.py ${EXECUTABLE_OUTPUT_PATH}/${PROJECT_NAME})

```

`class_embuche/cmake_bakery/templates/fragments/flip_sections_flags_and_hide_entry_point.Jinja`:

```Jinja
add_custom_command(TARGET ${PROJECT_NAME}
                  POST_BUILD
                  COMMAND python3.8 ${hellf_script_path}/flip_sections_flags_and_hide_entry_point.py ${EXECUTABLE_OUTPUT_PATH}/${PROJECT_NAME})

```

`class_embuche/cmake_bakery/templates/fragments/hide_entry_point.Jinja`:

```Jinja
add_custom_command(TARGET ${PROJECT_NAME}
                  POST_BUILD
                  COMMAND python3.8 ${hellf_script_path}/hide_entry_point.py ${EXECUTABLE_OUTPUT_PATH}/${PROJECT_NAME})

```

`class_embuche/cmake_bakery/templates/fragments/mixing_symbols.Jinja`:

```Jinja
add_custom_command(TARGET ${PROJECT_NAME}
                  POST_BUILD
                  COMMAND python3.8 ${hellf_script_path}/mixing_symbols_table.py ${EXECUTABLE_OUTPUT_PATH}/${PROJECT_NAME})

```

`class_embuche/cmake_bakery/templates/fragments/remove_section_header.Jinja`:

```Jinja
add_custom_command(TARGET ${PROJECT_NAME}
                  POST_BUILD
                  COMMAND python3.8 ${hellf_script_path}/remove_sections.py ${EXECUTABLE_OUTPUT_PATH}/${PROJECT_NAME})

```

`class_embuche/embuche.py`:

```py
import sys
import os
import shutil
import yaml
import subprocess
import glob
from .cmake_bakery.cmake_bakery import cmake_bakery

class embuche():
    def __init__(self, config_file):
        # Supported Embuche options
        self.__supported_options = {
            'compilation_options': {
                                    'strip': { 'value': False, 'flag': 's'},
                                    'symbols_hidden': { 'value': False, 'flag': 'fvisibility'},
                                    'optimize': { 'value': False, 'flag': 'O3'},
                                    'unroll_loops': { 'value': False, 'flag': 'funroll-all-loops'},
                                    'static': { 'value': False, 'flag': 'static'},
                                    'custom': { 'value': [], 'flag': ''}
                                    },
            'file_format': {
                'endianness': { 'value': False },
                'remove_section_header': { 'value': False },
                'flip_sections_flags': { 'value': False },
                'hide_entry_point': { 'value': False },
                'mixing_symbols': { 'value': False }
            },
            'packer': {
                'packer': { 'value': False },
                'packer_embuche': { 'value': False } }
            }
        # Set config file with Embuche options (yaml)
        self.__set_conf(config_file)

        # Set path to main code to compile
        self.__set_source_code()
        # Set project dir (Dir with build, bin, src)
        self.__set_project_directory()
        # Set the name of the project (name of the main source file)
        self.__set_project_name()
        # Check if config file is ok
        self.__parse_config()
        # Prepare directories
        self.__prepare_directories()
        # Prepare CMake for compilation
        self.__cmake_bakery_embuche = cmake_bakery(self.get_project_directory(), self.get_project_name(), self.get_conf(), 'CMakeLists_embuche.txt.Jinja')
        self.__cmake_bakery_packer = cmake_bakery(self.get_project_directory() + '/packer', self.get_project_name(), self.get_conf(), 'CMakeLists_packer.txt.Jinja')

    def __set_conf(self, config_file):
        # Try to load yaml in config file, exit otherwise
        try:
            # Read Conf file
            with open(config_file, 'r') as target:
                self.__conf = yaml.safe_load(target)

            if 'source_code' not in self.__conf:
                print('[-] No source_code defined.')
                exit(1)

            # Add missing options to avoid error
            if 'options' in self.__conf:
                self.__set_default_options()
            else:
                self.__conf['options'] = self.__supported_options

            # Create empty list if no external files, avoid error later
            if 'files' not in self.__conf:
                self.__conf['files'] = []
        except Exception as e:
            print("[-] Error in config file: {}".format(config_file))
            exit(1)

    def get_conf(self):
        # Return config (dictionnary)
        return self.__conf

    def __set_source_code(self):
        # Check if main source code exists and store path to it, exit otherwise
        if os.path.exists(self.get_conf()['source_code']):
            self.__source_code = self.get_conf()['source_code']
        else:
            print("{} doesn't exits".format(self.get_conf()['source_code']))
            exit(1)

    def get_source_code(self):
        # Return path to the main source code
        return self.__source_code

    def __set_project_directory(self):
        # Set path to the project directory
        self.__project_directory = os.path.dirname(os.path.abspath(os.path.join(self.get_source_code(), os.pardir)))

    def get_project_directory(self):
        # Return path to the project directory
        return self.__project_directory

    def __set_project_name(self):
        # Parse path to the main source code to store the filename as project name
        self.__project_name = os.path.splitext(os.path.basename(self.get_source_code()))[0]

    def get_project_name(self):
        # Return the name of the project (Name of the main source code file)
        return self.__project_name

    def __set_default_options(self):
        # Set missing options to avoid errors
        # For each kind of options, check if it's in config, add it if not
        for type in self.__supported_options.keys():
            if type not in self.__conf['options'].keys():
                self.__conf['options'][type] = self.__supported_options[type]
            else:
                # Foreach option in kind of options, check if it's in config, add it if not
                for option in self.__supported_options[type].keys():
                    if option not in self.__conf['options'][type].keys():
                        self.__conf['options'][type][option] = self.__supported_options[type][option]

    def __parse_compilation_options(self, compilation_options):
        # Default compilation option of Embuche
        set_options = ['Wall', 'Wextra', 'Wshadow', 'g', 'std']
        # Check if compilation_options is well configured (True or false value)
        for option in compilation_options:
            # If option doesn't exists in Embuche, exit
            if option not in self.__supported_options['compilation_options'].keys():
                print("[-] Unsupported GCC options (-{}) in config.".format(option))
                exit(1)

            # If options is not custom, check if value is True or False, if not set as False
            if option != 'custom':
                if compilation_options[option]['value'] not in [True, False]:
                    print("[-] Invalid value for compilation_options {}, must be True or False.".format(option))
                    compilation_options[option]['value'] = False

                # Add flag to set_options list, to check if no duplicate GCC flag later
                if compilation_options[option]['value'] is True:
                    set_options.append(self.__supported_options['compilation_options'][option]['flag'])

        # Check if there's no duplicate GCC flags with the custom flags
        if 'custom' in compilation_options:
            for flag in compilation_options['custom']['value']:
                if flag in set_options:
                    print('[-] GCC option (-{}) is already set in Embuche, can\'t be added again.'.format(flag))
                    exit(1)

    def __parse_file_format(self, file_format_options, compilation_options=None):
        # File format options that we'll be use, the list will be used to check if there's no mistake in config
        set_options = []
        # Check if file_format_options is well configured (True or false value)
        for option in file_format_options:
            # If option doesn't exists in Embuche, exit
            if option not in self.__supported_options['file_format'].keys():
                print("[-] Unsupported file_format options: {}".format(option))
                exit(1)
            # If value is not True or False, set it to False
            if file_format_options[option]['value'] not in [True, False]:
                print("[-] Invalid value for file_format {}, must be True or False.".format(option))
                file_format_options[option]['value'] = False

            # If true, add options to set_options to check later if there's error in config
            if file_format_options[option]['value'] is True:
                set_options.append(option)

        # Can't remove section header and mix symbol, print message and exit
        if ('remove_section_header' not in set_options) and (('flip_sections_flags' in set_options) or ('hide_entry_point' in set_options)):
            print('[-] The section header must be removed to use flip_sections_flags or hide_entry_point. Please set the remove_section_header to true.')
            exit(1)

        # Can't remove section header and mix symbol, print message and exit
        if ('remove_section_header' in set_options) and ('mixing_symbols' in set_options):
            print('[-] Can\'t remove section header and mix symbol table, one of this options must be set to false.')
            exit(1)

        # Can't mix symbols if there're hidden, print message and exit
        if compilation_options is not None:
            if ('mixing_symbols' in set_options) and (compilation_options['symbols_hidden']['value'] is True or compilation_options['static']['value'] is True):
                print('[-] .dynsym must be present to mix symbols table, either set mixing_symbols to false or symbols_hidden and static to false.')
                exit(1)

    def __parse_packer(self, packer):
        # Check if packer is well configured (True or false value)
        for option in packer:
            # If option doesn't exists in Embuche, exit
            if option not in self.__supported_options['packer'].keys():
                print("[-] Unsupported packer options: {}".format(option))
                exit(1)
            # If value is not True or False, set it to False
            if packer[option]['value'] not in [True, False]:
                print("[-] Invalid value for packer {}, must be True or False.".format(option))
                packer[option]['value'] = False

        # Exit if packer is not used but packer_embuche is set
        if packer['packer']['value'] is False and packer['packer_embuche']['value'] is True:
            print('[-] Can\'t use file format hacks on the packer if it\'s not enabled.')
            exit(1)

    def __parse_config(self):
        # Check if config is valid
        conf = self.get_conf()

        if 'files' in conf:
            # Check if each file in the 'files' options of the config exists
            for file in conf['files']:
                # Create path to the c_toolbox dir to check if file is in it
                c_tool_file = os.path.dirname(os.path.realpath(__file__)) + '/c_toolbox/' + file
                # Create path to the project dir to check if file is in it
                project_file = self.get_project_directory() + '/' + file

                # Check if file is in c_toolbox dir or project dir, exit otherwise
                if (os.path.exists(c_tool_file) == False) and (os.path.exists(project_file) == False):
                    print("{} doesn't exits".format(file))
                    exit(1)

        if 'options' in conf:
            if 'compilation_options' in conf['options']:
                # Check if compilation_options is well configured (True or false value and no duplicate options)
                self.__parse_compilation_options(conf['options']['compilation_options'])
            else:
                conf['options']['compilation_options'] = self.__supported_options['compilation_options']

            if 'file_format' in conf['options']:
                # Check if file_format is well configured (True or false value and no exclusive options)
                if 'compilation_options' in conf['options']:
                    self.__parse_file_format(conf['options']['file_format'], conf['options']['compilation_options'])
                else:
                    self.__parse_file_format(conf['options']['file_format'])

            if 'packer' in conf['options']:
                # Check if packer is well configured (True or false value)
                self.__parse_packer(conf['options']['packer'])
        else:
            print("[-] Error, no options in yaml, please use the provided template.")
            exit(1)

    def prepare_cmake(self):
        # Create CMake object
        self.__cmake_bakery_embuche.create_cmakelist_file()
        self.__cmake_bakery_packer.create_cmakelist_file()

    def __prepare_directories(self):
        # Create build directory if it doesn't exists in project path
        if not os.path.exists(self.get_project_directory() + '/build'):
            os.makedirs(self.get_project_directory() + '/build')
        else:
            # Clean build directory if it already exists
            for files in os.listdir(self.get_project_directory() + '/build'):
                # If file in build dir is a directory use shutil.rmtree
                if os.path.isdir(self.get_project_directory() + '/build/' + files):
                    shutil.rmtree(self.get_project_directory() + '/build/' + files)
                else:
                    # If file in build dir is file use os.remove
                    os.remove(self.get_project_directory() + '/build/' + files)

        # Create output dir (bin) in project directory if it doesn't exists
        if not os.path.exists(self.get_project_directory() + '/bin'):
            os.makedirs(self.get_project_directory() + '/bin')
        else:
            # If bin directory exists, remove all files in it
            for files in os.listdir(self.get_project_directory() + '/bin'):
                # Foreach file in directory, remove it, if it's dir use shutil.rmtree
                if os.path.isdir(self.get_project_directory() + '/bin/' + files):
                    shutil.rmtree(self.get_project_directory() + '/bin/' + files)
                else:
                    # If it's a file, use os.remove
                    os.remove(self.get_project_directory() + '/bin/' + files)

        # Copy files in c_toolbox to project directory
        for file in glob.glob(os.path.join(os.path.dirname(os.path.realpath(__file__)) + '/c_toolbox/', '*.*')):
            # If file in c_toolbox is not already in src dir, copy it
            if not os.path.exists(self.get_project_directory() + '/src/' + file):
                shutil.copy(file, self.get_project_directory() + '/src/')

        # If packer directory already exists, remove it
        if os.path.exists(self.get_project_directory() + '/packer'):
            shutil.rmtree(self.get_project_directory() + '/packer')

        # Copy the complete packer directory and subdirectories
        shutil.copytree(os.path.join(os.path.dirname(os.path.realpath(__file__)) + '/cmake_bakery/packer'), self.get_project_directory() + '/packer')

    def run(self):
        try:
            # Go to the build directory
            os.chdir(self.get_project_directory() + '/build')
            # Execute CMake
            subprocess.run(['cmake', '..'])
            # Execute make
            subprocess.run(['make'])

            # If packer is wanted
            if self.get_conf()['options']['packer']['packer']['value'] is True:
                # Go to packer directory
                os.chdir(self.get_project_directory() + '/packer')
                # Execute CMake
                subprocess.run(['cmake', '.'])
                # Execute make
                subprocess.run(['make'])
                # Delete packer directory in the program directory
                shutil.rmtree(self.get_project_directory() + '/packer')
                # Rename replace the previously build program by the packed one
                shutil.copy(self.get_project_directory() + '/bin/' + self.get_project_name() + '_packed', self.get_project_directory() + '/bin/' + self.get_project_name())
                # Delete the duplicated packed one
                os.remove(self.get_project_directory() + '/bin/' + self.get_project_name() + '_packed')
        except Exception as e:
            print('[-] Error while executing cmake/make.')
            exit(1)

```

`conf.yaml`:

```yaml
source_code: "./example/crackme/src/crackme.c"
files:
  - "anti_debug.c"
options:
  compilation_options:
    strip:
      description: "Remove .symtab section (symbols on disk)"
      value: false
    symbols_hidden:
      description: "Hide .dynsym section (symbols at runtime)"
      value: false
    optimize:
      description: "Optimize code (O3)"
      value: false
    unroll_loops:
      description: "Unroll loop structure"
      value: false
    static:
      description: "Use static dependencies (musl)"
      value: false
    custom:
      description: "Add custom GCC flags"
      value:
        - "fstack-protector-all"
  file_format:
    endianness:
      description: "Switch endianness to big endian"
      value: false
    remove_section_header:
      description: "Remove section header"
      value: false
    flip_sections_flags:
      description: "Flip sections flags (RX to RW & RW to RX)"
      value: false
    hide_entry_point:
      description: "Hide entry point with fake oversized section"
      value: false
    mixing_symbols:
      description: "Mix the name of symbols in .dynsym"
      value: false
  packer:
    packer:
      description: "Cipher the final binary and insert it in a program that will unciphered it at start."
      value: false
    packer_embuche:
      description: "Modify the packed binary with: endianness, remove_section_header, flip_sections_flags and hide_entry_point"
      value: false

```

`docs/compiler-options.md`:

```md
# Compiler Options

## Summary

- [TL;DR](compiler-options.md#tl-dr)
- [Target](compiler-options.md#target)
- [Debugging information](compiler-options.md#debugging-information)
- [Delete the symbol table (strip)](compiler-options.md#delete-the-symbol-table-strip)
- [Hide symbol](compiler-options.md#hide-symbol)
- [Optimization](compiler-options.md#optimization)
- [Unroll loops](compiler-options.md#unroll-loops)
- [Static compilation](compiler-options.md#static-compilation)

## TL;DR

- Do not use `-g`, it gives away information on the program and who wrote it
- Strip the binary with `-s` to remove symbols table
- Hide symbols with `-fvisibility`
- Optimize the code with `-O3` to make it harder to reverse
- Unroll the loops with `-funroll-all-loops` to create a longer code and harder to reverse
- Use static dependencies with `-s` to prevent LD_PRELOAD techniques for example

## Target

During this serie, we'll use the following code, *crackme.c*, as an example:

```c
#include <stdio.h>
#include <string.h>

int check_password(const char* p_password)
{
  char magnupass[9] = "MagnuB33r";
  return memcmp(magnupass, p_password, 9) != 0;
}

int main (int argc, char** argv) {

    if (argc != 2) {
        printf("Need exactly one argument.\n");
        return -1;
    }

    if (check_password(argv[1])) {
        printf("No, %s is not correct.\n", argv[1]);
        return 1;
    } else {
        printf("Yes, %s is correct!\n", argv[1]);
    }
    return 0;
}
```

The default *CMake* file is:

```
project(crackme)
cmake_minimum_required(VERSION 3.0)

set(CMAKE_C_FLAGS "-Wall -Wextra -Wshadow -std=gnu11")

add_executable(${PROJECT_NAME} src/${PROJECT_NAME}.c)
```

The arborescence of the project:

```
.
├── build
├── CMakeLists.txt
└── src
    └── crackme.c
```

If you want to compile the program:

```bash
magnussen@funcMyLife:~/embuche/build$ cmake ..; make
```

## Debugging information

Debugging information are really useful for a developer, it allows him to find the exact line where a variable was defined, track down the flow of an error, see the parameters of a function etc.

GCC creates several sections to store this information. All these sections start with *.debug_*.

An attacker might be interested by in the *.debug_info* section. This section contains:

- The absolute path to the source file (The name of the developer might be in that path).
- The absolute path to the compilation directory (The version of gcc is in that path).
- The C version that has been used.
- The exact line where a variable was defined.

An attacker can retrieve useful information with `objdump` (The output has been truncated):

```bash
magnussen@funcMyLife:~/embuche/build$ objdump --dwarf=info ./crackme
Contents of the .debug_info section:
  Compilation Unit @ offset 0x0:
   Length:        0x38a (32-bit)
   Version:       4
   Abbrev Offset: 0x0
   Pointer Size:  8
 <0><b>: Abbrev Number: 1 (DW_TAG_compile_unit)
    <c>   DW_AT_producer    : (indirect string, offset: 0x8d): GNU C11 7.5.0 -mtune=generic -march=x86-64 -g -std=gnu11 -fstack-protector-strong
    <10>   DW_AT_language    : 12	(ANSI C99)
    <11>   DW_AT_name        : (indirect string, offset: 0xc): /home/magnussen/crackme/src/crackme.c
    <15>   DW_AT_comp_dir    : (indirect string, offset: 0x219): /home/magnussen/crackme/build
    <19>   DW_AT_low_pc      : 0x93a
    <21>   DW_AT_high_pc     : 0x110
    <29>   DW_AT_stmt_list   : 0x0
```

> DWARF: DWARF stands for "Debugging With Attributed Record Formats" and is the default format GCC uses to store debugging information.

With this output we know that the code was compiled with GCC7.5, the program was written in C99 and the author is probably Magnussen (duh...)

The debugging information shouldn't be present in a final program. To prevent that, either don't set the `-g` option or set `-g0`.

## Delete the symbol table (strip)

Symbols can be variable or functions for example, they're defined into two sections of an ELF:

- **.symtab**, not loaded in memory
- **.dynsym**, loaded in memory at runtime.

These sections contain valuable information on symbols like their names, types, address etc.

An attacker can retrieve information on symbols with `readelf` (The output has been truncated):

```bash
magnussen@funcMyLife:~/embuche/build$ readelf --sym ./crackme

Symbol table '.dynsym' contains 23 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
    11: 0000000000201000     0 NOTYPE  GLOBAL DEFAULT   23 __data_start
    12: 0000000000201018     0 NOTYPE  GLOBAL DEFAULT   24 _end
    13: 000000000000093a   133 FUNC    GLOBAL DEFAULT   14 check_password
    14: 0000000000201000     0 NOTYPE  WEAK   DEFAULT   23 data_start
    15: 0000000000000ad0     4 OBJECT  GLOBAL DEFAULT   16 _IO_stdin_used
    16: 0000000000000a50   101 FUNC    GLOBAL DEFAULT   14 __libc_csu_init
    17: 0000000000000830    43 FUNC    GLOBAL DEFAULT   14 _start
    18: 0000000000201010     0 NOTYPE  GLOBAL DEFAULT   24 __bss_start
    19: 00000000000009bf   139 FUNC    GLOBAL DEFAULT   14 main
    20: 00000000000007b0     0 FUNC    GLOBAL DEFAULT   11 _init
    21: 0000000000000ac0     2 FUNC    GLOBAL DEFAULT   14 __libc_csu_fini
    22: 0000000000000ac4     0 FUNC    GLOBAL DEFAULT   15 _fini

Symbol table '.symtab' contains 67 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
    59: 0000000000201018     0 NOTYPE  GLOBAL DEFAULT   24 _end
    60: 0000000000000830    43 FUNC    GLOBAL DEFAULT   14 _start
    61: 0000000000201010     0 NOTYPE  GLOBAL DEFAULT   24 __bss_start
    62: 00000000000009bf   139 FUNC    GLOBAL DEFAULT   14 main
    63: 000000000000093a   133 FUNC    GLOBAL DEFAULT   14 check_password
    64: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
    65: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@@GLIBC_2.2
    66: 00000000000007b0     0 FUNC    GLOBAL DEFAULT   11 _init
```

Symbols can give away information on a program, for example, the name of the function `check_password` is pretty explicit.

The *.symtab* is not necessary for the execution of the program, we can remove it and so remove information on the program.

The strip option `-s` allows us to remove this section.

## Hide symbol

We saw in the last section how to remove the *.symtab* but an attacker could still retrieve valuable information with the *.dynsym* section.

The *.dynsym* is used during the execution so we can remove it but we can hide it with the `-fvisibility=hidden` option.

We can check with `readelf` if we can retrieve the symbols after that've been stripped and hidden:

```bash
magnussen@funcMyLife:~/embuche/build$ readelf --sym ./crackme

Symbol table '.dynsym' contains 21 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (2)
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (3)
     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5 (2)
     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)
     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND memcmp@GLIBC_2.2.5 (2)
     7: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     8: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
     9: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (2)
    10: 0000000000201010     0 NOTYPE  GLOBAL DEFAULT   23 _edata
    11: 0000000000201000     0 NOTYPE  GLOBAL DEFAULT   23 __data_start
    12: 0000000000201018     0 NOTYPE  GLOBAL DEFAULT   24 _end
    13: 0000000000201000     0 NOTYPE  WEAK   DEFAULT   23 data_start
    14: 0000000000000a80     4 OBJECT  GLOBAL DEFAULT   16 _IO_stdin_used
    15: 0000000000000a00   101 FUNC    GLOBAL DEFAULT   14 __libc_csu_init
    16: 00000000000007e0    43 FUNC    GLOBAL DEFAULT   14 _start
    17: 0000000000201010     0 NOTYPE  GLOBAL DEFAULT   24 __bss_start
    18: 0000000000000760     0 FUNC    GLOBAL DEFAULT   11 _init
    19: 0000000000000a70     2 FUNC    GLOBAL DEFAULT   14 __libc_csu_fini
    20: 0000000000000a74     0 FUNC    GLOBAL DEFAULT   15 _fini
```

Even the `main` is hidden, so GDB won't be able to break at `main` if an attacker try to debug the program.

## Optimization

> This option is sensitive, if the program is complex and not very well written it can cause errors.

During the compilation, GCC doesn't only *translate* the C code to ASM, it also performs various steps like optimization.

The optimization process aims to create the lighter and faster code as possible.

We can set the level of optimization in GCC, the most common options are: *-O1*, *-O2*, *-O3* and *-Os*.

*-O1*, *-O2* and *-Os* will create a smaller and faster code, because the code is smaller it'll be easier for an attacker to understand it.

On the other hand, the *-O3* options create a faster but longest code, the final program will be heavier, but it will also be more difficult to understand by an attacker.

## Unroll loops

As we saw in the previous section, the longer the code is, the harder is the job of the attacker.

GCC offers a nice option in order to create a bigger code, it allows us to *unroll* all the loops with *-funroll-all-loops*. This option undo the looping structure of any loop whose iterations can be determined at compile time, increasing the size of the final code.

## Static compilation

By default, a program will load external dependencies during its execution (*libc* oftenly).

An attacker can load his own dependencies and alter the behavior of a program. For example, he could load his own version of `memcmp` to print the values compared.

Here's an example:

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <dlfcn.h>

int memcmp(const void *s1, const void *s2, size_t n)
{
  char* new_s1 = calloc(n + 1, 1);
  char* new_s2 = calloc(n + 1, 1);
  memcpy(new_s1, s1, n);
  memcpy(new_s2, s2, n);
  printf("memcmp(%s, %s, %u)\n", new_s1, new_s2, (int)n);
  free(new_s1);
  free(new_s2);
  int (*original_memcmp)(const void *s1, const void *s2, size_t n);
  original_memcmp = dlsym(RTLD_NEXT, "memcmp");
  return original_memcmp(s1, s2, n);
}
```

The CmakeFile for this program:

```
project(memcmp_hijacking.so C)
cmake_minimum_required(VERSION 3.0)
set(CMAKE_C_FLAGS "-Wall -Wextra -Wshadow -fPIC -shared -std=gnu11")
add_executable(${PROJECT_NAME} src/memcmp_hijacking.c)
target_link_libraries(${PROJECT_NAME} dl)
```

We can create a shared object library from this program and load it when we execute our `crackme`.

```bash
magnussen@funcMyLife:~/memcmp_hijacking/build$ cmake ..; make
magnussen@funcMyLife:~/embuche/build$ LD_PRELOAD=~/memcmp_hijacking/build/memcmp_hijacking.so ./crackme test
memcmp(MagnusSwitch, test, 13)
No, test is not correct.
```

The `-static` option prevents linking with the shared libraries, *libc* is not meant to be a statically link so we have to use another library like *musl*.

The program will be significantly heavier, but an attacker won't be able to load his own library.

We have to modify the CmakeFile if we want to use *musl*:

```
project(crackme)
cmake_minimum_required(VERSION 3.0)

set(CMAKE_C_COMPILER musl-gcc)

set(CMAKE_C_FLAGS "-Wall -Wextra -Wshadow -static -std=gnu11")

add_executable(${PROJECT_NAME} src/${PROJECT_NAME}.c)
```

If we try to load our own `memcmp` it fails:

```bash
magnussen@funcMyLife:~/embuche/build$ LD_PRELOAD=~/memcmp_hijacking/build/memcmp_hijacking.so ./crackme test
No, test is not correct.
```

```

`docs/conf_file.md`:

```md
# Configuration

- **source_code**: The path to your main program (*Mandatory*, String).
- **files**: The list of files needed by your program (*Optionnal*, List).
- **options**: The list of all the options you want to use (*Optionnal*, List of Dictionnary).
  - **compilation_options**: The list of GCC options you want to use (*Optionnal*, Dictionnary).
    - **strip**: Strip the program with GCC (`-s`) (*Optionnal*).
      - **description**: String (*Optionnal*)
      - **value**: Boolean (*Mandatory*)
    - **symbols_hidden**: Hide the symbol table with GCC (`-fvisibility=hidden`) (*Optionnal*).
      - **description**: String (*Optionnal*)
      - **value**: Boolean (*Mandatory*)
    - **optimize**: Optimize the code with GCC (`-O3`) (*Optionnal*).
      - **description**: String (*Optionnal*)
      - **value**: Boolean (*Mandatory*)
    - **unroll_loops**: Undo loop structures with GCC (`-funroll-all-loops`) (*Optionnal*).
      - **description**: String (*Optionnal*)
      - **value**: Boolean (*Mandatory*)
    - **static**: Prevents linking with shared libraries (`-static`, compile with *musl*) (*Optionnal*).
      - **description**: String (*Optionnal*)
      - **value**: Boolean (*Mandatory*)
    - **custom**: Add custom GCC flags (*Optionnal*).
      - **description**: String (*Optionnal*)
      - **value**: List
  - **file_format**: The list of file format hacks you want to use (*Optionnal*, Dictionnary).
    - **endianness**: Change the endianness in the ELF header from little to big endian (*Optionnal*).
        - **description**: String (*Optionnal*)
        - **value**: Boolean (*Mandatory*)
    - **remove_section_header**: Modify the section header table to hide section (*Optionnal*).
        - **description**: String (*Optionnal*)
        - **value**: Boolean (*Mandatory*)
    - **flip_sections_flags**: Create a fake *.text* section with *RX* instead of *RW* and fake *.data* section with *RW* instead of *RX* (*Optionnal*).
        - **description**: String (*Optionnal*)
        - **value**: Boolean (*Mandatory*)
    - **hide_entry_point**: Create a fake *.data* section that override the entry point. (*Optionnal*).
        - **description**: String (*Optionnal*)
        - **value**: Boolean (*Mandatory*)
    - **mixing_symbols**: Create fake *.dynsym* section and mix symbols names. (*Optionnal*).
        - **description**: String (*Optionnal*)
        - **value**: Boolean (*Mandatory*)
  - **packer**: Use the packer and use some file format techniques on it (*Optionnal*, Dictionnary).
    - **packer**: Use the metamorphic packer (*Optionnal*).
      - **description**: String (*Optionnal*)
      - **value**: Boolean (*Mandatory*)
    - **packer_embuche**: Modify the binary after it has been packed with endianness, remove_section_header, flip_sections_flags and hide_entry_point techniques. (*Optionnal*).
      - **description**: String (*Optionnal*)
      - **value**: Boolean (*Mandatory*)

```

`docs/detect-debug.md`:

```md
# Detect debugging

## Summary

- [TL;DR](detect-debug.md#tl-dr)
- [Attach to *ptrace*](detect-debug.md#attach-to-ptrace)
- [File descriptor](detect-debug.md#file-descriptor)
- [Detect GDB by its PID](detect-debug.md#detect-GDB-by-its-pid)
- [Check the parent name](detect-debug.md#check-the-parent-name)
- [Detect LD_PRELOAD](detect-debug.md#detect-ld_preload)
- [Disable Core Dump](detect-debug.md#disable-core-dump)
- [Final code](detect-debug.md#final-code)

## TL;DR

- GDB and others debuggers use *ptrace* call to attach a process and control its memory and registers.
- A program can only be attached by one *ptrace* call, if our program is already attached, it can't be attached by GDB.
- GDB uses two file descriptors when it debugs a program, we can check the number of file descriptors pointing to our program to detect GDB.
- We can use the proc files *cmdline* and *status* to check if our program was started by a debugger.
- We can detect the environment variables and exit if the program was started with LD_PRELOAD
- We can block memory dump with `prctl(PR_SET_DUMPABLE, 0);`

## Attach to *ptrace*

A debugger attach itself to the program it debugs with *ptrace* system call.

This system call allows one process (called the *tracer*) to observe and control the execution of another process (the *tracee*).

What's interesting for us is that a process can only be attached by one tracer. So if our process has already called *ptrace*, GDB won't be able to attach to it.

With this function we can check if *ptrace* is already attached or not.

```c
#include <sys/ptrace.h>

int check_ptrace()
{
  return ptrace(ptrace_TRACEME, 0, NULL, NULL) != 0;
}
```

If it's attached the function will return 1, otherwise 0.


## File descriptor

Another way to detect a debugger is to check the file descriptor it uses.

Normally, a program has 3 file descriptors:

- stdin
- stdout
- stderr

But, when GDB is debugging a binary, it opens 3 more file descriptors.

We can easily check how many file descriptors are opened with this function:

```c
int dbg_file_descriptor()
{
    FILE* fd = fopen("/", "r");
    int nb_fd = fileno(fd);
    fclose(fd);

    return (nb_fd > 3);
}
```

If there's more than 3 file descriptors, the program might be debugged.

## Detect GDB by its PID

We can also check if the program is being debugged by checking the command line that started the process.

When a program is executed, a directory is created in /proc with the PID of the process.

In this directory we can find multiple information on the process like names and values of the environment variables, its run state and memory usage and the command that originally started the process.

By checking the /proc/*pid*/cmdline file we can find the complete command line for the process and check if the program was started by GDB.

Here's a function that allows us to read the /proc/*pid*/cmdline and check if it was GDB that started the process.

```c
#define check_strings(str_buff) (strstr(str_buff, "gdb") || strstr(str_buff, "ltrace") || strstr(str_buff, "strace") || (strstr(str_buff, "radare2")) || (strstr(str_buff, "ida")))

int dbg_cmdline()
{
    char buff [24], tmp [16];
    FILE* f;

    snprintf(buff, 24, "/proc/%d/cmdline", getppid());
    f = fopen(buff, "r");
    fgets(tmp, 16, f);
    fclose(f);

    return check_strings(tmp);
}
```

If there's *GDB*, *ltrace*, *strace*, *radare2* or *ida* in the command line that started the process it's certainly because the program was debugged.

> We check if the program is executed by GDB, but we can prevent GDB to statically analyze it.

## Check the parent name

Another way to see if our program is being traced is to check the status file in the proc directory.

If our process is being debugged, it might have been started by GDB. The debugger will be the parent process of our program.

We can check if the parent process is GDB by checking the /proc/PID/status file of our PPID (Parent Process IDentifier).

```c
#define check_strings(str_buff) (strstr(str_buff, "gdb") || strstr(str_buff, "ltrace") || strstr(str_buff, "strace") || (strstr(str_buff, "radare2")) || (strstr(str_buff, "ida")))

int dbg_getppid_name()
{
    char buff1[24], buff2[16];
    FILE* f;

    snprintf(buff1, 24, "/proc/%d/status", getppid());
    f = fopen(buff1, "r");
    fgets(buff2, 16, f);
    fclose(f);

    return check_strings(buff2);
}
```

If *GDB*, *ltrace*, *strace*, *radare2* or *ida* is in the status file of our parent process, our program might be debugged.

## Detect LD_PRELOAD

One other common technique to dynamically debug a program is loading external dependencies to modify the behaviour of a function in the program.

As we saw in the first article of this serie, it's possible to load its own version of a function and check which values are compared when it is called for example.

One solution was to use static dependencies to block the use of external ones.

We can also check the environment variables to check if LD_PRELOAD was set.

```c
int various_ldpreload()
{
    return (getenv("LD_PRELOAD") != NULL);
}
```

If the LD_PRELOAD environment variable is set, the program might be debugged.

## Disable core dump

The previous techniques worked if the program was directly debug by GDB but its possible for an attacker to dump the memory process without controlling executing and inject it in GDB.

To prevent core dump, we can disable the *dumpable* flag of the process and avoid the generation of a memory dump.

To do so we can use the following line:

```c
#include <sys/prctl.h>

prctl(PR_SET_DUMPABLE, 0);
```

As we set the *PR_SET_DUMPABLE* flag to 0, the process cannot be dumped.

## Final code

Here's the list of all the functions we've discussed, if one of these functions returns *1* the program is being debugged, we exit the program.

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/prctl.h>

typedef int bool;
#define true 1
#define false 0

#define check_strings(str_buff) (strstr(str_buff, "gdb") || strstr(str_buff, "ltrace") || strstr(str_buff, "strace") || (strstr(str_buff, "radare2")) || (strstr(str_buff, "ida")))

void dbg_checker();
int check_ptrace();
int dbg_file_descriptor();
int dbg_cmdline();
int dbg_getppid_name();
int various_ldpreload();

void dbg_checker()
{
  /* prevent core dump */
  prctl(PR_SET_DUMPABLE, 0);

  if (check_ptrace() == 1)
  {
    exit(0);
  }

  if (dbg_file_descriptor() == 1)
  {
    exit(0);
  }

  if (dbg_cmdline() == 1)
  {
    exit(0);
  }

  if (dbg_getppid_name() == 1)
  {
    exit(0);
  }

  if (various_ldpreload() == 1)
  {
    exit(0);
  }
}

/* Check if ptrace is already attached */
int check_ptrace()
{
  return ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0;
}

/* 2 file descriptors when programs open with GDB. Both pointing to the program being debugged.*/
int dbg_file_descriptor()
{
    FILE* fd = fopen("/", "r");
    int nb_fd = fileno(fd);
    fclose(fd);

    return (nb_fd > 3);
}

/* Detect GDB by the mean of /proc/$PID/cmdline, which should no be "gdb" */
int dbg_cmdline()
{
    char buff [24], tmp [16];
    FILE* f;

    snprintf(buff, 24, "/proc/%d/cmdline", getppid());
    f = fopen(buff, "r");
    fgets(tmp, 16, f);
    fclose(f);

    return check_strings(tmp);
}

/* Check the parent's name */
int dbg_getppid_name()
{
    char buff1[24], buff2[16];
    FILE* f;

    snprintf(buff1, 24, "/proc/%d/status", getppid());
    f = fopen(buff1, "r");
    fgets(buff2, 16, f);
    fclose(f);

    return check_strings(buff2);
}

/* Try to detect the LD_PRELOAD trick by looking into environnement variables of the program. */
int various_ldpreload()
{
    return (getenv("LD_PRELOAD") != NULL);
}
```

```

`docs/file-format-hacks.md`:

```md
# File format hacks

## Summary

- [TL;DR](file-format-hacks.md#tl-dr)
- [Change the endianness](file-format-hacks.md#change-the-endianness)
- [Remove section header table](file-format-hacks.md#remove-section-header-table)
- [Create fake sections](file-format-hacks.md#create-fake-sections)
- [Hide the entry point](file-format-hacks.md#hide-the-entry-point)
- [Mix symbol table](file-format-hacks.md#mix-symbol-table)
- [Impact on disassemblers](file-format-hacks.md#impact-on-disassemblers)

## TL;DR

- The endianness in an ELF header can be changed to mess with disassemblers as they're meant to read multiple architectures (The CPU loader doesn’t need to check the endianness because it can only execute little or big-endian).
- Some disassemblers rather use the sections than the segments, but as the sections aren't needed at runtime, we can remove them, create fake ones or hide the entry point by oversizing the first section.
- The **.dynsym** is always needed, but we can create a fake one an point it in our ELF header to mix our function's names in *IDA*.
- *Radare2* rather use the *segments* than the *sections* but rely a lot on the ELF header as *IDA* privileges the *sections* but doesn't rely on the ELF header.

## Change the endianness

The endianness is the order in which a sequence of bytes is stored in memory. There's different kind of endianness, but the most known are little-endian and big-endian. The difference is the way they order a sequence of byte:

- Big-endian: The least-significant byte is stored at the largest address and the least significant is stored at the smallest one. ("From left to right")
- Little-endian: The least-significant byte is stored at the smallest address and the most-significant at the largest one. ("From right to left")


So if we have this sequence of bytes: 0A CA B6 66, it will be stored as:

- Big-endian: 0x0ACAB666
- Little-endian: 0x66B6CA0A

The endianness in use is determined by the way the CPU reads a sequence of bytes.

As a system is either little-endian or big-endian (unless its ARM, which can be bi-endian), a loader doesn’t need to check the endianness because it can only execute one or the other.

This endianness is defined in the sixth byte of the ELF header (*EI_DATA*).

```
EI_DATA encoding:
  ELFDATANONE: Unknown data format. (0x00)
  ELFDATA2LSB: Two's complement, little-endian. (0x01)
  ELFDATA2MSB: Two's complement, big-endian. (0x02)
```

So the loader doesn't check the sixth byte because it can only execute little or big-endian.

However, tools like **readelf**, **Radare2**, and **IDA** expects to read files from many
architectures.

So if you modify this byte, your program will still run as expected, but tools that need the *EI_DATA* will behave differently.

For example, **GDB** will not recognize the format of the file and will not be able to load it.

As saw before the endianness is defined in the sixth byte of an ELF, if the byte is 0x01 the endianness is little-endian, if the sixth byte is 0x02, the endianness is big-endian. We can modify the endianness as follows:

```bash
magnussen@funcMyLife:~/embuche/bin$ readelf -h crackme
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x4011d0
  Start of program headers:          64 (bytes into file)
  Start of section headers:          60448 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         36
  Section header string table index: 35
magnussen@funcMyLife:~/embuche/bin$ printf '\x02' | dd conv=notrunc of=./crackme bs=1 seek=5
magnussen@funcMyLife:~/embuche/bin$ readelf -h crackme
ELF Header:
  Magic:   7f 45 4c 46 02 02 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, big endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              <unknown>: 200
  Machine:                           <unknown>: 0x3e00
  Version:                           0x1000000
  Entry point address:               0xd011400000000000
  Start of program headers:          4611686018427387904 (bytes into file)
  Start of section headers:          2372271103717408768 (bytes into file)
  Flags:                             0x0
  Size of this header:               16384 (bytes)
  Size of program headers:           14336 (bytes)
  Number of program headers:         2304
  Size of section headers:           16384 (bytes)
  Number of section headers:         9216
  Section header string table index: 8960
readelf: Warning: The e_shentsize field in the ELF header is larger than the size of an ELF section header
readelf: Error: Reading 150994944 bytes extends past end of file for section headers
readelf: Error: Too many program headers - 0x900 - the file is not that big
```

By rewriting the sixth byte from 0x01 to 0x02 we've changed the endianness in the ELF header and `readelf` reads the ELF file as big-endian but as our CPU is only using little-endian it execute it in little-endian.

The program is still executable, but every tool that uses the ELF header will read our program in big-endian.

Just changing that one byte makes the job of a reverser a lot more difficult if he doesn't know that the endianness is wrong.

> We've created a small python script to modify the endianness, you can find it [here](../class_embuche/cmake_bakery/hellf_scripts/endianness_changer.py)

## Remove section header table

The sections of a program describe the program on disk, whereas the segments describes the program at runtime.

The section header table breaks down the binary in very specific chunks and can be useful to a reverser to gain knowledge on how the program works. As the sections aren't used at runtime, the section header table isn't needed for execution, we can remove it and our program will still be executable.

Some debuggers and dissassemblers initialize their analysis with the sections, if we remove the section header table, they won't be able to properly initialize the program.

There are four variables from the ELF header that are used to find, parse, and display
the section header table:

- Start of section headers (**E_SHOFF**): The offset where the section headers start.
- Size of section headers (**E_SHENTSIZE**): The size of a section header.
- Number of section headers (**E_SHNUM**): The number of section headers.
- Section header string table index (**E_SHSTRNDX**): The location of the section header string table (name of the sections).

If you set the value of these variables at 0 then locating or parsing the table would be impossible.

You can use a hex editor like *flex* or *hex edit* to modify these values.

```bash
magnussen@funcMyLife:~/embuche/bin$ readelf -h crackme
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Shared object file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0xd50
  Start of program headers:          64 (bytes into file)
  Start of section headers:          11760 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         29
  Section header string table index: 28
magnussen@funcMyLife:~/embuche/bin$ readelf -S crackme
There are 29 section headers, starting at offset 0x2df0:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000000238  00000238
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.ABI-tag     NOTE             0000000000000254  00000254
       0000000000000020  0000000000000000   A       0     0     4
  [ 3] .note.gnu.build-i NOTE             0000000000000274  00000274
       0000000000000024  0000000000000000   A       0     0     4
  [ 4] .gnu.hash         GNU_HASH         0000000000000298  00000298
       00000000000000c0  0000000000000000   A       5     0     8
  [ 5] .dynsym           DYNSYM           0000000000000358  00000358
       0000000000000420  0000000000000018   A       6     1     8
  [ 6] .dynstr           STRTAB           0000000000000778  00000778
       00000000000001e4  0000000000000000   A       0     0     1
  [ 7] .gnu.version      VERSYM           000000000000095c  0000095c
       0000000000000058  0000000000000002   A       5     0     2
  [ 8] .gnu.version_r    VERNEED          00000000000009b8  000009b8
       0000000000000030  0000000000000000   A       6     1     8
  [ 9] .rela.dyn         RELA             00000000000009e8  000009e8
       00000000000000d8  0000000000000018   A       5     0     8
  [10] .rela.plt         RELA             0000000000000ac0  00000ac0
       0000000000000168  0000000000000018  AI       5    22     8
  [11] .init             PROGBITS         0000000000000c28  00000c28
       0000000000000017  0000000000000000  AX       0     0     4
  [12] .plt              PROGBITS         0000000000000c40  00000c40
       0000000000000100  0000000000000010  AX       0     0     16
  [13] .plt.got          PROGBITS         0000000000000d40  00000d40
       0000000000000008  0000000000000008  AX       0     0     8
  [14] .text             PROGBITS         0000000000000d50  00000d50
       00000000000008b2  0000000000000000  AX       0     0     16
  [15] .fini             PROGBITS         0000000000001604  00001604
       0000000000000009  0000000000000000  AX       0     0     4
  [16] .rodata           PROGBITS         0000000000001610  00001610
       000000000000009a  0000000000000000   A       0     0     4
  [17] .eh_frame_hdr     PROGBITS         00000000000016ac  000016ac
       000000000000008c  0000000000000000   A       0     0     4
  [18] .eh_frame         PROGBITS         0000000000001738  00001738
       0000000000000278  0000000000000000   A       0     0     8
  [19] .init_array       INIT_ARRAY       0000000000201d40  00001d40
       0000000000000010  0000000000000008  WA       0     0     8
  [20] .fini_array       FINI_ARRAY       0000000000201d50  00001d50
       0000000000000008  0000000000000008  WA       0     0     8
  [21] .dynamic          DYNAMIC          0000000000201d58  00001d58
       00000000000001f0  0000000000000010  WA       6     0     8
  [22] .got              PROGBITS         0000000000201f48  00001f48
       00000000000000b8  0000000000000008  WA       0     0     8
  [23] .data             PROGBITS         0000000000202000  00002000
       0000000000000010  0000000000000000  WA       0     0     8
  [24] .bss              NOBITS           0000000000202010  00002010
       0000000000000008  0000000000000000  WA       0     0     1
  [25] .comment          PROGBITS         0000000000000000  00002010
       0000000000000029  0000000000000001  MS       0     0     1
  [26] .symtab           SYMTAB           0000000000000000  00002040
       00000000000008d0  0000000000000018          27    51     8
  [27] .strtab           STRTAB           0000000000000000  00002910
       00000000000003e0  0000000000000000           0     0     1
  [28] .shstrtab         STRTAB           0000000000000000  00002cf0
       00000000000000fe  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)
magnussen@funcMyLife:~/embuche/bin$ python3.8 ../class_embuche/cmake_bakery/hellf_scripts/remove_sections.py crackme
magnussen@funcMyLife:~/embuche/bin$ readelf -h crackme
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Shared object file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0xd50
  Start of program headers:          64 (bytes into file)
  Start of section headers:          0 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           0 (bytes)
  Number of section headers:         0
  Section header string table index: 0
magnussen@funcMyLife:~/embuche/bin$ readelf -S crackme
There are no sections in this file.
```

> We've created a small python script to set these variables at 0, you can find it [here](../class_embuche/cmake_bakery/hellf_scripts/remove_sections.py)

## Create fake sections

Previously we removed the section header table, but we can also create a fake one.

The program doesn't need the section header table to be executed so it won't care about the fake one, but a disassembler might use the section header table to disassemble the program.

An important part of the section header and program header is the **flags** field, it describes if the section or segment is executable, writable, and/or readable. The flag of a section is the same flag as the segment.

Some disassembler will use the section header table and their flags rather than the program header.

We can create a fake sections with wrong flags to mess with the disassembler.

Here's a sample of sections that you can put in your fake section header table:

- **SHT_NULL**: This is commonly placed at the beginning of a section table and it would look weird if left out.
- **SHT_PROGBITS**: You can set the address space to cover the first LOAD segment. However, instead of being *re* (read/execute) like the first LOAD it will be *rw* (read/write) like the second LOAD. The name of the section will be *.data* so it’ll look like a normal data section.
- Another **SHT_PROGBITS**: In this section, you’ll set the address space to cover the second LOAD segment. This time marks the segment as *re* instead of *rw*. The name for this section should be *.text* since it’ll look like a code segment.

For example, *IDA* will find less functions and its analysis will be less complete because its decompiles only sections with executable flags. This forces the reverser to manually disassemble these types of sections.

```bash
magnussen@funcMyLife:~/embuche/bin$ readelf -h crackme
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Shared object file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0xd50
  Start of program headers:          64 (bytes into file)
  Start of section headers:          11760 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         29
  Section header string table index: 28
magnussen@funcMyLife:~/embuche/bin$ readelf -S crackme
There are 29 section headers, starting at offset 0x2df0:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000000238  00000238
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.ABI-tag     NOTE             0000000000000254  00000254
       0000000000000020  0000000000000000   A       0     0     4
  [ 3] .note.gnu.build-i NOTE             0000000000000274  00000274
       0000000000000024  0000000000000000   A       0     0     4
  [ 4] .gnu.hash         GNU_HASH         0000000000000298  00000298
       00000000000000c0  0000000000000000   A       5     0     8
  [ 5] .dynsym           DYNSYM           0000000000000358  00000358
       0000000000000420  0000000000000018   A       6     1     8
  [ 6] .dynstr           STRTAB           0000000000000778  00000778
       00000000000001e4  0000000000000000   A       0     0     1
  [ 7] .gnu.version      VERSYM           000000000000095c  0000095c
       0000000000000058  0000000000000002   A       5     0     2
  [ 8] .gnu.version_r    VERNEED          00000000000009b8  000009b8
       0000000000000030  0000000000000000   A       6     1     8
  [ 9] .rela.dyn         RELA             00000000000009e8  000009e8
       00000000000000d8  0000000000000018   A       5     0     8
  [10] .rela.plt         RELA             0000000000000ac0  00000ac0
       0000000000000168  0000000000000018  AI       5    22     8
  [11] .init             PROGBITS         0000000000000c28  00000c28
       0000000000000017  0000000000000000  AX       0     0     4
  [12] .plt              PROGBITS         0000000000000c40  00000c40
       0000000000000100  0000000000000010  AX       0     0     16
  [13] .plt.got          PROGBITS         0000000000000d40  00000d40
       0000000000000008  0000000000000008  AX       0     0     8
  [14] .text             PROGBITS         0000000000000d50  00000d50
       00000000000008b2  0000000000000000  AX       0     0     16
  [15] .fini             PROGBITS         0000000000001604  00001604
       0000000000000009  0000000000000000  AX       0     0     4
  [16] .rodata           PROGBITS         0000000000001610  00001610
       000000000000009a  0000000000000000   A       0     0     4
  [17] .eh_frame_hdr     PROGBITS         00000000000016ac  000016ac
       000000000000008c  0000000000000000   A       0     0     4
  [18] .eh_frame         PROGBITS         0000000000001738  00001738
       0000000000000278  0000000000000000   A       0     0     8
  [19] .init_array       INIT_ARRAY       0000000000201d40  00001d40
       0000000000000010  0000000000000008  WA       0     0     8
  [20] .fini_array       FINI_ARRAY       0000000000201d50  00001d50
       0000000000000008  0000000000000008  WA       0     0     8
  [21] .dynamic          DYNAMIC          0000000000201d58  00001d58
       00000000000001f0  0000000000000010  WA       6     0     8
  [22] .got              PROGBITS         0000000000201f48  00001f48
       00000000000000b8  0000000000000008  WA       0     0     8
  [23] .data             PROGBITS         0000000000202000  00002000
       0000000000000010  0000000000000000  WA       0     0     8
  [24] .bss              NOBITS           0000000000202010  00002010
       0000000000000008  0000000000000000  WA       0     0     1
  [25] .comment          PROGBITS         0000000000000000  00002010
       0000000000000029  0000000000000001  MS       0     0     1
  [26] .symtab           SYMTAB           0000000000000000  00002040
       00000000000008d0  0000000000000018          27    51     8
  [27] .strtab           STRTAB           0000000000000000  00002910
       00000000000003e0  0000000000000000           0     0     1
  [28] .shstrtab         STRTAB           0000000000000000  00002cf0
       00000000000000fe  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)
magnussen@funcMyLife:~/embuche/bin$ readelf -l crackme
  Elf file type is DYN (Shared object file)
  Entry point 0xd50
  There are 9 program headers, starting at offset 64

  Program Headers:
    Type           Offset             VirtAddr           PhysAddr
                   FileSiz            MemSiz              Flags  Align
    PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                   0x00000000000001f8 0x00000000000001f8  R      0x8
    INTERP         0x0000000000000238 0x0000000000000238 0x0000000000000238
                   0x000000000000001c 0x000000000000001c  R      0x1
        [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
    LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x00000000000019b0 0x00000000000019b0  R E    0x200000
    LOAD           0x0000000000001d40 0x0000000000201d40 0x0000000000201d40
                   0x00000000000002d0 0x00000000000002d8  RW     0x200000
    DYNAMIC        0x0000000000001d58 0x0000000000201d58 0x0000000000201d58
                   0x00000000000001f0 0x00000000000001f0  RW     0x8
    NOTE           0x0000000000000254 0x0000000000000254 0x0000000000000254
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_EH_FRAME   0x00000000000016ac 0x00000000000016ac 0x00000000000016ac
                   0x000000000000008c 0x000000000000008c  R      0x4
    GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x0000000000000000 0x0000000000000000  RW     0x10
    GNU_RELRO      0x0000000000001d40 0x0000000000201d40 0x0000000000201d40
                   0x00000000000002c0 0x00000000000002c0  R      0x1
magnussen@funcMyLife:~/embuche/bin$ python3.8 ../class_embuche/cmake_bakery/hellf_scripts/remove_sections.py crackme
magnussen@funcMyLife:~/embuche/bin$ python3.8 ../class_embuche/cmake_bakery/hellf_scripts/flip_sections_flags.py crackme
magnussen@funcMyLife:~/embuche/bin$ readelf -h crackme
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Shared object file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0xd50
  Start of program headers:          64 (bytes into file)
  Start of section headers:          13617 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         4
  Section header string table index: 3
magnussen@funcMyLife:~/embuche/bin$ readelf -S crackme
There are 4 section headers, starting at offset 0x3531:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .data             PROGBITS         0000000000000000  00000000
       00000000000019b0  0000000000000000  WA       0     0     4
  [ 2] .text             PROGBITS         0000000000201d40  00001d40
       00000000000002d0  0000000000000000  AX       0     0     4
  [ 3] .shstrtab         STRTAB           0000000000000000  00003631
       0000000000000017  0000000000000000           0     0     4
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)
magnussen@funcMyLife:~/embuche/bin$ readelf -l crackme

Elf file type is DYN (Shared object file)
Entry point 0xd50
There are 9 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000001f8 0x00000000000001f8  R      0x8
  INTERP         0x0000000000000238 0x0000000000000238 0x0000000000000238
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x00000000000019b0 0x00000000000019b0  R E    0x200000
  LOAD           0x0000000000001d40 0x0000000000201d40 0x0000000000201d40
                 0x00000000000002d0 0x00000000000002d8  RW     0x200000
  DYNAMIC        0x0000000000001d58 0x0000000000201d58 0x0000000000201d58
                 0x00000000000001f0 0x00000000000001f0  RW     0x8
  NOTE           0x0000000000000254 0x0000000000000254 0x0000000000000254
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_EH_FRAME   0x00000000000016ac 0x00000000000016ac 0x00000000000016ac
                 0x000000000000008c 0x000000000000008c  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000001d40 0x0000000000201d40 0x0000000000201d40
                 0x00000000000002c0 0x00000000000002c0  R      0x1
```

We successfully manage to create fake sections with wrong flags, but the segments still have the correct flag and our program is still executable.

> We've created a small python script to create these fake sections, you can find it [here](../class_embuche/cmake_bakery/hellf_scripts/flip_sections_flags.py), you have to remove the section header table before using it with this [script](../class_embuche/cmake_bakery/hellf_scripts/remove_sections.py).

## Hide the entry point

The entry point is the address where the process starts executing. This address is the address of the first section. We can hide it by creating a fake section that starts before the entry point. The disassembler will take the base address of this fake section instead of the true entry point.

There's three interesting fields for this technique:

- The virtual address (**sh_addr**)
- The physical offset (**sh_offset**)
- The size (**sh_size**)

When you have a virtual address and want to look up the actual location in the binary, you look at the section header table and find which section the virtual address would fall within by calculating the range of *sh_addr* and *sh_addr* + *sh_size*.

Once you’ve found the section, you want to calculate the physical offset of your
virtual address by subtracting the *sh_addr* and then adding the *sh_offset*.

You will calculate (*virtual_address* - *physical_address*) + *offset*.

You should now know the exact offset in the binary where you can find your virtual address.

```
Example:
virtual_address = 0x4002f0
sh_addr = 0x400000
sh_size = 0x000800
sh_offset = 0

If you want to locate your virtual address in the binary you'll do:
(*virtual_address* - *sh_addr*) + *sh_offset* = (0x4002f0 - 0x400000) + 0 = 0x2f0
```

If you add a fake section header table and alter the base address of the section that contains the entry point, then any disassembler relying exclusively on the section header table won’t be able to properly find the entry point in the file.

So we can create a fake `.data` section that overrides the entry point.

Here's how *IDA* disassembles our binary when the entry point is the right one.

![Right entrypoint](./img/ida_good_entrypoint.png)

```bash
magnussen@funcMyLife:~/embuche/bin$ python3.8 ../class_embuche/cmake_bakery/hellf_scripts/remove_sections.py crackme
magnussen@funcMyLife:~/embuche/bin$ python3.8 ../class_embuche/cmake_bakery/hellf_scripts/hide_entry_point.py crackme
```

![Wrong entrypoint](./img/ida_wrong_entrypoint.png)

As we can see, if we create a fake `.data` section that starts before the legitimate entry point, *IDA* failed to correctly disassemble our program.

> We've created a small python script to create this fake section, you can find it [here](../class_embuche/cmake_bakery/hellf_scripts/hide_entry_point.py), you have to remove the section header table before using it with this [script](../class_embuche/cmake_bakery/hellf_scripts/remove_sections.py).

## Mix symbol table

> In this technique you will need to have the dynamic symbol table to be present (**.dynsym**).

There's two symbol tables in an ELF, they contain the name of the functions used in our program:

- **.symtab**: Located in the section header, it also contains variable names for example.
- **.dynsym**: A smaller copy of the **.symtab** used by the dynamic linker with only the function's names.

We can't remove the **dynsym** as it's needed at runtime, but we can create a fake one with wrong symbol names. We'll create a fake **.dynsym** with the name of our functions mixed up and point the offset in the *.dynsym* section header to point to this fake symbol table.

As the section header table isn't needed at runtime, the fake **.dynsym** will not be used and the true one will be mapped in memory.

![IDA right symbols](./img/ida_right_symbols.png)

```bash
magnussen@funcMyLife:~/embuche/bin$ python3.8 ../class_embuche/cmake_bakery/hellf_scripts/mixing_symbols_table.py crackme
```

![IDA right symbols](./img/ida_wrong_symbols.png)

As we can see, *IDA* uses our fake symbol table and print incorrect function names.

The attacker using *IDA* will only notice the symbol names are incorrect if he come across it while doing dynamic analysis or if they compare the **.dynsym** offsets in the section headers and program headers.

> We've created a small python script to mix the symbol's names in **.dynsym**, you can find it [here](../class_embuche/cmake_bakery/hellf_scripts/mixing_symbols_table.py).

## Impact on Disassemblers

Unfortunately, these techniques don't apply to all the disassemblers.

*Radare2*, for example, seems to treat both the section entries and program segments as **sections** and the program segments is preferred for the disassembly. So techniques that modify the sections doesn't mess with *Radare2*.

*IDA* is affected by techniques that uses the section entries, but doesn't rely much on the ELF header for example.

| File Format Hack / Impact disassembler | GDB | IDA | Radare2 |
| --- | --- | --- | --- |
| Endianness | Yes | No (Confirmation Dialog) | Yes |
| Removing the Section Headers Table | Yes | No | Yes |
| Create fake sections with wrong flags | Yes | Yes | No |
| Hide the entry point | Yes | Yes | No |
| Mix symbol table | No | Yes | No |

These techniques are very interesting and not difficult to use and understand, but their impact is quite significant and teaches a lot about how disassemblers works.

```

`docs/img/diagramme.drawio`:

```drawio
<mxfile host="app.diagrams.net" modified="2020-06-13T12:18:19.793Z" agent="5.0 (X11)" etag="18cJ7zkqOwaJCXJY-vv0" version="13.2.4" type="device"><diagram id="1sSGhl-clJmZTjCsUqY8" name="Page-1">7V1bk5u4Ev41U5V9cIq78WPmlmRPLrM7JzmZJxcG2dYORhzAnnF+/UogbJBkwGOE8XhStTtGCAHd6o/uVnfrQr9aPH+MnHD+FXnAv9AU7/lCv77QNF1VbPyHtKyzFlUzzKxlFkGPtm0b7uFvQBsV2rqEHohLHROE/ASG5UYXBQFwk1KbE0XoqdxtivzyXUNnBriGe9fx+db/QS+ZZ622qWzbPwE4m+d3VhV6ZuHknWlDPHc89FRo0m8u9KsIoST7tXi+Aj6hXk6X7LrbHWc3DxaBIGlywf3j73t9riXfPj3M/JnmXz/+Hg+GdJiV4y/pG9OnTdY5CSK0DDxARlEu9MunOUzAfei45OwT5jpumycLHx+p+Cf/VPkdQJSA50ITfcqPAC1AEq1xF3rWoATLp4xOj5+29N9Mj3mB9pZNGx3K89lm6C1Z8A9KmX2oZNdTCXh43tBDFCVzNEOB499sWy/LdNz2+YJQSKn3D0iSNRUCZ5mghrSN0TJyQdUL0OdNnGgGkoqO1jDrSN6mklcR8J0ErspS0j7hNQHhLR+/weUUYSIUOWD9f4nyE4M4peEH3EG1w+ftSfxrRv5+8DwYzMgjBwkcxAl+F5fAwzJwE4iCOL/LJMqvyFvwe2S3zptPVFqGsoRFE/HsyERSFcsskUkbmc3IhKFeEp3UEwKVv65X1o+fKNJ+fXpYjR/U8e//OIP8c1yHKZrZNqbQS+8QTDEgZ7JdFgX8MS4PkT0pvWrLvQ9R5KwL3ULSIeb4u3nQRiyvoljraHafsYpoQR7oCLqm0PevkI+i9Frdc4A9dXF7nEToERTOWK4NJtN25HigDstyPOLRTjUkoZ2YpVb/0M5kwc7gqWToAiqZhqyPgtELrMMkjda/yPXvzfzwgQ6XHlw/l47W9OgAjBzyICnuaHcDkrZSBkl9xLB8b5AU32dolOegruvF4bj+1lCp6o9/ZE/QLh4PJQHyjQcJcRQUEN7PCTTffLklCib09wFoy1kQeAgmcVjodtizTVGEbdO+qrMvxi5p+qzawETut55mN8WgUdsYdNinlVeQP0FqtsWgzk4jLQ1ExBCJyGaMw4eALx8iAgu0AuP8Vd+H64LQQgF2THZKMaY2DGOwt1Y3tV3gCrW6iW0apkJfhU5a1ZCDAbrZ0Fhjv2XtYYBy6hgwaogBmt4vDBhxhL/FUzlkUUCZ+s4sblX2Tx4/pphQG/QYpwQ6Xwwxhg39YtIwhJ/JpwUhOTLUQ0hHpgxrMgwtxlXXkinD3UdXmMkgwTTJqS1SflLjlHAxe843zNsOMYceGKf0GafUOV/AM5t6uKUBnsi4PgefT+7v7g1QjnSFmRpyfD72qHwfa9QFUJrcNPsKn6l+uF5MkE/Uw3cFbMnE/b23DvB5ETr80TdMPQAQW4DlRUrOMSVmGVEnAkSFrwRRhzajQmrHViFVfq6fCaQ2dWHl3kLpa40a49/W9G4w1VaZKB/2wRTdPOyC3JO68wKV0YeZCyTBPO8M/AKThHjTFTw/NWUCM9XYg04g1yt4XDTO3jAAcTx2504wA9H5IrIlWP6VhsjiackrufcJCHFL4CzAnrPObEGPqB7j8CGaTX7hELfp2peCyIsQbxT+s4zxdwjLLuFxModxOjghX8UKmSwjrjBdzXamq6qzSKl1aJNVfh/bX/FMlzcxdR9T1ftUoudeHhgmLaLE4Ncbv8CYsAZNqXwQOTmMdDJm+0Y/zvVlk0dnVROQUm0j7ERMS42j5UdMp5Ah5quhpCmNkD0PVqw3DFoPbG6oHZtsVHpm7HCGwQsUZXG05amHKxiCdQbxm7Zu6x0mIrzH/q7uc3j6DnfyxacmCGbHZfp/9m1Xyph2c8/EGc+pFbp1bG+8xmt+VCHPA8KUOWbSJmotVeheFxMM++jqt6yAw1uIwRmfvYvQLHIWHSng+8eAk3sX2pX0X0vsVpnQVkvgr+02ONxosOZ/JIJLUVtVhgHqsRlgiszdI5uculJGpcYZWzbrYm6PTLISUz5e4QdSXLQIIVHBUIVntm+egRezSd5k5o1Z/gvdZ83ebBpBZLaeMXYY4XnN/m8Sm5stMntgsiR/YZApUmxYch8WkI9rIwxmysV56P0saGhKQ9CQpnGa55p5ZTaNwjE78gyx2pHBej13rBi3tYJq8sED18AHSTFUJqXXhFiFVwVLfhszg3vh82JhVt7dJxEMexc8c2Tsi88U+nSB8t8x9DVIze23vtQ0edTsV+KWyXs5NrHLPKbsjsPbotEbohQQZbqCMZxAHybnEtvMYkunkXjiKd7z9bB6bGmaEGb1a5XF5F1q38MELuBv6l9Q3tCihBbfzxQjzKb+GmkYYfFug2NgxN4u91rsyCGhHju0XmGHxXuDfwQeCR71MTF757Q5bpzpYLoMIuT7Awf/V6LPKw8yZYHEElSgkAYkl0tr+u3nQvm1vvkLqj8/WqPLcNAPHDkALzQeL4QvqvYLLkT+9my6e3CVz/aCJxg8JyDK1mE9EAJM7sCFIC7oJPg5Cpe+IrDIKyieJUIMBeF50hBipv50Hr6beNjw88NsOp+Ed+qgH9YIS+qDNA/hezaN9lOPVsa06rFbX169ShdW0xD6Xlf+kxj1MWS86mqXQR9CZp922jN4hknhMnz0kI+If28vIgd7LdJUffCL8lwlQPIrSjB+Jjk5fexK0MiuzrgzjQP7V3cf2lXdy+l8/Lsw30KbpVl74c7imdFISbvH6kmae0SC/rN6fGE5Uo7VzBiJxWiUlAXM8eEswL99MCVnCGJB1/E/0OYF9LxMkgFG8dSLnQkLnRx4VPPywrwmI2Hhjelnk/mKmnLBU7XYkDmdj5DcBLSXyiLLQk+VN3YaZGzsZo+LqQOik2XQpopH7tVSBAwSlUOUxyBRQAEncD9iQIwaGITL5GARe2U81ASx4JvY1W54uDsMuQSahURWQVh/tVG7w85tcmkzQ1RumiqJf4gDGIYgK+RKZnMPk1YPModlpbnqgq9It/awoCgMnc1OGPow5V+hNm9mPGVMFuU9nA006aIqeZYkaBKmqZx2hRNp1tNhxcW72oHBZgwbnZ0mO4wB3hBjTBIjD16TXF1FVytsn7YyNAUmy9UcwXQDB8d1UURDZdKyJhlALTN1CoXZGnctPJXxP0ABYD4WtKk5jIk+RGUxawGPhqYpnj91ec/S4Cg3RzqGH1kwUjkfaxNu84592RzqzdPW3NMmiIau3HFLep48U5NQVRkRbgnhByrjoBqx2+QxFzClF/btXlM7i6ka1nKBRHHib4MMgK6TqwYaoyls9mqq3+RvJAlO9H4UaJaaKVG5P1c9NhjdYAMns3pDcGhNZERWyE63Rps7EebJZNxGhNwKXiOf2unItbTtWwTllI4h1juJW1/mpKMqwZzUGSpjdEmuXCMo1tQrTtUDaXecMt6PCv8Ys8lkhUk2XPLhJx9SMFsuwtryN5zrl3PkZg0EHscpPJ5NFRkOTUV1wLqtImP3Q0l6uYzmZkct7NqtC/Nh2unuwo0FBeBqDtxH8tDBCkYoWIAUNlZOBIkHWrhbVoPYxDcRbS6iZpf7zAgt/RPKeqwUvNpo4aMViah87GoBvSbSMUuduS6V1QMWVt/dfb7OlirvNr9ur/94k+g2JbrTItNixbgf4b07iSvdV8gaJh2X1Ox74R3p+8cw4e6G2in5rX580Vp3zHUtNrK2eh6o7JYTNT7zAeM037e/blT3Z4MajA687MNTN4wsQTCBuGO/DKPRCWXHvSrCW/zy65/LRRqou6LBn/gUHoKEyiVi43N/jXRvp7smcro7/pOzjsdT5PvoaeyiwIPE244ZHpcU3R0u99es/zK5A1qXsXxiw6pBDc9+C3hHbmF2cdno2A1s8WbKdzzvfCffrhkGeCYvazdur5X97TVoO/64OPrZWKuMtB5/p3SL14N+ff87JbGTujsweVpbE3hG0Tgdd5yNeq5s78Hm1q/DJKvVwXICdo3lptWty2PIBw3dJZGTxqh6IMk2lX9b2Huh+HI+Rr3LjcHEWtZpB96/XDuzNV70K4ukdy36I0WO24a7j1UT6Tg8sH91dy4pugOnTc77YiQ+CqZwtozyanLTbI8UPLPi1tQWsJgs3TnoZm96CcrHjozvInaJ0hlVdiK3p330A7xeDkI5rNfrH62HYB5GeN42v3EiP3uAZBm1pCIAMuY4G/FslARGxzePvgw56sc6zAFSZjSUsvy70Bcp45Xxz4EHI6yF41bXISO0IWaQDjomQ56rnA27rC1cVRSnWAEj3UaHpJ/Hqf01hUExBb2QIXjivGArq9lHj6biNYvP3/6rE244j4Tukwg4j2GmylrOghA1mMRhtQTuJZOJfjaiyNnFtjKSxn98GCGyKrS1KDBV5l+RB0iPfwE=</diagram></mxfile>
```

`docs/index.md`:

```md
# Embuche overview

## Summary

- [Obstructing code analysis](./index.md#obstructing-code-analysis)
- [Detecting debuggers](./index.md#detecting-debuggers)
- [GCC options](./index.md#gcc-options)
- [File format hacks](./index.md#file-format-hacks)
- [Packer](./index.md#packer)

## Obstructing code analysis

Some anti-reversing techniques can only be set within the source code, to help you obstructing code analysis and tricking disassemblers you'll find a collection of C examples in the *snippets/* directory.

Here's the current snippets:

- **Jump over invalid bytes** (`always_follow_conditionnals.c`): Write some assembly that will be interpreted by the dissassembler but won't be executed by our program, this invalid bytes will be processed by the disassembler and mess with the disassembly it produces.  [MORE](./obstructing-code-analysis.md#always-follow-the-conditional)
- **Early return** (`early_return.c`): Trick the disassembler and prevent it to disassemble a function by forcing it to exit a function earlier. [MORE](./obstructing-code-analysis.md#early-return)
- **Indirect call** (`indirect_call.c`): Indirect call to function to limit cross-references in disassemblers.  [MORE](./obstructing-code-analysis.md#pointer-function-calls)
- **INT3** (`int3.c`): Stop the debugger if there's one attached. [MORE](./obstructing-code-analysis.md#int3)
- **Overlapping instructions** (`overlapping_instructions.c`): Write code that is executed twice but represents two different instructions.  [MORE](./obstructing-code-analysis.md#overlapping-instructions)
- **Xor stacked string** (`xor_stack_string.c`): Create xor stacked strings to prevent `strings`.
You can use `tools/c_xor.py.` to generate the C code. [MORE](./obstructing-code-analysis.md#prevent-strings)

## Detecting Debuggers

Some anti-debugging techniques can only be set in the C code. We've created a list of functions to detect debuggers.

The functions are located in `anti_debug.c`, this file will be automatically added in the `src` folder of your project at compilation, so if you want to use this function you just have to add the following lines at the start of your program:

```c
#include "anti_debug.h"

void __attribute__((constructor)) before_main()
{
  embuche_checker(1, 1, 1, 1, 1, 1);
}
```

Here's the prototype of `embuche_checker`:

`void embuche_checker(int dumpable, int ptrace, int file_descriptor, int pid, int ppid, int ld_preload)`

If you want to use an option, set the parameter to `1`.

Here's the techniques used to detect debugging:

- **dumpable**: Disable process memory dump. [MORE](./detect-debug.md#disable-core-dump)
- **ptrace**: Check if *ptrace* is already attached or not. **CAUTION: DON'T USE THIS OPTIONS IF YOU'VE IMPLEMENTED INT3 TECHNIQUE**. [MORE](./detect-debug.md#attach-to-ptrace)
- **file_descriptor**: Count the number of file descriptor to check if GDB is used. **CAUTION: THIS OPTIONS CANNOT BE SET WITH THE PACKER**. [MORE](./detect-debug.md#file-descriptor)
- **pid**: Check the process name to see if it's GDB. [MORE](./detect-debug.md#detect-GDB-by-its-pid)
- **ppid**: Check the name of the parent process to see if it's GDB. [MORE](./docs/detect-debug.md#check-the-parent-name)
- **ld_preload**: Check the environment variables to detect LD_PRELOAD. [MORE](./detect-debug.md#detect-ld_preload)

## GCC Options

The options used during the compilation modify the final binary, some of these options can give away a lot of information and help an attacker, others can strip away all unnecessary information, making the task of the attacker much harder.

Here's the list of GCC flags in Embuche by default:

- **Wall**: Show all warnings.
- **Wextra**: Show extra warnings (unused etc).
- **Wshadow**: Show local variable or type declaration that shadows other variables.
- **g0**: Disable debug informations. [MORE](./compiler-options.md#debugging-information)
- **std=gnu11**: C language dialect.

Available options for compilation:

- **strip** (-s): Remove `.symtab` section. [MORE](./compiler-options.md#delete-the-symbol-table-strip)
- **symbols_hidden** (-fvisibility=hidden): Hide `.dynsym` section. [MORE](./compiler-options.md#hide-symbol)
- **optimize** (-O3): Optimize code (level 3). [MORE](./compiler-options.md#optimization)
- **unroll_loops** (-funroll-all-loops): Undo loop structures. [MORE](./compiler-options.md#unroll-loops)
- **static** (-s): Use static dependencies instead of external ones (musl). [MORE](./compiler-options.md#static-compilation)

## File Format Hacks

It's possible to modify the ELF data structures after compilation in order to mess with disassemblers and make the reverse of a program harder.


Every techniques has a stand-alone script that you can use, there are located in `class_embuche/cmake_bakery/hellf_scripts`.

Each script takes an ELF as argument, for example:

```
./class_embuche/cmake_bakery/hellf_scripts/endianness_changer.py ./bin/myprogram
```


Here's the techniques available:

- **endianness** (`endianness_changer.py`): Change the endianness in the ELF header from little to big endian. [MORE](./docs/file-format-hacks.md#change-the-endianness)
- **remove_section_header** (`remove_sections.py`): Remove the section header table. [MORE](./docs/file-format-hacks.md#remove-section-header-table)
- **flip_sections_flags** (`flip_sections_flags.py`): Create a fake *.text* section with *RX* instead of *RW* and fake *.data* section with *RW* instead of *RX*. [MORE](./docs/file-format-hacks.md#create-fake-sections)
- **hide_entry_point** (`hide_entry_point.py`): Create a fake *.data* section that override the entry point. [MORE](./docs/file-format-hacks.md#hide-the-entry-point)
- **mixing_symbols** (`mixing_symbols_table.py`): Create a fake *.dynsym* section and mix symbols names. [MORE](./docs/file-format-hacks.md#mix-symbol-table)

To use *remove_section_header* & *flip_sections_flags* you must previously use *remove_section_header*.

If you want to combine *flip_sections_flags* & *hide_entry_point*, run `remove_section_header.py` and then `flip_sections_flags_and_hide_entry_point.py` (combination of *flip_sections_flags* and *hide_entry_point in one script*).

## Packer

A metamorphic packer is available in Embuche. This packer will load your binary and cipher it (AES 256 bits CBC).

If you decide to use the packer, your program will be ciphered and stored in a section of our packer. When you will execute your program the packer will copy itself in memory, unciphered your program and write it on the disk for execution.

Beside cipher your binary, the packer will also ensure its integrity. The encryption keys used for the encryption are based on the SHA sum of the `.text` section, so if the packer or your program is being debugged the SHA sum will be different of the one used for decryption.

There's two set of keys used by the packer to decipher the program:

- The SHA sum of the current `.text` section.
- The previous SHA sum of the `.text` section XOR'ed with the timestamp of the last run

The ELF of the packer can be modified with the `packer_embuche` options.
If this options is set the following techniques will be applied on the packer that contains your program:

- **endianness**: Change the endianness in the ELF header from little to big endian.
- **remove_section_header**: Remove the section header table.
- **flip_sections_flags**: Create a fake *.text* section with *RX* instead of *RW* and fake *.data* section with *RW* instead of *RX*.
- **hide_entry_point**: Create a fake *.data* section that override the entry point.

[MORE](./packer.md)

```

`docs/obstructing-code-analysis.md`:

```md
# Obstructing code analysis

## Summary

- [TL;DR](obstructing-code-analysis.md#tl-dr)
- [Target](obstructing-code-analysis.md#target)
- [Prevent strings](obstructing-code-analysis.md#prevent-strings)
- [Pointer function calls](obstructing-code-analysis.md#pointer-function-calls)
- [Early Return](obstructing-code-analysis.md#early-return)
- [Jump over invalid bytes](obstructing-code-analysis.md#jump-over-invalid-bytes)
- [Overlapping instructions](obstructing-code-analysis.md#overlapping-instructions)
- [INT3](obstructing-code-analysis.md#int3)
- [Final code](obstructing-code-analysis.md#final-code)

## TL;DR

- One way to prevent `strings` is to use stacked xor string.
- We can use pointers to call our functions and prevent cross references in IDA for example.
- It's possible to write assembly in our C code and add instructions that will be disassembled and obstruct the code analysis.
- We can mess with the disassembler by forcing it to exit earlier a function, make it disassemble invalid code or even use overlapping code that it won't be able to disassemble.
- You can add `INT3` instruction to stop debuggers whenever you want.

## Target

We'll use the same example we used in the previous articles, you can find the CMake in the first article of this serie (Compiler Options), but here's a reminder.

```c
#include <stdio.h>
#include <string.h>
#include "anti_debug.h"

void __attribute__((constructor)) before_main()
{
  dbg_checker();
}

int check_password(const char* p_password)
{
  char magnupass[9] = "MagnuB33r";
  return memcmp(magnupass, p_password, 9) != 0;
}

int main (int argc, char** argv) {

    if (argc != 2) {
        printf("Need exactly one argument.\n");
        return -1;
    }

    if (check_password(argv[1])) {
        printf("No, %s is not correct.\n", argv[1]);
        return 1;
    } else {
        printf("Yes, %s is correct!\n", argv[1]);
    }
    return 0;
}
```

The header file for anti_debug:

```c
#ifndef _ANTI_DEBUG_H_
#define _ANTI_DEBUG_H_

typedef int bool;
#define true 1
#define false 0

void dbg_checker();
int check_ptrace();
int dbg_file_descriptor();
int dbg_cmdline();
int dbg_getppid_name();
int various_ldpreload();

#endif
```

And the anti_debug.c:

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/prctl.h>

typedef int bool;
#define true 1
#define false 0

#define check_strings(str_buff) (strstr(str_buff, "gdb") || strstr(str_buff, "ltrace") || strstr(str_buff, "strace") || (strstr(str_buff, "radare2")) || (strstr(str_buff, "ida")))

void dbg_checker();
int check_ptrace();
int dbg_file_descriptor();
int dbg_cmdline();
int dbg_getppid_name();
int various_ldpreload();

void dbg_checker()
{
  /* prevent core dump */
  prctl(PR_SET_DUMPABLE, 0);

  if (check_ptrace() == 1)
  {
    exit(0);
  }

  if (dbg_file_descriptor() == 1)
  {
    exit(0);
  }

  if (dbg_cmdline() == 1)
  {
    exit(0);
  }

  if (dbg_getppid_name() == 1)
  {
    exit(0);
  }

  if (various_ldpreload() == 1)
  {
    exit(0);
  }
}

/* Check if ptrace is already attached */
int check_ptrace()
{
  return ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0;
}

/* 2 file descriptors when programs open with GDB. Both pointing to the program being debugged.*/
int dbg_file_descriptor()
{
    FILE* fd = fopen("/", "r");
    int nb_fd = fileno(fd);
    fclose(fd);

    return (nb_fd > 3);
}

/* Detect GDB by the mean of /proc/$PID/cmdline, which should no be "gdb" */
int dbg_cmdline()
{
    char buff [24], tmp [16];
    FILE* f;

    snprintf(buff, 24, "/proc/%d/cmdline", getppid());
    f = fopen(buff, "r");
    fgets(tmp, 16, f);
    fclose(f);

    return check_strings(tmp);
}

/* Check the parent's name */
int dbg_getppid_name()
{
    char buff1[24], buff2[16];
    FILE* f;

    snprintf(buff1, 24, "/proc/%d/status", getppid());
    f = fopen(buff1, "r");
    fgets(buff2, 16, f);
    fclose(f);

    return check_strings(buff2);
}

/* Try to detect the LD_PRELOAD trick by looking into environnement variables of the program. */
int various_ldpreload()
{
    return (getenv("LD_PRELOAD") != NULL);
}
```

## Prevent strings

With the current program, even if we modify the ELF file, set the good compiler options etc, we're still vulnerable to the best reverse tool for crackmes: `strings`. (The output has been truncated)

```bash
magnussen@funcMyLife:~/embuche/build$ strings ./crackme
MagnuB33r
```

One way to prevent `strings` is to add each byte of our string into the stack one by one.

We'll hide the construction of our string with stacked string. Here's the code:

```c
int check_password(const char* p_password)
{
  char magnupass[10] = {'M', 'a', 'g', 'n', 'u', 'B', '3', '3', 'r', 0};
  return memcmp(magnupass, p_password, 10) != 0;
}
```

If we use `strings`, our password is not visible, but we can still find it easily with radare2 for example.

```
|           0x563fa9d2b955      c645ee4d       mov byte [local_12h], 0x4d ; 'M' ; 77
|           0x563fa9d2b959      c645ef61       mov byte [local_11h], 0x61 ; 'a' ; 97
|           0x563fa9d2b95d      c645f067       mov byte [local_10h], 0x67 ; 'g' ; 103
|           0x563fa9d2b961      c645f16e       mov byte [local_fh], 0x6e ; 'n' ; 110
|           0x563fa9d2b965      c645f275       mov byte [local_eh], 0x75 ; 'u' ; 117
|           0x563fa9d2b969      c645f342       mov byte [local_dh], 0x42 ; 'B' ; 66
|           0x563fa9d2b96d      c645f433       mov byte [local_ch], 0x33 ; '3' ; 51
|           0x563fa9d2b971      c645f533       mov byte [local_bh], 0x33 ; '3' ; 51
|           0x563fa9d2b975      c645f672       mov byte [local_ah], 0x72 ; 'r' ; 114
```

One way to prevent that, is to ciphered our string with a xor, it's simple but an attacker will have to find the key to decrypt our string.

Here's the final `check_password` function and the function to xor our string to retrieve the clear string:

```c
char* undo_xor_string(char* string, int length, char* key, int key_length)
{
    for (int i = 0; i < length; i++)
    {
        string[i] = string[i] ^ key[i % key_length];
    }

    return string;
}

int check_password(const char* p_password)
{
  char magnupass[10] = {0x39, 0xbe, 0xaf, 0xc3, 0x98, 0xd9, 0x27, 0xf0, 0xc4, 0};
  char key_pass[10] = {0x74, 0xdf, 0xc8, 0xad, 0xed, 0x9b, 0x14, 0xc3, 0xb6, 0};

  return memcmp(undo_xor_string(magnupass, 10, key_pass, 10), p_password, 10) != 0;
}
```

Our string is still visible, but with the next parts we'll be able to alter the way a disassembler process our decryption function and make our string more difficult to retrieve.

## Pointer function calls

Disassemblers are oftenly able to show how functions are connected with cross references.

For example, even if we don't have the symbol table, it's still pretty obvious that our crackme depends on this function.

![Call function](./img/pointer_functions.png)

One way to prevent that, is to use indirect references to our `check_password` function.

To do that we can use functions pointers and mess a little with its value to prevent IDA to know where the pointer refers to.

```c
int main (int argc, char** argv) {
    bool (*indirect_call)(const char*) = NULL;

    indirect_call = check_password - 0x100;

    if (argc != 2) {
        printf("Need exactly one argument.\n");
        return -1;
    }
    indirect_call = indirect_call + 0x100;

    if ((*indirect_call)(argv[1])) {
        printf("No, %s is not correct.\n", argv[1]);
        return 1;
    } else {
        printf("Yes, %s is correct!\n", argv[1]);
    }
    return 0;
}
```

We defined a NULL pointer to prevent IDA to determine the location it refers, we store the value of the `check_password` function minus 0x100, like that our pointer will not refer to the proper function but we'll be able use it later by adding 0x100.

When we need to use our function, we simply add 0x100 to our pointer to refer to the `check_password` function and call it like we normally do.

![Indirect References](./img/indirect_references.png)

The `check_password` function isn't directly called in our code, so IDA isn't able to create cross references.

## Early Return

First of all, to understand this part we need to understand how a disassembler works.

A disassembler has two options:

- Linear sweep: It reads the first N-bytes until it gets a correct opcode. If the data are bad, it proceeds until it gets the next valid opcode.
- Recursive Traversal: It reads the first N-bytes until it gets a correct opcode. It keeps disassemble until it finds any sort of jump, then it store is the current position, follow the jump and proceed as described. It stops when it gets an invalid opcode and resume at the previously stored position.

What it means, is that disassembler reads N-Bytes and try to find a correct opcode and leave the data if they don't match opcodes.

We can trick the disassembler and prevent it to disassemble a function by forcing it to exit a function earlier.

Let's take the following example:

```asm
extern char* __executable_start;

char* calc_addr(char* p_addr)
{
    return p_addr + (unsigned long)&__executable_start;
}

int __attribute__((optimize("O1"))) main()
{
  char* label_address = 0;

  label_address = calc_addr(((char*)&&return_here) - (unsigned long)&__executable_start);

  asm volatile(
  "push %0\n"
  "ret\n"
  ".string \"\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\""
  :
  : "g"(label_address));

  return_here:

  return 0;
}
```

Our main function just returns 0, it doesn't do anything else.

What we do is that we add some assembly code to force the disassembler to exit our main earlier with:

```
push %0
ret
```

We also add some garbage to prevent it to disassemble more code with:

```
.string \"\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\"
```

So basically the disassembler will see that the function is over (push; ret) and confirms it with the garbage we added and that doesn't match any opcode. The disassembler will stop processing our main function and hide the `return 0;`.

In order to prevent the execution of our early return (the main will exit without returning 1), we have to say to the program to pass the assembly and go directly after it.

To do that we can use a label:

```c
label_address = calc_addr(((char*)&&return_here) - (unsigned long)&__executable_start);

return_here:

```

Essentially the first line calculates the offset we are (current address (&&return_here) minus the base address of our program (&__executable_start)) and go to this address (return_here:). This line allows us to pass the assembly code and execute the program normally.

As seen in the previous part, we mess with the label address to prevent cross references.
We use `calc_addr` to retrieve the right address to go to.

The last thing we have to do, is set an attribute (`__attribute__((optimize("O1")))`) to our function to prevent the assembly from being optimized at compilation.

So basically what we do is put some assembly code that will be disassembled, but won't be executed to force the disassembler to quit the function earlier.

## Jump over invalid bytes

Now that we know how to mess with a disassembler, we can use other techniques like setting invalid bytes to be disassembled.

We know that a disassembler takes N-bytes and try to find a valid opcode. As seen previously, it's possible for us to put some assembly that will be interpreted by the dissassembler but won't be executed by our program.

We can use the following code to fool the disassembler:

```
asm volatile(
  "jmp unaligned\n"
  ".short 0xe8\n"
  "unaligned:");
```

We insert an invalid byte that will be processed by the disassembler.

The disassembler will try to find an opcode with this invalid byte and will mess the next assembly it'll produce.

We want this invalid byte to be ignored at runtime, so we simply jump over it with a label.

At runtime, the invalid byte will be ignored, but it will processed by the disassembler and mess with the assembly code it produces.

The problem with this code is that a smart disassembler will be able to pass this invalid byte as it knows that the invalid byte will never be executed.

To prevent that we can use a conditional jump:

```
asm volatile(
  "jz unaligned+1\n"
  "jnz unaligned+1\n"
  "unaligned:\n"
  ".byte 0xe8\n");
```

So we use the same logic as the previous code, we jump over the invalid byte (unaligned+1) if the condition is true or false (so in all cases), but the disassembler will this time disassemble our invalid byte.

The only problem is that the double jump is pretty distinctive.

We can replace this double jump by a conditional jump that will always be true.

```
asm volatile(
  "xor %%rax, %%rax\n"
  "jz always_here + 1\n"
  "always_here:\n"
  ".byte 0xe8\n"
  : :
  : "%rax");
```

If we xor a register with itself, the result will be 0, so it will always take the jump `jz` (jump if zero) and jump over our invalid byte.

With the last code we mess with the disassembler by injecting an invalid byte that will be disassembled, but never executed as the condition is always true (we jump over it).

## Overlapping instructions

The next technique we can use to fool even the smarter disassembler is overlapping instructions.

It's possible to write code that is executed twice but represents two different instructions, this will be a problem for the disassembler.

There's an important concept that we left out until now, a disassembler only disassemble once. It means once an instruction has been disassembled, it won't disassemble it again.

For example, if we call a function multiple times, the dissassembler will process it the first time, but it won't disassembled it again because it knows that the function was already been disassembled.

This will be useful for our next technique. We'll use the following code:

```
asm volatile(
  "mov_ins:\n"
  "mov $2283, %%rax\n"
  "xor %%rax, %%rax\n"
  "jz mov_ins+3\n"
  ".byte 0xe8\n"
  : :
  : "%rax");
```

So we move 0xe8b into rax, we clear rax, and jump to mov_ins label plus three. Nothing too harmful at first.

But the jump to mov_ins plus three is in the middle of the first mov instruction.
The assembly that starts at this position (mov_ins+3) is a jump that skips the remaining code of this block to the next byte of legitimate code.

So basically the disassembler doesn't follow our `jz mov_ins+3` but our code does, and when our code jump to this position it finds a jump that pass all the instructions we added until the next block of valid code.

The disassembler is unable to process the next chunk of code because it hasn't followed the `js mov_ins+3` but our code did.

That one is pretty vicious...

## INT3

If you're used to debuggers, you probably know a very convenient feature: breakpoints.

A breakpoint allows you to stop the execution of a program when it reaches a position to investigate on the code at this position.

It's really convenient when you want to debug a program, but it can be really annoying if you don't set them yourself and the program keeps stopping its execution.

A INT3 instruction is used by debuggers to temporarily replace an instruction in a running program in order to set a code breakpoint. The program will return a signal that will be handled by the debugger when it reach that instruction.

When the program is executed outside a debugger, the signal isn't handle so the program continues its execution, but when it's executed inside a debugger, the signal is handled by the debugger and the program wait for the "continue" signal to pursue its execution.

We can set INT3 instruction in our program to force a debugger to stop when an attacker tries to debug our code. The main purpose of this technique is just to annoy the attacker when it debugs our program by stopping its debugger regularly.

```c
void int3_shield(int signo);

int main(int argc, char **argv){

    signal(SIGTRAP, int3_shield); // place this line at the beginning of your main() function
    __asm__("int3"); // Place this line wherever you want in your program, it will stop the debugger in its tracks.
    // you can put it multiple times if you want, try not to place it in "sensitive areas" where the code is important

    return 0;
}

// put this in your .h or in your code
void int3_shield(int signo){
}
```

This technique is pretty simple to implement, we just place the `int3` instruction in our code multiple time to force the debugger to stop when it reads this instruction.

## Final code

So here's the final code to mess with disassembler:

```c
#include <stdio.h>
#include <string.h>
#include "anti_debug.h"

extern char* __executable_start;

void __attribute__((constructor)) before_main()
{
  dbg_checker();
}

char* calc_addr(char* p_addr)
{
    return p_addr + (unsigned long)&__executable_start;
}

char* undo_xor_string(char* string, int length, char* key, int key_length)
{
    for (int i = 0; i < length; i++)
    {
        string[i] = string[i] ^ key[i % key_length];
    }

    return string;
}

int check_password(const char* p_password)
{
  char magnupass[10] = {0x39, 0xbe, 0xaf, 0xc3, 0x98, 0xd9, 0x27, 0xf0, 0xc4, 0};
  char key_pass[10] = {0x74, 0xdf, 0xc8, 0xad, 0xed, 0x9b, 0x14, 0xc3, 0xb6, 0};

  return memcmp(undo_xor_string(magnupass, 10, key_pass, 10), p_password, 10) != 0;
}

int __attribute__((optimize("O1"))) main (int argc, char** argv) {
    bool (*indirect_call)(const char*) = NULL;
    char* label_address = 0;

    asm volatile(
    "mov_ins:\n"
    "mov $2283, %%rax\n"
    "xor %%rax, %%rax\n"
    "jz mov_ins+3\n"
    ".byte 0xe8\n"
    : :
    : "%rax");

    asm volatile(
      "xor %%rax, %%rax\n"
      "jz always_here + 1\n"
      "always_here:\n"
      ".byte 0xe8\n"
      : :
      : "%rax");

    indirect_call = check_password - 0x100;

    if (argc != 2) {
        printf("Need exactly one argument.\n");
        return -1;
    }

    label_address = calc_addr(((char*)&&return_here) - (unsigned long)&__executable_start);

    asm volatile(
    "push %0\n"
    "ret\n"
    ".string \"\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\""
    :
    : "g"(label_address));

    indirect_call = indirect_call + 0x100;

    if ((*indirect_call)(argv[1])) {
        printf("No, %s is not correct.\n", argv[1]);
        return 1;
    } else {
        printf("Yes, %s is correct!\n", argv[1]);
    }
    return 0;
}
```

```

`docs/packer.md`:

```md
# Embuche packer

## Summary

- [TL;DR](packer.md#tl-dr)
- [Before compilation](packer.md#before-compilation)
  - [Adding a section](packer.md#adding-a-section)
  - [Linker scripts](packer.md#linker-scripts)
- [Post compilation](packer.md#post-compilation)
- [Runtime](packer.md#runtime)

A metamorphic packer is available with Embuche. This packer loads a binary and cipher it (AES 256 bits CBC).

The program is ciphered and stored in a section of the packer. When the program is executed, the packer will copy itself in memory, unciphered the program and write it on the disk for execution.

## TL;DR

- Embuche's packer cipher the program and store it in the `.fini.` section
- The `.fini.` section is loaded in memory at runtime.
- The `.text` section (code of the program) is encrypted in AES 256 bits CBC.
- The key and ciphered program changes at each execution as it's the result of sha256sum(`.text`) xor'ed with the timestamp at runtime.

## Before compilation

The packer needs to host the legitimate program in order to load it at runtime. In order to do that we have to prepare the packer to receive the program by adding a section of the size of the program in the packer.

The packer will cipher our program (AES 256 bits CBC) before adding it to a section.

### Adding a section

The program will be stored in a section of the packer. We need to prepare the packer to host the legitimate program.

The ELF of the program will be stored in a section called `.fini.` in order to look like a legitimate section.

We have to know the size of the program if we want to create this new section. As the program will be ciphered with AES in this section we have to know the size of the program once padded (*PKCS#5*).

The packer script ([packer.py](../class_embuche/cmake_bakery/packer/scripts/packer.py)) will return the size of a program once padded.

```bash
magnussen@funcMyLife:~/embuche$ python3.8 class_embuche/cmake_bakery/packer/scripts/packer.py crackme
13648
```

Now that we know that the size of our binary once ciphered is 13648 bytes we can create a new section of this size.

We can create a new section in C as such:

```C
extern char stack[REAL_SIZE] __attribute__ ((section (".fini.")));
```

The **make** file will pass the value of *REAL_SIZE* to GCC at compilation (through a *#define* directive) and GCC will add a section called *.fini.* of the size of our padded program in our packer.

In order to launch the program, we have to map this new section in memory. In order to make this section executable we have to describe it in a segment.

We use `memfd_create` in order to create this segment and load our section in memory.

We can see this new section and segment with `eu-readelf`.

![image-20200610185015460](img/readelf.png)

### Linker scripts

The packer needs to know the size and address of the `.text` section in order to create the keys used to ciphered and deciphered the program that it stored.

Unfortunately, this information is only available after completion.

We can use *linker scripts* to retrieve these informations. The linker is in charge of adding sections, edit links etc during the compilation.

We use a linker script ([layout.lds](../class_embuche/cmake_bakery/packer/src/layout.lds)) to define two variables that will store the address and size of the `.text` section:

```
SECTIONS
{
    text_addr = ADDR(.text);
    text_size = SIZEOF(.text);
}
```

We define these two variables in our [packer](../class_embuche/cmake_bakery/packer/includes/consts.h) as such:

```C
#ifndef CONSTS_H
#define CONSTS_H

[...]

extern void *text_size;
extern void* text_addr;

#endif /* CONSTS_H */
```

We can check the presence of these two variables with `nm`:

```
 λ ackira ~/projets/embuche/switch_stuff/v2/build [master●] » nm ../bin/packed | grep text
[...]
0000000000401220 T text_addr
0000000000000bd5 A text_size
```

## Post compilation

Once we compile our packer we have the `.fini.` section initialized and the keys to cipher our program.

We cipher our program with the sha256sum of the `.text` section and insert the ciphered program in the `.fini.` section with **HELLF**.

```python
    surprise = unloaded.get_section_by_name(".fini.")
    text = unloaded.get_section_by_name(".text")

    # computing .text section sha256
    text_sum = sha256(text.data).hexdigest()
    print(good(".text sha256 sum : ") + text_sum)

    key = bytearray.fromhex(text_sum)

    binary_to_be_packed = pad(open(argv[2], "rb").read(), 16)

    encryptor = AES.new(key, AES.MODE_CBC, iv)

    # we are adding 16 bytes of metadata, which are the place holder for the timestamp of the last run and the address of the .fini. section on disk.
    encrypted = (
        pack("<Q", 0)
        + pack("<Q", surprise.sh_offset)
        + encryptor.encrypt(binary_to_be_packed)
    )

    surprise.data = encrypted
    print(good("encrypted binary size : {}".format(len(encrypted))))

    unloaded.save(argv[3])
```

## Runtime

At the first execution the key used for decryption is just the sha256sum of the `.text` section. But once the program has been run once, the key used for decryption is the sha256sum of the `.text` section xor'ed with the timestamp of the last execution (sha256(.text) ^ timestamp).

In order to use the timestamp of the last execution and load the program we store 16 bytes at the start of the ciphered program in the `.fini.` section:

- First 8 bytes: Timestamp of the last execution.
- Last 8 bytes: Address of the `.fini.` section. The section address is different of the mapped address of the section (*stack*). This variable is used to write the `.fini` section on disk at runtime.

By using the sha256sum we ensure the integrity of the program. If an attacker place a breakpoint at runtime, the `.text` section will be modified (the debugger insert `int3` or `Oxcc` instruction) and the packer won't be able to decipher the legitimate program.

To ensure this integrity at each run, the packer recipher the program at each execution with the timestamp of execution. So at the next run, the new timestamp will be used to decipher the program.

So when the packer is run:

- It recreates the key to decipher the program by xor'ing the last timestamp with the sha256sum of `.text` section (or just uses the sha256sum if it's the first execution).
- Loads the `.text` in memory to run it.
- Ciphers the `.text` section with the timestamp.
- Writes the new ciphered `.text` section and timestamp for the next run.

![](img/packer.gif)

```

`embuche.py`:

```py
#!/usr/bin/python3.8
# coding: utf-8
import argparse
from class_embuche.embuche import embuche

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Embuche, anti-reverse helper.')
    parser.add_argument('config_file', type=str, help='Anti-reverse compilation.')
    args = parser.parse_args()

    embuche = embuche(args.config_file)
    embuche.prepare_cmake()
    embuche.run()

```

`example/crackme/CMakeLists.txt`:

```txt
project(crackme)
cmake_minimum_required(VERSION 3.0)

set(EXECUTABLE_OUTPUT_PATH "../bin")
set(hellf_script_path /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/class_embuche/cmake_bakery/hellf_scripts)



set(CMAKE_C_FLAGS "-Wall -Wextra -Wshadow -g0 -fstack-protector-all -std=gnu11")

add_executable(${PROJECT_NAME} src/${PROJECT_NAME}.c src/anti_debug.c )




```

`example/crackme/build/CMakeCache.txt`:

```txt
# This is the CMakeCache file.
# For build in directory: /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build
# It was generated by CMake: /opt/cmake/bin/cmake
# You can edit this file to change values found and used by cmake.
# If you do not want to change any of the values, simply exit the editor.
# If you do want to change a value, simply edit, save, and exit the editor.
# The syntax for the file is as follows:
# KEY:TYPE=VALUE
# KEY is the name of a variable in the cache.
# TYPE is a hint to GUIs for the type of VALUE, DO NOT EDIT TYPE!.
# VALUE is the current value for the KEY.

########################
# EXTERNAL cache entries
########################

//Path to a program.
CMAKE_ADDR2LINE:FILEPATH=/usr/bin/addr2line

//Path to a program.
CMAKE_AR:FILEPATH=/usr/bin/ar

//Choose the type of build, options are: None Debug Release RelWithDebInfo
// MinSizeRel ...
CMAKE_BUILD_TYPE:STRING=

//Enable/Disable color output during build.
CMAKE_COLOR_MAKEFILE:BOOL=ON

//CXX compiler
CMAKE_CXX_COMPILER:FILEPATH=/usr/bin/c++

//A wrapper around 'ar' adding the appropriate '--plugin' option
// for the GCC compiler
CMAKE_CXX_COMPILER_AR:FILEPATH=/usr/bin/gcc-ar-7

//A wrapper around 'ranlib' adding the appropriate '--plugin' option
// for the GCC compiler
CMAKE_CXX_COMPILER_RANLIB:FILEPATH=/usr/bin/gcc-ranlib-7

//Flags used by the CXX compiler during all build types.
CMAKE_CXX_FLAGS:STRING=

//Flags used by the CXX compiler during DEBUG builds.
CMAKE_CXX_FLAGS_DEBUG:STRING=-g

//Flags used by the CXX compiler during MINSIZEREL builds.
CMAKE_CXX_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG

//Flags used by the CXX compiler during RELEASE builds.
CMAKE_CXX_FLAGS_RELEASE:STRING=-O3 -DNDEBUG

//Flags used by the CXX compiler during RELWITHDEBINFO builds.
CMAKE_CXX_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG

//C compiler
CMAKE_C_COMPILER:FILEPATH=/usr/bin/cc

//A wrapper around 'ar' adding the appropriate '--plugin' option
// for the GCC compiler
CMAKE_C_COMPILER_AR:FILEPATH=/usr/bin/gcc-ar-7

//A wrapper around 'ranlib' adding the appropriate '--plugin' option
// for the GCC compiler
CMAKE_C_COMPILER_RANLIB:FILEPATH=/usr/bin/gcc-ranlib-7

//Flags used by the C compiler during all build types.
CMAKE_C_FLAGS:STRING=

//Flags used by the C compiler during DEBUG builds.
CMAKE_C_FLAGS_DEBUG:STRING=-g

//Flags used by the C compiler during MINSIZEREL builds.
CMAKE_C_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG

//Flags used by the C compiler during RELEASE builds.
CMAKE_C_FLAGS_RELEASE:STRING=-O3 -DNDEBUG

//Flags used by the C compiler during RELWITHDEBINFO builds.
CMAKE_C_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG

//Path to a program.
CMAKE_DLLTOOL:FILEPATH=CMAKE_DLLTOOL-NOTFOUND

//Flags used by the linker during all build types.
CMAKE_EXE_LINKER_FLAGS:STRING=

//Flags used by the linker during DEBUG builds.
CMAKE_EXE_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the linker during MINSIZEREL builds.
CMAKE_EXE_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the linker during RELEASE builds.
CMAKE_EXE_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the linker during RELWITHDEBINFO builds.
CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//Enable/Disable output of compile commands during generation.
CMAKE_EXPORT_COMPILE_COMMANDS:BOOL=OFF

//Install path prefix, prepended onto install directories.
CMAKE_INSTALL_PREFIX:PATH=/usr/local

//Path to a program.
CMAKE_LINKER:FILEPATH=/usr/bin/ld

//Path to a program.
CMAKE_MAKE_PROGRAM:FILEPATH=/usr/bin/make

//Flags used by the linker during the creation of modules during
// all build types.
CMAKE_MODULE_LINKER_FLAGS:STRING=

//Flags used by the linker during the creation of modules during
// DEBUG builds.
CMAKE_MODULE_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the linker during the creation of modules during
// MINSIZEREL builds.
CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the linker during the creation of modules during
// RELEASE builds.
CMAKE_MODULE_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the linker during the creation of modules during
// RELWITHDEBINFO builds.
CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//Path to a program.
CMAKE_NM:FILEPATH=/usr/bin/nm

//Path to a program.
CMAKE_OBJCOPY:FILEPATH=/usr/bin/objcopy

//Path to a program.
CMAKE_OBJDUMP:FILEPATH=/usr/bin/objdump

//Value Computed by CMake
CMAKE_PROJECT_DESCRIPTION:STATIC=

//Value Computed by CMake
CMAKE_PROJECT_HOMEPAGE_URL:STATIC=

//Value Computed by CMake
CMAKE_PROJECT_NAME:STATIC=crackme

//Path to a program.
CMAKE_RANLIB:FILEPATH=/usr/bin/ranlib

//Path to a program.
CMAKE_READELF:FILEPATH=/usr/bin/readelf

//Flags used by the linker during the creation of shared libraries
// during all build types.
CMAKE_SHARED_LINKER_FLAGS:STRING=

//Flags used by the linker during the creation of shared libraries
// during DEBUG builds.
CMAKE_SHARED_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the linker during the creation of shared libraries
// during MINSIZEREL builds.
CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the linker during the creation of shared libraries
// during RELEASE builds.
CMAKE_SHARED_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the linker during the creation of shared libraries
// during RELWITHDEBINFO builds.
CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//If set, runtime paths are not added when installing shared libraries,
// but are added when building.
CMAKE_SKIP_INSTALL_RPATH:BOOL=NO

//If set, runtime paths are not added when using shared libraries.
CMAKE_SKIP_RPATH:BOOL=NO

//Flags used by the linker during the creation of static libraries
// during all build types.
CMAKE_STATIC_LINKER_FLAGS:STRING=

//Flags used by the linker during the creation of static libraries
// during DEBUG builds.
CMAKE_STATIC_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the linker during the creation of static libraries
// during MINSIZEREL builds.
CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the linker during the creation of static libraries
// during RELEASE builds.
CMAKE_STATIC_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the linker during the creation of static libraries
// during RELWITHDEBINFO builds.
CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//Path to a program.
CMAKE_STRIP:FILEPATH=/usr/bin/strip

//If this value is on, makefiles will be generated without the
// .SILENT directive, and all commands will be echoed to the console
// during the make.  This is useful for debugging only. With Visual
// Studio IDE projects all commands are done without /nologo.
CMAKE_VERBOSE_MAKEFILE:BOOL=FALSE

//Value Computed by CMake
crackme_BINARY_DIR:STATIC=/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build

//Value Computed by CMake
crackme_SOURCE_DIR:STATIC=/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme


########################
# INTERNAL cache entries
########################

//ADVANCED property for variable: CMAKE_ADDR2LINE
CMAKE_ADDR2LINE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_AR
CMAKE_AR-ADVANCED:INTERNAL=1
//This is the directory where this CMakeCache.txt was created
CMAKE_CACHEFILE_DIR:INTERNAL=/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build
//Major version of cmake used to create the current loaded cache
CMAKE_CACHE_MAJOR_VERSION:INTERNAL=3
//Minor version of cmake used to create the current loaded cache
CMAKE_CACHE_MINOR_VERSION:INTERNAL=16
//Patch version of cmake used to create the current loaded cache
CMAKE_CACHE_PATCH_VERSION:INTERNAL=8
//ADVANCED property for variable: CMAKE_COLOR_MAKEFILE
CMAKE_COLOR_MAKEFILE-ADVANCED:INTERNAL=1
//Path to CMake executable.
CMAKE_COMMAND:INTERNAL=/opt/cmake/bin/cmake
//Path to cpack program executable.
CMAKE_CPACK_COMMAND:INTERNAL=/opt/cmake/bin/cpack
//Path to ctest program executable.
CMAKE_CTEST_COMMAND:INTERNAL=/opt/cmake/bin/ctest
//ADVANCED property for variable: CMAKE_CXX_COMPILER
CMAKE_CXX_COMPILER-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_COMPILER_AR
CMAKE_CXX_COMPILER_AR-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_COMPILER_RANLIB
CMAKE_CXX_COMPILER_RANLIB-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS
CMAKE_CXX_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS_DEBUG
CMAKE_CXX_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS_MINSIZEREL
CMAKE_CXX_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS_RELEASE
CMAKE_CXX_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS_RELWITHDEBINFO
CMAKE_CXX_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_COMPILER
CMAKE_C_COMPILER-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_COMPILER_AR
CMAKE_C_COMPILER_AR-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_COMPILER_RANLIB
CMAKE_C_COMPILER_RANLIB-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS
CMAKE_C_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_DEBUG
CMAKE_C_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_MINSIZEREL
CMAKE_C_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_RELEASE
CMAKE_C_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_RELWITHDEBINFO
CMAKE_C_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_DLLTOOL
CMAKE_DLLTOOL-ADVANCED:INTERNAL=1
//Path to cache edit program executable.
CMAKE_EDIT_COMMAND:INTERNAL=/opt/cmake/bin/ccmake
//Executable file format
CMAKE_EXECUTABLE_FORMAT:INTERNAL=ELF
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS
CMAKE_EXE_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_DEBUG
CMAKE_EXE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_MINSIZEREL
CMAKE_EXE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_RELEASE
CMAKE_EXE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXPORT_COMPILE_COMMANDS
CMAKE_EXPORT_COMPILE_COMMANDS-ADVANCED:INTERNAL=1
//Name of external makefile project generator.
CMAKE_EXTRA_GENERATOR:INTERNAL=
//Name of generator.
CMAKE_GENERATOR:INTERNAL=Unix Makefiles
//Generator instance identifier.
CMAKE_GENERATOR_INSTANCE:INTERNAL=
//Name of generator platform.
CMAKE_GENERATOR_PLATFORM:INTERNAL=
//Name of generator toolset.
CMAKE_GENERATOR_TOOLSET:INTERNAL=
//Source directory with the top level CMakeLists.txt file for this
// project
CMAKE_HOME_DIRECTORY:INTERNAL=/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme
//Install .so files without execute permission.
CMAKE_INSTALL_SO_NO_EXE:INTERNAL=1
//ADVANCED property for variable: CMAKE_LINKER
CMAKE_LINKER-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MAKE_PROGRAM
CMAKE_MAKE_PROGRAM-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS
CMAKE_MODULE_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_DEBUG
CMAKE_MODULE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL
CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_RELEASE
CMAKE_MODULE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_NM
CMAKE_NM-ADVANCED:INTERNAL=1
//number of local generators
CMAKE_NUMBER_OF_MAKEFILES:INTERNAL=1
//ADVANCED property for variable: CMAKE_OBJCOPY
CMAKE_OBJCOPY-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_OBJDUMP
CMAKE_OBJDUMP-ADVANCED:INTERNAL=1
//Platform information initialized
CMAKE_PLATFORM_INFO_INITIALIZED:INTERNAL=1
//ADVANCED property for variable: CMAKE_RANLIB
CMAKE_RANLIB-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_READELF
CMAKE_READELF-ADVANCED:INTERNAL=1
//Path to CMake installation.
CMAKE_ROOT:INTERNAL=/opt/cmake/share/cmake-3.16
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS
CMAKE_SHARED_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_DEBUG
CMAKE_SHARED_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL
CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_RELEASE
CMAKE_SHARED_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SKIP_INSTALL_RPATH
CMAKE_SKIP_INSTALL_RPATH-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SKIP_RPATH
CMAKE_SKIP_RPATH-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS
CMAKE_STATIC_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_DEBUG
CMAKE_STATIC_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL
CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_RELEASE
CMAKE_STATIC_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STRIP
CMAKE_STRIP-ADVANCED:INTERNAL=1
//uname command
CMAKE_UNAME:INTERNAL=/bin/uname
//ADVANCED property for variable: CMAKE_VERBOSE_MAKEFILE
CMAKE_VERBOSE_MAKEFILE-ADVANCED:INTERNAL=1


```

`example/crackme/build/CMakeFiles/3.16.8/CMakeCCompiler.cmake`:

```cmake
set(CMAKE_C_COMPILER "/usr/bin/cc")
set(CMAKE_C_COMPILER_ARG1 "")
set(CMAKE_C_COMPILER_ID "GNU")
set(CMAKE_C_COMPILER_VERSION "7.5.0")
set(CMAKE_C_COMPILER_VERSION_INTERNAL "")
set(CMAKE_C_COMPILER_WRAPPER "")
set(CMAKE_C_STANDARD_COMPUTED_DEFAULT "11")
set(CMAKE_C_COMPILE_FEATURES "c_std_90;c_function_prototypes;c_std_99;c_restrict;c_variadic_macros;c_std_11;c_static_assert")
set(CMAKE_C90_COMPILE_FEATURES "c_std_90;c_function_prototypes")
set(CMAKE_C99_COMPILE_FEATURES "c_std_99;c_restrict;c_variadic_macros")
set(CMAKE_C11_COMPILE_FEATURES "c_std_11;c_static_assert")

set(CMAKE_C_PLATFORM_ID "Linux")
set(CMAKE_C_SIMULATE_ID "")
set(CMAKE_C_COMPILER_FRONTEND_VARIANT "")
set(CMAKE_C_SIMULATE_VERSION "")



set(CMAKE_AR "/usr/bin/ar")
set(CMAKE_C_COMPILER_AR "/usr/bin/gcc-ar-7")
set(CMAKE_RANLIB "/usr/bin/ranlib")
set(CMAKE_C_COMPILER_RANLIB "/usr/bin/gcc-ranlib-7")
set(CMAKE_LINKER "/usr/bin/ld")
set(CMAKE_MT "")
set(CMAKE_COMPILER_IS_GNUCC 1)
set(CMAKE_C_COMPILER_LOADED 1)
set(CMAKE_C_COMPILER_WORKS TRUE)
set(CMAKE_C_ABI_COMPILED TRUE)
set(CMAKE_COMPILER_IS_MINGW )
set(CMAKE_COMPILER_IS_CYGWIN )
if(CMAKE_COMPILER_IS_CYGWIN)
  set(CYGWIN 1)
  set(UNIX 1)
endif()

set(CMAKE_C_COMPILER_ENV_VAR "CC")

if(CMAKE_COMPILER_IS_MINGW)
  set(MINGW 1)
endif()
set(CMAKE_C_COMPILER_ID_RUN 1)
set(CMAKE_C_SOURCE_FILE_EXTENSIONS c;m)
set(CMAKE_C_IGNORE_EXTENSIONS h;H;o;O;obj;OBJ;def;DEF;rc;RC)
set(CMAKE_C_LINKER_PREFERENCE 10)

# Save compiler ABI information.
set(CMAKE_C_SIZEOF_DATA_PTR "8")
set(CMAKE_C_COMPILER_ABI "ELF")
set(CMAKE_C_LIBRARY_ARCHITECTURE "x86_64-linux-gnu")

if(CMAKE_C_SIZEOF_DATA_PTR)
  set(CMAKE_SIZEOF_VOID_P "${CMAKE_C_SIZEOF_DATA_PTR}")
endif()

if(CMAKE_C_COMPILER_ABI)
  set(CMAKE_INTERNAL_PLATFORM_ABI "${CMAKE_C_COMPILER_ABI}")
endif()

if(CMAKE_C_LIBRARY_ARCHITECTURE)
  set(CMAKE_LIBRARY_ARCHITECTURE "x86_64-linux-gnu")
endif()

set(CMAKE_C_CL_SHOWINCLUDES_PREFIX "")
if(CMAKE_C_CL_SHOWINCLUDES_PREFIX)
  set(CMAKE_CL_SHOWINCLUDES_PREFIX "${CMAKE_C_CL_SHOWINCLUDES_PREFIX}")
endif()





set(CMAKE_C_IMPLICIT_INCLUDE_DIRECTORIES "/usr/lib/gcc/x86_64-linux-gnu/7/include;/usr/local/include;/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed;/usr/include/x86_64-linux-gnu;/usr/include")
set(CMAKE_C_IMPLICIT_LINK_LIBRARIES "gcc;gcc_s;c;gcc;gcc_s")
set(CMAKE_C_IMPLICIT_LINK_DIRECTORIES "/usr/lib/gcc/x86_64-linux-gnu/7;/usr/lib/x86_64-linux-gnu;/usr/lib;/lib/x86_64-linux-gnu;/lib")
set(CMAKE_C_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES "")

```

`example/crackme/build/CMakeFiles/3.16.8/CMakeCXXCompiler.cmake`:

```cmake
set(CMAKE_CXX_COMPILER "/usr/bin/c++")
set(CMAKE_CXX_COMPILER_ARG1 "")
set(CMAKE_CXX_COMPILER_ID "GNU")
set(CMAKE_CXX_COMPILER_VERSION "7.5.0")
set(CMAKE_CXX_COMPILER_VERSION_INTERNAL "")
set(CMAKE_CXX_COMPILER_WRAPPER "")
set(CMAKE_CXX_STANDARD_COMPUTED_DEFAULT "14")
set(CMAKE_CXX_COMPILE_FEATURES "cxx_std_98;cxx_template_template_parameters;cxx_std_11;cxx_alias_templates;cxx_alignas;cxx_alignof;cxx_attributes;cxx_auto_type;cxx_constexpr;cxx_decltype;cxx_decltype_incomplete_return_types;cxx_default_function_template_args;cxx_defaulted_functions;cxx_defaulted_move_initializers;cxx_delegating_constructors;cxx_deleted_functions;cxx_enum_forward_declarations;cxx_explicit_conversions;cxx_extended_friend_declarations;cxx_extern_templates;cxx_final;cxx_func_identifier;cxx_generalized_initializers;cxx_inheriting_constructors;cxx_inline_namespaces;cxx_lambdas;cxx_local_type_template_args;cxx_long_long_type;cxx_noexcept;cxx_nonstatic_member_init;cxx_nullptr;cxx_override;cxx_range_for;cxx_raw_string_literals;cxx_reference_qualified_functions;cxx_right_angle_brackets;cxx_rvalue_references;cxx_sizeof_member;cxx_static_assert;cxx_strong_enums;cxx_thread_local;cxx_trailing_return_types;cxx_unicode_literals;cxx_uniform_initialization;cxx_unrestricted_unions;cxx_user_literals;cxx_variadic_macros;cxx_variadic_templates;cxx_std_14;cxx_aggregate_default_initializers;cxx_attribute_deprecated;cxx_binary_literals;cxx_contextual_conversions;cxx_decltype_auto;cxx_digit_separators;cxx_generic_lambdas;cxx_lambda_init_captures;cxx_relaxed_constexpr;cxx_return_type_deduction;cxx_variable_templates;cxx_std_17")
set(CMAKE_CXX98_COMPILE_FEATURES "cxx_std_98;cxx_template_template_parameters")
set(CMAKE_CXX11_COMPILE_FEATURES "cxx_std_11;cxx_alias_templates;cxx_alignas;cxx_alignof;cxx_attributes;cxx_auto_type;cxx_constexpr;cxx_decltype;cxx_decltype_incomplete_return_types;cxx_default_function_template_args;cxx_defaulted_functions;cxx_defaulted_move_initializers;cxx_delegating_constructors;cxx_deleted_functions;cxx_enum_forward_declarations;cxx_explicit_conversions;cxx_extended_friend_declarations;cxx_extern_templates;cxx_final;cxx_func_identifier;cxx_generalized_initializers;cxx_inheriting_constructors;cxx_inline_namespaces;cxx_lambdas;cxx_local_type_template_args;cxx_long_long_type;cxx_noexcept;cxx_nonstatic_member_init;cxx_nullptr;cxx_override;cxx_range_for;cxx_raw_string_literals;cxx_reference_qualified_functions;cxx_right_angle_brackets;cxx_rvalue_references;cxx_sizeof_member;cxx_static_assert;cxx_strong_enums;cxx_thread_local;cxx_trailing_return_types;cxx_unicode_literals;cxx_uniform_initialization;cxx_unrestricted_unions;cxx_user_literals;cxx_variadic_macros;cxx_variadic_templates")
set(CMAKE_CXX14_COMPILE_FEATURES "cxx_std_14;cxx_aggregate_default_initializers;cxx_attribute_deprecated;cxx_binary_literals;cxx_contextual_conversions;cxx_decltype_auto;cxx_digit_separators;cxx_generic_lambdas;cxx_lambda_init_captures;cxx_relaxed_constexpr;cxx_return_type_deduction;cxx_variable_templates")
set(CMAKE_CXX17_COMPILE_FEATURES "cxx_std_17")
set(CMAKE_CXX20_COMPILE_FEATURES "")

set(CMAKE_CXX_PLATFORM_ID "Linux")
set(CMAKE_CXX_SIMULATE_ID "")
set(CMAKE_CXX_COMPILER_FRONTEND_VARIANT "")
set(CMAKE_CXX_SIMULATE_VERSION "")



set(CMAKE_AR "/usr/bin/ar")
set(CMAKE_CXX_COMPILER_AR "/usr/bin/gcc-ar-7")
set(CMAKE_RANLIB "/usr/bin/ranlib")
set(CMAKE_CXX_COMPILER_RANLIB "/usr/bin/gcc-ranlib-7")
set(CMAKE_LINKER "/usr/bin/ld")
set(CMAKE_MT "")
set(CMAKE_COMPILER_IS_GNUCXX 1)
set(CMAKE_CXX_COMPILER_LOADED 1)
set(CMAKE_CXX_COMPILER_WORKS TRUE)
set(CMAKE_CXX_ABI_COMPILED TRUE)
set(CMAKE_COMPILER_IS_MINGW )
set(CMAKE_COMPILER_IS_CYGWIN )
if(CMAKE_COMPILER_IS_CYGWIN)
  set(CYGWIN 1)
  set(UNIX 1)
endif()

set(CMAKE_CXX_COMPILER_ENV_VAR "CXX")

if(CMAKE_COMPILER_IS_MINGW)
  set(MINGW 1)
endif()
set(CMAKE_CXX_COMPILER_ID_RUN 1)
set(CMAKE_CXX_SOURCE_FILE_EXTENSIONS C;M;c++;cc;cpp;cxx;m;mm;CPP)
set(CMAKE_CXX_IGNORE_EXTENSIONS inl;h;hpp;HPP;H;o;O;obj;OBJ;def;DEF;rc;RC)

foreach (lang C OBJC OBJCXX)
  if (CMAKE_${lang}_COMPILER_ID_RUN)
    foreach(extension IN LISTS CMAKE_${lang}_SOURCE_FILE_EXTENSIONS)
      list(REMOVE_ITEM CMAKE_CXX_SOURCE_FILE_EXTENSIONS ${extension})
    endforeach()
  endif()
endforeach()

set(CMAKE_CXX_LINKER_PREFERENCE 30)
set(CMAKE_CXX_LINKER_PREFERENCE_PROPAGATES 1)

# Save compiler ABI information.
set(CMAKE_CXX_SIZEOF_DATA_PTR "8")
set(CMAKE_CXX_COMPILER_ABI "ELF")
set(CMAKE_CXX_LIBRARY_ARCHITECTURE "x86_64-linux-gnu")

if(CMAKE_CXX_SIZEOF_DATA_PTR)
  set(CMAKE_SIZEOF_VOID_P "${CMAKE_CXX_SIZEOF_DATA_PTR}")
endif()

if(CMAKE_CXX_COMPILER_ABI)
  set(CMAKE_INTERNAL_PLATFORM_ABI "${CMAKE_CXX_COMPILER_ABI}")
endif()

if(CMAKE_CXX_LIBRARY_ARCHITECTURE)
  set(CMAKE_LIBRARY_ARCHITECTURE "x86_64-linux-gnu")
endif()

set(CMAKE_CXX_CL_SHOWINCLUDES_PREFIX "")
if(CMAKE_CXX_CL_SHOWINCLUDES_PREFIX)
  set(CMAKE_CL_SHOWINCLUDES_PREFIX "${CMAKE_CXX_CL_SHOWINCLUDES_PREFIX}")
endif()





set(CMAKE_CXX_IMPLICIT_INCLUDE_DIRECTORIES "/usr/include/c++/7;/usr/include/x86_64-linux-gnu/c++/7;/usr/include/c++/7/backward;/usr/lib/gcc/x86_64-linux-gnu/7/include;/usr/local/include;/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed;/usr/include/x86_64-linux-gnu;/usr/include")
set(CMAKE_CXX_IMPLICIT_LINK_LIBRARIES "stdc++;m;gcc_s;gcc;c;gcc_s;gcc")
set(CMAKE_CXX_IMPLICIT_LINK_DIRECTORIES "/usr/lib/gcc/x86_64-linux-gnu/7;/usr/lib/x86_64-linux-gnu;/usr/lib;/lib/x86_64-linux-gnu;/lib")
set(CMAKE_CXX_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES "")

```

`example/crackme/build/CMakeFiles/3.16.8/CMakeSystem.cmake`:

```cmake
set(CMAKE_HOST_SYSTEM "Linux-4.15.0-101-generic")
set(CMAKE_HOST_SYSTEM_NAME "Linux")
set(CMAKE_HOST_SYSTEM_VERSION "4.15.0-101-generic")
set(CMAKE_HOST_SYSTEM_PROCESSOR "x86_64")



set(CMAKE_SYSTEM "Linux-4.15.0-101-generic")
set(CMAKE_SYSTEM_NAME "Linux")
set(CMAKE_SYSTEM_VERSION "4.15.0-101-generic")
set(CMAKE_SYSTEM_PROCESSOR "x86_64")

set(CMAKE_CROSSCOMPILING "FALSE")

set(CMAKE_SYSTEM_LOADED 1)

```

`example/crackme/build/CMakeFiles/3.16.8/CompilerIdC/CMakeCCompilerId.c`:

```c
#ifdef __cplusplus
# error "A C++ compiler has been selected for C."
#endif

#if defined(__18CXX)
# define ID_VOID_MAIN
#endif
#if defined(__CLASSIC_C__)
/* cv-qualifiers did not exist in K&R C */
# define const
# define volatile
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP */
# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
# if defined(__INTEL_COMPILER_UPDATE)
#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
# else
#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_C)
# define COMPILER_ID "SunPro"
# if __SUNPRO_C >= 0x5100
   /* __SUNPRO_C = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)
# endif

#elif defined(__HP_cc)
# define COMPILER_ID "HP"
  /* __HP_cc = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_cc/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_cc/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_cc     % 100)

#elif defined(__DECC)
# define COMPILER_ID "Compaq"
  /* __DECC_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECC_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECC_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECC_VER         % 10000)

#elif defined(__IBMC__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMC__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)

#elif defined(__ibmxl__) && defined(__clang__)
# define COMPILER_ID "XLClang"
# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)


#elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ >= 800
# define COMPILER_ID "XL"
  /* __IBMC__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)

#elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMC__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__FUJITSU) || defined(__FCC_VERSION) || defined(__fcc_version)
# define COMPILER_ID "Fujitsu"

#elif defined(__ghs__)
# define COMPILER_ID "GHS"
/* __GHS_VERSION_NUMBER = VVVVRP */
# ifdef __GHS_VERSION_NUMBER
# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
# endif

#elif defined(__TINYC__)
# define COMPILER_ID "TinyCC"

#elif defined(__BCC__)
# define COMPILER_ID "Bruce"

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__ARMCC_VERSION) && !defined(__clang__)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
# define COMPILER_ID "ARMClang"
  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION     % 10000)
# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__GNUC__)
# define COMPILER_ID "GNU"
# define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(__VISUALDSPVERSION__) || defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__)
# define COMPILER_ID "ADSP"
#if defined(__VISUALDSPVERSION__)
  /* __VISUALDSPVERSION__ = 0xVVRRPP00 */
# define COMPILER_VERSION_MAJOR HEX(__VISUALDSPVERSION__>>24)
# define COMPILER_VERSION_MINOR HEX(__VISUALDSPVERSION__>>16 & 0xFF)
# define COMPILER_VERSION_PATCH HEX(__VISUALDSPVERSION__>>8  & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"
# if defined(__VER__) && defined(__ICCARM__)
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__))
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# endif

#elif defined(__SDCC_VERSION_MAJOR) || defined(SDCC)
# define COMPILER_ID "SDCC"
# if defined(__SDCC_VERSION_MAJOR)
#  define COMPILER_VERSION_MAJOR DEC(__SDCC_VERSION_MAJOR)
#  define COMPILER_VERSION_MINOR DEC(__SDCC_VERSION_MINOR)
#  define COMPILER_VERSION_PATCH DEC(__SDCC_VERSION_PATCH)
# else
  /* SDCC = VRP */
#  define COMPILER_VERSION_MAJOR DEC(SDCC/100)
#  define COMPILER_VERSION_MINOR DEC(SDCC/10 % 10)
#  define COMPILER_VERSION_PATCH DEC(SDCC    % 10)
# endif


/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXE) || defined(__CRAYXC)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# else /* unknown platform */
#  define PLATFORM_ID
# endif

#elif defined(__INTEGRITY)
# if defined(INT_178B)
#  define PLATFORM_ID "Integrity178"

# else /* regular Integrity */
#  define PLATFORM_ID "Integrity"
# endif

#else /* unknown platform */
# define PLATFORM_ID

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM64)
#  define ARCHITECTURE_ID "ARM64"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# if defined(__ICCARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__ICCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__ICCRH850__)
#  define ARCHITECTURE_ID "RH850"

# elif defined(__ICCRL78__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__ICCRISCV__)
#  define ARCHITECTURE_ID "RISCV"

# elif defined(__ICCAVR__)
#  define ARCHITECTURE_ID "AVR"

# elif defined(__ICC430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__ICCV850__)
#  define ARCHITECTURE_ID "V850"

# elif defined(__ICC8051__)
#  define ARCHITECTURE_ID "8051"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__ghs__)
# if defined(__PPC64__)
#  define ARCHITECTURE_ID "PPC64"

# elif defined(__ppc__)
#  define ARCHITECTURE_ID "PPC"

# elif defined(__ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__x86_64__)
#  define ARCHITECTURE_ID "x64"

# elif defined(__i386__)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif
#else
#  define ARCHITECTURE_ID
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number components. */
#ifdef COMPILER_VERSION_MAJOR
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the internal version number. */
#ifdef COMPILER_VERSION_INTERNAL
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";




#if !defined(__STDC__)
# if (defined(_MSC_VER) && !defined(__clang__)) \
  || (defined(__ibmxl__) || defined(__IBMC__))
#  define C_DIALECT "90"
# else
#  define C_DIALECT
# endif
#elif __STDC_VERSION__ >= 201000L
# define C_DIALECT "11"
#elif __STDC_VERSION__ >= 199901L
# define C_DIALECT "99"
#else
# define C_DIALECT "90"
#endif
const char* info_language_dialect_default =
  "INFO" ":" "dialect_default[" C_DIALECT "]";

/*--------------------------------------------------------------------------*/

#ifdef ID_VOID_MAIN
void main() {}
#else
# if defined(__CLASSIC_C__)
int main(argc, argv) int argc; char *argv[];
# else
int main(int argc, char* argv[])
# endif
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  require += info_arch[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#ifdef COMPILER_VERSION_INTERNAL
  require += info_version_internal[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXE) || defined(__CRAYXC)
  require += info_cray[argc];
#endif
  require += info_language_dialect_default[argc];
  (void)argv;
  return require;
}
#endif

```

`example/crackme/build/CMakeFiles/3.16.8/CompilerIdCXX/CMakeCXXCompilerId.cpp`:

```cpp
/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__COMO__)
# define COMPILER_ID "Comeau"
  /* __COMO_VERSION__ = VRR */
# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)
# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)

#elif defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP */
# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
# if defined(__INTEL_COMPILER_UPDATE)
#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
# else
#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_CC)
# define COMPILER_ID "SunPro"
# if __SUNPRO_CC >= 0x5100
   /* __SUNPRO_CC = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# endif

#elif defined(__HP_aCC)
# define COMPILER_ID "HP"
  /* __HP_aCC = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)

#elif defined(__DECCXX)
# define COMPILER_ID "Compaq"
  /* __DECCXX_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)

#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__ibmxl__) && defined(__clang__)
# define COMPILER_ID "XLClang"
# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)


#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800
# define COMPILER_ID "XL"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__FUJITSU) || defined(__FCC_VERSION) || defined(__fcc_version)
# define COMPILER_ID "Fujitsu"

#elif defined(__ghs__)
# define COMPILER_ID "GHS"
/* __GHS_VERSION_NUMBER = VVVVRP */
# ifdef __GHS_VERSION_NUMBER
# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
# endif

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__ARMCC_VERSION) && !defined(__clang__)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
# define COMPILER_ID "ARMClang"
  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION     % 10000)
# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__GNUC__) || defined(__GNUG__)
# define COMPILER_ID "GNU"
# if defined(__GNUC__)
#  define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# else
#  define COMPILER_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(__VISUALDSPVERSION__) || defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__)
# define COMPILER_ID "ADSP"
#if defined(__VISUALDSPVERSION__)
  /* __VISUALDSPVERSION__ = 0xVVRRPP00 */
# define COMPILER_VERSION_MAJOR HEX(__VISUALDSPVERSION__>>24)
# define COMPILER_VERSION_MINOR HEX(__VISUALDSPVERSION__>>16 & 0xFF)
# define COMPILER_VERSION_PATCH HEX(__VISUALDSPVERSION__>>8  & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"
# if defined(__VER__) && defined(__ICCARM__)
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__))
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# endif


/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXE) || defined(__CRAYXC)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# else /* unknown platform */
#  define PLATFORM_ID
# endif

#elif defined(__INTEGRITY)
# if defined(INT_178B)
#  define PLATFORM_ID "Integrity178"

# else /* regular Integrity */
#  define PLATFORM_ID "Integrity"
# endif

#else /* unknown platform */
# define PLATFORM_ID

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM64)
#  define ARCHITECTURE_ID "ARM64"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# if defined(__ICCARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__ICCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__ICCRH850__)
#  define ARCHITECTURE_ID "RH850"

# elif defined(__ICCRL78__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__ICCRISCV__)
#  define ARCHITECTURE_ID "RISCV"

# elif defined(__ICCAVR__)
#  define ARCHITECTURE_ID "AVR"

# elif defined(__ICC430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__ICCV850__)
#  define ARCHITECTURE_ID "V850"

# elif defined(__ICC8051__)
#  define ARCHITECTURE_ID "8051"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__ghs__)
# if defined(__PPC64__)
#  define ARCHITECTURE_ID "PPC64"

# elif defined(__ppc__)
#  define ARCHITECTURE_ID "PPC"

# elif defined(__ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__x86_64__)
#  define ARCHITECTURE_ID "x64"

# elif defined(__i386__)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif
#else
#  define ARCHITECTURE_ID
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number components. */
#ifdef COMPILER_VERSION_MAJOR
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the internal version number. */
#ifdef COMPILER_VERSION_INTERNAL
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";




#if defined(__INTEL_COMPILER) && defined(_MSVC_LANG) && _MSVC_LANG < 201403L
#  if defined(__INTEL_CXX11_MODE__)
#    if defined(__cpp_aggregate_nsdmi)
#      define CXX_STD 201402L
#    else
#      define CXX_STD 201103L
#    endif
#  else
#    define CXX_STD 199711L
#  endif
#elif defined(_MSC_VER) && defined(_MSVC_LANG)
#  define CXX_STD _MSVC_LANG
#else
#  define CXX_STD __cplusplus
#endif

const char* info_language_dialect_default = "INFO" ":" "dialect_default["
#if CXX_STD > 201703L
  "20"
#elif CXX_STD >= 201703L
  "17"
#elif CXX_STD >= 201402L
  "14"
#elif CXX_STD >= 201103L
  "11"
#else
  "98"
#endif
"]";

/*--------------------------------------------------------------------------*/

int main(int argc, char* argv[])
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#ifdef COMPILER_VERSION_INTERNAL
  require += info_version_internal[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXE) || defined(__CRAYXC)
  require += info_cray[argc];
#endif
  require += info_language_dialect_default[argc];
  (void)argv;
  return require;
}

```

`example/crackme/build/CMakeFiles/CMakeDirectoryInformation.cmake`:

```cmake
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 3.16

# Relative path conversion top directories.
set(CMAKE_RELATIVE_PATH_TOP_SOURCE "/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme")
set(CMAKE_RELATIVE_PATH_TOP_BINARY "/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build")

# Force unix paths in dependencies.
set(CMAKE_FORCE_UNIX_PATHS 1)


# The C and CXX include file regular expressions for this directory.
set(CMAKE_C_INCLUDE_REGEX_SCAN "^.*$")
set(CMAKE_C_INCLUDE_REGEX_COMPLAIN "^$")
set(CMAKE_CXX_INCLUDE_REGEX_SCAN ${CMAKE_C_INCLUDE_REGEX_SCAN})
set(CMAKE_CXX_INCLUDE_REGEX_COMPLAIN ${CMAKE_C_INCLUDE_REGEX_COMPLAIN})

```

`example/crackme/build/CMakeFiles/CMakeOutput.log`:

```log
The system is: Linux - 4.15.0-101-generic - x86_64
Compiling the C compiler identification source file "CMakeCCompilerId.c" succeeded.
Compiler: /usr/bin/cc 
Build flags: 
Id flags:  

The output was:
0


Compilation of the C compiler identification source "CMakeCCompilerId.c" produced "a.out"

The C compiler identification is GNU, found in "/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/3.16.8/CompilerIdC/a.out"

Compiling the CXX compiler identification source file "CMakeCXXCompilerId.cpp" succeeded.
Compiler: /usr/bin/c++ 
Build flags: 
Id flags:  

The output was:
0


Compilation of the CXX compiler identification source "CMakeCXXCompilerId.cpp" produced "a.out"

The CXX compiler identification is GNU, found in "/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/3.16.8/CompilerIdCXX/a.out"

Determining if the C compiler works passed with the following output:
Change Dir: /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp

Run Build Command(s):/usr/bin/make cmTC_b44c8/fast && /usr/bin/make  -f CMakeFiles/cmTC_b44c8.dir/build.make CMakeFiles/cmTC_b44c8.dir/build
make[1]: Entering directory '/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp'
Building C object CMakeFiles/cmTC_b44c8.dir/testCCompiler.c.o
/usr/bin/cc    -o CMakeFiles/cmTC_b44c8.dir/testCCompiler.c.o   -c /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp/testCCompiler.c
Linking C executable cmTC_b44c8
/opt/cmake/bin/cmake -E cmake_link_script CMakeFiles/cmTC_b44c8.dir/link.txt --verbose=1
/usr/bin/cc      -rdynamic CMakeFiles/cmTC_b44c8.dir/testCCompiler.c.o  -o cmTC_b44c8 
make[1]: Leaving directory '/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp'



Detecting C compiler ABI info compiled with the following output:
Change Dir: /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp

Run Build Command(s):/usr/bin/make cmTC_58e14/fast && /usr/bin/make  -f CMakeFiles/cmTC_58e14.dir/build.make CMakeFiles/cmTC_58e14.dir/build
make[1]: Entering directory '/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp'
Building C object CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o
/usr/bin/cc   -v -o CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o   -c /opt/cmake/share/cmake-3.16/Modules/CMakeCCompilerABI.c
Using built-in specs.
COLLECT_GCC=/usr/bin/cc
OFFLOAD_TARGET_NAMES=nvptx-none
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) 
COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o' '-c' '-mtune=generic' '-march=x86-64'
 /usr/lib/gcc/x86_64-linux-gnu/7/cc1 -quiet -v -imultiarch x86_64-linux-gnu /opt/cmake/share/cmake-3.16/Modules/CMakeCCompilerABI.c -quiet -dumpbase CMakeCCompilerABI.c -mtune=generic -march=x86-64 -auxbase-strip CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccxCwDY1.s
GNU C11 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)
	compiled by GNU C version 7.5.0, GMP version 6.1.2, MPFR version 4.0.1, MPC version 1.1.0, isl version isl-0.19-GMP

GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring nonexistent directory "/usr/local/include/x86_64-linux-gnu"
ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/7/../../../../x86_64-linux-gnu/include"
#include "..." search starts here:
#include <...> search starts here:
 /usr/lib/gcc/x86_64-linux-gnu/7/include
 /usr/local/include
 /usr/lib/gcc/x86_64-linux-gnu/7/include-fixed
 /usr/include/x86_64-linux-gnu
 /usr/include
End of search list.
GNU C11 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)
	compiled by GNU C version 7.5.0, GMP version 6.1.2, MPFR version 4.0.1, MPC version 1.1.0, isl version isl-0.19-GMP

GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
Compiler executable checksum: b62ed4a2880cd4159476ea8293b72fa8
COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o' '-c' '-mtune=generic' '-march=x86-64'
 as -v --64 -o CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o /tmp/ccxCwDY1.s
GNU assembler version 2.30 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.30
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o' '-c' '-mtune=generic' '-march=x86-64'
Linking C executable cmTC_58e14
/opt/cmake/bin/cmake -E cmake_link_script CMakeFiles/cmTC_58e14.dir/link.txt --verbose=1
/usr/bin/cc     -v -rdynamic CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o  -o cmTC_58e14 
Using built-in specs.
COLLECT_GCC=/usr/bin/cc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) 
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_58e14' '-mtune=generic' '-march=x86-64'
 /usr/lib/gcc/x86_64-linux-gnu/7/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper -plugin-opt=-fresolution=/tmp/ccA0G4f5.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro -o cmTC_58e14 /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/7 -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/7/../../.. CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o
COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_58e14' '-mtune=generic' '-march=x86-64'
make[1]: Leaving directory '/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp'



Parsed C implicit include dir info from above output: rv=done
  found start of include info
  found start of implicit include info
    add: [/usr/lib/gcc/x86_64-linux-gnu/7/include]
    add: [/usr/local/include]
    add: [/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed]
    add: [/usr/include/x86_64-linux-gnu]
    add: [/usr/include]
  end of search list found
  collapse include dir [/usr/lib/gcc/x86_64-linux-gnu/7/include] ==> [/usr/lib/gcc/x86_64-linux-gnu/7/include]
  collapse include dir [/usr/local/include] ==> [/usr/local/include]
  collapse include dir [/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed] ==> [/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed]
  collapse include dir [/usr/include/x86_64-linux-gnu] ==> [/usr/include/x86_64-linux-gnu]
  collapse include dir [/usr/include] ==> [/usr/include]
  implicit include dirs: [/usr/lib/gcc/x86_64-linux-gnu/7/include;/usr/local/include;/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed;/usr/include/x86_64-linux-gnu;/usr/include]


Parsed C implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|CMAKE_LINK_STARTFILE-NOTFOUND|([^/\]+-)?ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command(s):/usr/bin/make cmTC_58e14/fast && /usr/bin/make  -f CMakeFiles/cmTC_58e14.dir/build.make CMakeFiles/cmTC_58e14.dir/build]
  ignore line: [make[1]: Entering directory '/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp']
  ignore line: [Building C object CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o]
  ignore line: [/usr/bin/cc   -v -o CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o   -c /opt/cmake/share/cmake-3.16/Modules/CMakeCCompilerABI.c]
  ignore line: [Using built-in specs.]
  ignore line: [COLLECT_GCC=/usr/bin/cc]
  ignore line: [OFFLOAD_TARGET_NAMES=nvptx-none]
  ignore line: [OFFLOAD_TARGET_DEFAULT=1]
  ignore line: [Target: x86_64-linux-gnu]
  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c ada c++ go brig d fortran objc obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32 m64 mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) ]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o' '-c' '-mtune=generic' '-march=x86-64']
  ignore line: [ /usr/lib/gcc/x86_64-linux-gnu/7/cc1 -quiet -v -imultiarch x86_64-linux-gnu /opt/cmake/share/cmake-3.16/Modules/CMakeCCompilerABI.c -quiet -dumpbase CMakeCCompilerABI.c -mtune=generic -march=x86-64 -auxbase-strip CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccxCwDY1.s]
  ignore line: [GNU C11 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)]
  ignore line: [	compiled by GNU C version 7.5.0  GMP version 6.1.2  MPFR version 4.0.1  MPC version 1.1.0  isl version isl-0.19-GMP]
  ignore line: []
  ignore line: [GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072]
  ignore line: [ignoring nonexistent directory "/usr/local/include/x86_64-linux-gnu"]
  ignore line: [ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/7/../../../../x86_64-linux-gnu/include"]
  ignore line: [#include "..." search starts here:]
  ignore line: [#include <...> search starts here:]
  ignore line: [ /usr/lib/gcc/x86_64-linux-gnu/7/include]
  ignore line: [ /usr/local/include]
  ignore line: [ /usr/lib/gcc/x86_64-linux-gnu/7/include-fixed]
  ignore line: [ /usr/include/x86_64-linux-gnu]
  ignore line: [ /usr/include]
  ignore line: [End of search list.]
  ignore line: [GNU C11 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)]
  ignore line: [	compiled by GNU C version 7.5.0  GMP version 6.1.2  MPFR version 4.0.1  MPC version 1.1.0  isl version isl-0.19-GMP]
  ignore line: []
  ignore line: [GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072]
  ignore line: [Compiler executable checksum: b62ed4a2880cd4159476ea8293b72fa8]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o' '-c' '-mtune=generic' '-march=x86-64']
  ignore line: [ as -v --64 -o CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o /tmp/ccxCwDY1.s]
  ignore line: [GNU assembler version 2.30 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.30]
  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../:/lib/:/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o' '-c' '-mtune=generic' '-march=x86-64']
  ignore line: [Linking C executable cmTC_58e14]
  ignore line: [/opt/cmake/bin/cmake -E cmake_link_script CMakeFiles/cmTC_58e14.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/cc     -v -rdynamic CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o  -o cmTC_58e14 ]
  ignore line: [Using built-in specs.]
  ignore line: [COLLECT_GCC=/usr/bin/cc]
  ignore line: [COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper]
  ignore line: [OFFLOAD_TARGET_NAMES=nvptx-none]
  ignore line: [OFFLOAD_TARGET_DEFAULT=1]
  ignore line: [Target: x86_64-linux-gnu]
  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c ada c++ go brig d fortran objc obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32 m64 mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) ]
  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../:/lib/:/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_58e14' '-mtune=generic' '-march=x86-64']
  link line: [ /usr/lib/gcc/x86_64-linux-gnu/7/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper -plugin-opt=-fresolution=/tmp/ccA0G4f5.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro -o cmTC_58e14 /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/7 -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/7/../../.. CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o]
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/collect2] ==> ignore
    arg [-plugin] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so] ==> ignore
    arg [-plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper] ==> ignore
    arg [-plugin-opt=-fresolution=/tmp/ccA0G4f5.res] ==> ignore
    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
    arg [-plugin-opt=-pass-through=-lc] ==> ignore
    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
    arg [--build-id] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_x86_64] ==> ignore
    arg [--hash-style=gnu] ==> ignore
    arg [--as-needed] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
    arg [-pie] ==> ignore
    arg [-znow] ==> ignore
    arg [-zrelro] ==> ignore
    arg [-o] ==> ignore
    arg [cmTC_58e14] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o] ==> ignore
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/7] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/7]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib]
    arg [-L/lib/x86_64-linux-gnu] ==> dir [/lib/x86_64-linux-gnu]
    arg [-L/lib/../lib] ==> dir [/lib/../lib]
    arg [-L/usr/lib/x86_64-linux-gnu] ==> dir [/usr/lib/x86_64-linux-gnu]
    arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/7/../../..] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/7/../../..]
    arg [CMakeFiles/cmTC_58e14.dir/CMakeCCompilerABI.c.o] ==> ignore
    arg [-lgcc] ==> lib [gcc]
    arg [--push-state] ==> ignore
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--pop-state] ==> ignore
    arg [-lc] ==> lib [c]
    arg [-lgcc] ==> lib [gcc]
    arg [--push-state] ==> ignore
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--pop-state] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o] ==> ignore
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/7] ==> [/usr/lib/gcc/x86_64-linux-gnu/7]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib] ==> [/usr/lib]
  collapse library dir [/lib/x86_64-linux-gnu] ==> [/lib/x86_64-linux-gnu]
  collapse library dir [/lib/../lib] ==> [/lib]
  collapse library dir [/usr/lib/x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse library dir [/usr/lib/../lib] ==> [/usr/lib]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/7/../../..] ==> [/usr/lib]
  implicit libs: [gcc;gcc_s;c;gcc;gcc_s]
  implicit dirs: [/usr/lib/gcc/x86_64-linux-gnu/7;/usr/lib/x86_64-linux-gnu;/usr/lib;/lib/x86_64-linux-gnu;/lib]
  implicit fwks: []


Determining if the CXX compiler works passed with the following output:
Change Dir: /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp

Run Build Command(s):/usr/bin/make cmTC_b0987/fast && /usr/bin/make  -f CMakeFiles/cmTC_b0987.dir/build.make CMakeFiles/cmTC_b0987.dir/build
make[1]: Entering directory '/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp'
Building CXX object CMakeFiles/cmTC_b0987.dir/testCXXCompiler.cxx.o
/usr/bin/c++     -o CMakeFiles/cmTC_b0987.dir/testCXXCompiler.cxx.o -c /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp/testCXXCompiler.cxx
Linking CXX executable cmTC_b0987
/opt/cmake/bin/cmake -E cmake_link_script CMakeFiles/cmTC_b0987.dir/link.txt --verbose=1
/usr/bin/c++       -rdynamic CMakeFiles/cmTC_b0987.dir/testCXXCompiler.cxx.o  -o cmTC_b0987 
make[1]: Leaving directory '/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp'



Detecting CXX compiler ABI info compiled with the following output:
Change Dir: /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp

Run Build Command(s):/usr/bin/make cmTC_5ea1c/fast && /usr/bin/make  -f CMakeFiles/cmTC_5ea1c.dir/build.make CMakeFiles/cmTC_5ea1c.dir/build
make[1]: Entering directory '/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp'
Building CXX object CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o
/usr/bin/c++    -v -o CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o -c /opt/cmake/share/cmake-3.16/Modules/CMakeCXXCompilerABI.cpp
Using built-in specs.
COLLECT_GCC=/usr/bin/c++
OFFLOAD_TARGET_NAMES=nvptx-none
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) 
COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mtune=generic' '-march=x86-64'
 /usr/lib/gcc/x86_64-linux-gnu/7/cc1plus -quiet -v -imultiarch x86_64-linux-gnu -D_GNU_SOURCE /opt/cmake/share/cmake-3.16/Modules/CMakeCXXCompilerABI.cpp -quiet -dumpbase CMakeCXXCompilerABI.cpp -mtune=generic -march=x86-64 -auxbase-strip CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccnTsamc.s
GNU C++14 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)
	compiled by GNU C version 7.5.0, GMP version 6.1.2, MPFR version 4.0.1, MPC version 1.1.0, isl version isl-0.19-GMP

GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring duplicate directory "/usr/include/x86_64-linux-gnu/c++/7"
ignoring nonexistent directory "/usr/local/include/x86_64-linux-gnu"
ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/7/../../../../x86_64-linux-gnu/include"
#include "..." search starts here:
#include <...> search starts here:
 /usr/include/c++/7
 /usr/include/x86_64-linux-gnu/c++/7
 /usr/include/c++/7/backward
 /usr/lib/gcc/x86_64-linux-gnu/7/include
 /usr/local/include
 /usr/lib/gcc/x86_64-linux-gnu/7/include-fixed
 /usr/include/x86_64-linux-gnu
 /usr/include
End of search list.
GNU C++14 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)
	compiled by GNU C version 7.5.0, GMP version 6.1.2, MPFR version 4.0.1, MPC version 1.1.0, isl version isl-0.19-GMP

GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
Compiler executable checksum: 3eb3dc290cd5714c3e1c3ae751116f07
COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mtune=generic' '-march=x86-64'
 as -v --64 -o CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o /tmp/ccnTsamc.s
GNU assembler version 2.30 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.30
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mtune=generic' '-march=x86-64'
Linking CXX executable cmTC_5ea1c
/opt/cmake/bin/cmake -E cmake_link_script CMakeFiles/cmTC_5ea1c.dir/link.txt --verbose=1
/usr/bin/c++      -v -rdynamic CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o  -o cmTC_5ea1c 
Using built-in specs.
COLLECT_GCC=/usr/bin/c++
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) 
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_5ea1c' '-shared-libgcc' '-mtune=generic' '-march=x86-64'
 /usr/lib/gcc/x86_64-linux-gnu/7/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper -plugin-opt=-fresolution=/tmp/ccytS2ye.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro -o cmTC_5ea1c /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/7 -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/7/../../.. CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o
COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_5ea1c' '-shared-libgcc' '-mtune=generic' '-march=x86-64'
make[1]: Leaving directory '/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp'



Parsed CXX implicit include dir info from above output: rv=done
  found start of include info
  found start of implicit include info
    add: [/usr/include/c++/7]
    add: [/usr/include/x86_64-linux-gnu/c++/7]
    add: [/usr/include/c++/7/backward]
    add: [/usr/lib/gcc/x86_64-linux-gnu/7/include]
    add: [/usr/local/include]
    add: [/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed]
    add: [/usr/include/x86_64-linux-gnu]
    add: [/usr/include]
  end of search list found
  collapse include dir [/usr/include/c++/7] ==> [/usr/include/c++/7]
  collapse include dir [/usr/include/x86_64-linux-gnu/c++/7] ==> [/usr/include/x86_64-linux-gnu/c++/7]
  collapse include dir [/usr/include/c++/7/backward] ==> [/usr/include/c++/7/backward]
  collapse include dir [/usr/lib/gcc/x86_64-linux-gnu/7/include] ==> [/usr/lib/gcc/x86_64-linux-gnu/7/include]
  collapse include dir [/usr/local/include] ==> [/usr/local/include]
  collapse include dir [/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed] ==> [/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed]
  collapse include dir [/usr/include/x86_64-linux-gnu] ==> [/usr/include/x86_64-linux-gnu]
  collapse include dir [/usr/include] ==> [/usr/include]
  implicit include dirs: [/usr/include/c++/7;/usr/include/x86_64-linux-gnu/c++/7;/usr/include/c++/7/backward;/usr/lib/gcc/x86_64-linux-gnu/7/include;/usr/local/include;/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed;/usr/include/x86_64-linux-gnu;/usr/include]


Parsed CXX implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|CMAKE_LINK_STARTFILE-NOTFOUND|([^/\]+-)?ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command(s):/usr/bin/make cmTC_5ea1c/fast && /usr/bin/make  -f CMakeFiles/cmTC_5ea1c.dir/build.make CMakeFiles/cmTC_5ea1c.dir/build]
  ignore line: [make[1]: Entering directory '/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/CMakeTmp']
  ignore line: [Building CXX object CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o]
  ignore line: [/usr/bin/c++    -v -o CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o -c /opt/cmake/share/cmake-3.16/Modules/CMakeCXXCompilerABI.cpp]
  ignore line: [Using built-in specs.]
  ignore line: [COLLECT_GCC=/usr/bin/c++]
  ignore line: [OFFLOAD_TARGET_NAMES=nvptx-none]
  ignore line: [OFFLOAD_TARGET_DEFAULT=1]
  ignore line: [Target: x86_64-linux-gnu]
  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c ada c++ go brig d fortran objc obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32 m64 mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) ]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mtune=generic' '-march=x86-64']
  ignore line: [ /usr/lib/gcc/x86_64-linux-gnu/7/cc1plus -quiet -v -imultiarch x86_64-linux-gnu -D_GNU_SOURCE /opt/cmake/share/cmake-3.16/Modules/CMakeCXXCompilerABI.cpp -quiet -dumpbase CMakeCXXCompilerABI.cpp -mtune=generic -march=x86-64 -auxbase-strip CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccnTsamc.s]
  ignore line: [GNU C++14 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)]
  ignore line: [	compiled by GNU C version 7.5.0  GMP version 6.1.2  MPFR version 4.0.1  MPC version 1.1.0  isl version isl-0.19-GMP]
  ignore line: []
  ignore line: [GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072]
  ignore line: [ignoring duplicate directory "/usr/include/x86_64-linux-gnu/c++/7"]
  ignore line: [ignoring nonexistent directory "/usr/local/include/x86_64-linux-gnu"]
  ignore line: [ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/7/../../../../x86_64-linux-gnu/include"]
  ignore line: [#include "..." search starts here:]
  ignore line: [#include <...> search starts here:]
  ignore line: [ /usr/include/c++/7]
  ignore line: [ /usr/include/x86_64-linux-gnu/c++/7]
  ignore line: [ /usr/include/c++/7/backward]
  ignore line: [ /usr/lib/gcc/x86_64-linux-gnu/7/include]
  ignore line: [ /usr/local/include]
  ignore line: [ /usr/lib/gcc/x86_64-linux-gnu/7/include-fixed]
  ignore line: [ /usr/include/x86_64-linux-gnu]
  ignore line: [ /usr/include]
  ignore line: [End of search list.]
  ignore line: [GNU C++14 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)]
  ignore line: [	compiled by GNU C version 7.5.0  GMP version 6.1.2  MPFR version 4.0.1  MPC version 1.1.0  isl version isl-0.19-GMP]
  ignore line: []
  ignore line: [GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072]
  ignore line: [Compiler executable checksum: 3eb3dc290cd5714c3e1c3ae751116f07]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mtune=generic' '-march=x86-64']
  ignore line: [ as -v --64 -o CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o /tmp/ccnTsamc.s]
  ignore line: [GNU assembler version 2.30 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.30]
  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../:/lib/:/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mtune=generic' '-march=x86-64']
  ignore line: [Linking CXX executable cmTC_5ea1c]
  ignore line: [/opt/cmake/bin/cmake -E cmake_link_script CMakeFiles/cmTC_5ea1c.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/c++      -v -rdynamic CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o  -o cmTC_5ea1c ]
  ignore line: [Using built-in specs.]
  ignore line: [COLLECT_GCC=/usr/bin/c++]
  ignore line: [COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper]
  ignore line: [OFFLOAD_TARGET_NAMES=nvptx-none]
  ignore line: [OFFLOAD_TARGET_DEFAULT=1]
  ignore line: [Target: x86_64-linux-gnu]
  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c ada c++ go brig d fortran objc obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32 m64 mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) ]
  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../:/lib/:/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_5ea1c' '-shared-libgcc' '-mtune=generic' '-march=x86-64']
  link line: [ /usr/lib/gcc/x86_64-linux-gnu/7/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper -plugin-opt=-fresolution=/tmp/ccytS2ye.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro -o cmTC_5ea1c /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/7 -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/7/../../.. CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o]
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/collect2] ==> ignore
    arg [-plugin] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so] ==> ignore
    arg [-plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper] ==> ignore
    arg [-plugin-opt=-fresolution=/tmp/ccytS2ye.res] ==> ignore
    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
    arg [-plugin-opt=-pass-through=-lc] ==> ignore
    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
    arg [--build-id] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_x86_64] ==> ignore
    arg [--hash-style=gnu] ==> ignore
    arg [--as-needed] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
    arg [-pie] ==> ignore
    arg [-znow] ==> ignore
    arg [-zrelro] ==> ignore
    arg [-o] ==> ignore
    arg [cmTC_5ea1c] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o] ==> ignore
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/7] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/7]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib]
    arg [-L/lib/x86_64-linux-gnu] ==> dir [/lib/x86_64-linux-gnu]
    arg [-L/lib/../lib] ==> dir [/lib/../lib]
    arg [-L/usr/lib/x86_64-linux-gnu] ==> dir [/usr/lib/x86_64-linux-gnu]
    arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/7/../../..] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/7/../../..]
    arg [CMakeFiles/cmTC_5ea1c.dir/CMakeCXXCompilerABI.cpp.o] ==> ignore
    arg [-lstdc++] ==> lib [stdc++]
    arg [-lm] ==> lib [m]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [-lc] ==> lib [c]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o] ==> ignore
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/7] ==> [/usr/lib/gcc/x86_64-linux-gnu/7]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib] ==> [/usr/lib]
  collapse library dir [/lib/x86_64-linux-gnu] ==> [/lib/x86_64-linux-gnu]
  collapse library dir [/lib/../lib] ==> [/lib]
  collapse library dir [/usr/lib/x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse library dir [/usr/lib/../lib] ==> [/usr/lib]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/7/../../..] ==> [/usr/lib]
  implicit libs: [stdc++;m;gcc_s;gcc;c;gcc_s;gcc]
  implicit dirs: [/usr/lib/gcc/x86_64-linux-gnu/7;/usr/lib/x86_64-linux-gnu;/usr/lib;/lib/x86_64-linux-gnu;/lib]
  implicit fwks: []



```

`example/crackme/build/CMakeFiles/Makefile.cmake`:

```cmake
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 3.16

# The generator used is:
set(CMAKE_DEPENDS_GENERATOR "Unix Makefiles")

# The top level Makefile was generated from the following files:
set(CMAKE_MAKEFILE_DEPENDS
  "CMakeCache.txt"
  "../CMakeLists.txt"
  "CMakeFiles/3.16.8/CMakeCCompiler.cmake"
  "CMakeFiles/3.16.8/CMakeCXXCompiler.cmake"
  "CMakeFiles/3.16.8/CMakeSystem.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeCCompiler.cmake.in"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeCCompilerABI.c"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeCInformation.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeCXXCompiler.cmake.in"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeCXXCompilerABI.cpp"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeCXXInformation.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeCheckCompilerFlagCommonPatterns.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeCommonLanguageInclude.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeCompilerIdDetection.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeDetermineCCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeDetermineCXXCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeDetermineCompileFeatures.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeDetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeDetermineCompilerABI.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeDetermineCompilerId.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeDetermineSystem.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeFindBinUtils.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeGenericSystem.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeInitializeConfigs.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeLanguageInformation.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeParseImplicitIncludeInfo.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeParseImplicitLinkInfo.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeSystem.cmake.in"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeSystemSpecificInformation.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeSystemSpecificInitialize.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeTestCCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeTestCXXCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeTestCompilerCommon.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/CMakeUnixFindMake.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/ADSP-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/ARMCC-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/ARMClang-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/AppleClang-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/Borland-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/Bruce-C-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/CMakeCommonCompilerMacros.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/Clang-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/Clang-DetermineCompilerInternal.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/Comeau-CXX-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/Compaq-C-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/Compaq-CXX-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/Cray-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/Embarcadero-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/Fujitsu-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/GHS-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/GNU-C-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/GNU-C.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/GNU-CXX-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/GNU-CXX.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/GNU-FindBinUtils.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/GNU.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/HP-C-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/HP-CXX-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/IAR-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/IBMCPP-C-DetermineVersionInternal.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/IBMCPP-CXX-DetermineVersionInternal.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/Intel-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/MSVC-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/NVIDIA-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/OpenWatcom-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/PGI-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/PathScale-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/SCO-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/SDCC-C-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/SunPro-C-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/SunPro-CXX-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/TI-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/TinyCC-C-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/VisualAge-C-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/VisualAge-CXX-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/Watcom-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/XL-C-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/XL-CXX-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/XLClang-C-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/XLClang-CXX-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/zOS-C-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Compiler/zOS-CXX-DetermineCompiler.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Internal/CMakeCheckCompilerFlag.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Internal/FeatureTesting.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Platform/Linux-Determine-CXX.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Platform/Linux-GNU-C.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Platform/Linux-GNU-CXX.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Platform/Linux-GNU.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Platform/Linux.cmake"
  "/opt/cmake/share/cmake-3.16/Modules/Platform/UnixPaths.cmake"
  )

# The corresponding makefile is:
set(CMAKE_MAKEFILE_OUTPUTS
  "Makefile"
  "CMakeFiles/cmake.check_cache"
  )

# Byproducts of CMake generate step:
set(CMAKE_MAKEFILE_PRODUCTS
  "CMakeFiles/3.16.8/CMakeSystem.cmake"
  "CMakeFiles/3.16.8/CMakeCCompiler.cmake"
  "CMakeFiles/3.16.8/CMakeCXXCompiler.cmake"
  "CMakeFiles/3.16.8/CMakeCCompiler.cmake"
  "CMakeFiles/3.16.8/CMakeCXXCompiler.cmake"
  "CMakeFiles/CMakeDirectoryInformation.cmake"
  )

# Dependency information for all targets:
set(CMAKE_DEPEND_INFO_FILES
  "CMakeFiles/crackme.dir/DependInfo.cmake"
  )

```

`example/crackme/build/CMakeFiles/Makefile2`:

```
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 3.16

# Default target executed when no arguments are given to make.
default_target: all

.PHONY : default_target

#=============================================================================
# Special targets provided by cmake.

# Disable implicit rules so canonical targets will work.
.SUFFIXES:


# Remove some rules from gmake that .SUFFIXES does not remove.
SUFFIXES =

.SUFFIXES: .hpux_make_needs_suffix_list


# Command-line flag to silence nested $(MAKE).
$(VERBOSE)MAKESILENT = -s

# Suppress display of executed commands.
$(VERBOSE).SILENT:


# A target that is always out of date.
cmake_force:

.PHONY : cmake_force

#=============================================================================
# Set environment variables for the build.

# The shell in which to execute make rules.
SHELL = /bin/sh

# The CMake executable.
CMAKE_COMMAND = /opt/cmake/bin/cmake

# The command to remove a file.
RM = /opt/cmake/bin/cmake -E remove -f

# Escaping for special characters.
EQUALS = =

# The top-level source directory on which CMake was run.
CMAKE_SOURCE_DIR = /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme

# The top-level build directory on which CMake was run.
CMAKE_BINARY_DIR = /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build

#=============================================================================
# Directory level rules for the build root directory

# The main recursive "all" target.
all: CMakeFiles/crackme.dir/all

.PHONY : all

# The main recursive "preinstall" target.
preinstall:

.PHONY : preinstall

# The main recursive "clean" target.
clean: CMakeFiles/crackme.dir/clean

.PHONY : clean

#=============================================================================
# Target rules for target CMakeFiles/crackme.dir

# All Build rule for target.
CMakeFiles/crackme.dir/all:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/crackme.dir/build.make CMakeFiles/crackme.dir/depend
	$(MAKE) $(MAKESILENT) -f CMakeFiles/crackme.dir/build.make CMakeFiles/crackme.dir/build
	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles --progress-num=1,2,3 "Built target crackme"
.PHONY : CMakeFiles/crackme.dir/all

# Build rule for subdir invocation for target.
CMakeFiles/crackme.dir/rule: cmake_check_build_system
	$(CMAKE_COMMAND) -E cmake_progress_start /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles 3
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 CMakeFiles/crackme.dir/all
	$(CMAKE_COMMAND) -E cmake_progress_start /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles 0
.PHONY : CMakeFiles/crackme.dir/rule

# Convenience name for target.
crackme: CMakeFiles/crackme.dir/rule

.PHONY : crackme

# clean rule for target.
CMakeFiles/crackme.dir/clean:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/crackme.dir/build.make CMakeFiles/crackme.dir/clean
.PHONY : CMakeFiles/crackme.dir/clean

#=============================================================================
# Special targets to cleanup operation of make.

# Special rule to run CMake to check the build system integrity.
# No rule that depends on this can have commands that come from listfiles
# because they might be regenerated.
cmake_check_build_system:
	$(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 0
.PHONY : cmake_check_build_system


```

`example/crackme/build/CMakeFiles/TargetDirectories.txt`:

```txt
/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/rebuild_cache.dir
/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/edit_cache.dir
/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/crackme.dir

```

`example/crackme/build/CMakeFiles/cmake.check_cache`:

```check_cache
# This file is generated by cmake for dependency checking of the CMakeCache.txt file

```

`example/crackme/build/CMakeFiles/crackme.dir/C.includecache`:

```includecache
#IncludeRegexLine: ^[ 	]*[#%][ 	]*(include|import)[ 	]*[<"]([^">]+)([">])

#IncludeRegexScan: ^.*$

#IncludeRegexComplain: ^$

#IncludeRegexTransform: 

/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/anti_debug.c
signal.h
-
stdio.h
-
unistd.h
-
stdlib.h
-
string.h
-
sys/ptrace.h
-
sys/prctl.h
-

/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/anti_debug.h

/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/crackme.c
stdio.h
-
string.h
-
anti_debug.h
/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/anti_debug.h
xor_string.h
/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/xor_string.h

/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/xor_string.h


```

`example/crackme/build/CMakeFiles/crackme.dir/DependInfo.cmake`:

```cmake
# The set of languages for which implicit dependencies are needed:
set(CMAKE_DEPENDS_LANGUAGES
  "C"
  )
# The set of files for implicit dependencies of each language:
set(CMAKE_DEPENDS_CHECK_C
  "/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/anti_debug.c" "/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/crackme.dir/src/anti_debug.c.o"
  "/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/crackme.c" "/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/crackme.dir/src/crackme.c.o"
  )
set(CMAKE_C_COMPILER_ID "GNU")

# The include file search paths:
set(CMAKE_C_TARGET_INCLUDE_PATH
  )

# Targets to which this target links.
set(CMAKE_TARGET_LINKED_INFO_FILES
  )

# Fortran module output directory.
set(CMAKE_Fortran_TARGET_MODULE_DIR "")

```

`example/crackme/build/CMakeFiles/crackme.dir/build.make`:

```make
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 3.16

# Delete rule output on recipe failure.
.DELETE_ON_ERROR:


#=============================================================================
# Special targets provided by cmake.

# Disable implicit rules so canonical targets will work.
.SUFFIXES:


# Remove some rules from gmake that .SUFFIXES does not remove.
SUFFIXES =

.SUFFIXES: .hpux_make_needs_suffix_list


# Command-line flag to silence nested $(MAKE).
$(VERBOSE)MAKESILENT = -s

# Suppress display of executed commands.
$(VERBOSE).SILENT:


# A target that is always out of date.
cmake_force:

.PHONY : cmake_force

#=============================================================================
# Set environment variables for the build.

# The shell in which to execute make rules.
SHELL = /bin/sh

# The CMake executable.
CMAKE_COMMAND = /opt/cmake/bin/cmake

# The command to remove a file.
RM = /opt/cmake/bin/cmake -E remove -f

# Escaping for special characters.
EQUALS = =

# The top-level source directory on which CMake was run.
CMAKE_SOURCE_DIR = /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme

# The top-level build directory on which CMake was run.
CMAKE_BINARY_DIR = /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build

# Include any dependencies generated for this target.
include CMakeFiles/crackme.dir/depend.make

# Include the progress variables for this target.
include CMakeFiles/crackme.dir/progress.make

# Include the compile flags for this target's objects.
include CMakeFiles/crackme.dir/flags.make

CMakeFiles/crackme.dir/src/crackme.c.o: CMakeFiles/crackme.dir/flags.make
CMakeFiles/crackme.dir/src/crackme.c.o: ../src/crackme.c
	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building C object CMakeFiles/crackme.dir/src/crackme.c.o"
	/usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -o CMakeFiles/crackme.dir/src/crackme.c.o   -c /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/crackme.c

CMakeFiles/crackme.dir/src/crackme.c.i: cmake_force
	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/crackme.dir/src/crackme.c.i"
	/usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/crackme.c > CMakeFiles/crackme.dir/src/crackme.c.i

CMakeFiles/crackme.dir/src/crackme.c.s: cmake_force
	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/crackme.dir/src/crackme.c.s"
	/usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/crackme.c -o CMakeFiles/crackme.dir/src/crackme.c.s

CMakeFiles/crackme.dir/src/anti_debug.c.o: CMakeFiles/crackme.dir/flags.make
CMakeFiles/crackme.dir/src/anti_debug.c.o: ../src/anti_debug.c
	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building C object CMakeFiles/crackme.dir/src/anti_debug.c.o"
	/usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -o CMakeFiles/crackme.dir/src/anti_debug.c.o   -c /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/anti_debug.c

CMakeFiles/crackme.dir/src/anti_debug.c.i: cmake_force
	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing C source to CMakeFiles/crackme.dir/src/anti_debug.c.i"
	/usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -E /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/anti_debug.c > CMakeFiles/crackme.dir/src/anti_debug.c.i

CMakeFiles/crackme.dir/src/anti_debug.c.s: cmake_force
	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling C source to assembly CMakeFiles/crackme.dir/src/anti_debug.c.s"
	/usr/bin/cc $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) -S /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/anti_debug.c -o CMakeFiles/crackme.dir/src/anti_debug.c.s

# Object files for target crackme
crackme_OBJECTS = \
"CMakeFiles/crackme.dir/src/crackme.c.o" \
"CMakeFiles/crackme.dir/src/anti_debug.c.o"

# External object files for target crackme
crackme_EXTERNAL_OBJECTS =

../bin/crackme: CMakeFiles/crackme.dir/src/crackme.c.o
../bin/crackme: CMakeFiles/crackme.dir/src/anti_debug.c.o
../bin/crackme: CMakeFiles/crackme.dir/build.make
../bin/crackme: CMakeFiles/crackme.dir/link.txt
	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Linking C executable ../bin/crackme"
	$(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/crackme.dir/link.txt --verbose=$(VERBOSE)

# Rule to build all files generated by this target.
CMakeFiles/crackme.dir/build: ../bin/crackme

.PHONY : CMakeFiles/crackme.dir/build

CMakeFiles/crackme.dir/clean:
	$(CMAKE_COMMAND) -P CMakeFiles/crackme.dir/cmake_clean.cmake
.PHONY : CMakeFiles/crackme.dir/clean

CMakeFiles/crackme.dir/depend:
	cd /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/crackme.dir/DependInfo.cmake --color=$(COLOR)
.PHONY : CMakeFiles/crackme.dir/depend


```

`example/crackme/build/CMakeFiles/crackme.dir/cmake_clean.cmake`:

```cmake
file(REMOVE_RECURSE
  "../bin/crackme"
  "../bin/crackme.pdb"
  "CMakeFiles/crackme.dir/src/anti_debug.c.o"
  "CMakeFiles/crackme.dir/src/crackme.c.o"
)

# Per-language clean rules from dependency scanning.
foreach(lang C)
  include(CMakeFiles/crackme.dir/cmake_clean_${lang}.cmake OPTIONAL)
endforeach()

```

`example/crackme/build/CMakeFiles/crackme.dir/depend.internal`:

```internal
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 3.16

CMakeFiles/crackme.dir/src/anti_debug.c.o
 /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/anti_debug.c
CMakeFiles/crackme.dir/src/crackme.c.o
 /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/anti_debug.h
 /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/crackme.c
 /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/src/xor_string.h

```

`example/crackme/build/CMakeFiles/crackme.dir/depend.make`:

```make
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 3.16

CMakeFiles/crackme.dir/src/anti_debug.c.o: ../src/anti_debug.c

CMakeFiles/crackme.dir/src/crackme.c.o: ../src/anti_debug.h
CMakeFiles/crackme.dir/src/crackme.c.o: ../src/crackme.c
CMakeFiles/crackme.dir/src/crackme.c.o: ../src/xor_string.h


```

`example/crackme/build/CMakeFiles/crackme.dir/flags.make`:

```make
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 3.16

# compile C with /usr/bin/cc
C_FLAGS = -Wall -Wextra -Wshadow -g0 -fstack-protector-all -std=gnu11  

C_DEFINES = 

C_INCLUDES = 


```

`example/crackme/build/CMakeFiles/crackme.dir/link.txt`:

```txt
/usr/bin/cc -Wall -Wextra -Wshadow -g0 -fstack-protector-all -std=gnu11  -rdynamic CMakeFiles/crackme.dir/src/crackme.c.o CMakeFiles/crackme.dir/src/anti_debug.c.o  -o ../bin/crackme 

```

`example/crackme/build/CMakeFiles/crackme.dir/progress.make`:

```make
CMAKE_PROGRESS_1 = 1
CMAKE_PROGRESS_2 = 2
CMAKE_PROGRESS_3 = 3


```

`example/crackme/build/CMakeFiles/progress.marks`:

```marks
3

```

`example/crackme/build/Makefile`:

```
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 3.16

# Default target executed when no arguments are given to make.
default_target: all

.PHONY : default_target

# Allow only one "make -f Makefile2" at a time, but pass parallelism.
.NOTPARALLEL:


#=============================================================================
# Special targets provided by cmake.

# Disable implicit rules so canonical targets will work.
.SUFFIXES:


# Remove some rules from gmake that .SUFFIXES does not remove.
SUFFIXES =

.SUFFIXES: .hpux_make_needs_suffix_list


# Command-line flag to silence nested $(MAKE).
$(VERBOSE)MAKESILENT = -s

# Suppress display of executed commands.
$(VERBOSE).SILENT:


# A target that is always out of date.
cmake_force:

.PHONY : cmake_force

#=============================================================================
# Set environment variables for the build.

# The shell in which to execute make rules.
SHELL = /bin/sh

# The CMake executable.
CMAKE_COMMAND = /opt/cmake/bin/cmake

# The command to remove a file.
RM = /opt/cmake/bin/cmake -E remove -f

# Escaping for special characters.
EQUALS = =

# The top-level source directory on which CMake was run.
CMAKE_SOURCE_DIR = /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme

# The top-level build directory on which CMake was run.
CMAKE_BINARY_DIR = /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build

#=============================================================================
# Targets provided globally by CMake.

# Special rule for the target rebuild_cache
rebuild_cache:
	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake to regenerate build system..."
	/opt/cmake/bin/cmake -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
.PHONY : rebuild_cache

# Special rule for the target rebuild_cache
rebuild_cache/fast: rebuild_cache

.PHONY : rebuild_cache/fast

# Special rule for the target edit_cache
edit_cache:
	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake cache editor..."
	/opt/cmake/bin/ccmake -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
.PHONY : edit_cache

# Special rule for the target edit_cache
edit_cache/fast: edit_cache

.PHONY : edit_cache/fast

# The main all target
all: cmake_check_build_system
	$(CMAKE_COMMAND) -E cmake_progress_start /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles/progress.marks
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 all
	$(CMAKE_COMMAND) -E cmake_progress_start /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/CMakeFiles 0
.PHONY : all

# The main clean target
clean:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 clean
.PHONY : clean

# The main clean target
clean/fast: clean

.PHONY : clean/fast

# Prepare targets for installation.
preinstall: all
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 preinstall
.PHONY : preinstall

# Prepare targets for installation.
preinstall/fast:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 preinstall
.PHONY : preinstall/fast

# clear depends
depend:
	$(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 1
.PHONY : depend

#=============================================================================
# Target rules for targets named crackme

# Build rule for target.
crackme: cmake_check_build_system
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 crackme
.PHONY : crackme

# fast build rule for target.
crackme/fast:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/crackme.dir/build.make CMakeFiles/crackme.dir/build
.PHONY : crackme/fast

src/anti_debug.o: src/anti_debug.c.o

.PHONY : src/anti_debug.o

# target to build an object file
src/anti_debug.c.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/crackme.dir/build.make CMakeFiles/crackme.dir/src/anti_debug.c.o
.PHONY : src/anti_debug.c.o

src/anti_debug.i: src/anti_debug.c.i

.PHONY : src/anti_debug.i

# target to preprocess a source file
src/anti_debug.c.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/crackme.dir/build.make CMakeFiles/crackme.dir/src/anti_debug.c.i
.PHONY : src/anti_debug.c.i

src/anti_debug.s: src/anti_debug.c.s

.PHONY : src/anti_debug.s

# target to generate assembly for a file
src/anti_debug.c.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/crackme.dir/build.make CMakeFiles/crackme.dir/src/anti_debug.c.s
.PHONY : src/anti_debug.c.s

src/crackme.o: src/crackme.c.o

.PHONY : src/crackme.o

# target to build an object file
src/crackme.c.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/crackme.dir/build.make CMakeFiles/crackme.dir/src/crackme.c.o
.PHONY : src/crackme.c.o

src/crackme.i: src/crackme.c.i

.PHONY : src/crackme.i

# target to preprocess a source file
src/crackme.c.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/crackme.dir/build.make CMakeFiles/crackme.dir/src/crackme.c.i
.PHONY : src/crackme.c.i

src/crackme.s: src/crackme.c.s

.PHONY : src/crackme.s

# target to generate assembly for a file
src/crackme.c.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/crackme.dir/build.make CMakeFiles/crackme.dir/src/crackme.c.s
.PHONY : src/crackme.c.s

# Help Target
help:
	@echo "The following are some of the valid targets for this Makefile:"
	@echo "... all (the default if no target is provided)"
	@echo "... clean"
	@echo "... depend"
	@echo "... rebuild_cache"
	@echo "... edit_cache"
	@echo "... crackme"
	@echo "... src/anti_debug.o"
	@echo "... src/anti_debug.i"
	@echo "... src/anti_debug.s"
	@echo "... src/crackme.o"
	@echo "... src/crackme.i"
	@echo "... src/crackme.s"
.PHONY : help



#=============================================================================
# Special targets to cleanup operation of make.

# Special rule to run CMake to check the build system integrity.
# No rule that depends on this can have commands that come from listfiles
# because they might be regenerated.
cmake_check_build_system:
	$(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 0
.PHONY : cmake_check_build_system


```

`example/crackme/build/cmake_install.cmake`:

```cmake
# Install script for directory: /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme

# Set the install prefix
if(NOT DEFINED CMAKE_INSTALL_PREFIX)
  set(CMAKE_INSTALL_PREFIX "/usr/local")
endif()
string(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
if(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  if(BUILD_TYPE)
    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  else()
    set(CMAKE_INSTALL_CONFIG_NAME "")
  endif()
  message(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
endif()

# Set the component getting installed.
if(NOT CMAKE_INSTALL_COMPONENT)
  if(COMPONENT)
    message(STATUS "Install component: \"${COMPONENT}\"")
    set(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  else()
    set(CMAKE_INSTALL_COMPONENT)
  endif()
endif()

# Install shared libraries without execute permission?
if(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)
  set(CMAKE_INSTALL_SO_NO_EXE "1")
endif()

# Is this installation the result of a crosscompile?
if(NOT DEFINED CMAKE_CROSSCOMPILING)
  set(CMAKE_CROSSCOMPILING "FALSE")
endif()

if(CMAKE_INSTALL_COMPONENT)
  set(CMAKE_INSTALL_MANIFEST "install_manifest_${CMAKE_INSTALL_COMPONENT}.txt")
else()
  set(CMAKE_INSTALL_MANIFEST "install_manifest.txt")
endif()

string(REPLACE ";" "\n" CMAKE_INSTALL_MANIFEST_CONTENT
       "${CMAKE_INSTALL_MANIFEST_FILES}")
file(WRITE "/home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/example/crackme/build/${CMAKE_INSTALL_MANIFEST}"
     "${CMAKE_INSTALL_MANIFEST_CONTENT}")

```

`example/crackme/packer/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.0)
project(unloaded C)

find_library(CRYPTO_LIB libcrypto.so REQUIRED)

set(hellf_script_path /home/magnussen/Documents/Cours/ENSIBS/2A/Compilateur_Anti_Reverse/Embuche/v2/class_embuche/cmake_bakery/hellf_scripts)

set(HELLF scripts/packer.py)

execute_process(COMMAND python3.8 ${CMAKE_SOURCE_DIR}/${HELLF} ../bin/crackme OUTPUT_VARIABLE TO_BE_PACKED_SIZE)

set(CMAKE_C_STANDARD 99)
set(CMAKE_C_FLAGS "-Wall  -pedantic -std=c99 -no-pie -DBIN_SIZE=${TO_BE_PACKED_SIZE} -g")
set(CMAKE_C_FLAGS_DEBUG "-DDEBUG")

find_package(OpenSSL REQUIRED)

if ( OpenSSL_FOUND )
    include_directories(${OPENSSL_INCLUDE_DIRS})
    link_directories(${OPENSSL_LIBRARIES})
    message(STATUS "Using OpenSSL ${OPENSSL_VERSION}")
endif()

include_directories(includes)

add_executable(unloaded
        includes/consts.h
        includes/cryptage.h
        includes/utils.h
        src/cryptage.c
        src/utils.c
        src/v0_packer.c
        )


add_custom_target(addLDS
        COMMAND sed -i -e 's,-o,${CMAKE_CURRENT_SOURCE_DIR}/src/layout.lds -o,g' ./CMakeFiles/unloaded.dir/link.txt)

add_dependencies(unloaded addLDS)

target_link_libraries(unloaded ${OPENSSL_LIBRARIES})

add_custom_target(crackme_packed ALL
        COMMAND python3.8 ${CMAKE_SOURCE_DIR}/${HELLF} ${CMAKE_BINARY_DIR}/unloaded ../bin/crackme ${CMAKE_SOURCE_DIR}/../bin/crackme_packed
        COMMAND chmod +x ${CMAKE_SOURCE_DIR}/../bin/crackme_packed )

add_dependencies(crackme_packed unloaded)


```

`example/crackme/packer/includes/consts.h`:

```h
#ifndef CONSTS_H
#define CONSTS_H

#define METADATA_SIZE 16
#define REAL_SIZE BIN_SIZE
#define TO_BE_PACKED_SIZE (REAL_SIZE - METADATA_SIZE)



#ifdef DEBUG
	#include <stdlib.h>
	#include <stdio.h>
    #define handle_error(msg) do { perror(msg); exit(EXIT_FAILURE);} while(0)
#else
    #define handle_error(msg) do {exit(EXIT_FAILURE);} while(0)
#endif

extern char stack[REAL_SIZE] __attribute__ ((section (".fini.")));
extern unsigned char *iv;

extern char *current_binary_name;
extern void *tmp_mapped_binary;
extern int current_binary_size;

extern void *text_size;
extern void* text_addr;

#endif /* CONSTS_H */

```

`example/crackme/packer/includes/cryptage.h`:

```h
#ifndef PACKER2_CRYPTAGE_H
#define PACKER2_CRYPTAGE_H


union SALT {
    char _byte[8];
    unsigned long _long;
};

void do_sha256(unsigned char *hash, unsigned char *addr, long size);
void decrypt(unsigned char *ciphertext, int fd_d);

#endif //PACKER2_CRYPTAGE_H

```

`example/crackme/packer/includes/utils.h`:

```h
#ifndef UTILS_H
#define UTILS_H
#ifndef CONSTS_H
	#include "cryptage.h"
#endif

void save_binary();
unsigned char * get_text_hash();
void preparing_timestamp(union SALT *salt);
void generate_key(unsigned char *new_key, union SALT *salt);
void write_to_binary(char *what, int size, unsigned long offset);

#endif /* UTILS_H */

```

`example/crackme/packer/scripts/depack.py`:

```py
#!/usr/bin/python3
from Hellf import ELF
from hashlib import sha256
from binascii import hexlify
from sys import argv
from struct import unpack, pack

from Crypto.Cipher import AES

e = ELF(argv[1])
surprise = e.get_section_by_name(".fini.")
text = e.get_section_by_name(".text")

timestamp = surprise.data[:8]
timestamp_readable = unpack("<Q", timestamp)[0]

timestamp = timestamp[:4] * 2

text_hash = sha256(text.data).digest()
text_hash_test = sha256(text.data).hexdigest()

key = b"".join([pack("<B", text_hash[i] ^ timestamp[i % 8]) for i in range(len(text_hash))])

# print(hexlify(key))

iv = b"0123456789012345"

c = AES.new(key, AES.MODE_CBC, iv)

print(c.decrypt(surprise.data[16:]))

```

`example/crackme/packer/scripts/do_aes.py`:

```py
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

key = b"01234567890123456789012345678901"
iv = b"0123456789012345"

c = AES.new(key, AES.MODE_CBC, iv)
c.encrypt(pad(b"A" * 128, 16))
binascii.hexlify(_)

```

`example/crackme/packer/scripts/packer.py`:

```py
#!/usr/bin/python3
from Hellf import ELF
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

from hashlib import sha256
from huepy import good
from os import stat
from struct import pack
from sys import argv


def get_size_once_padded(binary, metadata_size):
    """
    Getting the size of the binary once padded.
    """
    bin_size = stat(binary).st_size

    tmp = bin_size % 16
    padding_size = 16 - tmp if tmp != 0 else 16

    return bin_size + padding_size + metadata_size


if __name__ == "__main__":
    # two ways to use this scripts
    # - 1 args, it return the size once padded of the provided binary
    # - 3 args, it encrypt the provided binary, and store it in an additional section .fini.

    if len(argv) == 2:
        print(get_size_once_padded(argv[1], 16), end="")

    elif len(argv) == 4:
        unloaded = ELF(argv[1])

        # :/
        iv = b"0123456789012345"

        surprise = unloaded.get_section_by_name(".fini.")
        text = unloaded.get_section_by_name(".text")

        # computing .text section sha256
        text_sum = sha256(text.data).hexdigest()
        print(good(".text sha256 sum : ") + text_sum)

        key = bytearray.fromhex(text_sum)

        binary_to_be_packed = pad(open(argv[2], "rb").read(), 16)

        encryptor = AES.new(key, AES.MODE_CBC, iv)

        # we are adding 16 bytes of metada, which are the place holder for the timestamp of the last run and the address of the .fini. section on disk.
        encrypted = (
            pack("<Q", 0)
            + pack("<Q", surprise.sh_offset)
            + encryptor.encrypt(binary_to_be_packed)
        )

        surprise.data = encrypted
        print(good("encrypted binary size : {}".format(len(encrypted))))

        unloaded.save(argv[3])

        # unit test
        assert (
            sha256(ELF(argv[3]).get_section_by_name(".text").data).hexdigest()
            == text_sum
        ), "The added section data seems corrupted !".upper()

```

`example/crackme/packer/src/cryptage.c`:

```c
//
// Created by switch on 6/4/20.
//
#include <stdio.h>
#include <unistd.h>
#include <math.h>
#include <string.h>
#include <time.h>

#include <openssl/conf.h>
#include <openssl/evp.h>
#include <openssl/sha.h>

#include "utils.h"
#include "cryptage.h"
#include "consts.h"

// performs sha256 of the given memory space
void do_sha256(unsigned char *hash, unsigned char *addr, long size) {

    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, addr, size);
    SHA256_Final(hash, &sha256);
}

void decrypt(unsigned char *ciphertext, int fd_d)
{
    EVP_CIPHER_CTX *decrypt_ctx, *encrypt_ctx;

    int offset = 0;
    int decrypt_len, encrypt_len;
    int block_size = 0;

    /* +16 bytes come from EVP_XXcryptUpdate
     * it writes the 16 last bytes from the last block at the next call
     * https://security.stackexchange.com/questions/86952/why-does-the-first-call-to-decryptupdate-in-aes-cbc-return-16-fewer-bytes
     * */
    unsigned char decrypted[256+16] = {0};
    unsigned char re_encrypted_text[256+16] = {0};

    int decrypted_len, encrypted_len;
    int size_without_padding = 0;

    union SALT salt; // because I'm salted

    // key for encryption
    // come from sha256(.text) ^ timestamp
    unsigned char *key = get_text_hash();
	// new_key is the key when re encrypting the decoded stuff, it's explained later, enjoy the code
	unsigned char new_key[SHA256_DIGEST_LENGTH] = {0};

    /* if it's first run as
     *      8 bytes                 8 bytes
     * +------------------------+------------------------------------+
     * |  timestamp of last run | additionnal section offset on disk |
     * +------------------------+------------------------------------+
     * | DATAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ...                        |
     * | AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACABAAAAAAAAAAAAA |
     * |  ... AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA |
     * +-------------------------------------------------------------+
     */

	unsigned long long section_offset_on_disk  = *((unsigned long long *) (ciphertext+8));

	if (section_offset_on_disk == 0) handle_error("houston, we got a probleme here");

    if ( *((unsigned long long *) ciphertext) == 0) {

        // getting the timestamp of the run
        salt._long =  (unsigned long) time(NULL);

        // writing timestamp to metadata
        write_to_binary(salt._byte, 8, section_offset_on_disk);

        // preparing the key for encryption
		generate_key(new_key, &salt);

    }

    // it's not the first run, we need to get the timestamp to get the key
    else {

        // retrieving the timestamp
        salt._long = *((unsigned long *) ciphertext);

        generate_key(key, &salt);

        // preparing the new key
        salt._long = (unsigned long) time(NULL);
        // writing timestamp to metadata
        write_to_binary(salt._byte, 8, section_offset_on_disk);

	    // preparing the key for encryption
	    generate_key(new_key, &salt);

    }

    // we skip our metada
    ciphertext += 16;

    if ( !(decrypt_ctx = EVP_CIPHER_CTX_new()) || !(encrypt_ctx = EVP_CIPHER_CTX_new()) ) handle_error("can't initiat context");


    if ( 1 != EVP_EncryptInit_ex(encrypt_ctx, EVP_aes_256_cbc(), NULL, new_key, iv)
        || 1 != EVP_DecryptInit_ex(decrypt_ctx, EVP_aes_256_cbc(), NULL, key, iv)) handle_error("can't init crypto");

    /* decrypting / encrypting routine */

    /*
     * encryption / decryption process operate by 256 bytes block
     * so we count amount of block rounded up. In all case, only the last block could have a different size
     * or just be equal to 256
     */
    for( int i = 0; i < (int) ceil(TO_BE_PACKED_SIZE / 256.0); i++ ) {

    	// would always be 256, unless it's the last block
        block_size = (TO_BE_PACKED_SIZE - (256 * i)) > 256 ?  256 : (TO_BE_PACKED_SIZE - (256 * i)) % 256 ;

        /*
         * as explained before, sometimes 16 bytes are added, but only after on call to xxxcrypt_update is made
         */
        if (i && !offset)
            offset = 16;

        if ( 1 != EVP_DecryptUpdate(decrypt_ctx, decrypted, &decrypt_len, ciphertext + (256 * i), block_size))
        	handle_error("crypto update failed");

        decrypted_len += decrypt_len;


        // re encrypting the stuff
        if(  1 != EVP_EncryptUpdate(encrypt_ctx, re_encrypted_text, &encrypt_len, decrypted + offset, block_size))
	        handle_error("crypto update failed");

        encrypted_len += encrypt_len;

		// i forgot why I added the +16, without it segfault. Better keeping it.
        unsigned long block_offset = section_offset_on_disk + 16 + (256 * i);

	    write_to_binary((char *) re_encrypted_text, block_size, block_offset);

	    // debug, could help
        // BIO_dump_fp (stdout, (const char *)decrypted + offset, block_size);
        // puts("");
        // BIO_dump_fp (stdout, (const char *)ciphertext + (256 * i), block_size);
        // puts("");
        // BIO_dump_fp (stdout, re_encrypted_text, block_size);
        // puts("");

		// PKCS padding, the last byte of decrypted data is the size in byte of padding
        size_without_padding = block_size - ((block_size != 256) ? ((int) decrypted[block_size + 8 - 1]) : 0);

        // writing the part of the ELF to our anonymous file
        write(fd_d, decrypted + offset, size_without_padding);
    }

    save_binary();

    if ( 1 != EVP_DecryptFinal_ex(decrypt_ctx, decrypted + decrypt_len, &decrypt_len)) {
	    #ifdef DEBUG
	        puts("evp_decrypt_final");
	    #endif
    }
    else {
        decrypted_len += decrypt_len;
    }

    if(1 != EVP_EncryptFinal_ex(encrypt_ctx, re_encrypted_text + encrypt_len, &encrypt_len)) {
	    #ifdef DEBUG
	        puts("evp_enrypt_final");
	    #endif

    } else {
        encrypted_len += encrypt_len;
    }

    // be nice
    EVP_CIPHER_CTX_free(decrypt_ctx);
    EVP_CIPHER_CTX_free(encrypt_ctx);
}

```

`example/crackme/packer/src/layout.lds`:

```lds
SECTIONS
{
    text_addr = ADDR(.text);
    text_size = SIZEOF(.text);
}

```

`example/crackme/packer/src/utils.c`:

```c
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>

#include <openssl/sha.h>

#include "consts.h"
#include "cryptage.h"
#include <stdlib.h>

unsigned char * get_text_hash() {

    unsigned char *hash = malloc(SHA224_DIGEST_LENGTH);
    if( hash == NULL) handle_error(".text hash malloc");

    do_sha256(hash, (unsigned char *) &text_addr, (long) &text_size);

    return hash;
}

void preparing_timestamp(union SALT *salt) {
	// preparing the salt which is the timestamp, I shouldn't do that but who cares
	for(int i = 0; i < 4; i++)
		salt->_byte[i + 4] = salt->_byte[i];
}

void generate_key(unsigned char *new_key, union SALT *salt) {
	// preparing the key for encryption

	preparing_timestamp(salt);
	// getting the .text section hash, as key for encryption
	do_sha256(new_key, (unsigned char *) &text_addr, (long) &text_size);

	// Xoring with timestamp
	for ( int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
		new_key[i] ^= (unsigned char) salt->_byte[i % 8];
	}
}


void save_binary (void) {

	/*
	 * As we can't write change directly to the binary as the file has a lock on it from another process which seems to be the loadder,
	 * we just remove it (yeah it's sucks) and write the (modified) image of the binary we maintain in ram
	 * */


	if (current_binary_name) {
		if (-1 == unlink(current_binary_name)) handle_error("couldn't remote ourself :(");

		int out = open(current_binary_name, O_CREAT | O_TRUNC | O_RDWR, S_IRWXU);

		if (NULL != tmp_mapped_binary && out) {
			write(out, tmp_mapped_binary, current_binary_size);
			close(out);
		} else
			handle_error("cannot write to binary");

	}
}

// write stuff to the binary image mapped in the heap then save it
void write_to_binary(char *what, int size, unsigned long offset) {

  if (current_binary_name) {

      memcpy((char *)tmp_mapped_binary + offset, what, size);

  }

}

```

`example/crackme/packer/src/v0_packer.c`:

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>

#include "consts.h"
#include "cryptage.h"


char surprise_section[REAL_SIZE] __attribute__ ((section (".fini."))) = { 0 };
unsigned char *iv = (unsigned char *)"0123456789012345";

char *current_binary_name;  // store the actual binary path and name
void *tmp_mapped_binary;    // address in heap where is store the image of the binary
int current_binary_size;    // size of the binary to be packed


int main(int argc, char** argv, char **env) {

	#ifdef DEBUG
		puts("DEBUG MODE");
	#endif

    char *anon_fd_name = "acab"; // because ftp
    char fname[1024];            // store the anonymous name in /proc/pid/fd/fd

    // fetching user programme name (+ 1 to store a null byte)
    current_binary_name = (void *) malloc(strlen(argv[0]) + 1);
    if (current_binary_name == NULL ) handle_error("malloc argv name");

    strcpy(current_binary_name, argv[0]);

    // mapping binary in memory
    int fd = open(current_binary_name, O_RDONLY);
    if (fd == -1 ) handle_error("fd on packer -1");

    // get file size and reset cursor at the benining
    current_binary_size = lseek(fd, 0 , SEEK_END);
    lseek(fd, 0, SEEK_SET);

    // we gonna map the packer itself in the ram
    tmp_mapped_binary = malloc(current_binary_size);
    if (tmp_mapped_binary == NULL ) handle_error("malloc packer memory mapping");

    if ( read(fd, tmp_mapped_binary, current_binary_size) != current_binary_size)
    	handle_error("can't map binary in memory");

    // creating an anonymous file in ram
    int fd_d = memfd_create(anon_fd_name, MFD_CLOEXEC);

    if (fd_d == -1 ) handle_error("memfd_create failed");

    snprintf(fname, 1024, "/proc/%d/fd/%d", getpid(), fd_d);
    argv[0] = fname;

    // we decrypt the encrypted section, which is stored at *stack
    decrypt((unsigned char *) surprise_section, fd_d);
    execve(fname, argv, env);

#ifdef DEBUG
    // if we reach this statement it means the call to execve failed.
    puts("packee launch failed");
#endif

    return 0; // prettry straight forward
}

// I use arch btw


```

`example/crackme/src/anti_debug.c`:

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/prctl.h>

typedef int bool;
#define true 1
#define false 0

#define check_strings(str_buff) (strstr(str_buff, "gdb") || strstr(str_buff, "ltrace") || strstr(str_buff, "strace") || (strstr(str_buff, "radare2")) || (strstr(str_buff, "ida")))

char* calc_addr(char* p_addr);
void embuche_checker();
int check_ptrace();
int dbg_file_descriptor();
int dbg_cmdline();
int dbg_getppid_name();
int various_ldpreload();

extern char* __executable_start;

char* calc_addr(char* p_addr)
{
    return p_addr + (unsigned long)&__executable_start;
}

void __attribute__((optimize("O1"))) embuche_checker(int dumpable, int ptrace, int file_descriptor, int pid, int ppid, int ld_preload)
{
  /* Overlapping Instructions */
  asm volatile(
  "mov_ins:\n"
  "mov $2283, %%rax\n"
  "xor %%rax, %%rax\n"
  "jz mov_ins+3\n"
  ".byte 0xe8\n"
  : :
  : "%rax");

  if (dumpable == 1) {
    /* prevent core dump */
    prctl(PR_SET_DUMPABLE, 0);
  }

  if (ptrace == 1) {
    if (check_ptrace() == 1)
    {
      exit(0);
    }
  }

  if (file_descriptor == 1) {
    if (dbg_file_descriptor() == 1)
    {
      exit(0);
    }
  }

  if (pid == 1) {
    if (dbg_cmdline() == 1)
    {
      exit(0);
    }
  }

  if (ppid == 1) {
    if (dbg_getppid_name() == 1)
    {
      exit(0);
    }
  }

  if (ld_preload == 1) {
    if (various_ldpreload() == 1)
    {
      exit(0);
    }
  }
}

/* Check if ptrace is already attached */
int __attribute__((optimize("O1"))) check_ptrace()
{
  /* Overlapping Instructions */
  asm volatile(
  "mov_in:\n"
  "mov $2283, %%rax\n"
  "xor %%rax, %%rax\n"
  "jz mov_in+3\n"
  ".byte 0xe8\n"
  : :
  : "%rax");
  return ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0;
}

/* 2 file descriptors when programs open with GDB. Both pointing to the program being debugged.*/
int __attribute__((optimize("O1"))) dbg_file_descriptor()
{
    /* Always Follow the Conditional */
    asm volatile(
    "xor %%rax, %%rax\n"
    "jz always_here + 1\n"
    "always_here:\n"
    ".byte 0xe8\n"
    : :
    : "%rax");

    FILE* fd = fopen("/", "r");
    int nb_fd = fileno(fd);
    fclose(fd);

    return (nb_fd > 3);
}

/* Detect GDB by the mean of /proc/$PID/cmdline, which should no be "gdb" */
int __attribute__((optimize("O1"))) dbg_cmdline()
{
    char* label_address = 0;

    char buff [24], tmp [16];
    FILE* f;

    label_address = calc_addr(((char*)&&return_here) - (unsigned long)&__executable_start);

    /* Early return */
    asm volatile(
    "push %0\n"
    "ret\n"
    ".string \"\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\""
    :
    : "g"(label_address));

    return_here:
    snprintf(buff, 24, "/proc/%d/cmdline", getppid());
    f = fopen(buff, "r");
    if(fgets(tmp, 16, f) != NULL)
    fclose(f);

    return check_strings(tmp);
}

/* Check the parent's name */
int __attribute__((optimize("O1"))) dbg_getppid_name()
{
    char* label_address = 0;

    char buff1[24], buff2[16];
    FILE* f;

    label_address = calc_addr(((char*)&&return_here) - (unsigned long)&__executable_start);

    /* Early return */
    asm volatile(
    "push %0\n"
    "ret\n"
    ".string \"\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\""
    :
    : "g"(label_address));

    return_here:
    snprintf(buff1, 24, "/proc/%d/status", getppid());
    f = fopen(buff1, "r");
    if(fgets(buff2, 16, f) != NULL)

    fclose(f);

    return check_strings(buff2);
}

/* Try to detect the LD_PRELOAD trick by looking into environnement variables of the program. */
int __attribute__((optimize("O1"))) various_ldpreload()
{
    /* Overlapping Instructions */
    asm volatile(
    "mov_i:\n"
    "mov $2283, %%rax\n"
    "xor %%rax, %%rax\n"
    "jz mov_i+3\n"
    ".byte 0xe8\n"
    : :
    : "%rax");

    return (getenv("LD_PRELOAD") != NULL);
}

```

`example/crackme/src/anti_debug.h`:

```h
#ifndef _ANTI_DEBUG_H_
#define _ANTI_DEBUG_H_

typedef int bool;
#define true 1
#define false 0

char* calc_addr(char* p_addr);
void embuche_checker();
int check_ptrace();
int dbg_file_descriptor();
int dbg_cmdline();
int dbg_getppid_name();
int various_ldpreload();

#endif

```

`example/crackme/src/crackme.c`:

```c
#include <stdio.h>
#include <string.h>
#include "anti_debug.h"
#include "xor_string.h"

void __attribute__((constructor)) before_main()
{
  embuche_checker(1, 1, 0, 1, 1, 1);
}

int check_password(const char* p_password)
{
  char magnupass[10] = {0x39, 0xbe, 0xaf, 0xc3, 0x98, 0xd9, 0x27, 0xf0, 0xc4, 0};
  char key_pass[10] = {0x74, 0xdf, 0xc8, 0xad, 0xed, 0x9b, 0x14, 0xc3, 0xb6, 0};

  return memcmp(undo_xor_string(magnupass, 10, key_pass, 10), p_password, 10) != 0;
}

int main (int argc, char** argv) {
    bool (*indirect_call)(const char*) = NULL;

    indirect_call = check_password - 0x100;

    if (argc != 2) {
        printf("Need exactly one argument.\n");
        return -1;
    }
    indirect_call = indirect_call + 0x100;

    if ((*indirect_call)(argv[1])) {
        printf("No, %s is not correct.\n", argv[1]);
        return 1;
    } else {
        printf("Yes, %s is correct!\n", argv[1]);
    }
    return 0;
}

```

`example/crackme/src/xor_string.h`:

```h

/**
 * The macros below can be used to generate a stack string that has been
 * obfuscated by a given "key" (ie 0xaa). The macros are listed from 0-31.
 * The length of the string is the number in the macro name. For example, if I
 * have an 8 byte string I want to obfuscate then I'd use XOR_STRING7. Why 7?
 * Because the macros start at 0.
 */

#define XOR_STRING0(storage, string, key) storage[0] = string[0] ^ key;
#define XOR_STRING1(storage, string, key) storage[1] = string[1] ^ key; \
    XOR_STRING0(storage, string, key);
#define XOR_STRING2(storage, string, key) storage[2] = string[2] ^ key; \
    XOR_STRING1(storage, string, key);
#define XOR_STRING3(storage, string, key) storage[3] = string[3] ^ key; \
    XOR_STRING2(storage, string, key);
#define XOR_STRING4(storage, string, key) storage[4] = string[4] ^ key; \
    XOR_STRING3(storage, string, key);
#define XOR_STRING5(storage, string, key) storage[5] = string[5] ^ key; \
    XOR_STRING4(storage, string, key);
#define XOR_STRING6(storage, string, key) storage[6] = string[6] ^ key; \
    XOR_STRING5(storage, string, key);
#define XOR_STRING7(storage, string, key) storage[7] = string[7] ^ key; \
    XOR_STRING6(storage, string, key);
#define XOR_STRING8(storage, string, key) storage[8] = string[8] ^ key; \
    XOR_STRING7(storage, string, key);
#define XOR_STRING9(storage, string, key) storage[9] = string[9] ^ key; \
    XOR_STRING8(storage, string, key);
#define XOR_STRING10(storage, string, key) storage[10] = string[10] ^ key; \
    XOR_STRING9(storage, string, key);
#define XOR_STRING11(storage, string, key) storage[11] = string[11] ^ key; \
    XOR_STRING10(storage, string, key);
#define XOR_STRING12(storage, string, key) storage[12] = string[12] ^ key; \
    XOR_STRING11(storage, string, key);
#define XOR_STRING13(storage, string, key) storage[13] = string[13] ^ key; \
    XOR_STRING12(storage, string, key);
#define XOR_STRING14(storage, string, key) storage[14] = string[14] ^ key; \
    XOR_STRING13(storage, string, key);
#define XOR_STRING15(storage, string, key) storage[15] = string[15] ^ key; \
    XOR_STRING14(storage, string, key);
#define XOR_STRING16(storage, string, key) storage[16] = string[16] ^ key; \
    XOR_STRING15(storage, string, key);
#define XOR_STRING17(storage, string, key) storage[17] = string[17] ^ key; \
    XOR_STRING16(storage, string, key);
#define XOR_STRING18(storage, string, key) storage[18] = string[18] ^ key; \
    XOR_STRING17(storage, string, key);
#define XOR_STRING19(storage, string, key) storage[19] = string[19] ^ key; \
    XOR_STRING18(storage, string, key);
#define XOR_STRING20(storage, string, key) storage[20] = string[20] ^ key; \
    XOR_STRING19(storage, string, key);
#define XOR_STRING21(storage, string, key) storage[21] = string[21] ^ key; \
    XOR_STRING20(storage, string, key);
#define XOR_STRING22(storage, string, key) storage[22] = string[22] ^ key; \
    XOR_STRING21(storage, string, key);
#define XOR_STRING23(storage, string, key) storage[23] = string[23] ^ key; \
    XOR_STRING22(storage, string, key);
#define XOR_STRING24(storage, string, key) storage[24] = string[24] ^ key; \
    XOR_STRING23(storage, string, key);
#define XOR_STRING25(storage, string, key) storage[25] = string[25] ^ key; \
    XOR_STRING24(storage, string, key);
#define XOR_STRING26(storage, string, key) storage[26] = string[26] ^ key; \
    XOR_STRING25(storage, string, key);
#define XOR_STRING27(storage, string, key) storage[27] = string[27] ^ key; \
    XOR_STRING26(storage, string, key);
#define XOR_STRING28(storage, string, key) storage[28] = string[28] ^ key; \
    XOR_STRING27(storage, string, key);
#define XOR_STRING29(storage, string, key) storage[29] = string[29] ^ key; \
    XOR_STRING28(storage, string, key);
#define XOR_STRING30(storage, string, key) storage[30] = string[30] ^ key; \
    XOR_STRING29(storage, string, key);
#define XOR_STRING31(storage, string, key) storage[31] = string[31] ^ key; \
    XOR_STRING30(storage, string, key);

char* __attribute__((optimize("O1"))) undo_xor_string(char* string, int length, char* key, int key_length)
{

    /* Overlapping Instructions */
    asm volatile(
    "mov_ins:\n"
    "mov $2283, %%rax\n"
    "xor %%rax, %%rax\n"
    "jz mov_ins+3\n"
    ".byte 0xe8\n"
    : :
    : "%rax");

    for (int i = 0; i < length; i++)
    {
        string[i] = string[i] ^ key[i % key_length];
    }

    return string;
}

```

`requirements.txt`:

```txt
pyOpenSSL==19.1.0
Jinja2==2.11.2
huepy==1.2.1
pycryptodome==3.9.7
PyYAML==5.3.1
secrets==1.0.2

```

`snippets/always_follow_conditionnals.c`:

```c
#include <stdio.h>
#include <string.h>

int __attribute__((optimize("O1"))) main (int argc, char** argv) {
    /* Always Follow the Conditional */
    asm volatile(
    "xor %%rax, %%rax\n"
    "jz always_here + 1\n"
    "always_here:\n"
    ".byte 0xe8\n"
    : :
    : "%rax");

    /* A bit of code */

    return 0;
}

```

`snippets/early_return.c`:

```c
#include <stdio.h>
#include <string.h>
#include "anti_debug.h"

int myfunction()
{
  return 1;
}

int __attribute__((optimize("O1"))) main (int argc, char** argv) {
  char* label_address = 0;

  /* A bit of code */
  label_address = calc_addr(((char*)&&return_here) - (unsigned long)&__executable_start);

  /* A bit of code */

  /* Early return */
  asm volatile(
  "push %0\n"
  "ret\n"
  ".string \"\xa2\x33\x04\xe5\x76\x77\xaa\x09\xba\x4b\xac\xfd\xfe\x0f\""
  :
  : "g"(label_address));

  return_here:

  /* A bit of code */

  return 0;
}

```

`snippets/indirect_call.c`:

```c
#include <stdio.h>
#include <string.h>

typedef int bool;
#define true 1
#define false 0

int myfunction()
{
  return 1;
}

int main (int argc, char** argv) {
    bool (*indirect_call)(const char*) = NULL;

    /* A bit of code */

    indirect_call = myfunction - 0x100;

    /* A bit of code */

    indirect_call = indirect_call + 0x100;

    (*indirect_call)();

    return 0;
}

```

`snippets/int3.c`:

```c
#include<signal.h> // include this in your .c file

// be careful not to use this anti-debug with the "ptrace" option in embuche_checker()


// define this function above the main
void int3_shield(int signo);

int main(int argc, char **argv){
    
    signal(SIGTRAP, int3_shield); // place this line at the beginning of your main() function
    __asm__("int3"); // Place this line wherever you want in your program, it will stop the debugger in its tracks.
    // you can put it multiple times if you want, try not to place it in "sensitive areas" where the code is important
    
    return 0;
}

// put this in your .h or in your code
void int3_shield(int signo){
}

```

`snippets/overlapping_instructions.c`:

```c
#include <stdio.h>
#include <string.h>

int __attribute__((optimize("O1"))) main (int argc, char** argv) {
    /* Overlapping Instructions */
    asm volatile(
    "mov_ins:\n"
    "mov $2283, %%rax\n"
    "xor %%rax, %%rax\n"
    "jz mov_ins+3\n"
    ".byte 0xe8\n"
    : :
    : "%rax");

    /* A bit of code */

    return 0;
}

```

`snippets/xor_stack_string.c`:

```c
#include <stdio.h>
#include <string.h>
#include "xor_string.h"

int main (int argc, char** argv) {
  /* Generated by c_xor.py */
  char pass[10] = {0x39, 0xbe, 0xaf, 0xc3, 0x98, 0xd9, 0x27, 0xf0, 0xc4, 0};
  char key_pass[10] = {0x74, 0xdf, 0xc8, 0xad, 0xed, 0x9b, 0x14, 0xc3, 0xb6, 0};

  return undo_xor_string(pass, 10, key_pass, 10);
}

```

`tools/c_xor.py`:

```py
#!/usr/bin/python3.8
# coding: utf-8
import argparse
import secrets

def xor_string(string):
    cipher = []
    key = []

    for i in range(0, len(string)):
        key.append('0x' + secrets.token_bytes(1).hex())
        cipher.append(hex(ord(string[i]) ^ int(key[i], 16)))
    cipher.append(0)
    key.append(0)

    return cipher, key

def generate_code(variable, cipher, key):
    declaration_variable = "char {0}[{1}] = {2};".format(variable, len(cipher), str(cipher).replace('[', '{').replace(']', '}').replace('\'', ''))
    declaration_key = "char {0}[{1}] = {2};".format(variable + "_key", len(key), str(key).replace('[', '{').replace(']', '}').replace('\'', ''))

    declaration = "{0}\n{1}".format(declaration_variable, declaration_key)

    unxor = "{0}[{1}] = undo_xor_string({0}, {1}, {2}, {3});".format(variable, len(cipher), variable + "_key", len(key))

    output = "Declaration:\n{0}\n\nDecryption:\n{1}".format(declaration, unxor)

    return output

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Little helper to xor string and generate C code to unxor it.')
    parser.add_argument('variable', type=str, help='Name of the variable.')
    parser.add_argument('string', type=str, help='The string to xor.')
    args = parser.parse_args()

    if len(args.string) > 32:
        print("String is too long, must be less than 32 chars")
    else:
        cipher, key = xor_string(args.string)
        output = generate_code(args.variable, cipher, key)
        print("Don't forget to add the following header to include the xor decryption function:\n#include \"xor_string.h\"\n")
        print(output)

```

`tools/main.c`:

```c
#include <stdio.h>

int main (int argc, char** argv) {


    return 0;
}

```

`tools/program_init_helper.py`:

```py
#!/usr/bin/python3.8
# coding: utf-8
import argparse
import os
import shutil
import glob

if __name__ == "__main__":
    dir_list = ['bin', 'build', 'src']
    parser = argparse.ArgumentParser(description='Little helper to create the structure of a new C projet.')
    parser.add_argument('path', type=str, help='Path to the new project.')
    args = parser.parse_args()

    try:
        path = args.path
        if path[-1] != os.path.sep:
            path = path + os.path.sep

        os.makedirs(path, exist_ok=True)

        for dir in dir_list:
            os.makedirs(path + dir, exist_ok=True)

        shutil.copyfile(os.path.dirname(os.path.realpath(__file__)) + '/main.c', path + 'src/main.c')

        for file in glob.glob(os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))) + '/class_embuche/c_toolbox/', '*.*')):
            shutil.copy(file, path + 'src/')
    except Exception as e:
        print('[-] Error while creating the new project structure.')
        exit()

```

`tools/test/src/anti_debug.c`:

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/prctl.h>

typedef int bool;
#define true 1
#define false 0

#define check_strings(str_buff) (strstr(str_buff, "gdb") || strstr(str_buff, "ltrace") || strstr(str_buff, "strace") || (strstr(str_buff, "radare2")) || (strstr(str_buff, "ida")))

char* calc_addr(char* p_addr);
void embuche_checker();
int check_ptrace();
int dbg_file_descriptor();
int dbg_cmdline();
int dbg_getppid_name();
int various_ldpreload();

extern char* __executable_start;

char* calc_addr(char* p_addr)
{
    return p_addr + (unsigned long)&__executable_start;
}

void __attribute__((optimize("O1"))) embuche_checker(int dumpable, int ptrace, int file_descriptor, int pid, int ppid, int ld_preload)
{
  /* Overlapping Instructions */
  asm volatile(
  "mov_ins:\n"
  "mov $2283, %%rax\n"
  "xor %%rax, %%rax\n"
  "jz mov_ins+3\n"
  ".byte 0xe8\n"
  : :
  : "%rax");

  if (dumpable == 1) {
    /* prevent core dump */
    prctl(PR_SET_DUMPABLE, 0);
  }

  if (ptrace == 1) {
    if (check_ptrace() == 1)
    {
      exit(0);
    }
  }

  if (file_descriptor == 1) {
    if (dbg_file_descriptor() == 1)
    {
      exit(0);
    }
  }

  if (pid == 1) {
    if (dbg_cmdline() == 1)
    {
      exit(0);
    }
  }

  if (ppid == 1) {
    if (dbg_getppid_name() == 1)
    {
      exit(0);
    }
  }

  if (ld_preload == 1) {
    if (various_ldpreload() == 1)
    {
      exit(0);
    }
  }
}

/* Check if ptrace is already attached */
int __attribute__((optimize("O1"))) check_ptrace()
{
  /* Overlapping Instructions */
  asm volatile(
  "mov_in:\n"
  "mov $2283, %%rax\n"
  "xor %%rax, %%rax\n"
  "jz mov_in+3\n"
  ".byte 0xe8\n"
  : :
  : "%rax");
  return ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0;
}

/* 2 file descriptors when programs open with GDB. Both pointing to the program being debugged.*/
int __attribute__((optimize("O1"))) dbg_file_descriptor()
{
    /* Always Follow the Conditional */
    asm volatile(
    "xor %%rax, %%rax\n"
    "jz always_here + 1\n"
    "always_here:\n"
    ".byte 0xe8\n"
    : :
    : "%rax");

    FILE* fd = fopen("/", "r");
    int nb_fd = fileno(fd);
    fclose(fd);

    return (nb_fd > 3);
}

/* Detect GDB by the mean of /proc/$PID/cmdline, which should no be "gdb" */
int __attribute__((optimize("O1"))) dbg_cmdline()
{
    char* label_address = 0;

    char buff [24], tmp [16];
    FILE* f;

    label_address = calc_addr(((char*)&&return_here) - (unsigned long)&__executable_start);

    /* Early return */
    asm volatile(
    "push %0\n"
    "ret\n"
    ".string \"\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\""
    :
    : "g"(label_address));

    return_here:
    snprintf(buff, 24, "/proc/%d/cmdline", getppid());
    f = fopen(buff, "r");
    if(fgets(tmp, 16, f) != NULL)
    fclose(f);

    return check_strings(tmp);
}

/* Check the parent's name */
int __attribute__((optimize("O1"))) dbg_getppid_name()
{
    char* label_address = 0;

    char buff1[24], buff2[16];
    FILE* f;

    label_address = calc_addr(((char*)&&return_here) - (unsigned long)&__executable_start);

    /* Early return */
    asm volatile(
    "push %0\n"
    "ret\n"
    ".string \"\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\""
    :
    : "g"(label_address));

    return_here:
    snprintf(buff1, 24, "/proc/%d/status", getppid());
    f = fopen(buff1, "r");
    if(fgets(buff2, 16, f) != NULL)

    fclose(f);

    return check_strings(buff2);
}

/* Try to detect the LD_PRELOAD trick by looking into environnement variables of the program. */
int __attribute__((optimize("O1"))) various_ldpreload()
{
    /* Overlapping Instructions */
    asm volatile(
    "mov_i:\n"
    "mov $2283, %%rax\n"
    "xor %%rax, %%rax\n"
    "jz mov_i+3\n"
    ".byte 0xe8\n"
    : :
    : "%rax");

    return (getenv("LD_PRELOAD") != NULL);
}

```

`tools/test/src/anti_debug.h`:

```h
#ifndef _ANTI_DEBUG_H_
#define _ANTI_DEBUG_H_

typedef int bool;
#define true 1
#define false 0

char* calc_addr(char* p_addr);
void embuche_checker();
int check_ptrace();
int dbg_file_descriptor();
int dbg_cmdline();
int dbg_getppid_name();
int various_ldpreload();

#endif

```

`tools/test/src/main.c`:

```c
#include <stdio.h>

int main (int argc, char** argv) {


    return 0;
}

```

`tools/test/src/xor_string.h`:

```h

/**
 * The macros below can be used to generate a stack string that has been
 * obfuscated by a given "key" (ie 0xaa). The macros are listed from 0-31.
 * The length of the string is the number in the macro name. For example, if I
 * have an 8 byte string I want to obfuscate then I'd use XOR_STRING7. Why 7?
 * Because the macros start at 0.
 */

#define XOR_STRING0(storage, string, key) storage[0] = string[0] ^ key;
#define XOR_STRING1(storage, string, key) storage[1] = string[1] ^ key; \
    XOR_STRING0(storage, string, key);
#define XOR_STRING2(storage, string, key) storage[2] = string[2] ^ key; \
    XOR_STRING1(storage, string, key);
#define XOR_STRING3(storage, string, key) storage[3] = string[3] ^ key; \
    XOR_STRING2(storage, string, key);
#define XOR_STRING4(storage, string, key) storage[4] = string[4] ^ key; \
    XOR_STRING3(storage, string, key);
#define XOR_STRING5(storage, string, key) storage[5] = string[5] ^ key; \
    XOR_STRING4(storage, string, key);
#define XOR_STRING6(storage, string, key) storage[6] = string[6] ^ key; \
    XOR_STRING5(storage, string, key);
#define XOR_STRING7(storage, string, key) storage[7] = string[7] ^ key; \
    XOR_STRING6(storage, string, key);
#define XOR_STRING8(storage, string, key) storage[8] = string[8] ^ key; \
    XOR_STRING7(storage, string, key);
#define XOR_STRING9(storage, string, key) storage[9] = string[9] ^ key; \
    XOR_STRING8(storage, string, key);
#define XOR_STRING10(storage, string, key) storage[10] = string[10] ^ key; \
    XOR_STRING9(storage, string, key);
#define XOR_STRING11(storage, string, key) storage[11] = string[11] ^ key; \
    XOR_STRING10(storage, string, key);
#define XOR_STRING12(storage, string, key) storage[12] = string[12] ^ key; \
    XOR_STRING11(storage, string, key);
#define XOR_STRING13(storage, string, key) storage[13] = string[13] ^ key; \
    XOR_STRING12(storage, string, key);
#define XOR_STRING14(storage, string, key) storage[14] = string[14] ^ key; \
    XOR_STRING13(storage, string, key);
#define XOR_STRING15(storage, string, key) storage[15] = string[15] ^ key; \
    XOR_STRING14(storage, string, key);
#define XOR_STRING16(storage, string, key) storage[16] = string[16] ^ key; \
    XOR_STRING15(storage, string, key);
#define XOR_STRING17(storage, string, key) storage[17] = string[17] ^ key; \
    XOR_STRING16(storage, string, key);
#define XOR_STRING18(storage, string, key) storage[18] = string[18] ^ key; \
    XOR_STRING17(storage, string, key);
#define XOR_STRING19(storage, string, key) storage[19] = string[19] ^ key; \
    XOR_STRING18(storage, string, key);
#define XOR_STRING20(storage, string, key) storage[20] = string[20] ^ key; \
    XOR_STRING19(storage, string, key);
#define XOR_STRING21(storage, string, key) storage[21] = string[21] ^ key; \
    XOR_STRING20(storage, string, key);
#define XOR_STRING22(storage, string, key) storage[22] = string[22] ^ key; \
    XOR_STRING21(storage, string, key);
#define XOR_STRING23(storage, string, key) storage[23] = string[23] ^ key; \
    XOR_STRING22(storage, string, key);
#define XOR_STRING24(storage, string, key) storage[24] = string[24] ^ key; \
    XOR_STRING23(storage, string, key);
#define XOR_STRING25(storage, string, key) storage[25] = string[25] ^ key; \
    XOR_STRING24(storage, string, key);
#define XOR_STRING26(storage, string, key) storage[26] = string[26] ^ key; \
    XOR_STRING25(storage, string, key);
#define XOR_STRING27(storage, string, key) storage[27] = string[27] ^ key; \
    XOR_STRING26(storage, string, key);
#define XOR_STRING28(storage, string, key) storage[28] = string[28] ^ key; \
    XOR_STRING27(storage, string, key);
#define XOR_STRING29(storage, string, key) storage[29] = string[29] ^ key; \
    XOR_STRING28(storage, string, key);
#define XOR_STRING30(storage, string, key) storage[30] = string[30] ^ key; \
    XOR_STRING29(storage, string, key);
#define XOR_STRING31(storage, string, key) storage[31] = string[31] ^ key; \
    XOR_STRING30(storage, string, key);

char* __attribute__((optimize("O1"))) undo_xor_string(char* string, int length, char* key, int key_length)
{

    /* Overlapping Instructions */
    asm volatile(
    "mov_ins:\n"
    "mov $2283, %%rax\n"
    "xor %%rax, %%rax\n"
    "jz mov_ins+3\n"
    ".byte 0xe8\n"
    : :
    : "%rax");

    for (int i = 0; i < length; i++)
    {
        string[i] = string[i] ^ key[i % key_length];
    }

    return string;
}

```