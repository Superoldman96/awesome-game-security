Project Path: arc_gmh5225_Pink-Eye_cxiq5g3s

Source Tree:

```txt
arc_gmh5225_Pink-Eye_cxiq5g3s
├── BEEmulator
│   ├── BEEmulator.sln
│   ├── BEEmulator.vcxproj
│   ├── BEEmulator.vcxproj.filters
│   ├── BEEmulator.vcxproj.user
│   ├── Header Files
│   │   ├── Includes.hpp
│   │   ├── Structs.hpp
│   │   └── Utils.hpp
│   └── Source Files
│       └── Main.cpp
└── README.md

```

`BEEmulator/BEEmulator.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32901.215
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BEEmulator", "BEEmulator.vcxproj", "{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Debug|ARM.ActiveCfg = Debug|ARM
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Debug|ARM.Build.0 = Debug|ARM
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Debug|ARM.Deploy.0 = Debug|ARM
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Debug|ARM64.Build.0 = Debug|ARM64
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Debug|x64.ActiveCfg = Debug|x64
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Debug|x64.Build.0 = Debug|x64
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Debug|x64.Deploy.0 = Debug|x64
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Debug|x86.ActiveCfg = Debug|Win32
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Debug|x86.Build.0 = Debug|Win32
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Debug|x86.Deploy.0 = Debug|Win32
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Release|ARM.ActiveCfg = Release|ARM
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Release|ARM.Build.0 = Release|ARM
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Release|ARM.Deploy.0 = Release|ARM
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Release|ARM64.ActiveCfg = Release|ARM64
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Release|ARM64.Build.0 = Release|ARM64
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Release|ARM64.Deploy.0 = Release|ARM64
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Release|x64.ActiveCfg = Release|x64
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Release|x64.Build.0 = Release|x64
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Release|x64.Deploy.0 = Release|x64
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Release|x86.ActiveCfg = Release|Win32
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Release|x86.Build.0 = Release|Win32
		{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {CD17241F-6195-4D4E-A91B-F03C8671F654}
	EndGlobalSection
EndGlobal

```

`BEEmulator/BEEmulator.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B297B261-7F63-48BA-A2F5-E0EB95AFE09E}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>BEEmulator</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <ClCompile>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <AdditionalIncludeDirectories>$(ProjectDir)/Source Files;$(ProjectDir)/Header Files;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <AdditionalIncludeDirectories>$(ProjectDir)/Source Files;$(ProjectDir)/Header Files;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>Default</LanguageStandard_C>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <AdditionalDependencies>FltMgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <Inf>
      <SpecifyArchitecture>false</SpecifyArchitecture>
    </Inf>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source Files\Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Header Files\Includes.hpp" />
    <ClInclude Include="Header Files\Structs.hpp" />
    <ClInclude Include="Header Files\Utils.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BEEmulator/BEEmulator.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source Files\Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Header Files\Includes.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Header Files\Structs.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Header Files\Utils.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`BEEmulator/BEEmulator.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`BEEmulator/Header Files/Includes.hpp`:

```hpp
#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <cstdint>
#include <intrin.h>
#include <ntimage.h>
#include <cstdint>
#include <cstddef>
#include <ntdef.h>
#include <ntstrsafe.h>
#include <handleapi.h>

#include "Structs.hpp"
#include "Utils.hpp"
```

`BEEmulator/Header Files/Structs.hpp`:

```hpp
#pragma once
extern "C" NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);
extern "C" PVOID FltGetRoutineAddress(PCSTR FltMgrRoutineName);
extern "C" PVOID PsGetProcessSectionBaseAddress(PEPROCESS Process);

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemInformationClassMin = 0,
	SystemBasicInformation = 0,
	SystemProcessorInformation = 1,
	SystemPerformanceInformation = 2,
	SystemTimeOfDayInformation = 3,
	SystemPathInformation = 4,
	SystemNotImplemented1 = 4,
	SystemProcessInformation = 5,
	SystemProcessesAndThreadsInformation = 5,
	SystemCallCountInfoInformation = 6,
	SystemCallCounts = 6,
	SystemDeviceInformation = 7,
	SystemConfigurationInformation = 7,
	SystemProcessorPerformanceInformation = 8,
	SystemProcessorTimes = 8,
	SystemFlagsInformation = 9,
	SystemGlobalFlag = 9,
	SystemCallTimeInformation = 10,
	SystemNotImplemented2 = 10,
	SystemModuleInformation = 11,
	SystemLocksInformation = 12,
	SystemLockInformation = 12,
	SystemStackTraceInformation = 13,
	SystemNotImplemented3 = 13,
	SystemPagedPoolInformation = 14,
	SystemNotImplemented4 = 14,
	SystemNonPagedPoolInformation = 15,
	SystemNotImplemented5 = 15,
	SystemHandleInformation = 16,
	SystemObjectInformation = 17,
	SystemPageFileInformation = 18,
	SystemPagefileInformation = 18,
	SystemVdmInstemulInformation = 19,
	SystemInstructionEmulationCounts = 19,
	SystemVdmBopInformation = 20,
	SystemInvalidInfoClass1 = 20,
	SystemFileCacheInformation = 21,
	SystemCacheInformation = 21,
	SystemPoolTagInformation = 22,
	SystemInterruptInformation = 23,
	SystemProcessorStatistics = 23,
	SystemDpcBehaviourInformation = 24,
	SystemDpcInformation = 24,
	SystemFullMemoryInformation = 25,
	SystemNotImplemented6 = 25,
	SystemLoadImage = 26,
	SystemUnloadImage = 27,
	SystemTimeAdjustmentInformation = 28,
	SystemTimeAdjustment = 28,
	SystemSummaryMemoryInformation = 29,
	SystemNotImplemented7 = 29,
	SystemNextEventIdInformation = 30,
	SystemNotImplemented8 = 30,
	SystemEventIdsInformation = 31,
	SystemNotImplemented9 = 31,
	SystemCrashDumpInformation = 32,
	SystemExceptionInformation = 33,
	SystemCrashDumpStateInformation = 34,
	SystemKernelDebuggerInformation = 35,
	SystemContextSwitchInformation = 36,
	SystemRegistryQuotaInformation = 37,
	SystemLoadAndCallImage = 38,
	SystemPrioritySeparation = 39,
	SystemPlugPlayBusInformation = 40,
	SystemNotImplemented10 = 40,
	SystemDockInformation = 41,
	SystemNotImplemented11 = 41,
	SystemInvalidInfoClass2 = 42,
	SystemProcessorSpeedInformation = 43,
	SystemInvalidInfoClass3 = 43,
	SystemCurrentTimeZoneInformation = 44,
	SystemTimeZoneInformation = 44,
	SystemLookasideInformation = 45,
	SystemSetTimeSlipEvent = 46,
	SystemCreateSession = 47,
	SystemDeleteSession = 48,
	SystemInvalidInfoClass4 = 49,
	SystemRangeStartInformation = 50,
	SystemVerifierInformation = 51,
	SystemAddVerifier = 52,
	SystemSessionProcessesInformation = 53,
	SystemInformationClassMax
} SYSTEM_INFORMATION_CLASS;

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];

} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES {
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];

} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _POOL_TRACKER_BIG_PAGES
{
	volatile ULONGLONG Va;                                                  //0x0
	ULONG Key;                                                              //0x8
	ULONG Pattern : 8;                                                        //0xc
	ULONG PoolType : 12;                                                      //0xc
	ULONG SlushSize : 12;                                                     //0xc
	ULONGLONG NumberOfBytes;                                                //0x10
}POOL_TRACKER_BIG_PAGES, * PPOOL_TRACKER_BIG_PAGES;

typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB_LDR_DATA {
	ULONG Length;
	UCHAR Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _PEB {
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	PVOID CrossProcessFlags;
	PVOID KernelCallbackTable;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
} PEB, * PPEB;

typedef enum _KAPC_ENVIRONMENT
{
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
} KAPC_ENVIRONMENT;

typedef VOID(NTAPI* PKNORMAL_ROUTINE)(
	_In_ PVOID NormalContext,
	_In_ PVOID SystemArgument1,
	_In_ PVOID SystemArgument2
	);

typedef VOID KKERNEL_ROUTINE(
	_In_ PRKAPC Apc,
	_Inout_opt_ PKNORMAL_ROUTINE* NormalRoutine,
	_Inout_opt_ PVOID* NormalContext,
	_Inout_ PVOID* SystemArgument1,
	_Inout_ PVOID* SystemArgument2
);

typedef struct
{
	struct _DISPATCHER_HEADER Header;                                       //0x0
	VOID* SListFaultAddress;                                                //0x18
	ULONGLONG QuantumTarget;                                                //0x20
	VOID* InitialStack;                                                     //0x28
	VOID* volatile StackLimit;                                              //0x30
	VOID* StackBase;                                                        //0x38
	ULONGLONG ThreadLock;                                                   //0x40
	volatile ULONGLONG CycleTime;                                           //0x48
	ULONG CurrentRunTime;                                                   //0x50
	ULONG ExpectedRunTime;                                                  //0x54
	VOID* KernelStack;                                                      //0x58
	struct _XSAVE_FORMAT* StateSaveArea;                                    //0x60
	struct _KSCHEDULING_GROUP* volatile SchedulingGroup;                    //0x68
	char WaitRegister;                                                      //0x70
	volatile UCHAR Running;                                                 //0x71
	UCHAR Alerted[2];                                                       //0x72
	union
	{
		struct
		{
			ULONG AutoBoostActive : 1;                                        //0x74
			ULONG ReadyTransition : 1;                                        //0x74
			ULONG WaitNext : 1;                                               //0x74
			ULONG SystemAffinityActive : 1;                                   //0x74
			ULONG Alertable : 1;                                              //0x74
			ULONG UserStackWalkActive : 1;                                    //0x74
			ULONG ApcInterruptRequest : 1;                                    //0x74
			ULONG QuantumEndMigrate : 1;                                      //0x74
			ULONG UmsDirectedSwitchEnable : 1;                                //0x74
			ULONG TimerActive : 1;                                            //0x74
			ULONG SystemThread : 1;                                           //0x74
			ULONG ProcessDetachActive : 1;                                    //0x74
			ULONG CalloutActive : 1;                                          //0x74
			ULONG ScbReadyQueue : 1;                                          //0x74
			ULONG ApcQueueable : 1;                                           //0x74
			ULONG ReservedStackInUse : 1;                                     //0x74
			ULONG UmsPerformingSyscall : 1;                                   //0x74
			ULONG TimerSuspended : 1;                                         //0x74
			ULONG SuspendedWaitMode : 1;                                      //0x74
			ULONG SuspendSchedulerApcWait : 1;                                //0x74
			ULONG CetShadowStack : 1;                                         //0x74
			ULONG Reserved : 11;                                              //0x74
		};
		LONG MiscFlags;                                                     //0x74
	};
	union
	{
		struct
		{
			ULONG BamQosLevel : 2;                                            //0x78
			ULONG AutoAlignment : 1;                                          //0x78
			ULONG DisableBoost : 1;                                           //0x78
			ULONG AlertedByThreadId : 1;                                      //0x78
			ULONG QuantumDonation : 1;                                        //0x78
			ULONG EnableStackSwap : 1;                                        //0x78
			ULONG GuiThread : 1;                                              //0x78
			ULONG DisableQuantum : 1;                                         //0x78
			ULONG ChargeOnlySchedulingGroup : 1;                              //0x78
			ULONG DeferPreemption : 1;                                        //0x78
			ULONG QueueDeferPreemption : 1;                                   //0x78
			ULONG ForceDeferSchedule : 1;                                     //0x78
			ULONG SharedReadyQueueAffinity : 1;                               //0x78
			ULONG FreezeCount : 1;                                            //0x78
			ULONG TerminationApcRequest : 1;                                  //0x78
			ULONG AutoBoostEntriesExhausted : 1;                              //0x78
			ULONG KernelStackResident : 1;                                    //0x78
			ULONG TerminateRequestReason : 2;                                 //0x78
			ULONG ProcessStackCountDecremented : 1;                           //0x78
			ULONG RestrictedGuiThread : 1;                                    //0x78
			ULONG VpBackingThread : 1;                                        //0x78
			ULONG ThreadFlagsSpare : 1;                                       //0x78
			ULONG EtwStackTraceApcInserted : 8;                               //0x78
		};
		volatile LONG ThreadFlags;                                          //0x78
	};
	volatile UCHAR Tag;                                                     //0x7c
	UCHAR SystemHeteroCpuPolicy;                                            //0x7d
	UCHAR UserHeteroCpuPolicy : 7;                                            //0x7e
	UCHAR ExplicitSystemHeteroCpuPolicy : 1;                                  //0x7e
	union
	{
		struct
		{
			UCHAR RunningNonRetpolineCode : 1;                                //0x7f
			UCHAR SpecCtrlSpare : 7;                                          //0x7f
		};
		UCHAR SpecCtrl;                                                     //0x7f
	};
	ULONG SystemCallNumber;                                                 //0x80
	ULONG ReadyTime;                                                        //0x84
	VOID* FirstArgument;                                                    //0x88
	struct _KTRAP_FRAME* TrapFrame;                                         //0x90
	union
	{
		struct _KAPC_STATE ApcState;                                        //0x98
		struct
		{
			UCHAR ApcStateFill[43];                                         //0x98
			CHAR Priority;                                                  //0xc3
			ULONG UserIdealProcessor;                                       //0xc4
		};
	};
	volatile LONGLONG WaitStatus;                                           //0xc8
	struct _KWAIT_BLOCK* WaitBlockList;                                     //0xd0
	union
	{
		struct _LIST_ENTRY WaitListEntry;                                   //0xd8
		struct _SINGLE_LIST_ENTRY SwapListEntry;                            //0xd8
	};
	struct _DISPATCHER_HEADER* volatile Queue;                              //0xe8
	VOID* Teb;                                                              //0xf0
	ULONGLONG RelativeTimerBias;                                            //0xf8
	struct _KTIMER Timer;                                                   //0x100
	union
	{
		struct _KWAIT_BLOCK WaitBlock[4];                                   //0x140
		struct
		{
			UCHAR WaitBlockFill4[20];                                       //0x140
			ULONG ContextSwitches;                                          //0x154
		};
		struct
		{
			UCHAR WaitBlockFill5[68];                                       //0x140
			volatile UCHAR State;                                           //0x184
			CHAR Spare13;                                                   //0x185
			UCHAR WaitIrql;                                                 //0x186
			CHAR WaitMode;                                                  //0x187
		};
		struct
		{
			UCHAR WaitBlockFill6[116];                                      //0x140
			ULONG WaitTime;                                                 //0x1b4
		};
		struct
		{
			UCHAR WaitBlockFill7[164];                                      //0x140
			union
			{
				struct
				{
					SHORT KernelApcDisable;                                 //0x1e4
					SHORT SpecialApcDisable;                                //0x1e6
				};
				ULONG CombinedApcDisable;                                   //0x1e4
			};
		};
		struct
		{
			UCHAR WaitBlockFill8[40];                                       //0x140
			struct _KTHREAD_COUNTERS* ThreadCounters;                       //0x168
		};
		struct
		{
			UCHAR WaitBlockFill9[88];                                       //0x140
			struct _XSTATE_SAVE* XStateSave;                                //0x198
		};
		struct
		{
			UCHAR WaitBlockFill10[136];                                     //0x140
			VOID* volatile Win32Thread;                                     //0x1c8
		};
		struct
		{
			UCHAR WaitBlockFill11[176];                                     //0x140
			struct _UMS_CONTROL_BLOCK* Ucb;                                 //0x1f0
			struct _KUMS_CONTEXT_HEADER* volatile Uch;                      //0x1f8
		};
	};
	VOID* Spare21;                                                          //0x200
	struct _LIST_ENTRY QueueListEntry;                                      //0x208
	union
	{
		volatile ULONG NextProcessor;                                       //0x218
		struct
		{
			ULONG NextProcessorNumber : 31;                                   //0x218
			ULONG SharedReadyQueue : 1;                                       //0x218
		};
	};
	LONG QueuePriority;                                                     //0x21c
	struct _KPROCESS* Process;                                              //0x220
	union
	{
		struct _GROUP_AFFINITY UserAffinity;                                //0x228
		struct
		{
			UCHAR UserAffinityFill[10];                                     //0x228
			CHAR PreviousMode;                                              //0x232
			CHAR BasePriority;                                              //0x233
			union
			{
				CHAR PriorityDecrement;                                     //0x234
				struct
				{
					UCHAR ForegroundBoost : 4;                                //0x234
					UCHAR UnusualBoost : 4;                                   //0x234
				};
			};
			UCHAR Preempted;                                                //0x235
			UCHAR AdjustReason;                                             //0x236
			CHAR AdjustIncrement;                                           //0x237
		};
	};
	ULONGLONG AffinityVersion;                                              //0x238
	union
	{
		struct _GROUP_AFFINITY Affinity;                                    //0x240
		struct
		{
			UCHAR AffinityFill[10];                                         //0x240
			UCHAR ApcStateIndex;                                            //0x24a
			UCHAR WaitBlockCount;                                           //0x24b
			ULONG IdealProcessor;                                           //0x24c
		};
	};
	ULONGLONG NpxState;                                                     //0x250
	union
	{
		struct _KAPC_STATE SavedApcState;                                   //0x258
		struct
		{
			UCHAR SavedApcStateFill[43];                                    //0x258
			UCHAR WaitReason;                                               //0x283
			CHAR SuspendCount;                                              //0x284
			CHAR Saturation;                                                //0x285
			USHORT SListFaultCount;                                         //0x286
		};
	};
	union
	{
		struct _KAPC SchedulerApc;                                          //0x288
		struct
		{
			UCHAR SchedulerApcFill0[1];                                     //0x288
			UCHAR ResourceIndex;                                            //0x289
		};
		struct
		{
			UCHAR SchedulerApcFill1[3];                                     //0x288
			UCHAR QuantumReset;                                             //0x28b
		};
		struct
		{
			UCHAR SchedulerApcFill2[4];                                     //0x288
			ULONG KernelTime;                                               //0x28c
		};
		struct
		{
			UCHAR SchedulerApcFill3[64];                                    //0x288
			struct _KPRCB* volatile WaitPrcb;                               //0x2c8
		};
		struct
		{
			UCHAR SchedulerApcFill4[72];                                    //0x288
			VOID* LegoData;                                                 //0x2d0
		};
		struct
		{
			UCHAR SchedulerApcFill5[83];                                    //0x288
			UCHAR CallbackNestingLevel;                                     //0x2db
			ULONG UserTime;                                                 //0x2dc
		};
	};
	struct _KEVENT SuspendEvent;                                            //0x2e0
	struct _LIST_ENTRY ThreadListEntry;                                     //0x2f8
	struct _LIST_ENTRY MutantListHead;                                      //0x308
	UCHAR AbEntrySummary;                                                   //0x318
	UCHAR AbWaitEntryCount;                                                 //0x319
	UCHAR AbAllocationRegionCount;                                          //0x31a
	CHAR SystemPriority;                                                    //0x31b
	ULONG SecureThreadCookie;                                               //0x31c
	char LockEntries[0x240];                                                //0x320
	struct _SINGLE_LIST_ENTRY PropagateBoostsEntry;                         //0x560
	struct _SINGLE_LIST_ENTRY IoSelfBoostsEntry;                            //0x568
	UCHAR PriorityFloorCounts[16];                                          //0x570
	ULONG PriorityFloorSummary;                                             //0x580
	volatile LONG AbCompletedIoBoostCount;                                  //0x584
	volatile LONG AbCompletedIoQoSBoostCount;                               //0x588
	volatile SHORT KeReferenceCount;                                        //0x58c
	UCHAR AbOrphanedEntrySummary;                                           //0x58e
	UCHAR AbOwnedEntryCount;                                                //0x58f
	ULONG ForegroundLossTime;                                               //0x590
	union
	{
		struct _LIST_ENTRY GlobalForegroundListEntry;                       //0x598
		struct
		{
			struct _SINGLE_LIST_ENTRY ForegroundDpcStackListEntry;          //0x598
			ULONGLONG InGlobalForegroundList;                               //0x5a0
		};
	};
	LONGLONG ReadOperationCount;                                            //0x5a8
	LONGLONG WriteOperationCount;                                           //0x5b0
	LONGLONG OtherOperationCount;                                           //0x5b8
	LONGLONG ReadTransferCount;                                             //0x5c0
	LONGLONG WriteTransferCount;                                            //0x5c8
	LONGLONG OtherTransferCount;                                            //0x5d0
	struct _KSCB* QueuedScb;                                                //0x5d8
	volatile ULONG ThreadTimerDelay;                                        //0x5e0
	union
	{
		volatile LONG ThreadFlags2;                                         //0x5e4
		struct
		{
			ULONG PpmPolicy : 2;                                              //0x5e4
			ULONG ThreadFlags2Reserved : 30;                                  //0x5e4
		};
	};
	VOID* SchedulerAssist;                                                  //0x5e8
} KThread;

typedef VOID(NTAPI* PKRUNDOWN_ROUTINE)(_In_ PRKAPC Apc);
```

`BEEmulator/Header Files/Utils.hpp`:

```hpp
#define IMAGE_DIRECTORY_ENTRY_IMPORT 1
#define POOLTAG 'EB'

typedef unsigned long long QWORD;
#define ABSOLUTE(wait)			(wait)
#define RELATIVE(wait)			(-(wait))
#define NANOSECONDS(nanos)		(((signed __int64)(nanos)) / 100L)
#define MICROSECONDS(micros)	(((signed __int64)(micros)) * NANOSECONDS(1000L))
#define MILLISECONDS(milli)		(((signed __int64)(milli)) * MICROSECONDS(1000L))
#define SECONDS(seconds)		(((signed __int64)(seconds)) * MILLISECONDS(1000L))

namespace Utils
{
    PVOID GetSystemRoutineAddress(LPCWSTR name)
    {
        UNICODE_STRING unicodeName;
        RtlInitUnicodeString(&unicodeName, name);
        return MmGetSystemRoutineAddress(&unicodeName);
    }

    PVOID GetSystemModuleBase(LPCWSTR name)
    {
        PLIST_ENTRY loadedModuleList = (PLIST_ENTRY)(GetSystemRoutineAddress(L"PsLoadedModuleList"));
        if (!loadedModuleList)
        {
            return NULL;
        }
        __try
        {
            for (PLIST_ENTRY link = loadedModuleList->Flink; link != loadedModuleList; link = link->Flink)
            {
                LDR_DATA_TABLE_ENTRY* entry = CONTAINING_RECORD(link, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
                if (_wcsicmp(name, entry->BaseDllName.Buffer) == 0)
                {
                    return entry->DllBase;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            return NULL;
        }
        return NULL;
    }

    void WriteProtectOff()
    {
        auto cr0 = __readcr0();
        cr0 &= 0xfffffffffffeffff;
        __writecr0(cr0);
        _disable();
    }

    void WriteProtectOn()
    {
        auto cr0 = __readcr0();
        cr0 |= 0x10000;
        _enable();
        __writecr0(cr0);
    }

    bool is_pg_protected(const char* image)
    {
        static CONST CHAR* images[] = { "win32kbase.sys", "tm.sys", "clfs.sys", "msrpc.sys", "ndis.sys", "ntfs.sys", "fltmgr.sys", "clipsp.sys", "cng.sys", "Wdf01000.sys", "WppRecorder.sys", "SleepStudyHelper.sys", "acpiex.sys", "ACPI.sys", "pci.sys", "tpm.sys", "intelpep.sys", "WindowsTrustedRT.sys", "pdc.sys", "CEA.sys", "partmgr.sys", "spaceport.sys", "volmgr.sys", "volmgrx.sys", "mountmgr.sys", "storahci.sys", "storport.sys", "hall.dll", "kd.dll", "ksecdd.sys", "stornvme.sys", "EhStorClass.sys", "fileinfo.sys", "Wof.sys", "Ntfs.sys", "ksecpkg.sys", "tcpip.sys", "fwpkclnt.sys", "wfplwfs.sys", "fvevol.sys", "volsnap.sys", "rdyboost.sys", "mup.sys" };
        for (INT i = 0; i < 43; ++i)
        {
            if (strstr(image, images[i]))
            {
                return TRUE;
            }
        }
        return FALSE;
    }

    PVOID GetDriverBase(LPCSTR module_name)
    {
        ULONG bytes{};
        NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, NULL, bytes, &bytes);
        if (!bytes)
        {
            return NULL;
        }
        PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, POOLTAG);
        if (modules)
        {
            status = ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes);
            if (!NT_SUCCESS(status))
            {
                ExFreePoolWithTag(modules, POOLTAG);
                return NULL;
            }
            PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
            PVOID module_base{}, module_size{};
            for (ULONG i = 0; i < modules->NumberOfModules; i++)
            {
                if (strcmp(reinterpret_cast<char*>(module[i].FullPathName + module[i].OffsetToFileName), module_name) == 0)
                {
                    module_base = module[i].ImageBase;
                    module_size = (PVOID)module[i].ImageSize;
                    break;
                }
            }
            ExFreePoolWithTag(modules, POOLTAG);
            return module_base;
        }
        return NULL;
    }

    PVOID IATHook(PVOID lpBaseAddress, CHAR* lpcStrImport, PVOID lpFuncAddress)
    {
        PIMAGE_DOS_HEADER dosHeaders = reinterpret_cast<PIMAGE_DOS_HEADER>(lpBaseAddress);
        PIMAGE_NT_HEADERS ntHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<DWORD_PTR>(lpBaseAddress) + dosHeaders->e_lfanew);
        IMAGE_DATA_DIRECTORY importsDirectory = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
        PIMAGE_IMPORT_DESCRIPTOR importDescriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(importsDirectory.VirtualAddress + (DWORD_PTR)lpBaseAddress);

        LPCSTR libraryName = NULL;
        PVOID result = NULL;
        PIMAGE_IMPORT_BY_NAME functionName = NULL;

        if (!importDescriptor)
            return NULL;

        while (importDescriptor->Name != NULL)
        {
            libraryName = (LPCSTR)importDescriptor->Name + (DWORD_PTR)lpBaseAddress;
            if (GetDriverBase(libraryName))
            {
                PIMAGE_THUNK_DATA originalFirstThunk = NULL, firstThunk = NULL;
                originalFirstThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)lpBaseAddress + importDescriptor->OriginalFirstThunk);
                firstThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)lpBaseAddress + importDescriptor->FirstThunk);
                while (originalFirstThunk->u1.AddressOfData != NULL)
                {
                    functionName = (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)lpBaseAddress + originalFirstThunk->u1.AddressOfData);
                    if (strcmp(functionName->Name, lpcStrImport) == 0)
                    {
                        result = reinterpret_cast<PVOID>(firstThunk->u1.Function);
                        WriteProtectOff();
                        firstThunk->u1.Function = reinterpret_cast<ULONG64>(lpFuncAddress);
                        WriteProtectOn();
                        return result;
                    }
                    ++originalFirstThunk;
                    ++firstThunk;
                }
            }
            importDescriptor++;
        }
        return NULL;
    }

    static BOOLEAN is_retop(_In_ BYTE op)
    {
        return op == 0xC2 || op == 0xC3 || op == 0xCA || op == 0xCB;      
    }

    static QWORD find_codecave(_In_ VOID* module, _In_ INT length)
    {
        IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*)module;
        IMAGE_NT_HEADERS* nt_headers = (IMAGE_NT_HEADERS*)((BYTE*)dos_header + dos_header->e_lfanew);
        QWORD start = 0, size = 0;

        QWORD header_offset = (QWORD)IMAGE_FIRST_SECTION(nt_headers);
        for (INT x = 0; x < nt_headers->FileHeader.NumberOfSections; ++x)
        {
            IMAGE_SECTION_HEADER* header = (IMAGE_SECTION_HEADER*)header_offset;

            if (strcmp((CHAR*)header->Name, ".text") == 0)
            {
                start = (QWORD)module + header->PointerToRawData;
                size = header->SizeOfRawData;
                break;
            }
            header_offset += sizeof(IMAGE_SECTION_HEADER);
        }
        QWORD match = 0;
        INT curlength = 0;
        BOOLEAN ret = FALSE;

        for (QWORD cur = start; cur < start + size; ++cur)
        {
            if (!ret && is_retop(*(BYTE*)cur))
            {
                ret = TRUE;
            }
            else if (ret && *(BYTE*)cur == 0xCC)
            {
                if (!match) match = cur;
                if (++curlength == length) return match;
            }
            else
            {
                match = curlength = 0;
                ret = FALSE;
            }
        }
        return 0;
    }

    static BOOLEAN remap_page(_In_ VOID* address, _In_ BYTE* assembly, _In_ ULONG length, _In_ BOOLEAN restore)
    {
        MDL* mdl = IoAllocateMdl(address, length, FALSE, FALSE, 0);
        if (!mdl)
        {
            DbgPrint("[-] Failed allocating MDL!\n");
            return FALSE;
        }

        MmProbeAndLockPages(mdl, KernelMode, IoReadAccess);

        VOID* map_address = MmMapLockedPagesSpecifyCache(mdl, KernelMode, MmNonCached, 0, FALSE, NormalPagePriority);
        if (!map_address)
        {
            DbgPrint("[-] Failed mapping the page!\n");
            MmUnlockPages(mdl);
            IoFreeMdl(mdl);
            return FALSE;
        }

        NTSTATUS status = MmProtectMdlSystemAddress(mdl, PAGE_EXECUTE_READWRITE);
        if (status)
        {
            DbgPrint("[-] Failed MmProtectMdlSystemAddress with status: 0x%lX\n", status);
            MmUnmapLockedPages(map_address, mdl);
            MmUnlockPages(mdl);
            IoFreeMdl(mdl);
            return FALSE;
        }

        RtlCopyMemory(map_address, assembly, length);

        if (restore)
        {
            status = MmProtectMdlSystemAddress(mdl, PAGE_READONLY);
            if (status)
            {
                DbgPrint("[-] Failed second MmProtectMdlSystemAddress with status: 0x%lX\n", status);
                MmUnmapLockedPages(map_address, mdl);
                MmUnlockPages(mdl);
                IoFreeMdl(mdl);
                return FALSE;
            }
        }

        MmUnmapLockedPages(map_address, mdl);
        MmUnlockPages(mdl);
        IoFreeMdl(mdl);

        return TRUE;
    }

    static BOOLEAN patch_codecave_detour(_In_ QWORD address, _In_ QWORD target)
    {
        BYTE assembly[16] = 
        {
            0x50,                                                        // push rax
            0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // mov rax, TARGET
            0x48, 0x87, 0x04, 0x24,                                      // xchg QWORD PTR[rsp], rax
            0xC3                                                         // retn
        };
        *(QWORD*)(assembly + 3) = target;
        return remap_page((VOID*)address, assembly, 16, FALSE);
    }

    DWORD FindTextSection(char* module, DWORD* size)
    {
        PIMAGE_NT_HEADERS headers = (PIMAGE_NT_HEADERS)(module + ((PIMAGE_DOS_HEADER)module)->e_lfanew);
        PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);

        for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i)
        {
            PIMAGE_SECTION_HEADER section = &sections[i];
            if (memcmp(section->Name, ".text", 5) == 0)
            {
                *size = section->Misc.VirtualSize;
                return section->VirtualAddress;
            }
        }
        return 0;
    }

    PRTL_PROCESS_MODULES GetModuleList()
    {
        ULONG length = 0;
        ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &length);
        length += (10 * 1024);

        PRTL_PROCESS_MODULES module_list = (PRTL_PROCESS_MODULES)ExAllocatePool(PagedPool, length);
        ZwQuerySystemInformation(SystemModuleInformation, module_list, length, &length);

        if (!module_list)
        {
            DbgPrintEx(0, 0, "[-] Module List Is Empty\n");
            return 0;
        }
        return module_list;
    }

    VOID Sleep(LONGLONG milliseconds)
    {
        LARGE_INTEGER timeout;
        timeout.QuadPart = RELATIVE(MILLISECONDS(milliseconds));
        KeDelayExecutionThread(KernelMode, FALSE, &timeout);
    }

    BOOLEAN WriteToReadOnlyMemory(IN VOID* destination, IN VOID* source, IN ULONG size)
    {
        PMDL mdl = IoAllocateMdl(destination, size, FALSE, FALSE, 0);
        if (!mdl)
            return FALSE;

        MmProbeAndLockPages(mdl, KernelMode, IoReadAccess);

        PVOID map_address = MmMapLockedPagesSpecifyCache(mdl, KernelMode, MmNonCached, 0, FALSE, NormalPagePriority);
        if (!map_address)
        {
            MmUnlockPages(mdl);
            IoFreeMdl(mdl);
            return FALSE;
        }

        NTSTATUS status = MmProtectMdlSystemAddress(mdl, PAGE_EXECUTE_READWRITE);
        if (!NT_SUCCESS(status))
        {
            MmUnmapLockedPages(map_address, mdl);
            MmUnlockPages(mdl);
            IoFreeMdl(mdl);
            return FALSE;
        }

        RtlCopyMemory(map_address, source, size);

        MmUnmapLockedPages(map_address, mdl);
        MmUnlockPages(mdl);
        IoFreeMdl(mdl);
        return TRUE;
    }

    VOID ToLower(IN CHAR* in, OUT CHAR* out)
    {
        INT i = -1;

        while (in[++i] != '\x00')
        {
            out[i] = (CHAR)tolower(in[i]);
        }
    }
}
```

`BEEmulator/Source Files/Main.cpp`:

```cpp
#include "Includes.hpp"

static uint64_t _be_pre_ob_callback_cave = 0;
static POB_PRE_OPERATION_CALLBACK _be_original_ob_callback = 0;

OB_PREOP_CALLBACK_STATUS HookCallback(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation)
{
	auto result = _be_original_ob_callback(RegistrationContext, OperationInformation);
	OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess;
	return result;
}

PVOID Hook_ExAllocatePool(POOL_TYPE PoolType, SIZE_T NumberOfBytes)
{
	if (PoolType == 0x200 && NumberOfBytes == 0x1000 || PoolType == 0x200 && NumberOfBytes == 0x90)
	{
		return 0;
	}
	return ExAllocatePool(PoolType, NumberOfBytes);
}

NTSTATUS Hook_ObRegisterCallbacks(POB_CALLBACK_REGISTRATION callback_registration, PVOID* registration_handle)
{
	DbgPrintEx(0, 0, "[+] BE Called ObRegisterCallbacks\n");

	_be_original_ob_callback = callback_registration->OperationRegistration->PreOperation;
	PRTL_PROCESS_MODULES modules = Utils::GetModuleList();
	PVOID module_base{};
	PVOID module_size{};

	for (ULONG i = 0; i < modules->NumberOfModules; i++)
	{
		PRTL_PROCESS_MODULE_INFORMATION module = &modules->Modules[i];

		if (!strstr((const char*)module->FullPathName, "iorate"))
		{
			continue;
		}

		_be_pre_ob_callback_cave = Utils::find_codecave(module->ImageBase, 16);

		DbgPrintEx(0, 0, "[+] Code Cave Address 0x%p\n", _be_pre_ob_callback_cave);

		if (_be_pre_ob_callback_cave != 0)
		{
			DbgPrintEx(0, 0, "[+] Code Cave Inside %s\n", module->FullPathName);

			if (!Utils::patch_codecave_detour(_be_pre_ob_callback_cave, (uint64_t)&HookCallback))
			{
				DbgPrintEx(0, 0, "[!] Failed To Patch Code Cave\n");
				return STATUS_UNSUCCESSFUL;
			}
			callback_registration->OperationRegistration->PreOperation = (POB_PRE_OPERATION_CALLBACK)_be_pre_ob_callback_cave;
			DbgPrintEx(0, 0, "[+] Patched ObRegisterCallbacks\n");
			ExFreePoolWithTag(modules, 0);
			break;
		}
	}
	return ObRegisterCallbacks(callback_registration, registration_handle);
}

PVOID Hook_MmGetSystemRoutineAddress(PUNICODE_STRING SystemRoutineName)
{
	if (wcsstr(SystemRoutineName->Buffer, L"ObRegisterCallbacks"))
	{
		return &Hook_ObRegisterCallbacks;
	}
	else if (wcsstr(SystemRoutineName->Buffer, L"ExAllocatePool"))
	{
		return &Hook_ExAllocatePool;
	}
	return MmGetSystemRoutineAddress(SystemRoutineName);
}

NTSTATUS DriverEntry(uint64_t mdl_ptr, uint64_t image_size)
{
	/* No Point Using LoadImageNotifyRoutine */
	PVOID be_module = NULL;
	while (true)
	{
		be_module = Utils::GetSystemModuleBase(L"BEDaisy.sys");
		if (be_module != NULL) break;
	}
	if (be_module)
	{
		DbgPrintEx(0, 0, "[+] Found BEDaisy.sys -> %p\n", be_module);
		Utils::IATHook(be_module, "MmGetSystemRoutineAddress", &Hook_MmGetSystemRoutineAddress);
	}
	return STATUS_SUCCESS;
}
```

`README.md`:

```md
# Pink-Eye

Features:
- Hooking ObRegisterCallbacks And Registering Our Own Callback Within A Valid Module Via A Code Cave
- Patching IAT Integrity Check Using ExAllocatePool To Fail The Execution Of The Function

Credits:
- https://www.unknowncheats.me/forum/c-and-c-/415662-kernel-code-cave-poc.html
- https://www.unknowncheats.me/forum/anti-cheat-bypass/148364-obregistercallbacks-countermeasures.html
- BadEye (Xeroxz)
- Aterror2be & Gotcha


![POC](https://user-images.githubusercontent.com/80023326/224959092-f7bc17ec-8381-4ab8-b414-b940620584a5.jpg)

```