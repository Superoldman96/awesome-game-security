Project Path: arc_gmh5225_VX-It_8rcb_lns

Source Tree:

```txt
arc_gmh5225_VX-It_8rcb_lns
├── README.md
├── UnrealEngine
│   ├── FNamePool
│   │   ├── FNamePool.cpp
│   │   └── FNamePool.h
│   ├── FUObjectArray
│   │   ├── FUObjectArray.cpp
│   │   └── FUObjectArray.h
│   ├── UE.cpp
│   ├── UE.h
│   └── UObject
│       ├── CoreUObject.h
│       └── UObjectBaseUtility.cpp
├── UnrealIt.cpp
├── UnrealIt.vcxproj
├── UnrealIt.vcxproj.filters
├── UnrealIt.vcxproj.user
└── Utilities
    ├── Log.h
    ├── PatternScanner.h
    └── Types.h

```

`README.md`:

```md
# VX-It
Iterate And Decrypt FUObjectArray->ObjObjects &amp; FNamePool->Entries | Veiled Experts

```

`UnrealEngine/FNamePool/FNamePool.cpp`:

```cpp
#include <UnrealEngine/UE.h>

void FNameEntry::GetAnsiName(ANSICHAR(&Out)[NAME_SIZE]) const
{
	if (!IsWide()) {
		CopyUnterminatedName(Out);
		Out[Header.Len] = '\0';
	}
	else {
		printf("[FAIL] GetAnsiName was called while the name is wide.\n");
	}
}

void FNameEntry::GetWideName(WIDECHAR(&Out)[NAME_SIZE]) const
{
	if (IsWide()) {
		CopyUnterminatedName(Out);
		Out[Header.Len] = '\0';
	}
	else {
		printf("[FAIL] GetWideName was called while the name is not wide.\n");
	}
}

void DecryptWide(FNameEntry* Entry, wchar_t* OutName)
{
	wchar_t* v2; // rdi
	int NameLength; // ebx
	__int64 result; // rax
	int v6; // r8d
	unsigned int v7; // ecx
	char v8; // dl

	v2 = OutName;

	NameLength = Entry->GetNameLength();

	int32 CachedLength = NameLength;

	memcpy(OutName, (void*)(reinterpret_cast<uint64>(Entry) + Entry->GetDataOffset()), NameLength * 2);

	static uint64 BaseAddress = 0;
	if (!BaseAddress) BaseAddress = reinterpret_cast<uint64>(GetModuleHandleA(NULL));

	unsigned __int8 Key = *(unsigned __int8*)(BaseAddress + 0x62706D0);

	if (NameLength)
	{
		do
		{
			*v2++ ^= Key;
			--NameLength;
		} while (NameLength);
	}

	OutName[CachedLength] = '\0';
}


void DecryptNonWide(FNameEntry* Entry, char* OutName)
{
	char* v2; // rdi
	int NameLength; // ebx
	__int64 result; // rax
	int v6; // r8d
	unsigned int v7; // ecx
	char v8; // dl

	v2 = OutName;

	NameLength = Entry->GetNameLength();

	int32 CachedLength = NameLength;

	memcpy(OutName, (void*)(reinterpret_cast<uint64>(Entry) + Entry->GetDataOffset()), NameLength);

	static uint64 BaseAddress = 0;
	if (!BaseAddress) BaseAddress = reinterpret_cast<uint64>(GetModuleHandleA(NULL));

	unsigned __int8 Key = *(unsigned __int8*)(BaseAddress + 0x62706D0);

	if (NameLength)
	{
		do
		{
			*v2++ ^= Key;
			--NameLength;
		} while (NameLength);
	}

	OutName[CachedLength] = '\0';
}


std::string FNameEntry::String()
{
	if (IsWide()) 
	{
		wchar_t OutName[1024];
		DecryptWide(this, OutName);
		std::wstring Wide(OutName, Header.Len);
		return std::string(Wide.begin(), Wide.end());
	}

	char OutName[1024];
	DecryptNonWide(this, OutName);

	return std::string(OutName, Header.Len);
}

std::string FName::GetName()
{
	FNameEntry Entry = NamePoolData->Entries.Resolve(GetDisplayIndex());

	std::string Name = Entry.String();

	if (Number > 0)
	{
		/** Not the first instance of this name so add instance number. */
		Name += '_' + std::to_string(Number);
	}

	/** Find the last '/' and start the string from there + 1 so the name doesnt contain extra length and info and look ugly. */
	std::size_t Pos = Name.rfind('/');

	if (Pos != std::string::npos) Name = Name.substr(Pos + 1);

	return Name;
}

const FNameEntry* FName::GetDisplayNameEntry() const
{
	return &NamePoolData->Entries.Resolve(GetDisplayIndex());
}

int32 FNameEntry::GetSize(int32 Length, bool bIsPureAnsi)
{
	int32 Bytes = GetDataOffset() + Length * (bIsPureAnsi ? sizeof(ANSICHAR) : sizeof(WIDECHAR));
	return Align(Bytes, alignof(FNameEntry));
}

void FNameEntryAllocator::LogBlock(uint8* It, uint32 BlockSize, Logger& LOG)
{
	uint8* End = It + BlockSize - FNameEntry::GetDataOffset();
	while (It < End)
	{
		FNameEntry* Entry = reinterpret_cast<FNameEntry*>(It);
		if (uint32 Len = Entry->GetEntryHeader().Len)
		{
			LOG.LogToFile(Entry->String());
			It += FNameEntry::GetSize(Len, !Entry->IsWide());
		}
		else
		{
			break;
		}
	}
}

void FNameEntryAllocator::Log()
{
	Logger LOG("\\FNamePool_Entries_Log.txt");

	printf("[INFO] Logging FNamePool->Entries...\n\n");

	for (uint32 BlockIdx = 0; BlockIdx < CurrentBlock; ++BlockIdx)
	{
		LogBlock(Blocks[BlockIdx], BlockSizeBytes, LOG);
	}

	LogBlock(Blocks[CurrentBlock], CurrentByteCursor, LOG);

	printf("[SUCCESS] FNamePool->Entries log has completed.\n\n");

	LOG.CloseLog();
}
```

`UnrealEngine/FNamePool/FNamePool.h`:

```h
#pragma once

template <typename T>
FORCEINLINE constexpr T Align(T Val, uint64 Alignment)
{
	return (T)(((uint64)Val + Alignment - 1) & ~(Alignment - 1));
}


static constexpr uint32 FNameMaxBlockBits = 13;
static constexpr uint32 FNameBlockOffsetBits = 16;
static constexpr uint32 FNameMaxBlocks = 1 << FNameMaxBlockBits;
static constexpr uint32 FNameBlockOffsets = 1 << FNameBlockOffsetBits;


/** Implementation detail exposed for debug visualizers */
struct FNameEntryHeader
{
	uint16 bIsWide : 1;
#ifdef WITH_CASE_PRESERVING_NAME
	uint16 Len : 15;
#else
	static constexpr uint32 ProbeHashBits = 5;
	uint16 LowercaseProbeHash : ProbeHashBits;
	uint16 Len : 10;
#endif

	uint16 Padding; // Unknown Data In Header (VX)
};


/** A global deduplicated name stored in the global name table. */
struct FNameEntry {
	enum { NAME_SIZE = 1024 };
public:

	FORCEINLINE bool IsWide() const
	{
		return Header.bIsWide;
	}

	FORCEINLINE int32 GetNameLength() const
	{
		return Header.Len;
	}

	FORCEINLINE FNameEntryHeader GetEntryHeader() const
	{
		return Header;
	}

	FORCEINLINE void CopyUnterminatedName(ANSICHAR* Out) const
	{
		memcpy(Out, AnsiName, sizeof(ANSICHAR) * Header.Len);
	}

	FORCEINLINE void CopyUnterminatedName(WIDECHAR* Out) const
	{
		memcpy(Out, WideName, sizeof(WIDECHAR) * Header.Len);
	}

	FORCEINLINE static int32 GetDataOffset()
	{
		return offsetof(FNameEntry, AnsiName);
	}

	static int32 GetSize(int32 Length, bool bIsPureAnsi);

	void GetAnsiName(ANSICHAR(&Out)[NAME_SIZE]) const;

	void GetWideName(WIDECHAR(&Out)[NAME_SIZE]) const;

	std::string String();

private:

#ifdef WITH_CASE_PRESERVING_NAME
	FNameEntryId ComparisonId;
#endif

	FNameEntryHeader Header;

	union
	{
		ANSICHAR	AnsiName[NAME_SIZE];
		WIDECHAR	WideName[NAME_SIZE];
	};

};


/** Opaque id to a deduplicated name */
struct FNameEntryId
{
	FNameEntryId() : Value(0) {}

	FNameEntryId(uint32 Id) : Value(Id) {}

	explicit operator bool() const { return Value != 0; }

	FORCEINLINE static FNameEntryId FromUnstableInt(uint32 UnstableInt)
	{
		FNameEntryId Id;
		Id.Value = UnstableInt;
		return Id;
	}

	FORCEINLINE uint32 ToUnstableInt() const {
		return Value;
	}

	uint32 Value;
};


/** An unpacked FNameEntryId */
struct FNameEntryHandle
{
	uint32 Block = 0;
	uint32 Offset = 0;

	FNameEntryHandle(uint32 InBlock, uint32 InOffset)
		: Block(InBlock)
		, Offset(InOffset)
	{}

	FNameEntryHandle(FNameEntryId Id)
		: Block(Id.ToUnstableInt() >> FNameBlockOffsetBits)
		, Offset(Id.ToUnstableInt()& (FNameBlockOffsets - 1))
	{}

	operator FNameEntryId() const
	{
		return FNameEntryId::FromUnstableInt(Block << FNameBlockOffsetBits | Offset);
	}

	static uint32 GetTypeHash(FNameEntryHandle Handle)
	{
		return (Handle.Block << (32 - FNameMaxBlockBits)) + Handle.Block
			+ (Handle.Offset << FNameBlockOffsetBits) + Handle.Offset
			+ (Handle.Offset >> 4);
	}

	uint32 GetTypeHash(FNameEntryId Id)
	{
		return GetTypeHash(FNameEntryHandle(Id));
	}

	explicit operator bool() const { return Block | Offset; }
};


/** Paged FNameEntry allocator */
class FNameEntryAllocator
{
public:
	enum { Stride = alignof(FNameEntry) };
	enum { BlockSizeBytes = Stride * FNameBlockOffsets };

	void* FRWLock;
	uint32 CurrentBlock = 0;
	uint32 CurrentByteCursor = 0;
	uint8* Blocks[FNameMaxBlocks] = {};

	FORCEINLINE uint32 NumBlocks() const
	{
		return CurrentBlock + 1;
	}

	FORCEINLINE FNameEntry& Resolve(FNameEntryHandle Handle) const
	{
		if (Handle.Offset < 0 && Handle.Block > NumBlocks() && Handle.Offset * Stride < FNameBlockOffsets) {
			printf("[FAIL] Invalid FNameEntryHandle Passed To FNameEntryAllocator::Resolve.\n");
			return *reinterpret_cast<FNameEntry*>(Blocks[0] + Stride * 0);
		}

		return *reinterpret_cast<FNameEntry*>(Blocks[Handle.Block] + Stride * Handle.Offset);
	}

	void LogBlock(uint8* It, uint32 BlockSize, Logger& LOG);

	void Log();
};


class FNamePool
{
public:
	FNameEntryAllocator Entries;

	/*
	* Not interested in other members.
	* Complete from /Engine/Source/Runtime/Core/Private/UObject/UnrealNames.cpp if neccesary.
	*/
};


/**
 * Public name, available to the world.  Names are stored as a combination of
 * an index into a table of unique strings and an instance number.
 * Names are case-insensitive, but case-preserving (when WITH_CASE_PRESERVING_NAME is 1)
 */
struct FName {

	/** Index into the Names array (used to find String portion of the string/number pair used for comparison) */
	FNameEntryId	ComparisonIndex;

#ifdef WITH_CASE_PRESERVING_NAME
	/** Index into the Names array (used to find String portion of the string/number pair used for display) */
	FNameEntryId	DisplayIndex;
#endif

	/** Number portion of the string/number pair (stored internally as 1 more than actual, so zero'd memory will be the default, no-instance case) */
	uint32			Number;

	FORCEINLINE FNameEntryId GetComparisonIndex() const
	{
		return ComparisonIndex;
	}

	FORCEINLINE FNameEntryId GetDisplayIndex() const
	{
#ifdef WITH_CASE_PRESERVING_NAME
		return DisplayIndex;
#else
		return ComparisonIndex;
#endif
	}

	FORCEINLINE int32 GetNumber() const
	{
		return Number;
	}

#ifndef WITH_CASE_PRESERVING_NAME
	FORCEINLINE uint64 ToComparableInt() const
	{
		static_assert(sizeof(*this) == sizeof(uint64), "");
		alignas(uint64) FName AlignedCopy = *this;
		return reinterpret_cast<uint64&>(AlignedCopy);
	}
#endif

	FORCEINLINE bool operator==(FName Other) const
	{
#ifndef WITH_CASE_PRESERVING_NAME
		return ToComparableInt() == Other.ToComparableInt();
#else
		return (ComparisonIndex == Other.ComparisonIndex) & (GetNumber() == Other.GetNumber());
#endif
	}

	FORCEINLINE bool operator!=(FName Other) const
	{
		return !(*this == Other);
	}

	FName() :
		ComparisonIndex(FNameEntryId()),
		Number(0)
	{ }

	FName(int32 i, int32 n = 0) :
		ComparisonIndex(FNameEntryId(i)),
		Number(n)
	{ }
	
	// To do: Find FName from name

	const FNameEntry* GetDisplayNameEntry() const;

	std::string GetName();
};
```

`UnrealEngine/FUObjectArray/FUObjectArray.cpp`:

```cpp
#include <UnrealEngine/UE.h>

template<typename T>
T FChunkedFixedUObjectArray::FindUObject(const char* NameToFind)
{
	for (int CurrentElement = 0; CurrentElement < NumElements; CurrentElement++)
	{
		FUObjectItem* ObjectItem = GetObjectPtr(CurrentElement);

		if (ObjectItem && ObjectItem->Object->GetFullName() == NameToFind) {
			printf("[SUCCESS] Object with the name \"%s\" was the %i object found.\n\n", NameToFind, CurrentElement);

			return static_cast<T>(ObjectItem->Object);
		}
	}

	printf("[FAIL] All %i objects were checked for the name %s with no result.\n\n", NumElements, NameToFind);

	return NULL;
}

void FChunkedFixedUObjectArray::Log()
{
	Logger LOG("\\FUObjectArray_ObjObjects_Log.txt");

	printf("[INFO] Logging FUObjectArray->ObjObjects...\n\n");

	for (int CurrentElement = 0; CurrentElement < NumElements; CurrentElement++)
	{
		FUObjectItem* ObjectItem = GetObjectPtr(CurrentElement);

		UObject* Object = ObjectItem->Object;

		LOG.LogToFile(Object->GetFullName());
	}

	printf("[SUCCESS] FUObjectArray->ObjObjects log has completed.\n\n");

	LOG.CloseLog();
}

```

`UnrealEngine/FUObjectArray/FUObjectArray.h`:

```h
#pragma once

enum EInternalObjectFlags
{
	None = 0,
	ReachableInCluster = 1 << 23,
	ClusterRoot = 1 << 24,
	Native = 1 << 25,
	Async = 1 << 26,
	AsyncLoading = 1 << 27,
	Unreachable = 1 << 28,
	PendingKill = 1 << 29,
	RootSet = 1 << 30,
	GarbageCollectionKeepFlags = Native | Async | AsyncLoading,
	AllFlags = ReachableInCluster | ClusterRoot | Native | Async | AsyncLoading | Unreachable | PendingKill | RootSet,
};


struct FUObjectItem
{
	// Pointer to the allocated object
	class UObject* Object;

	// Internal flags
	int32 Flags;

	// UObject Owner Cluster Index
	int32 ClusterRootIndex;

	// Weak Object Pointer Serial number associated with the object
	int32 SerialNumber;
};


class FChunkedFixedUObjectArray
{
	enum
	{
		NumElementsPerChunk = 64 * 1024,
	};

	/** Master table to chunks of pointers **/
	FUObjectItem** Objects;

	/** If requested, a contiguous memory where all objects are allocated **/
	FUObjectItem* PreAllocatedObjects;

	/** Maximum number of elements **/
	int32 MaxElements;

	/** Number of elements we currently have **/
	int32 NumElements;

	/** Maximum number of chunks **/
	int32 MaxChunks;

	/** Number of chunks we currently have **/
	int32 NumChunks;

public:

	FORCEINLINE int32 Num() const
	{
		return NumElements;
	}

	FORCEINLINE int32 Capacity() const
	{
		return MaxElements;
	}

	FORCEINLINE bool IsValidIndex(int32 Index) const
	{
		return Index < Num() && Index >= 0;
	}

	FORCEINLINE FUObjectItem const* GetObjectPtr(int32 Index) const
	{
		const int32 ChunkIndex = Index / NumElementsPerChunk;
		const int32 WithinChunkIndex = Index % NumElementsPerChunk;

		if (!IsValidIndex(Index)) {
			printf("[FAIL] IsValidIndex Returned False For Index -> (%d)\n", Index);
			return NULL;
		}

		if (ChunkIndex >= NumChunks) {
			printf("[FAIL] ChunkIndex (%d) >= NumChunks (%d)\n", ChunkIndex, NumChunks);
			return NULL;
		}

		if (Index > MaxElements) {
			printf("[FAIL] Index (%d) > MaxElements (%d)\n", Index, MaxElements);
			return NULL;
		}

		FUObjectItem* Chunk = Objects[ChunkIndex];
		if (!Chunk) return NULL;

		return Chunk + WithinChunkIndex;
	}

	FORCEINLINE FUObjectItem* GetObjectPtr(int32 Index)
	{
		const int32 ChunkIndex = Index / NumElementsPerChunk;
		const int32 WithinChunkIndex = Index % NumElementsPerChunk;
		if (!IsValidIndex(Index)) {
			printf("[FAIL] IsValidIndex Returned False For Index -> (%d)\n", Index);
			return NULL;
		}

		if (ChunkIndex > NumChunks) {
			printf("[FAIL] ChunkIndex (%d) > NumChunks (%d)\n", ChunkIndex, NumChunks);
			return NULL;
		}

		if (Index > MaxElements) {
			printf("[FAIL] Index (%d) > MaxElements (%d)\n", Index, MaxElements);
			return NULL;
		}

		FUObjectItem* Chunk = Objects[ChunkIndex];
		if (!Chunk) return NULL;

		return Chunk + WithinChunkIndex;
	}

	FORCEINLINE FUObjectItem const& operator[](int32 Index) const
	{
		FUObjectItem const* ItemPtr = GetObjectPtr(Index);
		if (ItemPtr) return *ItemPtr;
	}

	FORCEINLINE FUObjectItem& operator[](int32 Index)
	{
		FUObjectItem* ItemPtr = GetObjectPtr(Index);
		if (ItemPtr) return *ItemPtr;
	}

	int64 GetAllocatedSize() const
	{
		return MaxChunks * sizeof(FUObjectItem*) + NumChunks * NumElementsPerChunk * sizeof(FUObjectItem);
	}

	template<typename T> T FindUObject(const char* NameToFind);

	void Log();
};


class FUObjectArray
{
public:
	typedef FChunkedFixedUObjectArray TUObjectArray;

	/** First index into objects array taken into account for GC.							*/
	int32 ObjFirstGCIndex;

	/** Index pointing to last object created in range disregarded for GC.					*/
	int32 ObjLastNonGCIndex;

	/** Maximum number of objects in the disregard for GC Pool */
	int32 MaxObjectsNotConsideredByGC;

	/** If true this is the intial load and we should load objects int the disregarded for GC range.	*/
	bool OpenForDisregardForGC;

	/** Array of all live objects.											*/
	TUObjectArray ObjObjects;

	FORCEINLINE FUObjectItem* IndexToObject(int32 Index)
	{
		if (Index < ObjObjects.Num())
		{
			return const_cast<FUObjectItem*>(&ObjObjects[Index]);
		}
		return nullptr;
	}

	/*
	* Not interested in other members.
	* Complete from here /Engine/Source/Runtime/CoreUObject/Public/UObject/UObjectArray.h
	*/
};

```

`UnrealEngine/UE.cpp`:

```cpp
#pragma once
#include <UnrealEngine/UE.h>

FNamePool* NamePoolData = nullptr;
FUObjectArray* GUObjectArray = nullptr;
void* EngineVersionString = nullptr;

std::string GetEngineVersion() {
	if (EngineVersionString) {
		WIDECHAR Copy[64];
		memcpy(Copy, EngineVersionString, 64);
		std::wstring WideString(Copy, std::wcslen(Copy));
		return std::string(WideString.begin(), WideString.end());
	}
	else {
		return std::string("Unknown Engine Version");
	}
}

bool Initalize(HMODULE GameModule)
{
	const uint64 BaseAddress = reinterpret_cast<uint64>(GameModule);

	const IMAGE_DOS_HEADER* DOSHeader = reinterpret_cast<IMAGE_DOS_HEADER*>(GameModule);
	const IMAGE_NT_HEADERS* NtHeaders = reinterpret_cast<IMAGE_NT_HEADERS*>(reinterpret_cast<long long>(GameModule) + DOSHeader->e_lfanew);
	
	const DWORD SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;


	// Search for "++UE", you will likely end up with a wide string "++UEx+Release-x.xx"
	EngineVersionString = PatternScan<void*>("2B ? 2B ? 55 ? 45 ?", BaseAddress, SizeOfImage); 
	if (!EngineVersionString) {
		printf("[FAIL] Engine version was not found by string, you can proceed anyways.\n");
	}

	/*
		Both contain a string in the image to assist you in finding these addresses.
		GUObjectArray https://imgur.com/7r4tOBc
		NamePoolData https://imgur.com/WJo0u6a
	*/
		
	GUObjectArray = PatternScan<FUObjectArray*>("48 8D 0D ? ? ? ? E8 ? ? ? ? 48 8D 8D ? ? ? ? E8 ? ? ? ? 48 8D 8D", BaseAddress, SizeOfImage, true);
	if (!GUObjectArray) {
		printf("[FAIL] GUObjectArray not found.\n");
		return false;
	}

	
	NamePoolData = PatternScan<FNamePool*>("48 8D 0D ? ? ? ? FF 15 ? ? ? ? 48 8B 7C 24 ? B8 ? ? ? ? 4C 3B E8 0F 85 ? ? ? ? 49 63 C4 4C 8D 3C C5 ? ? ? ? 48", BaseAddress, SizeOfImage, true);
	if (!NamePoolData) {
		printf("[FAIL] NamePoolData not found.\n");
		return false;
	}


	WIDECHAR GameFileDir[MAX_PATH];
	GetModuleFileNameW(NULL, GameFileDir, MAX_PATH);

	printf("[INFO] Game Directory -> %ws\n\n", GameFileDir);

	printf("[INFO] Game Module Base Address -> %llX \n\n", BaseAddress);

	printf("[INFO] Size Of Game Module -> 0x%X\n\n", SizeOfImage);

	printf("[INFO] Engine Version: %s\n\n", GetEngineVersion().c_str());

	printf("[INFO] FUObjectArray* GUObjectArray found -> Base Address + 0x%llX\n\n", reinterpret_cast<uint64>(GUObjectArray) - BaseAddress);

	printf("[INFO] FNamePool* NamePoolData found -> Base Address + 0x%llX\n\n", reinterpret_cast<uint64>(NamePoolData) - BaseAddress);

	return true;
}

```

`UnrealEngine/UE.h`:

```h
#pragma once

#include <Windows.h>
#include <Utilities/Types.h>
#include <Utilities/Log.h>

// #define WITH_CASE_PRESERVING_NAME

#include <UnrealEngine/FNamePool/FNamePool.h>
#include <UnrealEngine/UObject/CoreUObject.h>
#include <UnrealEngine/FUObjectArray/FUObjectArray.h>
#include <Utilities/PatternScanner.h> 

extern FNamePool* NamePoolData;
extern FUObjectArray* GUObjectArray;
extern void* EngineVersionString;

bool Initalize(HMODULE GameModule);


```

`UnrealEngine/UObject/CoreUObject.h`:

```h
class UObject;
class UClass;
struct FName;

#pragma warning (push)
#pragma warning (disable:4309)
enum EObjectFlags
{
	// Do not add new flags unless they truly belong here. There are alternatives.
	// if you change any the bit of any of the RF_Load flags, then you will need legacy serialization
	RF_NoFlags = 0x00000000,	///< No flags, used to avoid a cast

	// This first group of flags mostly has to do with what kind of object it is. Other than transient, these are the persistent object flags.
	// The garbage collector also tends to look at these.
	RF_Public = 0x00000001,	///< Object is visible outside its package.
	RF_Standalone = 0x00000002,	///< Keep object around for editing even if unreferenced.
	RF_MarkAsNative = 0x00000004,	///< Object (UField) will be marked as native on construction (DO NOT USE THIS FLAG in HasAnyFlags() etc)
	RF_Transactional = 0x00000008,	///< Object is transactional.
	RF_ClassDefaultObject = 0x00000010,	///< This object is its class's default object
	RF_ArchetypeObject = 0x00000020,	///< This object is a template for another object - treat like a class default object
	RF_Transient = 0x00000040,	///< Don't save object.

	// This group of flags is primarily concerned with garbage collection.
	RF_MarkAsRootSet = 0x00000080,	///< Object will be marked as root set on construction and not be garbage collected, even if unreferenced (DO NOT USE THIS FLAG in HasAnyFlags() etc)
	RF_TagGarbageTemp = 0x00000100,	///< This is a temp user flag for various utilities that need to use the garbage collector. The garbage collector itself does not interpret it.

	// The group of flags tracks the stages of the lifetime of a uobject
	RF_NeedInitialization = 0x00000200,	///< This object has not completed its initialization process. Cleared when ~FObjectInitializer completes
	RF_NeedLoad = 0x00000400,	///< During load, indicates object needs loading.
	RF_KeepForCooker = 0x00000800,	///< Keep this object during garbage collection because it's still being used by the cooker
	RF_NeedPostLoad = 0x00001000,	///< Object needs to be postloaded.
	RF_NeedPostLoadSubobjects = 0x00002000,	///< During load, indicates that the object still needs to instance subobjects and fixup serialized component references
	RF_NewerVersionExists = 0x00004000,	///< Object has been consigned to oblivion due to its owner package being reloaded, and a newer version currently exists
	RF_BeginDestroyed = 0x00008000,	///< BeginDestroy has been called on the object.
	RF_FinishDestroyed = 0x00010000,	///< FinishDestroy has been called on the object.

	// Misc. Flags
	RF_BeingRegenerated = 0x00020000,	///< Flagged on UObjects that are used to create UClasses (e.g. Blueprints) while they are regenerating their UClass on load (See FLinkerLoad::CreateExport()), as well as UClass objects in the midst of being created
	RF_DefaultSubObject = 0x00040000,	///< Flagged on subobjects that are defaults
	RF_WasLoaded = 0x00080000,	///< Flagged on UObjects that were loaded
	RF_TextExportTransient = 0x00100000,	///< Do not export object to text form (e.g. copy/paste). Generally used for sub-objects that can be regenerated from data in their parent object.
	RF_LoadCompleted = 0x00200000,	///< Object has been completely serialized by linkerload at least once. DO NOT USE THIS FLAG, It should be replaced with RF_WasLoaded.
	RF_InheritableComponentTemplate = 0x00400000, ///< Archetype of the object can be in its super class
	RF_DuplicateTransient = 0x00800000,	///< Object should not be included in any type of duplication (copy/paste, binary duplication, etc.)
	RF_StrongRefOnFrame = 0x01000000,	///< References to this object from persistent function frame are handled as strong ones.
	RF_NonPIEDuplicateTransient = 0x02000000,	///< Object should not be included for duplication unless it's being duplicated for a PIE session
	RF_Dynamic = 0x04000000,	///< Field Only. Dynamic field - doesn't get constructed during static initialization, can be constructed multiple times
	RF_WillBeLoaded = 0x08000000,	///< This object was constructed during load and will be loaded shortly
	RF_HasExternalPackage = 0x10000000,	///< This object has an external package assigned and should look it up when getting the outermost package
};
#pragma warning (pop)

class UObjectBase
{
public:
	/** VTable pointer. */
	void**						VTable;

	/** Flags used to track and report various object states. */
	EObjectFlags				ObjectFlags;

	/** Index into GObjectArray. */
	int32						InternalIndex;

	/** Class the object belongs to. */
	UClass*						ClassPrivate;

	/** Name of this object. */
	FName						NamePrivate;

	/** Object this object resides in. */
	UObject*					OuterPrivate;
};

class UObjectBaseUtility : public UObjectBase
{
public:
	std::string GetName();
	std::string GetFullName();
};

class UObject : public UObjectBaseUtility
{
public:

};

class UField : public UObject
{
public:

};

class FStructBaseChain
{
private:

};

class FFieldVariant
{
public:

};

class FFieldClass
{
public:

};

class FField
{
public:

};

class FProperty : public FField
{
public:

};

class UStruct : public UField, private FStructBaseChain
{
public:

};

class UClass : public UStruct
{
public:

};
```

`UnrealEngine/UObject/UObjectBaseUtility.cpp`:

```cpp
#include <UnrealEngine/UE.h>

std::string UObjectBaseUtility::GetName()
{
	return NamePrivate.GetName();
}

/** Credit to KN4CK3R's UnrealEngineSDKGenerator for this format of GetFullName. */
std::string UObjectBaseUtility::GetFullName()
{

	std::string Name;

	if (ClassPrivate)
	{
		std::string Temp;
		for (UObject* CurrentOuter = OuterPrivate; CurrentOuter; CurrentOuter = CurrentOuter->OuterPrivate)
		{
			Temp = CurrentOuter->GetName() + "." + Temp;
		}

		Name = ClassPrivate->GetName();
		Name += " ";
		Name += Temp;
		Name += GetName();
	}

	return Name;
}

```

`UnrealIt.cpp`:

```cpp
#pragma once
#include <UnrealEngine/UE.h>

/** Credit to UnrealEngine's cute and sexy employees */

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
	if (ul_reason_for_call != DLL_PROCESS_ATTACH) return FALSE;

	AllocConsole();
	freopen("CONOUT$", "w", stdout);

	HMODULE GameModule = GetModuleHandleA(NULL);

	if (!GameModule) return FALSE;
		
	if (!Initalize(GameModule)) return FALSE;

	GUObjectArray->ObjObjects.Log();

	NamePoolData->Entries.Log();

    return TRUE;
}
```

`UnrealIt.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7064de0e-7dc9-4b7d-8144-5e5fe378f4d4}</ProjectGuid>
    <RootNamespace>UnrealBase</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>UnrealIt</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(ProjectDir);$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions);_CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>Default</LanguageStandard_C>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="UnrealEngine\FNamePool\FNamePool.cpp" />
    <ClCompile Include="UnrealEngine\FUObjectArray\FUObjectArray.cpp" />
    <ClCompile Include="UnrealEngine\UE.cpp" />
    <ClCompile Include="UnrealEngine\UObject\UObjectBaseUtility.cpp" />
    <ClCompile Include="UnrealIt.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Utilities\Log.h" />
    <ClInclude Include="UnrealEngine\UObject\CoreUObject.h" />
    <ClInclude Include="UnrealEngine\UE.h" />
    <ClInclude Include="UnrealEngine\FNamePool\FNamePool.h" />
    <ClInclude Include="UnrealEngine\FUObjectArray\FUObjectArray.h" />
    <ClInclude Include="Utilities\PatternScanner.h" />
    <ClInclude Include="Utilities\Types.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`UnrealIt.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="UE">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Utilities">
      <UniqueIdentifier>{594e373f-f522-4d3e-92a8-b499a273df0d}</UniqueIdentifier>
    </Filter>
    <Filter Include="UE\Hooks">
      <UniqueIdentifier>{df863fea-931d-45a3-87e3-cd69e0c28bc3}</UniqueIdentifier>
    </Filter>
    <Filter Include="UE\Utilities">
      <UniqueIdentifier>{8572e09d-252d-4500-9eac-db73b6349559}</UniqueIdentifier>
    </Filter>
    <Filter Include="UE\Classes">
      <UniqueIdentifier>{59c9e8aa-fa3e-4259-b88f-e697c74d25d0}</UniqueIdentifier>
    </Filter>
    <Filter Include="UE\Classes\Math">
      <UniqueIdentifier>{482bbb50-74a5-4e27-8471-88f1924232e4}</UniqueIdentifier>
    </Filter>
    <Filter Include="UE\Classes\TUObjectArray">
      <UniqueIdentifier>{3fff60a3-db73-4e52-9935-4a552162aad5}</UniqueIdentifier>
    </Filter>
    <Filter Include="UE\Classes\UObject">
      <UniqueIdentifier>{d1c6f34d-7150-40b8-a214-69d03ad0d23a}</UniqueIdentifier>
    </Filter>
    <Filter Include="UE\Classes\NewFilter1">
      <UniqueIdentifier>{f6503b7c-acbb-495f-836d-74a1c443d4fd}</UniqueIdentifier>
    </Filter>
    <Filter Include="UE\Classes\FNamePool">
      <UniqueIdentifier>{64afd149-0c48-4ee7-8890-178b8a1bb6ac}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="UnrealIt.cpp" />
    <ClCompile Include="UnrealEngine\UE.cpp">
      <Filter>UE</Filter>
    </ClCompile>
    <ClCompile Include="UnrealEngine\UObject\UObjectBaseUtility.cpp">
      <Filter>UE\Classes\UObject</Filter>
    </ClCompile>
    <ClCompile Include="UnrealEngine\FNamePool\FNamePool.cpp">
      <Filter>UE\Classes\FNamePool</Filter>
    </ClCompile>
    <ClCompile Include="UnrealEngine\FUObjectArray\FUObjectArray.cpp">
      <Filter>UE</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="UnrealEngine\UE.h">
      <Filter>UE</Filter>
    </ClInclude>
    <ClInclude Include="UnrealEngine\FUObjectArray\FUObjectArray.h">
      <Filter>UE\Classes\TUObjectArray</Filter>
    </ClInclude>
    <ClInclude Include="UnrealEngine\UObject\CoreUObject.h">
      <Filter>UE\Classes\UObject</Filter>
    </ClInclude>
    <ClInclude Include="Utilities\Types.h">
      <Filter>Utilities</Filter>
    </ClInclude>
    <ClInclude Include="Utilities\Log.h">
      <Filter>Utilities</Filter>
    </ClInclude>
    <ClInclude Include="UnrealEngine\FNamePool\FNamePool.h">
      <Filter>UE\Classes\FNamePool</Filter>
    </ClInclude>
    <ClInclude Include="Utilities\PatternScanner.h">
      <Filter>Utilities</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`UnrealIt.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`Utilities/Log.h`:

```h
#pragma once
#include <stdio.h>
#include <fstream>
#include <filesystem>

class Logger {
public:

	Logger(std::string FileName, bool append = false)
	{
		std::filesystem::path Path = std::filesystem::current_path();
		Path += FileName;
		
		LogFile.open(Path, append ? std::fstream::out : std::fstream::out | std::fstream::app);

		printf("[LOG] Log has been created at location %ws\n\n", Path.c_str());
	}

	inline void CloseLog() {
		LogFile.close();
	}

	void LogToFile(std::string Information) {
		LogFile << Information << std::endl;
	}

private:
	std::ofstream LogFile;
};



```

`Utilities/PatternScanner.h`:

```h
#pragma once

/*	
	https://github.com/N-T33/PatternScanner
	Credits for the pattern scanner (tysm):
	lguilhermee - https://github.com/lguilhermee/Discord-DX11-Overlay-Hook/blob/master/Helper/Helper.cpp
	guttir14 - https://github.com/guttir14/CheatIt/blob/main/CheatIt/utils.cpp
*/

static std::vector<int> PatternToIntVector(const char* Pattern)
{
	std::vector<int> Bytes = std::vector<int>{};

	char* Start = const_cast<char*>(Pattern);
	char* End = const_cast<char*>(Pattern) + strlen(Pattern);

	for (char* Current = Start; Current < End; ++Current)
	{
		if (*Current == '?')
		{
			++Current;
			Bytes.push_back(-69);
		}
		else { 
			Bytes.push_back(strtoul(Current, &Current, 16)); 
		}
	}
	return Bytes;
}

inline static void* FindPointer(std::vector<int> Pattern, uint8* Address, int Addition = 0) {
	int i = 0;
	while (Pattern[i] != -69) i++;
	int Offset = *reinterpret_cast<int*>(Address + i);
	return reinterpret_cast<void*>(Address + i + 4 + Offset + Addition);
}

template<typename T>
static T PatternScan(const char* Pattern, uint64 Start, size_t Size, bool bFindPointer = false, int Addition = 0)
{
	std::vector<int> PatternVector = PatternToIntVector(Pattern);

	uint8* Search = reinterpret_cast<uint8*>(Start);

	const size_t SizeOfPattern = PatternVector.size();
	const int* PatternData = PatternVector.data();

	for (int i = 0; i < Size - SizeOfPattern; ++i)
	{
		bool FoundSignature = true;

		for (int j = 0; j < SizeOfPattern; ++j)
		{
			if (Search[i + j] != PatternData[j] && PatternData[j] != -69)
			{
				FoundSignature = false;
				break;
			}
		}

		if (FoundSignature) {

			if (bFindPointer) {
				return reinterpret_cast<T>(FindPointer(PatternVector, &Search[i], Addition));
			}

			return reinterpret_cast<T>(&Search[i]);

		}
	}

	return reinterpret_cast<T>(nullptr);
}

static int ScanVTable(std::string Pattern, void* Object, int SkipAmount = 0) {

	int Out_Index = 0;

	int FunctionCount = 0;

	void** VTable = *reinterpret_cast<void***>(Object);

	while (VTable[FunctionCount]) FunctionCount++;

	for (int Index = SkipAmount; Index <= FunctionCount; Index++) {

		void* Result = PatternScan<void*>(Pattern.c_str(), reinterpret_cast<uint64>(VTable[Index]), Pattern.size());
		if (!Result) continue;

		Out_Index = Index;

		break;
	}

	return Out_Index;
}
```

`Utilities/Types.h`:

```h
#pragma once

//~ Unsigned base types

// 8-bit unsigned integer
typedef unsigned char 		uint8;

// 16-bit unsigned integer
typedef unsigned short int	uint16;

// 32-bit unsigned integer
typedef unsigned int		uint32;

// 64-bit unsigned integer
typedef unsigned long long	uint64;

//~ Signed base types.

// 8-bit signed integer
typedef	signed char			int8;

// 16-bit signed integer
typedef signed short int	int16;

// 32-bit signed integer
typedef signed int	 		int32;

// 64-bit signed integer
typedef signed long long	int64;


//~ Character types

// An ANSI character. 8-bit fixed-width representation of 7-bit characters.
typedef char				ANSICHAR;

// A wide character. In-memory only. ?-bit fixed-width representation of the platform's natural wide character set. Could be different sizes on different platforms.
typedef wchar_t				WIDECHAR;

// An 8-bit character type. In-memory only. 8-bit representation. Should really be char8_t but making this the generic option is easier for compilers which don't fully support C++11 yet (i.e. MSVC).
typedef uint8				CHAR8;

// A 16-bit character type. In-memory only.  16-bit representation. Should really be char16_t but making this the generic option is easier for compilers which don't fully support C++11 yet (i.e. MSVC).
typedef uint16				CHAR16;

// A 32-bit character type. In-memory only. 32-bit representation. Should really be char32_t but making this the generic option is easier for compilers which don't fully support C++11 yet (i.e. MSVC).
typedef uint32				CHAR32;

// A switchable character. In-memory only. Either ANSICHAR or WIDECHAR, depending on a licensee's requirements.
typedef WIDECHAR			TCHAR;
```