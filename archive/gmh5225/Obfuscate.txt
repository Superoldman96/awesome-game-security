Project Path: arc_gmh5225_Obfuscate_weliwyk6

Source Tree:

```txt
arc_gmh5225_Obfuscate_weliwyk6
├── CMakeLists.txt
├── LICENSE
├── README.md
├── obfuscate.h
├── test_bloat.cpp
├── test_bloat.py
├── test_obfuscated.cpp
├── test_obfuscated.py
└── test_unit.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.14)

project(Obfuscate)

option(GENERATE_TESTS "GENERATE_TESTS" ON)

set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Set unix platforms to output executables to Release and Debug folders (Windows does by default)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${CMAKE_BINARY_DIR}/Release)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${CMAKE_BINARY_DIR}/Debug)

# Unit tests
if (GENERATE_TESTS)
    include(CTest)

    include(FetchContent)
    FetchContent_Declare(
      googletest
      # Specify the commit you depend on and update it regularly.
      URL https://github.com/google/googletest/archive/609281088cfefc76f9d0ce82e1ff6c30cc3591e5.zip
    )
    # For Windows: Prevent overriding the parent project's compiler/linker settings
    set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
    FetchContent_MakeAvailable(googletest)

    add_executable(test_unit obfuscate.h test_unit.cpp)
    target_link_libraries(test_unit gtest_main)

    add_test(NAME test_unit COMMAND test_unit)

    add_executable(test_obfuscated obfuscate.h test_obfuscated.cpp)
    set_target_properties(test_obfuscated PROPERTIES SUFFIX ".out")
endif()

# Bloat test
add_executable(test_bloat_on obfuscate.h test_bloat.cpp)
add_executable(test_bloat_off obfuscate.h test_bloat.cpp)
target_compile_definitions(test_bloat_on PRIVATE USE_AY_OBFUSCATE=1)
```

`LICENSE`:

```
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org>

```

`README.md`:

```md
**[Source available on GitHub](https://github.com/adamyaxley/Obfuscate)**

# Obfuscate
Guaranteed compile-time string literal obfuscation header-only library for C++14.

## Quick start guide
1. Copy `obfuscate.h` into your project
2. Wrap strings with `AY_OBFUSCATE("My String")`

Now your project will not expose those strings in plain text in the binary image.

_Note that these strings will still be accessible to determined hackers. Using obfuscation to hide private passwords or any other security sensitive strings is not recommended by the author._

## Whats the problem?
When plain text string literals are used in C++ programs, they will be compiled as-is into the resultant binary. This causes them to be incredibly easy to find. One can simply open up the binary file in a text editor to see all of the embedded string literals in plain view. A special utility called [strings](https://en.wikipedia.org/wiki/Strings_(Unix)) exists which can be used to search binary files for plain text strings.

## What does this library do?
This header-only library seeks to make it difficult (but not impossible) for embedded string literals in binary files to be found by encrypting them with an XOR cipher at compile-time using a constant expression, forcing the compiler to _work with_ the encrypted string instead of the plain text literal. Usage of `AY_OBFUSCATE` additionally removes the need for a const pointer to the string, which more often than not (for small strings) convinces the compiler to inline the encrypted string, building it up at runtime in a series of assembly operations, protecting the binary image against simple XOR decryption attacks. Encrypted strings will then be decrypted at runtime to be utilised within the program.

### Technical features
* _Guaranteed compile-time obfuscation_ - the string is compiled via a constexpr expression.
* _Global lifetime_ - the obfuscated string is stored in a function level static variable in a unique lambda.
* _Implicitly convertible to a char*_ - easy to integrate into existing codebases.
* _Random 64-bit key_ - obfusated with a random key each time.

By simply wrapping your string literal `"My String"` with `AY_OBFUSCATE("My String")` it will be encrypted at compile time with a random 64 bit key and stored in an `ay::obfuscated_data` object which you can manipulate at runtime. For convenience it is also implicitly convertable to a `char*`.

For example, the following program will not store the string "Hello World" in plain text anywhere in the compiled executable.
```c++
#include "obfuscate.h"

int main()
{
  std::cout << AY_OBFUSCATE("Hello World") << std::endl;
  return 0;
}
```

### Examples of usage
Because the obfuscated data that is generated by `AY_OBFUSCATE` has global lifetime it is completely fine to also use it in both a local and a temporary context.
```c++
char* var = AY_OBFUSCATE("string");
const char* var = AY_OBFUSCATE("string");
static const char* var = AY_OBFUSCATE("string");
std::string var(AY_OBFUSCATE("string"));
function_that_takes_char_pointer(AY_OBFUSCATE("string"));
```

### Thread safety
This library is *not* thread safe. If you intend to use this library in a multi-threaded context, you must put locks in appropriate places in your code to ensure that only one thread accesses this library at a time.

## Binary file size overhead
This does come at a small cost. In a very naive login program, which obfuscates two strings (username and password) the following binary file bloat exists.

| Config | Plain string literals | Obfuscated strings | Bloat |
|:------:|:---------------------:|:------------------:|:-----:|
| Release | 18944 | 21504 | 2560 (13.5%) |
| Debug | 95232 | 101888 | 6656 (7.0%) |

This output is generated by running test_bloat.py

```

`obfuscate.h`:

```h
/* --------------------------------- ABOUT -------------------------------------

Original Author: Adam Yaxley
Website: https://github.com/adamyaxley
License: See end of file

Obfuscate
Guaranteed compile-time string literal obfuscation library for C++14

Usage:
Pass string literals into the AY_OBFUSCATE macro to obfuscate them at compile
time. AY_OBFUSCATE returns a reference to an ay::obfuscated_data object with the
following traits:
	- Guaranteed obfuscation of string
	The passed string is encrypted with a simple XOR cipher at compile-time to
	prevent it being viewable in the binary image
	- Global lifetime
	The actual instantiation of the ay::obfuscated_data takes place inside a
	lambda as a function level static
	- Implicitly convertable to a char*
	This means that you can pass it directly into functions that would normally
	take a char* or a const char*

Example:
const char* obfuscated_string = AY_OBFUSCATE("Hello World");
std::cout << obfuscated_string << std::endl;

----------------------------------------------------------------------------- */

// Workaround for __LINE__ not being constexpr when /ZI (Edit and Continue) is enabled in Visual Studio
// See: https://developercommunity.visualstudio.com/t/-line-cannot-be-used-as-an-argument-for-constexpr/195665
#ifdef _MSC_VER
	#define AY_CAT(X,Y) AY_CAT2(X,Y)
	#define AY_CAT2(X,Y) X##Y
	#define AY_LINE int(AY_CAT(__LINE__,U))
#else
	#define AY_LINE __LINE__
#endif

#ifndef AY_OBFUSCATE_DEFAULT_KEY
	// The default 64 bit key to obfuscate strings with.
	// This can be user specified by defining AY_OBFUSCATE_DEFAULT_KEY before 
	// including obfuscate.h
	#define AY_OBFUSCATE_DEFAULT_KEY ay::generate_key(AY_LINE)
#endif

namespace ay
{
	using size_type = unsigned long long;
	using key_type = unsigned long long;

	// Generate a pseudo-random key that spans all 8 bytes
	constexpr key_type generate_key(key_type seed)
	{
		// Use the MurmurHash3 64-bit finalizer to hash our seed
		key_type key = seed;
		key ^= (key >> 33);
		key *= 0xff51afd7ed558ccd;
		key ^= (key >> 33);
		key *= 0xc4ceb9fe1a85ec53;
		key ^= (key >> 33);

		// Make sure that a bit in each byte is set
		key |= 0x0101010101010101ull;

		return key;
	}

	// Obfuscates or deobfuscates data with key
	constexpr void cipher(char* data, size_type size, key_type key)
	{
		// Obfuscate with a simple XOR cipher based on key
		for (size_type i = 0; i < size; i++)
		{
			data[i] ^= char(key >> ((i % 8) * 8));
		}
	}

	// Obfuscates a string at compile time
	template <size_type N, key_type KEY>
	class obfuscator
	{
	public:
		// Obfuscates the string 'data' on construction
		constexpr obfuscator(const char* data)
		{
			// Copy data
			for (size_type i = 0; i < N; i++)
			{
				m_data[i] = data[i];
			}

			// On construction each of the characters in the string is
			// obfuscated with an XOR cipher based on key
			cipher(m_data, N, KEY);
		}

		constexpr const char* data() const
		{
			return &m_data[0];
		}

		constexpr size_type size() const
		{
			return N;
		}

		constexpr key_type key() const
		{
			return KEY;
		}

	private:

		char m_data[N]{};
	};

	// Handles decryption and re-encryption of an encrypted string at runtime
	template <size_type N, key_type KEY>
	class obfuscated_data
	{
	public:
		obfuscated_data(const obfuscator<N, KEY>& obfuscator)
		{
			// Copy obfuscated data
			for (size_type i = 0; i < N; i++)
			{
				m_data[i] = obfuscator.data()[i];
			}
		}

		~obfuscated_data()
		{
			// Zero m_data to remove it from memory
			for (size_type i = 0; i < N; i++)
			{
				m_data[i] = 0;
			}
		}

		// Returns a pointer to the plain text string, decrypting it if
		// necessary
		operator char*()
		{
			decrypt();
			return m_data;
		}

		// Manually decrypt the string
		void decrypt()
		{
			if (m_encrypted)
			{
				cipher(m_data, N, KEY);
				m_encrypted = false;
			}
		}

		// Manually re-encrypt the string
		void encrypt()
		{
			if (!m_encrypted)
			{
				cipher(m_data, N, KEY);
				m_encrypted = true;
			}
		}

		// Returns true if this string is currently encrypted, false otherwise.
		bool is_encrypted() const
		{
			return m_encrypted;
		}

	private:

		// Local storage for the string. Call is_encrypted() to check whether or
		// not the string is currently obfuscated.
		char m_data[N];

		// Whether data is currently encrypted
		bool m_encrypted{ true };
	};

	// This function exists purely to extract the number of elements 'N' in the
	// array 'data'
	template <size_type N, key_type KEY = AY_OBFUSCATE_DEFAULT_KEY>
	constexpr auto make_obfuscator(const char(&data)[N])
	{
		return obfuscator<N, KEY>(data);
	}
}

// Obfuscates the string 'data' at compile-time and returns a reference to a
// ay::obfuscated_data object with global lifetime that has functions for
// decrypting the string and is also implicitly convertable to a char*
#define AY_OBFUSCATE(data) AY_OBFUSCATE_KEY(data, AY_OBFUSCATE_DEFAULT_KEY)

// Obfuscates the string 'data' with 'key' at compile-time and returns a
// reference to a ay::obfuscated_data object with global lifetime that has
// functions for decrypting the string and is also implicitly convertable to a
// char*
#define AY_OBFUSCATE_KEY(data, key) \
	[]() -> ay::obfuscated_data<sizeof(data)/sizeof(data[0]), key>& { \
		static_assert(sizeof(decltype(key)) == sizeof(ay::key_type), "key must be a 64 bit unsigned integer"); \
		static_assert((key) >= (1ull << 56), "key must span all 8 bytes"); \
		constexpr auto n = sizeof(data)/sizeof(data[0]); \
		constexpr auto obfuscator = ay::make_obfuscator<n, key>(data); \
		thread_local auto obfuscated_data = ay::obfuscated_data<n, key>(obfuscator); \
		return obfuscated_data; \
	}()

/* -------------------------------- LICENSE ------------------------------------

Public Domain (http://www.unlicense.org)

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.

In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

----------------------------------------------------------------------------- */

```

`test_bloat.cpp`:

```cpp
/* ------------------------------- ABOUT ---------------------------------------

Obfuscate naive login example (bloat test)
This example login program demonstrates how much bloat is added to the final
executable if AY_OBFUSCATE is used to obfuscate security sensitive strings at
compile-time.

Run calculate_bloat.py to output a table comparing release and debug configs.

----------------------------------------------------------------------------- */

#include <iostream>
#include <string>

#ifdef USE_AY_OBFUSCATE
	#include "obfuscate.h"
#else
	#define AY_OBFUSCATE(text) text
#endif

int main() 
{
	const std::string username(AY_OBFUSCATE("root"));
	const std::string password(AY_OBFUSCATE("password"));

	std::cout << "Obfuscate naive login example (bloat test)" << std::endl;

	std::string input_username;
	std::string input_password;

	while (true)
	{
		std::cout << "Username: ";
		std::cin >> input_username;

		std::cout << "Password: ";
		std::cin >> input_password;

		if (input_username == username && input_password == password)
		{
			std::cout << "Login success!" << std::endl;
			break;
		}
		else
		{
			std::cout << "Login failure: unrecognised username and password"
				"combination." << std::endl;
		}
	}

	return 0;
}
```

`test_bloat.py`:

```py
import os, errno, subprocess, sys

def callCommand(command):
    process = subprocess.Popen(command, stdout=subprocess.PIPE)
    process.communicate()
    process.wait()

def main():
    dir = "test_bloat"
    try:
        os.makedirs(dir)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
    os.chdir(dir)
    callCommand(["cmake", ".."])
    callCommand(["cmake", "--build", ".", "--config", "Debug"])
    callCommand(["cmake", "--build", ".", "--config", "Release"])
    os.chdir("..")
    
    print ("| Config | Plain string literals | Obfuscated strings | Bloat |")
    print ("|:------:|:---------------------:|:------------------:|:-----:|")
    for config in ["Release", "Debug"]:
        sizeOn = os.stat(os.path.join(dir, config, "test_bloat_on.exe")).st_size
        sizeOff = os.stat(os.path.join(dir, config, "test_bloat_off.exe")).st_size
        print ("| {} | {} | {} | {} ({:.1f}%) |".format(config, sizeOff, sizeOn, sizeOn - sizeOff, (sizeOn / sizeOff - 1.0) * 100))

if __name__ == "__main__":
    main()
```

`test_obfuscated.cpp`:

```cpp
#include "obfuscate.h"

#include <cstdio>

int main()
{
	{
		auto str = AY_OBFUSCATE("1 auto str");
		puts(str);
	}
	{
		char* str = AY_OBFUSCATE("2 char* str");
		puts(str);
	}
	{
		const char* str = AY_OBFUSCATE("3 const char* str");
		puts(str);
	}
	{
		static const char* str = AY_OBFUSCATE("4 static const char* str");
		puts(str);
	}
	{
		auto str = AY_OBFUSCATE("5 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent sed ullamcorper lectus. Cras dapibus, turpis in dignissim consequat, justo massa vehicula sem, vestibulum condimentum dui risus vitae nunc. Mauris tincidunt condimentum nulla, non elementum lectus molestie id. Ut eget libero lorem. Proin vitae massa vehicula, hendrerit est a, tincidunt est. Sed aliquam velit quam, laoreet commodo massa aliquam et. Phasellus in nulla ac risus facilisis porttitor sit amet at enim. Vivamus ornare libero sit amet enim egestas semper vel non dolor.Ut vitae scelerisque elit, sed tincidunt tellus.Maecenas a accumsan justo, sit amet auctor nisl.Donec et quam mollis.");
		puts(str);
	}

	return 0;
}
```

`test_obfuscated.py`:

```py
# Usage:
# test_obfuscated.py target.exe "Hello World"
# returns exit code 0 if obfuscated, 1 if not

import sys

def test_obfuscated(path, string):
    with open(path, 'rb') as f:
        contents = f.read()
        return (contents.find(string.encode()) == -1)

if __name__ == "__main__":
    path = sys.argv[1]
    string = sys.argv[2]
    if (test_obfuscated(path, string)):
        print("SUCCESS - string \"{}\" is obfuscated".format(string))
        sys.exit(0)
    else:
        print("FAILURE - string \"{}\" is not obfuscated".format(string))
        sys.exit(1)
```

`test_unit.cpp`:

```cpp
#include "gtest/gtest.h"
#include "obfuscate.h"

#include <cstdio>
#include <string>

// Test AY_OBFUSCATE (main test)
TEST(Obfuscate, AY_OBFUSCATE)
{
	// Encrypt a string literal with an XOR cipher at compile time and store
	// it in test.
	auto test = AY_OBFUSCATE("Hello World");

	// The string starts out as encrypted
	ASSERT_TRUE(test.is_encrypted());

	// Manually decrypt the string. This is useful for pre-processing
	// especially large strings.
	test.decrypt();
	ASSERT_TRUE(!test.is_encrypted());

	// Output the plain text string to the console (implicitly converts to
	// const char*)
	puts(test);

	// Re-encrypt the string so that it cannot be seen in it's plain text
	// form in memory.
	test.encrypt();
	ASSERT_TRUE(test.is_encrypted());

	// The encrypted string will be automatically decrypted if necessary
	// when implicitly converting to a const char*
	puts(test);

	// The string is in a decrypted state
	ASSERT_TRUE(!test.is_encrypted());

	// Test comparison
	ASSERT_TRUE(std::string("Hello World") == (char*)test);
}

// Test AY_OBFUSCATE_KEY
TEST(Obfuscate, AY_OBFUSCATE_KEY)
{
	auto test = AY_OBFUSCATE_KEY("Hello World", 0xf8d3481a4bc32d83ull);

	puts(test);

	// Test comparison
	ASSERT_TRUE(std::string("Hello World") == (char*)test);
}

// Test direct API usage
TEST(Obfuscate, API)
{
	constexpr auto obfuscator = ay::make_obfuscator("Hello World");
	auto test = ay::obfuscated_data<obfuscator.size(), obfuscator.key()>(obfuscator);

	puts(test);

	// Test comparison
	ASSERT_TRUE(std::string("Hello World") == (char*)test);
}

static const char* g_global_static1 = AY_OBFUSCATE("global_static1");
static const char* g_global_static2 = AY_OBFUSCATE("global_static2");

// Test global static const char* variables
TEST(Obfuscate, GlobalConstCharPtr)
{
	ASSERT_TRUE(strcmp(g_global_static1, "global_static1") == 0);
	puts(g_global_static1);
	ASSERT_TRUE(strcmp(g_global_static2, "global_static2") == 0);
	puts(g_global_static2);
}

// Test local const char* variables
TEST(Obfuscate, LocalConstCharPtr)
{
	const char* local1 = AY_OBFUSCATE("local1");
	const char* local2 = AY_OBFUSCATE("local2");

	ASSERT_TRUE(strcmp(local1, "local1") == 0);
	puts(local1);
	ASSERT_TRUE(strcmp(local2, "local2") == 0);
	puts(local2);
}

// Test non-null terminated strings
TEST(Obfuscate, NonNullTerminatedStr)
{
	constexpr auto obfuscator = ay::obfuscator<10, AY_OBFUSCATE_DEFAULT_KEY>("1234567890");
	auto test = ay::obfuscated_data<obfuscator.size(), obfuscator.key()>(obfuscator);

	puts(test);

	// Test comparison
	assert(std::string("1234567890") == (char*)test);
}

```