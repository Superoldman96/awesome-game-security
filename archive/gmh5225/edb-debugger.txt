Project Path: arc_gmh5225_edb-debugger_powvbm5p

Source Tree:

```txt
arc_gmh5225_edb-debugger_powvbm5p
├── BUGS
├── CHANGELOG
├── CMakeLists.txt
├── COPYING
├── README.md
├── TODO
├── appveyor.yml
├── cmake
│   └── Modules
│       ├── AddWarnings.cmake
│       ├── DetectArchitecture.cmake
│       ├── DetectCompiler.cmake
│       ├── DetectGitBranch.cmake
│       ├── DetectOS.cmake
│       ├── EnableSTLDebug.cmake
│       ├── EnableSanitizers.cmake
│       ├── FindCapstone.cmake
│       └── ProjectDefaults.cmake
├── edb.1
├── edb.appdata.xml
├── edb.desktop
├── include
│   ├── API.h
│   ├── ArchProcessor.h
│   ├── BasicBlock.h
│   ├── BinaryString.h
│   ├── ByteShiftArray.h
│   ├── Configuration.h
│   ├── Expression.h
│   ├── Expression.tcc
│   ├── FloatX.h
│   ├── Function.h
│   ├── GraphEdge.h
│   ├── GraphNode.h
│   ├── GraphWidget.h
│   ├── HexStringValidator.h
│   ├── IAnalyzer.h
│   ├── IBinary.h
│   ├── IBreakpoint.h
│   ├── IDebugEvent.h
│   ├── IDebugEventHandler.h
│   ├── IDebugger.h
│   ├── IPlugin.h
│   ├── IProcess.h
│   ├── IRegion.h
│   ├── IState.h
│   ├── ISymbolGenerator.h
│   ├── ISymbolManager.h
│   ├── IThread.h
│   ├── Instruction.h
│   ├── MemoryRegions.h
│   ├── Module.h
│   ├── Patch.h
│   ├── Prototype.h
│   ├── QLongValidator.h
│   ├── QULongValidator.h
│   ├── QtHelper.h
│   ├── Register.h
│   ├── RegisterRef.h
│   ├── RegisterViewModelBase.h
│   ├── State.h
│   ├── Status.h
│   ├── Symbol.h
│   ├── Theme.h
│   ├── ThreadsModel.h
│   ├── Types.h
│   ├── Util.h
│   ├── Value.h
│   ├── arch
│   │   ├── arm-generic
│   │   │   └── ArchTypes.h
│   │   └── x86-generic
│   │       └── ArchTypes.h
│   ├── edb.h
│   ├── os
│   │   ├── unix
│   │   │   ├── OSTypes.h
│   │   │   └── linux
│   │   │       └── linker.h
│   │   └── win32
│   │       └── OSTypes.h
│   ├── string_hash.h
│   ├── util
│   │   ├── Container.h
│   │   ├── Error.h
│   │   ├── Float.h
│   │   ├── Font.h
│   │   ├── Integer.h
│   │   ├── Math.h
│   │   └── String.h
│   └── version.h.in
├── lib
│   ├── CMakeLists.txt
│   ├── gdtoa-desktop
│   ├── libELF
│   │   ├── CMakeLists.txt
│   │   └── include
│   │       └── libELF
│   │           ├── elf_auxv.h
│   │           ├── elf_binary.h
│   │           ├── elf_dyn.h
│   │           ├── elf_header.h
│   │           ├── elf_model.h
│   │           ├── elf_move.h
│   │           ├── elf_nhdr.h
│   │           ├── elf_phdr.h
│   │           ├── elf_rel.h
│   │           ├── elf_rela.h
│   │           ├── elf_shdr.h
│   │           ├── elf_sym.h
│   │           ├── elf_syminfo.h
│   │           ├── elf_types.h
│   │           ├── elf_verdaux.h
│   │           ├── elf_verdef.h
│   │           ├── elf_vernaux.h
│   │           └── elf_verneed.h
│   └── libPE
│       ├── CMakeLists.txt
│       └── include
│           └── libPE
│               └── pe_binary.h
├── pkg
│   ├── deb
│   │   └── create-deb-qt5.sh
│   └── fedora
│       └── edb.spec
├── plugins
│   ├── Analyzer
│   │   ├── Analyzer.cpp
│   │   ├── Analyzer.h
│   │   ├── AnalyzerWidget.cpp
│   │   ├── AnalyzerWidget.h
│   │   ├── CMakeLists.txt
│   │   ├── DialogXRefs.cpp
│   │   ├── DialogXRefs.h
│   │   ├── DialogXRefs.ui
│   │   ├── OptionsPage.cpp
│   │   ├── OptionsPage.h
│   │   ├── OptionsPage.ui
│   │   ├── SpecifiedFunctions.cpp
│   │   ├── SpecifiedFunctions.h
│   │   └── SpecifiedFunctions.ui
│   ├── Assembler
│   │   ├── Assembler.cpp
│   │   ├── Assembler.h
│   │   ├── Assembler.qrc
│   │   ├── CMakeLists.txt
│   │   ├── DialogAssembler.cpp
│   │   ├── DialogAssembler.h
│   │   ├── DialogAssembler.ui
│   │   ├── OptionsPage.cpp
│   │   ├── OptionsPage.h
│   │   ├── OptionsPage.ui
│   │   └── xml
│   │       └── assemblers.xml
│   ├── Backtrace
│   │   ├── Backtrace.cpp
│   │   ├── Backtrace.h
│   │   ├── CMakeLists.txt
│   │   ├── CallStack.cpp
│   │   ├── CallStack.h
│   │   ├── DialogBacktrace.cpp
│   │   ├── DialogBacktrace.h
│   │   └── DialogBacktrace.ui
│   ├── BinaryInfo
│   │   ├── BinaryInfo.cpp
│   │   ├── BinaryInfo.h
│   │   ├── CMakeLists.txt
│   │   ├── DialogHeader.cpp
│   │   ├── DialogHeader.h
│   │   ├── DialogHeader.ui
│   │   ├── DialogRegions.cpp
│   │   ├── DialogRegions.h
│   │   ├── DialogRegions.ui
│   │   ├── ELF32.cpp
│   │   ├── ELF64.cpp
│   │   ├── ELFXX.cpp
│   │   ├── ELFXX.h
│   │   ├── OptionsPage.cpp
│   │   ├── OptionsPage.h
│   │   ├── OptionsPage.ui
│   │   ├── PE32.cpp
│   │   ├── PE32.h
│   │   ├── demangle.h
│   │   ├── symbols.cpp
│   │   └── symbols.h
│   ├── BinarySearcher
│   │   ├── BinarySearcher.cpp
│   │   ├── BinarySearcher.h
│   │   ├── CMakeLists.txt
│   │   ├── DialogAsciiString.cpp
│   │   ├── DialogAsciiString.h
│   │   ├── DialogAsciiString.ui
│   │   ├── DialogBinaryString.cpp
│   │   ├── DialogBinaryString.h
│   │   ├── DialogBinaryString.ui
│   │   ├── DialogResults.cpp
│   │   ├── DialogResults.h
│   │   └── DialogResults.ui
│   ├── Bookmarks
│   │   ├── BookmarkWidget.cpp
│   │   ├── BookmarkWidget.h
│   │   ├── BookmarkWidget.ui
│   │   ├── Bookmarks.cpp
│   │   ├── Bookmarks.h
│   │   ├── BookmarksModel.cpp
│   │   ├── BookmarksModel.h
│   │   └── CMakeLists.txt
│   ├── BreakpointManager
│   │   ├── BreakpointManager.cpp
│   │   ├── BreakpointManager.h
│   │   ├── CMakeLists.txt
│   │   ├── DialogBreakpoints.cpp
│   │   ├── DialogBreakpoints.h
│   │   └── DialogBreakpoints.ui
│   ├── CMakeLists.txt
│   ├── CheckVersion
│   │   ├── CMakeLists.txt
│   │   ├── CheckVersion.cpp
│   │   ├── CheckVersion.h
│   │   ├── OptionsPage.cpp
│   │   ├── OptionsPage.h
│   │   └── OptionsPage.ui
│   ├── DebuggerCore
│   │   ├── CMakeLists.txt
│   │   ├── DebuggerCoreBase.cpp
│   │   ├── DebuggerCoreBase.h
│   │   ├── arch
│   │   │   ├── arm-generic
│   │   │   │   ├── Breakpoint.cpp
│   │   │   │   └── Breakpoint.h
│   │   │   └── x86-generic
│   │   │       ├── Breakpoint.cpp
│   │   │       └── Breakpoint.h
│   │   ├── unix
│   │   │   ├── Posix.cpp
│   │   │   ├── Posix.h
│   │   │   ├── Unix.cpp
│   │   │   ├── Unix.h
│   │   │   ├── freebsd
│   │   │   │   ├── DebuggerCore.cpp
│   │   │   │   ├── DebuggerCore.h
│   │   │   │   ├── PlatformCommon.cpp
│   │   │   │   ├── PlatformCommon.h
│   │   │   │   ├── PlatformEvent.cpp
│   │   │   │   ├── PlatformEvent.h
│   │   │   │   ├── PlatformProcess.cpp
│   │   │   │   ├── PlatformProcess.h
│   │   │   │   ├── PlatformRegion.cpp
│   │   │   │   ├── PlatformRegion.h
│   │   │   │   ├── PlatformState.cpp
│   │   │   │   ├── PlatformState.h
│   │   │   │   ├── PlatformThread.cpp
│   │   │   │   └── PlatformThread.h
│   │   │   ├── linux
│   │   │   │   ├── DebuggerCore.cpp
│   │   │   │   ├── DebuggerCore.h
│   │   │   │   ├── DialogMemoryAccess.cpp
│   │   │   │   ├── DialogMemoryAccess.h
│   │   │   │   ├── DialogMemoryAccess.ui
│   │   │   │   ├── FeatureDetect.cpp
│   │   │   │   ├── FeatureDetect.h
│   │   │   │   ├── PlatformCommon.cpp
│   │   │   │   ├── PlatformCommon.h
│   │   │   │   ├── PlatformEvent.cpp
│   │   │   │   ├── PlatformEvent.h
│   │   │   │   ├── PlatformProcess.cpp
│   │   │   │   ├── PlatformProcess.h
│   │   │   │   ├── PlatformRegion.cpp
│   │   │   │   ├── PlatformRegion.h
│   │   │   │   ├── PlatformThread.cpp
│   │   │   │   ├── PlatformThread.h
│   │   │   │   ├── PrStatus.h
│   │   │   │   └── arch
│   │   │   │       ├── arm-generic
│   │   │   │       │   ├── PlatformState.cpp
│   │   │   │       │   ├── PlatformState.h
│   │   │   │       │   └── PlatformThread.cpp
│   │   │   │       └── x86-generic
│   │   │   │           ├── PlatformState.cpp
│   │   │   │           ├── PlatformState.h
│   │   │   │           └── PlatformThread.cpp
│   │   │   ├── openbsd
│   │   │   │   ├── DebuggerCore.cpp
│   │   │   │   ├── DebuggerCore.h
│   │   │   │   ├── PlatformEvent.cpp
│   │   │   │   ├── PlatformEvent.h
│   │   │   │   ├── PlatformProcess.cpp
│   │   │   │   ├── PlatformProcess.h
│   │   │   │   ├── PlatformRegion.cpp
│   │   │   │   ├── PlatformRegion.h
│   │   │   │   ├── PlatformState.cpp
│   │   │   │   └── PlatformState.h
│   │   │   └── osx
│   │   │       ├── DebuggerCore.cpp
│   │   │       ├── DebuggerCore.h
│   │   │       ├── PlatformEvent.cpp
│   │   │       ├── PlatformEvent.h
│   │   │       ├── PlatformProcess.cpp
│   │   │       ├── PlatformProcess.h
│   │   │       ├── PlatformRegion.cpp
│   │   │       ├── PlatformRegion.h
│   │   │       ├── PlatformState.cpp
│   │   │       └── PlatformState.h
│   │   └── win32
│   │       ├── DebuggerCore.cpp
│   │       ├── DebuggerCore.h
│   │       ├── PlatformEvent.cpp
│   │       ├── PlatformEvent.h
│   │       ├── PlatformProcess.cpp
│   │       ├── PlatformProcess.h
│   │       ├── PlatformRegion.cpp
│   │       ├── PlatformRegion.h
│   │       ├── PlatformState.cpp
│   │       ├── PlatformState.h
│   │       ├── PlatformThread.cpp
│   │       └── PlatformThread.h
│   ├── DebuggerErrorConsole
│   │   ├── CMakeLists.txt
│   │   ├── Plugin.cpp
│   │   └── Plugin.h
│   ├── DumpState
│   │   ├── CMakeLists.txt
│   │   ├── DumpState.cpp
│   │   ├── DumpState.h
│   │   ├── OptionsPage.cpp
│   │   ├── OptionsPage.h
│   │   └── OptionsPage.ui
│   ├── FasLoader
│   │   ├── CMakeLists.txt
│   │   ├── Fas
│   │   │   ├── Core.cpp
│   │   │   ├── Core.hpp
│   │   │   ├── Exception.cpp
│   │   │   ├── Exception.hpp
│   │   │   ├── Header.hpp
│   │   │   ├── PluginSymbol.hpp
│   │   │   ├── Symbol.hpp
│   │   │   └── fas.txt
│   │   ├── FasLoader.cpp
│   │   └── FasLoader.hpp
│   ├── FunctionFinder
│   │   ├── CMakeLists.txt
│   │   ├── DialogFunctions.cpp
│   │   ├── DialogFunctions.h
│   │   ├── DialogFunctions.ui
│   │   ├── DialogResults.cpp
│   │   ├── DialogResults.h
│   │   ├── DialogResults.ui
│   │   ├── FunctionFinder.cpp
│   │   ├── FunctionFinder.h
│   │   ├── ResultsModel.cpp
│   │   └── ResultsModel.h
│   ├── HardwareBreakpoints
│   │   ├── CMakeLists.txt
│   │   ├── DialogHwBreakpoints.cpp
│   │   ├── DialogHwBreakpoints.h
│   │   ├── DialogHwBreakpoints.ui
│   │   ├── HardwareBreakpoints.cpp
│   │   ├── HardwareBreakpoints.h
│   │   ├── libHardwareBreakpoints.cpp
│   │   └── libHardwareBreakpoints.h
│   ├── HeapAnalyzer
│   │   ├── CMakeLists.txt
│   │   ├── DialogHeap.cpp
│   │   ├── DialogHeap.h
│   │   ├── DialogHeap.ui
│   │   ├── HeapAnalyzer.cpp
│   │   ├── HeapAnalyzer.h
│   │   ├── ResultViewModel.cpp
│   │   └── ResultViewModel.h
│   ├── InstructionInspector
│   │   ├── CMakeLists.txt
│   │   ├── Plugin.cpp
│   │   └── Plugin.h
│   ├── ODbgRegisterView
│   │   ├── BitFieldDescription.cpp
│   │   ├── BitFieldDescription.h
│   │   ├── BitFieldFormatter.cpp
│   │   ├── BitFieldFormatter.h
│   │   ├── CMakeLists.txt
│   │   ├── Canvas.cpp
│   │   ├── Canvas.h
│   │   ├── DialogEditGPR.cpp
│   │   ├── DialogEditGPR.h
│   │   ├── DialogEditSimdRegister.cpp
│   │   ├── DialogEditSimdRegister.h
│   │   ├── EntryGridKeyUpDownEventFilter.cpp
│   │   ├── EntryGridKeyUpDownEventFilter.h
│   │   ├── FieldWidget.cpp
│   │   ├── FieldWidget.h
│   │   ├── FpuValueField.h
│   │   ├── GprEdit.cpp
│   │   ├── GprEdit.h
│   │   ├── MultiBitFieldWidget.cpp
│   │   ├── MultiBitFieldWidget.h
│   │   ├── NumberEdit.cpp
│   │   ├── NumberEdit.h
│   │   ├── ODbgRV_Common.h
│   │   ├── ODbgRV_Util.h
│   │   ├── Plugin.cpp
│   │   ├── Plugin.h
│   │   ├── RegisterGroup.cpp
│   │   ├── RegisterGroup.h
│   │   ├── RegisterView.cpp
│   │   ├── RegisterView.h
│   │   ├── SimdValueManager.cpp
│   │   ├── SimdValueManager.h
│   │   ├── ValueField.cpp
│   │   ├── ValueField.h
│   │   ├── VolatileNameField.cpp
│   │   ├── VolatileNameField.h
│   │   └── arch
│   │       ├── arm-generic
│   │       │   ├── armGroups.cpp
│   │       │   └── armGroups.h
│   │       └── x86-generic
│   │           ├── DialogEditFPU.cpp
│   │           ├── DialogEditFPU.h
│   │           ├── Float80Edit.cpp
│   │           ├── Float80Edit.h
│   │           ├── ODbgRV_x86Common.h
│   │           ├── x86FPUValueField.cpp
│   │           ├── x86Groups.cpp
│   │           └── x86Groups.h
│   ├── OpcodeSearcher
│   │   ├── CMakeLists.txt
│   │   ├── DialogOpcodes.cpp
│   │   ├── DialogOpcodes.h
│   │   ├── DialogOpcodes.ui
│   │   ├── DialogResults.cpp
│   │   ├── DialogResults.h
│   │   ├── DialogResults.ui
│   │   ├── OpcodeSearcher.cpp
│   │   ├── OpcodeSearcher.h
│   │   ├── ResultsModel.cpp
│   │   └── ResultsModel.h
│   ├── ProcessProperties
│   │   ├── CMakeLists.txt
│   │   ├── DialogProcessProperties.cpp
│   │   ├── DialogProcessProperties.h
│   │   ├── DialogProcessProperties.ui
│   │   ├── DialogResults.cpp
│   │   ├── DialogResults.h
│   │   ├── DialogResults.ui
│   │   ├── DialogStrings.cpp
│   │   ├── DialogStrings.h
│   │   ├── DialogStrings.ui
│   │   ├── ProcessProperties.cpp
│   │   ├── ProcessProperties.h
│   │   ├── ResultsModel.cpp
│   │   └── ResultsModel.h
│   ├── ROPTool
│   │   ├── CMakeLists.txt
│   │   ├── DialogROPTool.cpp
│   │   ├── DialogROPTool.h
│   │   ├── DialogROPTool.ui
│   │   ├── DialogResults.cpp
│   │   ├── DialogResults.h
│   │   ├── DialogResults.ui
│   │   ├── ROPTool.cpp
│   │   ├── ROPTool.h
│   │   ├── ResultsModel.cpp
│   │   └── ResultsModel.h
│   ├── References
│   │   ├── CMakeLists.txt
│   │   ├── DialogReferences.cpp
│   │   ├── DialogReferences.h
│   │   ├── DialogReferences.ui
│   │   ├── References.cpp
│   │   └── References.h
│   └── SymbolViewer
│       ├── CMakeLists.txt
│       ├── DialogSymbolViewer.cpp
│       ├── DialogSymbolViewer.h
│       ├── DialogSymbolViewer.ui
│       ├── SymbolViewer.cpp
│       └── SymbolViewer.h
└── src
    ├── BasicBlock.cpp
    ├── BinaryString.cpp
    ├── BinaryString.ui
    ├── ByteShiftArray.cpp
    ├── CMakeLists.txt
    ├── CommentServer.cpp
    ├── CommentServer.h
    ├── Configuration.cpp
    ├── DataViewInfo.cpp
    ├── DataViewInfo.h
    ├── DebugEventHandlers.cpp
    ├── DebugEventHandlers.h
    ├── Debugger.cpp
    ├── Debugger.h
    ├── Debugger.ui
    ├── DebuggerInternal.h
    ├── DialogAbout.cpp
    ├── DialogAbout.h
    ├── DialogAbout.ui
    ├── DialogArguments.cpp
    ├── DialogArguments.h
    ├── DialogArguments.ui
    ├── DialogAttach.cpp
    ├── DialogAttach.h
    ├── DialogAttach.ui
    ├── DialogInputBinaryString.cpp
    ├── DialogInputBinaryString.h
    ├── DialogInputBinaryString.ui
    ├── DialogInputValue.cpp
    ├── DialogInputValue.h
    ├── DialogInputValue.ui
    ├── DialogMemoryRegions.cpp
    ├── DialogMemoryRegions.h
    ├── DialogMemoryRegions.ui
    ├── DialogOpenProgram.cpp
    ├── DialogOpenProgram.h
    ├── DialogOptions.cpp
    ├── DialogOptions.h
    ├── DialogOptions.ui
    ├── DialogPlugins.cpp
    ├── DialogPlugins.h
    ├── DialogPlugins.ui
    ├── DialogThreads.cpp
    ├── DialogThreads.h
    ├── DialogThreads.ui
    ├── ExpressionDialog.cpp
    ├── ExpressionDialog.h
    ├── FixedFontSelector.cpp
    ├── FixedFontSelector.h
    ├── FixedFontSelector.ui
    ├── FloatX.cpp
    ├── Font.cpp
    ├── Function.cpp
    ├── HexStringValidator.cpp
    ├── LongDoubleX86.asm
    ├── MemoryRegions.cpp
    ├── PluginModel.cpp
    ├── PluginModel.h
    ├── ProcessModel.cpp
    ├── ProcessModel.h
    ├── QLongValidator.cpp
    ├── QULongValidator.cpp
    ├── RecentFileManager.cpp
    ├── RecentFileManager.h
    ├── RegionBuffer.cpp
    ├── RegionBuffer.h
    ├── Register.cpp
    ├── RegisterViewModelBase.cpp
    ├── State.cpp
    ├── SymbolManager.cpp
    ├── SymbolManager.h
    ├── Theme.cpp
    ├── ThreadsModel.cpp
    ├── arch
    │   ├── arm-generic
    │   │   ├── ArchProcessor.cpp
    │   │   ├── RegisterViewModel.cpp
    │   │   └── RegisterViewModel.h
    │   └── x86-generic
    │       ├── ArchProcessor.cpp
    │       ├── RegisterViewModel.cpp
    │       ├── RegisterViewModel.h
    │       └── errno-names-linux.h
    ├── capstone-edb
    │   ├── Inspection.cpp
    │   ├── Instruction.cpp
    │   └── include
    │       ├── Formatter.h
    │       ├── Inspection.h
    │       ├── Instruction.h
    │       └── Operand.h
    ├── edb.cpp
    ├── graph
    │   ├── GraphEdge.cpp
    │   ├── GraphNode.cpp
    │   ├── GraphWidget.cpp
    │   ├── GraphicsScene.cpp
    │   ├── GraphicsScene.h
    │   ├── GraphvizHelper.cpp
    │   └── GraphvizHelper.h
    ├── main.cpp
    ├── qhexview
    ├── res
    │   ├── breeze-dark-edb.qrc
    │   ├── breeze-edb.qrc
    │   ├── debugger.qrc
    │   ├── edb.rc
    │   ├── icons
    │   │   ├── breeze-dark-edb
    │   │   │   ├── 16x16
    │   │   │   │   ├── application-exit.svg
    │   │   │   │   ├── code-context.svg
    │   │   │   │   ├── configure.svg
    │   │   │   │   ├── dialog-close.svg
    │   │   │   │   ├── dialog-information.svg
    │   │   │   │   ├── document-export.svg
    │   │   │   │   ├── document-import.svg
    │   │   │   │   ├── document-open-recent.svg
    │   │   │   │   ├── document-open.svg
    │   │   │   │   ├── edit-clear-list.svg
    │   │   │   │   ├── edit-find.svg
    │   │   │   │   ├── edit-undo.svg
    │   │   │   │   ├── help-about.svg
    │   │   │   │   ├── help-contents.svg
    │   │   │   │   ├── list-add.svg
    │   │   │   │   ├── list-remove.svg
    │   │   │   │   ├── tab-close.png
    │   │   │   │   ├── tab-new.png
    │   │   │   │   ├── view-refresh.svg
    │   │   │   │   └── view-restore.svg
    │   │   │   ├── 24x24
    │   │   │   │   ├── dialog-information.svg
    │   │   │   │   └── distribute-graph.svg
    │   │   │   ├── 64x64
    │   │   │   │   ├── debug-close.png
    │   │   │   │   ├── debug-kill.png
    │   │   │   │   ├── debug-pause.png
    │   │   │   │   ├── debug-restart.png
    │   │   │   │   ├── debug-run.png
    │   │   │   │   ├── debug-step-into.png
    │   │   │   │   ├── debug-step-out.png
    │   │   │   │   ├── debug-step-over.png
    │   │   │   │   ├── dialog-information.svg
    │   │   │   │   ├── memory-slot.png
    │   │   │   │   └── plugin.png
    │   │   │   └── index.theme
    │   │   ├── breeze-edb
    │   │   │   ├── 16x16
    │   │   │   │   ├── application-exit.svg
    │   │   │   │   ├── code-context.svg
    │   │   │   │   ├── configure.svg
    │   │   │   │   ├── dialog-close.svg
    │   │   │   │   ├── dialog-information.svg
    │   │   │   │   ├── document-export.svg
    │   │   │   │   ├── document-import.svg
    │   │   │   │   ├── document-open-recent.svg
    │   │   │   │   ├── document-open.svg
    │   │   │   │   ├── edit-clear-list.svg
    │   │   │   │   ├── edit-find.svg
    │   │   │   │   ├── edit-undo.svg
    │   │   │   │   ├── help-about.svg
    │   │   │   │   ├── help-contents.svg
    │   │   │   │   ├── list-add.svg
    │   │   │   │   ├── list-remove.svg
    │   │   │   │   ├── tab-close.png
    │   │   │   │   ├── tab-new.png
    │   │   │   │   ├── view-refresh.svg
    │   │   │   │   └── view-restore.svg
    │   │   │   ├── 24x24
    │   │   │   │   ├── dialog-information.svg
    │   │   │   │   └── distribute-graph.svg
    │   │   │   ├── 64x64
    │   │   │   │   ├── debug-close.png
    │   │   │   │   ├── debug-kill.png
    │   │   │   │   ├── debug-pause.png
    │   │   │   │   ├── debug-restart.png
    │   │   │   │   ├── debug-run.png
    │   │   │   │   ├── debug-step-into.png
    │   │   │   │   ├── debug-step-out.png
    │   │   │   │   ├── debug-step-over.png
    │   │   │   │   ├── dialog-information.svg
    │   │   │   │   ├── memory-slot.png
    │   │   │   │   └── plugin.png
    │   │   │   └── index.theme
    │   │   └── edb
    │   │       └── index.theme
    │   ├── images
    │   │   ├── arrow-right-red.svg
    │   │   ├── arrow-right.svg
    │   │   ├── breakpoint.svg
    │   │   ├── edb.ico
    │   │   ├── edb.png
    │   │   ├── edb100-logo.png
    │   │   └── edb48-logo.png
    │   ├── lang
    │   │   └── edb_en.ts
    │   ├── themes
    │   │   ├── dark.ini
    │   │   ├── light.ini
    │   │   ├── system-dark.ini
    │   │   └── system-light.ini
    │   ├── themes.qrc
    │   └── xml
    │       ├── functions.xml
    │       └── syscalls.xml
    ├── session
    │   ├── SessionError.cpp
    │   ├── SessionError.h
    │   ├── SessionManager.cpp
    │   └── SessionManager.h
    ├── test
    │   ├── CMakeLists.txt
    │   └── Test.cpp
    └── widgets
        ├── NavigationHistory.cpp
        ├── NavigationHistory.h
        ├── QDisassemblyView.cpp
        ├── QDisassemblyView.h
        ├── RegisterViewDelegate.cpp
        ├── RegisterViewDelegate.h
        ├── SyntaxHighlighter.cpp
        ├── SyntaxHighlighter.h
        ├── TabWidget.cpp
        └── TabWidget.h

```

`BUGS`:

```
This file has been superseded by the issue tracker at: https://github.com/eteran/edb-debugger/issues

```

`CHANGELOG`:

```
NOTE: for future change logs, please refer to the commit logs found at:
      https://github.com/eteran/edb-debugger/commits/master


2011-07-11
----------
* Fixed a typo in the configuration where the close_behavior wasn't getting
  loaded correctly.

2011-07-07
----------
* Environment plugin now can get environment variables when no symbols are found
  it doesn't know the address of the variables, but at least you can view them.


2011-06-22
----------
* Code cleanup, some minor optimizations.

2010-10-16
----------

* Since the tools that ./edb_make_symbolmap is dependant on are not uniform 
  across all the platforms that I intend to support. I have built symbol
  file generation into edb directly. Running './edb --symbols <filename>' will
  create a symbol file in the same format as the old script. For now, ELF is the
  only supported format but more will be added as needed. This also means
  that future versions of edb will be able to generate symbols as needed
  if no symbol file is provided, making things "just work" more often.

2010-10-14
----------

* Improved the way that different OS's are handled in the source tree a bit

* Added more detection of suspicious breakpoints (ones that are likely 
  a user error).
  
* OpenBSD support is now at a functional level. There are some features
  missing, but it is a good start. You can do all of the basic debugging
  tasks now.

2010-10-10
----------

* Reference finder now will find calls/jumps and consider them code refernces
  double clicking those results will jump to the address in the CPU view.
  
* Code in general has now adopted a more clean and consistant style. It is
  a work in progress, but almost all plugin accessible code is conformant.
  
* Compiles and attaches on OpenBSD, but unfortunately cannot step yet. Almost
  functional.
  
* OpenBSD use KVM to get process maps, much cleaner than relying on other 
  meathods.

* The breakpoint API is simpler and has less redundancy between the core and 
  the edb namespace.
  
* Minor fixes for arches that don't support unaligned access. No such arch is
  currently supported, but may as well plan ahead ;-).
  
* New ROP gadget finder plugin. It is in the early stages, but will evolve over
  time. I hope to support some form of automatic shellcode generation in the
  future.
  
* Experimental "run until return" support. This is slow and not always correct
  but a start. It seems that linux delivers a different event when stepping
  over a syscall instruction, so I'm not sure of the best way to address that.
  
2010-09-20
----------

* Lots of small fixes here and there.

* Lots of work towards a working OSX port. It isn't quite there yet, but the
  ground work is being layed.
  
* Fixed a bug in the expression parser.

* Working towards a new improved edisassm API which will make introducing new
  arches much simpler in the long run.
  
* Fixed a hang when trying to use gnome-terminal as the I/O TTY. It's not what
  I consider an ideal fix (string compare to determine what terminal you are
  using), but it appears to be reasonable.
  
* LOTS of small speed tweaks all over the place.

* Did some work trying to get a functional trace mode, in my tests it is almost
  working correctly, but not quite there.

2010-07-02
----------

* Added Ctrl+G shortcut. This is a global shortcut which will activate the 
  "goto" functionality of the widget with the focus.
  
* Made the instruction analysis window update the register values are
  changed by the user.

2010-06-07
----------

* Added the ability to analyze the currently *viewed* region, not just the one
  that the IP is in currently. Also added an "Analyze Here" context menu to the
  cpu view.

2010-05-27
----------

* Added display of fs and gs base addresses. There is not an aweful lot of
  things you can do with this information since you cannot set this value
  directly. But it does provide a nice way to see what the address of the
  what is commonly the TEB/TCB.

* [E/R]FLAGS is now editable again in the GUI. I accidentally disabled this
  in the last release while refactoring some code.

* Much cleaner event model implemented. It is much more robust and simpler too!
  Now handlers simply return codes describing the resume state. The only thing 
  to keep in mind is that if you play with the state in a handler. You almost 
  always have to call edb::v1::syncronizeState() so the resume functions have 
  an up to date view to work with.
  
* Thanks to the new event model, breakpoint conditions work much more reliably.

* Minor optimization in resuming, no longer steps before a resume when it isn't 
  necessary.
  
* NOTE: I believe that I found a kernel bug where stepping in a signal handler
  can cause the target process to have the TF flag set incorrectly. Resulting
  in a purpetual stepping state. I may be able to work around this by 
  explicitly masking the flag in certain circumstances. But I feel this might
  result in other subtle bugs. Hopefully, if this isn't the expected behavior
  the linux guys will have this fixed soon. 
  See: https://bugzilla.kernel.org/show_bug.cgi?id=16061 for details.

2010-05-26
----------

* Fixed decoding of cmpxchg8b in 64-bit mode. It was incorrectly being
  decoded as cmpxchg16b.

* Started working on improving the event model of edb. It will be a lot of
  work, but in the end it will be much more robust
  
* Fixed a fairly major bug, I'm suprised that noone noticed ;) Opcodes which 
  are completely different in 64-bit mode (like 0x06 is "push es" in 32-bit
  but invalid in 64-bit) were not being decoded properly at all. The alternated
  tables were not being linked into the disassembly library correctly.

2010-04-27
----------

* Lots of minor tweaks and code refactoring

* Themes! there is no UI for modifying them, but you can set them up in the 
  config file (~/.config/codef00.com/edb.conf) manually. Basically there is a 
  "[Theme]" section which gets read on startup (a change will need a restart 
  to take effect). In this section  there are a bunch of settings that effect 
  the look of the disassembly which looks like this:
  
	theme.<category>.<property>=<value>
  
  Valid categories are:
  
	register
	constant
	ptr
	prefix
	flow_ctrl
	function
	stack
	comparison
	data_xfer
	arithmetic
	logic
	shift
  
  Valid properties are:
  
	foreground
	background
	weight
	italic
	underline
  
  NOTES:
  
  you may omit any property, which will yield the default value look for that
  property.
  
  foreground and background are colors, this is a string which can be anything
  you can pass to a QColor(const char *) constructor. So, it can take named 
  constants such as "green" or hex color codes like "#00ff00", the special value,
  transparent is also allowed.  See the Qt documentation for the full details.
  
  weight is on a scale of 0 to 99. 50 being normal and 75 being bold.
  
  italic and underline are typical boolean values.
  
  EXAMPLE (this will give the default look):
  
	[Theme]
	theme.register.foreground=red
	theme.register.background=transparent
	theme.register.weight=75
	theme.register.italic=false
	theme.register.underline=false
	theme.constant.foreground=black
	theme.constant.background=transparent
	theme.constant.weight=50
	theme.constant.italic=false
	theme.constant.underline=false
	theme.ptr.foreground=darkGreen
	theme.ptr.background=transparent
	theme.ptr.weight=50
	theme.ptr.italic=false
	theme.ptr.underline=false
	theme.prefix.foreground=black
	theme.prefix.background=transparent
	theme.prefix.weight=75
	theme.prefix.italic=false
	theme.prefix.underline=false
	theme.flow_ctrl.foreground=blue
	theme.flow_ctrl.background=yellow
	theme.flow_ctrl.weight=50
	theme.flow_ctrl.italic=false
	theme.flow_ctrl.underline=false
	theme.function.foreground=blue
	theme.function.background=yellow
	theme.function.weight=50
	theme.function.italic=false
	theme.function.underline=false
	theme.stack.foreground=blue
	theme.stack.background=transparent
	theme.stack.weight=50
	theme.stack.italic=false
	theme.stack.underline=false
	theme.comparison.foreground=blue
	theme.comparison.background=transparent
	theme.comparison.weight=50
	theme.comparison.italic=false
	theme.comparison.underline=false
	theme.data_xfer.foreground=blue
	theme.data_xfer.background=transparent
	theme.data_xfer.weight=50
	theme.data_xfer.italic=false
	theme.data_xfer.underline=false
	theme.arithmetic.foreground=blue
	theme.arithmetic.background=transparent
	theme.arithmetic.weight=50
	theme.arithmetic.italic=false
	theme.arithmetic.underline=false
	theme.logic.foreground=blue
	theme.logic.background=transparent
	theme.logic.weight=50
	theme.logic.italic=false
	theme.logic.underline=false
	theme.shift.foreground=blue
	theme.shift.background=transparent
	theme.shift.weight=50
	theme.shift.italic=false
	theme.shift.underline=false
	theme.system.foreground=blue
	theme.system.background=transparent
	theme.system.weight=75
	theme.system.italic=false
	theme.system.underline=false
  
2010-04-01
----------

* Made the copy operation of QHexView widgets do an ascii rendering of what the
  user has selected, this is infinitely more useful.
  
* Re-added the jump/call target symbol display in the disassembly view. This
  was accidentally chopped when I added syntax highlighting.
	
2010-03-31
----------

* Code cleanup

* Fixed potential memory corruption in symbol management code (could not
  demonstrate it, but technically it was possible).
  
* Added some options to the DumpState plugin

* The DumpState plugin now uses the current data view tab as the basis for
  its "data" portion of the output
  
* Got rid of the insanity of having "ctrl+c" mean "check version". :-P

* The BreakpointManager is no longer a modal dialog.

* Improved const correctness of some things

* Fixed corner case where the UI wouldn't update immediately

2010-02-26
----------

* Added support for highlighting of flow control commands

* Next version will allow "schemes" in the same sense that ollydbg does
  you will be able to edit the configuration file to adjust the colors to your
  liking.

2010-02-25
----------

* Added support for comments for bookmarks

* Fixed a bug where the UI didn't update immediately after closing the config
  dialog
  
* syntax highlighting in the CPU view!

2010-01-15
----------

* Added "Add Bookmark" to CPU view context menu.

2009-12-28
----------

* Too many small changes to list here :-P

* Increased minimum Qt version from 4.2 to 4.5. Now that 4.5 is widely deployed
  I think this is a reasonable requirement.

2009-10-19
----------

* Fixed builds on some systems.

* Made it so you can load plugins in any order and they should work just fine.

* Disabled graphing capabilities for this release. Unfortunately, graphviz
  has made a habit of breaking source compatibility in there C API which means
  that the build will break on some systems. I may need to add some sort of
  configure script in order to make this work correctly on all supported systems
  :-(.

2009-10-17
----------

* Fixed a crash if edb was set to use a terminal for I/O, but the program
  field was empty.
  
* Many small optimizations.

* A little bit of reorganization in the source tree.

* More steps towards good thread support.

* More functional in Win32 builds (still not good enough yet, but getting 
  closer)
  
* Heap Graphs! Sometimes they take a really long time to render, but they work
  and can show relationships between nodes!

2009-09-10
----------

* A few portability tweaks, working on creating a proper visual studio project
  file eventually.
  
* QHexView and QDisassemblyView now format the address based on the size of
  address_t instead of the native pointer size of the machine. This will allow
  the possibility of future builds being able to do remote debugging and/or
  debugging of 32-bit apps on a 64-bit platform.

2009-08-17
----------

* Fixed a crashable dead reference usage in Analyzer/FunctionFinder plugins.

* Improved the way that stop codes are handled internally, should make for
  cleaner code.
  
* Some of the bigger operator new usages have exception guards. They shouldn't
  be needed in 99% of cases, but it's better to not crash :-P.

2009-08-11
----------

* Lots of minor code improvements.

* Fixed conditional Breakpoints.

* Fixed HW Breakpoints (I think).

2009-07-16
----------

* Improved the way plugin options pages are shown.

2009-07-13
----------

* Instruction<> objects are now "copyable", this is a somewhat expensive
  operation, but is the first step towards making edisassm support being an
  assembler as well (since it will return an Instruction object).

2009-07-11
----------

* Made DebugEvent object a bit smarter as far as the info they carry with them.
  This should simplify things a bit.
  
* Now passing DebugEvent by reference to handlers. I couldn't before because
  the events were coming from the "Event Thread" but now that that is phased out
  it is more efficient to pass them this way.

* Changed the binary info plugins to be based on looking at a region, not a file
  this is more flexible as it will allow it to analyze data which is only seen
  at runtime.

2009-07-09
----------

* Seems that older versions of gcc have slightly different behavior with 
  regard to exported embedded classes. Minor update

2009-07-08
----------

* Heap analyzer now uses a linear search for the heap structures. This seem to 
  work nicely for both x86-64 and x86 arches.
  
2009-07-03
----------

* Added code to the heap analyzer to have it work with newer versions of glibc.
  I should probably have some sort of search method instead of fixed offsets,
  or better yet, do something reliable :-P.

* Provided a means for plugins to add tabs to the options dialog. The
  CheckVersion and Analyzer plugins now use this feature.
  
* The analyzer now has the option of not using "fuzzy" logic to find functions.
  Without fuzzy logic, it is *much* faster and the results are very high
  quality (since it only searches for functions reachable from known code). But 
  will find much less. The default is to use fuzzy logic.

2009-07-01
----------

* Analyzer is *much* faster than it was, and more accurate in finding functions.

2009-06-30
----------

* More work done to the core to help add thread support (not quite there yet).

* Working on cleaning up the conditional BP stuff, making it more robust.

* I believe that I have fixed the restart occasionally failing issue. Turns out
  that you should do a waitpid() after a detach to avoid getting events from the
  previously debugged process.

2009-06-20
----------

* Enabled UTF-16 support in base string searching routines. For now, it only
  will find strings which use the basic ASCII character set. Eventually I'll 
  find a good technique for finding non-english language strings as well.
  
* I Finally figured out how to safely catch SIGCHLD when using Qt4. This has
  enabled me to implement a version of waitpid which has a timeout! I am hoping
  that this proves to be nice and stable to I can finally phase out the
  "Event Thread." Which is necessary since ptrace really doesn't play nicely
  when different threads are used.

2009-05-29
----------

* Once again revised the plugin API. Now that the win32 build produces an
  edb.lib file, the original style is more appropriate. So once again, plugins
  can directly access the exported API. However, only the classes and functions
  which are part of the stable API will be exported since edb is now compiled 
  with -fvisibility=hidden.
  
* Cleaned up a lot of code now that the plugin system is simpler.

* Internal management of breakpoints is now simpler. Now I use shared pointers
  to BP objects which use RAII techniques. This has made the code which manages
  breakpoints MUCH cleaner :).

* Fixed a crash when removing breakpoints via the breakpoint manager plugin.

2009-05-27
----------

* Fixed the current line being outside of the disassembly view in certain
  circumstances.

2009-05-26
----------

* Added display of symbols in the code view.

* Added the basis for future colorization in the disassembly.

* Improved the way uppercase disassembly is handled. Most visibly, hex strings
  are displayed like "0xDEADBEEF" instead of "0XDEADBEEF" making this much more
  readable in uppercase mode.

2009-05-15
----------

* Fixed crash during initial config if it couldn't find the DebuggerCore plugin.

2009-04-14
----------

* Added the undocumented SAL opcode to edisassm.

2009-03-30
----------

* Fixed a bug in edisassm's disassembly of operands of type Ob and Ow.

2009-02-10
----------

* Moved the session handler code to be a plugin now. This will allow more
  creative session implementations. For example, the session files could
  be actually in a sqlite3 database, or even a mysql database for collaborative
  commenting. It should be much more flexible.

2009-02-04
----------

* Fixed a bug in the memory region modification code. It would ask if you wanted
  to remove the execute permissions of the last executable region any time
  there was only one left with execute permissions. This was the case even if 
  the region you wanted to modify wasn't executable to begin with.
  
* Started using boost::bind a lot more to make the code much more concise. Doing
  this will allow me to make a lot of the "search memory" code be run by a 
  std::for_each calling a function object. The nice thing about this is that
  it will nicely match the way that Qt's concurrent model. Making for a smooth
  transition.

2009-01-23
----------

* I've decided to start using boost (particularly smart pointers) wherever 
  appropriate. It will help make the code less likely to have bugs. Once Qt 4.5
  is out for long enough, I'll likely switch over to them their smart pointers
  since there is no point in having multiple library dependencies. But I feel 
  that boost is such a robust library, it would be silly not to take advantage 
  of it.

2009-01-22
----------

* Implemented the "Find ASCII string in stack" feature. Works like a charm. 
  To be clear, it is searching for pointers to matching strings on the stack,
  no strings in the stack itself. I *think* this is what people would want.
  Also, it only cares if the the search string is the beginning of the string
  on the stack (so if you look for "/bin/" it'll find "/bin/ls"). This is
  because there could be any amount of data (or characters) after the string
  on the stack.

* Added the ability for plugins to add items to the various context menus. This
  should allow much more useful plugins in the future. Starting with the 
  recently requested "Find ASCII string in stack" feature.

2009-01-08
----------

* Reorganized much of the DebuggerCore code into separate platform specific
  files to make things much easier to maintain.

2008-12-28
----------

* Imported some code provided by Phillip Mayhew which is the beginning of a 
  OSX port. He provided almost all of the functionality necessary to get the
  DebuggerCore plugin to be functional. Now I'll just have to start testing
  on a Mac soon.

2008-12-11
----------

* Fixed defunct process issue on kill/restart (missing waitpid)

* simplified a lot of code involving starting and stopping things. I used to
  delete/create objects each time. But simply stopping/starting them is 
  sufficient and means that I can do less NULL checks. 
  
* Simplified the event loop.

* Replaced all dynamic_cast's with qobject_cast's which don't require rtti.

2008-12-10
----------

* New plugin system is complete and things are working normally again. A few 
  internal functions take more parameters but it decouples those parts from the
  rest of the system.
  
* Windows port is now able to attach and (usually) step.

* Improved portability of error handing system.

2008-12-08
----------

* Started to make some large changes to how plugins interact with the core
  application. Not all platforms I'd like to target support having a plugin
  import symbols from the application that is loading it
  (*cough* windows *cough*). So now there is a "PluginAPI" structure which is
  passed to every plugin upon init which it will make a copy of (the interface
  code does this for you and makes it accessible through an m_API variable).
  
  This new system allows me to have much more strict control over what a plugin
  is allowed to do within edb which is nice, but it also will require I have a 
  "Core Library" that all plugins and edb will have to link to in order for 
  them to share classes which unfortunately means a little bit of binary code 
  duplication. Oh well.

2008-12-07
----------

* Added a messagebox warning when the arch edb was built for doesn't match the 
  target process's arch.

2008-12-06
----------

* More changes to support Win32/Win64

* Fixed a crash when no analyzer plugin is available.

* Started framework for supporting UTF16 strings in analysis. Currently it's a 
  lot of boxes and such, but I beleive it is working generally OK.

2008-12-05
----------

* Made some minor changes to the edisassm.pro file

* Reworked some function definitions to work around a visual studio bug.

* edisassm *finally* builds with visual studio 2008! Time to start porting edb 
  to windows :-)

2008-11-14
----------

* Improved the ebuild on 64-bit platforms.

* Fixed search and replace error with default plugin path, it should work 
  correctly now.

* Minor improvements to the html documentation.

2008-10-20
----------

* Right clicking in the register view will no longer show "Follow In ___" 
  options for things such as segments, eflags and FPU values. these do not
  have meaningful values as addresses.

2008-10-14
----------

* Fixed a bug where some old stub code from before the 64-bit port was breaking
  any instructions which use the FS or GS segments :(.
  
* Made the find ASCII string routines more intelligent about what they consider 
  to be an "ASCII" character. The output is a lot more comparable to the unix
  strings command.

2008-10-08
----------

* Switched from edb::v1::log to qDebug. The nice thing about this is that it 
  functions very much the same as my old logging. But also supports stream
  oriented logging. Finally, it is "hookable" so that a widget could be used to
  show the logging in a widget if we want.
  
* Made several string displays a bit more Unicode friendly. This most visibly
  results in "high" ASCII characters no longer appearing as junk.

2008-10-06
----------

* Started prepping the code for internationalization, this will be an ongoing 
  process. Once the process is started and I have at least one non-english
  translation, then it will be helpful if people report un-translated strings.
  But we aren't quite ready for that yet ;).
  
* Fixed a 64-bit compatibility bug in the breakpoint plugin.

* Sped up heap analyzer a lot by disabling updates during population.

2008-10-01
----------

* Fixed a bug introduced in last version where several entries for 0x00000000 
  were be entered in the function finder plugin. This was actually a bug in
  the analysis engine where I failed to notice the side effects of reading a 
  map using the [] syntax.
  
* Made it so the symbol viewer plugin will by default open up symbols for code
  in the disassembly and data in the data views when double clicked.
  
* Vastly improved the analyzer's handling of symbol information in its function
  search algorithm.

2008-09-29
----------

* Added context menu to Symbol viewer's list so that you can select where to 
  view the symbol in.
  
* Added a plugin management window. Currently, it just lets you see what's been
  loaded. But in the future, I will try to make it so you can disable/enable
  different plugins.

2008-08-29
----------

* Attempt #2 at making the /lib/ vs. /lib64/ automatic for 64-bit platforms. I 
  think the new solution should work.

2008-08-25
----------

* Added the ability for edb to get the base of the GS and FS segments. This 
  allows the instruction analyzer to correctly display the values of certain 
  expressions. This also makes segments valid in expressions, they will resolve
  to the base of the segment. Though CS/DS/ES/SS will always resolve to 0.
  One nice trick is that you can break on each system call by putting a 
  breakpoint on [gs+0x10] (though 0x10 may vary from system to system).

2008-08-16
----------

* Finished making the Heap Analyzer plugin work on x86-64.

2008-08-12
----------

* Sped up analysis by avoiding redundant function analysis. It still isn't 
  blazing fast, but is significantly better.
  
* Fixed a few previously missed 64-bit portability issues. 
  (toULong -> toULongLong). They were minor, but all of this type should be
  resolved.
  
* Added a symbol viewer plugin. Double click to see a symbol's value in the
  the current data view. Eventually, I'll add a context menu to make it
  so you can view it in the code view too depending on the type.

2008-08-11
----------

* Continued to make improvements to analyzer. It is more accurate, but also
  slower at the moment. I will look into good ways to speed it up.

2008-08-10
----------

* Fixed some compilation issues on x86-64. Thanks to Stephan Hegel for working
  with me to make sure that x86-64 users have a functioning edb.
  
* Reworked analysis to have a higher initial favoritism towards findings
  functions by recursively tracing known functions 
  (symbols/main/entry point, etc). This will make the analysis more accurate
  though it does have the side effect of making "percentage complete" at lot
  less meaningful since while it will always stop, the number of iterations
  during analysis is indefinite.

2008-08-09
----------

* Seems that <QtGlobal> needed to be included in QDisassemblyView.cpp for x86-64
  targets. Simple fix, but it broke compilation for some platforms so I'm going
  to make a release for it.

2008-08-08
----------

* Ouch, another bug fix. At least this time it was a failed assert. Basically,
  during my last fix, I forgot that reads can and will fail if done while the 
  debugee is running. I have added code to special case this and handle it more
  correctly. (Which is of course how it used to act in the first place).

2008-08-04
----------

* made plugins.pri smarter with library location. For 64-bit builds it will
  default to $prefix/lib64/edb/

2008-07-29
----------

* Since the config file was partially broken, I am taking this opportunity to 
  finish reworking the naming convention for settings. Some settings will
  unfortunately be lost. But odds are they were being dropped anyway :-/.

* WOW, I just noticed that for a long time (2-3 versions) options were not being
  actually saved. Fixed.

* Seems that my QDisassemblyView optimization revealed an off by one error in 
  the DebuggerCore which unfortunately was also crashable :(. But I believe 
  that the logic is correct now. I've added a few more asserts to help avoid 
  this type of bug in the future.

2008-07-25
----------

* Made analysis slightly faster by factoring out some no longer needed code.

* Simplified some code in the QDisassembler widget. Instead of passing an 
  instruction, its buffer and its size, you can now just pass the instruction
  since it has references to the buffer and its size anyway.

* Made the analyzer aware of using zeros as padding between functions. This will
  make the display more correct if displaying analyzed code.

2008-07-15
----------

* Added "Follow Immediate in Dump" and "Follow Immediate in Stack" CPU context 
  menus. They act similarly to the generic "Follow" CPU context menu.
  
* Improved analysis speed.

* Improved analysis quality, a few more types of common optimizations are 
  detected.

2008-07-13
----------

* Added a "Follow" item to the CPU context menu. Basically, if you right click
  on either a JMP or CALL which has an operand which can be evaluated, then 
  there will be a "Follow" menu item that will scroll the CPU view to that 
  location.

2008-07-12
----------

* Removed some code which was implemented to work around Qt 4.0.x bugs since
  4.2 is now a base requirement.

* Added some atomic-ness for pointer manipulations.

* Renamed some settings in configuration file to make them more consistent with 
  new convention.
  
* Fixed a integer underflow crash involving trying to select an address beyond 
  the end of a region. Which was causing a negative size to be passed to the
  "edb::v1::getInstructionBytes" function. Q_ASSERTS were added to catch this
  in the future if a similar bug is present elsewhere.
  
* Fixed a minor bug where tooltips would show data outside of the current 
  region if there is an adjacent region sometimes.
  
* Now attaching to a new process or opening a new program to debug will 
  invalidate any analysis that has been done. Eventually, the analysis will be
  stored in session files so that it can be reused. But not yet ;).

2008-07-05
----------

* more minor improvements to the analysis engine.

* Fixed a corner case in the disassembler where it would misformat things like
  "and eax, 0xffff" as "and eax, -1" due to a mis-optimization.

2008-07-03
----------

* Improved the analysis engine to be slightly more accurate.

* Added graphical indication of function bounds based on analysis results.

* You can now scroll the QHexView widgets by individual bytes by pressing up
  or down while holding the control key.

2008-07-01
----------

* Centralized analysis engine and provided it with a plugin. The FunctionFinder
  plugin is now just an interface towards it. Ctrl+A will analyze the current 
  region (though nothing is done with the results yet). I am hoping to have 
  function framing and scrolling by instructions.

* Added a "set EIP to selected instruction" to CPU context menu.

* Improved hueristic for analyzer. It will now more accurately identify certain
  types of functions.

2008-06-18
----------

* Fixed a bug in the hardware breakpoint manager plugin which didn't allow
  disabling of the last breakpoint.

* Extended the maximum size that OpcodeSearcher will consider from 4 bytes to 
  8 bytes, which yields some more options.

* Finished changing OpcodeSearcher plugin to use edisassm, it should be a lot 
  more robust now. Forutnately, edisassm is pretty fast, so the performance 
  impact isn't too bad.
  
* Most dialogs use Qt 4.2.x's QDialogButtonBox's now which should give a better
  look on non-KDE platforms.

2008-06-12
----------

* Fixed a bug in DebuggerCore involving hardware debug registers in 64-bit mode.
  this fix allows hardware breakpoints to work in 64-bit builds.
  
* Changed OpcodeSearcher plugin to use edisassm when searching instead of hard
  coded values. This allows the code to be more easily ported to new archs such
  as x86-64.

2008-06-06
----------

* Fixed minor bug with selections in QHexWidgets when selecting outside of the
  viewable range. There was an underflow, which was cast to an unsigned type
  causing some upward selections to select from start to the end of the range.
  
* More improvements in 64-bit support. The ArchProcessor for x86-64 is now
  aware of the amd64 C calling convention and will now properly predict function
  arguments for when symbols are available.

2008-06-01
----------

* Hardware breakpoints are much more complete, supporting Write, Read/Write, 
  and Execute types of 1, 2, and 4 bytes sizes.
  
2008-05-31
----------

* edisassm 1.5.2 released, mostely making the code more standards compliant to
  ensure that the code will compile on newer versions of g++.
  tested with 4.2.3 on Ubuntu.
  
2008-05-28
----------

* edisassm 1.5.1 released with some minor bug fixes

* Corrected some bugs in edb under x86-64 involving the analysis engine.

2008-05-28
----------

* edisassm 1.5.0 released with EMT64 support! A lot of time was put into 
  verifying the instruction tables to ensure that disassembly would be accurate.
  
* A couple of minor bug fixes were done in edb.

* Added patches to clean up build on ubuntu systems.

2008-05-18
----------

* Added LOTs of SSE4 ops to edissasm, updated a bunch of the tables.

2008-05-07
----------

* edisassm now can handle RIP relative addressing mode. I also fixed some decode
  ordering issues that were introduced when 64-bit mode was being added. The 
  only piece left is the tweaking of the instruction tables to match what was 
  added/removed/changed for 64-bit mode!

2008-05-06
----------

* edisassm now can disassemble 64-bit code partially correct. It does not yet
  support RIP relative modes and does not take into account changes in the 
  opcode map (new and removed opcodes). Soon edb will have full 64-bit support!

2008-04-30
----------

* Made a large effort to port edisassm to 64-bit :) The most visible change
  is that is makes much larger use of templates. Instruction and Operand now 
  take a template param (32 and 64 are valid). which can be used like this:
  Instruction<32> inst(buf, size); or you can use edb::Instruction which will be
  be typedefed to the appropriate type based on your build environment. Because
  of the massive ammount of templating needed to implement this, it is possible
  that older compilers will have trouble with it. I will test which compilers
  are expected to work.

2008-04-11
----------

* Renamed REG_NONE to REG_NULL to avoid a conflict with windows headers.

* Got edisassm compile on win32 for the first time :)

2008-03-24
----------

* Improved some of the function finder code, I am planning on moving this to a
  more central analysis system.

2008-03-15
----------

* Fixed some incorrect bit setting in HW breakpoint code.

2008-03-14
----------

* Improved the HW breakpoint code. It will now show the enabled state based on
  what the application is actually in. So if you do something like reset the
  application, then the HW breakpoints will show as disabled (because they are).
  
* Some general code optimizations.

2008-02-29
----------

* First code for hardware breakpoints is in, edb can now set a hardware bp
  and resume from it, next is setting the proper type of bp (read/write/execute)
  as needed and also making the dialog show correctly even when application
  has been terminated or restarted.

2008-02-27
----------

* Simplified some signal code in QHexView and Bookmarks plugin.

* Started some very preliminary work on the hardware breakpoint plugin. So far
  I have the GUI planned out for it. It will likely require that the plugin 
  hook the debug event system in order to enable resuming after hitting the BP.
  This is ok though since there is an infrastructure in place for that :).

2008-02-25
----------

* Improved handling of breakpoints which aren't caused by int3 bytes placed by
  edb. for example: "int 3" (which encodes as 0xcd 0x03) is now handeled more
  correctly.
  
* Preliminary code for hardware breakpoints is in place, the DebuggerCore is now
  able to get/set the debug registers on intel. The only real hurdle left is
  continuing after it is hit. This will need a similar system to software 
  breakpoints.

2008-02-15
----------

* Made some changes to help with portability.

* Made edisassm use std::ifstream instead of mmap.

2008-02-12
----------

* Simplified the expression code a bit by factoring down common code a bit. This
  results in a slightly larger binary, but smaller source (due to small function
  inlining). I think this is fine since the code is more managable.
  
* Fixed expressions handling of the XOR operator "^". It was not properly 
  implemented.

* Moved the known function table to a plugin. It isn't super efficient quite yet
  but works well.

2008-02-10
----------

* Made the columns in the disassembly view movable when mouse is 2 or less 
  pixels away from from the line, not just exact match. This should make it an
  easier target.

2008-02-08
----------

* Made DebuggerCore::readPages account for breakpoints in its results.

* Fixed a bug where reads/writes could return success when they couldn't read
  this resulted. Fortunately this really didn't effect the result of any 
  operations.

2008-02-06
----------

* applied patch from elitak@gmail.com to plugins.pri to help avoid build errors
  on certain configuration.

2008-01-28
----------

* updates Qt dependancy to be for version 4.2 or greater. There are a few 
  features of Qt that I have held off from using or have worked around in the 
  past. The next version (0.9.0) will no longer compile on versions lower than
  4.2

2008-01-24
----------

* Fixed more bugs in edisassm, it was some SSE opcodes where Intel docs claimed
  both operands have be Mod/RM, in which case I have no idea what the proper
  thing to do is. So, it is now in sync with what sandpile.org says, which 
  matches other disassemblers output. I have also added a regression test for
  this.
  
* You can now see symbols in the disassembler view if you move the left most 
  line right. By default it will look as usual. But in a very similar way to 
  ollydbg, you can now see known symbols next to addresses.
  
* Improved function finder plugin. It will now give "bonus points" to functions
  which have known symbols.
 

2008-01-19
----------

* Fixed a harmless crash when edb failed to load the debugger core plugin. This
  was introduced in the last release :(.

2008-01-17
----------

* For builds on Qt >= 4.3, you can now give a tab a label but right clicking
  on it.

* Made the QHexView and QDisassembly widgets use the system palette colors.
  This will make it so edb will match the prefered color scheme of the user.

2008-01-16
----------

* Fixed a potential crash on shutdown in the cleanup code

* Fixed a silly crash where if you ran the function finder with no selected 
  region (or if you are not attached to a program) it would crash.

2008-01-15
----------

* Fixed a bug in ModRM/SIB decoding where in some cases the index and base were
  inversed. This only really showed up in the less used redundant encodings, so
  it didn't show up until I started my regression tests.

2008-01-14
----------

* Fixed a bug in edisassm where it would think it didn't have enough space in
  the instruction buffer when prefixes are used.

2008-01-13
----------

* Added a graphical indicator of the direction for relative jumps.

2008-01-12
----------

* Improved load time.

* Fixed some very minor bugs in the disassembler.

* made disassembler differentiate between the different versions of ins/outs.

2008-01-10
----------

* Fixed a bug in edisassm where 32-bit signed offsets which have the 16-bit 
  set were being printed as 16-bit sign extended values.
  
* Added some regression tests to edisassm. Unfortunately nasm and edisassm 
  disagree on some syntax points and likes to re-order expressions sometimes, 
  so I'll have to come up with some normalization strategy before it can be
  fully automated. But it's a start :).


2008-01-03
----------

* Fixed a bug where if you used the fill feature ontop of a breakpoint it
  would not properly clear the breakpoint first.

2007-12-12
----------

* Moved the ELFxxBinaryInfo classes to plugins. This is more modular and makes
  it far simpler to add new BinaryFile handlers in the future.

2007-12-10
----------

* Added command line running of a program. You may write things like this:
  $ ./edb --run /bin/ls /etc /bin
  and it will start edb attached to a new instance of /bin/ls with the correct
  arguments passed.

2007-12-06
----------

* Fixed a display bug (Bug #37) where it was possible to make the data tabs show data to
  a region which does not exist after detaching (showing all 0xff's).

2007-12-03
----------

* Changed some code to convert numbers to toULongLong instead of toUInt to 
  ensure that when 64-bit is supported, addresses will be interpreted correctly.

2007-11-31
----------

* Ported the dump state plugin to be able to compile correctly on x86-64.

2007-11-29
----------

* Added code to load/save session files (which are currently mostely empty)
  This will read the file header, check it for the session signature, md5 the
  file in the sessiona and compare that to the md5 of the currently debugged
  application. This way, it should never load a session file for the wrong
  application. Next, I'll be adding useful data to the session files, for
  starters I plan on having sessions remember breakpoints and bookmarks.

2007-11-28
----------

* EDBTypes.h is now Types.h this will include the OSTypes.h and ArchTypes.h
  files, this makes adding new arch and os combinations much easier.

* Made various input dialogs accept 64-bit values when building on an x86-64 
  platform.

* Made many changes to help in portability to other platforms. edb will likely 
  be ready for x86-64 within a version or two. The big stumbling block left is
  edisassm support for proper disassembly.

2007-11-27
----------

* Now that I discovered that Qt has a qmake variable (undocumented) which 
  represents the arch it is being compiled on. I have started work on dividing
  the code which is arch specific into special arch dirs, one for each build 
  target (i386 is only which compiles, but it's a start). This should really
  help with porting to new targets.
  
* Started very beginning work towards a session file concept. I have mostely
  fleshed out what I want the file to look like.

2007-11-24
----------

* EDBTypes.h will now define some macros based on the arch it beleives it is 
  being built on such as EDB_X86_64 or EDB_X86. Also, it will define EDB_FMT_PTR
  which is a format specifier suitable for printing an edb::address_t type.
  
* DebuggerCore now compiles on x86-64, however there is still much work left to
  be done. I need to add x86-64 support the the disassembler, and to a few other
  arch sensitive areas.

2007-11-20
----------

* Added preliminary code for "--run" option which will allow the user
  to execute a program and attach to it from the command line, for example:
  $ ./edb --run /bin/ls /etc
  which would run /bin/ls with "/etc" as it's argument and attach to it.
  This code is not functional yet.

* Added new findPluginByName to plugin API. This should allow some basic
  for of dependancies to plugins. This should not be used until plugins are
  fully loaded because there is no gaurantee as to the order of loading yet.
  So, as a good rule of thumb, don't use it in the plugin constructor.
  Hopefully, this will lead to more code reuse and maintainability.

2007-11-15
----------

* Added identification of jump sources to instruction analysis. Now whenever 
  stopped on an instruction, it will attempt to find out if a nearby relative
  jump has a target equaling the the instruction you are stopped on.

2007-11-14
----------

* Setup new bugzilla for edb at: http://bugs.codef00.com/

* Implemented locked stack feature. It will stay locked at the position of the
  stack pointer (unless the stack pointer jumps to a whole other memory region) 
  when enabled.

2007-11-08
----------

* Added preliminary support for resizing the columns in the disassembly view.

2007-11-07
----------

* Fixed a bug in the disassembler where it would ignore the displacement of
  an opcode encoded in a particular way.


2007-11-06
----------

* Added option for CheckVersion plugin to automatically check for newest version
  on startup. It will not report anything if you are running an up to date 
  version of edb. This feature is enabled by default. You can disable this 
  feature by unchecking the menu item for it, found at: 
  "Plugins" -> "CheckVersion" -> "Check On Start". When enabled, the plugin 
  will perform a single HTTP get request to retrieve the latest available 
  version number each time edb is started.

2007-10-23
----------

* Worked on developing function and code analysis. I now have developed an 
  algorithm which can do reasonable accurate degree which bytes are actually
  code bytes. Basically the concept is first to enumerate potential functions
  by disassembling at each possible address in a region. For each call I see I 
  add it to a list and increase its reference count. Then for each function with
  2 or more references, I do further analysis. While reviewing these functions 
  with 2 or more references, I follow the code looking for the function end. If
  I see any calls to functions with a single reference, then they get a bonus 
  reference and are re-added onto the list of calls to analyze. For now, the 
  primary goal is to figure out the actual code bytes and bounds of the 
  functions. Next I will try to identify the conditional logic in the functions.
  
* Fixed duplicate error reporting on some invalid expressions.

2007-10-20
----------

* Added a heuristic for locating the heap start when using a newer ld. It isn't
  100% reliable, but seems to work "ok", I am hoping to solidify more checks 
  in the future to make it more reliable.

2007-10-11
----------

* Made some changes to the plugin API in order to help move towards 
  a stable 1.0 API.

2007-10-09
----------

* General code cleanups and optimizations

* Added support for arguments with spaces in them. Arguments with spaces are 
  specified with quotes, and if you need to have a quote character in the 
  argument then you can escape it with \.

2007-09-17
----------

* Added shortcuts to bookmarks (Ctrl + N will trigger the first 10 bookmarks).

2007-09-14
----------

* Fixed a bug where I accidentally was copying from a QByteArray directly 
  memcpy. It worked because the data array was the first class variable, but
  was not correct in principle.

2007-09-10
----------

* Corrected a minor bug where the GUI didn't update correctly when using the
  stack widgets push/pop menu items.

* Made Debugger::log a variadic function, this allows for passing formatted 
  output directly without a temp, allowing for cleaner code.

2007-09-08
----------

* Focused on optimising the code in certain locations.

* FunctionFinder now uses the new readPages interface.
  This costs more memory, but seems to be more than twice as fast :).

2007-09-05
----------

* BinaryStringSearch and ReferenceSearch now use the new readPages interface.
  This costs more memory, but seems to be more than twice as fast :).

* Added a readPages routine to the DebuggerCoreInterface, since reading large 
  blocks of data can be done more efficiently that individual bytes.

2007-08-28
----------

* Fixed a bug where edb would hang if the TTY console specified in the options
  does not exist. It defaults to "/usr/bin/xterm". Thanks Dmitry Bulashev for
  reporting!

2007-08-27
----------

* Corrected a minor bug where the core plugin would report success when trying
  to read when not attached.

* Bookmarks plugin can now take expressions.

2007-08-26
----------

* Added cool "data dump" plugin as per 0xf001s request :). Just hit ctrl+D and 
  it'll shoot out a dump similar to GDB to stdout.

* Added the ability to skip in-accessible regions (permissions currently "---")
  to both the reference search and the binary string plugins. Some applications
  such as wine like to create dummy regions like this. It should make the 
  searching a little more bareable.

2007-08-20
----------

* "Filling" instructions, as in functions which either have no real effect, 
  and/or are usually used to fill the space between functions are now displayed
  in grey. This makes seeing where function boundaries are easier.

2007-08-20
----------

* Added pointer detection to heap analysis.

2007-08-18
----------

* Tables with numeric content columns are now sorted numerically.

* I am working on stabalizing the programming API, BaseTypes:: and Debugger:: 
  namespaces will be merged and renamed to edb::. The contents of Debugger:: 
  will be located in in edb::v1:: to indicate version 1 of the plugin API. This
  way plugins will have a nice clean way of knowing which version of the API
  they are using. Functions in edb::v1:: will never be removed, after 1.0 is
  released.
  
* Corrected a bug where step over didn't work if you were on a breakpoint.

2007-08-16
----------

* Corrected copy and past bug in FunctionFinder plugin menu item name.

2007-08-15
----------

* updated some of the documentation.

2007-08-14
----------

* Added a "bookmarks" plugin, which allows you to put code addresses of your
  choice into a list, which you can later jump to. This plugin also serves
  as an example of how to add dock widgets to the main gui in a safe manor.

* Fixed a subtle crash caused by debugging an app, opening a plugin dialog, then
  detaching, and eventually debugging a new process (which not closing the
  dialog.
  
* Added a new "function finder" plugin. Suprisingly accurate. It includes a
  "reference count" column which is how many potential calls to this function
  the plugin saw. The higher the number, the greater the confidence that it is
  really a function entry point.

* Speed increases.

2007-08-13
----------

* Changed some of the global objects from pointers to references, this will
  reduce the need for null checks in many situations as well as simplify code.
  
* added wait for console process to die before closing for a better cleanup.

2007-08-10
----------

* Fixed accidentaly reference of breakpoint data after it was free when using
  one time breakpoints. Dangling pointers are no bueno!

2007-08-09
----------

* Removed references to Qt 4.3 features from UI files.

2007-08-08
----------

* Fixed a crashable bug introduced in last version, this was related to clearing
  the process state variable. Now that the state has virtual functions, it is
  no longer correct to use memset.

* Added search filter to the opcode search plugin so you can find the region you
  want to search more easily.

* Added search filter to the strings plugin so you can find the region you
  want to search more easily.

* Made the MemoryRegions object also a QAbstraceItemModel, suitable for a 
  QTableView. This should make it simpler/cleaner to display a table of
  available regions (there were already 3 copies of the code to fill the table
  in edb which will now no longer be needed, in addition to making the filtering
  code MUCH simpler since Qt can do it for us.

2007-08-06
----------

* Improved the build system a little for plugins. They now all share common 
  portions.

* Added ascii string display in heap viewer plugin. Now if, the heap block 
  contains an ascii string, it'll be displayed in the data column. I plan to
  add more types of known "data" to this column over time.

* Added a filter to the environment viewer plugin so you can quickly find the
  variable you are looking for.

2007-08-02
----------

* Conditional MOVs are now part of the instruction analysis, it will display 
  whether or not the MOV will be performed based on the current flags.

* I am making the config file entries use a more organized naming convention in
  the past they were very ad-hoc, but now i am going with namespaces. For 
  example: debugger.terminal.enabled=true. For now this will only apply to new
  settings so no one loses settings, but the old names will eventually be phased
  out in 0.9.0 which is when I will start to stabilize the varying APIs in edb.

* The view options for the stack and data views (word width/row width/which 
  columns to display) are now stored in the config file and restored on reload. 
  Data view is stored as well but is based on the options dialog because saving 
  the options set in the context menu makes no sense (many tabs, which to use).

2007-08-01
----------

* Added different binary fill options to the CPU context menu. Good for REMing
  out individual ops quickly.

* Command window program is now configurable in the debugging options dialog.
  You can enable/disable it, and you can use the terminal program of your 
  choice. The default is /usr/bin/xterm, as this should be fairly ubiquitous.
  "konsole --nomenubar --notabbar" works well for us KDE users out there as 
  well. The only real rule is that whitespace is assumed to be an argument 
  separator and bad things may happen if you try to be clever and use a program
  name or argument with a space in it. I was able to get launching konsole to 
  simply lock up edb (no idea why) simply by using it from a path with a space
  in it.

2007-07-31
----------

* Experimental code for opening an I/O window for command line apps is almost
  done. It actually works well, just need it to be more tunable. This is a
  big feature as it will allow more complete debugging of applications with a 
  CLI.

2007-07-30
----------

* Made the 3 byte UD opcode not decode as "invalid" but as "ud", since this op
  isn't really invalid, just is hardwired to generate an exception.

* FPU registers are now highlighted on changes.

* Made changes towards abstracting State such that it can be an opaque type.

* Renamed types.h to EDBTypes.h to avoid conflict with system types.h. Sorry
  if this makes people change code, but API isn't stable yet ;).

* Moved *nix specific headers to ROOT/include/os/unix from src, since plugins 
  may and likely need to see those types, now the include dir is all that is 
  NEEDED to have a plugin development setup.

* Changed getValueFromUser to get a reg_t value, this should be more 
  portable. (Thanks Thomas Faber!)
  
* Improved DebuggerCore's reading/writing routines to be more portable and
  more flexible with regards to endian size and word size. 
  (Thanks Thomas Faber!)
  
* Thomas Faber's changes make edb a few steps closer to compiling and 
  functioning correctly in an x86-64 setup.


2007-07-26
----------

* Implemented PID enumeration on FreeBSD. Still a lot to go for things to 
  compile and work...

* Made edb_make_symbolmap work if you have md5 instead of md5sum in your system.

* Added breakpoint management to CPU view context menu.

2007-07-25
----------

* Fixed error in which a shallow copy of a transient variable was being used
  which is bad because the data could be trashed.

2007-07-21
----------

* You can now see the FPU registers, they are currently read only, but it 
  appears to work correctly.

2007-07-19
----------

* Fixed a silly bug introduced recently where registers aren't properly 
  un-highlighted when no longer attached.
  
* Internally layed some ground work for reading FPU register support.

* Fixed a bug in the debugging core plugin which could cause a caller of a 
  read or write to think it succeeded when it didn't. It was very unlikely to
  get triggered and even so would likely have little to no side effects.

2007-07-17
----------

* Made it so when you try to modify bytes which overlap a breakpoint, 
  you are given the option to continue (which removes the breakpoints), or 
  abort the modification.
  
* Finally made the breakpoint dialog show the breakpoint type.

* Introduced initial code for supporting more than one binary type. It still 
  only accepts ELF32, but the framework is in place.
  
* Fixed a bug where misaligned jumps were fooling the disassembly view widget
  this was pretty bad since a lot of the point of active debugging versus static
  analysis is to avoid getting fooled by tricks like this!

2007-07-16
----------

* Fixed a bug where certain strings may not be reported corrected 
  (some characters chopped out).

* Fixed bug where offsets of 16-bit relative jumps were not being truncated like
  the CPU actually does. In the real thing, the target address has the upper 
  16-bits cleared. Not very useful in 32-bit code, but important to be correct.

* Fixed bug in new register reading code.

* Removed segfault due to settings invalid segments from TODO list, this is a 
  kernel bug and entirely out of edb's control.

2007-07-13
----------

* Numerous improvements to the disassembler, I believe it is fairly complete
  the only thing that's missing that I'm aware of is enforcement of certain 
  rules (like mod/rm that must only be mem, and which ops certain prefixes are
  valid for).

2007-07-12
----------

* Worked around a bug where Qt would deliver events to disabled actions if the
  shortcut key-combination is pressed. For now I have a check in each action
  where it simply returns if that action is not enabled. The Qt people seem
  to be aware of the issue, hopefully it'll be addressed in a future version
  of Qt.

* Fixed ability to debug a process which receives unknown stop signals. Now it 
  will simply break if you were trying to step. It is still annoying since 
  frequent signals will make you have to step twice all the time, but at least
  it is now possible.

* Fixed long standing (apparently no one noticed) bug where if you detached
  from a process while a breakpoint was set, the process had a chance of 
  crashing.

* Made operand analysis smarter, it now knows about different expression types
  (byte ptr, word ptr, dword ptr).
  
* Identified a few bugs I would like ironed out before next release.

* Many minor improvements in the disassembly output. It is difficult to decide
  when to use hex and when to use decimal, but I think I have something
  reasonable.
  
* Good speedup in instruction analysis.

2007-07-11
----------

* Finally compiled edb with edisassm ! This disassembly engine is faster and
  more robust than the previous one because I am more easily able to add
  specific features that edb can use into it. Unfortunately, this does mean
  that AT&T syntax is temporarily disabled.
  
* Fixed a major crashable bug in QDisassemblyView widget, it was very subtle.

2007-07-06
----------

* Finished environment viewer plugin

* edisassm is almost complete and ready for integration

* Condition flags can now be seen in the register view as a sub item to eflags

* Split out the i386 stuff away from the GUI yet more, almost at a good point
  of portability.
  
* More robust error checking

* A few minor UI updates.


2007-05-31
----------

* Multibyte invalid ops are now displayed properly.

2007-05-23
----------

* Very preliminary TTY support.

2007-05-20
----------

* Fixed a bug in getBinaryStringFromUser where it was setting the value 
  before the maximum allowed length. This made it so values were truncated 
  incorrectly.
  
* Added Edit bytes to the QDisassembly viewer!

* Fixed DebuggerCore incorrectly reporting success on reads/writes of where
  no bytes are read.

2007-05-16
----------

* Added UID to attach dialog.

* Added ability to filter out entries that don't match your UID in the attach
  dialog.

2007-05-15
----------

* Added "Goto ESP/EBP" to stack context menu.

* Fixed crashable bug in QDisassembly view, involving libdisasm, libdisasm will
  do a double free if "x86_oplist_free" is called on invalid opcodes, this is
  now avoided.
  
* You can now always disassemble code nearing the edge of a region.

2007-04-30
----------

* Isolated how recent files are managed away from primary GUI code.

* Made register view and disassembly view fonts configurable from options 
  dialog.
  
* Made data view's font default to what is set in the options.

* Font changes in the options now show immediately after accepting (clicking ok)
  the options dialog.

2007-04-27
----------

* Break point manger now takes an expression for it's address

* General code cleanups

* Added stack analysis, will now show returns and ascii strings in stack viewer!

2007-04-24
----------

* Made minimum length for ascii string detection tunable in options.

* Improved the String Searcher plugin to reuse code in the Debugger API instead
  of using its own.

2007-04-23
----------

* Began work on a new "Open Files" plugin, it can currently list open files
  and will eventually be able to show socket/pipe information as well.

* Fixed minor display bug in tooltips for long instructions

* Improved the internal disassembly API to make it more adaptable to other 
  disassembly libraries

2007-04-19
----------

* Vastley improved the speed of the Heap Analyzer's result view (order of 
  minutes to seconds)

2007-04-15
----------
* Added heuristic for resolving "main" symbol byte on bytecode matching
  if the symbol is not provided in the symbol map. This feature is currently
  very likely glibc specific.
  
* Added some more steps towards 64-bit build support.

2007-04-13
----------

* Added more constancy to context menus (operations you can do in the dump 
  view, you can also do in the stack view most of the time now.

2007-04-11
----------

* Registers are now highlighted in red if they have changed.

2007-04-08
----------

* Fixed a crashable bug BinaryString search plugin if an empty string was 
  supplied.

2007-04-07
----------

* CheckVersion plugin will now respect the HTTP_PROXY environment variable.

2007-04-06
----------

* corrected minor bug in edb_make_symbolmap.sh which preventing it from running
  on certain distributions which actually have /bin/sh act like the original sh
  not bash :)

* Added basic conditional breakpoints. The can be set in the breakpoint 
  manager plugin and are based on the expressions that were recently added.
  At the moment, the expressions are tested for validity at the moment of 
  the breakpoint, eventually this will be checked when you enter it.

2007-04-02
----------

* Added expression support to "Goto Address" in both the CPU and data views.
  Please see the README for more detailed information on this.
 
2007-03-29
----------

* Added MD5 code, which will notify the user of outdated symbol files.
  
* Added code to remove duplicates from the instruction analysis list.

2007-03-28
----------

* Renamed make_symbolmap.sh to edb_make_symbolmap.sh to make it more 
  distribution friendly.

* edb_make_symbolmap.sh now puts errors to stderr, not stdout, so you don't get
  false symbol files if you process a whole dir at a time.

2007-03-24
----------

* Shellcode address used to change region permissions is now chosen dynamically.

2007-03-20
----------

* Added preliminary framework for resolving parameters to standard library 
  functions.
  
* Added ability to show/hide the toolbar.

2007-03-15
----------

* Added ability to specify compile time some default directory strings, 
  makes package management easier.

* Added preliminary method for code to find a plugin based on the plugins name
  this will allow code to be written which depends on functionality exported
  by plugins, which could be cool.

* Added some basic measures to help prevent duplicate plugin loading caused
  by symlink trickery
  
* edb will now look in the current working directory as well as the path 
  specified in the options for plugins

2007-03-14
----------

* Added getting of working directory and arguments from attached processes
  this makes restarting work much better (which is now enabled).

2007-03-12
----------

* Internally, a lot of i386 specific code was moved to a new class 
  "i386ArchProcessor", which will eventually be a plugin (one for each arch).
  It is still a work in progress, but is a start.

* Removed quit role property from exit menu as this prevented 
  compiles on Qt < 4.2.0

2007-03-03
----------

* started work on restart code, seems to work ok

2007-02-26
----------

* Added ability to change the working directory opened applications run in. 

2007-02-23
----------

* Improved about dialog box :-P

2007-02-15
----------

* Added ability to dump the contents of a data view tab to a file.

2007-01-17
----------

* Added recent file list to File menu.

2007-01-16
----------

* Cleared internal state tracking on detach, nothing major.

2006-12-23
----------

* Added new stylized register view window, still working out the programmers API
  for it, but at least it looks nice :)

2006-12-22
----------

* Making slightly less assumptions about the architecture being 32-bit.

2006-12-18
----------

* Added a search filter to the attach and memory region dialogs.

* Fixed compilation issue with gcc 3.x series compilers.

2006-12-16
----------

* Added a tooltip to the disassembly view when there are too many instruction
  bytes to display which shows all bytes in the instruction.

* Added display of ASCII strings next to registers if analysis decides that 
  what the register points to is an ASCII string.

* Added push/pop operations to the stack context menu.

2006-12-13
----------

* Added preliminary PLT support to make_symbolmap.sh, this will allow edb 
  to properly display library calls, eventually, this will lead to a database
  of known functions with parameters so the analyzer can display the parameters
  correctly.

2006-12-12
----------

* Finally added the ability to edit the bytes in the data and stack dump 
  widgets! Simply right click and choose "Edit Bytes" and modify away :).
  If the new string of bytes is smaller, the debugger will zero fill the
  difference, in the future this will be tunable.

2006-12-08
----------

* Improved efficiency and clarity of rendering code for some custom widgets.

2006-12-06
----------

* Started working on some html based help files in doc directory, don't
  expect anything useful in there quite yet, but it'll get there.

* Isolated libdisasm calls to a single part of the code, this allowed 
  consolidation of common functions as well as creating a central point to 
  replace the code as I feel that libdisasm will likely be dropped in a later 
  version.

* Added more information in the instruction information panel.

* Made DebuggerCore plugin readBytes fill the trailing end of the buffer with 
  0xff if it could not read as many bytes as requested, this is to give more
  predictable results if only a partial read is possible.

2006-12-01
----------

* Reduced redundant drawing in QDisassembly widget, which should make things
  slightly faster due to less redraw.

2006-11-30
----------

* Added some more sanity checks to the internal reads and writes in the 
  debugger core plugin, this should prevent reporting incorrect data if a 
  add breakpoint failed to read/write correctly.

* Made step over, also step over REP prefixed ops.

* Fixed bug in indirect call/jmp analysis which resulted in the target symbol
  not being resolved even though it was in the symbol map.

* Made it so the expression evaluator shows a ? instead of junk when it can't 
  read from the effective address.

2006-11-29
----------

* Corrected bug in libdisasm which caused the instruction  8e e8 to disassemble 
  incorrectly as "mov ds, ax" instead of the correct "mov gs, ax".

2006-11-28
----------

* Added ability to choose both how many bytes per "word" in the displays
  and how many "words" per row via the context menu, this setting is not
  remembered yet, but that will follow shortly.

* Fixed very annoying bug where it was possible to make the QHexView widget
  not correctly highlight things if the origin was not aligned to the word 
  width * row width.

* Added ability for QHexView widget to display 64-bit formatted hex, once
  a bug related to selection of misaligned text is resolved this will be 
  enabled.

2006-11-27
----------

* Added getBinaryStringFromUser to debugger API.

* Added filename to title bar when opening an application.

* Removed updating of all views when selecting a memory region to view,
  now it only updates the data view tab.
  
* Fixed green arrow showing outside of viewable area sometimes.

2006-11-25
----------

* Changed string searcher to allow newlines in a string.

* Corrected DebuggerCore's behavior when writing less than 4 bytes from the 
  edge of a memory region, previously the result was undefined, now it acts
  as expected.

2006-11-22
----------

* Added double click to follow in dump to StringSearcher plugin

* Fixed rare double-free crash found by valgrind.

* Fixed occasional crash due to lack of copy constructor in a class.

* Now the open dialog will start in the directory which you last opened a file 
  from, this should make reloading the same file you previously ran quicker.

* Added a function to Debugger namespace which make it easier to properly 
  compare version numbers numerically.

* Added a plugin "CheckVersion" which will read the file 
  http://www.codef00.com/projects/debugger-latest and determine if a new version
  has been released.

2006-11-21
----------

* Added another opcode class "[esp + 8]->eip" in OpcodeSearcher and improved 
  efficiency of search by reducing memory compares.
  
* Added ability to double click results in OpcodeSearcher and it will jump
  the disassembly view to the found address.

2006-11-20
----------

* Improved instruction analysis, now it will attempt to give symbol relative
  information on many control flow ops such as calls/returns/jumps, more of 
  this to come.

2006-11-17
----------

* Changed name of utility functions ByteShiftArray::rol() and 
  ByteShiftArray::ror() to ByteShiftArray::shl and 
  ByteShiftArray::shr to reflect what they actually do
  
* Updated the makesymbolmap.sh script based on patch from pancake, SymbolManager
  has been updated to use the slightly different format.
  
* Reduced scrolling in disassembly view by only scrolling when new instruction
  isn't in visible range.
  
* Added arrow icon next to current instruction.

* Changed resultant binary from "debugger" to "edb" to reflect actual project 
  name.
  
* Added some basic documentation on how to write plugins, though the example 
  plugins are still the best way to learn.
  
* Added jump to address and jump to EIP to disassembly view context menu.

* Main window will now remember it size and restore it next time edb is run.

2006-11-16
----------

* Minor code cleanups.

* Slight change to DebuggerCoreInterface to have waits specify a timeout, 
  it is not required that the class actually do anything with the timeout, 
  but the groundwork is being set.
  
* Hopefully have a good solution for terminating the event server thread

* Removed parts of libdisasm which aren't needed for libdisasm.a to build
  this cuts the download size by 75%!

2006-11-13
----------

* Removed parts of libdisasm from source tree that aren't related to the build
  which cut the tarball down to a quarter of the size :)
  
* Working on cleaning up internal breakpoint management, current implementation
  works most of the time, but there are a few corner cases where it isn't 
  perfect. I plan to rework this so that the logic is more clear.

2006-11-12
----------

* Added upper limit of one second to how long debugger will wait for the event 
  thread to terminate. Eventually I will fix the fact that it doesn't always 
  terminate, but for now this seems to work OK.
  
2006-11-10
----------

* Fixed QTableWidgets not being populated correctly with Qt 4.2.x and up, it 
  seems that you must disable sorting before inserting to guarantee correct
  behavior.

2006-11-10
----------

* Fixed a bug related to adjacent breakpoints which were not placed by the 
  debugger (already in the code).

2006-11-09
----------

* Initial Release

```

`CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
project (edb LANGUAGES CXX VERSION 1.3.0)

enable_testing()

if(NOT EXISTS "${PROJECT_SOURCE_DIR}/src/qhexview/.git" OR NOT EXISTS "${PROJECT_SOURCE_DIR}/lib/gdtoa-desktop/.git")
	message(SEND_ERROR "The git submodules are not available. Please run:\ngit submodule update --init --recursive")
endif()

set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${PROJECT_SOURCE_DIR}/cmake/Modules/")

include("GNUInstallDirs")
include("CheckIncludeFileCXX")
include("DetectCompiler")
include("DetectOS")
include("DetectArchitecture")
include("EnableSanitizers")
include("EnableSTLDebug")
include("ProjectDefaults")
include("AddWarnings")
include("DetectGitBranch")

if(TARGET_COMPILER_GCC AND ${CMAKE_CXX_COMPILER_VERSION} VERSION_LESS 7.0)
	message(FATAL_ERROR "Your g++ version is too old. At least 7.0 is required.")
endif()

git_get_branch(GIT_BRANCH)

configure_file(include/version.h.in include/version.h)
include_directories("${PROJECT_BINARY_DIR}/include")

find_package(Capstone REQUIRED)
include_directories(${CAPSTONE_INCLUDE_DIRS})
link_directories(${CAPSTONE_LIBRARY_DIRS})

if (UNIX)
	find_package(PkgConfig REQUIRED)
	pkg_check_modules(GRAPHVIZ libgvc>=2.38.0)
	if(GRAPHVIZ_FOUND)
		add_definitions(-DENABLE_GRAPH)
	endif()
endif()

message(STATUS "Checking for module 'double-conversion'")
# Using check_include_file_cxx instead of find_package etc. to support various versions of double-conversion. Some versions don't have CMake modules, some have a bit incompatible ones...
check_include_file_cxx("double-conversion/double-conversion.h" HAVE_DOUBLE_CONVERSION)
if(NOT HAVE_DOUBLE_CONVERSION)
   UNSET(HAVE_DOUBLE_CONVERSION CACHE)
   message(WARNING "libdouble-conversion header wasn't found. 32- and 64-bit floating-point values will be shown with max_digits10 digits of precision instead of shortest representation.")
else()
   find_library(DOUBLE_CONVERSION_LIBRARIES double-conversion)
   if(NOT DOUBLE_CONVERSION_LIBRARIES)
	   message(WARNING "libdouble-conversion library wasn't found. 32- and 64-bit floating-point values will be shown with max_digits10 digits of precision instead of shortest representation.")
   else()
       add_definitions("-DHAVE_DOUBLE_CONVERSION")
   endif()
endif()

find_package(Qt5Core)

include_directories("include")

if(TARGET_PLATFORM_LINUX)
	include_directories("include/os/unix")
	include_directories("include/os/unix/linux")
elseif(TARGET_PLATFORM_WINDOWS)
	include_directories("include/os/win32")
endif()

if(TARGET_ARCH_X86 OR TARGET_ARCH_ARM32)
	add_definitions(-DEDB_IS_32_BIT=true -DEDB_IS_64_BIT=false)
elseif(TARGET_ARCH_X64 OR TARGET_ARCH_ARM64)
	add_definitions(-DEDB_IS_32_BIT=false -DEDB_IS_64_BIT=true)
else()
	message(SEND_ERROR "Unexpected bitness: \"sizeof(void*)=${CMAKE_SIZEOF_VOID_P}.\"")
endif()

if(TARGET_ARCH_X86)
	add_definitions(-DEDB_X86)
	include_directories("include/arch/x86-generic")
elseif(TARGET_ARCH_X64)
	add_definitions(-DEDB_X86_64)
	include_directories("include/arch/x86-generic")
elseif(TARGET_ARCH_ARM32)
	add_definitions(-DEDB_ARM32)
	include_directories("include/arch/arm-generic")
elseif(TARGET_ARCH_ARM64)
	add_definitions(-DEDB_ARM64)
	include_directories("include/arch/arm-generic")
endif()

if(UNIX)
	if(TARGET_ARCH_FAMILY_X86)
		pkg_check_modules(GDTOA gdtoa-desktop)
		if(NOT GDTOA_FOUND)
			message(STATUS "gdtoa-desktop package wasn't found. Using built in version.")
		endif()
	endif()
endif()

add_subdirectory(src)
add_subdirectory(plugins)
add_subdirectory(lib)

install (FILES ${CMAKE_SOURCE_DIR}/edb.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
install (FILES ${CMAKE_SOURCE_DIR}/edb.desktop DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/applications/)
install (FILES ${CMAKE_SOURCE_DIR}/src/res/images/edb.png DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/pixmaps/)

```

`COPYING`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

```

`README.md`:

```md
[![Gitter](https://badges.gitter.im/eteran/edb-debugger.svg)](https://gitter.im/eteran/edb-debugger?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)
[![Build Status](https://app.travis-ci.com/eteran/edb-debugger.svg?branch=master)](https://app.travis-ci.com/eteran/edb-debugger)
[![Build status](https://ci.appveyor.com/api/projects/status/91jfbbyg075wk96q?svg=true)](https://ci.appveyor.com/project/eteran/edb-debugger)
[![License](https://img.shields.io/badge/license-GPL2-blue.svg)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
[![Paypal](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=evan%2eteran%40gmail%2ecom&lc=US&item_name=edb%2ddebugger&currency_code=USD&bn=PP%2dDonationsBF%3a68747470733a2f2f696d672e736869656c64732e696f2f62616467652f446f6e6174652d50617950616c2d677265656e2e737667%3aNonHosted)


edb is a cross platform AArch32/x86/x86-64 debugger. It was inspired by [Ollydbg](http://www.ollydbg.de/ "Ollydbg"), 
but aims to function on AArch32, x86, and x86-64 as well as multiple OS's. Linux is the 
only officially supported platform at the moment, but FreeBSD, OpenBSD, OSX and 
Windows ports are underway with varying degrees of functionality.

![Screenshot](https://raw.githubusercontent.com/wiki/eteran/edb-debugger/img/edb_interface-2019.png)

edb is available under the GPL 2 license, see the COPYING for details.

NOTE: This README now only covers the most essential documentation, for more
complete documentation see the [wiki](https://github.com/eteran/edb-debugger/wiki)


Cloning
-------

When cloning the repo, please use git's `--recursive` flag to ensure that the 
sub-modules will be properly cloned and updated to the correct versions. 
Here is an example:

`git clone --recursive https://github.com/eteran/edb-debugger.git`

Compiling
---------

Compiling edb is generally quite simple. The latest release of edb currently 
depends on the following packages:

Dependency                                  | Version Required
------------------------------------------- | ----------------
GCC/Clang                                   | Supporting C++14
[Qt](http://www.qt.io/)                     | >= 5.2
[Boost](http://boost.org) (Headers Only)    | >= 1.35
[Capstone](http://www.capstone-engine.org/) | >= 3.0
[Graphviz](http://www.graphviz.org/)        | >= 2.38.0 (Optional)

The development master branch will be increasing the minimum requirements to:

Dependency                                  | Version Required
------------------------------------------- | ----------------
GCC/Clang                                   | Supporting C++17
[Qt](http://www.qt.io/)                     | >= 5.9
[Capstone](http://www.capstone-engine.org/) | >= 3.0
[Graphviz](http://www.graphviz.org/)        | >= 2.38.0 (Optional)

Many distributions already have packages that satisify these. The wiki contains 
examples for some popular distributions:

* https://github.com/eteran/edb-debugger/wiki/Compiling-(Fedora)
* https://github.com/eteran/edb-debugger/wiki/Compiling-(Ubuntu)
* https://github.com/eteran/edb-debugger/wiki/Compiling-(Debian)

Once you have the necessary dependencies installed, compilation is done with 
`cmake`:

### CMake

If you plan to just run edb out of the build directory, it's as simple as this:

	$ mkdir build
	$ cd build
	$ cmake ..
	$ make
	$ ./edb

If you would like to properly install edb on the system for all users, it's 
only a little different:

	$ mkdir build
	$ cd build
	$ cmake -DCMAKE_INSTALL_PREFIX=/usr/local/ ..
	$ make
	$ make install
	$ edb

Installing
----------

Basic installation is simple, you may run

	$ make install

In which case the plugins will be installed in `/usr/local/lib/edb` and the 
binaries will be installed in `/usr/local/bin/`.

![Analytics](https://www.google-analytics.com/collect?v=1&tid=UA-2958870-1&ds=web&t=pageview&dl=https%3A%2F%2Fgithub.com%2Feteran%2Fedb-debugger&dh=github.com&dp=%2Feteran%2Fedb-debugger&cid=555)

```

`TODO`:

```
This file has been superseded by the issue tracker at: https://github.com/eteran/edb-debugger/issues

```

`appveyor.yml`:

```yml
version: "{build}"

environment:
  CAPSTONE_SDK: C:\capstone\sdk
  matrix:
    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017
      CAPSTONE_ARCHIVE: capstone-3.0.5-rc2-win64
      CMAKE_GENERATOR: Visual Studio 15 2017 Win64
      QT_BASEDIR: C:\Qt\5.9\msvc2017_64

configuration:
  - Debug
  - Release

install:
  - ps: new-item -itemtype directory -path C:\capstone\sdk | out-null
  - ps: new-item -itemtype directory -path C:\capstone\sdk\include\capstone | out-null
  - ps: new-item -itemtype directory -path C:\capstone\sdk\lib | out-null
  - ps: "[Environment]::CurrentDirectory = 'C:\\capstone'"
  - ps: (new-object net.webclient).DownloadFile("https://github.com/aquynh/capstone/releases/download/3.0.5-rc2/${env:CAPSTONE_ARCHIVE}.zip", 'capstone.zip')
  - ps: expand-archive C:\capstone\capstone.zip -destinationpath C:\capstone
  - ps: copy-item C:\capstone\${env:CAPSTONE_ARCHIVE}\include\*.h C:\capstone\sdk\include\capstone
  - ps: copy-item C:\capstone\${env:CAPSTONE_ARCHIVE}\capstone.lib C:\capstone\sdk\lib\capstone_dll.lib
  
before_build:
  - cmd: git submodule update --init
  - cmd: cd C:\projects
  - cmd: md build
  - cmd: cd build
  - cmd: cmake -Wno-dev -G "%CMAKE_GENERATOR%" -DCMAKE_BUILD_TYPE=%configuration% -DCMAKE_INSTALL_PREFIX=C:\projects\install -DCAPSTONE_SDK="%CAPSTONE_SDK%" -DQt5Core_DIR="%QT_BASEDIR%\lib\cmake\Qt5Core" -DQt5_DIR="%QT_BASEDIR%\lib\cmake\Qt5" ..\edb-debugger

build_script:
  - cmd: msbuild C:\projects\build\edb.sln /t:edb /logger:"C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll"
  - cmd: msbuild C:\projects\build\edb.sln /t:DebuggerCore /logger:"C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll"
  

```

`cmake/Modules/AddWarnings.cmake`:

```cmake

include("DetectCompiler")

function(TARGET_ADD_WARNINGS TARGET)
	if((TARGET_COMPILER_GCC) OR (TARGET_COMPILER_CLANG))
		target_compile_options(${TARGET}
		PUBLIC
			-W
			-Wall
			#-Wshadow
			-Wnon-virtual-dtor
			#-Wold-style-cast
			-Wcast-align
			-Wunused
			-Woverloaded-virtual
			-pedantic
			#-Wconversion
			#-Wsign-conversion
			#-Wnull-dereference
			-Wdouble-promotion
			-Wformat=2
			-Wno-unused-macros
			-Wno-switch-enum
			-Wno-unknown-pragmas
			-Wimplicit-fallthrough
		)

		if(TARGET_COMPILER_CLANG)
			target_compile_options(${TARGET}
			PUBLIC
				#-Wexit-time-destructors
				#-Wglobal-constructors
				#-Wshadow-uncaptured-local
				#-Wshorten-64-to-32
				-Wconditional-uninitialized
				-Wmissing-prototypes
			)

	    elseif(TARGET_COMPILER_GCC)
			target_compile_options(${TARGET}
			PUBLIC
				#-Wduplicated-branches
				#-Wduplicated-cond
				#-Wsuggest-attribute=const
				#-Wsuggest-attribute=noreturn
				#-Wsuggest-attribute=pure
				#-Wsuggest-final-methods
				#-Wsuggest-final-types
				#-Wuseless-cast
				-Wlogical-op
				-Wsuggest-override
			)
	    endif()
	endif()
endfunction()

```

`cmake/Modules/DetectArchitecture.cmake`:

```cmake

if((CMAKE_SYSTEM_PROCESSOR MATCHES "i[3456]86") OR (CMAKE_SYSTEM_PROCESSOR MATCHES "x86_64") OR (CMAKE_SYSTEM_PROCESSOR MATCHES "[aA][mM][dD]64"))
	set(TARGET_ARCH_FAMILY_X86 1)
	if (CMAKE_SIZEOF_VOID_P EQUAL 8)
		set(TARGET_ARCH_X64 1)
		set(TARGET_ARCH_NAME "x86-64")
	elseif (CMAKE_SIZEOF_VOID_P EQUAL 4)
		set(TARGET_ARCH_X86 1)
		set(TARGET_ARCH_NAME "x86")
	endif()
elseif((CMAKE_SYSTEM_PROCESSOR MATCHES "armv[0-9]+"))
	set(TARGET_ARCH_FAMILY_ARM 1)	
	if (CMAKE_SIZEOF_VOID_P EQUAL 8)
		set(TARGET_ARCH_ARM64 1)
		set(TARGET_ARCH_NAME "arm64")
	elseif (CMAKE_SIZEOF_VOID_P EQUAL 4)
		set(TARGET_ARCH_ARM32 1)
		set(TARGET_ARCH_NAME "arm32")
	endif()
else()
	message(FATAL_ERROR "Unsupported Architecture: ${CMAKE_SYSTEM_PROCESSOR}")
endif()

```

`cmake/Modules/DetectCompiler.cmake`:

```cmake

if (CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
	set(TARGET_COMPILER_MSVC 1)
elseif (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
	set(TARGET_COMPILER_CLANG 1)
elseif (CMAKE_CXX_COMPILER_ID MATCHES "GNU")
	set(TARGET_COMPILER_GCC 1)
else()
	message(FATAL_ERROR "Unsupported Compiler: ${CMAKE_CXX_COMPILER_ID}")
endif()

```

`cmake/Modules/DetectGitBranch.cmake`:

```cmake

function(git_get_branch RESULT)
	find_package(Git)
	if(Git_FOUND AND EXISTS "${CMAKE_SOURCE_DIR}/.git")
		execute_process(
			COMMAND git rev-parse HEAD
			WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
			OUTPUT_VARIABLE OUTPUT
			OUTPUT_STRIP_TRAILING_WHITESPACE
		)
		set(${RESULT} ${OUTPUT} PARENT_SCOPE)
	else()
		set(${RESULT} "Unknown" PARENT_SCOPE)
	endif()
endfunction()

```

`cmake/Modules/DetectOS.cmake`:

```cmake

if (CMAKE_SYSTEM_NAME MATCHES "Windows") 
	set(TARGET_PLATFORM_WINDOWS 1) 
elseif (CMAKE_SYSTEM_NAME MATCHES "Linux")
	set(TARGET_PLATFORM_LINUX 1)
elseif (CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
	set(TARGET_PLATFORM_FREEBSD 1)
elseif (CMAKE_SYSTEM_NAME MATCHES "Darwin")
	set(TARGET_PLATFORM_MACOS 1)
else()
	message(FATAL_ERROR "Unsupported OS: ${CMAKE_SYSTEM_NAME}")
endif ()

```

`cmake/Modules/EnableSTLDebug.cmake`:

```cmake

include("DetectCompiler")

if((TARGET_COMPILER_GCC) OR (TARGET_COMPILER_CLANG))

	option(ENABLE_STL_DEBUG "Enable STL container debugging")

	if(ENABLE_STL_DEBUG)
		set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D_GLIBCXX_DEBUG")
		set(CMAKE_C_FLAGS   "${CMAKE_C_FLAGS}   -D_GLIBCXX_DEBUG")	
	endif()
endif()

```

`cmake/Modules/EnableSanitizers.cmake`:

```cmake

include("DetectCompiler")

function(JOIN VALUES GLUE OUTPUT)
  string (REPLACE ";" "${GLUE}" _TMP_STR "${VALUES}")
  set (${OUTPUT} "${_TMP_STR}" PARENT_SCOPE)
endfunction()

if((TARGET_COMPILER_GCC) OR (TARGET_COMPILER_CLANG))
	option(ENABLE_ASAN        "Enable address sanitizer")
	option(ENABLE_MSAN        "Enable memory sanitizer")
	option(ENABLE_USAN        "Enable undefined sanitizer")
	option(ENABLE_TSAN        "Enable thread sanitizer")

	set(SANITIZERS "")

	if(ENABLE_ASAN)
		list(APPEND SANITIZERS "address")
	endif()

	if(ENABLE_MSAN)
		list(APPEND SANITIZERS "memory")
	endif()

	if(ENABLE_USAN)
		list(APPEND SANITIZERS "undefined")
	endif()

	if(ENABLE_TSAN)
		list(APPEND SANITIZERS "thread")
	endif()

	JOIN("${SANITIZERS}" "," LIST_OF_SANITIZERS)
endif()

if(LIST_OF_SANITIZERS)
	if(NOT "${LIST_OF_SANITIZERS}" STREQUAL "")
		set(CMAKE_CXX_FLAGS        "${CMAKE_CXX_FLAGS}        -fsanitize=${LIST_OF_SANITIZERS}")
		set(CMAKE_C_FLAGS          "${CMAKE_C_FLAGS}          -fsanitize=${LIST_OF_SANITIZERS}")
		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fsanitize=${LIST_OF_SANITIZERS}")
	endif()
endif()


```

`cmake/Modules/FindCapstone.cmake`:

```cmake
if (UNIX)
	find_package(PkgConfig REQUIRED)
	pkg_check_modules(CAPSTONE REQUIRED capstone>=3.0.4)
elseif (WIN32)
	# CAPSTONE_SDK should be the path to a directory containing a subdirectory "include/capstone"
	# with all the include headers of capstone and another subdirectory "lib" with "capstone_dll.lib" or "libcapstone.dll".
	if (NOT DEFINED CAPSTONE_SDK)
		set(CAPSTONE_SDK NOTFOUND CACHE PATH "Path to the Capstone SDK")
		message(SEND_ERROR "Path to Capstone SDK is missing. Please specify CAPSTONE_SDK.")
	endif()

	find_path(CAPSTONE_INCLUDE_DIRS
		capstone/capstone.h
		PATHS ${CAPSTONE_SDK}/include
	)

    if (NOT CAPSTONE_INCLUDE_DIRS)
		message(SEND_ERROR "Include directory for Capstone not found. Please specify CAPSTONE_SDK.")
	endif()

	find_library(CAPSTONE_LIBRARIES
		NAMES capstone_dll libcapstone
		HINTS "${CAPSTONE_SDK}/lib"
	)

    if (NOT CAPSTONE_LIBRARIES)
		message(SEND_ERROR "Library directory for Capstone not found. Please specify CAPSTONE_SDK.")
	endif()
endif()

```

`cmake/Modules/ProjectDefaults.cmake`:

```cmake

include("DetectCompiler")

if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE "RelWithDebInfo" CACHE STRING "Choose the type of build." FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release" "RelWithDebInfo" "MinSizeRel")
endif()

# Generate compile_commands.json to make it easier to work with clang based tools
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

if(TARGET_COMPILER_MSVC)
	add_definitions(-DUNICODE -D_UNICODE -D_CRT_SECURE_NO_WARNINGS)
endif()

```

`edb.1`:

```1
.\"Text automatically generated by txt2man
.TH EDB 1 "December 2011" "" ""
.SH NAME
\fBedb \fP- graphical debugger and disassembler for executables
.SH SYNOPSIS
.nf
.fam C
 \fBedb\fP [OPTION]\.\.\. [\fITARGET\fP]
.fam T
.fi
.fam T
.fi
.SH DESCRIPTION
\fBedb\fP (Evan's Debugger) is a modular and modern disassembler and debugger for
binary ELF files based on ptrace API and the capstone disassembly library.
.TP
.B
\fB--help\fP
Show usage and exit.
.TP
.B
\fB--symbols\fP <file>
generate symbols map for file <file>
.TP
.B
\fB--attach\fP <pid>
attach the process of PID <pid> to debugger
.TP
.B
\fB--run\fP <program> [args\.\.\.]
open <program> in debugger with optional [args\.\.\.]
.TP
.B
\fB--version\fP
show version string and exit.
.TP
.B
\fB--dump-version\fP
show version and exit.
.SH EXAMPLE
\fBedb\fP \fB--symbols\fP /lib/libc.so.6 > libc.so.6.map
.PP
.nf
.fam C
     Will generate symbols for libc and save it in a text file. It's useful if you store this map files in the symbols directory configured in edb's preferences.

.fam T
.fi
for i in $(ls /lib); do \fBedb\fP \fB--symbols\fP $i > $(basename $i).map; done
.PP
.nf
.fam C
      Useful to generate maps for all libs you have in /lib.

.fam T
.fi
\fBedb\fP \fB--run\fP /bin/ls
.PP
.nf
.fam C
      Will open the ls program binary in debugger.

.fam T
.fi
\fBedb\fP \fB--attach\fP 1720
.PP
.nf
.fam C
     Attach the process of PID 1720 to debugger.
.fam T
.fi
.SH AUTHOR
Written by Evan Teran <evan.teran@gmail.com>
.SH REPORTING BUGS
Report any bugs or requests for features via BTS on https://github.com/eteran/edb-debugger/issues
.SH COPYRIGHT
Copyright © 2008 CodeF00. Licensed GPLv2: GNU GPL version 2 <http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.

```

`edb.appdata.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- Copyright 2014 Evan Teran <evan.teran@gmail.com> -->
<application>
	<id type="desktop">edb.desktop</id>
	<metadata_license>CC0</metadata_license>
	<project_license>GPL-2.0</project_license>
	<name>edb</name>
	<summary>A reverse engineer's debugger</summary>
	<description>
		<p>edb is a cross platform x86/x86-64 debugger. It was inspired by OllyDbg, but aims to function on x86 and x86-64 as well as multiple OS's.</p>
		<p>Linux is the only officially supported platform at the moment, but FreeBSD, OpenBSD, OSX and Windows ports are underway with varying degrees of functionality.</p>
	</description>
	<screenshots>
		<screenshot type="default" width="1121" height="839">http://codef00.com/img/debugger.png</screenshot>
	</screenshots>
	<url type="homepage">https://github.com/eteran/edb-debugger</url>
	<updatecontact>evan.teran_at_gmail.com</updatecontact>
</application>


```

`edb.desktop`:

```desktop
[Desktop Entry]
Name=edb
GenericName="Evan's Debugger"
Comment="edb is a cross platform x86/x86-64 debugger"
Exec=edb
Icon=edb
Terminal=false
Type=Application
Categories=Development;Qt;Debugger;

```

`include/API.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef API_H_20090529_
#define API_H_20090529_

#include <QtGlobal>

#ifdef QT_PLUGIN
#define EDB_EXPORT Q_DECL_IMPORT
#else
#define EDB_EXPORT Q_DECL_EXPORT
#endif

#endif

```

`include/ArchProcessor.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ARCH_PROCESSOR_H_20070312_
#define ARCH_PROCESSOR_H_20070312_

#include "API.h"
#include "RegisterViewModelBase.h"
#include "Status.h"
#include "Types.h"
#include <QObject>

class QByteArray;
class QMenu;
class QString;
class QStringList;
class State;

class EDB_EXPORT ArchProcessor : public QObject {
	Q_OBJECT

public:
	ArchProcessor();
	ArchProcessor(const ArchProcessor &) = delete;
	ArchProcessor &operator=(const ArchProcessor &) = delete;
	~ArchProcessor() override                       = default;

public:
	QStringList updateInstructionInfo(edb::address_t address);
	bool canStepOver(const edb::Instruction &inst) const;
	bool isFilling(const edb::Instruction &inst) const;
	//! Checks whether potentially conditional instruction's condition is satisfied
	bool isExecuted(const edb::Instruction &inst, const State &state) const;
	Result<edb::address_t, QString> getEffectiveAddress(const edb::Instruction &inst, const edb::Operand &op, const State &state) const;
	edb::address_t getEffectiveAddress(const edb::Instruction &inst, const edb::Operand &op, const State &state, bool &ok) const;
	void reset();
	void aboutToResume();
	void setupRegisterView();
	void updateRegisterView(const QString &default_region_name, const State &state);
	RegisterViewModelBase::Model &registerViewModel() const;

private:
	bool justAttached_ = true;
	bool hasMmx_;
	bool hasXmm_;
	bool hasYmm_;

private Q_SLOTS:
	void justAttached();
};

#endif

```

`include/BasicBlock.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef BASIC_BLOCK_H_20130830_
#define BASIC_BLOCK_H_20130830_

#include "API.h"
#include "Types.h"
#include <iterator>
#include <memory>
#include <vector>

class QString;

using instruction_pointer = std::shared_ptr<edb::Instruction>;

class EDB_EXPORT BasicBlock {
public:
	using size_type              = size_t;
	using value_type             = instruction_pointer;
	using reference              = instruction_pointer &;
	using const_reference        = const instruction_pointer &;
	using iterator               = std::vector<instruction_pointer>::iterator;
	using const_iterator         = std::vector<instruction_pointer>::const_iterator;
	using reverse_iterator       = std::reverse_iterator<iterator>;
	using const_reverse_iterator = std::reverse_iterator<const_iterator>;

public:
	BasicBlock()                        = default;
	BasicBlock(const BasicBlock &other) = default;
	BasicBlock &operator=(const BasicBlock &rhs) = default;
	BasicBlock(BasicBlock &&other)               = default;
	BasicBlock &operator=(BasicBlock &&rhs) = default;
	~BasicBlock()                           = default;

public:
	void push_back(const instruction_pointer &inst);
	void addReference(edb::address_t refsite, edb::address_t target);

public:
	std::vector<std::pair<edb::address_t, edb::address_t>> references() const;

public:
	reference operator[](size_type pos);
	const_reference operator[](size_type pos) const;

	const_reference back() const;
	const_reference front() const;
	reference back();
	reference front();

public:
	const_iterator begin() const;
	const_iterator end() const;
	const_reverse_iterator rbegin() const;
	const_reverse_iterator rend() const;
	iterator begin();
	iterator end();
	reverse_iterator rbegin();
	reverse_iterator rend();

public:
	size_type size() const;
	bool empty() const;

public:
	void swap(BasicBlock &other);

public:
	QString toString() const;

public:
	size_type byteSize() const;
	edb::address_t firstAddress() const;
	edb::address_t lastAddress() const;

private:
	std::vector<instruction_pointer> instructions_;
	std::vector<std::pair<edb::address_t, edb::address_t>> references_;
};

#endif

```

`include/BinaryString.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef BINARY_STRING_H_20060821_
#define BINARY_STRING_H_20060821_

#include "API.h"
#include <QWidget>

namespace Ui {
class BinaryStringWidget;
}

class QString;
class QByteArray;

class EDB_EXPORT BinaryString : public QWidget {
	Q_OBJECT

private:
	enum class Mode {
		LengthLimited, // obeys setMaxLength()
		MemoryEditing  // obeys user's choice in keepSize checkbox
	};

public:
	BinaryString(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~BinaryString() override;

private Q_SLOTS:
	void on_txtAscii_textEdited(const QString &text);
	void on_txtHex_textEdited(const QString &text);
	void on_txtUTF16_textEdited(const QString &text);
	void on_keepSize_stateChanged(int state);

public:
	void setMaxLength(int n);
	QByteArray value() const;
	void setValue(const QByteArray &);
	void setShowKeepSize(bool visible);
	bool showKeepSize() const;

private:
	void setEntriesMaxLength(int n);

	::Ui::BinaryStringWidget *ui = nullptr;
	Mode mode_                   = Mode::MemoryEditing;
	int requestedMaxLength_      = 0;
	int valueOriginalLength_     = 0;
};

#endif

```

`include/ByteShiftArray.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef BYTE_SHIFT_ARRAY_H_20060825_
#define BYTE_SHIFT_ARRAY_H_20060825_

#include "API.h"
#include <QVector>
#include <cstddef>

class EDB_EXPORT ByteShiftArray {
public:
	explicit ByteShiftArray(int size);
	ByteShiftArray(const ByteShiftArray &) = delete;
	ByteShiftArray &operator=(const ByteShiftArray &) = delete;

public:
	ByteShiftArray &shl();
	ByteShiftArray &shr();
	void clear();
	void swap(ByteShiftArray &other);

public:
	ByteShiftArray &operator<<(uint8_t x);

public:
	int size() const;

public:
	uint8_t &operator[](std::size_t i);
	uint8_t operator[](std::size_t i) const;
	const uint8_t *data() const;

private:
	QVector<uint8_t> data_;
	int maxSize_;
};

#endif

```

`include/Configuration.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef CONFIGURATION_H_20061031_
#define CONFIGURATION_H_20061031_

#include "API.h"
#include "IBreakpoint.h"
#include <QList>
#include <QObject>
#include <QString>

class EDB_EXPORT Configuration : public QObject {
	Q_OBJECT
public:
	Configuration(QObject *parent = nullptr);
	~Configuration() override;

public:
	void sendChangeNotification();

Q_SIGNALS:
	void settingsUpdated();

public:
	enum Syntax {
		Intel,
		Att
	};

	enum CloseBehavior {
		Detach,
		Kill,
		KillIfLaunchedDetachIfAttached
	};

	enum InitialBreakpoint {
		EntryPoint,
		MainSymbol
	};

	enum StartupWindowLocation {
		SystemDefault,
		Centered,
		Restore
	};

public:
	// general tab
	CloseBehavior close_behavior;

	// appearance tab
	bool show_address_separator;
	QString stack_font;
	QString registers_font;
	QString disassembly_font;
	QString data_font;
	bool data_show_address;
	bool data_show_hex;
	bool data_show_ascii;
	bool data_show_comments;
	int data_word_width;
	int data_row_width;
	StartupWindowLocation startup_window_location;
	bool function_offsets_in_hex;
	bool show_jump_arrow;
	QString theme_name;

	// debugging tab
	InitialBreakpoint initial_breakpoint;
	bool warn_on_no_exec_bp;
	bool find_main;
	bool tty_enabled;
	bool remove_stale_symbols;
	bool disableASLR;
	bool disableLazyBinding;
	bool break_on_library_load;
	IBreakpoint::TypeId default_breakpoint_type;
	QString tty_command;

	// disassembly tab
	Syntax syntax;
	bool show_register_badges;
	bool syntax_highlighting_enabled;
	bool zeros_are_filling;
	bool uppercase_disassembly;
	bool small_int_as_decimal;
	bool tab_between_mnemonic_and_operands;
	bool show_local_module_name_in_jump_targets;
	bool show_symbolic_addresses;
	bool simplify_rip_relative_targets;

	// directories tab
	QString symbol_path;
	QString plugin_path;
	QString session_path;

	int min_string_length;

	// Exceptions tab
	bool enable_signals_message_box;
	QList<qlonglong> ignored_exceptions;

protected:
	void readSettings();
	void writeSettings();
};

#endif

```

`include/Expression.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef EXPRESSION_H_20070402_
#define EXPRESSION_H_20070402_

#include "Status.h"
#include <QString>
#include <functional>

struct ExpressionError {
public:
	enum ErrorMessage {
		None,
		Syntax,
		UnbalancedParens,
		UnbalancedBraces,
		DivideByZero,
		InvalidNumber,
		UnknownVariable,
		CannotReadMemory,
		UnexpectedOperator,
		UnexpectedNumber,
		VariableLargerThanAddress
	};

public:
	ExpressionError() = default;

	explicit ExpressionError(ErrorMessage type)
		: error_(type) {
	}

	const char *what() const noexcept {
		switch (error_) {
		case Syntax:
			return "Syntax Error";
		case UnbalancedParens:
			return "Unbalanced Parenthesis";
		case DivideByZero:
			return "Divide By Zero";
		case InvalidNumber:
			return "Invalid Numerical Constant";
		case UnknownVariable:
			return "Unknown Variable";
		case UnbalancedBraces:
			return "Unbalanced Braces";
		case CannotReadMemory:
			return "Cannot Read Memory At the Effective Address";
		case UnexpectedOperator:
			return "Unexpected Operator";
		case UnexpectedNumber:
			return "Unexpected Numerical Constant";
		case VariableLargerThanAddress:
			return "Variable Does Not Fit Into An Address. Is it an FPU Register?";
		default:
			return "Unknown Error";
		}
	}

private:
	ErrorMessage error_ = None;
};

template <class T>
class Expression {
public:
	using variable_getter_t = std::function<T(const QString &, bool *, ExpressionError *)>;
	using memoryReader_t    = std::function<T(T, bool *, ExpressionError *)>;

public:
	Expression(const QString &s, variable_getter_t vg, memoryReader_t mr);
	~Expression() = default;

private:
	struct Token {
		Token()                   = default;
		Token(const Token &other) = default;

		enum Operator {
			NONE,
			AND,
			OR,
			XOR,
			LSHFT,
			RSHFT,
			PLUS,
			MINUS,
			MUL,
			DIV,
			MOD,
			CMP,
			LPAREN,
			RPAREN,
			LBRACE,
			RBRACE,
			NOT,
			LT,
			LE,
			GT,
			GE,
			EQ,
			NE,
			LOGICAL_AND,
			LOGICAL_OR
		};

		enum Type {
			UNKNOWN,
			OPERATOR,
			NUMBER,
			VARIABLE
		};

		void set(const QString &data, Operator oper, Type type) {
			data_     = data;
			operator_ = oper;
			type_     = type;
		}

		QString data_;
		Operator operator_ = NONE;
		Type type_         = UNKNOWN;
	};

private:
	T evalInternal() {
		T result;

		getToken();
		evalExp(result);

		return result;
	}

public:
	Result<T, ExpressionError> evaluate() noexcept {
		try {
			return evalInternal();
		} catch (const ExpressionError &e) {
			return make_unexpected(e);
		}
	}

private:
	void evalExp(T &result);
	void evalExp0(T &result);
	void evalExp1(T &result);
	void evalExp2(T &result);
	void evalExp3(T &result);
	void evalExp4(T &result);
	void evalExp5(T &result);
	void evalExp6(T &result);
	void evalExp7(T &result);
	void evalAtom(T &result);
	void getToken();

private:
	QString expression_;
	QString::const_iterator expressionPtr_;
	Token token_;
	variable_getter_t variableReader_;
	memoryReader_t memoryReader_;
};

#include "Expression.tcc"

#endif

```

`include/Expression.tcc`:

```tcc
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef EXPRESSION_20070402_TCC_
#define EXPRESSION_20070402_TCC_

namespace detail {

inline bool is_delim(QChar ch) {
	return QString("[]!()=+-*/%&|^~<>\t\n\r ").contains(ch);
}

}

//------------------------------------------------------------------------------
// Name: Expression
// Desc:
//------------------------------------------------------------------------------
template <class T>
Expression<T>::Expression(const QString &s, variable_getter_t vg, memoryReader_t mr)
	: expression_(s), expressionPtr_(expression_.begin()), variableReader_(vg), memoryReader_(mr) {
}

//------------------------------------------------------------------------------
// Name: evalExp
// Desc: private entry point with sanity check
//------------------------------------------------------------------------------
template <class T>
void Expression<T>::evalExp(T &result) {
	if (token_.type_ == Token::UNKNOWN) {
		throw ExpressionError(ExpressionError::Syntax);
	}

	evalExp0(result);

	switch (token_.type_) {
	case Token::OPERATOR:
		switch (token_.operator_) {
		case Token::LPAREN:
		case Token::RPAREN:
			throw ExpressionError(ExpressionError::UnbalancedParens);
		case Token::LBRACE:
		case Token::RBRACE:
			throw ExpressionError(ExpressionError::UnbalancedBraces);
		default:
			throw ExpressionError(ExpressionError::UnexpectedOperator);
		}
		break;
	case Token::NUMBER:
		throw ExpressionError(ExpressionError::UnexpectedNumber);
		break;
	default:
		break;
	}
}

//------------------------------------------------------------------------------
// Name: evalExp0
// Desc: logic
//------------------------------------------------------------------------------
template <class T>
void Expression<T>::evalExp0(T &result) {
	evalExp1(result);

	for (Token op = token_; op.operator_ == Token::LOGICAL_AND || op.operator_ == Token::LOGICAL_OR; op = token_) {
		T partial_value;

		getToken();
		evalExp1(partial_value);

		// add or subtract
		switch (op.operator_) {
		case Token::LOGICAL_AND:
			result = result && partial_value;
			break;
		case Token::LOGICAL_OR:
			result = result || partial_value;
			break;
		default:
			break;
		}
	}
}

//------------------------------------------------------------------------------
// Name: evalExp1
// Desc: binary logic
//------------------------------------------------------------------------------
template <class T>
void Expression<T>::evalExp1(T &result) {
	evalExp2(result);

	for (Token op = token_; op.operator_ == Token::AND || op.operator_ == Token::OR || op.operator_ == Token::XOR; op = token_) {
		T partial_value;

		getToken();
		evalExp2(partial_value);

		// add or subtract
		switch (op.operator_) {
		case Token::AND:
			result &= partial_value;
			break;
		case Token::OR:
			result |= partial_value;
			break;
		case Token::XOR:
			result ^= partial_value;
			break;
		default:
			break;
		}
	}
}

//------------------------------------------------------------------------------
// Name: evalExp2
// Desc: comparisons
//------------------------------------------------------------------------------
template <class T>
void Expression<T>::evalExp2(T &result) {
	evalExp3(result);

	for (Token op = token_; op.operator_ == Token::LT || op.operator_ == Token::LE || op.operator_ == Token::GT || op.operator_ == Token::GE || op.operator_ == Token::EQ || op.operator_ == Token::NE; op = token_) {
		T partial_value;

		getToken();
		evalExp3(partial_value);

		// perform the relational operation
		switch (op.operator_) {
		case Token::LT:
			result = result < partial_value;
			break;
		case Token::LE:
			result = result <= partial_value;
			break;
		case Token::GT:
			result = result > partial_value;
			break;
		case Token::GE:
			result = result >= partial_value;
			break;
		case Token::EQ:
			result = result == partial_value;
			break;
		case Token::NE:
			result = result != partial_value;
			break;
		default:
			break;
		}
	}
}

//------------------------------------------------------------------------------
// Name: evalExp3
// Desc: shifts
//------------------------------------------------------------------------------
template <class T>
void Expression<T>::evalExp3(T &result) {
	evalExp4(result);

	for (Token op = token_; op.operator_ == Token::RSHFT || op.operator_ == Token::LSHFT; op = token_) {
		T partial_value;

		getToken();
		evalExp4(partial_value);

		// perform the shift operation
		switch (op.operator_) {
		case Token::LSHFT:
			result <<= partial_value;
			break;
		case Token::RSHFT:
			result >>= partial_value;
			break;
		default:
			break;
		}
	}
}

//------------------------------------------------------------------------------
// Name: evalExp4
// Desc: addition/subtraction
//------------------------------------------------------------------------------
template <class T>
void Expression<T>::evalExp4(T &result) {
	evalExp5(result);

	for (Token op = token_; op.operator_ == Token::PLUS || op.operator_ == Token::MINUS; op = token_) {
		T partial_value;

		getToken();
		evalExp5(partial_value);

		// add or subtract
		switch (op.operator_) {
		case Token::PLUS:
			result += partial_value;
			break;
		case Token::MINUS:
#ifdef _MSC_VER
#pragma warning(push)
/* disable warning about applying unary - to an unsigned type */
#pragma warning(disable : 4146)
#endif
			result -= partial_value;
#ifdef _MSC_VER
#pragma warning(pop)
#endif
			break;
		default:
			break;
		}
	}
}

//------------------------------------------------------------------------------
// Name: evalExp5
// Desc: multiplication/division
//------------------------------------------------------------------------------
template <class T>
void Expression<T>::evalExp5(T &result) {
	evalExp6(result);

	for (Token op = token_; op.operator_ == Token::MUL || op.operator_ == Token::DIV || op.operator_ == Token::MOD; op = token_) {
		T partial_value;

		getToken();
		evalExp6(partial_value);

		// mul, div, or modulus
		switch (op.operator_) {
		case Token::MUL:
			result *= partial_value;
			break;
		case Token::DIV:
			if (partial_value == 0) {
				throw ExpressionError(ExpressionError::DivideByZero);
			}
			result /= partial_value;
			break;
		case Token::MOD:
			if (partial_value == 0) {
				throw ExpressionError(ExpressionError::DivideByZero);
			}
			result %= partial_value;
			break;
		default:
			break;
		}
	}
}

//------------------------------------------------------------------------------
// Name: evalExp6
// Desc: unary expressions
//------------------------------------------------------------------------------
template <class T>
void Expression<T>::evalExp6(T &result) {

	Token op = token_;
	if (op.operator_ == Token::PLUS || op.operator_ == Token::MINUS || op.operator_ == Token::CMP || op.operator_ == Token::NOT) {
		getToken();
	}

	evalExp7(result);

	switch (op.operator_) {
	case Token::PLUS:
		// this may seems like a waste, but unary + can be overloaded for a type
		// to have a non-nop effect!
		result = +result;
		break;
	case Token::MINUS:
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4146)
#endif
		result = -result;
#ifdef _MSC_VER
#pragma warning(pop)
#endif
		break;
	case Token::CMP:
		result = ~result;
		break;
	case Token::NOT:
		result = !result;
		break;
	default:
		break;
	}
}

//------------------------------------------------------------------------------
// Name: evalExp7
// Desc: sub-expressions
//------------------------------------------------------------------------------
template <class T>
void Expression<T>::evalExp7(T &result) {

	switch (token_.operator_) {
	case Token::LPAREN:
		getToken();

		// get sub-expression
		evalExp0(result);

		if (token_.operator_ != Token::RPAREN) {
			throw ExpressionError(ExpressionError::UnbalancedParens);
		}

		getToken();
		break;
	case Token::RPAREN:
		throw ExpressionError(ExpressionError::UnbalancedParens);
		break;
	case Token::LBRACE:
		do {
			getToken();

			// get sub-expression
			T effective_address;
			evalExp0(effective_address);

			if (memoryReader_) {
				bool ok;
				ExpressionError error;

				result = memoryReader_(effective_address, &ok, &error);
				if (!ok) {
					throw error;
				}
			} else {
				throw ExpressionError(ExpressionError::CannotReadMemory);
			}

			if (token_.operator_ != Token::RBRACE) {
				throw ExpressionError(ExpressionError::UnbalancedBraces);
			}

			getToken();
		} while (0);
		break;
	case Token::RBRACE:
		throw ExpressionError(ExpressionError::UnbalancedBraces);
		break;
	default:
		evalAtom(result);
		break;
	}
}

//------------------------------------------------------------------------------
// Name: evalAtom
// Desc: atoms (variables/constants)
//------------------------------------------------------------------------------
template <class T>
void Expression<T>::evalAtom(T &result) {

	switch (token_.type_) {
	case Token::VARIABLE:
		if (variableReader_) {
			bool ok;
			ExpressionError error;
			result = variableReader_(token_.data_, &ok, &error);
			if (!ok) {
				throw error;
			}
		} else {
			throw ExpressionError(ExpressionError::UnknownVariable);
		}
		getToken();
		break;
	case Token::NUMBER:
		bool ok;
		result = token_.data_.toULongLong(&ok, 0);
		if (!ok) {
			throw ExpressionError(ExpressionError::InvalidNumber);
		}
		getToken();
		break;
	default:
		throw ExpressionError(ExpressionError::Syntax);
		break;
	}
}

//------------------------------------------------------------------------------
// Name: getToken
// Desc:
//------------------------------------------------------------------------------
template <class T>
void Expression<T>::getToken() {

	// clear previous token
	token_ = Token();

	// eat up white space
	while (expressionPtr_ != expression_.end() && expressionPtr_->isSpace()) {
		++expressionPtr_;
	}

	if (expressionPtr_ != expression_.end()) {

		// get the token
		switch (expressionPtr_->toLatin1()) {
		case '(':
			++expressionPtr_;
			token_.set("(", Token::LPAREN, Token::OPERATOR);
			break;
		case ')':
			++expressionPtr_;
			token_.set(")", Token::RPAREN, Token::OPERATOR);
			break;
		case '[':
			++expressionPtr_;
			token_.set("[", Token::LBRACE, Token::OPERATOR);
			break;
		case ']':
			++expressionPtr_;
			token_.set("]", Token::RBRACE, Token::OPERATOR);
			break;
		case '!':
			++expressionPtr_;
			if (expressionPtr_ != expression_.end() && *expressionPtr_ == '=') {
				++expressionPtr_;
				token_.set("!=", Token::NE, Token::OPERATOR);
			} else {
				token_.set("!", Token::NOT, Token::OPERATOR);
			}
			break;
		case '+':
			++expressionPtr_;
			token_.set("+", Token::PLUS, Token::OPERATOR);
			break;
		case '-':
			++expressionPtr_;
			token_.set("-", Token::MINUS, Token::OPERATOR);
			break;
		case '*':
			++expressionPtr_;
			token_.set("*", Token::MUL, Token::OPERATOR);
			break;
		case '/':
			++expressionPtr_;
			token_.set("/", Token::DIV, Token::OPERATOR);
			break;
		case '%':
			++expressionPtr_;
			token_.set("%", Token::MOD, Token::OPERATOR);
			break;
		case '&':
			++expressionPtr_;
			if (expressionPtr_ != expression_.end() && *expressionPtr_ == '&') {
				++expressionPtr_;
				token_.set("&&", Token::LOGICAL_AND, Token::OPERATOR);
			} else {
				token_.set("&", Token::AND, Token::OPERATOR);
			}
			break;
		case '|':
			++expressionPtr_;
			if (expressionPtr_ != expression_.end() && *expressionPtr_ == '|') {
				++expressionPtr_;
				token_.set("||", Token::LOGICAL_OR, Token::OPERATOR);
			} else {
				token_.set("|", Token::OR, Token::OPERATOR);
			}
			break;
		case '^':
			++expressionPtr_;
			token_.set("^", Token::XOR, Token::OPERATOR);
			break;
		case '~':
			++expressionPtr_;
			token_.set("~", Token::CMP, Token::OPERATOR);
			break;
		case '=':
			++expressionPtr_;
			if (expressionPtr_ != expression_.end() && *expressionPtr_ == '=') {
				++expressionPtr_;
				token_.set("==", Token::EQ, Token::OPERATOR);
			} else {
				throw ExpressionError(ExpressionError::Syntax);
			}
			break;
		case '<':
			++expressionPtr_;
			if (expressionPtr_ != expression_.end() && *expressionPtr_ == '<') {
				++expressionPtr_;
				token_.set("<<", Token::LSHFT, Token::OPERATOR);
			} else if (expressionPtr_ != expression_.end() && *expressionPtr_ == '=') {
				++expressionPtr_;
				token_.set("<=", Token::LE, Token::OPERATOR);
			} else {
				token_.set("<", Token::LT, Token::OPERATOR);
			}
			break;
		case '>':
			++expressionPtr_;
			if (expressionPtr_ != expression_.end() && *expressionPtr_ == '>') {
				++expressionPtr_;
				token_.set(">>", Token::RSHFT, Token::OPERATOR);
			} else if (expressionPtr_ != expression_.end() && *expressionPtr_ == '=') {
				++expressionPtr_;
				token_.set(">=", Token::GE, Token::OPERATOR);
			} else {
				token_.set(">", Token::GT, Token::OPERATOR);
			}
			break;
		case '"':
			++expressionPtr_;
			// Begin a quoted string
			{
				QString temp_string;

				while (expressionPtr_ != expression_.end() && *expressionPtr_ != '"') {
					temp_string += *expressionPtr_++;
				}
				if (expressionPtr_ == expression_.end()) {
					token_.set("\"" + temp_string, Token::NONE, Token::VARIABLE);
				} else {
					token_.set(temp_string, Token::NONE, Token::VARIABLE);
				}
			}
			break;
		default:
			// is it a numerical constant?
			if (expressionPtr_->isDigit()) {
				QString temp_string;

				while (expressionPtr_ != expression_.end() && !detail::is_delim(*expressionPtr_)) {
					temp_string += *expressionPtr_++;
				}

				token_.set(temp_string, Token::NONE, Token::NUMBER);
			} else {
				// it must be a variable, get its name
				QString temp_string;

				while (expressionPtr_ != expression_.end()) {
					// NOTE(eteran): the expression: "VAR !" ... is kinda
					// nonsense AND we want to allow a name to have a "!" in
					// the middle of it since we want to support symbols with
					// module notation
					if (detail::is_delim(*expressionPtr_) && *expressionPtr_ != '!') {
						break;
					}

					temp_string += *expressionPtr_++;
				}

				token_.set(temp_string, Token::NONE, Token::VARIABLE);
			}
			break;
		}
	}
}

#endif

```

`include/FloatX.h`:

```h

#ifndef FLOAT_X_H_20151108_
#define FLOAT_X_H_20151108_

#include "API.h"
#include "Types.h"
#include <QValidator>
#include <cmath>
#include <limits>
#include <type_traits>

// Only class, nothing about sign
enum class FloatValueClass {
	Zero,
	Normal,
	Infinity,
	Denormal,
	PseudoDenormal,
	QNaN,
	SNaN,
	Unsupported
};

template <class Float>
Float EDB_EXPORT read_float(const QString &input, bool &ok);

template <class Float>
class EDB_EXPORT FloatXValidator : public QValidator {
public:
	explicit FloatXValidator(QObject *parent = nullptr)
		: QValidator(parent) {}

	QValidator::State validate(QString &input, int &) const override;
};

template <class Float>
EDB_EXPORT QString format_float(Float value);

EDB_EXPORT FloatValueClass float_type(edb::value32 value);
EDB_EXPORT FloatValueClass float_type(edb::value64 value);
EDB_EXPORT FloatValueClass float_type(edb::value80 value);

// This will work not only for floats, but also for integers
template <class T>
constexpr int max_printed_length() {
	using Limits = std::numeric_limits<T>;

	constexpr bool isInteger        = Limits::is_integer;
	constexpr int mantissaChars     = isInteger ? 1 + Limits::digits10 : Limits::max_digits10;
	constexpr int signChars         = std::is_signed<T>::value;
	constexpr int expSignChars      = !isInteger;
	constexpr int decimalPointChars = !isInteger;
	constexpr int expSymbol         = !isInteger; // 'e' for floating-point value in scientific format
	const int expMaxWidth           = isInteger ? 0 : std::ceil(std::log10(Limits::max_exponent10));
	const int maxWidth              = signChars + mantissaChars + decimalPointChars + expSymbol + expSignChars + expMaxWidth;

	return maxWidth;
}

#ifdef _MSC_VER
EDB_EXPORT void convert_real64_to_real80(const void *src, void *dst);
#endif

#endif

```

`include/Function.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef FUNCTION_H_20130830_
#define FUNCTION_H_20130830_

#include "API.h"
#include "BasicBlock.h"
#include "Types.h"
#include <map>

class EDB_EXPORT Function {
public:
	enum Type {
		Standard,
		Thunk
	};

public:
	using size_type              = size_t;
	using value_type             = BasicBlock;
	using reference              = BasicBlock &;
	using const_reference        = const BasicBlock &;
	using iterator               = std::map<edb::address_t, BasicBlock>::iterator;
	using const_iterator         = std::map<edb::address_t, BasicBlock>::const_iterator;
	using reverse_iterator       = std::reverse_iterator<iterator>;
	using const_reverse_iterator = std::reverse_iterator<const_iterator>;

public:
	Function()                      = default;
	Function(const Function &other) = default;
	Function &operator=(const Function &rhs) = default;

public:
	void insert(const BasicBlock &bb);
	void addReference();
	Type type() const;
	void setType(Type t);

public:
	const_reference back() const;
	const_reference front() const;
	reference back();
	reference front();

public:
	const_iterator begin() const;
	const_iterator end() const;
	const_reverse_iterator rbegin() const;
	const_reverse_iterator rend() const;
	iterator begin();
	iterator end();
	reverse_iterator rbegin();
	reverse_iterator rend();

public:
	bool empty() const;
	size_type size() const;

public:
	edb::address_t entryAddress() const;
	edb::address_t endAddress() const;
	edb::address_t lastInstruction() const;
	int referenceCount() const;

public:
	void swap(Function &other);

private:
	int referenceCount_ = 0;
	Type type_          = Standard;
	std::map<edb::address_t, BasicBlock> blocks_;
};

#endif

```

`include/GraphEdge.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef GRAPH_EDGE_H_20090903_
#define GRAPH_EDGE_H_20090903_

#include <QColor>
#include <QGraphicsItemGroup>
#include <graphviz/cgraph.h>
#include <graphviz/gvc.h>

class GraphWidget;
class GraphNode;
class GraphicsLineItem;

class GraphEdge final : public QGraphicsItemGroup {
public:
	GraphEdge(GraphNode *from, GraphNode *to, const QColor &color = Qt::black, QGraphicsItem *parent = nullptr);
	GraphEdge(const GraphEdge &) = delete;
	GraphEdge &operator=(const GraphEdge &) = delete;
	~GraphEdge() override;

public:
	enum { Type = UserType + 3 };

	int type() const override {
		// Enable the use of qgraphicsitem_cast with this item.
		return Type;
	}

public:
	GraphNode *from() const;
	GraphNode *to() const;
	void clear();
	void syncState();

public:
	int lineThickness() const;
	QColor lineColor() const;

public:
	void updateLines();

protected:
	void createLine();
	QGraphicsPolygonItem *addArrowHead(const QLineF &line);
	QGraphicsPolygonItem *addArrowHead(const QLineF &line, int lineThickness, const QColor &color, int ZValue);
	QLineF shortenLineToNode(QLineF line);
	QGraphicsLineItem *createLineSegment(const QPointF &p1, const QPointF &p2, const QPen &pen);
	QGraphicsLineItem *createLineSegment(const QLineF &line, const QPen &pen);

protected:
	GraphNode *from_    = nullptr;
	GraphNode *to_      = nullptr;
	GraphWidget *graph_ = nullptr;
	Agedge_t *edge_     = nullptr;
	QColor color_;
};

#endif

```

`include/GraphNode.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef GRAPH_NODE_H_20090903_
#define GRAPH_NODE_H_20090903_

#include <QGraphicsItem>
#include <QPicture>
#include <QSet>
#include <graphviz/cgraph.h>
#include <graphviz/gvc.h>

class QVariant;

class GraphWidget;
class GraphEdge;

constexpr int NodeZValue        = 1;
constexpr int NodeWidth         = 100;
constexpr int NodeHeight        = 50;
constexpr int LabelFontSize     = 10;
constexpr int BorderScaleFactor = 4;

class GraphNode final : public QGraphicsItem {
	friend class GraphWidget;
	friend class GraphEdge;

public:
	GraphNode(GraphWidget *graph, const QString &text, const QColor &color = Qt::white);
	GraphNode(const GraphNode &) = delete;
	GraphNode &operator=(const GraphNode &) = delete;
	~GraphNode() override;

public:
	enum { Type = UserType + 2 };

	int type() const override {
		// Enable the use of qgraphicsitem_cast with this item.
		return Type;
	}

public:
	void setFont(const QFont &font);
	QFont font() const;

public:
	void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
	QVariant itemChange(GraphicsItemChange change, const QVariant &value) override;
	QRectF boundingRect() const override;

protected:
	void hoverEnterEvent(QGraphicsSceneHoverEvent *e) override;
	void hoverLeaveEvent(QGraphicsSceneHoverEvent *e) override;

private:
	void addEdge(GraphEdge *edge);
	void removeEdge(GraphEdge *edge);
	void drawLabel(const QString &text);

protected:
	QPicture picture_;
	QColor color_;
	GraphWidget *graph_ = nullptr;
	QSet<GraphEdge *> edges_;
	Agnode_t *node_ = nullptr;
};

#endif

```

`include/GraphWidget.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef GRAPH_WIDGET_H_20090903_
#define GRAPH_WIDGET_H_20090903_

#include <QGraphicsView>
#include <graphviz/cgraph.h>
#include <graphviz/gvcext.h>

class GraphNode;
class QContextMenuEvent;
class QGraphicsScene;
class QLabel;
class QMouseEvent;
class QString;

class GraphWidget final : public QGraphicsView {
	Q_OBJECT
	friend class GraphNode;
	friend class GraphEdge;

public:
	GraphWidget(QWidget *parent = nullptr);
	GraphWidget(const GraphWidget &) = delete;
	GraphWidget &operator=(const GraphWidget &) = delete;
	~GraphWidget() override;

public:
	void clear();
	void layout();

public Q_SLOTS:
	void setScale(qreal factor);
	void setHUDNotification(const QString &s, int duration = 1000);

Q_SIGNALS:
	void backgroundContextMenuEvent(QContextMenuEvent *event);
	void nodeContextMenuEvent(QContextMenuEvent *event, GraphNode *node);
	void nodeDoubleClickEvent(QMouseEvent *event, GraphNode *node);
	void zoomEvent(qreal factor, qreal currentScale);

protected:
	void keyPressEvent(QKeyEvent *event) override;
	void keyReleaseEvent(QKeyEvent *event) override;
	void wheelEvent(QWheelEvent *event) override;
	void contextMenuEvent(QContextMenuEvent *event) override;
	void mouseDoubleClickEvent(QMouseEvent *event) override;

private:
	void setGraphAttribute(const QString name, const QString value);
	void setNodeAttribute(const QString name, const QString value);
	void setEdgeAttribute(const QString name, const QString value);

private:
	bool inLayout_      = false;
	QLayout *HUDLayout_ = nullptr;
	QLabel *HUDLabel_   = nullptr;
	GVC_t *context_     = nullptr;
	Agraph_t *graph_    = nullptr;
};

#endif

```

`include/HexStringValidator.h`:

```h
/*
Copyright (C) 2013 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef HEX_STRING_VALIDATOR_H_20130625_
#define HEX_STRING_VALIDATOR_H_20130625_

#include <QValidator>

class QString;
class QObject;

class HexStringValidator final : public QValidator {
	Q_OBJECT
public:
	HexStringValidator(QObject *parent);

public:
	void fixup(QString &input) const override;
	State validate(QString &input, int &pos) const override;
};

#endif

```

`include/IAnalyzer.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef IANALYZER_H_20080630_
#define IANALYZER_H_20080630_

#include "Function.h"
#include "Types.h"
#include <QSet>
#include <functional>
#include <memory>

class IRegion;

template <class T, class E>
class Result;

class IAnalyzer {
public:
	virtual ~IAnalyzer() = default;

public:
	using FunctionMap = QMap<edb::address_t, Function>;

public:
	enum AddressCategory {
		ADDRESS_FUNC_UNKNOWN = 0x00,
		ADDRESS_FUNC_START   = 0x01,
		ADDRESS_FUNC_BODY    = 0x02,
		ADDRESS_FUNC_END     = 0x04
	};

public:
	virtual AddressCategory category(edb::address_t address) const              = 0;
	virtual FunctionMap functions(const std::shared_ptr<IRegion> &region) const = 0;
	virtual FunctionMap functions() const                                       = 0;
	virtual QSet<edb::address_t> specifiedFunctions() const { return {}; }
	virtual Result<edb::address_t, QString> findContainingFunction(edb::address_t address) const                                = 0;
	virtual void analyze(const std::shared_ptr<IRegion> &region)                                                                = 0;
	virtual void invalidateAnalysis()                                                                                           = 0;
	virtual void invalidateAnalysis(const std::shared_ptr<IRegion> &region)                                                     = 0;
	virtual bool forFuncsInRange(edb::address_t start, edb::address_t end, std::function<bool(const Function *)> functor) const = 0;
};

#endif

```

`include/IBinary.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef IBINARY_H_20070718_
#define IBINARY_H_20070718_

#include "API.h"
#include "Types.h"
#include <memory>
#include <vector>

class IRegion;

class EDB_EXPORT IBinary {
public:
	struct Header {
		edb::address_t address;
		size_t size;
		// TODO(eteran): maybe label/type/etc...
	};

public:
	virtual ~IBinary() = default;

public:
	virtual bool native() const                 = 0;
	virtual edb::address_t entryPoint()         = 0;
	virtual size_t headerSize() const           = 0;
	virtual const void *header() const          = 0;
	virtual std::vector<Header> headers() const = 0;

public:
	using create_func_ptr_t = std::unique_ptr<IBinary> (*)(const std::shared_ptr<IRegion> &);
};

#endif

```

`include/IBreakpoint.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef IBREAKPOINT_H_20060720_
#define IBREAKPOINT_H_20060720_

#include "Types.h"

#include <QString>
#include <exception>

class QByteArray;

class BreakpointCreationError : public std::exception {
	const char *what() const noexcept override {
		return "BreakpointCreationError";
	}
};

class IBreakpoint {
protected:
	IBreakpoint() = default;

public:
	virtual ~IBreakpoint() = default;

	enum class TypeId : int {
		Automatic, // should be the default if the user hasn't chosen anything other
	};

	struct BreakpointType {
		TypeId type;
		QString description;
	};

public:
	virtual edb::address_t address() const       = 0;
	virtual uint64_t hitCount() const            = 0;
	virtual bool enabled() const                 = 0;
	virtual bool oneTime() const                 = 0;
	virtual bool internal() const                = 0;
	virtual const uint8_t *originalBytes() const = 0;
	virtual size_t size() const                  = 0;
	virtual TypeId type() const                  = 0;

public:
	virtual bool enable()                = 0;
	virtual bool disable()               = 0;
	virtual void hit()                   = 0;
	virtual void setOneTime(bool value)  = 0;
	virtual void setInternal(bool value) = 0;
	virtual void setType(TypeId type)    = 0;

public:
	QString condition;
	quint64 tag = 0;
};

Q_DECLARE_METATYPE(IBreakpoint::TypeId)

#endif

```

`include/IDebugEvent.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef IDEBUG_EVENT_H_20121005_
#define IDEBUG_EVENT_H_20121005_

#include "OSTypes.h"
#include <QString>

class IDebugEvent {
public:
	enum REASON {
		EVENT_EXITED,     // exited normally
		EVENT_TERMINATED, // terminated by event
		EVENT_STOPPED,    // normal event
		EVENT_UNKNOWN
	};

	enum TRAP_REASON {
		TRAP_STEPPING,
		TRAP_BREAKPOINT
	};

	struct Message {
		Message() = default;
		Message(const QString &c, const QString &m, const QString &s)
			: caption(c), message(m), statusMessage(s) {
		}

		QString caption;
		QString message;
		QString statusMessage;
	};

public:
	virtual ~IDebugEvent() = default;

public:
	virtual IDebugEvent *clone() const = 0;

public:
	virtual Message errorDescription() const = 0;
	virtual REASON reason() const            = 0;
	virtual TRAP_REASON trapReason() const   = 0;
	virtual bool exited() const              = 0;
	virtual bool isError() const             = 0;
	virtual bool isKill() const              = 0;
	virtual bool isStop() const              = 0;
	virtual bool isTrap() const              = 0;
	virtual bool stopped() const             = 0;
	virtual bool terminated() const          = 0;
	virtual edb::pid_t process() const       = 0;
	virtual edb::tid_t thread() const        = 0;
	virtual int64_t code() const             = 0;
};

#endif

```

`include/IDebugEventHandler.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef IDEBUG_EVENT_HANDLER_H_20061101_
#define IDEBUG_EVENT_HANDLER_H_20061101_

#include "Types.h"
#include <memory>

class IDebugEvent;

class IDebugEventHandler {
public:
	virtual ~IDebugEventHandler() = default;

public:
	virtual edb::EventStatus handleEvent(const std::shared_ptr<IDebugEvent> &event) = 0;
};

#endif

```

`include/IDebugger.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef IDEBUGGER_H_20061101_
#define IDEBUGGER_H_20061101_

#include "IBreakpoint.h"
#include "OSTypes.h"
#include "Types.h"
#include <QByteArray>
#include <QHash>
#include <QMap>
#include <QString>
#include <QtPlugin>
#include <chrono>
#include <memory>
#include <vector>

class IDebugEvent;
class IProcess;
class IState;
class State;
class Status;

class IDebugger {
public:
	using BreakpointList = QHash<edb::address_t, std::shared_ptr<IBreakpoint>>;

public:
	virtual ~IDebugger() = default;

public:
	enum class CpuMode {
		Unknown,
#if defined(EDB_X86) || defined(EDB_X86_64)
		x86_16,
		x86_32,
		x86_64,
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
		ARM32,
		Thumb,
		ARM64,
#endif
	};

public:
	// system properties
	virtual std::size_t pageSize() const                  = 0;
	virtual std::size_t pointerSize() const               = 0;
	virtual uint64_t cpuType() const                      = 0;
	virtual CpuMode cpuMode() const                       = 0;
	virtual bool hasExtension(uint64_t ext) const         = 0;
	virtual QMap<qlonglong, QString> exceptions() const   = 0;
	virtual QString exceptionName(qlonglong value)        = 0;
	virtual qlonglong exceptionValue(const QString &name) = 0;
	virtual uint8_t nopFillByte() const                   = 0;

public:
	// important register names
	virtual QString stackPointer() const       = 0;
	virtual QString framePointer() const       = 0;
	virtual QString instructionPointer() const = 0;
	virtual QString flagRegister() const       = 0;

public:
	// general process data
	virtual edb::pid_t parentPid(edb::pid_t pid) const                             = 0;
	virtual QMap<edb::pid_t, std::shared_ptr<IProcess>> enumerateProcesses() const = 0;

public:
	// basic process management
	virtual Status attach(edb::pid_t pid)                                                                                                    = 0;
	virtual Status open(const QString &path, const QString &cwd, const QList<QByteArray> &args, const QString &input, const QString &output) = 0;
	virtual std::shared_ptr<IDebugEvent> waitDebugEvent(std::chrono::milliseconds msecs)                                                     = 0;
	virtual Status detach()                                                                                                                  = 0;
	virtual void kill()                                                                                                                      = 0;
	virtual void endDebugSession()                                                                                                           = 0;

public:
	// basic breakpoint managment
	// TODO(eteran): these should be logically moved to IProcess
	virtual BreakpointList backupBreakpoints() const                                     = 0;
	virtual std::shared_ptr<IBreakpoint> addBreakpoint(edb::address_t address)           = 0;
	virtual std::shared_ptr<IBreakpoint> findBreakpoint(edb::address_t address)          = 0;
	virtual std::shared_ptr<IBreakpoint> findTriggeredBreakpoint(edb::address_t address) = 0;
	virtual void clearBreakpoints()                                                      = 0;
	virtual void removeBreakpoint(edb::address_t address)                                = 0;
	virtual std::vector<IBreakpoint::BreakpointType> supportedBreakpointTypes() const    = 0;

public:
	virtual void setIgnoredExceptions(const QList<qlonglong> &exceptions) = 0;

public:
	virtual std::unique_ptr<IState> createState() const = 0;

public:
	// nullptr if not attached
	virtual IProcess *process() const = 0;
};

Q_DECLARE_INTERFACE(IDebugger, "edb.IDebugger/1.0")

#endif

```

`include/IPlugin.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef IPLUGIN_H_20061101_
#define IPLUGIN_H_20061101_

#include <QList>
#include <QVariantMap>
#include <QtPlugin>

class QMenu;
class QAction;

class IPlugin {
public:
	virtual ~IPlugin() = default;

public:
	void init() {
		privateInit();
	}

	void fini() {
		privateFini();
	}

public:
	virtual QMenu *menu(QWidget *parent = nullptr) = 0;

public:
	// optional, overload these to have there contents added to a view's context menu
	virtual QList<QAction *> cpuContextMenu() { return {}; }
	virtual QList<QAction *> registerContextMenu() { return {}; }
	virtual QList<QAction *> stackContextMenu() { return {}; }
	virtual QList<QAction *> dataContextMenu() { return {}; }

	// optional, overload this to add a page to the options dialog
	virtual QWidget *optionsPage() { return nullptr; }

public:
	virtual QVariantMap saveState() const { return {}; }
	virtual void restoreState(const QVariantMap &) {}

public:
	enum ArgumentStatus {
		ARG_SUCCESS,
		ARG_ERROR,
		ARG_EXIT
	};

	// optional, command line argument processing
	// return a string to add to "--help"
	virtual QString extraArguments() const { return {}; }

	// take actions based on the command line arguments
	// you *may* remove arguments which are exclusively yours
	// return ARG_SUCCESS if the normal execution should continue
	// return ARG_ERROR   if we should show usage and exit
	// return ARG_EXIT    if you processed the arguments and we should terminate successfully
	virtual ArgumentStatus parseArguments(QStringList &) { return ARG_SUCCESS; }

protected:
	// optional init, overload this to have edb run it after loading the plugin
	virtual void privateInit() {
	}

	// optional fini, overload this to have edb run it before unloading the plugin
	virtual void privateFini() {
	}
};

Q_DECLARE_INTERFACE(IPlugin, "edb.IPlugin/1.0")

#endif

```

`include/IProcess.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef IPROCESS_H_20150516_
#define IPROCESS_H_20150516_

#include "OSTypes.h"
#include "Patch.h"
#include "Status.h"
#include "Types.h"
#include <QList>
#include <QMap>
#include <memory>

class IRegion;
class IThread;
class QDateTime;
class QString;
struct Module;

class IProcess {
public:
	virtual ~IProcess() = default;

public:
	// legal to call when not attached
	virtual QDateTime startTime() const                     = 0;
	virtual QList<QByteArray> arguments() const             = 0;
	virtual QString currentWorkingDirectory() const         = 0;
	virtual QString executable() const                      = 0;
	virtual QString stardardInput() const                   = 0;
	virtual QString stardardOutput() const                  = 0;
	virtual edb::pid_t pid() const                          = 0;
	virtual std::shared_ptr<IProcess> parent() const        = 0;
	virtual edb::address_t codeAddress() const              = 0;
	virtual edb::address_t dataAddress() const              = 0;
	virtual edb::address_t entryPoint() const               = 0;
	virtual QList<std::shared_ptr<IRegion>> regions() const = 0;
	virtual edb::uid_t uid() const                          = 0;
	virtual QString user() const                            = 0;
	virtual QString name() const                            = 0;
	virtual QList<Module> loadedModules() const             = 0;

public:
	virtual edb::address_t debugPointer() const { return 0; }
	virtual edb::address_t calculateMain() const { return 0; }

public:
	// only legal to call when attached
	virtual QList<std::shared_ptr<IThread>> threads() const                              = 0;
	virtual std::shared_ptr<IThread> currentThread() const                               = 0;
	virtual void setCurrentThread(IThread &thread)                                       = 0;
	virtual std::size_t writeBytes(edb::address_t address, const void *buf, size_t len)  = 0;
	virtual std::size_t patchBytes(edb::address_t address, const void *buf, size_t len)  = 0;
	virtual std::size_t readBytes(edb::address_t address, void *buf, size_t len) const   = 0;
	virtual std::size_t readPages(edb::address_t address, void *buf, size_t count) const = 0;
	virtual Status pause()                                                               = 0;
	virtual Status resume(edb::EventStatus status)                                       = 0;
	virtual Status step(edb::EventStatus status)                                         = 0;
	virtual bool isPaused() const                                                        = 0;
	virtual QMap<edb::address_t, Patch> patches() const                                  = 0;
};

#endif

```

`include/IRegion.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef IREGION_H_20120709_
#define IREGION_H_20120709_

#include "Types.h"
#include <memory>

class QString;

class IRegion {
public:
	using permissions_t = quint32;

public:
	virtual ~IRegion() = default;

public:
	virtual IRegion *clone() const = 0;

public:
	virtual bool accessible() const = 0;
	virtual bool readable() const   = 0;
	virtual bool writable() const   = 0;
	virtual bool executable() const = 0;
	virtual size_t size() const     = 0;

public:
	virtual void setPermissions(bool read, bool write, bool execute) = 0;
	virtual void setStart(edb::address_t address)                    = 0;
	virtual void setEnd(edb::address_t address)                      = 0;

public:
	virtual edb::address_t start() const      = 0;
	virtual edb::address_t end() const        = 0; // NOTE: is the address of one past the last byte of the region
	virtual edb::address_t base() const       = 0;
	virtual QString name() const              = 0;
	virtual permissions_t permissions() const = 0;

public:
	bool contains(edb::address_t address) const {
		return address >= start() && address < end();
	}

	template <class Pointer>
	bool equals(const Pointer &other) const {

		if (!other) {
			return false;
		}

		return start() == other->start() &&
			   end() == other->end() &&
			   base() == other->base() &&
			   name() == other->name() &&
			   permissions() == other->permissions();
	}
};

#endif

```

`include/IState.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ISTATE_H_20110315_
#define ISTATE_H_20110315_

#include <memory>
#include "Register.h"
#include "Types.h"

// TODO(eteran): This file is still too taylored to x86 and family
// we should develop a better abstraction model at some point

class IState {
public:
	virtual ~IState() = default;

public:
	virtual std::unique_ptr<IState> clone() const = 0;

public:
	virtual QString flagsToString() const                           = 0;
	virtual QString flagsToString(edb::reg_t flags) const           = 0;
	virtual Register value(const QString &reg) const                = 0;
	virtual Register instructionPointerRegister() const             = 0;
	virtual Register flagsRegister() const                          = 0;
	virtual edb::address_t framePointer() const                     = 0;
	virtual edb::address_t instructionPointer() const               = 0;
	virtual edb::address_t stackPointer() const                     = 0;
	virtual edb::reg_t debugRegister(size_t n) const                = 0;
	virtual edb::reg_t flags() const                                = 0;
	virtual void adjustStack(int bytes)                             = 0;
	virtual void clear()                                            = 0;
	virtual bool empty() const                                      = 0;
	virtual void setDebugRegister(size_t n, edb::reg_t value)       = 0;
	virtual void setFlags(edb::reg_t flags)                         = 0;
	virtual void setInstructionPointer(edb::address_t value)        = 0;
	virtual void setRegister(const QString &name, edb::reg_t value) = 0;
	virtual void setRegister(const Register &reg)                   = 0;

public:
	// GP
	virtual Register gpRegister(size_t n) const = 0;

public:
	// This is a more generic means to request architecture
	// specific registers. The type should be the result of
	// edb::string_hash, for example:
	// edb::string_hash("mmx"), string_hash("xmm"), and string_hash("ymm")
	// This will allow this interface to be much more platform independent
	virtual Register archRegister(uint64_t type, size_t n) const = 0;

#if defined(EDB_X86) || defined(EDB_X86_64)
public:
	// FPU
	virtual int fpuStackPointer() const                       = 0;
	virtual bool fpuRegisterIsEmpty(std::size_t n) const      = 0;
	virtual edb::value80 fpuRegister(size_t n) const          = 0;
	virtual QString fpuRegisterTagString(std::size_t n) const = 0;
	virtual edb::value16 fpuControlWord() const               = 0;
	virtual edb::value16 fpuStatusWord() const                = 0;
	virtual edb::value16 fpuTagWord() const                   = 0;
#endif
};

#endif

```

`include/ISymbolGenerator.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ISYMBOL_GENERATOR_H_20130808_
#define ISYMBOL_GENERATOR_H_20130808_

class QString;

class ISymbolGenerator {
public:
	virtual ~ISymbolGenerator() = default;

public:
	virtual bool generateSymbolFile(const QString &filename, const QString &symbol_file) = 0;
};

#endif

```

`include/ISymbolManager.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ISYMBOL_MANAGER_H_20110307_
#define ISYMBOL_MANAGER_H_20110307_

#include "Types.h"
#include <QHash>
#include <memory>
#include <vector>

class QString;
class Symbol;
class ISymbolGenerator;

class ISymbolManager {
public:
	virtual ~ISymbolManager() = default;

public:
	virtual const std::vector<std::shared_ptr<Symbol>> symbols() const                 = 0;
	virtual const std::shared_ptr<Symbol> find(const QString &name) const              = 0;
	virtual const std::shared_ptr<Symbol> find(edb::address_t address) const           = 0;
	virtual const std::shared_ptr<Symbol> findNearSymbol(edb::address_t address) const = 0;
	virtual void addSymbol(const std::shared_ptr<Symbol> &symbol)                      = 0;
	virtual void clear()                                                               = 0;
	virtual void loadSymbolFile(const QString &filename, edb::address_t base)          = 0;
	virtual void setSymbolGenerator(ISymbolGenerator *generator)                       = 0;
	virtual void setLabel(edb::address_t address, const QString &label)                = 0;
	virtual QString findAddressName(edb::address_t address, bool prefixed = true)      = 0;
	virtual QHash<edb::address_t, QString> labels() const                              = 0;
	virtual QStringList files() const                                                  = 0;
};

#endif

```

`include/IThread.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ITHREAD_H_20150529_
#define ITHREAD_H_20150529_

#include "OSTypes.h"
#include "Status.h"
#include "Types.h"

class State;

class IThread {
public:
	virtual ~IThread() = default;

public:
	virtual edb::tid_t tid() const                    = 0;
	virtual QString name() const                      = 0;
	virtual int priority() const                      = 0;
	virtual edb::address_t instructionPointer() const = 0;
	virtual QString runState() const                  = 0;

public:
	virtual void getState(State *state)       = 0;
	virtual void setState(const State &state) = 0;

public:
	virtual Status step()                          = 0;
	virtual Status step(edb::EventStatus status)   = 0;
	virtual Status resume()                        = 0;
	virtual Status resume(edb::EventStatus status) = 0;

public:
	virtual bool isPaused() const = 0;
};

#endif

```

`include/Instruction.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "../src/capstone-edb/include/Instruction.h"

```

`include/MemoryRegions.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef MEMORY_REGIONS_H_20060501_
#define MEMORY_REGIONS_H_20060501_

#include "API.h"
#include "Types.h"
#include <QAbstractItemModel>
#include <QList>
#include <memory>

class IRegion;

class EDB_EXPORT MemoryRegions final : public QAbstractItemModel {
	Q_OBJECT

public:
	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex &index) const override;
	QVariant data(const QModelIndex &index, int role) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
	int columnCount(const QModelIndex &parent = QModelIndex()) const override;
	int rowCount(const QModelIndex &parent = QModelIndex()) const override;

public:
	MemoryRegions();
	~MemoryRegions() override = default;

public:
	std::shared_ptr<IRegion> findRegion(edb::address_t address) const;
	const QList<std::shared_ptr<IRegion>> &regions() const { return regions_; }
	void clear();
	void sync();

private:
	QList<std::shared_ptr<IRegion>> regions_;
};

#endif

```

`include/Module.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef MODULE_H_20191119_
#define MODULE_H_20191119_

#include "Types.h"
#include <QString>

struct Module {
	QString name;
	edb::address_t baseAddress;
};

#endif

```

`include/Patch.h`:

```h
/*
Copyright (C) 2017 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PATCH_H_20191119_
#define PATCH_H_20191119_

#include "Types.h"
#include <QByteArray>

struct Patch {
	edb::address_t address;
	QByteArray origBytes;
	QByteArray newBytes;
};

#endif

```

`include/Prototype.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PROTOTYPE_H_20070320_
#define PROTOTYPE_H_20070320_

#include <QString>
#include <vector>

namespace edb {

struct Argument {
	QString name;
	QString type;
};

struct Prototype {
	QString name;
	QString type;
	bool noreturn;
	std::vector<Argument> arguments;
};

}

#endif

```

`include/QLongValidator.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef QLONG_VALIDATOR_H_20071128_
#define QLONG_VALIDATOR_H_20071128_

#include "API.h"
#include <QValidator>
#include <cstdint>

class EDB_EXPORT QLongValidator : public QValidator {
	Q_OBJECT
public:
	using value_type = std::int64_t;

public:
	explicit QLongValidator(QObject *parent = nullptr);
	QLongValidator(value_type minimum, value_type maximum, QObject *parent = nullptr);
	~QLongValidator() override = default;

public:
	value_type bottom() const;
	value_type top() const;
	QValidator::State validate(QString &input, int &pos) const override;
	void setRange(value_type bottom, value_type top);
	void setBottom(value_type bottom);
	void setTop(value_type top);

private:
	value_type minimum_ = 0;
	value_type maximum_ = 0;
};

#endif

```

`include/QULongValidator.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef QULONG_VALIDATOR_H_20071128_
#define QULONG_VALIDATOR_H_20071128_

#include "API.h"
#include <QValidator>
#include <cstdint>

class EDB_EXPORT QULongValidator : public QValidator {
	Q_OBJECT
public:
	using value_type = std::uint64_t;

public:
	explicit QULongValidator(QObject *parent = nullptr);
	QULongValidator(value_type minimum, value_type maximum, QObject *parent = nullptr);
	~QULongValidator() override = default;

public:
	value_type bottom() const;
	value_type top() const;
	QValidator::State validate(QString &input, int &pos) const override;
	void setRange(value_type bottom, value_type top);
	void setBottom(value_type bottom);
	void setTop(value_type top);

private:
	value_type minimum_ = 0;
	value_type maximum_ = 0;
};

#endif

```

`include/QtHelper.h`:

```h

#ifndef QT_HELPER_H_20191119_
#define QT_HELPER_H_20191119_

#include <QCoreApplication>

#define Q_DECLARE_NAMESPACE_TR(context)                                                             \
	inline QString tr(const char *sourceText, const char *disambiguation = Q_NULLPTR, int n = -1) { \
		return QCoreApplication::translate(#context, sourceText, disambiguation, n);                \
	}

#endif

```

`include/Register.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef REGISTER_H_20100329_
#define REGISTER_H_20100329_

#include "API.h"
#include "Types.h"
#include "Util.h"
#include <QCoreApplication>
#include <QString>
#include <cassert>
#include <cstring>
#include <type_traits>

class EDB_EXPORT Register {
	Q_DECLARE_TR_FUNCTIONS(Register)

public:
	enum Type {
		// groups, these catagories should remain as portable as possible
		TYPE_INVALID = 0x0000,
		TYPE_GPR     = 0x0001,
		TYPE_IP      = 0x0002,
		TYPE_SEG     = 0x0004,
		TYPE_COND    = 0x0008,
		TYPE_FPU     = 0x0010,
		TYPE_SIMD    = 0x0020,
	};

	// Expand when AVX-512 instructions and state are supported
	using StoredType = edb::value256;

public:
	Register();
	Register(const Register &other) = default;
	Register &operator=(const Register &rhs) = default;

public:
	bool operator==(const Register &rhs) const;
	bool operator!=(const Register &rhs) const;

public:
	bool valid() const { return type_ != TYPE_INVALID; }
	explicit operator bool() const { return valid(); }

	Type type() const { return type_; }
	QString name() const { return name_; }
	std::size_t bitSize() const { return bitSize_; }
	const char *rawData() const { return reinterpret_cast<const char *>(&value_); }

	template <class T>
	T value() const { return T(value_); }

	// Return the value, zero-extended to address_t to be usable in address calculations
	edb::address_t valueAsAddress() const;

	uint64_t valueAsInteger() const {
		return valueAsAddress().toUint();
	}

	int64_t valueAsSignedInteger() const {
		uint64_t result = valueAsInteger();
		// If MSB is set, sign extend the result
		if (result & (1ll << (bitSize_ - 1))) {
			result = -1ll;
			std::memcpy(&result, &value_, bitSize_ / 8);
		}
		return result;
	}

	void setScalarValue(std::uint64_t newValue);

	template <typename T>
	void setValueFrom(const T &source) {
		assert(bitSize_ <= 8 * sizeof(source));

		// NOTE(eteran): used to avoid warnings from GCC >= 8.2
		auto from = reinterpret_cast<const char *>(&source);
		auto to   = reinterpret_cast<char *>(&value_);

		std::memcpy(to, from, bitSize_ / 8);
	}

	QString toHexString() const;

private:
	QString name_        = tr("<unknown>");
	StoredType value_    = {};
	Type type_           = TYPE_INVALID;
	std::size_t bitSize_ = 0;

	template <std::size_t bitSize, typename T>
	friend Register make_Register(const QString &name, T value, Register::Type type);
};

template <std::size_t BitSize, typename T>
Register make_Register(const QString &name, T value, Register::Type type) {

	constexpr std::size_t bitSize = (BitSize ? BitSize : 8 * sizeof(T));
	static_assert(BitSize % 8 == 0, "Strange bit size");

	Register reg;
	reg.name_    = name;
	reg.type_    = type;
	reg.bitSize_ = bitSize;

	constexpr std::size_t size = bitSize / 8;
	static_assert(size <= sizeof(T), "ValueType appears smaller than size specified");
	util::mark_memory(&reg.value_, sizeof(reg.value_));

	// NOTE(eteran): used to avoid warnings from GCC >= 8.2
	auto from = reinterpret_cast<const char *>(&value);
	auto to   = reinterpret_cast<char *>(&reg.value_);

	std::memcpy(to, from, size);

	return reg;
}

template <typename T>
Register make_Register(const QString &name, T value, Register::Type type) {
	return make_Register<0>(name, value, type);
}

#endif

```

`include/RegisterRef.h`:

```h

// inspired from code from mozilla: https://github.com/mozilla/rr/blob/master/src/Registers.cc

#ifndef REGISTER_REF_H_20191119_
#define REGISTER_REF_H_20191119_

#include <cassert>
#include <climits>
#include <cstddef>
#include <cstdint>
#include <cstring>

class RegisterRef {
public:
	constexpr RegisterRef(const char *name, const void *ptr, std::size_t size)
		: name_(name), ptr_(ptr), size_(size) {
	}

	constexpr RegisterRef()          = default;
	RegisterRef(const RegisterRef &) = default;
	RegisterRef &operator=(const RegisterRef &) = default;

public:
	const void *data() const { return ptr_; }

public:
	bool operator==(const RegisterRef &rhs) const { return size_ == rhs.size_ && std::memcmp(ptr_, rhs.ptr_, size_) == 0; }
	bool operator!=(const RegisterRef &rhs) const { return size_ != rhs.size_ || std::memcmp(ptr_, rhs.ptr_, size_) != 0; }

public:
	bool valid() const { return ptr_ != nullptr; }

public:
	// The name of this register.
	const char *name_ = nullptr;

	// The ptr to register in state structure.
	const void *ptr_ = nullptr;

	// The size of the register. 0 means we cannot read it.
	std::size_t size_ = 0;
};

#endif

```

`include/RegisterViewModelBase.h`:

```h

#ifndef REGISTER_VIEW_MODEL_BASE_H_20151206_
#define REGISTER_VIEW_MODEL_BASE_H_20151206_

#include "Register.h"
#include "util/Integer.h"
#include <QAbstractItemModel>
#include <deque>
#include <memory>
#include <vector>

Q_DECLARE_METATYPE(std::vector<NumberDisplayMode>)
Q_DECLARE_METATYPE(Register)

namespace RegisterViewModelBase {

class RegisterViewItem;
class AbstractRegisterItem;
class CategoriesHolder;
class Category;
class SIMDCategory;
class FPUCategory;

class EDB_EXPORT Model : public QAbstractItemModel {
	Q_OBJECT

public:
	enum Column {
		NAME_COLUMN,
		VALUE_COLUMN,
		COMMENT_COLUMN,
		NUM_COLS
	};

	enum class ElementSize {
		BYTE  = 1,
		WORD  = 2,
		DWORD = 4,
		QWORD = 8,
	};

	enum SizesOrder {
		BYTES_ROW,
		WORDS_ROW,
		DWORDS_ROW,
		QWORDS_ROW
	};

	enum FormatsOrder {
		SIMD_HEX_ROW,
		SIMD_SIGNED_ROW,
		SIMD_UNSIGNED_ROW,
		SIMD_FLOAT_ROW
	};

	enum FPUFormatsOrder {
		FPU_HEX_ROW,
		FPU_FLOAT_ROW
	};

	enum Role {
		// true if changed, false otherwise
		// Property of: register's value column
		RegisterChangedRole = Qt::UserRole,
		// fixed length of text (name, value) or undefined (0) if it's not fixed (comment)
		// Type: int
		FixedLengthRole,
		// QByteArray with raw data
		// Property of: register's value column
		RawValueRole,
		// What user chose to be current size of SIMD element.
		// Type: ElementSize
		// Property of: Category
		ChosenSIMDSizeRole,
		// What user chose to be current format of SIMD element.
		// Type: NumberDisplayMode
		// Property of: Category
		ChosenSIMDFormatRole,
		// What row to take in given register index to get chosen-sized elements root
		// Type: int
		// Property of: Category
		ChosenSIMDSizeRowRole,
		// What row to take in given sized element to get chosen-formatted element
		// Type: int
		// Property of: Category
		ChosenSIMDFormatRowRole,
		// Which SIMD formats are valid to be set.
		// Type: std::vector<NumberDisplayMode>
		// Property of: Category
		ValidSIMDFormatsRole,
		// Whether the index corresponds to a normal register, i.e. not a bit field nor a SIMD element
		// Type: bool
		IsNormalRegisterRole,
		// Whether the index corresponds to a bit field of a normal register
		// Type: bool
		IsBitFieldRole,
		// Whether the index corresponds to an element of a SIMD register
		// Type: bool
		IsSIMDElementRole,
		// Whether the index corresponds to any-sized FPU register
		// Type: bool
		IsFPURegisterRole,
		// Offset of bit field in the register, starting from least significant bit
		// Type: int
		BitFieldOffsetRole,
		// Length of bit field in bits
		// Type: int
		BitFieldLengthRole,
		// Value as EDB's Register
		// Type: Register
		ValueAsRegisterRole,

		// What user chose to be current format of FPU registers
		// Type: NumberDisplayMode
		// Property of: Category
		ChosenFPUFormatRole,
		// What row to take in given register to get chosen-formatted value
		// Type: int
		// Property of: Category
		ChosenFPUFormatRowRole,

		FirstConcreteRole = Qt::UserRole + 10000 // first role available for use in derived models
	};

	Model(QObject *parent = nullptr);
	~Model() override = default;

public:
	int rowCount(const QModelIndex &parent = QModelIndex()) const override;
	int columnCount(const QModelIndex &parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex &index) const override;
	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override;
	QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
	bool setData(const QModelIndex &index, const QVariant &data, int role = Qt::EditRole) override;
	Qt::ItemFlags flags(const QModelIndex &index) const override;

public:
	void setActiveIndex(const QModelIndex &newActiveIndex);
	QModelIndex activeIndex() const;

public:
	void setChosenSIMDSize(const QModelIndex &index, ElementSize newSize);
	void setChosenSIMDFormat(const QModelIndex &index, NumberDisplayMode newFormat);
	void setChosenFPUFormat(const QModelIndex &index, NumberDisplayMode newFormat);

	// Should be called after updating all the data
	void dataUpdateFinished();
	// should be called when the debugger is about to resume, to save current register values to previous
	void saveValues();

protected:
	// All categories are there to stay after they've been inserted
	Category *addCategory(const QString &name);
	FPUCategory *addFPUCategory(const QString &name);
	SIMDCategory *addSIMDCategory(const QString &name, const std::vector<NumberDisplayMode> &validFormats);
	void hide(Category *cat);
	void show(Category *cat);
	void hide(AbstractRegisterItem *reg);
	void show(AbstractRegisterItem *reg);
	void hideAll();

private:
	std::unique_ptr<CategoriesHolder> rootItem;
	QPersistentModelIndex activeIndex_;

Q_SIGNALS:
	void SIMDDisplayFormatChanged();
	void FPUDisplayFormatChanged();
};

inline std::ostream &operator<<(std::ostream &os, Model::ElementSize size) {
	os << static_cast<std::underlying_type<Model::ElementSize>::type>(size);
	return os;
}

class RegisterViewItem {
protected:
	RegisterViewItem *parentItem = nullptr;
	int row_                     = -1;
	QString name_;

public:
	RegisterViewItem(const QString &name)
		: name_(name) {
	}

	virtual ~RegisterViewItem() = default;

public:
	void init(RegisterViewItem *parent, int row);

	virtual RegisterViewItem *parent() const {
		return parentItem;
	}

	QString name() const {
		return name_;
	}

	virtual int row() const {
		Q_ASSERT(row_ != -1);
		return row_;
	}

	virtual bool changed() const {
		return false;
	}

	virtual RegisterViewItem *child(int /*row*/) {
		return nullptr;
	}

	virtual int childCount() const {
		return 0;
	}

	virtual QVariant data(int /*column*/) const {
		return QVariant();
	}

	virtual int valueMaxLength() const {
		return 0;
	}

public:
	virtual QByteArray rawValue() const = 0;
};

class AbstractRegisterItem : public RegisterViewItem {
protected:
	AbstractRegisterItem(const QString &name)
		: RegisterViewItem(name) {
	}

public:
	// check whether it has some valid value (not unknown etc.)
	virtual bool valid() const = 0;
	// Should be used when EDB is about to resume execution of debuggee —
	// so that it's possible to check whether it changed on next stop
	virtual void saveValue() = 0;
	// clear all data, mark them unknown, both for current and previous states
	virtual void invalidate()                      = 0;
	virtual bool setValue(const QString &valueStr) = 0;
	virtual bool setValue(const QByteArray &value) = 0;
	virtual bool setValue(const Register &reg)     = 0;
};

template <class StoredType>
class RegisterItem : public AbstractRegisterItem {
protected:
	QString comment_;
	StoredType value_;
	StoredType prevValue_;
	bool valueKnown_     = false;
	bool prevValueKnown_ = false;

protected:
	virtual QString valueString() const;

public:
	RegisterItem(const QString &name);
	bool valid() const override;
	void saveValue() override;
	bool changed() const override;
	void invalidate() override;
	int childCount() const override;
	RegisterViewItem *child(int) override;
	QVariant data(int column) const override;
	QByteArray rawValue() const override;
	bool setValue(const QString &valueStr) override;
	bool setValue(const QByteArray &value) override;
	bool setValue(const Register &reg) override;
};

template <class StoredType>
class SimpleRegister : public RegisterItem<StoredType> {
public:
	SimpleRegister(const QString &name)
		: RegisterItem<StoredType>(name) {
	}

public:
	virtual void update(const StoredType &newValue, const QString &newComment);
	int valueMaxLength() const override;
};

struct BitFieldDescriptionEx {
	QString name;
	unsigned offset;
	unsigned length;
	std::vector<QString> explanations;

	// Prevent compiler warnings about missing initializer: make default argument explicitly default
	BitFieldDescriptionEx(QString name, unsigned offset, unsigned length, std::vector<QString> explanations = std::vector<QString>())
		: name(name), offset(offset), length(length), explanations(explanations) {
	}
};

class BitFieldProperties {
public:
	virtual ~BitFieldProperties()   = default;
	virtual unsigned offset() const = 0;
	virtual unsigned length() const = 0;
};

template <class UnderlyingType>
class FlagsRegister;

template <class UnderlyingType>
class BitFieldItem final : public RegisterViewItem, public BitFieldProperties {
protected:
	unsigned offset_;
	unsigned length_;
	std::vector<QString> explanations;

protected:
	FlagsRegister<UnderlyingType> *reg() const;
	UnderlyingType lengthToMask() const;
	UnderlyingType calcValue(UnderlyingType regVal) const;
	UnderlyingType value() const;
	UnderlyingType prevValue() const;

public:
	BitFieldItem(const BitFieldDescriptionEx &descr);

public:
	QVariant data(int column) const override;
	bool changed() const override;
	int valueMaxLength() const override;
	QByteArray rawValue() const override;

	unsigned offset() const override;
	unsigned length() const override;
};

template <class StoredType>
class FlagsRegister final : public SimpleRegister<StoredType> {
	template <class UnderlyingType>
	friend class BitFieldItem;

public:
	FlagsRegister(const QString &name, const std::vector<BitFieldDescriptionEx> &bitFields);

public:
	RegisterViewItem *child(int) override;
	int childCount() const override;

protected:
	std::vector<BitFieldItem<StoredType>> fields;
};

template <class StoredType>
class SIMDRegister;

template <class StoredType, class SizingType>
class SIMDFormatItem final : public RegisterViewItem {
public:
	SIMDFormatItem(NumberDisplayMode format);

public:
	using RegisterViewItem::name;

public:
	NumberDisplayMode format() const;
	QByteArray rawValue() const override;
	QVariant data(int column) const override;
	bool changed() const override;
	int valueMaxLength() const override;

private:
	QString name(NumberDisplayMode format) const;

private:
	NumberDisplayMode format_;
};

class SIMDElement {}; // generic non-templated class to dynamic_cast to

template <class StoredType, class SizingType>
class SIMDSizedElement final : public RegisterViewItem, public SIMDElement {
	friend class SIMDFormatItem<StoredType, SizingType>;

public:
	SIMDSizedElement(const QString &name, const std::vector<NumberDisplayMode> &validFormats);

public:
	QByteArray rawValue() const override;
	QVariant data(int column) const override;
	RegisterViewItem *child(int row) override;
	bool changed() const override;
	int childCount() const override;
	int valueMaxLength() const override;

private:
	QString valueString() const;
	SIMDRegister<StoredType> *reg() const;
	SizingType value() const;
	bool valid() const;

private:
	std::vector<SIMDFormatItem<StoredType, SizingType>> formats;
};

template <class StoredType>
class SIMDSizedElementsContainer final : public RegisterViewItem {
	template <class SizeType, class... Args>
	void addElement(Args &&...args);

protected:
	std::vector<std::unique_ptr<RegisterViewItem>> elements;

public:
	SIMDSizedElementsContainer(const QString &name, std::size_t size, const std::vector<NumberDisplayMode> &validFormats);
	SIMDSizedElementsContainer(SIMDSizedElementsContainer &&other) noexcept;
	RegisterViewItem *child(int row) override;
	int childCount() const override;
	QVariant data(int column) const override;
	QByteArray rawValue() const override;
	bool changed() const override;
};

template <class StoredType>
class SIMDRegister final : public SimpleRegister<StoredType> {
	template <class U, class V>
	friend class SIMDSizedElement;

protected:
	std::deque<SIMDSizedElementsContainer<StoredType>> sizedElementContainers;

	SIMDCategory *category() const;

public:
	SIMDRegister(const QString &name, const std::vector<NumberDisplayMode> &validFormats);
	int childCount() const override;
	RegisterViewItem *child(int) override;
	QVariant data(int column) const override;
};

class GenericFPURegister {}; // generic non-templated class to dynamic_cast to

template <class FloatType>
class FPURegister final : public SimpleRegister<FloatType>, public GenericFPURegister {
	template <class U, class V>
	friend class SIMDFormatItem;

public:
	FPURegister(const QString &name);

public:
	QString valueString() const override;
	RegisterViewItem *child(int) override;
	int childCount() const override;
	int valueMaxLength() const override;
	void saveValue() override;
	void update(const FloatType &newValue, const QString &newComment) override;

protected:
	FPUCategory *category() const;

private:
	FloatType value() const;

protected:
	std::vector<SIMDFormatItem<FloatType, FloatType>> formats;
};

class Category : public RegisterViewItem {
public:
	Category(const QString &name, int row);
	Category(Category &&other) noexcept;

public:
	AbstractRegisterItem *getRegister(std::size_t i) const;
	QByteArray rawValue() const override;
	QVariant data(int column) const override;
	RegisterViewItem *child(int row) override;
	bool visible() const;
	int childCount() const override;
	void addRegister(std::unique_ptr<AbstractRegisterItem> reg);
	void hide();
	void saveValues();
	void show();

private:
	std::vector<std::unique_ptr<AbstractRegisterItem>> registers;
	bool visible_ = true;
};

class SIMDCategory final : public Category {
public:
	SIMDCategory(const QString &name, int row, const std::vector<NumberDisplayMode> &validFormats);
	~SIMDCategory();

public:
	virtual Model::ElementSize chosenSize() const;
	virtual NumberDisplayMode chosenFormat() const;
	virtual void setChosenSize(Model::ElementSize newSize);
	virtual void setChosenFormat(NumberDisplayMode newFormat);

public:
	const std::vector<NumberDisplayMode> &validFormats() const;

private:
	bool sizeChanged_   = false;
	bool formatChanged_ = false;
	Model::ElementSize chosenSize_;
	NumberDisplayMode chosenFormat_;
	std::vector<NumberDisplayMode> const validFormats_;
};

class FPUCategory final : public Category {
public:
	FPUCategory(const QString &name, int row);
	~FPUCategory();

public:
	NumberDisplayMode chosenFormat() const;
	void setChosenFormat(NumberDisplayMode newFormat);

private:
	bool formatChanged_ = false;
	NumberDisplayMode chosenFormat_;
};

class CategoriesHolder final : public RegisterViewItem {
	friend class Model;

public:
	CategoriesHolder();

public:
	template <typename CategoryType = Category>
	CategoryType *insert(const QString &name);

	SIMDCategory *insertSimd(const QString &name, const std::vector<NumberDisplayMode> &validFormats);
	int childCount() const override;
	RegisterViewItem *child(int row) override;
	QVariant data(int column) const override;
	QByteArray rawValue() const override;

private:
	std::vector<std::unique_ptr<Category>> categories;
};

}

#endif

```

`include/State.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef STATE_H_20060715_
#define STATE_H_20060715_

#include <memory>
#include "API.h"
#include "Types.h"

class IState;
class Register;
class QString;

namespace DebuggerCorePlugin {
class DebuggerCore;
class PlatformThread;
}

// NOTE(eteran): the purpose of this class is simply to give IState objects
// value semantics, so it tends to nearly replicate that interface.
class EDB_EXPORT State {

	// TODO(eteran): I don't like needing to do this
	// need to revisit the IState/State/PlatformState stuff...
	friend class DebuggerCorePlugin::DebuggerCore;
	friend class DebuggerCorePlugin::PlatformThread;

public:
	State();
	State(const State &other);
	State &operator=(const State &rhs);
	State(State &&other) noexcept;
	State &operator=(State &&rhs) noexcept;
	~State();

public:
	void swap(State &other);

public:
	QString flagsToString() const;
	QString flagsToString(edb::reg_t flags) const;
	Register value(const QString &reg) const;
	Register instructionPointerRegister() const;
	Register flagsRegister() const;
	edb::address_t framePointer() const;
	edb::address_t instructionPointer() const;
	edb::address_t stackPointer() const;
	edb::reg_t debugRegister(size_t n) const;
	edb::reg_t flags() const;
	Register gpRegister(size_t n) const;
	Register archRegister(uint64_t type, size_t n) const;
	void adjustStack(int bytes);
	void clear();
	bool empty() const;

public:
#if defined(EDB_X86) || defined(EDB_X86_64)
	int fpuStackPointer() const;
	edb::value80 fpuRegister(size_t n) const;
	bool fpuRegisterIsEmpty(std::size_t n) const;
	QString fpuRegisterTagString(std::size_t n) const;
	edb::value16 fpuControlWord() const;
	edb::value16 fpuStatusWord() const;
	edb::value16 fpuTagWord() const;
#endif

public:
	void setDebugRegister(size_t n, edb::reg_t value);
	void setFlags(edb::reg_t flags);
	void setInstructionPointer(edb::address_t value);
	void setRegister(const QString &name, edb::reg_t value);
	void setRegister(const Register &reg);

public:
	Register operator[](const QString &reg) const;

private:
	std::unique_ptr<IState> impl_;
};

Q_DECLARE_METATYPE(State)

#endif

```

`include/Status.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef STATUS_H_20160803_
#define STATUS_H_20160803_

#include "API.h"
#include <QString>
#include <type_traits>
#include <variant>

class EDB_EXPORT Status {
public:
	enum OkType { Ok };

public:
	Status(OkType) {
	}

	explicit Status(const QString &message)
		: error_(message) {
	}

	Status(const Status &) = default;
	Status &operator=(const Status &) = default;
	Status(Status &&)                 = default;
	Status &operator=(Status &&) = default;

public:
	bool success() const { return error_.isEmpty(); }
	bool failure() const { return !success(); }
	explicit operator bool() const { return success(); }
	QString error() const { return error_; }

private:
	QString error_;
};

template <class E>
class Unexpected {
	template <class U, class Y>
	friend class Expected;

	template <class U, class Y>
	friend class Result;

	template <class U>
	friend Unexpected<typename std::decay<U>::type> make_unexpected(U &&);

public:
	Unexpected(const Unexpected &) = default;
	Unexpected &operator=(const Unexpected &) = default;
	Unexpected(Unexpected &&)                 = default;
	Unexpected &operator=(Unexpected &&) = default;

private:
	template <class U>
	Unexpected(U &&error)
		: error_(std::forward<U>(error)) {
	}

private:
	E error_;
};

template <class T, class E>
class Result {
public:
	template <class U, class = typename std::enable_if<std::is_convertible<U, T>::value>::type>
	Result(U &&value)
		: value_(std::forward<U>(value)) {
	}

	Result(const Unexpected<E> &value)
		: value_(value) {
	}

	Result(Unexpected<E> &&value)
		: value_(std::move(value)) {
	}

	Result(const Result &) = default;
	Result &operator=(const Result &) = default;
	Result(Result &&)                 = default;
	Result &operator=(Result &&) = default;

public:
	const T *operator->() const {
		Q_ASSERT(succeeded());
		return &std::get<T>(value_);
	}

	const T &operator*() const { return value(); }
	bool succeeded() const { return value_.index() == 0; }
	bool failed() const { return value_.index() == 1; }
	explicit operator bool() const { return succeeded(); }
	bool operator!() const { return failed(); }

	const E &error() const {
		Q_ASSERT(failed());
		return std::get<Unexpected<E>>(value_).error_;
	}

	const T &value() const {
		Q_ASSERT(succeeded());
		return std::get<T>(value_);
	}

private:
	std::variant<T, Unexpected<E>> value_;
};

template <class E>
class Result<void, E> {
public:
	Result() {
	}

	Result(const Unexpected<E> &value)
		: value_(value) {
	}

	Result(Unexpected<E> &&value)
		: value_(std::move(value)) {
	}

	Result(const Result &) = default;
	Result &operator=(const Result &) = default;
	Result(Result &&)                 = default;
	Result &operator=(Result &&) = default;

public:
	bool succeeded() const { return value_.index() == 0; }
	bool failed() const { return value_.index() == 1; }
	explicit operator bool() const { return succeeded(); }
	bool operator!() const { return failed(); }

	const E &error() const {
		Q_ASSERT(failed());
		return std::get<Unexpected<E>>(value_).error_;
	}

private:
	std::variant<std::monostate, Unexpected<E>> value_;
};

template <class E>
Unexpected<typename std::decay<E>::type> make_unexpected(E &&e) {
	return Unexpected<typename std::decay<E>::type>(std::forward<E>(e));
}

#endif

```

`include/Symbol.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef SYMBOL_H_20110401_
#define SYMBOL_H_20110401_

#include "API.h"
#include "Types.h"
#include <QString>
#include <cstdint>

class Symbol {
public:
	QString file;
	QString name;
	QString name_no_prefix;
	edb::address_t address;
	uint32_t size;
	char type;

	bool isCode() const { return type == 't' || type == 'T' || type == 'P'; }
	bool isData() const { return !isCode(); }
	bool isWeak() const { return type == 'W'; }
};

#endif

```

`include/Theme.h`:

```h
/*
Copyright (C) 2020 - 2020 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef THEME_H_
#define THEME_H_

#include <QColor>
#include <QTextCharFormat>

struct Theme {

	enum Palette {
		Window,
		WindowText,
		Base,
		AlternateBase,
		ToolTipBase,
		ToolTipText,
		Text,
		Button,
		ButtonText,
		BrightText,
		Highlight,
		HighlightedText,
		Link,
		LinkVisited,

		Light,
		Midlight,
		Dark,
		Mid,
		Shadow,

		WindowDisabled,
		WindowTextDisabled,
		BaseDisabled,
		AlternateBaseDisabled,
		ToolTipBaseDisabled,
		ToolTipTextDisabled,
		TextDisabled,
		ButtonDisabled,
		ButtonTextDisabled,
		BrightTextDisabled,
		HighlightDisabled,
		HighlightedTextDisabled,
		LinkDisabled,
		LinkVisitedDisabled,

		LightDisabled,
		MidlightDisabled,
		DarkDisabled,
		MidDisabled,
		ShadowDisabled,

		PaletteCount
	};

	QColor palette[PaletteCount];

	enum Text {
		Address,
		AlternatingByte,
		Arithmetic,
		Brackets,
		Comma,
		Comparison,
		Data,
		Constant,
		DataXfer,
		FlowCtrl,
		Function,
		Logic,
		NonPrintingCharacter,
		Operator,
		Prefix,
		Ptr,
		Register,
		Shift,
		Stack,
		System,
		Filling,
		TakenJump,

		TextCount
	};

	QTextCharFormat text[TextCount];

	enum Misc {
		Badge,

		MiscCount
	};

	QTextCharFormat misc[MiscCount];

public:
	static Theme load();
	static QStringList userThemes();
	static QString themeName(const QString &theme_file);
};

#endif

```

`include/ThreadsModel.h`:

```h
/*
Copyright (C) 2014 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef THREADS_MODEL_H_20191119_
#define THREADS_MODEL_H_20191119_

#include "API.h"
#include <QAbstractItemModel>
#include <QVector>
#include <memory>

class IThread;

class EDB_EXPORT ThreadsModel final : public QAbstractItemModel {
	Q_OBJECT

public:
	struct Item {
		std::shared_ptr<IThread> thread;
		bool current;
	};

public:
	ThreadsModel(QObject *parent = nullptr);
	~ThreadsModel() override = default;

public:
	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex &index) const override;
	QVariant data(const QModelIndex &index, int role) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
	int columnCount(const QModelIndex &parent = QModelIndex()) const override;
	int rowCount(const QModelIndex &parent = QModelIndex()) const override;

public:
	void addThread(const std::shared_ptr<IThread> &thread, bool current);
	void clear();

private:
	QVector<Item> items_;
};

#endif

```

`include/Types.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef TYPES_H_20071127_
#define TYPES_H_20071127_

#include "Value.h"
#include <QString>

namespace edb {

enum EventStatus {
	DEBUG_STOP,                  // do nothing, the UI will instigate the next event
	DEBUG_CONTINUE,              // the event has been addressed, continue as normal
	DEBUG_CONTINUE_STEP,         // the event has been addressed, step as normal
	DEBUG_CONTINUE_BP,           // the event was a BP, which we need to ignore
	DEBUG_EXCEPTION_NOT_HANDLED, // pass the event unmodified back thread and continue
	DEBUG_NEXT_HANDLER
};

}

/* Comment Type */
struct Comment {
	edb::address_t address;
	QString comment;
};

#include "ArchTypes.h"
#endif

```

`include/Util.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef UTIL_H_20061126_
#define UTIL_H_20061126_

namespace util {

// Used to interconvert between abstract enum defined in an interface and actual enumerators in implementation
template <typename AbstractEnum, typename ConcreteEnum>
class AbstractEnumData {
	AbstractEnum data;

public:
	AbstractEnumData(AbstractEnum a)
		: data(a) {
	}

	AbstractEnumData(ConcreteEnum c)
		: data(static_cast<AbstractEnum>(c)) {
	}

	operator AbstractEnum() const { return data; }
	operator ConcreteEnum() const { return static_cast<ConcreteEnum>(data); }
};

inline void mark_memory(void *memory, std::size_t size) {

	auto p = reinterpret_cast<uint8_t *>(memory);

	// Fill memory with 0xbad1bad1 marker
	for (std::size_t i = 0; i < size; ++i) {
		p[i] = (i & 1) ? 0xba : 0xd1;
	}
}

}

#endif

```

`include/Value.h`:

```h

#ifndef VALUE_H_20191119_
#define VALUE_H_20191119_

#include "API.h"
#include <array>
#include <cinttypes>
#include <cstdint>
#include <cstring>
#include <iomanip>
#include <sstream>

#include <QString>
#include <QVariant>

#ifdef _MSC_VER
extern "C" EDB_EXPORT void __fastcall long_double_to_double(const void *src, double *dest);
EDB_EXPORT void convert_real64_to_real80(const void *src, void *dst);
#endif

namespace edb {

namespace v1 {
EDB_EXPORT bool debuggeeIs32Bit();
}

namespace detail {

template <class Integer>
using IsInteger = typename std::enable_if<std::is_integral<Integer>::value>::type;

template <class T1, class T2>
using PromoteType = typename std::conditional<
	sizeof(T1) >= sizeof(T2),
	typename std::make_unsigned<T1>::type,
	typename std::make_unsigned<T2>::type>::type;

template <size_t N>
class value_type_large {
public:
	using T = uint64_t[N / 64];

public:
	// all defaulted to help ensure that this is a trivially-copyable type
	value_type_large()                         = default;
	value_type_large(const value_type_large &) = default;
	value_type_large &operator=(const value_type_large &) = default;
	value_type_large(value_type_large &&)                 = default;
	value_type_large &operator=(value_type_large &&) = default;
	~value_type_large()                              = default;

public:
	template <class U, class = typename std::enable_if<!std::is_arithmetic<U>::value>::type>
	explicit value_type_large(const U &data, size_t offset = 0) {

		static_assert(sizeof(data) >= sizeof(T), "value_type can only be constructed from large enough variable");
		static_assert(std::is_trivially_copyable<U>::value, "value_type can only be constructed from trivially copiable data");

		Q_ASSERT(sizeof(data) - offset >= sizeof(T)); // check bounds, this can't be done at compile time

		auto dataStart = reinterpret_cast<const char *>(&data);
		std::memcpy(&value_, dataStart + offset, sizeof(value_));
	}

public:
	template <class U>
	void load(const U &n) {
		static_assert(sizeof(T) >= sizeof(n), "Value to load is too large.");
		std::memcpy(&value_, &n, sizeof(n));
	}

public:
	bool operator==(const value_type_large &rhs) const { return std::memcmp(value_, rhs.value_, sizeof(T)) == 0; }
	bool operator!=(const value_type_large &rhs) const { return std::memcmp(value_, rhs.value_, sizeof(T)) != 0; }

public:
	QString toHexString() const {
		char buf[sizeof(T) * 2 + 1];
		char *p = buf;

		for (auto it = std::rbegin(value_); it != std::rend(value_); ++it) {
			p += sprintf(p, "%016" PRIx64, *it);
		}

		return QString::fromLatin1(buf);
	}

public:
	template <class U>
	static value_type_large fromZeroExtended(const U &data) {

		static_assert(sizeof(data) <= sizeof(T), "It doesn't make sense to expand a larger type into a smaller type");

		value_type_large created;

		auto dataStart = reinterpret_cast<const char *>(&data);
		auto target    = reinterpret_cast<char *>(&created.value_);

		std::memcpy(target, dataStart, sizeof(data));
		std::memset(target + sizeof(data), 0, sizeof(T) - sizeof(data));

		return created;
	}

private:
	T value_ = {};
};

template <class T>
class value_type {
	template <class U>
	friend class value_type;

public:
	using InnerValueType = T;

public:
	// all defaulted to help ensure that this is a trivially-copyable type
	value_type()                   = default;
	value_type(const value_type &) = default;
	value_type &operator=(const value_type &) = default;
	value_type(value_type &&)                 = default;
	value_type &operator=(value_type &&) = default;
	~value_type()                        = default;

public:
	template <class Integer, class = IsInteger<Integer>>
	value_type(Integer n)
		: value_(n) {
		// NOTE(eteran): this is allowed to truncate like assigning a uint64_t to a uint32_t
	}

	template <class Integer, class = IsInteger<Integer>>
	value_type &operator=(const Integer &rhs) {
		value_ = rhs;
		// NOTE(eteran): this is allowed to truncate like assigning a uint64_t to a uint32_t
		return *this;
	}

public:
	template <class U>
	explicit value_type(const value_type<U> &other)
		: value_(other.value_) {
		// NOTE(eteran): this is allowed to truncate like assigning a uint64_t to a uint32_t
	}

	template <class U>
	value_type &operator=(const value_type<U> &rhs) {
		value_ = rhs.value_;
		// NOTE(eteran): this is allowed to truncate like assigning a uint64_t to a uint32_t
		return *this;
	}

public:
	template <class U, class = typename std::enable_if<!std::is_arithmetic<U>::value>::type>
	explicit value_type(const U &data, size_t offset = 0) {

		static_assert(sizeof(data) >= sizeof(T), "value_type can only be constructed from large enough variable");
		static_assert(std::is_trivially_copyable<U>::value, "value_type can only be constructed from trivially copiable data");

		Q_ASSERT(sizeof(data) - offset >= sizeof(T)); // check bounds, this can't be done at compile time

		auto dataStart = reinterpret_cast<const char *>(&data);
		std::memcpy(&value_, dataStart + offset, sizeof(value_));
	}

public:
	template <class U>
	void load(const U &n) {
		static_assert(sizeof(T) >= sizeof(n), "Value to load is too large.");
		std::memcpy(&value_, &n, sizeof(n));
	}

public:
	static value_type fromString(const QString &str, bool *ok = nullptr, int base = 10, bool isSigned = false) {

		const qulonglong v = isSigned ? static_cast<qulonglong>(str.toLongLong(ok, base)) : str.toULongLong(ok, base);

		if (ok && !*ok) {
			return 0;
		}

		// Check that the result fits into the underlying type
		value_type result(v);
		if (result == v) {
			return result;
		}

		if (ok) {
			*ok = false;
		}

		return 0;
	}

	static value_type fromHexString(const QString &str, bool *ok = nullptr) {
		return fromString(str, ok, 16);
	}

	static value_type fromSignedString(const QString &str, bool *ok = nullptr) {
		return fromString(str, ok, 10, true);
	}

	static value_type fromCString(const QString &str, bool *ok = nullptr) {
		return fromString(str, ok, 0);
	}

	template <class U>
	static value_type fromZeroExtended(const U &data) {
		value_type created;

		static_assert(sizeof(data) <= sizeof(T), "It doesn't make sense to expand a larger type into a smaller type");

		auto dataStart = reinterpret_cast<const char *>(&data);
		auto target    = reinterpret_cast<char *>(&created.value_);

		std::memcpy(target, dataStart, sizeof(data));
		std::memset(target + sizeof(data), 0, sizeof(T) - sizeof(data));

		return created;
	}

public:
	void swap(value_type &other) {
		using std::swap;
		swap(value_, other.value_);
	}

public:
	bool negative() const {
		return typename std::make_signed<T>::type(value_) < 0;
	}

public:
	explicit operator bool() const { return value_ != 0; }
	bool operator!() const { return !value_; }
	operator T() const { return value_; }
	T toUint() const { return value_; }
	T &asUint() { return value_; }

public:
	value_type operator++(int) {
		T v(value_);
		++value_;
		return v;
	}

	value_type &operator++() {
		++value_;
		return *this;
	}

	value_type operator--(int) {
		T v(value_);
		--value_;
		return v;
	}

	value_type &operator--() {
		--value_;
		return *this;
	}

public:
	template <class U>
	value_type &operator+=(const value_type<U> &rhs) {
		value_ += rhs.value_;
		return *this;
	}

	template <class U>
	value_type &operator-=(const value_type<U> &rhs) {
		value_ -= rhs.value_;
		return *this;
	}

	template <class U>
	value_type &operator*=(const value_type<U> &rhs) {
		value_ *= rhs.value_;
		return *this;
	}

	template <class U>
	value_type &operator/=(const value_type<U> &rhs) {
		value_ /= rhs.value_;
		return *this;
	}

	template <class U>
	value_type &operator%=(const value_type<U> &rhs) {
		value_ %= rhs.value_;
		return *this;
	}

public:
	template <class U>
	value_type &operator&=(const value_type<U> &rhs) {
		value_ &= rhs.value_;
		return *this;
	}

	template <class U>
	value_type &operator|=(const value_type<U> &rhs) {
		value_ |= rhs.value_;
		return *this;
	}

	template <class U>
	value_type &operator^=(const value_type<U> &rhs) {
		value_ ^= rhs.value_;
		return *this;
	}

	template <class U>
	value_type &operator>>=(const value_type<U> &rhs) {
		value_ >>= rhs.value_;
		return *this;
	}

	template <class U>
	value_type &operator<<=(const value_type<U> &rhs) {
		value_ <<= rhs.value_;
		return *this;
	}

public:
	template <class Integer, class = IsInteger<Integer>>
	value_type &operator+=(Integer n) {
		value_ += n;
		return *this;
	}

	template <class Integer, class = IsInteger<Integer>>
	value_type &operator-=(Integer n) {
		value_ -= n;
		return *this;
	}

	template <class Integer, class = IsInteger<Integer>>
	value_type &operator*=(Integer n) {
		value_ *= n;
		return *this;
	}

	template <class Integer, class = IsInteger<Integer>>
	value_type &operator/=(Integer n) {
		value_ /= n;
		return *this;
	}

	template <class Integer, class = IsInteger<Integer>>
	value_type &operator%=(Integer n) {
		value_ %= n;
		return *this;
	}

public:
	template <class Integer, class = IsInteger<Integer>>
	value_type &operator&=(Integer n) {
		value_ &= n;
		return *this;
	}

	template <class Integer, class = IsInteger<Integer>>
	value_type &operator|=(Integer n) {
		value_ |= n;
		return *this;
	}

	template <class Integer, class = IsInteger<Integer>>
	value_type &operator^=(Integer n) {
		value_ ^= n;
		return *this;
	}

	template <class Integer, class = IsInteger<Integer>>
	value_type &operator>>=(Integer n) {
		value_ >>= n;
		return *this;
	}

	template <class Integer, class = IsInteger<Integer>>
	value_type &operator<<=(Integer n) {
		value_ <<= n;
		return *this;
	}

public:
	QString toPointerString(bool createdFromNativePointer = true) const {
		if (edb::v1::debuggeeIs32Bit()) {
			return "0x" + value_type<uint32_t>(value_).toHexString();
		} else {
			if (!createdFromNativePointer) { // then we don't know value of upper dword
				return "0x????????" + value_type<uint32_t>(value_).toHexString();
			} else {
				return "0x" + toHexString();
			}
		}
	}

	QString toHexString() const {
		std::ostringstream ss;
		ss << std::setw(sizeof(value_) * 2) << std::setfill('0') << std::hex << +value_; // + to prevent printing uint8_t as a character
		return QString::fromStdString(ss.str());
	}

	QString unsignedToString() const {
		return toString();
	}

	QString signedToString() const {
		return QString("%1").arg(typename std::make_signed<T>::type(value_));
	}

	QString toString() const {
		return QString("%1").arg(value_);
	}

	QVariant toQVariant() const {
		return QVariant::fromValue(value_);
	}

public:
	value_type signExtended(size_t valueLength) const {
		value_type result(value_);

		if (valueLength == sizeof(value_)) {
			return result;
		}

		// if the sign bit is set
		if (value_ & (1ull << (valueLength * 8 - 1))) {
			// start with all bits set
			result.value_ = -1ll;

			// overwrite the lower <valueLength> bytes with the original value
			std::memcpy(&result.value_, &value_, valueLength);
		}

		return result;
	}

public:
	void normalize() {
		if (edb::v1::debuggeeIs32Bit()) {
			value_ &= 0xffffffffull;
		}
	}

public:
	T value_ = {};
};

// iostream operators
template <class T>
std::istream &operator>>(std::istream &os, value_type<T> &val) {
	os >> val.asUint();
	return os;
}

template <class T>
std::ostream &operator<<(std::ostream &os, value_type<T> &val) {
	os << val.toUint();
	return os;
}

// operators for value_type, Integer
template <class T, class Integer, class = IsInteger<Integer>>
bool operator==(const value_type<T> &lhs, Integer rhs) {
	using U = typename std::make_unsigned<Integer>::type;
	return lhs.value_ == static_cast<U>(rhs);
}

template <class T, class Integer, class = IsInteger<Integer>>
bool operator!=(const value_type<T> &lhs, Integer rhs) {
	using U = typename std::make_unsigned<Integer>::type;
	return lhs.value_ != static_cast<U>(rhs);
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator+(const value_type<T> &lhs, Integer rhs) -> value_type<T> {
	value_type<T> r(lhs);
	r += rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator-(const value_type<T> &lhs, Integer rhs) -> value_type<T> {
	value_type<T> r(lhs);
	r -= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator*(const value_type<T> &lhs, Integer rhs) -> value_type<T> {
	value_type<T> r(lhs);
	r *= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator/(const value_type<T> &lhs, Integer rhs) -> value_type<T> {
	value_type<T> r(lhs);
	r /= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator%(const value_type<T> &lhs, Integer rhs) -> value_type<T> {
	value_type<T> r(lhs);
	r %= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator&(const value_type<T> &lhs, Integer rhs) -> value_type<T> {
	value_type<T> r(lhs);
	r &= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator|(const value_type<T> &lhs, Integer rhs) -> value_type<T> {
	value_type<T> r(lhs);
	r |= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator^(const value_type<T> &lhs, Integer rhs) -> value_type<T> {
	value_type<T> r(lhs);
	r ^= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator>>(const value_type<T> &lhs, Integer rhs) -> value_type<T> {
	value_type<T> r(lhs);
	r >>= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator<<(const value_type<T> &lhs, Integer rhs) -> value_type<T> {
	value_type<T> r(lhs);
	r <<= rhs;
	return r;
}

// operators for Integer, value_type
template <class T, class Integer, class = IsInteger<Integer>>
bool operator==(Integer lhs, const value_type<T> &rhs) {
	return rhs == lhs;
}

template <class T, class Integer, class = IsInteger<Integer>>
bool operator!=(Integer lhs, const value_type<T> &rhs) {
	return rhs != lhs;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator+(Integer lhs, const value_type<T> &rhs) -> value_type<PromoteType<T, Integer>> {

	using U = value_type<PromoteType<T, Integer>>;

	value_type<U> r(lhs);
	r += rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator-(Integer lhs, const value_type<T> &rhs) -> value_type<PromoteType<T, Integer>> {

	using U = value_type<PromoteType<T, Integer>>;

	value_type<U> r(lhs);
	r -= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator*(Integer lhs, const value_type<T> &rhs) -> value_type<PromoteType<T, Integer>> {

	using U = value_type<PromoteType<T, Integer>>;

	value_type<U> r(lhs);
	r *= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator/(Integer lhs, const value_type<T> &rhs) -> value_type<PromoteType<T, Integer>> {

	using U = value_type<PromoteType<T, Integer>>;

	value_type<U> r(lhs);
	r /= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator%(Integer lhs, const value_type<T> &rhs) -> value_type<PromoteType<T, Integer>> {

	using U = value_type<PromoteType<T, Integer>>;

	value_type<U> r(lhs);
	r %= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator&(Integer lhs, const value_type<T> &rhs) -> value_type<PromoteType<T, Integer>> {

	using U = value_type<PromoteType<T, Integer>>;

	value_type<U> r(lhs);
	r &= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator|(Integer lhs, const value_type<T> &rhs) -> value_type<PromoteType<T, Integer>> {

	using U = value_type<PromoteType<T, Integer>>;

	value_type<U> r(lhs);
	r |= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator^(Integer lhs, const value_type<T> &rhs) -> value_type<PromoteType<T, Integer>> {

	using U = value_type<PromoteType<T, Integer>>;

	value_type<U> r(lhs);
	r ^= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator>>(Integer lhs, const value_type<T> &rhs) -> value_type<PromoteType<T, Integer>> {

	using U = value_type<PromoteType<T, Integer>>;

	value_type<U> r(lhs);
	r >>= rhs;
	return r;
}

template <class T, class Integer, class = IsInteger<Integer>>
auto operator<<(Integer lhs, const value_type<T> &rhs) -> value_type<PromoteType<T, Integer>> {

	using U = value_type<PromoteType<T, Integer>>;

	value_type<U> r(lhs);
	r <<= rhs;
	return r;
}

// operators for value_type, value_type
template <class T1, class T2>
bool operator==(const value_type<T1> &lhs, const value_type<T2> &rhs) {
	return lhs.value_ == rhs.value_;
}

template <class T1, class T2>
bool operator!=(const value_type<T1> &lhs, const value_type<T2> &rhs) {
	return lhs.value_ != rhs.value_;
}

template <class T1, class T2>
auto operator+(const value_type<T1> &lhs, const value_type<T2> &rhs) -> value_type<PromoteType<T1, T2>> {

	using U = value_type<PromoteType<T1, T2>>;

	value_type<U> r(lhs);
	r += rhs;
	return r;
}

template <class T1, class T2>
auto operator-(const value_type<T1> &lhs, const value_type<T2> &rhs) -> value_type<PromoteType<T1, T2>> {

	using U = value_type<PromoteType<T1, T2>>;

	value_type<U> r(lhs);
	r -= rhs;
	return r;
}

template <class T1, class T2>
auto operator*(const value_type<T1> &lhs, const value_type<T2> &rhs) -> value_type<PromoteType<T1, T2>> {

	using U = value_type<PromoteType<T1, T2>>;

	value_type<U> r(lhs);
	r *= rhs;
	return r;
}

template <class T1, class T2>
auto operator/(const value_type<T1> &lhs, const value_type<T2> &rhs) -> value_type<PromoteType<T1, T2>> {

	using U = value_type<PromoteType<T1, T2>>;

	value_type<U> r(lhs);
	r /= rhs;
	return r;
}

template <class T1, class T2>
auto operator%(const value_type<T1> &lhs, const value_type<T2> &rhs) -> value_type<PromoteType<T1, T2>> {

	using U = value_type<PromoteType<T1, T2>>;

	value_type<U> r(lhs);
	r %= rhs;
	return r;
}

template <class T1, class T2>
auto operator&(const value_type<T1> &lhs, const value_type<T2> &rhs) -> value_type<PromoteType<T1, T2>> {

	using U = value_type<PromoteType<T1, T2>>;

	value_type<U> r(lhs);
	r &= rhs;
	return r;
}

template <class T1, class T2>
auto operator|(const value_type<T1> &lhs, const value_type<T2> &rhs) -> value_type<PromoteType<T1, T2>> {

	using U = value_type<PromoteType<T1, T2>>;

	value_type<U> r(lhs);
	r |= rhs;
	return r;
}

template <class T1, class T2>
auto operator^(const value_type<T1> &lhs, const value_type<T2> &rhs) -> value_type<PromoteType<T1, T2>> {

	using U = value_type<PromoteType<T1, T2>>;

	value_type<U> r(lhs);
	r ^= rhs;
	return r;
}

struct value_type80 {
public:
	using T = uint8_t[10];

public:
	// all defaulted to help ensure that this is a trivially-copyable type
	value_type80()                     = default;
	value_type80(const value_type80 &) = default;
	value_type80 &operator=(const value_type80 &) = default;
	value_type80(value_type80 &&)                 = default;
	value_type80 &operator=(value_type80 &&) = default;
	~value_type80()                          = default;

public:
	template <class U>
	explicit value_type80(const U &data, size_t offset = 0) {
#ifdef _MSC_VER
		if constexpr (std::is_same<U, long double>::value && sizeof(U) < sizeof(T)) {
			T temp;
			convert_real64_to_real80(&data, &temp);

			Q_ASSERT(sizeof(temp) - offset >= sizeof(T)); // check bounds, this can't be done at compile time

			auto dataStart = reinterpret_cast<const char *>(&temp);
			std::memcpy(&value_, dataStart + offset, sizeof(value_));
			return;
		}
#else
		static_assert(sizeof(data) >= sizeof(T), "ValueBase can only be constructed from large enough variable");
#endif
		static_assert(std::is_trivially_copyable<U>::value, "ValueBase can only be constructed from trivially copiable data");

		Q_ASSERT(sizeof(data) - offset >= sizeof(T)); // check bounds, this can't be done at compile time

		auto dataStart = reinterpret_cast<const char *>(&data);
		std::memcpy(&value_, dataStart + offset, sizeof(value_));
	}

public:
	bool negative() const {
		return value_[9] & 0x80;
	}

	value_type<uint16_t> exponent() const {
		value_type<uint16_t> e(value_, 8);
		e &= 0x7fff;
		return e;
	}

	value_type<uint64_t> mantissa() const {
		value_type<uint64_t> m(value_, 0);
		return m;
	}

	bool normalized() const {
		return value_[7] & 0x80;
	}

public:
	long double toFloatValue() const {
#ifdef _MSC_VER
		double d;
		long_double_to_double(&value_, &d);
		return d;
#else
		long double float80val;
		std::memcpy(&float80val, &value_, sizeof(value_));
		return float80val;
#endif
	}

public:
	QString toHexString() const {
		char buf[32];
		snprintf(buf, sizeof(buf), "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
				 value_[9],
				 value_[8],
				 value_[7],
				 value_[6],
				 value_[5],
				 value_[4],
				 value_[3],
				 value_[2],
				 value_[1],
				 value_[0]);

		return QString::fromLatin1(buf);
	}

public:
	bool operator==(const value_type80 &rhs) const { return std::memcmp(value_, rhs.value_, 10) == 0; }
	bool operator!=(const value_type80 &rhs) const { return std::memcmp(value_, rhs.value_, 10) != 0; }

private:
	T value_ = {};
};

static_assert(sizeof(value_type80) * 8 == 80, "value_type80 size is broken!");

}

// GPR on x86
using value8  = detail::value_type<uint8_t>;
using value16 = detail::value_type<uint16_t>;
using value32 = detail::value_type<uint32_t>;

// MMX/GPR(x86_64)
using value64 = detail::value_type<uint64_t>;

// We support registers and addresses of 64-bits
using address_t = value64;
using reg_t     = value64;

// FPU
using value80 = detail::value_type80;

// SSE
using value128 = detail::value_type_large<128>;

// AVX
using value256 = detail::value_type_large<256>;

// AVX512
using value512 = detail::value_type_large<512>;

static_assert(std::is_standard_layout<value8>::value &&
				  std::is_standard_layout<value16>::value &&
				  std::is_standard_layout<value32>::value &&
				  std::is_standard_layout<value64>::value &&
				  std::is_standard_layout<value80>::value &&
				  std::is_standard_layout<value128>::value &&
				  std::is_standard_layout<value256>::value &&
				  std::is_standard_layout<value512>::value,
			  "Fixed-sized values are intended to have standard layout");

static_assert(std::is_trivially_copyable<value8>::value &&
				  std::is_trivially_copyable<value16>::value &&
				  std::is_trivially_copyable<value32>::value &&
				  std::is_trivially_copyable<value64>::value &&
				  std::is_trivially_copyable<value80>::value &&
				  std::is_trivially_copyable<value128>::value &&
				  std::is_trivially_copyable<value256>::value &&
				  std::is_trivially_copyable<value512>::value,
			  "Fixed-sized values are intended to be trivially copyable");

}

#endif

```

`include/arch/arm-generic/ArchTypes.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ARCH_TYPES_H_20071127_
#define ARCH_TYPES_H_20071127_

#include "Instruction.h"
#include "Types.h"

namespace edb {

using Instruction = CapstoneEDB::Instruction;
using Operand     = CapstoneEDB::Operand;

}

#endif

```

`include/arch/x86-generic/ArchTypes.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ARCH_TYPES_H_20071127_
#define ARCH_TYPES_H_20071127_

#include "Instruction.h"
#include "Types.h"

namespace edb {

using seg_reg_t   = value16;
using Instruction = CapstoneEDB::Instruction;
using Operand     = CapstoneEDB::Operand;

}

#endif

```

`include/edb.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef EDB_H_20061101_
#define EDB_H_20061101_

#include "API.h"
#include "IBinary.h"
#include "Status.h"
#include "Types.h"
#include <QMap>
#include <QPointer>
#include <QStringList>
#include <QVector>
#include <memory>
#include <optional>

class ArchProcessor;
class Configuration;
class IAnalyzer;
class IBreakpoint;
class IDebugEventHandler;
class IDebugEvent;
class IDebugger;
class IPlugin;
class IRegion;
class ISymbolManager;
class MemoryRegions;
class Register;
class State;

class QAbstractScrollArea;
class QByteArray;
class QDialog;
class QWidget;
class QString;

struct ExpressionError;

namespace RegisterViewModelBase {
class Model;
}

namespace edb {

struct Prototype;

namespace v2 {
// ask the user for a value in an expression form
EDB_EXPORT std::optional<edb::address_t> get_expression_from_user(const QString &title, const QString &prompt);
EDB_EXPORT std::optional<edb::address_t> eval_expression(const QString &expression);
EDB_EXPORT QString format_bytes(const void *buffer, size_t count);

}

namespace v1 {

// some useful objects
EDB_EXPORT extern IDebugger *debugger_core;
EDB_EXPORT extern QWidget *debugger_ui;

// the symbol mananger
EDB_EXPORT ISymbolManager &symbol_manager();

// the memory region manager
EDB_EXPORT MemoryRegions &memory_regions();

// the current arch processor
EDB_EXPORT ArchProcessor &arch_processor();

// widgets
EDB_EXPORT QAbstractScrollArea *disassembly_widget();

// breakpoint managment
EDB_EXPORT std::shared_ptr<IBreakpoint> find_breakpoint(address_t address);
EDB_EXPORT std::shared_ptr<IBreakpoint> find_triggered_breakpoint(address_t address);
EDB_EXPORT QString get_breakpoint_condition(address_t address);
EDB_EXPORT address_t disable_breakpoint(address_t address);
EDB_EXPORT address_t enable_breakpoint(address_t address);
EDB_EXPORT std::shared_ptr<IBreakpoint> create_breakpoint(address_t address);
EDB_EXPORT void remove_breakpoint(address_t address);
EDB_EXPORT void set_breakpoint_condition(address_t address, const QString &condition);
EDB_EXPORT void toggle_breakpoint(address_t address);

EDB_EXPORT address_t current_data_view_address();

// change what the various views show
EDB_EXPORT bool dump_data_range(address_t address, address_t end_address, bool new_tab);
EDB_EXPORT bool dump_data_range(address_t address, address_t end_address);
EDB_EXPORT bool dump_data(address_t address, bool new_tab);
EDB_EXPORT bool dump_data(address_t address);
EDB_EXPORT bool dump_stack(address_t address, bool scroll_to);
EDB_EXPORT bool dump_stack(address_t address);
EDB_EXPORT bool jump_to_address(address_t address);

// ask the user for a value in an expression form
EDB_EXPORT bool get_expression_from_user(const QString &title, const QString &prompt, address_t *value);
EDB_EXPORT bool eval_expression(const QString &expression, address_t *value);

// ask the user for a value suitable for a register via an input box
EDB_EXPORT bool get_value_from_user(Register &value, const QString &title);
EDB_EXPORT bool get_value_from_user(Register &value);

// ask the user for a binary string via an input box (max_length forces maximum length, setting it to 0 removes the restriction)
EDB_EXPORT bool get_binary_string_from_user(QByteArray &value, const QString &title, int max_length = 0);

// determine if the given address is the starting point of an string, if so, s will contain it
// (formatted with C-style escape chars, so foundLength will have the original length of the string in chars).
EDB_EXPORT bool get_ascii_string_at_address(address_t address, QString &s, int min_length, int max_length, int &found_length);
EDB_EXPORT bool get_utf16_string_at_address(address_t address, QString &s, int min_length, int max_length, int &found_length);

// Combination of get_ascii/utf16_at_address using current user configuration. May perform more analysis types in the future
EDB_EXPORT bool get_human_string_at_address(address_t address, QString &s);

EDB_EXPORT std::shared_ptr<IRegion> current_cpu_view_region();
EDB_EXPORT std::shared_ptr<IRegion> primary_code_region();
EDB_EXPORT std::shared_ptr<IRegion> primary_data_region();

// configuration
EDB_EXPORT QPointer<QDialog> dialog_options();
EDB_EXPORT Configuration &config();

// a numeric version of the current version suitable for integer comparison
EDB_EXPORT quint32 edb_version();
EDB_EXPORT quint32 int_version(const QString &s);

// symbol resolution
EDB_EXPORT QString find_function_symbol(address_t address);
EDB_EXPORT QString find_function_symbol(address_t address, const QString &default_value);
EDB_EXPORT QString find_function_symbol(address_t address, const QString &default_value, int *offset);

// ask the user for either a value or a variable (register name and such)
EDB_EXPORT address_t get_value(address_t address, bool *ok, ExpressionError *err);
EDB_EXPORT address_t get_variable(const QString &s, bool *ok, ExpressionError *err);

// hook the debug event system
EDB_EXPORT edb::EventStatus execute_debug_event_handlers(const std::shared_ptr<IDebugEvent> &e);
EDB_EXPORT void add_debug_event_handler(IDebugEventHandler *p);
EDB_EXPORT void remove_debug_event_handler(IDebugEventHandler *p);

EDB_EXPORT IAnalyzer *set_analyzer(IAnalyzer *p);
EDB_EXPORT IAnalyzer *analyzer();

// reads up to size bytes from address (stores how many it could read in size)
EDB_EXPORT bool get_instruction_bytes(address_t address, uint8_t *buf, int *size);
EDB_EXPORT bool get_instruction_bytes(address_t address, uint8_t *buf, size_t *size);

template <int N>
int get_instruction_bytes(address_t address, uint8_t (&buffer)[N]) {
	int size = N;
	if (edb::v1::get_instruction_bytes(address, buffer, &size)) {
		return size;
	}

	return 0;
}

EDB_EXPORT QString disassemble_address(address_t address);

EDB_EXPORT std::unique_ptr<IBinary> get_binary_info(const std::shared_ptr<IRegion> &region);
EDB_EXPORT const Prototype *get_function_info(const QString &function);

EDB_EXPORT address_t locate_main_function();

EDB_EXPORT const QMap<QString, QObject *> &plugin_list();
EDB_EXPORT IPlugin *find_plugin_by_name(const QString &name);

EDB_EXPORT void reload_symbols();
EDB_EXPORT void repaint_cpu_view();
EDB_EXPORT void update_ui();

// these are here and not members of state because
// they may require using the debugger core plugin and
// we don't want to force a dependancy between the two
EDB_EXPORT void pop_value(State *state);
EDB_EXPORT void push_value(State *state, reg_t value);

EDB_EXPORT void register_binary_info(IBinary::create_func_ptr_t fptr);

EDB_EXPORT bool overwrite_check(address_t address, size_t size);
EDB_EXPORT bool modify_bytes(address_t address, size_t size, QByteArray &bytes, uint8_t fill);

EDB_EXPORT QByteArray get_file_md5(const QString &s);
EDB_EXPORT QByteArray get_md5(const void *p, size_t n);
EDB_EXPORT QByteArray get_md5(const QVector<uint8_t> &bytes);

EDB_EXPORT QString symlink_target(const QString &s);
EDB_EXPORT QStringList parse_command_line(const QString &cmdline);
EDB_EXPORT Result<address_t, QString> string_to_address(const QString &s);
EDB_EXPORT QString format_bytes(const QByteArray &x);
EDB_EXPORT QString format_bytes(const uint8_t *buffer, size_t count);
EDB_EXPORT QString format_bytes(uint8_t byte);
EDB_EXPORT QString format_pointer(address_t p);

EDB_EXPORT address_t cpu_selected_address();
EDB_EXPORT void set_cpu_selected_address(address_t address);

EDB_EXPORT void set_status(const QString &message, int timeoutMillisecs = 2000);
EDB_EXPORT void clear_status();

EDB_EXPORT size_t pointer_size();

EDB_EXPORT QVector<uint8_t> read_pages(address_t address, size_t page_count);

EDB_EXPORT CapstoneEDB::Formatter &formatter();

EDB_EXPORT bool debuggeeIs32Bit();
EDB_EXPORT bool debuggeeIs64Bit();

EDB_EXPORT address_t selected_stack_address();
EDB_EXPORT size_t selected_stack_size();

EDB_EXPORT address_t selected_data_address();
EDB_EXPORT size_t selected_data_size();

}
}

#endif

```

`include/os/unix/OSTypes.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef OSTYPES_H_20060625_
#define OSTYPES_H_20060625_

#include <sys/types.h> // for pid_t/uid_t

namespace edb {
using ::pid_t;
using ::uid_t;
using tid_t = ::pid_t;
}

#endif

```

`include/os/unix/linux/linker.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef LINKER_H_20170103_
#define LINKER_H_20170103_

namespace edb {
namespace linux_struct {

// Bitness-templated version of struct r_debug defined in link.h
template <class Addr>
struct r_debug {
	int r_version;
	Addr r_map; // struct link_map*
	Addr r_brk;
	enum {
		RT_CONSISTENT,
		RT_ADD,
		RT_DELETE
	} r_state;
	Addr r_ldbase;
};

// Bitness-templated version of struct link_map defined in link.h
template <class Addr>
struct link_map {
	Addr l_addr;
	Addr l_name;         // char*
	Addr l_ld;           // ElfW(Dyn)*
	Addr l_next, l_prev; // struct link_map*
};

}
}

#endif

```

`include/os/win32/OSTypes.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef OSTYPES_H_20070116_
#define OSTYPES_H_20070116_

#ifndef NOMINMAX
#define NOMINMAX
#endif

#include <Windows.h>

namespace edb {
using pid_t = DWORD;
using uid_t = DWORD; // TODO(eteran): I think this needs to be an SID to make any sense
using tid_t = DWORD;
}

#endif

```

`include/string_hash.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef STRING_HASH_H_20110823_
#define STRING_HASH_H_20110823_

#include <cstddef>
#include <cstdint>
#include <type_traits>

namespace edb {
namespace detail {

template <std::size_t N, std::size_t n>
constexpr typename std::enable_if<N <= 9 && n == 0, uint64_t>::type string_hash(const char (&)[N]) {
	return 0;
}

template <std::size_t N, std::size_t n = N - 1>
constexpr typename std::enable_if<N <= 9 && n != 0, uint64_t>::type string_hash(const char (&array)[N]) {
	return string_hash<N, n - 1>(array) | ((array[n - 1] & 0xffull) << (8 * (n - 1)));
}

}

template <std::size_t N>
constexpr typename std::enable_if<N <= 9, uint64_t>::type string_hash(const char (&array)[N]) {
	return detail::string_hash(array);
}

}

#endif

```

`include/util/Container.h`:

```h

#ifndef UTIL_CONTAINER_H_2020227_
#define UTIL_CONTAINER_H_2020227_

#include <algorithm>
#include <array>
#include <type_traits>

namespace util {

template <class T, size_t N, class U = T>
constexpr void shl(std::array<T, N> &buffer, U value = T()) {
	static_assert(std::is_convertible<T, U>::value, "U must be convertable to the type contained in the array!");
	std::rotate(buffer.begin(), buffer.begin() + 1, buffer.end());
	buffer[N - 1] = value;
}

template <class T, size_t N, class U = T>
constexpr void shr(std::array<T, N> &buffer, U value = T()) {
	static_assert(std::is_convertible<T, U>::value, "U must be convertable to the type contained in the array!");
	std::rotate(buffer.rbegin(), buffer.rbegin() + 1, buffer.rend());
	buffer[0] = value;
}

template <class T, size_t N>
constexpr void rol(std::array<T, N> &buffer) {
	std::rotate(buffer.begin(), buffer.begin() + 1, buffer.end());
}

template <class T, size_t N>
constexpr void ror(std::array<T, N> &buffer) {
	std::rotate(buffer.rbegin(), buffer.rbegin() + 1, buffer.rend());
}

template <typename T, typename... Tail>
constexpr auto make_array(T head, Tail... tail) -> std::array<T, 1 + sizeof...(Tail)> {
	return std::array<T, 1 + sizeof...(Tail)>{head, tail...};
}

template <typename Container, typename Element>
bool contains(const Container &container, const Element &element) {
	return std::find(std::begin(container), std::end(container), element) != std::end(container);
}

template <typename Container, typename Pred>
bool contains_if(const Container &container, Pred pred) {
	return std::find_if(std::begin(container), std::end(container), pred) != std::end(container);
}

}

#endif

```

`include/util/Error.h`:

```h

#ifndef UTIL_ERROR_H_2020227_
#define UTIL_ERROR_H_2020227_

#include <QString>
#include <iostream>

namespace util {

template <class Stream>
void print(Stream &str) {
	str << "\n";
}

template <class Stream, class Arg0, class... Args>
void print(Stream &str, Arg0 &&arg0, Args &&...args) {
	str << std::forward<Arg0>(arg0);
	print(str, std::forward<Args>(args)...);
}

}

#define EDB_PRINT_AND_DIE(...)                                                                              \
	do {                                                                                                    \
		util::print(std::cerr, __FILE__, ":", __LINE__, ": ", Q_FUNC_INFO, ": Fatal error: ", __VA_ARGS__); \
		std::abort();                                                                                       \
	} while (0)

#endif

```

`include/util/Float.h`:

```h

#ifndef UTIL_FLOAT_H_2020227_
#define UTIL_FLOAT_H_2020227_

#include "FloatX.h"
#include <cerrno>
#include <optional>
#include <string>
#include <type_traits>

namespace util {

template <typename Float>
std::optional<Float> full_string_to_float(const std::string &s) {

	static_assert(
		std::is_same<Float, float>::value ||
			std::is_same<Float, double>::value ||
			std::is_same<Float, long double>::value,
		"Floating-point type not supported by this function");

	// NOTE: Don't use std::istringstream: it doesn't support hexfloat.
	//       Don't use std::sto{f,d,ld} either: they throw std::out_of_range on denormals.
	//       Only std::strto{f,d,ld} are sane, for some definitions of sane...
	const char *const str = s.c_str();
	char *end;
	Float value;
	errno = 0;

	if constexpr (std::is_same<Float, float>::value) {
		value = std::strtof(str, &end);
	} else if constexpr (std::is_same<Float, double>::value) {
		value = std::strtod(str, &end);
	} else if constexpr (std::is_same<Float, long double>::value) {
		value = std::strtold(str, &end);
	}

	if (errno) {
		if ((errno == ERANGE && (value == 0 || std::isinf(value))) || errno != ERANGE) {
			return {};
		}
	}

	if (end == str + s.size()) {
		return value;
	}

	return {};
}

}

#endif

```

`include/util/Font.h`:

```h

#ifndef FONT_H_
#define FONT_H_

#include "API.h"

class QString;
class QFont;
class QFontMetrics;
class QChar;

namespace Font {

enum Type {
	Plain  = 0,
	Italic = 1,
	Bold   = 2,
};

EDB_EXPORT QFont fromString(const QString &fontName);
EDB_EXPORT int maxWidth(const QFontMetrics &fm);
EDB_EXPORT int characterWidth(const QFontMetrics &fm, QChar ch);
EDB_EXPORT int stringWidth(const QFontMetrics &fm, const QString &s);

}

#endif

```

`include/util/Integer.h`:

```h

#ifndef UTIL_INTEGER_H_2020227_
#define UTIL_INTEGER_H_2020227_

#include "Value.h"
#include "util/Error.h"
#include <type_traits>

enum class NumberDisplayMode {
	Hex,
	Signed,
	Unsigned,
	Float
};

namespace util {

template <typename T>
constexpr typename std::make_unsigned<T>::type to_unsigned(T x) {
	return x;
}

template <typename T>
QString format_int(T value, NumberDisplayMode mode) {
	switch (mode) {
	case NumberDisplayMode::Hex:
		return value.toHexString();
	case NumberDisplayMode::Signed:
		return value.signedToString();
	case NumberDisplayMode::Unsigned:
		return value.unsignedToString();
	default:
		EDB_PRINT_AND_DIE("Unexpected integer display mode ", static_cast<long>(mode));
	}
}

}

#endif

```

`include/util/Math.h`:

```h

#ifndef UTIL_MATH_H_2020227_
#define UTIL_MATH_H_2020227_

namespace util {

//------------------------------------------------------------------------------
// Name: percentage
// Desc: calculates how much of a multi-region byte search we have completed
//------------------------------------------------------------------------------
template <class N1, class N2, class N3, class N4>
int percentage(N1 regions_finished, N2 regions_total, N3 bytes_done, N4 bytes_total) {

	// how much percent does each region account for?
	const auto region_step = 1.0f / static_cast<float>(regions_total) * 100.0f;

	// how many regions are done?
	const float regions_complete = region_step * regions_finished;

	// how much of the current region is done?
	const float region_percent = region_step * static_cast<float>(bytes_done) / static_cast<float>(bytes_total);

	return static_cast<int>(regions_complete + region_percent);
}

//------------------------------------------------------------------------------
// Name: percentage
// Desc: calculates how much of a single-region byte search we have completed
//------------------------------------------------------------------------------
template <class N1, class N2>
int percentage(N1 bytes_done, N2 bytes_total) {
	return percentage(0, 1, bytes_done, bytes_total);
}

}

#endif

```

`include/util/String.h`:

```h

#ifndef UTIL_STRING_H_2020227_
#define UTIL_STRING_H_2020227_

#include <QString>

namespace util {

/**
 * @brief is_numeric
 * @param s
 * @return true if the string only contains decimal digits
 */
inline bool is_numeric(const QString &s) {
	for (QChar ch : s) {
		if (!ch.isDigit()) {
			return false;
		}
	}

	return true;
}

}

#endif

```

`include/version.h.in`:

```in
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef VERSION_H_20061109_
#define VERSION_H_20061109_

#define EDB_VERSION_STRING "@PROJECT_VERSION@"

#cmakedefine GIT_BRANCH "@GIT_BRANCH@"

#endif

```

`lib/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.1)
add_subdirectory(libELF)
add_subdirectory(libPE)

if(UNIX)
	if(TARGET_ARCH_FAMILY_X86 AND NOT GDTOA_FOUND)
		add_subdirectory(gdtoa-desktop)
	endif()
endif()



```

`lib/libELF/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.1)

add_library(ELF INTERFACE
)

target_include_directories(ELF
	INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/include
)

target_sources(ELF INTERFACE
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_model.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_auxv.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_binary.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_dyn.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_header.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_move.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_nhdr.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_phdr.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_rela.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_rel.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_shdr.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_sym.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_syminfo.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_types.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_verdaux.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_verdef.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_vernaux.h
	${CMAKE_CURRENT_SOURCE_DIR}/include/libELF/elf_verneed.h
)


```

`lib/libELF/include/libELF/elf_auxv.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_AUXV_H_20121007_
#define ELF_AUXV_H_20121007_

#include "elf_types.h"

/* Auxiliary vector.  */

/* This vector is normally only used by the program interpreter.  The
   usual definition in an ABI supplement uses the name auxv_t.  The
   vector is not usually defined in a standard <elf.h> file, but it
   can't hurt.  We rename it to avoid conflicts.  The sizes of these
   types are an arrangement between the exec server and the program
   interpreter, so we don't fully specify them here.  */

struct elf32_auxv_t {
	uint32_t a_type; /* Entry type */
	union {
		uint32_t a_val; /* Integer value */
						/*
		                We use to have pointer elements added here.  We cannot do that,
		                though, since it does not work when using 32-bit definitions
		                on 64-bit platforms and vice versa.
		                */
	} a_un;
};

struct elf64_auxv_t {
	uint64_t a_type; /* Entry type */
	union {
		uint64_t a_val; /* Integer value */
						/*
		                We use to have pointer elements added here.  We cannot do that,
		                though, since it does not work when using 32-bit definitions
		                on 64-bit platforms and vice versa.
		                */
	} a_un;
};

// Legal values for a_type (entry type).
enum {
	AT_NULL   = 0,  // End of vector
	AT_IGNORE = 1,  // Entry should be ignored
	AT_EXECFD = 2,  // File descriptor of program
	AT_PHDR   = 3,  // Program headers for program
	AT_PHENT  = 4,  // Size of program header entry
	AT_PHNUM  = 5,  // Number of program headers
	AT_PAGESZ = 6,  // System page size
	AT_BASE   = 7,  // Base address of interpreter
	AT_FLAGS  = 8,  // Flags
	AT_ENTRY  = 9,  // Entry point of program
	AT_NOTELF = 10, // Program is not ELF
	AT_UID    = 11, // Real uid
	AT_EUID   = 12, // Effective uid
	AT_GID    = 13, // Real gid
	AT_EGID   = 14, // Effective gid
	AT_CLKTCK = 17, // Frequency of times()

	// Some more special a_type values describing the hardware.
	AT_PLATFORM = 15, // String identifying platform.
	AT_HWCAP    = 16, // Machine dependent hints about processor capabilities.

	// This entry gives some information about the FPU initialization
	// performed by the kernel.
	AT_FPUCW = 18, // Used FPU control word.

	// Cache block sizes.
	AT_DCACHEBSIZE = 19, // Data cache block size.
	AT_ICACHEBSIZE = 20, // Instruction cache block size.
	AT_UCACHEBSIZE = 21, // Unified cache block size.

	// A special ignored value for PPC, used by the kernel to control the
	// interpretation of the AUXV. Must be > 16.
	AT_IGNOREPPC     = 22, // Entry should be ignored.
	AT_SECURE        = 23, // Boolean, was exec setuid-like?
	AT_BASE_PLATFORM = 24, // String identifying real platforms.
	AT_RANDOM        = 25, // Address of 16 random bytes.
	AT_EXECFN        = 31, // Filename of executable.

	// Pointer to the global system page used for system calls and other
	// nice things.
	AT_SYSINFO      = 32,
	AT_SYSINFO_EHDR = 33,

	// Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
	// log2 of line size; mask those to get cache size.
	AT_L1I_CACHESHAPE = 34,
	AT_L1D_CACHESHAPE = 35,
	AT_L2_CACHESHAPE  = 36,
	AT_L3_CACHESHAPE  = 37
};

#endif

```

`lib/libELF/include/libELF/elf_binary.h`:

```h
/*
Copyright (C) 2012 Evan Teran
                   evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_BINARY_H_20121007_
#define ELF_BINARY_H_20121007_

#include "elf_auxv.h"
#include "elf_dyn.h"
#include "elf_header.h"
#include "elf_move.h"
#include "elf_nhdr.h"
#include "elf_phdr.h"
#include "elf_rel.h"
#include "elf_rela.h"
#include "elf_shdr.h"
#include "elf_sym.h"
#include "elf_syminfo.h"
#include "elf_types.h"
#include "elf_verdaux.h"
#include "elf_verdef.h"
#include "elf_vernaux.h"
#include "elf_verneed.h"

/* Motorola 68k specific definitions.  */

/* Values for Elf32_Ehdr.e_flags.  */
enum { EF_CPU32 = 0x00810000 };

/* m68k relocs.  */
enum {
	R_68K_NONE         = 0,  /* No reloc */
	R_68K_32           = 1,  /* Direct 32 bit  */
	R_68K_16           = 2,  /* Direct 16 bit  */
	R_68K_8            = 3,  /* Direct 8 bit  */
	R_68K_PC32         = 4,  /* PC relative 32 bit */
	R_68K_PC16         = 5,  /* PC relative 16 bit */
	R_68K_PC8          = 6,  /* PC relative 8 bit */
	R_68K_GOT32        = 7,  /* 32 bit PC relative GOT entry */
	R_68K_GOT16        = 8,  /* 16 bit PC relative GOT entry */
	R_68K_GOT8         = 9,  /* 8 bit PC relative GOT entry */
	R_68K_GOT32O       = 10, /* 32 bit GOT offset */
	R_68K_GOT16O       = 11, /* 16 bit GOT offset */
	R_68K_GOT8O        = 12, /* 8 bit GOT offset */
	R_68K_PLT32        = 13, /* 32 bit PC relative PLT address */
	R_68K_PLT16        = 14, /* 16 bit PC relative PLT address */
	R_68K_PLT8         = 15, /* 8 bit PC relative PLT address */
	R_68K_PLT32O       = 16, /* 32 bit PLT offset */
	R_68K_PLT16O       = 17, /* 16 bit PLT offset */
	R_68K_PLT8O        = 18, /* 8 bit PLT offset */
	R_68K_COPY         = 19, /* Copy symbol at runtime */
	R_68K_GLOB_DAT     = 20, /* Create GOT entry */
	R_68K_JMP_SLOT     = 21, /* Create PLT entry */
	R_68K_RELATIVE     = 22, /* Adjust by program base */
	R_68K_TLS_GD32     = 25, /* 32 bit GOT offset for GD */
	R_68K_TLS_GD16     = 26, /* 16 bit GOT offset for GD */
	R_68K_TLS_GD8      = 27, /* 8 bit GOT offset for GD */
	R_68K_TLS_LDM32    = 28, /* 32 bit GOT offset for LDM */
	R_68K_TLS_LDM16    = 29, /* 16 bit GOT offset for LDM */
	R_68K_TLS_LDM8     = 30, /* 8 bit GOT offset for LDM */
	R_68K_TLS_LDO32    = 31, /* 32 bit module-relative offset */
	R_68K_TLS_LDO16    = 32, /* 16 bit module-relative offset */
	R_68K_TLS_LDO8     = 33, /* 8 bit module-relative offset */
	R_68K_TLS_IE32     = 34, /* 32 bit GOT offset for IE */
	R_68K_TLS_IE16     = 35, /* 16 bit GOT offset for IE */
	R_68K_TLS_IE8      = 36, /* 8 bit GOT offset for IE */
	R_68K_TLS_LE32     = 37, /* 32 bit offset relative to static TLS block */
	R_68K_TLS_LE16     = 38, /* 16 bit offset relative to static TLS block */
	R_68K_TLS_LE8      = 39, /* 8 bit offset relative to static TLS block */
	R_68K_TLS_DTPMOD32 = 40, /* 32 bit module number */
	R_68K_TLS_DTPREL32 = 41, /* 32 bit module-relative offset */
	R_68K_TLS_TPREL32  = 42, /* 32 bit TP-relative offset */

	/* Keep this the last entry.  */
	R_68K_NUM = 43
};

/* Intel 80386 specific definitions.  */

/* i386 relocs.  */
enum {
	R_386_NONE         = 0,  /* No reloc */
	R_386_32           = 1,  /* Direct 32 bit  */
	R_386_PC32         = 2,  /* PC relative 32 bit */
	R_386_GOT32        = 3,  /* 32 bit GOT entry */
	R_386_PLT32        = 4,  /* 32 bit PLT address */
	R_386_COPY         = 5,  /* Copy symbol at runtime */
	R_386_GLOB_DAT     = 6,  /* Create GOT entry */
	R_386_JMP_SLOT     = 7,  /* Create PLT entry */
	R_386_RELATIVE     = 8,  /* Adjust by program base */
	R_386_GOTOFF       = 9,  /* 32 bit offset to GOT */
	R_386_GOTPC        = 10, /* 32 bit PC relative offset to GOT */
	R_386_32PLT        = 11,
	R_386_TLS_TPOFF    = 14, /* Offset in static TLS block */
	R_386_TLS_IE       = 15, /* Address of GOT entry for static TLS block offset */
	R_386_TLS_GOTIE    = 16, /* GOT entry for static TLS block offset */
	R_386_TLS_LE       = 17, /* Offset relative to static TLS block */
	R_386_TLS_GD       = 18, /* Direct 32 bit for GNU version of general dynamic thread local data */
	R_386_TLS_LDM      = 19, /* Direct 32 bit for GNU version of local dynamic thread local data in LE code */
	R_386_16           = 20,
	R_386_PC16         = 21,
	R_386_8            = 22,
	R_386_PC8          = 23,
	R_386_TLS_GD_32    = 24, /* Direct 32 bit for general dynamic thread local data */
	R_386_TLS_GD_PUSH  = 25, /* Tag for pushl in GD TLS code */
	R_386_TLS_GD_CALL  = 26, /* Relocation for call to __tls_get_addr() */
	R_386_TLS_GD_POP   = 27, /* Tag for popl in GD TLS code */
	R_386_TLS_LDM_32   = 28, /* Direct 32 bit for local dynamic thread local data in LE code */
	R_386_TLS_LDM_PUSH = 29, /* Tag for pushl in LDM TLS code */
	R_386_TLS_LDM_CALL = 30, /* Relocation for call to __tls_get_addr() in LDM code */
	R_386_TLS_LDM_POP  = 31, /* Tag for popl in LDM TLS code */
	R_386_TLS_LDO_32   = 32, /* Offset relative to TLS block */
	R_386_TLS_IE_32    = 33, /* GOT entry for negated static TLS block offset */
	R_386_TLS_LE_32    = 34, /* Negated offset relative to static TLS block */
	R_386_TLS_DTPMOD32 = 35, /* ID of module containing symbol */
	R_386_TLS_DTPOFF32 = 36, /* Offset in TLS block */
	R_386_TLS_TPOFF32  = 37, /* Negated offset in static TLS block */
	/* 38? */
	R_386_TLS_GOTDESC   = 39, /* GOT offset for TLS descriptor.  */
	R_386_TLS_DESC_CALL = 40, /* Marker of call through TLS descriptor for relaxation.  */
	R_386_TLS_DESC      = 41, /* TLS descriptor containing pointer to code and to argument, returning the TLS offset for the symbol.  */
	R_386_IRELATIVE     = 42, /* Adjust indirectly by program base */

	/* Keep this the last entry.  */
	R_386_NUM = 43
};

/* SUN SPARC specific definitions.  */

/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
enum {
	STT_SPARC_REGISTER = 13 /* Global register reserved to app. */
};

/* Values for Elf64_Ehdr.e_flags.  */
enum {
	EF_SPARCV9_MM     = 3,
	EF_SPARCV9_TSO    = 0,
	EF_SPARCV9_PSO    = 1,
	EF_SPARCV9_RMO    = 2,
	EF_SPARC_LEDATA   = 0x800000, /* little endian data */
	EF_SPARC_EXT_MASK = 0xFFFF00,
	EF_SPARC_32PLUS   = 0x000100, /* generic V8+ features */
	EF_SPARC_SUN_US1  = 0x000200, /* Sun UltraSPARC1 extensions */
	EF_SPARC_HAL_R1   = 0x000400, /* HAL R1 extensions */
	EF_SPARC_SUN_US3  = 0x000800  /* Sun UltraSPARCIII extensions */
};

/* SPARC relocs.  */
enum {
	R_SPARC_NONE     = 0,  /* No reloc */
	R_SPARC_8        = 1,  /* Direct 8 bit */
	R_SPARC_16       = 2,  /* Direct 16 bit */
	R_SPARC_32       = 3,  /* Direct 32 bit */
	R_SPARC_DISP8    = 4,  /* PC relative 8 bit */
	R_SPARC_DISP16   = 5,  /* PC relative 16 bit */
	R_SPARC_DISP32   = 6,  /* PC relative 32 bit */
	R_SPARC_WDISP30  = 7,  /* PC relative 30 bit shifted */
	R_SPARC_WDISP22  = 8,  /* PC relative 22 bit shifted */
	R_SPARC_HI22     = 9,  /* High 22 bit */
	R_SPARC_22       = 10, /* Direct 22 bit */
	R_SPARC_13       = 11, /* Direct 13 bit */
	R_SPARC_LO10     = 12, /* Truncated 10 bit */
	R_SPARC_GOT10    = 13, /* Truncated 10 bit GOT entry */
	R_SPARC_GOT13    = 14, /* 13 bit GOT entry */
	R_SPARC_GOT22    = 15, /* 22 bit GOT entry shifted */
	R_SPARC_PC10     = 16, /* PC relative 10 bit truncated */
	R_SPARC_PC22     = 17, /* PC relative 22 bit shifted */
	R_SPARC_WPLT30   = 18, /* 30 bit PC relative PLT address */
	R_SPARC_COPY     = 19, /* Copy symbol at runtime */
	R_SPARC_GLOB_DAT = 20, /* Create GOT entry */
	R_SPARC_JMP_SLOT = 21, /* Create PLT entry */
	R_SPARC_RELATIVE = 22, /* Adjust by program base */
	R_SPARC_UA32     = 23, /* Direct 32 bit unaligned */
};

/* Additional Sparc64 relocs.  */
enum {
	R_SPARC_PLT32            = 24, /* Direct 32 bit ref to PLT entry */
	R_SPARC_HIPLT22          = 25, /* High 22 bit PLT entry */
	R_SPARC_LOPLT10          = 26, /* Truncated 10 bit PLT entry */
	R_SPARC_PCPLT32          = 27, /* PC rel 32 bit ref to PLT entry */
	R_SPARC_PCPLT22          = 28, /* PC rel high 22 bit PLT entry */
	R_SPARC_PCPLT10          = 29, /* PC rel trunc 10 bit PLT entry */
	R_SPARC_10               = 30, /* Direct 10 bit */
	R_SPARC_11               = 31, /* Direct 11 bit */
	R_SPARC_64               = 32, /* Direct 64 bit */
	R_SPARC_OLO10            = 33, /* 10bit with secondary 13bit addend */
	R_SPARC_HH22             = 34, /* Top 22 bits of direct 64 bit */
	R_SPARC_HM10             = 35, /* High middle 10 bits of ... */
	R_SPARC_LM22             = 36, /* Low middle 22 bits of ... */
	R_SPARC_PC_HH22          = 37, /* Top 22 bits of pc rel 64 bit */
	R_SPARC_PC_HM10          = 38, /* High middle 10 bit of ... */
	R_SPARC_PC_LM22          = 39, /* Low miggle 22 bits of ... */
	R_SPARC_WDISP16          = 40, /* PC relative 16 bit shifted */
	R_SPARC_WDISP19          = 41, /* PC relative 19 bit shifted */
	R_SPARC_GLOB_JMP         = 42, /* was part of v9 ABI but was removed */
	R_SPARC_7                = 43, /* Direct 7 bit */
	R_SPARC_5                = 44, /* Direct 5 bit */
	R_SPARC_6                = 45, /* Direct 6 bit */
	R_SPARC_DISP64           = 46, /* PC relative 64 bit */
	R_SPARC_PLT64            = 47, /* Direct 64 bit ref to PLT entry */
	R_SPARC_HIX22            = 48, /* High 22 bit complemented */
	R_SPARC_LOX10            = 49, /* Truncated 11 bit complemented */
	R_SPARC_H44              = 50, /* Direct high 12 of 44 bit */
	R_SPARC_M44              = 51, /* Direct mid 22 of 44 bit */
	R_SPARC_L44              = 52, /* Direct low 10 of 44 bit */
	R_SPARC_REGISTER         = 53, /* Global register usage */
	R_SPARC_UA64             = 54, /* Direct 64 bit unaligned */
	R_SPARC_UA16             = 55, /* Direct 16 bit unaligned */
	R_SPARC_TLS_GD_HI22      = 56,
	R_SPARC_TLS_GD_LO10      = 57,
	R_SPARC_TLS_GD_ADD       = 58,
	R_SPARC_TLS_GD_CALL      = 59,
	R_SPARC_TLS_LDM_HI22     = 60,
	R_SPARC_TLS_LDM_LO10     = 61,
	R_SPARC_TLS_LDM_ADD      = 62,
	R_SPARC_TLS_LDM_CALL     = 63,
	R_SPARC_TLS_LDO_HIX22    = 64,
	R_SPARC_TLS_LDO_LOX10    = 65,
	R_SPARC_TLS_LDO_ADD      = 66,
	R_SPARC_TLS_IE_HI22      = 67,
	R_SPARC_TLS_IE_LO10      = 68,
	R_SPARC_TLS_IE_LD        = 69,
	R_SPARC_TLS_IE_LDX       = 70,
	R_SPARC_TLS_IE_ADD       = 71,
	R_SPARC_TLS_LE_HIX22     = 72,
	R_SPARC_TLS_LE_LOX10     = 73,
	R_SPARC_TLS_DTPMOD32     = 74,
	R_SPARC_TLS_DTPMOD64     = 75,
	R_SPARC_TLS_DTPOFF32     = 76,
	R_SPARC_TLS_DTPOFF64     = 77,
	R_SPARC_TLS_TPOFF32      = 78,
	R_SPARC_TLS_TPOFF64      = 79,
	R_SPARC_GOTDATA_HIX22    = 80,
	R_SPARC_GOTDATA_LOX10    = 81,
	R_SPARC_GOTDATA_OP_HIX22 = 82,
	R_SPARC_GOTDATA_OP_LOX10 = 83,
	R_SPARC_GOTDATA_OP       = 84,
	R_SPARC_H34              = 85,
	R_SPARC_SIZE32           = 86,
	R_SPARC_SIZE64           = 87,
	R_SPARC_JMP_IREL         = 248,
	R_SPARC_IRELATIVE        = 249,
	R_SPARC_GNU_VTINHERIT    = 250,
	R_SPARC_GNU_VTENTRY      = 251,
	R_SPARC_REV32            = 252,

	/* Keep this the last entry.  */
	R_SPARC_NUM = 253,
};

/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */
enum {
	DT_SPARC_REGISTER = 0x70000001,
	DT_SPARC_NUM      = 2,
};

/* MIPS R3000 specific definitions.  */

/* Legal values for e_flags field of Elf32_Ehdr.  */
enum {
	EF_MIPS_NOREORDER   = 1, /* A .noreorder directive was used */
	EF_MIPS_PIC         = 2, /* Contains PIC code */
	EF_MIPS_CPIC        = 4, /* Uses PIC calling sequence */
	EF_MIPS_XGOT        = 8,
	EF_MIPS_64BIT_WHIRL = 16,
	EF_MIPS_ABI2        = 32,
	EF_MIPS_ABI_ON32    = 64,
	EF_MIPS_ARCH        = 0xf0000000 /* MIPS architecture level */
};

/* Legal values for MIPS architecture level.  */
enum {
	EF_MIPS_ARCH_1  = 0x00000000, /* -mips1 code.  */
	EF_MIPS_ARCH_2  = 0x10000000, /* -mips2 code.  */
	EF_MIPS_ARCH_3  = 0x20000000, /* -mips3 code.  */
	EF_MIPS_ARCH_4  = 0x30000000, /* -mips4 code.  */
	EF_MIPS_ARCH_5  = 0x40000000, /* -mips5 code.  */
	EF_MIPS_ARCH_32 = 0x60000000, /* MIPS32 code.  */
	EF_MIPS_ARCH_64 = 0x70000000, /* MIPS64 code.  */
};

/* The following are non-official names and should not be used.  */
enum {
	E_MIPS_ARCH_1  = 0x00000000, /* -mips1 code.  */
	E_MIPS_ARCH_2  = 0x10000000, /* -mips2 code.  */
	E_MIPS_ARCH_3  = 0x20000000, /* -mips3 code.  */
	E_MIPS_ARCH_4  = 0x30000000, /* -mips4 code.  */
	E_MIPS_ARCH_5  = 0x40000000, /* -mips5 code.  */
	E_MIPS_ARCH_32 = 0x60000000, /* MIPS32 code.  */
	E_MIPS_ARCH_64 = 0x70000000, /* MIPS64 code.  */
};

/* Special section indices.  */
enum {
	SHN_MIPS_ACOMMON    = 0xff00, /* Allocated common symbols */
	SHN_MIPS_TEXT       = 0xff01, /* Allocated test symbols.  */
	SHN_MIPS_DATA       = 0xff02, /* Allocated data symbols.  */
	SHN_MIPS_SCOMMON    = 0xff03, /* Small common symbols */
	SHN_MIPS_SUNDEFINED = 0xff04, /* Small undefined symbols */
};

/* Legal values for sh_type field of Elf32_Shdr.  */
enum {
	SHT_MIPS_LIBLIST       = 0x70000000, /* Shared objects used in link */
	SHT_MIPS_MSYM          = 0x70000001,
	SHT_MIPS_CONFLICT      = 0x70000002, /* Conflicting symbols */
	SHT_MIPS_GPTAB         = 0x70000003, /* Global data area sizes */
	SHT_MIPS_UCODE         = 0x70000004, /* Reserved for SGI/MIPS compilers */
	SHT_MIPS_DEBUG         = 0x70000005, /* MIPS ECOFF debugging information*/
	SHT_MIPS_REGINFO       = 0x70000006, /* Register usage information */
	SHT_MIPS_PACKAGE       = 0x70000007,
	SHT_MIPS_PACKSYM       = 0x70000008,
	SHT_MIPS_RELD          = 0x70000009,
	SHT_MIPS_IFACE         = 0x7000000b,
	SHT_MIPS_CONTENT       = 0x7000000c,
	SHT_MIPS_OPTIONS       = 0x7000000d, /* Miscellaneous options.  */
	SHT_MIPS_SHDR          = 0x70000010,
	SHT_MIPS_FDESC         = 0x70000011,
	SHT_MIPS_EXTSYM        = 0x70000012,
	SHT_MIPS_DENSE         = 0x70000013,
	SHT_MIPS_PDESC         = 0x70000014,
	SHT_MIPS_LOCSYM        = 0x70000015,
	SHT_MIPS_AUXSYM        = 0x70000016,
	SHT_MIPS_OPTSYM        = 0x70000017,
	SHT_MIPS_LOCSTR        = 0x70000018,
	SHT_MIPS_LINE          = 0x70000019,
	SHT_MIPS_RFDESC        = 0x7000001a,
	SHT_MIPS_DELTASYM      = 0x7000001b,
	SHT_MIPS_DELTAINST     = 0x7000001c,
	SHT_MIPS_DELTACLASS    = 0x7000001d,
	SHT_MIPS_DWARF         = 0x7000001e, /* DWARF debugging information.  */
	SHT_MIPS_DELTADECL     = 0x7000001f,
	SHT_MIPS_SYMBOL_LIB    = 0x70000020,
	SHT_MIPS_EVENTS        = 0x70000021, /* Event section.  */
	SHT_MIPS_TRANSLATE     = 0x70000022,
	SHT_MIPS_PIXIE         = 0x70000023,
	SHT_MIPS_XLATE         = 0x70000024,
	SHT_MIPS_XLATE_DEBUG   = 0x70000025,
	SHT_MIPS_WHIRL         = 0x70000026,
	SHT_MIPS_EH_REGION     = 0x70000027,
	SHT_MIPS_XLATE_OLD     = 0x70000028,
	SHT_MIPS_PDR_EXCEPTION = 0x70000029,
};

/* Legal values for sh_flags field of Elf32_Shdr.  */
enum {
	SHF_MIPS_GPREL   = 0x10000000, /* Must be part of global data area */
	SHF_MIPS_MERGE   = 0x20000000,
	SHF_MIPS_ADDR    = 0x40000000,
	SHF_MIPS_STRINGS = 0x80000000,
	SHF_MIPS_NOSTRIP = 0x08000000,
	SHF_MIPS_LOCAL   = 0x04000000,
	SHF_MIPS_NAMES   = 0x02000000,
	SHF_MIPS_NODUPE  = 0x01000000,
};

/* Symbol tables.  */

/* MIPS specific values for `st_other'.  */
enum {
	STO_MIPS_DEFAULT         = 0x0,
	STO_MIPS_INTERNAL        = 0x1,
	STO_MIPS_HIDDEN          = 0x2,
	STO_MIPS_PROTECTED       = 0x3,
	STO_MIPS_PLT             = 0x8,
	STO_MIPS_SC_ALIGN_UNUSED = 0xff,
};

/* MIPS specific values for `st_info'.  */
enum {
	STB_MIPS_SPLIT_COMMON = 13,
};

/* Entries found in sections of type SHT_MIPS_GPTAB.  */

union elf32_gptab {
	struct {
		elf32_word gt_current_g_value; /* -G value used for compilation */
		elf32_word gt_unused;          /* Not used */
	} gt_header;                       /* First entry in section */

	struct {
		elf32_word gt_g_value; /* If this value were used for -G */
		elf32_word gt_bytes;   /* This many bytes would be used */
	} gt_entry;                /* Subsequent entries in section */
};

/* Entry found in sections of type SHT_MIPS_REGINFO.  */
struct elf32_reginfo {
	elf32_word ri_gprmask;    /* General registers used */
	elf32_word ri_cprmask[4]; /* Coprocessor registers used */
	elf32_sword ri_gp_value;  /* $gp register value */
};

/* Entries found in sections of type SHT_MIPS_OPTIONS.  */
struct elf_options {
	uint8_t kind;          /* Determines interpretation of the variable part of descriptor.  */
	uint8_t size;          /* Size of descriptor, including header.  */
	elf32_section section; /* Section header index of section affected, 0 for global options.  */
	elf32_word info;       /* Kind-specific information.  */
};

/* Values for `kind' field in Elf_Options.  */
enum {
	ODK_NULL       = 0, /* Undefined.  */
	ODK_REGINFO    = 1, /* Register usage information.  */
	ODK_EXCEPTIONS = 2, /* Exception processing options.  */
	ODK_PAD        = 3, /* Section padding options.  */
	ODK_HWPATCH    = 4, /* Hardware workarounds performed */
	ODK_FILL       = 5, /* record the fill value used by the linker. */
	ODK_TAGS       = 6, /* reserve space for desktop tools to write. */
	ODK_HWAND      = 7, /* HW workarounds.  'AND' bits when merging. */
	ODK_HWOR       = 8, /* HW workarounds.  'OR' bits when merging.  */
};

/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */
enum {
	OEX_FPU_MIN   = 0x1f,    /* FPE's which MUST be enabled.  */
	OEX_FPU_MAX   = 0x1f00,  /* FPE's which MAY be enabled.  */
	OEX_PAGE0     = 0x10000, /* page zero must be mapped.  */
	OEX_SMM       = 0x20000, /* Force sequential memory mode?  */
	OEX_FPDBUG    = 0x40000, /* Force floating point debug mode?  */
	OEX_PRECISEFP = OEX_FPDBUG,
	OEX_DISMISS   = 0x80000, /* Dismiss invalid address faults?  */

	OEX_FPU_INVAL = 0x10,
	OEX_FPU_DIV0  = 0x08,
	OEX_FPU_OFLO  = 0x04,
	OEX_FPU_UFLO  = 0x02,
	OEX_FPU_INEX  = 0x01,
};

/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */
enum {
	OHW_R4KEOP    = 0x1, /* R4000 end-of-page patch.  */
	OHW_R8KPFETCH = 0x2, /* may need R8000 prefetch patch.  */
	OHW_R5KEOP    = 0x4, /* R5000 end-of-page patch.  */
	OHW_R5KCVTL   = 0x8, /* R5000 cvt.[ds].l bug.  clean=1.  */

	OPAD_PREFIX  = 0x1,
	OPAD_POSTFIX = 0x2,
	OPAD_SYMBOL  = 0x4,
};

/* Entry found in `.options' section.  */
struct elf_options_hw {
	elf32_word hwp_flags1; /* Extra flags.  */
	elf32_word hwp_flags2; /* Extra flags.  */
};

/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */
enum {
	OHWA0_R4KEOP_CHECKED = 0x00000001,
	OHWA1_R4KEOP_CLEAN   = 0x00000002,
};

/* MIPS relocs.  */
enum {
	R_MIPS_NONE            = 0,  /* No reloc */
	R_MIPS_16              = 1,  /* Direct 16 bit */
	R_MIPS_32              = 2,  /* Direct 32 bit */
	R_MIPS_REL32           = 3,  /* PC relative 32 bit */
	R_MIPS_26              = 4,  /* Direct 26 bit shifted */
	R_MIPS_HI16            = 5,  /* High 16 bit */
	R_MIPS_LO16            = 6,  /* Low 16 bit */
	R_MIPS_GPREL16         = 7,  /* GP relative 16 bit */
	R_MIPS_LITERAL         = 8,  /* 16 bit literal entry */
	R_MIPS_GOT16           = 9,  /* 16 bit GOT entry */
	R_MIPS_PC16            = 10, /* PC relative 16 bit */
	R_MIPS_CALL16          = 11, /* 16 bit GOT entry for function */
	R_MIPS_GPREL32         = 12, /* GP relative 32 bit */
	R_MIPS_SHIFT5          = 16,
	R_MIPS_SHIFT6          = 17,
	R_MIPS_64              = 18,
	R_MIPS_GOT_DISP        = 19,
	R_MIPS_GOT_PAGE        = 20,
	R_MIPS_GOT_OFST        = 21,
	R_MIPS_GOT_HI16        = 22,
	R_MIPS_GOT_LO16        = 23,
	R_MIPS_SUB             = 24,
	R_MIPS_INSERT_A        = 25,
	R_MIPS_INSERT_B        = 26,
	R_MIPS_DELETE          = 27,
	R_MIPS_HIGHER          = 28,
	R_MIPS_HIGHEST         = 29,
	R_MIPS_CALL_HI16       = 30,
	R_MIPS_CALL_LO16       = 31,
	R_MIPS_SCN_DISP        = 32,
	R_MIPS_REL16           = 33,
	R_MIPS_ADD_IMMEDIATE   = 34,
	R_MIPS_PJUMP           = 35,
	R_MIPS_RELGOT          = 36,
	R_MIPS_JALR            = 37,
	R_MIPS_TLS_DTPMOD32    = 38, /* Module number 32 bit */
	R_MIPS_TLS_DTPREL32    = 39, /* Module-relative offset 32 bit */
	R_MIPS_TLS_DTPMOD64    = 40, /* Module number 64 bit */
	R_MIPS_TLS_DTPREL64    = 41, /* Module-relative offset 64 bit */
	R_MIPS_TLS_GD          = 42, /* 16 bit GOT offset for GD */
	R_MIPS_TLS_LDM         = 43, /* 16 bit GOT offset for LDM */
	R_MIPS_TLS_DTPREL_HI16 = 44, /* Module-relative offset, high 16 bits */
	R_MIPS_TLS_DTPREL_LO16 = 45, /* Module-relative offset, low 16 bits */
	R_MIPS_TLS_GOTTPREL    = 46, /* 16 bit GOT offset for IE */
	R_MIPS_TLS_TPREL32     = 47, /* TP-relative offset, 32 bit */
	R_MIPS_TLS_TPREL64     = 48, /* TP-relative offset, 64 bit */
	R_MIPS_TLS_TPREL_HI16  = 49, /* TP-relative offset, high 16 bits */
	R_MIPS_TLS_TPREL_LO16  = 50, /* TP-relative offset, low 16 bits */
	R_MIPS_GLOB_DAT        = 51,
	R_MIPS_COPY            = 126,
	R_MIPS_JUMP_SLOT       = 127,

	/* Keep this the last entry.  */
	R_MIPS_NUM = 128,
};

/* Legal values for p_type field of Elf32_Phdr.  */
enum {
	PT_MIPS_REGINFO = 0x70000000, /* Register usage information */
	PT_MIPS_RTPROC  = 0x70000001, /* Runtime procedure table. */
	PT_MIPS_OPTIONS = 0x70000002,
};

/* Special program header types.  */
enum {
	PF_MIPS_LOCAL = 0x10000000,
};

/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */
enum {
	RHF_NONE                   = 0,        /* No flags */
	RHF_QUICKSTART             = (1 << 0), /* Use quickstart */
	RHF_NOTPOT                 = (1 << 1), /* Hash size not power of 2 */
	RHF_NO_LIBRARY_REPLACEMENT = (1 << 2), /* Ignore LD_LIBRARY_PATH */
	RHF_NO_MOVE                = (1 << 3),
	RHF_SGI_ONLY               = (1 << 4),
	RHF_GUARANTEE_INIT         = (1 << 5),
	RHF_DELTA_C_PLUS_PLUS      = (1 << 6),
	RHF_GUARANTEE_START_INIT   = (1 << 7),
	RHF_PIXIE                  = (1 << 8),
	RHF_DEFAULT_DELAY_LOAD     = (1 << 9),
	RHF_REQUICKSTART           = (1 << 10),
	RHF_REQUICKSTARTED         = (1 << 11),
	RHF_CORD                   = (1 << 12),
	RHF_NO_UNRES_UNDEF         = (1 << 13),
	RHF_RLD_ORDER_SAFE         = (1 << 14),
};

/* Entries found in sections of type SHT_MIPS_LIBLIST.  */

struct elf32_lib {
	elf32_word l_name;       /* Name (string table index) */
	elf32_word l_time_stamp; /* Timestamp */
	elf32_word l_checksum;   /* Checksum */
	elf32_word l_version;    /* Interface version */
	elf32_word l_flags;      /* Flags */
};

struct elf64_lib {
	elf64_word l_name;       /* Name (string table index) */
	elf64_word l_time_stamp; /* Timestamp */
	elf64_word l_checksum;   /* Checksum */
	elf64_word l_version;    /* Interface version */
	elf64_word l_flags;      /* Flags */
};

/* Legal values for l_flags.  */
enum {
	LL_NONE           = 0,
	LL_EXACT_MATCH    = (1 << 0), /* Require exact match */
	LL_IGNORE_INT_VER = (1 << 1), /* Ignore interface version */
	LL_REQUIRE_MINOR  = (1 << 2),
	LL_EXPORTS        = (1 << 3),
	LL_DELAY_LOAD     = (1 << 4),
	LL_DELTA          = (1 << 5),
};

/* Entries found in sections of type SHT_MIPS_CONFLICT.  */

using elf32_conflict = elf32_addr;

/* HPPA specific definitions.  */

/* Legal values for e_flags field of Elf32_Ehdr.  */
enum {
	EF_PARISC_TRAPNIL  = 0x00010000, /* Trap nil pointer dereference.  */
	EF_PARISC_EXT      = 0x00020000, /* Program uses arch. extensions. */
	EF_PARISC_LSB      = 0x00040000, /* Program expects little endian. */
	EF_PARISC_WIDE     = 0x00080000, /* Program expects wide mode.  */
	EF_PARISC_NO_KABP  = 0x00100000, /* No kernel assisted branch prediction.  */
	EF_PARISC_LAZYSWAP = 0x00400000, /* Allow lazy swapping.  */
	EF_PARISC_ARCH     = 0x0000ffff, /* Architecture version.  */
};

/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */
enum {
	EFA_PARISC_1_0 = 0x020b, /* PA-RISC 1.0 big-endian.  */
	EFA_PARISC_1_1 = 0x0210, /* PA-RISC 1.1 big-endian.  */
	EFA_PARISC_2_0 = 0x0214, /* PA-RISC 2.0 big-endian.  */
};

/* Additional section indeces.  */
enum {
	SHN_PARISC_ANSI_COMMON = 0xff00, /* Section for tenatively declared symbols in ANSI C.  */
	SHN_PARISC_HUGE_COMMON = 0xff01, /* Common blocks in huge model.  */
};

/* Legal values for sh_type field of Elf32_Shdr.  */
enum {
	SHT_PARISC_EXT    = 0x70000000, /* Contains product specific ext. */
	SHT_PARISC_UNWIND = 0x70000001, /* Unwind information.  */
	SHT_PARISC_DOC    = 0x70000002, /* Debug info for optimized code. */
};

/* Legal values for sh_flags field of Elf32_Shdr.  */
enum {
	SHF_PARISC_SHORT = 0x20000000, /* Section with short addressing. */
	SHF_PARISC_HUGE  = 0x40000000, /* Section far from gp.  */
	SHF_PARISC_SBP   = 0x80000000, /* Static branch prediction code. */
};

/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
enum {
	STT_PARISC_MILLICODE = 13 /* Millicode function entry point.  */
};

enum {
	STT_HP_OPAQUE = (STT_LOOS + 0x1),
	STT_HP_STUB   = (STT_LOOS + 0x2),
};

/* HPPA relocs.  */
enum {
	R_PARISC_NONE           = 0,   /* No reloc.  */
	R_PARISC_DIR32          = 1,   /* Direct 32-bit reference.  */
	R_PARISC_DIR21L         = 2,   /* Left 21 bits of eff. address.  */
	R_PARISC_DIR17R         = 3,   /* Right 17 bits of eff. address.  */
	R_PARISC_DIR17F         = 4,   /* 17 bits of eff. address.  */
	R_PARISC_DIR14R         = 6,   /* Right 14 bits of eff. address.  */
	R_PARISC_PCREL32        = 9,   /* 32-bit rel. address.  */
	R_PARISC_PCREL21L       = 10,  /* Left 21 bits of rel. address.  */
	R_PARISC_PCREL17R       = 11,  /* Right 17 bits of rel. address.  */
	R_PARISC_PCREL17F       = 12,  /* 17 bits of rel. address.  */
	R_PARISC_PCREL14R       = 14,  /* Right 14 bits of rel. address.  */
	R_PARISC_DPREL21L       = 18,  /* Left 21 bits of rel. address.  */
	R_PARISC_DPREL14R       = 22,  /* Right 14 bits of rel. address.  */
	R_PARISC_GPREL21L       = 26,  /* GP-relative, left 21 bits.  */
	R_PARISC_GPREL14R       = 30,  /* GP-relative, right 14 bits.  */
	R_PARISC_LTOFF21L       = 34,  /* LT-relative, left 21 bits.  */
	R_PARISC_LTOFF14R       = 38,  /* LT-relative, right 14 bits.  */
	R_PARISC_SECREL32       = 41,  /* 32 bits section rel. address.  */
	R_PARISC_SEGBASE        = 48,  /* No relocation, set segment base.  */
	R_PARISC_SEGREL32       = 49,  /* 32 bits segment rel. address.  */
	R_PARISC_PLTOFF21L      = 50,  /* PLT rel. address, left 21 bits.  */
	R_PARISC_PLTOFF14R      = 54,  /* PLT rel. address, right 14 bits.  */
	R_PARISC_LTOFF_FPTR32   = 57,  /* 32 bits LT-rel. function pointer. */
	R_PARISC_LTOFF_FPTR21L  = 58,  /* LT-rel. fct ptr, left 21 bits. */
	R_PARISC_LTOFF_FPTR14R  = 62,  /* LT-rel. fct ptr, right 14 bits. */
	R_PARISC_FPTR64         = 64,  /* 64 bits function address.  */
	R_PARISC_PLABEL32       = 65,  /* 32 bits function address.  */
	R_PARISC_PLABEL21L      = 66,  /* Left 21 bits of fdesc address.  */
	R_PARISC_PLABEL14R      = 70,  /* Right 14 bits of fdesc address.  */
	R_PARISC_PCREL64        = 72,  /* 64 bits PC-rel. address.  */
	R_PARISC_PCREL22F       = 74,  /* 22 bits PC-rel. address.  */
	R_PARISC_PCREL14WR      = 75,  /* PC-rel. address, right 14 bits.  */
	R_PARISC_PCREL14DR      = 76,  /* PC rel. address, right 14 bits.  */
	R_PARISC_PCREL16F       = 77,  /* 16 bits PC-rel. address.  */
	R_PARISC_PCREL16WF      = 78,  /* 16 bits PC-rel. address.  */
	R_PARISC_PCREL16DF      = 79,  /* 16 bits PC-rel. address.  */
	R_PARISC_DIR64          = 80,  /* 64 bits of eff. address.  */
	R_PARISC_DIR14WR        = 83,  /* 14 bits of eff. address.  */
	R_PARISC_DIR14DR        = 84,  /* 14 bits of eff. address.  */
	R_PARISC_DIR16F         = 85,  /* 16 bits of eff. address.  */
	R_PARISC_DIR16WF        = 86,  /* 16 bits of eff. address.  */
	R_PARISC_DIR16DF        = 87,  /* 16 bits of eff. address.  */
	R_PARISC_GPREL64        = 88,  /* 64 bits of GP-rel. address.  */
	R_PARISC_GPREL14WR      = 91,  /* GP-rel. address, right 14 bits.  */
	R_PARISC_GPREL14DR      = 92,  /* GP-rel. address, right 14 bits.  */
	R_PARISC_GPREL16F       = 93,  /* 16 bits GP-rel. address.  */
	R_PARISC_GPREL16WF      = 94,  /* 16 bits GP-rel. address.  */
	R_PARISC_GPREL16DF      = 95,  /* 16 bits GP-rel. address.  */
	R_PARISC_LTOFF64        = 96,  /* 64 bits LT-rel. address.  */
	R_PARISC_LTOFF14WR      = 99,  /* LT-rel. address, right 14 bits.  */
	R_PARISC_LTOFF14DR      = 100, /* LT-rel. address, right 14 bits.  */
	R_PARISC_LTOFF16F       = 101, /* 16 bits LT-rel. address.  */
	R_PARISC_LTOFF16WF      = 102, /* 16 bits LT-rel. address.  */
	R_PARISC_LTOFF16DF      = 103, /* 16 bits LT-rel. address.  */
	R_PARISC_SECREL64       = 104, /* 64 bits section rel. address.  */
	R_PARISC_SEGREL64       = 112, /* 64 bits segment rel. address.  */
	R_PARISC_PLTOFF14WR     = 115, /* PLT-rel. address, right 14 bits.  */
	R_PARISC_PLTOFF14DR     = 116, /* PLT-rel. address, right 14 bits.  */
	R_PARISC_PLTOFF16F      = 117, /* 16 bits LT-rel. address.  */
	R_PARISC_PLTOFF16WF     = 118, /* 16 bits PLT-rel. address.  */
	R_PARISC_PLTOFF16DF     = 119, /* 16 bits PLT-rel. address.  */
	R_PARISC_LTOFF_FPTR64   = 120, /* 64 bits LT-rel. function ptr.  */
	R_PARISC_LTOFF_FPTR14WR = 123, /* LT-rel. fct. ptr., right 14 bits. */
	R_PARISC_LTOFF_FPTR14DR = 124, /* LT-rel. fct. ptr., right 14 bits. */
	R_PARISC_LTOFF_FPTR16F  = 125, /* 16 bits LT-rel. function ptr.  */
	R_PARISC_LTOFF_FPTR16WF = 126, /* 16 bits LT-rel. function ptr.  */
	R_PARISC_LTOFF_FPTR16DF = 127, /* 16 bits LT-rel. function ptr.  */
	R_PARISC_LORESERVE      = 128,
	R_PARISC_COPY           = 128, /* Copy relocation.  */
	R_PARISC_IPLT           = 129, /* Dynamic reloc, imported PLT */
	R_PARISC_EPLT           = 130, /* Dynamic reloc, exported PLT */
	R_PARISC_TPREL32        = 153, /* 32 bits TP-rel. address.  */
	R_PARISC_TPREL21L       = 154, /* TP-rel. address, left 21 bits.  */
	R_PARISC_TPREL14R       = 158, /* TP-rel. address, right 14 bits.  */
	R_PARISC_LTOFF_TP21L    = 162, /* LT-TP-rel. address, left 21 bits. */
	R_PARISC_LTOFF_TP14R    = 166, /* LT-TP-rel. address, right 14 bits.*/
	R_PARISC_LTOFF_TP14F    = 167, /* 14 bits LT-TP-rel. address.  */
	R_PARISC_TPREL64        = 216, /* 64 bits TP-rel. address.  */
	R_PARISC_TPREL14WR      = 219, /* TP-rel. address, right 14 bits.  */
	R_PARISC_TPREL14DR      = 220, /* TP-rel. address, right 14 bits.  */
	R_PARISC_TPREL16F       = 221, /* 16 bits TP-rel. address.  */
	R_PARISC_TPREL16WF      = 222, /* 16 bits TP-rel. address.  */
	R_PARISC_TPREL16DF      = 223, /* 16 bits TP-rel. address.  */
	R_PARISC_LTOFF_TP64     = 224, /* 64 bits LT-TP-rel. address.  */
	R_PARISC_LTOFF_TP14WR   = 227, /* LT-TP-rel. address, right 14 bits.*/
	R_PARISC_LTOFF_TP14DR   = 228, /* LT-TP-rel. address, right 14 bits.*/
	R_PARISC_LTOFF_TP16F    = 229, /* 16 bits LT-TP-rel. address.  */
	R_PARISC_LTOFF_TP16WF   = 230, /* 16 bits LT-TP-rel. address.  */
	R_PARISC_LTOFF_TP16DF   = 231, /* 16 bits LT-TP-rel. address.  */
	R_PARISC_GNU_VTENTRY    = 232,
	R_PARISC_GNU_VTINHERIT  = 233,
	R_PARISC_TLS_GD21L      = 234, /* GD 21-bit left.  */
	R_PARISC_TLS_GD14R      = 235, /* GD 14-bit right.  */
	R_PARISC_TLS_GDCALL     = 236, /* GD call to __t_g_a.  */
	R_PARISC_TLS_LDM21L     = 237, /* LD module 21-bit left.  */
	R_PARISC_TLS_LDM14R     = 238, /* LD module 14-bit right.  */
	R_PARISC_TLS_LDMCALL    = 239, /* LD module call to __t_g_a.  */
	R_PARISC_TLS_LDO21L     = 240, /* LD offset 21-bit left.  */
	R_PARISC_TLS_LDO14R     = 241, /* LD offset 14-bit right.  */
	R_PARISC_TLS_DTPMOD32   = 242, /* DTP module 32-bit.  */
	R_PARISC_TLS_DTPMOD64   = 243, /* DTP module 64-bit.  */
	R_PARISC_TLS_DTPOFF32   = 244, /* DTP offset 32-bit.  */
	R_PARISC_TLS_DTPOFF64   = 245, /* DTP offset 32-bit.  */
	R_PARISC_TLS_LE21L      = R_PARISC_TPREL21L,
	R_PARISC_TLS_LE14R      = R_PARISC_TPREL14R,
	R_PARISC_TLS_IE21L      = R_PARISC_LTOFF_TP21L,
	R_PARISC_TLS_IE14R      = R_PARISC_LTOFF_TP14R,
	R_PARISC_TLS_TPREL32    = R_PARISC_TPREL32,
	R_PARISC_TLS_TPREL64    = R_PARISC_TPREL64,
	R_PARISC_HIRESERVE      = 255,
};

/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */
enum {
	PT_HP_TLS           = (PT_LOOS + 0x0),
	PT_HP_CORE_NONE     = (PT_LOOS + 0x1),
	PT_HP_CORE_VERSION  = (PT_LOOS + 0x2),
	PT_HP_CORE_KERNEL   = (PT_LOOS + 0x3),
	PT_HP_CORE_COMM     = (PT_LOOS + 0x4),
	PT_HP_CORE_PROC     = (PT_LOOS + 0x5),
	PT_HP_CORE_LOADABLE = (PT_LOOS + 0x6),
	PT_HP_CORE_STACK    = (PT_LOOS + 0x7),
	PT_HP_CORE_SHM      = (PT_LOOS + 0x8),
	PT_HP_CORE_MMF      = (PT_LOOS + 0x9),
	PT_HP_PARALLEL      = (PT_LOOS + 0x10),
	PT_HP_FASTBIND      = (PT_LOOS + 0x11),
	PT_HP_OPT_ANNOT     = (PT_LOOS + 0x12),
	PT_HP_HSL_ANNOT     = (PT_LOOS + 0x13),
	PT_HP_STACK         = (PT_LOOS + 0x14),
};

enum {
	PT_PARISC_ARCHEXT = 0x70000000,
	PT_PARISC_UNWIND  = 0x70000001,
};

/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */
enum {
	PF_PARISC_SBP = 0x08000000,
};

enum {
	PF_HP_PAGE_SIZE   = 0x00100000,
	PF_HP_FAR_SHARED  = 0x00200000,
	PF_HP_NEAR_SHARED = 0x00400000,
	PF_HP_CODE        = 0x01000000,
	PF_HP_MODIFY      = 0x02000000,
	PF_HP_LAZYSWAP    = 0x04000000,
	PF_HP_SBP         = 0x08000000,
};

/* Alpha specific definitions.  */

/* Legal values for e_flags field of Elf64_Ehdr.  */
enum {
	EF_ALPHA_32BIT    = 1, /* All addresses must be < 2GB.  */
	EF_ALPHA_CANRELAX = 2  /* Relocations for relaxing exist.  */
};

/* Legal values for sh_type field of Elf64_Shdr.  */

/* These two are primerily concerned with ECOFF debugging info.  */
enum {
	SHT_ALPHA_DEBUG   = 0x70000001,
	SHT_ALPHA_REGINFO = 0x70000002,
};

/* Legal values for sh_flags field of Elf64_Shdr.  */
enum {
	SHF_ALPHA_GPREL = 0x10000000,
};

/* Legal values for st_other field of Elf64_Sym.  */
enum {
	STO_ALPHA_NOPV       = 0x80, /* No PV required.  */
	STO_ALPHA_STD_GPLOAD = 0x88, /* PV only used for initial ldgp.  */
};

/* Alpha relocs.  */
enum {
	R_ALPHA_NONE      = 0,  /* No reloc */
	R_ALPHA_REFLONG   = 1,  /* Direct 32 bit */
	R_ALPHA_REFQUAD   = 2,  /* Direct 64 bit */
	R_ALPHA_GPREL32   = 3,  /* GP relative 32 bit */
	R_ALPHA_LITERAL   = 4,  /* GP relative 16 bit w/optimization */
	R_ALPHA_LITUSE    = 5,  /* Optimization hint for LITERAL */
	R_ALPHA_GPDISP    = 6,  /* Add displacement to GP */
	R_ALPHA_BRADDR    = 7,  /* PC+4 relative 23 bit shifted */
	R_ALPHA_HINT      = 8,  /* PC+4 relative 16 bit shifted */
	R_ALPHA_SREL16    = 9,  /* PC relative 16 bit */
	R_ALPHA_SREL32    = 10, /* PC relative 32 bit */
	R_ALPHA_SREL64    = 11, /* PC relative 64 bit */
	R_ALPHA_GPRELHIGH = 17, /* GP relative 32 bit, high 16 bits */
	R_ALPHA_GPRELLOW  = 18, /* GP relative 32 bit, low 16 bits */
	R_ALPHA_GPREL16   = 19, /* GP relative 16 bit */
	R_ALPHA_COPY      = 24, /* Copy symbol at runtime */
	R_ALPHA_GLOB_DAT  = 25, /* Create GOT entry */
	R_ALPHA_JMP_SLOT  = 26, /* Create PLT entry */
	R_ALPHA_RELATIVE  = 27, /* Adjust by program base */
	R_ALPHA_TLS_GD_HI = 28,
	R_ALPHA_TLSGD     = 29,
	R_ALPHA_TLS_LDM   = 30,
	R_ALPHA_DTPMOD64  = 31,
	R_ALPHA_GOTDTPREL = 32,
	R_ALPHA_DTPREL64  = 33,
	R_ALPHA_DTPRELHI  = 34,
	R_ALPHA_DTPRELLO  = 35,
	R_ALPHA_DTPREL16  = 36,
	R_ALPHA_GOTTPREL  = 37,
	R_ALPHA_TPREL64   = 38,
	R_ALPHA_TPRELHI   = 39,
	R_ALPHA_TPRELLO   = 40,
	R_ALPHA_TPREL16   = 41,

	/* Keep this the last entry.  */
	R_ALPHA_NUM = 46,
};

/* Magic values of the LITUSE relocation addend.  */
enum {
	LITUSE_ALPHA_ADDR    = 0,
	LITUSE_ALPHA_BASE    = 1,
	LITUSE_ALPHA_BYTOFF  = 2,
	LITUSE_ALPHA_JSR     = 3,
	LITUSE_ALPHA_TLS_GD  = 4,
	LITUSE_ALPHA_TLS_LDM = 5,
};

/* Legal values for d_tag of Elf64_Dyn.  */
enum {
	DT_ALPHA_PLTRO = (DT_LOPROC + 0),
	DT_ALPHA_NUM   = 1,
};

/* PowerPC specific declarations */

/* Values for Elf32/64_Ehdr.e_flags.  */
enum {
	EF_PPC_EMB = 0x80000000, /* PowerPC embedded flag */
};

/* Cygnus local bits below */
enum {
	EF_PPC_RELOCATABLE     = 0x00010000, /* PowerPC -mrelocatable flag*/
	EF_PPC_RELOCATABLE_LIB = 0x00008000, /* PowerPC -mrelocatable-lib flag */
};

/* PowerPC relocations defined by the ABIs */
enum {
	R_PPC_NONE            = 0,
	R_PPC_ADDR32          = 1, /* 32bit absolute address */
	R_PPC_ADDR24          = 2, /* 26bit address, 2 bits ignored.  */
	R_PPC_ADDR16          = 3, /* 16bit absolute address */
	R_PPC_ADDR16_LO       = 4, /* lower 16bit of absolute address */
	R_PPC_ADDR16_HI       = 5, /* high 16bit of absolute address */
	R_PPC_ADDR16_HA       = 6, /* adjusted high 16bit */
	R_PPC_ADDR14          = 7, /* 16bit address, 2 bits ignored */
	R_PPC_ADDR14_BRTAKEN  = 8,
	R_PPC_ADDR14_BRNTAKEN = 9,
	R_PPC_REL24           = 10, /* PC relative 26 bit */
	R_PPC_REL14           = 11, /* PC relative 16 bit */
	R_PPC_REL14_BRTAKEN   = 12,
	R_PPC_REL14_BRNTAKEN  = 13,
	R_PPC_GOT16           = 14,
	R_PPC_GOT16_LO        = 15,
	R_PPC_GOT16_HI        = 16,
	R_PPC_GOT16_HA        = 17,
	R_PPC_PLTREL24        = 18,
	R_PPC_COPY            = 19,
	R_PPC_GLOB_DAT        = 20,
	R_PPC_JMP_SLOT        = 21,
	R_PPC_RELATIVE        = 22,
	R_PPC_LOCAL24PC       = 23,
	R_PPC_UADDR32         = 24,
	R_PPC_UADDR16         = 25,
	R_PPC_REL32           = 26,
	R_PPC_PLT32           = 27,
	R_PPC_PLTREL32        = 28,
	R_PPC_PLT16_LO        = 29,
	R_PPC_PLT16_HI        = 30,
	R_PPC_PLT16_HA        = 31,
	R_PPC_SDAREL16        = 32,
	R_PPC_SECTOFF         = 33,
	R_PPC_SECTOFF_LO      = 34,
	R_PPC_SECTOFF_HI      = 35,
	R_PPC_SECTOFF_HA      = 36,
};

/* PowerPC relocations defined for the TLS access ABI.  */
enum {
	R_PPC_TLS             = 67, /* none	(sym+add)@tls */
	R_PPC_DTPMOD32        = 68, /* word32	(sym+add)@dtpmod */
	R_PPC_TPREL16         = 69, /* half16*	(sym+add)@tprel */
	R_PPC_TPREL16_LO      = 70, /* half16	(sym+add)@tprel@l */
	R_PPC_TPREL16_HI      = 71, /* half16	(sym+add)@tprel@h */
	R_PPC_TPREL16_HA      = 72, /* half16	(sym+add)@tprel@ha */
	R_PPC_TPREL32         = 73, /* word32	(sym+add)@tprel */
	R_PPC_DTPREL16        = 74, /* half16*	(sym+add)@dtprel */
	R_PPC_DTPREL16_LO     = 75, /* half16	(sym+add)@dtprel@l */
	R_PPC_DTPREL16_HI     = 76, /* half16	(sym+add)@dtprel@h */
	R_PPC_DTPREL16_HA     = 77, /* half16	(sym+add)@dtprel@ha */
	R_PPC_DTPREL32        = 78, /* word32	(sym+add)@dtprel */
	R_PPC_GOT_TLSGD16     = 79, /* half16*	(sym+add)@got@tlsgd */
	R_PPC_GOT_TLSGD16_LO  = 80, /* half16	(sym+add)@got@tlsgd@l */
	R_PPC_GOT_TLSGD16_HI  = 81, /* half16	(sym+add)@got@tlsgd@h */
	R_PPC_GOT_TLSGD16_HA  = 82, /* half16	(sym+add)@got@tlsgd@ha */
	R_PPC_GOT_TLSLD16     = 83, /* half16*	(sym+add)@got@tlsld */
	R_PPC_GOT_TLSLD16_LO  = 84, /* half16	(sym+add)@got@tlsld@l */
	R_PPC_GOT_TLSLD16_HI  = 85, /* half16	(sym+add)@got@tlsld@h */
	R_PPC_GOT_TLSLD16_HA  = 86, /* half16	(sym+add)@got@tlsld@ha */
	R_PPC_GOT_TPREL16     = 87, /* half16*	(sym+add)@got@tprel */
	R_PPC_GOT_TPREL16_LO  = 88, /* half16	(sym+add)@got@tprel@l */
	R_PPC_GOT_TPREL16_HI  = 89, /* half16	(sym+add)@got@tprel@h */
	R_PPC_GOT_TPREL16_HA  = 90, /* half16	(sym+add)@got@tprel@ha */
	R_PPC_GOT_DTPREL16    = 91, /* half16*	(sym+add)@got@dtprel */
	R_PPC_GOT_DTPREL16_LO = 92, /* half16*	(sym+add)@got@dtprel@l */
	R_PPC_GOT_DTPREL16_HI = 93, /* half16*	(sym+add)@got@dtprel@h */
	R_PPC_GOT_DTPREL16_HA = 94, /* half16*	(sym+add)@got@dtprel@ha */
};

/* The remaining relocs are from the Embedded ELF ABI, and are not
   in the SVR4 ELF ABI.  */
enum {
	R_PPC_EMB_NADDR32    = 101,
	R_PPC_EMB_NADDR16    = 102,
	R_PPC_EMB_NADDR16_LO = 103,
	R_PPC_EMB_NADDR16_HI = 104,
	R_PPC_EMB_NADDR16_HA = 105,
	R_PPC_EMB_SDAI16     = 106,
	R_PPC_EMB_SDA2I16    = 107,
	R_PPC_EMB_SDA2REL    = 108,
	R_PPC_EMB_SDA21      = 109, /* 16 bit offset in SDA */
	R_PPC_EMB_MRKREF     = 110,
	R_PPC_EMB_RELSEC16   = 111,
	R_PPC_EMB_RELST_LO   = 112,
	R_PPC_EMB_RELST_HI   = 113,
	R_PPC_EMB_RELST_HA   = 114,
	R_PPC_EMB_BIT_FLD    = 115,
	R_PPC_EMB_RELSDA     = 116, /* 16 bit relative offset in SDA */
};

/* Diab tool relocations.  */
enum {
	R_PPC_DIAB_SDA21_LO  = 180, /* like EMB_SDA21, but lower 16 bit */
	R_PPC_DIAB_SDA21_HI  = 181, /* like EMB_SDA21, but high 16 bit */
	R_PPC_DIAB_SDA21_HA  = 182, /* like EMB_SDA21, adjusted high 16 */
	R_PPC_DIAB_RELSDA_LO = 183, /* like EMB_RELSDA, but lower 16 bit */
	R_PPC_DIAB_RELSDA_HI = 184, /* like EMB_RELSDA, but high 16 bit */
	R_PPC_DIAB_RELSDA_HA = 185, /* like EMB_RELSDA, adjusted high 16 */
};

/* GNU extension to support local ifunc.  */
enum {
	R_PPC_IRELATIVE = 248,
};

/* GNU relocs used in PIC code sequences.  */
enum {
	R_PPC_REL16    = 249, /* half16   (sym+add-.) */
	R_PPC_REL16_LO = 250, /* half16   (sym+add-.)@l */
	R_PPC_REL16_HI = 251, /* half16   (sym+add-.)@h */
	R_PPC_REL16_HA = 252, /* half16   (sym+add-.)@ha */
};

/* This is a phony reloc to handle any old fashioned TOC16 references
   that may still be in object files.  */
enum {
	R_PPC_TOC16 = 255,
};

/* PowerPC specific values for the Dyn d_tag field.  */
enum {
	DT_PPC_GOT = (DT_LOPROC + 0),
	DT_PPC_NUM = 1,
};

/* PowerPC64 relocations defined by the ABIs */
enum {
	R_PPC64_NONE            = R_PPC_NONE,
	R_PPC64_ADDR32          = R_PPC_ADDR32,    /* 32bit absolute address */
	R_PPC64_ADDR24          = R_PPC_ADDR24,    /* 26bit address, word aligned */
	R_PPC64_ADDR16          = R_PPC_ADDR16,    /* 16bit absolute address */
	R_PPC64_ADDR16_LO       = R_PPC_ADDR16_LO, /* lower 16bits of address */
	R_PPC64_ADDR16_HI       = R_PPC_ADDR16_HI, /* high 16bits of address. */
	R_PPC64_ADDR16_HA       = R_PPC_ADDR16_HA, /* adjusted high 16bits.  */
	R_PPC64_ADDR14          = R_PPC_ADDR14,    /* 16bit address, word aligned */
	R_PPC64_ADDR14_BRTAKEN  = R_PPC_ADDR14_BRTAKEN,
	R_PPC64_ADDR14_BRNTAKEN = R_PPC_ADDR14_BRNTAKEN,
	R_PPC64_REL24           = R_PPC_REL24, /* PC-rel. 26 bit, word aligned */
	R_PPC64_REL14           = R_PPC_REL14, /* PC relative 16 bit */
	R_PPC64_REL14_BRTAKEN   = R_PPC_REL14_BRTAKEN,
	R_PPC64_REL14_BRNTAKEN  = R_PPC_REL14_BRNTAKEN,
	R_PPC64_GOT16           = R_PPC_GOT16,
	R_PPC64_GOT16_LO        = R_PPC_GOT16_LO,
	R_PPC64_GOT16_HI        = R_PPC_GOT16_HI,
	R_PPC64_GOT16_HA        = R_PPC_GOT16_HA,
	R_PPC64_COPY            = R_PPC_COPY,
	R_PPC64_GLOB_DAT        = R_PPC_GLOB_DAT,
	R_PPC64_JMP_SLOT        = R_PPC_JMP_SLOT,
	R_PPC64_RELATIVE        = R_PPC_RELATIVE,
	R_PPC64_UADDR32         = R_PPC_UADDR32,
	R_PPC64_UADDR16         = R_PPC_UADDR16,
	R_PPC64_REL32           = R_PPC_REL32,
	R_PPC64_PLT32           = R_PPC_PLT32,
	R_PPC64_PLTREL32        = R_PPC_PLTREL32,
	R_PPC64_PLT16_LO        = R_PPC_PLT16_LO,
	R_PPC64_PLT16_HI        = R_PPC_PLT16_HI,
	R_PPC64_PLT16_HA        = R_PPC_PLT16_HA,
	R_PPC64_SECTOFF         = R_PPC_SECTOFF,
	R_PPC64_SECTOFF_LO      = R_PPC_SECTOFF_LO,
	R_PPC64_SECTOFF_HI      = R_PPC_SECTOFF_HI,
	R_PPC64_SECTOFF_HA      = R_PPC_SECTOFF_HA,
	R_PPC64_ADDR30          = 37, /* word30 (S + A - P) >> 2 */
	R_PPC64_ADDR64          = 38, /* doubleword64 S + A */
	R_PPC64_ADDR16_HIGHER   = 39, /* half16 #higher(S + A) */
	R_PPC64_ADDR16_HIGHERA  = 40, /* half16 #highera(S + A) */
	R_PPC64_ADDR16_HIGHEST  = 41, /* half16 #highest(S + A) */
	R_PPC64_ADDR16_HIGHESTA = 42, /* half16 #highesta(S + A) */
	R_PPC64_UADDR64         = 43, /* doubleword64 S + A */
	R_PPC64_REL64           = 44, /* doubleword64 S + A - P */
	R_PPC64_PLT64           = 45, /* doubleword64 L + A */
	R_PPC64_PLTREL64        = 46, /* doubleword64 L + A - P */
	R_PPC64_TOC16           = 47, /* half16* S + A - .TOC */
	R_PPC64_TOC16_LO        = 48, /* half16 #lo(S + A - .TOC.) */
	R_PPC64_TOC16_HI        = 49, /* half16 #hi(S + A - .TOC.) */
	R_PPC64_TOC16_HA        = 50, /* half16 #ha(S + A - .TOC.) */
	R_PPC64_TOC             = 51, /* doubleword64 .TOC */
	R_PPC64_PLTGOT16        = 52, /* half16* M + A */
	R_PPC64_PLTGOT16_LO     = 53, /* half16 #lo(M + A) */
	R_PPC64_PLTGOT16_HI     = 54, /* half16 #hi(M + A) */
	R_PPC64_PLTGOT16_HA     = 55, /* half16 #ha(M + A) */
	R_PPC64_ADDR16_DS       = 56, /* half16ds* (S + A) >> 2 */
	R_PPC64_ADDR16_LO_DS    = 57, /* half16ds  #lo(S + A) >> 2 */
	R_PPC64_GOT16_DS        = 58, /* half16ds* (G + A) >> 2 */
	R_PPC64_GOT16_LO_DS     = 59, /* half16ds  #lo(G + A) >> 2 */
	R_PPC64_PLT16_LO_DS     = 60, /* half16ds  #lo(L + A) >> 2 */
	R_PPC64_SECTOFF_DS      = 61, /* half16ds* (R + A) >> 2 */
	R_PPC64_SECTOFF_LO_DS   = 62, /* half16ds  #lo(R + A) >> 2 */
	R_PPC64_TOC16_DS        = 63, /* half16ds* (S + A - .TOC.) >> 2 */
	R_PPC64_TOC16_LO_DS     = 64, /* half16ds  #lo(S + A - .TOC.) >> 2 */
	R_PPC64_PLTGOT16_DS     = 65, /* half16ds* (M + A) >> 2 */
	R_PPC64_PLTGOT16_LO_DS  = 66, /* half16ds  #lo(M + A) >> 2 */
};

/* PowerPC64 relocations defined for the TLS access ABI.  */
enum {
	R_PPC64_TLS                = 67,  /* none	(sym+add)@tls */
	R_PPC64_DTPMOD64           = 68,  /* doubleword64 (sym+add)@dtpmod */
	R_PPC64_TPREL16            = 69,  /* half16*	(sym+add)@tprel */
	R_PPC64_TPREL16_LO         = 70,  /* half16	(sym+add)@tprel@l */
	R_PPC64_TPREL16_HI         = 71,  /* half16	(sym+add)@tprel@h */
	R_PPC64_TPREL16_HA         = 72,  /* half16	(sym+add)@tprel@ha */
	R_PPC64_TPREL64            = 73,  /* doubleword64 (sym+add)@tprel */
	R_PPC64_DTPREL16           = 74,  /* half16*	(sym+add)@dtprel */
	R_PPC64_DTPREL16_LO        = 75,  /* half16	(sym+add)@dtprel@l */
	R_PPC64_DTPREL16_HI        = 76,  /* half16	(sym+add)@dtprel@h */
	R_PPC64_DTPREL16_HA        = 77,  /* half16	(sym+add)@dtprel@ha */
	R_PPC64_DTPREL64           = 78,  /* doubleword64 (sym+add)@dtprel */
	R_PPC64_GOT_TLSGD16        = 79,  /* half16*	(sym+add)@got@tlsgd */
	R_PPC64_GOT_TLSGD16_LO     = 80,  /* half16	(sym+add)@got@tlsgd@l */
	R_PPC64_GOT_TLSGD16_HI     = 81,  /* half16	(sym+add)@got@tlsgd@h */
	R_PPC64_GOT_TLSGD16_HA     = 82,  /* half16	(sym+add)@got@tlsgd@ha */
	R_PPC64_GOT_TLSLD16        = 83,  /* half16*	(sym+add)@got@tlsld */
	R_PPC64_GOT_TLSLD16_LO     = 84,  /* half16	(sym+add)@got@tlsld@l */
	R_PPC64_GOT_TLSLD16_HI     = 85,  /* half16	(sym+add)@got@tlsld@h */
	R_PPC64_GOT_TLSLD16_HA     = 86,  /* half16	(sym+add)@got@tlsld@ha */
	R_PPC64_GOT_TPREL16_DS     = 87,  /* half16ds*	(sym+add)@got@tprel */
	R_PPC64_GOT_TPREL16_LO_DS  = 88,  /* half16ds (sym+add)@got@tprel@l */
	R_PPC64_GOT_TPREL16_HI     = 89,  /* half16	(sym+add)@got@tprel@h */
	R_PPC64_GOT_TPREL16_HA     = 90,  /* half16	(sym+add)@got@tprel@ha */
	R_PPC64_GOT_DTPREL16_DS    = 91,  /* half16ds*	(sym+add)@got@dtprel */
	R_PPC64_GOT_DTPREL16_LO_DS = 92,  /* half16ds (sym+add)@got@dtprel@l */
	R_PPC64_GOT_DTPREL16_HI    = 93,  /* half16	(sym+add)@got@dtprel@h */
	R_PPC64_GOT_DTPREL16_HA    = 94,  /* half16	(sym+add)@got@dtprel@ha */
	R_PPC64_TPREL16_DS         = 95,  /* half16ds*	(sym+add)@tprel */
	R_PPC64_TPREL16_LO_DS      = 96,  /* half16ds	(sym+add)@tprel@l */
	R_PPC64_TPREL16_HIGHER     = 97,  /* half16	(sym+add)@tprel@higher */
	R_PPC64_TPREL16_HIGHERA    = 98,  /* half16	(sym+add)@tprel@highera */
	R_PPC64_TPREL16_HIGHEST    = 99,  /* half16	(sym+add)@tprel@highest */
	R_PPC64_TPREL16_HIGHESTA   = 100, /* half16	(sym+add)@tprel@highesta */
	R_PPC64_DTPREL16_DS        = 101, /* half16ds* (sym+add)@dtprel */
	R_PPC64_DTPREL16_LO_DS     = 102, /* half16ds	(sym+add)@dtprel@l */
	R_PPC64_DTPREL16_HIGHER    = 103, /* half16	(sym+add)@dtprel@higher */
	R_PPC64_DTPREL16_HIGHERA   = 104, /* half16	(sym+add)@dtprel@highera */
	R_PPC64_DTPREL16_HIGHEST   = 105, /* half16	(sym+add)@dtprel@highest */
	R_PPC64_DTPREL16_HIGHESTA  = 106, /* half16	(sym+add)@dtprel@highesta */
};

/* GNU extension to support local ifunc.  */
enum {
	R_PPC64_JMP_IREL  = 247,
	R_PPC64_IRELATIVE = 248,
	R_PPC64_REL16     = 249, /* half16   (sym+add-.) */
	R_PPC64_REL16_LO  = 250, /* half16   (sym+add-.)@l */
	R_PPC64_REL16_HI  = 251, /* half16   (sym+add-.)@h */
	R_PPC64_REL16_HA  = 252, /* half16   (sym+add-.)@ha */
};

/* PowerPC64 specific values for the Dyn d_tag field.  */
enum {
	DT_PPC64_GLINK = (DT_LOPROC + 0),
	DT_PPC64_OPD   = (DT_LOPROC + 1),
	DT_PPC64_OPDSZ = (DT_LOPROC + 2),
	DT_PPC64_NUM   = 3,
};

/* ARM specific declarations */

/* Processor specific flags for the ELF header e_flags field.  */
enum {
	EF_ARM_RELEXEC        = 0x01,
	EF_ARM_HASENTRY       = 0x02,
	EF_ARM_INTERWORK      = 0x04,
	EF_ARM_APCS_26        = 0x08,
	EF_ARM_APCS_FLOAT     = 0x10,
	EF_ARM_PIC            = 0x20,
	EF_ARM_ALIGN8         = 0x40, /* 8-bit structure alignment is in use */
	EF_ARM_NEW_ABI        = 0x80,
	EF_ARM_OLD_ABI        = 0x100,
	EF_ARM_SOFT_FLOAT     = 0x200,
	EF_ARM_VFP_FLOAT      = 0x400,
	EF_ARM_MAVERICK_FLOAT = 0x800,
};

/* Other constants defined in the ARM ELF spec. version B-01.  */
/* NB. These conflict with values defined above.  */
enum {
	EF_ARM_SYMSARESORTED    = 0x04,
	EF_ARM_DYNSYMSUSESEGIDX = 0x08,
	EF_ARM_MAPSYMSFIRST     = 0x10,
	EF_ARM_EABIMASK         = 0XFF000000
};

/* Constants defined in AAELF.  */
enum {
	EF_ARM_BE8 = 0x00800000,
	EF_ARM_LE8 = 0x00400000,
};

template <class T>
constexpr T EF_ARM_EABI_VERSION(T flags) {
	return flags & EF_ARM_EABIMASK;
}

enum {
	EF_ARM_EABI_UNKNOWN = 0x00000000,
	EF_ARM_EABI_VER1    = 0x01000000,
	EF_ARM_EABI_VER2    = 0x02000000,
	EF_ARM_EABI_VER3    = 0x03000000,
	EF_ARM_EABI_VER4    = 0x04000000,
	EF_ARM_EABI_VER5    = 0x05000000,
};

/* Additional symbol types for Thumb.  */
enum {
	STT_ARM_TFUNC = STT_LOPROC, /* A Thumb function.  */
	STT_ARM_16BIT = STT_HIPROC, /* A Thumb label.  */
};

/* ARM-specific values for sh_flags */
enum {
	SHF_ARM_ENTRYSECT = 0x10000000, /* Section contains an entry point */
	SHF_ARM_COMDEF    = 0x80000000, /* Section may be multiply defined	in the input to a link step.  */
};

/* ARM-specific program header flags */
enum {
	PF_ARM_SB  = 0x10000000, /* Segment contains the location addressed by the static base. */
	PF_ARM_PI  = 0x20000000, /* Position-independent segment.  */
	PF_ARM_ABS = 0x40000000, /* Absolute segment.  */
};

/* Processor specific values for the Phdr p_type field.  */
enum {
	PT_ARM_EXIDX = (PT_LOPROC + 1), /* ARM unwind segment.  */
};

/* Processor specific values for the Shdr sh_type field.  */
enum {
	SHT_ARM_EXIDX      = (SHT_LOPROC + 1), /* ARM unwind section.  */
	SHT_ARM_PREEMPTMAP = (SHT_LOPROC + 2), /* Preemption details.  */
	SHT_ARM_ATTRIBUTES = (SHT_LOPROC + 3), /* ARM attributes section.  */
};

/* ARM relocs.  */
enum {
	R_ARM_NONE            = 0, /* No reloc */
	R_ARM_PC24            = 1, /* PC relative 26 bit branch */
	R_ARM_ABS32           = 2, /* Direct 32 bit  */
	R_ARM_REL32           = 3, /* PC relative 32 bit */
	R_ARM_PC13            = 4,
	R_ARM_ABS16           = 5, /* Direct 16 bit */
	R_ARM_ABS12           = 6, /* Direct 12 bit */
	R_ARM_THM_ABS5        = 7,
	R_ARM_ABS8            = 8, /* Direct 8 bit */
	R_ARM_SBREL32         = 9,
	R_ARM_THM_PC22        = 10,
	R_ARM_THM_PC8         = 11,
	R_ARM_AMP_VCALL9      = 12,
	R_ARM_SWI24           = 13, /* Obsolete static relocation.  */
	R_ARM_TLS_DESC        = 13, /* Dynamic relocation.  */
	R_ARM_THM_SWI8        = 14,
	R_ARM_XPC25           = 15,
	R_ARM_THM_XPC22       = 16,
	R_ARM_TLS_DTPMOD32    = 17, /* ID of module containing symbol */
	R_ARM_TLS_DTPOFF32    = 18, /* Offset in TLS block */
	R_ARM_TLS_TPOFF32     = 19, /* Offset in static TLS block */
	R_ARM_COPY            = 20, /* Copy symbol at runtime */
	R_ARM_GLOB_DAT        = 21, /* Create GOT entry */
	R_ARM_JUMP_SLOT       = 22, /* Create PLT entry */
	R_ARM_RELATIVE        = 23, /* Adjust by program base */
	R_ARM_GOTOFF          = 24, /* 32 bit offset to GOT */
	R_ARM_GOTPC           = 25, /* 32 bit PC relative offset to GOT */
	R_ARM_GOT32           = 26, /* 32 bit GOT entry */
	R_ARM_PLT32           = 27, /* 32 bit PLT address */
	R_ARM_ALU_PCREL_7_0   = 32,
	R_ARM_ALU_PCREL_15_8  = 33,
	R_ARM_ALU_PCREL_23_15 = 34,
	R_ARM_LDR_SBREL_11_0  = 35,
	R_ARM_ALU_SBREL_19_12 = 36,
	R_ARM_ALU_SBREL_27_20 = 37,
	R_ARM_TLS_GOTDESC     = 90,
	R_ARM_TLS_CALL        = 91,
	R_ARM_TLS_DESCSEQ     = 92,
	R_ARM_THM_TLS_CALL    = 93,
	R_ARM_GNU_VTENTRY     = 100,
	R_ARM_GNU_VTINHERIT   = 101,
	R_ARM_THM_PC11        = 102, /* thumb unconditional branch */
	R_ARM_THM_PC9         = 103, /* thumb conditional branch */
	R_ARM_TLS_GD32        = 104, /* PC-rel 32 bit for global dynamic thread local data */
	R_ARM_TLS_LDM32       = 105, /* PC-rel 32 bit for local dynamic thread local data */
	R_ARM_TLS_LDO32       = 106, /* 32 bit offset relative to TLS block */
	R_ARM_TLS_IE32        = 107, /* PC-rel 32 bit for GOT entry of static TLS block offset */
	R_ARM_TLS_LE32        = 108, /* 32 bit offset relative to static TLS block */
	R_ARM_THM_TLS_DESCSEQ = 129,
	R_ARM_IRELATIVE       = 160,
	R_ARM_RXPC25          = 249,
	R_ARM_RSBREL32        = 250,
	R_ARM_THM_RPC22       = 251,
	R_ARM_RREL32          = 252,
	R_ARM_RABS22          = 253,
	R_ARM_RPC24           = 254,
	R_ARM_RBASE           = 255,

	/* Keep this the last entry.  */
	R_ARM_NUM = 256,
};

/* IA-64 specific declarations.  */

/* Processor specific flags for the Ehdr e_flags field.  */
enum {
	EF_IA_64_MASKOS = 0x0000000f, /* os-specific flags */
	EF_IA_64_ABI64  = 0x00000010, /* 64-bit ABI */
	EF_IA_64_ARCH   = 0xff000000, /* arch. version mask */
};

/* Processor specific values for the Phdr p_type field.  */
enum {
	PT_IA_64_ARCHEXT     = (PT_LOPROC + 0), /* arch extension bits */
	PT_IA_64_UNWIND      = (PT_LOPROC + 1), /* ia64 unwind bits */
	PT_IA_64_HP_OPT_ANOT = (PT_LOOS + 0x12),
	PT_IA_64_HP_HSL_ANOT = (PT_LOOS + 0x13),
	PT_IA_64_HP_STACK    = (PT_LOOS + 0x14),
};

/* Processor specific flags for the Phdr p_flags field.  */
enum {
	PF_IA_64_NORECOV = 0x80000000, /* spec insns w/o recovery */
};

/* Processor specific values for the Shdr sh_type field.  */
enum {
	SHT_IA_64_EXT    = (SHT_LOPROC + 0), /* extension bits */
	SHT_IA_64_UNWIND = (SHT_LOPROC + 1), /* unwind bits */
};

/* Processor specific flags for the Shdr sh_flags field.  */
enum {
	SHF_IA_64_SHORT   = 0x10000000, /* section near gp */
	SHF_IA_64_NORECOV = 0x20000000, /* spec insns w/o recovery */
};

/* Processor specific values for the Dyn d_tag field.  */
enum {
	DT_IA_64_PLT_RESERVE = (DT_LOPROC + 0),
	DT_IA_64_NUM         = 1,
};

/* IA-64 relocations.  */
enum {
	R_IA64_NONE            = 0x00, /* none */
	R_IA64_IMM14           = 0x21, /* symbol + addend, add imm14 */
	R_IA64_IMM22           = 0x22, /* symbol + addend, add imm22 */
	R_IA64_IMM64           = 0x23, /* symbol + addend, mov imm64 */
	R_IA64_DIR32MSB        = 0x24, /* symbol + addend, data4 MSB */
	R_IA64_DIR32LSB        = 0x25, /* symbol + addend, data4 LSB */
	R_IA64_DIR64MSB        = 0x26, /* symbol + addend, data8 MSB */
	R_IA64_DIR64LSB        = 0x27, /* symbol + addend, data8 LSB */
	R_IA64_GPREL22         = 0x2a, /* @gprel(sym + add), add imm22 */
	R_IA64_GPREL64I        = 0x2b, /* @gprel(sym + add), mov imm64 */
	R_IA64_GPREL32MSB      = 0x2c, /* @gprel(sym + add), data4 MSB */
	R_IA64_GPREL32LSB      = 0x2d, /* @gprel(sym + add), data4 LSB */
	R_IA64_GPREL64MSB      = 0x2e, /* @gprel(sym + add), data8 MSB */
	R_IA64_GPREL64LSB      = 0x2f, /* @gprel(sym + add), data8 LSB */
	R_IA64_LTOFF22         = 0x32, /* @ltoff(sym + add), add imm22 */
	R_IA64_LTOFF64I        = 0x33, /* @ltoff(sym + add), mov imm64 */
	R_IA64_PLTOFF22        = 0x3a, /* @pltoff(sym + add), add imm22 */
	R_IA64_PLTOFF64I       = 0x3b, /* @pltoff(sym + add), mov imm64 */
	R_IA64_PLTOFF64MSB     = 0x3e, /* @pltoff(sym + add), data8 MSB */
	R_IA64_PLTOFF64LSB     = 0x3f, /* @pltoff(sym + add), data8 LSB */
	R_IA64_FPTR64I         = 0x43, /* @fptr(sym + add), mov imm64 */
	R_IA64_FPTR32MSB       = 0x44, /* @fptr(sym + add), data4 MSB */
	R_IA64_FPTR32LSB       = 0x45, /* @fptr(sym + add), data4 LSB */
	R_IA64_FPTR64MSB       = 0x46, /* @fptr(sym + add), data8 MSB */
	R_IA64_FPTR64LSB       = 0x47, /* @fptr(sym + add), data8 LSB */
	R_IA64_PCREL60B        = 0x48, /* @pcrel(sym + add), brl */
	R_IA64_PCREL21B        = 0x49, /* @pcrel(sym + add), ptb, call */
	R_IA64_PCREL21M        = 0x4a, /* @pcrel(sym + add), chk.s */
	R_IA64_PCREL21F        = 0x4b, /* @pcrel(sym + add), fchkf */
	R_IA64_PCREL32MSB      = 0x4c, /* @pcrel(sym + add), data4 MSB */
	R_IA64_PCREL32LSB      = 0x4d, /* @pcrel(sym + add), data4 LSB */
	R_IA64_PCREL64MSB      = 0x4e, /* @pcrel(sym + add), data8 MSB */
	R_IA64_PCREL64LSB      = 0x4f, /* @pcrel(sym + add), data8 LSB */
	R_IA64_LTOFF_FPTR22    = 0x52, /* @ltoff(@fptr(s+a)), imm22 */
	R_IA64_LTOFF_FPTR64I   = 0x53, /* @ltoff(@fptr(s+a)), imm64 */
	R_IA64_LTOFF_FPTR32MSB = 0x54, /* @ltoff(@fptr(s+a)), data4 MSB */
	R_IA64_LTOFF_FPTR32LSB = 0x55, /* @ltoff(@fptr(s+a)), data4 LSB */
	R_IA64_LTOFF_FPTR64MSB = 0x56, /* @ltoff(@fptr(s+a)), data8 MSB */
	R_IA64_LTOFF_FPTR64LSB = 0x57, /* @ltoff(@fptr(s+a)), data8 LSB */
	R_IA64_SEGREL32MSB     = 0x5c, /* @segrel(sym + add), data4 MSB */
	R_IA64_SEGREL32LSB     = 0x5d, /* @segrel(sym + add), data4 LSB */
	R_IA64_SEGREL64MSB     = 0x5e, /* @segrel(sym + add), data8 MSB */
	R_IA64_SEGREL64LSB     = 0x5f, /* @segrel(sym + add), data8 LSB */
	R_IA64_SECREL32MSB     = 0x64, /* @secrel(sym + add), data4 MSB */
	R_IA64_SECREL32LSB     = 0x65, /* @secrel(sym + add), data4 LSB */
	R_IA64_SECREL64MSB     = 0x66, /* @secrel(sym + add), data8 MSB */
	R_IA64_SECREL64LSB     = 0x67, /* @secrel(sym + add), data8 LSB */
	R_IA64_REL32MSB        = 0x6c, /* data 4 + REL */
	R_IA64_REL32LSB        = 0x6d, /* data 4 + REL */
	R_IA64_REL64MSB        = 0x6e, /* data 8 + REL */
	R_IA64_REL64LSB        = 0x6f, /* data 8 + REL */
	R_IA64_LTV32MSB        = 0x74, /* symbol + addend, data4 MSB */
	R_IA64_LTV32LSB        = 0x75, /* symbol + addend, data4 LSB */
	R_IA64_LTV64MSB        = 0x76, /* symbol + addend, data8 MSB */
	R_IA64_LTV64LSB        = 0x77, /* symbol + addend, data8 LSB */
	R_IA64_PCREL21BI       = 0x79, /* @pcrel(sym + add), 21bit inst */
	R_IA64_PCREL22         = 0x7a, /* @pcrel(sym + add), 22bit inst */
	R_IA64_PCREL64I        = 0x7b, /* @pcrel(sym + add), 64bit inst */
	R_IA64_IPLTMSB         = 0x80, /* dynamic reloc, imported PLT, MSB */
	R_IA64_IPLTLSB         = 0x81, /* dynamic reloc, imported PLT, LSB */
	R_IA64_COPY            = 0x84, /* copy relocation */
	R_IA64_SUB             = 0x85, /* Addend and symbol difference */
	R_IA64_LTOFF22X        = 0x86, /* LTOFF22, relaxable.  */
	R_IA64_LDXMOV          = 0x87, /* Use of LTOFF22X.  */
	R_IA64_TPREL14         = 0x91, /* @tprel(sym + add), imm14 */
	R_IA64_TPREL22         = 0x92, /* @tprel(sym + add), imm22 */
	R_IA64_TPREL64I        = 0x93, /* @tprel(sym + add), imm64 */
	R_IA64_TPREL64MSB      = 0x96, /* @tprel(sym + add), data8 MSB */
	R_IA64_TPREL64LSB      = 0x97, /* @tprel(sym + add), data8 LSB */
	R_IA64_LTOFF_TPREL22   = 0x9a, /* @ltoff(@tprel(s+a)), imm2 */
	R_IA64_DTPMOD64MSB     = 0xa6, /* @dtpmod(sym + add), data8 MSB */
	R_IA64_DTPMOD64LSB     = 0xa7, /* @dtpmod(sym + add), data8 LSB */
	R_IA64_LTOFF_DTPMOD22  = 0xaa, /* @ltoff(@dtpmod(sym + add)), imm22 */
	R_IA64_DTPREL14        = 0xb1, /* @dtprel(sym + add), imm14 */
	R_IA64_DTPREL22        = 0xb2, /* @dtprel(sym + add), imm22 */
	R_IA64_DTPREL64I       = 0xb3, /* @dtprel(sym + add), imm64 */
	R_IA64_DTPREL32MSB     = 0xb4, /* @dtprel(sym + add), data4 MSB */
	R_IA64_DTPREL32LSB     = 0xb5, /* @dtprel(sym + add), data4 LSB */
	R_IA64_DTPREL64MSB     = 0xb6, /* @dtprel(sym + add), data8 MSB */
	R_IA64_DTPREL64LSB     = 0xb7, /* @dtprel(sym + add), data8 LSB */
	R_IA64_LTOFF_DTPREL22  = 0xba, /* @ltoff(@dtprel(s+a)), imm22 */
};

/* SH specific declarations */

/* Processor specific flags for the ELF header e_flags field.  */
enum {
	EF_SH_MACH_MASK    = 0x1f,
	EF_SH_UNKNOWN      = 0x0,
	EF_SH1             = 0x1,
	EF_SH2             = 0x2,
	EF_SH3             = 0x3,
	EF_SH_DSP          = 0x4,
	EF_SH3_DSP         = 0x5,
	EF_SH4AL_DSP       = 0x6,
	EF_SH3E            = 0x8,
	EF_SH4             = 0x9,
	EF_SH2E            = 0xb,
	EF_SH4A            = 0xc,
	EF_SH2A            = 0xd,
	EF_SH4_NOFPU       = 0x10,
	EF_SH4A_NOFPU      = 0x11,
	EF_SH4_NOMMU_NOFPU = 0x12,
	EF_SH2A_NOFPU      = 0x13,
	EF_SH3_NOMMU       = 0x14,
	EF_SH2A_SH4_NOFPU  = 0x15,
	EF_SH2A_SH3_NOFPU  = 0x16,
	EF_SH2A_SH4        = 0x17,
	EF_SH2A_SH3E       = 0x18,
};

/* SH relocs.  */
enum {
	R_SH_NONE          = 0,
	R_SH_DIR32         = 1,
	R_SH_REL32         = 2,
	R_SH_DIR8WPN       = 3,
	R_SH_IND12W        = 4,
	R_SH_DIR8WPL       = 5,
	R_SH_DIR8WPZ       = 6,
	R_SH_DIR8BP        = 7,
	R_SH_DIR8W         = 8,
	R_SH_DIR8L         = 9,
	R_SH_SWITCH16      = 25,
	R_SH_SWITCH32      = 26,
	R_SH_USES          = 27,
	R_SH_COUNT         = 28,
	R_SH_ALIGN         = 29,
	R_SH_CODE          = 30,
	R_SH_DATA          = 31,
	R_SH_LABEL         = 32,
	R_SH_SWITCH8       = 33,
	R_SH_GNU_VTINHERIT = 34,
	R_SH_GNU_VTENTRY   = 35,
	R_SH_TLS_GD_32     = 144,
	R_SH_TLS_LD_32     = 145,
	R_SH_TLS_LDO_32    = 146,
	R_SH_TLS_IE_32     = 147,
	R_SH_TLS_LE_32     = 148,
	R_SH_TLS_DTPMOD32  = 149,
	R_SH_TLS_DTPOFF32  = 150,
	R_SH_TLS_TPOFF32   = 151,
	R_SH_GOT32         = 160,
	R_SH_PLT32         = 161,
	R_SH_COPY          = 162,
	R_SH_GLOB_DAT      = 163,
	R_SH_JMP_SLOT      = 164,
	R_SH_RELATIVE      = 165,
	R_SH_GOTOFF        = 166,
	R_SH_GOTPC         = 167,

	/* Keep this the last entry.  */
	R_SH_NUM = 256,
};

/* S/390 specific definitions.  */

/* Valid values for the e_flags field.  */
enum {
	EF_S390_HIGH_GPRS = 0x00000001, /* High GPRs kernel facility needed.  */
};

/* Additional s390 relocs */
enum {
	R_390_NONE        = 0,  /* No reloc.  */
	R_390_8           = 1,  /* Direct 8 bit.  */
	R_390_12          = 2,  /* Direct 12 bit.  */
	R_390_16          = 3,  /* Direct 16 bit.  */
	R_390_32          = 4,  /* Direct 32 bit.  */
	R_390_PC32        = 5,  /* PC relative 32 bit.	*/
	R_390_GOT12       = 6,  /* 12 bit GOT offset.  */
	R_390_GOT32       = 7,  /* 32 bit GOT offset.  */
	R_390_PLT32       = 8,  /* 32 bit PC relative PLT address.  */
	R_390_COPY        = 9,  /* Copy symbol at runtime.  */
	R_390_GLOB_DAT    = 10, /* Create GOT entry.  */
	R_390_JMP_SLOT    = 11, /* Create PLT entry.  */
	R_390_RELATIVE    = 12, /* Adjust by program base.  */
	R_390_GOTOFF32    = 13, /* 32 bit offset to GOT.	 */
	R_390_GOTPC       = 14, /* 32 bit PC relative offset to GOT.  */
	R_390_GOT16       = 15, /* 16 bit GOT offset.  */
	R_390_PC16        = 16, /* PC relative 16 bit.	*/
	R_390_PC16DBL     = 17, /* PC relative 16 bit shifted by 1.  */
	R_390_PLT16DBL    = 18, /* 16 bit PC rel. PLT shifted by 1.  */
	R_390_PC32DBL     = 19, /* PC relative 32 bit shifted by 1.  */
	R_390_PLT32DBL    = 20, /* 32 bit PC rel. PLT shifted by 1.  */
	R_390_GOTPCDBL    = 21, /* 32 bit PC rel. GOT shifted by 1.  */
	R_390_64          = 22, /* Direct 64 bit.  */
	R_390_PC64        = 23, /* PC relative 64 bit.	*/
	R_390_GOT64       = 24, /* 64 bit GOT offset.  */
	R_390_PLT64       = 25, /* 64 bit PC relative PLT address.  */
	R_390_GOTENT      = 26, /* 32 bit PC rel. to GOT entry >> 1. */
	R_390_GOTOFF16    = 27, /* 16 bit offset to GOT. */
	R_390_GOTOFF64    = 28, /* 64 bit offset to GOT. */
	R_390_GOTPLT12    = 29, /* 12 bit offset to jump slot.	*/
	R_390_GOTPLT16    = 30, /* 16 bit offset to jump slot.	*/
	R_390_GOTPLT32    = 31, /* 32 bit offset to jump slot.	*/
	R_390_GOTPLT64    = 32, /* 64 bit offset to jump slot.	*/
	R_390_GOTPLTENT   = 33, /* 32 bit rel. offset to jump slot.  */
	R_390_PLTOFF16    = 34, /* 16 bit offset from GOT to PLT. */
	R_390_PLTOFF32    = 35, /* 32 bit offset from GOT to PLT. */
	R_390_PLTOFF64    = 36, /* 16 bit offset from GOT to PLT. */
	R_390_TLS_LOAD    = 37, /* Tag for load insn in TLS code.  */
	R_390_TLS_GDCALL  = 38, /* Tag for function call in general dynamic TLS code. */
	R_390_TLS_LDCALL  = 39, /* Tag for function call in local dynamic TLS code. */
	R_390_TLS_GD32    = 40, /* Direct 32 bit for general dynamic thread local data.  */
	R_390_TLS_GD64    = 41, /* Direct 64 bit for general dynamic thread local data.  */
	R_390_TLS_GOTIE12 = 42, /* 12 bit GOT offset for static TLS block offset.  */
	R_390_TLS_GOTIE32 = 43, /* 32 bit GOT offset for static TLS block offset.  */
	R_390_TLS_GOTIE64 = 44, /* 64 bit GOT offset for static TLS block offset. */
	R_390_TLS_LDM32   = 45, /* Direct 32 bit for local dynamic   thread local data in LE code.  */
	R_390_TLS_LDM64   = 46, /* Direct 64 bit for local dynamic   thread local data in LE code.  */
	R_390_TLS_IE32    = 47, /* 32 bit address of GOT entry for	negated static TLS block offset.  */
	R_390_TLS_IE64    = 48, /* 64 bit address of GOT entry for	negated static TLS block offset.  */
	R_390_TLS_IEENT   = 49, /* 32 bit rel. offset to GOT entry for   negated static TLS block offset.  */
	R_390_TLS_LE32    = 50, /* 32 bit negated offset relative to static TLS block.  */
	R_390_TLS_LE64    = 51, /* 64 bit negated offset relative to static TLS block.  */
	R_390_TLS_LDO32   = 52, /* 32 bit offset relative to TLS block.  */
	R_390_TLS_LDO64   = 53, /* 64 bit offset relative to TLS block.  */
	R_390_TLS_DTPMOD  = 54, /* ID of module containing symbol.  */
	R_390_TLS_DTPOFF  = 55, /* Offset in TLS block.	 */
	R_390_TLS_TPOFF   = 56, /* Negated offset in static TLS block.  */
	R_390_20          = 57, /* Direct 20 bit.  */
	R_390_GOT20       = 58, /* 20 bit GOT offset.  */
	R_390_GOTPLT20    = 59, /* 20 bit offset to jump slot.  */
	R_390_TLS_GOTIE20 = 60, /* 20 bit GOT offset for static TLS block offset.  */

	/* Keep this the last entry.  */
	R_390_NUM = 61,
};

/* CRIS relocations.  */
enum {
	R_CRIS_NONE          = 0,
	R_CRIS_8             = 1,
	R_CRIS_16            = 2,
	R_CRIS_32            = 3,
	R_CRIS_8_PCREL       = 4,
	R_CRIS_16_PCREL      = 5,
	R_CRIS_32_PCREL      = 6,
	R_CRIS_GNU_VTINHERIT = 7,
	R_CRIS_GNU_VTENTRY   = 8,
	R_CRIS_COPY          = 9,
	R_CRIS_GLOB_DAT      = 10,
	R_CRIS_JUMP_SLOT     = 11,
	R_CRIS_RELATIVE      = 12,
	R_CRIS_16_GOT        = 13,
	R_CRIS_32_GOT        = 14,
	R_CRIS_16_GOTPLT     = 15,
	R_CRIS_32_GOTPLT     = 16,
	R_CRIS_32_GOTREL     = 17,
	R_CRIS_32_PLT_GOTREL = 18,
	R_CRIS_32_PLT_PCREL  = 19,

	R_CRIS_NUM = 20,
};

/* AMD x86-64 relocations.  */
enum {
	R_X86_64_NONE            = 0,  /* No reloc */
	R_X86_64_64              = 1,  /* Direct 64 bit  */
	R_X86_64_PC32            = 2,  /* PC relative 32 bit signed */
	R_X86_64_GOT32           = 3,  /* 32 bit GOT entry */
	R_X86_64_PLT32           = 4,  /* 32 bit PLT address */
	R_X86_64_COPY            = 5,  /* Copy symbol at runtime */
	R_X86_64_GLOB_DAT        = 6,  /* Create GOT entry */
	R_X86_64_JUMP_SLOT       = 7,  /* Create PLT entry */
	R_X86_64_RELATIVE        = 8,  /* Adjust by program base */
	R_X86_64_GOTPCREL        = 9,  /* 32 bit signed PC relative  offset to GOT */
	R_X86_64_32              = 10, /* Direct 32 bit zero extended */
	R_X86_64_32S             = 11, /* Direct 32 bit sign extended */
	R_X86_64_16              = 12, /* Direct 16 bit zero extended */
	R_X86_64_PC16            = 13, /* 16 bit sign extended pc relative */
	R_X86_64_8               = 14, /* Direct 8 bit sign extended  */
	R_X86_64_PC8             = 15, /* 8 bit sign extended pc relative */
	R_X86_64_DTPMOD64        = 16, /* ID of module containing symbol */
	R_X86_64_DTPOFF64        = 17, /* Offset in module's TLS block */
	R_X86_64_TPOFF64         = 18, /* Offset in initial TLS block */
	R_X86_64_TLSGD           = 19, /* 32 bit signed PC relative offset to two GOT entries for GD symbol */
	R_X86_64_TLSLD           = 20, /* 32 bit signed PC relative offset to two GOT entries for LD symbol */
	R_X86_64_DTPOFF32        = 21, /* Offset in TLS block */
	R_X86_64_GOTTPOFF        = 22, /* 32 bit signed PC relative offset GOT entry for IE symbol */
	R_X86_64_TPOFF32         = 23, /* Offset in initial TLS block */
	R_X86_64_PC64            = 24, /* PC relative 64 bit */
	R_X86_64_GOTOFF64        = 25, /* 64 bit offset to GOT */
	R_X86_64_GOTPC32         = 26, /* 32 bit signed pc relative offset to GOT */
	R_X86_64_GOT64           = 27, /* 64-bit GOT entry offset */
	R_X86_64_GOTPCREL64      = 28, /* 64-bit PC relative offset to GOT entry */
	R_X86_64_GOTPC64         = 29, /* 64-bit PC relative offset to GOT */
	R_X86_64_GOTPLT64        = 30, /* like GOT64, says PLT entry needed */
	R_X86_64_PLTOFF64        = 31, /* 64-bit GOT relative offset to PLT entry */
	R_X86_64_SIZE32          = 32, /* Size of symbol plus 32-bit addend */
	R_X86_64_SIZE64          = 33, /* Size of symbol plus 64-bit addend */
	R_X86_64_GOTPC32_TLSDESC = 34, /* GOT offset for TLS descriptor.  */
	R_X86_64_TLSDESC_CALL    = 35, /* Marker for call through TLS descriptor.  */
	R_X86_64_TLSDESC         = 36, /* TLS descriptor.  */
	R_X86_64_IRELATIVE       = 37, /* Adjust indirectly by program base */

	R_X86_64_NUM = 38,
};

/* AM33 relocations.  */
enum {
	R_MN10300_NONE          = 0,  /* No reloc.  */
	R_MN10300_32            = 1,  /* Direct 32 bit.  */
	R_MN10300_16            = 2,  /* Direct 16 bit.  */
	R_MN10300_8             = 3,  /* Direct 8 bit.  */
	R_MN10300_PCREL32       = 4,  /* PC-relative 32-bit.  */
	R_MN10300_PCREL16       = 5,  /* PC-relative 16-bit signed.  */
	R_MN10300_PCREL8        = 6,  /* PC-relative 8-bit signed.  */
	R_MN10300_GNU_VTINHERIT = 7,  /* Ancient C++ vtable garbage... */
	R_MN10300_GNU_VTENTRY   = 8,  /* ... collection annotation.  */
	R_MN10300_24            = 9,  /* Direct 24 bit.  */
	R_MN10300_GOTPC32       = 10, /* 32-bit PCrel offset to GOT.  */
	R_MN10300_GOTPC16       = 11, /* 16-bit PCrel offset to GOT.  */
	R_MN10300_GOTOFF32      = 12, /* 32-bit offset from GOT.  */
	R_MN10300_GOTOFF24      = 13, /* 24-bit offset from GOT.  */
	R_MN10300_GOTOFF16      = 14, /* 16-bit offset from GOT.  */
	R_MN10300_PLT32         = 15, /* 32-bit PCrel to PLT entry.  */
	R_MN10300_PLT16         = 16, /* 16-bit PCrel to PLT entry.  */
	R_MN10300_GOT32         = 17, /* 32-bit offset to GOT entry.  */
	R_MN10300_GOT24         = 18, /* 24-bit offset to GOT entry.  */
	R_MN10300_GOT16         = 19, /* 16-bit offset to GOT entry.  */
	R_MN10300_COPY          = 20, /* Copy symbol at runtime.  */
	R_MN10300_GLOB_DAT      = 21, /* Create GOT entry.  */
	R_MN10300_JMP_SLOT      = 22, /* Create PLT entry.  */
	R_MN10300_RELATIVE      = 23, /* Adjust by program base.  */

	R_MN10300_NUM = 24,
};

/* M32R relocs.  */
enum {
	R_M32R_NONE          = 0,  /* No reloc. */
	R_M32R_16            = 1,  /* Direct 16 bit. */
	R_M32R_32            = 2,  /* Direct 32 bit. */
	R_M32R_24            = 3,  /* Direct 24 bit. */
	R_M32R_10_PCREL      = 4,  /* PC relative 10 bit shifted. */
	R_M32R_18_PCREL      = 5,  /* PC relative 18 bit shifted. */
	R_M32R_26_PCREL      = 6,  /* PC relative 26 bit shifted. */
	R_M32R_HI16_ULO      = 7,  /* High 16 bit with unsigned low. */
	R_M32R_HI16_SLO      = 8,  /* High 16 bit with signed low. */
	R_M32R_LO16          = 9,  /* Low 16 bit. */
	R_M32R_SDA16         = 10, /* 16 bit offset in SDA. */
	R_M32R_GNU_VTINHERIT = 11,
	R_M32R_GNU_VTENTRY   = 12,
};

/* M32R relocs use SHT_RELA.  */
enum {
	R_M32R_16_RELA            = 33, /* Direct 16 bit. */
	R_M32R_32_RELA            = 34, /* Direct 32 bit. */
	R_M32R_24_RELA            = 35, /* Direct 24 bit. */
	R_M32R_10_PCREL_RELA      = 36, /* PC relative 10 bit shifted. */
	R_M32R_18_PCREL_RELA      = 37, /* PC relative 18 bit shifted. */
	R_M32R_26_PCREL_RELA      = 38, /* PC relative 26 bit shifted. */
	R_M32R_HI16_ULO_RELA      = 39, /* High 16 bit with unsigned low */
	R_M32R_HI16_SLO_RELA      = 40, /* High 16 bit with signed low */
	R_M32R_LO16_RELA          = 41, /* Low 16 bit */
	R_M32R_SDA16_RELA         = 42, /* 16 bit offset in SDA */
	R_M32R_RELA_GNU_VTINHERIT = 43,
	R_M32R_RELA_GNU_VTENTRY   = 44,
	R_M32R_REL32              = 45, /* PC relative 32 bit.  */

	R_M32R_GOT24         = 48, /* 24 bit GOT entry */
	R_M32R_26_PLTREL     = 49, /* 26 bit PC relative to PLT shifted */
	R_M32R_COPY          = 50, /* Copy symbol at runtime */
	R_M32R_GLOB_DAT      = 51, /* Create GOT entry */
	R_M32R_JMP_SLOT      = 52, /* Create PLT entry */
	R_M32R_RELATIVE      = 53, /* Adjust by program base */
	R_M32R_GOTOFF        = 54, /* 24 bit offset to GOT */
	R_M32R_GOTPC24       = 55, /* 24 bit PC relative offset to GOT */
	R_M32R_GOT16_HI_ULO  = 56, /* High 16 bit GOT entry with unsigned low */
	R_M32R_GOT16_HI_SLO  = 57, /* High 16 bit GOT entry with signed low */
	R_M32R_GOT16_LO      = 58, /* Low 16 bit GOT entry */
	R_M32R_GOTPC_HI_ULO  = 59, /* High 16 bit PC relative offset to GOT with unsigned low */
	R_M32R_GOTPC_HI_SLO  = 60, /* High 16 bit PC relative offset to GOT with signed low */
	R_M32R_GOTPC_LO      = 61, /* Low 16 bit PC relative offset to GOT */
	R_M32R_GOTOFF_HI_ULO = 62, /* High 16 bit offset to GOT with unsigned low */
	R_M32R_GOTOFF_HI_SLO = 63, /* High 16 bit offset to GOT with signed low */
	R_M32R_GOTOFF_LO     = 64, /* Low 16 bit offset to GOT */

	R_M32R_NUM = 256, /* Keep this the last entry. */
};

#endif

```

`lib/libELF/include/libELF/elf_dyn.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_DYN_H_20121007_
#define ELF_DYN_H_20121007_

#include "elf_types.h"

/* Dynamic section entry.  */

struct elf32_dyn {
	elf32_sword d_tag; /* Dynamic entry type */
	union {
		elf32_word d_val; /* Integer value */
		elf32_addr d_ptr; /* Address value */
	} d_un;
};

struct elf64_dyn {
	elf64_sxword d_tag; /* Dynamic entry type */
	union {
		elf64_xword d_val; /* Integer value */
		elf64_addr d_ptr;  /* Address value */
	} d_un;
};

/* Legal values for d_tag field of Elf32_Dyn.  */
enum {
	DT_MIPS_RLD_VERSION           = 0x70000001, /* Runtime linker interface version */
	DT_MIPS_TIME_STAMP            = 0x70000002, /* Timestamp */
	DT_MIPS_ICHECKSUM             = 0x70000003, /* Checksum */
	DT_MIPS_IVERSION              = 0x70000004, /* Version string (string tbl index) */
	DT_MIPS_FLAGS                 = 0x70000005, /* Flags */
	DT_MIPS_BASE_ADDRESS          = 0x70000006, /* Base address */
	DT_MIPS_MSYM                  = 0x70000007,
	DT_MIPS_CONFLICT              = 0x70000008, /* Address of CONFLICT section */
	DT_MIPS_LIBLIST               = 0x70000009, /* Address of LIBLIST section */
	DT_MIPS_LOCAL_GOTNO           = 0x7000000a, /* Number of local GOT entries */
	DT_MIPS_CONFLICTNO            = 0x7000000b, /* Number of CONFLICT entries */
	DT_MIPS_LIBLISTNO             = 0x70000010, /* Number of LIBLIST entries */
	DT_MIPS_SYMTABNO              = 0x70000011, /* Number of DYNSYM entries */
	DT_MIPS_UNREFEXTNO            = 0x70000012, /* First external DYNSYM */
	DT_MIPS_GOTSYM                = 0x70000013, /* First GOT entry in DYNSYM */
	DT_MIPS_HIPAGENO              = 0x70000014, /* Number of GOT page table entries */
	DT_MIPS_RLD_MAP               = 0x70000016, /* Address of run time loader map.  */
	DT_MIPS_DELTA_CLASS           = 0x70000017, /* Delta C++ class definition.  */
	DT_MIPS_DELTA_CLASS_NO        = 0x70000018, /* Number of entries in DT_MIPS_DELTA_CLASS.  */
	DT_MIPS_DELTA_INSTANCE        = 0x70000019, /* Delta C++ class instances.  */
	DT_MIPS_DELTA_INSTANCE_NO     = 0x7000001a, /* Number of entries in DT_MIPS_DELTA_INSTANCE.  */
	DT_MIPS_DELTA_RELOC           = 0x7000001b, /* Delta relocations.  */
	DT_MIPS_DELTA_RELOC_NO        = 0x7000001c, /* Number of entries in DT_MIPS_DELTA_RELOC.  */
	DT_MIPS_DELTA_SYM             = 0x7000001d, /* Delta symbols that Delta    relocations refer to.  */
	DT_MIPS_DELTA_SYM_NO          = 0x7000001e, /* Number of entries in    DT_MIPS_DELTA_SYM.  */
	DT_MIPS_DELTA_CLASSSYM        = 0x70000020, /* Delta symbols that hold the	class declaration.  */
	DT_MIPS_DELTA_CLASSSYM_NO     = 0x70000021, /* Number of entries in DT_MIPS_DELTA_CLASSSYM.  */
	DT_MIPS_CXX_FLAGS             = 0x70000022, /* Flags indicating for C++ flavor.  */
	DT_MIPS_PIXIE_INIT            = 0x70000023,
	DT_MIPS_SYMBOL_LIB            = 0x70000024,
	DT_MIPS_LOCALPAGE_GOTIDX      = 0x70000025,
	DT_MIPS_LOCAL_GOTIDX          = 0x70000026,
	DT_MIPS_HIDDEN_GOTIDX         = 0x70000027,
	DT_MIPS_PROTECTED_GOTIDX      = 0x70000028,
	DT_MIPS_OPTIONS               = 0x70000029, /* Address of .options.  */
	DT_MIPS_INTERFACE             = 0x7000002a, /* Address of .interface.  */
	DT_MIPS_DYNSTR_ALIGN          = 0x7000002b,
	DT_MIPS_INTERFACE_SIZE        = 0x7000002c, /* Size of the .interface section. */
	DT_MIPS_RLD_TEXT_RESOLVE_ADDR = 0x7000002d, /* Address of rld_text_rsolve function stored in GOT.  */
	DT_MIPS_PERF_SUFFIX           = 0x7000002e, /* Default suffix of dso to be added by rld on dlopen() calls.  */
	DT_MIPS_COMPACT_SIZE          = 0x7000002f, /* (O32)Size of compact rel section. */
	DT_MIPS_GP_VALUE              = 0x70000030, /* GP value for aux GOTs.  */
	DT_MIPS_AUX_DYNAMIC           = 0x70000031, /* Address of aux .dynamic.  */

	/* The address of .got.plt in an executable using the new non-PIC ABI.  */
	DT_MIPS_PLTGOT = 0x70000032,

	/* The base of the PLT in an executable using the new non-PIC ABI if that
	   PLT is writable.  For a non-writable PLT, this is omitted or has a zero
	   value.  */
	DT_MIPS_RWPLT = 0x70000034,
	DT_MIPS_NUM   = 0x35,
};

/* Legal values for d_tag (dynamic entry type).  */
enum {
	DT_NULL            = 0,          /* Marks end of dynamic section */
	DT_NEEDED          = 1,          /* Name of needed library */
	DT_PLTRELSZ        = 2,          /* Size in bytes of PLT relocs */
	DT_PLTGOT          = 3,          /* Processor defined value */
	DT_HASH            = 4,          /* Address of symbol hash table */
	DT_STRTAB          = 5,          /* Address of string table */
	DT_SYMTAB          = 6,          /* Address of symbol table */
	DT_RELA            = 7,          /* Address of Rela relocs */
	DT_RELASZ          = 8,          /* Total size of Rela relocs */
	DT_RELAENT         = 9,          /* Size of one Rela reloc */
	DT_STRSZ           = 10,         /* Size of string table */
	DT_SYMENT          = 11,         /* Size of one symbol table entry */
	DT_INIT            = 12,         /* Address of init function */
	DT_FINI            = 13,         /* Address of termination function */
	DT_SONAME          = 14,         /* Name of shared object */
	DT_RPATH           = 15,         /* Library search path (deprecated) */
	DT_SYMBOLIC        = 16,         /* Start symbol search here */
	DT_REL             = 17,         /* Address of Rel relocs */
	DT_RELSZ           = 18,         /* Total size of Rel relocs */
	DT_RELENT          = 19,         /* Size of one Rel reloc */
	DT_PLTREL          = 20,         /* Type of reloc in PLT */
	DT_DEBUG           = 21,         /* For debugging; unspecified */
	DT_TEXTREL         = 22,         /* Reloc might modify .text */
	DT_JMPREL          = 23,         /* Address of PLT relocs */
	DT_BIND_NOW        = 24,         /* Process relocations of object */
	DT_INIT_ARRAY      = 25,         /* Array with addresses of init fct */
	DT_FINI_ARRAY      = 26,         /* Array with addresses of fini fct */
	DT_INIT_ARRAYSZ    = 27,         /* Size in bytes of DT_INIT_ARRAY */
	DT_FINI_ARRAYSZ    = 28,         /* Size in bytes of DT_FINI_ARRAY */
	DT_RUNPATH         = 29,         /* Library search path */
	DT_FLAGS           = 30,         /* Flags for the object being loaded */
	DT_ENCODING        = 32,         /* Start of encoded range */
	DT_PREINIT_ARRAY   = 32,         /* Array with addresses of preinit fct*/
	DT_PREINIT_ARRAYSZ = 33,         /* size in bytes of DT_PREINIT_ARRAY */
	DT_NUM             = 34,         /* Number used */
	DT_LOOS            = 0x6000000d, /* Start of OS-specific */
	DT_HIOS            = 0x6ffff000, /* End of OS-specific */
	DT_LOPROC          = 0x70000000, /* Start of processor-specific */
	DT_HIPROC          = 0x7fffffff, /* End of processor-specific */

	DT_PROCNUM = DT_MIPS_NUM /* Most used by any processor */
};

/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
   approach.  */
enum {
	DT_VALRNGLO       = 0x6ffffd00,
	DT_GNU_PRELINKED  = 0x6ffffdf5, /* Prelinking timestamp */
	DT_GNU_CONFLICTSZ = 0x6ffffdf6, /* Size of conflict section */
	DT_GNU_LIBLISTSZ  = 0x6ffffdf7, /* Size of library list */
	DT_CHECKSUM       = 0x6ffffdf8,
	DT_PLTPADSZ       = 0x6ffffdf9,
	DT_MOVEENT        = 0x6ffffdfa,
	DT_MOVESZ         = 0x6ffffdfb,
	DT_FEATURE_1      = 0x6ffffdfc, /* Feature selection (DTF_*).  */
	DT_POSFLAG_1      = 0x6ffffdfd, /* Flags for DT_* entries, effecting the following DT_* entry.  */
	DT_SYMINSZ        = 0x6ffffdfe, /* Size of syminfo table (in bytes) */
	DT_SYMINENT       = 0x6ffffdff, /* Entry size of syminfo */
	DT_VALRNGHI       = 0x6ffffdff,
	DT_VALNUM         = 12,
};

constexpr inline uint32_t DT_VALTAGIDX(uint32_t tag) {
	return DT_VALRNGHI - tag; /* Reverse order! */
}

/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.

   If any adjustment is made to the ELF object after it has been
   built these entries will need to be adjusted.  */
enum {
	DT_ADDRRNGLO    = 0x6ffffe00,
	DT_GNU_HASH     = 0x6ffffef5, /* GNU-style hash table.  */
	DT_TLSDESC_PLT  = 0x6ffffef6,
	DT_TLSDESC_GOT  = 0x6ffffef7,
	DT_GNU_CONFLICT = 0x6ffffef8, /* Start of conflict section */
	DT_GNU_LIBLIST  = 0x6ffffef9, /* Library list */
	DT_CONFIG       = 0x6ffffefa, /* Configuration information.  */
	DT_DEPAUDIT     = 0x6ffffefb, /* Dependency auditing.  */
	DT_AUDIT        = 0x6ffffefc, /* Object auditing.  */
	DT_PLTPAD       = 0x6ffffefd, /* PLT padding.  */
	DT_MOVETAB      = 0x6ffffefe, /* Move table.  */
	DT_SYMINFO      = 0x6ffffeff, /* Syminfo table.  */
	DT_ADDRRNGHI    = 0x6ffffeff,
	DT_ADDRNUM      = 11,
};

constexpr inline uint32_t DT_ADDRTAGIDX(uint32_t tag) {
	return DT_ADDRRNGHI - tag; /* Reverse order! */
}

/* The versioning entry types.  The next are defined as part of the
   GNU extension.  */
enum {
	DT_VERSYM = 0x6ffffff0,
};

enum {
	DT_RELACOUNT = 0x6ffffff9,
	DT_RELCOUNT  = 0x6ffffffa,
};

/* These were chosen by Sun.  */
enum {
	DT_FLAGS_1       = 0x6ffffffb, /* State flags, see DF_1_* below.  */
	DT_VERDEF        = 0x6ffffffc, /* Address of version definition table */
	DT_VERDEFNUM     = 0x6ffffffd, /* Number of version definitions */
	DT_VERNEED       = 0x6ffffffe, /* Address of table with needed versions */
	DT_VERNEEDNUM    = 0x6fffffff, /* Number of needed versions */
	DT_VERSIONTAGNUM = 16,
};

constexpr inline uint32_t DT_VERSIONTAGIDX(uint32_t tag) {
	return DT_VERNEEDNUM - tag; /* Reverse order! */
}

/* Sun added these machine-independent extensions in the "processor-specific"
   range.  Be compatible.  */
enum {
	DT_AUXILIARY = 0x7ffffffd, /* Shared object to load before self */
	DT_FILTER    = 0x7fffffff, /* Shared object to get values from */
	DT_EXTRANUM  = 3,
};

constexpr inline uint32_t DT_EXTRATAGIDX(uint32_t tag) {
	return static_cast<elf32_word>(-(static_cast<elf32_sword>(tag) << 1 >> 1) - 1);
}

/* Values of `d_un.d_val' in the DT_FLAGS entry.  */
enum {
	DF_ORIGIN     = 0x00000001, /* Object may use DF_ORIGIN */
	DF_SYMBOLIC   = 0x00000002, /* Symbol resolutions starts here */
	DF_TEXTREL    = 0x00000004, /* Object contains text relocations */
	DF_BIND_NOW   = 0x00000008, /* No lazy binding for this object */
	DF_STATIC_TLS = 0x00000010, /* Module uses the static TLS model */
};

/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1
   entry in the dynamic section.  */
enum {
	DF_1_NOW        = 0x00000001, /* Set RTLD_NOW for this object.  */
	DF_1_GLOBAL     = 0x00000002, /* Set RTLD_GLOBAL for this object.  */
	DF_1_GROUP      = 0x00000004, /* Set RTLD_GROUP for this object.  */
	DF_1_NODELETE   = 0x00000008, /* Set RTLD_NODELETE for this object.*/
	DF_1_LOADFLTR   = 0x00000010, /* Trigger filtee loading at runtime.*/
	DF_1_INITFIRST  = 0x00000020, /* Set RTLD_INITFIRST for this object*/
	DF_1_NOOPEN     = 0x00000040, /* Set RTLD_NOOPEN for this object.  */
	DF_1_ORIGIN     = 0x00000080, /* $ORIGIN must be handled.  */
	DF_1_DIRECT     = 0x00000100, /* Direct binding enabled.  */
	DF_1_TRANS      = 0x00000200,
	DF_1_INTERPOSE  = 0x00000400, /* Object is used to interpose.  */
	DF_1_NODEFLIB   = 0x00000800, /* Ignore default lib search path.  */
	DF_1_NODUMP     = 0x00001000, /* Object can't be dldump'ed.  */
	DF_1_CONFALT    = 0x00002000, /* Configuration alternative created.*/
	DF_1_ENDFILTEE  = 0x00004000, /* Filtee terminates filters search. */
	DF_1_DISPRELDNE = 0x00008000, /* Disp reloc applied at build time. */
	DF_1_DISPRELPND = 0x00010000, /* Disp reloc applied at run-time.  */
};

/* Flags for the feature selection in DT_FEATURE_1.  */
enum {
	DTF_1_PARINIT = 0x00000001,
	DTF_1_CONFEXP = 0x00000002,
};

/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */
enum {
	DF_P1_LAZYLOAD  = 0x00000001, /* Lazyload following object.  */
	DF_P1_GROUPPERM = 0x00000002, /* Symbols from next object are not generally available.  */
};

#endif

```

`lib/libELF/include/libELF/elf_header.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_HEADER_H_20121007_
#define ELF_HEADER_H_20121007_

#include "elf_types.h"

// The ELF file header.  This appears at the start of every ELF file.
enum { EI_NIDENT = 16 };

/* Fields in the e_ident array.  The EI_* macros are indices into the
   array.  The macros under each EI_* macro are the values the byte
   may have.  */
enum {
	EI_MAG0 = 0, /* File identification byte 0 index */
	EI_MAG1 = 1, /* File identification byte 1 index */
	EI_MAG2 = 2, /* File identification byte 2 index */
	EI_MAG3 = 3, /* File identification byte 3 index */
};

#define ELFMAG0 0x7f /* Magic number byte 0 */
#define ELFMAG1 'E' /* Magic number byte 1 */
#define ELFMAG2 'L' /* Magic number byte 2 */
#define ELFMAG3 'F' /* Magic number byte 3 */

/* Conglomeration of the identification bytes, for easy testing as a word.  */
#define ELFMAG "\177ELF"
#define SELFMAG 4

enum {
	EI_CLASS     = 4, /* File class byte index */
	ELFCLASSNONE = 0, /* Invalid class */
	ELFCLASS32   = 1, /* 32-bit objects */
	ELFCLASS64   = 2, /* 64-bit objects */
	ELFCLASSNUM  = 3,

	EI_DATA     = 5, /* Data encoding byte index */
	ELFDATANONE = 0, /* Invalid data encoding */
	ELFDATA2LSB = 1, /* 2's complement, little endian */
	ELFDATA2MSB = 2, /* 2's complement, big endian */
	ELFDATANUM  = 3,

	EI_VERSION = 6, /* File version byte index */
					/* Value must be EV_CURRENT */
};

/* Legal values for e_version (version).  */
enum {
	EV_NONE    = 0, /* Invalid ELF version */
	EV_CURRENT = 1, /* Current version */
	EV_NUM     = 2,
};

enum {
	EI_OSABI            = 7,            /* OS ABI identification */
	ELFOSABI_NONE       = 0,            /* UNIX System V ABI */
	ELFOSABI_SYSV       = 0,            /* Alias.  */
	ELFOSABI_HPUX       = 1,            /* HP-UX */
	ELFOSABI_NETBSD     = 2,            /* NetBSD.  */
	ELFOSABI_GNU        = 3,            /* Object uses GNU ELF extensions.  */
	ELFOSABI_LINUX      = ELFOSABI_GNU, /* Compatibility alias.  */
	ELFOSABI_SOLARIS    = 6,            /* Sun Solaris.  */
	ELFOSABI_AIX        = 7,            /* IBM AIX.  */
	ELFOSABI_IRIX       = 8,            /* SGI Irix.  */
	ELFOSABI_FREEBSD    = 9,            /* FreeBSD.  */
	ELFOSABI_TRU64      = 10,           /* Compaq TRU64 UNIX.  */
	ELFOSABI_MODESTO    = 11,           /* Novell Modesto.  */
	ELFOSABI_OPENBSD    = 12,           /* OpenBSD.  */
	ELFOSABI_ARM_AEABI  = 64,           /* ARM EABI */
	ELFOSABI_ARM        = 97,           /* ARM */
	ELFOSABI_STANDALONE = 255,          /* Standalone (embedded) application */

	EI_ABIVERSION = 8, /* ABI version */

	EI_PAD = 9, /* Byte index of padding bytes */
};

/* Legal values for e_type (object file type).  */
enum {
	ET_NONE   = 0,      /* No file type */
	ET_REL    = 1,      /* Relocatable file */
	ET_EXEC   = 2,      /* Executable file */
	ET_DYN    = 3,      /* Shared object file */
	ET_CORE   = 4,      /* Core file */
	ET_NUM    = 5,      /* Number of defined types */
	ET_LOOS   = 0xfe00, /* OS-specific range start */
	ET_HIOS   = 0xfeff, /* OS-specific range end */
	ET_LOPROC = 0xff00, /* Processor-specific range start */
	ET_HIPROC = 0xffff, /* Processor-specific range end */
};

/* Legal values for e_machine (architecture).  */
enum {
	EM_NONE        = 0,  /* No machine */
	EM_M32         = 1,  /* AT&T WE 32100 */
	EM_SPARC       = 2,  /* SUN SPARC */
	EM_386         = 3,  /* Intel 80386 */
	EM_68K         = 4,  /* Motorola m68k family */
	EM_88K         = 5,  /* Motorola m88k family */
	EM_860         = 7,  /* Intel 80860 */
	EM_MIPS        = 8,  /* MIPS R3000 big-endian */
	EM_S370        = 9,  /* IBM System/370 */
	EM_MIPS_RS3_LE = 10, /* MIPS R3000 little-endian */

	EM_PARISC      = 15, /* HPPA */
	EM_VPP500      = 17, /* Fujitsu VPP500 */
	EM_SPARC32PLUS = 18, /* Sun's "v8plus" */
	EM_960         = 19, /* Intel 80960 */
	EM_PPC         = 20, /* PowerPC */
	EM_PPC64       = 21, /* PowerPC 64-bit */
	EM_S390        = 22, /* IBM S390 */

	EM_V800       = 36, /* NEC V800 series */
	EM_FR20       = 37, /* Fujitsu FR20 */
	EM_RH32       = 38, /* TRW RH-32 */
	EM_RCE        = 39, /* Motorola RCE */
	EM_ARM        = 40, /* ARM */
	EM_FAKE_ALPHA = 41, /* Digital Alpha */
	EM_SH         = 42, /* Hitachi SH */
	EM_SPARCV9    = 43, /* SPARC v9 64-bit */
	EM_TRICORE    = 44, /* Siemens Tricore */
	EM_ARC        = 45, /* Argonaut RISC Core */
	EM_H8_300     = 46, /* Hitachi H8/300 */
	EM_H8_300H    = 47, /* Hitachi H8/300H */
	EM_H8S        = 48, /* Hitachi H8S */
	EM_H8_500     = 49, /* Hitachi H8/500 */
	EM_IA_64      = 50, /* Intel Merced */
	EM_MIPS_X     = 51, /* Stanford MIPS-X */
	EM_COLDFIRE   = 52, /* Motorola Coldfire */
	EM_68HC12     = 53, /* Motorola M68HC12 */
	EM_MMA        = 54, /* Fujitsu MMA Multimedia Accelerator*/
	EM_PCP        = 55, /* Siemens PCP */
	EM_NCPU       = 56, /* Sony nCPU embeeded RISC */
	EM_NDR1       = 57, /* Denso NDR1 microprocessor */
	EM_STARCORE   = 58, /* Motorola Start*Core processor */
	EM_ME16       = 59, /* Toyota ME16 processor */
	EM_ST100      = 60, /* STMicroelectronic ST100 processor */
	EM_TINYJ      = 61, /* Advanced Logic Corp. Tinyj emb.fam*/
	EM_X86_64     = 62, /* AMD x86-64 architecture */
	EM_PDSP       = 63, /* Sony DSP Processor */

	EM_FX66     = 66, /* Siemens FX66 microcontroller */
	EM_ST9PLUS  = 67, /* STMicroelectronics ST9+ 8/16 mc */
	EM_ST7      = 68, /* STmicroelectronics ST7 8 bit mc */
	EM_68HC16   = 69, /* Motorola MC68HC16 microcontroller */
	EM_68HC11   = 70, /* Motorola MC68HC11 microcontroller */
	EM_68HC08   = 71, /* Motorola MC68HC08 microcontroller */
	EM_68HC05   = 72, /* Motorola MC68HC05 microcontroller */
	EM_SVX      = 73, /* Silicon Graphics SVx */
	EM_ST19     = 74, /* STMicroelectronics ST19 8 bit mc */
	EM_VAX      = 75, /* Digital VAX */
	EM_CRIS     = 76, /* Axis Communications 32-bit embedded processor */
	EM_JAVELIN  = 77, /* Infineon Technologies 32-bit embedded processor */
	EM_FIREPATH = 78, /* Element 14 64-bit DSP Processor */
	EM_ZSP      = 79, /* LSI Logic 16-bit DSP Processor */
	EM_MMIX     = 80, /* Donald Knuth's educational 64-bit processor */
	EM_HUANY    = 81, /* Harvard University machine-independent object files */
	EM_PRISM    = 82, /* SiTera Prism */
	EM_AVR      = 83, /* Atmel AVR 8-bit microcontroller */
	EM_FR30     = 84, /* Fujitsu FR30 */
	EM_D10V     = 85, /* Mitsubishi D10V */
	EM_D30V     = 86, /* Mitsubishi D30V */
	EM_V850     = 87, /* NEC v850 */
	EM_M32R     = 88, /* Mitsubishi M32R */
	EM_MN10300  = 89, /* Matsushita MN10300 */
	EM_MN10200  = 90, /* Matsushita MN10200 */
	EM_PJ       = 91, /* picoJava */
	EM_OPENRISC = 92, /* OpenRISC 32-bit embedded processor */
	EM_ARC_A5   = 93, /* ARC Cores Tangent-A5 */
	EM_XTENSA   = 94, /* Tensilica Xtensa Architecture */
	EM_NUM      = 95,

	/* If it is necessary to assign new unofficial EM_* values, please
	   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
	   chances of collision with official or non-GNU unofficial values.  */
	EM_ALPHA = 0x9026,
};

struct elf32_phdr;
struct elf32_header {
	using elf_phdr = elf32_phdr;
	enum { ELFCLASS = ELFCLASS32 };

	uint8_t e_ident[EI_NIDENT]; /* Magic number and other info */
	elf32_half e_type;          /* Object file type */
	elf32_half e_machine;       /* Architecture */
	elf32_word e_version;       /* Object file version */
	elf32_addr e_entry;         /* Entry point virtual address */
	elf32_off e_phoff;          /* Program header table file offset */
	elf32_off e_shoff;          /* Section header table file offset */
	elf32_word e_flags;         /* Processor-specific flags */
	elf32_half e_ehsize;        /* ELF header size in bytes */
	elf32_half e_phentsize;     /* Program header table entry size */
	elf32_half e_phnum;         /* Program header table entry count */
	elf32_half e_shentsize;     /* Section header table entry size */
	elf32_half e_shnum;         /* Section header table entry count */
	elf32_half e_shstrndx;      /* Section header string table index */
};

struct elf64_phdr;
struct elf64_header {
	using elf_phdr = elf64_phdr;
	enum { ELFCLASS = ELFCLASS64 };

	uint8_t e_ident[EI_NIDENT]; /* Magic number and other info */
	elf64_half e_type;          /* Object file type */
	elf64_half e_machine;       /* Architecture */
	elf64_word e_version;       /* Object file version */
	elf64_addr e_entry;         /* Entry point virtual address */
	elf64_off e_phoff;          /* Program header table file offset */
	elf64_off e_shoff;          /* Section header table file offset */
	elf64_word e_flags;         /* Processor-specific flags */
	elf64_half e_ehsize;        /* ELF header size in bytes */
	elf64_half e_phentsize;     /* Program header table entry size */
	elf64_half e_phnum;         /* Program header table entry count */
	elf64_half e_shentsize;     /* Section header table entry size */
	elf64_half e_shnum;         /* Section header table entry count */
	elf64_half e_shstrndx;      /* Section header string table index */
};

#endif

```

`lib/libELF/include/libELF/elf_model.h`:

```h
/*
Copyright (C) 2018 - 2018 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_MODEL_H_20181206_
#define ELF_MODEL_H_20181206_

#include "elf_auxv.h"
#include "elf_dyn.h"
#include "elf_header.h"
#include "elf_move.h"
#include "elf_nhdr.h"
#include "elf_phdr.h"
#include "elf_rel.h"
#include "elf_rela.h"
#include "elf_shdr.h"
#include "elf_sym.h"
#include "elf_syminfo.h"
#include "elf_types.h"
#include "elf_verdaux.h"
#include "elf_verdef.h"
#include "elf_vernaux.h"
#include "elf_verneed.h"

template <int>
struct elf_model;

template <>
struct elf_model<64> {
	// types
	using elf_half    = elf64_half;
	using elf_word    = elf64_word;
	using elf_sword   = elf64_sword;
	using elf_xword   = elf64_xword;
	using elf_sxword  = elf64_sxword;
	using elf_addr    = elf64_addr;
	using elf_off     = elf64_off;
	using elf_section = elf64_section;
	using elf_versym  = elf64_versym;

	// structures
	using elf_auxv_t = elf64_auxv_t;
	using elf_dyn    = elf64_dyn;
	using elf_header = elf64_header;
#if 0
	using elf_lib	  =  elf64_lib;
#endif
	using elf_move    = elf64_move;
	using elf_nhdr    = elf64_nhdr;
	using elf_phdr    = elf64_phdr;
	using elf_rel     = elf64_rel;
	using elf_rela    = elf64_rela;
	using elf_shdr    = elf64_shdr;
	using elf_sym     = elf64_sym;
	using elf_syminfo = elf64_syminfo;
	using elf_verdaux = elf64_verdaux;
	using elf_verdef  = elf64_verdef;
	using elf_vernaux = elf64_vernaux;
	using elf_verneed = elf64_verneed;
};

template <>
struct elf_model<32> {
	// types
	using elf_half    = elf32_half;
	using elf_word    = elf32_word;
	using elf_sword   = elf32_sword;
	using elf_xword   = elf32_xword;
	using elf_sxword  = elf32_sxword;
	using elf_addr    = elf32_addr;
	using elf_off     = elf32_off;
	using elf_section = elf32_section;
	using elf_versym  = elf32_versym;

	// structures
	using elf_auxv_t = elf32_auxv_t;
	using elf_dyn    = elf32_dyn;
	using elf_header = elf32_header;
#if 0
	using elf_lib	  =  elf32_lib;
#endif
	using elf_move    = elf32_move;
	using elf_nhdr    = elf32_nhdr;
	using elf_phdr    = elf32_phdr;
	using elf_rel     = elf32_rel;
	using elf_rela    = elf32_rela;
	using elf_shdr    = elf32_shdr;
	using elf_sym     = elf32_sym;
	using elf_syminfo = elf32_syminfo;
	using elf_verdaux = elf32_verdaux;
	using elf_verdef  = elf32_verdef;
	using elf_vernaux = elf32_vernaux;
	using elf_verneed = elf32_verneed;
};

#endif

```

`lib/libELF/include/libELF/elf_move.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_MOVE_H_20121007_
#define ELF_MOVE_H_20121007_

#include "elf_types.h"

// Move records.
struct elf32_move {
	elf32_xword m_value;  // Symbol value.
	elf32_word m_info;    // Size and index.
	elf32_word m_poffset; // Symbol offset.
	elf32_half m_repeat;  // Repeat count.
	elf32_half m_stride;  // Stride info.
};

struct elf64_move {
	elf64_xword m_value;   // Symbol value.
	elf64_xword m_info;    // Size and index.
	elf64_xword m_poffset; // Symbol offset.
	elf64_half m_repeat;   // Repeat count.
	elf64_half m_stride;   // Stride info.
};

// Macro to construct move records.
template <class T>
constexpr T ELF32_M_SYM(T info) {
	return info >> 8;
}

template <class T>
constexpr auto ELF32_M_SIZE(T info) {
	return static_cast<uint8_t>(info);
}

template <class T1, class T2>
constexpr auto ELF32_M_INFO(T1 sym, T2 size) {
	return (sym << 8) + static_cast<uint8_t>(size);
}

template <class T>
constexpr T ELF64_M_SYM(T info) {
	return ELF32_M_SYM(info);
}

template <class T>
constexpr auto ELF64_M_SIZE(T info) {
	return ELF32_M_SIZE(info);
}

template <class T1, class T2>
constexpr auto ELF64_M_INFO(T1 sym, T2 size) {
	return ELF32_M_INFO(sym, size);
}

#endif

```

`lib/libELF/include/libELF/elf_nhdr.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_NHDR_H_20121007_
#define ELF_NHDR_H_20121007_

#include "elf_types.h"

/* Note section contents.  Each entry in the note section begins with
   a header of a fixed form.  */
struct elf32_nhdr {
	elf32_word n_namesz; /* Length of the note's name.  */
	elf32_word n_descsz; /* Length of the note's descriptor.  */
	elf32_word n_type;   /* Type of the note.  */
};

struct elf64_nhdr {
	elf64_word n_namesz; /* Length of the note's name.  */
	elf64_word n_descsz; /* Length of the note's descriptor.  */
	elf64_word n_type;   /* Type of the note.  */
};

/* Known names of notes.  */

/* Solaris entries in the note section have this name.  */
#define ELF_NOTE_SOLARIS "SUNW Solaris"

/* Note entries for GNU systems have this name.  */
#define ELF_NOTE_GNU "GNU"

/* Defined types of notes for Solaris.  */

/* Value of descriptor (one word) is desired pagesize for the binary.  */
enum {
	ELF_NOTE_PAGESIZE_HINT = 1,
};

/* Defined note types for GNU systems.  */

/* ABI information.  The descriptor consists of words:
   word 0: OS descriptor
   word 1: major version of the ABI
   word 2: minor version of the ABI
   word 3: subminor version of the ABI
*/
enum {
	NT_GNU_ABI_TAG = 1,
	ELF_NOTE_ABI   = NT_GNU_ABI_TAG, /* Old name.  */
};

/* Known OSes.  These values can appear in word 0 of an
   NT_GNU_ABI_TAG note section entry.  */
enum {
	ELF_NOTE_OS_LINUX    = 0,
	ELF_NOTE_OS_GNU      = 1,
	ELF_NOTE_OS_SOLARIS2 = 2,
	ELF_NOTE_OS_FREEBSD  = 3,
};

enum {
	/* Synthetic hwcap information.  The descriptor begins with two words:
	   word 0: number of entries
	   word 1: bitmask of enabled entries
	   Then follow variable-length entries, one byte followed by a
	   '\0'-terminated hwcap name string.  The byte gives the bit
	   number to test if enabled, (1U << bit) & bitmask.  */
	NT_GNU_HWCAP = 2,

	NT_GNU_BUILD_ID     = 3, /* Build ID bits as generated by ld --build-id. The descriptor consists of any nonzero number of bytes.  */
	NT_GNU_GOLD_VERSION = 4, /* Version note generated by GNU gold containing a version string.  */
};

#endif

```

`lib/libELF/include/libELF/elf_phdr.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_PHDR_H_20121007_
#define ELF_PHDR_H_20121007_

#include "elf_types.h"

/* Program segment header.  */
struct elf32_phdr {
	elf32_word p_type;   /* Segment type */
	elf32_off p_offset;  /* Segment file offset */
	elf32_addr p_vaddr;  /* Segment virtual address */
	elf32_addr p_paddr;  /* Segment physical address */
	elf32_word p_filesz; /* Segment size in file */
	elf32_word p_memsz;  /* Segment size in memory */
	elf32_word p_flags;  /* Segment flags */
	elf32_word p_align;  /* Segment alignment */
};

struct elf64_phdr {
	elf64_word p_type;    /* Segment type */
	elf64_word p_flags;   /* Segment flags */
	elf64_off p_offset;   /* Segment file offset */
	elf64_addr p_vaddr;   /* Segment virtual address */
	elf64_addr p_paddr;   /* Segment physical address */
	elf64_xword p_filesz; /* Segment size in file */
	elf64_xword p_memsz;  /* Segment size in memory */
	elf64_xword p_align;  /* Segment alignment */
};

/* Special value for e_phnum.  This indicates that the real number of
   program headers is too large to fit into e_phnum.  Instead the real
   value is in the field sh_info of section 0.  */
enum {
	PN_XNUM = 0xffff,
};

/* Legal values for p_type (segment type).  */
enum {
	PT_NULL         = 0,          /* Program header table entry unused */
	PT_LOAD         = 1,          /* Loadable program segment */
	PT_DYNAMIC      = 2,          /* Dynamic linking information */
	PT_INTERP       = 3,          /* Program interpreter */
	PT_NOTE         = 4,          /* Auxiliary information */
	PT_SHLIB        = 5,          /* Reserved */
	PT_PHDR         = 6,          /* Entry for header table itself */
	PT_TLS          = 7,          /* Thread-local storage segment */
	PT_NUM          = 8,          /* Number of defined types */
	PT_LOOS         = 0x60000000, /* Start of OS-specific */
	PT_GNU_EH_FRAME = 0x6474e550, /* GCC .eh_frame_hdr segment */
	PT_GNU_STACK    = 0x6474e551, /* Indicates stack executability */
	PT_GNU_RELRO    = 0x6474e552, /* Read-only after relocation */
	PT_PAX_FLAGS    = 0x65041580, /* Indicates PaX flag markings */
	PT_LOSUNW       = 0x6ffffffa,
	PT_SUNWBSS      = 0x6ffffffa, /* Sun Specific segment */
	PT_SUNWSTACK    = 0x6ffffffb, /* Stack segment */
	PT_HISUNW       = 0x6fffffff,
	PT_HIOS         = 0x6fffffff, /* End of OS-specific */
	PT_LOPROC       = 0x70000000, /* Start of processor-specific */
	PT_HIPROC       = 0x7fffffff, /* End of processor-specific */
};

/* Legal values for p_flags (segment flags).  */
enum {
	PF_X          = (1 << 0),   /* Segment is executable */
	PF_W          = (1 << 1),   /* Segment is writable */
	PF_R          = (1 << 2),   /* Segment is readable */
	PF_PAGEEXEC   = (1 << 4),   /* Enable  PAGEEXEC */
	PF_NOPAGEEXEC = (1 << 5),   /* Disable PAGEEXEC */
	PF_SEGMEXEC   = (1 << 6),   /* Enable  SEGMEXEC */
	PF_NOSEGMEXEC = (1 << 7),   /* Disable SEGMEXEC */
	PF_MPROTECT   = (1 << 8),   /* Enable  MPROTECT */
	PF_NOMPROTECT = (1 << 9),   /* Disable MPROTECT */
	PF_RANDEXEC   = (1 << 10),  /* Enable  RANDEXEC */
	PF_NORANDEXEC = (1 << 11),  /* Disable RANDEXEC */
	PF_EMUTRAMP   = (1 << 12),  /* Enable  EMUTRAMP */
	PF_NOEMUTRAMP = (1 << 13),  /* Disable EMUTRAMP */
	PF_RANDMMAP   = (1 << 14),  /* Enable  RANDMMAP */
	PF_NORANDMMAP = (1 << 15),  /* Disable RANDMMAP */
	PF_MASKOS     = 0x0ff00000, /* OS-specific */
	PF_MASKPROC   = 0xf0000000, /* Processor-specific */
};

/* Legal values for note segment descriptor types for core files. */
enum {
	NT_PRSTATUS   = 1,          /* Contains copy of prstatus struct */
	NT_FPREGSET   = 2,          /* Contains copy of fpregset struct */
	NT_PRPSINFO   = 3,          /* Contains copy of prpsinfo struct */
	NT_PRXREG     = 4,          /* Contains copy of prxregset struct */
	NT_TASKSTRUCT = 4,          /* Contains copy of task structure */
	NT_PLATFORM   = 5,          /* String from sysinfo(SI_PLATFORM) */
	NT_AUXV       = 6,          /* Contains copy of auxv array */
	NT_GWINDOWS   = 7,          /* Contains copy of gwindows struct */
	NT_ASRS       = 8,          /* Contains copy of asrset struct */
	NT_PSTATUS    = 10,         /* Contains copy of pstatus struct */
	NT_PSINFO     = 13,         /* Contains copy of psinfo struct */
	NT_PRCRED     = 14,         /* Contains copy of prcred struct */
	NT_UTSNAME    = 15,         /* Contains copy of utsname struct */
	NT_LWPSTATUS  = 16,         /* Contains copy of lwpstatus struct */
	NT_LWPSINFO   = 17,         /* Contains copy of lwpinfo struct */
	NT_PRFPXREG   = 20,         /* Contains copy of fprxregset struct */
	NT_PRXFPREG   = 0x46e62b7f, /* Contains copy of user_fxsr_struct */
	NT_PPC_VMX    = 0x100,      /* PowerPC Altivec/VMX registers */
	NT_PPC_SPE    = 0x101,      /* PowerPC SPE/EVR registers */
	NT_PPC_VSX    = 0x102,      /* PowerPC VSX registers */
	NT_386_TLS    = 0x200,      /* i386 TLS slots (struct user_desc) */
	NT_386_IOPERM = 0x201,      /* x86 io permission bitmap (1=deny) */
	NT_X86_XSTATE = 0x202,      /* x86 extended state using xsave */
};

/* Legal values for the note segment descriptor types for object files.  */
enum {
	NT_VERSION = 1, /* Contains a version string.  */
};

#endif

```

`lib/libELF/include/libELF/elf_rel.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_REL_H_20121007_
#define ELF_REL_H_20121007_

#include "elf_types.h"

// Relocation table entry without addend (in section of type SHT_REL).
struct elf32_rel {
	elf32_addr r_offset; /* Address */
	elf32_word r_info;   /* Relocation type and symbol index */
};

/* I have seen two different definitions of the Elf64_Rel and
   Elf64_Rela structures, so we'll leave them out until Novell (or
   whoever) gets their act together.  */
/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */
struct elf64_rel {
	elf64_addr r_offset; /* Address */
	elf64_xword r_info;  /* Relocation type and symbol index */
};

#endif

```

`lib/libELF/include/libELF/elf_rela.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_RELA_H_20121007_
#define ELF_RELA_H_20121007_

#include "elf_types.h"

/* Relocation table entry with addend (in section of type SHT_RELA).  */
struct elf32_rela {
	elf32_addr r_offset;  /* Address */
	elf32_word r_info;    /* Relocation type and symbol index */
	elf32_sword r_addend; /* Addend */
};

struct elf64_rela {
	elf64_addr r_offset;   /* Address */
	elf64_xword r_info;    /* Relocation type and symbol index */
	elf64_sxword r_addend; /* Addend */
};

/* How to extract and insert information held in the r_info field.  */
template <class T>
constexpr T ELF32_R_SYM(T val) {
	return val >> 8;
}

template <class T>
constexpr T ELF32_R_TYPE(T val) {
	return val & 0xff;
}

template <class T1, class T2>
constexpr auto ELF32_R_INFO(T1 sym, T2 type) {
	return (sym << 8) + (type & 0xff);
}

template <class T>
constexpr T ELF64_R_SYM(T i) {
	return i >> 32;
}

template <class T>
constexpr T ELF64_R_TYPE(T i) {
	return i & 0xffffffff;
}

template <class T1, class T2>
constexpr auto ELF64_R_INFO(T1 sym, T2 type) {
	return (static_cast<elf64_xword>(sym) << 32) + type;
}

#endif

```

`lib/libELF/include/libELF/elf_shdr.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_SHDR_H_20121007_
#define ELF_SHDR_H_20121007_

#include "elf_types.h"

// Section header.
struct elf32_shdr {
	elf32_word sh_name;      /* Section name (string tbl index) */
	elf32_word sh_type;      /* Section type */
	elf32_word sh_flags;     /* Section flags */
	elf32_addr sh_addr;      /* Section virtual addr at execution */
	elf32_off sh_offset;     /* Section file offset */
	elf32_word sh_size;      /* Section size in bytes */
	elf32_word sh_link;      /* Link to another section */
	elf32_word sh_info;      /* Additional section information */
	elf32_word sh_addralign; /* Section alignment */
	elf32_word sh_entsize;   /* Entry size if section holds table */
};

struct elf64_shdr {
	elf64_word sh_name;       /* Section name (string tbl index) */
	elf64_word sh_type;       /* Section type */
	elf64_xword sh_flags;     /* Section flags */
	elf64_addr sh_addr;       /* Section virtual addr at execution */
	elf64_off sh_offset;      /* Section file offset */
	elf64_xword sh_size;      /* Section size in bytes */
	elf64_word sh_link;       /* Link to another section */
	elf64_word sh_info;       /* Additional section information */
	elf64_xword sh_addralign; /* Section alignment */
	elf64_xword sh_entsize;   /* Entry size if section holds table */
};

/* Special section indices.  */
enum {
	SHN_UNDEF     = 0,      /* Undefined section */
	SHN_LORESERVE = 0xff00, /* Start of reserved indices */
	SHN_LOPROC    = 0xff00, /* Start of processor-specific */
	SHN_BEFORE    = 0xff00, /* Order section before all others (Solaris).  */
	SHN_AFTER     = 0xff01, /* Order section after all others (Solaris).  */
	SHN_HIPROC    = 0xff1f, /* End of processor-specific */
	SHN_LOOS      = 0xff20, /* Start of OS-specific */
	SHN_HIOS      = 0xff3f, /* End of OS-specific */
	SHN_ABS       = 0xfff1, /* Associated symbol is absolute */
	SHN_COMMON    = 0xfff2, /* Associated symbol is common */
	SHN_XINDEX    = 0xffff, /* Index is in extra table.  */
	SHN_HIRESERVE = 0xffff, /* End of reserved indices */
};

/* Legal values for sh_type (section type).  */
enum {
	SHT_NULL           = 0,          /* Section header table entry unused */
	SHT_PROGBITS       = 1,          /* Program data */
	SHT_SYMTAB         = 2,          /* Symbol table */
	SHT_STRTAB         = 3,          /* String table */
	SHT_RELA           = 4,          /* Relocation entries with addends */
	SHT_HASH           = 5,          /* Symbol hash table */
	SHT_DYNAMIC        = 6,          /* Dynamic linking information */
	SHT_NOTE           = 7,          /* Notes */
	SHT_NOBITS         = 8,          /* Program space with no data (bss) */
	SHT_REL            = 9,          /* Relocation entries, no addends */
	SHT_SHLIB          = 10,         /* Reserved */
	SHT_DYNSYM         = 11,         /* Dynamic linker symbol table */
	SHT_INIT_ARRAY     = 14,         /* Array of constructors */
	SHT_FINI_ARRAY     = 15,         /* Array of destructors */
	SHT_PREINIT_ARRAY  = 16,         /* Array of pre-constructors */
	SHT_GROUP          = 17,         /* Section group */
	SHT_SYMTAB_SHNDX   = 18,         /* Extended section indeces */
	SHT_NUM            = 19,         /* Number of defined types.  */
	SHT_LOOS           = 0x60000000, /* Start OS-specific.  */
	SHT_GNU_ATTRIBUTES = 0x6ffffff5, /* Object attributes.  */
	SHT_GNU_HASH       = 0x6ffffff6, /* GNU-style hash table.  */
	SHT_GNU_LIBLIST    = 0x6ffffff7, /* Prelink library list */
	SHT_CHECKSUM       = 0x6ffffff8, /* Checksum for DSO content.  */
	SHT_LOSUNW         = 0x6ffffffa, /* Sun-specific low bound.  */
	SHT_SUNW_move      = 0x6ffffffa,
	SHT_SUNW_COMDAT    = 0x6ffffffb,
	SHT_SUNW_syminfo   = 0x6ffffffc,
	SHT_GNU_verdef     = 0x6ffffffd, /* Version definition section.  */
	SHT_GNU_verneed    = 0x6ffffffe, /* Version needs section.  */
	SHT_GNU_versym     = 0x6fffffff, /* Version symbol table.  */
	SHT_HISUNW         = 0x6fffffff, /* Sun-specific high bound.  */
	SHT_HIOS           = 0x6fffffff, /* End OS-specific type */
	SHT_LOPROC         = 0x70000000, /* Start of processor-specific */
	SHT_HIPROC         = 0x7fffffff, /* End of processor-specific */
	SHT_LOUSER         = 0x80000000, /* Start of application-specific */
	SHT_HIUSER         = 0x8fffffff, /* End of application-specific */
};

/* Legal values for sh_flags (section flags).  */
enum {
	SHF_WRITE            = (1U << 0),  /* Writable */
	SHF_ALLOC            = (1U << 1),  /* Occupies memory during execution */
	SHF_EXECINSTR        = (1U << 2),  /* Executable */
	SHF_MERGE            = (1U << 4),  /* Might be merged */
	SHF_STRINGS          = (1U << 5),  /* Contains nul-terminated strings */
	SHF_INFO_LINK        = (1U << 6),  /* `sh_info' contains SHT index */
	SHF_LINK_ORDER       = (1U << 7),  /* Preserve order after combining */
	SHF_OS_NONCONFORMING = (1U << 8),  /* Non-standard OS specific handling required */
	SHF_GROUP            = (1U << 9),  /* Section is member of a group.  */
	SHF_TLS              = (1U << 10), /* Section hold thread-local data.  */
	SHF_MASKOS           = 0x0ff00000, /* OS-specific.  */
	SHF_MASKPROC         = 0xf0000000, /* Processor-specific */
	SHF_ORDERED          = (1U << 30), /* Special ordering requirement (Solaris).  */
	SHF_EXCLUDE          = (1U << 31), /* Section is excluded unless referenced or allocated (Solaris).*/
};

/* Section group handling.  */
enum {
	GRP_COMDAT = 0x1, /* Mark group as COMDAT.  */
};

#endif

```

`lib/libELF/include/libELF/elf_sym.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_SYM_H_20121007_
#define ELF_SYM_H_20121007_

#include "elf_types.h"

// Symbol table entry.

struct elf32_sym {
	elf32_word st_name;     // Symbol name (string tbl index)
	elf32_addr st_value;    // Symbol value
	elf32_word st_size;     // Symbol size
	uint8_t st_info;        // Symbol type and binding
	uint8_t st_other;       // Symbol visibility
	elf32_section st_shndx; // Section index
};

struct elf64_sym {
	elf64_word st_name;     // Symbol name (string tbl index)
	uint8_t st_info;        // Symbol type and binding
	uint8_t st_other;       // Symbol visibility
	elf64_section st_shndx; // Section index
	elf64_addr st_value;    // Symbol value
	elf64_xword st_size;    // Symbol size
};

#endif

```

`lib/libELF/include/libELF/elf_syminfo.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_SYMINFO_H_20121007_
#define ELF_SYMINFO_H_20121007_

#include "elf_types.h"

/* The syminfo section if available contains additional information about
   every dynamic symbol.  */

struct elf32_syminfo {
	elf32_half si_boundto; /* Direct bindings, symbol bound to */
	elf32_half si_flags;   /* Per symbol flags */
};

struct elf64_syminfo {
	elf64_half si_boundto; /* Direct bindings, symbol bound to */
	elf64_half si_flags;   /* Per symbol flags */
};

/* Possible values for si_boundto.  */
enum {
	SYMINFO_BT_SELF       = 0xffff, /* Symbol bound to self */
	SYMINFO_BT_PARENT     = 0xfffe, /* Symbol bound to parent */
	SYMINFO_BT_LOWRESERVE = 0xff00, /* Beginning of reserved entries */
};

/* Possible bitmasks for si_flags.  */
enum {
	SYMINFO_FLG_DIRECT   = 0x0001, /* Direct bound symbol */
	SYMINFO_FLG_PASSTHRU = 0x0002, /* Pass-thru symbol for translator */
	SYMINFO_FLG_COPY     = 0x0004, /* Symbol is a copy-reloc */
	SYMINFO_FLG_LAZYLOAD = 0x0008, /* Symbol bound to object to be lazy loaded */
};

/* Syminfo version values.  */
enum {
	SYMINFO_NONE    = 0,
	SYMINFO_CURRENT = 1,
	SYMINFO_NUM     = 2,
};

/* How to extract and insert information held in the st_info field.  */
template <class T>
constexpr auto ELF32_ST_BIND(T val) {
	return static_cast<uint8_t>(val) >> 4;
}

template <class T>
constexpr uint8_t ELF32_ST_TYPE(T val) {
	return val & 0xf;
}

template <class T1, class T2>
constexpr auto ELF32_ST_INFO(T1 bind, T2 type) {
	return (bind << 4) + (type & 0xf);
}

/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */
template <class T>
constexpr uint8_t ELF64_ST_BIND(T val) {
	return ELF32_ST_BIND(val);
}

template <class T>
constexpr uint8_t ELF64_ST_TYPE(T val) {
	return ELF32_ST_TYPE(val);
}

template <class T1, class T2>
constexpr auto ELF64_ST_INFO(T1 bind, T2 type) {
	return ELF32_ST_INFO(bind, type);
}

/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
enum {
	STB_LOCAL      = 0,  /* Local symbol */
	STB_GLOBAL     = 1,  /* Global symbol */
	STB_WEAK       = 2,  /* Weak symbol */
	STB_NUM        = 3,  /* Number of defined types.  */
	STB_LOOS       = 10, /* Start of OS-specific */
	STB_GNU_UNIQUE = 10, /* Unique symbol.  */
	STB_HIOS       = 12, /* End of OS-specific */
	STB_LOPROC     = 13, /* Start of processor-specific */
	STB_HIPROC     = 15, /* End of processor-specific */
};

/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
enum {
	STT_NOTYPE    = 0,  /* Symbol type is unspecified */
	STT_OBJECT    = 1,  /* Symbol is a data object */
	STT_FUNC      = 2,  /* Symbol is a code object */
	STT_SECTION   = 3,  /* Symbol associated with a section */
	STT_FILE      = 4,  /* Symbol's name is file name */
	STT_COMMON    = 5,  /* Symbol is a common data object */
	STT_TLS       = 6,  /* Symbol is thread-local data object*/
	STT_NUM       = 7,  /* Number of defined types.  */
	STT_LOOS      = 10, /* Start of OS-specific */
	STT_GNU_IFUNC = 10, /* Symbol is indirect code object */
	STT_HIOS      = 12, /* End of OS-specific */
	STT_LOPROC    = 13, /* Start of processor-specific */
	STT_HIPROC    = 15, /* End of processor-specific */
};

/* Symbol table indices are found in the hash buckets and chain table
   of a symbol hash table section.  This special index value indicates
   the end of a chain, meaning no further symbols are found in that bucket.  */
enum {
	STN_UNDEF = 0, /* End of a chain.  */
};

/* How to extract and insert information held in the st_other field.  */

template <class T>
constexpr T ELF32_ST_VISIBILITY(T o) {
	return ((o)&0x03);
}

/* For ELF64 the definitions are the same.  */
template <class T>
constexpr T ELF64_ST_VISIBILITY(T o) {
	return ELF32_ST_VISIBILITY(o);
}

/* Symbol visibility specification encoded in the st_other field.  */
enum {
	STV_DEFAULT   = 0, /* Default symbol visibility rules */
	STV_INTERNAL  = 1, /* Processor specific hidden class */
	STV_HIDDEN    = 2, /* Sym unavailable in other modules */
	STV_PROTECTED = 3, /* Not preemptible, not exported */
};

#endif

```

`lib/libELF/include/libELF/elf_types.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_TYPES_H_20121007_
#define ELF_TYPES_H_20121007_

#include <cstdint>

/* Type for a 16-bit quantity.  */
using elf32_half = uint16_t;
using elf64_half = uint16_t;

/* Types for signed and unsigned 32-bit quantities.  */
using elf32_word  = uint32_t;
using elf32_sword = int32_t;
using elf64_word  = uint32_t;
using elf64_sword = int32_t;

/* Types for signed and unsigned 64-bit quantities.  */
using elf32_xword  = uint64_t;
using elf32_sxword = int64_t;
using elf64_xword  = uint64_t;
using elf64_sxword = int64_t;

/* Type of addresses.  */
using elf32_addr = uint32_t;
using elf64_addr = uint64_t;

/* Type of file offsets.  */
using elf32_off = uint32_t;
using elf64_off = uint64_t;

/* Type for section indices, which are 16-bit quantities.  */
using elf32_section = uint16_t;
using elf64_section = uint16_t;

/* Type for version symbol information.  */
using elf32_versym = elf32_half;
using elf64_versym = elf64_half;

#endif

```

`lib/libELF/include/libELF/elf_verdaux.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_VERDAUX_H_20121007_
#define ELF_VERDAUX_H_20121007_

#include "elf_types.h"

/* Auxialiary version information.  */
struct elf32_verdaux {
	elf32_word vda_name; /* Version or dependency names */
	elf32_word vda_next; /* Offset in bytes to next verdaux entry */
};

struct elf64_verdaux {
	elf64_word vda_name; /* Version or dependency names */
	elf64_word vda_next; /* Offset in bytes to next verdaux entry */
};

#endif

```

`lib/libELF/include/libELF/elf_verdef.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_VERDEF_H_20121007_
#define ELF_VERDEF_H_20121007_

#include "elf_types.h"

/* Version definition sections.  */

struct elf32_verdef {
	elf32_half vd_version; /* Version revision */
	elf32_half vd_flags;   /* Version information */
	elf32_half vd_ndx;     /* Version Index */
	elf32_half vd_cnt;     /* Number of associated aux entries */
	elf32_word vd_hash;    /* Version name hash value */
	elf32_word vd_aux;     /* Offset in bytes to verdaux array */
	elf32_word vd_next;    /* Offset in bytes to next verdef entry */
};

struct elf64_verdef {
	elf64_half vd_version; /* Version revision */
	elf64_half vd_flags;   /* Version information */
	elf64_half vd_ndx;     /* Version Index */
	elf64_half vd_cnt;     /* Number of associated aux entries */
	elf64_word vd_hash;    /* Version name hash value */
	elf64_word vd_aux;     /* Offset in bytes to verdaux array */
	elf64_word vd_next;    /* Offset in bytes to next verdef entry */
};

/* Legal values for vd_version (version revision).  */
enum {
	VER_DEF_NONE    = 0, /* No version */
	VER_DEF_CURRENT = 1, /* Current version */
	VER_DEF_NUM     = 2  /* Given version number */
};

/* Legal values for vd_flags (version information flags).  */
enum {
	VER_FLG_BASE = 0x1, /* Version definition of file itself */
	VER_FLG_WEAK = 0x2  /* Weak version identifier */
};

/* Versym symbol index values.  */
enum {
	VER_NDX_LOCAL     = 0,      /* Symbol is local.  */
	VER_NDX_GLOBAL    = 1,      /* Symbol is global.  */
	VER_NDX_LORESERVE = 0xff00, /* Beginning of reserved entries.  */
	VER_NDX_ELIMINATE = 0xff01  /* Symbol is to be eliminated.  */
};

#endif

```

`lib/libELF/include/libELF/elf_vernaux.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_VERNAUX_H_20121007_
#define ELF_VERNAUX_H_20121007_

#include "elf_types.h"

/* Auxiliary needed version information.  */

struct elf32_vernaux {
	elf32_word vna_hash;  /* Hash value of dependency name */
	elf32_half vna_flags; /* Dependency specific information */
	elf32_half vna_other; /* Unused */
	elf32_word vna_name;  /* Dependency name string offset */
	elf32_word vna_next;  /* Offset in bytes to next vernaux entry */
};

struct elf64_vernaux {
	elf64_word vna_hash;  /* Hash value of dependency name */
	elf64_half vna_flags; /* Dependency specific information */
	elf64_half vna_other; /* Unused */
	elf64_word vna_name;  /* Dependency name string offset */
	elf64_word vna_next;  /* Offset in bytes to next vernaux entry */
};

/* Legal values for vna_flags.  */
#if 0
enum {
	VER_FLG_WEAK = 0x2 /* Weak version identifier */
};
#endif

#endif

```

`lib/libELF/include/libELF/elf_verneed.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010,2011
                   Free Software Foundation, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELF_VERNEED_H_20121007_
#define ELF_VERNEED_H_20121007_

#include "elf_types.h"

/* Version dependency section.  */
struct elf32_verneed {
	elf32_half vn_version; /* Version of structure */
	elf32_half vn_cnt;     /* Number of associated aux entries */
	elf32_word vn_file;    /* Offset of filename for this dependency */
	elf32_word vn_aux;     /* Offset in bytes to vernaux array */
	elf32_word vn_next;    /* Offset in bytes to next verneed entry */
};

struct elf64_verneed {
	elf64_half vn_version; /* Version of structure */
	elf64_half vn_cnt;     /* Number of associated aux entries */
	elf64_word vn_file;    /* Offset of filename for this dependency */
	elf64_word vn_aux;     /* Offset in bytes to vernaux array */
	elf64_word vn_next;    /* Offset in bytes to next verneed entry */
};

/* Legal values for vn_version (version revision).  */
enum {
	VER_NEED_NONE    = 0, /* No version */
	VER_NEED_CURRENT = 1, /* Current version */
	VER_NEED_NUM     = 2  /* Given version number */
};

#endif

```

`lib/libPE/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.1)

add_library(PE INTERFACE
)

target_include_directories(PE
	INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/include
)

target_sources(PE INTERFACE
	${CMAKE_CURRENT_SOURCE_DIR}/include/libPE/pe_binary.h

)


```

`lib/libPE/include/libPE/pe_binary.h`:

```h
/*
Copyright (C) 2012 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PE_BINARY_H_20121007_
#define PE_BINARY_H_20121007_

#include <stdint.h>

#ifdef WIN32
#include <Windows.h>
#else
using BYTE                                     = uint8_t;
using BOOLEAN                                  = uint8_t;
using SHORT                                    = int16_t;
using WORD                                     = uint16_t;
using USHORT                                   = uint16_t;
using INT                                      = int32_t;
using LONG                                     = int32_t;
using DWORD                                    = uint32_t;
using ULONG                                    = uint32_t;
using UINT                                     = uint32_t;
using ULONGLONG                                = uint64_t;
using LONGLONG                                 = int64_t;
constexpr int IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;
#endif

namespace libPE {

struct IMAGE_DOS_HEADER {
	WORD e_magic; // "MZ"
	WORD e_cblp;
	WORD e_cp;
	WORD e_crlc;
	WORD e_cparhdr;
	WORD e_minalloc;
	WORD e_maxalloc;
	WORD e_ss;
	WORD e_sp;
	WORD e_csum;
	WORD e_ip;
	WORD e_cs;
	WORD e_lfarlc;
	WORD e_ovno;
	WORD e_res[4];
	WORD e_oemid;
	WORD e_oeminfo;
	WORD e_res2[10];
	LONG e_lfanew;
};

struct IMAGE_DATA_DIRECTORY {
	DWORD VirtualAddress;
	DWORD Size;
};

struct IMAGE_OPTIONAL_HEADER64 {
	WORD Magic;
	BYTE MajorLinkerVersion;
	BYTE MinorLinkerVersion;
	DWORD SizeOfCode;
	DWORD SizeOfInitializedData;
	DWORD SizeOfUninitializedData;
	DWORD AddressOfEntryPoint;
	DWORD BaseOfCode;
	ULONGLONG ImageBase;
	DWORD SectionAlignment;
	DWORD FileAlignment;
	WORD MajorOperatingSystemVersion;
	WORD MinorOperatingSystemVersion;
	WORD MajorImageVersion;
	WORD MinorImageVersion;
	WORD MajorSubsystemVersion;
	WORD MinorSubsystemVersion;
	DWORD Win32VersionValue;
	DWORD SizeOfImage;
	DWORD SizeOfHeaders;
	DWORD CheckSum;
	WORD Subsystem;
	WORD DllCharacteristics;
	ULONGLONG SizeOfStackReserve;
	ULONGLONG SizeOfStackCommit;
	ULONGLONG SizeOfHeapReserve;
	ULONGLONG SizeOfHeapCommit;
	DWORD LoaderFlags;
	DWORD NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
};

struct IMAGE_OPTIONAL_HEADER32 {
	WORD Magic;
	BYTE MajorLinkerVersion;
	BYTE MinorLinkerVersion;
	DWORD SizeOfCode;
	DWORD SizeOfInitializedData;
	DWORD SizeOfUninitializedData;
	DWORD AddressOfEntryPoint;
	DWORD BaseOfCode;
	DWORD BaseOfData;
	DWORD ImageBase;
	DWORD SectionAlignment;
	DWORD FileAlignment;
	WORD MajorOperatingSystemVersion;
	WORD MinorOperatingSystemVersion;
	WORD MajorImageVersion;
	WORD MinorImageVersion;
	WORD MajorSubsystemVersion;
	WORD MinorSubsystemVersion;
	DWORD Win32VersionValue;
	DWORD SizeOfImage;
	DWORD SizeOfHeaders;
	DWORD CheckSum;
	WORD Subsystem;
	WORD DllCharacteristics;
	DWORD SizeOfStackReserve;
	DWORD SizeOfStackCommit;
	DWORD SizeOfHeapReserve;
	DWORD SizeOfHeapCommit;
	DWORD LoaderFlags;
	DWORD NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
};

struct IMAGE_FILE_HEADER {
	WORD Machine;
	WORD NumberOfSections;
	DWORD TimeDateStamp;
	DWORD PointerToSymbolTable;
	DWORD NumberOfSymbols;
	WORD SizeOfOptionalHeader;
	WORD Characteristics;
};

struct IMAGE_NT_HEADERS32 {
	DWORD Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

struct IMAGE_NT_HEADERS64 {
	DWORD Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
};

}

#endif

```

`pkg/deb/create-deb-qt5.sh`:

```sh
#!/bin/bash

SOURCE_DIR=$PWD/../../
TEMP_DIR=$(mktemp -d)
BUILD_DIR=$TEMP_DIR/build
DEB_DIR=$BUILD_DIR/deb

trap "rm -rf $TEMP_DIR" EXIT

# Build edb
mkdir -p $BUILD_DIR
pushd $BUILD_DIR
cmake $SOURCE_DIR
if ! make -j8; then
	echo "Compiling error. Exiting..."
	exit 1
fi

# Install it into a temp directory
make DESTDIR=$DEB_DIR install

# Getting Arch
if [ $(uname -m) == "x86_64" ]; then
	ARCH="amd64"
else
	ARCH="i386"
fi

INSTALL_SIZE=$(du -b -s $DEB_DIR | cut -f1)
VERSION=$($BUILD_DIR/edb --dump-version 2> /dev/null)

#TODO(eteran): figure out the proper deps for Qt5 on Ubuntu/Debian
DEPENDS="libqt5core5a (>= 5.0.0), libqt5gui5 (>= 5.0.0), libcapstone3"

# Create the meta-data dir
mkdir -p $DEB_DIR/DEBIAN

# MD5s 
# TODO(eteran): do we need to get rid of the prefix on the files here?
find $DEB_DIR -type f | xargs md5sum > $DEB_DIR/DEBIAN/md5sums

# Generating Debian control file
echo "Package: edb-debugger-qt5
Version: $VERSION
Architecture: $ARCH
Maintainer: Evan Teran
Homepage: http://www.codef00.com
Installed-Size: $INSTALL_SIZE
Depends: $DEPENDS
Provides: edb
Section: devel
Priority: extra
Description: Graphical debugger and disassembler for ELF binaries
 EDB (Evan's Debugger) is a modular and modern disassembler and debugger for
 binary ELF files based on ptrace API and the capstone disassembly library. 
 EDB is very similar to OllyDbg, a famous freeware debugger for PE 
 (Portable Executable) files. The intent of EDB is to debug binaries without 
 source code. It's possible to set conditional and inconditional breakpoints, 
 display memory stack, processor registers state and more. The power of EDB can 
 be increased with many plugins." > $DEB_DIR/DEBIAN/control

# Generate package
dpkg-deb -b $DEB_DIR $SOURCE_DIR/edb-debugger-qt5_${VERSION}_${ARCH}.deb

```

`pkg/fedora/edb.spec`:

```spec
Name:           edb
Version:        1.3.0
Release:        2%{?dist}
Summary:        A debugger based on the ptrace API and Qt

License:        GPLv2+
URL:            https://github.com/eteran/edb-debugger
Source0:        https://github.com/eteran/edb-debugger/releases/download/%{version}/edb-debugger-%{version}.tgz

BuildRequires:  gcc-c++
BuildRequires:  desktop-file-utils
BuildRequires:  libappstream-glib
BuildRequires:  qt5-qtbase-devel
BuildRequires:  qt5-qtsvg
BuildRequires:  qt5-qtsvg-devel
BuildRequires:  qt5-qtxmlpatterns
BuildRequires:  qt5-qtxmlpatterns-devel
BuildRequires:  cmake
BuildRequires:  boost-devel
BuildRequires:  capstone-devel

# as edb is an x86 debugger
ExclusiveArch:  %{ix86} x86_64

%description
edb a debugger based on the ptrace API.

One of the main goals of this debugger is modularity.
The interface is written in Qt and thus source portable to many platforms.
The debugger core is a plugin and the platform specific code is isolated
to just a few files, porting to a new OS would require porting these few
files and implementing a plugin which implements the 
DebuggerCoreInterface interface. Also, because the plugins are based
on the QPlugin API, and do their work through the DebuggerCoreInterface
object, they are almost always portable with just a simple recompile.


%prep
%autosetup -n edb-debugger -p1

%build
%cmake .
make -C %{__cmake_builddir} %{?_smp_mflags}


%install
make -C %{__cmake_builddir} install DESTDIR=%{buildroot}
desktop-file-validate %{buildroot}/%{_datadir}/applications/%{name}.desktop

#install appdata file
mkdir -p %{buildroot}%{_datadir}/metainfo/
install -m 644 %{name}.appdata.xml %{buildroot}%{_datadir}/metainfo/
appstream-util validate-relax --nonet %{buildroot}%{_datadir}/metainfo/%{name}.appdata.xml

%files
%doc CHANGELOG COPYING README.md TODO
%{_bindir}/%{name}
%{_libdir}/%{name}
%{_datadir}/metainfo/%{name}.appdata.xml
%{_datadir}/applications/%{name}.desktop
%{_datadir}/pixmaps/%{name}.png
%{_mandir}/man1/%{name}.1*

%changelog
* Sun Dec 12 2021 Pekka Oinas <peoinas@gmail.com> - 1.3.0-2
- Fix building on Fedora 35

* Sun Apr 11 2021 Pekka Oinas <peoinas@gmail.com> - 1.3.0-1
- Updated to new version

* Tue Jan 28 2020 Fedora Release Engineering <releng@fedoraproject.org> - 0.9.21-5
- Rebuilt for https://fedoraproject.org/wiki/Fedora_32_Mass_Rebuild

* Wed Jul 24 2019 Fedora Release Engineering <releng@fedoraproject.org> - 0.9.21-4
- Rebuilt for https://fedoraproject.org/wiki/Fedora_31_Mass_Rebuild

* Thu Jan 31 2019 Fedora Release Engineering <releng@fedoraproject.org> - 0.9.21-3
- Rebuilt for https://fedoraproject.org/wiki/Fedora_30_Mass_Rebuild

* Thu Jul 12 2018 Fedora Release Engineering <releng@fedoraproject.org> - 0.9.21-2
- Rebuilt for https://fedoraproject.org/wiki/Fedora_29_Mass_Rebuild

* Fri Feb 16 2018 Michael Cullen <mich181189@fedoraproject.org> - 0.9.21-1
- Added GraphViz dependency for added functionality
- Updated to new version
- Changed to use Qt5 instead of Qt4
* Wed Feb 07 2018 Fedora Release Engineering <releng@fedoraproject.org> - 0.9.18-24
- Rebuilt for https://fedoraproject.org/wiki/Fedora_28_Mass_Rebuild

* Wed Aug 02 2017 Fedora Release Engineering <releng@fedoraproject.org> - 0.9.18-23
- Rebuilt for https://fedoraproject.org/wiki/Fedora_27_Binutils_Mass_Rebuild

* Wed Jul 26 2017 Fedora Release Engineering <releng@fedoraproject.org> - 0.9.18-22
- Rebuilt for https://fedoraproject.org/wiki/Fedora_27_Mass_Rebuild

* Sun Jun 18 2017 Filipe Rosset <rosset.filipe@gmail.com> - 0.9.18-21
- Spec cleanup

* Fri Feb 10 2017 Fedora Release Engineering <releng@fedoraproject.org> - 0.9.18-20
- Rebuilt for https://fedoraproject.org/wiki/Fedora_26_Mass_Rebuild

* Wed Feb 03 2016 Fedora Release Engineering <releng@fedoraproject.org> - 0.9.18-19
- Rebuilt for https://fedoraproject.org/wiki/Fedora_24_Mass_Rebuild

* Tue Feb 02 2016 Rex Dieter <rdieter@fedoraproject.org> - 0.9.18-18
- use %%qmake_qt4 macro to ensure proper build flags

* Thu Aug 27 2015 Jonathan Wakely <jwakely@redhat.com> - 0.9.18-17
- Rebuilt for Boost 1.59

* Wed Jul 29 2015 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0.9.18-16
- Rebuilt for https://fedoraproject.org/wiki/Changes/F23Boost159

* Wed Jul 22 2015 David Tardon <dtardon@redhat.com> - 0.9.18-15
- rebuild for Boost 1.58

* Wed Jun 17 2015 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0.9.18-14
- Rebuilt for https://fedoraproject.org/wiki/Fedora_23_Mass_Rebuild

* Sat May 02 2015 Kalev Lember <kalevlember@gmail.com> - 0.9.18-13
- Rebuilt for GCC 5 C++11 ABI change

* Thu Mar 26 2015 Richard Hughes <rhughes@redhat.com> - 0.9.18-12
- Add an AppData file for the software center

* Mon Jan 26 2015 Petr Machata <pmachata@redhat.com> - 0.9.18-11
- Rebuild for boost 1.57.0

* Sat Aug 16 2014 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0.9.18-10
- Rebuilt for https://fedoraproject.org/wiki/Fedora_21_22_Mass_Rebuild

* Sat Jun 07 2014 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0.9.18-9
- Rebuilt for https://fedoraproject.org/wiki/Fedora_21_Mass_Rebuild

* Thu May 22 2014 Petr Machata <pmachata@redhat.com> - 0.9.18-8
- Rebuild for boost 1.54.0

* Sat Aug 03 2013 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0.9.18-7
- Rebuilt for https://fedoraproject.org/wiki/Fedora_20_Mass_Rebuild

* Tue Jul 30 2013 Petr Machata <pmachata@redhat.com> - 0.9.18-6
- Rebuild for boost 1.54.0

* Wed Feb 13 2013 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0.9.18-5
- Rebuilt for https://fedoraproject.org/wiki/Fedora_19_Mass_Rebuild

* Wed Jul 18 2012 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0.9.18-4
- Rebuilt for https://fedoraproject.org/wiki/Fedora_18_Mass_Rebuild

* Tue Feb 28 2012 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0.9.18-3
- Rebuilt for c++ ABI breakage

* Fri Jan 13 2012 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0.9.18-2
- Rebuilt for https://fedoraproject.org/wiki/Fedora_17_Mass_Rebuild

* Sun Jan  1 2012 Nicoleau Fabien <nicoleau.fabien@gmail.com> - 0.9.18-1
- Update to 0.9.18 
* Sat Apr 23 2011 Nicoleau Fabien <nicoleau.fabien@gmail.com> - 0.9.17-1
- Update to 0.9.17
* Tue Feb 08 2011 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0.9.16-3
- Rebuilt for https://fedoraproject.org/wiki/Fedora_15_Mass_Rebuild
* Sun Nov  7 2010 Dan Horák <dan[at]danny.cz> - 0.9.16-2
- switch to ExclusiveArch
* Thu Oct 28 2010 Nicoleau Fabien <nicoleau.fabien@gmail.com> - 0.9.16-1
- Update to 0.9.16 
* Wed Jun  2 2010 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.15-1
- Update to 0.9.15
* Sat Feb 27 2010 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.13-1
- Update to 0.9.13
* Thu Feb 18 2010 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.12-1
- Update to 0.9.12
* Tue Jan 12 2010 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.11-1
- Update to 0.9.11
* Fri Jul 24 2009 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0.9.10-2
- Rebuilt for https://fedoraproject.org/wiki/Fedora_12_Mass_Rebuild
* Sat Jul 11 2009 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.10-1
- Rebuild for 0.9.10
* Wed May 27 2009 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.9-1
- Rebuild for 0.9.9
* Wed Apr 22 2009 Kedar Sovani <kedars@marvell.com> 0.9.8-2
- ExcludeArch ARM
* Sat Apr  4 2009 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.8-1
- Rebuild for 0.9.8
* Tue Mar 17 2009 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.7-1
- Rebuild for 0.9.7
* Tue Feb 24 2009 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0.9.6-3
- Rebuilt for https://fedoraproject.org/wiki/Fedora_11_Mass_Rebuild
- added an include
* Sun Nov 23 2008 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.6-2
- Licence fix
- Add desktop file
- Removed separate plugin package
* Sun Nov 16 2008 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.6-1
- Rebuild for 0.9.6
* Mon Sep 29 2008 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.5-1
- rebuild for 0.9.5
* Wed Aug 13 2008 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.4-1
- rebuild for 0.9.4
* Sat Aug  9 2008 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.3-1
* rebuild for 0.9.3
* Thu Jul 31 2008 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.2-1
- rebuild for 0.9.2
* Mon Jul 28 2008 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.1-1
- Rebuild for 0.9.1
* Mon Jul 21 2008 Nicoleau Fabien <nicoleau.fabien@gmail.com> 0.9.0-1
- Initital build

```

`plugins/Analyzer/Analyzer.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Analyzer.h"
#include "AnalyzerWidget.h"
#include "Configuration.h"
#include "DialogXRefs.h"
#include "Function.h"
#include "IBinary.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "ISymbolManager.h"
#include "IThread.h"
#include "Instruction.h"
#include "MemoryRegions.h"
#include "OptionsPage.h"
#include "Prototype.h"
#include "SpecifiedFunctions.h"
#include "State.h"
#include "edb.h"
#include "util/Math.h"

#include <QCoreApplication>
#include <QDir>
#include <QElapsedTimer>
#include <QFileInfo>
#include <QHash>
#include <QMainWindow>
#include <QMenu>
#include <QMessageBox>
#include <QProgressDialog>
#include <QSettings>
#include <QStack>
#include <QToolBar>
#include <QtDebug>

#include <cstring>
#include <functional>

namespace AnalyzerPlugin {

namespace {

constexpr int MinRefCount = 2;
/**
 * @brief will_return
 * @param address
 * @return
 */
bool will_return(edb::address_t address) {

	const std::shared_ptr<Symbol> symbol = edb::v1::symbol_manager().find(address);
	if (symbol) {
		const QString symname   = symbol->name_no_prefix;
		const QString func_name = symname.mid(0, symname.indexOf("@"));

		if (const edb::Prototype *const info = edb::v1::get_function_info(func_name)) {
			if (info->noreturn) {
				return false;
			}
		}
	}

	return true;
}

/**
 * @brief is_entrypoint
 * @param sym
 * @return
 */
bool is_entrypoint(const Symbol &sym) {
#ifdef Q_OS_UNIX
	return sym.name_no_prefix == "_start";
#else
	return false;
#endif
}

/**
 * @brief is_thunk
 * @param address
 * @return true if the first instruction of the function is a jmp
 */
bool is_thunk(edb::address_t address) {

	uint8_t buf[edb::Instruction::MaxSize];
	if (const int buf_size = edb::v1::get_instruction_bytes(address, buf)) {
		const edb::Instruction inst(buf, buf + buf_size, address);
		return is_unconditional_jump(inst);
	}

	return false;
}

/**
 * @brief set_function_types
 * @param results
 */
void set_function_types(IAnalyzer::FunctionMap *results) {

	Q_ASSERT(results);

	// give bonus if we have a symbol for the address
	std::for_each(results->begin(), results->end(), [](Function &function) {
		if (is_thunk(function.entryAddress())) {
			function.setType(Function::Thunk);
		} else {
			function.setType(Function::Standard);
		}
	});
}

/**
 * @brief module_entry_point
 * @param region
 * @return
 */
edb::address_t module_entry_point(const std::shared_ptr<IRegion> &region) {
	if (std::unique_ptr<IBinary> binary_info = edb::v1::get_binary_info(region)) {
		return binary_info->entryPoint();
	}

	return 0;
}

}

/**
 * @brief Analyzer::Analyzer
 * @param parent
 */
Analyzer::Analyzer(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief Analyzer::optionsPage
 * @return
 */
QWidget *Analyzer::optionsPage() {
	return new OptionsPage;
}

/**
 * @brief Analyzer::menu
 * @param parent
 * @return
 */
QMenu *Analyzer::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("Analyzer"), parent);
		menu_->addAction(tr("Show &Specified Functions"), this, SLOT(showSpecified()));

		if (edb::v1::debugger_core) {
			menu_->addAction(tr("&Analyze %1's Region").arg(edb::v1::debugger_core->instructionPointer().toUpper()), this, SLOT(doIpAnalysis()), QKeySequence(tr("Ctrl+A")));
		}

		menu_->addAction(tr("&Analyze Viewed Region"), this, SLOT(doViewAnalysis()), QKeySequence(tr("Ctrl+Shift+A")));

		// if we are dealing with a main window (and we are...)
		// add the dock object
		if (auto main_window = qobject_cast<QMainWindow *>(edb::v1::debugger_ui)) {
			analyzerWidget_ = new AnalyzerWidget;

			// make the toolbar widget and _name_ it, it is important to name it so
			// that it's state is saved in the GUI info
			auto toolbar = new QToolBar(tr("Region Analysis"), main_window);
			toolbar->setAllowedAreas(Qt::TopToolBarArea | Qt::BottomToolBarArea);
			toolbar->setObjectName(QString::fromUtf8("Region Analysis"));
			toolbar->addWidget(analyzerWidget_);

			// add it to the dock
			main_window->addToolBar(Qt::TopToolBarArea, toolbar);

			// make the menu and add the show/hide toggle for the widget
			menu_->addAction(toolbar->toggleViewAction());
		}
	}

	return menu_;
}

/**
 * @brief Analyzer::privateInit
 */
void Analyzer::privateInit() {
	edb::v1::set_analyzer(this);
}

/**
 * @brief Analyzer::showSpecified
 */
void Analyzer::showSpecified() {
	static auto dialog = new SpecifiedFunctions(edb::v1::debugger_ui);
	dialog->show();
}

/**
 * @brief Analyzer::doIpAnalysis
 */
void Analyzer::doIpAnalysis() {
	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			State state;
			thread->getState(&state);

			const edb::address_t address = state.instructionPointer();
			if (std::shared_ptr<IRegion> region = edb::v1::memory_regions().findRegion(address)) {
				doAnalysis(region);
			}
		}
	}
}

/**
 * @brief Analyzer::doViewAnalysis
 */
void Analyzer::doViewAnalysis() {
	doAnalysis(edb::v1::current_cpu_view_region());
}

/**
 * @brief Analyzer::markFunctionStart
 */
void Analyzer::markFunctionStart() {

	const edb::address_t address = edb::v1::cpu_selected_address();
	if (std::shared_ptr<IRegion> region = edb::v1::memory_regions().findRegion(address)) {
		qDebug("Added %s to the list of known functions", qPrintable(address.toPointerString()));
		specifiedFunctions_.insert(address);
		invalidateDynamicAnalysis(region);
	}
}

/**
 * @brief Analyzer::showXrefs
 */
void Analyzer::showXrefs() {

	const edb::address_t address = edb::v1::cpu_selected_address();

	auto dialog = new DialogXRefs(edb::v1::debugger_ui);

	for (const RegionData &data : analysisInfo_) {
		for (const BasicBlock &bb : data.basicBlocks) {
			const std::vector<std::pair<edb::address_t, edb::address_t>> refs = bb.references();

			for (auto it = refs.begin(); it != refs.end(); ++it) {
				if (it->second == address) {
					dialog->addReference(*it);
				}
			}
		}
	}

	dialog->setWindowTitle(tr("X-Refs For %1").arg(address.toPointerString()));
	dialog->show();
}
/**
 * @brief Analyzer::gotoFunctionStart
 */
void Analyzer::gotoFunctionStart() {

	const edb::address_t address = edb::v1::cpu_selected_address();

	Function function;
	if (findContainingFunction(address, &function)) {
		edb::v1::jump_to_address(function.entryAddress());
		return;
	}

	QMessageBox::critical(
		nullptr,
		tr("Goto Function Start"),
		tr("The selected instruction is not inside of a known function. Have you run an analysis of this region?"));
}

/**
 * @brief Analyzer::gotoFunctionEnd
 */
void Analyzer::gotoFunctionEnd() {

	const edb::address_t address = edb::v1::cpu_selected_address();

	Function function;
	if (findContainingFunction(address, &function)) {
		edb::v1::jump_to_address(function.lastInstruction());
		return;
	}

	QMessageBox::critical(
		nullptr,
		tr("Goto Function End"),
		tr("The selected instruction is not inside of a known function. Have you run an analysis of this region?"));
}
/**
 * @brief Analyzer::cpuContextMenu
 * @return
 */
QList<QAction *> Analyzer::cpuContextMenu() {

	QList<QAction *> ret;

	auto action_find                = new QAction(tr("Analyze Here"), this);
	auto action_goto_function_start = new QAction(tr("Goto Function Start"), this);
	auto action_goto_function_end   = new QAction(tr("Goto Function End"), this);
	auto action_mark_function_start = new QAction(tr("Mark As Function Start"), this);
	auto action_xrefs               = new QAction(tr("Show X-Refs"), this);

	connect(action_find, &QAction::triggered, this, &Analyzer::doViewAnalysis);
	connect(action_goto_function_start, &QAction::triggered, this, &Analyzer::gotoFunctionStart);
	connect(action_goto_function_end, &QAction::triggered, this, &Analyzer::gotoFunctionEnd);
	connect(action_mark_function_start, &QAction::triggered, this, &Analyzer::markFunctionStart);
	connect(action_xrefs, &QAction::triggered, this, &Analyzer::showXrefs);

	ret << action_find << action_goto_function_start << action_goto_function_end << action_mark_function_start << action_xrefs;

	return ret;
}

/**
 * @brief Analyzer::doAnalysis
 * @param region
 */
void Analyzer::doAnalysis(const std::shared_ptr<IRegion> &region) {
	if (region && region->size() != 0) {
		QProgressDialog progress(tr("Performing Analysis"), nullptr, 0, 100, edb::v1::debugger_ui);
		connect(this, &Analyzer::updateProgress, &progress, &QProgressDialog::setValue);
		progress.show();
		progress.setValue(0);
		analyze(region);
		edb::v1::repaint_cpu_view();
	}
}

/**
 * @brief Analyzer::bonusMain
 * @param data
 */
void Analyzer::bonusMain(RegionData *data) const {

	Q_ASSERT(data);

	const QString s = edb::v1::debugger_core->process()->executable();
	if (!s.isEmpty()) {
		if (const edb::address_t main = edb::v1::locate_main_function()) {
			if (data->region->contains(main)) {
				data->knownFunctions.insert(main);
			}
		}
	}
}

/**
 * @brief Analyzer::bonusSymbols
 * @param data
 */
void Analyzer::bonusSymbols(RegionData *data) {

	Q_ASSERT(data);

	// give bonus if we have a symbol for the address
	const std::vector<std::shared_ptr<Symbol>> symbols = edb::v1::symbol_manager().symbols();

	for (const std::shared_ptr<Symbol> &sym : symbols) {
		const edb::address_t addr = sym->address;

		// NOTE(eteran): we special case the module entry point because while we bonus the
		// application's entry point in bonusEntryPoint, each module can have one which
		// is called on load by the linker, including the linker itself! And unfortunately
		// at least on some systems, it is a data symbol, not a code symbol
		if (data->region->contains(addr) && (sym->isCode() || is_entrypoint(*sym))) {
			qDebug("[Analyzer] adding: %s <%s>", qPrintable(sym->name), qPrintable(addr.toPointerString()));
			data->knownFunctions.insert(addr);
		}
	}
}

/**
 * @brief Analyzer::bonusMarkedFunctions
 * @param data
 */
void Analyzer::bonusMarkedFunctions(RegionData *data) {

	Q_ASSERT(data);

	Q_FOREACH (const edb::address_t addr, specifiedFunctions_) {
		if (data->region->contains(addr)) {
			qDebug("[Analyzer] adding user marked function: <%s>", qPrintable(addr.toPointerString()));
			data->knownFunctions.insert(addr);
		}
	}
}

/**
 * @brief Analyzer::identHeader
 * @param data
 */
void Analyzer::identHeader(Analyzer::RegionData *data) {
	Q_UNUSED(data)
}

/**
 * @brief Analyzer::collectFunctions
 * @param data
 */
void Analyzer::collectFunctions(Analyzer::RegionData *data) {
	Q_ASSERT(data);

	// results
	QHash<edb::address_t, BasicBlock> basic_blocks;
	FunctionMap functions;

	// push all known functions onto a stack
	QStack<edb::address_t> known_functions;
	Q_FOREACH (const edb::address_t function, data->knownFunctions) {
		known_functions.push(function);
	}

	// push all fuzzy function too...
	Q_FOREACH (const edb::address_t function, data->fuzzyFunctions) {
		known_functions.push(function);
	}

	// process all functions that are known
	while (!known_functions.empty()) {
		const edb::address_t function_address = known_functions.pop();

		if (!functions.contains(function_address)) {

			QStack<edb::address_t> blocks;
			blocks.push(function_address);

			Function func;

			// process are basic blocks that are known
			while (!blocks.empty()) {

				const edb::address_t block_address = blocks.pop();
				edb::address_t address             = block_address;
				BasicBlock block;

				if (!basic_blocks.contains(block_address)) {
					while (data->region->contains(address)) {

						uint8_t buffer[edb::Instruction::MaxSize];
						const int buf_size = edb::v1::get_instruction_bytes(address, buffer);
						if (buf_size == 0) {
							break;
						}

						auto inst = std::make_shared<edb::Instruction>(buffer, buffer + buf_size, address);
						if (!inst->valid()) {
							break;
						}

						block.push_back(inst);

						if (is_call(*inst)) {

							// note the destination and move on
							// we special case some simple things.
							// also this is an opportunity to find call tables.
							const edb::Operand op = inst->operand(0);
							if (is_immediate(op)) {
								const edb::address_t ea = op->imm;

								// skip over ones which are: "call <label>; label:"
								if (ea != address + inst->byteSize()) {
									known_functions.push(ea);

									if (!will_return(ea)) {
										break;
									}

									block.addReference(address, ea);
								}
							} else if (is_expression(op)) {
								// looks like: "call [...]", if it is of the form, call [C + REG]
								// then it may be a jump table using REG as an offset
							} else if (is_register(op)) {
								// looks like: "call <reg>", this is this may be a callback
								// if we can use analysis to determine that it's a constant
								// we can figure it out...
								// eventually, we should figure out the parameters of the function
								// to see if we can know what the target is
							}

						} else if (is_unconditional_jump(*inst)) {

							Q_ASSERT(inst->operandCount() >= 1);
							const edb::Operand op = inst->operand(0);

							// TODO(eteran): we need some heuristic for detecting when this is
							//               a call/ret -> jmp optimization
							if (is_immediate(op)) {
								const edb::address_t ea = op->imm;

								if (functions.contains(ea)) {
									functions[ea].addReference();
								} else if ((ea - function_address) > 0x2000u) {
									known_functions.push(ea);
								} else {
									blocks.push(ea);
								}

								block.addReference(address, ea);
							}
							break;
						} else if (is_conditional_jump(*inst)) {

							Q_ASSERT(inst->operandCount() == 1);
							const edb::Operand op = inst->operand(0);

							if (is_immediate(op)) {

								const edb::address_t ea = op->imm;

								blocks.push(ea);
								blocks.push(address + inst->byteSize());

								block.addReference(address, ea);
							}
							break;
						} else if (is_terminator(*inst)) {
							break;
						}

						address += inst->byteSize();
					}

					if (!block.empty()) {
						basic_blocks.insert(block_address, block);

						if (block_address >= function_address) {
							func.insert(block);
						}
					}
				}
			}

			if (!func.empty()) {
				functions.insert(function_address, func);
			}
		} else {
			functions[function_address].addReference();
		}
	}

	std::swap(data->basicBlocks, basic_blocks);
	std::swap(data->functions, functions);
}

/**
 * @brief Analyzer::collectFuzzyFunctions
 * @param data
 */
void Analyzer::collectFuzzyFunctions(RegionData *data) {
	Q_ASSERT(data);

	data->fuzzyFunctions.clear();

	if (data->fuzzy) {

		QHash<edb::address_t, int> fuzzy_functions;

		uint8_t *const first = &data->memory[0];
		uint8_t *const last  = &first[data->memory.size()];

		uint8_t *p = first;

		// fuzzy_functions, known_functions
		for (edb::address_t addr = data->region->start(); addr != data->region->end(); ++addr) {
			if (auto inst = edb::Instruction(p, last, addr)) {
				if (is_call(inst)) {

					// note the destination and move on
					// we special case some simple things.
					// also this is an opportunity to find call tables.
					const edb::Operand op = inst[0];
					if (is_immediate(op)) {
						const edb::address_t ea = op->imm;

						// skip over ones which are: "call <label>; label:"
						if (ea != addr + inst.byteSize()) {

							if (!data->knownFunctions.contains(ea)) {
								fuzzy_functions[ea]++;
							}
						}
					}
				}
			}
			++p;
		}

		// transfer results to data->fuzzy_functions
		for (auto it = fuzzy_functions.begin(); it != fuzzy_functions.end(); ++it) {
			if (it.value() > MinRefCount) {
				data->fuzzyFunctions.insert(it.key());
			}
		}
	}
}

/**
 * @brief Analyzer::analyze
 * @param region
 */
void Analyzer::analyze(const std::shared_ptr<IRegion> &region) {

	QElapsedTimer t;
	t.start();

	RegionData &region_data = analysisInfo_[region->start()];
	qDebug() << "[Analyzer] Region name:" << region->name();

	QSettings settings;
	const bool fuzzy = settings.value("Analyzer/fuzzy_logic_functions.enabled", true).toBool();

	const size_t page_size  = edb::v1::debugger_core->pageSize();
	const size_t page_count = region->size() / page_size;

	QVector<uint8_t> memory = edb::v1::read_pages(region->start(), page_count);

	const QByteArray md5      = (!memory.isEmpty()) ? edb::v1::get_md5(memory) : QByteArray();
	const QByteArray prev_md5 = region_data.md5;

	if (md5 != prev_md5 || fuzzy != region_data.fuzzy) {

		region_data.basicBlocks.clear();
		region_data.functions.clear();
		region_data.fuzzyFunctions.clear();
		region_data.knownFunctions.clear();

		region_data.memory = memory;
		region_data.region = region;
		region_data.md5    = md5;
		region_data.fuzzy  = fuzzy;

		const struct {
			const char *message;
			std::function<void()> function;
		} analysis_steps[] = {
			{"identifying executable headers...", [this, &region_data]() { identHeader(&region_data); }},
			{"adding entry points to the list...", [this, &region_data]() { bonusEntryPoint(&region_data); }},
			{"attempting to add 'main' to the list...", [this, &region_data]() { bonusMain(&region_data); }},
			{"attempting to add functions with symbols to the list...", [this, &region_data]() { bonusSymbols(&region_data); }},
			{"attempting to add marked functions to the list...", [this, &region_data]() { bonusMarkedFunctions(&region_data); }},
			{"attempting to collect functions with fuzzy analysis...", [this, &region_data]() { collectFuzzyFunctions(&region_data); }},
			{"collecting basic blocks...", [this, &region_data]() { collectFunctions(&region_data); }},
		};

		const int total_steps = sizeof(analysis_steps) / sizeof(analysis_steps[0]);

		Q_EMIT updateProgress(util::percentage(0, total_steps));
		for (int i = 0; i < total_steps; ++i) {
			qDebug("[Analyzer] %s", analysis_steps[i].message);
			analysis_steps[i].function();
			Q_EMIT updateProgress(util::percentage(i + 1, total_steps));
		}

		qDebug("[Analyzer] determining function types...");

		set_function_types(&region_data.functions);

		qDebug("[Analyzer] complete");
		Q_EMIT updateProgress(100);

		if (analyzerWidget_) {
			analyzerWidget_->update();
		}

	} else {
		qDebug("[Analyzer] region unchanged, using previous analysis");
	}

	qDebug("[Analyzer] elapsed: %lld ms", t.elapsed());
}

/**
 * @brief Analyzer::category
 * @param address
 * @return
 */
IAnalyzer::AddressCategory Analyzer::category(edb::address_t address) const {

	Function func;
	if (findContainingFunction(address, &func)) {
		if (address == func.entryAddress()) {
			return ADDRESS_FUNC_START;
		} else if (address == func.endAddress()) {
			return ADDRESS_FUNC_END;
		} else {
			return ADDRESS_FUNC_BODY;
		}
	}
	return ADDRESS_FUNC_UNKNOWN;
}

/**
 * @brief Analyzer::functions
 * @param region
 * @return
 */
IAnalyzer::FunctionMap Analyzer::functions(const std::shared_ptr<IRegion> &region) const {
	return analysisInfo_[region->start()].functions;
}

/**
 * @brief Analyzer::functions
 * @return
 */
IAnalyzer::FunctionMap Analyzer::functions() const {
	FunctionMap results;
	for (auto &it : analysisInfo_) {
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
		results.insert(it.functions);
#else
		results.unite(it.functions);
#endif
	}
	return results;
}

/**
 * @brief Analyzer::findContainingFunction
 * @param address
 * @param function
 * @return
 */
bool Analyzer::findContainingFunction(edb::address_t address, Function *function) const {

	Q_ASSERT(function);

	if (std::shared_ptr<IRegion> region = edb::v1::memory_regions().findRegion(address)) {
		const FunctionMap &funcs = functions(region);

		// upperBound returns the first item that is >= address here, or end().
		// Note the ">", it does not do the opposite of lowerBound!
		auto iter = funcs.upperBound(address);
		if (iter == funcs.end()) {
			return false;
		}

		// handle address == entrypoint case
		if ((*iter).entryAddress() == address) {
			*function = *iter;
			return true;
		}

		// go to previous function and test it
		if (iter == funcs.begin()) {
			return false;
		}

		const Function &func = *(--iter);
		if (address >= func.entryAddress() && address <= func.endAddress()) {
			*function = func;
			return true;
		}
	}
	return false;
}

/**
 * @brief Analyzer::forFuncsInRange
 *
 * Calls functor once for every function that exists between the start and end
 * addresses. This includes functions whose bodies include the start address.
 * start and end must reside in the same region. If the functor returns false,
 * iteration is halted.
 *
 * @param start
 * @param end
 * @param functor
 * @return true if all functions were iterated,
 * false if the iteration was halted early.
 */
bool Analyzer::forFuncsInRange(edb::address_t start, edb::address_t end, std::function<bool(const Function *)> functor) const {
	if (std::shared_ptr<IRegion> region = edb::v1::memory_regions().findRegion(start)) {
		const FunctionMap &funcs = functions(region);
		auto it                  = funcs.lowerBound(start - 4096);

		while (it != funcs.end()) {
			edb::address_t f_start = it->entryAddress();
			edb::address_t f_end   = it->endAddress();

			// Only works if FunctionMap is a QMap
			if (f_start > end) {
				return true;
			}
			// ranges overlap: http://stackoverflow.com/a/3269471
			if (f_start <= end && start <= f_end) {
				if (!functor(&(*it))) {
					return false;
				}
			}

			++it;
		}
	}
	return true;
}

/**
 * @brief Analyzer::bonusEntryPoint
 * @param data
 */
void Analyzer::bonusEntryPoint(RegionData *data) const {

	Q_ASSERT(data);

	if (edb::address_t entry = module_entry_point(data->region)) {

		// if the entry seems like a relative one (like for a library)
		// then add the base of its image
		if (entry < data->region->start()) {
			entry += data->region->start();
		}

		qDebug("[Analyzer] found entry point: %s", qPrintable(entry.toPointerString()));

		if (data->region->contains(entry)) {
			data->knownFunctions.insert(entry);
		}
	}
}

/**
 * @brief Analyzer::invalidateAnalysis
 * @param region
 */
void Analyzer::invalidateAnalysis(const std::shared_ptr<IRegion> &region) {
	invalidateDynamicAnalysis(region);
	Q_FOREACH (const edb::address_t addr, specifiedFunctions_) {
		if (addr >= region->start() && addr < region->end()) {
			specifiedFunctions_.remove(addr);
		}
	}
}

/**
 * @brief Analyzer::invalidateDynamicAnalysis
 * @param region
 */
void Analyzer::invalidateDynamicAnalysis(const std::shared_ptr<IRegion> &region) {

	RegionData info;
	info.region = region;
	info.fuzzy  = false;

	analysisInfo_[region->start()] = info;
}

/**
 * @brief Analyzer::invalidateAnalysis
 */
void Analyzer::invalidateAnalysis() {
	analysisInfo_.clear();
	specifiedFunctions_.clear();
}

/**
 * @brief Analyzer::findContainingFunction
 * @param address
 * @return the entry point of the function which contains <address>
 */
Result<edb::address_t, QString> Analyzer::findContainingFunction(edb::address_t address) const {

	Function function;
	if (findContainingFunction(address, &function)) {
		return function.entryAddress();
	} else {
		return make_unexpected(tr("Containing Function Not Found"));
	}
}

}

```

`plugins/Analyzer/Analyzer.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ANALYZER_H_20080630_
#define ANALYZER_H_20080630_

#include "BasicBlock.h"
#include "IAnalyzer.h"
#include "IPlugin.h"
#include "IRegion.h"
#include "Symbol.h"
#include "Types.h"

#include <QHash>
#include <QList>
#include <QMap>
#include <QSet>
#include <QVector>

class QMenu;

namespace AnalyzerPlugin {

class AnalyzerWidget;

class Analyzer final : public QObject, public IAnalyzer, public IPlugin {
	Q_OBJECT
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_INTERFACES(IPlugin)
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

private:
	struct RegionData;

public:
	explicit Analyzer(QObject *parent = nullptr);

public:
	QMenu *menu(QWidget *parent = nullptr) override;
	QList<QAction *> cpuContextMenu() override;

private:
	void privateInit() override;
	QWidget *optionsPage() override;

public:
	AddressCategory category(edb::address_t address) const override;
	FunctionMap functions(const std::shared_ptr<IRegion> &region) const override;
	FunctionMap functions() const override;
	QSet<edb::address_t> specifiedFunctions() const override { return specifiedFunctions_; }
	Result<edb::address_t, QString> findContainingFunction(edb::address_t address) const override;
	void analyze(const std::shared_ptr<IRegion> &region) override;
	void invalidateAnalysis() override;
	void invalidateAnalysis(const std::shared_ptr<IRegion> &region) override;
	bool forFuncsInRange(edb::address_t start, edb::address_t end, std::function<bool(const Function *)> functor) const override;

private:
	bool findContainingFunction(edb::address_t address, Function *function) const;
	void bonusEntryPoint(RegionData *data) const;
	void bonusMain(RegionData *data) const;
	void bonusMarkedFunctions(RegionData *data);
	void bonusSymbols(RegionData *data);
	void collectFunctions(RegionData *data);
	void collectFuzzyFunctions(RegionData *data);
	void doAnalysis(const std::shared_ptr<IRegion> &region);
	void identHeader(Analyzer::RegionData *data);
	void invalidateDynamicAnalysis(const std::shared_ptr<IRegion> &region);

Q_SIGNALS:
	void updateProgress(int);

public Q_SLOTS:
	void doIpAnalysis();
	void doViewAnalysis();
	void gotoFunctionStart();
	void gotoFunctionEnd();
	void markFunctionStart();
	void showXrefs();
	void showSpecified();

private:
	struct RegionData {
		QSet<edb::address_t> knownFunctions;
		QSet<edb::address_t> fuzzyFunctions;

		FunctionMap functions;
		QHash<edb::address_t, BasicBlock> basicBlocks;

		QByteArray md5;
		bool fuzzy;
		std::shared_ptr<IRegion> region;

		// a copy of the whole region
		QVector<uint8_t> memory;
	};

	QMenu *menu_                    = nullptr;
	AnalyzerWidget *analyzerWidget_ = nullptr;
	QHash<edb::address_t, RegionData> analysisInfo_;
	QSet<edb::address_t> specifiedFunctions_;
};

}

#endif

```

`plugins/Analyzer/AnalyzerWidget.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "AnalyzerWidget.h"
#include "Function.h"
#include "IAnalyzer.h"
#include "IDebugger.h"
#include "IRegion.h"
#include "MemoryRegions.h"
#include "State.h"
#include "edb.h"
#include "util/Font.h"

#include <QAbstractScrollArea>
#include <QDebug>
#include <QDir>
#include <QElapsedTimer>
#include <QFontMetrics>
#include <QMouseEvent>
#include <QPainter>
#include <QPixmap>
#include <QScrollBar>

namespace AnalyzerPlugin {

/**
 * @brief AnalyzerWidget::AnalyzerWidget
 * @param parent
 * @param f
 */
AnalyzerWidget::AnalyzerWidget(QWidget *parent, Qt::WindowFlags f)
	: QWidget(parent, f) {

	QFontMetrics fm(font());

	setMinimumHeight(fm.lineSpacing());
	setMaximumHeight(fm.lineSpacing());
	QSizePolicy policy;

	policy.setHorizontalPolicy(QSizePolicy::Expanding);
	setSizePolicy(policy);

	connect(edb::v1::disassembly_widget(), SIGNAL(regionChanged()), this, SLOT(update()));

	if (auto scroll_area = qobject_cast<QAbstractScrollArea *>(edb::v1::disassembly_widget())) {
		if (QScrollBar *scrollbar = scroll_area->verticalScrollBar()) {
			connect(scrollbar, &QScrollBar::valueChanged, this, [this](int) {
				update();
			});
		}
	}
}

/**
 * @brief AnalyzerWidget::paintEvent
 * @param event
 */
void AnalyzerWidget::paintEvent(QPaintEvent *event) {
	QElapsedTimer timer;
	timer.start();

	Q_UNUSED(event)

	const std::shared_ptr<IRegion> region = edb::v1::current_cpu_view_region();
	if (!region || region->size() == 0) {
		return;
	}

	const QSet<edb::address_t> specified_functions = edb::v1::analyzer()->specifiedFunctions();
	const IAnalyzer::FunctionMap functions         = edb::v1::analyzer()->functions(region);

	const auto byte_width = static_cast<float>(width()) / region->size();

	if (!cache_ || width() != cache_->width() || height() != cache_->height() || cacheNumFuncs_ != functions.size()) {

		cache_         = std::make_unique<QPixmap>(width(), height());
		cacheNumFuncs_ = functions.size();

		QPainter painter(cache_.get());
		painter.fillRect(0, 0, width(), height(), QBrush(Qt::black));

		for (auto it = functions.begin(); it != functions.end(); ++it) {
			const Function &f = it.value();

			const auto first_offset = static_cast<int>((f.entryAddress() - region->start()) * byte_width);
			const auto last_offset  = static_cast<int>((f.endAddress() - region->start()) * byte_width);

			if (!specified_functions.contains(f.entryAddress())) {
				painter.fillRect(first_offset, 0, last_offset - first_offset, height(), QBrush(Qt::darkGreen));
			} else {
				painter.fillRect(first_offset, 0, last_offset - first_offset, height(), QBrush(Qt::darkRed));
			}
		}

		// highlight header of binary (probably not going to be too noticeable but just in case)
		if (std::unique_ptr<IBinary> binary_info = edb::v1::get_binary_info(region)) {
			painter.fillRect(0, 0, static_cast<int>(binary_info->headerSize() * byte_width), height(), QBrush(Qt::darkBlue));
		}
	}

	QPainter painter(this);
	painter.drawPixmap(0, 0, *cache_);

	if (!functions.isEmpty()) {
		if (auto scroll_area = qobject_cast<QAbstractScrollArea *>(edb::v1::disassembly_widget())) {
			if (QScrollBar *scrollbar = scroll_area->verticalScrollBar()) {
				QFontMetrics fm(font());
				const auto offset = static_cast<int>(scrollbar->value() * byte_width);

				const QString triangle(QChar(0x25b4));

#ifdef Q_OS_WIN32
				const QFont f = painter.font();
				painter.setFont(QFont("Lucida Sans Unicode", 16));
#endif
				painter.setPen(QPen(Qt::yellow));
				painter.drawText(offset - Font::stringWidth(fm, triangle) / 2, height(), triangle);
#ifdef Q_OS_WIN32
				painter.setFont(f);
#endif
			}
		}
	} else {
		painter.setPen(QPen(Qt::white));
		painter.drawText(rect(), Qt::AlignCenter,
						 QString("%1: %2").arg(
							 region->name().split(QDir::separator()).last(),
							 tr("No Analysis Found")));
	}

	const int64_t renderTime = timer.elapsed();
	if (renderTime > 8) {
		qDebug() << "AnalyzerWidget: Painting took longer than desired: " << renderTime << "ms";
	}
}

/**
 * @brief AnalyzerWidget::mousePressEvent
 * @param event
 */
void AnalyzerWidget::mousePressEvent(QMouseEvent *event) {

	mousePressed_ = true;

	if (const std::shared_ptr<IRegion> region = edb::v1::current_cpu_view_region()) {
		const IAnalyzer::FunctionMap functions = edb::v1::analyzer()->functions(region);
		if (region->size() != 0 && !functions.empty()) {
			const auto byte_width = static_cast<float>(width()) / region->size();

			const edb::address_t start = region->start();
			const edb::address_t end   = region->end();

			edb::address_t offset = start + static_cast<int>(event->x() / byte_width);

			const edb::address_t address = qBound<edb::address_t>(start, offset, end - 1);
			edb::v1::jump_to_address(address);
		}
	}
}

/**
 * @brief AnalyzerWidget::mouseReleaseEvent
 * @param event
 */
void AnalyzerWidget::mouseReleaseEvent(QMouseEvent *event) {
	Q_UNUSED(event)
	mousePressed_ = false;
}

/**
 * @brief AnalyzerWidget::mouseMoveEvent
 * @param event
 */
void AnalyzerWidget::mouseMoveEvent(QMouseEvent *event) {
	if (mousePressed_) {
		mousePressEvent(event);
	}
}

}

```

`plugins/Analyzer/AnalyzerWidget.h`:

```h
/*
Copyright (C) 2013 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ANALYZER_WIDGET_H_20190412_
#define ANALYZER_WIDGET_H_20190412_

#include <QWidget>
#include <memory>

class QPixmap;

namespace AnalyzerPlugin {

class AnalyzerWidget final : public QWidget {
	Q_OBJECT
public:
	AnalyzerWidget(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());

protected:
	void paintEvent(QPaintEvent *event) override;
	void mousePressEvent(QMouseEvent *event) override;
	void mouseReleaseEvent(QMouseEvent *event) override;
	void mouseMoveEvent(QMouseEvent *event) override;

private:
	std::unique_ptr<QPixmap> cache_;
	bool mousePressed_ = false;
	int cacheNumFuncs_ = 0;
};

}

#endif

```

`plugins/Analyzer/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "Analyzer")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	Analyzer.cpp
	Analyzer.h
	AnalyzerWidget.cpp
	AnalyzerWidget.h
	DialogXRefs.cpp
	DialogXRefs.h
	DialogXRefs.ui
	OptionsPage.cpp
	OptionsPage.h
	OptionsPage.ui
	SpecifiedFunctions.cpp
	SpecifiedFunctions.h
	SpecifiedFunctions.ui
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/Analyzer/DialogXRefs.cpp`:

```cpp

#include "DialogXRefs.h"

namespace AnalyzerPlugin {

/**
 * @brief DialogXRefs::DialogXRefs
 * @param parent
 */
DialogXRefs::DialogXRefs(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {
	ui.setupUi(this);
}

/**
 * @brief DialogXRefs::on_listReferences_itemDoubleClicked
 * @param item
 */
void DialogXRefs::on_listReferences_itemDoubleClicked(QListWidgetItem *item) {

	edb::address_t site = item->data(Qt::UserRole).toULongLong();
	edb::v1::jump_to_address(site);
}

/**
 * @brief DialogXRefs::addReference
 * @param ref
 */
void DialogXRefs::addReference(const std::pair<edb::address_t, edb::address_t> &ref) {

	int offset;
	QString sym = edb::v1::find_function_symbol(ref.first, ref.first.toPointerString(), &offset);

	auto string = tr("%1. %2 -> %3").arg(ui.listReferences->count() + 1, 2, 10, QChar('0')).arg(sym).arg(ref.second.toPointerString());

	auto item = new QListWidgetItem(string, ui.listReferences);
	item->setData(Qt::UserRole, static_cast<qlonglong>(ref.first));
}

}

```

`plugins/Analyzer/DialogXRefs.h`:

```h

#ifndef DIALOG_XREFS_H_20191119_
#define DIALOG_XREFS_H_20191119_

#include "edb.h"
#include "ui_DialogXRefs.h"

#include <QDialog>
#include <utility>

class QListWidgetItem;

namespace AnalyzerPlugin {

class DialogXRefs : public QDialog {
	Q_OBJECT

public:
	explicit DialogXRefs(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogXRefs() override = default;

public Q_SLOTS:
	void on_listReferences_itemDoubleClicked(QListWidgetItem *item);

public:
	void addReference(const std::pair<edb::address_t, edb::address_t> &reference);

private:
	Ui::DialogXRefs ui;
};

}

#endif

```

`plugins/Analyzer/DialogXRefs.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>AnalyzerPlugin::DialogXRefs</class>
 <widget class="QDialog" name="AnalyzerPlugin::DialogXRefs">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>432</width>
    <height>308</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>X-Refs For %1</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0" colspan="2">
    <widget class="QListWidget" name="listReferences">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
    </widget>
   </item>
   <item row="1" column="1">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>AnalyzerPlugin::DialogXRefs</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>371</x>
     <y>285</y>
    </hint>
    <hint type="destinationlabel">
     <x>3</x>
     <y>251</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>AnalyzerPlugin::DialogXRefs</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>139</x>
     <y>287</y>
    </hint>
    <hint type="destinationlabel">
     <x>105</x>
     <y>265</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/Analyzer/OptionsPage.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "OptionsPage.h"
#include <QSettings>

namespace AnalyzerPlugin {

/**
 * @brief OptionsPage::OptionsPage
 * @param parent
 * @param f
 */
OptionsPage::OptionsPage(QWidget *parent, Qt::WindowFlags f)
	: QWidget(parent, f) {

	ui.setupUi(this);
	connect(ui.checkBox, &QCheckBox::toggled, this, &OptionsPage::checkBoxToggled);
}

/**
 * @brief OptionsPage::showEvent
 * @param event
 */
void OptionsPage::showEvent(QShowEvent *event) {
	Q_UNUSED(event)

	QSettings settings;
	ui.checkBox->setChecked(settings.value("Analyzer/fuzzy_logic_functions.enabled", true).toBool());
}

/**
 * @brief OptionsPage::checkBoxToggled
 * @param checked
 */
void OptionsPage::checkBoxToggled(bool checked) {
	Q_UNUSED(checked)

	QSettings settings;
	settings.setValue("Analyzer/fuzzy_logic_functions.enabled", ui.checkBox->isChecked());
}

}

```

`plugins/Analyzer/OptionsPage.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef OPTIONS_PAGE_H_20090706_
#define OPTIONS_PAGE_H_20090706_

#include "ui_OptionsPage.h"
#include <QWidget>

namespace AnalyzerPlugin {

class OptionsPage : public QWidget {
	Q_OBJECT

public:
	explicit OptionsPage(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~OptionsPage() override = default;

public:
	void showEvent(QShowEvent *event) override;

private:
	void checkBoxToggled(bool checked = false);

private:
	Ui::OptionsPage ui;
};

}

#endif

```

`plugins/Analyzer/OptionsPage.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>AnalyzerPlugin::OptionsPage</class>
 <widget class="QWidget" name="AnalyzerPlugin::OptionsPage">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Analyzer Plugin</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QCheckBox" name="checkBox">
     <property name="text">
      <string>Use fuzzy logic to find functions</string>
     </property>
    </widget>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>262</height>
      </size>
     </property>
    </spacer>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`plugins/Analyzer/SpecifiedFunctions.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "SpecifiedFunctions.h"
#include "IAnalyzer.h"
#include "edb.h"

#include <QHeaderView>
#include <QPushButton>
#include <QSortFilterProxyModel>
#include <QStringListModel>
#include <QtDebug>

namespace AnalyzerPlugin {

/**
 * @brief SpecifiedFunctions::SpecifiedFunctions
 * @param parent
 * @param f
 */
SpecifiedFunctions::SpecifiedFunctions(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);

	model_       = new QStringListModel(this);
	filterModel_ = new QSortFilterProxyModel(this);

	filterModel_->setFilterKeyColumn(0);
	filterModel_->setSourceModel(model_);
	ui.function_list->setModel(filterModel_);

	connect(ui.filter, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);

	buttonRefresh_ = new QPushButton(QIcon::fromTheme("view-refresh"), tr("Refresh"));
	connect(buttonRefresh_, &QPushButton::clicked, this, [this]() {
		buttonRefresh_->setEnabled(false);
		doFind();
		buttonRefresh_->setEnabled(true);
	});

	ui.buttonBox->addButton(buttonRefresh_, QDialogButtonBox::ActionRole);
}

/**
 * @brief SpecifiedFunctions::on_function_list_doubleClicked
 *
 * follows the found item in the data view
 *
 * @param index
 */
void SpecifiedFunctions::on_function_list_doubleClicked(const QModelIndex &index) {

	const QString s = index.data().toString();
	if (const Result<edb::address_t, QString> addr = edb::v1::string_to_address(s)) {
		edb::v1::jump_to_address(*addr);
	}
}

/**
 * @brief SpecifiedFunctions::doFind
 */
void SpecifiedFunctions::doFind() {

	IAnalyzer *const analyzer      = edb::v1::analyzer();
	QSet<edb::address_t> functions = analyzer->specifiedFunctions();

	QStringList results;
	for (edb::address_t address : functions) {
		results << QString("%1").arg(edb::v1::format_pointer(address));
	}
	model_->setStringList(results);
}

/**
 * @brief SpecifiedFunctions::showEvent
 */
void SpecifiedFunctions::showEvent(QShowEvent *) {
	buttonRefresh_->setEnabled(false);
	doFind();
	buttonRefresh_->setEnabled(true);
}

}

```

`plugins/Analyzer/SpecifiedFunctions.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_SPECIFIED_FUNCTIONS_H_20070705_
#define DIALOG_SPECIFIED_FUNCTIONS_H_20070705_

#include "ui_SpecifiedFunctions.h"
#include <QDialog>

class QStringListModel;
class QSortFilterProxyModel;
class QModelIndex;

namespace AnalyzerPlugin {

class SpecifiedFunctions : public QDialog {
	Q_OBJECT

public:
	explicit SpecifiedFunctions(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~SpecifiedFunctions() override = default;

public Q_SLOTS:
	void on_function_list_doubleClicked(const QModelIndex &index);

private:
	void showEvent(QShowEvent *event) override;

private:
	void doFind();

private:
	Ui::SpecifiedFunctions ui;
	QStringListModel *model_            = nullptr;
	QSortFilterProxyModel *filterModel_ = nullptr;
	QPushButton *buttonRefresh_         = nullptr;
};

}

#endif

```

`plugins/Analyzer/SpecifiedFunctions.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>AnalyzerPlugin::SpecifiedFunctions</class>
 <widget class="QDialog" name="AnalyzerPlugin::SpecifiedFunctions">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>455</width>
    <height>283</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Specified Functions</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="label">
     <property name="text">
      <string>Specified Functions</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLineEdit" name="filter">
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QListView" name="function_list">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="showDropIndicator" stdset="0">
      <bool>false</bool>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>AnalyzerPlugin::SpecifiedFunctions</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>417</x>
     <y>265</y>
    </hint>
    <hint type="destinationlabel">
     <x>429</x>
     <y>242</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>AnalyzerPlugin::SpecifiedFunctions</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>264</x>
     <y>259</y>
    </hint>
    <hint type="destinationlabel">
     <x>256</x>
     <y>240</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/Assembler/Assembler.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Assembler.h"
#include "DialogAssembler.h"
#include "MemoryRegions.h"
#include "OptionsPage.h"
#include "edb.h"

#include <QAction>
#include <QList>
#include <QMenu>

namespace AssemblerPlugin {

/**
 * @brief Assembler::Assembler
 * @param parent
 */
Assembler::Assembler(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief Assembler::~Assembler
 */
Assembler::~Assembler() {
	delete dialog_;
}

/**
 * @brief Assembler::cpuContextMenu
 * @return
 */
QList<QAction *> Assembler::cpuContextMenu() {

	QList<QAction *> ret;

	auto action_assemble = new QAction(tr("&Assemble..."), this);
	action_assemble->setShortcut(QKeySequence(tr("Space")));

	connect(action_assemble, &QAction::triggered, this, &Assembler::showDialog);
	ret << action_assemble;

	return ret;
}

/**
 * @brief Assembler::menu
 * @param parent
 * @return
 */
QMenu *Assembler::menu(QWidget *parent) {
	Q_UNUSED(parent)
	return nullptr;
}

/**
 * @brief Assembler::showDialog
 */
void Assembler::showDialog() {

	if (!dialog_) {
		dialog_ = new DialogAssembler(edb::v1::debugger_ui);
	}

	const edb::address_t address = edb::v1::cpu_selected_address();
	if (std::shared_ptr<IRegion> region = edb::v1::memory_regions().findRegion(address)) {
		if (auto d = qobject_cast<DialogAssembler *>(dialog_)) {
			d->setAddress(address);
		}
		dialog_->show();
	}
}

/**
 * @brief Assembler::optionsPage
 * @return
 */
QWidget *Assembler::optionsPage() {
	return new OptionsPage;
}

}

```

`plugins/Assembler/Assembler.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ASSEMBLER_H_20130611_
#define ASSEMBLER_H_20130611_

#include "IPlugin.h"

class QMenu;
class QDialog;

namespace AssemblerPlugin {

class Assembler : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit Assembler(QObject *parent = nullptr);
	~Assembler() override;

public:
	QMenu *menu(QWidget *parent = nullptr) override;
	QList<QAction *> cpuContextMenu() override;
	QWidget *optionsPage() override;

private:
	void showDialog();

private:
	QPointer<QDialog> dialog_ = nullptr;
};

}

#endif

```

`plugins/Assembler/Assembler.qrc`:

```qrc
<RCC>
  <qresource prefix="/debugger/Assembler" >
	<file>xml/assemblers.xml</file>
  </qresource>
</RCC>

```

`plugins/Assembler/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "Assembler")

find_package(Qt5 5.0.0 REQUIRED Widgets Xml XmlPatterns)

qt5_add_resources(QRC_SOURCES 
	Assembler.qrc
)

foreach(FILE IN LISTS QRC_SOURCES)
	set_property(SOURCE ${FILE} PROPERTY SKIP_UNITY_BUILD_INCLUSION ON)
endforeach()

add_library(${PluginName} SHARED
	${QRC_SOURCES}
	Assembler.cpp
	Assembler.h
	DialogAssembler.cpp
	DialogAssembler.h
	DialogAssembler.ui
	OptionsPage.cpp
	OptionsPage.h
	OptionsPage.ui
)

target_link_libraries(${PluginName} Qt5::Widgets Qt5::Xml Qt5::XmlPatterns edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/Assembler/DialogAssembler.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogAssembler.h"
#include "IDebugger.h"
#include "edb.h"
#include "string_hash.h"

#include <QDebug>
#include <QDir>
#include <QDomDocument>
#include <QFile>
#include <QFileInfo>
#include <QLineEdit>
#include <QMessageBox>
#include <QProcess>
#include <QRegExp>
#include <QSettings>
#include <QTemporaryFile>
#include <QTextDocument>
#include <QXmlQuery>

#ifdef Q_OS_UNIX
#include <sys/types.h>
#include <unistd.h>
#endif

namespace AssemblerPlugin {

namespace {

/**
 * @brief escape_html
 * @param str
 * @return
 */
QString escape_html(const QString &str) {
	return str.toHtmlEscaped();
}

/**
 * @brief assembler_description
 * @return
 */
QDomDocument assembler_description() {

	const QString assembler = QSettings().value("Assembler/helper", "yasm").toString();

	QFile file(":/debugger/Assembler/xml/assemblers.xml");
	if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {

		QXmlQuery query;
		QString assembler_xml;
		query.setFocus(&file);
		query.setQuery(QString("assemblers/assembler[@name='%1']").arg(escape_html(assembler)));
		if (query.isValid()) {
			query.evaluateTo(&assembler_xml);
		}

		QDomDocument xml;
		xml.setContent(assembler_xml);
		return xml;
	}
	return {};
}

/**
 * @brief fixupSyntax
 * @param insn
 * @return
 */
QString fixup_syntax(QString insn) {

	const QDomElement asmRoot = assembler_description().documentElement();
	if (asmRoot.isNull()) {
		return insn;
	}

	const QDomElement opSizes = asmRoot.firstChildElement("operand_sizes");
	if (opSizes.isNull()) {
		return insn;
	}

	static const QString sizes[] = {
		"byte",
		"word",
		"dword",
		"qword",
		"tbyte",
		"xmmword",
		"ymmword",
		"zmmword"};

	for (const QString &size : sizes) {
		const QString replacement = opSizes.attribute(size);
		if (!replacement.isEmpty()) {
			insn.replace(QRegExp("\\b" + size + "\\b"), replacement);
		}
	}

	return insn;
}

}

/**
 * @brief DialogAssembler::DialogAssembler
 * @param parent
 * @param f
 */
DialogAssembler::DialogAssembler(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);

	// Disable click focus: we don't want to unnecessarily defocus instruction entry without need
	ui.fillWithNOPs->setFocusPolicy(Qt::TabFocus);
	ui.keepSize->setFocusPolicy(Qt::TabFocus);
}

/**
 * @brief DialogAssembler::setAddress
 * @param address
 */
void DialogAssembler::setAddress(edb::address_t address) {
	address_ = address;
	ui.address->setText(edb::v1::format_pointer(address_));

	uint8_t buffer[edb::Instruction::MaxSize];
	if (const int size = edb::v1::get_instruction_bytes(address, buffer)) {
		edb::Instruction inst(buffer, buffer + size, address);
		if (inst) {
			ui.assembly->setEditText(fixup_syntax(edb::v1::formatter().toString(inst).c_str()).simplified());
			instructionSize_ = inst.byteSize();
		}
	}
}

/**
 * @brief DialogAssembler::on_buttonBox_accepted
 */
void DialogAssembler::on_buttonBox_accepted() {

	if (IDebugger *core = edb::v1::debugger_core) {
		const QString nasm_syntax = ui.assembly->currentText().trimmed();

		const QDomElement asm_root = assembler_description().documentElement();
		if (!asm_root.isNull()) {
			QDomElement asm_executable = asm_root.firstChildElement("executable");
			QDomElement asm_template   = asm_root.firstChildElement("template");
#if defined(EDB_ARM32)
			const auto mode = core->cpuMode();
			while (mode == IDebugger::CpuMode::ARM32 && asm_template.attribute("mode") != "arm" ||
				   mode == IDebugger::CpuMode::Thumb && asm_template.attribute("mode") != "thumb") {

				asm_template = asm_template.nextSiblingElement("template");
				if (asm_template.isNull()) {
					QMessageBox::critical(
						this,
						tr("Error running assembler"),
						tr("Failed to locate source file template for current CPU mode"));
					return;
				}
			}
#endif

			const QString asm_name = asm_root.attribute("name");
			const QString asm_cmd  = asm_executable.attribute("command_line");
			const QString asm_ext  = asm_executable.attribute("extension");
			Q_UNUSED(asm_name)

			QString asm_code = asm_template.text();

			QStringList command_line = edb::v1::parse_command_line(asm_cmd);
			if (command_line.isEmpty()) {
				QMessageBox::warning(this, tr("Couldn't Find Assembler"), tr("Failed to locate your assembler."));
				return;
			}

			QTemporaryFile source_file(QString("%1/edb_asm_temp_%2_XXXXXX.%3").arg(QDir::tempPath()).arg(QCoreApplication::applicationPid()).arg(asm_ext));
			if (!source_file.open()) {
				QMessageBox::critical(this, tr("Error Creating File"), tr("Failed to create temporary source file."));
				return;
			}

			QTemporaryFile output_file(QString("%1/edb_asm_temp_%2_XXXXXX.bin").arg(QDir::tempPath()).arg(QCoreApplication::applicationPid()));
			if (!output_file.open()) {
				QMessageBox::critical(this, tr("Error Creating File"), tr("Failed to create temporary object file."));
				return;
			}

			const QString bitsStr = std::to_string(core->pointerSize() * 8).c_str();
			const QString addrStr = edb::v1::format_pointer(address_);

			static const char *bitsTag = "%BITS%";
			static const char *addrTag = "%ADDRESS%";
			static const char *insnTag = "%INSTRUCTION%";

			asm_code.replace(bitsTag, bitsStr);
			asm_code.replace(addrTag, addrStr);
			asm_code.replace(insnTag, nasm_syntax);

			source_file.write(asm_code.toLatin1());
			source_file.close();

			QProcess process;
			QString program(command_line[0]);

			command_line.pop_front();

			QStringList arguments = command_line;
			for (QString &arg : arguments) {
				arg.replace("%OUT%", output_file.fileName());
				arg.replace("%IN%", source_file.fileName());
				arg.replace(bitsTag, bitsStr);
				arg.replace(addrTag, addrStr);
				arg.replace(insnTag, nasm_syntax);
			}

			qDebug() << "RUNNING ASM TOOL: " << program << arguments;

			process.start(program, arguments);

			if (process.waitForFinished()) {

				const int exit_code = process.exitCode();

				if (exit_code != 0) {
					QMessageBox::warning(this, tr("Error In Code"), process.readAllStandardError());
				} else {
					QByteArray bytes              = output_file.readAll();
					const size_t replacement_size = bytes.size();

					if (replacement_size != 0 && replacement_size <= instructionSize_) {
						if (ui.fillWithNOPs->isChecked()) {
							if (!edb::v1::modify_bytes(address_, instructionSize_, bytes, core->nopFillByte())) {
								return;
							}
						} else {
							if (!edb::v1::modify_bytes(address_, instructionSize_, bytes, 0x00)) {
								return;
							}
						}
					} else if (replacement_size == 0) {
						const QString stdError = process.readAllStandardError();
						QMessageBox::warning(this, tr("Error In Code"), tr("Got zero bytes from the assembler") + (stdError.isEmpty() ? "" : tr(", here's what it has to say:\n\n") + stdError));
						return;
					} else {
						if (ui.keepSize->isChecked()) {
							QMessageBox::warning(this, tr("Error In Code"), tr("New instruction is too big to fit."));
							return;
						} else {
							if (!edb::v1::modify_bytes(address_, replacement_size, bytes, 0x00)) {
								return;
							}
						}
					}

					const edb::address_t new_address = address_ + replacement_size;
					setAddress(new_address);
					edb::v1::set_cpu_selected_address(new_address);
				}
				ui.assembly->setFocus(Qt::OtherFocusReason);
				ui.assembly->lineEdit()->selectAll();
			} else if (process.error() == QProcess::FailedToStart) {
				QMessageBox::warning(this, tr("Couldn't Launch Assembler"), tr("Failed to start your assembler."));
				return;
			}
		}
	}
}

/**
 * @brief DialogAssembler::showEvent
 * @param event
 */
void DialogAssembler::showEvent(QShowEvent *event) {
	Q_UNUSED(event)

	QSettings settings;
	const QString assembler = settings.value("Assembler/helper", "yasm").toString();

	ui.label->setText(tr("Assembler: %1").arg(assembler));

	ui.assembly->setFocus(Qt::OtherFocusReason);
}

}

```

`plugins/Assembler/DialogAssembler.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_ASSEMBLER_H_20130611_
#define DIALOG_ASSEMBLER_H_20130611_

#include "IRegion.h"
#include "Types.h"
#include "ui_DialogAssembler.h"
#include <QDialog>

namespace AssemblerPlugin {

class DialogAssembler : public QDialog {
	Q_OBJECT

public:
	explicit DialogAssembler(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogAssembler() override = default;

public Q_SLOTS:
	void on_buttonBox_accepted();

public:
	void setAddress(edb::address_t address);

public:
	void showEvent(QShowEvent *event) override;

private:
	Ui::DialogAssembler ui;
	edb::address_t address_ = 0;
	size_t instructionSize_ = 0;
};

}

#endif

```

`plugins/Assembler/DialogAssembler.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>AssemblerPlugin::DialogAssembler</class>
 <widget class="QDialog" name="AssemblerPlugin::DialogAssembler">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>423</width>
    <height>134</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Assembler</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="1" column="0" colspan="2">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="address">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Maximum" vsizetype="Preferred">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="text">
        <string>00000000</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QComboBox" name="assembly">
       <property name="editable">
        <bool>true</bool>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item row="2" column="0">
    <widget class="QCheckBox" name="keepSize">
     <property name="enabled">
      <bool>true</bool>
     </property>
     <property name="text">
      <string>&amp;Keep Size</string>
     </property>
     <property name="checked">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item row="3" column="0">
    <widget class="QCheckBox" name="fillWithNOPs">
     <property name="text">
      <string>Fill rest with &amp;NOPs</string>
     </property>
     <property name="checked">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item row="3" column="1">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
   <item row="0" column="0" colspan="2">
    <widget class="QLabel" name="label">
     <property name="font">
      <font>
       <weight>75</weight>
       <bold>true</bold>
      </font>
     </property>
     <property name="text">
      <string>Assembler: </string>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>AssemblerPlugin::DialogAssembler</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>388</x>
     <y>116</y>
    </hint>
    <hint type="destinationlabel">
     <x>386</x>
     <y>75</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>AssemblerPlugin::DialogAssembler</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>278</x>
     <y>112</y>
    </hint>
    <hint type="destinationlabel">
     <x>268</x>
     <y>80</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/Assembler/OptionsPage.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "OptionsPage.h"
#include <QDebug>
#include <QDomDocument>
#include <QFileDialog>
#include <QSettings>

namespace AssemblerPlugin {

/**
 * @brief OptionsPage::OptionsPage
 * @param parent
 * @param f
 */
OptionsPage::OptionsPage(QWidget *parent, Qt::WindowFlags f)
	: QWidget(parent, f) {

	ui.setupUi(this);

	QSettings settings;
	const QString name = settings.value("Assembler/helper", "yasm").toString();

	ui.assemblerName->clear();

#if defined(EDB_X86) || defined(EDB_X86_64)
	const QLatin1String targetArch("x86");
#elif defined(EDB_ARM32)
	const QLatin1String targetArch("arm");
#elif defined(EDB_ARM64)
	const QLatin1String targetArch("aarch64");
#endif

	QFile file(":/debugger/Assembler/xml/assemblers.xml");
	if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
		QDomDocument xml;
		xml.setContent(&file);
		QDomElement root = xml.documentElement();

		for (QDomElement assembler = root.firstChildElement("assembler"); !assembler.isNull(); assembler = assembler.nextSiblingElement("assembler")) {
			const QString name = assembler.attribute("name");
			const QString arch = assembler.attribute("arch");
			if (arch == targetArch) {
				ui.assemblerName->addItem(name);
			}
		}
	}

	const int index = ui.assemblerName->findText(name, Qt::MatchFixedString);
	if (index == -1 && ui.assemblerName->count() > 0) {
		ui.assemblerName->setCurrentIndex(0);
	} else {
		ui.assemblerName->setCurrentIndex(index);
	}
}

/**
 * @brief OptionsPage::on_assemblerName_currentIndexChanged
 * @param text
 */
void OptionsPage::on_assemblerName_currentIndexChanged(const QString &text) {
	QSettings settings;
	settings.setValue("Assembler/helper", text);
}

}

```

`plugins/Assembler/OptionsPage.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ASSEMBLER_OPTIONS_PAGE_H_20130611_
#define ASSEMBLER_OPTIONS_PAGE_H_20130611_

#include "ui_OptionsPage.h"
#include <QWidget>

namespace AssemblerPlugin {

class OptionsPage : public QWidget {
	Q_OBJECT

public:
	explicit OptionsPage(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~OptionsPage() override = default;

public Q_SLOTS:
	void on_assemblerName_currentIndexChanged(const QString &text);

private:
	Ui::OptionsPage ui;
};

}

#endif

```

`plugins/Assembler/OptionsPage.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>AssemblerPlugin::OptionsPage</class>
 <widget class="QWidget" name="AssemblerPlugin::OptionsPage">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>532</width>
    <height>232</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Assembly Plugin</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Assembler Helper Application</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QComboBox" name="assemblerName">
       <property name="editable">
        <bool>false</bool>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>191</height>
      </size>
     </property>
    </spacer>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`plugins/Assembler/xml/assemblers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<assemblers>
	<assembler name="yasm" arch="x86">
		<executable command_line="/usr/bin/yasm -f bin %IN% -o %OUT%" extension="asm" />
		<template>
		<![CDATA[
		[BITS %BITS%]
		[SECTION .text vstart=%ADDRESS% valign=1]
	
		%INSTRUCTION%
		]]>
		</template>
		<operand_sizes
			byte="byte"
			word="word"
			dword="dword"
			qword="qword"
			tbyte="tword"
			xmmword="oword"
			ymmword="yword"
			zmmword="zword"
		/>
	</assembler>
	<assembler name="nasm" arch="x86">
		<executable command_line="/usr/bin/nasm -f bin %IN% -o %OUT%" extension="asm" />
		<template>
		<![CDATA[
		[BITS %BITS%]
		ORG %ADDRESS%
	
		%INSTRUCTION%
		]]>
		</template>
		<operand_sizes
			byte="byte"
			word="word"
			dword="dword"
			qword="qword"
			tbyte="tword"
			xmmword="oword"
			ymmword="yword"
			zmmword="zword"
		/>
	</assembler>
	<assembler name="fasm" arch="x86">
		<executable command_line="fasm %IN% %OUT%" extension="asm" />
		<template>
		<![CDATA[
		use%BITS%
		ORG %ADDRESS%

		%INSTRUCTION%
		]]>
		</template>
		<operand_sizes
			byte="byte"
			word="word"
			dword="dword"
			qword="qword"
			tbyte="tbyte"
			xmmword="xword"
			ymmword="yword"
			zmmword="zword"
		/>
	</assembler>
	<assembler name="gas (Intel syntax)" arch="x86">
		<executable command_line="sh -c &quot;
		[ %BITS% = 32 ] &amp;&amp; FORMAT=elf_i386 || FORMAT=elf_x86_64;
		asmOut=`mktemp %OUT%.o.XXXXXXXX`;
		linkerScript=`mktemp %OUT%.ld.XXXXXXXX`;
		if [ -z $asmOut ] || [ -z $linkerScript ]; then exit 1; fi;
		echo 'SECTIONS { . = %ADDRESS%; .text . : SUBALIGN(0) { *(.text) } }' &gt; $linkerScript &amp;&amp;
		 as --%BITS% -o $asmOut %IN% &amp;&amp;
		 ld -m $FORMAT -T $linkerScript --oformat binary -o %OUT% $asmOut;
		RESULT=$?;
		rm -f $asmOut $linkerScript;
		exit $RESULT
		&quot;"
					extension="s" />
		<template>
		<![CDATA[
		.section .text
		.globl _start
		.intel_syntax noprefix
		_start:
		%INSTRUCTION%
		]]>
		</template>
		<operand_sizes
			byte="byte ptr"
			word="word ptr"
			dword="dword ptr"
			qword="qword ptr"
			tbyte="tbyte ptr"
			xmmword="xmmword ptr"
			ymmword="ymmword ptr"
			zmmword="zmmword ptr"
		/>
	</assembler>
	<assembler name="gas (AT&amp;T syntax)" arch="x86">
		<!-- command lines are identical for Intel and AT&T syntax, only source is different -->
		<executable command_line="sh -c &quot;
		[ %BITS% = 32 ] &amp;&amp; FORMAT=elf_i386 || FORMAT=elf_x86_64;
		asmOut=`mktemp %OUT%.o.XXXXXXXX`;
		linkerScript=`mktemp %OUT%.ld.XXXXXXXX`;
		if [ -z $asmOut ] || [ -z $linkerScript ]; then exit 1; fi;
		echo 'SECTIONS { . = %ADDRESS%; .text . : SUBALIGN(0) { *(.text) } }' &gt; $linkerScript &amp;&amp;
		 as --%BITS% -o $asmOut %IN% &amp;&amp;
		 ld -m $FORMAT -T $linkerScript --oformat binary -o %OUT% $asmOut;
		RESULT=$?;
		rm -f $asmOut $linkerScript;
		exit $RESULT
		&quot;"
					extension="s" />
		<template>
		<![CDATA[
		.section .text
		.globl _start
		_start:
		%INSTRUCTION%
		]]>
		</template>
	</assembler>
	<assembler name="gas" arch="arm">
		<executable command_line="sh -c &quot;
		if [ %BITS% != 32 ]; then
			echo 'Bad BITS: %BITS%' &gt;&amp;2;
			exit 1;
		fi;
		asmOut=`mktemp %OUT%.out.XXXXXXXX`;
		linkerScript=`mktemp %OUT%.ld.XXXXXXXX`;
		linkedELF=`mktemp %OUT%.executable.XXXXXXXX`;
		if [ -z $asmOut ] || [ -z $linkerScript ] || [ -z $linkedELF ]; then exit 1; fi;
		echo 'SECTIONS { . = %ADDRESS%; .text . : SUBALIGN(0) { *(.text) } }' &gt; $linkerScript &amp;&amp;
		 as -o $asmOut %IN% &amp;&amp;
		 ld -T $linkerScript -o $linkedELF $asmOut &amp;&amp;
		 objcopy -O binary $linkedELF %OUT%;
		result=$?;
		rm -f $asmOut $linkerScript $linkedELF;
		exit $result
		&quot;"
					extension="s" />
		<template mode="arm">
		<![CDATA[
		.syntax unified
		.arm
		.fpu neon	// FIXME: is this OK in general?
		%INSTRUCTION%
		]]>
		</template>
		<template mode="thumb">
		<![CDATA[
		.syntax unified
		.thumb
		.fpu neon	// FIXME: is this OK in general?
		%INSTRUCTION%
		]]>
		</template>
	</assembler>
</assemblers>

```

`plugins/Backtrace/Backtrace.cpp`:

```cpp
/*
Copyright (C) 2015	Armen Boursalian
					aboursalian@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Backtrace.h"
#include "DialogBacktrace.h"
#include "edb.h"

#include <QKeySequence>
#include <QMenu>

namespace BacktracePlugin {

/**
 * @brief Backtrace::Backtrace
 * @param parent
 */
Backtrace::Backtrace(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief Backtrace::~Backtrace
 */
Backtrace::~Backtrace() {
	delete dialog_;
}

/**
 * @brief Backtrace::menu
 * @param parent
 * @return
 */
QMenu *Backtrace::menu(QWidget *parent) {
	Q_ASSERT(parent);

	if (!menu_) {

		//So it will appear as Plugins > Call Stack > Backtrace in the menu.
		menu_ = new QMenu(tr("Call Stack"), parent);

		//Ctrl + K shortcut, reminiscent of OllyDbg
		menu_->addAction(tr("Backtrace"), this, SLOT(showMenu()), QKeySequence(tr("Ctrl+K")));
	}

	return menu_;
}

/**
 * @brief Backtrace::showMenu
 */
void Backtrace::showMenu() {
	if (!dialog_) {
		dialog_ = new DialogBacktrace(edb::v1::debugger_ui);
	}
	dialog_->show();
}

}

```

`plugins/Backtrace/Backtrace.h`:

```h
/*
Copyright (C) 2015	Armen Boursalian
					aboursalian@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef BACKTRACE_H_20191119_
#define BACKTRACE_H_20191119_

#include "IPlugin.h"

class QMenu;
class QDialog;

namespace BacktracePlugin {

class Backtrace : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Armen Boursalian")
	Q_CLASSINFO("url", "https://github.com/Northern-Lights")

public:
	explicit Backtrace(QObject *parent = nullptr);
	~Backtrace() override;

public:
	QMenu *menu(QWidget *parent = nullptr) override;

public Q_SLOTS:
	void showMenu();

private:
	QMenu *menu_              = nullptr;
	QPointer<QDialog> dialog_ = nullptr;
};

}
#endif

```

`plugins/Backtrace/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "Backtrace")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	Backtrace.cpp
	Backtrace.h
	CallStack.cpp
	CallStack.h
	DialogBacktrace.cpp
	DialogBacktrace.h
	DialogBacktrace.ui
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/Backtrace/CallStack.cpp`:

```cpp
/*
Copyright (C) 2015	Armen Boursalian
					aboursalian@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "CallStack.h"
#include "Expression.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IRegion.h"
#include "IState.h"
#include "IThread.h"
#include "MemoryRegions.h"
#include "State.h"
#include "edb.h"

// TODO: This may be specific to x86... Maybe abstract this in the future.

/**
 * @brief CallStack::CallStack
 */
CallStack::CallStack() {
	getCallStack();
}

/**
 * @brief CallStack::get_call_stack
 *
 * Gets the state of the call stack at the time the object is created.
 */
void CallStack::getCallStack() {
	/*
	 * Is rbp a pointer somewhere in the stack?
	 * Is the value below rbp a ret addr?
	 * Are we still scanning within the stack region?
	 */

	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {

			// Get the frame & stack pointers.
			State state;
			thread->getState(&state);
			const edb::address_t rbp = state.framePointer();
			const edb::address_t rsp = state.stackPointer();

			// Check the alignment.  rbp and rsp should be aligned to the stack.
			if (rbp % edb::v1::pointer_size() != 0 || rsp % edb::v1::pointer_size() != 0) {
				qDebug("It appears that the application is not using frame pointers, call stack unavailable.");
				return;
			}

			// Make sure frame pointer is pointing in the same region as stack pointer.
			// If not, then it's being used as a GPR, and we don't have enough info.
			// This assumes the stack pointer is always pointing somewhere in the stack.
			edb::v1::memory_regions().sync();
			std::shared_ptr<IRegion> region_rsp = edb::v1::memory_regions().findRegion(rsp);
			std::shared_ptr<IRegion> region_rbp = edb::v1::memory_regions().findRegion(rbp);
			if (!region_rsp || !region_rbp || (region_rbp != region_rsp)) {
				return;
			}

			// But if we're good, then scan from rbp downward and look for return addresses.
			// Code is largely from CommentServer.cpp.  Makes assumption of size of call.
			constexpr uint8_t CallMinSize = 2;
			constexpr uint8_t CallMaxSize = 7;

			uint8_t buffer[edb::Instruction::MaxSize];
			for (edb::address_t addr = rbp; region_rbp->contains(addr); addr += edb::v1::pointer_size()) {

				// Get the stack value so that we can see if it's a pointer
				bool ok;
				ExpressionError err;
				edb::address_t possible_ret = edb::v1::get_value(addr, &ok, &err);

				if (process->readBytes(possible_ret - CallMaxSize, buffer, sizeof(buffer))) { // 0xfffff... if not a ptr.
					for (int i = (CallMaxSize - CallMinSize); i >= 0; --i) {
						edb::Instruction inst(buffer + i, buffer + sizeof(buffer), 0);

						// If it's a call, then make a frame
						if (is_call(inst)) {
							StackFrame frame;
							frame.ret    = possible_ret;
							frame.caller = possible_ret - CallMaxSize + i;
							stackFrames_.push_back(frame);
							break;
						}
					}
				}
			}
		}
	}
}

/**
 * @brief CallStack::operator []
 *
 * Provides array-like access to the stack_frames_
 *
 * @param index
 * @return
 */
CallStack::StackFrame *CallStack::operator[](size_t index) {
	if (index > size()) {
		return nullptr;
	}

	return &stackFrames_[index];
}

/**
 * @brief CallStack::size
 * @return the number of frames in the call stack.
 */
size_t CallStack::size() const {
	return stackFrames_.size();
}

/**
 * @brief CallStack::top
 * @return a pointer to the frame at the top of the call stack or nullptr
 * if there are no frames on the stack
 */
CallStack::StackFrame *CallStack::top() {
	if (!size()) {
		return nullptr;
	}

	return &stackFrames_.front();
}

/**
 * @brief CallStack::bottom
 * @return a pointer to the frame at the bottom of the call stack or nullptr
 * if there are no frames on the stack
 */
CallStack::StackFrame *CallStack::bottom() {
	if (!size()) {
		return nullptr;
	}

	return &stackFrames_.back();
}

/**
 * @brief CallStack::push
 *
 * Pushes a stack frame onto the top of the call stack.
 *
 * @param frame
 */
void CallStack::push(StackFrame frame) {
	stackFrames_.push_front(frame);
}

```

`plugins/Backtrace/CallStack.h`:

```h
/*
Copyright (C) 2015	Armen Boursalian
                    aboursalian@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef CALL_STACK_H_20191119_
#define CALL_STACK_H_20191119_

#include "edb.h"
#include <deque>

class CallStack {
public:
	CallStack();
	~CallStack() = default;

public:
	// Struct that holds the caller and return addresses.
	struct StackFrame {
		edb::address_t ret;
		edb::address_t caller;
	};

private:
	void getCallStack();

public:
	StackFrame *operator[](size_t index);
	size_t size() const;
	StackFrame *top();
	StackFrame *bottom();
	void push(StackFrame frame);

private:
	std::deque<StackFrame> stackFrames_;
};

#endif

```

`plugins/Backtrace/DialogBacktrace.cpp`:

```cpp
/*
Copyright (C) 2015	Armen Boursalian
					aboursalian@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogBacktrace.h"
#include "CallStack.h"
#include "IBreakpoint.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "ISymbolManager.h"
#include "Symbol.h"

#include <QPushButton>
#include <QTableWidget>

namespace BacktracePlugin {
namespace {

// Default values in the table
constexpr int FirstRow     = 0;
constexpr int ReturnColumn = 1;

/**
 * @brief address_from_table
 * @param item
 * @return the edb::address_t represented by the given *item and sets *ok to
 * true if successful or false, otherwise.
 */
edb::address_t address_from_table(const QTableWidgetItem *item) {
	return static_cast<edb::address_t>(item->data(Qt::UserRole).value<qulonglong>());
}

/**
 * @brief is_ret
 * @param column
 * @return true if the column number is the one dedicated to return addresses.
 * otherwise, false.
 */
bool is_ret(int column) {
	return column == ReturnColumn;
}

/**
 * @brief is_ret
 * @param item
 * @return true if the selected item is in the column for return addresses.
 * otherwise, false.
 */
bool is_ret(const QTableWidgetItem *item) {
	if (!item) {
		return false;
	}

	return is_ret(item->column());
}

}

/**
 * @brief DialogBacktrace::DialogBacktrace
 *
 * Initializes the Dialog with its QTableWidget.  This class over all is
 * designed to analyze the stack for return addresses to show the user the
 * runtime call stack.  The user can double-click addresses to go to them in
 * the CPU Disassembly view or click "Run To Return" on return addresses to
 * return to those addresses.  The first item on the stack should be the
 * current RIP/PC, and "Run To Return" should do a "Step Out"
 * (the behavior for the 1st row should be different than all others.
 *
 * @param parent
 * @param f
 */
DialogBacktrace::DialogBacktrace(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);

	table_ = ui.tableWidgetCallStack;
	table_->verticalHeader()->hide();
	table_->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

	buttonReturnTo_ = new QPushButton(QIcon::fromTheme("edit-undo"), tr("Return To"));
	connect(buttonReturnTo_, &QPushButton::clicked, this, [this]() {
		// Desc: Ensures that the selected item is a return address.  If so, sets a
		//       breakpoint at that address and continues execution.

		//Make sure our current item is in the RETURN_COLUMN
		QTableWidgetItem *item = table_->currentItem();
		if (!is_ret(item)) {
			return;
		}

		edb::address_t address = address_from_table(item);

		if (IProcess *process = edb::v1::debugger_core->process()) {

			// Now that we got the address, we can run.  First check if bp @ that address
			// already exists.
			if (std::shared_ptr<IBreakpoint> bp = edb::v1::debugger_core->findBreakpoint(address)) {
				process->resume(edb::DEBUG_CONTINUE);
				return;
			}

			// Using the non-debugger_core version ensures bp is set in a valid region
			// TODO(eteran): I think it's safe to just use the return value of create_breakpoint here...
			edb::v1::create_breakpoint(address);
			if (std::shared_ptr<IBreakpoint> bp = edb::v1::debugger_core->findBreakpoint(address)) {
				bp->setInternal(true);
				bp->setOneTime(true);
				process->resume(edb::DEBUG_CONTINUE);
			}
		}
	});

	ui.buttonBox->addButton(buttonReturnTo_, QDialogButtonBox::ActionRole);
}

/**
 * @brief DialogBacktrace::showEvent
 *
 * Ensures the column sizes are correct, connects the sig/slot for syncing with
 * the Debugger UI, then populates the Call Stack table.
 *
 */
void DialogBacktrace::showEvent(QShowEvent *) {

	// Sync with the Debugger UI.
	connect(edb::v1::debugger_ui, SIGNAL(uiUpdated()), this, SLOT(populateTable()));

	// Populate the tabel with our call stack info.
	populateTable();

	table_->horizontalHeader()->resizeSections(QHeaderView::Stretch);
}

/**
 * @brief DialogBacktrace::populateTable
 *
 * Populates the Call Stack table with stack frame entries.
 *
 */
void DialogBacktrace::populateTable() {

	//TODO: The first row should break protocol and display the current RIP/PC.
	//		It should be treated specially on "Run To Return" and do a "Step Out"

	//Remove rows of the table (clearing does not remove rows)
	//Yes, we depend on i going negative.
	for (int i = table_->rowCount() - 1; i >= 0; i--) {
		table_->removeRow(i);
	}

	//Get the call stack and populate the table with entries.
	CallStack call_stack;
	const size_t size = call_stack.size();
	for (size_t i = 0; i < size; i++) {

		//Create the row to insert info
		table_->insertRow(i);

		//Get the stack frame so that we can insert its info
		CallStack::StackFrame *frame = call_stack[i];

		//Get the caller & ret addresses and put them in the table
		QList<edb::address_t> stack_entry;
		edb::address_t caller = frame->caller;
		edb::address_t ret    = frame->ret;
		stack_entry.append(caller);
		stack_entry.append(ret);

		//Put them in the table: create string from address and set item flags.
		for (int j = 0; j < stack_entry.size() && j < table_->columnCount(); j++) {

			edb::address_t address              = stack_entry.at(j);
			std::shared_ptr<Symbol> near_symbol = edb::v1::symbol_manager().findNearSymbol(address);

			//Turn the address into a string prefixed with "0x"
			auto item = new QTableWidgetItem;
			item->setData(Qt::UserRole, static_cast<qlonglong>(address));

			if (near_symbol) {
				const QString function = near_symbol->name;
				const uint64_t offset  = address - near_symbol->address;
				item->setText(tr("0x%1 <%2+%3>").arg(QString::number(address, 16), function).arg(offset));
			} else {
				item->setText(tr("0x%1").arg(QString::number(address, 16)));
			}

			//Remove all flags (namely Edit), then put the flags that we want.
			Qt::ItemFlags flags = Qt::NoItemFlags;
			flags |= Qt::ItemIsEnabled | Qt::ItemIsSelectable;
			item->setFlags(flags);

			table_->setItem(i, j, item);
		}
	}

	//1st ret is selected on every refresh so that we can just click "Return To"
	//Turn Run To button off if no item.
	QTableWidgetItem *item = table_->item(FirstRow, ReturnColumn);
	if (item) {
		table_->setCurrentItem(item);
		buttonReturnTo_->setEnabled(true);
	} else {
		buttonReturnTo_->setEnabled(false);
	}
}

/**
 * @brief DialogBacktrace::hideEvent
 *
 * Disconnects the signal/slot when the dialog goes away so that
 * populate_table() is not called unnecessarily.
 *
 */
void DialogBacktrace::hideEvent(QHideEvent *) {
	disconnect(edb::v1::debugger_ui, SIGNAL(uiUpdated()), this, SLOT(populateTable()));
}

/**
 * @brief DialogBacktrace::on_tableWidgetCallStack_itemDoubleClicked
 *
 * Jumps to the double-clicked address in the CPU/Disassembly view.
 *
 * @param item
 */
void DialogBacktrace::on_tableWidgetCallStack_itemDoubleClicked(QTableWidgetItem *item) {
	edb::v1::jump_to_address(address_from_table(item));
}

/**
 * @brief DialogBacktrace::on_tableWidgetCallStack_cellClicked
 *
 * Enables the "Run To Return" button if the selected cell is in the column for
 * return addresses.  Disables it, otherwise.
 *
 * @param row
 * @param column
 */
void DialogBacktrace::on_tableWidgetCallStack_cellClicked(int row, int column) {
	Q_UNUSED(row)
	if (is_ret(column)) {
		buttonReturnTo_->setEnabled(true);
	} else {
		buttonReturnTo_->setEnabled(false);
	}
}

}

```

`plugins/Backtrace/DialogBacktrace.h`:

```h
/*
Copyright (C) 2015	Armen Boursalian
					aboursalian@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_BACKTRACE_H_20191119_
#define DIALOG_BACKTRACE_H_20191119_

#include "CallStack.h"
#include "ui_DialogBacktrace.h"
#include <QDialog>
#include <QTableWidget>

namespace BacktracePlugin {

class DialogBacktrace : public QDialog {
	Q_OBJECT

public:
	explicit DialogBacktrace(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogBacktrace() override = default;

protected:
	void showEvent(QShowEvent *) override;
	void hideEvent(QHideEvent *) override;

public Q_SLOTS:
	void populateTable();

private Q_SLOTS:
	void on_tableWidgetCallStack_itemDoubleClicked(QTableWidgetItem *item);
	void on_tableWidgetCallStack_cellClicked(int row, int column);

private:
	Ui::DialogBacktrace ui;
	QTableWidget *table_;
	QPushButton *buttonReturnTo_;
};

}

#endif

```

`plugins/Backtrace/DialogBacktrace.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>BacktracePlugin::DialogBacktrace</class>
 <widget class="QDialog" name="BacktracePlugin::DialogBacktrace">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>600</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Call Stack</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QTableWidget" name="tableWidgetCallStack">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <column>
      <property name="text">
       <string>Call From</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Return To</string>
      </property>
     </column>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>BacktracePlugin::DialogBacktrace</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>538</x>
     <y>272</y>
    </hint>
    <hint type="destinationlabel">
     <x>538</x>
     <y>256</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>BacktracePlugin::DialogBacktrace</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>576</x>
     <y>286</y>
    </hint>
    <hint type="destinationlabel">
     <x>471</x>
     <y>255</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/BinaryInfo/BinaryInfo.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "BinaryInfo.h"
#include "DialogRegions.h"
#include "ELFXX.h"
#include "IBinary.h"
#include "ISymbolManager.h"
#include "OptionsPage.h"
#include "PE32.h"
#include "edb.h"
#include "symbols.h"

#include <QDebug>
#include <QMenu>

#include <fstream>
#include <memory>

namespace BinaryInfoPlugin {

/**
 * @brief BinaryInfo::BinaryInfo
 * @param parent
 */
BinaryInfo::BinaryInfo(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief BinaryInfo::privateInit
 */
void BinaryInfo::privateInit() {

	edb::v1::register_binary_info([](const std::shared_ptr<IRegion> &region) {
		return std::unique_ptr<IBinary>(new ELF32(region));
	});

	edb::v1::register_binary_info([](const std::shared_ptr<IRegion> &region) {
		return std::unique_ptr<IBinary>(new ELF64(region));
	});

	edb::v1::register_binary_info([](const std::shared_ptr<IRegion> &region) {
		return std::unique_ptr<IBinary>(new PE32(region));
	});

	edb::v1::symbol_manager().setSymbolGenerator(this);
}

/**
 * @brief BinaryInfo::optionsPage
 * @return
 */
QWidget *BinaryInfo::optionsPage() {
	return new OptionsPage;
}

/**
 * @brief BinaryInfo::menu
 * @param parent
 * @return
 */
QMenu *BinaryInfo::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("Binary Info"), parent);
		menu_->addAction(tr("&Explore Binary Header"), this, SLOT(exploreHeader()));
	}

	return menu_;
}

/**
 * @brief BinaryInfo::exploreHeader
 */
void BinaryInfo::exploreHeader() {
	static auto dialog = new DialogRegions(edb::v1::debugger_ui);
	dialog->show();
}

/**
 * @brief BinaryInfo::extraArguments
 * @return
 */
QString BinaryInfo::extraArguments() const {
	return " --symbols <filename>      : generate symbols for <filename> and exit";
}

/**
 * @brief BinaryInfo::parseArguments
 * @param args
 * @return
 */
IPlugin::ArgumentStatus BinaryInfo::parseArguments(QStringList &args) {

	if (args.size() == 3 && args[1] == "--symbols") {
		generate_symbols(args[2]);
		return ARG_EXIT;
	}

	return ARG_SUCCESS;
}

/**
 * @brief BinaryInfo::generateSymbolFile
 * @param filename
 * @param symbol_file
 * @return
 */
bool BinaryInfo::generateSymbolFile(const QString &filename, const QString &symbol_file) {

	std::ofstream file(qPrintable(symbol_file));
	if (file) {
		if (generate_symbols(filename, file)) {
			return true;
		}
	}

	return false;
}

}

```

`plugins/BinaryInfo/BinaryInfo.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef BINARY_INFO_H_20061122_
#define BINARY_INFO_H_20061122_

#include "IPlugin.h"
#include "ISymbolGenerator.h"
#include "Types.h"

class QMenu;

namespace BinaryInfoPlugin {

class BinaryInfo : public QObject, public IPlugin, public ISymbolGenerator {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit BinaryInfo(QObject *parent = nullptr);

private:
	void privateInit() override;
	QWidget *optionsPage() override;

public:
	QMenu *menu(QWidget *parent = nullptr) override;
	QString extraArguments() const override;
	ArgumentStatus parseArguments(QStringList &args) override;

public:
	bool generateSymbolFile(const QString &filename, const QString &symbol_file) override;

public Q_SLOTS:
	void exploreHeader();

private:
	QMenu *menu_ = nullptr;
};

}

#endif

```

`plugins/BinaryInfo/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "BinaryInfo")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	BinaryInfo.cpp
	BinaryInfo.h
	demangle.h
	DialogRegions.cpp
	DialogRegions.h
	DialogRegions.ui
	DialogHeader.ui
	DialogHeader.cpp
	DialogHeader.h
	ELF32.cpp
	ELF64.cpp
	ELFXX.cpp
	ELFXX.h
	OptionsPage.cpp
	OptionsPage.h
	OptionsPage.ui
	PE32.cpp
	PE32.h
	symbols.cpp
	symbols.h
)

target_link_libraries(${PluginName} Qt5::Widgets PE ELF edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})


```

`plugins/BinaryInfo/DialogHeader.cpp`:

```cpp

#include "DialogHeader.h"
#include "ELFXX.h"
#include "PE32.h"
#include "QtHelper.h"
#include "edb.h"

namespace BinaryInfoPlugin {
namespace {

Q_DECLARE_NAMESPACE_TR(BinaryInfo)

template <class Header>
QTreeWidgetItem *create_elf_magic(const Header *header) {

	auto item = new QTreeWidgetItem;

	item->setText(0, tr("Magic"));
	item->setText(1, QString("0x%1, %2, %3, %4")
						 .arg(header->e_ident[EI_MAG0], 0, 16)
						 .arg(static_cast<char>(header->e_ident[EI_MAG1]))
						 .arg(static_cast<char>(header->e_ident[EI_MAG2]))
						 .arg(static_cast<char>(header->e_ident[EI_MAG3])));

	return item;
}

template <class Header>
QTreeWidgetItem *create_elf_class(const Header *header) {

	auto item = new QTreeWidgetItem;

	item->setText(0, tr("Class"));
	switch (header->e_ident[EI_CLASS]) {
	case ELFCLASS32:
		item->setText(1, tr("32-bit"));
		break;
	case ELFCLASS64:
		item->setText(1, tr("64-bit"));
		break;
	default:
		item->setText(1, tr("Invalid"));
		break;
	}
	return item;
}

template <class Header>
QTreeWidgetItem *create_elf_data(const Header *header) {

	auto item = new QTreeWidgetItem;

	item->setText(0, tr("Data"));
	switch (header->e_ident[EI_DATA]) {
	case ELFDATA2LSB:
		item->setText(1, tr("2's complement, little endian"));
		break;
	case ELFDATA2MSB:
		item->setText(1, tr("2's complement, big endian"));
		break;
	default:
		item->setText(1, tr("Invalid"));
		break;
	}
	return item;
}

template <class Header>
QTreeWidgetItem *create_elf_version(const Header *header) {

	auto item = new QTreeWidgetItem;

	item->setText(0, tr("Version"));
	switch (header->e_ident[EI_VERSION]) {
	case EV_CURRENT:
		item->setText(1, tr("Current"));
		break;
	default:
		item->setText(1, tr("Invalid"));
		break;
	}
	return item;
}

template <class Header>
QTreeWidgetItem *create_elf_abi(const Header *header) {

	auto item = new QTreeWidgetItem;

	item->setText(0, tr("ABI"));
	switch (header->e_ident[EI_OSABI]) {
	case ELFOSABI_SYSV:
		//case ELFOSABI_NONE: // alias
		item->setText(1, tr("UNIX System V ABI"));
		break;
	case ELFOSABI_HPUX:
		item->setText(1, tr("HP-UX"));
		break;
	case ELFOSABI_NETBSD:
		item->setText(1, tr("NetBSD"));
		break;
	case ELFOSABI_GNU:
		// case ELFOSABI_LINUX: // alias
		item->setText(1, tr("GNU/Linux"));
		break;
	case ELFOSABI_SOLARIS:
		item->setText(1, tr("Sun Solaris"));
		break;
	case ELFOSABI_AIX:
		item->setText(1, tr("IBM AIX"));
		break;
	case ELFOSABI_IRIX:
		item->setText(1, tr("SGI Irix"));
		break;
	case ELFOSABI_FREEBSD:
		item->setText(1, tr("FreeBSD"));
		break;
	case ELFOSABI_TRU64:
		item->setText(1, tr("Compaq TRU64 UNIX"));
		break;
	case ELFOSABI_MODESTO:
		item->setText(1, tr("Novell Modesto"));
		break;
	case ELFOSABI_OPENBSD:
		item->setText(1, tr("OpenBSD"));
		break;
	case ELFOSABI_ARM_AEABI:
		item->setText(1, tr("ARM EABI"));
		break;
	case ELFOSABI_ARM:
		item->setText(1, tr("ARM"));
		break;
	case ELFOSABI_STANDALONE:
		item->setText(1, tr("Standalone (embedded) application"));
		break;
	default:
		item->setText(1, tr("Invalid"));
		break;
	}
	return item;
}

template <class Header>
QTreeWidgetItem *create_elf_abi_version(const Header *header) {

	auto item = new QTreeWidgetItem;

	item->setText(0, tr("ABI Version"));
	item->setText(1, QString("%1").arg(header->e_ident[EI_MAG0], 0, 10));

	return item;
}

template <class Header>
QTreeWidgetItem *create_elf_type(const Header *header) {

	auto item = new QTreeWidgetItem;

	item->setText(0, tr("Type"));

	switch (header->e_type) {
	case ET_NONE:
		item->setText(1, tr("No file type"));
		break;
	case ET_REL:
		item->setText(1, tr("Relocatable file"));
		break;
	case ET_EXEC:
		item->setText(1, tr("Executable file"));
		break;
	case ET_DYN:
		item->setText(1, tr("Shared object file"));
		break;
	case ET_CORE:
		item->setText(1, tr("Core file"));
		break;
	default:
		item->setText(1, tr("<OS Specific>"));
		break;
	}
	return item;
}

template <class Header>
QTreeWidgetItem *create_elf_machine(const Header *header) {

	auto item = new QTreeWidgetItem;

	item->setText(0, tr("Machine"));

	switch (header->e_machine) {
	case EM_NONE:
		item->setText(1, tr("No machine"));
		break;
	case EM_M32:
		item->setText(1, tr("AT&T WE 32100"));
		break;
	case EM_SPARC:
		item->setText(1, tr("SUN SPARC"));
		break;
	case EM_386:
		item->setText(1, tr("Intel 80386"));
		break;
	case EM_68K:
		item->setText(1, tr("Motorola m68k family"));
		break;
	case EM_88K:
		item->setText(1, tr("Motorola m88k family"));
		break;
	case EM_860:
		item->setText(1, tr("Intel 80860"));
		break;
	case EM_MIPS:
		item->setText(1, tr("MIPS R3000 big-endian"));
		break;
	case EM_S370:
		item->setText(1, tr("IBM System/370"));
		break;
	case EM_MIPS_RS3_LE:
		item->setText(1, tr("MIPS R3000 little-endian"));
		break;
	case EM_PARISC:
		item->setText(1, tr("HPPA"));
		break;
	case EM_VPP500:
		item->setText(1, tr("Fujitsu VPP500"));
		break;
	case EM_SPARC32PLUS:
		item->setText(1, tr("Sun's \"v8plus\""));
		break;
	case EM_960:
		item->setText(1, tr("Intel 80960"));
		break;
	case EM_PPC:
		item->setText(1, tr("PowerPC"));
		break;
	case EM_PPC64:
		item->setText(1, tr("PowerPC 64-bit"));
		break;
	case EM_S390:
		item->setText(1, tr("IBM S390"));
		break;
	case EM_V800:
		item->setText(1, tr("NEC V800 series"));
		break;
	case EM_FR20:
		item->setText(1, tr("Fujitsu FR20"));
		break;
	case EM_RH32:
		item->setText(1, tr("TRW RH-32"));
		break;
	case EM_RCE:
		item->setText(1, tr("Motorola RCE"));
		break;
	case EM_ARM:
		item->setText(1, tr("ARM"));
		break;
	case EM_FAKE_ALPHA:
		item->setText(1, tr("Digital Alpha"));
		break;
	case EM_SH:
		item->setText(1, tr("Hitachi SH"));
		break;
	case EM_SPARCV9:
		item->setText(1, tr("SPARC v9 64-bit"));
		break;
	case EM_TRICORE:
		item->setText(1, tr("Siemens Tricore"));
		break;
	case EM_ARC:
		item->setText(1, tr("Argonaut RISC Core"));
		break;
	case EM_H8_300:
		item->setText(1, tr("Hitachi H8/300"));
		break;
	case EM_H8_300H:
		item->setText(1, tr("Hitachi H8/300H"));
		break;
	case EM_H8S:
		item->setText(1, tr("Hitachi H8S"));
		break;
	case EM_H8_500:
		item->setText(1, tr("Hitachi H8/500"));
		break;
	case EM_IA_64:
		item->setText(1, tr("Intel Merced"));
		break;
	case EM_MIPS_X:
		item->setText(1, tr("Stanford MIPS-X"));
		break;
	case EM_COLDFIRE:
		item->setText(1, tr("Motorola Coldfire"));
		break;
	case EM_68HC12:
		item->setText(1, tr("Motorola M68HC12"));
		break;
	case EM_MMA:
		item->setText(1, tr("Fujitsu MMA Multimedia Accelerator"));
		break;
	case EM_PCP:
		item->setText(1, tr("Siemens PCP"));
		break;
	case EM_NCPU:
		item->setText(1, tr("Sony nCPU embeeded RISC"));
		break;
	case EM_NDR1:
		item->setText(1, tr("Denso NDR1 microprocessor"));
		break;
	case EM_STARCORE:
		item->setText(1, tr("Motorola Start*Core processor"));
		break;
	case EM_ME16:
		item->setText(1, tr("Toyota ME16 processor"));
		break;
	case EM_ST100:
		item->setText(1, tr("STMicroelectronic ST100 processor"));
		break;
	case EM_TINYJ:
		item->setText(1, tr("Advanced Logic Corp. Tinyj emb.fam"));
		break;
	case EM_X86_64:
		item->setText(1, tr("AMD x86-64 architecture"));
		break;
	case EM_PDSP:
		item->setText(1, tr("Sony DSP Processor"));
		break;
	case EM_FX66:
		item->setText(1, tr("Siemens FX66 microcontroller"));
		break;
	case EM_ST9PLUS:
		item->setText(1, tr("STMicroelectronics ST9+ 8/16 mc"));
		break;
	case EM_ST7:
		item->setText(1, tr("STmicroelectronics ST7 8 bit mc"));
		break;
	case EM_68HC16:
		item->setText(1, tr("Motorola MC68HC16 microcontroller"));
		break;
	case EM_68HC11:
		item->setText(1, tr("Motorola MC68HC11 microcontroller"));
		break;
	case EM_68HC08:
		item->setText(1, tr("Motorola MC68HC08 microcontroller"));
		break;
	case EM_68HC05:
		item->setText(1, tr("Motorola MC68HC05 microcontroller"));
		break;
	case EM_SVX:
		item->setText(1, tr("Silicon Graphics SVx"));
		break;
	case EM_ST19:
		item->setText(1, tr("STMicroelectronics ST19 8 bit mc"));
		break;
	case EM_VAX:
		item->setText(1, tr("Digital VAX"));
		break;
	case EM_CRIS:
		item->setText(1, tr("Axis Communications 32-bit embedded processor"));
		break;
	case EM_JAVELIN:
		item->setText(1, tr("Infineon Technologies 32-bit embedded processor"));
		break;
	case EM_FIREPATH:
		item->setText(1, tr("Element 14 64-bit DSP Processor"));
		break;
	case EM_ZSP:
		item->setText(1, tr("LSI Logic 16-bit DSP Processor"));
		break;
	case EM_MMIX:
		item->setText(1, tr("Donald Knuth's educational 64-bit processor"));
		break;
	case EM_HUANY:
		item->setText(1, tr("Harvard University machine-independent object files"));
		break;
	case EM_PRISM:
		item->setText(1, tr("SiTera Prism"));
		break;
	case EM_AVR:
		item->setText(1, tr("Atmel AVR 8-bit microcontroller"));
		break;
	case EM_FR30:
		item->setText(1, tr("Fujitsu FR30"));
		break;
	case EM_D10V:
		item->setText(1, tr("Mitsubishi D10V"));
		break;
	case EM_D30V:
		item->setText(1, tr("Mitsubishi D30V"));
		break;
	case EM_V850:
		item->setText(1, tr("NEC v850"));
		break;
	case EM_M32R:
		item->setText(1, tr("Mitsubishi M32R"));
		break;
	case EM_MN10300:
		item->setText(1, tr("Matsushita MN10300"));
		break;
	case EM_MN10200:
		item->setText(1, tr("Matsushita MN10200"));
		break;
	case EM_PJ:
		item->setText(1, tr("picoJava"));
		break;
	case EM_OPENRISC:
		item->setText(1, tr("OpenRISC 32-bit embedded processor"));
		break;
	case EM_ARC_A5:
		item->setText(1, tr("ARC Cores Tangent-A5"));
		break;
	case EM_XTENSA:
		item->setText(1, tr("Tensilica Xtensa Architecture"));
		break;
	default:
		item->setText(1, tr("Unknown"));
		break;
	}
	return item;
}

template <class Header>
QTreeWidgetItem *create_elf_object_version(const Header *header) {

	auto item = new QTreeWidgetItem;

	item->setText(0, tr("Object File Version"));
	item->setText(1, QString("%1").arg(header->e_version, 0, 10));

	return item;
}

template <class Header>
QTreeWidgetItem *create_elf_entry_point(const Header *header) {

	auto item = new QTreeWidgetItem;

	item->setText(0, tr("Entry Point"));
	item->setText(1, QString("0x%1").arg(header->e_entry, 0, 16));

	return item;
}

}

DialogHeader::DialogHeader(const std::shared_ptr<IRegion> &region, QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {
	ui.setupUi(this);

	if (std::unique_ptr<IBinary> binary_info = edb::v1::get_binary_info(region)) {

		if (auto elf32 = dynamic_cast<ELF32 *>(binary_info.get())) {

			auto header = reinterpret_cast<const elf32_header *>(elf32->header());

			auto root = new QTreeWidgetItem;
			root->setText(0, tr("ELF32"));

			root->addChild(create_elf_magic(header));
			root->addChild(create_elf_class(header));
			root->addChild(create_elf_data(header));
			root->addChild(create_elf_version(header));
			root->addChild(create_elf_abi(header));
			root->addChild(create_elf_abi_version(header));
			root->addChild(create_elf_type(header));
			root->addChild(create_elf_machine(header));
			root->addChild(create_elf_object_version(header));
			root->addChild(create_elf_entry_point(header));

			ui.treeWidget->insertTopLevelItem(0, root);
		}

		if (auto elf64 = dynamic_cast<ELF64 *>(binary_info.get())) {

			auto header = reinterpret_cast<const elf64_header *>(elf64->header());

			auto root = new QTreeWidgetItem;
			root->setText(0, tr("ELF64"));

			root->addChild(create_elf_magic(header));
			root->addChild(create_elf_class(header));
			root->addChild(create_elf_data(header));
			root->addChild(create_elf_version(header));
			root->addChild(create_elf_abi(header));
			root->addChild(create_elf_abi_version(header));
			root->addChild(create_elf_type(header));
			root->addChild(create_elf_machine(header));
			root->addChild(create_elf_object_version(header));
			root->addChild(create_elf_entry_point(header));

			ui.treeWidget->insertTopLevelItem(0, root);
		}

		if (auto pe32 = dynamic_cast<PE32 *>(binary_info.get())) {
			Q_UNUSED(pe32)
#if 0
			auto header = reinterpret_cast<const pe32_header *>(pe32->header());
#endif
			auto root = new QTreeWidgetItem;
			root->setText(0, tr("PE32"));
			ui.treeWidget->insertTopLevelItem(0, root);
		}
	}
}

}

```

`plugins/BinaryInfo/DialogHeader.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_HEADER_H_20190403_
#define DIALOG_HEADER_H_20190403_

#include "IRegion.h"
#include "Types.h"
#include "ui_DialogHeader.h"
#include <QDialog>
#include <memory>

class QStringListModel;
class QSortFilterProxyModel;
class QModelIndex;

namespace BinaryInfoPlugin {

class DialogHeader : public QDialog {
	Q_OBJECT

public:
	explicit DialogHeader(const std::shared_ptr<IRegion> &region, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogHeader() override = default;

private:
	Ui::DialogHeader ui;
};

}

#endif

```

`plugins/BinaryInfo/DialogHeader.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>BinaryInfoPlugin::DialogHeader</class>
 <widget class="QDialog" name="BinaryInfoPlugin::DialogHeader">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>630</width>
    <height>390</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Binary Header</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QTreeWidget" name="treeWidget">
     <column>
      <property name="text">
       <string>Header</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Value</string>
      </property>
     </column>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>BinaryInfoPlugin::DialogHeader</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>588</x>
     <y>380</y>
    </hint>
    <hint type="destinationlabel">
     <x>5</x>
     <y>278</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>BinaryInfoPlugin::DialogHeader</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>102</x>
     <y>366</y>
    </hint>
    <hint type="destinationlabel">
     <x>49</x>
     <y>346</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/BinaryInfo/DialogRegions.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogRegions.h"
#include "DialogHeader.h"
#include "MemoryRegions.h"
#include "edb.h"
#include <QMessageBox>
#include <QPushButton>
#include <QSortFilterProxyModel>
#include <QTreeWidgetItem>

namespace BinaryInfoPlugin {

/**
 * @brief DialogRegions::DialogRegions
 * @param parent
 */
DialogRegions::DialogRegions(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
	ui.tableView->verticalHeader()->hide();
	ui.tableView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

	filterModel_ = new QSortFilterProxyModel(this);
	connect(ui.txtSearch, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);

	buttonExplore_ = new QPushButton(QIcon::fromTheme("edit-find"), tr("Explore Header"));
	connect(buttonExplore_, &QPushButton::clicked, this, [this]() {
		const QItemSelectionModel *const selModel = ui.tableView->selectionModel();
		const QModelIndexList sel                 = selModel->selectedRows();

		if (sel.size() == 0) {
			QMessageBox::critical(
				this,
				tr("No Region Selected"),
				tr("You must select a region which is to be scanned for executable headers."));
		} else {

			for (const QModelIndex &selected_item : sel) {

				const QModelIndex index = filterModel_->mapToSource(selected_item);
				if (auto region = *reinterpret_cast<const std::shared_ptr<IRegion> *>(index.internalPointer())) {
					auto dialog = new DialogHeader(region, this);
					dialog->show();
				}
			}
		}
	});

	ui.buttonBox->addButton(buttonExplore_, QDialogButtonBox::ActionRole);
}

/**
 * @brief DialogRegions::showEvent
 */
void DialogRegions::showEvent(QShowEvent *) {
	filterModel_->setFilterKeyColumn(3);
	filterModel_->setSourceModel(&edb::v1::memory_regions());
	ui.tableView->setModel(filterModel_);
}

}

```

`plugins/BinaryInfo/DialogRegions.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_REGIONS_H_20111128_
#define DIALOG_REGIONS_H_20111128_

#include "Types.h"
#include "ui_DialogRegions.h"
#include <QDialog>

class QStringListModel;
class QSortFilterProxyModel;
class QModelIndex;

namespace BinaryInfoPlugin {

class DialogRegions : public QDialog {
	Q_OBJECT

public:
	explicit DialogRegions(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogRegions() override = default;

private:
	void showEvent(QShowEvent *event) override;

private:
	Ui::DialogRegions ui;
	QSortFilterProxyModel *filterModel_ = nullptr;
	QPushButton *buttonExplore_         = nullptr;
};

}

#endif

```

`plugins/BinaryInfo/DialogRegions.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>BinaryInfoPlugin::DialogRegions</class>
 <widget class="QDialog" name="BinaryInfoPlugin::DialogRegions">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>640</width>
    <height>400</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Header Explorer</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="label">
     <property name="text">
      <string>Regions:</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLineEdit" name="txtSearch">
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QTableView" name="tableView">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>txtSearch</tabstop>
  <tabstop>tableView</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>BinaryInfoPlugin::DialogRegions</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>592</x>
     <y>382</y>
    </hint>
    <hint type="destinationlabel">
     <x>593</x>
     <y>399</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>BinaryInfoPlugin::DialogRegions</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>557</x>
     <y>369</y>
    </hint>
    <hint type="destinationlabel">
     <x>540</x>
     <y>399</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/BinaryInfo/ELF32.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ELFXX.h"
#include "IDebugger.h"
#include "edb.h"
#include "string_hash.h"

namespace BinaryInfoPlugin {

/**
 * @brief ELF32::native
 * @return true if this binary is native to the arch edb was built for
 */
template <>
bool ELF32::native() const {
#if defined(EDB_X86) || defined(EDB_X86_64)
	return edb::v1::debugger_core->cpuType() == edb::string_hash("x86");
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	return edb::v1::debugger_core->cpuType() == edb::string_hash("arm");
#else
#error "Unsupported Architecture"
#endif
}

}

```

`plugins/BinaryInfo/ELF64.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ELFXX.h"
#include "IDebugger.h"
#include "edb.h"
#include "string_hash.h"

namespace BinaryInfoPlugin {

/**
 * @brief ELF64::native
 * @return true if this binary is native to the arch edb was built for
 */
template <>
bool ELF64::native() const {
#if defined(EDB_X86) || defined(EDB_X86_64)
	return edb::v1::debugger_core->cpuType() == edb::string_hash("x86-64");
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	return edb::v1::debugger_core->cpuType() == edb::string_hash("AArch64");
#else
#error "Unsupported Architecture"
#endif
}

}

```

`plugins/BinaryInfo/ELFXX.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ELFXX.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IRegion.h"
#include "MemoryRegions.h"
#include "Util.h"
#include "edb.h"
#include "libELF/elf_phdr.h"
#include "string_hash.h"

#include <QDebug>
#include <QFile>
#include <QVector>
#include <cstdint>
#include <cstring>

namespace BinaryInfoPlugin {

class ELFBinaryException : public std::exception {
	const char *what() const noexcept override = 0;
};

class InvalidArguments : public ELFBinaryException {
public:
	const char *what() const noexcept override {
		return "Invalid Arguments";
	}
};

class ReadFailure : public ELFBinaryException {
public:
	const char *what() const noexcept override {
		return "Read Failure";
	}
};

class InvalidELF : public ELFBinaryException {
public:
	const char *what() const noexcept override {
		return "Invalid ELF";
	}
};

class InvalidArchitecture : public ELFBinaryException {
public:
	const char *what() const noexcept override {
		return "Invalid Architecture";
	}
};

template <class ElfHeader>
ELFXX<ElfHeader>::ELFXX(const std::shared_ptr<IRegion> &region)
	: region_(region) {

	using phdr_type = typename ElfHeader::elf_phdr;

	if (!region_) {
		throw InvalidArguments();
	}

	IProcess *const process = edb::v1::debugger_core->process();
	if (!process) {
		throw ReadFailure();
	}

	if (!process->readBytes(region_->start(), &header_, sizeof(ElfHeader))) {
		throw ReadFailure();
	}

	validateHeader();

	headers_.push_back({region_->start(), header_.e_ehsize});
	headers_.push_back({region_->start() + header_.e_phoff, static_cast<size_t>(header_.e_phentsize * header_.e_phnum)});

	auto phdr_size = header_.e_phentsize;

	if (phdr_size < sizeof(phdr_type)) {
		qDebug() << QString::number(region_->start(), 16) << "program header size less than expected";
		baseAddress_ = region_->start();
		return;
	}

	phdr_type phdr;

	auto phdr_base        = region_->start() + header_.e_phoff;
	edb::address_t lowest = ULLONG_MAX;

	if (header_.e_type == ET_EXEC) {

		// iterate all of the program headers
		for (uint16_t entry = 0; entry < header_.e_phnum; ++entry) {

			if (!process->readBytes(phdr_base + (phdr_size * entry), &phdr, sizeof(phdr_type))) {
				qDebug() << "Failed to read program header";
				break;
			}

			if (phdr.p_type == PT_LOAD && phdr.p_vaddr < lowest) {
				lowest = phdr.p_vaddr;
				// NOTE(eteran): they are defined to be in ascending order of vaddr
				break;
			}
		}
	} else if (header_.e_type == ET_DYN) {

		const QString process_executable = edb::v1::debugger_core->process()->name();
		for (const std::shared_ptr<IRegion> &r : edb::v1::memory_regions().regions()) {
			if (r->executable() && r->name() == region->name()) {
				lowest = std::min(lowest, r->start());
			}
		}
	}

	if (lowest == ULLONG_MAX) {
		qDebug() << "binary base address not found. Assuming " << QString::number(region_->start(), 16);
		baseAddress_ = region->start();
	} else {
		baseAddress_ = lowest;
	}
}

template <class ElfHeader>
/**
 * @brief ELFXX<ElfHeader>::headerSize
 * @return the number of bytes in this executable's header
 */
size_t ELFXX<ElfHeader>::headerSize() const {
	size_t size = header_.e_ehsize;
	// Do the program headers immediately follow the ELF header?
	if (size == header_.e_phoff) {
		size += header_.e_phentsize * header_.e_phnum;
	}
	return size;
}

/**
 * @brief ELFXX<ElfHeader>::headers
 * @return a list of all headers in this binary
 */
template <class ElfHeader>
std::vector<IBinary::Header> ELFXX<ElfHeader>::headers() const {
	return headers_;
}

/**
 * @brief ELFXX<ElfHeader>::validateHeader
 *
 * ensures that the header that we read was valid
 */
template <class ElfHeader>
void ELFXX<ElfHeader>::validateHeader() {
	if (std::memcmp(header_.e_ident, ELFMAG, SELFMAG) != 0) {
		throw InvalidELF();
	}
	if (header_.e_ident[EI_CLASS] != ElfHeader::ELFCLASS) {
		throw InvalidArchitecture();
	}
}

/**
 * @brief ELFXX<ElfHeader>::entryPoint
 * @return the entry point if any of the binary
 */
template <class ElfHeader>
edb::address_t ELFXX<ElfHeader>::entryPoint() {
	return header_.e_entry + baseAddress_;
}

/**
 * @brief ELFXX<ElfHeader>::header
 * @return a copy of the file header or nullptr if the region wasn't a valid,
 * known binary type
 */
template <class ElfHeader>
const void *ELFXX<ElfHeader>::header() const {
	return &header_;
}

// explicit instantiations
template class ELFXX<elf32_header>;
template class ELFXX<elf64_header>;

}

```

`plugins/BinaryInfo/ELFXX.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ELFXX_H_20070718_
#define ELFXX_H_20070718_

#include "IBinary.h"
#include "libELF/elf_binary.h"

namespace BinaryInfoPlugin {

template <class ElfHeader>
class ELFXX : public IBinary {
public:
	explicit ELFXX(const std::shared_ptr<IRegion> &region);
	~ELFXX() override = default;

public:
	bool native() const override;
	edb::address_t entryPoint() override;
	size_t headerSize() const override;
	const void *header() const override;
	std::vector<Header> headers() const override;

private:
	void validateHeader();

private:
	std::shared_ptr<IRegion> region_;
	ElfHeader header_;
	edb::address_t baseAddress_{0};
	std::vector<Header> headers_;
};

using ELF32 = ELFXX<elf32_header>;
using ELF64 = ELFXX<elf64_header>;

}

#endif

```

`plugins/BinaryInfo/OptionsPage.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "OptionsPage.h"
#include "demangle.h"
#include <QFileDialog>
#include <QSettings>

namespace BinaryInfoPlugin {

OptionsPage::OptionsPage(QWidget *parent, Qt::WindowFlags f)
	: QWidget(parent, f) {
	ui.setupUi(this);
}

void OptionsPage::showEvent(QShowEvent *) {

	QSettings settings;

#ifdef DEMANGLING_SUPPORTED
	ui.checkBox->setChecked(settings.value("BinaryInfo/demangling_enabled", true).toBool());
#else
	ui.checkBox->setEnabled(false);
	ui.checkBox->setChecked(false);
#endif

	ui.txtDebugDir->setText(settings.value("BinaryInfo/debug_info_path", "/usr/lib/debug").toString());
}

void OptionsPage::on_checkBox_toggled(bool checked) {
	QSettings settings;
	settings.setValue("BinaryInfo/demangling_enabled", checked);
}

void OptionsPage::on_txtDebugDir_textChanged(const QString &text) {
	QSettings settings;
	settings.setValue("BinaryInfo/debug_info_path", text);
}

void OptionsPage::on_btnDebugDir_clicked() {
	QString dir = QFileDialog::getExistingDirectory(
		this,
		tr("Choose a directory"),
		QString(),
		QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);

	if (!dir.isNull()) {
		ui.txtDebugDir->setText(dir);
	}
}

}

```

`plugins/BinaryInfo/OptionsPage.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef OPTIONS_PAGE_H_20151113_
#define OPTIONS_PAGE_H_20151113_

#include "ui_OptionsPage.h"
#include <QWidget>
#include <memory>

namespace BinaryInfoPlugin {

class OptionsPage : public QWidget {
	Q_OBJECT

public:
	explicit OptionsPage(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~OptionsPage() override = default;

public:
	void showEvent(QShowEvent *event) override;

public Q_SLOTS:
	void on_checkBox_toggled(bool checked = false);
	void on_txtDebugDir_textChanged(const QString &text);
	void on_btnDebugDir_clicked();

private:
	Ui::OptionsPage ui;
};

}

#endif

```

`plugins/BinaryInfo/OptionsPage.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>BinaryInfoPlugin::OptionsPage</class>
 <widget class="QWidget" name="BinaryInfoPlugin::OptionsPage">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>334</width>
    <height>323</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>BinaryInfo Plugin</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QCheckBox" name="checkBox">
     <property name="text">
      <string>Demangle auto-generated symbols</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="label_7">
       <property name="text">
        <string>Debug Info Directory</string>
       </property>
       <property name="buddy">
        <cstring>txtDebugDir</cstring>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="txtDebugDir"/>
     </item>
     <item>
      <widget class="QToolButton" name="btnDebugDir">
       <property name="text">
        <string>...</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>262</height>
      </size>
     </property>
    </spacer>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`plugins/BinaryInfo/PE32.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PE32.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IRegion.h"
#include "edb.h"
#include "libPE/pe_binary.h"
#include "string_hash.h"
#include <QDebug>

namespace BinaryInfoPlugin {

PEBinaryException::PEBinaryException(Reason reason)
	: reason_(reason) {
}
const char *PEBinaryException::what() const noexcept {
	return "PEBinaryException";
}

/**
 * @brief PE32::PE32
 * @param region
 */
PE32::PE32(const std::shared_ptr<IRegion> &region)
	: region_(region) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
	constexpr WORD DosMagic = 0x5A4D;
	constexpr LONG PeMagic  = 0x00004550;
#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
	constexpr WORD dos_magic = 0x4D5A;
	constexpr LONG pe_magic  = 0x50450000;
#endif

	if (!region_) {
		throw PEBinaryException(PEBinaryException::Reason::INVALID_ARGUMENTS);
	}
	IProcess *process = edb::v1::debugger_core->process();

	if (!process) {
		throw PEBinaryException(PEBinaryException::Reason::READ_FAILURE);
	}

	if (!process->readBytes(region_->start(), &dos_, sizeof(dos_))) {
		throw PEBinaryException(PEBinaryException::Reason::READ_FAILURE);
	}

	if (dos_.e_magic != DosMagic || dos_.e_lfanew == 0) {
		throw PEBinaryException(PEBinaryException::Reason::INVALID_PE);
	}

	if (!process->readBytes(region_->start() + dos_.e_lfanew, &pe_, sizeof(pe_))) {
		throw PEBinaryException(PEBinaryException::Reason::READ_FAILURE);
	}

	if (pe_.Signature != PeMagic) {
		throw PEBinaryException(PEBinaryException::Reason::INVALID_PE);
	}
}

/**
 * @brief PE32::entryPoint
 * @return
 */
edb::address_t PE32::entryPoint() {
	// TODO(eteran): relative to pe_.OptionalHeader.ImageBase;?
	return pe_.OptionalHeader.AddressOfEntryPoint;
}

/**
 * @brief PE32::native
 * @return
 */
bool PE32::native() const {
	return true;
}

/**
 * @brief PE32::headerSize
 * @return
 */
size_t PE32::headerSize() const {
	return sizeof(pe_) + dos_.e_lfanew;
}

/**
 * @brief PE32::headers
 * @return a list of all headers in this binary
 */
std::vector<IBinary::Header> PE32::headers() const {
	std::vector<Header> results = {
		{region_->start(), sizeof(pe_) + dos_.e_lfanew}};
	return results;
}

/**
 * @brief PE32::header
 * @return a copy of the file header or nullptr if the region wasn't a valid,
 * known binary type
 */
const void *PE32::header() const {
	return nullptr;
}

}

```

`plugins/BinaryInfo/PE32.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PE32_H_20070718_
#define PE32_H_20070718_

#include "IBinary.h"
#include "libPE/pe_binary.h"

namespace BinaryInfoPlugin {

class PEBinaryException : public std::exception {
public:
	enum Reason {
		INVALID_ARGUMENTS    = 1,
		READ_FAILURE         = 2,
		INVALID_PE           = 3,
		INVALID_ARCHITECTURE = 4
	};

public:
	explicit PEBinaryException(Reason reason);
	const char *what() const noexcept override;

private:
	Reason reason_;
};

class PE32 : public IBinary {
public:
	explicit PE32(const std::shared_ptr<IRegion> &region);
	~PE32() override = default;

public:
	bool native() const override;
	edb::address_t entryPoint() override;
	size_t headerSize() const override;
	const void *header() const override;
	std::vector<Header> headers() const override;

private:
	std::shared_ptr<IRegion> region_;
	libPE::IMAGE_DOS_HEADER dos_  = {};
	libPE::IMAGE_NT_HEADERS32 pe_ = {};
};

}

#endif

```

`plugins/BinaryInfo/demangle.h`:

```h

#ifndef EDB_DEMANGLE_H_20151113_
#define EDB_DEMANGLE_H_20151113_

#include <QString>
#include <QStringList>

#ifdef __GNUG__
#include <cxxabi.h>
#include <memory>

#define DEMANGLING_SUPPORTED

inline QString demangle(const QString &mangled) {
	if (!mangled.startsWith("_Z")) {
		return mangled; // otherwise we'll try to demangle C functions coinciding with types like "f" as "float", which is bad
	}

	int failed        = 0;
	QStringList split = mangled.split("@"); // for cases like funcName@plt

	std::unique_ptr<char, decltype(std::free) *> demangled(abi::__cxa_demangle(split.front().toStdString().c_str(), nullptr, nullptr, &failed), std::free);

	if (failed) {
		return mangled;
	}

	split.front() = QString(demangled.get());
	return split.join("@");
}

#else

inline QString demangle(const QString &mangled) {
	return mangled;
}

#endif

#endif

```

`plugins/BinaryInfo/symbols.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "symbols.h"
#include "demangle.h"
#include "edb.h"

#include <iostream>
#include <memory>
#include <set>

#include <QDateTime>
#include <QDebug>
#include <QFile>
#include <QFileInfo>
#include <QList>
#include <QSettings>
#include <QString>

#include "libELF/elf_header.h"
#include "libELF/elf_model.h"
#include "libELF/elf_rel.h"
#include "libELF/elf_rela.h"
#include "libELF/elf_shdr.h"
#include "libELF/elf_sym.h"
#include "libELF/elf_syminfo.h"
#include "libELF/elf_types.h"

namespace BinaryInfoPlugin {
namespace {

struct elf32_model : elf_model<32> {

	static constexpr size_t plt_entry_size = 0x10;

	static constexpr uint32_t elf_r_sym(uint32_t x) { return ELF32_R_SYM(x); }
	static constexpr uint32_t elf_r_type(uint32_t x) { return ELF32_R_TYPE(x); }
	static constexpr uint8_t elf_st_type(uint8_t x) { return ELF32_ST_TYPE(x); }
	static constexpr uint8_t elf_st_bind(uint8_t x) { return ELF32_ST_BIND(x); }

	struct symbol {
		elf_addr address;
		size_t size;
		QString name;
		char type;

		bool operator<(const symbol &rhs) const {
			return std::tie(address, name) < std::tie(rhs.address, rhs.name);
		}

		bool operator==(const symbol &rhs) const {
			return std::tie(address, name) == std::tie(rhs.address, rhs.name);
		}

		QString to_string() const {
			return QString("%1 %2 %3 %4").arg(edb::value32(address).toHexString(), edb::value32(size).toHexString()).arg(type).arg(name);
		}
	};
};

struct elf64_model : elf_model<64> {

	static constexpr size_t plt_entry_size = 0x10;

	static constexpr uint64_t elf_r_sym(uint64_t x) { return ELF64_R_SYM(x); }
	static constexpr uint64_t elf_r_type(uint64_t x) { return ELF64_R_TYPE(x); }
	static constexpr uint8_t elf_st_type(uint8_t x) { return ELF64_ST_TYPE(x); }
	static constexpr uint8_t elf_st_bind(uint8_t x) { return ELF64_ST_BIND(x); }

	struct symbol {
		elf_addr address;
		size_t size;
		QString name;
		char type;

		bool operator<(const symbol &rhs) const {
			return std::tie(address, name) < std::tie(rhs.address, rhs.name);
		}

		bool operator==(const symbol &rhs) const {
			return std::tie(address, name) == std::tie(rhs.address, rhs.name);
		}

		QString to_string() const {
			return QString("%1 %2 %3 %4").arg(edb::value64(address).toHexString(), edb::value32(size).toHexString()).arg(type).arg(name);
		}
	};
};

bool is_elf32(const void *ptr) {
	auto elf32_hdr = reinterpret_cast<const elf32_header *>(ptr);
	if (std::memcmp(elf32_hdr->e_ident, ELFMAG, SELFMAG) == 0) {
		return elf32_hdr->e_ident[EI_CLASS] == ELFCLASS32;
	}
	return false;
}

bool is_elf64(const void *ptr) {
	auto elf64_hdr = reinterpret_cast<const elf64_header *>(ptr);
	if (std::memcmp(elf64_hdr->e_ident, ELFMAG, SELFMAG) == 0) {
		return elf64_hdr->e_ident[EI_CLASS] == ELFCLASS64;
	}
	return false;
}

/*
The  symbol  type.   At least the following types are used; others are, as well, depending on the object file format.  If lowercase,
the symbol is local; if uppercase, the symbol is global (external).

"A" The symbol's value is absolute, and will not be changed by further linking.

"B"
"b" The symbol is in the uninitialized data section (known as BSS).

"C" The symbol is common.  Common symbols are uninitialized data.  When linking, multiple common symbols may appear  with  the  same
	name.  If the symbol is defined anywhere, the common symbols are treated as undefined references.

"D"
"d" The symbol is in the initialized data section.

"G"
"g" The  symbol is in an initialized data section for small objects.  Some object file formats permit more efficient access to small
	data objects, such as a global int variable as opposed to a large global array.

"N" The symbol is a debugging symbol.

"p" The symbols is in a stack unwind section.

"R"
"r" The symbol is in a read only data section.

"S"
"s" The symbol is in an uninitialized data section for small objects.

"T"
"t" The symbol is in the text (code) section.

"U" The symbol is undefined.

"u" The  symbol  is  a unique global symbol.  This is a GNU extension to the standard set of ELF symbol bindings.  For such a symbol
	the dynamic linker will make sure that in the entire process there is just one symbol with this name and type in use.

"V"
"v" The symbol is a weak object.  When a weak defined symbol is linked with a normal defined symbol, the normal  defined  symbol  is
	used  with no error.  When a weak undefined symbol is linked and the symbol is not defined, the value of the weak symbol becomes
	zero with no error.  On some systems, uppercase indicates that a default value has been specified.

"W"
"w" The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.  When a weak defined symbol is linked
	with  a  normal defined symbol, the normal defined symbol is used with no error.  When a weak undefined symbol is linked and the
	symbol is not defined, the value of the symbol is determined in a system-specific manner without error.  On some systems, upper-
	case indicates that a default value has been specified.

"-" The  symbol  is  a  stabs  symbol in an a.out object file.  In this case, the next values printed are the stabs other field, the
	stabs desc field, and the stab type.  Stabs symbols are used to hold debugging information.

"?" The symbol type is unknown, or object file format specific.
*/

template <class M, class Size>
void collect_symbols(const void *p, Size size, std::vector<typename M::symbol> &symbols) {
	Q_UNUSED(size)

	using elf_addr   = typename M::elf_addr;
	using elf_header = typename M::elf_header;
	using elf_shdr   = typename M::elf_shdr;
	using elf_sym    = typename M::elf_sym;
	using elf_rela   = typename M::elf_rela;
	using elf_rel    = typename M::elf_rel;
	using symbol     = typename M::symbol;

	const auto base = reinterpret_cast<uintptr_t>(p);

	const auto header = static_cast<const elf_header *>(p);
	if (header->e_shnum == 0 || header->e_shentsize == 0) {
		return;
	}
	const auto sections_begin          = reinterpret_cast<elf_shdr *>(base + header->e_shoff);
	const elf_shdr *const sections_end = sections_begin + header->e_shnum;
	auto section_strings               = reinterpret_cast<const char *>(base + sections_begin[header->e_shstrndx].sh_offset);

	elf_addr plt_address = 0;
	elf_addr got_address = 0;
	std::set<elf_addr> plt_addresses;

	// collect special section addresses
	for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {
		if (strcmp(&section_strings[section->sh_name], ".plt") == 0) {
			plt_address = section->sh_addr;
		} else if (strcmp(&section_strings[section->sh_name], ".got") == 0) {
			got_address = section->sh_addr;
		}
	}

	// print out relocated symbols for special sections
	for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {
		elf_addr base_address = 0;
		if (strcmp(&section_strings[section->sh_name], ".rela.plt") == 0) {
			base_address = plt_address;
		} else if (strcmp(&section_strings[section->sh_name], ".rel.plt") == 0) {
			base_address = plt_address;
		} else if (strcmp(&section_strings[section->sh_name], ".rela.got") == 0) {
			base_address = got_address;
		} else if (strcmp(&section_strings[section->sh_name], ".rel.got") == 0) {
			base_address = got_address;
		} else {
			continue;
		}

		switch (section->sh_type) {
		case SHT_RELA: {
			elf_addr n      = 0;
			auto relocation = reinterpret_cast<elf_rela *>(base + section->sh_offset);

			if (section->sh_link == 0) {
				break;
			}

			for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {

				const size_t sym_index = M::elf_r_sym(relocation[i].r_info);
				const elf_shdr *linked = &sections_begin[section->sh_link];
				auto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset);
				auto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset);

				const elf_addr symbol_address = base_address + ++n * M::plt_entry_size;

				const char *sym_name = &section_strings[section->sh_name];
				if (strlen(sym_name) > (sizeof(".rela.") - 1) && memcmp(sym_name, ".rela.", (sizeof(".rela.") - 1)) == 0) {
					sym_name += 6;
				}

				plt_addresses.insert(symbol_address);

				symbol sym;
				sym.address = symbol_address;
				sym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10);
				sym.name    = &string_tab[symbol_tab[sym_index].st_name];
				sym.name += "@";
				sym.name += sym_name;
				sym.type = 'P';
				symbols.push_back(sym);
			}
		} break;
		case SHT_REL: {
			elf_addr n      = 0;
			auto relocation = reinterpret_cast<elf_rel *>(base + section->sh_offset);

			if (section->sh_link == 0) {
				break;
			}

			for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {

				const size_t sym_index = M::elf_r_sym(relocation[i].r_info);
				const elf_shdr *linked = &sections_begin[section->sh_link];
				auto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset);
				auto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset);

				const elf_addr symbol_address = base_address + ++n * M::plt_entry_size;

				const char *sym_name = &section_strings[section->sh_name];
				if (strlen(sym_name) > (sizeof(".rel.") - 1) && memcmp(sym_name, ".rel.", (sizeof(".rel.") - 1)) == 0) {
					sym_name += 5;
				}

				plt_addresses.insert(symbol_address);

				symbol sym;
				sym.address = symbol_address;
				sym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10);
				sym.name    = &string_tab[symbol_tab[sym_index].st_name];
				sym.name += "@";
				sym.name += sym_name;
				sym.type = 'P';
				symbols.push_back(sym);
			}
		} break;
		}
	}

	// collect regular symbols
	for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {

		switch (section->sh_type) {
		case SHT_SYMTAB:
		case SHT_DYNSYM: {
			auto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset);
			auto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset);

			for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {

				const elf_shdr *related_section = nullptr;

				if (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) {
					related_section = &sections_begin[symbol_tab[i].st_shndx];
				}

				Q_UNUSED(related_section)

				if (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) {

					if (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) > 0) {

						symbol sym;
						sym.address = symbol_tab[i].st_value;
						sym.size    = symbol_tab[i].st_size;
						sym.name    = &string_tab[symbol_tab[i].st_name];
						sym.type    = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D');
						symbols.push_back(sym);
					}
				}
			}
		} break;
		}
	}

	// collect unnamed symbols
	for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {

		switch (section->sh_type) {
		case SHT_SYMTAB:
		case SHT_DYNSYM: {
			auto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset);
			auto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset);

			for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {

				const elf_shdr *related_section = nullptr;

				if (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) {
					related_section = &sections_begin[symbol_tab[i].st_shndx];
				}

				Q_UNUSED(related_section)

				if (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) {

					if (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) == 0) {
						symbol sym;
						sym.address = symbol_tab[i].st_value;
						sym.size    = symbol_tab[i].st_size;

						for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {
							if (sym.address >= section->sh_addr && sym.address + sym.size <= section->sh_addr + section->sh_size) {
								const std::int64_t offset = sym.address - section->sh_addr;
								const QString hexPrefix   = std::abs(offset) > 9 ? "0x" : "";
								const QString offsetStr   = offset ? "+" + hexPrefix + QString::number(offset, 16) : "";
								const QString sectionName(&section_strings[section->sh_name]);
								if (!sectionName.isEmpty()) {
									sym.name = QString(sectionName + offsetStr);
									break;
								}
							}
						}

						if (sym.name.isEmpty()) {
							sym.name = QString("$sym_%1").arg(edb::v1::format_pointer(symbol_tab[i].st_value));
						}

						sym.type = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D');
						symbols.push_back(sym);
					}
				}
			}
		} break;
		}
	}
}

//--------------------------------------------------------------------------
// Name: output_symbols
// Desc: outputs the symbols to OS ensuring uniqueness and adding any
//       needed demangling
//--------------------------------------------------------------------------
template <class Symbol>
void output_symbols(std::vector<Symbol> &symbols, std::ostream &os) {
	std::sort(symbols.begin(), symbols.end());
	auto new_end                 = std::unique(symbols.begin(), symbols.end());
	const auto demanglingEnabled = QSettings().value("BinaryInfo/demangling_enabled", true).toBool();
	for (auto it = symbols.begin(); it != new_end; ++it) {
		if (demanglingEnabled) {
			it->name = demangle(it->name);
		}
		os << qPrintable(it->to_string()) << '\n';
	}
}

//--------------------------------------------------------------------------
// Name: generate_symbols_internal
// Desc:
//--------------------------------------------------------------------------
bool generate_symbols_internal(QFile &file, std::shared_ptr<QFile> &debugFile, std::ostream &os) {
	if (auto file_ptr = reinterpret_cast<void *>(file.map(0, file.size(), QFile::NoOptions))) {
		if (is_elf64(file_ptr)) {

			using symbol = typename elf64_model::symbol;
			std::vector<symbol> symbols;

			collect_symbols<elf64_model>(file_ptr, file.size(), symbols);

			// if there was a debug file
			if (debugFile) {
				// and we sucessfully opened it
				if (debugFile->open(QIODevice::ReadOnly)) {

					// map it and include it with the symbols
					if (auto debug_ptr = reinterpret_cast<void *>(debugFile->map(0, debugFile->size(), QFile::NoOptions))) {

						// this should never fail... but just being sure
						if (is_elf64(debug_ptr)) {
							collect_symbols<elf64_model>(debug_ptr, debugFile->size(), symbols);
						}
					}
				}
			}

			output_symbols(symbols, os);
			return true;
		} else if (is_elf32(file_ptr)) {

			using symbol = typename elf32_model::symbol;
			std::vector<symbol> symbols;

			collect_symbols<elf32_model>(file_ptr, file.size(), symbols);

			// if there was a debug file
			if (debugFile) {
				// and we sucessfully opened it
				if (debugFile->open(QIODevice::ReadOnly)) {

					// map it and include it with the symbols
					if (auto debug_ptr = reinterpret_cast<void *>(debugFile->map(0, debugFile->size(), QFile::NoOptions))) {

						// this should never fail... but just being sure
						if (is_elf32(debug_ptr)) {
							collect_symbols<elf32_model>(debug_ptr, debugFile->size(), symbols);
						}
					}
				}
			}

			output_symbols(symbols, os);
			return true;
		} else {
			qDebug() << "unknown file type";
		}
	}

	return false;
}

}

/**
 * @brief generate_symbols
 * @param filename
 * @param os
 * @return
 */
bool generate_symbols(const QString &filename, std::ostream &os) {

	QFile file(filename);
	if (file.open(QIODevice::ReadOnly)) {
		os << qPrintable(QDateTime::currentDateTimeUtc().toString(Qt::ISODate)) << " +0000" << '\n';
		const QByteArray md5 = edb::v1::get_file_md5(filename);
		os << md5.toHex().data() << ' ' << qPrintable(QFileInfo(filename).absoluteFilePath()) << '\n';

		const QString debugInfoPath = QSettings().value("BinaryInfo/debug_info_path", "/usr/lib/debug").toString();

		std::shared_ptr<QFile> debugFile;
		if (!debugInfoPath.isEmpty()) {
			debugFile = std::make_shared<QFile>(QString("%1/%2.debug").arg(debugInfoPath, filename));
			if (!debugFile->exists()) { // systems such as Ubuntu don't have .debug suffix, try without it
				debugFile = std::make_shared<QFile>(QString("%1/%2").arg(debugInfoPath, filename));
			}
		}

		return generate_symbols_internal(file, debugFile, os);
	}

	return false;
}

}

```

`plugins/BinaryInfo/symbols.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef SYMBOLS_H_20110312_
#define SYMBOLS_H_20110312_

class QString;
#include <iostream>

namespace BinaryInfoPlugin {

bool generate_symbols(const QString &filename, std::ostream &os = std::cout);

}

#endif

```

`plugins/BinarySearcher/BinarySearcher.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "BinarySearcher.h"
#include "DialogAsciiString.h"
#include "DialogBinaryString.h"
#include "edb.h"
#include <QMenu>

namespace BinarySearcherPlugin {

/**
 * @brief BinarySearcher::BinarySearcher
 * @param parent
 */
BinarySearcher::BinarySearcher(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief BinarySearcher::menu
 * @param parent
 * @return
 */
QMenu *BinarySearcher::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("BinarySearcher"), parent);
		menu_->addAction(tr("&Binary String Search"), this, SLOT(showMenu()), QKeySequence(tr("Ctrl+F")));
	}

	return menu_;
}

/**
 * @brief BinarySearcher::stackContextMenu
 * @return
 */
QList<QAction *> BinarySearcher::stackContextMenu() {

	QList<QAction *> ret;

	auto action_find = new QAction(tr("&Find ASCII String"), this);
	connect(action_find, &QAction::triggered, this, &BinarySearcher::mnuStackFindAscii);
	ret << action_find;

	return ret;
}

/**
 * @brief BinarySearcher::showMenu
 */
void BinarySearcher::showMenu() {
	static auto dialog = new DialogBinaryString(edb::v1::debugger_ui);
	dialog->show();
}

/**
 * @brief BinarySearcher::mnuStackFindAscii
 */
void BinarySearcher::mnuStackFindAscii() {
	static auto dialog = new DialogAsciiString(edb::v1::debugger_ui);
	dialog->show();
}

}

```

`plugins/BinarySearcher/BinarySearcher.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef BINARY_SEARCHER_H_20060430_
#define BINARY_SEARCHER_H_20060430_

#include "IPlugin.h"

class QMenu;
class QDialog;

namespace BinarySearcherPlugin {

class BinarySearcher : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit BinarySearcher(QObject *parent = nullptr);
	~BinarySearcher() override = default;

public:
	QMenu *menu(QWidget *parent = nullptr) override;
	QList<QAction *> stackContextMenu() override;

public Q_SLOTS:
	void showMenu();
	void mnuStackFindAscii();

private:
	QMenu *menu_ = nullptr;
};

}

#endif

```

`plugins/BinarySearcher/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "BinarySearcher")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	BinarySearcher.cpp
	BinarySearcher.h
	DialogAsciiString.cpp
	DialogAsciiString.h
	DialogAsciiString.ui
	DialogBinaryString.cpp
	DialogBinaryString.h
	DialogBinaryString.ui
	DialogResults.cpp
	DialogResults.h
	DialogResults.ui
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})


```

`plugins/BinarySearcher/DialogAsciiString.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogAsciiString.h"
#include "DialogResults.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IRegion.h"
#include "IThread.h"
#include "MemoryRegions.h"
#include "State.h"
#include "edb.h"
#include "util/Math.h"

#include <QListWidget>
#include <QMessageBox>
#include <QPushButton>
#include <QVector>
#include <QtDebug>

#include <cstring>

namespace BinarySearcherPlugin {

/**
 * @brief DialogAsciiString::DialogAsciiString
 * @param parent
 * @param f
 */
DialogAsciiString::DialogAsciiString(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {
	ui.setupUi(this);
	ui.progressBar->setValue(0);

	buttonFind_ = new QPushButton(QIcon::fromTheme("edit-find"), tr("Find"));
	connect(buttonFind_, &QPushButton::clicked, this, [this]() {
		buttonFind_->setEnabled(false);
		ui.progressBar->setValue(0);
		doFind();
		ui.progressBar->setValue(100);
		buttonFind_->setEnabled(true);
	});

	ui.buttonBox->addButton(buttonFind_, QDialogButtonBox::ActionRole);
}

/**
 * @brief DialogAsciiString::doFind
 *
 * find *stack aligned pointers* to exact string matches
 */
void DialogAsciiString::doFind() {

	const QByteArray b = ui.txtAscii->text().toLatin1();
	auto results       = new DialogResults(this);

	const auto sz = static_cast<size_t>(b.size());
	if (sz != 0) {

		edb::v1::memory_regions().sync();

		if (IProcess *process = edb::v1::debugger_core->process()) {
			if (std::shared_ptr<IThread> thread = process->currentThread()) {

				State state;
				thread->getState(&state);
				edb::address_t stack_ptr = state.stackPointer();

				if (std::shared_ptr<IRegion> region = edb::v1::memory_regions().findRegion(stack_ptr)) {

					edb::address_t count = (region->end() - stack_ptr) / edb::v1::pointer_size();
					stack_ptr            = region->start();

					try {
						std::vector<uint8_t> chars(sz);

						int i = 0;
						while (stack_ptr < region->end()) {

							// get the value from the stack
							edb::address_t stack_address;

							if (process->readBytes(stack_ptr, &stack_address, edb::v1::pointer_size())) {
								if (process->readBytes(stack_address, &chars[0], chars.size())) {
									if (std::memcmp(&chars[0], b.constData(), chars.size()) == 0) {
										results->addResult(DialogResults::RegionType::Stack, stack_ptr);
									}
								}
							}
							ui.progressBar->setValue(util::percentage(i++, count));
							stack_ptr += edb::v1::pointer_size();
						}

					} catch (const std::bad_alloc &) {
						QMessageBox::critical(
							nullptr,
							tr("Memroy Allocation Error"),
							tr("Unable to satisfy memory allocation request for search string."));
					}
				}
			}
		}
	}

	if (results->resultCount() == 0) {
		QMessageBox::information(nullptr, tr("No Results"), tr("No Results were found!"));
		delete results;
	} else {
		results->show();
	}
}

/**
 * @brief DialogAsciiString::showEvent
 * @param event
 */
void DialogAsciiString::showEvent(QShowEvent *event) {
	Q_UNUSED(event)
	ui.txtAscii->setFocus();
}

}

```

`plugins/BinarySearcher/DialogAsciiString.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_ASCII_STRING_H_20082201_
#define DIALOG_ASCII_STRING_H_20082201_

#include "ui_DialogAsciiString.h"
#include <QDialog>

class QListWidgetItem;

namespace BinarySearcherPlugin {

class DialogAsciiString : public QDialog {
	Q_OBJECT

public:
	explicit DialogAsciiString(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogAsciiString() override = default;

protected:
	void showEvent(QShowEvent *event) override;

private:
	void doFind();

private:
	Ui::DialogAsciiString ui;
	QPushButton *buttonFind_ = nullptr;
};

}

#endif

```

`plugins/BinarySearcher/DialogAsciiString.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>BinarySearcherPlugin::DialogAsciiString</class>
 <widget class="QDialog" name="BinarySearcherPlugin::DialogAsciiString">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>391</width>
    <height>142</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Find ASCII String</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QLabel" name="label">
     <property name="text">
      <string>ASCII String</string>
     </property>
    </widget>
   </item>
   <item row="0" column="1">
    <widget class="QLineEdit" name="txtAscii">
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item row="1" column="0" colspan="2">
    <widget class="QCheckBox" name="chkCaseSensitive">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="text">
      <string>Case Sensitive</string>
     </property>
     <property name="checked">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item row="2" column="0" colspan="2">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
   <item row="3" column="0" colspan="2">
    <widget class="QProgressBar" name="progressBar"/>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>txtAscii</tabstop>
  <tabstop>chkCaseSensitive</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>BinarySearcherPlugin::DialogAsciiString</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>174</x>
     <y>83</y>
    </hint>
    <hint type="destinationlabel">
     <x>285</x>
     <y>56</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>BinarySearcherPlugin::DialogAsciiString</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>133</x>
     <y>88</y>
    </hint>
    <hint type="destinationlabel">
     <x>326</x>
     <y>99</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/BinarySearcher/DialogBinaryString.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogBinaryString.h"
#include "DialogResults.h"
#include "IDebugger.h"
#include "IRegion.h"
#include "MemoryRegions.h"
#include "edb.h"
#include "util/Math.h"

#include <QListWidget>
#include <QMessageBox>
#include <QPushButton>
#include <QVector>
#include <cstring>

namespace BinarySearcherPlugin {

/**
 * @brief DialogBinaryString::DialogBinaryString
 * @param parent
 * @param f
 */
DialogBinaryString::DialogBinaryString(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
	ui.progressBar->setValue(0);

	// NOTE(eteran): address issue #574
	ui.binaryString->setShowKeepSize(false);

	buttonFind_ = new QPushButton(QIcon::fromTheme("edit-find"), tr("Find"));
	connect(buttonFind_, &QPushButton::clicked, this, [this]() {
		buttonFind_->setEnabled(false);
		ui.progressBar->setValue(0);
		doFind();
		ui.progressBar->setValue(100);
		buttonFind_->setEnabled(true);
	});

	ui.buttonBox->addButton(buttonFind_, QDialogButtonBox::ActionRole);
}

/**
 * @brief DialogBinaryString::doFind
 */
void DialogBinaryString::doFind() {
	// TODO: Algorithm here should be Boyer-Moore for better performance
	const QByteArray b = ui.binaryString->value();

	auto results = new DialogResults(this);

	const edb::address_t align = ui.chkAlignment->isChecked() ? 1 << (ui.cmbAlignment->currentIndex() + 1) : 1;
	const size_t sz = b.size();
	edb::v1::memory_regions().sync();
	const QList<std::shared_ptr<IRegion>> regions = edb::v1::memory_regions().regions();
	const size_t page_size = edb::v1::debugger_core->pageSize();

	int i = 0;

	const size_t max_number_pages = 4096;  // how many pages our read chunks are.

	if (sz == 0) {
		return;
	}
	if (sz > max_number_pages * page_size) {
		QMessageBox::information(nullptr, tr("Input String Too Large"), tr("The search string is too large."));
		return;
	}

	for (const std::shared_ptr<IRegion> &region : regions) {
		const size_t region_size = region->size();

		// a short circut for speading things up
		if (ui.chkSkipNoAccess->isChecked() && !region->accessible()) {
			ui.progressBar->setValue(util::percentage(++i, regions.size()));
			continue;
		}

		const size_t page_count = region_size / page_size;
		// Read out 4096 pages at a time, as some applications have huge regions
		// and we will push against memory fragmentation if we mirror those regions.
		// To prevent missing a needle in the haystack if it is split between read
		// boundaries. increment current_page by only 4095.
		for (size_t current_page = 0; current_page < page_count; current_page += max_number_pages - 1) {
			const QVector<uint8_t> pages = edb::v1::read_pages(
				region->start() + (current_page * page_size),
				std::min(max_number_pages, page_count - current_page)
			);

			if (!pages.isEmpty()) {

				const uint8_t *p = &pages.constFirst();
				const uint8_t *const pages_end = &pages.constLast() - sz;

				while (p < pages_end) {
					// compare values..
					if (std::memcmp(p, b.constData(), sz) == 0) {
						const edb::address_t addr = p - &pages[0] + region->start() + (current_page * page_size);
						results->addResult(DialogResults::RegionType::Data, addr);
					}

					// update progress bar every 64KB
					if ((reinterpret_cast<uint64_t>(p) & 0xFFFF) == 0) {
						ui.progressBar->setValue(util::percentage(i, regions.size(), p - &pages[0], region_size));
					}

					p += align;
				}
			}
		}
		++i;
	}

	if (results->resultCount() == 0) {
		QMessageBox::information(nullptr, tr("No Results"), tr("No Results were found!"));
		delete results;
	} else {
		results->show();
	}
}

}

```

`plugins/BinarySearcher/DialogBinaryString.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_BINARY_STRING_H_20061101_
#define DIALOG_BINARY_STRING_H_20061101_

#include "ui_DialogBinaryString.h"
#include <QDialog>

class QListWidgetItem;

namespace BinarySearcherPlugin {

class DialogBinaryString : public QDialog {
	Q_OBJECT

public:
	explicit DialogBinaryString(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogBinaryString() override = default;

private:
	void doFind();

private:
	Ui::DialogBinaryString ui;
	QPushButton *buttonFind_ = nullptr;
};

}

#endif

```

`plugins/BinarySearcher/DialogBinaryString.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>BinarySearcherPlugin::DialogBinaryString</class>
 <widget class="QDialog" name="BinarySearcherPlugin::DialogBinaryString">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>480</width>
    <height>185</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Binary String</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0" colspan="2">
    <widget class="BinaryString" name="binaryString">
     <property name="sizePolicy">
      <sizepolicy hsizetype="MinimumExpanding" vsizetype="Minimum">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
    </widget>
   </item>
   <item row="1" column="0">
    <widget class="QCheckBox" name="chkSkipNoAccess">
     <property name="text">
      <string>Skip Regions With No Access Rights</string>
     </property>
    </widget>
   </item>
   <item row="2" column="0">
    <widget class="QCheckBox" name="chkCaseSensitive">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <property name="text">
      <string>Case Sensitive</string>
     </property>
     <property name="checked">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item row="3" column="0">
    <widget class="QCheckBox" name="chkAlignment">
     <property name="text">
      <string>Show Results With This Address Alignment</string>
     </property>
    </widget>
   </item>
   <item row="3" column="1">
    <widget class="QComboBox" name="cmbAlignment">
     <property name="currentIndex">
      <number>1</number>
     </property>
     <item>
      <property name="text">
       <string>2 Byte Alignment</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>4 Byte Alignment</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>8 Byte Alignment</string>
      </property>
     </item>
    </widget>
   </item>
   <item row="4" column="0" colspan="2">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
   <item row="5" column="0" colspan="2">
    <widget class="QProgressBar" name="progressBar"/>
   </item>
  </layout>
 </widget>
 <customwidgets>
  <customwidget>
   <class>BinaryString</class>
   <extends>QFrame</extends>
   <header>BinaryString.h</header>
   <container>1</container>
  </customwidget>
 </customwidgets>
 <tabstops>
  <tabstop>chkSkipNoAccess</tabstop>
  <tabstop>chkCaseSensitive</tabstop>
  <tabstop>chkAlignment</tabstop>
  <tabstop>cmbAlignment</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>BinarySearcherPlugin::DialogBinaryString</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>417</x>
     <y>130</y>
    </hint>
    <hint type="destinationlabel">
     <x>458</x>
     <y>153</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>BinarySearcherPlugin::DialogBinaryString</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>443</x>
     <y>126</y>
    </hint>
    <hint type="destinationlabel">
     <x>329</x>
     <y>150</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/BinarySearcher/DialogResults.cpp`:

```cpp

#include "DialogResults.h"
#include "edb.h"

namespace BinarySearcherPlugin {

/**
 * @brief DialogResults::DialogResults
 * @param parent
 * @param f
 */
DialogResults::DialogResults(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
}

/**
 * follows the found item in the appropriate view
 *
 * @brief DialogResults::on_listWidget_itemDoubleClicked
 * @param item
 */
void DialogResults::on_listWidget_itemDoubleClicked(QListWidgetItem *item) {
	const edb::address_t addr = item->data(Qt::UserRole).toULongLong();
	switch (static_cast<RegionType>(item->data(Qt::UserRole + 1).toInt())) {
	case RegionType::Code:
		edb::v1::jump_to_address(addr);
		break;
	case RegionType::Stack:
		edb::v1::dump_stack(addr, true);
		break;
	case RegionType::Data:
		edb::v1::dump_data(addr);
		break;
	}
}

/**
 * @brief DialogResults::addResult
 * @param address
 */
void DialogResults::addResult(RegionType region, edb::address_t address) {
	auto item = new QListWidgetItem(edb::v1::format_pointer(address));
	item->setData(Qt::UserRole, address.toQVariant());
	item->setData(Qt::UserRole + 1, static_cast<int>(region));
	ui.listWidget->addItem(item);
}

/**
 * @brief DialogResults::resultCount
 * @return
 */
int DialogResults::resultCount() const {
	return ui.listWidget->count();
}

}

```

`plugins/BinarySearcher/DialogResults.h`:

```h
/*
Copyright (C) 2006 - 2019 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_RESULTS_H_20190403_
#define DIALOG_RESULTS_H_20190403_

#include "edb.h"
#include "ui_DialogResults.h"
#include <QDialog>

class QListWidgetItem;

namespace BinarySearcherPlugin {

class DialogResults : public QDialog {
	Q_OBJECT

public:
	enum class RegionType {
		Code,
		Stack,
		Data
	};

public:
	explicit DialogResults(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogResults() override = default;

public:
	void addResult(RegionType region, edb::address_t address);
	int resultCount() const;

public Q_SLOTS:
	void on_listWidget_itemDoubleClicked(QListWidgetItem *);

private:
	Ui::DialogResults ui;
};

}

#endif

```

`plugins/BinarySearcher/DialogResults.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>BinarySearcherPlugin::DialogResults</class>
 <widget class="QDialog" name="BinarySearcherPlugin::DialogResults">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>581</width>
    <height>254</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Search Results</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QListWidget" name="listWidget">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>BinarySearcherPlugin::DialogResults</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>224</x>
     <y>317</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>BinarySearcherPlugin::DialogResults</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>292</x>
     <y>323</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/Bookmarks/BookmarkWidget.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "BookmarkWidget.h"
#include "BookmarksModel.h"
#include "Expression.h"
#include "edb.h"
#include <QInputDialog>
#include <QMenu>
#include <QMessageBox>
#include <QTableWidgetItem>

namespace BookmarksPlugin {

/**
 * @brief BookmarkWidget::BookmarkWidget
 * @param parent
 * @param f
 */
BookmarkWidget::BookmarkWidget(QWidget *parent, Qt::WindowFlags f)
	: QWidget(parent, f) {

	ui.setupUi(this);

	model_ = new BookmarksModel(this);
	ui.tableView->setModel(model_);

	connect(edb::v1::debugger_ui, SIGNAL(detachEvent()), model_, SLOT(clearBookmarks()));
	connect(ui.buttonAdd, &QPushButton::clicked, this, &BookmarkWidget::buttonAddClicked);
	connect(ui.buttonDel, &QPushButton::clicked, this, &BookmarkWidget::buttonDelClicked);
	connect(ui.buttonClear, &QPushButton::clicked, this, &BookmarkWidget::buttonClearClicked);
}

/**
 * @brief BookmarkWidget::on_tableView_doubleClicked
 * @param index
 */
void BookmarkWidget::on_tableView_doubleClicked(const QModelIndex &index) {

	if (auto item = static_cast<BookmarksModel::Bookmark *>(index.internalPointer())) {
		switch (index.column()) {
		case 0: //address
			switch (item->type) {
			case BookmarksModel::Bookmark::Code:
				edb::v1::jump_to_address(item->address);
				break;
			case BookmarksModel::Bookmark::Data:
				edb::v1::dump_data(item->address);
				break;
			case BookmarksModel::Bookmark::Stack:
				edb::v1::dump_stack(item->address);
				break;
			}
			break;
		case 1: // type
		{
			QString old_type = BookmarksModel::bookmarkTypeToString(item->type);
			QStringList items;
			items << tr("Code") << tr("Data") << tr("Stack");

			bool ok;
			const QString new_type = QInputDialog::getItem(ui.tableView, tr("Comment"), tr("Set Type:"), items, items.indexOf(old_type), false, &ok);
			if (ok) {
				model_->setType(index, new_type);
			}
		} break;
		case 2: //comment
		{
			QString old_comment = item->comment;
			bool ok;
			const QString new_comment = QInputDialog::getText(ui.tableView, tr("Comment"), tr("Set Comment:"), QLineEdit::Normal, old_comment, &ok);
			if (ok) {
				model_->setComment(index, new_comment);
			}
		} break;
		}
	}
}

/**
 * @brief BookmarkWidget::buttonAddClicked
 */
void BookmarkWidget::buttonAddClicked() {

	if (std::optional<edb::address_t> address = edb::v2::get_expression_from_user(tr("Bookmark Address"), tr("Address:"))) {
		addAddress(*address);
	}
}

/**
 * @brief BookmarkWidget::buttonDelClicked
 */
void BookmarkWidget::buttonDelClicked() {

	const QItemSelectionModel *const selModel = ui.tableView->selectionModel();
	const QModelIndexList selections          = selModel->selectedRows();

	if (selections.size() == 1) {
		QModelIndex index = selections[0];
		model_->deleteBookmark(index);
	}
}

/**
 * @brief BookmarkWidget::buttonClearClicked
 */
void BookmarkWidget::buttonClearClicked() {
	model_->clearBookmarks();
}

/**
 * @brief BookmarkWidget::addAddress
 * @param address
 * @param type
 * @param comment
 */
void BookmarkWidget::addAddress(edb::address_t address, const QString &type, const QString &comment) {

	const QVector<BookmarksModel::Bookmark> &bookmarks = model_->bookmarks();

	auto it = std::find_if(bookmarks.begin(), bookmarks.end(), [address](const BookmarksModel::Bookmark &bookmark) {
		return bookmark.address == address;
	});

	if (it == bookmarks.end()) {
		BookmarksModel::Bookmark bookmark = {
			address,
			BookmarksModel::bookmarkStringToType(type),
			comment,
		};

		model_->addBookmark(bookmark);
	}
}

/**
 * @brief BookmarkWidget::shortcut
 * @param index
 */
void BookmarkWidget::shortcut(int index) {

	const QVector<BookmarksModel::Bookmark> &bookmarks = model_->bookmarks();
	if (index < bookmarks.size()) {
		const BookmarksModel::Bookmark *item = &bookmarks[index];

		switch (item->type) {
		case BookmarksModel::Bookmark::Code:
			edb::v1::jump_to_address(item->address);
			break;
		case BookmarksModel::Bookmark::Data:
			edb::v1::dump_data(item->address);
			break;
		case BookmarksModel::Bookmark::Stack:
			edb::v1::dump_stack(item->address);
			break;
		}
	}
}

/**
 * @brief BookmarkWidget::on_tableView_customContextMenuRequested
 * @param pos
 */
void BookmarkWidget::on_tableView_customContextMenuRequested(const QPoint &pos) {

	QMenu menu;
	QAction *const actionAdd   = menu.addAction(tr("&Add Address"));
	QAction *const actionDel   = menu.addAction(tr("&Delete Address"));
	QAction *const actionClear = menu.addAction(tr("&Clear"));
	menu.addSeparator();
	QAction *const actionComment = menu.addAction(tr("&Set Comment"));
	QAction *const actionType    = menu.addAction(tr("Set &Type"));
	QAction *const chosen        = menu.exec(ui.tableView->mapToGlobal(pos));

	if (chosen == actionAdd) {
		buttonAddClicked();
	} else if (chosen == actionDel) {
		buttonDelClicked();
	} else if (chosen == actionClear) {
		buttonClearClicked();
	} else if (chosen == actionComment) {

		const QItemSelectionModel *const selModel = ui.tableView->selectionModel();
		const QModelIndexList selections          = selModel->selectedRows();

		if (selections.size() == 1) {
			QModelIndex index = selections[0];

			if (auto item = static_cast<BookmarksModel::Bookmark *>(index.internalPointer())) {
				QString old_comment = item->comment;
				bool ok;
				const QString new_comment = QInputDialog::getText(ui.tableView, tr("Comment"), tr("Set Comment:"), QLineEdit::Normal, old_comment, &ok);
				if (ok) {
					model_->setComment(index, new_comment);
				}
			}
		}
	} else if (chosen == actionType) {
		const QItemSelectionModel *const selModel = ui.tableView->selectionModel();
		const QModelIndexList selections          = selModel->selectedRows();

		if (selections.size() == 1) {
			QModelIndex index = selections[0];

			if (auto item = static_cast<BookmarksModel::Bookmark *>(index.internalPointer())) {

				QString old_type = BookmarksModel::bookmarkTypeToString(item->type);
				QStringList items;
				items << tr("Code") << tr("Data") << tr("Stack");

				bool ok;
				const QString new_type = QInputDialog::getItem(ui.tableView, tr("Comment"), tr("Set Type:"), items, items.indexOf(old_type), false, &ok);
				if (ok) {
					model_->setType(index, new_type);
				}
			}
		}
	}
}

/**
 * @brief BookmarkWidget::entries
 * @return
 */
QList<BookmarksModel::Bookmark> BookmarkWidget::entries() const {
	const QVector<BookmarksModel::Bookmark> &bookmarks = model_->bookmarks();
	return bookmarks.toList();
}

}

```

`plugins/Bookmarks/BookmarkWidget.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef BOOKMARK_WIDGET_H_20101207_
#define BOOKMARK_WIDGET_H_20101207_

#include "BookmarksModel.h"
#include "Types.h"
#include "ui_BookmarkWidget.h"
#include <QWidget>

class QModelIndex;

namespace BookmarksPlugin {

class BookmarksModel;

class BookmarkWidget : public QWidget {
	Q_OBJECT

public:
	BookmarkWidget(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~BookmarkWidget() override = default;

public Q_SLOTS:
	void on_tableView_doubleClicked(const QModelIndex &index);
	void on_tableView_customContextMenuRequested(const QPoint &pos);

public:
	void shortcut(int index);
	void addAddress(edb::address_t address, const QString &type = QString(), const QString &comment = QString());
	QList<BookmarksModel::Bookmark> entries() const;

private:
	void buttonAddClicked();
	void buttonDelClicked();
	void buttonClearClicked();

private:
	Ui::BookmarkWidget ui;
	BookmarksModel *model_ = nullptr;
};

}

#endif

```

`plugins/Bookmarks/BookmarkWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>BookmarksPlugin::BookmarkWidget</class>
 <widget class="QWidget" name="BookmarksPlugin::BookmarkWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>342</width>
    <height>227</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0" colspan="3">
    <widget class="QTableView" name="tableView">
     <property name="contextMenuPolicy">
      <enum>Qt::CustomContextMenu</enum>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
    </widget>
   </item>
   <item row="1" column="0">
    <widget class="QPushButton" name="buttonAdd">
     <property name="text">
      <string>Add</string>
     </property>
     <property name="icon">
      <iconset theme="list-add">
       <normaloff>.</normaloff>.</iconset>
     </property>
    </widget>
   </item>
   <item row="1" column="1">
    <widget class="QPushButton" name="buttonDel">
     <property name="text">
      <string>Del</string>
     </property>
     <property name="icon">
      <iconset theme="list-remove">
       <normaloff>.</normaloff>.</iconset>
     </property>
    </widget>
   </item>
   <item row="1" column="2">
    <widget class="QPushButton" name="buttonClear">
     <property name="text">
      <string>Clear</string>
     </property>
     <property name="icon">
      <iconset theme="edit-clear-list">
       <normaloff>.</normaloff>.</iconset>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`plugins/Bookmarks/Bookmarks.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Bookmarks.h"
#include "BookmarkWidget.h"
#include "edb.h"
#include <QDockWidget>
#include <QMainWindow>
#include <QMenu>
#include <QShortcut>
#include <QtDebug>

namespace BookmarksPlugin {

/**
 * @brief Bookmarks::Bookmarks
 * @param parent
 */
Bookmarks::Bookmarks(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief Bookmarks::menu
 * @param parent
 * @return
 */
QMenu *Bookmarks::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {

		// if we are dealing with a main window (and we are...)
		// add the dock object
		if (const auto main_window = edb::v1::debugger_ui->findChild<QMainWindow *>(QLatin1String("dockingRoot"))) {
			bookmarkWidget_ = new BookmarkWidget;

			// make the dock widget and _name_ it, it is important to name it so
			// that it's state is saved in the GUI info
			auto dock_widget = new QDockWidget(tr("Bookmarks"), main_window);
			dock_widget->setObjectName(QString::fromUtf8("Bookmarks"));
			dock_widget->setWidget(bookmarkWidget_);

			// add it to the dock
			main_window->addDockWidget(Qt::RightDockWidgetArea, dock_widget);

			QList<QDockWidget *> dockWidgets = main_window->findChildren<QDockWidget *>();
			for (QDockWidget *widget : dockWidgets) {
				if (widget != dock_widget) {
					if (main_window->dockWidgetArea(widget) == Qt::RightDockWidgetArea) {
						main_window->tabifyDockWidget(widget, dock_widget);

						// place the new doc widget UNDER the one we tabbed with
						widget->show();
						widget->raise();
						break;
					}
				}
			}

			// make the menu and add the show/hide toggle for the widget
			menu_ = new QMenu(tr("Bookmarks"), parent);
			menu_->addAction(dock_widget->toggleViewAction());

			for (int i = 0; i < 10; ++i) {
				// create an action and attach it to the signal mapper
				auto action = new QShortcut(QKeySequence(tr("Ctrl+%1").arg(i)), main_window);
				connect(action, &QShortcut::activated, this, [this, index = (i == 0) ? 9 : (i - 1)]() {
					bookmarkWidget_->shortcut(index);
				});
			}
		}
	}

	return menu_;
}

/**
 * @brief Bookmarks::cpuContextMenu
 * @return
 */
QList<QAction *> Bookmarks::cpuContextMenu() {

	QList<QAction *> ret;

	auto action_bookmark = new QAction(tr("Add &Bookmark"), this);
	connect(action_bookmark, &QAction::triggered, this, &Bookmarks::addBookmarkMenu);
	ret << action_bookmark;

	return ret;
}

/**
 * @brief Bookmarks::addBookmarkMenu
 */
void Bookmarks::addBookmarkMenu() {
	bookmarkWidget_->addAddress(edb::v1::cpu_selected_address());
}

/**
 * @brief Bookmarks::saveState
 * @return
 */
QVariantMap Bookmarks::saveState() const {
	QVariantMap state;
	QVariantList bookmarks;
	for (auto &bookmark : bookmarkWidget_->entries()) {

		QVariantMap entry;
		entry["address"] = bookmark.address.toHexString();
		entry["type"]    = BookmarksModel::bookmarkTypeToString(bookmark.type);
		entry["comment"] = bookmark.comment;

		bookmarks.push_back(entry);
	}

	state["bookmarks"] = bookmarks;
	return state;
}

/**
 * @brief Bookmarks::restoreState
 * @param state
 */
void Bookmarks::restoreState(const QVariantMap &state) {

	QVariantList bookmarks = state["bookmarks"].toList();
	for (auto &entry : bookmarks) {
		auto bookmark = entry.value<QVariantMap>();

		edb::address_t address = edb::address_t::fromHexString(bookmark["address"].toString());
		QString type           = bookmark["type"].toString();
		QString comment        = bookmark["comment"].toString();

		qDebug() << "Restoring bookmark with address: " << address.toHexString();

		bookmarkWidget_->addAddress(address, type, comment);
	}
}

}

```

`plugins/Bookmarks/Bookmarks.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef BOOKMARKS_H_20061122_
#define BOOKMARKS_H_20061122_

#include "BookmarksModel.h"
#include "IPlugin.h"
#include "Types.h"
#include <QVariantList>

namespace BookmarksPlugin {

class BookmarkWidget;

class Bookmarks : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit Bookmarks(QObject *parent = nullptr);

public:
	QMenu *menu(QWidget *parent = nullptr) override;
	QList<QAction *> cpuContextMenu() override;

public:
	QVariantMap saveState() const override;
	void restoreState(const QVariantMap &) override;

private:
	void addBookmarkMenu();

private:
	QMenu *menu_                    = nullptr;
	BookmarkWidget *bookmarkWidget_ = nullptr;
};

}

#endif

```

`plugins/Bookmarks/BookmarksModel.cpp`:

```cpp
/*
Copyright (C) 2017 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "BookmarksModel.h"
#include "edb.h"

namespace BookmarksPlugin {

/**
 * @brief BookmarksModel::BookmarksModel
 * @param parent
 */
BookmarksModel::BookmarksModel(QObject *parent)
	: QAbstractItemModel(parent) {
}

/**
 * @brief BookmarksModel::headerData
 * @param section
 * @param orientation
 * @param role
 * @return
 */
QVariant BookmarksModel::headerData(int section, Qt::Orientation orientation, int role) const {

	if (role == Qt::DisplayRole && orientation == Qt::Horizontal) {
		switch (section) {
		case 0:
			return tr("Address");
		case 1:
			return tr("Type");
		case 2:
			return tr("Comment");
		}
	}

	return QVariant();
}

/**
 * @brief BookmarksModel::data
 * @param index
 * @param role
 * @return
 */
QVariant BookmarksModel::data(const QModelIndex &index, int role) const {

	if (!index.isValid()) {
		return QVariant();
	}

	const Bookmark &bookmark = bookmarks_[index.row()];

	if (role == Qt::DisplayRole) {
		switch (index.column()) {
		case 0:
			return edb::v1::format_pointer(bookmark.address);
		case 1:
			switch (bookmark.type) {
			case Bookmark::Code:
				return tr("Code");
			case Bookmark::Data:
				return tr("Data");
			case Bookmark::Stack:
				return tr("Stack");
			}
			break;
		case 2:
			return bookmark.comment;
		default:
			return QVariant();
		}
	}

	return QVariant();
}

/**
 * @brief BookmarksModel::addBookmark
 * @param r
 */
void BookmarksModel::addBookmark(const Bookmark &r) {
	beginInsertRows(QModelIndex(), rowCount(), rowCount());
	bookmarks_.push_back(r);
	endInsertRows();
}

/**
 * @brief BookmarksModel::clearBookmarks
 */
void BookmarksModel::clearBookmarks() {
	beginResetModel();
	bookmarks_.clear();
	endResetModel();
}

/**
 * @brief BookmarksModel::index
 * @param row
 * @param column
 * @param parent
 * @return
 */
QModelIndex BookmarksModel::index(int row, int column, const QModelIndex &parent) const {

	Q_UNUSED(parent)

	if (row >= bookmarks_.size()) {
		return QModelIndex();
	}

	if (column >= 3) {
		return QModelIndex();
	}

	if (row >= 0) {
		return createIndex(row, column, const_cast<Bookmark *>(&bookmarks_[row]));
	} else {
		return createIndex(row, column);
	}
}

/**
 * @brief BookmarksModel::parent
 * @param index
 * @return
 */
QModelIndex BookmarksModel::parent(const QModelIndex &index) const {
	Q_UNUSED(index)
	return QModelIndex();
}

/**
 * @brief BookmarksModel::rowCount
 * @param parent
 * @return
 */
int BookmarksModel::rowCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return bookmarks_.size();
}

/**
 * @brief BookmarksModel::columnCount
 * @param parent
 * @return
 */
int BookmarksModel::columnCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return 3;
}

/**
 * @brief BookmarksModel::setComment
 * @param index
 * @param comment
 */
void BookmarksModel::setComment(const QModelIndex &index, const QString &comment) {

	if (!index.isValid()) {
		return;
	}

	Bookmark &bookmark = bookmarks_[index.row()];

	bookmark.comment = comment;
	Q_EMIT dataChanged(index, index);
}

/**
 * @brief BookmarksModel::setType
 * @param index
 * @param type
 */
void BookmarksModel::setType(const QModelIndex &index, const QString &type) {

	if (!index.isValid()) {
		return;
	}

	Bookmark &bookmark = bookmarks_[index.row()];

	bookmark.type = bookmarkStringToType(type);

	Q_EMIT dataChanged(index, index);
}

/**
 * @brief BookmarksModel::deleteBookmark
 * @param index
 */
void BookmarksModel::deleteBookmark(const QModelIndex &index) {

	if (!index.isValid()) {
		return;
	}

	int row = index.row();

	beginRemoveRows(QModelIndex(), row, row);
	bookmarks_.remove(row);
	endRemoveRows();
}

}

```

`plugins/Bookmarks/BookmarksModel.h`:

```h
/*
Copyright (C) 2017 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef BOOKMARKS_MODEL_H_20170103_
#define BOOKMARKS_MODEL_H_20170103_

#include "Types.h"
#include <QAbstractItemModel>
#include <QVector>

namespace BookmarksPlugin {

class BookmarksModel final : public QAbstractItemModel {
	Q_OBJECT

public:
	struct Bookmark {
		enum Type {
			Code,
			Data,
			Stack
		};

		edb::address_t address;
		Type type;
		QString comment;
	};

	static QString bookmarkTypeToString(Bookmark::Type type) {
		switch (type) {
		case Bookmark::Code:
			return tr("Code");
		case Bookmark::Data:
			return tr("Data");
		case Bookmark::Stack:
			return tr("Stack");
		}

		return tr("Code");
	}

	static Bookmark::Type bookmarkStringToType(const QString &type) {
		if (type == tr("Code")) {
			return Bookmark::Code;
		} else if (type == tr("Data")) {
			return Bookmark::Data;
		} else if (type == tr("Stack")) {
			return Bookmark::Stack;
		}

		return Bookmark::Code;
	}

public:
	explicit BookmarksModel(QObject *parent = nullptr);
	~BookmarksModel() override = default;

public:
	QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex &index) const override;
	int rowCount(const QModelIndex &parent = QModelIndex()) const override;
	int columnCount(const QModelIndex &parent = QModelIndex()) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;

public Q_SLOTS:
	void addBookmark(const Bookmark &r);
	void clearBookmarks();
	void deleteBookmark(const QModelIndex &index);
	void setComment(const QModelIndex &index, const QString &comment);
	void setType(const QModelIndex &index, const QString &type);

public:
	const QVector<Bookmark> &bookmarks() const { return bookmarks_; }

private:
	QVector<Bookmark> bookmarks_;
};

}

#endif

```

`plugins/Bookmarks/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "Bookmarks")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	Bookmarks.cpp
	Bookmarks.h
	BookmarkWidget.cpp
	BookmarkWidget.h
	BookmarksModel.cpp
	BookmarksModel.h
	BookmarkWidget.ui
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/BreakpointManager/BreakpointManager.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "BreakpointManager.h"
#include "DialogBreakpoints.h"
#include "edb.h"
#include <QKeySequence>
#include <QMenu>

namespace BreakpointManagerPlugin {

/**
 * @brief BreakpointManager::BreakpointManager
 * @param parent
 */
BreakpointManager::BreakpointManager(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief BreakpointManager::~BreakpointManager
 */
BreakpointManager::~BreakpointManager() {
	delete dialog_;
}

/**
 * @brief BreakpointManager::menu
 * @param parent
 * @return
 */
QMenu *BreakpointManager::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("BreakpointManager"), parent);
		menu_->addAction(tr("&Breakpoints"), this, SLOT(showMenu()), QKeySequence(tr("Ctrl+B")));
	}

	return menu_;
}

/**
 * @brief BreakpointManager::showMenu
 */
void BreakpointManager::showMenu() {

	if (!dialog_) {
		dialog_ = new DialogBreakpoints(edb::v1::debugger_ui);
	}

	dialog_->show();
}

}

```

`plugins/BreakpointManager/BreakpointManager.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef BREAKPOINT_MANAGER_H_20060430_
#define BREAKPOINT_MANAGER_H_20060430_

#include "IPlugin.h"

class QMenu;
class QDialog;

namespace BreakpointManagerPlugin {

class BreakpointManager : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit BreakpointManager(QObject *parent = nullptr);
	~BreakpointManager() override;

public:
	QMenu *menu(QWidget *parent = nullptr) override;

public Q_SLOTS:
	void showMenu();

private:
	QMenu *menu_              = nullptr;
	QPointer<QDialog> dialog_ = nullptr;
};

}

#endif

```

`plugins/BreakpointManager/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "BreakpointManager")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	BreakpointManager.cpp
	BreakpointManager.h
	DialogBreakpoints.cpp
	DialogBreakpoints.h
	DialogBreakpoints.ui
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/BreakpointManager/DialogBreakpoints.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogBreakpoints.h"
#include "Expression.h"
#include "IBreakpoint.h"
#include "IDebugger.h"
#include "MemoryRegions.h"
#include "edb.h"

#include <QHeaderView>
#include <QInputDialog>
#include <QMessageBox>

#include <QDir>
#include <QFile>
#include <QFileDialog>
#include <QMessageBox>
#include <QStringList>
#include <QTextStream>

namespace BreakpointManagerPlugin {

/**
 * @brief DialogBreakpoints::DialogBreakpoints
 * @param parent
 * @param f
 */
DialogBreakpoints::DialogBreakpoints(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
	ui.tableWidget->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
}

/**
 * @brief DialogBreakpoints::showEvent
 */
void DialogBreakpoints::showEvent(QShowEvent *) {
	connect(edb::v1::disassembly_widget(), SIGNAL(signalUpdated()), this, SLOT(updateList()));
	updateList();
}

/**
 * @brief DialogBreakpoints::hideEvent
 */
void DialogBreakpoints::hideEvent(QHideEvent *) {
	disconnect(edb::v1::disassembly_widget(), SIGNAL(signalUpdated()), this, SLOT(updateList()));
}

/**
 * @brief DialogBreakpoints::updateList
 */
void DialogBreakpoints::updateList() {

	ui.tableWidget->setSortingEnabled(false);
	ui.tableWidget->setRowCount(0);

	const IDebugger::BreakpointList breakpoint_state = edb::v1::debugger_core->backupBreakpoints();

	for (const std::shared_ptr<IBreakpoint> &bp : breakpoint_state) {

		//Skip if it's an internal bp; we don't want to insert a row for it.
		if (bp->internal()) {
			continue;
		}

		const int row = ui.tableWidget->rowCount();
		ui.tableWidget->insertRow(row);

		const edb::address_t address = bp->address();
		const QString condition      = bp->condition;
		const bool onetime           = bp->oneTime();
		const QString symname        = edb::v1::find_function_symbol(address, QString(), nullptr);
		const QString bytes          = edb::v1::format_bytes(bp->originalBytes(), bp->size());

		auto item = new QTableWidgetItem(edb::v1::format_pointer(address));
		item->setData(Qt::UserRole, address.toQVariant());

		ui.tableWidget->setItem(row, 0, item);
		ui.tableWidget->setItem(row, 1, new QTableWidgetItem(condition));
		ui.tableWidget->setItem(row, 2, new QTableWidgetItem(bytes));
		ui.tableWidget->setItem(row, 3, new QTableWidgetItem(onetime ? tr("One Time") : tr("Standard")));
		ui.tableWidget->setItem(row, 4, new QTableWidgetItem(symname));
	}

	ui.tableWidget->setSortingEnabled(true);
}

/**
 * @brief DialogBreakpoints::on_btnAdd_clicked
 */
void DialogBreakpoints::on_btnAdd_clicked() {

	bool ok;
	QString text = QInputDialog::getText(this, tr("Add Breakpoint"), tr("Address:"), QLineEdit::Normal, QString(), &ok);

	if (ok && !text.isEmpty()) {
		Expression<edb::address_t> expr(text, edb::v1::get_variable, edb::v1::get_value);

		const Result<edb::address_t, ExpressionError> address = expr.evaluate();
		if (address) {
			edb::v1::create_breakpoint(*address);
			updateList();

		} else {
			QMessageBox::critical(this, tr("Error In Address Expression!"), address.error().what());
		}
	}
}

/**
 * @brief DialogBreakpoints::on_btnCondition_clicked
 */
void DialogBreakpoints::on_btnCondition_clicked() {
	QList<QTableWidgetItem *> sel = ui.tableWidget->selectedItems();
	if (!sel.empty()) {
		QTableWidgetItem *const item = sel[0];
		bool ok;
		const edb::address_t address = item->data(Qt::UserRole).toULongLong();
		const QString condition      = edb::v1::get_breakpoint_condition(address);
		const QString text           = QInputDialog::getText(this, tr("Set Breakpoint Condition"), tr("Expression:"), QLineEdit::Normal, condition, &ok);
		if (ok) {
			edb::v1::set_breakpoint_condition(address, text);
			updateList();
		}
	}
}

/**
 * @brief DialogBreakpoints::on_btnRemove_clicked
 */
void DialogBreakpoints::on_btnRemove_clicked() {
	QList<QTableWidgetItem *> sel = ui.tableWidget->selectedItems();
	if (!sel.empty()) {
		QTableWidgetItem *const item = sel[0];
		const edb::address_t address = item->data(Qt::UserRole).toULongLong();
		edb::v1::remove_breakpoint(address);
	}
	updateList();
}

/**
 * @brief DialogBreakpoints::on_tableWidget_cellDoubleClicked
 * @param row
 * @param col
 */
void DialogBreakpoints::on_tableWidget_cellDoubleClicked(int row, int col) {
	switch (col) {
	case 0: // address
		if (QTableWidgetItem *const address_item = ui.tableWidget->item(row, 0)) {
			const edb::address_t address = address_item->data(Qt::UserRole).toULongLong();
			edb::v1::jump_to_address(address);
		}
		break;
	case 1: // condition
		if (QTableWidgetItem *const address_item = ui.tableWidget->item(row, 0)) {
			bool ok;
			const edb::address_t address = address_item->data(Qt::UserRole).toULongLong();
			const QString condition      = edb::v1::get_breakpoint_condition(address);
			const QString text           = QInputDialog::getText(this, tr("Set Breakpoint Condition"), tr("Expression:"), QLineEdit::Normal, condition, &ok);
			if (ok) {
				edb::v1::set_breakpoint_condition(address, text);
				updateList();
			}
		}
		break;
	}
}

/**
 * @brief DialogBreakpoints::on_btnImport_clicked
 *
 * Opens a file selection window to choose a file with newline-separated,
 * hex address breakpoints.
 */
void DialogBreakpoints::on_btnImport_clicked() {

	// Let the user choose the file; get the file name.
	QString home_directory = QDir::homePath();
	QString file_name      = QFileDialog::getOpenFileName(this, tr("Breakpoint Import File"), home_directory, nullptr);

	if (file_name.isEmpty()) {
		return;
	}

	// Open the file; fail if error or it doesn't exist.
	QFile file(file_name);
	if (!file.open(QIODevice::ReadOnly)) {
		QMessageBox::critical(this, tr("Error Opening File"), tr("Unable to open breakpoint file: %1").arg(file_name));
		return;
	}

	// Keep a list of any lines in the file that don't make valid breakpoints.
	QStringList errors;

	// Iterate through each line; attempt to make a breakpoint for each line.
	// Addreses should be prefixed with 0x, i.e. a hex number.
	// Count each breakpoint successfully made.
	int count = 0;
	Q_FOREVER {

		// Get the address
		QString line = file.readLine().trimmed();

		if (line.isEmpty()) {
			break;
		}

		bool ok;
		int base               = 16;
		edb::address_t address = line.toULong(&ok, base);

		// Skip if there's an issue.
		if (!ok) {
			errors.append(line);
			continue;
		}

		// If there's an issue with the line or address isn't in any region,
		// add to error list and skip.
		edb::v1::memory_regions().sync();
		std::shared_ptr<IRegion> p = edb::v1::memory_regions().findRegion(address);
		if (!p) {
			errors.append(line);
			continue;
		}

		// If the bp already exists, skip.  No error.
		if (edb::v1::debugger_core->findBreakpoint(address)) {
			continue;
		}

		// If the line was converted to an address, try to create the breakpoint.
		// Access debugger_core directly to avoid many possible error windows by edb::v1::create_breakpoint()
		if (const std::shared_ptr<IBreakpoint> bp = edb::v1::debugger_core->addBreakpoint(address)) {
			count++;
		} else {
			errors.append(line);
		}
	}

	// Report any errors to the user
	if (errors.size() > 0) {
		QMessageBox::warning(this, tr("Invalid Breakpoints"), tr("The following breakpoints were not made:\n%1").arg(errors.join("")));
	}

	// Report breakpoints successfully made
	QMessageBox::information(this, tr("Breakpoint Import"), tr("Imported %1 breakpoints.").arg(count));

	updateList();
}

/**
 * @brief DialogBreakpoints::on_btnExport_clicked
 *
 * Opens a file selection window to choose a file to save newline-separated,
 * hex address breakpoints.
 */
void DialogBreakpoints::on_btnExport_clicked() {

	//Get the current list of breakpoints
	const IDebugger::BreakpointList breakpoint_state = edb::v1::debugger_core->backupBreakpoints();

	//Create a list for addresses to be exported at the end
	QList<edb::address_t> export_list;

	//Go through our breakpoints and add for export if not one-time and not internal.
	for (const std::shared_ptr<IBreakpoint> &bp : breakpoint_state) {
		if (!bp->oneTime() && !bp->internal()) {
			export_list.append(bp->address());
		}
	}

	//If there are no breakpoints, fail
	if (export_list.isEmpty()) {
		QMessageBox::critical(this, tr("No Breakpoints"), tr("There are no breakpoints to export."));
		return;
	}

	//Now ask the user for a file, open it, and write each address to it.
	QString filename = QFileDialog::getSaveFileName(this, tr("Breakpoint Export File"), QDir::homePath());

	if (filename.isEmpty()) {
		return;
	}

	QFile file(filename);

	if (!file.open(QIODevice::WriteOnly)) {
		return;
	}

	for (edb::address_t address : export_list) {
		QString string_address = "0x" + QString::number(address, 16) + "\n";
		file.write(string_address.toLatin1());
	}

	QMessageBox::information(this, tr("Breakpoint Export"), tr("Exported %1 breakpoints").arg(export_list.size()));
}

}

```

`plugins/BreakpointManager/DialogBreakpoints.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_BREAKPOINTS_H_20061101_
#define DIALOG_BREAKPOINTS_H_20061101_

#include "ui_DialogBreakpoints.h"
#include <QDialog>

namespace BreakpointManagerPlugin {

class DialogBreakpoints : public QDialog {
	Q_OBJECT

public:
	explicit DialogBreakpoints(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogBreakpoints() override = default;

public Q_SLOTS:
	void updateList();
	void on_btnAdd_clicked();
	void on_btnRemove_clicked();
	void on_btnCondition_clicked();
	void on_tableWidget_cellDoubleClicked(int row, int col);
	void on_btnImport_clicked();
	void on_btnExport_clicked();

private:
	void showEvent(QShowEvent *event) override;
	void hideEvent(QHideEvent *event) override;

private:
	Ui::DialogBreakpoints ui;
};

}

#endif

```

`plugins/BreakpointManager/DialogBreakpoints.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>BreakpointManagerPlugin::DialogBreakpoints</class>
 <widget class="QDialog" name="BreakpointManagerPlugin::DialogBreakpoints">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>853</width>
    <height>252</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Breakpoint Manager</string>
  </property>
  <layout class="QGridLayout">
   <item row="4" column="1">
    <widget class="QPushButton" name="btnImport">
     <property name="text">
      <string>&amp;Import Breakpoints</string>
     </property>
     <property name="icon">
      <iconset theme="document-import">
       <normaloff>.</normaloff>.</iconset>
     </property>
    </widget>
   </item>
   <item row="2" column="1">
    <widget class="QPushButton" name="btnCondition">
     <property name="text">
      <string>Set Breakpoint &amp;Condition</string>
     </property>
     <property name="icon">
      <iconset theme="code-context">
       <normaloff>.</normaloff>.</iconset>
     </property>
    </widget>
   </item>
   <item row="6" column="1">
    <spacer>
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>40</height>
      </size>
     </property>
    </spacer>
   </item>
   <item row="7" column="1">
    <widget class="QPushButton" name="okButton">
     <property name="text">
      <string>&amp;Close</string>
     </property>
     <property name="icon">
      <iconset theme="dialog-close">
       <normaloff>.</normaloff>.</iconset>
     </property>
     <property name="default">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item row="1" column="1">
    <widget class="QPushButton" name="btnRemove">
     <property name="text">
      <string>&amp;Remove Breakpoint</string>
     </property>
     <property name="icon">
      <iconset theme="list-remove">
       <normaloff>.</normaloff>.</iconset>
     </property>
    </widget>
   </item>
   <item row="0" column="1">
    <widget class="QPushButton" name="btnAdd">
     <property name="text">
      <string>&amp;Add Breakpoint</string>
     </property>
     <property name="icon">
      <iconset theme="list-add">
       <normaloff>.</normaloff>.</iconset>
     </property>
    </widget>
   </item>
   <item row="0" column="0" rowspan="8">
    <widget class="QTableWidget" name="tableWidget">
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <column>
      <property name="text">
       <string>Address</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Condition</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Original Byte</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Type</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Function</string>
      </property>
     </column>
    </widget>
   </item>
   <item row="3" column="1">
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>40</height>
      </size>
     </property>
    </spacer>
   </item>
   <item row="5" column="1">
    <widget class="QPushButton" name="btnExport">
     <property name="text">
      <string>&amp;Export Breakpoints</string>
     </property>
     <property name="icon">
      <iconset theme="document-export">
       <normaloff>.</normaloff>.</iconset>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>tableWidget</tabstop>
  <tabstop>btnAdd</tabstop>
  <tabstop>btnRemove</tabstop>
  <tabstop>btnCondition</tabstop>
  <tabstop>okButton</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>okButton</sender>
   <signal>clicked()</signal>
   <receiver>BreakpointManagerPlugin::DialogBreakpoints</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>702</x>
     <y>242</y>
    </hint>
    <hint type="destinationlabel">
     <x>660</x>
     <y>212</y>
    </hint>
   </hints>
  </connection>
 </connections>
 <slots>
  <slot>on_btnImport_clicked()</slot>
  <slot>on_btnExport_clicked()</slot>
 </slots>
</ui>

```

`plugins/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)

add_definitions(-DQT_PLUGIN)

add_subdirectory(DebuggerCore)
add_subdirectory(Analyzer)
add_subdirectory(Assembler)
add_subdirectory(BinaryInfo)
add_subdirectory(Bookmarks)
add_subdirectory(BreakpointManager)
add_subdirectory(CheckVersion)
add_subdirectory(OpcodeSearcher)
add_subdirectory(ProcessProperties)
add_subdirectory(ROPTool)
add_subdirectory(References)
add_subdirectory(SymbolViewer)
add_subdirectory(Backtrace)
add_subdirectory(DumpState)
add_subdirectory(FunctionFinder)
add_subdirectory(DebuggerErrorConsole)
add_subdirectory(BinarySearcher)
add_subdirectory(InstructionInspector)
add_subdirectory(FasLoader)
add_subdirectory(ODbgRegisterView)

if(TARGET_ARCH_FAMILY_X86)
    add_subdirectory(HardwareBreakpoints)
endif()

if(TARGET_PLATFORM_LINUX)
    add_subdirectory(HeapAnalyzer)
endif()

```

`plugins/CheckVersion/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "CheckVersion")

find_package(Qt5 5.0.0 REQUIRED Widgets Network)

add_library(${PluginName} SHARED
	CheckVersion.cpp
	CheckVersion.h
	OptionsPage.cpp
	OptionsPage.h
	OptionsPage.ui
)

target_link_libraries(${PluginName} Qt5::Widgets Qt5::Network edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/CheckVersion/CheckVersion.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "CheckVersion.h"
#include "OptionsPage.h"
#include "edb.h"
#include "version.h"

#include <QDebug>
#include <QJsonDocument>
#include <QMenu>
#include <QMessageBox>
#include <QNetworkAccessManager>
#include <QNetworkProxy>
#include <QNetworkProxyFactory>
#include <QNetworkReply>
#include <QNetworkRequest>
#include <QSettings>
#include <QUrl>

namespace CheckVersionPlugin {

/**
 * @brief CheckVersion::CheckVersion
 * @param parent
 */
CheckVersion::CheckVersion(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief CheckVersion::privateInit
 */
void CheckVersion::privateInit() {
	QSettings settings;
	if (settings.value("CheckVersion/check_on_start.enabled", true).toBool()) {
		doCheck();
	}
}

/**
 * @brief CheckVersion::optionsPage
 * @return
 */
QWidget *CheckVersion::optionsPage() {
	return new OptionsPage;
}

/**
 * @brief CheckVersion::menu
 * @param parent
 * @return
 */
QMenu *CheckVersion::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("CheckVersion"), parent);
		menu_->addAction(tr("&Check For Latest Version"), this, SLOT(showMenu()));
	}

	return menu_;
}

/**
 * @brief CheckVersion::doCheck
 */
void CheckVersion::doCheck() {

	if (!network_) {
		network_ = new QNetworkAccessManager(this);
		connect(network_, &QNetworkAccessManager::finished, this, &CheckVersion::requestFinished);
	}

	QUrl update_url(QString("https://codef00.com/projects/debugger-latest.json?v=%1").arg(EDB_VERSION_STRING));
	QNetworkRequest request(update_url);

	setProxy(update_url);
	network_->get(request);
}

/**
 * @brief CheckVersion::setProxy
 * @param url
 */
void CheckVersion::setProxy(const QUrl &url) {

	QNetworkProxy proxy;

#ifdef Q_OS_LINUX
	Q_UNUSED(url)
	auto proxy_str = QString::fromUtf8(qgetenv("HTTP_PROXY"));
	if (proxy_str.isEmpty()) {
		proxy_str = QString::fromUtf8(qgetenv("http_proxy"));
	}

	if (!proxy_str.isEmpty()) {
		const QUrl proxy_url = QUrl::fromUserInput(proxy_str);

		proxy = QNetworkProxy(QNetworkProxy::HttpProxy, proxy_url.host(), proxy_url.port(80), proxy_url.userName(), proxy_url.password());
	}

#else
	QList<QNetworkProxy> proxies = QNetworkProxyFactory::systemProxyForQuery(QNetworkProxyQuery(url));
	if (proxies.size() >= 1) {
		proxy = proxies.first();
	}
#endif
	network_->setProxy(proxy);
}

/**
 * @brief CheckVersion::showMenu
 */
void CheckVersion::showMenu() {
	initialCheck_ = false;
	doCheck();
}

/**
 * @brief CheckVersion::requestFinished
 * @param reply
 */
void CheckVersion::requestFinished(QNetworkReply *reply) {

	if (reply->error() != QNetworkReply::NoError) {
		if (!initialCheck_) {
			QMessageBox::critical(
				nullptr,
				tr("An Error Occured"),
				reply->errorString());
		}
	} else {

		QByteArray s = reply->readAll();

		QJsonParseError e;
		QJsonDocument d = QJsonDocument::fromJson(s, &e);
		if (d.isNull() || e.error != QJsonParseError::NoError) {
			qDebug("[CheckVersion] Error parsing JSON response: %s", qPrintable(e.errorString()));
			return;
		}

		if (!d.isObject()) {
			qDebug("[CheckVersion] Unexpected data format in JSON response");
			return;
		}

		QJsonObject obj = d.object();

		QString version = obj["version"].toString();
		QString url     = obj["url"].toString();
		QString md5     = obj["md5"].toString();
		QString sha1    = obj["sha1"].toString();

		if (version.isEmpty() || url.isEmpty() || md5.isEmpty() || sha1.isEmpty()) {
			qDebug("[CheckVersion] Unexpected data format in JSON response");
			return;
		}

		qDebug("comparing versions: [%d] [%d]", edb::v1::int_version(version), edb::v1::edb_version());

		if (edb::v1::int_version(version) > edb::v1::edb_version()) {
			QMessageBox msg;
			msg.setTextFormat(Qt::RichText);
			msg.setWindowTitle(tr("New Version Available"));
			msg.setText(tr("A newer version of edb is available: <strong>%1</strong><br><br>"
						   "URL: <a href=\"%2\">%2</a><br><br>"
						   "MD5: %3<br>"
						   "SHA1: %4")
							.arg(version, url, md5, sha1));
			msg.setStandardButtons(QMessageBox::Ok);
			msg.exec();

		} else {
			if (!initialCheck_) {
				QMessageBox::information(
					nullptr,
					tr("You are up to date"),
					tr("You are running the latest version of edb"));
			}
		}
	}

	reply->deleteLater();
	initialCheck_ = false;
}

}

```

`plugins/CheckVersion/CheckVersion.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef CHECK_VERSION_H_20061122_
#define CHECK_VERSION_H_20061122_

#include "IPlugin.h"

class QMenu;
class QNetworkReply;
class QNetworkAccessManager;
class QUrl;

namespace CheckVersionPlugin {

class CheckVersion : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit CheckVersion(QObject *parent = nullptr);
	~CheckVersion() override = default;

public:
	QMenu *menu(QWidget *parent = nullptr) override;
	QWidget *optionsPage() override;

public Q_SLOTS:
	void showMenu();

private:
	void requestFinished(QNetworkReply *reply);

protected:
	void privateInit() override;

private:
	void doCheck();
	void setProxy(const QUrl &url);

private:
	QMenu *menu_                    = nullptr;
	QNetworkAccessManager *network_ = nullptr;
	bool initialCheck_              = true;
};

}

#endif

```

`plugins/CheckVersion/OptionsPage.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "OptionsPage.h"
#include <QSettings>

namespace CheckVersionPlugin {

/**
 * @brief OptionsPage::OptionsPage
 * @param parent
 * @param f
 */
OptionsPage::OptionsPage(QWidget *parent, Qt::WindowFlags f)
	: QWidget(parent, f) {

	ui.setupUi(this);
}

/**
 * @brief OptionsPage::showEvent
 * @param event
 */
void OptionsPage::showEvent(QShowEvent *event) {
	Q_UNUSED(event)

	QSettings settings;
	ui.checkBox->setChecked(settings.value("CheckVersion/check_on_start.enabled", true).toBool());
}

/**
 * @brief OptionsPage::on_checkBox_toggled
 * @param checked
 */
void OptionsPage::on_checkBox_toggled(bool checked) {
	Q_UNUSED(checked)

	QSettings settings;
	settings.setValue("CheckVersion/check_on_start.enabled", ui.checkBox->isChecked());
}

}

```

`plugins/CheckVersion/OptionsPage.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef OPTIONS_PAGE_H_20090703_
#define OPTIONS_PAGE_H_20090703_

#include "ui_OptionsPage.h"
#include <QWidget>

namespace CheckVersionPlugin {

class OptionsPage : public QWidget {
	Q_OBJECT

public:
	explicit OptionsPage(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~OptionsPage() override = default;

public:
	void showEvent(QShowEvent *event) override;

public Q_SLOTS:
	void on_checkBox_toggled(bool checked);

private:
	Ui::OptionsPage ui;
};

}

#endif

```

`plugins/CheckVersion/OptionsPage.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>CheckVersionPlugin::OptionsPage</class>
 <widget class="QWidget" name="CheckVersionPlugin::OptionsPage">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Check Version Plugin</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QCheckBox" name="checkBox">
     <property name="text">
      <string>Check for new version on startup</string>
     </property>
    </widget>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>262</height>
      </size>
     </property>
    </spacer>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`plugins/DebuggerCore/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "DebuggerCore")

find_package(Qt5 5.0.0 REQUIRED Widgets)

set(DebuggerCore_SRCS
	DebuggerCoreBase.cpp
	DebuggerCoreBase.h
)

if(TARGET_PLATFORM_LINUX)

	set(PLUGIN_INCLUDES
		${PLUGIN_INCLUDES}
		unix/linux
		unix
	)

	set(DebuggerCore_SRCS
		${DebuggerCore_SRCS}
		unix/linux/DebuggerCore.cpp
		unix/linux/DebuggerCore.h
		unix/linux/DialogMemoryAccess.cpp
		unix/linux/DialogMemoryAccess.h
		unix/linux/DialogMemoryAccess.ui
		unix/linux/FeatureDetect.cpp
		unix/linux/FeatureDetect.h
		unix/linux/PlatformCommon.cpp
		unix/linux/PlatformCommon.h
		unix/linux/PlatformEvent.cpp
		unix/linux/PlatformEvent.h
		unix/linux/PlatformProcess.cpp
		unix/linux/PlatformProcess.h
		unix/linux/PlatformRegion.cpp
		unix/linux/PlatformRegion.h
		unix/linux/PlatformThread.cpp
		unix/linux/PlatformThread.h
		unix/linux/PrStatus.h
		unix/Posix.cpp
		unix/Posix.h
		unix/Unix.cpp
		unix/Unix.h
	)
elseif(TARGET_PLATFORM_WINDOWS)

	set(PLUGIN_INCLUDES
		${PLUGIN_INCLUDES}
		win32
	)
	
	set(DebuggerCore_SRCS
		${DebuggerCore_SRCS}
		win32/DebuggerCore.cpp
		win32/DebuggerCore.h
		win32/PlatformEvent.cpp
		win32/PlatformEvent.h
		win32/PlatformProcess.cpp
		win32/PlatformProcess.h
		win32/PlatformRegion.cpp
		win32/PlatformRegion.h
		win32/PlatformState.cpp
		win32/PlatformState.h
		win32/PlatformThread.cpp
		win32/PlatformThread.h
	)
elseif(TARGET_PLATFORM_FREEBSD)

	set(PLUGIN_INCLUDES
		${PLUGIN_INCLUDES}
		unix/freebsd
		unix
	)

	set(DebuggerCore_SRCS
		${DebuggerCore_SRCS}
		unix/freebsd/DebuggerCore.cpp
		unix/freebsd/DebuggerCore.h
		unix/freebsd/PlatformCommon.cpp
		unix/freebsd/PlatformCommon.h
		unix/freebsd/PlatformEvent.cpp
		unix/freebsd/PlatformEvent.h
		unix/freebsd/PlatformProcess.cpp
		unix/freebsd/PlatformProcess.h
		unix/freebsd/PlatformRegion.cpp
		unix/freebsd/PlatformRegion.h
		unix/freebsd/PlatformThread.cpp
		unix/freebsd/PlatformThread.h
	)
endif()

if(TARGET_ARCH_FAMILY_X86)
	set(PLUGIN_INCLUDES
		${PLUGIN_INCLUDES}
		arch/x86-generic
	)
	
	set(DebuggerCore_SRCS
		${DebuggerCore_SRCS}
		arch/x86-generic/Breakpoint.cpp
		arch/x86-generic/Breakpoint.h
	)

    if(TARGET_PLATFORM_LINUX)	
		set(PLUGIN_INCLUDES
			${PLUGIN_INCLUDES}
			unix/linux/arch/x86-generic
		)

        set(DebuggerCore_SRCS
            ${DebuggerCore_SRCS}
            unix/linux/arch/x86-generic/PlatformState.cpp
            unix/linux/arch/x86-generic/PlatformState.h
            unix/linux/arch/x86-generic/PlatformThread.cpp
        )
    endif()

endif()

if(TARGET_ARCH_FAMILY_ARM)

		set(PLUGIN_INCLUDES
			${PLUGIN_INCLUDES}
			arch/arm-generic
		)

        set(DebuggerCore_SRCS
                ${DebuggerCore_SRCS}
                arch/arm-generic/Breakpoint.cpp
                arch/arm-generic/Breakpoint.h
        )

        if(TARGET_PLATFORM_LINUX)
		
			set(PLUGIN_INCLUDES
				${PLUGIN_INCLUDES}
				unix/linux/arch/arm-generic
			)

            set(DebuggerCore_SRCS
                ${DebuggerCore_SRCS}
                unix/linux/arch/arm-generic/PlatformState.cpp
                unix/linux/arch/arm-generic/PlatformState.h
                unix/linux/arch/arm-generic/PlatformThread.cpp
            )
        endif()

endif()

add_library(${PluginName} SHARED ${DebuggerCore_SRCS} )

target_include_directories(${PluginName} PRIVATE
	${CMAKE_CURRENT_SOURCE_DIR}
	${PLUGIN_INCLUDES}
)

target_link_libraries(${PluginName} Qt5::Widgets PE ELF edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/DebuggerCore/DebuggerCoreBase.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DebuggerCoreBase.h"
#include "Breakpoint.h"
#include "Configuration.h"
#include "edb.h"
#include <QtDebug>

namespace DebuggerCorePlugin {

/**
 * removes all breakpoints
 *
 * @brief DebuggerCoreBase::clearBreakpoints
 */
void DebuggerCoreBase::clearBreakpoints() {
	if (attached()) {
		breakpoints_.clear();
	}
}

/**
 * creates a new breakpoint (only if there isn't already one at the given address)
 *
 * @brief DebuggerCoreBase::addBreakpoint
 * @param address
 * @return the breakpoint which was created/found
 */
std::shared_ptr<IBreakpoint> DebuggerCoreBase::addBreakpoint(edb::address_t address) {

	try {
		if (attached()) {
			if (std::shared_ptr<IBreakpoint> bp = findBreakpoint(address)) {
				return bp;
			}

			auto bp               = std::make_shared<Breakpoint>(address);
			breakpoints_[address] = bp;
			return bp;
		}

		return nullptr;
	} catch (const BreakpointCreationError &) {
		qDebug() << "Failed to create breakpoint";
		return nullptr;
	}
}

/**
 * @brief DebuggerCoreBase::findBreakpoint
 * @param address
 * @return the breakpoint at the given address or std::shared_ptr<IBreakpoint>()
 */
std::shared_ptr<IBreakpoint> DebuggerCoreBase::findBreakpoint(edb::address_t address) {
	if (attached()) {
		auto it = breakpoints_.find(address);
		if (it != breakpoints_.end()) {
			return it.value();
		}
	}
	return nullptr;
}

/**
 * similarly to findBreakpoint, finds a breakpoint near given address. But
 * unlike findBreakpoint, this function looks for a breakpoint which ends
 * up at this address after being triggered, instead of just starting there.
 *
 * @brief DebuggerCoreBase::findTriggeredBreakpoint
 * @param address
 * @return
 */
std::shared_ptr<IBreakpoint> DebuggerCoreBase::findTriggeredBreakpoint(edb::address_t address) {
	if (attached()) {
		for (const size_t size : Breakpoint::possibleRewindSizes()) {
			const edb::address_t bpAddr           = address - size;
			const std::shared_ptr<IBreakpoint> bp = findBreakpoint(bpAddr);

			if (bp && bp->address() == bpAddr) {
				return bp;
			}
		}
	}
	return nullptr;
}

/**
 * Decrements the reference count for the breakpoint found at the given address.
 * If the refernce count goes to zero, then it is removed.
 * This is a no-op if there is no breakpoint present.
 *
 * @brief DebuggerCoreBase::removeBreakpoint
 * @param address
 */
void DebuggerCoreBase::removeBreakpoint(edb::address_t address) {

	// TODO(eteran): assert paused
	if (attached()) {
		auto it = breakpoints_.find(address);
		if (it != breakpoints_.end()) {
			breakpoints_.erase(it);
		}
	}
}

/**
 * Ends debug session, detaching from or killing debuggee according to user preferences
 *
 * @brief DebuggerCoreBase::endDebugSession
 */
void DebuggerCoreBase::endDebugSession() {
	if (attached()) {
		switch (edb::v1::config().close_behavior) {
		case Configuration::Detach:
			detach();
			break;
		case Configuration::Kill:
			kill();
			break;
		case Configuration::KillIfLaunchedDetachIfAttached:
			if (lastMeansOfCapture() == MeansOfCapture::Launch) {
				kill();
			} else {
				detach();
			}
			break;
		}
	}
}

/**
 * returns a copy of the BP list, these count as references to the BPs
 * preventing full removal until this list is destructed.
 *
 * @brief DebuggerCoreBase::backupBreakpoints
 * @return a list of shared_ptr's to the BPs
 */
DebuggerCoreBase::BreakpointList DebuggerCoreBase::backupBreakpoints() const {
	return breakpoints_;
}

/**
 * @brief DebuggerCoreBase::attached
 * @return
 */
bool DebuggerCoreBase::attached() const {
	return process() != nullptr;
}

/**
 * @brief DebuggerCoreBase::supportedBreakpointTypes
 * @return
 */
std::vector<IBreakpoint::BreakpointType> DebuggerCoreBase::supportedBreakpointTypes() const {
	return Breakpoint::supportedTypes();
}

}

```

`plugins/DebuggerCore/DebuggerCoreBase.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DEBUGGER_CORE_BASE_H_20090529_
#define DEBUGGER_CORE_BASE_H_20090529_

#include "IDebugger.h"

class Status;

namespace DebuggerCorePlugin {

class DebuggerCoreBase : public QObject, public IDebugger {
public:
	~DebuggerCoreBase() override = default;

public:
	enum class MeansOfCapture {
		NeverCaptured,
		Attach,
		Launch
	};

	virtual MeansOfCapture lastMeansOfCapture() const = 0;

public:
	BreakpointList backupBreakpoints() const override;
	std::shared_ptr<IBreakpoint> addBreakpoint(edb::address_t address) override;
	std::shared_ptr<IBreakpoint> findBreakpoint(edb::address_t address) override;
	std::shared_ptr<IBreakpoint> findTriggeredBreakpoint(edb::address_t address) override;
	void clearBreakpoints() override;
	void removeBreakpoint(edb::address_t address) override;
	void endDebugSession() override;

	std::vector<IBreakpoint::BreakpointType> supportedBreakpointTypes() const override;

protected:
	bool attached() const;

protected:
	BreakpointList breakpoints_;
};

}

#endif

```

`plugins/DebuggerCore/arch/arm-generic/Breakpoint.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Breakpoint.h"
#include "Configuration.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "edb.h"

namespace DebuggerCorePlugin {

namespace {
const std::vector<quint8> BreakpointInstructionARM_LE   = {0xf0, 0x01, 0xf0, 0xe7}; // udf #0x10
const std::vector<quint8> BreakpointInstructionThumb_LE = {0x01, 0xde};             // udf #1
// We have to sometimes use a 32-bit Thumb-2 breakpoint. For explanation how to
// correctly use it see GDB's thumb_get_next_pcs_raw function and comments
// around arm_linux_thumb2_le_breakpoint array.
const std::vector<quint8> BreakpointInstructionThumb2_LE = {0xf0, 0xf7, 0x00, 0xa0}; // udf.w #0
// This one generates SIGILL both in ARM32 and Thumb mode. In ARM23 mode it's decoded as UDF 0xDDE0, while
// in Thumb it's a sequence `1: UDF 0xF0; B 1b`, which does stop the process even if it lands in the
// middle (on the second half-word), although the signal still occurs at the first half-word.
const std::vector<quint8> BreakpointInstructionUniversalThumbARM_LE = {0xf0, 0xde, 0xfd, 0xe7};
const std::vector<quint8> BreakpointInstructionThumbBKPT_LE         = {0x00, 0xbe};             // bkpt #0
const std::vector<quint8> BreakpointInstructionARM32BKPT_LE         = {0x70, 0x00, 0x20, 0xe1}; // bkpt #0
}

//------------------------------------------------------------------------------
// Name: Breakpoint
// Desc: constructor
//------------------------------------------------------------------------------
Breakpoint::Breakpoint(edb::address_t address)
	: address_(address), type_(edb::v1::config().default_breakpoint_type) {

	if (!enable()) {
		throw BreakpointCreationError();
	}
}

auto Breakpoint::supportedTypes() -> std::vector<BreakpointType> {
	std::vector<BreakpointType> types = {
		BreakpointType{Type{TypeId::Automatic}, QObject::tr("Automatic")},
		BreakpointType{Type{TypeId::ARM32}, QObject::tr("Always ARM32 UDF")},
		BreakpointType{Type{TypeId::Thumb2Byte}, QObject::tr("Always Thumb UDF")},
		BreakpointType{Type{TypeId::Thumb4Byte}, QObject::tr("Always Thumb2 UDF.W")},
		BreakpointType{Type{TypeId::UniversalThumbARM32}, QObject::tr("Universal ARM/Thumb UDF(+B .-2)")},
		BreakpointType{Type{TypeId::ARM32BKPT}, QObject::tr("ARM32 BKPT (may be slow)")},
		BreakpointType{Type{TypeId::ThumbBKPT}, QObject::tr("Thumb BKPT (may be slow)")},
	};
	return types;
}

void Breakpoint::setType(TypeId type) {
	disable();
	type_ = type;
	if (!enable()) {
		throw BreakpointCreationError();
	}
}

void Breakpoint::setType(IBreakpoint::TypeId type) {
	disable();
	if (Type{type} >= TypeId::TYPE_COUNT)
		throw BreakpointCreationError();
	setType(type);
}

//------------------------------------------------------------------------------
// Name: ~Breakpoint
// Desc:
//------------------------------------------------------------------------------
Breakpoint::~Breakpoint() {
	disable();
}

//------------------------------------------------------------------------------
// Name: enable
// Desc:
//------------------------------------------------------------------------------
bool Breakpoint::enable() {
	if (!enabled()) {
		if (IProcess *process = edb::v1::debugger_core->process()) {
			std::vector<quint8> prev(4);
			prev.resize(process->readBytes(address(), &prev[0], prev.size()));
			if (prev.size()) {
				originalBytes_ = prev;

				const std::vector<quint8> *bpBytes = nullptr;
				switch (TypeId{type_}) {
				case TypeId::Automatic:
					if (edb::v1::debugger_core->cpuMode() == IDebugger::CpuMode::Thumb) {
						bpBytes = &BreakpointInstructionThumb_LE;
					} else {
						bpBytes = &BreakpointInstructionARM_LE;
					}
					break;
				case TypeId::ARM32:
					bpBytes = &BreakpointInstructionARM_LE;
					break;
				case TypeId::Thumb2Byte:
					bpBytes = &BreakpointInstructionThumb_LE;
					break;
				case TypeId::Thumb4Byte:
					bpBytes = &BreakpointInstructionThumb2_LE;
					break;
				case TypeId::UniversalThumbARM32:
					bpBytes = &BreakpointInstructionUniversalThumbARM_LE;
					break;
				case TypeId::ARM32BKPT:
					bpBytes = &BreakpointInstructionARM32BKPT_LE;
					break;
				case TypeId::ThumbBKPT:
					bpBytes = &BreakpointInstructionThumbBKPT_LE;
					break;
				}
				assert(bpBytes);
				assert(originalBytes_.size() >= bpBytes->size());
				originalBytes_.resize(bpBytes->size());

				// FIXME: we don't check whether this breakpoint will overlap any of the existing breakpoints

				if (process->writeBytes(address(), bpBytes->data(), bpBytes->size())) {
					enabled_ = true;
					return true;
				}
			}
		}
	}
	return false;
}

//------------------------------------------------------------------------------
// Name: disable
// Desc:
//------------------------------------------------------------------------------
bool Breakpoint::disable() {
	if (enabled()) {
		if (IProcess *process = edb::v1::debugger_core->process()) {
			if (process->writeBytes(address(), &originalBytes_[0], originalBytes_.size())) {
				enabled_ = false;
				return true;
			}
		}
	}
	return false;
}

//------------------------------------------------------------------------------
// Name: hit
// Desc:
//------------------------------------------------------------------------------
void Breakpoint::hit() {
	++hitCount_;
}

//------------------------------------------------------------------------------
// Name: setOneTime
// Desc:
//------------------------------------------------------------------------------
void Breakpoint::setOneTime(bool value) {
	oneTime_ = value;
}

//------------------------------------------------------------------------------
// Name: setInternal
// Desc:
//------------------------------------------------------------------------------
void Breakpoint::setInternal(bool value) {
	internal_ = value;
}

std::vector<size_t> Breakpoint::possibleRewindSizes() {
	return {0}; // Even BKPT stops before the instruction, let alone UDF
}

}

```

`plugins/DebuggerCore/arch/arm-generic/Breakpoint.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef BREAKPOINT_H_20060720_
#define BREAKPOINT_H_20060720_

#include "IBreakpoint.h"
#include "Util.h"
#include <array>
#include <vector>

namespace DebuggerCorePlugin {

class Breakpoint final : public IBreakpoint {
public:
	enum class TypeId {
		Automatic = static_cast<int>(IBreakpoint::TypeId::Automatic),
		ARM32,
		Thumb2Byte,
		Thumb4Byte,
		UniversalThumbARM32,
		ARM32BKPT,
		ThumbBKPT,

		TYPE_COUNT
	};

	using Type = util::AbstractEnumData<IBreakpoint::TypeId, TypeId>;

public:
	explicit Breakpoint(edb::address_t address);
	~Breakpoint() override;

public:
	edb::address_t address() const override { return address_; }
	uint64_t hitCount() const override { return hitCount_; }
	bool enabled() const override { return enabled_; }
	bool oneTime() const override { return oneTime_; }
	bool internal() const override { return internal_; }
	size_t size() const override { return originalBytes_.size(); }
	const uint8_t *originalBytes() const override { return &originalBytes_[0]; }
	IBreakpoint::TypeId type() const override { return type_; }

	static std::vector<BreakpointType> supportedTypes();
	static std::vector<size_t> possibleRewindSizes();

public:
	bool enable() override;
	bool disable() override;
	void hit() override;
	void setOneTime(bool value) override;
	void setInternal(bool value) override;
	void setType(IBreakpoint::TypeId type) override;
	void setType(TypeId type);

private:
	std::vector<uint8_t> originalBytes_;
	edb::address_t address_;
	uint64_t hitCount_ = 0;
	bool enabled_      = false;
	bool oneTime_      = false;
	bool internal_     = false;
	Type type_;
};

}

#endif

```

`plugins/DebuggerCore/arch/x86-generic/Breakpoint.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Breakpoint.h"
#include "Configuration.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "edb.h"
#include <cassert>

namespace DebuggerCorePlugin {

namespace {
const std::vector<uint8_t> BreakpointInstructionINT3  = {0xcc};
const std::vector<uint8_t> BreakpointInstructionINT1  = {0xf1};
const std::vector<uint8_t> BreakpointInstructionHLT   = {0xf4};
const std::vector<uint8_t> BreakpointInstructionCLI   = {0xfa};
const std::vector<uint8_t> BreakpointInstructionSTI   = {0xfb};
const std::vector<uint8_t> BreakpointInstructionINSB  = {0x6c};
const std::vector<uint8_t> BreakpointInstructionINSD  = {0x6d};
const std::vector<uint8_t> BreakpointInstructionOUTSB = {0x6e};
const std::vector<uint8_t> BreakpointInstructionOUTSD = {0x6f};
const std::vector<uint8_t> BreakpointInstructionUD2   = {0x0f, 0x0b};
const std::vector<uint8_t> BreakpointInstructionUD0   = {0x0f, 0xff};
}

/**
 * @brief Breakpoint::Breakpoint
 * @param address
 */
Breakpoint::Breakpoint(edb::address_t address)
	: address_(address), type_(edb::v1::config().default_breakpoint_type) {

	if (!this->enable()) {
		throw BreakpointCreationError();
	}
}

/**
 * @brief Breakpoint::supportedTypes
 * @return
 */
auto Breakpoint::supportedTypes() -> std::vector<BreakpointType> {
	std::vector<BreakpointType> types = {
		BreakpointType{Type{TypeId::Automatic}, tr("Automatic")},
		BreakpointType{Type{TypeId::INT3}, tr("INT3")},
		BreakpointType{Type{TypeId::INT1}, tr("INT1 (ICEBP)")},
		BreakpointType{Type{TypeId::HLT}, tr("HLT")},
		BreakpointType{Type{TypeId::CLI}, tr("CLI")},
		BreakpointType{Type{TypeId::STI}, tr("STI")},
		BreakpointType{Type{TypeId::INSB}, tr("INSB")},
		BreakpointType{Type{TypeId::INSD}, tr("INSD")},
		BreakpointType{Type{TypeId::OUTSB}, tr("OUTSB")},
		BreakpointType{Type{TypeId::OUTSD}, tr("OUTSD")},
		BreakpointType{Type{TypeId::UD2}, tr("UD2 (2-byte)")},
		BreakpointType{Type{TypeId::UD0}, tr("UD0 (2-byte)")},
	};
	return types;
}

/**
 * @brief Breakpoint::setType
 * @param type
 */
void Breakpoint::setType(TypeId type) {
	disable();
	type_ = type;
	if (!enable()) {
		throw BreakpointCreationError();
	}
}

/**
 * @brief Breakpoint::setType
 * @param type
 */
void Breakpoint::setType(IBreakpoint::TypeId type) {
	disable();

	if (Type{type} >= TypeId::TYPE_COUNT) {
		throw BreakpointCreationError();
	}

	setType(type);
}

/**
 * @brief Breakpoint::~Breakpoint
 */
Breakpoint::~Breakpoint() {
	this->disable();
}

/**
 * @brief Breakpoint::enable
 * @return
 */
bool Breakpoint::enable() {
	if (!enabled()) {
		if (IProcess *process = edb::v1::debugger_core->process()) {
			std::vector<uint8_t> prev(2);
			if (process->readBytes(address(), &prev[0], prev.size())) {
				originalBytes_                      = prev;
				const std::vector<uint8_t> *bpBytes = nullptr;

				switch (TypeId{type_}) {
				case TypeId::Automatic:
				case TypeId::INT3:
					bpBytes = &BreakpointInstructionINT3;
					break;
				case TypeId::INT1:
					bpBytes = &BreakpointInstructionINT1;
					break;
				case TypeId::HLT:
					bpBytes = &BreakpointInstructionHLT;
					break;
				case TypeId::CLI:
					bpBytes = &BreakpointInstructionCLI;
					break;
				case TypeId::STI:
					bpBytes = &BreakpointInstructionSTI;
					break;
				case TypeId::INSB:
					bpBytes = &BreakpointInstructionINSB;
					break;
				case TypeId::INSD:
					bpBytes = &BreakpointInstructionINSD;
					break;
				case TypeId::OUTSB:
					bpBytes = &BreakpointInstructionOUTSB;
					break;
				case TypeId::OUTSD:
					bpBytes = &BreakpointInstructionOUTSD;
					break;
				case TypeId::UD2:
					bpBytes = &BreakpointInstructionUD2;
					break;
				case TypeId::UD0:
					bpBytes = &BreakpointInstructionUD0;
					break;
				default:
					return false;
				}

				assert(bpBytes);
				assert(originalBytes_.size() >= bpBytes->size());
				originalBytes_.resize(bpBytes->size());

				if (process->writeBytes(address(), bpBytes->data(), bpBytes->size())) {
					enabled_ = true;
					return true;
				}
			}
		}
	}
	return false;
}

/**
 * @brief Breakpoint::disable
 * @return
 */
bool Breakpoint::disable() {
	if (enabled()) {
		if (IProcess *process = edb::v1::debugger_core->process()) {
			if (process->writeBytes(address(), &originalBytes_[0], originalBytes_.size())) {
				enabled_ = false;
				return true;
			}
		}
	}
	return false;
}

/**
 * @brief Breakpoint::hit
 */
void Breakpoint::hit() {
	++hitCount_;
}

/**
 * @brief Breakpoint::setOneTime
 * @param value
 */
void Breakpoint::setOneTime(bool value) {
	oneTime_ = value;
}

/**
 * @brief Breakpoint::setInternal
 * @param value
 */
void Breakpoint::setInternal(bool value) {
	internal_ = value;
}

/**
 * @brief Breakpoint::possibleRewindSizes
 * @return
 */
std::vector<size_t> Breakpoint::possibleRewindSizes() {
	return {1, 0, 2}; // e.g. int3/int1, cli/sti/hlt/etc., int 0x1/int 0x3
}

}

```

`plugins/DebuggerCore/arch/x86-generic/Breakpoint.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef X86_BREAKPOINT_H_20060720_
#define X86_BREAKPOINT_H_20060720_

#include "IBreakpoint.h"
#include "Util.h"
#include <QCoreApplication>
#include <array>
#include <vector>

namespace DebuggerCorePlugin {

class Breakpoint final : public IBreakpoint {
	Q_DECLARE_TR_FUNCTIONS(Breakpoint)
public:
	enum class TypeId {
		Automatic = static_cast<int>(IBreakpoint::TypeId::Automatic),
		INT3,
		INT1,
		HLT,
		CLI,
		STI,
		INSB,
		INSD,
		OUTSB,
		OUTSD,
		UD2,
		UD0,

		TYPE_COUNT
	};

	using Type = util::AbstractEnumData<IBreakpoint::TypeId, TypeId>;

public:
	explicit Breakpoint(edb::address_t address);
	~Breakpoint() override;

public:
	edb::address_t address() const override { return address_; }
	uint64_t hitCount() const override { return hitCount_; }
	bool enabled() const override { return enabled_; }
	bool oneTime() const override { return oneTime_; }
	bool internal() const override { return internal_; }
	size_t size() const override { return originalBytes_.size(); }
	const uint8_t *originalBytes() const override { return &originalBytes_[0]; }
	IBreakpoint::TypeId type() const override { return type_; }

	static std::vector<BreakpointType> supportedTypes();
	static std::vector<size_t> possibleRewindSizes();

public:
	bool enable() override;
	bool disable() override;
	void hit() override;
	void setOneTime(bool value) override;
	void setInternal(bool value) override;
	void setType(IBreakpoint::TypeId type) override;
	void setType(TypeId type);

private:
	std::vector<uint8_t> originalBytes_;
	edb::address_t address_;
	uint64_t hitCount_ = 0;
	bool enabled_      = false;
	bool oneTime_      = false;
	bool internal_     = false;
	Type type_;
};

}

#endif

```

`plugins/DebuggerCore/unix/Posix.cpp`:

```cpp

#include "Posix.h"
#include <cerrno>
#include <fcntl.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#include <QProcess>

#ifdef Q_OS_LINUX
#include <linux/version.h>
// being very conservative for now, technically this could be
// as low as 2.6.22
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
#define USE_SIGTIMEDWAIT
#endif
#endif

namespace DebuggerCorePlugin {

namespace {

#if !defined(USE_SIGTIMEDWAIT)
int selfpipe[2];
struct sigaction old_action;

/**
 * @brief sigchld_handler
 * @param sig
 * @param info
 * @param p
 */
void sigchld_handler(int sig, siginfo_t *info, void *p) {

	if (sig == SIGCHLD) {
		Posix::write(selfpipe[1], " ", sizeof(char));
	}

	// load as volatile
	volatile struct sigaction *vsa = &old_action;

	if (old_action.sa_flags & SA_SIGINFO) {
		using old_action_type       = void (*)(int, siginfo_t *, void *);
		old_action_type prev_action = vsa->sa_sigaction;

		if (prev_action) {
			prev_action(sig, info, p);
		}
	} else {
		using old_action_type       = void (*)(int);
		old_action_type prev_action = vsa->sa_handler;

		if (prev_action && prev_action != SIG_IGN) {
			prev_action(sig);
		}
	}
}

struct timeval duration_to_timeval(std::chrono::milliseconds msecs) {
	struct timeval tv;
	tv.tv_sec  = (msecs.count() / 1000);
	tv.tv_usec = (msecs.count() % 1000) * 1000;
	return tv;
}
#else
timespec duration_to_timespec(std::chrono::milliseconds msecs) {
	struct timespec ts;
	ts.tv_sec  = (msecs.count() / 1000);
	ts.tv_nsec = (msecs.count() % 1000) * 1000000;
	return ts;
}
#endif
}

namespace detail {
namespace {
/**
 * @brief sigtimedwait
 * @param set
 * @param info
 * @param timeout
 * @return
 */
int sigtimedwait(const sigset_t *set, siginfo_t *info, const struct timespec *timeout) {
	int ret;
	do {
		ret = ::sigtimedwait(set, info, timeout);
	} while (ret == -1 && errno == EINTR);
	return ret;
}

}
}

/**
 * @brief Posix::read
 * @param fd
 * @param buf
 * @param count
 * @return
 */
ssize_t Posix::read(int fd, void *buf, size_t count) {
	ssize_t ret;
	do {
		ret = ::read(fd, buf, count);
	} while (ret == -1 && errno == EINTR);
	return ret;
}

/**
 * @brief Posix::write
 * @param fd
 * @param buf
 * @param count
 * @return
 */
ssize_t Posix::write(int fd, const void *buf, size_t count) {
	ssize_t ret;
	do {
		ret = ::write(fd, buf, count);
	} while (ret == -1 && errno == EINTR);
	return ret;
}

/**
 * @brief Posix::select
 * @param nfds
 * @param readfds
 * @param writefds
 * @param exceptfds
 * @param timeout
 * @return
 */
int Posix::select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout) {
	int ret;
	do {
		ret = ::select(nfds, readfds, writefds, exceptfds, timeout);
	} while (ret == -1 && errno == EINTR);
	return ret;
}

/**
 * @brief Posix::waitpid
 * @param pid
 * @param status
 * @param options
 * @return
 */
pid_t Posix::waitpid(pid_t pid, int *status, int options) {
	pid_t ret;
	do {
		ret = ::waitpid(pid, status, options);
	} while (ret == -1 && errno == EINTR);
	return ret;
}

#if !defined(USE_SIGTIMEDWAIT)
/**
 * similar to select but has the timeout specified as a quantity of msecs
 *
 * @brief Posix::select_ex
 * @param nfds
 * @param readfds
 * @param writefds
 * @param exceptfds
 * @param msecs - 0 means wait forever.
 * @return
 */
int Posix::select_ex(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, std::chrono::milliseconds msecs) {
	if (msecs.count() != 0) {
		struct timeval tv = duration_to_timeval(msecs);
		return Posix::select(nfds, readfds, writefds, exceptfds, &tv);
	} else {
		return Posix::select(nfds, readfds, writefds, exceptfds, nullptr);
	}
}
#endif

/**
 * @brief Posix::wait_for_sigchld
 * @param msecs
 * @return
 */
bool Posix::wait_for_sigchld(std::chrono::milliseconds msecs) {
#if !defined(USE_SIGTIMEDWAIT)
	fd_set rfds;
	FD_ZERO(&rfds);
	FD_SET(selfpipe[0], &rfds);

	if (Posix::select_ex(selfpipe[0] + 1, &rfds, nullptr, nullptr, msecs) == 0) {
		return true;
	}

	char ch;
	if (Posix::read(selfpipe[0], &ch, sizeof(char)) == -1) {
		return true;
	}

	return false;
#else
	sigset_t mask;
	siginfo_t info;
	struct timespec ts = duration_to_timespec(msecs);
	sigemptyset(&mask);
	sigaddset(&mask, SIGCHLD);

	return detail::sigtimedwait(&mask, &info, &ts) == SIGCHLD;
#endif
}

/**
 * @brief Posix::initialize
 */
void Posix::initialize() {
#if !defined(USE_SIGTIMEDWAIT)

	// HACK(eteran): so, the first time we create a QProcess, it will hook SIGCHLD
	//               unfortunately, in Qt5 it doesn't seem to call our handler
	//               so we do this to force it to hook BEFORE we do, letting us
	//               get the first crack at the signal, then we call the one that
	//               Qt installed.
	auto p = new QProcess(nullptr);
	p->start("/bin/true");

	// create a pipe and make it non-blocking
	int r = ::pipe(selfpipe);
	Q_UNUSED(r)

	::fcntl(selfpipe[0], F_SETFL, ::fcntl(selfpipe[0], F_GETFL) | O_NONBLOCK);
	::fcntl(selfpipe[1], F_SETFL, ::fcntl(selfpipe[1], F_GETFL) | O_NONBLOCK);

	// setup a signal handler
	struct sigaction new_action = {};

	new_action.sa_sigaction = sigchld_handler;
	new_action.sa_flags     = SA_RESTART | SA_SIGINFO;
	sigemptyset(&new_action.sa_mask);

	sigaction(SIGCHLD, &new_action, &old_action);
#else
	// TODO(eteran): the man pages mention blocking the signal we want to catch
	//               but I'm not sure if it is necessary for this use case...
#endif
}

}

```

`plugins/DebuggerCore/unix/Posix.h`:

```h

#ifndef POSIX_H_20181211_
#define POSIX_H_20181211_

#include "OSTypes.h"
#include <chrono>
#include <cstdint>

namespace DebuggerCorePlugin {
namespace Posix {

void initialize();
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
int select_ex(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, std::chrono::milliseconds msecs);
pid_t waitpid(pid_t pid, int *status, int options);
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
bool wait_for_sigchld(std::chrono::milliseconds msecs);

}
}

#endif

```

`plugins/DebuggerCore/unix/Unix.cpp`:

```cpp

#include "Unix.h"
#include <cstring>
#include <signal.h>
#include <unistd.h>

namespace DebuggerCorePlugin {
namespace {

struct Exception {
	qlonglong value;
	const char *const name;
};

constexpr Exception Exceptions[] = {
#ifdef SIGABRT
	{SIGABRT, "SIGABRT"},
#endif
#ifdef SIGALRM
	{SIGALRM, "SIGALRM"},
#endif
#ifdef SIGVTALRM
	{SIGVTALRM, "SIGVTALRM"},
#endif
#ifdef SIGPROF
	{SIGPROF, "SIGPROF"},
#endif
#ifdef SIGBUS
	{SIGBUS, "SIGBUS"},
#endif
#ifdef SIGCHLD
	{SIGCHLD, "SIGCHLD"},
#endif
#ifdef SIGCONT
	{SIGCONT, "SIGCONT"},
#endif
#ifdef SIGFPE
	{SIGFPE, "SIGFPE"},
#endif
#ifdef SIGHUP
	{SIGHUP, "SIGHUP"},
#endif
#ifdef SIGILL
	{SIGILL, "SIGILL"},
#endif
#ifdef SIGINT
	{SIGINT, "SIGINT"},
#endif
#ifdef SIGKILL
	{SIGKILL, "SIGKILL"},
#endif
#ifdef SIGPIPE
	{SIGPIPE, "SIGPIPE"},
#endif
#ifdef SIGQUIT
	{SIGQUIT, "SIGQUIT"},
#endif
#ifdef SIGSEGV
	{SIGSEGV, "SIGSEGV"},
#endif
#ifdef SIGSTOP
	{SIGSTOP, "SIGSTOP"},
#endif
#ifdef SIGTERM
	{SIGTERM, "SIGTERM"},
#endif
#ifdef SIGTSTP
	{SIGTSTP, "SIGTSTP"},
#endif
#ifdef SIGTTIN
	{SIGTTIN, "SIGTTIN"},
#endif
#ifdef SIGTTOU
	{SIGTTOU, "SIGTTOU"},
#endif
#ifdef SIGUSR1
	{SIGUSR1, "SIGUSR1"},
#endif
#ifdef SIGUSR2
	{SIGUSR2, "SIGUSR2"},
#endif
#ifdef SIGPOLL
	{SIGPOLL, "SIGPOLL"},
#endif
#ifdef SIGSYS
	{SIGSYS, "SIGSYS"},
#endif
#ifdef SIGTRAP
	{SIGTRAP, "SIGTRAP"},
#endif
#ifdef SIGURG
	{SIGURG, "SIGURG"},
#endif
#ifdef SIGXCPU
	{SIGXCPU, "SIGXCPU"},
#endif
#ifdef SIGXFSZ
	{SIGXFSZ, "SIGXFSZ"},
#endif
#ifdef SIGIO
	{SIGIO, "SIGIO"},
#endif
#ifdef SIGSTKFLT
	{SIGSTKFLT, "SIGSTKFLT"},
#endif
#ifdef SIGWINCH
	{SIGWINCH, "SIGWINCH"},
#endif
};

/**
 * @brief copyString
 * @param str
 * @return
 */
char *copyString(const QByteArray &str) {
	char *p = new char[str.length() + 1];
	std::strcpy(p, str.constData());
	return p;
}

}

/**
 * @brief Unix::exceptions
 * @return
 */
QMap<qlonglong, QString> Unix::exceptions() {

	QMap<qlonglong, QString> exceptions;
	for (Exception e : Exceptions) {
		exceptions.insert(e.value, e.name);
	}
	return exceptions;
}

/**
 * @brief Unix::exception_name
 * @param value
 * @return
 */
QString Unix::exception_name(qlonglong value) {
	auto it = std::find_if(std::begin(Exceptions), std::end(Exceptions), [value](const Exception &ex) {
		return ex.value == value;
	});

	if (it != std::end(Exceptions)) {
		return it->name;
	}

	return QString();
}

/**
 * @brief Unix::exception_value
 * @param name
 * @return
 */
qlonglong Unix::exception_value(const QString &name) {
	auto it = std::find_if(std::begin(Exceptions), std::end(Exceptions), [&name](const Exception &ex) {
		return ex.name == name;
	});

	if (it != std::end(Exceptions)) {
		return it->value;
	}

	return -1;
}

/**
 * @brief Unix::execute_process
 * @param path
 * @param cwd
 * @param args
 * @return
 */
Status Unix::execute_process(const QString &path, const QString &cwd, const QList<QByteArray> &args) {

	QString errorString = "internal error";

	// change to the desired working directory
	if (::chdir(qPrintable(cwd)) == 0) {

		// allocate space for all the arguments
		auto argv_pointers = new char *[args.count() + 2];

		char **p = argv_pointers;

		*p++ = copyString(path.toLocal8Bit());

		for (int i = 0; i < args.count(); ++i) {
			*p++ = copyString(args[i]);
		}

		*p = nullptr;

		// NOTE: it's a bad idea to use execvp and similar functions searching in
		// $PATH. At least on Linux, if the file is corrupted/unsupported, they
		// instead appear to launch shell
		const int ret = execv(argv_pointers[0], argv_pointers);

		// should be no need to cleanup, the process which allocated all that
		// space no longer exists!
		// if we get here...execv failed!
		if (ret == -1) {
			errorString = QString("execv() failed: %1").arg(strerror(errno));
			p           = argv_pointers;
			while (*p) {
				delete[] * p++;
			}
			delete[] argv_pointers;
		}
	}

	// frankly, any return is technically an error I think
	// this is only executed from a fork
	return Status(errorString);
}

}

```

`plugins/DebuggerCore/unix/Unix.h`:

```h

#ifndef UNIX_H_20181211_
#define UNIX_H_20181211_

#include "Status.h"
#include <QMap>
#include <QString>
#include <QtGlobal>

namespace DebuggerCorePlugin {
namespace Unix {

QMap<qlonglong, QString> exceptions();
QString exception_name(qlonglong value);
qlonglong exception_value(const QString &name);
Status execute_process(const QString &path, const QString &cwd, const QList<QByteArray> &args);

}
}

#endif

```

`plugins/DebuggerCore/unix/freebsd/DebuggerCore.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DebuggerCore.h"
#include "PlatformEvent.h"
#include "PlatformRegion.h"
#include "PlatformState.h"
#include "State.h"
#include "string_hash.h"

#include <QDebug>
#include <QMessageBox>

#include <cerrno>
#include <cstring>

#include <fcntl.h>
#include <kvm.h>
#include <machine/reg.h>
#include <paths.h>
#include <signal.h>
#include <sys/mman.h>
#include <sys/param.h>
#include <sys/ptrace.h>
#include <sys/sysctl.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <unistd.h>

namespace DebuggerCorePlugin {

namespace {

constexpr uint64_t PageSize = 0x1000;

void SET_OK(bool &ok, long value) {
	ok = (value != -1) || (errno == 0);
}

int resume_code(int status) {
	if (WIFSIGNALED(status)) {
		return WTERMSIG(status);
	} else if (WIFSTOPPED(status)) {
		return WSTOPSIG(status);
	}
	return 0;
}
}

//------------------------------------------------------------------------------
// Name: DebuggerCore
// Desc: constructor
//------------------------------------------------------------------------------
DebuggerCore::DebuggerCore() {
#if defined(_SC_PAGESIZE)
	page_size_ = sysconf(_SC_PAGESIZE);
#elif defined(_SC_PAGE_SIZE)
	page_size_ = sysconf(_SC_PAGE_SIZE);
#else
	page_size_ = PageSize;
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
bool DebuggerCore::has_extension(quint64 ext) const {
	Q_UNUSED(ext)
	return false;
}

//------------------------------------------------------------------------------
// Name: page_size
// Desc: returns the size of a page on this system
//------------------------------------------------------------------------------
size_t DebuggerCore::page_size() const {
	return page_size_;
}

//------------------------------------------------------------------------------
// Name: ~DebuggerCore
// Desc:
//------------------------------------------------------------------------------
DebuggerCore::~DebuggerCore() {
	detach();
}

//------------------------------------------------------------------------------
// Name: wait_debug_event
// Desc: waits for a debug event, msecs is a timeout
//      it will return false if an error or timeout occurs
//------------------------------------------------------------------------------
std::shared_ptr<const IDebugEvent> DebuggerCore::wait_debug_event(int msecs) {
	if (attached()) {
		int status;
		bool timeout;

		const edb::tid_t tid = Posix::waitpid_timeout(pid(), &status, 0, msecs, &timeout);
		if (!timeout) {
			if (tid > 0) {

				// normal event
				auto e    = std::make_shared<PlatformEvent>();
				e->pid    = pid();
				e->tid    = tid;
				e->status = status;

				char errbuf[_POSIX2_LINE_MAX];
				if (kvm_t *const kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) {
					int rc;
					struct kinfo_proc *const proc = kvm_getprocs(kd, KERN_PROC_PID, pid(), &rc);

					struct proc p;
					kvm_read(kd, (unsigned long)proc->ki_paddr, &p, sizeof(p));

					struct ksiginfo siginfo;
					kvm_read(kd, (unsigned long)p.p_ksi, &siginfo, sizeof(siginfo));

					// TODO: why doesn't this get the fault address correctly?
					// perhaps I need to target the tid instead?
					e->fault_code_    = siginfo.ksi_code;
					e->fault_address_ = siginfo.ksi_addr;

					//printf("ps_sig   : %d\n", siginfo.ksi_signo);
					//printf("ps_type  : %d\n", p.p_stype);
					kvm_close(kd);
				} else {
					e->fault_code_    = 0;
					e->fault_address_ = 0;
				}

				active_thread_       = tid;
				threads_[tid].status = status;
				return e;
			}
		}
	}
	return nullptr;
}

//------------------------------------------------------------------------------
// Name: read_data
// Desc:
//------------------------------------------------------------------------------
long DebuggerCore::read_data(edb::address_t address, bool *ok) {

	Q_ASSERT(ok);
	errno        = 0;
	const long v = ptrace(PT_READ_D, pid(), reinterpret_cast<char *>(address), 0);
	SET_OK(*ok, v);
	return v;
}

//------------------------------------------------------------------------------
// Name: write_data
// Desc:
//------------------------------------------------------------------------------
bool DebuggerCore::write_data(edb::address_t address, long value) {
	return ptrace(PT_WRITE_D, pid(), reinterpret_cast<char *>(address), value) != -1;
}

//------------------------------------------------------------------------------
// Name: attach
// Desc:
//------------------------------------------------------------------------------
bool DebuggerCore::attach(edb::pid_t pid) {
	detach();

	const long ret = ptrace(PT_ATTACH, pid, 0, 0);
	if (ret == 0) {
		pid_           = pid;
		active_thread_ = pid;
		threads_.clear();
		threads_.insert(pid, thread_info());

		// TODO: attach to all of the threads
	}

	return ret == 0;
}

//------------------------------------------------------------------------------
// Name: detach
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::detach() {
	if (attached()) {

		// TODO: do i need to stop each thread first, and wait for them?

		clear_breakpoints();
		for (auto it = threads_.begin(); it != threads_.end(); ++it) {
			ptrace(PT_DETACH, it.key(), 0, 0);
		}

		pid_ = 0;
		threads_.clear();
	}
}

//------------------------------------------------------------------------------
// Name: kill
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::kill() {
	if (attached()) {
		clear_breakpoints();
		ptrace(PT_KILL, pid(), 0, 0);
		Posix::waitpid(pid(), 0, WAIT_ANY);
		pid_ = 0;
		threads_.clear();
	}
}

//------------------------------------------------------------------------------
// Name: pause
// Desc: stops *all* threads of a process
//------------------------------------------------------------------------------
void DebuggerCore::pause() {
	if (attached()) {
		for (auto it = threads_.begin(); it != threads_.end(); ++it) {
			::kill(it.key(), SIGSTOP);
		}
	}
}

//------------------------------------------------------------------------------
// Name: resume
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::resume(edb::EVENT_STATUS status) {
	// TODO: assert that we are paused

	if (attached()) {
		if (status != edb::DEBUG_STOP) {
			const edb::tid_t tid = active_thread();
			const int code       = (status == edb::DEBUG_EXCEPTION_NOT_HANDLED) ? resume_code(threads_[tid].status) : 0;
			ptrace(PT_CONTINUE, tid, reinterpret_cast<caddr_t>(1), code);
		}
	}
}

//------------------------------------------------------------------------------
// Name: open
// Desc:
//------------------------------------------------------------------------------
bool DebuggerCore::open(const QString &path, const QString &cwd, const QList<QByteArray> &args, const QString &tty) {
	detach();
	pid_t pid;

	switch (pid = fork()) {
	case 0:
		// we are in the child now...

		// set ourselves (the child proc) up to be traced
		ptrace(PT_TRACE_ME, 0, 0, 0);

		// redirect it's I/O
		if (!tty.isEmpty()) {
			FILE *const std_out = freopen(qPrintable(tty), "r+b", stdout);
			FILE *const std_in  = freopen(qPrintable(tty), "r+b", stdin);
			FILE *const std_err = freopen(qPrintable(tty), "r+b", stderr);

			Q_UNUSED(std_out)
			Q_UNUSED(std_in)
			Q_UNUSED(std_err)
		}

		// do the actual exec
		execute_process(path, cwd, args);

		// we should never get here!
		abort();
		break;
	case -1:
		// error!
		pid_ = 0;
		return false;
	default:
		// parent
		do {
			threads_.clear();

			int status;
			if (Posix::waitpid(pid, &status, 0) == -1) {
				return false;
			}

			// the very first event should be a STOP of type SIGTRAP
			if (!WIFSTOPPED(status) || WSTOPSIG(status) != SIGTRAP) {
				detach();
				return false;
			}

			// setup the first event data for the primary thread
			threads_.insert(pid, thread_info());
			pid_                 = pid;
			active_thread_       = pid;
			threads_[pid].status = status;
			return true;
		} while (0);
		break;
	}
}

//------------------------------------------------------------------------------
// Name: set_active_thread
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::set_active_thread(edb::tid_t tid) {
	Q_ASSERT(threads_.contains(tid));
	active_thread_ = tid;
}

//------------------------------------------------------------------------------
// Name: create_state
// Desc:
//------------------------------------------------------------------------------
std::unique_ptr<IState> DebuggerCore::create_state() const {
	return std::make_unique<PlatformState>();
}

//------------------------------------------------------------------------------
// Name: enumerate_processes
// Desc:
//------------------------------------------------------------------------------
QMap<edb::pid_t, ProcessInfo> DebuggerCore::enumerate_processes() const {
	QMap<edb::pid_t, ProcessInfo> ret;

	char ebuffer[_POSIX2_LINE_MAX];
	int numprocs;
	if (kvm_t *const kaccess = kvm_openfiles(_PATH_DEVNULL, _PATH_DEVNULL, 0, O_RDONLY, ebuffer)) {
		if (struct kinfo_proc *const kprocaccess = kvm_getprocs(kaccess, KERN_PROC_ALL, 0, &numprocs)) {
			for (int i = 0; i < numprocs; ++i) {
				ProcessInfo procInfo;

				procInfo.pid  = kprocaccess[i].ki_pid;
				procInfo.uid  = kprocaccess[i].ki_uid;
				procInfo.name = kprocaccess[i].ki_comm;
				ret.insert(procInfo.pid, procInfo);
			}
		}
		kvm_close(kaccess);
	} else {
		QMessageBox::warning(0, "Error Listing Processes", ebuffer);
	}

	return ret;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
edb::pid_t DebuggerCore::parent_pid(edb::pid_t pid) const {
	// TODO: implement this
	return -1;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
quint64 DebuggerCore::cpu_type() const {
#ifdef EDB_X86
	return edb::string_hash<'x', '8', '6'>::value;
#elif defined(EDB_X86_64)
	return edb::string_hash<'x', '8', '6', '-', '6', '4'>::value;
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::format_pointer(edb::address_t address) const {
	char buf[32];
#ifdef EDB_X86
	qsnprintf(buf, sizeof(buf), "%08x", address);
#elif defined(EDB_X86_64)
	qsnprintf(buf, sizeof(buf), "%016llx", address);
#endif
	return buf;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::stack_pointer() const {
#ifdef EDB_X86
	return "esp";
#elif defined(EDB_X86_64)
	return "rsp";
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::frame_pointer() const {
#ifdef EDB_X86
	return "ebp";
#elif defined(EDB_X86_64)
	return "rbp";
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::instruction_pointer() const {
#ifdef EDB_X86
	return "eip";
#elif defined(EDB_X86_64)
	return "rip";
#endif
}

}

```

`plugins/DebuggerCore/unix/freebsd/DebuggerCore.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DEBUGGER_CORE_H_20090529_
#define DEBUGGER_CORE_H_20090529_

#include "DebuggerCoreBase.h"
#include <QHash>

namespace DebuggerCorePlugin {

class DebuggerCore : public DebuggerCoreBase {
	Q_OBJECT
	Q_PLUGIN_METADATA(IID "edb.IDebugger/1.0")
	Q_INTERFACES(IDebugger)
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")
	friend class PlatformProcess;
	friend class PlatformThread;

public:
	DebuggerCore();
	~DebuggerCore() override;

public:
	std::size_t pointer_size() const override;
	size_t page_size() const override;
	bool has_extension(quint64 ext) const override;
	std::shared_ptr<IDebugEvent> wait_debug_event(int msecs) override;
	Status attach(edb::pid_t pid) override;
	Status detach() override;
	void kill() override;
	Status open(const QString &path, const QString &cwd, const QList<QByteArray> &args, const QString &tty) override;
	MeansOfCapture lastMeansOfCapture() const override;
	void set_ignored_exceptions(const QList<qlonglong> &exceptions) override;

public:
	QMap<qlonglong, QString> exceptions() const override;
	QString exceptionName(qlonglong value) override;
	qlonglong exceptionValue(const QString &name) override;

public:
	edb::pid_t parent_pid(edb::pid_t pid) const override;

public:
	std::unique_ptr<IState> create_state() const override;

public:
	quint64 cpu_type() const override;

private:
	QMap<edb::pid_t, std::shared_ptr<IProcess>> enumerate_processes() const override;

public:
	QString stack_pointer() const override;
	QString frame_pointer() const override;
	QString instruction_pointer() const override;
	QString flag_register() const override;

public:
	IProcess *process() const override;

private:
	virtual long read_data(edb::address_t address, bool *ok);
	virtual bool write_data(edb::address_t address, long value);

private:
	struct thread_info {
	public:
		thread_info() = default;
		thread_info(int s)
			: status(s) {
		}

		int status = 0;
	};

	using threadmap_t = QHash<edb::tid_t, thread_info>;

	edb::address_t page_size_;
	threadmap_t threads_;
};

}

#endif

```

`plugins/DebuggerCore/unix/freebsd/PlatformCommon.cpp`:

```cpp

#include "PlatformCommon.h"

```

`plugins/DebuggerCore/unix/freebsd/PlatformCommon.h`:

```h

#ifndef PLATFORM_COMMON_H_20181225_
#define PLATFORM_COMMON_H_20181225_

#endif

```

`plugins/DebuggerCore/unix/freebsd/PlatformEvent.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformEvent.h"
#include "edb.h"
#include <cstdio>
#include <cstring>
#include <fcntl.h>
#include <kvm.h>
#include <signal.h> // for the SIG* definitions
#include <sys/exec.h>
#include <sys/mman.h>
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/ptrace.h>
#include <sys/signalvar.h>
#include <sys/sysctl.h>
#include <sys/types.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <unistd.h>

namespace DebuggerCorePlugin {

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
PlatformEvent::PlatformEvent()
	: status(0), pid(-1), tid(-1), fault_address_(0), fault_code_(0) {
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
PlatformEvent *PlatformEvent::clone() const {
	return new PlatformEvent(*this);
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
IDebugEvent::Message PlatformEvent::error_description() const {
	Q_ASSERT(is_error());

	auto fault_address = reinterpret_cast<edb::address_t>(fault_address_);

	switch (code()) {
	case SIGSEGV:
		return Message(
			tr("Illegal Access Fault"),
			tr(
				"<p>The debugged application encountered a segmentation fault.<br />The address <strong>0x%1</strong> could not be accessed.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>")
				.arg(edb::v1::format_pointer(fault_address)));
	case SIGILL:
		return Message(
			tr("Illegal Instruction Fault"),
			tr(
				"<p>The debugged application attempted to execute an illegal instruction.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
	case SIGFPE:
		switch (fault_code_) {
		case FPE_INTDIV:
			return Message(
				tr("Divide By Zero"),
				tr(
					"<p>The debugged application tried to divide an integer value by an integer divisor of zero.</p>"
					"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
		default:
			return Message(
				tr("Floating Point Exception"),
				tr(
					"<p>The debugged application encountered a floating-point exception.</p>"
					"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
		}

	case SIGABRT:
		return Message(
			tr("Application Aborted"),
			tr(
				"<p>The debugged application has aborted.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
	case SIGBUS:
		return Message(
			tr("Bus Error"),
			tr(
				"<p>The debugged application tried to read or write data that is misaligned.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
#ifdef SIGSTKFLT
	case SIGSTKFLT:
		return Message(
			tr("Stack Fault"),
			tr(
				"<p>The debugged application encountered a stack fault.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
#endif
	case SIGPIPE:
		return Message(
			tr("Broken Pipe Fault"),
			tr(
				"<p>The debugged application encountered a broken pipe fault.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
	default:
		return Message();
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
IDebugEvent::REASON PlatformEvent::reason() const {
	// this basically converts our value into a 'switchable' value for convenience

	if (stopped()) {
		return EVENT_STOPPED;
	} else if (terminated()) {
		return EVENT_TERMINATED;
	} else if (exited()) {
		return EVENT_EXITED;
	} else {
		return EVENT_UNKNOWN;
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
IDebugEvent::TRAP_REASON PlatformEvent::trap_reason() const {
	switch (fault_code_) {
	case TRAP_TRACE:
		return TRAP_STEPPING;
	default:
		return TRAP_BREAKPOINT;
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::exited() const {
	return WIFEXITED(status) != 0;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::is_error() const {
	if (stopped()) {
		switch (code()) {
		case SIGTRAP:
		case SIGSTOP:
			return false;
		case SIGSEGV:
		case SIGILL:
		case SIGFPE:
		case SIGABRT:
		case SIGBUS:
#ifdef SIGSTKFLT
		case SIGSTKFLT:
#endif
		case SIGPIPE:
			return true;
		default:
			return false;
		}
	} else {
		return false;
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::is_kill() const {
	return stopped() && code() == SIGKILL;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::is_stop() const {
	return stopped() && code() == SIGSTOP;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::is_trap() const {
	return stopped() && code() == SIGTRAP;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::terminated() const {
	return WIFSIGNALED(status) != 0;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::stopped() const {
	return WIFSTOPPED(status) != 0;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
edb::pid_t PlatformEvent::process() const {
	return pid;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
edb::tid_t PlatformEvent::thread() const {
	return tid;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
int64_t PlatformEvent::code() const {
	if (stopped()) {
		return WSTOPSIG(status);
	}

	if (terminated()) {
		return WTERMSIG(status);
	}

	if (exited()) {
		return WEXITSTATUS(status);
	}

	return 0;
}

}

```

`plugins/DebuggerCore/unix/freebsd/PlatformEvent.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_EVENT_H_20121005_
#define PLATFORM_EVENT_H_20121005_

#include "IDebugEvent.h"
#include <QCoreApplication>

namespace DebuggerCorePlugin {

class PlatformEvent : IDebugEvent {
	Q_DECLARE_TR_FUNCTIONS(PlatformEvent)
	friend class DebuggerCore;

public:
	PlatformEvent();

public:
	PlatformEvent *clone() const override;

public:
	Message error_description() const override;
	REASON reason() const override;
	TRAP_REASON trap_reason() const override;
	bool exited() const override;
	bool is_error() const override;
	bool is_kill() const override;
	bool is_stop() const override;
	bool is_trap() const override;
	bool terminated() const override;
	bool stopped() const override;
	edb::pid_t process() const override;
	edb::tid_t thread() const override;
	int64_t code() const override;

private:
	int status;
	edb::pid_t pid;
	edb::tid_t tid;
	void *fault_address_;
	long fault_code_;
};

}

#endif

```

`plugins/DebuggerCore/unix/freebsd/PlatformProcess.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformProcess.h"
#include <fcntl.h>
#include <kvm.h>
#include <machine/reg.h>
#include <paths.h>
#include <signal.h>
#include <sys/mman.h>
#include <sys/param.h>
#include <sys/ptrace.h>
#include <sys/sysctl.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <unistd.h>

namespace DebuggerCorePlugin {

QString PlatformProcess::executable() const {
	// TODO: implement this
	return QString();
}

QString PlatformProcess::current_working_directory() const {
	// TODO(eteran): implement this
	return QString();
}

QDateTime PlatformProcess::start_time() const {
	// TODO(eteran): implement this
	return QDateTime();
}

QList<Module> PlatformProcess::loaded_modules() const {
	QList<Module> modules;
	// TODO(eteran): implement this
	return modules;
}

edb::address_t PlatformProcess::code_address() const {
	// TODO(eteran): implement this
	return 0;
}

edb::address_t PlatformProcess::data_address() const {
	// TODO(eteran): implement this
	return 0;
}

QList<QByteArray> PlatformProcess::arguments() const {
	QList<QByteArray> ret;
	// TODO(eteran): implement this
	return ret;
}

QList<std::shared_ptr<IRegion>> PlatformProcess::regions() const {
	QList<std::shared_ptr<IRegion>> regions;

	if (pid_ != 0) {
		char buffer[PATH_MAX] = {};
		struct ptrace_vm_entry vm_entry;
		memset(&vm_entry, 0, sizeof(vm_entry));
		vm_entry.pve_entry = 0;

		while (ptrace(PT_VM_ENTRY, pid_, reinterpret_cast<char *>(&vm_entry), NULL) == 0) {
			vm_entry.pve_path    = buffer;
			vm_entry.pve_pathlen = sizeof(buffer);

			const edb::address_t start               = vm_entry.pve_start;
			const edb::address_t end                 = vm_entry.pve_end;
			const edb::address_t base                = vm_entry.pve_start - vm_entry.pve_offset;
			const QString name                       = vm_entry.pve_path;
			const IRegion::permissions_t permissions = vm_entry.pve_prot;

			regions.push_back(std::make_shared<PlatformRegion>(start, end, base, name, permissions));
			memset(buffer, 0, sizeof(buffer));
		}
	}

	return regions;
}

}

```

`plugins/DebuggerCore/unix/freebsd/PlatformProcess.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_PROCESS_H_20150517_
#define PLATFORM_PROCESS_H_20150517_

#include "IProcess.h"

class PlatformProcess : public IProcess {
public:
	// legal to call when not attached
	QDateTime start_time() const override;
	QList<QByteArray> arguments() const override;
	QString current_working_directory() const override;
	QString executable() const override;
	edb::pid_t pid() const override;
	std::shared_ptr<IProcess> parent() const override;
	edb::address_t code_address() const override;
	edb::address_t data_address() const override;
	edb::address_t entry_point() const override;
	QList<std::shared_ptr<IRegion>> regions() const override;
	edb::uid_t uid() const override;
	QString user() const override;
	QString name() const override;
	QList<Module> loaded_modules() const override;

public:
	edb::address_t debug_pointer() const override;
	edb::address_t calculate_main() const override;

public:
	// only legal to call when attached
	QList<std::shared_ptr<IThread>> threads() const override;
	std::shared_ptr<IThread> current_thread() const override;
	void set_current_thread(IThread &thread) override;
	std::size_t write_bytes(edb::address_t address, const void *buf, size_t len) override;
	std::size_t patch_bytes(edb::address_t address, const void *buf, size_t len) override;
	std::size_t read_bytes(edb::address_t address, void *buf, size_t len) const override;
	std::size_t read_pages(edb::address_t address, void *buf, size_t count) const override;
	Status pause() override;
	Status resume(edb::EVENT_STATUS status) override;
	Status step(edb::EVENT_STATUS status) override;
	bool isPaused() const override;
	QMap<edb::address_t, Patch> patches() const override;

private:
	edb::pid_t pid_;
};

#endif

```

`plugins/DebuggerCore/unix/freebsd/PlatformRegion.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformRegion.h"

#include "IDebugEventHandler.h"
#include "IDebugger.h"
#include "MemoryRegions.h"
#include "State.h"
#include "edb.h"
#include <QMessageBox>
#include <sys/mman.h>
#include <sys/syscall.h>

namespace DebuggerCorePlugin {

PlatformRegion::PlatformRegion(edb::address_t start, edb::address_t end, edb::address_t base, const QString &name, permissions_t permissions)
	: start_(start), end_(end), base_(base), name_(name), permissions_(permissions) {
}

IRegion *PlatformRegion::clone() const {
	return new PlatformRegion(start_, end_, base_, name_, permissions_);
}

bool PlatformRegion::accessible() const {
	return readable() || writable() || executable();
}

bool PlatformRegion::readable() const {
	return (permissions_ & PROT_READ) != 0;
}

bool PlatformRegion::writable() const {
	return (permissions_ & PROT_WRITE) != 0;
}

bool PlatformRegion::executable() const {
	return (permissions_ & PROT_EXEC) != 0;
}

size_t PlatformRegion::size() const {
	return end_ - start_;
}

void PlatformRegion::set_permissions(bool read, bool write, bool execute) {
	Q_UNUSED(read)
	Q_UNUSED(write)
	Q_UNUSED(execute)
}

edb::address_t PlatformRegion::start() const {
	return start_;
}

edb::address_t PlatformRegion::end() const {
	return end_;
}

edb::address_t PlatformRegion::base() const {
	return base_;
}

QString PlatformRegion::name() const {
	return name_;
}

IRegion::permissions_t PlatformRegion::permissions() const {
	return permissions_;
}

void PlatformRegion::set_start(edb::address_t address) {
	start_ = address;
}

void PlatformRegion::set_end(edb::address_t address) {
	end_ = address;
}

}

```

`plugins/DebuggerCore/unix/freebsd/PlatformRegion.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_REGION_H_20120330_
#define PLATFORM_REGION_H_20120330_

#include "IRegion.h"
#include <QCoreApplication>
#include <QString>

namespace DebuggerCorePlugin {

class PlatformRegion : public IRegion {
	Q_DECLARE_TR_FUNCTIONS(PlatformRegion)

public:
	PlatformRegion(edb::address_t start, edb::address_t end, edb::address_t base, const QString &name, permissions_t permissions);
	~PlatformRegion() override = default;

public:
	IRegion *clone() const override;

public:
	bool accessible() const override;
	bool readable() const override;
	bool writable() const override;
	bool executable() const override;
	size_t size() const override;

public:
	void set_permissions(bool read, bool write, bool execute) override;
	void set_start(edb::address_t address) override;
	void set_end(edb::address_t address) override;

public:
	edb::address_t start() const override;
	edb::address_t end() const override;
	edb::address_t base() const override;
	QString name() const override;
	permissions_t permissions() const override;

private:
	edb::address_t start_;
	edb::address_t end_;
	edb::address_t base_;
	QString name_;
	permissions_t permissions_;
};

}

#endif

```

`plugins/DebuggerCore/unix/freebsd/PlatformState.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformState.h"

namespace DebuggerCorePlugin {

}

```

`plugins/DebuggerCore/unix/freebsd/PlatformState.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_STATE_H_20110330_
#define PLATFORM_STATE_H_20110330_

#include "IState.h"
#include "Types.h"
#include "edb.h"
#include <cstddef>
#include <kvm.h>
#include <machine/reg.h>

namespace DebuggerCorePlugin {

class PlatformState : public IState {
	friend class DebuggerCore;
	friend class PlatformThread;

public:
	PlatformState();

public:
	std::unique_ptr<IState> clone() const override;

public:
	QString flagsToString() const override;
	QString flagsToString(edb::reg_t flags) const override;
	Register value(const QString &reg) const override;
	Register instructionPointeRregister() const override;
	Register flags_register() const override;
	edb::address_t frame_pointer() const override;
	edb::address_t instruction_pointer() const override;
	edb::address_t stack_pointer() const override;
	edb::reg_t debug_register(size_t n) const override;
	edb::reg_t flags() const override;
	int fpu_stack_pointer() const override;
	edb::value80 fpu_register(size_t n) const override;
	bool fpu_register_is_empty(size_t n) const override;
	QString fpu_register_tag_string(size_t n) const override;
	edb::value16 fpu_control_word() const override;
	edb::value16 fpu_status_word() const override;
	edb::value16 fpu_tag_word() const override;
	void adjust_stack(int bytes) override;
	void clear() override;
	bool empty() const override;
	void set_debug_register(size_t n, edb::reg_t value) override;
	void set_flags(edb::reg_t flags) override;
	void set_instruction_pointer(edb::address_t value) override;
	void set_register(const Register &reg) override;
	void set_register(const QString &name, edb::reg_t value) override;
	Register mmx_register(size_t n) const override;
	Register xmm_register(size_t n) const override;
	Register ymm_register(size_t n) const override;
	Register gp_register(size_t n) const override;

private:
	reg regs_;
	fpreg fpregs_;
	dbreg dbregs_;
};

}

#endif

```

`plugins/DebuggerCore/unix/freebsd/PlatformThread.cpp`:

```cpp
/*
Copyright (C) 2018 - 2018 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformThread.h"

namespace DebuggerCorePlugin {

void PlatformThread::get_state(State *state) {
	auto state_impl = static_cast<PlatformState *>(state->impl_);
	ptrace(PT_GETREGS, tid_, reinterpret_cast<char *>(&state_impl->regs_), 0);
}

void PlatformThread::set_state(const State &state) {
	auto state_impl = static_cast<PlatformState *>(state->impl_);
	ptrace(PT_SETREGS, tid_, reinterpret_cast<char *>(&state_impl->regs_), 0);
}

Status PlatformThread::step(edb::EVENT_STATUS status) {
	if (status != edb::DEBUG_STOP) {
		const int code = (status == edb::DEBUG_EXCEPTION_NOT_HANDLED) ? resume_code(status_) : 0;
		ptrace(PT_STEP, tid_, reinterpret_cast<caddr_t>(1), code);
	}

	return Status::Ok;
}

Status PlatformThread::resume(edb::EVENT_STATUS status) {
	if (status != edb::DEBUG_STOP) {
		const int code = (status == edb::DEBUG_EXCEPTION_NOT_HANDLED) ? resume_code(status_) : 0;
		ptrace(PT_CONTINUE, tid_, reinterpret_cast<caddr_t>(1), code);
	}

	return Status::Ok;
}

}

```

`plugins/DebuggerCore/unix/freebsd/PlatformThread.h`:

```h
/*
Copyright (C) 2018 - 2018 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_THREAD_H_20181225_
#define PLATFORM_THREAD_H_20181225_

#include "IBreakpoint.h"
#include "IThread.h"
#include <QCoreApplication>
#include <memory>

class IProcess;

namespace DebuggerCorePlugin {

class DebuggerCore;
class PlatformState;

class PlatformThread : public IThread {
	Q_DECLARE_TR_FUNCTIONS(PlatformThread)
	friend class DebuggerCore;
	friend class PlatformProcess;

public:
	edb::tid_t tid() const override;
	QString name() const override;
	int priority() const override;
	edb::address_t instruction_pointer() const override;
	QString runState() const override;

public:
	void get_state(State *state) override;
	void set_state(const State &state) override;

public:
	Status step() override;
	Status step(edb::EVENT_STATUS status) override;
	Status resume() override;
	Status resume(edb::EVENT_STATUS status) override;

public:
	bool isPaused() const override;

private:
	DebuggerCore *core_ = nullptr;
	std::shared_ptr<IProcess> process_;
	edb::tid_t tid_;
	int status_ = 0;
};

}

#endif

```

`plugins/DebuggerCore/unix/linux/DebuggerCore.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DebuggerCore.h"
#include "Configuration.h"
#include "DialogMemoryAccess.h"
#include "FeatureDetect.h"
#include "MemoryRegions.h"
#include "PlatformCommon.h"
#include "PlatformEvent.h"
#include "PlatformProcess.h"
#include "PlatformRegion.h"
#include "PlatformState.h"
#include "PlatformThread.h"
#include "Posix.h"
#include "State.h"
#include "Unix.h"
#include "edb.h"
#include "string_hash.h"
#include "util/Container.h"
#include "util/String.h"

#include <QDebug>
#include <QDir>
#include <QSettings>

#include <cerrno>
#include <cstring>

#ifndef _GNU_SOURCE
#define _GNU_SOURCE /* or _BSD_SOURCE or _SVID_SOURCE */
#endif

#if defined(EDB_X86) || defined(EDB_X86_64)
#include <cpuid.h>
#endif

#include <sys/mman.h>
#include <sys/personality.h>
#include <sys/ptrace.h>
#include <sys/syscall.h> /* For SYS_xxx definitions */
#include <sys/wait.h>

// doesn't always seem to be defined in the headers

#ifndef PTRACE_GETSIGINFO
#define PTRACE_GETSIGINFO static_cast<__ptrace_request>(0x4202)
#endif

#ifndef PTRACE_EVENT_CLONE
#define PTRACE_EVENT_CLONE 3
#endif

#ifndef PTRACE_O_TRACECLONE
#define PTRACE_O_TRACECLONE (1 << PTRACE_EVENT_CLONE)
#endif

#ifndef PTRACE_O_EXITKILL
#define PTRACE_O_EXITKILL (1 << 20)
#endif

#ifndef PTRACE_O_TRACEEXIT
#define PTRACE_O_TRACEEXIT (1 << PTRACE_EVENT_EXIT)
#endif

namespace DebuggerCorePlugin {

namespace {

constexpr size_t PageSize = 0x1000;

/**
 * @brief disable_aslr
 */
void disable_aslr() {
	const int current = ::personality(UINT32_MAX);
	// This shouldn't fail, but let's at least perror if it does anyway
	if (current == -1) {
		perror("Failed to get current personality");
	} else if (::personality(current | ADDR_NO_RANDOMIZE) == -1) {
		perror("Failed to disable ASLR");
	}
}

/**
 * @brief disable_lazy_binding
 */
void disable_lazy_binding() {
	if (setenv("LD_BIND_NOW", "1", true) == -1) {
		perror("Failed to disable lazy binding");
	}
}

/**
 * @brief is_clone_event
 * @param status
 * @return
 */
constexpr bool is_clone_event(int status) {
	return (status >> 8 == (SIGTRAP | (PTRACE_EVENT_CLONE << 8)));
}

/**
 * @brief is_exit_trace_event
 * @param status
 * @return
 */
constexpr bool is_exit_trace_event(int status) {
	return (status >> 8 == (SIGTRAP | (PTRACE_EVENT_EXIT << 8)));
}

#if defined(EDB_X86) || defined(EDB_X86_64)
/**
 * @brief in_64bit_segment
 * @return
 */
bool in_64bit_segment() {
	bool edbIsIn64BitSegment;
	// Check that we're running in 64 bit segment: this can be in cases
	// of LP64 and ILP32 programming models, so we can't rely on sizeof(void*)
	__asm__(R"(
		   .byte 0x33,0xc0 # XOR EAX,EAX
		   .byte 0x48      # DEC EAX for 32 bit, REX prefix for 64 bit
		   .byte 0xff,0xc0 # INC EAX for 32 bit, INC RAX due to REX.W in 64 bit
		 )"
			: "=a"(edbIsIn64BitSegment));
	return edbIsIn64BitSegment;
}

/**
 * @brief os_is_64_bit
 * @param edbIsIn64BitSegment
 * @return
 */
bool os_is_64_bit() {
	bool edbIsIn64BitSegment = in_64bit_segment();
	bool osIs64Bit;

	if (edbIsIn64BitSegment) {
		osIs64Bit = true;
	} else {
		// We want to be really sure the OS is 32 bit, so we can't rely on such easy
		// to (even unintentionally) fake mechanisms as uname(2) (e.g. see setarch(8))
		__asm__(R"(.intel_syntax noprefix
			   mov eax,cs
			   cmp ax,0x23 # this value is set for 32-bit processes on 64-bit kernel
			   mov ah,0    # not sure this is really needed: usually the compiler will do
						   # MOVZX EAX,AL, but we have to be certain the result is correct
			   sete al
			   .att_syntax # restore default syntax
			   )"
				: "=a"(osIs64Bit));
	}

	return osIs64Bit;
}
#endif

}

/**
 * @brief DebuggerCore::DebuggerCore
 */
DebuggerCore::DebuggerCore()
#if defined(EDB_X86) || defined(EDB_X86_64)
	: osIs64Bit_(os_is_64_bit()),
	  userCodeSegment32_(osIs64Bit_ ? 0x23 : 0x73),
	  userCodeSegment64_(osIs64Bit_ ? 0x33 : 0xfff8), // RPL 0 can't appear in user segment registers, so 0xfff8 is safe
	  userStackSegment_(osIs64Bit_ ? 0x2b : 0x7b)
#endif
{
	Posix::initialize();

	feature::detect_proc_access(&procMemReadBroken_, &procMemWriteBroken_);

	if (procMemReadBroken_ || procMemWriteBroken_) {

		qDebug() << "Detect that read /proc/<pid>/mem works  = " << !procMemReadBroken_;
		qDebug() << "Detect that write /proc/<pid>/mem works = " << !procMemWriteBroken_;

		QSettings settings;
		const bool warn = settings.value("DebuggerCore/warn_on_broken_proc_mem.enabled", true).toBool();
		if (warn) {
			auto dialog = std::make_unique<DialogMemoryAccess>(nullptr);
			dialog->exec();

			settings.setValue("DebuggerCore/warn_on_broken_proc_mem.enabled", dialog->warnNextTime());
		}
	}
}

/**
 * @brief DebuggerCore::hasExtension
 * @param ext
 * @return
 */
bool DebuggerCore::hasExtension(uint64_t ext) const {
#if defined(EDB_X86) || defined(EDB_X86_64)
	static constexpr auto mmxHash = edb::string_hash("MMX");
	static constexpr auto xmmHash = edb::string_hash("XMM");
	static constexpr auto ymmHash = edb::string_hash("YMM");

#if defined(EDB_X86_64)
	if (ext == xmmHash || ext == mmxHash) {
		return true;
	}
#endif

	uint32_t eax;
	uint32_t ebx;
	uint32_t ecx;
	uint32_t edx;
	__cpuid(1, eax, ebx, ecx, edx);

	switch (ext) {
	case mmxHash:
		return (edx & bit_MMX);
	case xmmHash:
		return (edx & bit_SSE);
	case ymmHash: {
		// Check OSXSAVE and AVX feature flags
		if ((ecx & 0x18000000) != 0x18000000) {
			return false;
		}

		// Get XCR0, must be exactly after OSXSAVE feature check, otherwise #UD
		__asm__ __volatile__("xgetbv"
							 : "=a"(eax), "=d"(edx)
							 : "c"(0));

		// Check that the OS has enabled XMM and YMM state support
		if ((eax & 0x6) != 0x6) {
			return false;
		}
		return true;
	}
	default:
		return false;
	}
#else
	Q_UNUSED(ext)
	return false;
#endif
}

/**
 * @brief DebuggerCore::pageSize
 * @return the size of a page on this system
 */
size_t DebuggerCore::pageSize() const {
	return PageSize;
}

/**
 * @brief DebuggerCore::pointerSize
 * @return
 */
std::size_t DebuggerCore::pointerSize() const {
	return pointerSize_;
}

/**
 * @brief DebuggerCore::~DebuggerCore
 */
DebuggerCore::~DebuggerCore() {
	endDebugSession();
}

/**
 * @brief DebuggerCore::ptraceGetSigInfo
 * @param tid
 * @param siginfo
 * @return
 */
Status DebuggerCore::ptraceGetSigInfo(edb::tid_t tid, siginfo_t *siginfo) {

	Q_ASSERT(siginfo);

	if (ptrace(PTRACE_GETSIGINFO, tid, 0, siginfo) == -1) {
		const char *const strError = strerror(errno);
		qWarning() << "Unable to get signal info for thread" << tid << ": PTRACE_GETSIGINFO failed:" << strError;
		return Status(strError);
	}
	return Status::Ok;
}

/**
 * @brief DebuggerCore::ptraceTraceme
 * @return
 */
long DebuggerCore::ptraceTraceme() {
	return ptrace(PTRACE_TRACEME, 0, 0, 0);
}

/**
 * @brief DebuggerCore::ptraceContinue
 * @param tid
 * @param status
 * @return
 */
Status DebuggerCore::ptraceContinue(edb::tid_t tid, long status) {
	// TODO(eteran): perhaps address this at a higher layer?
	//               I would like to not have these events show up
	//               in the first place if we aren't stopped on this TID :-(
	if (util::contains(waitedThreads_, tid)) {
		Q_ASSERT(tid != 0);
		if (ptrace(PTRACE_CONT, tid, 0, status) == -1) {
			const char *const strError = strerror(errno);
			qWarning() << "Unable to continue thread" << tid << ": PTRACE_CONT failed:" << strError;
			return Status(strError);
		}
		waitedThreads_.erase(tid);
		return Status::Ok;
	}
	return Status(tr("ptrace_continue(): waited_threads_ doesn't contain tid %1").arg(tid));
}

/**
 * @brief DebuggerCore::ptraceStep
 * @param tid
 * @param status
 * @return
 */
Status DebuggerCore::ptraceStep(edb::tid_t tid, long status) {
	// TODO(eteran): perhaps address this at a higher layer?
	//               I would like to not have these events show up
	//               in the first place if we aren't stopped on this TID :-(
	if (util::contains(waitedThreads_, tid)) {
		Q_ASSERT(tid != 0);
		if (ptrace(PTRACE_SINGLESTEP, tid, 0, status) == -1) {
			const char *const strError = strerror(errno);
			qWarning() << "Unable to step thread" << tid << ": PTRACE_SINGLESTEP failed:" << strError;
			return Status(strError);
		}
		waitedThreads_.erase(tid);
		return Status::Ok;
	}
	return Status(tr("ptrace_step(): waited_threads_ doesn't contain tid %1").arg(tid));
}

/**
 * @brief DebuggerCore::ptraceSetOptions
 * @param tid
 * @param options
 * @return
 */
Status DebuggerCore::ptraceSetOptions(edb::tid_t tid, long options) {
	Q_ASSERT(util::contains(waitedThreads_, tid));
	Q_ASSERT(tid != 0);
	if (ptrace(PTRACE_SETOPTIONS, tid, 0, options) == -1) {
		const char *const strError = strerror(errno);
		qWarning() << "Unable to set ptrace options for thread" << tid << ": PTRACE_SETOPTIONS failed:" << strError;
		return Status(strError);
	}
	return Status::Ok;
}

/**
 * @brief DebuggerCore::ptraceGetEventMessage
 * @param tid
 * @param message
 * @return
 */
Status DebuggerCore::ptraceGetEventMessage(edb::tid_t tid, unsigned long *message) {
	Q_ASSERT(util::contains(waitedThreads_, tid));
	Q_ASSERT(tid != 0);
	Q_ASSERT(message);

	if (ptrace(PTRACE_GETEVENTMSG, tid, 0, message) == -1) {
		const char *const strError = strerror(errno);
		qWarning() << "Unable to get event message for thread" << tid << ": PTRACE_GETEVENTMSG failed:" << strError;
		return Status(strError);
	}
	return Status::Ok;
}

/**
 * @brief DebuggerCore::ptraceOptions
 * @return
 */
long DebuggerCore::ptraceOptions() const {

	// we want to trace clone (thread) creation events
	long options = PTRACE_O_TRACECLONE;

	// if applicable, we want an auto SIGKILL sent to the child
	// process and its threads
	switch (edb::v1::config().close_behavior) {
	case Configuration::Kill:
		options |= PTRACE_O_EXITKILL;
		break;
	case Configuration::KillIfLaunchedDetachIfAttached:
		if (lastMeansOfCapture() == MeansOfCapture::Launch) {
			options |= PTRACE_O_EXITKILL;
		}
		break;
	default:
		break;
	}

#if 0
	// TODO(eteran): research this option for issue #46
	options |= PTRACE_O_TRACEEXIT;
#endif

	return options;
}

/**
 * @brief DebuggerCore::handleThreadExit
 * @param tid
 * @param status
 */
void DebuggerCore::handleThreadExit(edb::tid_t tid, int status) {
	Q_UNUSED(status)

	threads_.remove(tid);
	waitedThreads_.erase(tid);
}

/**
 * @brief DebuggerCore::handleThreadCreate
 * @param tid
 * @param status
 * @return
 */
std::shared_ptr<IDebugEvent> DebuggerCore::handleThreadCreate(edb::tid_t tid, int status) {

	Q_UNUSED(status)

	unsigned long message;
	if (ptraceGetEventMessage(tid, &message)) {

		auto new_tid = static_cast<edb::tid_t>(message);

		auto new_thread = std::make_shared<PlatformThread>(this, process_, new_tid);

		threads_.insert(new_tid, new_thread);

		int thread_status = 0;
		if (!util::contains(waitedThreads_, new_tid)) {
			if (Posix::waitpid(new_tid, &thread_status, __WALL) > 0) {
				waitedThreads_.insert(new_tid);
			}
		}

		// A new thread could exit before we have fully created it, no event then since it can't be the last thread
		if (WIFEXITED(thread_status)) {
			handleThreadExit(tid, thread_status);
			return nullptr;
		}

		if (!WIFSTOPPED(thread_status) || WSTOPSIG(thread_status) != SIGSTOP) {
			qWarning("handle_event(): new thread [%d] received an event besides SIGSTOP: status=0x%x", static_cast<int>(new_tid), thread_status);
		}

		new_thread->status_ = thread_status;

		// copy the hardware debug registers from the current thread to the new thread
		if (process_) {
			if (auto cur_thread = process_->currentThread()) {
				auto old_thread = std::static_pointer_cast<PlatformThread>(cur_thread);
				for (size_t i = 0; i < 8; ++i) {
					new_thread->setDebugRegister(i, old_thread->getDebugRegister(i));
				}
			}
		}

		new_thread->resume();
	}

	ptraceContinue(tid, 0);
	return nullptr;
}

/**
 * @brief DebuggerCore::handleEvent
 * @param tid
 * @param status
 * @return
 */
std::shared_ptr<IDebugEvent> DebuggerCore::handleEvent(edb::tid_t tid, int status) {

	// note that we have waited on this thread
	waitedThreads_.insert(tid);

	// was it a thread exit event?
	if (WIFEXITED(status)) {

		handleThreadExit(tid, status);
		// if this was the last thread, return nullptr
		// so we report it to the user.
		// if this wasn't, then we should silently
		// procceed.
		if (!threads_.empty()) {
			return nullptr;
		}
	}

	if (is_exit_trace_event(status)) {
	}

	// was it a thread create event?
	if (is_clone_event(status)) {
		return handleThreadCreate(tid, status);
	}

	// normal event
	auto e = std::make_shared<PlatformEvent>();

	e->pid_    = process_->pid();
	e->tid_    = tid;
	e->status_ = status;
	if (!ptraceGetSigInfo(tid, &e->siginfo_)) {
		// TODO: handle no info?
	}

	// if necessary, just ignore this event
	if (util::contains(ignoredExceptions_, e->code())) {
		ptraceContinue(tid, resume_code(status));
		return nullptr;
	}

	/* NOTE(eteran): OK, so when we get an event, we generally want to stop
	 * any other threads as well. So we will call stopThreads() below
	 * which sends a SIGSTOP.
	 *
	 * We need to be very careful to avoid those future events causing the
	 * active thread to be set, because we want it to remain set to the thread
	 * which recieved the initial signal. This is all so that later when the
	 * user clicks resume, that the correct active thread gets (or doesn't)
	 * get signaled, and the rest get resumed properly.
	 *
	 * To do this, we simply only alter the activeThread_ variable if this
	 * event was the first we saw after a resume/run (phew!).*/
	if (waitedThreads_.size() == 1) {
		activeThread_ = tid;
	}

	auto it = threads_.find(tid);
	if (it != threads_.end()) {
		it.value()->status_ = status;
	}

	stopThreads();

	// Some breakpoint types result in SIGILL or SIGSEGV. We'll transform the
	// event into breakpoint event if such a breakpoint has triggered.
	if (it != threads_.end() && WIFSTOPPED(status)) {
		const auto signo = WSTOPSIG(status);
		if (signo == SIGILL || signo == SIGSEGV) {
			// no need to peekuser for SIGILL, but have to for SIGSEGV
			const auto address = signo == SIGILL ? edb::address_t::fromZeroExtended(e->siginfo_.si_addr)
												 : (*it)->instructionPointer();

			if (edb::v1::find_triggered_breakpoint(address)) {
				e->status_           = SIGTRAP << 8 | 0x7f;
				e->siginfo_.si_signo = SIGTRAP;
				e->siginfo_.si_code  = TRAP_BRKPT;
			}
		}
	}

#if defined(EDB_ARM32)
	if (it != threads_.end()) {
		const auto &thread = *it;
		if (thread->singleStepBreakpoint) {

			removeBreakpoint(thread->singleStepBreakpoint->address());
			thread->singleStepBreakpoint = nullptr;

			assert(e->siginfo_.si_signo == SIGTRAP); // signo must have already be converted to SIGTRAP if needed
			e->siginfo_.si_code = TRAP_TRACE;
		}
	}
#endif
	return e;
}

/**
 * @brief DebuggerCore::stopThreads
 * @return
 */
Status DebuggerCore::stopThreads() {

	QString errorMessage;

	if (process_) {
		for (auto &thread : process_->threads()) {
			const edb::tid_t tid = thread->tid();

			if (!util::contains(waitedThreads_, tid)) {

				if (auto thread_ptr = std::static_pointer_cast<PlatformThread>(thread)) {

					if (syscall(SYS_tgkill, process_->pid(), thread->tid(), SIGSTOP) == -1) {
						const char *const error = strerror(errno);
						errorMessage += tr("Failed to stop thread %1: %2\n").arg(tid).arg(error);
					}

					int thread_status;
					if (Posix::waitpid(thread->tid(), &thread_status, __WALL /* | WNOHANG*/) > 0) {
						waitedThreads_.insert(tid);
						thread_ptr->status_ = thread_status;

						// A thread could have exited between previous waitpid and the latest one...
						if (WIFEXITED(thread_status)) {
							handleThreadExit(tid, thread_status);
						}

						// ..., otherwise it must have stopped.
						else if (!WIFSTOPPED(thread_status) || WSTOPSIG(thread_status) != SIGSTOP) {
							qWarning("stop_threads(): paused thread [%d] received an event besides SIGSTOP: status=0x%x", tid, thread_status);
						}
					}
				}
			}
		}
	}

	if (errorMessage.isEmpty()) {
		return Status::Ok;
	}

	qWarning() << qPrintable(errorMessage);
	return Status("\n" + errorMessage);
}

/**
 * waits for a debug event, witha timeout specified in milliseconds
 *
 * @brief DebuggerCore::waitDebugEvent
 * @param msecs
 * @return nullptr if an error or timeout occurs
 */
std::shared_ptr<IDebugEvent> DebuggerCore::waitDebugEvent(std::chrono::milliseconds msecs) {

	if (process_) {
		if (!Posix::wait_for_sigchld(msecs)) {
			for (auto &thread : process_->threads()) {
				int status;
				const edb::tid_t tid = Posix::waitpid(thread->tid(), &status, __WALL | WNOHANG);
				if (tid > 0) {
					return handleEvent(tid, status);
				}
			}
		}
	}
	return nullptr;
}

/**
 * @brief DebuggerCore::attachThread
 * @param tid
 * @return 0 if successful, errno if failed
 */
int DebuggerCore::attachThread(edb::tid_t tid) {

	if (ptrace(PTRACE_ATTACH, tid, 0, 0) == 0) {

		int status;
		const int ret = Posix::waitpid(tid, &status, __WALL);
		if (ret > 0) {

			auto newThread     = std::make_shared<PlatformThread>(this, process_, tid);
			newThread->status_ = status;

			threads_.insert(tid, newThread);
			waitedThreads_.insert(tid);

			const long options = ptraceOptions();

			const auto setoptStatus = ptraceSetOptions(tid, options);
			if (!setoptStatus) {
				qDebug() << "[DebuggerCore] failed to set ptrace options: [" << tid << "]" << setoptStatus.error();
			}

			return 0;
		} else if (ret == -1) {
			return errno;
		} else {
			return -1; // unknown error
		}
	} else {
		return errno;
	}
}

/**
 * @brief DebuggerCore::attach
 * @param pid
 * @return
 */
Status DebuggerCore::attach(edb::pid_t pid) {

	endDebugSession();

	lastMeansOfCapture_ = MeansOfCapture::Attach;

	// create this, so the threads created can refer to it
	process_ = std::make_shared<PlatformProcess>(this, pid);

	int lastErr = attachThread(pid); // Fail early if we are going to
	if (lastErr) {
		process_ = nullptr;
		return Status(std::strerror(lastErr));
	}

	lastErr = -2;
	bool attached;
	do {
		attached = false;
		QDir proc_directory(QString("/proc/%1/task/").arg(pid));
		for (const QString &s : proc_directory.entryList(QDir::NoDotAndDotDot | QDir::Dirs)) {
			// this can get tricky if the threads decide to spawn new threads
			// when we are attaching. I wish that linux had an atomic way to do this
			// all in one shot
			const edb::tid_t tid = s.toInt();
			if (!threads_.contains(tid)) {
				const auto errnum = attachThread(tid);
				if (errnum == 0) {
					attached = true;
				} else {
					lastErr = errnum;
				}
			}
		}
	} while (attached);

	if (!threads_.empty()) {
		activeThread_ = pid;
		detectCpuMode();
		return Status::Ok;
	}

	process_ = nullptr;
	return Status(std::strerror(lastErr));
}

/**
 * @brief DebuggerCore::detach
 * @return
 */
Status DebuggerCore::detach() {

	QString errorMessage;

	if (process_) {
		stopThreads();
		clearBreakpoints();

		for (auto &thread : process_->threads()) {
			if (ptrace(PTRACE_DETACH, thread->tid(), 0, 0) == -1) {
				const char *const error = strerror(errno);
				errorMessage += tr("Unable to detach from thread %1: PTRACE_DETACH failed: %2\n").arg(thread->tid()).arg(error);
			}
		}

		process_ = nullptr;
		reset();
	}

	if (errorMessage.isEmpty()) {
		return Status::Ok;
	}

	qWarning() << errorMessage.toStdString().c_str();
	return Status(errorMessage);
}

/**
 * @brief DebuggerCore::kill
 */
void DebuggerCore::kill() {
	if (attached()) {
		clearBreakpoints();

		::kill(process_->pid(), SIGKILL);

		pid_t ret;
		while ((ret = Posix::waitpid(-1, nullptr, __WALL)) != process_->pid() && ret != -1)
			;

		process_ = nullptr;
		reset();
	}
}

/**
 * @brief DebuggerCore::detectCpuMode
 */
void DebuggerCore::detectCpuMode() {

#if defined(EDB_X86) || defined(EDB_X86_64)

#if defined(EDB_X86)
	constexpr size_t Offset = offsetof(UserRegsStructX86, xcs);
#elif defined(EDB_X86_64)
	constexpr size_t Offset = offsetof(UserRegsStructX86_64, cs);
#endif

	errno                   = 0;
	const edb::seg_reg_t cs = ptrace(PTRACE_PEEKUSER, activeThread_, Offset, 0);

	if (!errno) {
		if (cs == userCodeSegment32_) {
			if (pointerSize_ == sizeof(uint64_t)) {
				qDebug() << "Debuggee is now 32 bit";
				cpuMode_ = CpuMode::x86_32;
				CapstoneEDB::init(CapstoneEDB::Architecture::ARCH_X86);
			}
			pointerSize_ = sizeof(uint32_t);
			return;
		} else if (cs == userCodeSegment64_) {
			if (pointerSize_ == sizeof(uint32_t)) {
				qDebug() << "Debuggee is now 64 bit";
				cpuMode_ = CpuMode::x86_64;
				CapstoneEDB::init(CapstoneEDB::Architecture::ARCH_AMD64);
			}
			pointerSize_ = sizeof(uint64_t);
			return;
		}
	}
#elif defined(EDB_ARM32)
	errno           = 0;
	const auto cpsr = ptrace(PTRACE_PEEKUSER, activeThread_, sizeof(long) * 16, 0L);
	if (!errno) {
		const bool thumb = cpsr & 0x20;
		if (thumb) {
			cpuMode_ = CpuMode::Thumb;
			CapstoneEDB::init(CapstoneEDB::Architecture::ARCH_ARM32_THUMB);
		} else {
			cpuMode_ = CpuMode::ARM32;
			CapstoneEDB::init(CapstoneEDB::Architecture::ARCH_ARM32_ARM);
		}
	}
	pointerSize_ = sizeof(uint32_t);
#elif defined(EDB_ARM64)
	cpuMode_ = CpuMode::ARM64;
	CapstoneEDB::init(CapstoneEDB::Architecture::ARCH_ARM64);
	pointerSize_ = sizeof(uint64_t);
#else
#error "Unsupported Architecture"
#endif
}

/**
 * @brief DebuggerCore::open
 * @param path
 * @param cwd
 * @param args
 * @param tty
 * @return
 */
Status DebuggerCore::open(const QString &path, const QString &cwd, const QList<QByteArray> &args, const QString &input, const QString &output) {

	endDebugSession();

	lastMeansOfCapture_ = MeansOfCapture::Launch;

	constexpr std::size_t SharedMemSize = 4096;

	void *const ptr      = ::mmap(nullptr, SharedMemSize, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	const auto sharedMem = static_cast<QChar *>(ptr);

	std::memset(ptr, 0, SharedMemSize);

	switch (pid_t pid = fork()) {
	case 0: {
		// we are in the child now...

		// set ourselves (the child proc) up to be traced
		ptraceTraceme();

		// redirect it's I/O
		FILE *std_in  = nullptr;
		FILE *std_out = nullptr;
		FILE *std_err = nullptr;

		if (!input.isEmpty()) {
			std_in = freopen(qPrintable(input), "rb", stdin);
		}

		if (!output.isEmpty()) {
			std_out = freopen(qPrintable(output), "wb", stdout);
			std_err = freopen(qPrintable(output), "wb", stderr);
		}

		Q_UNUSED(std_in)
		Q_UNUSED(std_out)
		Q_UNUSED(std_err)

		if (edb::v1::config().disableASLR) {
			disable_aslr();
		}

		if (edb::v1::config().disableLazyBinding) {
			disable_lazy_binding();
		}

		// do the actual exec
		const Status status = Unix::execute_process(path, cwd, args);

#if defined __GNUG__ && __GNUC__ >= 5 || !defined __GNUG__ || defined __clang__ && __clang_major__ * 100 + __clang_minor__ >= 306
		static_assert(std::is_trivially_copyable<QChar>::value, "Can't copy string of QChar to shared memory");
#endif
		QString error = status.error();
		std::memcpy(sharedMem, error.constData(), std::min(sizeof(QChar) * error.size(), SharedMemSize - sizeof(QChar) /*prevent overwriting of last null*/));

		// we should never get here!
		abort();
	}
	case -1:
		// error! for some reason we couldn't fork
		reset();
		return Status(tr("Failed to fork"));
	default:
		// parent
		{
			reset();

			int status;
			const auto wpidRet = Posix::waitpid(pid, &status, __WALL);
			const QString childError(sharedMem);
			::munmap(sharedMem, SharedMemSize);

			if (wpidRet == -1) {
				return Status(tr("waitpid() failed: %1").arg(std::strerror(errno)) + (childError.isEmpty() ? "" : tr(".\nError returned by child:\n%1.").arg(childError)));
			}

			if (WIFEXITED(status)) {
				return Status(tr("The child unexpectedly exited with code %1. Error returned by child:\n%2").arg(WEXITSTATUS(status)).arg(childError));
			}

			if (WIFSIGNALED(status)) {
				return Status(tr("The child was unexpectedly killed by signal %1. Error returned by child:\n%2").arg(WTERMSIG(status)).arg(childError));
			}

			// This happens when exec failed, but just in case it's something another return some description.
			if (WIFSTOPPED(status) && WSTOPSIG(status) == SIGABRT) {
				return Status(childError.isEmpty() ? tr("The child unexpectedly aborted") : childError);
			}

			// the very first event should be a STOP of type SIGTRAP
			if (!WIFSTOPPED(status) || WSTOPSIG(status) != SIGTRAP) {
				endDebugSession();
				return Status(tr("First event after waitpid() should be a STOP of type SIGTRAP, but wasn't, instead status=0x%1")
								  .arg(status, 0, 16) +
							  (childError.isEmpty() ? "" : tr(".\nError returned by child:\n%1.").arg(childError)));
			}

			waitedThreads_.insert(pid);

			const long options = ptraceOptions();

			// enable following clones (threads) and other options we are concerned with
			const auto setoptStatus = ptraceSetOptions(pid, options);
			if (!setoptStatus) {
				endDebugSession();
				return Status(tr("[DebuggerCore] failed to set ptrace options: %1").arg(setoptStatus.error()));
			}

			// create the process
			process_ = std::make_shared<PlatformProcess>(this, pid);

			// the PID == primary TID
			auto newThread     = std::make_shared<PlatformThread>(this, process_, pid);
			newThread->status_ = status;

			threads_.insert(pid, newThread);

			activeThread_ = pid;
			detectCpuMode();

			return Status::Ok;
		}
	}
}

/**
 * @brief DebuggerCore::lastMeansOfCapture
 * @return how the last process was captured to debug
 */
DebuggerCore::MeansOfCapture DebuggerCore::lastMeansOfCapture() const {
	return lastMeansOfCapture_;
}

/**
 * @brief DebuggerCore::reset
 */
void DebuggerCore::reset() {
	threads_.clear();
	waitedThreads_.clear();
	activeThread_ = 0;
}

/**
 * @brief DebuggerCore::createState
 * @return
 */
std::unique_ptr<IState> DebuggerCore::createState() const {
	return std::make_unique<PlatformState>();
}

/**
 * @brief DebuggerCore::enumerateProcesses
 * @return
 */
QMap<edb::pid_t, std::shared_ptr<IProcess>> DebuggerCore::enumerateProcesses() const {
	QMap<edb::pid_t, std::shared_ptr<IProcess>> ret;

	QDir proc_directory("/proc/");
	QFileInfoList entries = proc_directory.entryInfoList(QDir::Dirs | QDir::NoDotAndDotDot);

	for (const QFileInfo &info : entries) {
		const QString filename = info.fileName();
		if (util::is_numeric(filename)) {
			const edb::pid_t pid = filename.toInt();

			// NOTE(eteran): the const_cast is reasonable here.
			// While we don't want THIS function to mutate the DebuggerCore object
			// we do want the associated PlatformProcess to be able to trigger
			// non-const operations in the future, at least hypothetically.
			ret.insert(pid, std::make_shared<PlatformProcess>(const_cast<DebuggerCore *>(this), pid));
		}
	}

	return ret;
}

/**
 * @brief DebuggerCore::parentPid
 * @param pid
 * @return
 */
edb::pid_t DebuggerCore::parentPid(edb::pid_t pid) const {

	struct user_stat user_stat;
	int n = get_user_stat(pid, &user_stat);
	if (n >= 4) {
		return user_stat.ppid;
	}

	return 0;
}

/**
 * @brief DebuggerCore::cpuType
 * @return edb's native CPU type
 */
uint64_t DebuggerCore::cpuType() const {
#if defined(EDB_X86_64)
	return edb::string_hash("x86-64");
#elif defined(EDB_X86)
	return edb::string_hash("x86");
#elif defined(EDB_ARM32)
	return edb::string_hash("arm");
#elif defined(EDB_ARM64)
	return edb::string_hash("AArch64");
#else
#error "Unsupported Architecture"
#endif
}

/**
 * @brief DebuggerCore::stackPointer
 * @return
 */
QString DebuggerCore::stackPointer() const {
#if defined(EDB_X86) || defined(EDB_X86_64)
	if (edb::v1::debuggeeIs32Bit()) {
		return "esp";
	} else {
		return "rsp";
	}
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	return "sp";
#else
#error "Unsupported Architecture"
#endif
}

/**
 * @brief DebuggerCore::framePointer
 * @return
 */
QString DebuggerCore::framePointer() const {
#if defined(EDB_X86) || defined(EDB_X86_64)
	if (edb::v1::debuggeeIs32Bit()) {
		return "ebp";
	} else {
		return "rbp";
	}
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	return "fp";
#else
#error "Unsupported Architecture"
#endif
}

/**
 * @brief DebuggerCore::instructionPointer
 * @return
 */
QString DebuggerCore::instructionPointer() const {
#if defined(EDB_X86) || defined(EDB_X86_64)
	if (edb::v1::debuggeeIs32Bit()) {
		return "eip";
	} else {
		return "rip";
	}
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	return "pc";
#else
#error "Unsupported Architecture"
#endif
}

/**
 * @brief DebuggerCore::flagRegister
 * @return the name of the flag register
 */
QString DebuggerCore::flagRegister() const {
#if defined(EDB_X86) || defined(EDB_X86_64)
	if (edb::v1::debuggeeIs32Bit()) {
		return "eflags";
	} else {
		return "rflags";
	}
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	return "cpsr";
#else
#error "Unsupported Architecture"
#endif
}

/**
 * @brief DebuggerCore::process
 * @return
 */
IProcess *DebuggerCore::process() const {
	return process_.get();
}

/**
 * @brief DebuggerCore::setIgnoredExceptions
 * @param exceptions
 */
void DebuggerCore::setIgnoredExceptions(const QList<qlonglong> &exceptions) {
	ignoredExceptions_ = exceptions;
}

/**
 * @brief DebuggerCore::exceptions
 * @return
 */
QMap<qlonglong, QString> DebuggerCore::exceptions() const {
	return Unix::exceptions();
}

/**
 * @brief DebuggerCore::exceptionName
 * @param value
 * @return
 */
QString DebuggerCore::exceptionName(qlonglong value) {
	return Unix::exception_name(value);
}

/**
 * @brief DebuggerCore::exceptionValue
 * @param name
 * @return
 */
qlonglong DebuggerCore::exceptionValue(const QString &name) {
	return Unix::exception_value(name);
}

/**
 * @brief DebuggerCore::nopFillByte
 * @return
 */
uint8_t DebuggerCore::nopFillByte() const {
#if defined(EDB_X86) || defined(EDB_X86_64)
	return 0x90;
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	// TODO(eteran): does this concept even make sense for a multi-byte instruction encoding?
	return 0x00;
#else
#error "Unsupported Architecture"
#endif
}

}

```

`plugins/DebuggerCore/unix/linux/DebuggerCore.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DEBUGGER_CORE_H_20090529_
#define DEBUGGER_CORE_H_20090529_

#include "DebuggerCoreBase.h"
#include <QHash>
#include <QObject>
#include <csignal>
#include <set>
#include <unistd.h>

class IBinary;
class Status;

namespace DebuggerCorePlugin {

class PlatformThread;

class DebuggerCore final : public DebuggerCoreBase {
	Q_OBJECT
	Q_PLUGIN_METADATA(IID "edb.IDebugger/1.0")
	Q_INTERFACES(IDebugger)
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")
	friend class PlatformProcess;
	friend class PlatformThread;

	CpuMode cpuMode() const override { return cpuMode_; }

public:
	DebuggerCore();
	~DebuggerCore() override;

public:
	MeansOfCapture lastMeansOfCapture() const override;
	Status attach(edb::pid_t pid) override;
	Status detach() override;
	Status open(const QString &path, const QString &cwd, const QList<QByteArray> &args, const QString &input, const QString &output) override;
	bool hasExtension(uint64_t ext) const override;
	size_t pageSize() const override;
	std::shared_ptr<IDebugEvent> waitDebugEvent(std::chrono::milliseconds msecs) override;
	std::size_t pointerSize() const override;
	uint8_t nopFillByte() const override;
	void kill() override;
	void setIgnoredExceptions(const QList<qlonglong> &exceptions) override;

public:
	QMap<qlonglong, QString> exceptions() const override;
	QString exceptionName(qlonglong value) override;
	qlonglong exceptionValue(const QString &name) override;

public:
	edb::pid_t parentPid(edb::pid_t pid) const override;

public:
	std::unique_ptr<IState> createState() const override;

public:
	uint64_t cpuType() const override;

private:
	QMap<edb::pid_t, std::shared_ptr<IProcess>> enumerateProcesses() const override;

public:
	QString flagRegister() const override;
	QString framePointer() const override;
	QString instructionPointer() const override;
	QString stackPointer() const override;

public:
	IProcess *process() const override;

private:
	Status ptraceContinue(edb::tid_t tid, long status);
	Status ptraceGetEventMessage(edb::tid_t tid, unsigned long *message);
	Status ptraceGetSigInfo(edb::tid_t tid, siginfo_t *siginfo);
	Status ptraceSetOptions(edb::tid_t tid, long options);
	Status ptraceStep(edb::tid_t tid, long status);
	long ptraceTraceme();

private:
	Status stopThreads();
	int attachThread(edb::tid_t tid);
	long ptraceOptions() const;
	std::shared_ptr<IDebugEvent> handleEvent(edb::tid_t tid, int status);
	std::shared_ptr<IDebugEvent> handleThreadCreate(edb::tid_t tid, int status);
	void detectCpuMode();
	void handleThreadExit(edb::tid_t tid, int status);
	void reset();

private:
	using threads_type = QHash<edb::tid_t, std::shared_ptr<PlatformThread>>;

private:
	// TODO(eteran): a few of these logically belong in PlatformProcess...
	CpuMode cpuMode_                   = CpuMode::Unknown;
	MeansOfCapture lastMeansOfCapture_ = MeansOfCapture::NeverCaptured;
	QList<qlonglong> ignoredExceptions_;
	std::set<edb::tid_t> waitedThreads_;
	edb::tid_t activeThread_;
	std::shared_ptr<IProcess> process_;
	threads_type threads_;
	bool procMemReadBroken_  = true;
	bool procMemWriteBroken_ = true;
	std::size_t pointerSize_ = sizeof(void *);
#if defined(EDB_X86) || defined(EDB_X86_64)
	const bool osIs64Bit_;
	const edb::seg_reg_t userCodeSegment32_;
	const edb::seg_reg_t userCodeSegment64_;
	const edb::seg_reg_t userStackSegment_;
#endif
};

}

#endif

```

`plugins/DebuggerCore/unix/linux/DialogMemoryAccess.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogMemoryAccess.h"

namespace DebuggerCorePlugin {

/**
 * @brief DialogMemoryAccess::DialogMemoryAccess
 * @param parent
 * @param f
 */
DialogMemoryAccess::DialogMemoryAccess(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
	adjustSize();
	setFixedSize(width(), height());
}

/**
 * @brief DialogMemoryAccess::warnNextTime
 * @return
 */
bool DialogMemoryAccess::warnNextTime() const {
	return !ui.checkNeverShowAgain->isChecked();
}

}

```

`plugins/DebuggerCore/unix/linux/DialogMemoryAccess.h`:

```h
/*
Copyright (C) 2016 - 2016 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_MEMORY_ACCESS_H_20160930_
#define DIALOG_MEMORY_ACCESS_H_20160930_

#include "ui_DialogMemoryAccess.h"
#include <QDialog>

namespace DebuggerCorePlugin {

class DialogMemoryAccess final : public QDialog {
	Q_OBJECT

public:
	explicit DialogMemoryAccess(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogMemoryAccess() override = default;

public:
	bool warnNextTime() const;

private:
	Ui::DialogMemoryAccess ui;
};

}

#endif

```

`plugins/DebuggerCore/unix/linux/DialogMemoryAccess.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DebuggerCorePlugin::DialogMemoryAccess</class>
 <widget class="QDialog" name="DebuggerCorePlugin::DialogMemoryAccess">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>360</width>
    <height>276</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Memory Access Error</string>
  </property>
  <property name="modal">
   <bool>true</bool>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="label">
     <property name="text">
      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;EDB has detected that on this kernel, access to debugee memory &lt;br/&gt;does not work through &lt;span style=&quot; font-family:'Courier New,courier';&quot;&gt;/proc/&amp;lt;pid&amp;gt;/mem&lt;/span&gt;. &lt;/p&gt;&lt;p&gt;Possible causes include: &lt;/p&gt;&lt;ul style=&quot;margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;&quot;&gt;&lt;li style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EDB's feature detection has a bug&lt;/li&gt;&lt;/ul&gt;&lt;ul style=&quot;margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;&quot;&gt;&lt;li style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;The kernel is older and restricts writes to &lt;span style=&quot; font-family:'Courier New,courier';&quot;&gt;/proc/&amp;lt;pid&amp;gt;/mem&lt;/span&gt;&lt;/li&gt;&lt;li style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;The kernel has &lt;span style=&quot; font-weight:600;&quot;&gt;grsecurity&lt;/span&gt; enabled&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;EDB has a fallback method of accessing debugee memory, &lt;br/&gt;but it may have a negative impact on performance. &lt;br/&gt;If you experience poor performance, please file a bug report at:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://github.com/eteran/edb-debugger/issues&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#2980b9;&quot;&gt;http://github.com/eteran/edb-debugger/issues&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
     </property>
     <property name="textFormat">
      <enum>Qt::RichText</enum>
     </property>
     <property name="openExternalLinks">
      <bool>false</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QCheckBox" name="checkNeverShowAgain">
     <property name="text">
      <string>Never show this message again</string>
     </property>
     <property name="checked">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>DebuggerCorePlugin::DialogMemoryAccess</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>DebuggerCorePlugin::DialogMemoryAccess</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/DebuggerCore/unix/linux/FeatureDetect.cpp`:

```cpp
/*
Copyright (C) 2016 - 2016 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "FeatureDetect.h"
#include "edb.h"

#include <fcntl.h>
#include <iomanip>
#include <iostream>
#include <string>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

namespace DebuggerCorePlugin {
namespace feature {
namespace {

// Custom class to work with files, since various wrappers
// appear to be unreliable to check whether writes succeeded
class File {
public:
	explicit File(const std::string &filename) {
		fd_      = ::open(filename.c_str(), O_RDWR);
		success_ = fd_ != -1;
	}

	ssize_t write(const void *buf, size_t count) {
		const ssize_t result = ::write(fd_, buf, count);
		success_             = result != -1;
		return result;
	}

	ssize_t read(void *buf, size_t count) {
		const ssize_t result = ::read(fd_, buf, count);
		success_             = result != -1;
		return result;
	}

	off_t seekp(size_t offset) {
		const off_t result = ::lseek(fd_, offset, SEEK_SET);
		success_           = result != -1;
		return result;
	}

	~File() {
		close(fd_);
	}

	explicit operator bool() {
		return success_;
	}

private:
	int fd_       = -1;
	bool success_ = false;
};

/**
 * @brief kill_child
 * @param pid
 */
void kill_child(int pid) {
	if (kill(pid, SIGKILL) == -1) {
		perror("failed to kill child");
	}
}

}

/**
 * detects whether or not reads/writes through /proc/<pid>/mem work correctly
 *
 * @brief detect_proc_access
 * @param read_broken
 * @param write_broken
 * @return
 */
bool detect_proc_access(bool *read_broken, bool *write_broken) {

	switch (pid_t pid = fork()) {
	case 0:
		if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
			perror("child: PTRACE_TRACEME failed");
			abort();
		}

		// force a signal
		raise(SIGCONT);

		for (;;) {
			sleep(10);
		}
		abort();

	case -1:
		perror("fork");
		return false;

	default: {
		int status;
		if (waitpid(pid, &status, __WALL) == -1) {
			perror("parent: waitpid failed");
			kill_child(pid);
			return false;
		}

		if (!WIFSTOPPED(status) || WSTOPSIG(status) != SIGCONT) {
			std::cerr << "unexpected status returned by waitpid: 0x" << std::hex << status << "\n";
			kill_child(pid);
			return false;
		}

		File file("/proc/" + std::to_string(pid) + "/mem");
		if (!file) {
			perror("failed to open memory file");
			kill_child(pid);
			return false;
		}

		const auto pageAlignMask = ~(sysconf(_SC_PAGESIZE) - 1);
		const auto addr          = reinterpret_cast<uintptr_t>(&edb::v1::debugger_ui) & pageAlignMask;
		file.seekp(addr);
		if (!file) {
			perror("failed to seek to address to read");
			kill_child(pid);
			return false;
		}

		int buf = 0x12345678;
		{
			file.read(&buf, sizeof(buf));
			if (!file) {
				*read_broken  = true;
				*write_broken = true;
				kill_child(pid);
				return false;
			}
		}

		file.seekp(addr);
		if (!file) {
			perror("failed to seek to address to write");
			kill_child(pid);
			return false;
		}

		{
			file.write(&buf, sizeof(buf));
			if (!file) {
				*read_broken  = false;
				*write_broken = true;
			} else {
				*read_broken  = false;
				*write_broken = false;
			}
		}
		kill_child(pid);
		return true;
	}
	}
}

}
}

```

`plugins/DebuggerCore/unix/linux/FeatureDetect.h`:

```h
/*
Copyright (C) 2016 - 2016 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef FEATURE_DETECT_H_20191119_
#define FEATURE_DETECT_H_20191119_

namespace DebuggerCorePlugin {
namespace feature {

bool detect_proc_access(bool *read_broken, bool *write_broken);

}
}

#endif

```

`plugins/DebuggerCore/unix/linux/PlatformCommon.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformCommon.h"
#include <fstream>
#include <iostream>
#include <linux/limits.h>
#include <sys/wait.h>

namespace DebuggerCorePlugin {

/**
 * @brief resume_code
 * @param status
 * @return
 */
int resume_code(int status) {

	if (WIFSTOPPED(status) && WSTOPSIG(status) == SIGSTOP) {
		return 0;
	}

	if (WIFSIGNALED(status)) {
		return WTERMSIG(status);
	}

	if (WIFSTOPPED(status)) {
		return WSTOPSIG(status);
	}

	return 0;
}

/**
 * gets the contents of /proc/<pid>/stat
 *
 * @brief get_user_stat
 * @param path
 * @param user_stat
 * @return the number of elements successfully parsed
 */
int get_user_stat(const char *path, struct user_stat *user_stat) {
	Q_ASSERT(user_stat);

	std::ifstream stream(path);
	std::string line;
	if (std::getline(stream, line)) {
		// the comm field is wrapped with "(" and ")", so we look for the closing one
		size_t left  = line.find_first_of('(');
		size_t right = line.find_last_of(')');

		if (right == std::string::npos || left == std::string::npos) {
			return -1;
		}

		int r = sscanf(&line[right + 2], "%c %d %d %d %d %d %u %llu %llu %llu %llu %llu %llu %lld %lld %lld %lld %lld %lld %llu %llu %lld %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %d %d %u %u %llu %llu %lld %llu %llu %llu %llu %llu %llu %llu %d",
					   &user_stat->state,
					   &user_stat->ppid,
					   &user_stat->pgrp,
					   &user_stat->session,
					   &user_stat->tty_nr,
					   &user_stat->tpgid,
					   &user_stat->flags,
					   &user_stat->minflt,
					   &user_stat->cminflt,
					   &user_stat->majflt,
					   &user_stat->cmajflt,
					   &user_stat->utime,
					   &user_stat->stime,
					   &user_stat->cutime,
					   &user_stat->cstime,
					   &user_stat->priority,
					   &user_stat->nice,
					   &user_stat->num_threads,
					   &user_stat->itrealvalue,
					   &user_stat->starttime,
					   &user_stat->vsize,
					   &user_stat->rss,
					   &user_stat->rsslim,
					   &user_stat->startcode,
					   &user_stat->endcode,
					   &user_stat->startstack,
					   &user_stat->kstkesp,
					   &user_stat->kstkeip,
					   &user_stat->signal,
					   &user_stat->blocked,
					   &user_stat->sigignore,
					   &user_stat->sigcatch,
					   &user_stat->wchan,
					   &user_stat->nswap,
					   &user_stat->cnswap,
					   &user_stat->exit_signal,
					   &user_stat->processor,
					   &user_stat->rt_priority,
					   &user_stat->policy,

					   // Linux 2.6.18
					   &user_stat->delayacct_blkio_ticks,

					   // Linux 2.6.24
					   &user_stat->guest_time,
					   &user_stat->cguest_time,

					   // Linux 3.3
					   &user_stat->start_data,
					   &user_stat->end_data,
					   &user_stat->start_brk,

					   // Linux 3.5
					   &user_stat->arg_start,
					   &user_stat->arg_end,
					   &user_stat->env_start,
					   &user_stat->env_end,
					   &user_stat->exit_code);

		// fill in the pid
		r += sscanf(&line[0], "%d", &user_stat->pid);

		// fill in the comm field
		const size_t len = std::min(sizeof(user_stat->comm), (right - left) - 1);
		line.copy(user_stat->comm, len, left + 1);
		user_stat->comm[len] = '\0';
		++r;

		return r;
	}

	return -1;
}

/**
 * gets the contents of /proc/<pid>/stat
 *
 * @brief get_user_stat
 * @param pid
 * @param user_stat
 * @return the number of elements or -1 on error
 */
int get_user_stat(edb::pid_t pid, struct user_stat *user_stat) {
	char path[PATH_MAX];
	snprintf(path, sizeof(path), "/proc/%d/stat", pid);
	return get_user_stat(path, user_stat);
}

/**
 * gets the contents of /proc/<pid>/task/<tid>/stat
 *
 * @brief get_user_task_stat
 * @param pid
 * @param tid
 * @param user_stat
 * @return the number of elements or -1 on error
 */
int get_user_task_stat(edb::pid_t pid, edb::tid_t tid, struct user_stat *user_stat) {
	char path[PATH_MAX];
	snprintf(path, sizeof(path), "/proc/%d/task/%d/stat", pid, tid);
	return get_user_stat(path, user_stat);
}

}

```

`plugins/DebuggerCore/unix/linux/PlatformCommon.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_COMMON_H_20151011_
#define PLATFORM_COMMON_H_20151011_

#include "OSTypes.h"
#include "edb.h"

class QString;

namespace DebuggerCorePlugin {

struct user_stat {
	/* 01 */ int pid;
	/* 02 */ char comm[256];
	/* 03 */ char state;
	/* 04 */ int ppid;
	/* 05 */ int pgrp;
	/* 06 */ int session;
	/* 07 */ int tty_nr;
	/* 08 */ int tpgid;
	/* 09 */ unsigned flags;
	/* 10 */ unsigned long long minflt;
	/* 11 */ unsigned long long cminflt;
	/* 12 */ unsigned long long majflt;
	/* 13 */ unsigned long long cmajflt;
	/* 14 */ unsigned long long utime;
	/* 15 */ unsigned long long stime;
	/* 16 */ long long cutime;
	/* 17 */ long long cstime;
	/* 18 */ long long priority;
	/* 19 */ long long nice;
	/* 20 */ long long num_threads;
	/* 21 */ long long itrealvalue;
	/* 22 */ unsigned long long starttime;
	/* 23 */ unsigned long long vsize;
	/* 24 */ long long rss;
	/* 25 */ unsigned long long rsslim;
	/* 26 */ unsigned long long startcode;
	/* 27 */ unsigned long long endcode;
	/* 28 */ unsigned long long startstack;
	/* 29 */ unsigned long long kstkesp;
	/* 30 */ unsigned long long kstkeip;
	/* 31 */ unsigned long long signal;
	/* 32 */ unsigned long long blocked;
	/* 33 */ unsigned long long sigignore;
	/* 34 */ unsigned long long sigcatch;
	/* 35 */ unsigned long long wchan;
	/* 36 */ unsigned long long nswap;
	/* 37 */ unsigned long long cnswap;
	/* 38 */ int exit_signal;
	/* 39 */ int processor;
	/* 40 */ unsigned rt_priority;
	/* 41 */ unsigned policy;

	// Linux 2.6.18
	/* 42 */ unsigned long long delayacct_blkio_ticks;

	// Linux 2.6.24
	/* 43 */ unsigned long long guest_time;
	/* 44 */ long long cguest_time;

	// Linux 3.3
	/* 45 */ unsigned long long start_data;
	/* 46 */ unsigned long long end_data;
	/* 47 */ unsigned long long start_brk;

	// Linux 3.5
	/* 48 */ unsigned long long arg_start;
	/* 49 */ unsigned long long arg_end;
	/* 50 */ unsigned long long env_start;
	/* 51 */ unsigned long long env_end;
	/* 52 */ int exit_code;
};

int get_user_stat(const char *path, struct user_stat *user_stat);
int get_user_stat(edb::pid_t pid, struct user_stat *user_stat);
int get_user_task_stat(edb::pid_t pid, edb::tid_t tid, struct user_stat *user_stat);
int resume_code(int status);

}

#endif

```

`plugins/DebuggerCore/unix/linux/PlatformEvent.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformEvent.h"
#include "edb.h"

namespace DebuggerCorePlugin {

/**
 * @brief PlatformEvent::clone
 * @return
 */
IDebugEvent *PlatformEvent::clone() const {
	return new PlatformEvent(*this);
}

/**
 * @brief PlatformEvent::createUnexpectedSignalMessage
 * @param name
 * @param number
 * @return
 */
IDebugEvent::Message PlatformEvent::createUnexpectedSignalMessage(const QString &name, int number) {
	return Message(
		tr("Unexpected Signal Encountered"),
		tr("<p>The debugged application encountered a %1 (%2).</p>").arg(name).arg(number),
		tr("% received").arg(name));
}

/**
 * @brief PlatformEvent::errorDescription
 * @return
 */
IDebugEvent::Message PlatformEvent::errorDescription() const {
	Q_ASSERT(isError());

	auto fault_address = edb::address_t::fromZeroExtended(siginfo_.si_addr);

	std::size_t debuggeePtrSize = edb::v1::pointer_size();
	bool fullAddressKnown       = debuggeePtrSize <= sizeof(void *);
	const QString addressString = fault_address.toPointerString(fullAddressKnown);

	Message message;
	switch (code()) {
	case SIGSEGV:
		switch (siginfo_.si_code) {
		case SEGV_MAPERR:
			message = Message(
				tr("Illegal Access Fault"),
				tr("<p>The debugged application encountered a segmentation fault.<br />The address <strong>%1</strong> does not appear to be mapped.</p>").arg(addressString),
				tr("SIGSEGV: SEGV_MAPERR: Accessed address %1 not mapped").arg(addressString));
			break;
		case SEGV_ACCERR:
			message = Message(
				tr("Illegal Access Fault"),
				tr("<p>The debugged application encountered a segmentation fault.<br />The address <strong>%1</strong> could not be accessed.</p>").arg(addressString),
				tr("SIGSEGV: SEGV_ACCERR: Access to address %1 not permitted").arg(addressString));
			break;
		default:
			message = Message(
				tr("Illegal Access Fault"),
				tr("<p>The debugged application encountered a segmentation fault.<br />The instruction could not be executed.</p>"),
				tr("SIGSEGV: Segmentation fault"));
			break;
		}
		break;

	case SIGILL:
		message = Message(
			tr("Illegal Instruction Fault"),
			tr("<p>The debugged application attempted to execute an illegal instruction.</p>"),
			tr("SIGILL: Illegal instruction"));
		break;
	case SIGFPE:
		switch (siginfo_.si_code) {
		case FPE_INTDIV:
			message = Message(
				tr("Divide By Zero"),
				tr("<p>The debugged application tried to divide an integer value by an integer divisor of zero or encountered integer division overflow.</p>"),
				tr("SIGFPE: FPE_INTDIV: Integer division by zero or division overflow"));
			break;
		case FPE_FLTDIV:
			message = Message(
				tr("Divide By Zero"),
				tr("<p>The debugged application tried to divide an floating-point value by a floating-point divisor of zero.</p>"),
				tr("SIGFPE: FPE_FLTDIV: Floating-point division by zero"));
			break;
		case FPE_FLTOVF:
			message = Message(
				tr("Numeric Overflow"),
				tr("<p>The debugged application encountered a numeric overflow while performing a floating-point computation.</p>"),
				tr("SIGFPE: FPE_FLTOVF: Numeric overflow exception"));
			break;
		case FPE_FLTUND:
			message = Message(
				tr("Numeric Underflow"),
				tr("<p>The debugged application encountered a numeric underflow while performing a floating-point computation.</p>"),
				tr("SIGFPE: FPE_FLTUND: Numeric underflow exception"));
			break;
		case FPE_FLTRES:
			message = Message(
				tr("Inexact Result"),
				tr("<p>The debugged application encountered an inexact result of a floating-point computation it was performing.</p>"),
				tr("SIGFPE: FPE_FLTRES: Inexact result exception"));
			break;
		case FPE_FLTINV:
			message = Message(
				tr("Invalid Operation"),
				tr("<p>The debugged application attempted to perform an invalid floating-point operation.</p>"),
				tr("SIGFPE: FPE_FLTINV: Invalid floating-point operation"));
			break;
		default:
			message = Message(
				tr("Floating Point Exception"),
				tr("<p>The debugged application encountered a floating-point exception.</p>"),
				tr("SIGFPE: Floating-point exception"));
			break;
		}
		break;

	case SIGABRT:
		message = Message(
			tr("Application Aborted"),
			tr("<p>The debugged application has aborted.</p>"),
			tr("SIGABRT: Application aborted"));
		break;
	case SIGBUS:
		message = Message(
			tr("Bus Error"),
			tr("<p>The debugged application received a bus error. Typically, this means that it tried to read or write data that is misaligned.</p>"),
			tr("SIGBUS: Bus error"));
		break;
#ifdef SIGSTKFLT
	case SIGSTKFLT:
		message = Message(
			tr("Stack Fault"),
			tr("<p>The debugged application encountered a stack fault.</p>"),
			tr("SIGSTKFLT: Stack fault"));
		break;
#endif
	case SIGPIPE:
		message = Message(
			tr("Broken Pipe Fault"),
			tr("<p>The debugged application encountered a broken pipe fault.</p>"),
			tr("SIGPIPE: Pipe broken"));
		break;
#ifdef SIGHUP
	case SIGHUP:
		message = createUnexpectedSignalMessage("SIGHUP", SIGHUP);
		break;
#endif
#ifdef SIGINT
	case SIGINT:
		message = createUnexpectedSignalMessage("SIGINT", SIGINT);
		break;
#endif
#ifdef SIGQUIT
	case SIGQUIT:
		message = createUnexpectedSignalMessage("SIGQUIT", SIGQUIT);
		break;
#endif
#ifdef SIGTRAP
	case SIGTRAP:
		message = createUnexpectedSignalMessage("SIGTRAP", SIGTRAP);
		break;
#endif
#ifdef SIGKILL
	case SIGKILL:
		message = createUnexpectedSignalMessage("SIGKILL", SIGKILL);
		break;
#endif
#ifdef SIGUSR1
	case SIGUSR1:
		message = createUnexpectedSignalMessage("SIGUSR1", SIGUSR1);
		break;
#endif
#ifdef SIGUSR2
	case SIGUSR2:
		message = createUnexpectedSignalMessage("SIGUSR2", SIGUSR2);
		break;
#endif
#ifdef SIGALRM
	case SIGALRM:
		message = createUnexpectedSignalMessage("SIGALRM", SIGALRM);
		break;
#endif
#ifdef SIGTERM
	case SIGTERM:
		message = createUnexpectedSignalMessage("SIGTERM", SIGTERM);
		break;
#endif
#ifdef SIGCHLD
	case SIGCHLD:
		message = createUnexpectedSignalMessage("SIGCHLD", SIGCHLD);
		break;
#endif
#ifdef SIGCONT
	case SIGCONT:
		message = createUnexpectedSignalMessage("SIGCONT", SIGCONT);
		break;
#endif
#ifdef SIGSTOP
	case SIGSTOP:
		message = createUnexpectedSignalMessage("SIGSTOP", SIGSTOP);
		break;
#endif
#ifdef SIGTSTP
	case SIGTSTP:
		message = createUnexpectedSignalMessage("SIGTSTP", SIGTSTP);
		break;
#endif
#ifdef SIGTTIN
	case SIGTTIN:
		message = createUnexpectedSignalMessage("SIGTTIN", SIGTTIN);
		break;
#endif
#ifdef SIGTTOU
	case SIGTTOU:
		message = createUnexpectedSignalMessage("SIGTTOU", SIGTTOU);
		break;
#endif
#ifdef SIGURG
	case SIGURG:
		message = createUnexpectedSignalMessage("SIGURG", SIGURG);
		break;
#endif
#ifdef SIGXCPU
	case SIGXCPU:
		message = createUnexpectedSignalMessage("SIGXCPU", SIGXCPU);
		break;
#endif
#ifdef SIGXFSZ
	case SIGXFSZ:
		message = createUnexpectedSignalMessage("SIGXFSZ", SIGXFSZ);
		break;
#endif
#ifdef SIGVTALRM
	case SIGVTALRM:
		message = createUnexpectedSignalMessage("SIGVTALRM", SIGVTALRM);
		break;
#endif
#ifdef SIGPROF
	case SIGPROF:
		message = createUnexpectedSignalMessage("SIGPROF", SIGPROF);
		break;
#endif
#ifdef SIGWINCH
	case SIGWINCH:
		message = createUnexpectedSignalMessage("SIGWINCH", SIGWINCH);
		break;
#endif
#ifdef SIGIO
	case SIGIO:
		message = createUnexpectedSignalMessage("SIGIO", SIGIO);
		break;
#endif
	default:
		return Message();
	}

	message.message += "<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>";
	message.statusMessage += ". Shift+Run/Step to pass signal to the program";
	return message;
}

/**
 * @brief PlatformEvent::reason
 * @return
 */
IDebugEvent::REASON PlatformEvent::reason() const {
	// this basically converts our value into a 'switchable' value for convenience

	if (stopped()) {
		return EVENT_STOPPED;
	} else if (terminated()) {
		return EVENT_TERMINATED;
	} else if (exited()) {
		return EVENT_EXITED;
	} else {
		return EVENT_UNKNOWN;
	}
}

/**
 * @brief PlatformEvent::trapReason
 * @return
 */
IDebugEvent::TRAP_REASON PlatformEvent::trapReason() const {
	switch (siginfo_.si_code) {
	case TRAP_TRACE:
		return TRAP_STEPPING;
	default:
		return TRAP_BREAKPOINT;
	}
}

/**
 * @brief PlatformEvent::exited
 * @return
 */
bool PlatformEvent::exited() const {
	return WIFEXITED(status_) != 0;
}

/**
 * @brief PlatformEvent::isError
 * @return
 */
bool PlatformEvent::isError() const {
	if (stopped()) {
		switch (code()) {
		case SIGTRAP:
		case SIGSTOP:
			return false;
		case SIGSEGV:
		case SIGILL:
		case SIGFPE:
		case SIGABRT:
		case SIGBUS:
#ifdef SIGSTKFLT
		case SIGSTKFLT:
#endif
		case SIGPIPE:
			return true;
		default:
			return false;
		}
	} else {
		return false;
	}
}

/**
 * @brief PlatformEvent::isKill
 * @return
 */
bool PlatformEvent::isKill() const {
	return stopped() && code() == SIGKILL;
}

/**
 * @brief PlatformEvent::isStop
 * @return
 */
bool PlatformEvent::isStop() const {
	return stopped() && code() == SIGSTOP;
}

/**
 * @brief PlatformEvent::isTrap
 * @return
 */
bool PlatformEvent::isTrap() const {
	return stopped() && code() == SIGTRAP;
}

/**
 * @brief PlatformEvent::terminated
 * @return
 */
bool PlatformEvent::terminated() const {
	return WIFSIGNALED(status_) != 0;
}

/**
 * @brief PlatformEvent::stopped
 * @return
 */
bool PlatformEvent::stopped() const {
	return WIFSTOPPED(status_) != 0;
}

/**
 * @brief PlatformEvent::process
 * @return
 */
edb::pid_t PlatformEvent::process() const {
	return pid_;
}

/**
 * @brief PlatformEvent::thread
 * @return
 */
edb::tid_t PlatformEvent::thread() const {
	return tid_;
}

/**
 * @brief PlatformEvent::code
 * @return
 */
int64_t PlatformEvent::code() const {
	if (stopped()) {
		return WSTOPSIG(status_);
	}

	if (terminated()) {
		return WTERMSIG(status_);
	}

	if (exited()) {
		return WEXITSTATUS(status_);
	}

	return 0;
}

}

```

`plugins/DebuggerCore/unix/linux/PlatformEvent.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_EVENT_H_20121005_
#define PLATFORM_EVENT_H_20121005_

#include "IDebugEvent.h"

#include <QCoreApplication>
#include <signal.h> // for the SIG* definitions

namespace DebuggerCorePlugin {

class PlatformEvent final : public IDebugEvent {
	Q_DECLARE_TR_FUNCTIONS(PlatformEvent)
	friend class DebuggerCore;

public:
	PlatformEvent() = default;

private:
	PlatformEvent(const PlatformEvent &) = default;
	PlatformEvent &operator=(const PlatformEvent &) = default;

public:
	IDebugEvent *clone() const override;

public:
	Message errorDescription() const override;
	REASON reason() const override;
	TRAP_REASON trapReason() const override;
	bool exited() const override;
	bool isError() const override;
	bool isKill() const override;
	bool isStop() const override;
	bool isTrap() const override;
	bool stopped() const override;
	bool terminated() const override;
	edb::pid_t process() const override;
	edb::tid_t thread() const override;
	int64_t code() const override;

private:
	static IDebugEvent::Message createUnexpectedSignalMessage(const QString &name, int number);

private:
	siginfo_t siginfo_ = {};
	edb::pid_t pid_    = 0;
	edb::tid_t tid_    = 0;
	int status_        = 0;
};

}

#endif

```

`plugins/DebuggerCore/unix/linux/PlatformProcess.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef _LARGEFILE64_SOURCE
#define _LARGEFILE64_SOURCE
#endif

#include "PlatformProcess.h"
#include "ByteShiftArray.h"
#include "DebuggerCore.h"
#include "IBreakpoint.h"
#include "MemoryRegions.h"
#include "Module.h"
#include "PlatformCommon.h"
#include "PlatformRegion.h"
#include "PlatformThread.h"
#include "edb.h"
#include "libELF/elf_binary.h"
#include "libELF/elf_model.h"
#include "linker.h"
#include "util/Container.h"

#include <QByteArray>
#include <QDateTime>
#include <QDebug>
#include <QFile>
#include <QFileInfo>
#include <QTextStream>

#include <fstream>

#include <elf.h>
#include <linux/limits.h>
#include <pwd.h>
#include <sys/mman.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <unistd.h>

namespace DebuggerCorePlugin {
namespace {

// Used as size of ptrace word
constexpr size_t WordSize = sizeof(long);

template <class T>
void hash_combine(std::size_t &seed, const T &v) {
	std::hash<T> hasher;
	seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

/**
 * @brief set_ok
 * @param value
 */
bool set_ok(long value) {
	return (value != -1) || (errno == 0);
}

/**
 * @brief split_max
 * @param str
 * @param maxparts
 * @return
 */
QStringList split_max(const QString &str, int maxparts) {
	int prev_idx = 0;
	int idx      = 0;
	QStringList items;
	for (const QChar &c : str) {
		if (c == ' ') {
			if (prev_idx < idx) {
				if (items.size() < maxparts - 1)
					items << str.mid(prev_idx, idx - prev_idx);
				else {
					items << str.right(str.size() - prev_idx);
					break;
				}
			}
			prev_idx = idx + 1;
		}
		++idx;
	}

	if (prev_idx < str.size() && items.size() < maxparts) {
		items << str.right(str.size() - prev_idx);
	}

	return items;
}

/**
 * parses the data from a line of a memory map file
 *
 * @brief process_map_line
 * @param line
 * @return
 */
std::shared_ptr<IRegion> process_map_line(const QString &line) {

	edb::address_t start;
	edb::address_t end;
	edb::address_t base;
	IRegion::permissions_t permissions;
	QString name;

	const QStringList items = split_max(line, 6);
	if (items.size() >= 3) {
		bool ok;
		const QStringList bounds = items[0].split("-");
		if (bounds.size() == 2) {
			start = edb::address_t::fromHexString(bounds[0], &ok);
			if (ok) {
				end = edb::address_t::fromHexString(bounds[1], &ok);
				if (ok) {
					base = edb::address_t::fromHexString(items[2], &ok);
					if (ok) {
						const QString perms = items[1];
						permissions         = 0;
						if (perms[0] == 'r') permissions |= PROT_READ;
						if (perms[1] == 'w') permissions |= PROT_WRITE;
						if (perms[2] == 'x') permissions |= PROT_EXEC;

						if (items.size() >= 6) {
							name = items[5];
						}

						return std::make_shared<PlatformRegion>(start, end, base, name, permissions);
					}
				}
			}
		}
	}
	return nullptr;
}

/**
 * @brief get_loaded_modules
 * @param process
 * @return
 */
template <class Addr>
QList<Module> get_loaded_modules(const IProcess *process) {

	QList<Module> ret;

	edb::linux_struct::r_debug<Addr> dynamic_info;
	if (process) {
		if (const edb::address_t debug_pointer = process->debugPointer()) {
			if (process->readBytes(debug_pointer, &dynamic_info, sizeof(dynamic_info))) {
				if (dynamic_info.r_map) {

					auto link_address = edb::address_t::fromZeroExtended(dynamic_info.r_map);

					while (link_address) {

						edb::linux_struct::link_map<Addr> map;
						if (process->readBytes(link_address, &map, sizeof(map))) {
							char path[PATH_MAX];
							if (!process->readBytes(edb::address_t::fromZeroExtended(map.l_name), &path, sizeof(path))) {
								path[0] = '\0';
							}

							if (map.l_addr) {
								Module module;
								module.name        = path;
								module.baseAddress = map.l_addr;
								ret.push_back(module);
							}

							link_address = edb::address_t::fromZeroExtended(map.l_next);
						} else {
							break;
						}
					}
				}
			}
		}
	}

	// fallback
	if (ret.isEmpty()) {
		const QList<std::shared_ptr<IRegion>> r = edb::v1::memory_regions().regions();
		QSet<QString> found_modules;

		for (const std::shared_ptr<IRegion> &region : r) {

			// we assume that modules will be listed by absolute path
			if (region->name().startsWith("/")) {
				if (!util::contains(found_modules, region->name())) {
					Module module;
					module.name        = region->name();
					module.baseAddress = region->start();
					found_modules.insert(region->name());
					ret.push_back(module);
				}
			}
		}
	}

	return ret;
}

/**
 * seeks memory file to given address, taking possible negativity of the
 * address into account
 *
 * @brief seek_addr
 * @param file
 * @param address
 */
void seek_addr(QFile &file, edb::address_t address) {
	if (address <= UINT64_MAX / 2) {
		file.seek(address);
	} else {
		const int fd = file.handle();
		// Seek in two parts to avoid specifying negative offset: off64_t is a signed type
		const off64_t halfAddressTruncated = address >> 1;
		lseek64(fd, halfAddressTruncated, SEEK_SET);
		const off64_t secondHalfAddress = address - halfAddressTruncated;
		lseek64(fd, secondHalfAddress, SEEK_CUR);
	}
}

}

/**
 * @brief PlatformProcess::PlatformProcess
 * @param core
 * @param pid
 */
PlatformProcess::PlatformProcess(DebuggerCore *core, edb::pid_t pid)
	: core_(core), pid_(pid) {

	if (!core_->procMemReadBroken_) {
		auto memory_file = std::make_shared<QFile>(QString("/proc/%1/mem").arg(pid_));

		QIODevice::OpenMode flags = QIODevice::ReadOnly | QIODevice::Unbuffered;
		if (!core_->procMemWriteBroken_) {
			flags |= QIODevice::WriteOnly;
		}

		if (memory_file->open(flags)) {
			readOnlyMemFile_ = memory_file;
			if (!core_->procMemWriteBroken_) {
				readWriteMemFile_ = memory_file;
			}
		}
	}
}

/**
 * reads <len> bytes into <buf> starting at <address>
 *
 * @brief PlatformProcess::readBytes
 * @param address
 * @param buf
 * @param len
 * @return
 */
std::size_t PlatformProcess::readBytes(edb::address_t address, void *buf, std::size_t len) const {

	// NOTE(eteran): returns the number of bytes read <N>
	// NOTE(eteran): if the read is short, only the first <N> bytes are defined

	quint64 read = 0;

	Q_ASSERT(buf);
	Q_ASSERT(core_->process_.get() == this);

	auto ptr = reinterpret_cast<char *>(buf);

	if (len != 0) {

		// small reads take the fast path
		if (len == 1) {

			auto it = core_->breakpoints_.find(address);
			if (it != core_->breakpoints_.end()) {
				*ptr = (*it)->originalBytes()[0];
				return 1;
			}

			if (readOnlyMemFile_) {
				seek_addr(*readOnlyMemFile_, address);
				read = readOnlyMemFile_->read(ptr, 1);
				if (read == 1) {
					return 1;
				}
				return 0;
			} else {
				bool ok;
				uint8_t x = ptraceReadByte(address, &ok);
				if (ok) {
					*ptr = x;
					return 1;
				}
				return 0;
			}
		}

		if (readOnlyMemFile_) {
			seek_addr(*readOnlyMemFile_, address);
			read = readOnlyMemFile_->read(ptr, len);
			if (read == 0 || read == quint64(-1)) {
				return 0;
			}
		} else {
			for (std::size_t index = 0; index < len; ++index) {

				// read a byte, if we failed, we are done
				bool ok;
				const uint8_t x = ptraceReadByte(address + index, &ok);
				if (!ok) {
					break;
				}

				// store it
				reinterpret_cast<char *>(buf)[index] = x;

				++read;
			}
		}

		// replace any breakpoints
		Q_FOREACH (const std::shared_ptr<IBreakpoint> &bp, core_->breakpoints_) {
			auto bpBytes                = bp->originalBytes();
			const edb::address_t bpAddr = bp->address();
			// show the original bytes in the buffer..
			for (size_t i = 0; i < bp->size(); ++i) {
				if (bpAddr + i >= address && bpAddr + i < address + read) {
					ptr[bpAddr + i - address] = bpBytes[i];
				}
			}
		}
	}

	return read;
}

/**
 * same as writeBytes, except that it also records the original data that was
 * found at the address being written to.
 *
 * @brief PlatformProcess::patchBytes
 * @param address
 * @param buf
 * @param len
 * @return
 */
std::size_t PlatformProcess::patchBytes(edb::address_t address, const void *buf, size_t len) {

	// NOTE(eteran): Unlike the read_bytes, write_bytes functions, this will
	//               not apply the write if we could not properly backup <len>
	//               bytes as requested.
	// NOTE(eteran): On the off chance that we can READ <len> bytes, but can't
	//               WRITE <len> bytes, we will return the number of bytes
	//               written, but record <len> bytes of patch data.

	Q_ASSERT(buf);
	Q_ASSERT(core_->process_.get() == this);

	Patch patch;
	patch.address = address;
	patch.origBytes.resize(len);
	patch.newBytes = QByteArray(static_cast<const char *>(buf), len);

	size_t read_ret = readBytes(address, patch.origBytes.data(), len);
	if (read_ret != len) {
		return 0;
	}

	patches_.insert(address, patch);

	return writeBytes(address, buf, len);
}

/**
 * writes <len> bytes from <buf> starting at <address>
 *
 * @brief PlatformProcess::writeBytes
 * @param address
 * @param buf
 * @param len
 * @return
 */
std::size_t PlatformProcess::writeBytes(edb::address_t address, const void *buf, std::size_t len) {
	quint64 written = 0;

	Q_ASSERT(buf);
	Q_ASSERT(core_->process_.get() == this);

	if (len != 0) {
		if (readWriteMemFile_) {
			seek_addr(*readWriteMemFile_, address);
			written = readWriteMemFile_->write(reinterpret_cast<const char *>(buf), len);
			if (written == 0 || written == quint64(-1)) {
				return 0;
			}
		} else {
			// TODO write whole words at a time using ptrace_poke.
			for (std::size_t byteIndex = 0; byteIndex < len; ++byteIndex) {
				bool ok = false;
				ptraceWriteByte(address + byteIndex, *(reinterpret_cast<const char *>(buf) + byteIndex), &ok);
				if (!ok) return written;
				++written;
			}
		}
	}

	return written;
}

/**
 * reads <count> pages from the process starting at <address>
 *
 * @brief PlatformProcess::readPages
 * @param address - must be page aligned.
 * @param buf - sizeof(buf) must be >= count * core_->page_size()
 * @param count - number of pages
 * @return
 */
std::size_t PlatformProcess::readPages(edb::address_t address, void *buf, std::size_t count) const {
	Q_ASSERT(buf);
	Q_ASSERT(core_->process_.get() == this);
	return readBytes(address, buf, count * core_->pageSize()) / core_->pageSize();
}

/**
 * @brief PlatformProcess::startTime
 * @return
 */
QDateTime PlatformProcess::startTime() const {
	QFileInfo info(QString("/proc/%1/stat").arg(pid_));
#if QT_VERSION >= QT_VERSION_CHECK(5, 10, 0)
	return info.birthTime();
#else
	return info.created();
#endif
}

/**
 * @brief PlatformProcess::arguments
 * @return
 */
QList<QByteArray> PlatformProcess::arguments() const {
	QList<QByteArray> ret;

	if (pid_ != 0) {
		const QString command_line_file(QString("/proc/%1/cmdline").arg(pid_));
		QFile file(command_line_file);

		if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
			QTextStream in(&file);

			QByteArray s;
			char ch;

			while (in.status() == QTextStream::Ok) {
				in >> ch;
				if (ch != '\0') {
					if (!s.isEmpty()) {
						ret << s;
					}
					s.clear();
				} else {
					s += ch;
				}
			}

			if (!s.isEmpty()) {
				ret << s;
			}
		}
	}
	return ret;
}

/**
 * @brief PlatformProcess::currentWorkingDirectory
 * @return
 */
QString PlatformProcess::currentWorkingDirectory() const {
	return edb::v1::symlink_target(QString("/proc/%1/cwd").arg(pid_));
}

/**
 * @brief PlatformProcess::executable
 * @return
 */
QString PlatformProcess::executable() const {
	return edb::v1::symlink_target(QString("/proc/%1/exe").arg(pid_));
}

/**
 * @brief PlatformProcess::pid
 * @return
 */
edb::pid_t PlatformProcess::pid() const {
	return pid_;
}

/**
 * @brief PlatformProcess::parent
 * @return
 */
std::shared_ptr<IProcess> PlatformProcess::parent() const {

	struct user_stat user_stat;
	int n = get_user_stat(pid_, &user_stat);
	if (n >= 4) {
		return std::make_shared<PlatformProcess>(core_, user_stat.ppid);
	}

	return nullptr;
}

/**
 * @brief PlatformProcess::codeAddress
 * @return
 */
edb::address_t PlatformProcess::codeAddress() const {
	struct user_stat user_stat;
	int n = get_user_stat(pid_, &user_stat);
	if (n >= 26) {
		return user_stat.startcode;
	}
	return 0;
}

/**
 * @brief PlatformProcess::dataAddress
 * @return
 */
edb::address_t PlatformProcess::dataAddress() const {
	struct user_stat user_stat;
	int n = get_user_stat(pid_, &user_stat);
	if (n >= 27) {
		return user_stat.endcode + 1; // endcode == startdata ?
	}
	return 0;
}

/**
 * @brief PlatformProcess::regions
 * @return
 */
QList<std::shared_ptr<IRegion>> PlatformProcess::regions() const {

	static QList<std::shared_ptr<IRegion>> regions;
	const QString map_file(QString("/proc/%1/maps").arg(pid_));

	// hash the region file to see if it changed or not
	{
		static size_t totalHash = 0;

		std::ifstream mf(map_file.toStdString());
		size_t newHash = 0;
		std::string line;

		while (std::getline(mf, line)) {
			hash_combine(newHash, line);
		}

		if (totalHash == newHash) {
			return regions;
		}

		totalHash = newHash;
		regions.clear();
	}

	// it changed, so let's process it
	QFile file(map_file);
	if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {

		QTextStream in(&file);
		QString line = in.readLine();

		while (!line.isNull()) {
			if (std::shared_ptr<IRegion> region = process_map_line(line)) {
				regions.push_back(region);
			}
			line = in.readLine();
		}
	}

	return regions;
}

/**
 * @brief PlatformProcess::ptraceReadByte
 * @param address
 * @param ok
 * @return
 */
uint8_t PlatformProcess::ptraceReadByte(edb::address_t address, bool *ok) const {
	// TODO(eteran): assert that we are paused

	Q_ASSERT(ok);
	Q_ASSERT(core_->process_.get() == this);

	*ok = false;

	// if this spot is unreadable, then just return 0xff, otherwise
	// continue as normal.

	// core_->page_size() - 1 will always be 0xf* because pagesizes
	// are always 0x10*, so the masking works
	// range of nBytesToNextPage is [1..n] where n=pagesize, and we have to adjust
	// if nByteToNextPage < wordsize
	const size_t nBytesToNextPage = core_->pageSize() - (address & (core_->pageSize() - 1));

	// Avoid crossing page boundary, since next page may be unreadable
	const size_t addressShift = nBytesToNextPage < WordSize ? WordSize - nBytesToNextPage : 0;
	address -= addressShift;

	const long value = ptracePeek(address, ok);

	if (*ok) {
		uint8_t result;
		// We aren't interested in `value` as in number, it's just a buffer, so no endianness magic.
		// Just have to compensate for `addressShift` when reading it.
		std::memcpy(&result, reinterpret_cast<const char *>(&value) + addressShift, sizeof(result));
		return result;
	}

	return 0xff;
}

/**
 * writes a single byte at a given address via ptrace API.
 *
 * @brief PlatformProcess::ptraceWriteByte
 * @param address
 * @param value
 * @param ok
 */
void PlatformProcess::ptraceWriteByte(edb::address_t address, uint8_t value, bool *ok) {
	// TODO(eteran): assert that we are paused
	// NOTE(eteran): assumes the this will not trample any breakpoints, must
	// be handled in calling code!

	Q_ASSERT(ok);
	Q_ASSERT(core_->process_.get() == this);

	*ok = false;

	// core_->page_size() - 1 will always be 0xf* because pagesizes
	// are always 0x10*, so the masking works
	// range of nBytesToNextPage is [1..n] where n=pagesize, and we have to adjust
	// if nBytesToNextPage < wordsize
	const size_t nBytesToNextPage = core_->pageSize() - (address & (core_->pageSize() - 1));

	// Avoid crossing page boundary, since next page may be inaccessible
	const size_t addressShift = nBytesToNextPage < WordSize ? WordSize - nBytesToNextPage : 0;
	address -= addressShift;

	long word = ptracePeek(address, ok);
	if (!*ok) {
		return;
	}

	// We aren't interested in `value` as in number, it's just a buffer, so no endianness magic.
	// Just have to compensate for `addressShift` when writing it.
	std::memcpy(reinterpret_cast<char *>(&word) + addressShift, &value, sizeof(value));

	*ok = ptracePoke(address, word);
}

/**
 * @brief PlatformProcess::ptracePeek
 * @param address
 * @param ok
 * @return
 */
long PlatformProcess::ptracePeek(edb::address_t address, bool *ok) const {

	// NOTE(eteran): this will fail on newer versions of linux if called from a
	//               different thread than the one which attached to process

	Q_ASSERT(ok);
	Q_ASSERT(core_->process_.get() == this);

	if (EDB_IS_32_BIT && address > 0xffffffffULL) {
		// 32 bit ptrace can't handle such long addresses
		*ok = false;
		return 0;
	}

	errno = 0;
	// NOTE: on some Linux systems ptrace prototype has ellipsis instead of third and fourth arguments
	// Thus we can't just pass address as is on IA32 systems: it'd put 64 bit integer on stack and cause UB
	auto nativeAddress = reinterpret_cast<const void *>(address.toUint());
	const long v       = ptrace(PTRACE_PEEKTEXT, pid_, nativeAddress, 0);
	*ok                = set_ok(v);
	return v;
}

/**
 * @brief PlatformProcess::ptracePoke
 * @param address
 * @param value
 * @return
 */
bool PlatformProcess::ptracePoke(edb::address_t address, long value) {

	Q_ASSERT(core_->process_.get() == this);

	if (EDB_IS_32_BIT && address > 0xffffffffULL) {
		// 32 bit ptrace can't handle such long addresses
		return false;
	}

	// NOTE: on some Linux systems ptrace prototype has ellipsis instead of third and fourth arguments
	// Thus we can't just pass address as is on IA32 systems: it'd put 64 bit integer on stack and cause UB
	auto nativeAddress = reinterpret_cast<const void *>(address.toUint());
	return ptrace(PTRACE_POKETEXT, pid_, nativeAddress, value) != -1;
}

/**
 * @brief PlatformProcess::threads
 * @return
 */
QList<std::shared_ptr<IThread>> PlatformProcess::threads() const {

	Q_ASSERT(core_->process_.get() == this);

	QList<std::shared_ptr<IThread>> threadList;
	threadList.reserve(core_->threads_.size());
	std::copy(core_->threads_.begin(), core_->threads_.end(), std::back_inserter(threadList));
	return threadList;
}

/**
 * @brief PlatformProcess::currentThread
 * @return
 */
std::shared_ptr<IThread> PlatformProcess::currentThread() const {

	Q_ASSERT(core_->process_.get() == this);

	auto it = core_->threads_.find(core_->activeThread_);
	if (it != core_->threads_.end()) {
		return it.value();
	}
	return nullptr;
}

/**
 * @brief PlatformProcess::setCurrentThread
 * @param thread
 */
void PlatformProcess::setCurrentThread(IThread &thread) {
	core_->activeThread_ = static_cast<PlatformThread *>(&thread)->tid();
	edb::v1::update_ui();
}

/**
 * @brief PlatformProcess::uid
 * @return
 */
edb::uid_t PlatformProcess::uid() const {

	const QFileInfo info(QString("/proc/%1").arg(pid_));
	return info.ownerId();
}

/**
 * @brief PlatformProcess::user
 * @return
 */
QString PlatformProcess::user() const {
	if (const struct passwd *const pwd = ::getpwuid(uid())) {
		return pwd->pw_name;
	}

	return QString();
}

/**
 * @brief PlatformProcess::name
 * @return
 */
QString PlatformProcess::name() const {
	struct user_stat user_stat;
	const int n = get_user_stat(pid_, &user_stat);
	if (n >= 2) {
		return user_stat.comm;
	}

	return QString();
}

/**
 * @brief PlatformProcess::loadedModules
 * @return
 */
QList<Module> PlatformProcess::loadedModules() const {
	if (edb::v1::debuggeeIs64Bit()) {
		return get_loaded_modules<Elf64_Addr>(this);
	} else if (edb::v1::debuggeeIs32Bit()) {
		return get_loaded_modules<Elf32_Addr>(this);
	} else {
		return QList<Module>();
	}
}

/**
 * stops *all* threads of a process
 *
 * @brief PlatformProcess::pause
 * @return
 */
Status PlatformProcess::pause() {
	// belive it or not, I belive that this is sufficient for all threads.
	// This is because in the debug event handler, a SIGSTOP is sent
	// to all threads when any event arrives, so no need to explicitly do
	// it here. We just need any thread to stop. So we'll just target the
	// pid_ which will send it to any one of the threads in the process.
	if (::kill(pid_, SIGSTOP) == -1) {
		const char *const strError = strerror(errno);
		qWarning() << "Unable to pause process" << pid_ << ": kill(SIGSTOP) failed:" << strError;
		return Status(strError);
	}

	return Status::Ok;
}

/**
 * resumes ALL threads
 *
 * @brief PlatformProcess::resume
 * @param status
 * @return
 */
Status PlatformProcess::resume(edb::EventStatus status) {

	// NOTE(eteran): OK, this is very tricky. When the user wants to resume
	// while ignoring a signal (DEBUG_CONTINUE), we need to know which thread
	// needs to have the signal ignored, and which need to have their signals
	// passed during the resume

	// TODO: assert that we are paused
	Q_ASSERT(core_->process_.get() == this);

	QString errorMessage;

	if (status != edb::DEBUG_STOP) {

		if (std::shared_ptr<IThread> thread = currentThread()) {
			const auto resumeStatus = thread->resume(status);
			if (!resumeStatus) {
				errorMessage += tr("Failed to resume thread %1: %2\n").arg(thread->tid()).arg(resumeStatus.error());
			}

			// resume the other threads passing the signal they originally reported had
			for (auto &other_thread : threads()) {
				if (util::contains(core_->waitedThreads_, other_thread->tid())) {
					const auto resumeStatus = other_thread->resume();
					if (!resumeStatus) {
						errorMessage += tr("Failed to resume thread %1: %2\n").arg(thread->tid()).arg(resumeStatus.error());
					}
				}
			}
		}
	}

	if (errorMessage.isEmpty()) {
		return Status::Ok;
	}

	qWarning() << errorMessage.toStdString().c_str();
	return Status("\n" + errorMessage);
}

/**
 * steps the currently active thread
 *
 * @brief PlatformProcess::step
 * @param status
 * @return
 */
Status PlatformProcess::step(edb::EventStatus status) {
	// TODO: assert that we are paused
	Q_ASSERT(core_->process_.get() == this);

	if (status != edb::DEBUG_STOP) {
		if (std::shared_ptr<IThread> thread = currentThread()) {
			return thread->step(status);
		}
	}
	return Status::Ok;
}

/**
 * @brief PlatformProcess::isPaused
 * @return true if ALL threads are currently in the debugger's wait list
 */
bool PlatformProcess::isPaused() const {
	for (auto &thread : threads()) {
		if (!thread->isPaused()) {
			return false;
		}
	}

	return true;
}

/**
 * @brief PlatformProcess::patches
 * @return any patches applied to this process
 */
QMap<edb::address_t, Patch> PlatformProcess::patches() const {
	return patches_;
}

/**
 * @brief PlatformProcess::entry_point
 * @return
 */
edb::address_t PlatformProcess::entryPoint() const {

	QFile auxv(QString("/proc/%1/auxv").arg(pid_));
	if (auxv.open(QIODevice::ReadOnly)) {

		if (edb::v1::debuggeeIs64Bit()) {
			elf64_auxv_t entry;
			while (auxv.read(reinterpret_cast<char *>(&entry), sizeof(entry))) {
				if (entry.a_type == AT_ENTRY) {
					return entry.a_un.a_val;
				}
			}
		} else if (edb::v1::debuggeeIs32Bit()) {
			elf32_auxv_t entry;
			while (auxv.read(reinterpret_cast<char *>(&entry), sizeof(entry))) {
				if (entry.a_type == AT_ENTRY) {
					return entry.a_un.a_val;
				}
			}
		}
	}

	return edb::address_t{};
}

/**
 * @brief get_program_headers
 * @param process
 * @param phdr_memaddr
 * @param num_phdr
 * @return
 */
bool get_program_headers(const IProcess *process, edb::address_t *phdr_memaddr, int *num_phdr) {

	*phdr_memaddr = edb::address_t{};
	*num_phdr     = 0;

	QFile auxv(QString("/proc/%1/auxv").arg(process->pid()));
	if (auxv.open(QIODevice::ReadOnly)) {

		if (edb::v1::debuggeeIs64Bit()) {
			elf64_auxv_t entry;
			while (auxv.read(reinterpret_cast<char *>(&entry), sizeof(entry))) {
				switch (entry.a_type) {
				case AT_PHDR:
					*phdr_memaddr = entry.a_un.a_val;
					break;
				case AT_PHNUM:
					*num_phdr = entry.a_un.a_val;
					break;
				}
			}
		} else if (edb::v1::debuggeeIs32Bit()) {
			elf32_auxv_t entry;
			while (auxv.read(reinterpret_cast<char *>(&entry), sizeof(entry))) {
				switch (entry.a_type) {
				case AT_PHDR:
					*phdr_memaddr = entry.a_un.a_val;
					break;
				case AT_PHNUM:
					*num_phdr = entry.a_un.a_val;
					break;
				}
			}
		}
	}

	return (*phdr_memaddr != 0 && *num_phdr != 0);
}

/**
 * @brief get_debug_pointer
 * @param process
 * @param phdr_memaddr
 * @param count
 * @param relocation
 * @return
 */
template <class Model>
edb::address_t get_debug_pointer(const IProcess *process, edb::address_t phdr_memaddr, int count, edb::address_t relocation) {

	using elf_phdr = typename Model::elf_phdr;

	elf_phdr phdr;
	for (int i = 0; i < count; ++i) {
		if (process->readBytes(phdr_memaddr + i * sizeof(elf_phdr), &phdr, sizeof(elf_phdr))) {
			if (phdr.p_type == PT_DYNAMIC) {
				try {

					auto buf = std::make_unique<uint8_t[]>(phdr.p_memsz);

					if (process->readBytes(phdr.p_vaddr + relocation, &buf[0], phdr.p_memsz)) {
						auto dynamic = reinterpret_cast<typename Model::elf_dyn *>(&buf[0]);
						while (dynamic->d_tag != DT_NULL) {
							if (dynamic->d_tag == DT_DEBUG) {
								return dynamic->d_un.d_val;
							}
							++dynamic;
						}
					}
				} catch (const std::bad_alloc &) {
					qDebug() << "[get_debug_pointer] no more memory";
					return 0;
				}
			}
		}
	}

	return 0;
}

/**
 * @brief get_relocation
 * @param process
 * @param phdr_memaddr
 * @param i
 * @return
 */
template <class Model>
edb::address_t get_relocation(const IProcess *process, edb::address_t phdr_memaddr, int i) {

	using elf_phdr = typename Model::elf_phdr;

	elf_phdr phdr;
	if (process->readBytes(phdr_memaddr + i * sizeof(elf_phdr), &phdr, sizeof(elf_phdr))) {
		if (phdr.p_type == PT_PHDR) {
			return phdr_memaddr - phdr.p_vaddr;
		}
	}

	return -1;
}

/**
 * attempts to locate the ELF debug pointer in the target process and returns
 * it, 0 of not found
 *
 * @brief PlatformProcess::debug_pointer
 * @return
 */
edb::address_t PlatformProcess::debugPointer() const {

	// NOTE(eteran): some of this code is from or inspired by code in
	// gdb/gdbserver/linux-low.c

	edb::address_t phdr_memaddr;
	int num_phdr;

	if (get_program_headers(this, &phdr_memaddr, &num_phdr)) {

		/* Compute relocation: it is expected to be 0 for "regular" executables,
		 * non-zero for PIE ones.  */
		edb::address_t relocation = -1;
		for (int i = 0; relocation == -1 && i < num_phdr; i++) {

			if (edb::v1::debuggeeIs64Bit()) {
				relocation = get_relocation<elf_model<64>>(this, phdr_memaddr, i);
			} else if (edb::v1::debuggeeIs32Bit()) {
				relocation = get_relocation<elf_model<32>>(this, phdr_memaddr, i);
			}
		}

		if (relocation == -1) {
			/* PT_PHDR is optional, but necessary for PIE in general.
			 * Fortunately any real world executables, including PIE
			 * executables, have always PT_PHDR present.  PT_PHDR is not
			 * present in some shared libraries or in fpc (Free Pascal 2.4)
			 * binaries but neither of those have a need for or present
			 * DT_DEBUG anyway (fpc binaries are statically linked).
			 *
			 * Therefore if there exists DT_DEBUG there is always also PT_PHDR.
			 *
			 * GDB could find RELOCATION also from AT_ENTRY - e_entry.  */
			return 0;
		}

		if (edb::v1::debuggeeIs64Bit()) {
			return get_debug_pointer<elf_model<64>>(this, phdr_memaddr, num_phdr, relocation);
		} else if (edb::v1::debuggeeIs32Bit()) {
			return get_debug_pointer<elf_model<32>>(this, phdr_memaddr, num_phdr, relocation);
		}
	}

	return edb::address_t{};
}

/**
 * @brief PlatformProcess::calculateMain
 * @return
 */
edb::address_t PlatformProcess::calculateMain() const {
	if (edb::v1::debuggeeIs64Bit()) {
		ByteShiftArray ba(14);

		edb::address_t entry_point = this->entryPoint();

		for (int i = 0; i < 50; ++i) {
			uint8_t byte;
			if (readBytes(entry_point + i, &byte, sizeof(byte))) {
				ba << byte;

				edb::address_t address = 0;

				if (ba.size() >= 13) {
					// beginning of a call preceeded by a 64-bit mov and followed by a hlt
					if (ba[0] == 0x48 && ba[1] == 0xc7 && ba[7] == 0xe8 && ba[12] == 0xf4) {
						// Seems that this 64-bit mov still has a 32-bit immediate
						address = *reinterpret_cast<const edb::address_t *>(ba.data() + 3) & 0xffffffff;
					}

					// same heuristic except for PIC binaries
					else if (ba.size() >= 14 && ba[0] == 0x48 && ba[1] == 0x8d && ba[2] == 0x3d && ba[7] == 0xFF && ba[8] == 0x15 && ba[13] == 0xf4) {
						// It's signed relative!
						auto rel = *reinterpret_cast<const qint32 *>(ba.data() + 3);
						// ba[0] is entry_point + i - 13. instruction is 7 bytes long.
						address = rel + entry_point + i - 13 + 7;
					}

					if (address) {
						// TODO: make sure that this address resides in an executable region
						qDebug() << "No main symbol found, calculated it to be " << edb::v1::format_pointer(address) << " using heuristic";
						return address;
					}
				}
			} else {
				break;
			}
		}
	} else if (edb::v1::debuggeeIs32Bit()) {
		ByteShiftArray ba(11);

		edb::address_t entry_point = this->entryPoint();

		for (int i = 0; i < 50; ++i) {
			uint8_t byte;
			if (readBytes(entry_point + i, &byte, sizeof(byte))) {
				ba << byte;

				if (ba.size() >= 11) {
					// beginning of a call preceeded by a push and followed by a hlt
					if (ba[0] == 0x68 && ba[5] == 0xe8 && ba[10] == 0xf4) {
						edb::address_t address(0);

						auto to = reinterpret_cast<char *>(&address);
						std::memcpy(to, ba.data() + 1, sizeof(uint32_t));

						// TODO: make sure that this address resides in an executable region
						qDebug() << "No main symbol found, calculated it to be " << edb::v1::format_pointer(address) << " using heuristic";
						return address;
					}
				}
			} else {
				break;
			}
		}
	}

	return 0;
}

/**
 * @brief PlatformProcess::stardardInput
 * @return
 */
QString PlatformProcess::stardardInput() const {
	return input_;
}

/**
 * @brief PlatformProcess::stardardOutput
 * @return
 */
QString PlatformProcess::stardardOutput() const {
	return output_;
}

}

```

`plugins/DebuggerCore/unix/linux/PlatformProcess.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_PROCESS_H_20150517_
#define PLATFORM_PROCESS_H_20150517_

#include "IProcess.h"
#include "Status.h"

#include <QCoreApplication>
#include <QFile>

namespace DebuggerCorePlugin {

class DebuggerCore;

class PlatformProcess final : public IProcess {
	Q_DECLARE_TR_FUNCTIONS(PlatformProcess)
	friend class PlatformThread;

public:
	PlatformProcess(DebuggerCore *core, edb::pid_t pid);
	~PlatformProcess() override              = default;
	PlatformProcess(const PlatformProcess &) = delete;
	PlatformProcess &operator=(const PlatformProcess &) = delete;

public:
	QDateTime startTime() const override;
	QList<QByteArray> arguments() const override;
	QString currentWorkingDirectory() const override;
	QString executable() const override;
	QString stardardInput() const override;
	QString stardardOutput() const override;
	edb::pid_t pid() const override;
	std::shared_ptr<IProcess> parent() const override;
	edb::address_t codeAddress() const override;
	edb::address_t dataAddress() const override;
	edb::address_t entryPoint() const override;
	QList<std::shared_ptr<IRegion>> regions() const override;
	QList<std::shared_ptr<IThread>> threads() const override;
	std::shared_ptr<IThread> currentThread() const override;
	void setCurrentThread(IThread &thread) override;
	edb::uid_t uid() const override;
	QString user() const override;
	QString name() const override;
	QList<Module> loadedModules() const override;

public:
	edb::address_t debugPointer() const override;
	edb::address_t calculateMain() const override;

public:
	Status pause() override;
	Status resume(edb::EventStatus status) override;
	Status step(edb::EventStatus status) override;
	bool isPaused() const override;

public:
	std::size_t writeBytes(edb::address_t address, const void *buf, size_t len) override;
	std::size_t patchBytes(edb::address_t address, const void *buf, size_t len) override;
	std::size_t readBytes(edb::address_t address, void *buf, size_t len) const override;
	std::size_t readPages(edb::address_t address, void *buf, size_t count) const override;
	QMap<edb::address_t, Patch> patches() const override;

private:
	bool ptracePoke(edb::address_t address, long value);
	long ptracePeek(edb::address_t address, bool *ok) const;
	uint8_t ptraceReadByte(edb::address_t address, bool *ok) const;
	void ptraceWriteByte(edb::address_t address, uint8_t value, bool *ok);

private:
	DebuggerCore *core_ = nullptr;
	edb::pid_t pid_;
	std::shared_ptr<QFile> readOnlyMemFile_;
	std::shared_ptr<QFile> readWriteMemFile_;
	QMap<edb::address_t, Patch> patches_;
	QString input_;
	QString output_;
};

}

#endif

```

`plugins/DebuggerCore/unix/linux/PlatformRegion.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformRegion.h"
#include "IDebugEventHandler.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IThread.h"
#include "MemoryRegions.h"
#include "State.h"
#include "edb.h"

#include <QMessageBox>

#include <asm/unistd.h>
#include <sys/mman.h>

namespace DebuggerCorePlugin {

namespace {

/**
 * @brief permissions_value
 * @param read
 * @param write
 * @param execute
 * @return
 */
IRegion::permissions_t permissions_value(bool read, bool write, bool execute) {
	IRegion::permissions_t perms = 0;
	if (read) perms |= PROT_READ;
	if (write) perms |= PROT_WRITE;
	if (execute) perms |= PROT_EXEC;
	return perms;
}

}

template <size_t N>
class BackupInfo : public IDebugEventHandler {
public:
	BackupInfo(edb::address_t address, IRegion::permissions_t perms, PlatformRegion *region);
	~BackupInfo() override;
	BackupInfo(const BackupInfo &) = delete;
	BackupInfo &operator=(const BackupInfo &) = delete;

public:
	IRegion::permissions_t perms() const { return premissions_; }
	bool locked() { return !lock_.testAndSetAcquire(0, 1); }

public:
	bool backup();
	bool restore();

public:
	edb::EventStatus handleEvent(const std::shared_ptr<IDebugEvent> &event) override;

private:
	QAtomicInt lock_ = 1;
	edb::address_t address_;
	IRegion::permissions_t premissions_;
	State state_;
	uint8_t buffer_[N];
	PlatformRegion *const region_;
};

/**
 * @brief BackupInfo<N>::BackupInfo
 * @param address
 * @param perms
 * @param region
 */
template <size_t N>
BackupInfo<N>::BackupInfo(edb::address_t address, IRegion::permissions_t perms, PlatformRegion *region)
	: address_(address), premissions_(perms), region_(region) {
	edb::v1::add_debug_event_handler(this);
}

/**
 * @brief BackupInfo<N>::~BackupInfo
 */
template <size_t N>
BackupInfo<N>::~BackupInfo() {
	edb::v1::remove_debug_event_handler(this);
}

/**
 * @brief BackupInfo<N>::backup
 * @return
 */
template <size_t N>
bool BackupInfo<N>::backup() {

	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			thread->getState(&state_);
		}
		return process->readBytes(address_, buffer_, N);
	}

	return false;
}

/**
 * @brief BackupInfo<N>::restore
 * @return
 */
template <size_t N>
bool BackupInfo<N>::restore() {

	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			thread->setState(state_);
		}

		return process->writeBytes(address_, buffer_, N);
	}

	return false;
}

/**
 * @brief BackupInfo<N>::handleEvent
 * @param event
 * @return
 */
template <size_t N>
edb::EventStatus BackupInfo<N>::handleEvent(const std::shared_ptr<IDebugEvent> &event) {
	Q_UNUSED(event)

	lock_.testAndSetRelease(1, 0);

	// restore the original code and register state
	restore();

	// update permissions mask
	region_->permissions_ = perms();

	// really shouldn't matter since the return value isn't used at all
	// we simply want tot catch the event and set the lock to 0
	return edb::DEBUG_STOP;
}

/**
 * @brief PlatformRegion::PlatformRegion
 * @param start
 * @param end
 * @param base
 * @param name
 * @param permissions
 */
PlatformRegion::PlatformRegion(edb::address_t start, edb::address_t end, edb::address_t base, const QString &name, permissions_t permissions)
	: start_(start), end_(end), base_(base), name_(name), permissions_(permissions) {
}

/**
 * @brief PlatformRegion::clone
 * @return
 */
IRegion *PlatformRegion::clone() const {
	return new PlatformRegion(start_, end_, base_, name_, permissions_);
}

/**
 * @brief PlatformRegion::accessible
 * @return
 */
bool PlatformRegion::accessible() const {
	return readable() || writable() || executable();
}

/**
 * @brief PlatformRegion::readable
 * @return
 */
bool PlatformRegion::readable() const {
	return (permissions_ & PROT_READ) != 0;
}

/**
 * @brief PlatformRegion::writable
 * @return
 */
bool PlatformRegion::writable() const {
	return (permissions_ & PROT_WRITE) != 0;
}

/**
 * @brief PlatformRegion::executable
 * @return
 */
bool PlatformRegion::executable() const {
	return (permissions_ & PROT_EXEC) != 0;
}

/**
 * @brief PlatformRegion::size
 * @return
 */
size_t PlatformRegion::size() const {
	return end_ - start_;
}
/**
 * @brief PlatformRegion::setPermissions
 * @param read
 * @param write
 * @param execute
 */
void PlatformRegion::setPermissions(bool read, bool write, bool execute) {
	edb::address_t temp_address                    = 0;
	int count                                      = 0;
	int ret                                        = QMessageBox::Yes;
	const QList<std::shared_ptr<IRegion>> &regions = edb::v1::memory_regions().regions();

	// search for an executable region to run our shell code
	for (const std::shared_ptr<IRegion> &region : regions) {
		if (region->executable()) {
			if (temp_address == 0) {
				temp_address = region->start();
			}

			if (++count > 1) {
				break;
			}
		}
	}

	if (executable() && count == 1 && !execute) {
		ret = QMessageBox::question(nullptr,
									tr("Removing Execute Permissions On Last Executable std::shared_ptr<IRegion>"),
									tr("You are about to remove execute permissions from the last executable region. Because of the need "
									   "to run code in the process to change permissions, there will be no way to undo this. In addition, "
									   "the process will no longer be able to run as it will have no execute permissions in any regions. "
									   "Odds are this is not what you want to do."
									   "Are you sure you want to remove execute permissions from this region?"),
									QMessageBox::Yes, QMessageBox::No);
	}

	if (ret == QMessageBox::Yes) {
		if (temp_address != 0) {
			setPermissions(read, write, execute, temp_address);
		} else {
			QMessageBox::critical(
				nullptr,
				tr("No Suitable Address Found"),
				tr("This feature relies on running shellcode in the debugged process, no executable memory region was found. Unfortunately, this means that no more region permission changes can be made (it also means that there is nothing the process can continue to do since it cannot execute at all)."));
		}
	}
}

/**
 * @brief PlatformRegion::start
 * @return
 */
edb::address_t PlatformRegion::start() const {
	return start_;
}

/**
 * @brief PlatformRegion::end
 * @return
 */
edb::address_t PlatformRegion::end() const {
	return end_;
}

/**
 * @brief PlatformRegion::base
 * @return
 */
edb::address_t PlatformRegion::base() const {
	return base_;
}

/**
 * @brief PlatformRegion::name
 * @return
 */
QString PlatformRegion::name() const {
	return name_;
}

/**
 * @brief PlatformRegion::permissions
 * @return
 */
IRegion::permissions_t PlatformRegion::permissions() const {
	return permissions_;
}

/**
 * @brief PlatformRegion::setPermissions
 * @param read
 * @param write
 * @param execute
 * @param temp_address
 */
void PlatformRegion::setPermissions(bool read, bool write, bool execute, edb::address_t temp_address) {
	const permissions_t perms = permissions_value(read, write, execute);
	const edb::address_t len  = size();
	const edb::address_t addr = start();

	// I wish there was a clean way to get the value of this system call for either target
	// but nothing obvious comes to mind. We may have to do something crazy
	// with macros, but for now, we just hard code it :-/
	const edb::address_t syscallnum = edb::v1::debuggeeIs32Bit() ? 125 : 10; //__NR_mprotect;

#if defined(EDB_X86) || defined(EDB_X86_64)
	// start of nowhere near portable code
	const uint8_t shellcode32[] = {
		"\xcd\x80" // int $0x80
		"\xf4"     // hlt
	};

	const uint8_t shellcode64[] = {
		"\x0f\x05" // syscall
		"\xf4"     // hlt
	};

	uint8_t shellcode[3];

	if (edb::v1::debuggeeIs32Bit()) {
		memcpy(shellcode, shellcode32, sizeof(shellcode));
	} else {
		memcpy(shellcode, shellcode64, sizeof(shellcode));
	}

	// end nowhere near portable code
	using BI = BackupInfo<sizeof(shellcode)>;
	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			try {
				BI backup_info(temp_address, perms, this);

				if (backup_info.backup()) {
					// write out our shellcode
					if (process->writeBytes(temp_address, shellcode, sizeof(shellcode))) {

						State state;
						thread->getState(&state);
						state.setInstructionPointer(temp_address);

						if (edb::v1::debuggeeIs32Bit()) {
							state.setRegister("ecx", len);
							state.setRegister("ebx", addr);
							state.setRegister("edx", perms);
							state.setRegister("eax", syscallnum);
						} else {
							state.setRegister("rsi", len);
							state.setRegister("rdi", addr);
							state.setRegister("rdx", perms);
							state.setRegister("rax", syscallnum);
						}

						thread->setState(state);

						// run the system call instruction and wait for the trap
						thread->step(edb::DEBUG_CONTINUE);

						// we use a spinlock here because we want to be able to
						// process events while waiting
						while (backup_info.locked()) {
							QCoreApplication::processEvents(QEventLoop::WaitForMoreEvents);
						}
					}
				}
			} catch (const std::bad_alloc &) {
				QMessageBox::critical(
					nullptr,
					tr("Memory Allocation Error"),
					tr("Unable to satisfy memory allocation request for backup code."));
			}
		}
	}
#endif
}

/**
 * @brief PlatformRegion::setStart
 * @param address
 */
void PlatformRegion::setStart(edb::address_t address) {
	start_ = address;
}

/**
 * @brief PlatformRegion::setEnd
 * @param address
 */
void PlatformRegion::setEnd(edb::address_t address) {
	end_ = address;
}

}

```

`plugins/DebuggerCore/unix/linux/PlatformRegion.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_REGION_H_20120330_
#define PLATFORM_REGION_H_20120330_

#include "IRegion.h"
#include <QCoreApplication>
#include <QString>

namespace DebuggerCorePlugin {

class PlatformRegion final : public IRegion {
	Q_DECLARE_TR_FUNCTIONS(PlatformRegion)

	template <size_t N>
	friend class BackupInfo;

public:
	PlatformRegion(edb::address_t start, edb::address_t end, edb::address_t base, const QString &name, permissions_t permissions);
	~PlatformRegion() override = default;

public:
	IRegion *clone() const override;

public:
	bool accessible() const override;
	bool readable() const override;
	bool writable() const override;
	bool executable() const override;
	size_t size() const override;

public:
	void setPermissions(bool read, bool write, bool execute) override;
	void setStart(edb::address_t address) override;
	void setEnd(edb::address_t address) override;

public:
	edb::address_t start() const override;
	edb::address_t end() const override;
	edb::address_t base() const override;
	QString name() const override;
	permissions_t permissions() const override;

private:
	void setPermissions(bool read, bool write, bool execute, edb::address_t temp_address);

private:
	edb::address_t start_;
	edb::address_t end_;
	edb::address_t base_;
	QString name_;
	permissions_t permissions_;
};

}

#endif

```

`plugins/DebuggerCore/unix/linux/PlatformThread.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformThread.h"
#include "DebuggerCore.h"
#include "IProcess.h"
#include "PlatformCommon.h"
#include "util/Container.h"

#include <QDebug>
#include <cassert>

#ifndef _GNU_SOURCE
#define _GNU_SOURCE /* or _BSD_SOURCE or _SVID_SOURCE */
#endif

namespace DebuggerCorePlugin {

/**
 * @brief PlatformThread::PlatformThread
 * @param core
 * @param process
 * @param tid
 */
PlatformThread::PlatformThread(DebuggerCore *core, std::shared_ptr<IProcess> &process, edb::tid_t tid)
	: core_(core), process_(process), tid_(tid) {
	assert(process);
	assert(core);
}

/**
 * @brief PlatformThread::tid
 * @return
 */
edb::tid_t PlatformThread::tid() const {
	return tid_;
}

/**
 * @brief PlatformThread::name
 * @return
 */
QString PlatformThread::name() const {
	struct user_stat thread_stat;
	int n = get_user_task_stat(process_->pid(), tid_, &thread_stat);
	if (n >= 2) {
		return thread_stat.comm;
	}

	return QString();
}

/**
 * @brief PlatformThread::priority
 * @return
 */
int PlatformThread::priority() const {
	struct user_stat thread_stat;
	int n = get_user_task_stat(process_->pid(), tid_, &thread_stat);
	if (n >= 18) {
		return thread_stat.priority;
	}

	return 0;
}

/**
 * @brief PlatformThread::runState
 * @return
 */
QString PlatformThread::runState() const {
	struct user_stat thread_stat;
	int n = get_user_task_stat(process_->pid(), tid_, &thread_stat);
	if (n >= 3) {
		switch (thread_stat.state) { // 03
		case 'R':
			return tr("%1 (Running)").arg(thread_stat.state);
		case 'S':
			return tr("%1 (Sleeping)").arg(thread_stat.state);
		case 'D':
			return tr("%1 (Disk Sleep)").arg(thread_stat.state);
		case 'T':
			return tr("%1 (Stopped)").arg(thread_stat.state);
		case 't':
			return tr("%1 (Tracing Stop)").arg(thread_stat.state);
		case 'Z':
			return tr("%1 (Zombie)").arg(thread_stat.state);
		case 'X':
		case 'x':
			return tr("%1 (Dead)").arg(thread_stat.state);
		case 'W':
			return tr("%1 (Waking/Paging)").arg(thread_stat.state);
		case 'K':
			return tr("%1 (Wakekill)").arg(thread_stat.state);
		case 'P':
			return tr("%1 (Parked)").arg(thread_stat.state);
		default:
			return tr("%1").arg(thread_stat.state);
		}
	}

	return tr("Unknown");
}

/**
 * resumes this thread, passing the signal that stopped it
 * (unless the signal was SIGSTOP)
 *
 * @brief PlatformThread::resume
 * @return
 */
Status PlatformThread::resume() {
	return core_->ptraceContinue(tid_, resume_code(status_));
}

/**
 * resumes this thread, passing the signal that stopped it
 * (unless the signal was SIGSTOP, or the passed status != DEBUG_EXCEPTION_NOT_HANDLED)
 * @brief PlatformThread::resume
 * @param status
 * @return
 */
Status PlatformThread::resume(edb::EventStatus status) {
	const int code = (status == edb::DEBUG_EXCEPTION_NOT_HANDLED) ? resume_code(status_) : 0;
	return core_->ptraceContinue(tid_, code);
}

/**
 * @brief PlatformThread::isPaused
 * @return true if this thread is currently in the debugger's wait list
 */
bool PlatformThread::isPaused() const {
	return util::contains(core_->waitedThreads_, tid_);
}

}

```

`plugins/DebuggerCore/unix/linux/PlatformThread.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_THREAD_H_20151013_
#define PLATFORM_THREAD_H_20151013_

#include "IBreakpoint.h"
#include "IThread.h"
#include <QCoreApplication>
#include <memory>

class IProcess;

namespace DebuggerCorePlugin {

class DebuggerCore;
class PlatformState;

class PlatformThread final : public IThread {
	Q_DECLARE_TR_FUNCTIONS(PlatformThread)
	friend class DebuggerCore;

public:
	PlatformThread(DebuggerCore *core, std::shared_ptr<IProcess> &process, edb::tid_t tid);
	~PlatformThread() override             = default;
	PlatformThread(const PlatformThread &) = delete;
	PlatformThread &operator=(const PlatformThread &) = delete;

public:
	edb::tid_t tid() const override;
	QString name() const override;
	int priority() const override;
	edb::address_t instructionPointer() const override;
	QString runState() const override;

public:
	void getState(State *state) override;
	void setState(const State &state) override;

public:
	Status step() override;
	Status step(edb::EventStatus status) override;
	Status resume() override;
	Status resume(edb::EventStatus status) override;

public:
	bool isPaused() const override;

private:
	void fillSegmentBases(PlatformState *state);
	bool fillStateFromPrStatus(PlatformState *state);
	bool fillStateFromSimpleRegs(PlatformState *state);
#if defined(EDB_ARM32)
	bool fillStateFromVFPRegs(PlatformState *state);
#endif

private:
	unsigned long getDebugRegister(std::size_t n);
	long setDebugRegister(std::size_t n, unsigned long value);

private:
	DebuggerCore *core_ = nullptr;
	std::shared_ptr<IProcess> process_;
	edb::tid_t tid_;
	int status_ = 0;

#if defined(EDB_ARM32) || defined(EDB_ARM64)
private:
	Status doStep(edb::tid_t tid, long status);
	std::shared_ptr<IBreakpoint> singleStepBreakpoint;
#endif
};

}

#endif

```

`plugins/DebuggerCore/unix/linux/PrStatus.h`:

```h

#ifndef PR_STATUS_H_20191119_
#define PR_STATUS_H_20191119_

#include <cstdint>

struct PrStatus_X86 {
	uint32_t ebx;
	uint32_t ecx;
	uint32_t edx;
	uint32_t esi;
	uint32_t edi;
	uint32_t ebp;
	uint32_t eax;
	uint32_t ds;
	uint32_t es;
	uint32_t fs;
	uint32_t gs;
	uint32_t orig_eax;
	uint32_t eip;
	uint32_t cs;
	uint32_t eflags;
	uint32_t esp;
	uint32_t ss;
};

static_assert(sizeof(PrStatus_X86) == 68, "PrStatus_X86 is messed up!");

struct PrStatus_X86_64 {
	uint64_t r15;
	uint64_t r14;
	uint64_t r13;
	uint64_t r12;
	uint64_t rbp;
	uint64_t rbx;
	uint64_t r11;
	uint64_t r10;
	uint64_t r9;
	uint64_t r8;
	uint64_t rax;
	uint64_t rcx;
	uint64_t rdx;
	uint64_t rsi;
	uint64_t rdi;
	uint64_t orig_rax;
	uint64_t rip;
	uint64_t cs;
	uint64_t rflags;
	uint64_t rsp;
	uint64_t ss;
	uint64_t fs_base;
	uint64_t gs_base;
	uint64_t ds;
	uint64_t es;
	uint64_t fs;
	uint64_t gs;
};

static_assert(sizeof(PrStatus_X86_64) == 216, "PrStatus_X86_64 is messed up!");

struct PrStatus_ARM {
	uint32_t regs[18];
};

static_assert(sizeof(PrStatus_ARM) == 72, "PrStatus_ARM is messed up!");

#endif

```

`plugins/DebuggerCore/unix/linux/arch/arm-generic/PlatformState.cpp`:

```cpp
/*
Copyright (C) 2017 Ruslan Kabatsayev
                   b7.10110111@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformState.h"

namespace DebuggerCorePlugin {

const std::array<PlatformState::GPR::RegNameVariants, GPR_COUNT> PlatformState::GPR::GPRegNames = {
	RegNameVariants{"r0", "a1"},
	RegNameVariants{"r1", "a2"},
	RegNameVariants{"r2", "a3"},
	RegNameVariants{"r3", "a4"},
	RegNameVariants{"r4", "v1"},
	RegNameVariants{"r5", "v2"},
	RegNameVariants{"r6", "v3"},
	RegNameVariants{"r7", "v4"},
	RegNameVariants{"r8", "v5"},
	RegNameVariants{"r9", "sb", "v6"},
	RegNameVariants{"r10", "sl", "v7"},
	RegNameVariants{"r11", "fp", "v8"},
	RegNameVariants{"r12", "ip", "v6"},
	RegNameVariants{"sp", "r13"},
	RegNameVariants{"lr", "r14"},
	RegNameVariants{"pc", "r15"}};

/**
 * @brief PlatformState::PlatformState
 */
PlatformState::PlatformState() {
	clear();
}

/**
 * @brief PlatformState::clone
 * @return
 */
std::unique_ptr<IState> PlatformState::clone() const {
	auto copy = std::make_unique<PlatformState>();
	copy->gpr = gpr;
	return copy;
}

/**
 * @brief PlatformState::flagsToString
 * @return
 */
QString PlatformState::flagsToString() const {
	return flagsToString(flagsRegister().valueAsInteger());
}

/**
 * @brief PlatformState::flagsToString
 * @param flags
 * @return
 */
QString PlatformState::flagsToString(edb::reg_t flags) const {
	return "flags string"; // FIXME: stub
}

/**
 * @brief PlatformState::findGPR
 * @param name
 */
auto PlatformState::findGPR(QString const &name) const -> decltype(gpr.GPRegNames.begin()) {

	return std::find_if(GPR::GPRegNames.begin(), GPR::GPRegNames.end(), [&name](const GPR::RegNameVariants &variants) {
		for (const char *const var : variants) {
			if (var == name) {
				return true;
			}
		}
		return false;
	});
}

/**
 * @brief PlatformState::value
 * @param reg
 * @return
 */
Register PlatformState::value(const QString &reg) const {
	const QString name = reg.toLower();
	if (name == "cpsr") {
		return flagsRegister();
	}

	if (vfp.filled && name == "fpscr") {
		return make_Register<32>("fpscr", vfp.fpscr, Register::TYPE_FPU);
	}

	const auto gprFoundIt = findGPR(name);
	if (gprFoundIt != GPR::GPRegNames.end()) {
		return gpRegister(gprFoundIt - GPR::GPRegNames.begin());
	}

	return Register();
}

/**
 * @brief PlatformState::instructionPointerRegister
 * @return
 */
Register PlatformState::instructionPointerRegister() const {
#ifdef EDB_ARM32
	return gpRegister(GPR::PC);
#else
	return Register(); // FIXME: stub
#endif
}

/**
 * @brief PlatformState::flagsRegister
 * @return
 */
Register PlatformState::flagsRegister() const {
#ifdef EDB_ARM32
	if (!gpr.filled)
		return Register();
	return make_Register<32>("cpsr", gpr.cpsr, Register::TYPE_GPR);
#else
	return Register(); // FIXME: stub
#endif
}

/**
 * @brief PlatformState::framePointer
 * @return
 */
edb::address_t PlatformState::framePointer() const {
	return gpr.GPRegs[GPR::FP];
}

/**
 * @brief PlatformState::instructionPointer
 * @return
 */
edb::address_t PlatformState::instructionPointer() const {
	return gpr.GPRegs[GPR::PC];
}

/**
 * @brief PlatformState::stackPointer
 * @return
 */
edb::address_t PlatformState::stackPointer() const {
	return gpr.GPRegs[GPR::SP];
}

/**
 * @brief PlatformState::debugRegister
 * @param n
 * @return
 */
edb::reg_t PlatformState::debugRegister(size_t n) const {
	return 0; // FIXME: stub
}

/**
 * @brief PlatformState::flags
 * @return
 */
edb::reg_t PlatformState::flags() const {
	return gpr.cpsr;
}

/**
 * @brief PlatformState::adjustStack
 * @param bytes
 */
void PlatformState::adjustStack(int bytes) {
	gpr.GPRegs[GPR::SP] += bytes;
}

/**
 * @brief PlatformState::clear
 */
void PlatformState::clear() {
	gpr.clear();
}

/**
 * @brief PlatformState::empty
 * @return
 */
bool PlatformState::empty() const {
	return gpr.empty();
}

/**
 * @brief PlatformState::GPR::empty
 * @return
 */
bool PlatformState::GPR::empty() const {
	return !filled;
}

/**
 * @brief PlatformState::GPR::clear
 */
void PlatformState::GPR::clear() {
	util::mark_memory(this, sizeof(*this));
	filled = false;
}

/**
 * @brief PlatformState::setDebugRegister
 * @param n
 * @param value
 */
void PlatformState::setDebugRegister(size_t n, edb::reg_t value) {
	// FIXME: stub
}

/**
 * @brief PlatformState::setFlags
 * @param flags
 */
void PlatformState::setFlags(edb::reg_t flags) {
	gpr.cpsr = flags;
}

/**
 * @brief PlatformState::setInstructionPointer
 * @param value
 */
void PlatformState::setInstructionPointer(edb::address_t value) {
	gpr.GPRegs[GPR::PC] = value;
}

/**
 * @brief PlatformState::setRegister
 * @param reg
 */
void PlatformState::setRegister(const Register &reg) {
	if (!reg) {
		return;
	}

	const QString name = reg.name().toLower();
	if (name == "cpsr") {
		setFlags(reg.value<edb::reg_t>());
		return;
	}

	if (name == "fpscr") {
		vfp.fpscr = reg.value<decltype(vfp.fpscr)>();
		return;
	}

	const auto gprFoundIt = findGPR(name);
	if (gprFoundIt != GPR::GPRegNames.end()) {
		const auto index = gprFoundIt - GPR::GPRegNames.begin();
		assert(index < 16);
		gpr.GPRegs[index] = reg.value<edb::reg_t>();
		return;
	}
}

/**
 * @brief PlatformState::setRegister
 * @param name
 * @param value
 */
void PlatformState::setRegister(const QString &name, edb::reg_t value) {
#ifdef EDB_ARM32
	const QString regName = name.toLower();
	setRegister(make_Register<32>(regName, value, Register::TYPE_GPR));
	// FIXME: this doesn't take into account any 64-bit registers - possibly FPU data?
#endif
}

/**
 * @brief PlatformState::gpRegister
 * @param n
 * @return
 */
Register PlatformState::gpRegister(size_t n) const {
#ifdef EDB_ARM32
	if (n < GPR::GPRegNames.size())
		return make_Register<32>(gpr.GPRegNames[n].front(), gpr.GPRegs[n], Register::TYPE_GPR);
	return Register();
#else
	return Register(); // FIXME: stub
#endif
}

/**
 * @brief PlatformState::fillFrom
 * @param regs
 */
void PlatformState::fillFrom(user_regs const &regs) {
	for (unsigned i = 0; i < gpr.GPRegs.size(); ++i) {
		gpr.GPRegs[i] = regs.uregs[i];
	}

	gpr.cpsr   = regs.uregs[16];
	gpr.filled = true;
}

/**
 * @brief PlatformState::fillFrom
 * @param regs
 */
void PlatformState::fillFrom(user_vfp const &regs) {
	for (unsigned i = 0; i < vfp.d.size(); ++i) {
		vfp.d[i] = regs.fpregs[i];
	}

	vfp.fpscr  = regs.fpscr;
	vfp.filled = true;
}

/**
 * @brief PlatformState::fillStruct
 * @param regs
 */
void PlatformState::fillStruct(user_regs &regs) const {
	util::mark_memory(&regs, sizeof(regs));
	if (gpr.filled) {
		for (unsigned i = 0; i < gpr.GPRegs.size(); ++i) {
			regs.uregs[i] = gpr.GPRegs[i];
		}

		regs.uregs[16] = gpr.cpsr;
		// FIXME: uregs[17] is not filled
	}
}

/**
 * @brief PlatformState::fillStruct
 * @param regs
 */
void PlatformState::fillStruct(user_vfp &regs) const {
	util::mark_memory(&regs, sizeof(regs));
	if (vfp.filled) {
		for (unsigned i = 0; i < vfp.d.size(); ++i) {
			regs.fpregs[i] = vfp.d[i];
		}

		regs.fpscr = vfp.fpscr;
	}
}

}

```

`plugins/DebuggerCore/unix/linux/arch/arm-generic/PlatformState.h`:

```h
/*
Copyright (C) 2017 Ruslan Kabatsayev
                   b7.1010111@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_STATE_H_20170806_
#define PLATFORM_STATE_H_20170806_

#include "IState.h"
#include "PrStatus.h"
#include "Types.h"
#include "edb.h"
#include <cstddef>
#include <sys/user.h>
#include <vector>

namespace DebuggerCorePlugin {

using std::size_t;
static constexpr size_t GPR_COUNT  = 16;
static constexpr size_t VFPR_COUNT = 32;

struct user_vfp {
	unsigned long long fpregs[32];
	unsigned long fpscr;
};

class PlatformState final : public IState {
	Q_DECLARE_TR_FUNCTIONS(PlatformThread)
	friend class DebuggerCore;
	friend class PlatformThread;

public:
	PlatformState();

public:
	std::unique_ptr<IState> clone() const override;

	QString flagsToString() const override;
	QString flagsToString(edb::reg_t flags) const override;
	Register value(const QString &reg) const override;
	Register instructionPointerRegister() const override;
	Register flagsRegister() const override;
	edb::address_t framePointer() const override;
	edb::address_t instructionPointer() const override;
	edb::address_t stackPointer() const override;
	edb::reg_t debugRegister(size_t n) const override;
	edb::reg_t flags() const override;
	void adjustStack(int bytes) override;
	void clear() override;
	bool empty() const override;
	void setDebugRegister(size_t n, edb::reg_t value) override;
	void setFlags(edb::reg_t flags) override;
	void setInstructionPointer(edb::address_t value) override;
	void setRegister(const Register &reg) override;
	void setRegister(const QString &name, edb::reg_t value) override;
	Register gpRegister(size_t n) const override;

	Register archRegister(uint64_t type, size_t n) const override {
		return Register();
	}

	void fillFrom(const user_regs &regs);
	void fillFrom(const user_vfp &regs);
	void fillStruct(user_regs &regs) const;
	void fillStruct(user_vfp &regs) const;

private:
	struct GPR {
		enum NamedGPRIndex : size_t {
			SB = 9,  // historical name, but still printed by modern disassemblers
			SL = 10, // historical name, but still printed by modern disassemblers
			FP = 11, // conventionally, but much like rBP on x86
			IP = 12, // conventionally, intra-procedure scratch register
			SP = 13,
			LR = 14,
			PC = 15,
		};
		using RegNameVariants = std::vector<const char *>;
		static const std::array<RegNameVariants, GPR_COUNT> GPRegNames;

		bool filled = false;
		std::array<edb::reg_t, GPR_COUNT> GPRegs;
		edb::reg_t cpsr;

	public:
		void clear();
		bool empty() const;
	} gpr;
	struct VFP {
		std::array<edb::value64, VFPR_COUNT> d;
		edb::value32 fpscr;
		bool filled = false;
	} vfp;

private:
	auto findGPR(const QString &name) const -> decltype(gpr.GPRegNames.begin());
};

}

#endif

```

`plugins/DebuggerCore/unix/linux/arch/arm-generic/PlatformThread.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com
Copyright (C) 2017 Ruslan Kabatsayev
                   b7.10110111@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformThread.h"
#include "ArchProcessor.h"
#include "Breakpoint.h"
#include "DebuggerCore.h"
#include "IProcess.h"
#include "Instruction.h"
#include "PlatformCommon.h"
#include "PlatformState.h"
#include "State.h"
#include "Types.h"
#include <QtDebug>

#ifndef _GNU_SOURCE
#define _GNU_SOURCE /* or _BSD_SOURCE or _SVID_SOURCE */
#endif

#include <elf.h>
#include <linux/uio.h>
#include <sys/ptrace.h>
#include <sys/user.h>

// doesn't always seem to be defined in the headers
#ifndef PTRACE_GET_THREAD_AREA
#define PTRACE_GET_THREAD_AREA static_cast<__ptrace_request>(22)
#endif

#ifndef PTRACE_GETSIGINFO
#define PTRACE_GETSIGINFO static_cast<__ptrace_request>(0x4202)
#endif

#ifndef PTRACE_GETREGSET
#define PTRACE_GETREGSET static_cast<__ptrace_request>(0x4204)
#endif

#ifndef PTRACE_SETREGSET
#define PTRACE_SETREGSET static_cast<__ptrace_request>(0x4205)
#endif

#ifndef PTRACE_GETWMMXREGS
#define PTRACE_GETWMMXREGS static_cast<__ptrace_request>(18)
#define PTRACE_SETWMMXREGS static_cast<__ptrace_request>(19)
#endif

#ifndef PTRACE_GETVFPREGS
#define PTRACE_GETVFPREGS static_cast<__ptrace_request>(27)
#define PTRACE_SETVFPREGS static_cast<__ptrace_request>(28)
#endif

#ifndef PTRACE_GETHBPREGS
#define PTRACE_GETHBPREGS static_cast<__ptrace_request>(29)
#define PTRACE_SETHBPREGS static_cast<__ptrace_request>(30)
#endif

namespace DebuggerCorePlugin {

/**
 * @brief PlatformThread::fillStateFromPrStatus
 * @param state
 * @return
 */
bool PlatformThread::fillStateFromPrStatus(PlatformState *state) {

	return false;
}

/**
 * @brief PlatformThread::fillStateFromSimpleRegs
 * @param state
 * @return
 */
bool PlatformThread::fillStateFromSimpleRegs(PlatformState *state) {

	user_regs regs;
	if (ptrace(PTRACE_GETREGS, tid_, 0, &regs) != -1) {

		state->fillFrom(regs);
		return true;
	} else {
		perror("PTRACE_GETREGS failed");
		return false;
	}
}

/**
 * @brief PlatformThread::fillStateFromVFPRegs
 * @param state
 * @return
 */
bool PlatformThread::fillStateFromVFPRegs(PlatformState *state) {

	user_vfp fpr;
	if (ptrace(PTRACE_GETVFPREGS, tid_, 0, &fpr) != -1) {
		for (unsigned i = 0; i < sizeof fpr.fpregs / sizeof *fpr.fpregs; ++i)
			state->fillFrom(fpr);
		return true;
	} else {
		perror("PTRACE_GETVFPREGS failed");
		return false;
	}
}

/**
 * @brief PlatformThread::getState
 * @param state
 */
void PlatformThread::getState(State *state) {
	// TODO: assert that we are paused

	core_->detectCpuMode();

	if (auto state_impl = static_cast<PlatformState *>(state->impl_.get())) {

		fillStateFromSimpleRegs(state_impl);
		fillStateFromVFPRegs(state_impl);
	}
}

/**
 * @brief PlatformThread::setState
 * @param state
 */
void PlatformThread::setState(const State &state) {

	// TODO: assert that we are paused

	if (auto state_impl = static_cast<PlatformState *>(state.impl_.get())) {

		user_regs regs;
		state_impl->fillStruct(regs);
		if (ptrace(PTRACE_SETREGS, tid_, 0, &regs) == -1) {
			perror("PTRACE_SETREGS failed");
		}

		user_vfp fpr;
		state_impl->fillStruct(fpr);
		if (ptrace(PTRACE_SETVFPREGS, tid_, 0, &fpr) == -1) {
			perror("PTRACE_SETVFPREGS failed");
		}
	}
}

/**
 * @brief PlatformThread::getDebugRegister
 * @param n
 * @return
 */
unsigned long PlatformThread::getDebugRegister(std::size_t n) {
	return 0;
}

/**
 * @brief PlatformThread::setDebugRegister
 * @param n
 * @param value
 * @return
 */
long PlatformThread::setDebugRegister(std::size_t n, long value) {
	return 0;
}

/**
 * @brief PlatformThread::instructionPointer
 * @return
 */
edb::address_t PlatformThread::instructionPointer() const {
	return 0;
}

/**
 * @brief PlatformThread::doStep
 * @param tid
 * @param status
 * @return
 */
Status PlatformThread::doStep(const edb::tid_t tid, const long status) {

	constexpr auto AddressSize = 4; // The code here is ARM32-specific anyway...

	State state;
	getState(&state);
	if (state.empty()) return Status(tr("failed to get thread state."));
	const auto pc    = state.instructionPointer();
	const auto flags = state.flags();
	enum {
		CPSR_Tbit = 1 << 5,

		CPSR_ITbits72 = 1 << 10,
		CPSR_ITmask72 = 0xfc00,

		CPSR_Jbit = 1 << 24,

		CPSR_ITbits10 = 1 << 25,
		CPSR_ITmask10 = 0x06000000,
	};
	if (flags & CPSR_Jbit)
		return Status(tr("EDB doesn't yet support single-stepping in Jazelle state."));
	if (flags & CPSR_Tbit && flags & (CPSR_ITmask10 | CPSR_ITmask72))
		return Status(tr("EDB doesn't yet support single-stepping inside Thumb-2 IT-block."));
	quint8 buffer[4];
	if (const int size = edb::v1::get_instruction_bytes(pc, buffer)) {
		if (const auto insn = edb::Instruction(buffer, buffer + size, pc)) {

			const auto op                = insn.operation();
			edb::address_t addrAfterInsn = pc + insn.byteSize();

			auto targetMode = core_->cpuMode();
			if (modifies_pc(insn) && edb::v1::arch_processor().isExecuted(insn, state)) {
				if (op == ARM_INS_BXJ)
					return Status(tr("EDB doesn't yet support single-stepping into Jazelle state."));

				const auto opCount = insn.operandCount();
				if (opCount == 0)
					return Status(tr("instruction %1 isn't supported yet.").arg(insn.mnemonic().c_str()));

				switch (op) {
				case ARM_INS_LDR: {
					const auto destOperand = insn.operand(0);
					if (!is_register(destOperand) || destOperand->reg != ARM_REG_PC)
						return Status(tr("instruction %1 with non-PC destination isn't supported yet.").arg(insn.mnemonic().c_str()));
					const auto srcOperand = insn.operand(1);
					if (!is_expression(srcOperand))
						return Status(tr("unexpected type of second operand of LDR instruction."));
					const auto effAddrR = edb::v1::arch_processor().getEffectiveAddress(insn, srcOperand, state);
					if (!effAddrR) return Status(effAddrR.error());

					const auto effAddr = effAddrR.value();
					if (process_->readBytes(effAddr, &addrAfterInsn, AddressSize) != AddressSize)
						return Status(tr("failed to read memory referred to by LDR operand (address %1).").arg(effAddr.toPointerString()));

					// FIXME: for ARMv5 or below (without "T" in the name) bits [1:0] are simply ignored, without any mode change
					if (addrAfterInsn & 1)
						targetMode = IDebugger::CpuMode::Thumb;
					else
						targetMode = IDebugger::CpuMode::ARM32;
					switch (edb::v1::debugger_core->cpuMode()) {
					case IDebugger::CpuMode::Thumb:
						addrAfterInsn &= -2;
						break;
					case IDebugger::CpuMode::ARM32:
						addrAfterInsn &= -4;
						break;
					default:
						return Status(tr("single-stepping LDR instruction in modes other than ARM or Thumb is not supported yet."));
					}
					break;
				}
				case ARM_INS_POP: {
					int i = 0;
					for (; i < opCount; ++i) {
						const auto operand = insn.operand(i);
						if (is_register(operand) && operand->reg == ARM_REG_PC) {
#if CS_API_MAJOR >= 4
							assert(operand->access == CS_AC_WRITE);
#endif
							const auto sp = state.gpRegister(PlatformState::GPR::SP);
							if (!sp) return Status(tr("failed to get value of SP register"));
							if (process_->readBytes(sp.valueAsAddress() + AddressSize * i, &addrAfterInsn, AddressSize) != AddressSize)
								return Status(tr("failed to read thread stack"));
							break;
						}
					}
					if (i == opCount)
						return Status(tr("internal EDB error: failed to locate PC in the instruction operand list"));
					break;
				}
				case ARM_INS_BX:
				case ARM_INS_BLX:
				case ARM_INS_B:
				case ARM_INS_BL: {
					if (opCount != 1)
						return Status(tr("unexpected form of instruction %1 with %2 operands.").arg(insn.mnemonic().c_str()).arg(opCount));
					const auto &operand = insn.operand(0);
					assert(operand);
					if (is_immediate(operand)) {
						addrAfterInsn = edb::address_t(util::to_unsigned(operand->imm));
						if (op == ARM_INS_BX || op == ARM_INS_BLX) {
							if (targetMode == IDebugger::CpuMode::ARM32)
								targetMode = IDebugger::CpuMode::Thumb;
							else
								targetMode = IDebugger::CpuMode::ARM32;
						}
						break;
					} else if (is_register(operand)) {
						if (operand->reg == ARM_REG_PC && (op == ARM_INS_BX || op == ARM_INS_BLX))
							return Status(tr("unpredictable instruction"));
						// This may happen only with BX or BLX: B and BL require an immediate operand
						const auto result = edb::v1::arch_processor().getEffectiveAddress(insn, operand, state);
						if (!result) return Status(result.error());
						addrAfterInsn = result.value();
						if (addrAfterInsn & 1)
							targetMode = IDebugger::CpuMode::Thumb;
						else
							targetMode = IDebugger::CpuMode::ARM32;
						addrAfterInsn &= ~1;
						if (addrAfterInsn & 0x3 && targetMode != IDebugger::CpuMode::Thumb)
							return Status(tr("won't try to set breakpoint at unaligned address"));
						break;
					}
					return Status(tr("bad operand for %1 instruction.").arg(insn.mnemonic().c_str()));
				}
				default:
					return Status(tr("instruction %1 modifies PC, but isn't a branch instruction known to EDB's single-stepper.").arg(insn.mnemonic().c_str()));
				}
			}

			if (singleStepBreakpoint)
				return Status(tr("internal EDB error: single-step breakpoint still present"));
			if (const auto oldBP = core_->findBreakpoint(addrAfterInsn)) {
				// TODO: EDB should support overlapping breakpoints
				if (!oldBP->enabled())
					return Status(tr("a disabled breakpoint is present at address %1, can't set one for single step.").arg(addrAfterInsn.toPointerString()));
			} else {
				singleStepBreakpoint = core_->addBreakpoint(addrAfterInsn);
				if (!singleStepBreakpoint)
					return Status(tr("failed to set breakpoint at address %1.").arg(addrAfterInsn.toPointerString()));
				const auto bp = std::static_pointer_cast<Breakpoint>(singleStepBreakpoint);
				if (targetMode != core_->cpuMode()) {
					switch (targetMode) {
					case IDebugger::CpuMode::ARM32:
						bp->setType(Breakpoint::TypeId::ARM32);
						break;
					case IDebugger::CpuMode::Thumb:
						bp->setType(Breakpoint::TypeId::Thumb2Byte);
						break;
					}
				}
				singleStepBreakpoint->setOneTime(true); // TODO: don't forget to remove it once we've paused after this, even if the BP wasn't hit (e.g. due to an exception on current instruction)
				singleStepBreakpoint->setInternal(true);
			}
			return core_->ptraceContinue(tid, status);
		}
		return Status(tr("failed to disassemble instruction at address %1.").arg(pc.toPointerString()));
	}
	return Status(tr("failed to get instruction bytes at address %1.").arg(pc.toPointerString()));
}

/**
 * steps this thread one instruction, passing the signal that stopped it
 * (unless the signal was SIGSTOP)
 *
 * @brief PlatformThread::step
 * @return
 */
Status PlatformThread::step() {
	return doStep(tid_, resume_code(status_));
}

/**
 * steps this thread one instruction, passing the signal that stopped it
 * (unless the signal was SIGSTOP, or the passed status != DEBUG_EXCEPTION_NOT_HANDLED)
 *
 * @brief PlatformThread::step
 * @param status
 * @return
 */
Status PlatformThread::step(edb::EVENT_STATUS status) {
	const int code = (status == edb::DEBUG_EXCEPTION_NOT_HANDLED) ? resume_code(status_) : 0;
	return doStep(tid_, code);
}

}

```

`plugins/DebuggerCore/unix/linux/arch/x86-generic/PlatformState.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformState.h"
#include "FloatX.h"
#include "Util.h"
#include "string_hash.h"
#include <QDebug>
#include <QRegExp>
#include <unordered_map>

namespace DebuggerCorePlugin {

constexpr const char *PlatformState::AVX::mxcsrName;
constexpr const char *PlatformState::X86::IP64Name;
constexpr const char *PlatformState::X86::IP32Name;
constexpr const char *PlatformState::X86::IP16Name;
constexpr const char *PlatformState::X86::origEAXName;
constexpr const char *PlatformState::X86::origRAXName;
constexpr const char *PlatformState::X86::flags64Name;
constexpr const char *PlatformState::X86::flags32Name;
constexpr const char *PlatformState::X86::flags16Name;

const std::array<const char *, MAX_GPR_COUNT> PlatformState::X86::GPReg64Names = {
	"rax",
	"rcx",
	"rdx",
	"rbx",
	"rsp",
	"rbp",
	"rsi",
	"rdi",
	"r8",
	"r9",
	"r10",
	"r11",
	"r12",
	"r13",
	"r14",
	"r15",
};

const std::array<const char *, MAX_GPR_COUNT> PlatformState::X86::GPReg32Names = {
	"eax",
	"ecx",
	"edx",
	"ebx",
	"esp",
	"ebp",
	"esi",
	"edi",
	"r8d",
	"r9d",
	"r10d",
	"r11d",
	"r12d",
	"r13d",
	"r14d",
	"r15d",
};

const std::array<const char *, MAX_GPR_COUNT> PlatformState::X86::GPReg16Names = {
	"ax",
	"cx",
	"dx",
	"bx",
	"sp",
	"bp",
	"si",
	"di",
	"r8w",
	"r9w",
	"r10w",
	"r11w",
	"r12w",
	"r13w",
	"r14w",
	"r15w",
};

const std::array<const char *, MAX_GPR_LOW_ADDRESSABLE_COUNT> PlatformState::X86::GPReg8LNames = {
	"al",
	"cl",
	"dl",
	"bl",
	"spl",
	"bpl",
	"sil",
	"dil",
	"r8b",
	"r9b",
	"r10b",
	"r11b",
	"r12b",
	"r13b",
	"r14b",
	"r15b",
};

const std::array<const char *, MAX_GPR_HIGH_ADDRESSABLE_COUNT> PlatformState::X86::GPReg8HNames = {
	"ah",
	"ch",
	"dh",
	"bh",
};

const std::array<const char *, MAX_SEG_REG_COUNT> PlatformState::X86::segRegNames = {
	"es",
	"cs",
	"ss",
	"ds",
	"fs",
	"gs",
};

void PlatformState::fillFrom(const UserRegsStructX86 &regs) {

	// Don't touch higher parts to avoid zeroing out bad value mark, so use load
	x86.GPRegs[X86::EAX].load(regs.eax);
	x86.GPRegs[X86::ECX].load(regs.ecx);
	x86.GPRegs[X86::EDX].load(regs.edx);
	x86.GPRegs[X86::EBX].load(regs.ebx);
	x86.GPRegs[X86::ESP].load(regs.esp);
	x86.GPRegs[X86::EBP].load(regs.ebp);
	x86.GPRegs[X86::ESI].load(regs.esi);
	x86.GPRegs[X86::EDI].load(regs.edi);
	x86.orig_ax.load(regs.orig_eax);
	x86.flags.load(regs.eflags);
	x86.IP.load(regs.eip);

	x86.segRegs[X86::ES] = regs.xes;
	x86.segRegs[X86::CS] = regs.xcs;
	x86.segRegs[X86::SS] = regs.xss;
	x86.segRegs[X86::DS] = regs.xds;
	x86.segRegs[X86::FS] = regs.xfs;
	x86.segRegs[X86::GS] = regs.xgs;
	x86.gpr32Filled      = true;
}

size_t PlatformState::X87::stackPointer() const {
	return (statusWord & 0x3800) >> 11;
}

size_t PlatformState::X87::RIndexToSTIndex(size_t n) const {
	n = (n + 8 - stackPointer()) % 8;
	return n;
}

size_t PlatformState::X87::STIndexToRIndex(size_t n) const {
	n = (n + stackPointer()) % 8;
	return n;
}

int PlatformState::X87::recreateTag(edb::value80 value) const {
	switch (float_type(value)) {
	case FloatValueClass::Zero:
		return TAG_ZERO;
	case FloatValueClass::Normal:
		return TAG_VALID;
	default:
		return TAG_SPECIAL;
	}
}

edb::value80 PlatformState::X87::st(size_t n) const {
	return R[STIndexToRIndex(n)];
}

edb::value80 &PlatformState::X87::st(size_t n) {
	return R[STIndexToRIndex(n)];
}

int PlatformState::X87::makeTag(size_t n, uint16_t twd) const {
	int minitag = (twd >> n) & 0x1;
	return minitag ? recreateTag(R[n]) : TAG_EMPTY;
}

int PlatformState::X87::tag(size_t n) const {
	return (tagWord >> (2 * n)) & 0x3;
}

edb::value16 PlatformState::X87::restoreTagWord(uint16_t twd) const {
	uint16_t tagWord = 0;
	for (size_t n = 0; n < MAX_FPU_REG_COUNT; ++n) {
		tagWord |= makeTag(n, twd) << (2 * n);
	}

	return edb::value16(tagWord);
}

std::uint16_t PlatformState::X87::reducedTagWord() const {
	// Algorithm is the same as in linux/arch/x86/kernel/i387.c: twd_i387_to_fxsr()

	// Transforming each pair of bits into 01 (valid) or 00 (empty)
	unsigned int result = ~tagWord;
	result              = (result | (result >> 1)) & 0x5555; // 0102030405060708

	// moving the valid bits to the lower byte
	result = (result | (result >> 1)) & 0x3333; // 0012003400560078
	result = (result | (result >> 2)) & 0x0f0f; // 0000123400005678
	result = (result | (result >> 4)) & 0x00ff; // 0000000012345678

	return result;
}

void PlatformState::fillFrom(const UserFPRegsStructX86 &regs) {
	x87.statusWord = regs.swd; // should be first for RIndexToSTIndex() to work

	for (size_t n = 0; n < MAX_FPU_REG_COUNT; ++n) {
		x87.R[n] = edb::value80(regs.st_space, 10 * x87.RIndexToSTIndex(n));
	}

	x87.controlWord     = regs.cwd;
	x87.tagWord         = regs.twd; // This is the true tag word, unlike in FPX regs and x86-64 FP regs structs
	x87.instPtrOffset   = edb::address_t::fromZeroExtended(regs.fip);
	x87.dataPtrOffset   = edb::address_t::fromZeroExtended(regs.foo);
	x87.instPtrSelector = regs.fcs;
	x87.dataPtrSelector = regs.fos;
	x87.opCode          = 0; // not present in the given structure
	x87.filled          = true;
}

void PlatformState::fillFrom(const UserFPXRegsStructX86 &regs) {
	x87.statusWord = regs.swd; // should be first for RIndexToSTIndex() to work

	for (size_t n = 0; n < MAX_FPU_REG_COUNT; ++n) {
		x87.R[n] = edb::value80(regs.st_space, 16 * x87.RIndexToSTIndex(n));
	}

	x87.controlWord     = regs.cwd;
	x87.tagWord         = x87.restoreTagWord(regs.twd);
	x87.instPtrOffset   = edb::address_t::fromZeroExtended(regs.fip);
	x87.dataPtrOffset   = edb::address_t::fromZeroExtended(regs.foo);
	x87.instPtrSelector = regs.fcs;
	x87.dataPtrSelector = regs.fos;
	x87.opCode          = regs.fop;
	x87.filled          = true;
	x87.opCodeFilled    = true;

	for (size_t n = 0; n < IA32_XMM_REG_COUNT; ++n) {
		avx.setXMM(n, edb::value128(regs.xmm_space, 16 * n));
	}

	avx.mxcsr         = regs.mxcsr;
	avx.xmmFilledIA32 = true;
}

void PlatformState::fillFrom(const UserRegsStructX86_64 &regs) {

	// On 32 bit OS this code would access beyond the length of the array, but it won't ever execute there
	assert(x86.GPRegs.size() == 16);
	x86.GPRegs[X86::RAX] = regs.rax;
	x86.GPRegs[X86::RCX] = regs.rcx;
	x86.GPRegs[X86::RDX] = regs.rdx;
	x86.GPRegs[X86::RBX] = regs.rbx;
	x86.GPRegs[X86::RSP] = regs.rsp;
	x86.GPRegs[X86::RBP] = regs.rbp;
	x86.GPRegs[X86::RSI] = regs.rsi;
	x86.GPRegs[X86::RDI] = regs.rdi;
	x86.GPRegs[X86::R8]  = regs.r8;
	x86.GPRegs[X86::R9]  = regs.r9;
	x86.GPRegs[X86::R10] = regs.r10;
	x86.GPRegs[X86::R11] = regs.r11;
	x86.GPRegs[X86::R12] = regs.r12;
	x86.GPRegs[X86::R13] = regs.r13;
	x86.GPRegs[X86::R14] = regs.r14;
	x86.GPRegs[X86::R15] = regs.r15;
	x86.orig_ax          = regs.orig_rax;
	x86.flags            = regs.eflags;
	x86.IP               = regs.rip;
	x86.segRegs[X86::ES] = regs.es;
	x86.segRegs[X86::CS] = regs.cs;
	x86.segRegs[X86::SS] = regs.ss;
	x86.segRegs[X86::DS] = regs.ds;
	x86.segRegs[X86::FS] = regs.fs;
	x86.segRegs[X86::GS] = regs.gs;
	x86.gpr32Filled      = true;
	x86.gpr64Filled      = true;

	if (is64Bit()) { // 32-bit processes get always zeros here, which may be wrong or meaningless
		if (x86.segRegs[X86::FS] == 0) {
			x86.segRegBases[X86::FS]       = regs.fs_base;
			x86.segRegBasesFilled[X86::FS] = true;
		}
		if (x86.segRegs[X86::GS] == 0) {
			x86.segRegBases[X86::GS]       = regs.gs_base;
			x86.segRegBasesFilled[X86::GS] = true;
		}
	}
}

void PlatformState::fillFrom(const UserFPRegsStructX86_64 &regs) {
	x87.statusWord = regs.swd; // should be first for RIndexToSTIndex() to work

	for (size_t n = 0; n < MAX_FPU_REG_COUNT; ++n) {
		x87.R[n] = edb::value80(regs.st_space, 16 * x87.RIndexToSTIndex(n));
	}

	x87.controlWord     = regs.cwd;
	x87.tagWord         = x87.restoreTagWord(regs.ftw);
	x87.instPtrOffset   = regs.rip;
	x87.dataPtrOffset   = regs.rdp;
	x87.instPtrSelector = 0;
	x87.dataPtrSelector = 0;
	x87.opCode          = regs.fop;
	x87.filled          = true;
	x87.opCodeFilled    = true;

	for (size_t n = 0; n < MAX_XMM_REG_COUNT; ++n) {
		avx.setXMM(n, edb::value128(regs.xmm_space, 16 * n));
	}

	avx.mxcsr           = regs.mxcsr;
	avx.mxcsrMask       = regs.mxcr_mask;
	avx.mxcsrMaskFilled = true;
	avx.xmmFilledIA32   = true;
	avx.xmmFilledAMD64  = true;
}

void PlatformState::fillFrom(const PrStatus_X86 &regs) {

	// Don't touch higher parts to avoid zeroing out bad value mark, so use load
	x86.GPRegs[X86::EAX].load(regs.eax);
	x86.GPRegs[X86::ECX].load(regs.ecx);
	x86.GPRegs[X86::EDX].load(regs.edx);
	x86.GPRegs[X86::EBX].load(regs.ebx);
	x86.GPRegs[X86::ESP].load(regs.esp);
	x86.GPRegs[X86::EBP].load(regs.ebp);
	x86.GPRegs[X86::ESI].load(regs.esi);
	x86.GPRegs[X86::EDI].load(regs.edi);
	x86.orig_ax.load(regs.orig_eax);
	x86.flags.load(regs.eflags);
	x86.IP.load(regs.eip);

	x86.segRegs[X86::ES] = regs.es;
	x86.segRegs[X86::CS] = regs.cs;
	x86.segRegs[X86::SS] = regs.ss;
	x86.segRegs[X86::DS] = regs.ds;
	x86.segRegs[X86::FS] = regs.fs;
	x86.segRegs[X86::GS] = regs.gs;
	x86.gpr32Filled      = true;
}

void PlatformState::fillFrom(const PrStatus_X86_64 &regs) {
	x86.GPRegs[X86::RAX]           = regs.rax;
	x86.GPRegs[X86::RCX]           = regs.rcx;
	x86.GPRegs[X86::RDX]           = regs.rdx;
	x86.GPRegs[X86::RBX]           = regs.rbx;
	x86.GPRegs[X86::RSP]           = regs.rsp;
	x86.GPRegs[X86::RBP]           = regs.rbp;
	x86.GPRegs[X86::RSI]           = regs.rsi;
	x86.GPRegs[X86::RDI]           = regs.rdi;
	x86.GPRegs[X86::R8]            = regs.r8;
	x86.GPRegs[X86::R9]            = regs.r9;
	x86.GPRegs[X86::R10]           = regs.r10;
	x86.GPRegs[X86::R11]           = regs.r11;
	x86.GPRegs[X86::R12]           = regs.r12;
	x86.GPRegs[X86::R13]           = regs.r13;
	x86.GPRegs[X86::R14]           = regs.r14;
	x86.GPRegs[X86::R15]           = regs.r15;
	x86.orig_ax                    = regs.orig_rax;
	x86.flags                      = regs.rflags;
	x86.IP                         = regs.rip;
	x86.segRegs[X86::ES]           = regs.es;
	x86.segRegs[X86::CS]           = regs.cs;
	x86.segRegs[X86::SS]           = regs.ss;
	x86.segRegs[X86::DS]           = regs.ds;
	x86.segRegs[X86::FS]           = regs.fs;
	x86.segRegs[X86::GS]           = regs.gs;
	x86.gpr32Filled                = true;
	x86.gpr64Filled                = true;
	x86.segRegBases[X86::FS]       = regs.fs_base;
	x86.segRegBasesFilled[X86::FS] = true;
	x86.segRegBases[X86::GS]       = regs.gs_base;
	x86.segRegBasesFilled[X86::GS] = true;
}

bool PlatformState::fillFrom(const X86XState &regs, size_t sizeFromKernel) {
	if (sizeFromKernel < X86XState::XSAVE_NONEXTENDED_SIZE) {
		// Shouldn't ever happen. XSAVE area must at least have an XSAVE header.
		qDebug() << "Size of X86_XSTATE returned from the kernel appears less than expected: " << sizeFromKernel;
		return false;
	}

	avx.xcr0 = regs.xcr0;

	bool statePresentX87 = regs.xstate_bv & X86XState::FEATURE_X87;
	bool statePresentSSE = regs.xstate_bv & X86XState::FEATURE_SSE;
	bool statePresentAVX = regs.xstate_bv & X86XState::FEATURE_AVX;

	// Due to the lazy saving the feature bits may be unset in XSTATE_BV if the app
	// has not touched the corresponding registers yet. But once the registers are
	// touched, they are initialized to zero by the OS (not control/tag ones). To the app
	// it looks as if the registers have always been zero. Thus we should provide the same
	// illusion to the user.
	if (statePresentX87) {
		x87.statusWord = regs.swd; // should be first for RIndexToSTIndex() to work

		for (size_t n = 0; n < MAX_FPU_REG_COUNT; ++n) {
			x87.R[n] = edb::value80(regs.st_space, 16 * x87.RIndexToSTIndex(n));
		}

		x87.controlWord   = regs.cwd;
		x87.tagWord       = x87.restoreTagWord(regs.twd);
		x87.instPtrOffset = regs.fioff;
		x87.dataPtrOffset = regs.fooff;

		if (is64Bit()) {
			std::memcpy(reinterpret_cast<char *>(&x87.instPtrOffset) + 4, &regs.fiseg, sizeof(regs.fiseg));
			std::memcpy(reinterpret_cast<char *>(&x87.dataPtrOffset) + 4, &regs.foseg, sizeof(regs.foseg));
			x87.instPtrSelector = 0;
			x87.dataPtrSelector = 0;
		} else {
			x87.instPtrSelector = regs.fiseg;
			x87.dataPtrSelector = regs.foseg;
		}
		x87.opCode       = regs.fop;
		x87.filled       = true;
		x87.opCodeFilled = true;
	} else {
		std::memset(reinterpret_cast<char *>(&x87), 0, sizeof(x87));
		x87.controlWord  = regs.cwd; // this appears always present
		x87.tagWord      = 0xffff;
		x87.filled       = true;
		x87.opCodeFilled = true;
	}

	if (statePresentAVX) {
		for (size_t n = 0; n < MAX_YMM_REG_COUNT; ++n) {
			avx.setYMM(n, edb::value128(regs.xmm_space, 16 * n), edb::value128(regs.ymmh_space, 16 * n));
		}

		avx.mxcsr           = regs.mxcsr;
		avx.mxcsrMask       = regs.mxcsr_mask;
		avx.mxcsrMaskFilled = true;
		avx.xmmFilledIA32   = true;
		avx.xmmFilledAMD64  = true;
		avx.ymmFilled       = true;
	} else if (statePresentSSE) {
		// If AVX state management has been enabled by the OS,
		// the state may be not present due to lazy saving,
		// so initialize the space with zeros
		if (avx.xcr0 & X86XState::FEATURE_AVX) {
			for (size_t n = 0; n < MAX_YMM_REG_COUNT; ++n) {
				avx.setYMM(n, edb::value256::fromZeroExtended(0));
			}

			avx.ymmFilled = true;
		}

		// Now we can fill in the XMM registers
		for (size_t n = 0; n < MAX_XMM_REG_COUNT; ++n) {
			avx.setXMM(n, edb::value128(regs.xmm_space, 16 * n));
		}

		avx.mxcsr           = regs.mxcsr;
		avx.mxcsrMask       = regs.mxcsr_mask;
		avx.mxcsrMaskFilled = true;
		avx.xmmFilledIA32   = true;
		avx.xmmFilledAMD64  = true;
	} else {
		avx.mxcsr           = regs.mxcsr;
		avx.mxcsrMask       = regs.mxcsr_mask;
		avx.mxcsrMaskFilled = true;
		// Only fill the registers which are actually supported, leave invalidity marks intact for other parts
		if (avx.xcr0 & X86XState::FEATURE_AVX) { // If AVX state management has been enabled by the OS
			for (size_t n = 0; n < MAX_YMM_REG_COUNT; ++n) {
				avx.setYMM(n, edb::value256::fromZeroExtended(0));
			}

			avx.xmmFilledIA32  = true;
			avx.xmmFilledAMD64 = true;
			avx.ymmFilled      = true;
		} else if (avx.xcr0 & X86XState::FEATURE_SSE) { // If SSE state management has been enabled by the OS
			for (size_t n = 0; n < MAX_YMM_REG_COUNT; ++n) {
				avx.setYMM(n, edb::value256::fromZeroExtended(0));
			}

			avx.xmmFilledIA32  = true;
			avx.xmmFilledAMD64 = true;
		}
	}
	return true;
}

void PlatformState::fillStruct(UserRegsStructX86 &regs) const {

	util::mark_memory(&regs, sizeof(regs));

	if (x86.gpr32Filled) {
		regs.eax      = x86.GPRegs[X86::EAX];
		regs.ecx      = x86.GPRegs[X86::ECX];
		regs.edx      = x86.GPRegs[X86::EDX];
		regs.ebx      = x86.GPRegs[X86::EBX];
		regs.esp      = x86.GPRegs[X86::ESP];
		regs.ebp      = x86.GPRegs[X86::EBP];
		regs.esi      = x86.GPRegs[X86::ESI];
		regs.edi      = x86.GPRegs[X86::EDI];
		regs.xes      = x86.segRegs[X86::ES];
		regs.xcs      = x86.segRegs[X86::CS];
		regs.xss      = x86.segRegs[X86::SS];
		regs.xds      = x86.segRegs[X86::DS];
		regs.xfs      = x86.segRegs[X86::FS];
		regs.xgs      = x86.segRegs[X86::GS];
		regs.orig_eax = x86.orig_ax;
		regs.eflags   = x86.flags;
		regs.eip      = x86.IP;
	}
}

void PlatformState::fillStruct(UserRegsStructX86_64 &regs) const {

	// If 64-bit part is not filled in state, we'll set marked values
	if (x86.gpr64Filled || x86.gpr32Filled) {
		regs.rax      = x86.GPRegs[X86::RAX];
		regs.rcx      = x86.GPRegs[X86::RCX];
		regs.rdx      = x86.GPRegs[X86::RDX];
		regs.rbx      = x86.GPRegs[X86::RBX];
		regs.rsp      = x86.GPRegs[X86::RSP];
		regs.rbp      = x86.GPRegs[X86::RBP];
		regs.rsi      = x86.GPRegs[X86::RSI];
		regs.rdi      = x86.GPRegs[X86::RDI];
		regs.r8       = x86.GPRegs[X86::R8];
		regs.r9       = x86.GPRegs[X86::R9];
		regs.r10      = x86.GPRegs[X86::R10];
		regs.r11      = x86.GPRegs[X86::R11];
		regs.r12      = x86.GPRegs[X86::R12];
		regs.r13      = x86.GPRegs[X86::R13];
		regs.r14      = x86.GPRegs[X86::R14];
		regs.r15      = x86.GPRegs[X86::R15];
		regs.es       = x86.segRegs[X86::ES];
		regs.cs       = x86.segRegs[X86::CS];
		regs.ss       = x86.segRegs[X86::SS];
		regs.ds       = x86.segRegs[X86::DS];
		regs.fs       = x86.segRegs[X86::FS];
		regs.gs       = x86.segRegs[X86::GS];
		regs.fs_base  = x86.segRegBases[X86::FS];
		regs.gs_base  = x86.segRegBases[X86::GS];
		regs.orig_rax = x86.orig_ax;
		regs.eflags   = x86.flags;
		regs.rip      = x86.IP;
	}
}

void PlatformState::fillStruct(PrStatus_X86_64 &regs) const {

	// If 64-bit part is not filled in state, we'll set marked values
	if (x86.gpr64Filled || x86.gpr32Filled) {
		regs.rax      = x86.GPRegs[X86::RAX];
		regs.rcx      = x86.GPRegs[X86::RCX];
		regs.rdx      = x86.GPRegs[X86::RDX];
		regs.rbx      = x86.GPRegs[X86::RBX];
		regs.rsp      = x86.GPRegs[X86::RSP];
		regs.rbp      = x86.GPRegs[X86::RBP];
		regs.rsi      = x86.GPRegs[X86::RSI];
		regs.rdi      = x86.GPRegs[X86::RDI];
		regs.r8       = x86.GPRegs[X86::R8];
		regs.r9       = x86.GPRegs[X86::R9];
		regs.r10      = x86.GPRegs[X86::R10];
		regs.r11      = x86.GPRegs[X86::R11];
		regs.r12      = x86.GPRegs[X86::R12];
		regs.r13      = x86.GPRegs[X86::R13];
		regs.r14      = x86.GPRegs[X86::R14];
		regs.r15      = x86.GPRegs[X86::R15];
		regs.orig_rax = x86.orig_ax;
		regs.rflags   = x86.flags;
		regs.rip      = x86.IP;
		regs.es       = x86.segRegs[X86::ES];
		regs.cs       = x86.segRegs[X86::CS];
		regs.ss       = x86.segRegs[X86::SS];
		regs.ds       = x86.segRegs[X86::DS];
		regs.fs       = x86.segRegs[X86::FS];
		regs.gs       = x86.segRegs[X86::GS];
		regs.fs_base  = x86.segRegBases[X86::FS];
		regs.gs_base  = x86.segRegBases[X86::GS];
	}
}

void PlatformState::fillStruct(UserFPRegsStructX86 &regs) const {
	util::mark_memory(&regs, sizeof(regs));
	if (x87.filled) {
		regs.swd = x87.statusWord;
		regs.cwd = x87.controlWord;
		regs.twd = x87.tagWord;
		regs.fip = x87.instPtrOffset;
		regs.foo = x87.dataPtrOffset;
		regs.fcs = x87.instPtrSelector;
		regs.fos = x87.dataPtrSelector;
		for (size_t n = 0; n < MAX_FPU_REG_COUNT; ++n) {
			std::memcpy(reinterpret_cast<char *>(regs.st_space) + 10 * x87.RIndexToSTIndex(n), &x87.R[n], sizeof(x87.R[n]));
		}
	}
}

void PlatformState::fillStruct(UserFPRegsStructX86_64 &regs) const {
	util::mark_memory(&regs, sizeof(regs));
	if (x87.filled) {
		regs.swd = x87.statusWord;
		regs.cwd = x87.controlWord;
		regs.ftw = x87.reducedTagWord();
		regs.rip = x87.instPtrOffset;
		regs.rdp = x87.dataPtrOffset;
		if (x87.opCodeFilled) {
			regs.fop = x87.opCode;
		}

		for (size_t n = 0; n < MAX_FPU_REG_COUNT; ++n) {
			std::memcpy(reinterpret_cast<char *>(regs.st_space) + 16 * x87.RIndexToSTIndex(n), &x87.R[n], sizeof(x87.R[n]));
		}

		if (avx.xmmFilledIA32 || avx.xmmFilledAMD64) {
			for (size_t n = 0; n < MAX_XMM_REG_COUNT; ++n) {
				std::memcpy(reinterpret_cast<char *>(regs.xmm_space) + 16 * n, &avx.zmmStorage[n], sizeof(edb::value128));
			}
			regs.mxcsr = avx.mxcsr;
		}

		if (avx.mxcsrMaskFilled) {
			regs.mxcr_mask = avx.mxcsrMask;
		}
	}
}

void PlatformState::fillStruct(UserFPXRegsStructX86 &regs) const {
	util::mark_memory(&regs, sizeof(regs));
	if (x87.filled) {
		regs.swd = x87.statusWord;
		regs.twd = x87.reducedTagWord();
		regs.cwd = x87.controlWord;
		regs.fip = x87.instPtrOffset;
		regs.foo = x87.dataPtrOffset;
		regs.fcs = x87.instPtrSelector;
		regs.fos = x87.dataPtrSelector;
		regs.fop = x87.opCode;
		for (size_t n = 0; n < MAX_FPU_REG_COUNT; ++n) {
			std::memcpy(reinterpret_cast<char *>(&regs.st_space) + 16 * x87.RIndexToSTIndex(n), &x87.R[n], sizeof(x87.R[n]));
		}
	}

	if (avx.xmmFilledIA32) {
		regs.mxcsr = avx.mxcsr;
		for (size_t n = 0; n < IA32_XMM_REG_COUNT; ++n) {
			std::memcpy(reinterpret_cast<char *>(&regs.xmm_space) + 16 * n, &avx.zmmStorage[n], sizeof(edb::value128));
		}
	}
}

size_t PlatformState::fillStruct(X86XState &regs) const {
	util::mark_memory(&regs, sizeof(regs));
	// Zero out reserved bytes; set xstate_bv to 0
	std::memset(regs.xstate_hdr_bytes, 0, sizeof(regs.xstate_hdr_bytes));

	regs.xcr0 = avx.xcr0;
	if (x87.filled) {
		regs.swd   = x87.statusWord;
		regs.cwd   = x87.controlWord;
		regs.twd   = x87.reducedTagWord();
		regs.fioff = x87.instPtrOffset;
		regs.fooff = x87.dataPtrOffset;
		if (is64Bit()) {
			std::memcpy(&regs.fiseg, reinterpret_cast<const char *>(&x87.instPtrOffset) + 4, 4);
			std::memcpy(&regs.foseg, reinterpret_cast<const char *>(&x87.dataPtrOffset) + 4, 4);
		} else {
			regs.fiseg = x87.instPtrSelector;
			regs.foseg = x87.dataPtrSelector;
		}

		regs.fop = x87.opCode;

		for (size_t n = 0; n < MAX_FPU_REG_COUNT; ++n) {
			std::memcpy(reinterpret_cast<char *>(&regs.st_space) + 16 * x87.RIndexToSTIndex(n), &x87.R[n], sizeof(x87.R[n]));
		}

		regs.xstate_bv |= X86XState::FEATURE_X87;
	}

	if (avx.xmmFilledIA32) {
		const auto nMax = avx.xmmFilledAMD64 ? AMD64_XMM_REG_COUNT : IA32_XMM_REG_COUNT;
		for (size_t n = 0; n < nMax; ++n) {
			std::memcpy(reinterpret_cast<char *>(&regs.xmm_space) + 16 * n, &avx.zmmStorage[n], sizeof(edb::value128));
		}

		regs.mxcsr      = avx.mxcsr;
		regs.mxcsr_mask = avx.mxcsrMask;
		regs.xstate_bv |= X86XState::FEATURE_SSE;
	}

	if (avx.ymmFilled) {
		// In this case SSE state is already filled by the code writing XMMx&MXCSR registers
		for (size_t n = 0; n < MAX_YMM_REG_COUNT; ++n) {
			std::memcpy(reinterpret_cast<char *>(&regs.ymmh_space) + 16 * n, reinterpret_cast<const char *>(&avx.zmmStorage[n]) + sizeof(edb::value128), sizeof(edb::value128));
		}

		regs.xstate_bv |= X86XState::FEATURE_AVX;
	}

	size_t size;
	if (regs.xstate_bv & X86XState::FEATURE_AVX) {
		size = X86XState::AVX_SIZE;
	} else if (regs.xstate_bv & (X86XState::FEATURE_X87 | X86XState::FEATURE_SSE)) {
		size = X86XState::SSE_SIZE; // minimum size: legacy state + xsave header
	} else {
		size = 0;
	}

	return size;
}

edb::value128 PlatformState::AVX::xmm(size_t index) const {
	return edb::value128(zmmStorage[index]);
}

edb::value256 PlatformState::AVX::ymm(size_t index) const {
	return edb::value256(zmmStorage[index]);
}

edb::value512 PlatformState::AVX::zmm(size_t index) const {
	return zmmStorage[index];
}

void PlatformState::AVX::setXMM(size_t index, edb::value128 value) {
	// leave upper part unchanged.
	zmmStorage[index].load(value);
}

void PlatformState::AVX::setYMM(size_t index, edb::value128 low, edb::value128 high) {
	// leave upper part unchanged.
	std::memcpy(reinterpret_cast<uint8_t *>(&zmmStorage[index]) + 0, &low, sizeof(low));
	std::memcpy(reinterpret_cast<uint8_t *>(&zmmStorage[index]) + 16, &high, sizeof(high));
}

void PlatformState::AVX::setYMM(size_t index, edb::value256 value) {
	// leave upper part unchanged.
	zmmStorage[index].load(value);
}

void PlatformState::AVX::setZMM(size_t index, edb::value512 value) {
	zmmStorage[index] = value;
}

void PlatformState::X86::clear() {
	util::mark_memory(this, sizeof(*this));
	gpr32Filled = false;
	gpr64Filled = false;

	std::fill(segRegBasesFilled.begin(), segRegBasesFilled.end(), false);
}

bool PlatformState::X86::empty() const {
	return !gpr32Filled;
}

void PlatformState::X87::clear() {
	util::mark_memory(this, sizeof(*this));
	filled       = false;
	opCodeFilled = false;
}

bool PlatformState::X87::empty() const {
	return !filled;
}

void PlatformState::AVX::clear() {
	util::mark_memory(this, sizeof(*this));
	xmmFilledIA32  = false;
	xmmFilledAMD64 = false;
	ymmFilled      = false;
	zmmFilled      = false;
}

bool PlatformState::AVX::empty() const {
	return !xmmFilledIA32;
}

/**
 * @brief PlatformState::PlatformState
 */
PlatformState::PlatformState() {
	this->clear();
}

/**
 * makes a copy of the state object
 *
 * @brief PlatformState::clone
 * @return
 */
std::unique_ptr<IState> PlatformState::clone() const {
	return std::make_unique<PlatformState>(*this);
}

/**
 * @brief PlatformState::flagsToString
 * @param flags
 * @return the flags in a string form appropriate for this platform
 */
QString PlatformState::flagsToString(edb::reg_t flags) const {
	char buf[32];
	qsnprintf(buf, sizeof(buf), "%c %c %c %c %c %c %c %c %c",
			  ((flags & 0x001) ? 'C' : 'c'),
			  ((flags & 0x004) ? 'P' : 'p'),
			  ((flags & 0x010) ? 'A' : 'a'),
			  ((flags & 0x040) ? 'Z' : 'z'),
			  ((flags & 0x080) ? 'S' : 's'),
			  ((flags & 0x100) ? 'T' : 't'),
			  ((flags & 0x200) ? 'I' : 'i'),
			  ((flags & 0x400) ? 'D' : 'd'),
			  ((flags & 0x800) ? 'O' : 'o'));
	return QString::fromLatin1(buf);
}

/**
 * @brief PlatformState::flagsToString
 * @return the flags in a string form appropriate for this platform
 */
QString PlatformState::flagsToString() const {
	return flagsToString(flags());
}

/**
 * @brief findRegisterValue
 * @param names
 * @param regs
 * @param regName
 * @param type
 * @param maxNames
 * @param shift
 * @return
 */
template <size_t BitSize = 0, class Names, class Regs>
Register findRegisterValue(const Names &names, const Regs &regs, const QString &regName, Register::Type type, size_t maxNames, int shift = 0) {

	const auto end        = names.begin() + maxNames;
	auto regNameFoundIter = std::find(names.begin(), end, regName);

	if (regNameFoundIter != end) {
		return make_Register<BitSize>(regName, regs[regNameFoundIter - names.begin()] >> shift, type);
	} else {
		return Register();
	}
}

/**
 * @brief PlatformState::value
 * @param reg
 * @return a Register object which represents the register with the name supplied
 */
Register PlatformState::value(const QString &reg) const {

	const QString regName = reg.toLower();
	// TODO: make use of string_hash and switch-case construct to make things easier to understand
	// 		 All register names are always less than 9 chars in length, so string_hash would work.

	Register found;

	// don't return valid Register with garbage value
	if (x86.gpr32Filled) {
		if (reg == x86.origRAXName && x86.gpr64Filled && is64Bit())
			return make_Register<64>(x86.origRAXName, x86.orig_ax, Register::TYPE_GPR);
		if (reg == x86.origEAXName)
			return make_Register<32>(x86.origEAXName, x86.orig_ax, Register::TYPE_GPR);
		if (x86.gpr64Filled && is64Bit() && !!(found = findRegisterValue(x86.GPReg64Names, x86.GPRegs, regName, Register::TYPE_GPR, gpr64_count())))
			return found;
		if (!!(found = findRegisterValue<32>(x86.GPReg32Names, x86.GPRegs, regName, Register::TYPE_GPR, gpr_count())))
			return found;
		if (!!(found = findRegisterValue<16>(x86.GPReg16Names, x86.GPRegs, regName, Register::TYPE_GPR, gpr_count())))
			return found;
		if (!!(found = findRegisterValue<8>(x86.GPReg8LNames, x86.GPRegs, regName, Register::TYPE_GPR, gpr_low_addressable_count())))
			return found;
		if (!!(found = findRegisterValue<8>(x86.GPReg8HNames, x86.GPRegs, regName, Register::TYPE_GPR, gpr_high_addressable_count(), 8)))
			return found;
		if (!!(found = findRegisterValue(x86.segRegNames, x86.segRegs, regName, Register::TYPE_SEG, seg_reg_count())))
			return found;

		if (regName.mid(1) == "s_base") {
			const QString segRegName    = regName.mid(0, 2);
			const auto end              = x86.segRegNames.end();
			const auto regNameFoundIter = std::find(x86.segRegNames.begin(), end, segRegName);

			if (regNameFoundIter != end) {
				const size_t index = regNameFoundIter - x86.segRegNames.begin();

				if (!x86.segRegBasesFilled[index]) {
					return Register();
				}

				const auto value = x86.segRegBases[index];

				if (is64Bit()) {
					return make_Register(regName, value, Register::TYPE_SEG);
				} else {
					return make_Register<32>(regName, value, Register::TYPE_SEG);
				}
			}
		}

		if (is64Bit() && regName == x86.flags64Name)
			return make_Register(x86.flags64Name, x86.flags, Register::TYPE_COND);
		if (regName == x86.flags32Name)
			return make_Register<32>(x86.flags32Name, x86.flags, Register::TYPE_COND);
		if (regName == x86.flags16Name)
			return make_Register<16>(x86.flags16Name, x86.flags, Register::TYPE_COND);
		if (is64Bit() && regName == x86.IP64Name)
			return make_Register(x86.IP64Name, x86.IP, Register::TYPE_IP);
		if (regName == x86.IP32Name)
			return make_Register<32>(x86.IP32Name, x86.IP, Register::TYPE_IP);
		if (regName == x86.IP16Name)
			return make_Register<16>(x86.IP16Name, x86.IP, Register::TYPE_IP);
	}

	if (x86.gpr32Filled) {
		QRegExp DRx("^dr([0-7])$");
		if (DRx.indexIn(regName) != -1) {
			QChar digit = DRx.cap(1).at(0);
			assert(digit.isDigit());
			char digitChar = digit.toLatin1();
			size_t i       = digitChar - '0';
			assert(dbgIndexValid(i));

			if (is64Bit() && x86.gpr64Filled) {
				return make_Register(regName, x86.dbgRegs[i], Register::TYPE_COND);
			} else {
				return make_Register<32>(regName, x86.dbgRegs[i], Register::TYPE_COND);
			}
		}
	}

	if (x87.filled) {
		QRegExp Rx("^r([0-7])$");
		if (Rx.indexIn(regName) != -1) {
			QChar digit = Rx.cap(1).at(0);
			assert(digit.isDigit());
			char digitChar = digit.toLatin1();
			size_t i       = digitChar - '0';
			assert(fpuIndexValid(i));
			return make_Register(regName, x87.R[i], Register::TYPE_FPU);
		}
	}

	if (x87.filled) {
		QRegExp STx("^st\\(?([0-7])\\)?$");
		if (STx.indexIn(regName) != -1) {
			QChar digit = STx.cap(1).at(0);
			assert(digit.isDigit());
			char digitChar = digit.toLatin1();
			size_t i       = digitChar - '0';
			assert(fpuIndexValid(i));
			return make_Register(regName, x87.st(i), Register::TYPE_FPU);
		}
	}

	if (x87.filled) {
		if (regName == "fip" || regName == "fdp") {
			const edb::address_t addr = regName == "fip" ? x87.instPtrOffset : x87.dataPtrOffset;
			if (is64Bit()) {
				return make_Register<64>(regName, addr, Register::TYPE_FPU);
			} else {
				return make_Register<32>(regName, addr, Register::TYPE_FPU);
			}
		}

		if (regName == "fis" || regName == "fds") {
			const edb::value16 val = regName == "fis" ? x87.instPtrSelector : x87.dataPtrSelector;
			return make_Register<16>(regName, val, Register::TYPE_FPU);
		}

		if (regName == "fopcode" || regName == "fop") {
			return make_Register<16>(regName, x87.opCode, Register::TYPE_FPU);
		}

		if (regName == "ftr" || regName == "ftw") {
			return make_Register<16>(regName, x87.tagWord, Register::TYPE_FPU);
		}

		if (regName == "fsr" || regName == "fsw") {
			return make_Register<16>(regName, x87.statusWord, Register::TYPE_FPU);
		}

		if (regName == "fcr" || regName == "fcw") {
			return make_Register<16>(regName, x87.controlWord, Register::TYPE_FPU);
		}
	}

	if (x87.filled) {
		QRegExp MMx("^mm([0-7])$");
		if (MMx.indexIn(regName) != -1) {
			QChar digit = MMx.cap(1).at(0);
			assert(digit.isDigit());
			char digitChar = digit.toLatin1();
			size_t i       = digitChar - '0';
			assert(mmxIndexValid(i));
			return make_Register(regName, x87.R[i].mantissa(), Register::TYPE_SIMD);
		}
	}

	if (avx.xmmFilledIA32) {
		QRegExp XMMx("^xmm([0-9]|1[0-5])$");
		if (XMMx.indexIn(regName) != -1) {
			bool ok  = false;
			size_t i = XMMx.cap(1).toUShort(&ok);
			assert(ok);
			if (i >= IA32_XMM_REG_COUNT && !avx.xmmFilledAMD64) {
				return Register();
			}

			if (xmmIndexValid(i)) { // May be invalid but legitimate for a disassembler: e.g. XMM13 but 32 bit mode
				return make_Register(regName, avx.xmm(i), Register::TYPE_SIMD);
			}
		}
	}

	if (avx.ymmFilled) {
		QRegExp YMMx("^ymm([0-9]|1[0-5])$");
		if (YMMx.indexIn(regName) != -1) {
			bool ok  = false;
			size_t i = YMMx.cap(1).toUShort(&ok);
			assert(ok);
			if (ymmIndexValid(i)) { // May be invalid but legitimate for a disassembler: e.g. YMM13 but 32 bit mode
				return make_Register(regName, avx.ymm(i), Register::TYPE_SIMD);
			}
		}
	}

	if (avx.xmmFilledIA32 && regName == avx.mxcsrName) {
		return make_Register(avx.mxcsrName, avx.mxcsr, Register::TYPE_COND);
	}

	return Register();
}

/**
 * @brief PlatformState::instructionPointerRegister
 * @return
 */
Register PlatformState::instructionPointerRegister() const {

	if (x86.gpr64Filled && is64Bit()) {
		return make_Register(x86.IP64Name, x86.IP, Register::TYPE_GPR);
	} else if (x86.gpr32Filled) {
		return make_Register<32>(x86.IP32Name, x86.IP, Register::TYPE_GPR);
	}

	return Register();
}

/**
 * @brief PlatformState::framePointer
 * @return what is conceptually the frame pointer for this platform
 */
edb::address_t PlatformState::framePointer() const {
	return gpRegister(X86::RBP).valueAsAddress();
}

/**
 * @brief PlatformState::instructionPointer
 * @return the instruction pointer for this platform
 */
edb::address_t PlatformState::instructionPointer() const {
	return instructionPointerRegister().valueAsAddress();
}

/**
 * @brief PlatformState::stackPointer
 * @return stack pointer for this platform
 */
edb::address_t PlatformState::stackPointer() const {
	return gpRegister(X86::RSP).valueAsAddress();
}

/**
 * @brief PlatformState::debugRegister
 * @param n
 * @return
 */
edb::reg_t PlatformState::debugRegister(size_t n) const {
	assert(dbgIndexValid(n));
	return x86.dbgRegs[n];
}

/**
 * @brief PlatformState::flagsRegister
 * @return
 */
Register PlatformState::flagsRegister() const {
	if (x86.gpr64Filled && is64Bit()) {
		return make_Register(x86.flags64Name, x86.flags, Register::TYPE_GPR);
	} else if (x86.gpr32Filled) {
		return make_Register<32>(x86.flags32Name, x86.flags, Register::TYPE_GPR);
	}

	return Register();
}

/**
 * @brief PlatformState::flags
 * @return
 */
edb::reg_t PlatformState::flags() const {
	return flagsRegister().valueAsInteger();
}

/**
 * @brief PlatformState::fpuStackPointer
 * @return
 */
int PlatformState::fpuStackPointer() const {
	return x87.stackPointer();
}

/**
 * @brief PlatformState::fpuRegister
 * @param n
 * @return
 */
edb::value80 PlatformState::fpuRegister(size_t n) const {
	assert(fpuIndexValid(n));

	if (!x87.filled) {

		edb::value80 v;
		constexpr std::uint64_t Mant = 0x0badbad1bad1bad1;
		constexpr std::uint16_t Exp  = 0x0bad;

		std::memcpy(reinterpret_cast<char *>(&v), &Mant, sizeof(Mant));
		std::memcpy(reinterpret_cast<char *>(&v) + sizeof(Mant), &Exp, sizeof(Exp));
		return v;
	}

	return x87.R[n];
}

/**
 * @brief PlatformState::fpuRegisterIsEmpty
 * @param n
 * @return true if Rn register is empty when treated in terms of FPU stack
 */
bool PlatformState::fpuRegisterIsEmpty(size_t n) const {
	return x87.tag(n) == X87::TAG_EMPTY;
}

/**
 * @brief PlatformState::fpuRegisterTagString
 * @param n
 * @return
 */
QString PlatformState::fpuRegisterTagString(size_t n) const {
	int tag = x87.tag(n);
	static const std::unordered_map<int, QString> names{
		{X87::TAG_VALID, "Valid"},
		{X87::TAG_ZERO, "Zero"},
		{X87::TAG_SPECIAL, "Special"},
		{X87::TAG_EMPTY, "Empty"},
	};

	return names.at(tag);
}

/**
 * @brief PlatformState::fpuControlWord
 * @return
 */
edb::value16 PlatformState::fpuControlWord() const {
	return x87.controlWord;
}

/**
 * @brief PlatformState::fpuStatusWord
 * @return
 */
edb::value16 PlatformState::fpuStatusWord() const {
	return x87.statusWord;
}

/**
 * @brief PlatformState::fpuTagWord
 * @return
 */
edb::value16 PlatformState::fpuTagWord() const {
	return x87.tagWord;
}

/**
 * @brief PlatformState::adjustStack
 * @param bytes
 */
void PlatformState::adjustStack(int bytes) {
	x86.GPRegs[X86::RSP] += bytes;
}

/**
 * @brief PlatformState::clear
 */
void PlatformState::clear() {
	x86.clear();
	x87.clear();
	avx.clear();
}

/**
 * @brief PlatformState::empty
 * @return
 */
bool PlatformState::empty() const {
	return x86.empty() && x87.empty() && avx.empty();
}

/**
 * @brief PlatformState::setDebugRegister
 * @param n
 * @param value
 */
void PlatformState::setDebugRegister(size_t n, edb::reg_t value) {
	assert(dbgIndexValid(n));
	x86.dbgRegs[n] = value;
}

/**
 * @brief PlatformState::setFlags
 * @param flags
 */
void PlatformState::setFlags(edb::reg_t flags) {
	x86.flags = flags;
}
/**
 * @brief PlatformState::setInstructionPointer
 * @param value
 */
void PlatformState::setInstructionPointer(edb::address_t value) {
	x86.IP      = value;
	x86.orig_ax = -1;
}

/**
 * @brief PlatformState::gpRegister
 * @param n
 * @return
 */
Register PlatformState::gpRegister(size_t n) const {

	if (gprIndexValid(n)) {
		if (x86.gpr64Filled && is64Bit()) {
			return make_Register(x86.GPReg64Names[n], x86.GPRegs[n], Register::TYPE_GPR);
		} else if (x86.gpr32Filled && n < IA32_GPR_COUNT) {
			return make_Register<32>(x86.GPReg32Names[n], x86.GPRegs[n], Register::TYPE_GPR);
		}
	}

	return Register();
}

/**
 * @brief PlatformState::setRegister
 * @param reg
 */
void PlatformState::setRegister(const Register &reg) {
	const QString regName = reg.name().toLower();

	const auto gpr_end            = GPRegNames().begin() + gpr_count();
	const auto GPRegNameFoundIter = std::find(GPRegNames().begin(), gpr_end, regName);

	if (GPRegNameFoundIter != gpr_end) {
		size_t index      = GPRegNameFoundIter - GPRegNames().begin();
		x86.GPRegs[index] = reg.value<edb::value64>();
		return;
	}

	auto segRegNameFoundIter = std::find(x86.segRegNames.begin(), x86.segRegNames.end(), regName);

	if (segRegNameFoundIter != x86.segRegNames.end()) {
		size_t index       = segRegNameFoundIter - x86.segRegNames.begin();
		x86.segRegs[index] = reg.value<edb::seg_reg_t>();
		return;
	}

	if (regName == IPName()) {
		x86.IP = reg.value<edb::value64>();
		return;
	}

	if (regName == flagsName()) {
		x86.flags = reg.value<edb::value64>();
		return;
	}

	if (regName == avx.mxcsrName) {
		avx.mxcsr = reg.value<edb::value32>();
		return;
	}

	{
		// TODO(eteran): these memcpy's which have the size set to the SOURCE and
		// not the dest look suspicious/potentially dangerous
		QRegExp MMx("^mm([0-7])$");
		if (MMx.indexIn(regName) != -1) {
			QChar digit = MMx.cap(1).at(0);
			assert(digit.isDigit());
			char digitChar = digit.toLatin1();
			size_t i       = digitChar - '0';
			assert(mmxIndexValid(i));

			const auto value = reg.value<edb::value64>();
			std::memcpy(reinterpret_cast<char *>(&x87.R[i]), &value, sizeof(value));

			const uint16_t RiUpper = 0xffff;
			std::memcpy(reinterpret_cast<char *>(&x87.R[i]) + sizeof(value), &RiUpper, sizeof(RiUpper));
			return;
		}
	}

	{
		QRegExp Rx("^r([0-7])$");
		if (Rx.indexIn(regName) != -1) {
			QChar digit = Rx.cap(1).at(0);
			assert(digit.isDigit());
			char digitChar = digit.toLatin1();
			size_t i       = digitChar - '0';
			assert(fpuIndexValid(i));
			const auto value = reg.value<edb::value80>();
			std::memcpy(&x87.R[i], &value, sizeof(value));
			return;
		}
	}

	{
		QRegExp Rx("^st\\(?([0-7])\\)?$");
		if (Rx.indexIn(regName) != -1) {
			QChar digit = Rx.cap(1).at(0);
			assert(digit.isDigit());
			char digitChar = digit.toLatin1();
			size_t i       = digitChar - '0';
			assert(fpuIndexValid(i));
			const auto value = reg.value<edb::value80>();
			std::memcpy(&x87.st(i), &value, sizeof(value));
			return;
		}
	}

	{
		QRegExp XMMx("^xmm([12]?[0-9]|3[01])$");
		if (XMMx.indexIn(regName) != -1) {
			const auto value = reg.value<edb::value128>();
			bool indexReadOK = false;
			size_t i         = XMMx.cap(1).toInt(&indexReadOK);
			assert(indexReadOK && xmmIndexValid(i));

			avx.zmmStorage[i].load(value);
			return;
		}
	}

	{
		QRegExp YMMx("^ymm([12]?[0-9]|3[01])$");
		if (YMMx.indexIn(regName) != -1) {
			const auto value = reg.value<edb::value256>();
			bool indexReadOK = false;
			size_t i         = YMMx.cap(1).toInt(&indexReadOK);
			assert(indexReadOK && ymmIndexValid(i));

			avx.zmmStorage[i].load(value);
			return;
		}
	}

	if (regName == "ftr" || regName == "ftw") {
		x87.tagWord = reg.value<edb::value16>();
		return;
	}

	if (regName == "fsr" || regName == "fsw") {
		x87.statusWord = reg.value<edb::value16>();
		return;
	}

	if (regName == "fcr" || regName == "fcw") {
		x87.controlWord = reg.value<edb::value16>();
		return;
	}

	if (regName == "fis" || regName == "fds") {
		(regName == "fis" ? x87.instPtrSelector : x87.dataPtrSelector) = reg.value<edb::value16>();
		return;
	}

	if (regName == "fip" || regName == "fdp") {
		(regName == "fip" ? x87.instPtrOffset : x87.dataPtrOffset) = reg.valueAsAddress();
		return;
	}

	if (regName == "fopcode" || regName == "fop") {
		x87.opCode = reg.value<edb::value16>();
		return;
	}

	{
		QRegExp DRx("^dr([0-7])$");
		if (DRx.indexIn(regName) != -1) {
			QChar digit = DRx.cap(1).at(0);
			assert(digit.isDigit());
			char digitChar = digit.toLatin1();
			size_t i       = digitChar - '0';
			assert(dbgIndexValid(i));
			x86.dbgRegs[i] = reg.valueAsAddress();
			return;
		}
	}

	qDebug().nospace() << "fixme: set_register(0x" << qPrintable(reg.toHexString()) << "): didn't set register " << reg.name();
}

/**
 * @brief PlatformState::setRegister
 * @param name
 * @param value
 */
void PlatformState::setRegister(const QString &name, edb::reg_t value) {

	const QString regName = name.toLower();
	setRegister(make_Register<64>(regName, value, Register::TYPE_GPR));
}

/**
 * @brief PlatformState::archRegister
 * @param type
 * @param n
 * @return
 */
Register PlatformState::archRegister(uint64_t type, size_t n) const {
	switch (type) {
	case edb::string_hash("mmx"):
		return mmx_register(n);
	case edb::string_hash("xmm"):
		return xmm_register(n);
	case edb::string_hash("ymm"):
		return ymm_register(n);
	default:
		break;
	}
	return Register();
}

/**
 * @brief PlatformState::mmx_register
 * @param n
 * @return
 */
Register PlatformState::mmx_register(size_t n) const {
	if (!mmxIndexValid(n)) {
		return Register();
	}

	edb::value64 value(x87.R[n].mantissa());
	return make_Register(QString("mm%1").arg(n), value, Register::TYPE_SIMD);
}

/**
 * @brief PlatformState::xmm_register
 * @param n
 * @return
 */
Register PlatformState::xmm_register(size_t n) const {
	if (!xmmIndexValid(n) || !avx.xmmFilledIA32) {
		return Register();
	}

	if (n >= IA32_XMM_REG_COUNT && !avx.xmmFilledAMD64) {
		return Register();
	}

	edb::value128 value(avx.xmm(n));
	return make_Register(QString("xmm%1").arg(n), value, Register::TYPE_SIMD);
}

/**
 * @brief PlatformState::ymm_register
 * @param n
 * @return
 */
Register PlatformState::ymm_register(size_t n) const {
	if (!ymmIndexValid(n) || !avx.ymmFilled) {
		return Register();
	}

	edb::value256 value(avx.ymm(n));
	return make_Register(QString("ymm%1").arg(n), value, Register::TYPE_SIMD);
}

}

```

`plugins/DebuggerCore/unix/linux/arch/x86-generic/PlatformState.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_STATE_H_20110330_
#define PLATFORM_STATE_H_20110330_

#include "IState.h"
#include "PrStatus.h"
#include "Types.h"
#include "edb.h"
#include <cstddef>
#include <sys/user.h>

namespace DebuggerCorePlugin {

using std::size_t;

static constexpr size_t IA32_GPR_COUNT                  = 8;
static constexpr size_t IA32_GPR_LOW_ADDRESSABLE_COUNT  = 4; // al,cl,dl,bl
static constexpr size_t AMD64_GPR_COUNT                 = 16;
static constexpr size_t AMD64_GPR_LOW_ADDRESSABLE_COUNT = 16; // all GPRs' low bytes are addressable in 64 bit mode
static constexpr size_t IA32_XMM_REG_COUNT              = IA32_GPR_COUNT;
static constexpr size_t AMD64_XMM_REG_COUNT             = AMD64_GPR_COUNT;
static constexpr size_t IA32_YMM_REG_COUNT              = IA32_GPR_COUNT;
static constexpr size_t AMD64_YMM_REG_COUNT             = AMD64_GPR_COUNT;
static constexpr size_t IA32_ZMM_REG_COUNT              = IA32_GPR_COUNT;
static constexpr size_t AMD64_ZMM_REG_COUNT             = 32;
static constexpr size_t MAX_GPR_COUNT                   = AMD64_GPR_COUNT;
static constexpr size_t MAX_GPR_LOW_ADDRESSABLE_COUNT   = AMD64_GPR_LOW_ADDRESSABLE_COUNT;
static constexpr size_t MAX_GPR_HIGH_ADDRESSABLE_COUNT  = 4; // ah,ch,dh,bh
static constexpr size_t MAX_DBG_REG_COUNT               = 8;
static constexpr size_t MAX_SEG_REG_COUNT               = 6;
static constexpr size_t MAX_FPU_REG_COUNT               = 8;
static constexpr size_t MAX_MMX_REG_COUNT               = MAX_FPU_REG_COUNT;
static constexpr size_t MAX_XMM_REG_COUNT               = AMD64_XMM_REG_COUNT;
static constexpr size_t MAX_YMM_REG_COUNT               = AMD64_YMM_REG_COUNT;
static constexpr size_t MAX_ZMM_REG_COUNT               = AMD64_ZMM_REG_COUNT;

#if defined(EDB_X86)
using UserRegsStructX86    = struct user_regs_struct;
using UserFPRegsStructX86  = struct user_fpregs_struct;
using UserFPXRegsStructX86 = struct user_fpxregs_struct;

// Dummies to avoid missing compile-time checks for conversion code.
// Actual layout is irrelevant since the code is not going to be executed
struct UserFPRegsStructX86_64 {
	uint16_t cwd;
	uint16_t swd;
	uint16_t ftw;
	uint16_t fop; // last instruction opcode
	uint64_t rip; // last instruction EIP
	uint64_t rdp; // last operand pointer
	uint32_t mxcsr;
	uint32_t mxcr_mask;
	uint32_t st_space[32];
	uint32_t xmm_space[64];
	uint32_t padding[24];
};

struct UserRegsStructX86_64 {
	uint64_t r15;
	uint64_t r14;
	uint64_t r13;
	uint64_t r12;
	uint64_t rbp;
	uint64_t rbx;
	uint64_t r11;
	uint64_t r10;
	uint64_t r9;
	uint64_t r8;
	uint64_t rax;
	uint64_t rcx;
	uint64_t rdx;
	uint64_t rsi;
	uint64_t rdi;
	uint64_t orig_rax;
	uint64_t rip;
	uint64_t cs;
	uint64_t eflags;
	uint64_t rsp;
	uint64_t ss;
	uint64_t fs_base;
	uint64_t gs_base;
	uint64_t ds;
	uint64_t es;
	uint64_t fs;
	uint64_t gs;
};

#elif defined(EDB_X86_64)

using UserRegsStructX86_64   = user_regs_struct;
using UserFPRegsStructX86_64 = user_fpregs_struct;

// Dummies to avoid missing compile-time checks for conversion code
// Actual layout is irrelevant since the code is not going to be executed
struct UserRegsStructX86 {
	uint32_t ebx;
	uint32_t ecx;
	uint32_t edx;
	uint32_t esi;
	uint32_t edi;
	uint32_t ebp;
	uint32_t eax;
	uint32_t xds;
	uint32_t xes;
	uint32_t xfs;
	uint32_t xgs;
	uint32_t orig_eax;
	uint32_t eip;
	uint32_t xcs;
	uint32_t eflags;
	uint32_t esp;
	uint32_t xss;
};

struct UserFPXRegsStructX86 {
	uint16_t cwd;
	uint16_t swd;
	uint16_t twd;
	uint16_t fop; // last instruction opcode
	uint32_t fip; // last instruction EIP
	uint32_t fcs; // last instruction CS
	uint32_t foo; // last operand offset
	uint32_t fos; // last operand selector
	uint32_t mxcsr;
	uint32_t reserved;
	uint32_t st_space[32];  /* 8*16 bytes for each FP-reg = 128 bytes */
	uint32_t xmm_space[32]; /* 8*16 bytes for each XMM-reg = 128 bytes */
	uint32_t padding[56];
};

struct UserFPRegsStructX86 {
	uint32_t cwd;
	uint32_t swd;
	uint32_t twd;
	uint32_t fip; // last instruction EIP
	uint32_t fcs; // last instruction CS
	uint32_t foo; // last operand offset
	uint32_t fos; // last operand selector
	uint32_t st_space[20];
};
#endif

// Masks for XCR0 feature enabled bits
#define X86_XSTATE_X87_MASK X87_XSTATE_X87
#define X86_XSTATE_SSE_MASK (X87_XSTATE_X87 | X87_XSTATE_SSE)

struct X86XState {
	uint16_t cwd;
	uint16_t swd;
	uint16_t twd;
	uint16_t fop;   // last instruction opcode
	uint32_t fioff; // last instruction EIP
	uint32_t fiseg; // last instruction CS in 32 bit mode, high 32 bits of RIP in 64 bit mode
	uint32_t fooff; // last operand offset
	uint32_t foseg; // last operand selector in 32 bit mode, high 32 bits of FDP in 64 bit mode
	uint32_t mxcsr;
	uint32_t mxcsr_mask;        // FIXME
	uint8_t st_space[16 * 8];   // 8 16-byte fields
	uint8_t xmm_space[16 * 16]; // 16 16-byte fields, regardless of XMM_REG_COUNT
	uint8_t padding[48];

	union {
		uint64_t xcr0;
		uint8_t sw_usable_bytes[48];
	};

	union {
		uint64_t xstate_bv;
		uint8_t xstate_hdr_bytes[64];
	};

	uint8_t ymmh_space[16 * 16];

	// The extended state feature bits
	enum FeatureBit : uint64_t {
		FEATURE_X87 = 1 << 0,
		FEATURE_SSE = 1 << 1,
		FEATURE_AVX = 1 << 2,
		// MPX adds two feature bits
		FEATURE_BNDREGS = 1 << 3,
		FEATURE_BNDCFG  = 1 << 4,
		FEATURE_MPX     = FEATURE_BNDREGS | FEATURE_BNDCFG,
		// AVX-512 adds three feature bits
		FEATURE_K      = 1 << 5,
		FEATURE_ZMM_H  = 1 << 6,
		FEATURE_ZMM    = 1 << 7,
		FEATURE_AVX512 = FEATURE_K | FEATURE_ZMM_H | FEATURE_ZMM,
	};

	// Possible sizes of X86_XSTATE
	static constexpr size_t XSAVE_NONEXTENDED_SIZE = 576;
	static constexpr size_t SSE_SIZE               = XSAVE_NONEXTENDED_SIZE;
	static constexpr size_t AVX_SIZE               = 832;
	static constexpr size_t BNDREGS_SIZE           = 1024;
	static constexpr size_t BNDCFG_SIZE            = 1088;
	static constexpr size_t AVX512_SIZE            = 2688;
	static constexpr size_t MAX_SIZE               = 2688;
};

static_assert(std::is_standard_layout<X86XState>::value, "X86XState struct is supposed to have standard layout");
static_assert(offsetof(X86XState, st_space) == 32, "ST space should appear at offset 32");
static_assert(offsetof(X86XState, xmm_space) == 160, "XMM space should appear at offset 160");
static_assert(offsetof(X86XState, xcr0) == 464, "XCR0 should appear at offset 464");
static_assert(offsetof(X86XState, ymmh_space) == 576, "YMM_H space should appear at offset 576");

class PlatformState final : public IState {
	friend class DebuggerCore;
	friend class PlatformThread;

public:
	PlatformState();

public:
	std::unique_ptr<IState> clone() const override;

public:
	QString flagsToString() const override;
	QString flagsToString(edb::reg_t flags) const override;
	Register value(const QString &reg) const override;
	Register instructionPointerRegister() const override;
	Register flagsRegister() const override;
	edb::address_t framePointer() const override;
	edb::address_t instructionPointer() const override;
	edb::address_t stackPointer() const override;
	edb::reg_t debugRegister(size_t n) const override;
	edb::reg_t flags() const override;
	int fpuStackPointer() const override;
	edb::value80 fpuRegister(size_t n) const override;
	bool fpuRegisterIsEmpty(size_t n) const override;
	QString fpuRegisterTagString(size_t n) const override;
	edb::value16 fpuControlWord() const override;
	edb::value16 fpuStatusWord() const override;
	edb::value16 fpuTagWord() const override;
	void adjustStack(int bytes) override;
	void clear() override;
	bool empty() const override;
	void setDebugRegister(size_t n, edb::reg_t value) override;
	void setFlags(edb::reg_t flags) override;
	void setInstructionPointer(edb::address_t value) override;
	void setRegister(const Register &reg) override;
	void setRegister(const QString &name, edb::reg_t value) override;

	Register archRegister(uint64_t type, size_t n) const override;
	Register gpRegister(size_t n) const override;

	bool is64Bit() const {
		return edb::v1::debuggeeIs64Bit();
	}

	bool is32Bit() const {
		return edb::v1::debuggeeIs32Bit();
	}

	size_t dbg_reg_count() const {
		return MAX_DBG_REG_COUNT;
	}

	size_t seg_reg_count() const {
		return MAX_SEG_REG_COUNT;
	}

	size_t fpu_reg_count() const {
		return MAX_FPU_REG_COUNT;
	}

	size_t mmx_reg_count() const {
		return MAX_MMX_REG_COUNT;
	}

	size_t xmm_reg_count() const {
		return is64Bit() ? AMD64_XMM_REG_COUNT : IA32_XMM_REG_COUNT;
	}

	size_t ymm_reg_count() const {
		return is64Bit() ? AMD64_YMM_REG_COUNT : IA32_YMM_REG_COUNT;
	}

	size_t zmm_reg_count() const {
		return is64Bit() ? AMD64_ZMM_REG_COUNT : IA32_ZMM_REG_COUNT;
	}

	size_t gpr64_count() const {
		return is64Bit() ? AMD64_GPR_COUNT : 0;
	}

	size_t gpr_count() const {
		return is64Bit() ? AMD64_GPR_COUNT : IA32_GPR_COUNT;
	}

	size_t gpr_low_addressable_count() const {
		return is64Bit() ? AMD64_GPR_LOW_ADDRESSABLE_COUNT : IA32_GPR_LOW_ADDRESSABLE_COUNT;
	}

	size_t gpr_high_addressable_count() const {
		return MAX_GPR_HIGH_ADDRESSABLE_COUNT;
	}

	const char *IPName() const {
		return is64Bit() ? x86.IP64Name : x86.IP32Name;
	}

	const char *flagsName() const {
		return is64Bit() ? x86.flags64Name : x86.flags32Name;
	}

	const std::array<const char *, MAX_GPR_COUNT> &GPRegNames() const {
		return is64Bit() ? x86.GPReg64Names : x86.GPReg32Names;
	}

private:
	Register mmx_register(size_t n) const;
	Register xmm_register(size_t n) const;
	Register ymm_register(size_t n) const;

private:
	// The whole AVX* state. XMM and YMM registers are lower parts of ZMM ones.
	struct AVX {
	public:
		static constexpr const char *mxcsrName = "mxcsr";

	public:
		std::array<edb::value512, MAX_ZMM_REG_COUNT> zmmStorage;

		edb::value32 mxcsr;
		edb::value32 mxcsrMask;
		edb::value64 xcr0;
		bool xmmFilledIA32   = false;
		bool xmmFilledAMD64  = false; // This can be false when filled from e.g. FPXregs
		bool ymmFilled       = false;
		bool zmmFilled       = false;
		bool mxcsrMaskFilled = false;

	public:
		void clear();
		bool empty() const;
		edb::value128 xmm(size_t index) const;
		void setXMM(size_t index, edb::value128);
		edb::value256 ymm(size_t index) const;
		void setYMM(size_t index, edb::value256);
		void setYMM(size_t index, edb::value128 low, edb::value128 high);
		edb::value512 zmm(size_t index) const;
		void setZMM(size_t index, edb::value512);
	} avx;

	// x87 state
	struct X87 {
	public:
		enum Tag {
			TAG_VALID   = 0,
			TAG_ZERO    = 1,
			TAG_SPECIAL = 2,
			TAG_EMPTY   = 3
		};

	public:
		std::array<edb::value80, MAX_FPU_REG_COUNT> R; // Rx registers
		edb::address_t instPtrOffset;
		edb::address_t dataPtrOffset;
		edb::value16 instPtrSelector;
		edb::value16 dataPtrSelector;
		edb::value16 controlWord;
		edb::value16 statusWord;
		edb::value16 tagWord;
		edb::value16 opCode;
		bool filled       = false;
		bool opCodeFilled = false;

	public:
		void clear();
		bool empty() const;
		size_t stackPointer() const;
		// Convert from ST(n) index n to Rx index x
		size_t RIndexToSTIndex(size_t index) const;
		size_t STIndexToRIndex(size_t index) const;
		// Restore the full FPU Tag Word from the ptrace-filtered version
		edb::value16 restoreTagWord(uint16_t twd) const;
		std::uint16_t reducedTagWord() const;
		int tag(size_t n) const;
		edb::value80 st(size_t n) const;
		edb::value80 &st(size_t n);

	private:
		int recreateTag(const edb::value80 value) const;
		int makeTag(size_t n, uint16_t twd) const;
	} x87;

	// i386-inherited (and expanded on x86_64) state
	struct X86 {
	public:
		enum GPRIndex : size_t {
			EAX,
			RAX = EAX,
			ECX,
			RCX = ECX,
			EDX,
			RDX = EDX,
			EBX,
			RBX = EBX,
			ESP,
			RSP = ESP,
			EBP,
			RBP = EBP,
			ESI,
			RSI = ESI,
			EDI,
			RDI = EDI,
			R8,
			R9,
			R10,
			R11,
			R12,
			R13,
			R14,
			R15
		};

		enum SegRegIndex : size_t {
			ES,
			CS,
			SS,
			DS,
			FS,
			GS
		};

		static constexpr const char *origEAXName = "orig_eax";
		static constexpr const char *origRAXName = "orig_rax";
		static constexpr const char *IP64Name    = "rip";
		static constexpr const char *IP32Name    = "eip";
		static constexpr const char *IP16Name    = "ip";
		static constexpr const char *flags64Name = "rflags";
		static constexpr const char *flags32Name = "eflags";
		static constexpr const char *flags16Name = "flags";

		// gcc 4.8 fails to understand inline initialization of std::array, so define these the old way
		static const std::array<const char *, MAX_GPR_COUNT> GPReg64Names;
		static const std::array<const char *, MAX_GPR_COUNT> GPReg32Names;
		static const std::array<const char *, MAX_GPR_COUNT> GPReg16Names;
		static const std::array<const char *, MAX_GPR_LOW_ADDRESSABLE_COUNT> GPReg8LNames;
		static const std::array<const char *, MAX_GPR_HIGH_ADDRESSABLE_COUNT> GPReg8HNames;
		static const std::array<const char *, MAX_SEG_REG_COUNT> segRegNames;

	public:
		std::array<edb::reg_t, MAX_GPR_COUNT> GPRegs;
		std::array<edb::reg_t, MAX_DBG_REG_COUNT> dbgRegs;
		edb::reg_t orig_ax;
		edb::reg_t flags;  // whole flags register: EFLAGS/RFLAGS
		edb::address_t IP; // program counter: EIP/RIP
		std::array<edb::seg_reg_t, MAX_SEG_REG_COUNT> segRegs;
		std::array<edb::address_t, MAX_SEG_REG_COUNT> segRegBases;
		std::array<bool, MAX_SEG_REG_COUNT> segRegBasesFilled = {{false}};
		bool gpr64Filled                                      = false;
		bool gpr32Filled                                      = false;

	public:
		void clear();
		bool empty() const;
	} x86;

	bool dbgIndexValid(size_t n) const {
		return n < dbg_reg_count();
	}

	bool gprIndexValid(size_t n) const {
		return n < gpr_count();
	}

	bool fpuIndexValid(size_t n) const {
		return n < fpu_reg_count();
	}

	bool mmxIndexValid(size_t n) const {
		return n < mmx_reg_count();
	}

	bool xmmIndexValid(size_t n) const {
		return n < xmm_reg_count();
	}

	bool ymmIndexValid(size_t n) const {
		return n < ymm_reg_count();
	}

	bool zmmIndexValid(size_t n) const {
		return n < zmm_reg_count();
	}

	void fillFrom(const UserRegsStructX86 &regs);
	void fillFrom(const UserRegsStructX86_64 &regs);
	void fillFrom(const PrStatus_X86 &regs);
	void fillFrom(const PrStatus_X86_64 &regs);
	void fillFrom(const UserFPRegsStructX86 &regs);
	void fillFrom(const UserFPRegsStructX86_64 &regs);
	void fillFrom(const UserFPXRegsStructX86 &regs);
	bool fillFrom(const X86XState &regs, size_t sizeFromKernel);

	void fillStruct(UserRegsStructX86 &regs) const;
	void fillStruct(UserRegsStructX86_64 &regs) const;
	void fillStruct(PrStatus_X86_64 &regs) const;
	void fillStruct(UserFPRegsStructX86 &regs) const;
	void fillStruct(UserFPRegsStructX86_64 &regs) const;
	void fillStruct(UserFPXRegsStructX86 &regs) const;
	size_t fillStruct(X86XState &regs) const;
};

}

#endif

```

`plugins/DebuggerCore/unix/linux/arch/x86-generic/PlatformThread.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformThread.h"
#include "DebuggerCore.h"
#include "IProcess.h"
#include "PlatformCommon.h"
#include "PlatformState.h"
#include "State.h"
#include <QtDebug>

#ifndef _GNU_SOURCE
#define _GNU_SOURCE /* or _BSD_SOURCE or _SVID_SOURCE */
#endif

#include <asm/ldt.h>
#include <elf.h>
#include <fcntl.h>
#include <sys/ptrace.h>
#include <sys/user.h>

// doesn't always seem to be defined in the headers
#ifndef PTRACE_GET_THREAD_AREA
#define PTRACE_GET_THREAD_AREA static_cast<__ptrace_request>(25)
#endif

#ifndef PTRACE_SET_THREAD_AREA
#define PTRACE_SET_THREAD_AREA static_cast<__ptrace_request>(26)
#endif

#ifndef PTRACE_GETSIGINFO
#define PTRACE_GETSIGINFO static_cast<__ptrace_request>(0x4202)
#endif

#ifndef PTRACE_GETREGSET
#define PTRACE_GETREGSET static_cast<__ptrace_request>(0x4204)
#endif

#ifndef PTRACE_SETREGSET
#define PTRACE_SETREGSET static_cast<__ptrace_request>(0x4205)
#endif

namespace DebuggerCorePlugin {

/**
 * @brief PlatformThread::fillSegmentBases
 * @param state
 */
void PlatformThread::fillSegmentBases(PlatformState *state) {

	struct user_desc desc = {};

	for (size_t sregIndex = 0; sregIndex < state->seg_reg_count(); ++sregIndex) {
		const edb::seg_reg_t reg = state->x86.segRegs[sregIndex];
		if (!reg) {
			continue;
		}

		bool fromGDT = !(reg & 0x04); // otherwise the selector picks descriptor from LDT
		if (!fromGDT) {
			continue;
		}

		if (ptrace(PTRACE_GET_THREAD_AREA, tid_, reg.toUint() / LDT_ENTRY_SIZE, &desc) != -1) {
			state->x86.segRegBases[sregIndex]       = desc.base_addr;
			state->x86.segRegBasesFilled[sregIndex] = true;
		}
	}

	for (size_t sregIndex = 0; sregIndex < state->seg_reg_count(); ++sregIndex) {
		const edb::seg_reg_t sreg = state->x86.segRegs[sregIndex];
		if (sreg == core_->userCodeSegment32_ || sreg == core_->userCodeSegment64_ || sreg == core_->userStackSegment_ || (state->is64Bit() && sregIndex < PlatformState::X86::FS)) {
			state->x86.segRegBases[sregIndex]       = 0;
			state->x86.segRegBasesFilled[sregIndex] = true;
		}
	}
}

/**
 * @brief PlatformThread::fillStateFromPrStatus
 * @param state
 * @return
 */
bool PlatformThread::fillStateFromPrStatus(PlatformState *state) {

	static bool prStatusSupported = true;

	if (!prStatusSupported) {
		return false;
	}

	PrStatus_X86_64 prstat64;

	iovec prstat_iov = {&prstat64, sizeof(prstat64)};

	if (ptrace(PTRACE_GETREGSET, tid_, NT_PRSTATUS, &prstat_iov) != -1) {

		switch (prstat_iov.iov_len) {
		case sizeof(PrStatus_X86_64):
			state->fillFrom(prstat64);
			break;
		case sizeof(PrStatus_X86):
			// In this case the actual structure returned is PrStatus_X86,
			// so copy it to the correct container (reinterpret_cast would
			// cause UB in any case). Good compiler should be able to optimize this out.
			PrStatus_X86 prstat32;
			std::memcpy(&prstat32, &prstat64, sizeof(prstat32));
			state->fillFrom(prstat32);
			break;
		default:
			prStatusSupported = false;
			qWarning() << "PTRACE_GETREGSET(NT_PRSTATUS) returned unexpected length " << prstat_iov.iov_len;
			return false;
		}
	} else {
		prStatusSupported = false;
		perror("PTRACE_GETREGSET(NT_PRSTATUS) failed");
		return false;
	}

	fillSegmentBases(state);
	return true;
}

/**
 * @brief PlatformThread::fillStateFromSimpleRegs
 * @param state
 * @return
 */
bool PlatformThread::fillStateFromSimpleRegs(PlatformState *state) {

	user_regs_struct regs;
	if (ptrace(PTRACE_GETREGS, tid_, 0, &regs) != -1) {

		state->fillFrom(regs);
		fillSegmentBases(state);
		return true;
	} else {
		perror("PTRACE_GETREGS failed");
		return false;
	}
}

/**
 * @brief PlatformThread::getState
 * @param state
 */
void PlatformThread::getState(State *state) {
	// TODO: assert that we are paused

	core_->detectCpuMode();

	if (auto state_impl = static_cast<PlatformState *>(state->impl_.get())) {

		// State must be cleared before filling to zero all presence flags, otherwise something
		// may remain not updated. Also, this way we'll mark all the unfilled values.
		state_impl->clear();

		if (EDB_IS_64_BIT) {
			// 64-bit GETREGS call always returns 64-bit state, so use it
			fillStateFromSimpleRegs(state_impl);
		} else if (!fillStateFromPrStatus(state_impl)) {
			// if EDB is 32 bit, use GETREGSET so that we get 64-bit state for 64-bit debuggee
			fillStateFromSimpleRegs(state_impl);
			// failing that, try to just get what we can
		}

		// First try to get full XSTATE
		X86XState xstate;
		struct iovec iov = {&xstate, sizeof(xstate)};

		long status = ptrace(PTRACE_GETREGSET, tid_, NT_X86_XSTATE, &iov);

		if (status == -1 || !state_impl->fillFrom(xstate, iov.iov_len)) {

			// No XSTATE available, get just floating point and SSE registers
			static bool getFPXRegsSupported = EDB_IS_32_BIT;

			UserFPXRegsStructX86 fpxregs;

			// This should be automatically optimized out on amd64. If not, not a big deal.
			// Avoiding conditional compilation to facilitate syntax error checking
			if (getFPXRegsSupported) {
				getFPXRegsSupported = (ptrace(PTRACE_GETFPXREGS, tid_, 0, &fpxregs) != -1);
			}

			if (getFPXRegsSupported) {
				state_impl->fillFrom(fpxregs);
			} else {
				// No GETFPXREGS: on x86 this means SSE is not supported
				//                on x86_64 FPREGS already contain SSE state
				struct user_fpregs_struct fpregs;
				status = ptrace(PTRACE_GETFPREGS, tid_, 0, &fpregs);

				if (status != -1) {
					state_impl->fillFrom(fpregs);
				} else {
					perror("PTRACE_GETFPREGS failed");
				}
			}
		}

		// debug registers
		for (std::size_t i = 0; i < 8; ++i) {
			state_impl->x86.dbgRegs[i] = getDebugRegister(i);
		}
	}
}

/**
 * @brief PlatformThread::setState
 * @param state
 */
void PlatformThread::setState(const State &state) {

	// TODO: assert that we are paused

	if (auto state_impl = static_cast<PlatformState *>(state.impl_.get())) {
		bool setPrStatusDone = false;

		if (EDB_IS_32_BIT && state_impl->is64Bit()) {
			// Try to set 64-bit state
			PrStatus_X86_64 prstat64;
			state_impl->fillStruct(prstat64);

			struct iovec prstat_iov = {&prstat64, sizeof(prstat64)};
			if (ptrace(PTRACE_SETREGSET, tid_, NT_PRSTATUS, &prstat_iov) != -1) {
				setPrStatusDone = true;
			} else {
				perror("PTRACE_SETREGSET failed");
			}
		}

		// Fallback to setting 32-bit set
		if (!setPrStatusDone) {
			struct user_regs_struct regs;
			state_impl->fillStruct(regs);
			ptrace(PTRACE_SETREGS, tid_, 0, &regs);
		}

		// debug registers
		for (std::size_t i = 0; i < 8; ++i) {
			setDebugRegister(i, state_impl->x86.dbgRegs[i]);
		}

		// hope for the best, adjust for reality
		static bool xsaveSupported = true;

		if (xsaveSupported) {
			X86XState xstate;
			const auto size  = state_impl->fillStruct(xstate);
			struct iovec iov = {&xstate, size};
			if (ptrace(PTRACE_SETREGSET, tid_, NT_X86_XSTATE, &iov) == -1) {
				xsaveSupported = false;
			}
		}

		// If xsave/xrstor appears unsupported, fallback to fxrstor
		// NOTE: it's not "else", it's an independent check for possibly modified flag
		if (!xsaveSupported) {
			static bool setFPXRegsSupported = EDB_IS_32_BIT;
			if (setFPXRegsSupported) {
				UserFPXRegsStructX86 fpxregs;
				state_impl->fillStruct(fpxregs);
				setFPXRegsSupported = (ptrace(PTRACE_SETFPXREGS, tid_, 0, &fpxregs) != -1);
			}

			if (!setFPXRegsSupported) {
				// No SETFPXREGS: on x86 this means SSE is not supported
				//                on x86_64 FPREGS already contain SSE state
				// Just set fpregs then
				struct user_fpregs_struct fpregs;
				state_impl->fillStruct(fpregs);
				if (ptrace(PTRACE_SETFPREGS, tid_, 0, &fpregs) == -1) {
					perror("PTRACE_SETFPREGS failed");
				}
			}
		}
	}
}

/**
 * @brief PlatformThread::instructionPointer
 * @return
 */
edb::address_t PlatformThread::instructionPointer() const {
#if defined(EDB_X86)
	return ptrace(PTRACE_PEEKUSER, tid_, offsetof(UserRegsStructX86, eip), 0);
#elif defined(EDB_X86_64)
	// NOTE(eteran): even when we debug a 32-bit app on a 64-bit debugger,
	// we use the 64-bit register struct here
	return ptrace(PTRACE_PEEKUSER, tid_, offsetof(UserRegsStructX86_64, rip), 0);
#elif defined(EDB_ARM32)
	return 0;
#elif defined(EDB_ARM64)
	return 0;
#endif
}

/**
 * @brief PlatformThread::getDebugRegister
 * @param n
 * @return
 */
unsigned long PlatformThread::getDebugRegister(std::size_t n) {
	size_t drOffset = offsetof(struct user, u_debugreg) + n * sizeof(user::u_debugreg[0]);
	return ptrace(PTRACE_PEEKUSER, tid_, drOffset, 0);
}

/**
 * @brief PlatformThread::setDebugRegister
 * @param n
 * @param value
 * @return
 */
long PlatformThread::setDebugRegister(std::size_t n, unsigned long value) {
	size_t drOffset = offsetof(struct user, u_debugreg) + n * sizeof(user::u_debugreg[0]);
	return ptrace(PTRACE_POKEUSER, tid_, drOffset, value);
}

/**
 * steps this thread one instruction, passing the signal that stopped it
 * (unless the signal was SIGSTOP)
 *
 * @brief PlatformThread::step
 * @return
 */
Status PlatformThread::step() {
	return core_->ptraceStep(tid_, resume_code(status_));
}

/**
 * steps this thread one instruction, passing the signal that stopped it
 * (unless the signal was SIGSTOP, or the passed status != DEBUG_EXCEPTION_NOT_HANDLED)
 *
 * @brief PlatformThread::step
 * @param status
 * @return
 */
Status PlatformThread::step(edb::EventStatus status) {
	const int code = (status == edb::DEBUG_EXCEPTION_NOT_HANDLED) ? resume_code(status_) : 0;
	return core_->ptraceStep(tid_, code);
}

}

```

`plugins/DebuggerCore/unix/openbsd/DebuggerCore.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DebuggerCore.h"
#include "PlatformEvent.h"
#include "PlatformRegion.h"
#include "PlatformState.h"
#include "State.h"
#include "string_hash.h"

#include <QDebug>
#include <QMessageBox>

#include <cerrno>
#include <cstring>

#include <fcntl.h>
#include <kvm.h>
#include <machine/reg.h>
#include <paths.h>
#include <signal.h>
#include <sys/exec.h>
#include <sys/lock.h>
#include <sys/mman.h>
#include <sys/param.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <unistd.h>
#include <uvm/uvm.h>

#define __need_process
#include <sys/proc.h>
#include <sys/sysctl.h>

namespace DebuggerCore {

namespace {

void SET_OK(bool &ok, long value) {
	ok = (value != -1) || (errno == 0);
}

int resume_code(int status) {
	if (WIFSIGNALED(status)) {
		return WTERMSIG(status);
	} else if (WIFSTOPPED(status)) {
		return WSTOPSIG(status);
	}
	return 0;
}

#if defined(OpenBSD) && (OpenBSD > 201205)
//------------------------------------------------------------------------------
// Name: load_vmmap_entries
// Desc: Download vmmap_entries from the kernel into our address space.
//       We fix up the addr tree while downloading.
//       Returns the size of the tree on success, or -1 on failure.
//       On failure, *rptr needs to be passed to unload_vmmap_entries to free
//       the lot.
//------------------------------------------------------------------------------
ssize_t load_vmmap_entries(kvm_t *kd, u_long kptr, struct vm_map_entry **rptr, struct vm_map_entry *parent) {
	struct vm_map_entry *entry;
	u_long left_kptr;
	u_long right_kptr;
	ssize_t left_sz;
	ssize_t right_sz;

	if (kptr == 0)
		return 0;

	/* Need space. */
	entry = (struct vm_map_entry *)malloc(sizeof(*entry));
	if (entry == NULL)
		return -1;

	/* Download entry at kptr. */
	if (!kvm_read(kd, kptr, (char *)entry, sizeof(*entry))) {
		free(entry);
		return -1;
	}

	/*
	 * Update addr pointers to have sane values in this address space.
	 * We save the kernel pointers in {left,right}_kptr, so we have them
	 * available to download children.
	 */
	left_kptr                         = (u_long)RB_LEFT(entry, daddrs.addr_entry);
	right_kptr                        = (u_long)RB_RIGHT(entry, daddrs.addr_entry);
	RB_LEFT(entry, daddrs.addr_entry) = RB_RIGHT(entry, daddrs.addr_entry) = NULL;
	/* Fill in parent pointer. */
	RB_PARENT(entry, daddrs.addr_entry) = parent;

	/*
	 * Consistent state reached, fill in *rptr.
	 */
	*rptr = entry;

	/*
	 * Download left, right.
	 * On failure, our map is in a state that can be handled by
	 * unload_vmmap_entries.
	 */
	left_sz = load_vmmap_entries(kd, left_kptr, &RB_LEFT(entry, daddrs.addr_entry), entry);
	if (left_sz == -1)
		return -1;
	right_sz = load_vmmap_entries(kd, right_kptr, &RB_RIGHT(entry, daddrs.addr_entry), entry);
	if (right_sz == -1)
		return -1;

	return 1 + left_sz + right_sz;
}

//------------------------------------------------------------------------------
// Name:
// Desc: Free the vmmap entries in the given tree.
//------------------------------------------------------------------------------
void unload_vmmap_entries(struct vm_map_entry *entry) {
	if (entry == NULL)
		return;

	unload_vmmap_entries(RB_LEFT(entry, daddrs.addr_entry));
	unload_vmmap_entries(RB_RIGHT(entry, daddrs.addr_entry));
	free(entry);
}

//------------------------------------------------------------------------------
// Name:
// Desc: Don't implement address comparison.
//------------------------------------------------------------------------------
int no_impl(void *p, void *q) {
	Q_UNUSED(p)
	Q_UNUSED(q)
	Q_ASSERT(0); /* Should not be called. */
	return 0;
}
#endif
}

#if defined(OpenBSD) && (OpenBSD > 201205)
RB_GENERATE(uvm_map_addr, vm_map_entry, daddrs.addr_entry, no_impl)
#endif

//------------------------------------------------------------------------------
// Name: DebuggerCore
// Desc: constructor
//------------------------------------------------------------------------------
DebuggerCore::DebuggerCore() {
#if defined(_SC_PAGESIZE)
	page_size_ = sysconf(_SC_PAGESIZE);
#elif defined(_SC_PAGE_SIZE)
	page_size_ = sysconf(_SC_PAGE_SIZE);
#else
	page_size_ = PAGE_SIZE;
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
bool DebuggerCore::has_extension(quint64 ext) const {
	return false;
}

//------------------------------------------------------------------------------
// Name: page_size
// Desc: returns the size of a page on this system
//------------------------------------------------------------------------------
size_t DebuggerCore::page_size() const {
	return page_size_;
}

//------------------------------------------------------------------------------
// Name: ~DebuggerCore
// Desc:
//------------------------------------------------------------------------------
DebuggerCore::~DebuggerCore() {
	detach();
}

//------------------------------------------------------------------------------
// Name: wait_debug_event
// Desc: waits for a debug event, msecs is a timeout
//      it will return false if an error or timeout occurs
//------------------------------------------------------------------------------
std::shared_ptr<const IDebugEvent> DebuggerCore::wait_debug_event(int msecs) {
	if (attached()) {
		int status;
		bool timeout;

		const edb::tid_t tid = native::waitpid_timeout(pid(), &status, 0, msecs, &timeout);
		if (!timeout) {
			if (tid > 0) {

				// normal event
				auto e = std::make_shared<PlatformEvent>();

				e->pid    = pid();
				e->tid    = tid;
				e->status = status;

				char errbuf[_POSIX2_LINE_MAX];
				if (kvm_t *const kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) {
					int rc;
					struct kinfo_proc *const kiproc = kvm_getprocs(kd, KERN_PROC_PID, pid(), sizeof(struct kinfo_proc), &rc);

					struct proc proc;
					kvm_read(kd, kiproc->p_paddr, &proc, sizeof(proc));

					e->fault_code_    = proc.p_sicode;
					e->fault_address_ = proc.p_sigval.sival_ptr;

					//printf("ps_sig   : %d\n", sigacts.ps_sig);
					//printf("ps_type  : %d\n", sigacts.ps_type);

					kvm_close(kd);
				} else {
					e->fault_code_    = 0;
					e->fault_address_ = 0;
				}

				active_thread_       = tid;
				threads_[tid].status = status;
				return e;
			}
		}
	}
	return nullptr;
}

//------------------------------------------------------------------------------
// Name: read_data
// Desc:
//------------------------------------------------------------------------------
long DebuggerCore::read_data(edb::address_t address, bool *ok) {

	Q_ASSERT(ok);

	errno        = 0;
	const long v = ptrace(PT_READ_D, pid(), reinterpret_cast<char *>(address), 0);
	SET_OK(*ok, v);
	return v;
}

//------------------------------------------------------------------------------
// Name: write_data
// Desc:
//------------------------------------------------------------------------------
bool DebuggerCore::write_data(edb::address_t address, long value) {
	return ptrace(PT_WRITE_D, pid(), reinterpret_cast<char *>(address), value) != -1;
}

//------------------------------------------------------------------------------
// Name: attach
// Desc:
//------------------------------------------------------------------------------
bool DebuggerCore::attach(edb::pid_t pid) {
	detach();

	const long ret = ptrace(PT_ATTACH, pid, 0, 0);
	if (ret == 0) {
		pid_           = pid;
		active_thread_ = pid;
		threads_.clear();
		threads_.insert(pid, thread_info());

		// TODO: attach to all of the threads
	}

	return ret == 0;
}

//------------------------------------------------------------------------------
// Name: detach
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::detach() {
	if (attached()) {

		// TODO: do i need to stop each thread first, and wait for them?

		clear_breakpoints();
		ptrace(PT_DETACH, pid(), 0, 0);
		pid_ = 0;
		threads_.clear();
	}
}

//------------------------------------------------------------------------------
// Name: kill
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::kill() {
	if (attached()) {
		clear_breakpoints();
		ptrace(PT_KILL, pid(), 0, 0);
		native::waitpid(pid(), 0, WAIT_ANY);
		pid_ = 0;
		threads_.clear();
	}
}

//------------------------------------------------------------------------------
// Name: pause
// Desc: stops *all* threads of a process
//------------------------------------------------------------------------------
void DebuggerCore::pause() {
	if (attached()) {
		for (auto it = threads_.begin(); it != threads_.end(); ++it) {
			::kill(it.key(), SIGSTOP);
		}
	}
}

//------------------------------------------------------------------------------
// Name: resume
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::resume(edb::EVENT_STATUS status) {
	// TODO: assert that we are paused

	if (attached()) {
		if (status != edb::DEBUG_STOP) {
			const edb::tid_t tid = active_thread();
			const int code       = (status == edb::DEBUG_EXCEPTION_NOT_HANDLED) ? resume_code(threads_[tid].status) : 0;
			ptrace(PT_CONTINUE, tid, reinterpret_cast<caddr_t>(1), code);
		}
	}
}

//------------------------------------------------------------------------------
// Name: step
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::step(edb::EVENT_STATUS status) {
	// TODO: assert that we are paused

	if (attached()) {
		if (status != edb::DEBUG_STOP) {
			const edb::tid_t tid = active_thread();
			const int code       = (status == edb::DEBUG_EXCEPTION_NOT_HANDLED) ? resume_code(threads_[tid].status) : 0;
			ptrace(PT_STEP, tid, reinterpret_cast<caddr_t>(1), code);
		}
	}
}

//------------------------------------------------------------------------------
// Name: get_state
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::get_state(State *state) {

	Q_ASSERT(state);

	// TODO: assert that we are paused
	auto state_impl = static_cast<PlatformState *>(state->impl_);

	if (attached()) {
		if (ptrace(PT_GETREGS, active_thread(), reinterpret_cast<char *>(&state_impl->regs_), 0) != -1) {
			// TODO
			state_impl->gs_base = 0;
			state_impl->fs_base = 0;
		}

		if (ptrace(PT_GETFPREGS, active_thread(), reinterpret_cast<char *>(&state_impl->fpregs_), 0) != -1) {
		}

		// TODO: Debug Registers

	} else {
		state->clear();
	}
}

//------------------------------------------------------------------------------
// Name: set_state
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::set_state(const State &state) {

	// TODO: assert that we are paused
	auto state_impl = static_cast<PlatformState *>(state.impl_);

	if (attached()) {
		ptrace(PT_SETREGS, active_thread(), reinterpret_cast<char *>(&state_impl->regs_), 0);

		// TODO: FPU
		// TODO: Debug Registers
	}
}

//------------------------------------------------------------------------------
// Name: open
// Desc:
//------------------------------------------------------------------------------
bool DebuggerCore::open(const QString &path, const QString &cwd, const QList<QByteArray> &args, const QString &tty) {
	detach();
	pid_t pid;

	switch (pid = fork()) {
	case 0:
		// we are in the child now...

		// set ourselves (the child proc) up to be traced
		ptrace(PT_TRACE_ME, 0, 0, 0);

		// redirect it's I/O
		if (!tty.isEmpty()) {
			FILE *const std_out = freopen(qPrintable(tty), "r+b", stdout);
			FILE *const std_in  = freopen(qPrintable(tty), "r+b", stdin);
			FILE *const std_err = freopen(qPrintable(tty), "r+b", stderr);

			Q_UNUSED(std_out)
			Q_UNUSED(std_in)
			Q_UNUSED(std_err)
		}

		// do the actual exec
		execute_process(path, cwd, args);

		// we should never get here!
		abort();
		break;
	case -1:
		// error!
		pid_ = 0;
		return false;
	default:
		// parent
		do {
			threads_.clear();

			int status;
			if (native::waitpid(pid, &status, 0) == -1) {
				return false;
			}

			// the very first event should be a STOP of type SIGTRAP
			if (!WIFSTOPPED(status) || WSTOPSIG(status) != SIGTRAP) {
				detach();
				return false;
			}

			// setup the first event data for the primary thread
			threads_.insert(pid, thread_info());
			pid_                 = pid;
			active_thread_       = pid;
			threads_[pid].status = status;
			return true;
		} while (0);
		break;
	}
}

//------------------------------------------------------------------------------
// Name: set_active_thread
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::set_active_thread(edb::tid_t tid) {
	Q_ASSERT(threads_.contains(tid));
	active_thread_ = tid;
}

//------------------------------------------------------------------------------
// Name: create_state
// Desc:
//------------------------------------------------------------------------------
std::unique_ptr<IState> DebuggerCore::create_state() const {
	return std::make_unique<PlatformState>();
}

//------------------------------------------------------------------------------
// Name: enumerate_processes
// Desc:
//------------------------------------------------------------------------------
QMap<edb::pid_t, ProcessInfo> DebuggerCore::enumerate_processes() const {
	QMap<edb::pid_t, ProcessInfo> ret;

	char ebuffer[_POSIX2_LINE_MAX];
	int numprocs;

	if (kvm_t *const kaccess = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, ebuffer)) {
		if (struct kinfo_proc *const kprocaccess = kvm_getprocs(kaccess, KERN_PROC_ALL, 0, sizeof *kprocaccess, &numprocs)) {
			for (int i = 0; i < numprocs; ++i) {
				ProcessInfo procInfo;
				procInfo.pid  = kprocaccess[i].p_pid;
				procInfo.uid  = kprocaccess[i].p_uid;
				procInfo.name = kprocaccess[i].p_comm;

				ret.insert(procInfo.pid, procInfo);
			}
		}
		kvm_close(kaccess);
	} else {
		QMessageBox::warning(0, "Error Listing Processes", ebuffer);
	}

	return ret;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::process_exe(edb::pid_t pid) const {
	QString ret;

	char errbuf[_POSIX2_LINE_MAX];
	if (kvm_t *kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) {
		char p_comm[KI_MAXCOMLEN] = "";
		int rc;
		if (struct kinfo_proc *const proc = kvm_getprocs(kd, KERN_PROC_PID, pid, sizeof(struct kinfo_proc), &rc)) {
			memcpy(p_comm, proc->p_comm, sizeof(p_comm));
		}

		kvm_close(kd);
		return p_comm;
	}

	return ret;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::process_cwd(edb::pid_t pid) const {
	// TODO: implement this
	return QString();
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
edb::pid_t DebuggerCore::parent_pid(edb::pid_t pid) const {
	edb::pid_t ret = 0;
	char errbuf[_POSIX2_LINE_MAX];
	if (kvm_t *kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) {
		int rc;
		struct kinfo_proc *const proc = kvm_getprocs(kd, KERN_PROC_PID, pid, sizeof *proc, &rc);
		ret                           = proc->p_ppid;
		kvm_close(kd);
	}
	return ret;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QList<std::shared_ptr<IRegion>> DebuggerCore::memory_regions() const {

	QList<std::shared_ptr<IRegion>> regions;

	if (pid_ != 0) {

		char err_buf[_POSIX2_LINE_MAX];
		if (kvm_t *const kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, err_buf)) {
			int rc;
			struct kinfo_proc *const proc = kvm_getprocs(kd, KERN_PROC_PID, pid_, sizeof *proc, &rc);
			Q_ASSERT(proc);

			struct vmspace vmsp;

			kvm_read(kd, proc->p_vmspace, &vmsp, sizeof vmsp);

#if defined(OpenBSD) && (OpenBSD > 201205)
			uvm_map_addr root;
			RB_INIT(&root);
			if (load_vmmap_entries(kd, (u_long)RB_ROOT(&vmsp.vm_map.addr), &RB_ROOT(&root), NULL) == -1)
				goto do_unload;

			struct vm_map_entry *e;
			RB_FOREACH(e, uvm_map_addr, &root) {
				const edb::address_t start = e->start;
				const edb::address_t end   = e->end;
				const edb::address_t base  = e->offset;
				const QString name         = QString();
				const IRegion::permissions_t permissions =
					((e->protection & VM_PROT_READ) ? PROT_READ : 0) |
					((e->protection & VM_PROT_WRITE) ? PROT_WRITE : 0) |
					((e->protection & VM_PROT_EXECUTE) ? PROT_EXEC : 0);

				regions.push_back(std::make_shared<PlatformRegion>(start, end, base, name, permissions));
			}

		do_unload:
			unload_vmmap_entries(RB_ROOT(&root));
#else
			struct vm_map_entry e;
			if (vmsp.vm_map.header.next != 0) {
				kvm_read(kd, (u_long)vmsp.vm_map.header.next, &e, sizeof(e));
				while (e.next != vmsp.vm_map.header.next) {

					const edb::address_t start = e.start;
					const edb::address_t end   = e.end;
					const edb::address_t base  = e.offset;
					const QString name         = QString();
					const IRegion::permissions_t permissions =
						((e.protection & VM_PROT_READ) ? PROT_READ : 0) |
						((e.protection & VM_PROT_WRITE) ? PROT_WRITE : 0) |
						((e.protection & VM_PROT_EXECUTE) ? PROT_EXEC : 0);

					regions.push_back(std::make_shared<PlatformRegion>(start, end, base, name, permissions));
					kvm_read(kd, (u_long)e.next, &e, sizeof(e));
				}
			}
#endif
			kvm_close(kd);
		} else {
			fprintf(stderr, "sync: %s\n", err_buf);
			return QList<std::shared_ptr<IRegion>>();
		}
	}

	return regions;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QList<QByteArray> DebuggerCore::process_args(edb::pid_t pid) const {
	QList<QByteArray> ret;
	if (pid != 0) {

		// TODO: assert attached!
		char errbuf[_POSIX2_LINE_MAX];
		if (kvm_t *kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) {
			int rc;
			if (struct kinfo_proc *const proc = kvm_getprocs(kd, KERN_PROC_PID, sizeof *proc, pid, &rc)) {
				char **argv = kvm_getargv(kd, proc, 0);
				char **p    = argv;
				while (*p) {
					ret << *p++;
				}
			}
			kvm_close(kd);
		}
	}
	return ret;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
edb::address_t DebuggerCore::process_code_address() const {
	qDebug() << "TODO: implement DebuggerCore::process_code_address";
	return 0;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
edb::address_t DebuggerCore::process_data_address() const {
	qDebug() << "TODO: implement DebuggerCore::process_data_address";
	return 0;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QList<Module> DebuggerCore::loaded_modules() const {
	QList<Module> modules;
	qDebug() << "TODO: implement DebuggerCore::loaded_modules";
	return modules;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QDateTime DebuggerCore::process_start(edb::pid_t pid) const {
	qDebug() << "TODO: implement DebuggerCore::process_start";
	return QDateTime();
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
quint64 DebuggerCore::cpu_type() const {
#ifdef EDB_X86
	return edb::string_hash<'x', '8', '6'>::value;
#elif defined(EDB_X86_64)
	return edb::string_hash<'x', '8', '6', '-', '6', '4'>::value;
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::format_pointer(edb::address_t address) const {
	char buf[32];
#ifdef EDB_X86
	qsnprintf(buf, sizeof(buf), "%08x", address);
#elif defined(EDB_X86_64)
	qsnprintf(buf, sizeof(buf), "%016llx", address);
#endif
	return buf;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::stack_pointer() const {
#ifdef EDB_X86
	return "esp";
#elif defined(EDB_X86_64)
	return "rsp";
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::frame_pointer() const {
#ifdef EDB_X86
	return "ebp";
#elif defined(EDB_X86_64)
	return "rbp";
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::instruction_pointer() const {
#ifdef EDB_X86
	return "eip";
#elif defined(EDB_X86_64)
	return "rip";
#endif
}

}

```

`plugins/DebuggerCore/unix/openbsd/DebuggerCore.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DEBUGGER_CORE_H_20090529_
#define DEBUGGER_CORE_H_20090529_

#include "DebuggerCoreUNIX.h"
#include <QHash>

namespace DebuggerCore {

class DebuggerCore : public DebuggerCoreUNIX {
	Q_OBJECT
	Q_INTERFACES(IDebugger)
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	DebuggerCore();
	~DebuggerCore() override;

public:
	size_t page_size() const override;
	bool has_extension(quint64 ext) const override;
	std::shared_ptr<const IDebugEvent> wait_debug_event(int msecs) override;
	bool attach(edb::pid_t pid) override;
	void detach() override;
	void kill() override;
	void pause() override;
	void resume(edb::EVENT_STATUS status) override;
	void step(edb::EVENT_STATUS status) override;
	void get_state(State *state) override;
	void set_state(const State &state) override;
	bool open(const QString &path, const QString &cwd, const QList<QByteArray> &args, const QString &tty) override;

public:
	// thread support stuff (optional)
	QList<edb::tid_t> thread_ids() const override { return threads_.keys(); }
	edb::tid_t active_thread() const override { return active_thread_; }
	void set_active_thread(edb::tid_t) override;

public:
	QList<std::shared_ptr<IRegion>> memory_regions() const override;
	edb::address_t process_code_address() const override;
	edb::address_t process_data_address() const override;

public:
	std::unique_ptr<IState> create_state() const override;

public:
	// process properties
	QList<QByteArray> process_args(edb::pid_t pid) const override;
	QString process_exe(edb::pid_t pid) const override;
	QString process_cwd(edb::pid_t pid) const override;
	edb::pid_t parent_pid(edb::pid_t pid) const override;
	QDateTime process_start(edb::pid_t pid) const override;
	quint64 cpu_type() const override;

private:
	QMap<edb::pid_t, ProcessInfo> enumerate_processes() const override;
	QList<Module> loaded_modules() const override;

public:
	QString stack_pointer() const override;
	QString frame_pointer() const override;
	QString instruction_pointer() const override;

public:
	QString format_pointer(edb::address_t address) const override;

private:
	long read_data(edb::address_t address, bool *ok) override;
	bool write_data(edb::address_t address, long value) override;

private:
	struct thread_info {
	public:
		thread_info()
			: status(0) {
		}

		thread_info(int s)
			: status(s) {
		}

		int status;
	};

	using threadmap_t = QHash<edb::tid_t, thread_info>;

	size_t page_size_;
	threadmap_t threads_;
};

}

#endif

```

`plugins/DebuggerCore/unix/openbsd/PlatformEvent.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformEvent.h"
#include "edb.h"
#include <cstdio>
#include <cstring>
#include <fcntl.h>
#include <kvm.h>
#include <signal.h> // for the SIG* definitions
#include <sys/exec.h>
#include <sys/mman.h>
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/ptrace.h>
#include <sys/signalvar.h>
#include <sys/sysctl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <uvm/uvm.h>
#include <uvm/uvm_amap.h>

namespace DebuggerCore {

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
PlatformEvent::PlatformEvent()
	: status(0), pid(-1), tid(-1), fault_address_(0), fault_code_(0) {
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
PlatformEvent *PlatformEvent::clone() const {
	return new PlatformEvent(*this);
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
IDebugEvent::Message PlatformEvent::error_description() const {
	Q_ASSERT(is_error());

	auto fault_address = reinterpret_cast<edb::address_t>(fault_address_);

	switch (code()) {
	case SIGSEGV:
		return Message(
			tr("Illegal Access Fault"),
			tr(
				"<p>The debugged application encountered a segmentation fault.<br />The address <strong>0x%1</strong> could not be accessed.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>")
				.arg(edb::v1::format_pointer(fault_address)));
	case SIGILL:
		return Message(
			tr("Illegal Instruction Fault"),
			tr(
				"<p>The debugged application attempted to execute an illegal instruction.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
	case SIGFPE:
		switch (fault_code_) {
		case FPE_INTDIV:
			return Message(
				tr("Divide By Zero"),
				tr(
					"<p>The debugged application tried to divide an integer value by an integer divisor of zero.</p>"
					"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
		default:
			return Message(
				tr("Floating Point Exception"),
				tr(
					"<p>The debugged application encountered a floating-point exception.</p>"
					"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
		}

	case SIGABRT:
		return Message(
			tr("Application Aborted"),
			tr(
				"<p>The debugged application has aborted.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
	case SIGBUS:
		return Message(
			tr("Bus Error"),
			tr(
				"<p>The debugged application tried to read or write data that is misaligned.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
#ifdef SIGSTKFLT
	case SIGSTKFLT:
		return Message(
			tr("Stack Fault"),
			tr(
				"<p>The debugged application encountered a stack fault.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
#endif
	case SIGPIPE:
		return Message(
			tr("Broken Pipe Fault"),
			tr(
				"<p>The debugged application encountered a broken pipe fault.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
	default:
		return Message();
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
IDebugEvent::REASON PlatformEvent::reason() const {
	// this basically converts our value into a 'switchable' value for convenience

	if (stopped()) {
		return EVENT_STOPPED;
	} else if (terminated()) {
		return EVENT_TERMINATED;
	} else if (exited()) {
		return EVENT_EXITED;
	} else {
		return EVENT_UNKNOWN;
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
IDebugEvent::TRAP_REASON PlatformEvent::trap_reason() const {
	switch (fault_code_) {
	case TRAP_TRACE:
		return TRAP_STEPPING;
	default:
		return TRAP_BREAKPOINT;
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::exited() const {
	return WIFEXITED(status) != 0;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::is_error() const {
	if (stopped()) {
		switch (code()) {
		case SIGTRAP:
		case SIGSTOP:
			return false;
		case SIGSEGV:
		case SIGILL:
		case SIGFPE:
		case SIGABRT:
		case SIGBUS:
#ifdef SIGSTKFLT
		case SIGSTKFLT:
#endif
		case SIGPIPE:
			return true;
		default:
			return false;
		}
	} else {
		return false;
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::is_kill() const {
	return stopped() && code() == SIGKILL;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::is_stop() const {
	return stopped() && code() == SIGSTOP;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::is_trap() const {
	return stopped() && code() == SIGTRAP;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::terminated() const {
	return WIFSIGNALED(status) != 0;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::stopped() const {
	return WIFSTOPPED(status) != 0;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
edb::pid_t PlatformEvent::process() const {
	return pid;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
edb::tid_t PlatformEvent::thread() const {
	return tid;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
int64_t PlatformEvent::code() const {
	if (stopped()) {
		return WSTOPSIG(status);
	}

	if (terminated()) {
		return WTERMSIG(status);
	}

	if (exited()) {
		return WEXITSTATUS(status);
	}

	return 0;
}

}

```

`plugins/DebuggerCore/unix/openbsd/PlatformEvent.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_EVENT_H_20121005_
#define PLATFORM_EVENT_H_20121005_

#include "IDebugEvent.h"
#include <QCoreApplication>

namespace DebuggerCore {

class PlatformEvent : IDebugEvent {
	Q_DECLARE_TR_FUNCTIONS(PlatformEvent)
	friend class DebuggerCore;

public:
	PlatformEvent();

public:
	PlatformEvent *clone() const override;

public:
	Message error_description() const override;
	REASON reason() const override;
	TRAP_REASON trap_reason() const override;
	bool exited() const override;
	bool is_error() const override;
	bool is_kill() const override;
	bool is_stop() const override;
	bool is_trap() const override;
	bool terminated() const override;
	bool stopped() const override;
	edb::pid_t process() const override;
	edb::tid_t thread() const override;
	int64_t code() const override;

private:
	int status;
	edb::pid_t pid;
	edb::tid_t tid;
	void *fault_address_;
	long fault_code_;
};

}

#endif

```

`plugins/DebuggerCore/unix/openbsd/PlatformProcess.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformProcess.h"

```

`plugins/DebuggerCore/unix/openbsd/PlatformProcess.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_PROCESS_H_20150517_
#define PLATFORM_PROCESS_H_20150517_

#include "IProcess.h"

class PlatformProcess : public IProcess {
};

#endif

```

`plugins/DebuggerCore/unix/openbsd/PlatformRegion.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformRegion.h"

#include "IDebugEventHandler.h"
#include "IDebugger.h"
#include "MemoryRegions.h"
#include "State.h"
#include "edb.h"
#include <QMessageBox>
#include <sys/mman.h>
#include <sys/syscall.h>

namespace DebuggerCore {

PlatformRegion::PlatformRegion(edb::address_t start, edb::address_t end, edb::address_t base, const QString &name, permissions_t permissions)
	: start_(start), end_(end), base_(base), name_(name), permissions_(permissions) {
}

IRegion *PlatformRegion::clone() const {
	return new PlatformRegion(start_, end_, base_, name_, permissions_);
}

bool PlatformRegion::accessible() const {
	return readable() || writable() || executable();
}

bool PlatformRegion::readable() const {
	return (permissions_ & PROT_READ) != 0;
}

bool PlatformRegion::writable() const {
	return (permissions_ & PROT_WRITE) != 0;
}

bool PlatformRegion::executable() const {
	return (permissions_ & PROT_EXEC) != 0;
}

size_t PlatformRegion::size() const {
	return end_ - start_;
}

void PlatformRegion::set_permissions(bool read, bool write, bool execute) {
	Q_UNUSED(read)
	Q_UNUSED(write)
	Q_UNUSED(execute)
}

edb::address_t PlatformRegion::start() const {
	return start_;
}

edb::address_t PlatformRegion::end() const {
	return end_;
}

edb::address_t PlatformRegion::base() const {
	return base_;
}

QString PlatformRegion::name() const {
	return name_;
}

IRegion::permissions_t PlatformRegion::permissions() const {
	return permissions_;
}

void PlatformRegion::set_start(edb::address_t address) {
	start_ = address;
}

void PlatformRegion::set_end(edb::address_t address) {
	end_ = address;
}

}

```

`plugins/DebuggerCore/unix/openbsd/PlatformRegion.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_REGION_H_20120330_
#define PLATFORM_REGION_H_20120330_

#include "IRegion.h"
#include <QCoreApplication>
#include <QString>

namespace DebuggerCore {

class PlatformRegion : public IRegion {
	Q_DECLARE_TR_FUNCTIONS(PlatformRegion)

public:
	PlatformRegion(edb::address_t start, edb::address_t end, edb::address_t base, const QString &name, permissions_t permissions);
	~PlatformRegion() override = default;

public:
	IRegion *clone() const override;

public:
	bool accessible() const override;
	bool readable() const override;
	bool writable() const override;
	bool executable() const override;
	size_t size() const override;

public:
	void set_permissions(bool read, bool write, bool execute) override;
	void set_start(edb::address_t address) override;
	void set_end(edb::address_t address) override;

public:
	edb::address_t start() const override;
	edb::address_t end() const override;
	edb::address_t base() const override;
	QString name() const override;
	permissions_t permissions() const override;

private:
	edb::address_t start_;
	edb::address_t end_;
	edb::address_t base_;
	QString name_;
	permissions_t permissions_;
};

}

#endif

```

`plugins/DebuggerCore/unix/openbsd/PlatformState.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformState.h"

namespace DebuggerCore {

//------------------------------------------------------------------------------
// Name: PlatformState
// Desc:
//------------------------------------------------------------------------------
PlatformState::PlatformState() {
	memset(&regs_, 0, sizeof(regs_));
	memset(&fpregs_, 0, sizeof(fpregs_));
	memset(&dr_, 0, sizeof(dr_));
	fs_base = 0;
	gs_base = 0;
}

//------------------------------------------------------------------------------
// Name: PlatformState::clone
// Desc: makes a copy of the state object
//------------------------------------------------------------------------------
std::unique_ptr<IState> PlatformState::clone() const {
	return std::make_unique<PlatformState>(*this);
}

//------------------------------------------------------------------------------
// Name: flags_to_string
// Desc: returns the flags in a string form appropriate for this platform
//------------------------------------------------------------------------------
QString PlatformState::flags_to_string(edb::reg_t flags) const {
	char buf[14];
	qsnprintf(
		buf,
		sizeof(buf),
		"%c %c %c %c %c %c %c",
		((flags & 0x001) ? 'C' : 'c'),
		((flags & 0x004) ? 'P' : 'p'),
		((flags & 0x010) ? 'A' : 'a'),
		((flags & 0x040) ? 'Z' : 'z'),
		((flags & 0x080) ? 'S' : 's'),
		((flags & 0x400) ? 'D' : 'd'),
		((flags & 0x800) ? 'O' : 'o'));

	return buf;
}

//------------------------------------------------------------------------------
// Name: flags_to_string
// Desc: returns the flags in a string form appropriate for this platform
//------------------------------------------------------------------------------
QString PlatformState::flags_to_string() const {
	return flags_to_string(flags());
}

//------------------------------------------------------------------------------
// Name: value
// Desc: returns a Register object which represents the register with the name
//       supplied
//------------------------------------------------------------------------------
Register PlatformState::value(const QString &reg) const {
	const QString lreg = reg.toLower();

#if defined(EDB_X86)
	if (lreg == "eax")
		return Register("eax", regs_.r_eax, Register::TYPE_GPR);
	else if (lreg == "ebx")
		return Register("ebx", regs_.r_ebx, Register::TYPE_GPR);
	else if (lreg == "ecx")
		return Register("ecx", regs_.r_ecx, Register::TYPE_GPR);
	else if (lreg == "edx")
		return Register("edx", regs_.r_edx, Register::TYPE_GPR);
	else if (lreg == "ebp")
		return Register("ebp", regs_.r_ebp, Register::TYPE_GPR);
	else if (lreg == "esp")
		return Register("esp", regs_.r_esp, Register::TYPE_GPR);
	else if (lreg == "esi")
		return Register("esi", regs_.r_esi, Register::TYPE_GPR);
	else if (lreg == "edi")
		return Register("edi", regs_.r_edi, Register::TYPE_GPR);
	else if (lreg == "eip")
		return Register("eip", regs_.r_eip, Register::TYPE_IP);
	else if (lreg == "ax")
		return Register("ax", regs_.r_eax & 0xffff, Register::TYPE_GPR);
	else if (lreg == "bx")
		return Register("bx", regs_.r_ebx & 0xffff, Register::TYPE_GPR);
	else if (lreg == "cx")
		return Register("cx", regs_.r_ecx & 0xffff, Register::TYPE_GPR);
	else if (lreg == "dx")
		return Register("dx", regs_.r_edx & 0xffff, Register::TYPE_GPR);
	else if (lreg == "bp")
		return Register("bp", regs_.r_ebp & 0xffff, Register::TYPE_GPR);
	else if (lreg == "sp")
		return Register("sp", regs_.r_esp & 0xffff, Register::TYPE_GPR);
	else if (lreg == "si")
		return Register("si", regs_.r_esi & 0xffff, Register::TYPE_GPR);
	else if (lreg == "di")
		return Register("di", regs_.r_edi & 0xffff, Register::TYPE_GPR);
	else if (lreg == "al")
		return Register("al", regs_.r_eax & 0xff, Register::TYPE_GPR);
	else if (lreg == "bl")
		return Register("bl", regs_.r_ebx & 0xff, Register::TYPE_GPR);
	else if (lreg == "cl")
		return Register("cl", regs_.r_ecx & 0xff, Register::TYPE_GPR);
	else if (lreg == "dl")
		return Register("dl", regs_.r_edx & 0xff, Register::TYPE_GPR);
	else if (lreg == "ah")
		return Register("ah", (regs_.r_eax >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "bh")
		return Register("bh", (regs_.r_ebx >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "ch")
		return Register("ch", (regs_.r_ecx >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "dh")
		return Register("dh", (regs_.r_edx >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "cs")
		return Register("cs", regs_.r_cs, Register::TYPE_SEG);
	else if (lreg == "ds")
		return Register("ds", regs_.r_ds, Register::TYPE_SEG);
	else if (lreg == "es")
		return Register("es", regs_.r_es, Register::TYPE_SEG);
	else if (lreg == "fs")
		return Register("fs", regs_.r_fs, Register::TYPE_SEG);
	else if (lreg == "gs")
		return Register("gs", regs_.r_gs, Register::TYPE_SEG);
	else if (lreg == "ss")
		return Register("ss", regs_.r_ss, Register::TYPE_SEG);
	else if (lreg == "fs_base")
		return Register("fs_base", fs_base, Register::TYPE_SEG);
	else if (lreg == "gs_base")
		return Register("gs_base", gs_base, Register::TYPE_SEG);
	else if (lreg == "eflags")
		return Register("eflags", regs_.r_eflags, Register::TYPE_COND);
#elif defined(EDB_X86_64)
	if (lreg == "rax")
		return Register("rax", regs_.r_rax, Register::TYPE_GPR);
	else if (lreg == "rbx")
		return Register("rbx", regs_.r_rbx, Register::TYPE_GPR);
	else if (lreg == "rcx")
		return Register("rcx", regs_.r_rcx, Register::TYPE_GPR);
	else if (lreg == "rdx")
		return Register("rdx", regs_.r_rdx, Register::TYPE_GPR);
	else if (lreg == "rbp")
		return Register("rbp", regs_.r_rbp, Register::TYPE_GPR);
	else if (lreg == "rsp")
		return Register("rsp", regs_.r_rsp, Register::TYPE_GPR);
	else if (lreg == "rsi")
		return Register("rsi", regs_.r_rsi, Register::TYPE_GPR);
	else if (lreg == "rdi")
		return Register("rdi", regs_.r_rdi, Register::TYPE_GPR);
	else if (lreg == "rip")
		return Register("rip", regs_.r_rip, Register::TYPE_IP);
	else if (lreg == "r8")
		return Register("r8", regs_.r_r8, Register::TYPE_GPR);
	else if (lreg == "r9")
		return Register("r9", regs_.r_r9, Register::TYPE_GPR);
	else if (lreg == "r10")
		return Register("r10", regs_.r_r10, Register::TYPE_GPR);
	else if (lreg == "r11")
		return Register("r11", regs_.r_r11, Register::TYPE_GPR);
	else if (lreg == "r12")
		return Register("r12", regs_.r_r12, Register::TYPE_GPR);
	else if (lreg == "r13")
		return Register("r13", regs_.r_r13, Register::TYPE_GPR);
	else if (lreg == "r14")
		return Register("r14", regs_.r_r14, Register::TYPE_GPR);
	else if (lreg == "r15")
		return Register("r15", regs_.r_r15, Register::TYPE_GPR);
	else if (lreg == "eax")
		return Register("eax", regs_.r_rax & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "ebx")
		return Register("ebx", regs_.r_rbx & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "ecx")
		return Register("ecx", regs_.r_rcx & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "edx")
		return Register("edx", regs_.r_rdx & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "ebp")
		return Register("ebp", regs_.r_rbp & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "esp")
		return Register("esp", regs_.r_rsp & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "esi")
		return Register("esi", regs_.r_rsi & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "edi")
		return Register("edi", regs_.r_rdi & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r8d")
		return Register("r8d", regs_.r_r8 & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r9d")
		return Register("r9d", regs_.r_r9 & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r10d")
		return Register("r10d", regs_.r_r10 & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r11d")
		return Register("r11d", regs_.r_r11 & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r12d")
		return Register("r12d", regs_.r_r12 & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r13d")
		return Register("r13d", regs_.r_r13 & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r14d")
		return Register("r14d", regs_.r_r14 & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r15d")
		return Register("r15d", regs_.r_r15 & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "ax")
		return Register("ax", regs_.r_rax & 0xffff, Register::TYPE_GPR);
	else if (lreg == "bx")
		return Register("bx", regs_.r_rbx & 0xffff, Register::TYPE_GPR);
	else if (lreg == "cx")
		return Register("cx", regs_.r_rcx & 0xffff, Register::TYPE_GPR);
	else if (lreg == "dx")
		return Register("dx", regs_.r_rdx & 0xffff, Register::TYPE_GPR);
	else if (lreg == "bp")
		return Register("bp", regs_.r_rbp & 0xffff, Register::TYPE_GPR);
	else if (lreg == "sp")
		return Register("sp", regs_.r_rsp & 0xffff, Register::TYPE_GPR);
	else if (lreg == "si")
		return Register("si", regs_.r_rsi & 0xffff, Register::TYPE_GPR);
	else if (lreg == "di")
		return Register("di", regs_.r_rdi & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r8w")
		return Register("r8w", regs_.r_r8 & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r9w")
		return Register("r9w", regs_.r_r9 & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r10w")
		return Register("r10w", regs_.r_r10 & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r11w")
		return Register("r11w", regs_.r_r11 & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r12w")
		return Register("r12w", regs_.r_r12 & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r13w")
		return Register("r13w", regs_.r_r13 & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r14w")
		return Register("r14w", regs_.r_r14 & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r15w")
		return Register("r15w", regs_.r_r15 & 0xffff, Register::TYPE_GPR);
	else if (lreg == "al")
		return Register("al", regs_.r_rax & 0xff, Register::TYPE_GPR);
	else if (lreg == "bl")
		return Register("bl", regs_.r_rbx & 0xff, Register::TYPE_GPR);
	else if (lreg == "cl")
		return Register("cl", regs_.r_rcx & 0xff, Register::TYPE_GPR);
	else if (lreg == "dl")
		return Register("dl", regs_.r_rdx & 0xff, Register::TYPE_GPR);
	else if (lreg == "ah")
		return Register("ah", (regs_.r_rax >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "bh")
		return Register("bh", (regs_.r_rbx >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "ch")
		return Register("ch", (regs_.r_rcx >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "dh")
		return Register("dh", (regs_.r_rdx >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "spl")
		return Register("spl", (regs_.r_rsp >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "bpl")
		return Register("bpl", (regs_.r_rbp >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "sil")
		return Register("sil", (regs_.r_rsi >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "dil")
		return Register("dil", (regs_.r_rdi >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "r8b")
		return Register("r8b", regs_.r_r8 & 0xff, Register::TYPE_GPR);
	else if (lreg == "r9b")
		return Register("r9b", regs_.r_r9 & 0xff, Register::TYPE_GPR);
	else if (lreg == "r10b")
		return Register("r10b", regs_.r_r10 & 0xff, Register::TYPE_GPR);
	else if (lreg == "r11b")
		return Register("r11b", regs_.r_r11 & 0xff, Register::TYPE_GPR);
	else if (lreg == "r12b")
		return Register("r12b", regs_.r_r12 & 0xff, Register::TYPE_GPR);
	else if (lreg == "r13b")
		return Register("r13b", regs_.r_r13 & 0xff, Register::TYPE_GPR);
	else if (lreg == "r14b")
		return Register("r14b", regs_.r_r14 & 0xff, Register::TYPE_GPR);
	else if (lreg == "r15b")
		return Register("r15b", regs_.r_r15 & 0xff, Register::TYPE_GPR);
	else if (lreg == "cs")
		return Register("cs", regs_.r_cs, Register::TYPE_SEG);
	else if (lreg == "ds")
		return Register("ds", regs_.r_ds, Register::TYPE_SEG);
	else if (lreg == "es")
		return Register("es", regs_.r_es, Register::TYPE_SEG);
	else if (lreg == "fs")
		return Register("fs", regs_.r_fs, Register::TYPE_SEG);
	else if (lreg == "gs")
		return Register("gs", regs_.r_gs, Register::TYPE_SEG);
	else if (lreg == "ss")
		return Register("ss", regs_.r_ss, Register::TYPE_SEG);
	else if (lreg == "fs_base")
		return Register("fs_base", fs_base, Register::TYPE_SEG);
	else if (lreg == "gs_base")
		return Register("gs_base", gs_base, Register::TYPE_SEG);
	else if (lreg == "rflags")
		return Register("rflags", regs_.r_rflags, Register::TYPE_COND);
#endif

	return Register();
}

//------------------------------------------------------------------------------
// Name: frame_pointer
// Desc: returns what is conceptually the frame pointer for this platform
//------------------------------------------------------------------------------
edb::address_t PlatformState::frame_pointer() const {
#if defined(EDB_X86)
	return regs_.r_ebp;
#elif defined(EDB_X86_64)
	return regs_.r_rbp;
#endif
}

//------------------------------------------------------------------------------
// Name: instruction_pointer
// Desc: returns the instruction pointer for this platform
//------------------------------------------------------------------------------
edb::address_t PlatformState::instruction_pointer() const {
#if defined(EDB_X86)
	return regs_.r_eip;
#elif defined(EDB_X86_64)
	return regs_.r_rip;
#endif
}

//------------------------------------------------------------------------------
// Name: stack_pointer
// Desc: returns the stack pointer for this platform
//------------------------------------------------------------------------------
edb::address_t PlatformState::stack_pointer() const {
#if defined(EDB_X86)
	return regs_.r_esp;
#elif defined(EDB_X86_64)
	return regs_.r_rsp;
#endif
}

//------------------------------------------------------------------------------
// Name: debug_register
// Desc:
//------------------------------------------------------------------------------
edb::reg_t PlatformState::debug_register(int n) const {
	return dr_[n];
}

//------------------------------------------------------------------------------
// Name: flags
// Desc:
//------------------------------------------------------------------------------
edb::reg_t PlatformState::flags() const {
#if defined(EDB_X86)
	return regs_.r_eflags;
#elif defined(EDB_X86_64)
	return regs_.r_rflags;
#endif
}

//------------------------------------------------------------------------------
// Name: fpu_register
// Desc:
//------------------------------------------------------------------------------
long double PlatformState::fpu_register(int n) const {
	return reinterpret_cast<const long double *>(&fpregs_)[n];
}

//------------------------------------------------------------------------------
// Name: adjust_stack
// Desc:
//------------------------------------------------------------------------------
void PlatformState::adjust_stack(int bytes) {
#if defined(EDB_X86)
	regs_.r_esp += bytes;
#elif defined(EDB_X86_64)
	regs_.r_rsp += bytes;
#endif
}

//------------------------------------------------------------------------------
// Name: clear
// Desc:
//------------------------------------------------------------------------------
void PlatformState::clear() {
	memset(&regs_, 0, sizeof(regs_));
	memset(&fpregs_, 0, sizeof(fpregs_));
	memset(&dr_, 0, sizeof(dr_));
#if defined(EDB_X86)
	fs_base = 0;
	gs_base = 0;
#endif
}

//------------------------------------------------------------------------------
// Name: set_debug_register
// Desc:
//------------------------------------------------------------------------------
void PlatformState::set_debug_register(int n, edb::reg_t value) {
	dr_[n] = value;
}

//------------------------------------------------------------------------------
// Name: set_flags
// Desc:
//------------------------------------------------------------------------------
void PlatformState::set_flags(edb::reg_t flags) {
#if defined(EDB_X86)
	regs_.r_eflags = flags;
#elif defined(EDB_X86_64)
	regs_.r_rflags = flags;
#endif
}

//------------------------------------------------------------------------------
// Name: set_instruction_pointer
// Desc:
//------------------------------------------------------------------------------
void PlatformState::set_instruction_pointer(edb::address_t value) {
#if defined(EDB_X86)
	regs_.r_eip = value;
#elif defined(EDB_X86_64)
	regs_.r_rip = value;
#endif
}

//------------------------------------------------------------------------------
// Name: set_register
// Desc:
//------------------------------------------------------------------------------
void PlatformState::set_register(const QString &name, edb::reg_t value) {

	const QString lreg = name.toLower();
#if defined(EDB_X86)
	if (lreg == "eax") {
		regs_.r_eax = value;
	} else if (lreg == "ebx") {
		regs_.r_ebx = value;
	} else if (lreg == "ecx") {
		regs_.r_ecx = value;
	} else if (lreg == "edx") {
		regs_.r_edx = value;
	} else if (lreg == "ebp") {
		regs_.r_ebp = value;
	} else if (lreg == "esp") {
		regs_.r_esp = value;
	} else if (lreg == "esi") {
		regs_.r_esi = value;
	} else if (lreg == "edi") {
		regs_.r_edi = value;
	} else if (lreg == "eip") {
		regs_.r_eip = value;
	} else if (lreg == "cs") {
		regs_.r_cs = value;
	} else if (lreg == "ds") {
		regs_.r_ds = value;
	} else if (lreg == "es") {
		regs_.r_es = value;
	} else if (lreg == "fs") {
		regs_.r_fs = value;
	} else if (lreg == "gs") {
		regs_.r_gs = value;
	} else if (lreg == "ss") {
		regs_.r_ss = value;
	} else if (lreg == "eflags") {
		regs_.r_eflags = value;
	}
#elif defined(EDB_X86_64)
	if (lreg == "rax") {
		regs_.r_rax = value;
	} else if (lreg == "rbx") {
		regs_.r_rbx = value;
	} else if (lreg == "rcx") {
		regs_.r_rcx = value;
	} else if (lreg == "rdx") {
		regs_.r_rdx = value;
	} else if (lreg == "rbp") {
		regs_.r_rbp = value;
	} else if (lreg == "rsp") {
		regs_.r_rsp = value;
	} else if (lreg == "rsi") {
		regs_.r_rsi = value;
	} else if (lreg == "rdi") {
		regs_.r_rdi = value;
	} else if (lreg == "r8") {
		regs_.r_r8 = value;
	} else if (lreg == "r9") {
		regs_.r_r9 = value;
	} else if (lreg == "r10") {
		regs_.r_r10 = value;
	} else if (lreg == "r11") {
		regs_.r_r11 = value;
	} else if (lreg == "r12") {
		regs_.r_r12 = value;
	} else if (lreg == "r13") {
		regs_.r_r13 = value;
	} else if (lreg == "r14") {
		regs_.r_r14 = value;
	} else if (lreg == "r15") {
		regs_.r_r15 = value;
	} else if (lreg == "rip") {
		regs_.r_rip = value;
	} else if (lreg == "cs") {
		regs_.r_cs = value;
	} else if (lreg == "ds") {
		regs_.r_ds = value;
	} else if (lreg == "es") {
		regs_.r_es = value;
	} else if (lreg == "fs") {
		regs_.r_fs = value;
	} else if (lreg == "gs") {
		regs_.r_gs = value;
	} else if (lreg == "ss") {
		regs_.r_ss = value;
	} else if (lreg == "rflags") {
		regs_.r_rflags = value;
	}
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
quint64 PlatformState::mmx_register(int n) const {
	Q_UNUSED(n)
	return 0;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QByteArray PlatformState::xmm_register(int n) const {
	Q_UNUSED(n)
	return QByteArray();
}

}

```

`plugins/DebuggerCore/unix/openbsd/PlatformState.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_STATE_H_20110330_
#define PLATFORM_STATE_H_20110330_

#include "IState.h"
#include "Types.h"
#include <machine/reg.h>
#include <sys/types.h>

namespace DebuggerCore {

class PlatformState : public IState {
	friend class DebuggerCore;

public:
	PlatformState();

public:
	std::unique_ptr<IState> clone() const override;

public:
	QString flagsToString() const override;
	QString flagsToString(edb::reg_t flags) const override;
	Register value(const QString &reg) const override;
	edb::address_t frame_pointer() const override;
	edb::address_t instruction_pointer() const override;
	edb::address_t stack_pointer() const override;
	edb::reg_t debug_register(int n) const override;
	edb::reg_t flags() const override;
	long double fpu_register(int n) const override;
	void adjust_stack(int bytes) override;
	void clear() override;
	void set_debug_register(int n, edb::reg_t value) override;
	void set_flags(edb::reg_t flags) override;
	void set_instruction_pointer(edb::address_t value) override;
	void set_register(const QString &name, edb::reg_t value) override;
	quint64 mmx_register(int n) const override;
	QByteArray xmm_register(int n) const override;

private:
	struct reg regs_;
	struct fpreg fpregs_;
	edb::reg_t dr_[8];
	edb::address_t fs_base;
	edb::address_t gs_base;
};

}

#endif

```

`plugins/DebuggerCore/unix/osx/DebuggerCore.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DebuggerCore.h"
#include "PlatformEvent.h"
#include "PlatformRegion.h"
#include "PlatformState.h"
#include "State.h"
#include "string_hash.h"

#include <QDebug>

#include <fcntl.h>
#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <mach/vm_region.h>
#include <mach/vm_statistics.h>
#include <paths.h>
#include <signal.h>
#include <sys/mman.h>
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/ptrace.h>
#include <sys/sysctl.h>
#include <sys/types.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <unistd.h>

namespace DebuggerCore {

namespace {
int resume_code(int status) {
	if (WIFSIGNALED(status)) {
		return WTERMSIG(status);
	} else if (WIFSTOPPED(status)) {
		return WSTOPSIG(status);
	}
	return 0;
}
}

//------------------------------------------------------------------------------
// Name: DebuggerCore
// Desc: constructor
//------------------------------------------------------------------------------
DebuggerCore::DebuggerCore() {
	page_size_ = 0x1000;
}

//------------------------------------------------------------------------------
// Name: ~DebuggerCore
// Desc:
//------------------------------------------------------------------------------
DebuggerCore::~DebuggerCore() {
	detach();
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
bool DebuggerCore::has_extension(quint64 ext) const {
	return false;
}

//------------------------------------------------------------------------------
// Name: page_size
// Desc: returns the size of a page on this system
//------------------------------------------------------------------------------
size_t DebuggerCore::page_size() const {
	return page_size_;
}

//------------------------------------------------------------------------------
// Name: wait_debug_event
// Desc: waits for a debug event, secs is a timeout (but is not yet respected)
//       ok will be set to false if the timeout expires
//------------------------------------------------------------------------------
std::shared_ptr<const IDebugEvent> DebuggerCore::wait_debug_event(int msecs) {
	if (attached()) {
		int status;
		bool timeout;

		const edb::tid_t tid = native::waitpid_timeout(pid(), &status, 0, msecs, &timeout);
		if (!timeout) {
			if (tid > 0) {
				// normal event
				auto e    = std::make_shared<PlatformEvent>();
				e->pid    = pid();
				e->tid    = tid;
				e->status = status;

				active_thread_       = tid;
				threads_[tid].status = status;
				return e;
			}
		}
	}
	return nullptr;
}

//------------------------------------------------------------------------------
// Name: read_data
// Desc:
//------------------------------------------------------------------------------
long DebuggerCore::read_data(edb::address_t address, bool *ok) {

	Q_ASSERT(ok);

	mach_port_t task;
	kern_return_t err = task_for_pid(mach_task_self(), pid(), &task);
	if (err != KERN_SUCCESS) {
		qDebug("task_for_pid() failed with %x [%d]", err, pid());
		*ok = false;
		return -1;
	}

	long x;
	vm_size_t size;
	*ok = vm_read_overwrite(task, address, sizeof(long), (vm_address_t)&x, &size) == 0;
	return x;
}

//------------------------------------------------------------------------------
// Name: write_data
// Desc:
//------------------------------------------------------------------------------
bool DebuggerCore::write_data(edb::address_t address, long value) {
	return ptrace(PT_WRITE_D, pid(), (char *)address, value) != -1;
}

//------------------------------------------------------------------------------
// Name: attach
// Desc:
//------------------------------------------------------------------------------
bool DebuggerCore::attach(edb::pid_t pid) {
	detach();

	const long ret = ptrace(PT_ATTACH, pid, 0, 0);
	if (ret == 0) {
		pid_           = pid;
		active_thread_ = pid;
		threads_.clear();
		threads_.insert(pid, thread_info());

		// TODO: attach to all of the threads
	}

	return ret == 0;
}

//------------------------------------------------------------------------------
// Name: detach
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::detach() {
	if (attached()) {

		// TODO: do i need to stop each thread first, and wait for them?

		clear_breakpoints();
		for (auto it = threads_.begin(); it != threads_.end(); ++it) {
			ptrace(PT_DETACH, it.key(), 0, 0);
		}

		pid_ = 0;
		threads_.clear();
	}
}

//------------------------------------------------------------------------------
// Name: kill
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::kill() {
	if (attached()) {
		clear_breakpoints();
		ptrace(PT_KILL, pid(), 0, 0);
		native::waitpid(pid(), 0, WAIT_ANY);
		pid_ = 0;
		threads_.clear();
	}
}

//------------------------------------------------------------------------------
// Name: pause
// Desc: stops *all* threads of a process
//------------------------------------------------------------------------------
void DebuggerCore::pause() {
	if (attached()) {
		for (auto it = threads_.begin(); it != threads_.end(); ++it) {
			::kill(it.key(), SIGSTOP);
		}
	}
}

//------------------------------------------------------------------------------
// Name: resume
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::resume(edb::EVENT_STATUS status) {
	// TODO: assert that we are paused

	if (attached()) {
		if (status != edb::DEBUG_STOP) {
			const edb::tid_t tid = active_thread();
			const int code       = (status == edb::DEBUG_EXCEPTION_NOT_HANDLED) ? resume_code(threads_[tid].status) : 0;
			ptrace(PT_CONTINUE, tid, reinterpret_cast<caddr_t>(1), code);
		}
	}
}

//------------------------------------------------------------------------------
// Name: step
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::step(edb::EVENT_STATUS status) {
	// TODO: assert that we are paused

	if (attached()) {
		if (status != edb::DEBUG_STOP) {
			const edb::tid_t tid = active_thread();
			const int code       = (status == edb::DEBUG_EXCEPTION_NOT_HANDLED) ? resume_code(threads_[tid].status) : 0;
			ptrace(PT_STEP, tid, reinterpret_cast<caddr_t>(1), code);
		}
	}
}

//------------------------------------------------------------------------------
// Name: get_state
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::get_state(State *state) {

	Q_ASSERT(state);

	// TODO: assert that we are paused
	auto state_impl = static_cast<PlatformState *>(state->impl_);

	if (attached()) {

		/* Get the mach task for the target process */
		mach_port_t task;
		kern_return_t err = task_for_pid(mach_task_self(), pid(), &task);
		if (err != KERN_SUCCESS) {
			qDebug("task_for_pid() failed with %x [%d]", err, pid());
			return;
		}

		/* Suspend the target process */
		err = task_suspend(task);
		if (err != KERN_SUCCESS) {
			qDebug("task_suspend() failed");
			return;
		}

		/* Get all threads in the specified task */
		thread_act_port_array_t thread_list;
		mach_msg_type_number_t thread_count;

		err = task_threads(task, &thread_list, &thread_count);
		if (err != KERN_SUCCESS) {
			qDebug("task_threads() failed");
			err = task_resume(task);
			if (err != KERN_SUCCESS) {
				qDebug("task_resume() failed");
			}
		}

		Q_ASSERT(thread_count > 0);

#ifdef EDB_X86
		mach_msg_type_number_t state_count           = x86_THREAD_STATE32_COUNT;
		const thread_state_flavor_t flavor           = x86_THREAD_STATE32;
		const thread_state_flavor_t debug_flavor     = x86_DEBUG_STATE32;
		const thread_state_flavor_t fpu_flavor       = x86_FLOAT_STATE32;
		const thread_state_flavor_t exception_flavor = x86_EXCEPTION_STATE32;
#elif defined(EDB_X86_64)
		mach_msg_type_number_t state_count           = x86_THREAD_STATE64_COUNT;
		const thread_state_flavor_t flavor           = x86_THREAD_STATE64;
		const thread_state_flavor_t debug_flavor     = x86_DEBUG_STATE64;
		const thread_state_flavor_t fpu_flavor       = x86_FLOAT_STATE64;
		const thread_state_flavor_t exception_flavor = x86_EXCEPTION_STATE64;
#endif
		// TODO Get all threads, not just the first one.
		err = thread_get_state(
			thread_list[0],
			flavor,
			(thread_state_t)&state_impl->thread_state_,
			&state_count);

		if (err != KERN_SUCCESS) {
			qDebug("thread_get_state() failed with %.08x", err);
			err = task_resume(task);
			if (err != KERN_SUCCESS) {
				qDebug("task_resume() failed");
			}
			return;
		}

		err = thread_get_state(
			thread_list[0],
			debug_flavor,
			(thread_state_t)&state_impl->debug_state_,
			&state_count);

		if (err != KERN_SUCCESS) {
			qDebug("thread_get_state() failed with %.08x", err);
			err = task_resume(task);
			if (err != KERN_SUCCESS) {
				qDebug("task_resume() failed");
			}
			return;
		}

		err = thread_get_state(
			thread_list[0],
			fpu_flavor,
			(thread_state_t)&state_impl->float_state_,
			&state_count);

		if (err != KERN_SUCCESS) {
			qDebug("thread_get_state() failed with %.08x", err);
			err = task_resume(task);
			if (err != KERN_SUCCESS) {
				qDebug("task_resume() failed");
			}
			return;
		}

		err = thread_get_state(
			thread_list[0],
			exception_flavor,
			(thread_state_t)&state_impl->exception_state_,
			&state_count);

		if (err != KERN_SUCCESS) {
			qDebug("thread_get_state() failed with %.08x", err);
			err = task_resume(task);
			if (err != KERN_SUCCESS) {
				qDebug("task_resume() failed");
			}
			return;
		}
	} else {
		state->clear();
	}
}

//------------------------------------------------------------------------------
// Name: set_state
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::set_state(const State &state) {

	// TODO: assert that we are paused
	auto state_impl = static_cast<PlatformState *>(state.impl_);

	if (attached()) {

		/* Get the mach task for the target process */
		mach_port_t task;
		kern_return_t err = task_for_pid(mach_task_self(), pid(), &task);
		if (err != KERN_SUCCESS) {
			qDebug("task_for_pid() failed with %x [%d]", err, pid());
			return;
		}

		/* Suspend the target process */
		err = task_suspend(task);
		if (err != KERN_SUCCESS) {
			qDebug("task_suspend() failed");
		}

		/* Get all threads in the specified task */
		thread_act_port_array_t thread_list;
		mach_msg_type_number_t thread_count;
		err = task_threads(task, &thread_list, &thread_count);

		if (err != KERN_SUCCESS) {
			qDebug("task_threads() failed");
			err = task_resume(task);
			if (err != KERN_SUCCESS) {
				qDebug("task_resume() failed");
			}
		}

		Q_ASSERT(thread_count > 0);

#ifdef EDB_X86
		mach_msg_type_number_t state_count       = x86_THREAD_STATE32_COUNT;
		const thread_state_flavor_t flavor       = x86_THREAD_STATE32;
		const thread_state_flavor_t debug_flavor = x86_DEBUG_STATE32;
		//const thread_state_flavor_t fpu_flavor       = x86_FLOAT_STATE32;
		//const thread_state_flavor_t exception_flavor = x86_EXCEPTION_STATE32;
#elif defined(EDB_X86_64)
		mach_msg_type_number_t state_count       = x86_THREAD_STATE64_COUNT;
		const thread_state_flavor_t flavor       = x86_THREAD_STATE64;
		const thread_state_flavor_t debug_flavor = x86_DEBUG_STATE64;
		//const thread_state_flavor_t fpu_flavor       = x86_FLOAT_STATE64;
		//const thread_state_flavor_t exception_flavor = x86_EXCEPTION_STATE64;
#endif

		// TODO Set for specific thread, not first one
		err = thread_set_state(
			thread_list[0],
			flavor,
			(thread_state_t)&state_impl->thread_state_,
			state_count);

		if (err != KERN_SUCCESS) {
			qDebug("thread_set_state() failed with %.08x", err);
			err = task_resume(task);
			if (err != KERN_SUCCESS) {
				qDebug("task_resume() failed");
			}
			return;
		}

		err = thread_set_state(
			thread_list[0],
			debug_flavor,
			(thread_state_t)&state_impl->debug_state_,
			state_count);

		if (err != KERN_SUCCESS) {
			qDebug("thread_set_state() failed with %.08x", err);
			err = task_resume(task);
			if (err != KERN_SUCCESS) {
				qDebug("task_resume() failed");
			}
			return;
		}
	}
}

//------------------------------------------------------------------------------
// Name: open
// Desc:
//------------------------------------------------------------------------------
bool DebuggerCore::open(const QString &path, const QString &cwd, const QList<QByteArray> &args, const QString &tty) {
	detach();
	pid_t pid;

	switch (pid = fork()) {
	case 0:
		// we are in the child now...

		// set ourselves (the child proc) up to be traced
		ptrace(PT_TRACE_ME, 0, 0, 0);

		// redirect it's I/O
		if (!tty.isEmpty()) {
			FILE *const std_out = freopen(qPrintable(tty), "r+b", stdout);
			FILE *const std_in  = freopen(qPrintable(tty), "r+b", stdin);
			FILE *const std_err = freopen(qPrintable(tty), "r+b", stderr);

			Q_UNUSED(std_out)
			Q_UNUSED(std_in)
			Q_UNUSED(std_err)
		}

		// do the actual exec
		execute_process(path, cwd, args);

		// we should never get here!
		abort();
		break;
	case -1:
		// error!
		pid_ = 0;
		return false;
	default:
		// parent
		do {
			threads_.clear();

			int status;
			if (native::waitpid(pid, &status, 0) == -1) {
				return false;
			}

			// the very first event should be a STOP of type SIGTRAP
			if (!WIFSTOPPED(status) || WSTOPSIG(status) != SIGTRAP) {
				detach();
				return false;
			}

			// setup the first event data for the primary thread
			threads_.insert(pid, thread_info());
			pid_                 = pid;
			active_thread_       = pid;
			threads_[pid].status = status;
			return true;
		} while (0);
		break;
	}
}

//------------------------------------------------------------------------------
// Name: set_active_thread
// Desc:
//------------------------------------------------------------------------------
void DebuggerCore::set_active_thread(edb::tid_t tid) {
	Q_ASSERT(threads_.contains(tid));
	active_thread_ = tid;
}

//------------------------------------------------------------------------------
// Name: create_state
// Desc:
//------------------------------------------------------------------------------
std::unique_ptr<IState> DebuggerCore::create_state() const {
	return std::make_unique<PlatformState>();
}
//------------------------------------------------------------------------------
// Name: enumerate_processes
// Desc:
//------------------------------------------------------------------------------
QMap<edb::pid_t, ProcessInfo> DebuggerCore::enumerate_processes() const {
	QMap<edb::pid_t, ProcessInfo> ret;

	static const int name[] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};
	size_t length           = 0;

	sysctl(const_cast<int *>(name), (sizeof(name) / sizeof(*name)) - 1, 0, &length, 0, 0);
	auto proc_info = static_cast<struct kinfo_proc *>(malloc(length));
	sysctl(const_cast<int *>(name), (sizeof(name) / sizeof(*name)) - 1, proc_info, &length, 0, 0);

	size_t count = length / sizeof(struct kinfo_proc);
	for (size_t i = 0; i < count; ++i) {
		ProcessInfo procInfo;
		procInfo.pid  = proc_info[i].kp_proc.p_pid;
		procInfo.uid  = proc_info[i].kp_eproc.e_ucred.cr_uid;
		procInfo.name = proc_info[i].kp_proc.p_comm;

		ret.insert(procInfo.pid, procInfo);
	}

	free(proc_info);

	return ret;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::process_exe(edb::pid_t pid) const {
	// TODO: implement this
	return QString();
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::process_cwd(edb::pid_t pid) const {
	// TODO: implement this
	return QString();
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
edb::pid_t DebuggerCore::parent_pid(edb::pid_t pid) const {
	// TODO: implement this
	return -1;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QList<std::shared_ptr<IRegion>> DebuggerCore::memory_regions() const {

#if 0
	static const char *inheritance_strings[] = {
		"SHARE",
		"COPY",
		"NONE",
		"DONATE_COPY",
	};

	static const char *behavior_strings[] = {
		"DEFAULT",
		"RANDOM",
		"SEQUENTIAL",
		"RESQNTL",
		"WILLNEED",
		"DONTNEED",
	};
#endif

	QList<std::shared_ptr<IRegion>> regions;
	if (pid_ != 0) {
		task_t the_task;
		kern_return_t kr = task_for_pid(mach_task_self(), pid_, &the_task);
		if (kr != KERN_SUCCESS) {
			qDebug("task_for_pid failed");
			return QList<std::shared_ptr<IRegion>>();
		}

		vm_size_t vmsize;
		vm_address_t address;
		vm_region_basic_info_data_64_t info;
		mach_msg_type_number_t info_count;
		vm_region_flavor_t flavor;
		memory_object_name_t object;

		kr      = KERN_SUCCESS;
		address = 0;

		do {
			flavor     = VM_REGION_BASIC_INFO_64;
			info_count = VM_REGION_BASIC_INFO_COUNT_64;
			kr         = vm_region_64(the_task, &address, &vmsize, flavor, (vm_region_info_64_t)&info, &info_count, &object);
			if (kr == KERN_SUCCESS) {

				const edb::address_t start = address;
				const edb::address_t end   = address + vmsize;
				const edb::address_t base  = address;
				const QString name         = QString();
				const IRegion::permissions_t permissions =
					((info.protection & VM_PROT_READ) ? PROT_READ : 0) |
					((info.protection & VM_PROT_WRITE) ? PROT_WRITE : 0) |
					((info.protection & VM_PROT_EXECUTE) ? PROT_EXEC : 0);

				regions.push_back(std::make_shared<PlatformRegion>(start, end, base, name, permissions));

				/*
				printf("%016llx-%016llx %8uK %c%c%c/%c%c%c %11s %6s %10s uwir=%hu sub=%u\n",
				address, (address + vmsize), (vmsize >> 10),
				(info.protection & VM_PROT_READ)        ? 'r' : '-',
				(info.protection & VM_PROT_WRITE)       ? 'w' : '-',
				(info.protection & VM_PROT_EXECUTE)     ? 'x' : '-',
				(info.max_protection & VM_PROT_READ)    ? 'r' : '-',
				(info.max_protection & VM_PROT_WRITE)   ? 'w' : '-',
				(info.max_protection & VM_PROT_EXECUTE) ? 'x' : '-',
				inheritance_strings[info.inheritance],
				(info.shared) ? "shared" : "-",
				behavior_strings[info.behavior],
				info.user_wired_count,
				info.reserved);
				*/

				address += vmsize;
			} else if (kr != KERN_INVALID_ADDRESS) {
				if (the_task != MACH_PORT_NULL) {
					mach_port_deallocate(mach_task_self(), the_task);
				}
				return QList<std::shared_ptr<IRegion>>();
			}
		} while (kr != KERN_INVALID_ADDRESS);

		if (the_task != MACH_PORT_NULL) {
			mach_port_deallocate(mach_task_self(), the_task);
		}
	}

	return regions;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QList<QByteArray> DebuggerCore::process_args(edb::pid_t pid) const {
	QList<QByteArray> ret;
	if (pid != 0) {
		// TODO: assert attached!
		qDebug() << "TODO: implement edb::v1::get_process_args";
	}
	return ret;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
edb::address_t DebuggerCore::process_code_address() const {
	qDebug() << "TODO: implement DebuggerCore::process_code_address";
	return 0;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
edb::address_t DebuggerCore::process_data_address() const {
	qDebug() << "TODO: implement DebuggerCore::process_data_address";
	return 0;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QList<Module> DebuggerCore::loaded_modules() const {
	QList<Module> modules;
	qDebug() << "TODO: implement DebuggerCore::loaded_modules";
	return modules;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QDateTime DebuggerCore::process_start(edb::pid_t pid) const {
	qDebug() << "TODO: implement DebuggerCore::process_start";
	return QDateTime();
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
quint64 DebuggerCore::cpu_type() const {
#ifdef EDB_X86
	return edb::string_hash<'x', '8', '6'>::value;
#elif defined(EDB_X86_64)
	return edb::string_hash<'x', '8', '6', '-', '6', '4'>::value;
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::format_pointer(edb::address_t address) const {
	char buf[32];
#ifdef EDB_X86
	qsnprintf(buf, sizeof(buf), "%08x", address);
#elif defined(EDB_X86_64)
	qsnprintf(buf, sizeof(buf), "%016llx", address);
#endif
	return buf;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::stack_pointer() const {
#ifdef EDB_X86
	return "esp";
#elif defined(EDB_X86_64)
	return "rsp";
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::frame_pointer() const {
#ifdef EDB_X86
	return "ebp";
#elif defined(EDB_X86_64)
	return "rbp";
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QString DebuggerCore::instruction_pointer() const {
#ifdef EDB_X86
	return "eip";
#elif defined(EDB_X86_64)
	return "rip";
#endif
}

}

```

`plugins/DebuggerCore/unix/osx/DebuggerCore.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DEBUGGER_CORE_H_20090529_
#define DEBUGGER_CORE_H_20090529_

#include "DebuggerCoreUNIX.h"
#include <QHash>

namespace DebuggerCore {

class DebuggerCore : public DebuggerCoreUNIX {
	Q_OBJECT
	Q_INTERFACES(IDebugger)
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	DebuggerCore();
	~DebuggerCore() override;

public:
	size_t page_size() const override;
	bool has_extension(quint64 ext) const override;
	std::shared_ptr<const IDebugEvent> wait_debug_event(int msecs) override;
	bool attach(edb::pid_t pid) override;
	void detach() override;
	void kill() override;
	void pause() override;
	void resume(edb::EVENT_STATUS status) override;
	void step(edb::EVENT_STATUS status) override;
	void get_state(State *state) override;
	void set_state(const State &state) override;
	bool open(const QString &path, const QString &cwd, const QList<QByteArray> &args, const QString &tty) override;

public:
	// thread support stuff (optional)
	QList<edb::tid_t> thread_ids() const override { return threads_.keys(); }
	edb::tid_t active_thread() const override { return active_thread_; }
	void set_active_thread(edb::tid_t) override;

public:
	QList<std::shared_ptr<IRegion>> memory_regions() const override;
	edb::address_t process_code_address() const override;
	edb::address_t process_data_address() const override;

public:
	// process properties
	QList<QByteArray> process_args(edb::pid_t pid) const override;
	QString process_exe(edb::pid_t pid) const override;
	QString process_cwd(edb::pid_t pid) const override;
	edb::pid_t parent_pid(edb::pid_t pid) const override;
	QDateTime process_start(edb::pid_t pid) const override;
	quint64 cpu_type() const override;

public:
	std::unique_ptr<IState> create_state() const override;

private:
	QMap<edb::pid_t, ProcessInfo> enumerate_processes() const override;
	QList<Module> loaded_modules() const override;

public:
	QString stack_pointer() const override;
	QString frame_pointer() const override;
	QString instruction_pointer() const override;

public:
	QString format_pointer(edb::address_t address) const override;

private:
	long read_data(edb::address_t address, bool *ok) override;
	bool write_data(edb::address_t address, long value) override;

private:
	struct thread_info {
	public:
		thread_info()
			: status(0) {
		}

		thread_info(int s)
			: status(s) {
		}

		int status;
	};

	using threadmap_t = QHash<edb::tid_t, thread_info>;

	size_t page_size_;
	threadmap_t threads_;
};

}

#endif

```

`plugins/DebuggerCore/unix/osx/PlatformEvent.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformEvent.h"
#include "edb.h"
#include <cstdio>
#include <cstring>
#include <signal.h> // for the SIG* definitions
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>

namespace DebuggerCore {

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
PlatformEvent::PlatformEvent()
	: status(0), pid(-1), tid(-1) {
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
PlatformEvent *PlatformEvent::clone() const {
	return new PlatformEvent(*this);
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
IDebugEvent::Message PlatformEvent::error_description() const {
	Q_ASSERT(is_error());

	// TODO: figure out the fault address
	const edb::address_t fault_address = 0;

	switch (code()) {
	case SIGSEGV:
		return Message(
			tr("Illegal Access Fault"),
			tr(
				"<p>The debugged application encountered a segmentation fault.<br />The address <strong>0x%1</strong> could not be accessed.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>")
				.arg(edb::v1::format_pointer(fault_address)));
	case SIGILL:
		return Message(
			tr("Illegal Instruction Fault"),
			tr(
				"<p>The debugged application attempted to execute an illegal instruction.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
	case SIGFPE:
		// TODO: figure out the fault code for FPU stuff
		switch (0) {
		case FPE_INTDIV:
			return Message(
				tr("Divide By Zero"),
				tr(
					"<p>The debugged application tried to divide an integer value by an integer divisor of zero.</p>"
					"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
		default:
			return Message(
				tr("Floating Point Exception"),
				tr(
					"<p>The debugged application encountered a floating-point exception.</p>"
					"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
		}

	case SIGABRT:
		return Message(
			tr("Application Aborted"),
			tr(
				"<p>The debugged application has aborted.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
	case SIGBUS:
		return Message(
			tr("Bus Error"),
			tr(
				"<p>The debugged application tried to read or write data that is misaligned.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
#ifdef SIGSTKFLT
	case SIGSTKFLT:
		return Message(
			tr("Stack Fault"),
			tr(
				"<p>The debugged application encountered a stack fault.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
#endif
	case SIGPIPE:
		return Message(
			tr("Broken Pipe Fault"),
			tr(
				"<p>The debugged application encountered a broken pipe fault.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"));
	default:
		return Message();
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
IDebugEvent::REASON PlatformEvent::reason() const {
	// this basically converts our value into a 'switchable' value for convenience

	if (stopped()) {
		return EVENT_STOPPED;
	} else if (terminated()) {
		return EVENT_TERMINATED;
	} else if (exited()) {
		return EVENT_EXITED;
	} else {
		return EVENT_UNKNOWN;
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
IDebugEvent::TRAP_REASON PlatformEvent::trap_reason() const {
	// TODO: figure out how to detect if it is a step
	return TRAP_BREAKPOINT;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::exited() const {
	return WIFEXITED(status) != 0;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::is_error() const {
	if (stopped()) {
		switch (code()) {
		case SIGTRAP:
		case SIGSTOP:
			return false;
		case SIGSEGV:
		case SIGILL:
		case SIGFPE:
		case SIGABRT:
		case SIGBUS:
#ifdef SIGSTKFLT
		case SIGSTKFLT:
#endif
		case SIGPIPE:
			return true;
		default:
			return false;
		}
	} else {
		return false;
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::is_kill() const {
	return stopped() && code() == SIGKILL;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::is_stop() const {
	return stopped() && code() == SIGSTOP;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::is_trap() const {
	return stopped() && code() == SIGTRAP;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::terminated() const {
	return WIFSIGNALED(status) != 0;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
bool PlatformEvent::stopped() const {
	return WIFSTOPPED(status) != 0;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
edb::pid_t PlatformEvent::process() const {
	return pid;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
edb::tid_t PlatformEvent::thread() const {
	return tid;
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
int64_t PlatformEvent::code() const {
	if (stopped()) {
		return WSTOPSIG(status);
	}

	if (terminated()) {
		return WTERMSIG(status);
	}

	if (exited()) {
		return WEXITSTATUS(status);
	}

	return 0;
}

}

```

`plugins/DebuggerCore/unix/osx/PlatformEvent.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_EVENT_H_20121005_
#define PLATFORM_EVENT_H_20121005_

#include "IDebugEvent.h"
#include <QCoreApplication>

namespace DebuggerCore {

class PlatformEvent : IDebugEvent {
	Q_DECLARE_TR_FUNCTIONS(PlatformEvent)
	friend class DebuggerCore;

public:
	PlatformEvent();

public:
	PlatformEvent *clone() const override;

public:
	Message error_description() const override;
	REASON reason() const override;
	TRAP_REASON trap_reason() const override;
	bool exited() const override;
	bool is_error() const override;
	bool is_kill() const override;
	bool is_stop() const override;
	bool is_trap() const override;
	bool terminated() const override;
	bool stopped() const override;
	edb::pid_t process() const override;
	edb::tid_t thread() const override;
	int64_t code() const override;

private:
	int status;
	edb::pid_t pid;
	edb::tid_t tid;
};

}

#endif

```

`plugins/DebuggerCore/unix/osx/PlatformProcess.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformProcess.h"

```

`plugins/DebuggerCore/unix/osx/PlatformProcess.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_PROCESS_H_20150517_
#define PLATFORM_PROCESS_H_20150517_

#include "IProcess.h"

class PlatformProcess : public IProcess {
};

#endif

```

`plugins/DebuggerCore/unix/osx/PlatformRegion.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformRegion.h"

#include "IDebugEventHandler.h"
#include "IDebugger.h"
#include "MemoryRegions.h"
#include "State.h"
#include "edb.h"
#include <QMessageBox>
#include <sys/mman.h>
#include <sys/syscall.h>

namespace DebuggerCore {

PlatformRegion::PlatformRegion(edb::address_t start, edb::address_t end, edb::address_t base, const QString &name, permissions_t permissions)
	: start_(start), end_(end), base_(base), name_(name), permissions_(permissions) {
}

IRegion *PlatformRegion::clone() const {
	return new PlatformRegion(start_, end_, base_, name_, permissions_);
}

bool PlatformRegion::accessible() const {
	return readable() || writable() || executable();
}

bool PlatformRegion::readable() const {
	return (permissions_ & PROT_READ) != 0;
}

bool PlatformRegion::writable() const {
	return (permissions_ & PROT_WRITE) != 0;
}

bool PlatformRegion::executable() const {
	return (permissions_ & PROT_EXEC) != 0;
}

size_t PlatformRegion::size() const {
	return end_ - start_;
}

void PlatformRegion::set_permissions(bool read, bool write, bool execute) {
	Q_UNUSED(read)
	Q_UNUSED(write)
	Q_UNUSED(execute)
}

edb::address_t PlatformRegion::start() const {
	return start_;
}

edb::address_t PlatformRegion::end() const {
	return end_;
}

edb::address_t PlatformRegion::base() const {
	return base_;
}

QString PlatformRegion::name() const {
	return name_;
}

IRegion::permissions_t PlatformRegion::permissions() const {
	return permissions_;
}

void PlatformRegion::set_start(edb::address_t address) {
	start_ = address;
}

void PlatformRegion::set_end(edb::address_t address) {
	end_ = address;
}

}

```

`plugins/DebuggerCore/unix/osx/PlatformRegion.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_REGION_H_20120330_
#define PLATFORM_REGION_H_20120330_

#include "IRegion.h"
#include <QCoreApplication>
#include <QString>

namespace DebuggerCore {

class PlatformRegion : public IRegion {
	Q_DECLARE_TR_FUNCTIONS(PlatformRegion)

public:
	PlatformRegion(edb::address_t start, edb::address_t end, edb::address_t base, const QString &name, permissions_t permissions);
	~PlatformRegion() override = default;

public:
	IRegion *clone() const override;

public:
	bool accessible() const override;
	bool readable() const override;
	bool writable() const override;
	bool executable() const override;
	size_t size() const override;

public:
	void set_permissions(bool read, bool write, bool execute) override;
	void set_start(edb::address_t address) override;
	void set_end(edb::address_t address) override;

public:
	edb::address_t start() const override;
	edb::address_t end() const override;
	edb::address_t base() const override;
	QString name() const override;
	permissions_t permissions() const override;

private:
	edb::address_t start_;
	edb::address_t end_;
	edb::address_t base_;
	QString name_;
	permissions_t permissions_;
};

}

#endif

```

`plugins/DebuggerCore/unix/osx/PlatformState.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformState.h"
#if __DARWIN_UNIX03
#define REG(x) __##x
#else
#define REG(x) x
#endif

namespace DebuggerCore {

//------------------------------------------------------------------------------
// Name: PlatformState
// Desc:
//------------------------------------------------------------------------------
PlatformState::PlatformState() {
	memset(&thread_state_, 0, sizeof(thread_state_));
	memset(&float_state_, 0, sizeof(float_state_));
	memset(&debug_state_, 0, sizeof(debug_state_));
	memset(&exception_state_, 0, sizeof(exception_state_));
}

//------------------------------------------------------------------------------
// Name: PlatformState::clone
// Desc: makes a copy of the state object
//------------------------------------------------------------------------------
std::unique_ptr<IState> PlatformState::clone() const {
	return std::make_unique<PlatformState>(*this);
}

//------------------------------------------------------------------------------
// Name: flags_to_string
// Desc: returns the flags in a string form appropriate for this platform
//------------------------------------------------------------------------------
QString PlatformState::flags_to_string(edb::reg_t flags) const {
	char buf[14];
	qsnprintf(
		buf,
		sizeof(buf),
		"%c %c %c %c %c %c %c",
		((flags & 0x001) ? 'C' : 'c'),
		((flags & 0x004) ? 'P' : 'p'),
		((flags & 0x010) ? 'A' : 'a'),
		((flags & 0x040) ? 'Z' : 'z'),
		((flags & 0x080) ? 'S' : 's'),
		((flags & 0x400) ? 'D' : 'd'),
		((flags & 0x800) ? 'O' : 'o'));

	return buf;
}

//------------------------------------------------------------------------------
// Name: flags_to_string
// Desc: returns the flags in a string form appropriate for this platform
//------------------------------------------------------------------------------
QString PlatformState::flags_to_string() const {
	return flags_to_string(flags());
}

//------------------------------------------------------------------------------
// Name: value
// Desc: returns a Register object which represents the register with the name
//       supplied
//------------------------------------------------------------------------------
Register PlatformState::value(const QString &reg) const {
	const QString lreg = reg.toLower();

#if defined(EDB_X86)
	if (lreg == "eax")
		return Register("eax", thread_state_.REG(eax), Register::TYPE_GPR);
	else if (lreg == "ebx")
		return Register("ebx", thread_state_.REG(ebx), Register::TYPE_GPR);
	else if (lreg == "ecx")
		return Register("ecx", thread_state_.REG(ecx), Register::TYPE_GPR);
	else if (lreg == "edx")
		return Register("edx", thread_state_.REG(edx), Register::TYPE_GPR);
	else if (lreg == "ebp")
		return Register("ebp", thread_state_.REG(ebp), Register::TYPE_GPR);
	else if (lreg == "esp")
		return Register("esp", thread_state_.REG(esp), Register::TYPE_GPR);
	else if (lreg == "esi")
		return Register("esi", thread_state_.REG(esi), Register::TYPE_GPR);
	else if (lreg == "edi")
		return Register("edi", thread_state_.REG(edi), Register::TYPE_GPR);
	else if (lreg == "eip")
		return Register("eip", thread_state_.REG(eip), Register::TYPE_IP);
	else if (lreg == "ax")
		return Register("ax", thread_state_.REG(eax) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "bx")
		return Register("bx", thread_state_.REG(ebx) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "cx")
		return Register("cx", thread_state_.REG(ecx) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "dx")
		return Register("dx", thread_state_.REG(edx) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "bp")
		return Register("bp", thread_state_.REG(ebp) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "sp")
		return Register("sp", thread_state_.REG(esp) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "si")
		return Register("si", thread_state_.REG(esi) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "di")
		return Register("di", thread_state_.REG(edi) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "al")
		return Register("al", thread_state_.REG(eax) & 0xff, Register::TYPE_GPR);
	else if (lreg == "bl")
		return Register("bl", thread_state_.REG(ebx) & 0xff, Register::TYPE_GPR);
	else if (lreg == "cl")
		return Register("cl", thread_state_.REG(ecx) & 0xff, Register::TYPE_GPR);
	else if (lreg == "dl")
		return Register("dl", thread_state_.REG(edx) & 0xff, Register::TYPE_GPR);
	else if (lreg == "ah")
		return Register("ah", (thread_state_.REG(eax) >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "bh")
		return Register("bh", (thread_state_.REG(ebx) >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "ch")
		return Register("ch", (thread_state_.REG(ecx) >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "dh")
		return Register("dh", (thread_state_.REG(edx) >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "cs")
		return Register("cs", thread_state_.REG(cs), Register::TYPE_SEG);
	else if (lreg == "ds")
		return Register("ds", thread_state_.REG(ds), Register::TYPE_SEG);
	else if (lreg == "es")
		return Register("es", thread_state_.REG(es), Register::TYPE_SEG);
	else if (lreg == "fs")
		return Register("fs", thread_state_.REG(fs), Register::TYPE_SEG);
	else if (lreg == "gs")
		return Register("gs", thread_state_.REG(gs), Register::TYPE_SEG);
	else if (lreg == "ss")
		return Register("ss", thread_state_.REG(ss), Register::TYPE_SEG);
	else if (lreg == "fs_base")
		return Register("fs_base", 0 /* TODO fs_base */, Register::TYPE_SEG);
	else if (lreg == "gs_base")
		return Register("gs_base", 0 /* TODO gs_base */, Register::TYPE_SEG);
	else if (lreg == "eflags")
		return Register("eflags", thread_state_.REG(eflags), Register::TYPE_COND);
#elif defined(EDB_X86_64)
	if (lreg == "rax")
		return Register("rax", thread_state_.REG(rax), Register::TYPE_GPR);
	else if (lreg == "rbx")
		return Register("rbx", thread_state_.REG(rbx), Register::TYPE_GPR);
	else if (lreg == "rcx")
		return Register("rcx", thread_state_.REG(rcx), Register::TYPE_GPR);
	else if (lreg == "rdx")
		return Register("rdx", thread_state_.REG(rdx), Register::TYPE_GPR);
	else if (lreg == "rbp")
		return Register("rbp", thread_state_.REG(rbp), Register::TYPE_GPR);
	else if (lreg == "rsp")
		return Register("rsp", thread_state_.REG(rsp), Register::TYPE_GPR);
	else if (lreg == "rsi")
		return Register("rsi", thread_state_.REG(rsi), Register::TYPE_GPR);
	else if (lreg == "rdi")
		return Register("rdi", thread_state_.REG(rdi), Register::TYPE_GPR);
	else if (lreg == "rip")
		return Register("rip", thread_state_.REG(rip), Register::TYPE_IP);
	else if (lreg == "r8")
		return Register("r8", thread_state_.REG(r8), Register::TYPE_GPR);
	else if (lreg == "r9")
		return Register("r9", thread_state_.REG(r9), Register::TYPE_GPR);
	else if (lreg == "r10")
		return Register("r10", thread_state_.REG(r10), Register::TYPE_GPR);
	else if (lreg == "r11")
		return Register("r11", thread_state_.REG(r11), Register::TYPE_GPR);
	else if (lreg == "r12")
		return Register("r12", thread_state_.REG(r12), Register::TYPE_GPR);
	else if (lreg == "r13")
		return Register("r13", thread_state_.REG(r13), Register::TYPE_GPR);
	else if (lreg == "r14")
		return Register("r14", thread_state_.REG(r14), Register::TYPE_GPR);
	else if (lreg == "r15")
		return Register("r15", thread_state_.REG(r15), Register::TYPE_GPR);
	else if (lreg == "eax")
		return Register("eax", thread_state_.REG(rax) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "ebx")
		return Register("ebx", thread_state_.REG(rbx) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "ecx")
		return Register("ecx", thread_state_.REG(rcx) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "edx")
		return Register("edx", thread_state_.REG(rdx) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "ebp")
		return Register("ebp", thread_state_.REG(rbp) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "esp")
		return Register("esp", thread_state_.REG(rsp) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "esi")
		return Register("esi", thread_state_.REG(rsi) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "edi")
		return Register("edi", thread_state_.REG(rdi) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r8d")
		return Register("r8d", thread_state_.REG(r8) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r9d")
		return Register("r9d", thread_state_.REG(r9) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r10d")
		return Register("r10d", thread_state_.REG(r10) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r11d")
		return Register("r11d", thread_state_.REG(r11) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r12d")
		return Register("r12d", thread_state_.REG(r12) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r13d")
		return Register("r13d", thread_state_.REG(r13) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r14d")
		return Register("r14d", thread_state_.REG(r14) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "r15d")
		return Register("r15d", thread_state_.REG(r15) & 0xffffffff, Register::TYPE_GPR);
	else if (lreg == "ax")
		return Register("ax", thread_state_.REG(rax) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "bx")
		return Register("bx", thread_state_.REG(rbx) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "cx")
		return Register("cx", thread_state_.REG(rcx) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "dx")
		return Register("dx", thread_state_.REG(rdx) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "bp")
		return Register("bp", thread_state_.REG(rbp) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "sp")
		return Register("sp", thread_state_.REG(rsp) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "si")
		return Register("si", thread_state_.REG(rsi) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "di")
		return Register("di", thread_state_.REG(rdi) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r8w")
		return Register("r8w", thread_state_.REG(r8) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r9w")
		return Register("r9w", thread_state_.REG(r9) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r10w")
		return Register("r10w", thread_state_.REG(r10) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r11w")
		return Register("r11w", thread_state_.REG(r11) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r12w")
		return Register("r12w", thread_state_.REG(r12) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r13w")
		return Register("r13w", thread_state_.REG(r13) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r14w")
		return Register("r14w", thread_state_.REG(r14) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "r15w")
		return Register("r15w", thread_state_.REG(r15) & 0xffff, Register::TYPE_GPR);
	else if (lreg == "al")
		return Register("al", thread_state_.REG(rax) & 0xff, Register::TYPE_GPR);
	else if (lreg == "bl")
		return Register("bl", thread_state_.REG(rbx) & 0xff, Register::TYPE_GPR);
	else if (lreg == "cl")
		return Register("cl", thread_state_.REG(rcx) & 0xff, Register::TYPE_GPR);
	else if (lreg == "dl")
		return Register("dl", thread_state_.REG(rdx) & 0xff, Register::TYPE_GPR);
	else if (lreg == "ah")
		return Register("ah", (thread_state_.REG(rax) >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "bh")
		return Register("bh", (thread_state_.REG(rbx) >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "ch")
		return Register("ch", (thread_state_.REG(rcx) >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "dh")
		return Register("dh", (thread_state_.REG(rdx) >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "spl")
		return Register("spl", (thread_state_.REG(rsp) >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "bpl")
		return Register("bpl", (thread_state_.REG(rbp) >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "sil")
		return Register("sil", (thread_state_.REG(rsi) >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "dil")
		return Register("dil", (thread_state_.REG(rdi) >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "r8b")
		return Register("r8b", thread_state_.REG(r8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "r9b")
		return Register("r9b", thread_state_.REG(r9) & 0xff, Register::TYPE_GPR);
	else if (lreg == "r10b")
		return Register("r10b", thread_state_.REG(r10) & 0xff, Register::TYPE_GPR);
	else if (lreg == "r11b")
		return Register("r11b", thread_state_.REG(r11) & 0xff, Register::TYPE_GPR);
	else if (lreg == "r12b")
		return Register("r12b", thread_state_.REG(r12) & 0xff, Register::TYPE_GPR);
	else if (lreg == "r13b")
		return Register("r13b", thread_state_.REG(r13) & 0xff, Register::TYPE_GPR);
	else if (lreg == "r14b")
		return Register("r14b", thread_state_.REG(r14) & 0xff, Register::TYPE_GPR);
	else if (lreg == "r15b")
		return Register("r15b", thread_state_.REG(r15) & 0xff, Register::TYPE_GPR);
	else if (lreg == "cs")
		return Register("cs", thread_state_.REG(cs), Register::TYPE_SEG);
	else if (lreg == "fs")
		return Register("fs", thread_state_.REG(fs), Register::TYPE_SEG);
	else if (lreg == "gs")
		return Register("gs", thread_state_.REG(gs), Register::TYPE_SEG);
	else if (lreg == "fs_base")
		return Register("fs_base", 0 /* TODO fs_base */, Register::TYPE_SEG);
	else if (lreg == "gs_base")
		return Register("gs_base", 0 /* TODO gs_base */, Register::TYPE_SEG);
	else if (lreg == "rflags")
		return Register("rflags", thread_state_.REG(rflags), Register::TYPE_COND);
#endif

	return Register();
}

//------------------------------------------------------------------------------
// Name: frame_pointer
// Desc: returns what is conceptually the frame pointer for this platform
//------------------------------------------------------------------------------
edb::address_t PlatformState::frame_pointer() const {
#if defined(EDB_X86)
	return thread_state_.REG(ebp);
#elif defined(EDB_X86_64)
	return thread_state_.REG(rbp);
#endif
}

//------------------------------------------------------------------------------
// Name: instruction_pointer
// Desc: returns the instruction pointer for this platform
//------------------------------------------------------------------------------
edb::address_t PlatformState::instruction_pointer() const {
#if defined(EDB_X86)
	return thread_state_.REG(eip);
#elif defined(EDB_X86_64)
	return thread_state_.REG(rip);
#endif
}

//------------------------------------------------------------------------------
// Name: stack_pointer
// Desc: returns the stack pointer for this platform
//------------------------------------------------------------------------------
edb::address_t PlatformState::stack_pointer() const {
#if defined(EDB_X86)
	return thread_state_.REG(esp);
#elif defined(EDB_X86_64)
	return thread_state_.REG(rsp);
#endif
}

//------------------------------------------------------------------------------
// Name: debug_register
// Desc:
//------------------------------------------------------------------------------
edb::reg_t PlatformState::debug_register(int n) const {
	switch (n) {
	case 0:
		return debug_state_.REG(dr0);
	case 1:
		return debug_state_.REG(dr1);
	case 2:
		return debug_state_.REG(dr2);
	case 3:
		return debug_state_.REG(dr3);
	case 4:
		return debug_state_.REG(dr4);
	case 5:
		return debug_state_.REG(dr5);
	case 6:
		return debug_state_.REG(dr6);
	case 7:
		return debug_state_.REG(dr7);
	}
	return 0;
}

//------------------------------------------------------------------------------
// Name: flags
// Desc:
//------------------------------------------------------------------------------
edb::reg_t PlatformState::flags() const {
#if defined(EDB_X86)
	return thread_state_.REG(eflags);
#elif defined(EDB_X86_64)
	return thread_state_.REG(rflags);
#endif
}

//------------------------------------------------------------------------------
// Name: fpu_register
// Desc:
//------------------------------------------------------------------------------
long double PlatformState::fpu_register(int n) const {

	/*
	switch(n) {
	case 0: return static_cast<long double>(float_state_.REG(fpu_stmm0).REG(mmst_reg));
	case 1: return static_cast<long double>(float_state_.REG(fpu_stmm1).REG(mmst_reg));
	case 2: return static_cast<long double>(float_state_.REG(fpu_stmm2).REG(mmst_reg));
	case 3: return static_cast<long double>(float_state_.REG(fpu_stmm3).REG(mmst_reg));
	case 4: return static_cast<long double>(float_state_.REG(fpu_stmm4).REG(mmst_reg));
	case 5: return static_cast<long double>(float_state_.REG(fpu_stmm5).REG(mmst_reg));
	case 6: return static_cast<long double>(float_state_.REG(fpu_stmm6).REG(mmst_reg));
	case 7: return static_cast<long double>(float_state_.REG(fpu_stmm7).REG(mmst_reg));
	}
	*/

	return 0.0;
}

//------------------------------------------------------------------------------
// Name: adjust_stack
// Desc:
//------------------------------------------------------------------------------
void PlatformState::adjust_stack(int bytes) {
#if defined(EDB_X86)
	thread_state_.REG(esp) += bytes;
#elif defined(EDB_X86_64)
	thread_state_.REG(rsp) += bytes;
#endif
}

//------------------------------------------------------------------------------
// Name: clear
// Desc:
//------------------------------------------------------------------------------
void PlatformState::clear() {
	memset(&thread_state_, 0, sizeof(thread_state_));
	memset(&float_state_, 0, sizeof(float_state_));
	memset(&debug_state_, 0, sizeof(debug_state_));
	memset(&exception_state_, 0, sizeof(exception_state_));
}

//------------------------------------------------------------------------------
// Name: set_debug_register
// Desc:
//------------------------------------------------------------------------------
void PlatformState::set_debug_register(int n, edb::reg_t value) {
	switch (n) {
	case 0:
		debug_state_.REG(dr0) = value;
		break;
	case 1:
		debug_state_.REG(dr1) = value;
		break;
	case 2:
		debug_state_.REG(dr2) = value;
		break;
	case 3:
		debug_state_.REG(dr3) = value;
		break;
	case 4:
		debug_state_.REG(dr4) = value;
		break;
	case 5:
		debug_state_.REG(dr5) = value;
		break;
	case 6:
		debug_state_.REG(dr6) = value;
		break;
	case 7:
		debug_state_.REG(dr7) = value;
		break;
	default:
		break;
	}
}

//------------------------------------------------------------------------------
// Name: set_flags
// Desc:
//------------------------------------------------------------------------------
void PlatformState::set_flags(edb::reg_t flags) {
#if defined(EDB_X86)
	thread_state_.REG(eflags) = flags;
#elif defined(EDB_X86_64)
	thread_state_.REG(rflags) = flags;
#endif
}

//------------------------------------------------------------------------------
// Name: set_instruction_pointer
// Desc:
//------------------------------------------------------------------------------
void PlatformState::set_instruction_pointer(edb::address_t value) {
#if defined(EDB_X86)
	thread_state_.REG(eip) = value;
#elif defined(EDB_X86_64)
	thread_state_.REG(rip) = value;
#endif
}

//------------------------------------------------------------------------------
// Name: set_register
// Desc:
//------------------------------------------------------------------------------
void PlatformState::set_register(const QString &name, edb::reg_t value) {

	const QString lreg = name.toLower();
#if defined(EDB_X86)
	if (lreg == "eax") {
		thread_state_.REG(eax) = value;
	} else if (lreg == "ebx") {
		thread_state_.REG(ebx) = value;
	} else if (lreg == "ecx") {
		thread_state_.REG(ecx) = value;
	} else if (lreg == "edx") {
		thread_state_.REG(edx) = value;
	} else if (lreg == "ebp") {
		thread_state_.REG(ebp) = value;
	} else if (lreg == "esp") {
		thread_state_.REG(esp) = value;
	} else if (lreg == "esi") {
		thread_state_.REG(esi) = value;
	} else if (lreg == "edi") {
		thread_state_.REG(edi) = value;
	} else if (lreg == "eip") {
		thread_state_.REG(eip) = value;
	} else if (lreg == "cs") {
		thread_state_.REG(cs) = value;
	} else if (lreg == "ds") {
		thread_state_.REG(ds) = value;
	} else if (lreg == "es") {
		thread_state_.REG(es) = value;
	} else if (lreg == "fs") {
		thread_state_.REG(fs) = value;
	} else if (lreg == "gs") {
		thread_state_.REG(gs) = value;
	} else if (lreg == "ss") {
		thread_state_.REG(ss) = value;
	} else if (lreg == "eflags") {
		thread_state_.REG(eflags) = value;
	}
#elif defined(EDB_X86_64)
	if (lreg == "rax") {
		thread_state_.REG(rax) = value;
	} else if (lreg == "rbx") {
		thread_state_.REG(rbx) = value;
	} else if (lreg == "rcx") {
		thread_state_.REG(rcx) = value;
	} else if (lreg == "rdx") {
		thread_state_.REG(rdx) = value;
	} else if (lreg == "rbp") {
		thread_state_.REG(rbp) = value;
	} else if (lreg == "rsp") {
		thread_state_.REG(rsp) = value;
	} else if (lreg == "rsi") {
		thread_state_.REG(rsi) = value;
	} else if (lreg == "rdi") {
		thread_state_.REG(rdi) = value;
	} else if (lreg == "r8") {
		thread_state_.REG(r8) = value;
	} else if (lreg == "r9") {
		thread_state_.REG(r9) = value;
	} else if (lreg == "r10") {
		thread_state_.REG(r10) = value;
	} else if (lreg == "r11") {
		thread_state_.REG(r11) = value;
	} else if (lreg == "r12") {
		thread_state_.REG(r12) = value;
	} else if (lreg == "r13") {
		thread_state_.REG(r13) = value;
	} else if (lreg == "r14") {
		thread_state_.REG(r14) = value;
	} else if (lreg == "r15") {
		thread_state_.REG(r15) = value;
	} else if (lreg == "rip") {
		thread_state_.REG(rip) = value;
	} else if (lreg == "cs") {
		thread_state_.REG(cs) = value;
	} else if (lreg == "fs") {
		thread_state_.REG(fs) = value;
	} else if (lreg == "gs") {
		thread_state_.REG(gs) = value;
	} else if (lreg == "rflags") {
		thread_state_.REG(rflags) = value;
	}
#endif
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
quint64 PlatformState::mmx_register(int n) const {
	Q_UNUSED(n)
	return 0;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
QByteArray PlatformState::xmm_register(int n) const {
	Q_UNUSED(n)
	return QByteArray();
}

}

```

`plugins/DebuggerCore/unix/osx/PlatformState.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_STATE_H_20110330_
#define PLATFORM_STATE_H_20110330_

#include "IState.h"
#include "Types.h"
#include <mach/mach.h>
#include <sys/user.h>

namespace DebuggerCore {

class PlatformState : public IState {
	friend class DebuggerCore;

public:
	PlatformState();

public:
	std::unique_ptr<IState> clone() const override;

public:
	QString flagsToString() const override;
	QString flagsToString(edb::reg_t flags) const override;
	Register value(const QString &reg) const override;
	edb::address_t frame_pointer() const override;
	edb::address_t instruction_pointer() const override;
	edb::address_t stack_pointer() const override;
	edb::reg_t debug_register(int n) const override;
	edb::reg_t flags() const override;
	long double fpu_register(int n) const override;
	void adjust_stack(int bytes) override;
	void clear() override;
	void set_debug_register(int n, edb::reg_t value) override;
	void set_flags(edb::reg_t flags) override;
	void set_instruction_pointer(edb::address_t value) override;
	void set_register(const QString &name, edb::reg_t value) override;
	quint64 mmx_register(int n) const override;
	QByteArray xmm_register(int n) const override;

private:
#if defined(EDB_X86)
	x86_thread_state32_t thread_state_;
	x86_float_state32_t float_state_;
	x86_debug_state32_t debug_state_;
	x86_exception_state32_t exception_state_;
#elif defined(EDB_X86_64)
	x86_thread_state64_t thread_state_;
	x86_float_state64_t float_state_;
	x86_debug_state64_t debug_state_;
	x86_exception_state64_t exception_state_;
#endif
};

}

#endif

```

`plugins/DebuggerCore/win32/DebuggerCore.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DebuggerCore.h"
#include "edb.h"

#include "MemoryRegions.h"
#include "PlatformEvent.h"
#include "PlatformProcess.h"
#include "PlatformRegion.h"
#include "PlatformState.h"
#include "PlatformThread.h"
#include "State.h"
#include "string_hash.h"

#include <QDateTime>
#include <QDebug>
#include <QFileInfo>
#include <QStringList>

#include <Psapi.h>
#include <TlHelp32.h>
#include <Windows.h>

#include <algorithm>

#ifdef _MSC_VER
#pragma comment(lib, "Advapi32.lib")
#pragma comment(lib, "Psapi.lib")
#endif

/* NOTE(eteran): from the MSDN:
 * Note that while reporting debug events, all threads within the reporting
 * process are frozen. Debuggers are expected to use the SuspendThread and
 * ResumeThread functions to limit the set of threads that can execute within a
 * process. By suspending all threads in a process except for the one reporting
 * a debug event, it is possible to "single step" a single thread. The other
 * threads are not released by a continue operation if they are suspended.
 */

namespace DebuggerCorePlugin {

namespace {

/*
 * Required to debug and adjust the memory of a process owned by another account.
 * OpenProcess quote (MSDN):
 *   "If the caller has enabled the SeDebugPrivilege privilege, the requested access
 *    is granted regardless of the contents of the security descriptor."
 * Needed to open system processes (user SYSTEM)
 *
 * NOTE: You need to be admin to enable this privilege
 * NOTE: You need to have the 'Debug programs' privilege set for the current user,
 *       if the privilege is not present it can't be enabled!
 * NOTE: Detectable by antidebug code (changes debuggee privileges too)
 */
bool set_debug_privilege(HANDLE process, bool set) {

	HANDLE token;
	bool ok = false;

	//process must have PROCESS_QUERY_INFORMATION
	if (OpenProcessToken(process, TOKEN_ADJUST_PRIVILEGES, &token)) {

		LUID luid;
		if (LookupPrivilegeValue(nullptr, SE_DEBUG_NAME, &luid)) {
			TOKEN_PRIVILEGES tp;
			tp.PrivilegeCount           = 1;
			tp.Privileges[0].Luid       = luid;
			tp.Privileges[0].Attributes = set ? SE_PRIVILEGE_ENABLED : 0;

			ok = AdjustTokenPrivileges(token, false, &tp, NULL, nullptr, nullptr);
		}
		CloseHandle(token);
	}

	return ok;
}

}

/**
 * @brief DebuggerCore::DebuggerCore
 */
DebuggerCore::DebuggerCore() {
	DebugSetProcessKillOnExit(false);

	SYSTEM_INFO sys_info;
	GetSystemInfo(&sys_info);
	pageSize_ = sys_info.dwPageSize;

	set_debug_privilege(GetCurrentProcess(), true); // gogo magic powers
}

/**
 * @brief DebuggerCore::~DebuggerCore
 */
DebuggerCore::~DebuggerCore() {
	detach();
	set_debug_privilege(GetCurrentProcess(), false);
}

/**
 * @brief DebuggerCore::pageSize
 * @return the size of a page on this system
 */
size_t DebuggerCore::pageSize() const {
	return pageSize_;
}

/**
 * @brief DebuggerCore::hasExtension
 * @param ext
 * @return
 */
bool DebuggerCore::hasExtension(uint64_t ext) const {
#if !defined(EDB_X86_64)
	switch (ext) {
	case edb::string_hash("MMX"):
		return IsProcessorFeaturePresent(PF_MMX_INSTRUCTIONS_AVAILABLE);
	case edb::string_hash("XMM"):
		return IsProcessorFeaturePresent(PF_XMMI_INSTRUCTIONS_AVAILABLE);
	default:
		return false;
	}
#else
	switch (ext) {
	case edb::string_hash("MMX"):
	case edb::string_hash("XMM"):
		return true;
	default:
		return false;
	}
#endif
}

/**
 * waits for a debug event, secs is a timeout (but is not yet respected)
 *
 * @brief DebuggerCore::waitDebugEvent
 * @param msecs
 * @return null if timeout occured
 */
std::shared_ptr<IDebugEvent> DebuggerCore::waitDebugEvent(std::chrono::milliseconds msecs) {
	if (attached()) {
		DEBUG_EVENT de;
		while (WaitForDebugEvent(&de, msecs.count() == 0 ? INFINITE : msecs.count())) {

			Q_ASSERT(process_->pid() == de.dwProcessId);

			activeThread_  = de.dwThreadId;
			bool propagate = false;

			switch (de.dwDebugEventCode) {
			case CREATE_THREAD_DEBUG_EVENT: {
				auto newThread = std::make_shared<PlatformThread>(this, process_, &de.u.CreateThread);
				threads_.insert(activeThread_, newThread);
				break;
			}
			case EXIT_THREAD_DEBUG_EVENT:
				threads_.remove(activeThread_);
				break;
			case CREATE_PROCESS_DEBUG_EVENT: {
				CloseHandle(de.u.CreateProcessInfo.hFile);

				process_ = std::make_shared<PlatformProcess>(this, de.u.CreateProcessInfo.hProcess);

				// fake a thread create event for the main thread..
				CREATE_THREAD_DEBUG_INFO thread_info;
				thread_info.hThread           = de.u.CreateProcessInfo.hThread;
				thread_info.lpStartAddress    = de.u.CreateProcessInfo.lpStartAddress;
				thread_info.lpThreadLocalBase = de.u.CreateProcessInfo.lpThreadLocalBase;
				auto newThread                = std::make_shared<PlatformThread>(this, process_, &thread_info);
				threads_.insert(activeThread_, newThread);
				break;
			}
			case LOAD_DLL_DEBUG_EVENT:
				CloseHandle(de.u.LoadDll.hFile);
				break;
			case EXIT_PROCESS_DEBUG_EVENT:
				process_->resume(edb::DEBUG_CONTINUE);
				process_ = nullptr;
				// handle_event_exited returns DEBUG_STOP, which in turn keeps the debugger from resuming the process
				// However, this is needed to close all internal handles etc. and finish the debugging session
				// So we do it manually here
				propagate = true;
				break;
			case EXCEPTION_DEBUG_EVENT:
				propagate = true;
				break;
			case RIP_EVENT:
				break;
			default:
				break;
			}

			if (auto p = static_cast<PlatformProcess *>(process_.get())) {
				p->lastEvent_ = de;
			}

			if (propagate) {
				// normal event
				auto e    = std::make_shared<PlatformEvent>();
				e->event_ = de;
				return e;
			}

			process_->resume(edb::DEBUG_EXCEPTION_NOT_HANDLED);
		}
	}
	return nullptr;
}

/**
 * @brief DebuggerCore::attach
 * @param pid
 * @return
 */
Status DebuggerCore::attach(edb::pid_t pid) {

	detach();

	if (DebugActiveProcess(pid)) {
		process_ = std::make_shared<PlatformProcess>(this, pid);
		return Status::Ok;
	}

	return Status("Error DebuggerCore::attach");
}

/**
 * @brief DebuggerCore::detach
 * @return
 */
Status DebuggerCore::detach() {
	if (attached()) {
		clearBreakpoints();
		// Make sure exceptions etc. are passed
		ContinueDebugEvent(process_->pid(), active_thread(), DBG_CONTINUE);
		DebugActiveProcessStop(process_->pid());
		process_ = nullptr;
		threads_.clear();
	}
	return Status::Ok;
}

/**
 * @brief DebuggerCore::kill
 */
void DebuggerCore::kill() {
	if (auto p = static_cast<PlatformProcess *>(process_.get())) {
		TerminateProcess(p->hProcess_, -1);
		detach();
	}
}

/**
 * @brief DebuggerCore::open
 * @param path
 * @param cwd
 * @param args
 * @param tty
 * @return
 */
Status DebuggerCore::open(const QString &path, const QString &cwd, const QList<QByteArray> &args, const QString &input, const QString &output) {

	// TODO: Don't inherit security descriptors from this process (default values)
	//       Is this even possible?

	Q_UNUSED(input)
	Q_UNUSED(output)

	Q_ASSERT(!path.isEmpty());

	bool ok = false;

	detach();

	// default to process's directory
	QString tcwd = cwd.isEmpty() ? QFileInfo(path).canonicalPath() : cwd;

	STARTUPINFO startup_info         = {};
	PROCESS_INFORMATION process_info = {};

	const DWORD CREATE_FLAGS = DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS | CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_CONSOLE;

	wchar_t *const env_block = GetEnvironmentStringsW();

	// Set up command line
	QString command_str = '\"' + QFileInfo(path).canonicalPath() + '\"'; // argv[0] = full path (explorer style)
	if (!args.isEmpty()) {
		for (QByteArray arg : args) {
			command_str += " ";
			command_str += arg;
		}
	}

	// CreateProcessW wants a writable copy of the command line :<
	auto command_path = new wchar_t[command_str.length() + sizeof(wchar_t)];
	wcscpy_s(command_path, command_str.length() + 1, reinterpret_cast<const wchar_t *>(command_str.utf16()));

	if (CreateProcessW(
			reinterpret_cast<const wchar_t *>(path.utf16()), // exe
			command_path,                                    // commandline
			nullptr,                                         // default security attributes
			nullptr,                                         // default thread security too
			FALSE,                                           // inherit handles
			CREATE_FLAGS,
			env_block,                                       // environment data
			reinterpret_cast<const wchar_t *>(tcwd.utf16()), // working directory
			&startup_info,
			&process_info)) {

		activeThread_ = process_info.dwThreadId;
		CloseHandle(process_info.hThread); // We don't need the thread handle
		set_debug_privilege(process_info.hProcess, false);

		//process_info.hProcess  has PROCESS_ALL_ACCESS
		process_ = std::make_shared<PlatformProcess>(this, process_info.hProcess);

		ok = true;
	}

	delete[] command_path;
	FreeEnvironmentStringsW(env_block);

	if (ok) {
		return Status::Ok;
	} else {
		return Status("Error DebuggerCore::open");
	}
}

/**
 * @brief DebuggerCore::createState
 * @return
 */
std::unique_ptr<IState> DebuggerCore::createState() const {
	return std::make_unique<PlatformState>();
}

/**
 * @brief DebuggerCore::sys_pointer_size
 * @return the size of a pointer on this arch
 */
int DebuggerCore::sys_pointer_size() const {
	return sizeof(void *);
}

/**
 * @brief DebuggerCore::enumerateProcesses
 * @return
 */
QMap<edb::pid_t, std::shared_ptr<IProcess>> DebuggerCore::enumerateProcesses() const {
	QMap<edb::pid_t, std::shared_ptr<IProcess>> ret;

	HANDLE handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (handle != INVALID_HANDLE_VALUE) {

		PROCESSENTRY32 lppe;

		std::memset(&lppe, 0, sizeof(lppe));
		lppe.dwSize = sizeof(lppe);

		if (Process32First(handle, &lppe)) {
			do {
				// NOTE(eteran): the const_cast is reasonable here.
				// While we don't want THIS function to mutate the DebuggerCore object
				// we do want the associated PlatformProcess to be able to trigger
				// non-const operations in the future, at least hypothetically.
				auto pi = std::make_shared<PlatformProcess>(const_cast<DebuggerCore *>(this), lppe.th32ProcessID);
				if (pi->hProcess_ == nullptr) {
					continue;
				}

				ret.insert(pi->pid(), pi);

				std::memset(&lppe, 0, sizeof(lppe));
				lppe.dwSize = sizeof(lppe);
			} while (Process32Next(handle, &lppe));
		}

		CloseHandle(handle);
	}
	return ret;
}

/**
 * @brief DebuggerCore::parentPid
 * @param pid
 * @return
 */
edb::pid_t DebuggerCore::parentPid(edb::pid_t pid) const {
	edb::pid_t parent   = 1; // 1??
	HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, pid);
	if (hProcessSnap != INVALID_HANDLE_VALUE) {
		PROCESSENTRY32W pe32;
		pe32.dwSize = sizeof(pe32);

		if (Process32FirstW(hProcessSnap, &pe32)) {
			do {
				if (pid == pe32.th32ProcessID) {
					parent = pe32.th32ParentProcessID;
					break;
				}
			} while (Process32NextW(hProcessSnap, &pe32));
		}
		CloseHandle(hProcessSnap);
	}
	return parent;
}

/**
 * @brief DebuggerCore::exceptions
 * @return
 */
QMap<qlonglong, QString> DebuggerCore::exceptions() const {
	QMap<qlonglong, QString> exceptions;

	return exceptions;
}

/**
 * @brief DebuggerCore::cpuType
 * @return
 */
uint64_t DebuggerCore::cpuType() const {
#ifdef EDB_X86
	return edb::string_hash("x86");
#elif defined(EDB_X86_64)
	return edb::string_hash("x86-64");
#endif
}

/**
 * @brief DebuggerCore::stackPointer
 * @return
 */
QString DebuggerCore::stackPointer() const {
#ifdef EDB_X86
	return "esp";
#elif defined(EDB_X86_64)
	// TODO(eteran): WOW64 support
	return "rsp";
#endif
}

/**
 * @brief DebuggerCore::framePointer
 * @return
 */
QString DebuggerCore::framePointer() const {
#ifdef EDB_X86
	return "ebp";
#elif defined(EDB_X86_64)
	// TODO(eteran): WOW64 support
	return "rbp";
#endif
}

/**
 * @brief DebuggerCore::instructionPointer
 * @return
 */
QString DebuggerCore::instructionPointer() const {
#ifdef EDB_X86
	return "eip";
#elif defined(EDB_X86_64)
	// TODO(eteran): WOW64 support
	return "rip";
#endif
}

/**
 * @brief DebuggerCore::process
 * @return
 */
IProcess *DebuggerCore::process() const {
	return process_.get();
}

/**
 * @brief DebuggerCore::nopFillByte
 * @return
 */
uint8_t DebuggerCore::nopFillByte() const {
	return 0x90;
}

}

```

`plugins/DebuggerCore/win32/DebuggerCore.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DEBUGGER_CORE_H_20090529_
#define DEBUGGER_CORE_H_20090529_

#include "DebuggerCoreBase.h"
#include "IRegion.h"
#include "Module.h"
#include <QSet>

namespace DebuggerCorePlugin {

class PlatformProcess;
class PlatformThread;

class DebuggerCore : public DebuggerCoreBase {
	Q_OBJECT
	Q_PLUGIN_METADATA(IID "edb.IDebugger/1.0")
	Q_INTERFACES(IDebugger)
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

	friend class PlatformProcess;
	friend class PlatformThread;

public:
	DebuggerCore();
	~DebuggerCore() override;

public:
	bool hasExtension(uint64_t ext) const override;
	size_t pageSize() const override;
	std::size_t pointerSize() const override {
		return sizeof(void *);
	}
	std::shared_ptr<IDebugEvent> waitDebugEvent(std::chrono::milliseconds msecs) override;
	Status attach(edb::pid_t pid) override;
	Status detach() override;
	void kill() override;

	Status open(const QString &path, const QString &cwd, const QList<QByteArray> &args, const QString &input, const QString &output) override;

	MeansOfCapture lastMeansOfCapture() const override {
		qDebug("TODO: Implement DebuggerCore::lastMeansOfCapture");
		return MeansOfCapture::NeverCaptured;
	}

	int sys_pointer_size() const;
	QMap<qlonglong, QString> exceptions() const override;
	QString exceptionName(qlonglong value) override {
		qDebug("TODO: Implement DebuggerCore::exceptionName");
		return "";
	}

	qlonglong exceptionValue(const QString &name) override {
		qDebug("TODO: Implement DebuggerCore::exceptionValue");
		return 0;
	}

public:
	// thread support stuff (optional)
	QList<edb::tid_t> thread_ids() const { return threads_.keys(); }
	edb::tid_t active_thread() const { return activeThread_; }
	void set_active_thread(edb::tid_t tid) {
		Q_ASSERT(threads_.contains(tid));
		activeThread_ = tid;
	}

public:
	// process properties
	edb::pid_t parentPid(edb::pid_t pid) const override;
	uint64_t cpuType() const override;

	CpuMode cpuMode() const override {
		qDebug("TODO: Implement DebuggerCore::cpu_mode");
		return CpuMode::Unknown;
	}

public:
	std::unique_ptr<IState> createState() const override;

private:
	QMap<edb::pid_t, std::shared_ptr<IProcess>> enumerateProcesses() const override;

public:
	QString stackPointer() const override;
	QString framePointer() const override;
	QString instructionPointer() const override;
	QString flagRegister() const override {
		qDebug("TODO: Implement DebuggerCore::flag_register");
		return "";
	}

	void setIgnoredExceptions(const QList<qlonglong> &exceptions) override {
		Q_UNUSED(exceptions)
		qDebug("TODO: Implement DebuggerCore::set_ignored_exceptions");
	}

public:
	uint8_t nopFillByte() const override;

public:
	IProcess *process() const override;

private:
	using threadmap_t = QHash<edb::tid_t, std::shared_ptr<PlatformThread>>;

private:
	size_t pageSize_ = 0;
	std::shared_ptr<IProcess> process_;
	threadmap_t threads_;
	edb::tid_t activeThread_;
};

}

#endif

```

`plugins/DebuggerCore/win32/PlatformEvent.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformEvent.h"
#include "edb.h"

namespace DebuggerCorePlugin {

/**
 * @brief PlatformEvent::clone
 * @return
 */
PlatformEvent *PlatformEvent::clone() const {
	return new PlatformEvent(*this);
}

/**
 * @brief PlatformEvent::errorDescription
 * @return
 */
IDebugEvent::Message PlatformEvent::errorDescription() const {
	Q_ASSERT(isError());

	auto fault_address = static_cast<edb::address_t>(-1);
	if (event_.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) {
		fault_address = static_cast<edb::address_t>(event_.u.Exception.ExceptionRecord.ExceptionInformation[1]);
	}

	switch (code()) {
	case EXCEPTION_ACCESS_VIOLATION:
		return Message(
			tr("Illegal Access Fault"),
			tr(
				"<p>The debugged application encountered a segmentation fault.<br />The address <strong>0x%1</strong> could not be accessed.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>")
				.arg(edb::v1::format_pointer(fault_address)),
			tr("EXCEPTION_ACCESS_VIOLATION"));
	case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
		return Message(
			tr("Array Bounds Error"),
			tr(
				"<p>The debugged application tried to access an out of bounds array element.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>")
				.arg(edb::v1::format_pointer(fault_address)),
			tr("EXCEPTION_ARRAY_BOUNDS_EXCEEDED"));
	case EXCEPTION_DATATYPE_MISALIGNMENT:
		return Message(
			tr("Bus Error"),
			tr(
				"<p>The debugged application tried to read or write data that is misaligned.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_DATATYPE_MISALIGNMENT"));
	case EXCEPTION_FLT_DENORMAL_OPERAND:
		return Message(
			tr("Floating Point Exception"),
			tr(
				"<p>One of the operands in a floating-point operation is denormal. A denormal value is one that is too small to represent as a standard floating-point value.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_FLT_DENORMAL_OPERAND"));

	case EXCEPTION_FLT_DIVIDE_BY_ZERO:
		return Message(
			tr("Floating Point Exception"),
			tr(
				"<p>The debugged application tried to divide a floating-point value by a floating-point divisor of zero.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_FLT_DIVIDE_BY_ZERO"));
	case EXCEPTION_FLT_INEXACT_RESULT:
		return Message(
			tr("Floating Point Exception"),
			tr(
				"<p>The result of a floating-point operation cannot be represented exactly as a decimal fraction.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPITION_FLT_INEXACT_RESULT"));
	case EXCEPTION_FLT_INVALID_OPERATION:
		return Message(
			tr("Floating Point Exception"),
			tr(
				"<p>The application attempted an invalid floating point operation.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_FLT_INVALID_OPERATION"));
	case EXCEPTION_FLT_OVERFLOW:
		return Message(
			tr("Floating Point Exception"),
			tr(
				"<p>The exponent of a floating-point operation is greater than the magnitude allowed by the corresponding type.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_FLT_OVERFLOW"));
	case EXCEPTION_FLT_STACK_CHECK:
		return Message(
			tr("Floating Point Exception"),
			tr(
				"<p>The stack overflowed or underflowed as the result of a floating-point operation.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_FLT_STACK_CHECK"));
	case EXCEPTION_FLT_UNDERFLOW:
		return Message(
			tr("Floating Point Exception"),
			tr(
				"<p>The exponent of a floating-point operation is less than the magnitude allowed by the corresponding type.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_FLT_UNDERFLOW"));
	case EXCEPTION_ILLEGAL_INSTRUCTION:
		return Message(
			tr("Illegal Instruction Fault"),
			tr(
				"<p>The debugged application attempted to execute an illegal instruction.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_ILLEGAL_INSTRUCTION"));
	case EXCEPTION_IN_PAGE_ERROR:
		return Message(
			tr("Page Error"),
			tr(
				"<p>The debugged application tried to access a page that was not present, and the system was unable to load the page.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_IN_PAGE_ERROR"));
	case EXCEPTION_INT_DIVIDE_BY_ZERO:
		return Message(
			tr("Divide By Zero"),
			tr(
				"<p>The debugged application tried to divide an integer value by an integer divisor of zero.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_INT_DIVIDE_BY_ZERO"));
	case EXCEPTION_INT_OVERFLOW:
		return Message(
			tr("Integer Overflow"),
			tr(
				"<p>The result of an integer operation caused a carry out of the most significant bit of the result.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_INT_OVERFLOW"));
	case EXCEPTION_INVALID_DISPOSITION:
		return Message(
			tr("Invalid Disposition"),
			tr(
				"<p>An exception handler returned an invalid disposition to the exception dispatcher.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_INVALID_DISPOSITION"));
	case EXCEPTION_NONCONTINUABLE_EXCEPTION:
		return Message(
			tr("Non-Continuable Exception"),
			tr(
				"<p>The debugged application tried to continue execution after a non-continuable exception occurred.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_NONCONTINUABLE_EXCEPTION"));
	case EXCEPTION_PRIV_INSTRUCTION:
		return Message(
			tr("Privileged Instruction"),
			tr(
				"<p>The debugged application tried to execute an instruction whose operation is not allowed in the current machine mode.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_PRIV_INSTRUCTION"));
	case EXCEPTION_STACK_OVERFLOW:
		return Message(
			tr("Stack Overflow"),
			tr(
				"<p>The debugged application has exhausted its stack.</p>"
				"<p>If you would like to pass this exception to the application press Shift+[F7/F8/F9]</p>"),
			tr("EXCEPTION_STACK_OVERFLOW"));
	default:
		return Message();
	}
}

/**
 * @brief PlatformEvent::reason
 * @return
 */
IDebugEvent::REASON PlatformEvent::reason() const {
	switch (event_.dwDebugEventCode) {
	case EXCEPTION_DEBUG_EVENT:
		if (event_.u.Exception.ExceptionRecord.ExceptionFlags == EXCEPTION_NONCONTINUABLE) {
			return EVENT_TERMINATED;
		} else {
			return EVENT_STOPPED;
		}
	case EXIT_PROCESS_DEBUG_EVENT:
		return EVENT_EXITED;
	/*
	case CREATE_THREAD_DEBUG_EVENT:
	case CREATE_PROCESS_DEBUG_EVENT:
	case EXIT_THREAD_DEBUG_EVENT:
	case LOAD_DLL_DEBUG_EVENT:
	case UNLOAD_DLL_DEBUG_EVENT:
	case OUTPUT_DEBUG_STRING_EVENT:
	case RIP_EVENT:
	*/
	default:
		return EVENT_UNKNOWN;
	}
}

/**
 * @brief PlatformEvent::trapReason
 * @return
 */
IDebugEvent::TRAP_REASON PlatformEvent::trapReason() const {
	switch (event_.dwDebugEventCode) {
	case EXCEPTION_DEBUG_EVENT:
		switch (event_.u.Exception.ExceptionRecord.ExceptionCode) {
		case EXCEPTION_BREAKPOINT:
			return TRAP_BREAKPOINT;
		case EXCEPTION_SINGLE_STEP:
			return TRAP_STEPPING;
		}
	}
	return TRAP_BREAKPOINT;
}

/**
 * @brief PlatformEvent::exited
 * @return
 */
bool PlatformEvent::exited() const {
	return reason() == EVENT_EXITED;
}

/**
 * @brief PlatformEvent::isError
 * @return
 */
bool PlatformEvent::isError() const {
	switch (event_.dwDebugEventCode) {
	case EXCEPTION_DEBUG_EVENT:
		switch (event_.u.Exception.ExceptionRecord.ExceptionCode) {
		case EXCEPTION_ACCESS_VIOLATION:
		case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
		case EXCEPTION_DATATYPE_MISALIGNMENT:
		case EXCEPTION_FLT_DENORMAL_OPERAND:
		case EXCEPTION_FLT_DIVIDE_BY_ZERO:
		case EXCEPTION_FLT_INEXACT_RESULT:
		case EXCEPTION_FLT_INVALID_OPERATION:
		case EXCEPTION_FLT_OVERFLOW:
		case EXCEPTION_FLT_STACK_CHECK:
		case EXCEPTION_FLT_UNDERFLOW:
		case EXCEPTION_ILLEGAL_INSTRUCTION:
		case EXCEPTION_INT_DIVIDE_BY_ZERO:
		case EXCEPTION_INT_OVERFLOW:
		case EXCEPTION_INVALID_DISPOSITION:
		case EXCEPTION_IN_PAGE_ERROR:
		case EXCEPTION_NONCONTINUABLE_EXCEPTION:
		case EXCEPTION_PRIV_INSTRUCTION:
		case EXCEPTION_STACK_OVERFLOW:
			return true;
		case EXCEPTION_BREAKPOINT:
		case EXCEPTION_SINGLE_STEP:
			return false;
		}
	/*
	case CREATE_THREAD_DEBUG_EVENT:
	case CREATE_PROCESS_DEBUG_EVENT:
	case EXIT_THREAD_DEBUG_EVENT:
	case EXIT_PROCESS_DEBUG_EVENT:
	case LOAD_DLL_DEBUG_EVENT:
	case UNLOAD_DLL_DEBUG_EVENT:
	case OUTPUT_DEBUG_STRING_EVENT:
	case RIP_EVENT:
	*/
	default:
		return false;
	}
}

/**
 * @brief PlatformEvent::isKill
 * @return
 */
bool PlatformEvent::isKill() const {
	return false;
}

/**
 * @brief PlatformEvent::isStop
 * @return
 */
bool PlatformEvent::isStop() const {
	return !isTrap();
}

/**
 * @brief PlatformEvent::isTrap
 * @return
 */
bool PlatformEvent::isTrap() const {
	if (stopped()) {
		switch (event_.u.Exception.ExceptionRecord.ExceptionCode) {
		case EXCEPTION_SINGLE_STEP:
		case EXCEPTION_BREAKPOINT:
			return true;
		default:
			return false;
		}
	}
	return false;
}

/**
 * @brief PlatformEvent::terminated
 * @return
 */
bool PlatformEvent::terminated() const {
	return reason() == EVENT_TERMINATED;
}

/**
 * @brief PlatformEvent::stopped
 * @return
 */
bool PlatformEvent::stopped() const {
	return reason() == EVENT_STOPPED;
}

/**
 * @brief PlatformEvent::process
 * @return
 */
edb::pid_t PlatformEvent::process() const {
	return event_.dwProcessId;
}

/**
 * @brief PlatformEvent::thread
 * @return
 */
edb::tid_t PlatformEvent::thread() const {
	return event_.dwThreadId;
}

/**
 * @brief PlatformEvent::code
 * @return
 */
int64_t PlatformEvent::code() const {
	if (stopped()) {
		return event_.u.Exception.ExceptionRecord.ExceptionCode;
	}

	if (terminated()) {
		return event_.u.Exception.ExceptionRecord.ExceptionCode;
	}

	if (exited()) {
		return event_.u.ExitProcess.dwExitCode;
	}

	return 0;
}

}

```

`plugins/DebuggerCore/win32/PlatformEvent.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_EVENT_H_20121005_
#define PLATFORM_EVENT_H_20121005_

#include "IDebugEvent.h"
#include <QCoreApplication>

namespace DebuggerCorePlugin {

class PlatformEvent : public IDebugEvent {
	Q_DECLARE_TR_FUNCTIONS(PlatformEvent)
	friend class DebuggerCore;

public:
	PlatformEvent() = default;

public:
	PlatformEvent *clone() const override;

public:
	Message errorDescription() const override;
	REASON reason() const override;
	TRAP_REASON trapReason() const override;
	bool exited() const override;
	bool isError() const override;
	bool isKill() const override;
	bool isStop() const override;
	bool isTrap() const override;
	bool terminated() const override;
	bool stopped() const override;
	edb::pid_t process() const override;
	edb::tid_t thread() const override;
	int64_t code() const override;

private:
	DEBUG_EVENT event_ = {};
};

}

#endif

```

`plugins/DebuggerCore/win32/PlatformProcess.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformProcess.h"
#include "PlatformRegion.h"
#include "PlatformThread.h"
#include "edb.h"
#include <processthreadsapi.h>

namespace DebuggerCorePlugin {
namespace {

#pragma pack(push)
#pragma pack(1)
template <class T>
struct LIST_ENTRY_T {
	T Flink;
	T Blink;
};

template <class T>
struct UNICODE_STRING_T {
	union {
		struct {
			WORD Length;
			WORD MaximumLength;
		};
		T dummy;
	};
	T _Buffer;
};

template <class T, class NGF, int A>
struct _PEB_T {
	union {
		struct {
			BYTE InheritedAddressSpace;
			BYTE ReadImageFileExecOptions;
			BYTE BeingDebugged;
			BYTE _SYSTEM_DEPENDENT_01;
		};
		T dummy01;
	};
	T Mutant;
	T ImageBaseAddress;
	T Ldr;
	T ProcessParameters;
	T SubSystemData;
	T ProcessHeap;
	T FastPebLock;
	T _SYSTEM_DEPENDENT_02;
	T _SYSTEM_DEPENDENT_03;
	T _SYSTEM_DEPENDENT_04;
	union {
		T KernelCallbackTable;
		T UserSharedInfoPtr;
	};
	DWORD SystemReserved;
	DWORD _SYSTEM_DEPENDENT_05;
	T _SYSTEM_DEPENDENT_06;
	T TlsExpansionCounter;
	T TlsBitmap;
	DWORD TlsBitmapBits[2];
	T ReadOnlySharedMemoryBase;
	T _SYSTEM_DEPENDENT_07;
	T ReadOnlyStaticServerData;
	T AnsiCodePageData;
	T OemCodePageData;
	T UnicodeCaseTableData;
	DWORD NumberOfProcessors;
	union {
		DWORD NtGlobalFlag;
		NGF dummy02;
	};
	LARGE_INTEGER CriticalSectionTimeout;
	T HeapSegmentReserve;
	T HeapSegmentCommit;
	T HeapDeCommitTotalFreeThreshold;
	T HeapDeCommitFreeBlockThreshold;
	DWORD NumberOfHeaps;
	DWORD MaximumNumberOfHeaps;
	T ProcessHeaps;
	T GdiSharedHandleTable;
	T ProcessStarterHelper;
	T GdiDCAttributeList;
	T LoaderLock;
	DWORD OSMajorVersion;
	DWORD OSMinorVersion;
	WORD OSBuildNumber;
	WORD OSCSDVersion;
	DWORD OSPlatformId;
	DWORD ImageSubsystem;
	DWORD ImageSubsystemMajorVersion;
	T ImageSubsystemMinorVersion;
	union {
		T ImageProcessAffinityMask;
		T ActiveProcessAffinityMask;
	};
	T GdiHandleBuffer[A];
	T PostProcessInitRoutine;
	T TlsExpansionBitmap;
	DWORD TlsExpansionBitmapBits[32];
	T SessionId;
	ULARGE_INTEGER AppCompatFlags;
	ULARGE_INTEGER AppCompatFlagsUser;
	T pShimData;
	T AppCompatInfo;
	UNICODE_STRING_T<T> CSDVersion;
	T ActivationContextData;
	T ProcessAssemblyStorageMap;
	T SystemDefaultActivationContextData;
	T SystemAssemblyStorageMap;
	T MinimumStackCommit;
};
#pragma pack(pop)

typedef _PEB_T<DWORD, DWORD64, 34> PEB32;
typedef _PEB_T<DWORD64, DWORD, 30> PEB64;

typedef struct _PROCESS_BASIC_INFORMATION {
	PVOID Reserved1;
	PVOID PebBaseAddress;
	PVOID Reserved2[2];
	ULONG_PTR UniqueProcessId;
	PVOID Reserved3;
} PROCESS_BASIC_INFORMATION;

typedef enum _PROCESSINFOCLASS {
	ProcessBasicInformation = 0,
	ProcessDebugPort        = 7,
	ProcessWow64Information = 26,
	ProcessImageFileName    = 27
} PROCESSINFOCLASS;

bool getProcessEntry(edb::pid_t pid, PROCESSENTRY32 *entry) {

	bool ret = false;
	if (HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)) {

		PROCESSENTRY32 peInfo;
		peInfo.dwSize = sizeof(peInfo); // this line is REQUIRED

		if (Process32First(hSnapshot, &peInfo)) {
			do {
				if (peInfo.th32ProcessID == pid) {
					*entry = peInfo;
					ret    = true;
					break;
				}
			} while (Process32Next(hSnapshot, &peInfo));
		}

		CloseHandle(hSnapshot);
	}

	return ret;
}

}

/**
 * @brief PlatformProcess::PlatformProcess
 * @param core
 * @param pid
 */
PlatformProcess::PlatformProcess(DebuggerCore *core, edb::pid_t pid)
	: core_(core) {
	hProcess_ = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);
}

/**
 * @brief PlatformProcess::PlatformProcess
 * @param core
 * @param handle
 */
PlatformProcess::PlatformProcess(DebuggerCore *core, HANDLE handle)
	: core_(core) {

	DuplicateHandle(
		GetCurrentProcess(),
		handle,
		GetCurrentProcess(),
		&hProcess_,
		0,
		FALSE,
		DUPLICATE_SAME_ACCESS);
}

/**
 * @brief PlatformProcess::~PlatformProcess
 */
PlatformProcess::~PlatformProcess() {
	CloseHandle(hProcess_);
}

/**
 * @brief PlatformProcess::isWow64
 * @return
 */
bool PlatformProcess::isWow64() const {
#if defined(EDB_X86_64)
	BOOL wow64 = FALSE;

	using LPFN_ISWOW64PROCESS    = BOOL(WINAPI *)(HANDLE, PBOOL);
	static auto fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(GetModuleHandle(TEXT("kernel32")), "IsWow64Process");

	if (fnIsWow64Process && fnIsWow64Process(hProcess_, &wow64)) {
		return wow64;
	}
#endif
	return false;
}

/**
 * @brief PlatformProcess::startTime
 * @return
 */
QDateTime PlatformProcess::startTime() const {
	Q_ASSERT(hProcess_);

	FILETIME create;
	FILETIME exit;
	FILETIME kernel;
	FILETIME user;

	if (GetProcessTimes(hProcess_, &create, &exit, &kernel, &user)) {

		ULARGE_INTEGER createTime;
		createTime.LowPart  = create.dwLowDateTime;
		createTime.HighPart = create.dwHighDateTime;
		return QDateTime::fromMSecsSinceEpoch(createTime.QuadPart / 10000);
	}

	return QDateTime();
}

/**
 * @brief PlatformProcess::pid
 * @return
 */
edb::pid_t PlatformProcess::pid() const {
	return GetProcessId(hProcess_);
}

/**
 * @brief PlatformProcess::name
 * @return
 */
QString PlatformProcess::name() const {

	PROCESSENTRY32 pEntry = {};
	getProcessEntry(pid(), &pEntry);

	QString name = QString::fromWCharArray(pEntry.szExeFile);
	if (isWow64()) {
		name += " *32";
	}
	return name;
}

/**
 * @brief PlatformProcess::user
 * @return
 */
QString PlatformProcess::user() const {

	QString user;

	HANDLE hToken;
	if (OpenProcessToken(hProcess_, TOKEN_QUERY, &hToken)) {

		DWORD needed;
		GetTokenInformation(hToken, TokenOwner, nullptr, 0, &needed);

		if (auto owner = static_cast<TOKEN_OWNER *>(std::malloc(needed))) {
			if (GetTokenInformation(hToken, TokenOwner, owner, needed, &needed)) {
				WCHAR user_buf[MAX_PATH];
				WCHAR domain[MAX_PATH];
				DWORD user_sz   = MAX_PATH;
				DWORD domain_sz = MAX_PATH;
				SID_NAME_USE snu;

				if (LookupAccountSid(nullptr, owner->Owner, user_buf, &user_sz, domain, &domain_sz, &snu) && snu == SidTypeUser) {
					user = QString::fromWCharArray(user_buf);
				}
			}
			std::free(owner);
		}

		CloseHandle(hToken);
	}
	return user;
}

/**
 * @brief PlatformProcess::parent
 * @return
 */
std::shared_ptr<IProcess> PlatformProcess::parent() const {
	edb::pid_t parent_pid = core_->parentPid(pid());
	return std::make_shared<PlatformProcess>(core_, parent_pid);
}

/**
 * @brief PlatformProcess::uid
 * @return
 */
edb::uid_t PlatformProcess::uid() const {
	Q_ASSERT(hProcess_);

	HANDLE token;
	TOKEN_USER user;
	DWORD length;

	// TODO(eteran): is this on the right track?
	if (OpenProcessToken(hProcess_, 0, &token)) {
		if (GetTokenInformation(token, TokenUser, &user, sizeof(user), &length)) {
		}
	}

	return 0;
}

/**
 * @brief PlatformProcess::patches
 * @return
 */
QMap<edb::address_t, Patch> PlatformProcess::patches() const {
	return patches_;
}

/**
 * @brief PlatformProcess::write_bytes
 * @param address
 * @param buf
 * @param len
 * @return
 */
std::size_t PlatformProcess::writeBytes(edb::address_t address, const void *buf, size_t len) {
	Q_ASSERT(buf);

	if (hProcess_) {
		if (len == 0) {
			return 0;
		}

		SIZE_T bytes_written = 0;
		if (WriteProcessMemory(hProcess_, reinterpret_cast<LPVOID>(address.toUint()), buf, len, &bytes_written)) {
			return bytes_written;
		}
	}
	return 0;
}

/**
 * @brief PlatformProcess::readBytes
 * @param address
 * @param buf
 * @param len
 * @return
 */
std::size_t PlatformProcess::readBytes(edb::address_t address, void *buf, size_t len) const {
	Q_ASSERT(buf);

	if (hProcess_) {
		if (len == 0) {
			return 0;
		}

		memset(buf, 0xff, len);
		SIZE_T bytes_read = 0;
		if (ReadProcessMemory(hProcess_, reinterpret_cast<LPCVOID>(address.toUint()), buf, len, &bytes_read)) {
			// TODO(eteran): implement breakpoint stuff
#if 0
			for(const std::shared_ptr<IBreakpoint> &bp: breakpoints_) {

				if(bp->address() >= address && bp->address() < address + bytes_read) {
					reinterpret_cast<quint8 *>(buf)[bp->address() - address] = bp->original_bytes()[0];
				}
			}
#endif
			return bytes_read;
		}
	}
	return 0;
}

/**
 * @brief PlatformProcess::readPages
 * @param address
 * @param buf
 * @param count
 * @return
 */
std::size_t PlatformProcess::readPages(edb::address_t address, void *buf, size_t count) const {
	Q_ASSERT(address % core_->pageSize() == 0);
	return readBytes(address, buf, core_->pageSize() * count);
}

/**
 * @brief PlatformProcess::pause
 * @return
 */
Status PlatformProcess::pause() {
	Q_ASSERT(hProcess_);
	if (DebugBreakProcess(hProcess_)) {
		return Status::Ok;
	}

	// TODO(eteran): use GetLastError/FormatMessage
	return Status("Failed to pause");
}

/**
 * @brief PlatformProcess::regions
 * @return
 */
QList<std::shared_ptr<IRegion>> PlatformProcess::regions() const {
	QList<std::shared_ptr<IRegion>> regions;

	if (hProcess_) {
		edb::address_t addr = 0;
		auto last_base      = reinterpret_cast<LPVOID>(-1);

		Q_FOREVER {
			MEMORY_BASIC_INFORMATION info;
			VirtualQueryEx(hProcess_, reinterpret_cast<LPVOID>(addr.toUint()), &info, sizeof(info));

			if (last_base == info.BaseAddress) {
				break;
			}

			last_base = info.BaseAddress;

			if (info.State == MEM_COMMIT) {

				const auto start                         = edb::address_t::fromZeroExtended(info.BaseAddress);
				const auto end                           = edb::address_t::fromZeroExtended(info.BaseAddress) + info.RegionSize;
				const auto base                          = edb::address_t::fromZeroExtended(info.AllocationBase);
				const QString name                       = QString();
				const IRegion::permissions_t permissions = info.Protect; // let std::shared_ptr<IRegion> handle permissions and modifiers

				if (info.Type == MEM_IMAGE) {
					// set region.name to the module name
				}
				// get stack addresses, PEB, TEB, etc. and set name accordingly

				regions.push_back(std::make_shared<PlatformRegion>(start, end, base, name, permissions));
			}

			addr += info.RegionSize;
		}
	}

	return regions;
}

/**
 * @brief PlatformProcess::executable
 * @return
 */
QString PlatformProcess::executable() const {
	Q_ASSERT(hProcess_);

	// These functions don't work immediately after CreateProcess but only
	// after basic initialization, usually after the system breakpoint
	// The same applies to psapi/toolhelp, maybe using NtQueryXxxxxx is the way to go

	using QueryFullProcessImageNameWPtr = BOOL(WINAPI *)(
		HANDLE hProcess,
		DWORD dwFlags,
		LPWSTR lpExeName,
		PDWORD lpdwSize);

	HMODULE kernel32                    = GetModuleHandleW(L"kernel32.dll");
	auto QueryFullProcessImageNameWFunc = (QueryFullProcessImageNameWPtr)GetProcAddress(kernel32, "QueryFullProcessImageNameW");

	wchar_t name[MAX_PATH] = L"";

	if (QueryFullProcessImageNameWFunc /* && LOBYTE(GetVersion()) >= 6*/) { // Vista and up

		DWORD size = _countof(name);
		if (QueryFullProcessImageNameWFunc(hProcess_, 0, name, &size)) {
			return QString::fromWCharArray(name);
		}
	}

	return {};
}

/**
 * @brief PlatformProcess::arguments
 * @return
 */
QList<QByteArray> PlatformProcess::arguments() const {

	QList<QByteArray> ret;
	if (hProcess_) {

		using ZwQueryInformationProcessPtr = NTSTATUS (*WINAPI)(
			HANDLE ProcessHandle,
			PROCESSINFOCLASS ProcessInformationClass,
			PVOID ProcessInformation,
			ULONG ProcessInformationLength,
			PULONG ReturnLength);

		HMODULE ntdll                      = GetModuleHandleW(L"ntdll.dll");
		auto ZwQueryInformationProcessFunc = (ZwQueryInformationProcessPtr)GetProcAddress(ntdll, "NtQueryInformationProcess");
		PROCESS_BASIC_INFORMATION ProcessInfo;

		if (ZwQueryInformationProcessFunc) {
			ULONG l;
			NTSTATUS r = ZwQueryInformationProcessFunc(hProcess_, ProcessBasicInformation, &ProcessInfo, sizeof(PROCESS_BASIC_INFORMATION), &l);
			printf("TODO(eteran): implement this\n");
		}
	}
	return ret;
}

/**
 * @brief loadedModules
 * @return
 */
QList<Module> PlatformProcess::loadedModules() const {
	QList<Module> ret;
	HANDLE hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid());
	if (hModuleSnap != INVALID_HANDLE_VALUE) {
		MODULEENTRY32 me32;
		me32.dwSize = sizeof(me32);

		if (Module32First(hModuleSnap, &me32)) {
			do {
				Module module;
				module.baseAddress = edb::address_t::fromZeroExtended(me32.modBaseAddr);
				module.name        = QString::fromWCharArray(me32.szModule);
				ret.push_back(module);
			} while (Module32Next(hModuleSnap, &me32));
		}
	}
	CloseHandle(hModuleSnap);
	return ret;
}

/**
 * @brief PlatformProcess::threads
 * @return
 */
QList<std::shared_ptr<IThread>> PlatformProcess::threads() const {

	Q_ASSERT(core_->process_.get() == this);

	QList<std::shared_ptr<IThread>> threadList;

	for (auto &thread : core_->threads_) {
		threadList.push_back(thread);
	}

	return threadList;
}

/**
 * @brief PlatformProcess::currentThread
 * @return
 */
std::shared_ptr<IThread> PlatformProcess::currentThread() const {

	Q_ASSERT(core_->process_.get() == this);

	auto it = core_->threads_.find(core_->activeThread_);
	if (it != core_->threads_.end()) {
		return it.value();
	}
	return nullptr;
}

/**
 * @brief PlatformProcess::setCurrentThread
 * @param thread
 */
void PlatformProcess::setCurrentThread(IThread &thread) {
	core_->activeThread_ = static_cast<PlatformThread *>(&thread)->tid();
	edb::v1::update_ui();
}

Status PlatformProcess::step(edb::EventStatus status) {
	// TODO: assert that we are paused
	Q_ASSERT(core_->process_.get() == this);

	if (status != edb::DEBUG_STOP) {
		if (std::shared_ptr<IThread> thread = currentThread()) {
			return thread->step(status);
		}
	}
	return Status::Ok;
}

bool PlatformProcess::isPaused() const {
	for (auto &thread : threads()) {
		if (!thread->isPaused()) {
			return false;
		}
	}

	return true;
}

/**
 * @brief PlatformProcess::resume
 * @param status
 * @return
 */
Status PlatformProcess::resume(edb::EventStatus status) {

	int ret;

	switch (status) {
	case edb::EventStatus::DEBUG_CONTINUE:
		ret = ContinueDebugEvent(lastEvent_.dwProcessId, lastEvent_.dwThreadId, DBG_CONTINUE);
		break;
	case edb::EventStatus::DEBUG_EXCEPTION_NOT_HANDLED:
		ret = ContinueDebugEvent(lastEvent_.dwProcessId, lastEvent_.dwThreadId, DBG_EXCEPTION_NOT_HANDLED);
		break;
	case edb::EventStatus::DEBUG_NEXT_HANDLER:
	case edb::EventStatus::DEBUG_CONTINUE_BP:
	case edb::EventStatus::DEBUG_CONTINUE_STEP:
	case edb::EventStatus::DEBUG_STOP:
	default:
		break;
	}

	if (ret) {
		return Status::Ok;
	}

	return Status(QObject::tr("Error Continuing: %1").arg(GetLastError()));
}

}

```

`plugins/DebuggerCore/win32/PlatformProcess.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_PROCESS_H_20150517_
#define PLATFORM_PROCESS_H_20150517_

#include "DebuggerCore.h"
#include "IProcess.h"
#include "Module.h"

#include <QDateTime>

#include <TlHelp32.h>

namespace DebuggerCorePlugin {

class DebuggerCore;

class PlatformProcess : public IProcess {
	friend class DebuggerCore;
	friend class PlatformThread;

public:
	PlatformProcess(DebuggerCore *core, edb::pid_t pid);
	PlatformProcess(DebuggerCore *core, HANDLE handle);
	~PlatformProcess() override;

public:
	// legal to call when not attached
	QDateTime startTime() const override;

	QList<QByteArray> arguments() const override;

	QString stardardInput() const override {
		qDebug("TODO: implement PlatformProcess::stardardInput");
		return QString();
	}

	QString stardardOutput() const override {
		qDebug("TODO: implement PlatformProcess::currentWorkingDirectory");
		return QString();
	}

	QString currentWorkingDirectory() const override {
		qDebug("TODO: implement PlatformProcess::currentWorkingDirectory");
		return QString();
	}

	QString executable() const override;

	edb::address_t entryPoint() const override {
		qDebug("TODO: implement PlatformProcess::entryPoint");
		return edb::address_t();
		return 0;
	}

	edb::pid_t pid() const override;
	std::shared_ptr<IProcess> parent() const override;

	edb::address_t codeAddress() const override {
		qDebug("TODO: implement PlatformProcess::codeAddress");
		return edb::address_t();
	}

	edb::address_t dataAddress() const override {
		qDebug("TODO: implement PlatformProcess::dataAddress");
		return edb::address_t();
	}

	QList<std::shared_ptr<IRegion>> regions() const override;

	edb::uid_t uid() const override;
	QString user() const override;
	QString name() const override;
	QList<Module> loadedModules() const override;

public:
	// only legal to call when attached
	QList<std::shared_ptr<IThread>> threads() const override;
	std::shared_ptr<IThread> currentThread() const override;
	void setCurrentThread(IThread &thread) override;
	Status pause() override;
	std::size_t writeBytes(edb::address_t address, const void *buf, size_t len) override;
	std::size_t readBytes(edb::address_t address, void *buf, size_t len) const override;
	std::size_t readPages(edb::address_t address, void *buf, size_t count) const override;

	std::size_t patchBytes(edb::address_t address, const void *buf, size_t len) override {
		Q_UNUSED(address)
		Q_UNUSED(buf)
		Q_UNUSED(len)
		qDebug("TODO: implement PlatformProcess::patchBytes");
		return 0;
	}

	Status resume(edb::EventStatus status) override;
	Status step(edb::EventStatus status) override;
	bool isPaused() const override;
	QMap<edb::address_t, Patch> patches() const override;

private:
	bool isWow64() const;

private:
	edb::address_t startAddress_ = 0;
	edb::address_t imageBase_    = 0;
	DebuggerCore *core_          = nullptr;
	HANDLE hProcess_             = nullptr;
	QMap<edb::address_t, Patch> patches_;
	DEBUG_EVENT lastEvent_ = {};
};

}

#endif

```

`plugins/DebuggerCore/win32/PlatformRegion.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformRegion.h"

#include "IDebugEventHandler.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "MemoryRegions.h"
#include "State.h"
#include "edb.h"
#include <QMessageBox>

namespace DebuggerCorePlugin {

namespace {

constexpr IRegion::permissions_t KnownPermissions = (PAGE_NOACCESS | PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY);

}

/**
 * @brief PlatformRegion::PlatformRegion
 * @param start
 * @param end
 * @param base
 * @param name
 * @param permissions
 */
PlatformRegion::PlatformRegion(edb::address_t start, edb::address_t end, edb::address_t base, const QString &name, permissions_t permissions)
	: start_(start), end_(end), base_(base), name_(name), permissions_(permissions) {
}

/**
 * @brief PlatformRegion::clone
 * @return
 */
IRegion *PlatformRegion::clone() const {
	return new PlatformRegion(start_, end_, base_, name_, permissions_);
}

/**
 * @brief PlatformRegion::accessible
 * @return
 */
bool PlatformRegion::accessible() const {
	return readable() || writable() || executable();
}

/**
 * @brief PlatformRegion::readable
 * @return
 */
bool PlatformRegion::readable() const {
	switch (permissions_ & KnownPermissions) { // ignore modifiers
	case PAGE_EXECUTE_READ:
	case PAGE_EXECUTE_READWRITE:
	case PAGE_READONLY:
	case PAGE_READWRITE:
		return true;
	default:
		return false;
	}
}

/**
 * @brief PlatformRegion::writable
 * @return
 */
bool PlatformRegion::writable() const {
	switch (permissions_ & KnownPermissions) { // ignore modifiers
	case PAGE_EXECUTE_READWRITE:
	case PAGE_EXECUTE_WRITECOPY:
	case PAGE_READWRITE:
	case PAGE_WRITECOPY:
		return true;
	default:
		return false;
	}
}

/**
 * @brief PlatformRegion::executable
 * @return
 */
bool PlatformRegion::executable() const {
	switch (permissions_ & KnownPermissions) { // ignore modifiers
	case PAGE_EXECUTE:
	case PAGE_EXECUTE_READ:
	case PAGE_EXECUTE_READWRITE:
	case PAGE_EXECUTE_WRITECOPY:
		return true;
	default:
		return false;
	}
}

/**
 * @brief PlatformRegion::size
 * @return
 */
size_t PlatformRegion::size() const {
	return end_ - start_;
}

/**
 * @brief PlatformRegion::setPermissions
 * @param read
 * @param write
 * @param execute
 */
void PlatformRegion::setPermissions(bool read, bool write, bool execute) {
	if (HANDLE ph = OpenProcess(PROCESS_VM_OPERATION, FALSE, edb::v1::debugger_core->process()->pid())) {
		DWORD prot = PAGE_NOACCESS;

		switch ((static_cast<int>(read) << 2) | (static_cast<int>(write) << 1) | (static_cast<int>(execute) << 0)) {
		case 0x0:
			prot = PAGE_NOACCESS;
			break;
		case 0x1:
			prot = PAGE_EXECUTE;
			break;
		case 0x2:
			prot = PAGE_WRITECOPY;
			break;
		case 0x3:
			prot = PAGE_EXECUTE_WRITECOPY;
			break;
		case 0x4:
			prot = PAGE_READONLY;
			break;
		case 0x5:
			prot = PAGE_EXECUTE_READ;
			break;
		case 0x6:
			prot = PAGE_READWRITE;
			break;
		case 0x7:
			prot = PAGE_EXECUTE_READWRITE;
			break;
		}

		prot |= permissions_ & ~KnownPermissions; // keep modifiers

		DWORD prev_prot;
		if (VirtualProtectEx(ph, reinterpret_cast<LPVOID>(start().toUint()), size(), prot, &prev_prot)) {
			permissions_ = prot;
		}

		CloseHandle(ph);
	}
}

/**
 * @brief PlatformRegion::start
 * @return
 */
edb::address_t PlatformRegion::start() const {
	return start_;
}

/**
 * @brief PlatformRegion::end
 * @return
 */
edb::address_t PlatformRegion::end() const {
	return end_;
}

/**
 * @brief PlatformRegion::base
 * @return
 */
edb::address_t PlatformRegion::base() const {
	return base_;
}

/**
 * @brief PlatformRegion::name
 * @return
 */
QString PlatformRegion::name() const {
	return name_;
}

/**
 * @brief PlatformRegion::permissions
 * @return
 */
IRegion::permissions_t PlatformRegion::permissions() const {
	return permissions_;
}

/**
 * @brief PlatformRegion::setStart
 * @param address
 */
void PlatformRegion::setStart(edb::address_t address) {
	start_ = address;
}

/**
 * @brief PlatformRegion::setEnd
 * @param address
 */
void PlatformRegion::setEnd(edb::address_t address) {
	end_ = address;
}

}

```

`plugins/DebuggerCore/win32/PlatformRegion.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_REGION_H_20120330_
#define PLATFORM_REGION_H_20120330_

#include "IRegion.h"
#include <QCoreApplication>
#include <QString>

namespace DebuggerCorePlugin {

class PlatformRegion : public IRegion {
	Q_DECLARE_TR_FUNCTIONS(PlatformRegion)

	template <size_t N>
	friend class BackupInfo;

public:
	PlatformRegion(edb::address_t start, edb::address_t end, edb::address_t base, const QString &name, permissions_t permissions);
	~PlatformRegion() override = default;

public:
	IRegion *clone() const override;

public:
	bool accessible() const override;
	bool readable() const override;
	bool writable() const override;
	bool executable() const override;
	size_t size() const override;

public:
	void setPermissions(bool read, bool write, bool execute) override;
	void setStart(edb::address_t address) override;
	void setEnd(edb::address_t address) override;

public:
	edb::address_t start() const override;
	edb::address_t end() const override;
	edb::address_t base() const override;
	QString name() const override;
	permissions_t permissions() const override;

private:
	edb::address_t start_;
	edb::address_t end_;
	edb::address_t base_;
	QString name_;
	permissions_t permissions_;
};

}

#endif

```

`plugins/DebuggerCore/win32/PlatformState.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformState.h"
#include "edb.h"
#include "string_hash.h"
#include <cmath>
#include <limits>

namespace DebuggerCorePlugin {

namespace {

/**
 * @brief read_float80
 * @param buffer
 * @return
 */
double read_float80(const uint8_t buffer[10]) {
	// little-endian!
	//80 bit floating point value according to IEEE-754:
	//1 bit sign, 15 bit exponent, 64 bit mantissa

	constexpr uint16_t SIGNBIT    = (1 << 15);
	constexpr uint16_t EXP_BIAS   = (1 << 14) - 1; // 2^(n-1) - 1 = 16383
	constexpr uint16_t SPECIALEXP = (1 << 15) - 1; // all bits set
	constexpr uint64_t HIGHBIT    = 1ull << 63;
	constexpr uint64_t QUIETBIT   = 1ull << 62;

	// Extract sign, exponent and mantissa
	auto exponent       = *reinterpret_cast<const uint16_t *>(&buffer[8]);
	const auto mantissa = *reinterpret_cast<const uint16_t *>(&buffer[0]);

	const double sign = (exponent & SIGNBIT) ? -1.0 : 1.0;
	exponent &= ~SIGNBIT;

	// Check for undefined values
	if ((!exponent && (mantissa & HIGHBIT)) || (exponent && !(mantissa & HIGHBIT))) {
		return std::numeric_limits<double>::quiet_NaN();
	}

	// Check for special values (infinity, NaN)
	if (exponent == 0) {
		if (mantissa == 0) {
			return sign * 0.0;
		} else {
			// denormalized
		}
	} else if (exponent == SPECIALEXP) {
		if (!(mantissa & ~HIGHBIT)) {
			return sign * std::numeric_limits<double>::infinity();
		} else {
			if (mantissa & QUIETBIT) {
				return std::numeric_limits<double>::quiet_NaN();
			} else {
				return std::numeric_limits<double>::signaling_NaN();
			}
		}
	}

	//value = (-1)^s * (m / 2^63) * 2^(e - 16383)
	double significand = (static_cast<double>(mantissa) / (1ull << 63));
	return sign * ldexp(significand, exponent - EXP_BIAS);
}
}

/**
 * @brief PlatformState::clone
 * @return a copy of the state object
 */
std::unique_ptr<IState> PlatformState::clone() const {
	return std::make_unique<PlatformState>(*this);
}

/**
 * @brief PlatformState::flagsToString
 * @param flags
 * @return the flags in a string form appropriate for this platform
 */
QString PlatformState::flagsToString(edb::reg_t flags) const {
	char buf[14];
	qsnprintf(
		buf,
		sizeof(buf),
		"%c %c %c %c %c %c %c",
		((flags & 0x001) ? 'C' : 'c'),
		((flags & 0x004) ? 'P' : 'p'),
		((flags & 0x010) ? 'A' : 'a'),
		((flags & 0x040) ? 'Z' : 'z'),
		((flags & 0x080) ? 'S' : 's'),
		((flags & 0x400) ? 'D' : 'd'),
		((flags & 0x800) ? 'O' : 'o'));

	return buf;
}

/**
 * @brief PlatformState::flagsToString
 * @return the flags in a string form appropriate for this platform
 */
QString PlatformState::flagsToString() const {
	return flagsToString(flags());
}

/**
 * @brief PlatformState::value
 * @param reg
 * @return a Register object which represents the register with the name supplied
 */
Register PlatformState::value(const QString &reg) const {
	const QString lreg = reg.toLower();

#if defined(EDB_X86)
	if (lreg == "eax")
		return make_Register("eax", context32_.Eax, Register::TYPE_GPR);
	else if (lreg == "ebx")
		return make_Register("ebx", context32_.Ebx, Register::TYPE_GPR);
	else if (lreg == "ecx")
		return make_Register("ecx", context32_.Ecx, Register::TYPE_GPR);
	else if (lreg == "edx")
		return make_Register("edx", context32_.Edx, Register::TYPE_GPR);
	else if (lreg == "ebp")
		return make_Register("ebp", context32_.Ebp, Register::TYPE_GPR);
	else if (lreg == "esp")
		return make_Register("esp", context32_.Esp, Register::TYPE_GPR);
	else if (lreg == "esi")
		return make_Register("esi", context32_.Esi, Register::TYPE_GPR);
	else if (lreg == "edi")
		return make_Register("edi", context32_.Edi, Register::TYPE_GPR);
	else if (lreg == "eip")
		return make_Register("eip", context32_.Eip, Register::TYPE_IP);
	else if (lreg == "ax")
		return make_Register("ax", context32_.Eax & 0xffff, Register::TYPE_GPR);
	else if (lreg == "bx")
		return make_Register("bx", context32_.Ebx & 0xffff, Register::TYPE_GPR);
	else if (lreg == "cx")
		return make_Register("cx", context32_.Ecx & 0xffff, Register::TYPE_GPR);
	else if (lreg == "dx")
		return make_Register("dx", context32_.Edx & 0xffff, Register::TYPE_GPR);
	else if (lreg == "bp")
		return make_Register("bp", context32_.Ebp & 0xffff, Register::TYPE_GPR);
	else if (lreg == "sp")
		return make_Register("sp", context32_.Esp & 0xffff, Register::TYPE_GPR);
	else if (lreg == "si")
		return make_Register("si", context32_.Esi & 0xffff, Register::TYPE_GPR);
	else if (lreg == "di")
		return make_Register("di", context32_.Edi & 0xffff, Register::TYPE_GPR);
	else if (lreg == "al")
		return make_Register("al", context32_.Eax & 0xff, Register::TYPE_GPR);
	else if (lreg == "bl")
		return make_Register("bl", context32_.Ebx & 0xff, Register::TYPE_GPR);
	else if (lreg == "cl")
		return make_Register("cl", context32_.Ecx & 0xff, Register::TYPE_GPR);
	else if (lreg == "dl")
		return make_Register("dl", context32_.Edx & 0xff, Register::TYPE_GPR);
	else if (lreg == "ah")
		return make_Register("ah", (context32_.Eax >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "bh")
		return make_Register("bh", (context32_.Ebx >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "ch")
		return make_Register("ch", (context32_.Ecx >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "dh")
		return make_Register("dh", (context32_.Edx >> 8) & 0xff, Register::TYPE_GPR);
	else if (lreg == "cs")
		return make_Register("cs", context32_.SegCs, Register::TYPE_SEG);
	else if (lreg == "ds")
		return make_Register("ds", context32_.SegDs, Register::TYPE_SEG);
	else if (lreg == "es")
		return make_Register("es", context32_.SegEs, Register::TYPE_SEG);
	else if (lreg == "fs")
		return make_Register("fs", context32_.SegFs, Register::TYPE_SEG);
	else if (lreg == "gs")
		return make_Register("gs", context32_.SegGs, Register::TYPE_SEG);
	else if (lreg == "ss")
		return make_Register("ss", context32_.SegSs, Register::TYPE_SEG);
	else if (lreg == "fs_base")
		return make_Register("fs_base", fs_base_, Register::TYPE_SEG);
	else if (lreg == "gs_base")
		return make_Register("gs_base", gs_base_, Register::TYPE_SEG);
	else if (lreg == "eflags")
		return make_Register("eflags", context32_.EFlags, Register::TYPE_COND);
#elif defined(EDB_X86_64)
	if (!isWow64_) {
		if (lreg == "rax")
			return make_Register("rax", context64_.Rax, Register::TYPE_GPR);
		else if (lreg == "rbx")
			return make_Register("rbx", context64_.Rbx, Register::TYPE_GPR);
		else if (lreg == "rcx")
			return make_Register("rcx", context64_.Rcx, Register::TYPE_GPR);
		else if (lreg == "rdx")
			return make_Register("rdx", context64_.Rdx, Register::TYPE_GPR);
		else if (lreg == "rbp")
			return make_Register("rbp", context64_.Rbp, Register::TYPE_GPR);
		else if (lreg == "rsp")
			return make_Register("rsp", context64_.Rsp, Register::TYPE_GPR);
		else if (lreg == "rsi")
			return make_Register("rsi", context64_.Rsi, Register::TYPE_GPR);
		else if (lreg == "rdi")
			return make_Register("rdi", context64_.Rdi, Register::TYPE_GPR);
		else if (lreg == "rip")
			return make_Register("rip", context64_.Rip, Register::TYPE_IP);
		else if (lreg == "r8")
			return make_Register("r8", context64_.R8, Register::TYPE_GPR);
		else if (lreg == "r9")
			return make_Register("r9", context64_.R9, Register::TYPE_GPR);
		else if (lreg == "r10")
			return make_Register("r10", context64_.R10, Register::TYPE_GPR);
		else if (lreg == "r11")
			return make_Register("r11", context64_.R11, Register::TYPE_GPR);
		else if (lreg == "r12")
			return make_Register("r12", context64_.R12, Register::TYPE_GPR);
		else if (lreg == "r13")
			return make_Register("r13", context64_.R13, Register::TYPE_GPR);
		else if (lreg == "r14")
			return make_Register("r14", context64_.R14, Register::TYPE_GPR);
		else if (lreg == "r15")
			return make_Register("r15", context64_.R15, Register::TYPE_GPR);
		else if (lreg == "eax")
			return make_Register("eax", context64_.Rax & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "ebx")
			return make_Register("ebx", context64_.Rbx & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "ecx")
			return make_Register("ecx", context64_.Rcx & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "edx")
			return make_Register("edx", context64_.Rdx & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "ebp")
			return make_Register("ebp", context64_.Rbp & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "esp")
			return make_Register("esp", context64_.Rsp & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "esi")
			return make_Register("esi", context64_.Rsi & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "edi")
			return make_Register("edi", context64_.Rdi & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "r8d")
			return make_Register("r8d", context64_.R8 & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "r9d")
			return make_Register("r9d", context64_.R9 & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "r10d")
			return make_Register("r10d", context64_.R10 & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "r11d")
			return make_Register("r11d", context64_.R11 & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "r12d")
			return make_Register("r12d", context64_.R12 & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "r13d")
			return make_Register("r13d", context64_.R13 & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "r14d")
			return make_Register("r14d", context64_.R14 & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "r15d")
			return make_Register("r15d", context64_.R15 & 0xffffffff, Register::TYPE_GPR);
		else if (lreg == "ax")
			return make_Register("ax", context64_.Rax & 0xffff, Register::TYPE_GPR);
		else if (lreg == "bx")
			return make_Register("bx", context64_.Rbx & 0xffff, Register::TYPE_GPR);
		else if (lreg == "cx")
			return make_Register("cx", context64_.Rcx & 0xffff, Register::TYPE_GPR);
		else if (lreg == "dx")
			return make_Register("dx", context64_.Rdx & 0xffff, Register::TYPE_GPR);
		else if (lreg == "bp")
			return make_Register("bp", context64_.Rbp & 0xffff, Register::TYPE_GPR);
		else if (lreg == "sp")
			return make_Register("sp", context64_.Rsp & 0xffff, Register::TYPE_GPR);
		else if (lreg == "si")
			return make_Register("si", context64_.Rsi & 0xffff, Register::TYPE_GPR);
		else if (lreg == "di")
			return make_Register("di", context64_.Rdi & 0xffff, Register::TYPE_GPR);
		else if (lreg == "r8w")
			return make_Register("r8w", context64_.R8 & 0xffff, Register::TYPE_GPR);
		else if (lreg == "r9w")
			return make_Register("r9w", context64_.R9 & 0xffff, Register::TYPE_GPR);
		else if (lreg == "r10w")
			return make_Register("r10w", context64_.R10 & 0xffff, Register::TYPE_GPR);
		else if (lreg == "r11w")
			return make_Register("r11w", context64_.R11 & 0xffff, Register::TYPE_GPR);
		else if (lreg == "r12w")
			return make_Register("r12w", context64_.R12 & 0xffff, Register::TYPE_GPR);
		else if (lreg == "r13w")
			return make_Register("r13w", context64_.R13 & 0xffff, Register::TYPE_GPR);
		else if (lreg == "r14w")
			return make_Register("r14w", context64_.R14 & 0xffff, Register::TYPE_GPR);
		else if (lreg == "r15w")
			return make_Register("r15w", context64_.R15 & 0xffff, Register::TYPE_GPR);
		else if (lreg == "al")
			return make_Register("al", context64_.Rax & 0xff, Register::TYPE_GPR);
		else if (lreg == "bl")
			return make_Register("bl", context64_.Rbx & 0xff, Register::TYPE_GPR);
		else if (lreg == "cl")
			return make_Register("cl", context64_.Rcx & 0xff, Register::TYPE_GPR);
		else if (lreg == "dl")
			return make_Register("dl", context64_.Rdx & 0xff, Register::TYPE_GPR);
		else if (lreg == "ah")
			return make_Register("ah", (context64_.Rax >> 8) & 0xff, Register::TYPE_GPR);
		else if (lreg == "bh")
			return make_Register("bh", (context64_.Rbx >> 8) & 0xff, Register::TYPE_GPR);
		else if (lreg == "ch")
			return make_Register("ch", (context64_.Rcx >> 8) & 0xff, Register::TYPE_GPR);
		else if (lreg == "dh")
			return make_Register("dh", (context64_.Rdx >> 8) & 0xff, Register::TYPE_GPR);
		else if (lreg == "spl")
			return make_Register("spl", (context64_.Rsp >> 8) & 0xff, Register::TYPE_GPR);
		else if (lreg == "bpl")
			return make_Register("bpl", (context64_.Rbp >> 8) & 0xff, Register::TYPE_GPR);
		else if (lreg == "sil")
			return make_Register("sil", (context64_.Rsi >> 8) & 0xff, Register::TYPE_GPR);
		else if (lreg == "dil")
			return make_Register("dil", (context64_.Rdi >> 8) & 0xff, Register::TYPE_GPR);
		else if (lreg == "r8b")
			return make_Register("r8b", context64_.R8 & 0xff, Register::TYPE_GPR);
		else if (lreg == "r9b")
			return make_Register("r9b", context64_.R9 & 0xff, Register::TYPE_GPR);
		else if (lreg == "r10b")
			return make_Register("r10b", context64_.R10 & 0xff, Register::TYPE_GPR);
		else if (lreg == "r11b")
			return make_Register("r11b", context64_.R11 & 0xff, Register::TYPE_GPR);
		else if (lreg == "r12b")
			return make_Register("r12b", context64_.R12 & 0xff, Register::TYPE_GPR);
		else if (lreg == "r13b")
			return make_Register("r13b", context64_.R13 & 0xff, Register::TYPE_GPR);
		else if (lreg == "r14b")
			return make_Register("r14b", context64_.R14 & 0xff, Register::TYPE_GPR);
		else if (lreg == "r15b")
			return make_Register("r15b", context64_.R15 & 0xff, Register::TYPE_GPR);
		else if (lreg == "cs")
			return make_Register("cs", context64_.SegCs, Register::TYPE_SEG);
		else if (lreg == "ds")
			return make_Register("ds", context64_.SegDs, Register::TYPE_SEG);
		else if (lreg == "es")
			return make_Register("es", context64_.SegEs, Register::TYPE_SEG);
		else if (lreg == "fs")
			return make_Register("fs", context64_.SegFs, Register::TYPE_SEG);
		else if (lreg == "gs")
			return make_Register("gs", context64_.SegGs, Register::TYPE_SEG);
		else if (lreg == "ss")
			return make_Register("ss", context64_.SegSs, Register::TYPE_SEG);
		else if (lreg == "fs_base")
			return make_Register("fs_base", fs_base_, Register::TYPE_SEG);
		else if (lreg == "gs_base")
			return make_Register("gs_base", gs_base_, Register::TYPE_SEG);
		else if (lreg == "rflags")
			return make_Register("rflags", context64_.EFlags, Register::TYPE_COND);
	} else {
		if (lreg == "eax")
			return make_Register("eax", context32_.Eax, Register::TYPE_GPR);
		else if (lreg == "ebx")
			return make_Register("ebx", context32_.Ebx, Register::TYPE_GPR);
		else if (lreg == "ecx")
			return make_Register("ecx", context32_.Ecx, Register::TYPE_GPR);
		else if (lreg == "edx")
			return make_Register("edx", context32_.Edx, Register::TYPE_GPR);
		else if (lreg == "ebp")
			return make_Register("ebp", context32_.Ebp, Register::TYPE_GPR);
		else if (lreg == "esp")
			return make_Register("esp", context32_.Esp, Register::TYPE_GPR);
		else if (lreg == "esi")
			return make_Register("esi", context32_.Esi, Register::TYPE_GPR);
		else if (lreg == "edi")
			return make_Register("edi", context32_.Edi, Register::TYPE_GPR);
		else if (lreg == "eip")
			return make_Register("eip", context32_.Eip, Register::TYPE_IP);
		else if (lreg == "ax")
			return make_Register("ax", context32_.Eax & 0xffff, Register::TYPE_GPR);
		else if (lreg == "bx")
			return make_Register("bx", context32_.Ebx & 0xffff, Register::TYPE_GPR);
		else if (lreg == "cx")
			return make_Register("cx", context32_.Ecx & 0xffff, Register::TYPE_GPR);
		else if (lreg == "dx")
			return make_Register("dx", context32_.Edx & 0xffff, Register::TYPE_GPR);
		else if (lreg == "bp")
			return make_Register("bp", context32_.Ebp & 0xffff, Register::TYPE_GPR);
		else if (lreg == "sp")
			return make_Register("sp", context32_.Esp & 0xffff, Register::TYPE_GPR);
		else if (lreg == "si")
			return make_Register("si", context32_.Esi & 0xffff, Register::TYPE_GPR);
		else if (lreg == "di")
			return make_Register("di", context32_.Edi & 0xffff, Register::TYPE_GPR);
		else if (lreg == "al")
			return make_Register("al", context32_.Eax & 0xff, Register::TYPE_GPR);
		else if (lreg == "bl")
			return make_Register("bl", context32_.Ebx & 0xff, Register::TYPE_GPR);
		else if (lreg == "cl")
			return make_Register("cl", context32_.Ecx & 0xff, Register::TYPE_GPR);
		else if (lreg == "dl")
			return make_Register("dl", context32_.Edx & 0xff, Register::TYPE_GPR);
		else if (lreg == "ah")
			return make_Register("ah", (context32_.Eax >> 8) & 0xff, Register::TYPE_GPR);
		else if (lreg == "bh")
			return make_Register("bh", (context32_.Ebx >> 8) & 0xff, Register::TYPE_GPR);
		else if (lreg == "ch")
			return make_Register("ch", (context32_.Ecx >> 8) & 0xff, Register::TYPE_GPR);
		else if (lreg == "dh")
			return make_Register("dh", (context32_.Edx >> 8) & 0xff, Register::TYPE_GPR);
		else if (lreg == "cs")
			return make_Register("cs", context32_.SegCs, Register::TYPE_SEG);
		else if (lreg == "ds")
			return make_Register("ds", context32_.SegDs, Register::TYPE_SEG);
		else if (lreg == "es")
			return make_Register("es", context32_.SegEs, Register::TYPE_SEG);
		else if (lreg == "fs")
			return make_Register("fs", context32_.SegFs, Register::TYPE_SEG);
		else if (lreg == "gs")
			return make_Register("gs", context32_.SegGs, Register::TYPE_SEG);
		else if (lreg == "ss")
			return make_Register("ss", context32_.SegSs, Register::TYPE_SEG);
		else if (lreg == "fs_base")
			return make_Register("fs_base", fs_base_, Register::TYPE_SEG);
		else if (lreg == "gs_base")
			return make_Register("gs_base", gs_base_, Register::TYPE_SEG);
		else if (lreg == "eflags")
			return make_Register("eflags", context32_.EFlags, Register::TYPE_COND);
	}
#endif

	return Register();
}

/**
 * @brief PlatformState::framePointer
 * @return what is conceptually the frame pointer for this platform
 */
edb::address_t PlatformState::framePointer() const {
#if defined(EDB_X86)
	return context32_.Ebp;
#elif defined(EDB_X86_64)
	return isWow64_ ? context32_.Ebp : context64_.Rbp;
#endif
}

/**
 * @brief PlatformState::instructionPointer
 * @return the instruction pointer for this platform
 */
edb::address_t PlatformState::instructionPointer() const {
#if defined(EDB_X86)
	return context32_.Eip;
#elif defined(EDB_X86_64)
	return isWow64_ ? context32_.Eip : context64_.Rip;
#endif
}

/**
 * @brief PlatformState::stackPointer
 * @return the stack pointer for this platform
 */
edb::address_t PlatformState::stackPointer() const {
#if defined(EDB_X86)
	return context32_.Esp;
#elif defined(EDB_X86_64)
	return isWow64_ ? context32_.Esp : context64_.Rsp;
#endif
}

/**
 * @brief PlatformState::debugRegister
 * @param n
 * @return
 */
edb::reg_t PlatformState::debugRegister(size_t n) const {
#if defined(EDB_X86)
	switch (n) {
	case 0:
		return context32_.Dr0;
	case 1:
		return context32_.Dr1;
	case 2:
		return context32_.Dr2;
	case 3:
		return context32_.Dr3;
	case 6:
		return context32_.Dr6;
	case 7:
		return context32_.Dr7;
	}
#elif defined(EDB_X86_64)
	if (isWow64_) {
		switch (n) {
		case 0:
			return context32_.Dr0;
		case 1:
			return context32_.Dr1;
		case 2:
			return context32_.Dr2;
		case 3:
			return context32_.Dr3;
		case 6:
			return context32_.Dr6;
		case 7:
			return context32_.Dr7;
		}
	} else {
		switch (n) {
		case 0:
			return context64_.Dr0;
		case 1:
			return context64_.Dr1;
		case 2:
			return context64_.Dr2;
		case 3:
			return context64_.Dr3;
		case 6:
			return context64_.Dr6;
		case 7:
			return context64_.Dr7;
		}
	}
#endif
	return 0;
}

/**
 * @brief PlatformState::flags
 * @return
 */
edb::reg_t PlatformState::flags() const {
#if defined(EDB_X86)
	return context32_.EFlags;
#elif defined(EDB_X86_64)
	return isWow64_ ? context32_.EFlags : context64_.EFlags;
#endif
}

/**
 * @brief PlatformState::fpu_register
 * @param n
 * @return
 */
long double PlatformState::fpu_register(int n) const {
	double ret = 0.0;

	if (n >= 0 && n <= 7) {
#if defined(EDB_X86)
		auto p = reinterpret_cast<const uint8_t *>(&context32_.FloatSave.RegisterArea[n * 10]);
		if (sizeof(long double) == 10) { // can we check this at compile time?
			ret = *(reinterpret_cast<const long double *>(p));
		} else {
			ret = read_float80(p);
		}
#elif defined(EDB_X86_64)
		if (isWow64_) {
			auto p = reinterpret_cast<const uint8_t *>(&context32_.FloatSave.RegisterArea[n * 10]);
			if (sizeof(long double) == 10) { // can we check this at compile time?
				ret = *(reinterpret_cast<const long double *>(p));
			} else {
				ret = read_float80(p);
			}
		} else {
			auto p = reinterpret_cast<const uint8_t *>(&context64_.FltSave.FloatRegisters[n]);
			if (sizeof(long double) == 10) {
				ret = *(reinterpret_cast<const long double *>(p));
			} else {
				ret = read_float80(p);
			}
		}
#endif
	}
	return ret;
}

/**
 * @brief PlatformState::mmx_register
 * @param n
 * @return
 */
quint64 PlatformState::mmx_register(int n) const {
	quint64 ret = 0;

	if (n >= 0 && n <= 7) {
#if defined(EDB_X86)
		// MMX registers are an alias to the lower 64-bits of the FPU regs
		auto p = reinterpret_cast<const quint64 *>(&context32_.FloatSave.RegisterArea[n * 10]);
		ret    = *p; // little endian!
#elif defined(EDB_X86_64)
		if (isWow64_) {
			auto p = reinterpret_cast<const quint64 *>(&context32_.FloatSave.RegisterArea[n * 10]);
			ret    = *p; // little endian!
		} else {
			auto p = reinterpret_cast<const quint64 *>(&context64_.FltSave.FloatRegisters[n]);
			ret    = *p;
		}
#endif
	}
	return ret;
}

/**
 * @brief PlatformState::xmm_register
 * @param n
 * @return
 */
QByteArray PlatformState::xmm_register(int n) const {
	QByteArray ret(16, 0);

#if defined(EDB_X86)
	if (n >= 0 && n <= 7) {
		auto p = reinterpret_cast<const char *>(&context32_.ExtendedRegisters[(10 + n) * 16]);
		ret    = QByteArray(p, 16);
		std::reverse(ret.begin(), ret.end()); //little endian!
	}
#elif defined(EDB_X86_64)
	if (n >= 0 && n <= 15) {
		if (isWow64_) {
			auto p = reinterpret_cast<const char *>(&context32_.ExtendedRegisters[(10 + n) * 16]);
			ret    = QByteArray(p, 16);
			std::reverse(ret.begin(), ret.end()); //little endian!
		} else {
			auto p = reinterpret_cast<const char *>(&context64_.FltSave.XmmRegisters[n]);
			ret    = QByteArray(p, sizeof(M128A));
			std::reverse(ret.begin(), ret.end());
		}
	}
#endif

	return ret;
}

/**
 * @brief PlatformState::adjustStack
 * @param bytes
 */
void PlatformState::adjustStack(int bytes) {
#if defined(EDB_X86)
	context32_.Esp += bytes;
#elif defined(EDB_X86_64)
	if (isWow64_) {
		context32_.Esp += bytes;
	} else {
		context64_.Rsp += bytes;
	}
#endif
}

/**
 * @brief PlatformState::clear
 */
void PlatformState::clear() {
	context32_ = {};
#if defined(EDB_X86_64)
	context64_ = {};
#endif
	fs_base_ = 0;
	gs_base_ = 0;
}

/**
 * @brief PlatformState::setDebugRegister
 * @param n
 * @param value
 */
void PlatformState::setDebugRegister(size_t n, edb::reg_t value) {
#if defined(EDB_X86)
	switch (n) {
	case 0:
		context32_.Dr0 = value;
		break;
	case 1:
		context32_.Dr1 = value;
		break;
	case 2:
		context32_.Dr2 = value;
		break;
	case 3:
		context32_.Dr3 = value;
		break;
	case 6:
		context32_.Dr6 = value;
		break;
	case 7:
		context32_.Dr7 = value;
		break;
	default:
		break;
	}
#elif defined(EDB_X86_64)
	if (isWow64_) {
		switch (n) {
		case 0:
			context32_.Dr0 = value;
			break;
		case 1:
			context32_.Dr1 = value;
			break;
		case 2:
			context32_.Dr2 = value;
			break;
		case 3:
			context32_.Dr3 = value;
			break;
		case 6:
			context32_.Dr6 = value;
			break;
		case 7:
			context32_.Dr7 = value;
			break;
		default:
			break;
		}
	} else {
		switch (n) {
		case 0:
			context64_.Dr0 = value;
			break;
		case 1:
			context64_.Dr1 = value;
			break;
		case 2:
			context64_.Dr2 = value;
			break;
		case 3:
			context64_.Dr3 = value;
			break;
		case 6:
			context64_.Dr6 = value;
			break;
		case 7:
			context64_.Dr7 = value;
			break;
		default:
			break;
		}
	}
#endif
}

/**
 * @brief PlatformState::setFlags
 * @param flags
 */
void PlatformState::setFlags(edb::reg_t flags) {
#if defined(EDB_X86)
	context32_.EFlags = flags;
#elif defined(EDB_X86_64)
	if (isWow64_) {
		context32_.EFlags = flags;
	} else {
		context64_.EFlags = flags;
	}
#endif
}

/**
 * @brief PlatformState::setInstructionPointer
 * @param value
 */
void PlatformState::setInstructionPointer(edb::address_t value) {
#if defined(EDB_X86)
	context32_.Eip = value;
#elif defined(EDB_X86_64)
	if (isWow64_) {
		context32_.Eip = static_cast<uint32_t>(value);
	} else {
		context64_.Rip = value;
	}
#endif
}

/**
 * @brief PlatformState::setRegister
 * @param name
 * @param value
 */
void PlatformState::setRegister(const QString &name, edb::reg_t value) {

	const QString lreg = name.toLower();
#if defined(EDB_X86)
	if (lreg == "eax") {
		context32_.Eax = value;
	} else if (lreg == "ebx") {
		context32_.Ebx = value;
	} else if (lreg == "ecx") {
		context32_.Ecx = value;
	} else if (lreg == "edx") {
		context32_.Edx = value;
	} else if (lreg == "ebp") {
		context32_.Ebp = value;
	} else if (lreg == "esp") {
		context32_.Esp = value;
	} else if (lreg == "esi") {
		context32_.Esi = value;
	} else if (lreg == "edi") {
		context32_.Edi = value;
	} else if (lreg == "eip") {
		context32_.Eip = value;
	} else if (lreg == "cs") {
		context32_.SegCs = value;
	} else if (lreg == "ds") {
		context32_.SegDs = value;
	} else if (lreg == "es") {
		context32_.SegEs = value;
	} else if (lreg == "fs") {
		context32_.SegFs = value;
	} else if (lreg == "gs") {
		context32_.SegGs = value;
	} else if (lreg == "ss") {
		context32_.SegSs = value;
	} else if (lreg == "eflags") {
		context32_.EFlags = value;
	}
#elif defined(EDB_X86_64)
	if (!isWow64_) {
		if (lreg == "rax") {
			context64_.Rax = value;
		} else if (lreg == "rbx") {
			context64_.Rbx = value;
		} else if (lreg == "rcx") {
			context64_.Rcx = value;
		} else if (lreg == "rdx") {
			context64_.Rdx = value;
		} else if (lreg == "rbp") {
			context64_.Rbp = value;
		} else if (lreg == "rsp") {
			context64_.Rsp = value;
		} else if (lreg == "rsi") {
			context64_.Rsi = value;
		} else if (lreg == "rdi") {
			context64_.Rdi = value;
		} else if (lreg == "r8") {
			context64_.R8 = value;
		} else if (lreg == "r9") {
			context64_.R9 = value;
		} else if (lreg == "r10") {
			context64_.R10 = value;
		} else if (lreg == "r11") {
			context64_.R11 = value;
		} else if (lreg == "r12") {
			context64_.R12 = value;
		} else if (lreg == "r13") {
			context64_.R13 = value;
		} else if (lreg == "r14") {
			context64_.R14 = value;
		} else if (lreg == "r15") {
			context64_.R15 = value;
		} else if (lreg == "rip") {
			context64_.Rip = value;
		} else if (lreg == "cs") {
			context64_.SegCs = value;
		} else if (lreg == "ds") {
			context64_.SegDs = value;
		} else if (lreg == "es") {
			context64_.SegEs = value;
		} else if (lreg == "fs") {
			context64_.SegFs = value;
		} else if (lreg == "gs") {
			context64_.SegGs = value;
		} else if (lreg == "ss") {
			context64_.SegSs = value;
		} else if (lreg == "rflags") {
			context64_.EFlags = value;
		}
	} else {
		if (lreg == "eax") {
			context32_.Eax = value;
		} else if (lreg == "ebx") {
			context32_.Ebx = value;
		} else if (lreg == "ecx") {
			context32_.Ecx = value;
		} else if (lreg == "edx") {
			context32_.Edx = value;
		} else if (lreg == "ebp") {
			context32_.Ebp = value;
		} else if (lreg == "esp") {
			context32_.Esp = value;
		} else if (lreg == "esi") {
			context32_.Esi = value;
		} else if (lreg == "edi") {
			context32_.Edi = value;
		} else if (lreg == "eip") {
			context32_.Eip = value;
		} else if (lreg == "cs") {
			context32_.SegCs = value;
		} else if (lreg == "ds") {
			context32_.SegDs = value;
		} else if (lreg == "es") {
			context32_.SegEs = value;
		} else if (lreg == "fs") {
			context32_.SegFs = value;
		} else if (lreg == "gs") {
			context32_.SegGs = value;
		} else if (lreg == "ss") {
			context32_.SegSs = value;
		} else if (lreg == "eflags") {
			context32_.EFlags = value;
		}
	}
#endif
}

/**
 * @brief PlatformState::instructionPointerRegister
 * @return
 */
Register PlatformState::instructionPointerRegister() const {
#if defined(EDB_X86_64)
	if (!isWow64_) {
		return make_Register("rip", context64_.Rip, Register::TYPE_IP);
	} else {
		return make_Register("eip", context32_.Eip, Register::TYPE_IP);
	}
#elif defined(EDB_X86)
	return make_Register("eip", context32_.Eip, Register::TYPE_IP);
#endif
}

/**
 * @brief PlatformState::flagsRegister
 * @return
 */
Register PlatformState::flagsRegister() const {
#if defined(EDB_X86_64)
	if (!isWow64_) {
		return make_Register("rflags", context64_.EFlags, Register::TYPE_IP);
	} else {
		return make_Register("eflags", context32_.EFlags, Register::TYPE_IP);
	}
#elif defined(EDB_X86)
	return make_Register("eflags", context32_.EFlags, Register::TYPE_IP);
#endif
	return Register();
}

/**
 * @brief PlatformState::getThreadState
 * @param hThread
 * @param isWow64
 */
void PlatformState::getThreadState(HANDLE hThread, bool isWow64) {
#if defined(EDB_X86)
	context32_.ContextFlags = CONTEXT_ALL; //CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS | CONTEXT_FLOATING_POINT;
	GetThreadContext(hThread, &context32_);

	gs_base_ = 0;
	fs_base_ = 0;

	LDT_ENTRY ldt_entry;
	if (GetThreadSelectorEntry(hThread, context32_.SegGs, &ldt_entry)) {
		gs_base_ = ldt_entry.BaseLow | (ldt_entry.HighWord.Bits.BaseMid << 16) | (ldt_entry.HighWord.Bits.BaseHi << 24);
	}

	if (GetThreadSelectorEntry(hThread, context32_.SegFs, &ldt_entry)) {
		fs_base_ = ldt_entry.BaseLow | (ldt_entry.HighWord.Bits.BaseMid << 16) | (ldt_entry.HighWord.Bits.BaseHi << 24);
	}
#elif defined(EDB_X86_64)

	gs_base_ = 0;
	fs_base_ = 0;

	if (isWow64) {
		context32_.ContextFlags = CONTEXT_ALL; //CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS | CONTEXT_FLOATING_POINT;
		Wow64GetThreadContext(hThread, &context32_);

		WOW64_LDT_ENTRY ldt_entry;
		if (Wow64GetThreadSelectorEntry(hThread, context32_.SegGs, &ldt_entry)) {
			gs_base_ = ldt_entry.BaseLow | (ldt_entry.HighWord.Bits.BaseMid << 16) | (ldt_entry.HighWord.Bits.BaseHi << 24);
		}

		if (Wow64GetThreadSelectorEntry(hThread, context32_.SegFs, &ldt_entry)) {
			fs_base_ = ldt_entry.BaseLow | (ldt_entry.HighWord.Bits.BaseMid << 16) | (ldt_entry.HighWord.Bits.BaseHi << 24);
		}
	} else {
		context64_.ContextFlags = CONTEXT_ALL; //CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS | CONTEXT_FLOATING_POINT;
		GetThreadContext(hThread, &context64_);

		// GetThreadSelectorEntry always returns false on x64
		// on x64 gs_base == TEB, maybe we can use that somehow
	}

	isWow64_ = isWow64;
#endif
}

/**
 * @brief PlatformState::setThreadState
 * @param hThread
 */
void PlatformState::setThreadState(HANDLE hThread) const {
#if defined(EDB_X86)
	SetThreadContext(hThread, &context32_);
#elif defined(EDB_X86_64)
	if (isWow64_) {
		Wow64SetThreadContext(hThread, &context32_);
	} else {
		SetThreadContext(hThread, &context64_);
	}
#endif
}

/**
 * @brief PlatformState::archRegister
 * @param type
 * @param n
 * @return
 */
Register PlatformState::archRegister(uint64_t type, size_t n) const {
	switch (type) {
	case edb::string_hash("mmx"):
		return mmxRegister(n);
	case edb::string_hash("xmm"):
		return xmmRegister(n);
	case edb::string_hash("ymm"):
		return ymmRegister(n);
	default:
		break;
	}
	return Register();
}

}

```

`plugins/DebuggerCore/win32/PlatformState.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_STATE_H_20110330_
#define PLATFORM_STATE_H_20110330_

#include "IState.h"
#include "Types.h"
#include <Windows.h>

namespace DebuggerCorePlugin {

class PlatformState : public IState {
	friend class DebuggerCore;
	friend class PlatformThread;

public:
	PlatformState() = default;

public:
	std::unique_ptr<IState> clone() const override;

public:
	long double fpu_register(int n) const;
	quint64 mmx_register(int n) const;
	QByteArray xmm_register(int n) const;

public:
	QString flagsToString() const override;
	QString flagsToString(edb::reg_t flags) const override;
	Register value(const QString &reg) const override;
	Register instructionPointerRegister() const override;
	Register flagsRegister() const override;
	edb::address_t framePointer() const override;
	edb::address_t instructionPointer() const override;
	edb::address_t stackPointer() const override;
	edb::reg_t debugRegister(size_t n) const override;
	edb::reg_t flags() const override;

	void adjustStack(int bytes) override;
	void clear() override;
	bool empty() const override {
		qDebug("TODO: implement PlatformState::empty");
		return true;
	}
	void setDebugRegister(size_t n, edb::reg_t value) override;
	void setFlags(edb::reg_t flags) override;
	void setInstructionPointer(edb::address_t value) override;
	void setRegister(const QString &name, edb::reg_t value) override;
	void setRegister(const Register &reg) override {
		qDebug("TODO: implement PlatformState::set_register");
	}

	Register archRegister(uint64_t type, size_t n) const override;

	Register mmxRegister(size_t n) const {
		qDebug("TODO: implement PlatformState::mmx_register");
		return Register();
	}

	Register xmmRegister(size_t n) const {
		qDebug("TODO: implement PlatformState::xmm_register");
		return Register();
	}

	Register ymmRegister(size_t n) const {
		qDebug("TODO: implement PlatformState::ymm_register");
		return Register();
	}

	Register gpRegister(size_t n) const override {
		qDebug("TODO: implement PlatformState::gp_register");
		return Register();
	}

	int fpuStackPointer() const override {
		qDebug("TODO: implement PlatformState::fpu_stack_pointer");
		return 0;
	}

	edb::value80 fpuRegister(size_t n) const override {
		qDebug("TODO: implement PlatformState::fpu_register");
		return edb::value80();
	}

	bool fpuRegisterIsEmpty(size_t n) const override {
		qDebug("TODO: implement PlatformState::fpu_register_is_empty");
		return true;
	}

	QString fpuRegisterTagString(size_t n) const override {
		qDebug("TODO: implement PlatformState::fpu_register_tag_string");
		return "";
	}

	edb::value16 fpuControlWord() const override {
		qDebug("TODO: implement PlatformState::fpu_control_word");
		return edb::value16();
	}

	edb::value16 fpuStatusWord() const override {
		qDebug("TODO: implement PlatformState::fpu_status_word");
		return edb::value16();
	}

	edb::value16 fpuTagWord() const override {
		qDebug("TODO: implement PlatformState::fpu_tag_word");
		return edb::value16();
	}

public:
	void getThreadState(HANDLE hThread, bool isWow64);
	void setThreadState(HANDLE hThread) const;

private:
#if defined(EDB_X86_64)
	union {
		CONTEXT context64_ = {};
		WOW64_CONTEXT context32_;
	};

	bool isWow64_ = false;
#else
	CONTEXT context32_;
#endif
	edb::address_t fs_base_ = 0;
	edb::address_t gs_base_ = 0;
};

}

#endif

```

`plugins/DebuggerCore/win32/PlatformThread.cpp`:

```cpp
/*
Copyright (C) 2015 - 2018 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PlatformThread.h"
#include "PlatformProcess.h"
#include "PlatformState.h"
#include "State.h"

namespace DebuggerCorePlugin {

/**
 * @brief PlatformThread::PlatformThread
 * @param core
 * @param process
 * @param hThread
 */
PlatformThread::PlatformThread(DebuggerCore *core, std::shared_ptr<IProcess> &process, const CREATE_THREAD_DEBUG_INFO *info)
	: core_(core), process_(process) {

	isWow64_ = static_cast<PlatformProcess *>(process.get())->isWow64();

	DuplicateHandle(
		GetCurrentProcess(),
		info->hThread,
		GetCurrentProcess(),
		&hThread_,
		0,
		FALSE,
		DUPLICATE_SAME_ACCESS);
}

/**
 * @brief PlatformThread::tid
 * @return
 */
edb::tid_t PlatformThread::tid() const {
	return GetThreadId(hThread_);
}

/**
 * @brief PlatformThread::name
 * @return
 */
QString PlatformThread::name() const {

	using GetThreadDescriptionType = HRESULT(WINAPI *)(HANDLE, PWSTR *);

	static auto fnGetThreadDescription = reinterpret_cast<GetThreadDescriptionType>(GetProcAddress(GetModuleHandle(TEXT("kernel32")), "GetThreadDescription"));
	if (fnGetThreadDescription) {
		WCHAR *data;
		HRESULT hr = fnGetThreadDescription(hThread_, &data);
		if (SUCCEEDED(hr)) {
			auto name = QString::fromWCharArray(data);
			LocalFree(data);
			return name;
		}
	}

	return tr("Thread: %1").arg(tid());
}

/**
 * @brief PlatformThread::priority
 * @return
 */
int PlatformThread::priority() const {
	return GetThreadPriority(hThread_);
}

/**
 * @brief PlatformThread::instructionPointer
 * @return
 */
edb::address_t PlatformThread::instructionPointer() const {
#if defined(EDB_X86)
	CONTEXT context;
	context.ContextFlags = CONTEXT_CONTROL;
	GetThreadContext(hThread_, &context);
	return context.Eip;
#elif defined(EDB_X86_64)
	if (isWow64_) {
		WOW64_CONTEXT context;
		context.ContextFlags = CONTEXT_CONTROL;
		Wow64GetThreadContext(hThread_, &context);
		return context.Eip;
	} else {
		CONTEXT context;
		context.ContextFlags = CONTEXT_CONTROL;
		GetThreadContext(hThread_, &context);
		return context.Rip;
	}
#endif
}

/**
 * @brief PlatformThread::runState
 * @return
 */
QString PlatformThread::runState() const {
	return {};
}

/**
 * @brief PlatformThread::get_state
 * @param state
 */
void PlatformThread::getState(State *state) {
	if (auto p = static_cast<PlatformState *>(state->impl_.get())) {
		p->getThreadState(hThread_, isWow64_);
	}
}

/**
 * @brief PlatformThread::set_state
 * @param state
 */
void PlatformThread::setState(const State &state) {
	if (auto p = static_cast<const PlatformState *>(state.impl_.get())) {
		p->setThreadState(hThread_);
	}
}

/**
 * @brief PlatformThread::step
 * @return
 */
Status PlatformThread::step() {
#if defined(EDB_X86)
	CONTEXT context;
	context.ContextFlags = CONTEXT_CONTROL;
	GetThreadContext(hThread_, &context);
	context.EFlags |= (1 << 8); // set the trap flag
	SetThreadContext(hThread_, &context);
#elif defined(EDB_X86_64)
	if (isWow64_) {
		WOW64_CONTEXT context;
		context.ContextFlags = CONTEXT_CONTROL;
		Wow64GetThreadContext(hThread_, &context);
		context.EFlags |= (1 << 8); // set the trap flag
		Wow64SetThreadContext(hThread_, &context);
	} else {
		CONTEXT context;
		context.ContextFlags = CONTEXT_CONTROL;
		GetThreadContext(hThread_, &context);
		context.EFlags |= (1 << 8); // set the trap flag
		SetThreadContext(hThread_, &context);
	}
#endif

	return resume();
}

/**
 * @brief PlatformThread::step
 * @param status
 * @return
 */
Status PlatformThread::step(edb::EventStatus status) {
#if defined(EDB_X86)
	CONTEXT context;
	context.ContextFlags = CONTEXT_CONTROL;
	GetThreadContext(hThread_, &context);
	context.EFlags |= (1 << 8); // set the trap flag
	SetThreadContext(hThread_, &context);
#elif defined(EDB_X86_64)
	if (isWow64_) {
		WOW64_CONTEXT context;
		context.ContextFlags = CONTEXT_CONTROL;
		Wow64GetThreadContext(hThread_, &context);
		context.EFlags |= (1 << 8); // set the trap flag
		Wow64SetThreadContext(hThread_, &context);
	} else {
		CONTEXT context;
		context.ContextFlags = CONTEXT_CONTROL;
		GetThreadContext(hThread_, &context);
		context.EFlags |= (1 << 8); // set the trap flag
		SetThreadContext(hThread_, &context);
	}
#endif

	return resume(status);
}

/**
 * @brief PlatformThread::resume
 * @return
 */
Status PlatformThread::resume() {

	// TODO(eteran): suspend the other threads, then basically just call process_->resume

	ContinueDebugEvent(process_->pid(), tid(), DBG_CONTINUE);
	return Status::Ok;
}

/**
 * @brief PlatformThread::resume
 * @param status
 * @return
 */
Status PlatformThread::resume(edb::EventStatus status) {

	// TODO(eteran): suspend the other threads, then basically just call process_->resume

	ContinueDebugEvent(
		process_->pid(),
		tid(),
		(status == edb::DEBUG_CONTINUE) ? (DBG_CONTINUE) : (DBG_EXCEPTION_NOT_HANDLED));
	return Status::Ok;
}

/**
 * @brief PlatformThread::isPaused
 * @return
 */
bool PlatformThread::isPaused() const {
	return {};
}

}

```

`plugins/DebuggerCore/win32/PlatformThread.h`:

```h
/*
Copyright (C) 2015 - 2018 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLATFORM_THREAD_H_20191119_
#define PLATFORM_THREAD_H_20191119_

#include "DebuggerCore.h"
#include "IProcess.h"
#include "IThread.h"
#include <QCoreApplication>
#include <memory>

namespace DebuggerCorePlugin {

class PlatformThread : public IThread {
	Q_DECLARE_TR_FUNCTIONS(PlatformThread)
public:
	PlatformThread(DebuggerCore *core, std::shared_ptr<IProcess> &process, const CREATE_THREAD_DEBUG_INFO *info);
	~PlatformThread() override = default;

public:
	edb::tid_t tid() const override;
	QString name() const override;
	int priority() const override;
	edb::address_t instructionPointer() const override;
	QString runState() const override;

public:
	void getState(State *state) override;
	void setState(const State &state) override;

public:
	Status step() override;
	Status step(edb::EventStatus status) override;
	Status resume() override;
	Status resume(edb::EventStatus status) override;

public:
	bool isPaused() const override;

private:
	DebuggerCore *core_ = nullptr;
	std::shared_ptr<IProcess> process_;
	HANDLE hThread_ = nullptr;
	bool isWow64_   = false;
};

}

#endif

```

`plugins/DebuggerErrorConsole/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "DebuggerErrorConsole")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	Plugin.cpp
	Plugin.h
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/DebuggerErrorConsole/Plugin.cpp`:

```cpp
/*
Copyright (C) 2017 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Plugin.h"

namespace DebuggerErrorConsolePlugin {

/**
 * @brief Plugin::Plugin
 * @param parent
 */
Plugin::Plugin(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief Plugin::menu
 * @param parent
 * @return
 */
QMenu *Plugin::menu(QWidget *) {
	return nullptr;
}

/**
 * @brief DebuggerErrorConsole::DebuggerErrorConsole
 * @param parent
 * @param f
 */
DebuggerErrorConsole::DebuggerErrorConsole(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {
}

}

```

`plugins/DebuggerErrorConsole/Plugin.h`:

```h
/*
Copyright (C) 2017 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DEBUGGER_ERROR_CONSOLE_PLUGIN_H_20170808_
#define DEBUGGER_ERROR_CONSOLE_PLUGIN_H_20170808_

#include "IPlugin.h"
#include "edb.h"
#include <QDialog>

namespace DebuggerErrorConsolePlugin {

class DebuggerErrorConsole : public QDialog {
	Q_OBJECT
public:
	explicit DebuggerErrorConsole(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
};

class Plugin : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Ruslan Kabatsayev")
	Q_CLASSINFO("email", "b7.10110111@gmail.com")

public:
	explicit Plugin(QObject *parent = nullptr);
	~Plugin() override = default;

public:
	QMenu *menu(QWidget *parent = nullptr) override;
};

}

#endif

```

`plugins/DumpState/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "DumpState")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	DumpState.cpp
	DumpState.h
	OptionsPage.cpp
	OptionsPage.h
	OptionsPage.ui
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/DumpState/DumpState.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DumpState.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IThread.h"
#include "Instruction.h"
#include "OptionsPage.h"
#include "Register.h"
#include "State.h"
#include "Util.h"
#include "edb.h"

#include <QMenu>
#include <QSettings>
#include <cctype>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

namespace DumpStatePlugin {
namespace {

/**
 * @brief hex_string
 * @param value
 * @return
 */
template <class T>
std::string hex_string(const T &value) {
	return value.toHexString().toStdString();
}

constexpr const char Reset[]  = "\x1B[0m";
constexpr const char Red[]    = "\x1B[91m";
constexpr const char Yellow[] = "\x1B[93m";
constexpr const char Cyan[]   = "\x1B[96m";
constexpr const char Blue[]   = "\x1B[94m";
constexpr const char Green[]  = "\x1B[92m";
constexpr const char Purple[] = "\x1B[95m";

/**
 * @brief format_register
 * @param value
 * @return
 */
template <class T>
std::string format_register(const T &value) {

	QSettings settings;
	const int colorize = settings.value("DumpState/colorize", true).toBool();

	if (colorize) {
		return Blue + hex_string(value) + Reset;
	} else {
		return hex_string(value);
	}
}

/**
 * @brief format_segment
 * @param value
 * @return
 */
template <class T>
std::string format_segment(const T &value) {

	QSettings settings;
	const int colorize = settings.value("DumpState/colorize", true).toBool();

	if (colorize) {
		return Green + hex_string(value) + Reset;
	} else {
		return hex_string(value);
	}
}

/**
 * @brief format_address
 * @param value
 * @return
 */
template <class T>
std::string format_address(const T &value) {

	QSettings settings;
	const int colorize = settings.value("DumpState/colorize", true).toBool();

	if (colorize) {
		return Purple + hex_string(value) + Reset;
	} else {
		return hex_string(value);
	}
}

}

/**
 * @brief DumpState::DumpState
 * @param parent
 */
DumpState::DumpState(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief DumpState::menu
 * @param parent
 * @return
 */
QMenu *DumpState::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("DumpState"), parent);
		menu_->addAction(tr("&Dump Current State"), this, SLOT(showMenu()), QKeySequence(tr("Ctrl+D")));
	}

	return menu_;
}

/**
 * @brief DumpState::dumpCode
 * @param state
 */
void DumpState::dumpCode(const State &state) {

	QSettings settings;
	const int instructions_to_print = settings.value("DumpState/instructions_after_ip", 6).toInt();

	const edb::address_t ip = state.instructionPointer();
	edb::address_t address  = ip;

	for (int i = 0; i < instructions_to_print + 1; ++i) {
		uint8_t buf[edb::Instruction::MaxSize];
		if (const int size = edb::v1::get_instruction_bytes(address, buf)) {
			edb::Instruction inst(buf, buf + size, address);
			if (inst) {
				std::cout << ((address == ip) ? "> " : "  ") << hex_string(address) << ": " << edb::v1::formatter().toString(inst) << "\n";
			} else {
				break;
			}
			address += inst.byteSize();
		} else {
			break;
		}
	}
}

/**
 * @brief DumpState::dumpRegisters
 * @param state
 */
void DumpState::dumpRegisters(const State &state) {

	using std::cout;
	if (edb::v1::debuggeeIs32Bit()) { // TODO: check if state itself is 32 bit, not current debuggee. Generally it's not the same.
		cout << "     eax:" << format_register(state["eax"]);
		cout << " ecx:" << format_register(state["ecx"]);
		cout << "  edx:" << format_register(state["edx"]);
		cout << "  ebx:" << format_register(state["ebx"]);
		cout << "     eflags:" << format_register(state["eflags"]);
		cout << "\n";
		cout << "     esp:" << format_register(state["esp"]);
		cout << " ebp:" << format_register(state["ebp"]);
		cout << "  esi:" << format_register(state["esi"]);
		cout << "  edi:" << format_register(state["edi"]);
		cout << "     eip:" << format_register(state["eip"]);
		cout << "\n";
		cout << "     es:" << format_segment(state["es"]);
		cout << "  cs:" << format_segment(state["cs"]);
		cout << "  ss:" << format_segment(state["ss"]);
		cout << "  ds:" << format_segment(state["ds"]);
		cout << "  fs:" << format_segment(state["fs"]);
		cout << "  gs:" << format_segment(state["gs"]);
		cout << "    ";
		const Register eflagsR = state["eflags"];
		if (eflagsR) {
			const auto eflags = eflagsR.value<edb::value32>();
			cout << ((eflags & (1 << 11)) != 0 ? 'O' : 'o') << ' ';
			cout << ((eflags & (1 << 10)) != 0 ? 'D' : 'd') << ' ';
			cout << ((eflags & (1 << 9)) != 0 ? 'I' : 'i') << ' ';
			cout << ((eflags & (1 << 8)) != 0 ? 'T' : 't') << ' ';
			cout << ((eflags & (1 << 7)) != 0 ? 'S' : 's') << ' ';
			cout << ((eflags & (1 << 6)) != 0 ? 'Z' : 'z') << ' ';
			cout << ((eflags & (1 << 4)) != 0 ? 'A' : 'a') << ' ';
			cout << ((eflags & (1 << 2)) != 0 ? 'P' : 'p') << ' ';
			cout << ((eflags & (1 << 0)) != 0 ? 'C' : 'c');
		}
		cout << "\n";
	} else {
		cout << "     rax:" << format_register(state["rax"]);
		cout << " rcx:" << format_register(state["rcx"]);
		cout << "  rdx:" << format_register(state["rdx"]);
		cout << "  rbx:" << format_register(state["rbx"]);
		cout << "     rflags:" << format_register(state["rflags"]);
		cout << "\n";
		cout << "     rsp:" << format_register(state["rsp"]);
		cout << " rbp:" << format_register(state["rbp"]);
		cout << "  rsi:" << format_register(state["rsi"]);
		cout << "  rdi:" << format_register(state["rdi"]);
		cout << "        rip:" << format_register(state["rip"]);
		cout << "\n";
		cout << "      r8:" << format_register(state["r8"]);
		cout << "  r9:" << format_register(state["r9"]);
		cout << "  r10:" << format_register(state["r10"]);
		cout << "  r11:" << format_register(state["r11"]);
		cout << "           ";

		const Register rflagsR = state["rflags"];
		if (rflagsR) {
			const auto rflags = rflagsR.value<edb::value32>();
			cout << ((rflags & (1 << 11)) != 0 ? 'O' : 'o') << ' ';
			cout << ((rflags & (1 << 10)) != 0 ? 'D' : 'd') << ' ';
			cout << ((rflags & (1 << 9)) != 0 ? 'I' : 'i') << ' ';
			cout << ((rflags & (1 << 8)) != 0 ? 'T' : 't') << ' ';
			cout << ((rflags & (1 << 7)) != 0 ? 'S' : 's') << ' ';
			cout << ((rflags & (1 << 6)) != 0 ? 'Z' : 'z') << ' ';
			cout << ((rflags & (1 << 4)) != 0 ? 'A' : 'a') << ' ';
			cout << ((rflags & (1 << 2)) != 0 ? 'P' : 'p') << ' ';
			cout << ((rflags & (1 << 0)) != 0 ? 'C' : 'c');
		}

		cout << "\n";
		cout << "     r12:" << format_register(state["r12"]);
		cout << " r13:" << format_register(state["r13"]);
		cout << "  r14:" << format_register(state["r14"]);
		cout << "  r15:" << format_register(state["r15"]);
		cout << "\n";
		cout << "     es:" << format_segment(state["es"]);
		cout << "  cs:" << format_segment(state["cs"]);
		cout << "  ss:" << format_segment(state["ss"]);
		cout << "  ds:" << format_segment(state["ds"]);
		cout << "  fs:" << format_segment(state["fs"]);
		cout << "  gs:" << format_segment(state["gs"]);
		cout << "\n";
	}
}

/**
 * @brief DumpState::dumpLines
 * @param address
 * @param lines
 */
void DumpState::dumpLines(edb::address_t address, int lines) {

	if (IProcess *process = edb::v1::debugger_core->process()) {
		for (int i = 0; i < lines; ++i) {
			edb::value8 buf[16];
			if (process->readBytes(address, buf, sizeof(buf))) {

				std::cout << hex_string(address) << " : ";

				for (int j = 0x00; j < 0x04; ++j)
					std::cout << hex_string(buf[j]) << " ";
				std::cout << " ";

				for (int j = 0x04; j < 0x08; ++j)
					std::cout << hex_string(buf[j]) << " ";
				std::cout << "- ";
				for (int j = 0x08; j < 0x0c; ++j)
					std::cout << hex_string(buf[j]) << " ";
				std::cout << " ";
				for (int j = 0x0c; j < 0x10; ++j)
					std::cout << hex_string(buf[j]) << " ";

				for (int j = 0; j < 16; ++j) {
					// TODO(eteran): why won't this compile with MSVC?
					const uint8_t ch = buf[j].toUint();
					std::cout << ((std::isprint(ch) || (std::isspace(ch) && (ch != '\f' && ch != '\t' && ch != '\r' && ch != '\n' && ch != '\x0b') && ch < 0x80)) ? static_cast<char>(ch) : '.');
				}

				std::cout << "\n";
			} else {
				break;
			}
			address += 16;
		}
	}
}

/**
 * @brief DumpState::dumpStack
 * @param state
 */
void DumpState::dumpStack(const State &state) {
	dumpLines(state.stackPointer(), 4);
}

/**
 * @brief DumpState::dumpData
 * @param address
 */
void DumpState::dumpData(edb::address_t address) {
	dumpLines(address, 2);
}

/**
 * @brief DumpState::showMenu
 */
void DumpState::showMenu() {

	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			State state;
			thread->getState(&state);

			std::cout << "------------------------------------------------------------------------------\n";
			dumpRegisters(state);
			std::cout << "[" << format_segment(state["ss"]) << ":" << format_address(state.stackPointer()) << "]---------------------------------------------------------[stack]\n";
			dumpStack(state);

			const edb::address_t data_address = edb::v1::current_data_view_address();
			std::cout << "[" << format_segment(state["ds"]) << ":" << format_address(data_address) << "]---------------------------------------------------------[ data]\n";
			dumpData(data_address);
			std::cout << "[" << format_segment(state["cs"]) << ":" << format_address(state.instructionPointer()) << "]---------------------------------------------------------[ code]\n";
			dumpCode(state);
			std::cout << "------------------------------------------------------------------------------\n";
		}
	}
}

/**
 * @brief DumpState::optionsPage
 * @return
 */
QWidget *DumpState::optionsPage() {
	return new OptionsPage;
}

}

```

`plugins/DumpState/DumpState.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DUMP_STATE_H_20061122_
#define DUMP_STATE_H_20061122_

#include "IPlugin.h"
#include "Types.h"

class QMenu;
class State;

namespace DumpStatePlugin {

class DumpState : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit DumpState(QObject *parent = nullptr);
	~DumpState() override = default;

public:
	QMenu *menu(QWidget *parent = nullptr) override;

public Q_SLOTS:
	void showMenu();

private:
	QWidget *optionsPage() override;

private:
	void dumpCode(const State &state);
	void dumpRegisters(const State &state);
	void dumpStack(const State &state);
	void dumpData(edb::address_t address);
	void dumpLines(edb::address_t address, int lines);

private:
	QMenu *menu_ = nullptr;
};

}

#endif

```

`plugins/DumpState/OptionsPage.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "OptionsPage.h"
#include <QSettings>

namespace DumpStatePlugin {

/**
 * @brief OptionsPage::OptionsPage
 * @param parent
 * @param f
 */
OptionsPage::OptionsPage(QWidget *parent, Qt::WindowFlags f)
	: QWidget(parent, f) {

	ui.setupUi(this);
}

/**
 * @brief OptionsPage::showEvent
 * @param event
 */
void OptionsPage::showEvent(QShowEvent *event) {
	Q_UNUSED(event)

	QSettings settings;
	ui.instructionsBeforeIP->setValue(settings.value("DumpState/instructions_before_ip", 0).toInt());
	ui.instructionsAfterIP->setValue(settings.value("DumpState/instructions_after_ip", 5).toInt());
	ui.colorizeOutput->setChecked(settings.value("DumpState/colorize", true).toBool());
}

/**
 * @brief OptionsPage::on_instructionsBeforeIP_valueChanged
 * @param i
 */
void OptionsPage::on_instructionsBeforeIP_valueChanged(int i) {
	QSettings settings;
	settings.setValue("DumpState/instructions_before_ip", i);
}

/**
 * @brief OptionsPage::on_instructionsAfterIP_valueChanged
 * @param i
 */
void OptionsPage::on_instructionsAfterIP_valueChanged(int i) {
	QSettings settings;
	settings.setValue("DumpState/instructions_after_ip", i);
}

/**
 * @brief OptionsPage::on_colorizeOutput_toggled
 * @param value
 */
void OptionsPage::on_colorizeOutput_toggled(bool value) {
	QSettings settings;
	settings.setValue("DumpState/colorize", value);
}

}

```

`plugins/DumpState/OptionsPage.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef OPTIONS_PAGE_H_20090706_
#define OPTIONS_PAGE_H_20090706_

#include "ui_OptionsPage.h"
#include <QWidget>

namespace DumpStatePlugin {

class OptionsPage : public QWidget {
	Q_OBJECT

public:
	explicit OptionsPage(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~OptionsPage() override = default;

public:
	void showEvent(QShowEvent *event) override;

public Q_SLOTS:
	void on_instructionsBeforeIP_valueChanged(int i);
	void on_instructionsAfterIP_valueChanged(int i);
	void on_colorizeOutput_toggled(bool value);

private:
	Ui::OptionsPage ui;
};

}

#endif

```

`plugins/DumpState/OptionsPage.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DumpStatePlugin::OptionsPage</class>
 <widget class="QWidget" name="DumpStatePlugin::OptionsPage">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>443</width>
    <height>259</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dump State Plugin</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QLabel" name="label">
     <property name="text">
      <string>Instructions To Display Before Instruction Pointer:</string>
     </property>
    </widget>
   </item>
   <item row="0" column="1">
    <widget class="QSpinBox" name="instructionsBeforeIP">
     <property name="enabled">
      <bool>false</bool>
     </property>
    </widget>
   </item>
   <item row="1" column="0">
    <widget class="QLabel" name="label_2">
     <property name="text">
      <string>Instructions To Display After Instruction Pointer:</string>
     </property>
    </widget>
   </item>
   <item row="1" column="1">
    <widget class="QSpinBox" name="instructionsAfterIP">
     <property name="value">
      <number>6</number>
     </property>
    </widget>
   </item>
   <item row="2" column="0" colspan="2">
    <widget class="QCheckBox" name="colorizeOutput">
     <property name="text">
      <string>Colorize Output</string>
     </property>
    </widget>
   </item>
   <item row="3" column="0">
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>190</height>
      </size>
     </property>
    </spacer>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`plugins/FasLoader/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "FasLoader")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
  FasLoader.cpp
  FasLoader.hpp

  Fas/Core.cpp
  Fas/Core.hpp
  Fas/Exception.cpp
  Fas/Exception.hpp
  Fas/Header.hpp
  Fas/PluginSymbol.hpp
  Fas/Symbol.hpp
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/FasLoader/Fas/Core.cpp`:

```cpp

#include "Core.hpp"
#include "Exception.hpp"
#include <QtDebug>

namespace {

constexpr uint32_t Signature = 0x1A736166;

}

// TODO(eteran): this class is generally a good candiate for more RAII
// and usage of the QFile class instead of std::ifstream

namespace Fas {

void Core::load(const std::string &fileName) {
	fileName_ = fileName;

	try {
		open();
		loadHeader();
		loadFasSymbols();
		deleteUndefinedSymbols();
		deleteAssemblyTimeVariable();
		deleteCannotBeForwardReferenced();
		deleteNegativeSymbols();
		deleteSpecialMarkers();
		qDebug() << fasSymbols_.size();
		deleteAnonymousSymbols();
		loadSymbols();
	} catch (std::exception &e) {
		qWarning() << e.what();
	}
}

void Core::open() {
	ifs_.open(fileName_, std::ios::binary);
	if (!ifs_.is_open()) {
		throw Exception("*.fas file not loaded.");
	}
}

void Core::loadHeader() {
	ifs_.seekg(0);

	if (!ifs_.read((char *)&header_, sizeof(Header))) {
		throw Exception("*.fas Header not loaded.");
	}

	if (header_.signature != Signature) {
		throw Exception("*.fas signature fail");
	}

	if (header_.lengthOfHeader != 64) {
		throw Exception("*.fas header size not supported");
	}
}

void Core::loadFasSymbols() {
	ifs_.seekg(header_.offsetOfSymbolsTable);

	auto size  = header_.lengthOfSymbolsTable;
	auto count = size / sizeof(Fas::Symbol);
	for (uint i = 0; i < count; ++i) {
		auto symbol = loadFasSymbol();
		fasSymbols_.push_back(symbol);
	}
}

Fas::Symbol Core::loadFasSymbol() {
	Fas::Symbol symbol;

	if (!ifs_.read((char *)&symbol, sizeof(Fas::Symbol))) {
		throw Exception("*.fas symbol not loaded");
	}

	return symbol;
}

void Core::deleteUndefinedSymbols() {
	auto it = std::begin(fasSymbols_);
	while (it != std::end(fasSymbols_)) {
		uint16_t wasDefined = it->flags & 1;
		if (!wasDefined) {
			it = fasSymbols_.erase(it);
		} else {
			++it;
		}
	}
}

void Core::deleteAssemblyTimeVariable() {
	auto it = std::begin(fasSymbols_);
	while (it != std::end(fasSymbols_)) {
		uint16_t isAssemblyTimeVariable = it->flags & 0x2;
		if (isAssemblyTimeVariable) {
			it = fasSymbols_.erase(it);
		} else {
			++it;
		}
	}
}

void Core::deleteCannotBeForwardReferenced() {
	auto it = std::begin(fasSymbols_);
	while (it != std::end(fasSymbols_)) {
		uint16_t cannotBeForwardReferenced = it->flags & 0x4;
		if (cannotBeForwardReferenced) {
			it = fasSymbols_.erase(it);
		} else {
			++it;
		}
	}
}

void Core::deleteSpecialMarkers() {
	auto it = std::begin(fasSymbols_);
	while (it != std::end(fasSymbols_)) {
		uint16_t isSpecialMarker = it->flags & 0x400;
		if (isSpecialMarker) {
			it = fasSymbols_.erase(it);
		} else {
			++it;
		}
	}
}

void Core::deleteNegativeSymbols() {
	auto it = std::begin(fasSymbols_);
	while (it != std::end(fasSymbols_)) {
		if (it->valueSign) {
			it = fasSymbols_.erase(it);
		} else {
			++it;
		}
	}
}

void Core::deleteAnonymousSymbols() {
	auto it = std::begin(fasSymbols_);
	while (it != std::end(fasSymbols_)) {
		bool isAnonymous = it->preprocessedSign == 0 && it->preprocessed == 0;
		if (isAnonymous) {
			it = fasSymbols_.erase(it);
		} else {
			++it;
		}
	}
}

void Core::loadSymbols() {
	for (auto fasSymbol : fasSymbols_) {
		checkAbsoluteValue(fasSymbol);
		loadSymbolFromFasSymbol(fasSymbol);
	}
}

void Core::checkAbsoluteValue(const Fas::Symbol &fasSymbol) {
	if (fasSymbol.typeOfValue != ValueTypes::ABSOLUTE_VALUE) {
		throw Exception(" Support only absolute value");
	}
}

void Core::loadSymbolFromFasSymbol(const Fas::Symbol &fasSymbol) {
	PluginSymbol symbol;

	symbol.value = fasSymbol.value;
	symbol.size  = fasSymbol.sizeOfData;

	if (fasSymbol.preprocessedSign) {
		// in the strings table
		symbol.name = cstr2string(fasSymbol);
	} else {
		// in the preprocessed pascal style
		symbol.name = pascal2string(fasSymbol);
	}

	symbols_.push_back(symbol);
}

std::string Core::cstr2string(const Symbol &fasSymbol) {

	constexpr int MaxLength = 64;

	auto offset = header_.offsetOfSymbolsTable + fasSymbol.preprocessed;
	char cstr[MaxLength];
	auto count = 0;

	ifs_.seekg(offset);
	char *c = cstr;
	while (true) {
		ifs_.read(c, 1);
		if (count >= (MaxLength - 1)) break;
		if (*c == 0) break;
		++c;
		++count;
	}

	cstr[count] = '\0';

	std::string str = cstr;
	return str;
}

std::string Core::pascal2string(const Fas::Symbol &fasSymbol) {

	auto offset = header_.offsetOfPreprocessedSource + fasSymbol.preprocessed;
	uint8_t len;
	char pascal[64];

	ifs_.seekg(offset);

	if (!ifs_.read((char *)&len, sizeof(len))) {
		throw Exception("Length of pascal string not loaded");
	}

	if (!ifs_.read(pascal, len)) {
		throw Exception("Pascal string not loaded");
	}
	pascal[len] = '\0';

	std::string str = pascal;
	return str;
}

const PluginSymbols &Core::getSymbols() {
	return symbols_;
}

}

```

`plugins/FasLoader/Fas/Core.hpp`:

```hpp
#pragma once

#include "Header.hpp"
#include "PluginSymbol.hpp"
#include "Symbol.hpp"

#include <fstream>
#include <string>
#include <vector>

namespace Fas {

using FasSymbols    = std::vector<Symbol>;
using PluginSymbols = std::vector<PluginSymbol>;

class Core {
public:
	Core() = default;

public:
	void load(const std::string &fileName_);
	const PluginSymbols &getSymbols();

private:
	void open();
	void loadHeader();
	void loadFasSymbols();
	Symbol loadFasSymbol();
	void deleteUndefinedSymbols();
	void deleteCannotBeForwardReferenced();
	void deleteAssemblyTimeVariable();
	void deleteSpecialMarkers();
	void deleteNegativeSymbols();
	void deleteAnonymousSymbols();
	void loadSymbols();
	void checkAbsoluteValue(const Symbol &fasSymbol);
	void loadSymbolFromFasSymbol(const Symbol &fasSymbol);
	std::string pascal2string(const Symbol &fasSymbol);
	std::string cstr2string(const Symbol &fasSymbol);

private:
	std::ifstream ifs_;
	std::string fileName_;
	Header header_;
	FasSymbols fasSymbols_;
	PluginSymbols symbols_;
};
}

```

`plugins/FasLoader/Fas/Exception.cpp`:

```cpp
/*
 * @file: Exception.cpp
 *
 * This file part of RT ( Reconstructive Tools )
 * Copyright (c) 2018 darkprof <dark_prof@mail.ru>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
**/

#include "Exception.hpp"

namespace Fas {

Exception::Exception(const std::string &message)
	: message_(message) {
}

const char *Exception::what() const noexcept {
	return message_.c_str();
}

}

```

`plugins/FasLoader/Fas/Exception.hpp`:

```hpp
/*
 * @file: Exception.hpp
 *
 * This file part of RT ( Reconstructive Tools )
 * Copyright (c) 2018 darkprof <dark_prof@mail.ru>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
**/

#pragma once

#include <exception>
#include <string>

namespace Fas {

class Exception : public std::exception {
public:
	explicit Exception(const std::string &message);
	~Exception() noexcept override = default;

	const char *what() const noexcept override;

protected:
	std::string message_;
};

}

```

`plugins/FasLoader/Fas/Header.hpp`:

```hpp
#pragma once

#include <cstdint>

namespace Fas {

#pragma pack(push, 1)
struct Header {
	uint32_t signature;
	uint8_t major;
	uint8_t minor;
	uint16_t lengthOfHeader;
	uint32_t offsetOfInputFileName;  // base = strings table
	uint32_t offsetOfOutputFileName; // base = strings table
	uint32_t offsetOfStringsTable;
	uint32_t lengthOfStringsTable;
	uint32_t offsetOfSymbolsTable;
	uint32_t lengthOfSymbolsTable;
	uint32_t offsetOfPreprocessedSource;
	uint32_t lengthOfPreprocessedSource;
	uint32_t offsetOfAssemblyDump;
	uint32_t lengthOfAssemblyDump;
	uint32_t offsetOfSectionNamesTable;
	uint32_t lengthOfSectionNamesTable;
	uint32_t offsetOfSymbolReferencesDump;
	uint32_t lengthOfSymbolReferencesDump;
};
#pragma pack(pop)

}

```

`plugins/FasLoader/Fas/PluginSymbol.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>

namespace Fas {

struct PluginSymbol {
	uint64_t value;
	std::string name;
	uint8_t size;
};

}

```

`plugins/FasLoader/Fas/Symbol.hpp`:

```hpp
#pragma once

#include <cstdint>

namespace Fas {

enum class ValueTypes : uint8_t {
	ABSOLUTE_VALUE = 0,
	RELOCATABLE_SEGMENT_ADDRESS,
	RELOCATABLE_32_BIT_ADDRESS,
	RELOCATABLE_RELATIVE_32_BIT_ADDRESS,
	RELOCATABLE_64_BIT_ADDRESS,
	GOT_RELATIVE_32_BIT_ADDRESS,
	_32_BIT_ADDRESS_OF_PLT_ENTRY,
	RELATIVE_32_BIT_ADDRESS_OF_PLT_ENTRY
};

#pragma pack(push, 1)
struct Symbol {
	uint64_t value : 63;
	uint64_t valueSign : 1;

	uint16_t flags;

	uint8_t sizeOfData;
	ValueTypes typeOfValue;
	uint32_t extendedSib;
	uint16_t numberOfPassDefined;
	uint16_t numberOfPassUsed;

	uint32_t section : 31;
	uint32_t sectionSign : 1;

	uint32_t preprocessed : 31;
	uint32_t preprocessedSign : 1;

	uint32_t offsetInPreprocessed;
};
#pragma pack(pop)

}

```

`plugins/FasLoader/Fas/fas.txt`:

```txt

                                flat assembler
                       Symbolic information file format


   Table 1  Header
  /-------------------------------------------------------------------------\
  | Offset | Size    | Description                                          |
  |========|=========|======================================================|
  |   +0   |  dword  | Signature 1A736166h (little-endian).                 |
  |--------|---------|------------------------------------------------------|
  |   +4   |  byte   | Major version of flat assembler.                     |
  |--------|---------|------------------------------------------------------|
  |   +5   |  byte   | Minor version of flat assembler.                     |
  |--------|---------|------------------------------------------------------|
  |   +6   |  word   | Length of header.                                    |
  |--------|---------|------------------------------------------------------|
  |   +8   |  dword  | Offset of input file name in the strings table.      |
  |--------|---------|------------------------------------------------------|
  |  +12   |  dword  | Offset of output file name in the strings table.     |
  |--------|---------|------------------------------------------------------|
  |  +16   |  dword  | Offset of strings table.                             |
  |--------|---------|------------------------------------------------------|
  |  +20   |  dword  | Length of strings table.                             |
  |--------|---------|------------------------------------------------------|
  |  +24   |  dword  | Offset of symbols table.                             |
  |--------|---------|------------------------------------------------------|
  |  +28   |  dword  | Length of symbols table.                             |
  |--------|---------|------------------------------------------------------|
  |  +32   |  dword  | Offset of preprocessed source.                       |
  |--------|---------|------------------------------------------------------|
  |  +36   |  dword  | Length of preprocessed source.                       |
  |--------|---------|------------------------------------------------------|
  |  +40   |  dword  | Offset of assembly dump.                             |
  |--------|---------|------------------------------------------------------|
  |  +44   |  dword  | Length of assembly dump.                             |
  |--------|---------|------------------------------------------------------|
  |  +48   |  dword  | Offset of section names table.                       |
  |--------|---------|------------------------------------------------------|
  |  +52   |  dword  | Length of section names table.                       |
  |--------|---------|------------------------------------------------------|
  |  +56   |  dword  | Offset of symbol references dump.                    |
  |--------|---------|------------------------------------------------------|
  |  +60   |  dword  | Length of symbol references dump.                    |
  \-------------------------------------------------------------------------/

  Notes:

    If header is shorter than 64 bytes, it comes from a version that does not
    support dumping some of the structures. It should then be interpreted
    that the data for missing structures could not be provided, not that the
    size of that data is zero.

    Offsets given in header generally mean positions in the file, however
    input and output file names are specified by offsets in the strings table,
    so you have to add their offset to the offset of strings table to obtain
    the positions of those strings in the file.

    The strings table contains just a sequence of ASCIIZ strings, which may
    be referred to by other parts of the file. It contains the names of
    main input file, the output file, and the names of the sections and
    external symbols if there were any.

    The symbols table is an array of 32-byte structures, each one in format
    specified by table 2.

    The preprocessed source is a sequence of preprocessed lines, each one
    in format as defined in table 3.

    The assembly dump contains an array of 28-byte structures, each one in
    format specified by table 4, and at the end of this array an additional
    double word containing the offset in output file at which the assembly
    was ended.

    It is possible that file does not contain assembly dump at all - this
    happens when some error occured and only the preprocessed source was
    dumped. If error occured during the preprocessing, only the source up to
    the point of error is provided. In such case (and only then) the field
    at offset 44 contains zero.

    The section names table exists only when the output format was an object
    file (ELF or COFF), and it is an array of 4-byte entries, each being an
    offset of the name of the section in the strings table.
    The index of section in this table is the same, as the index of section
    in the generated object file.

    The symbol references dump contains an array of 8-byte structures, each
    one describes an event of some symbol being used. The first double word
    of such structure contains an offset of symbol in the symbols table,
    and the second double word is an offset of structure in assembly dump,
    which specifies at what moment the symbol was referenced.


   Table 2  Symbol structure
  /-------------------------------------------------------------------------\
  | Offset | Size  | Description                                            |
  |========|=======|========================================================|
  |   +0   | qword | Value of symbol.                                       |
  |--------|-------|--------------------------------------------------------|
  |   +8   | word  | Flags (table 2.1).                                     |
  |--------|-------|--------------------------------------------------------|
  |  +10   | byte  | Size of data labelled by this symbol (zero means plain |
  |        |       | label without size attached).                          |
  |--------|-------|--------------------------------------------------------|
  |  +11   | byte  | Type of value (table 2.2). Any value other than zero   |
  |        |       | means some kind of relocatable symbol.                 |
  |--------|-------|--------------------------------------------------------|
  |  +12   | dword | Extended SIB, the first two bytes are register codes   |
  |        |       | and the second two bytes are corresponding scales.     |
  |--------|-------|--------------------------------------------------------|
  |  +16   | word  | Number of pass in which symbol was defined last time.  |
  |--------|-------|--------------------------------------------------------|
  |  +18   | word  | Number of pass in which symbol was used last time.     |
  |--------|-------|--------------------------------------------------------|
  |  +20   | dword | If the symbol is relocatable, this field contains      |
  |        |       | information about section or external symbol, to which |
  |        |       | it is relative - otherwise this field has no meaning.  |
  |        |       | When the highest bit is cleared, the symbol is         |
  |        |       | relative to a section, and the bits 0-30 contain       |
  |        |       | the index (starting from 1) in the table of sections.  |
  |        |       | When the highest bit is set, the symbol is relative to |
  |        |       | an external symbol, and the bits 0-30 contain the      |
  |        |       | the offset of the name of this symbol in the strings   |
  |        |       | table.                                                 |
  |--------|-------|--------------------------------------------------------|
  |  +24   | dword | If the highest bit is cleared, the bits 0-30 contain   |
  |        |       | the offset of symbol name in the preprocessed source.  |
  |        |       | This name is a pascal-style string (byte length        |
  |        |       | followed by string data).                              |
  |        |       | Zero in this field means an anonymous symbol.          |
  |        |       | If the highest bit is set, the bits 0-30 contain the   |
  |        |       | offset of the symbol name in the strings table, and    |
  |        |       | this name is a zero-ended string in this case (as are  |
  |        |       | all the strings there).                                |
  |--------|-------|--------------------------------------------------------|
  |  +28   | dword | Offset in the preprocessed source of line that defined |
  |        |       | this symbol (see table 3).                             |
  \-------------------------------------------------------------------------/


   Table 2.1  Symbol flags
  /-----------------------------------------------------------------\
  | Bit | Value | Description                                       |
  |=====|=======|===================================================|
  |  0  |     1 | Symbol was defined.                               |
  |-----|-------|---------------------------------------------------|
  |  1  |     2 | Symbol is an assembly-time variable.              |
  |-----|-------|---------------------------------------------------|
  |  2  |     4 | Symbol cannot be forward-referenced.              |
  |-----|-------|---------------------------------------------------|
  |  3  |     8 | Symbol was used.                                  |
  |-----|-------|---------------------------------------------------|
  |  4  |   10h | The prediction was needed when checking           |
  |     |       | whether the symbol was used.                      |
  |-----|-------|---------------------------------------------------|
  |  5  |   20h | Result of last predicted check for being used.    |
  |-----|-------|---------------------------------------------------|
  |  6  |   40h | The prediction was needed when checking           |
  |     |       | whether the symbol was defined.                   |
  |-----|-------|---------------------------------------------------|
  |  7  |   80h | Result of last predicted check for being defined. |
  |-----|-------|---------------------------------------------------|
  |  8  |  100h | The optimization adjustment is applied to         |
  |     |       | the value of this symbol.                         |
  |-----|-------|---------------------------------------------------|
  |  9  |  200h | The value of symbol is negative number encoded    |
  |     |       | as two's complement.                              |
  |-----|-------|---------------------------------------------------|
  | 10  |  400h | Symbol is a special marker and has no value.      |
  \-----------------------------------------------------------------/

  Notes:

    Some of those flags are listed here just for completness, as they
    have little use outside of the flat assembler. However the bit 0
    is important, because the symbols table contains all the labels
    that occured in source, even if some of them were in the
    conditional blocks that did not get assembled.


   Table 2.2  Symbol value types
  /-------------------------------------------------------------------\
  | Value | Description                                               |
  |=======|===========================================================|
  |   0   | Absolute value.                                           |
  |-------|-----------------------------------------------------------|
  |   1   | Relocatable segment address (only with MZ output).        |
  |-------|-----------------------------------------------------------|
  |   2   | Relocatable 32-bit address.                               |
  |-------|-----------------------------------------------------------|
  |   3   | Relocatable relative 32-bit address (value valid only for |
  |       | symbol used in the same place where it was calculated,    |
  |       | it should not occur in the symbol structure).             |
  |-------|-----------------------------------------------------------|
  |   4   | Relocatable 64-bit address.                               |
  |-------|-----------------------------------------------------------|
  |   5   | [ELF only] GOT-relative 32-bit address.                   |
  |-------|-----------------------------------------------------------|
  |   6   | [ELF only] 32-bit address of PLT entry.                   |
  |-------|-----------------------------------------------------------|
  |   7   | [ELF only] Relative 32-bit address of PLT entry (value    |
  |       | valid only for symbol used in the same place where it     |
  |       | was calculated, it should not occur in the symbol         |
  |       | structure).                                               |
  \-------------------------------------------------------------------/

  Notes:

    The types 3 and 7 should never be encountered in the symbols dump,
    they are only used internally by the flat assembler.

    If type value is a negative number, it is an opposite of a value
    from this table and it means that the symbol of a given type has
    been negated.


   Table 2.3  Register codes for extended SIB
  /------------------\
  | Value | Register |
  |=======|==========|
  |  23h  | BX       |
  |-------|----------|
  |  25h  | BP       |
  |-------|----------|
  |  26h  | SI       |
  |-------|----------|
  |  27h  | DI       |
  |-------|----------|
  |  40h  | EAX      |
  |-------|----------|
  |  41h  | ECX      |
  |-------|----------|
  |  42h  | EDX      |
  |-------|----------|
  |  43h  | EBX      |
  |-------|----------|
  |  44h  | ESP      |
  |-------|----------|
  |  45h  | EBP      |
  |-------|----------|
  |  46h  | ESI      |
  |-------|----------|
  |  47h  | EDI      |
  |-------|----------|
  |  48h  | R8D      |
  |-------|----------|
  |  49h  | R9D      |
  |-------|----------|
  |  4Ah  | R10D     |
  |-------|----------|
  |  4Bh  | R11D     |
  |-------|----------|
  |  4Ch  | R12D     |
  |-------|----------|
  |  4Dh  | R13D     |
  |-------|----------|
  |  4Eh  | R14D     |
  |-------|----------|
  |  4Fh  | R15D     |
  |-------|----------|
  |  80h  | RAX      |
  |-------|----------|
  |  81h  | RCX      |
  |-------|----------|
  |  82h  | RDX      |
  |-------|----------|
  |  83h  | RBX      |
  |-------|----------|
  |  84h  | RSP      |
  |-------|----------|
  |  85h  | RBP      |
  |-------|----------|
  |  86h  | RSI      |
  |-------|----------|
  |  87h  | RDI      |
  |-------|----------|
  |  88h  | R8       |
  |-------|----------|
  |  89h  | R9       |
  |-------|----------|
  |  8Ah  | R10      |
  |-------|----------|
  |  8Bh  | R11      |
  |-------|----------|
  |  8Ch  | R12      |
  |-------|----------|
  |  8Dh  | R13      |
  |-------|----------|
  |  8Eh  | R14      |
  |-------|----------|
  |  8Fh  | R15      |
  |-------|----------|
  |  94h  | EIP      |
  |-------|----------|
  |  98h  | RIP      |
  \------------------/


   Table 3  Preprocessed line
  /--------------------------------------------------------------------------\
  | Offset | Size  | Value                                                   |
  |========|=================================================================|
  |   +0   | dword | When the line was loaded from source, this field        |
  |        |       | contains either zero (if it is the line from the main   |
  |        |       | input file), or an offset inside the preprocessed       |
  |        |       | source to the name of file, from which this line was    |
  |        |       | loaded (the name of file is zero-ended string).         |
  |        |       | When the line was generated by macroinstruction, this   |
  |        |       | field contains offset inside the preprocessed source to |
  |        |       | the pascal-style string specifying the name of          |
  |        |       | macroinstruction, which generated this line.            |
  |--------|-------|---------------------------------------------------------|
  |   +4   | dword | Bits 0-30 contain the number of this line.              |
  |        |       | If the highest bit is zeroed, this line was loaded from |
  |        |       | source.                                                 |
  |        |       | If the highest bit is set, this line was generated by   |
  |        |       | macroinstruction.                                       |
  |--------|-------|---------------------------------------------------------|
  |   +8   | dword | If the line was loaded from source, this field contains |
  |        |       | the position of the line inside the source file, from   |
  |        |       | which it was loaded.                                    |
  |        |       | If line was generated by macroinstruction, this field   |
  |        |       | contains the offset of preprocessed line, which invoked |
  |        |       | the macroinstruction.                                   |
  |        |       | If line was generated by instantaneous macro, this      |
  |        |       | field is equal to the next one.                         |
  |--------|-------|---------------------------------------------------------|
  |  +12   | dword | If the line was generated by macroinstruction, this     |
  |        |       | field contains offset of the preprocessed line inside   |
  |        |       | the definition of macro, from which this one was        |
  |        |       | generated.                                              |
  |--------|-------|---------------------------------------------------------|
  |  +16   | ?     | The tokenized contents of line.                         |
  \--------------------------------------------------------------------------/

  Notes:

    To determine, whether this is the line loaded from source, or generated by
    macroinstruction, you need to check the highest bit of the second double
    word.

    The contents of line is no longer a text, which it was in source file,
    but a sequence of tokens, ended with a zero byte.
    Any chain of characters that aren't special ones, separated from other
    similar chains with spaces or some other special characters, is converted
    into symbol token. The first byte of this element has the value of 1Ah,
    the second byte is the count of characters, followed by this amount of
    bytes, which build the symbol.
    Some characters have a special meaning, and cannot occur inside the
    symbol, they split the symbols and are converted into separate tokens.
    For example, if source contains this line of text:

      mov ax,4

    preprocessor converts it into the chain of bytes, shown here with their
    hexadecimal values (characters corresponding to some of those values are
    placed below the hexadecimal codes):

      1A 03 6D 6F 76 1A 02 61 78 2C 1A 01 34 00
            m  o  v        a  x  ,        4

    The third type of token that can be found in preprocessed line is the
    quoted text. This element is created from chain of any bytes other than
    line breaks that are placed between the single or double quotes in the
    original text. First byte of such element is always 22h, it is followed
    by double word which specifies the number of bytes that follow, and the
    value of quoted text comes next. For example, this line from source:

      mov eax,'ABCD'

    is converted into (the notation used is the same as in previous sample):

      1A 03 6D 6F 76 1A 03 65 61 78 2C 22 04 00 00 00 41 42 43 44 00
            m  o  v        e  a  x  ,                 A  B  C  D

    This data defines two symbols followed by symbol character, quoted text
    and zero byte that marks end of line.
    There is also a special case of symbol token with first byte having the
    value 3Bh instead of 1Ah, such symbol means that all the line elements
    that follow, including this one, have already been interpreted by
    preprocessor and are ignored by assembler.


   Table 4  Row of the assembly dump
  /-------------------------------------------------------------------------\
  | Offset | Size  | Description                                            |
  |========|=======|========================================================|
  |   +0   | dword | Offset in output file.                                 |
  |--------|-------|--------------------------------------------------------|
  |   +4   | dword | Offset of line in preprocessed source.                 |
  |--------|-------|--------------------------------------------------------|
  |   +8   | qword | Value of $ address.                                    |
  |--------|-------|--------------------------------------------------------|
  |  +16   | dword | Extended SIB for the $ address, the first two bytes    |
  |        |       | are register codes and the second two bytes are        |
  |        |       | corresponding scales.                                  |
  |--------|-------|--------------------------------------------------------|
  |  +20   | dword | If the $ address is relocatable, this field contains   |
  |        |       | information about section or external symbol, to which |
  |        |       | it is relative - otherwise this field is zero.         |
  |        |       | When the highest bit is cleared, the address is        |
  |        |       | relative to a section, and the bits 0-30 contain       |
  |        |       | the index (starting from 1) in the table of sections.  |
  |        |       | When the highest bit is set, the address is relative   |
  |        |       | to an external symbol, and the bits 0-30 contain the   |
  |        |       | the offset of the name of this symbol in the strings   |
  |        |       | table.                                                 |
  |--------|-------|--------------------------------------------------------|
  |  +24   | byte  | Type of $ address value (as in table 2.2).             |
  |--------|-------|--------------------------------------------------------|
  |  +25   | byte  | Type of code - possible values are 16, 32, and 64.     |
  |--------|-------|--------------------------------------------------------|
  |  +26   | byte  | If the bit 0 is set, then at this point the assembly   |
  |        |       | was taking place inside the virtual block, and the     |
  |        |       | offset in output file has no meaning here.             |
  |        |       | If the bit 1 is set, the line was assembled at the     |
  |        |       | point, which was not included in the output file for   |
  |        |       | some other reasons (like inside the reserved data at   |
  |        |       | the end of section).                                   |
  |--------|-------|--------------------------------------------------------|
  |  +27   | byte  | The higher bits of value of $ address.                 |
  \-------------------------------------------------------------------------/


  Notes:

    Each row of the assembly dump informs, that the given line of preprocessed
    source was assembled at the specified address (defined by its type, value
    and the extended SIB) and at the specified position in output file.

```

`plugins/FasLoader/FasLoader.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 * Evan Teran evan.teran@gmail.com
                          * darkprof dark_prof@mail.ru

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "FasLoader.hpp"
#include "IDebugger.h"
#include "IProcess.h"
#include "ISymbolManager.h"
#include "Symbol.h"
#include "edb.h"

#include <QMenu>
#include <QSettings>

namespace FasLoaderPlugin {

/**
 * @brief FasLoader::FasLoader
 * @param parent
 */
FasLoader::FasLoader(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief FasLoader::menu
 * @param parent
 * @return
 */
QMenu *FasLoader::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("FasLoader"), parent);
		menu_->addAction(tr("&Load *.fas symbols"), this, SLOT(load()));
	}

	return menu_;
}

/**
 * @brief FasLoader::load
 */
void FasLoader::load() {
	if (edb::v1::debugger_core) {
		if (IProcess *process = edb::v1::debugger_core->process()) {
			const QString fileName = process->executable();
			QString fasName        = fileName;
			fasName.append(".fas");

			Fas::Core fasCore;
			fasCore.load(fasName.toUtf8().constData());

			auto pluginSymbols = fasCore.getSymbols();
			for (auto pluginSymbol : pluginSymbols) {

				auto symbol = std::make_shared<Symbol>();

				symbol->file    = fileName;
				symbol->address = pluginSymbol.value;
				symbol->name    = QString::fromStdString(pluginSymbol.name);
				symbol->size    = pluginSymbol.size;
				if (pluginSymbol.size > 0) {
					symbol->type = 'd';
				}

				edb::v1::symbol_manager().addSymbol(symbol);
			}
		}
	}
}

}

```

`plugins/FasLoader/FasLoader.hpp`:

```hpp
#pragma once

#include "Fas/Core.hpp"
#include "IPlugin.h"

class QMenu;

namespace FasLoaderPlugin {

class FasLoader : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "darkprof")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit FasLoader(QObject *parent = nullptr);
	~FasLoader() override = default;

public:
	QMenu *menu(QWidget *parent = nullptr) override;

private Q_SLOTS:
	void load();

private:
	QMenu *menu_ = nullptr;
};

}

```

`plugins/FunctionFinder/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "FunctionFinder")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	DialogFunctions.cpp
	DialogFunctions.h
	DialogFunctions.ui
	DialogResults.cpp
	DialogResults.h
	DialogResults.ui
	FunctionFinder.cpp
	FunctionFinder.h
	ResultsModel.h
	ResultsModel.cpp
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/FunctionFinder/DialogFunctions.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogFunctions.h"
#include "DialogResults.h"
#include "IAnalyzer.h"
#include "MemoryRegions.h"
#include "edb.h"

#include <QDialog>
#include <QHeaderView>
#include <QMenu>
#include <QMessageBox>
#include <QPushButton>
#include <QSortFilterProxyModel>

namespace FunctionFinderPlugin {

/**
 * @brief DialogFunctions::DialogFunctions
 * @param parent
 * @param f
 */
DialogFunctions::DialogFunctions(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
	ui.tableView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

	filterModel_ = new QSortFilterProxyModel(this);
	connect(ui.txtSearch, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);

	buttonFind_ = new QPushButton(QIcon::fromTheme("edit-find"), tr("Find"));
	connect(buttonFind_, &QPushButton::clicked, this, [this]() {
		buttonFind_->setEnabled(false);
		ui.progressBar->setValue(0);
		doFind();
		ui.progressBar->setValue(100);
		buttonFind_->setEnabled(true);
	});

	ui.buttonBox->addButton(buttonFind_, QDialogButtonBox::ActionRole);
}

/**
 * @brief DialogFunctions::showEvent
 */
void DialogFunctions::showEvent(QShowEvent *) {
	filterModel_->setFilterKeyColumn(3);
	filterModel_->setSourceModel(&edb::v1::memory_regions());
	ui.tableView->setModel(filterModel_);

	ui.progressBar->setValue(0);
}

/**
 * @brief DialogFunctions::doFind
 */
void DialogFunctions::doFind() {

	if (IAnalyzer *const analyzer = edb::v1::analyzer()) {
		const QItemSelectionModel *const selModel = ui.tableView->selectionModel();
		const QModelIndexList sel                 = selModel->selectedRows();

		if (sel.size() == 0) {
			QMessageBox::critical(this, tr("No Region Selected"), tr("You must select a region which is to be scanned for functions."));
			return;
		}

		auto analyzer_object = dynamic_cast<QObject *>(analyzer);
		if (analyzer_object) {
			connect(analyzer_object, SIGNAL(updateProgress(int)), ui.progressBar, SLOT(setValue(int)));
		}

		auto resultsDialog = new DialogResults(this);

		for (const QModelIndex &selected_item : sel) {

			const QModelIndex index = filterModel_->mapToSource(selected_item);

			// do the search for this region!
			if (auto region = *reinterpret_cast<const std::shared_ptr<IRegion> *>(index.internalPointer())) {

				analyzer->analyze(region);

				const IAnalyzer::FunctionMap &results = analyzer->functions(region);
				for (const Function &function : results) {
					resultsDialog->addResult(function);
				}
			}
		}

		if (resultsDialog->resultCount() == 0) {
			QMessageBox::information(this, tr("No Results"), tr("No Functions Found!"));
			delete resultsDialog;
		} else {
			resultsDialog->show();
		}

		if (analyzer_object) {
			disconnect(analyzer_object, SIGNAL(updateProgress(int)), ui.progressBar, SLOT(setValue(int)));
		}
	}
}

}

```

`plugins/FunctionFinder/DialogFunctions.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_FUNCTIONS_H_20061101_
#define DIALOG_FUNCTIONS_H_20061101_

#include "Types.h"
#include "ui_DialogFunctions.h"
#include <QDialog>

class QSortFilterProxyModel;

namespace FunctionFinderPlugin {

class DialogFunctions : public QDialog {
	Q_OBJECT

public:
	explicit DialogFunctions(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogFunctions() override = default;

private:
	void showEvent(QShowEvent *event) override;

private:
	void doFind();

private:
	Ui::DialogFunctions ui;
	QSortFilterProxyModel *filterModel_ = nullptr;
	QPushButton *buttonFind_            = nullptr;
};

}

#endif

```

`plugins/FunctionFinder/DialogFunctions.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>FunctionFinderPlugin::DialogFunctions</class>
 <widget class="QDialog" name="FunctionFinderPlugin::DialogFunctions">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>640</width>
    <height>400</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Function Finder</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="lblRegions">
     <property name="text">
      <string>Regions To Search:</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLineEdit" name="txtSearch">
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QTableView" name="tableView">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBar">
     <property name="value">
      <number>0</number>
     </property>
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>tableView</tabstop>
  <tabstop>txtSearch</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>FunctionFinderPlugin::DialogFunctions</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>161</x>
     <y>353</y>
    </hint>
    <hint type="destinationlabel">
     <x>113</x>
     <y>338</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>FunctionFinderPlugin::DialogFunctions</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>346</x>
     <y>358</y>
    </hint>
    <hint type="destinationlabel">
     <x>361</x>
     <y>340</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/FunctionFinder/DialogResults.cpp`:

```cpp
/*
Copyright (C) 2006 - 2019 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogResults.h"
#include "IAnalyzer.h"
#include "ISymbolManager.h"
#include "MemoryRegions.h"
#include "ResultsModel.h"
#include "edb.h"
#ifdef ENABLE_GRAPH
#include "GraphEdge.h"
#include "GraphNode.h"
#include "GraphWidget.h"
#endif
#include <QDialog>
#include <QHeaderView>
#include <QMenu>
#include <QMessageBox>
#include <QPushButton>
#include <QSortFilterProxyModel>

namespace FunctionFinderPlugin {

/**
 * @brief DialogResults::DialogResults
 * @param parent
 * @param f
 */
DialogResults::DialogResults(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
	ui.tableView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

	resultsModel_ = new ResultsModel(this);

	filterModel_ = new QSortFilterProxyModel(this);
	filterModel_->setFilterKeyColumn(5);
	filterModel_->setSourceModel(resultsModel_);
	connect(ui.textFilter, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);
	ui.tableView->setModel(filterModel_);

	buttonGraph_ = new QPushButton(QIcon::fromTheme("distribute-graph"), tr("Graph Selected Function"));
#if defined(ENABLE_GRAPH)
	connect(buttonGraph_, &QPushButton::clicked, this, [this]() {
		// this code is not very pretty...
		// but it works!
		qDebug("[FunctionFinder] Constructing Graph...");

		const QItemSelectionModel *const selModel = ui.tableView->selectionModel();
		const QModelIndexList sel                 = selModel->selectedRows();

		if (sel.size() == 1) {
			const QModelIndex index = filterModel_->mapToSource(sel[0]);

			if (auto item = static_cast<ResultsModel::Result *>(index.internalPointer())) {
				const edb::address_t addr = item->startAddress;

				if (IAnalyzer *const analyzer = edb::v1::analyzer()) {
					const IAnalyzer::FunctionMap &functions = analyzer->functions();

					auto it = functions.find(addr);
					if (it != functions.end()) {
						Function f = *it;

						auto graph = new GraphWidget(nullptr);
						graph->setAttribute(Qt::WA_DeleteOnClose);

						QMap<edb::address_t, GraphNode *> nodes;

						// first create all of the nodes
						for (const auto &pair : f) {
							const BasicBlock &bb = pair.second;
							auto node            = new GraphNode(graph, bb.toString(), Qt::lightGray);
							nodes.insert(bb.firstAddress(), node);
						}

						// then connect them!
						for (const auto &pair : f) {
							const BasicBlock &bb = pair.second;

							if (!bb.empty()) {

								auto term  = bb.back();
								auto &inst = *term;

								if (is_unconditional_jump(inst)) {

									Q_ASSERT(inst.operandCount() >= 1);
									const auto op = inst[0];

									// TODO: we need some heuristic for detecting when this is
									//       a call/ret -> jmp optimization
									if (is_immediate(op)) {
										const edb::address_t ea = op->imm;

										auto from = nodes.find(bb.firstAddress());
										auto to   = nodes.find(ea);
										if (to != nodes.end() && from != nodes.end()) {
											new GraphEdge(from.value(), to.value(), Qt::black);
										}
									}
								} else if (is_conditional_jump(inst)) {

									Q_ASSERT(inst.operandCount() == 1);
									const auto op = inst[0];

									if (is_immediate(op)) {

										auto from = nodes.find(bb.firstAddress());

										auto to_taken = nodes.find(op->imm);
										if (to_taken != nodes.end() && from != nodes.end()) {
											new GraphEdge(from.value(), to_taken.value(), Qt::green);
										}

										auto to_skipped = nodes.find(inst.rva() + inst.byteSize());
										if (to_taken != nodes.end() && from != nodes.end()) {
											new GraphEdge(from.value(), to_skipped.value(), Qt::red);
										}
									}
								} else if (is_terminator(inst)) {
								}
							}
						}

						graph->layout();
						graph->show();
					}
				}
			}
		}
	});
#endif

	ui.buttonBox->addButton(buttonGraph_, QDialogButtonBox::ActionRole);

#ifdef ENABLE_GRAPH
	buttonGraph_->setEnabled(true);
#else
	buttonGraph_->setEnabled(false);
#endif
}

/**
 * @brief DialogResults::on_tableView_doubleClicked
 * @param index
 */
void DialogResults::on_tableView_doubleClicked(const QModelIndex &index) {

	if (index.isValid()) {
		const QModelIndex realIndex = filterModel_->mapToSource(index);
		if (auto item = static_cast<ResultsModel::Result *>(realIndex.internalPointer())) {
			edb::v1::jump_to_address(item->startAddress);
		}
	}
}

/**
 * @brief DialogResults::addResult
 * @param function
 */
void DialogResults::addResult(const Function &function) {

	ResultsModel::Result result;

	// entry point
	result.startAddress = function.entryAddress();

	// upper bound of the function
	result.endAddress = function.endAddress();
	result.size       = function.endAddress() - function.entryAddress() + 1;

	// reference count
	result.score = function.referenceCount();

	// type
	result.type = function.type();

	QString symbol_name = edb::v1::symbol_manager().findAddressName(function.entryAddress());
	if (!symbol_name.isEmpty()) {
		result.symbol = symbol_name;
	}

	resultsModel_->addResult(result);
}

/**
 * @brief DialogResults::resultCount
 * @return
 */
int DialogResults::resultCount() const {
	return resultsModel_->rowCount();
}

}

```

`plugins/FunctionFinder/DialogResults.h`:

```h
/*
Copyright (C) 2006 - 2019 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_RESULTS_H_20190403_
#define DIALOG_RESULTS_H_20190403_

#include "Types.h"
#include "ui_DialogResults.h"
#include <QDialog>

class QSortFilterProxyModel;
class IAnalyzer;
class Function;

namespace FunctionFinderPlugin {

class ResultsModel;

class DialogResults : public QDialog {
	Q_OBJECT

public:
	explicit DialogResults(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogResults() override = default;

public:
	void addResult(const Function &function);
	int resultCount() const;

public Q_SLOTS:
	void on_tableView_doubleClicked(const QModelIndex &index);

private:
	Ui::DialogResults ui;
	QSortFilterProxyModel *filterModel_ = nullptr;
	ResultsModel *resultsModel_         = nullptr;
	QPushButton *buttonGraph_           = nullptr;
};

}

#endif

```

`plugins/FunctionFinder/DialogResults.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FunctionFinderPlugin::DialogResults</class>
 <widget class="QDialog" name="FunctionFinderPlugin::DialogResults">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>850</width>
    <height>450</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Functions Found</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLineEdit" name="textFilter">
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QTableView" name="tableView">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="contextMenuPolicy">
      <enum>Qt::CustomContextMenu</enum>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>FunctionFinderPlugin::DialogResults</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>791</x>
     <y>422</y>
    </hint>
    <hint type="destinationlabel">
     <x>788</x>
     <y>406</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>FunctionFinderPlugin::DialogResults</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>810</x>
     <y>423</y>
    </hint>
    <hint type="destinationlabel">
     <x>826</x>
     <y>407</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/FunctionFinder/FunctionFinder.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "FunctionFinder.h"
#include "DialogFunctions.h"
#include "edb.h"
#include <QMenu>

namespace FunctionFinderPlugin {

/**
 * @brief FunctionFinder::FunctionFinder
 * @param parent
 */
FunctionFinder::FunctionFinder(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief FunctionFinder::~FunctionFinder
 */
FunctionFinder::~FunctionFinder() {
	delete dialog_;
}

/**
 * @brief FunctionFinder::menu
 * @param parent
 * @return
 */
QMenu *FunctionFinder::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("FunctionFinder"), parent);
		menu_->addAction(tr("&Function Finder"), this, SLOT(showMenu()), QKeySequence(tr("Ctrl+Shift+F")));
	}

	return menu_;
}

/**
 * @brief FunctionFinder::showMenu
 */
void FunctionFinder::showMenu() {

	if (!dialog_) {
		dialog_ = new DialogFunctions(edb::v1::debugger_ui);
	}

	dialog_->show();
}

}

```

`plugins/FunctionFinder/FunctionFinder.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef FUNCTION_FINDER_H_20060430_
#define FUNCTION_FINDER_H_20060430_

#include "IPlugin.h"

class QMenu;
class QDialog;

namespace FunctionFinderPlugin {

class FunctionFinder : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit FunctionFinder(QObject *parent = nullptr);
	~FunctionFinder() override;

public:
	QMenu *menu(QWidget *parent = nullptr) override;

public Q_SLOTS:
	void showMenu();

private:
	QMenu *menu_              = nullptr;
	QPointer<QDialog> dialog_ = nullptr;
};

}

#endif

```

`plugins/FunctionFinder/ResultsModel.cpp`:

```cpp
/*
Copyright (C) 2006 - 2019 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ResultsModel.h"
#include "edb.h"
#include <algorithm>

namespace FunctionFinderPlugin {

/**
 * @brief ResultsModel::ResultsModel
 * @param parent
 */
ResultsModel::ResultsModel(QObject *parent)
	: QAbstractItemModel(parent) {
}

/**
 * @brief ResultsModel::headerData
 * @param section
 * @param orientation
 * @param role
 * @return
 */
QVariant ResultsModel::headerData(int section, Qt::Orientation orientation, int role) const {

	if (role == Qt::DisplayRole && orientation == Qt::Horizontal) {
		switch (section) {
		case 0:
			return tr("Start Address");
		case 1:
			return tr("End Address");
		case 2:
			return tr("Size");
		case 3:
			return tr("Score");
		case 4:
			return tr("Type");
		case 5:
			return tr("Symbol");
		}
	}

	return QVariant();
}

/**
 * @brief ResultsModel::data
 * @param index
 * @param role
 * @return
 */
QVariant ResultsModel::data(const QModelIndex &index, int role) const {

	if (!index.isValid()) {
		return QVariant();
	}

	const Result &result = results_[index.row()];

	if (role == Qt::DisplayRole) {
		switch (index.column()) {
		case 0:
			return edb::v1::format_pointer(result.startAddress);
		case 1:
			return edb::v1::format_pointer(result.endAddress);
		case 2:
			return static_cast<quint64>(result.size);
		case 3:
			return result.score;
		case 4:
			return result.type == Function::Thunk ? tr("Thunk") : tr("Standard Function");
		case 5:
			return result.symbol;
		default:
			return QVariant();
		}
	}

	return QVariant();
}

/**
 * @brief ResultsModel::addResult
 * @param r
 */
void ResultsModel::addResult(const Result &r) {
	beginInsertRows(QModelIndex(), rowCount(), rowCount());
	results_.push_back(r);
	endInsertRows();
}

/**
 * @brief ResultsModel::index
 * @param row
 * @param column
 * @param parent
 * @return
 */
QModelIndex ResultsModel::index(int row, int column, const QModelIndex &parent) const {

	Q_UNUSED(parent)

	if (row >= results_.size()) {
		return QModelIndex();
	}

	if (column >= 6) {
		return QModelIndex();
	}

	if (row >= 0) {
		return createIndex(row, column, const_cast<Result *>(&results_[row]));
	} else {
		return createIndex(row, column);
	}
}

/**
 * @brief ResultsModel::parent
 * @param index
 * @return
 */
QModelIndex ResultsModel::parent(const QModelIndex &index) const {
	Q_UNUSED(index)
	return QModelIndex();
}

/**
 * @brief ResultsModel::rowCount
 * @param parent
 * @return
 */
int ResultsModel::rowCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return results_.size();
}

/**
 * @brief ResultsModel::columnCount
 * @param parent
 * @return
 */
int ResultsModel::columnCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return 6;
}

/**
 * @brief ResultsModel::sort
 * @param column
 * @param order
 */
void ResultsModel::sort(int column, Qt::SortOrder order) {

	if (order == Qt::AscendingOrder) {
		switch (column) {
		case 0:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.startAddress < s2.startAddress; });
			break;
		case 1:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.endAddress < s2.endAddress; });
			break;
		case 2:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.size < s2.size; });
			break;
		case 3:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.score < s2.score; });
			break;
		case 4:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.type < s2.type; });
			break;
		case 5:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.symbol < s2.symbol; });
			break;
		}
	} else {
		switch (column) {
		case 0:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.startAddress > s2.startAddress; });
			break;
		case 1:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.endAddress > s2.endAddress; });
			break;
		case 2:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.size > s2.size; });
			break;
		case 3:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.score > s2.score; });
			break;
		case 4:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.type > s2.type; });
			break;
		case 5:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.symbol > s2.symbol; });
			break;
		}
	}

	Q_EMIT dataChanged(createIndex(0, 0, nullptr), createIndex(-1, -1, nullptr));
}

}

```

`plugins/FunctionFinder/ResultsModel.h`:

```h
/*
Copyright (C) 2006 - 2019 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef RESULTS_MODEL_H_20070419_
#define RESULTS_MODEL_H_20070419_

#include "Function.h"
#include "Types.h"
#include <QAbstractItemModel>
#include <QVector>

namespace FunctionFinderPlugin {

class ResultsModel : public QAbstractItemModel {
	Q_OBJECT
public:
	struct Result {
		edb::address_t startAddress = 0;
		edb::address_t endAddress   = 0;
		size_t size                 = 0;
		int score                   = 0;
		Function::Type type         = Function::Type::Standard;
		QString symbol;
	};

public:
	explicit ResultsModel(QObject *parent = nullptr);

public:
	QVariant data(const QModelIndex &index, int role) const override;
	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex &index) const override;
	int rowCount(const QModelIndex &parent = QModelIndex()) const override;
	int columnCount(const QModelIndex &parent = QModelIndex()) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
	void sort(int column, Qt::SortOrder order = Qt::AscendingOrder) override;

public:
	void addResult(const Result &r);

public:
	const QVector<Result> &results() const { return results_; }

private:
	QVector<Result> results_;
};

}

#endif

```

`plugins/HardwareBreakpoints/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "HardwareBreakpoints")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	DialogHwBreakpoints.cpp
	DialogHwBreakpoints.h
	DialogHwBreakpoints.ui
	HardwareBreakpoints.cpp
	HardwareBreakpoints.h
	libHardwareBreakpoints.cpp
	libHardwareBreakpoints.h
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/HardwareBreakpoints/DialogHwBreakpoints.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogHwBreakpoints.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IThread.h"
#include "State.h"
#include "edb.h"
#include "libHardwareBreakpoints.h"

namespace HardwareBreakpointsPlugin {

/**
 * @brief DialogHwBreakpoints::DialogHwBreakpoints
 * @param parent
 * @param f
 */
DialogHwBreakpoints::DialogHwBreakpoints(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);

	connect(ui.cmbType1, SIGNAL(currentIndexChanged(int)), this, SLOT(type1IndexChanged(int)));
	connect(ui.cmbType2, SIGNAL(currentIndexChanged(int)), this, SLOT(type2IndexChanged(int)));
	connect(ui.cmbType3, SIGNAL(currentIndexChanged(int)), this, SLOT(type3IndexChanged(int)));
	connect(ui.cmbType4, SIGNAL(currentIndexChanged(int)), this, SLOT(type4IndexChanged(int)));
}

/**
 * @brief DialogHwBreakpoints::type1IndexChanged
 * @param index
 */
void DialogHwBreakpoints::type1IndexChanged(int index) {
	ui.cmbSize1->setEnabled(index != 0);
}

/**
 * @brief DialogHwBreakpoints::type2IndexChanged
 * @param index
 */
void DialogHwBreakpoints::type2IndexChanged(int index) {
	ui.cmbSize2->setEnabled(index != 0);
}

/**
 * @brief DialogHwBreakpoints::type3IndexChanged
 * @param index
 */
void DialogHwBreakpoints::type3IndexChanged(int index) {
	ui.cmbSize3->setEnabled(index != 0);
}

/**
 * @brief DialogHwBreakpoints::type4IndexChanged
 * @param index
 */
void DialogHwBreakpoints::type4IndexChanged(int index) {
	ui.cmbSize4->setEnabled(index != 0);
}

/**
 * @brief DialogHwBreakpoints::showEvent
 * @param event
 */
void DialogHwBreakpoints::showEvent(QShowEvent *event) {
	Q_UNUSED(event)

	if (IProcess *process = edb::v1::debugger_core->process()) {

		State state;
		process->currentThread()->getState(&state);

		const BreakpointState bp_state1 = breakpoint_state(&state, Register1);
		const BreakpointState bp_state2 = breakpoint_state(&state, Register2);
		const BreakpointState bp_state3 = breakpoint_state(&state, Register3);
		const BreakpointState bp_state4 = breakpoint_state(&state, Register4);

		ui.chkBP1->setChecked(bp_state1.enabled);
		ui.chkBP2->setChecked(bp_state2.enabled);
		ui.chkBP3->setChecked(bp_state3.enabled);
		ui.chkBP4->setChecked(bp_state4.enabled);

		if (bp_state1.enabled) {
			ui.txtBP1->setText(bp_state1.addr.toPointerString());
			ui.cmbSize1->setCurrentIndex(bp_state1.size);
			ui.cmbType1->setCurrentIndex(bp_state1.type);
		}

		if (bp_state2.enabled) {
			ui.txtBP2->setText(bp_state2.addr.toPointerString());
			ui.cmbSize2->setCurrentIndex(bp_state2.size);
			ui.cmbType2->setCurrentIndex(bp_state2.type);
		}

		if (bp_state3.enabled) {
			ui.txtBP3->setText(bp_state3.addr.toPointerString());
			ui.cmbSize3->setCurrentIndex(bp_state3.size);
			ui.cmbType3->setCurrentIndex(bp_state3.type);
		}

		if (bp_state4.enabled) {
			ui.txtBP4->setText(bp_state4.addr.toPointerString());
			ui.cmbSize4->setCurrentIndex(bp_state4.size);
			ui.cmbType4->setCurrentIndex(bp_state4.type);
		}
	}
}

}

```

`plugins/HardwareBreakpoints/DialogHwBreakpoints.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_HW_BREAKPOINTS_H_20080228_
#define DIALOG_HW_BREAKPOINTS_H_20080228_

#include "ui_DialogHwBreakpoints.h"
#include <QDialog>

namespace HardwareBreakpointsPlugin {

class DialogHwBreakpoints : public QDialog {
	Q_OBJECT

private:
	friend class HardwareBreakpoints;

public:
	explicit DialogHwBreakpoints(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogHwBreakpoints() override = default;

private:
	void showEvent(QShowEvent *event) override;

private Q_SLOTS:
	void type1IndexChanged(int index);
	void type2IndexChanged(int index);
	void type3IndexChanged(int index);
	void type4IndexChanged(int index);

private:
	Ui::DialogHwBreakpoints ui;
};

}

#endif

```

`plugins/HardwareBreakpoints/DialogHwBreakpoints.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>HardwareBreakpointsPlugin::DialogHwBreakpoints</class>
 <widget class="QDialog" name="HardwareBreakpointsPlugin::DialogHwBreakpoints">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>461</width>
    <height>222</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Hardware Breakpoints</string>
  </property>
  <layout class="QGridLayout">
   <item row="0" column="1">
    <widget class="QLabel" name="label_2">
     <property name="text">
      <string>Address</string>
     </property>
    </widget>
   </item>
   <item row="0" column="2">
    <widget class="QLabel" name="label_4">
     <property name="text">
      <string>Type</string>
     </property>
    </widget>
   </item>
   <item row="0" column="3">
    <widget class="QLabel" name="label_3">
     <property name="text">
      <string>Size</string>
     </property>
    </widget>
   </item>
   <item row="1" column="0">
    <widget class="QLabel" name="label">
     <property name="text">
      <string>BP 1</string>
     </property>
    </widget>
   </item>
   <item row="1" column="1">
    <widget class="QLineEdit" name="txtBP1">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
    </widget>
   </item>
   <item row="1" column="2">
    <widget class="QComboBox" name="cmbType1">
     <item>
      <property name="text">
       <string>Execute</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>Write</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>Read/Write</string>
      </property>
     </item>
    </widget>
   </item>
   <item row="1" column="3">
    <widget class="QComboBox" name="cmbSize1">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <item>
      <property name="text">
       <string>1 Byte</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>2 Bytes</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>4 Bytes</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>8 Bytes</string>
      </property>
     </item>
    </widget>
   </item>
   <item row="1" column="4">
    <widget class="QCheckBox" name="chkBP1">
     <property name="text">
      <string>Enabled</string>
     </property>
    </widget>
   </item>
   <item row="2" column="0">
    <widget class="QLabel" name="label_5">
     <property name="text">
      <string>BP 2</string>
     </property>
    </widget>
   </item>
   <item row="2" column="1">
    <widget class="QLineEdit" name="txtBP2">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
    </widget>
   </item>
   <item row="2" column="2">
    <widget class="QComboBox" name="cmbType2">
     <item>
      <property name="text">
       <string>Execute</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>Write</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>Read/Write</string>
      </property>
     </item>
    </widget>
   </item>
   <item row="2" column="3">
    <widget class="QComboBox" name="cmbSize2">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <item>
      <property name="text">
       <string>1 Byte</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>2 Bytes</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>4 Bytes</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>8 Bytes</string>
      </property>
     </item>
    </widget>
   </item>
   <item row="2" column="4">
    <widget class="QCheckBox" name="chkBP2">
     <property name="text">
      <string>Enabled</string>
     </property>
    </widget>
   </item>
   <item row="3" column="0">
    <widget class="QLabel" name="label_6">
     <property name="text">
      <string>BP 3</string>
     </property>
    </widget>
   </item>
   <item row="3" column="1">
    <widget class="QLineEdit" name="txtBP3">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
    </widget>
   </item>
   <item row="3" column="2">
    <widget class="QComboBox" name="cmbType3">
     <item>
      <property name="text">
       <string>Execute</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>Write</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>Read/Write</string>
      </property>
     </item>
    </widget>
   </item>
   <item row="3" column="3">
    <widget class="QComboBox" name="cmbSize3">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <item>
      <property name="text">
       <string>1 Byte</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>2 Bytes</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>4 Bytes</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>8 Bytes</string>
      </property>
     </item>
    </widget>
   </item>
   <item row="3" column="4">
    <widget class="QCheckBox" name="chkBP3">
     <property name="text">
      <string>Enabled</string>
     </property>
    </widget>
   </item>
   <item row="4" column="0">
    <widget class="QLabel" name="label_7">
     <property name="text">
      <string>BP 4</string>
     </property>
    </widget>
   </item>
   <item row="4" column="1">
    <widget class="QLineEdit" name="txtBP4">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
    </widget>
   </item>
   <item row="4" column="2">
    <widget class="QComboBox" name="cmbType4">
     <item>
      <property name="text">
       <string>Execute</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>Write</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>Read/Write</string>
      </property>
     </item>
    </widget>
   </item>
   <item row="4" column="3">
    <widget class="QComboBox" name="cmbSize4">
     <property name="enabled">
      <bool>false</bool>
     </property>
     <item>
      <property name="text">
       <string>1 Byte</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>2 Bytes</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>4 Bytes</string>
      </property>
     </item>
     <item>
      <property name="text">
       <string>8 Bytes</string>
      </property>
     </item>
    </widget>
   </item>
   <item row="4" column="4">
    <widget class="QCheckBox" name="chkBP4">
     <property name="text">
      <string>Enabled</string>
     </property>
    </widget>
   </item>
   <item row="5" column="1">
    <spacer>
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>40</height>
      </size>
     </property>
    </spacer>
   </item>
   <item row="6" column="0" colspan="5">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>HardwareBreakpointsPlugin::DialogHwBreakpoints</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>262</x>
     <y>199</y>
    </hint>
    <hint type="destinationlabel">
     <x>89</x>
     <y>191</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>HardwareBreakpointsPlugin::DialogHwBreakpoints</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>401</x>
     <y>201</y>
    </hint>
    <hint type="destinationlabel">
     <x>18</x>
     <y>189</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/HardwareBreakpoints/HardwareBreakpoints.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "HardwareBreakpoints.h"
#include "DialogHwBreakpoints.h"
#include "IDebugEvent.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IThread.h"
#include "State.h"
#include "edb.h"

#include <QDialog>
#include <QMenu>
#include <QMessageBox>
#include <QtDebug>

#include "ui_DialogHwBreakpoints.h"

// TODO: at the moment, nearly this entire file is x86/x86-64 specific
//       we need to figure out a proper way to support (if at all) non
//       x86 arches

#if !(defined(EDB_X86_64) || defined(EDB_X86))
#error "Unsupported Platform"
#endif

namespace HardwareBreakpointsPlugin {

/**
 * @brief HardwareBreakpoints::HardwareBreakpoints
 * @param parent
 */
HardwareBreakpoints::HardwareBreakpoints(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief HardwareBreakpoints::private_init
 */
void HardwareBreakpoints::privateInit() {

	auto dialog = new DialogHwBreakpoints(edb::v1::debugger_ui);
	dialog_     = dialog;

	// indexed access to members for simplicity later
	enabled_[Register1] = dialog->ui.chkBP1;
	enabled_[Register2] = dialog->ui.chkBP2;
	enabled_[Register3] = dialog->ui.chkBP3;
	enabled_[Register4] = dialog->ui.chkBP4;

	types_[Register1] = dialog->ui.cmbType1;
	types_[Register2] = dialog->ui.cmbType2;
	types_[Register3] = dialog->ui.cmbType3;
	types_[Register4] = dialog->ui.cmbType4;

	sizes_[Register1] = dialog->ui.cmbSize1;
	sizes_[Register2] = dialog->ui.cmbSize2;
	sizes_[Register3] = dialog->ui.cmbSize3;
	sizes_[Register4] = dialog->ui.cmbSize4;

	addresses_[Register1] = dialog->ui.txtBP1;
	addresses_[Register2] = dialog->ui.txtBP2;
	addresses_[Register3] = dialog->ui.txtBP3;
	addresses_[Register4] = dialog->ui.txtBP4;

	edb::v1::add_debug_event_handler(this);
}

/**
 * @brief HardwareBreakpoints::privateFini
 */
void HardwareBreakpoints::privateFini() {
	edb::v1::remove_debug_event_handler(this);
}

/**
 * @brief HardwareBreakpoints::menu
 * @param parent
 * @return
 */
QMenu *HardwareBreakpoints::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("Hardware BreakpointManager"), parent);
		menu_->addAction(tr("&Hardware Breakpoints"), this, SLOT(showMenu()), QKeySequence(tr("Ctrl+Shift+H")));
	}

	return menu_;
}

/**
 * @brief HardwareBreakpoints::setupBreakpoints
 */
void HardwareBreakpoints::setupBreakpoints() {

	if (IProcess *process = edb::v1::debugger_core->process()) {

		if (!process->isPaused()) {
			QMessageBox::warning(
				nullptr,
				tr("Process Not Paused"),
				tr("Unable to update hardware breakpoints because the process does not appear to be currently paused. Please suspend the process."));
			return;
		}

		const bool enabled =
			enabled_[Register1]->isChecked() ||
			enabled_[Register2]->isChecked() ||
			enabled_[Register3]->isChecked() ||
			enabled_[Register4]->isChecked();

		if (enabled) {

			edb::address_t addr[RegisterCount];
			bool ok[RegisterCount];

			// evaluate all the expressions
			for (int i = 0; i < RegisterCount; ++i) {
				ok[i] = enabled_[i]->isChecked() && edb::v1::eval_expression(addresses_[i]->text(), &addr[i]);
			}

			if (!ok[Register1] && !ok[Register2] && !ok[Register3] && !ok[Register4]) {
				QMessageBox::critical(
					nullptr,
					tr("Address Error"),
					tr("An address expression provided does not appear to be valid"));
				return;
			}

			for (int i = 0; i < RegisterCount; ++i) {
				if (ok[i]) {

					const BreakpointStatus status = validate_breakpoint({enabled_[i]->isChecked(),
																		 addr[i],
																		 types_[i]->currentIndex(),
																		 sizes_[i]->currentIndex()});

					switch (status) {
					case AlignmentError:
						QMessageBox::critical(
							nullptr,
							tr("Address Alignment Error"),
							tr("Hardware read/write breakpoint address must be aligned to breakpoint size."));
						return;
					case SizeError:
						QMessageBox::critical(
							nullptr,
							tr("BP Size Error"),
							tr("Hardware read/write breakpoints cannot be 8-bytes in a 32-bit debuggee."));
						return;
					case Valid:
						break;
					}
				}
			}

			for (std::shared_ptr<IThread> &thread : process->threads()) {
				State state;
				thread->getState(&state);

				for (int i = 0; i < RegisterCount; ++i) {
					if (ok[i]) {
						set_breakpoint_state(
							&state,
							i,
							{enabled_[i]->isChecked(),
							 addr[i],
							 types_[i]->currentIndex(),
							 sizes_[i]->currentIndex()});
					}
				}

				thread->setState(state);
			}

		} else {

			for (std::shared_ptr<IThread> &thread : process->threads()) {
				State state;
				thread->getState(&state);
				state.setDebugRegister(7, 0);
				thread->setState(state);
			}
		}
	}

	edb::v1::update_ui();
}

/**
 * @brief HardwareBreakpoints::showMenu
 */
void HardwareBreakpoints::showMenu() {

	if (dialog_->exec() == QDialog::Accepted) {
		setupBreakpoints();
	}
}

/**
 * @brief HardwareBreakpoints::handleEvent
 *
 * this hooks the debug event handler so we can make the breakpoints able to be resumed
 *
 * @param event
 * @return
 */
edb::EventStatus HardwareBreakpoints::handleEvent(const std::shared_ptr<IDebugEvent> &event) {

	if (event->stopped() && event->isTrap()) {

		if (IProcess *process = edb::v1::debugger_core->process()) {
			if (std::shared_ptr<IThread> thread = process->currentThread()) {
				// check DR6 to see if it was a HW BP event
				// if so, set the resume flag
				State state;
				thread->getState(&state);
				if ((state.debugRegister(6) & 0x0f) != 0x00) {
					state.setFlags(state.flags() | (1 << 16));
					thread->setState(state);
				}
			}
		}
	}

	// pass the event down the stack
	return edb::DEBUG_NEXT_HANDLER;
}

/**
 * @brief HardwareBreakpoints::stackContextMenu
 * @return
 */
QList<QAction *> HardwareBreakpoints::stackContextMenu() {
	auto menu = new QMenu(tr("Hardware Breakpoints"));

	auto rw1 = menu->addAction(tr("Hardware, On Read/Write #1"), this, SLOT(setAccess1()));
	auto rw2 = menu->addAction(tr("Hardware, On Read/Write #2"), this, SLOT(setAccess2()));
	auto rw3 = menu->addAction(tr("Hardware, On Read/Write #3"), this, SLOT(setAccess3()));
	auto rw4 = menu->addAction(tr("Hardware, On Read/Write #4"), this, SLOT(setAccess4()));

	auto wo1 = menu->addAction(tr("Hardware, On Write #1"), this, SLOT(setWrite1()));
	auto wo2 = menu->addAction(tr("Hardware, On Write #2"), this, SLOT(setWrite2()));
	auto wo3 = menu->addAction(tr("Hardware, On Write #3"), this, SLOT(setWrite3()));
	auto wo4 = menu->addAction(tr("Hardware, On Write #4"), this, SLOT(setWrite4()));

	rw1->setData(1);
	rw2->setData(1);
	rw3->setData(1);
	rw4->setData(1);

	wo1->setData(1);
	wo2->setData(1);
	wo3->setData(1);
	wo4->setData(1);

	QList<QAction *> ret;

	auto action = new QAction(tr("Hardware Breakpoints"), this);
	action->setMenu(menu);
	ret << action;
	return ret;
}

/**
 * @brief HardwareBreakpoints::dataContextMenu
 * @return
 */
QList<QAction *> HardwareBreakpoints::dataContextMenu() {
	auto menu = new QMenu(tr("Hardware Breakpoints"));

	auto rw1 = menu->addAction(tr("Hardware, On Read/Write #1"), this, SLOT(setAccess1()));
	auto rw2 = menu->addAction(tr("Hardware, On Read/Write #2"), this, SLOT(setAccess2()));
	auto rw3 = menu->addAction(tr("Hardware, On Read/Write #3"), this, SLOT(setAccess3()));
	auto rw4 = menu->addAction(tr("Hardware, On Read/Write #4"), this, SLOT(setAccess4()));

	auto wo1 = menu->addAction(tr("Hardware, On Write #1"), this, SLOT(setWrite1()));
	auto wo2 = menu->addAction(tr("Hardware, On Write #2"), this, SLOT(setWrite2()));
	auto wo3 = menu->addAction(tr("Hardware, On Write #3"), this, SLOT(setWrite3()));
	auto wo4 = menu->addAction(tr("Hardware, On Write #4"), this, SLOT(setWrite4()));

	rw1->setData(2);
	rw2->setData(2);
	rw3->setData(2);
	rw4->setData(2);

	wo1->setData(2);
	wo2->setData(2);
	wo3->setData(2);
	wo4->setData(2);

	QList<QAction *> ret;

	auto action = new QAction(tr("Hardware Breakpoints"), this);
	action->setMenu(menu);
	ret << action;
	return ret;
}

/**
 * @brief HardwareBreakpoints::cpuContextMenu
 * @return
 */
QList<QAction *> HardwareBreakpoints::cpuContextMenu() {

	auto menu = new QMenu(tr("Hardware Breakpoints"));
	auto ex1  = menu->addAction(tr("Hardware, On Execute #1"), this, SLOT(setExec1()));
	auto ex2  = menu->addAction(tr("Hardware, On Execute #2"), this, SLOT(setExec2()));
	auto ex3  = menu->addAction(tr("Hardware, On Execute #3"), this, SLOT(setExec3()));
	auto ex4  = menu->addAction(tr("Hardware, On Execute #4"), this, SLOT(setExec4()));

	auto rw1 = menu->addAction(tr("Hardware, On Read/Write #1"), this, SLOT(setAccess1()));
	auto rw2 = menu->addAction(tr("Hardware, On Read/Write #2"), this, SLOT(setAccess2()));
	auto rw3 = menu->addAction(tr("Hardware, On Read/Write #3"), this, SLOT(setAccess3()));
	auto rw4 = menu->addAction(tr("Hardware, On Read/Write #4"), this, SLOT(setAccess4()));

	auto wo1 = menu->addAction(tr("Hardware, On Write #1"), this, SLOT(setWrite1()));
	auto wo2 = menu->addAction(tr("Hardware, On Write #2"), this, SLOT(setWrite2()));
	auto wo3 = menu->addAction(tr("Hardware, On Write #3"), this, SLOT(setWrite3()));
	auto wo4 = menu->addAction(tr("Hardware, On Write #4"), this, SLOT(setWrite4()));

	ex1->setData(3);
	ex2->setData(3);
	ex3->setData(3);
	ex4->setData(3);

	rw1->setData(3);
	rw2->setData(3);
	rw3->setData(3);
	rw4->setData(3);

	wo1->setData(3);
	wo2->setData(3);
	wo3->setData(3);
	wo4->setData(3);

	QList<QAction *> ret;

	auto action = new QAction(tr("Hardware Breakpoints"), this);
	action->setMenu(menu);
	ret << action;
	return ret;
}

/**
 * @brief HardwareBreakpoints::setExecuteBP
 * @param index
 * @param inUse
 */
void HardwareBreakpoints::setExecuteBP(int index, bool inUse) {

	if (IProcess *process = edb::v1::debugger_core->process()) {

		if (!process->isPaused()) {
			QMessageBox::warning(
				nullptr,
				tr("Process Not Paused"),
				tr("Unable to update hardware breakpoints because the process does not appear to be currently paused. Please suspend the process."));
			return;
		}

		if (inUse) {
			QMessageBox::StandardButton button = QMessageBox::question(nullptr, tr("Breakpoint Already In Use"), tr("This breakpoint is already being used. Do you want to replace it?"), QMessageBox::Yes | QMessageBox::Cancel);
			if (button != QMessageBox::Yes) {
				return;
			}
		}

		edb::address_t address = edb::v1::cpu_selected_address();

		for (std::shared_ptr<IThread> &thread : process->threads()) {
			State state;
			thread->getState(&state);
			set_breakpoint_state(&state, index, {true, address, 0, 0});
			thread->setState(state);
		}
	}

	edb::v1::update_ui();
}

/**
 * @brief HardwareBreakpoints::setWriteBP
 * @param index
 * @param inUse
 * @param address
 * @param size
 */
void HardwareBreakpoints::setWriteBP(int index, bool inUse, edb::address_t address, size_t size) {

	if (IProcess *process = edb::v1::debugger_core->process()) {

		if (!process->isPaused()) {
			QMessageBox::warning(
				nullptr,
				tr("Process Not Paused"),
				tr("Unable to update hardware breakpoints because the process does not appear to be currently paused. Please suspend the process."));
			return;
		}

		if (inUse) {
			QMessageBox::StandardButton button = QMessageBox::question(nullptr, tr("Breakpoint Already In Use"), tr("This breakpoint is already being used. Do you want to replace it?"), QMessageBox::Yes | QMessageBox::Cancel);
			if (button != QMessageBox::Yes) {
				return;
			}
		}

		for (std::shared_ptr<IThread> &thread : process->threads()) {
			State state;
			thread->getState(&state);

			switch (size) {
			case 1:
				set_breakpoint_state(&state, index, {true, address, 1, 0});
				break;
			case 2:
				set_breakpoint_state(&state, index, {true, address, 1, 1});
				break;
			case 4:
				set_breakpoint_state(&state, index, {true, address, 1, 2});
				break;
			case 8:
				set_breakpoint_state(&state, index, {true, address, 1, 3});
				break;
			default:
				QMessageBox::critical(nullptr, tr("Invalid Selection Size"), tr("Please select 1, 2, 4, or 8 bytes for this type of hardware breakpoint"));
				return;
			}

			thread->setState(state);
		}
	}

	edb::v1::update_ui();
}

/**
 * @brief HardwareBreakpoints::setReadWriteBP
 * @param index
 * @param inUse
 * @param address
 * @param size
 */
void HardwareBreakpoints::setReadWriteBP(int index, bool inUse, edb::address_t address, size_t size) {

	if (IProcess *process = edb::v1::debugger_core->process()) {

		if (!process->isPaused()) {
			QMessageBox::warning(
				nullptr,
				tr("Process Not Paused"),
				tr("Unable to update hardware breakpoints because the process does not appear to be currently paused. Please suspend the process."));
			return;
		}

		if (inUse) {
			QMessageBox::StandardButton button = QMessageBox::question(
				nullptr,
				tr("Breakpoint Already In Use"),
				tr("This breakpoint is already being used. Do you want to replace it?"),
				QMessageBox::Yes | QMessageBox::Cancel);
			if (button != QMessageBox::Yes) {
				return;
			}
		}

		for (std::shared_ptr<IThread> &thread : process->threads()) {
			State state;
			thread->getState(&state);

			switch (size) {
			case 1:
				set_breakpoint_state(&state, index, {true, address, 2, 0});
				break;
			case 2:
				set_breakpoint_state(&state, index, {true, address, 2, 1});
				break;
			case 4:
				set_breakpoint_state(&state, index, {true, address, 2, 2});
				break;
			case 8:
				set_breakpoint_state(&state, index, {true, address, 2, 3});
				break;
			default:
				QMessageBox::critical(nullptr, tr("Invalid Selection Size"), tr("Please select 1, 2, 4, or 8 bytes for this type of hardward breakpoint"));
				return;
			}

			thread->setState(state);
		}
	}

	edb::v1::update_ui();
}

/**
 * @brief HardwareBreakpoints::setExec
 * @param index
 */
void HardwareBreakpoints::setExec(int index) {
	if (auto a = qobject_cast<QAction *>(sender())) {
		switch (a->data().toLongLong()) {
		case 3:
			setExecuteBP(index, enabled_[index]->isChecked());
			break;
		default:
			Q_ASSERT(0 && "Internal Error");
			break;
		}
	}
}

/**
 * @brief HardwareBreakpoints::setWrite
 * @param index
 */
void HardwareBreakpoints::setWrite(int index) {
	if (auto a = qobject_cast<QAction *>(sender())) {
		switch (a->data().toLongLong()) {
		case 1:
			setStackWriteBP(index, enabled_[index]->isChecked());
			break;
		case 2:
			setDataWriteBP(index, enabled_[index]->isChecked());
			break;
		case 3:
			setCPUWriteBP(index, enabled_[index]->isChecked());
			break;
		default:
			Q_ASSERT(0 && "Internal Error");
			break;
		}
	}
}

/**
 * @brief HardwareBreakpoints::setAccess
 * @param index
 */
void HardwareBreakpoints::setAccess(int index) {
	if (auto a = qobject_cast<QAction *>(sender())) {
		switch (a->data().toLongLong()) {
		case 1:
			setStackReadWriteBP(index, enabled_[index]->isChecked());
			break;
		case 2:
			setDataReadWriteBP(index, enabled_[index]->isChecked());
			break;
		case 3:
			setCPUReadWriteBP(index, enabled_[index]->isChecked());
			break;
		default:
			Q_ASSERT(0 && "Internal Error");
			break;
		}
	}
}

/**
 * @brief HardwareBreakpoints::setDataReadWriteBP
 * @param index
 * @param inUse
 */
void HardwareBreakpoints::setDataReadWriteBP(int index, bool inUse) {
	const edb::address_t address = edb::v1::selected_data_address();
	const size_t size            = edb::v1::selected_data_size();
	setReadWriteBP(index, inUse, address, size);
}

/**
 * @brief HardwareBreakpoints::setDataWriteBP
 * @param index
 * @param inUse
 */
void HardwareBreakpoints::setDataWriteBP(int index, bool inUse) {
	const edb::address_t address = edb::v1::selected_data_address();
	const size_t size            = edb::v1::selected_data_size();
	setReadWriteBP(index, inUse, address, size);
}

/**
 * @brief HardwareBreakpoints::setStackReadWriteBP
 * @param index
 * @param inUse
 */
void HardwareBreakpoints::setStackReadWriteBP(int index, bool inUse) {
	const edb::address_t address = edb::v1::selected_stack_address();
	const size_t size            = edb::v1::selected_stack_size();
	setReadWriteBP(index, inUse, address, size);
}

/**
 * @brief HardwareBreakpoints::setStackWriteBP
 * @param index
 * @param inUse
 */
void HardwareBreakpoints::setStackWriteBP(int index, bool inUse) {
	const edb::address_t address = edb::v1::selected_stack_address();
	const size_t size            = edb::v1::selected_stack_size();
	setWriteBP(index, inUse, address, size);
}

/**
 * @brief HardwareBreakpoints::setCPUReadWriteBP
 * @param index
 * @param inUse
 */
void HardwareBreakpoints::setCPUReadWriteBP(int index, bool inUse) {
	const edb::address_t address = edb::v1::cpu_selected_address();
	constexpr size_t Size        = 1;
	setWriteBP(index, inUse, address, Size);
}

/**
 * @brief HardwareBreakpoints::setCPUWriteBP
 * @param index
 * @param inUse
 */
void HardwareBreakpoints::setCPUWriteBP(int index, bool inUse) {
	const edb::address_t address = edb::v1::cpu_selected_address();
	constexpr size_t Size        = 1;
	setWriteBP(index, inUse, address, Size);
}

/**
 * @brief HardwareBreakpoints::setExec1
 */
void HardwareBreakpoints::setExec1() {
	setExec(Register1);
}

/**
 * @brief HardwareBreakpoints::setExec2
 */
void HardwareBreakpoints::setExec2() {
	setExec(Register2);
}

/**
 * @brief HardwareBreakpoints::setExec3
 */
void HardwareBreakpoints::setExec3() {
	setExec(Register3);
}

/**
 * @brief HardwareBreakpoints::setExec4
 */
void HardwareBreakpoints::setExec4() {
	setExec(Register4);
}

/**
 * @brief HardwareBreakpoints::setAccess1
 */
void HardwareBreakpoints::setAccess1() {
	setAccess(Register1);
}

/**
 * @brief HardwareBreakpoints::setAccess2
 */
void HardwareBreakpoints::setAccess2() {
	setAccess(Register2);
}

/**
 * @brief HardwareBreakpoints::setAccess3
 */
void HardwareBreakpoints::setAccess3() {
	setAccess(Register3);
}

/**
 * @brief HardwareBreakpoints::setAccess4
 */
void HardwareBreakpoints::setAccess4() {
	setAccess(Register4);
}

/**
 * @brief HardwareBreakpoints::setWrite1
 */
void HardwareBreakpoints::setWrite1() {
	setWrite(Register1);
}

/**
 * @brief HardwareBreakpoints::setWrite2
 */
void HardwareBreakpoints::setWrite2() {
	setWrite(Register2);
}

/**
 * @brief HardwareBreakpoints::setWrite3
 */
void HardwareBreakpoints::setWrite3() {
	setWrite(Register3);
}

/**
 * @brief HardwareBreakpoints::setWrite4
 */
void HardwareBreakpoints::setWrite4() {
	setWrite(Register4);
}

}

```

`plugins/HardwareBreakpoints/HardwareBreakpoints.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef HARDWARE_BREAKPOINTS_H_20080228_
#define HARDWARE_BREAKPOINTS_H_20080228_

#include "IDebugEventHandler.h"
#include "IPlugin.h"
#include "libHardwareBreakpoints.h"

class QDialog;
class QMenu;
class State;
class QCheckBox;
class QComboBox;
class QLineEdit;

namespace HardwareBreakpointsPlugin {

class HardwareBreakpoints : public QObject, public IPlugin, public IDebugEventHandler {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	HardwareBreakpoints(QObject *parent = nullptr);

protected:
	void privateInit() override;
	void privateFini() override;

public:
	QMenu *menu(QWidget *parent = nullptr) override;
	edb::EventStatus handleEvent(const std::shared_ptr<IDebugEvent> &event) override;
	QList<QAction *> cpuContextMenu() override;
	QList<QAction *> stackContextMenu() override;
	QList<QAction *> dataContextMenu() override;

public Q_SLOTS:
	void showMenu();

private:
	void setupBreakpoints();
	void setExecuteBP(int index, bool inUse);
	void setReadWriteBP(int index, bool inUse, edb::address_t address, size_t size);
	void setWriteBP(int index, bool inUse, edb::address_t address, size_t size);

	void setDataReadWriteBP(int index, bool inUse);
	void setDataWriteBP(int index, bool inUse);
	void setStackReadWriteBP(int index, bool inUse);
	void setStackWriteBP(int index, bool inUse);
	void setCPUReadWriteBP(int index, bool inUse);
	void setCPUWriteBP(int index, bool inUse);

	void setExec(int index);
	void setWrite(int index);
	void setAccess(int index);

private Q_SLOTS:
	void setWrite1();
	void setWrite2();
	void setWrite3();
	void setWrite4();

	void setAccess1();
	void setAccess2();
	void setAccess3();
	void setAccess4();

	void setExec1();
	void setExec2();
	void setExec3();
	void setExec4();

private:
	QMenu *menu_              = nullptr;
	QPointer<QDialog> dialog_ = nullptr;

	QLineEdit *addresses_[4] = {};
	QCheckBox *enabled_[4]   = {};
	QComboBox *types_[4]     = {};
	QComboBox *sizes_[4]     = {};
};

}

#endif

```

`plugins/HardwareBreakpoints/libHardwareBreakpoints.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "libHardwareBreakpoints.h"
#include "State.h"

namespace HardwareBreakpointsPlugin {

/**
 * @brief validate_breakpoint
 * @param bp_state
 * @return
 */
BreakpointStatus validate_breakpoint(const BreakpointState &bp_state) {

	if (bp_state.enabled) {
		switch (bp_state.type) {
		case 2:
		case 1: {
			const edb::address_t address_mask = (1u << bp_state.size) - 1;
			if ((bp_state.addr & address_mask) != 0) {
				return AlignmentError;
			}
		} break;
		default:
			break;
		}

		if (edb::v1::debuggeeIs32Bit()) {
			if (bp_state.size == 3) {
				return SizeError;
			}
		}
	}

	return Valid;
}

/**
 * @brief breakpoint_state
 * @param state
 * @param num
 * @return
 */
BreakpointState breakpoint_state(const State *state, int num) {

	Q_ASSERT(num < RegisterCount);

	const int N1 = 16 + (num * 4);
	const int N2 = 18 + (num * 4);

	BreakpointState bp_state;

	// enabled
	switch (num) {
	case Register1:
		bp_state.enabled = (state->debugRegister(7) & 0x00000001) != 0;
		break;
	case Register2:
		bp_state.enabled = (state->debugRegister(7) & 0x00000004) != 0;
		break;
	case Register3:
		bp_state.enabled = (state->debugRegister(7) & 0x00000010) != 0;
		break;
	case Register4:
		bp_state.enabled = (state->debugRegister(7) & 0x00000040) != 0;
		break;
	}

	// address
	bp_state.addr = state->debugRegister(num);

	// type
	switch ((state->debugRegister(7) >> N1) & 0x03) {
	case 0x00:
		bp_state.type = 0;
		break;
	case 0x01:
		bp_state.type = 1;
		break;
	case 0x03:
		bp_state.type = 2;
		break;
	default:
		bp_state.type = -1;
		Q_ASSERT(0 && "Internal Error");
	}

	// size
	switch ((state->debugRegister(7) >> N2) & 0x03) {
	case 0x00:
		bp_state.size = 0;
		break;
	case 0x01:
		bp_state.size = 1;
		break;
	case 0x03:
		bp_state.size = 2;
		break;
	case 0x02:
		bp_state.size = 3;
	}

	return bp_state;
}

/**
 * @brief set_breakpoint_state
 * @param state
 * @param num
 * @param bp_state
 */
void set_breakpoint_state(State *state, int num, const BreakpointState &bp_state) {

	const int N1 = 16 + (num * 4);
	const int N2 = 18 + (num * 4);

	// default to disabled
	state->setDebugRegister(7, (state->debugRegister(7) & ~(0x01ULL << (num * 2))));

	if (bp_state.enabled) {
		// set the address
		state->setDebugRegister(num, bp_state.addr);

		// enable this breakpoint
		state->setDebugRegister(7, state->debugRegister(7) | (0x01ULL << (num * 2)));

		// setup the type
		switch (bp_state.type) {
		case 2:
			// read/write
			state->setDebugRegister(7, (state->debugRegister(7) & ~(0x03ULL << N1)) | (0x03ULL << N1));
			break;
		case 1:
			// write
			state->setDebugRegister(7, (state->debugRegister(7) & ~(0x03ULL << N1)) | (0x01ULL << N1));
			break;
		case 0:
			// execute
			state->setDebugRegister(7, (state->debugRegister(7) & ~(0x03ULL << N1)) | (0x00ULL << N1));
			break;
		}

		if (bp_state.type != 0) {
			// setup the size
			switch (bp_state.size) {
			case 3:
				// 8 bytes
				Q_ASSERT(edb::v1::debuggeeIs64Bit());
				state->setDebugRegister(7, (state->debugRegister(7) & ~(0x03ULL << N2)) | (0x02ULL << N2));
				break;
			case 2:
				// 4 bytes
				state->setDebugRegister(7, (state->debugRegister(7) & ~(0x03ULL << N2)) | (0x03ULL << N2));
				break;
			case 1:
				// 2 bytes
				state->setDebugRegister(7, (state->debugRegister(7) & ~(0x03ULL << N2)) | (0x01ULL << N2));
				break;
			case 0:
				// 1 byte
				state->setDebugRegister(7, (state->debugRegister(7) & ~(0x03ULL << N2)) | (0x00ULL << N2));
				break;
			}
		} else {
			state->setDebugRegister(7, (state->debugRegister(7) & ~(0x03ULL << N2)));
		}
	}
}

}

```

`plugins/HardwareBreakpoints/libHardwareBreakpoints.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef LIB_HARDWARE_BREAKPOINTS_H_20191119_
#define LIB_HARDWARE_BREAKPOINTS_H_20191119_

#include "edb.h"

namespace HardwareBreakpointsPlugin {

constexpr int Register1     = 0;
constexpr int Register2     = 1;
constexpr int Register3     = 2;
constexpr int Register4     = 3;
constexpr int RegisterCount = 4;

struct BreakpointState {
	bool enabled;
	edb::address_t addr;
	int type;
	int size;
};

enum BreakpointStatus {
	Valid,
	AlignmentError,
	SizeError
};

BreakpointState breakpoint_state(const State *state, int num);
void set_breakpoint_state(State *state, int num, const BreakpointState &bp_state);
BreakpointStatus validate_breakpoint(const BreakpointState &bp_state);

}

#endif

```

`plugins/HeapAnalyzer/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "HeapAnalyzer")

find_package(Qt5 5.0.0 REQUIRED Widgets Concurrent)

add_library(${PluginName} SHARED
	DialogHeap.cpp
	DialogHeap.h
	DialogHeap.ui
	HeapAnalyzer.cpp
	HeapAnalyzer.h
	ResultViewModel.cpp
	ResultViewModel.h
)

target_link_libraries(${PluginName} Qt5::Widgets Qt5::Concurrent edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/HeapAnalyzer/DialogHeap.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogHeap.h"
#include "Configuration.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IRegion.h"
#include "ISymbolManager.h"
#include "MemoryRegions.h"
#include "Module.h"
#include "ResultViewModel.h"
#include "Symbol.h"
#include "edb.h"
#include "util/Math.h"

#ifdef ENABLE_GRAPH
#include "GraphEdge.h"
#include "GraphNode.h"
#include "GraphWidget.h"
#endif

#include <QFileInfo>
#include <QHeaderView>
#include <QMessageBox>
#include <QPushButton>
#include <QSortFilterProxyModel>
#include <QStack>
#include <QString>
#include <QVector>
#include <QtDebug>
#include <algorithm>
#include <functional>

namespace HeapAnalyzerPlugin {
namespace {

constexpr int PreviousInUse = 0x1;
constexpr int IsMMapped     = 0x2;
constexpr int NonMainArena  = 0x4;

constexpr int SizeBits = (PreviousInUse | IsMMapped | NonMainArena);

// NOTE: the details of this structure are 32/64-bit sensitive!
template <class MallocChunkPtr>
struct malloc_chunk {
	using ULong = MallocChunkPtr; // ulong has the same size

	ULong prevSize; /* Size of previous chunk (if free).  */
	ULong size;     /* Size in bytes, including overhead. */

	MallocChunkPtr fd; /* double links -- used only if free. */
	MallocChunkPtr bk;

	edb::address_t chunkSize() const { return edb::address_t::fromZeroExtended(size & ~(SizeBits)); }
	bool prevInUse() const { return size & PreviousInUse; }
};

template <class Addr>
edb::address_t next_chunk(edb::address_t p, const malloc_chunk<Addr> &c) {
	return p + c.chunkSize();
}

/**
 * @brief block_start
 * @param pointer
 * @return
 */
edb::address_t block_start(edb::address_t pointer) {
	return pointer + edb::v1::pointer_size() * 2; // pointer_size() is malloc_chunk*
}

/**
 * @brief block_start
 * @param result
 * @return
 */
edb::address_t block_start(const ResultViewModel::Result &result) {
	return block_start(result.address);
}

/**
 * @brief get_library_names
 * @param libcName
 * @param ldName
 */
void get_library_names(QString *libcName, QString *ldName) {

	Q_ASSERT(libcName);
	Q_ASSERT(ldName);

	if (edb::v1::debugger_core) {
		if (IProcess *process = edb::v1::debugger_core->process()) {
			const QList<Module> libs = process->loadedModules();

			for (const Module &module : libs) {
				if (!ldName->isEmpty() && !libcName->isEmpty()) {
					break;
				}

				const QFileInfo fileinfo(module.name);

				// this tries its best to cover all possible libc library versioning
				// possibilities we need to find out if this is 100% accurate, so far
				// seems correct based on my system

				if (fileinfo.completeBaseName().startsWith("libc-")) {
					*libcName = fileinfo.completeBaseName() + "." + fileinfo.suffix();
					qDebug() << "[Heap Analyzer] libc library appears to be:" << *libcName;
					continue;
				}

				if (fileinfo.completeBaseName().startsWith("libc.so")) {
					*libcName = fileinfo.completeBaseName() + "." + fileinfo.suffix();
					qDebug() << "[Heap Analyzer] libc library appears to be:" << *libcName;
					continue;
				}

				if (fileinfo.completeBaseName().startsWith("ld-")) {
					*ldName = fileinfo.completeBaseName() + "." + fileinfo.suffix();
					qDebug() << "[Heap Analyzer] ld library appears to be:" << *ldName;
					continue;
				}
			}
		}
	}
}

}

/**
 * @brief DialogHeap::DialogHeap
 * @param parent
 * @param f
 */
DialogHeap::DialogHeap(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {
	ui.setupUi(this);

	model_ = new ResultViewModel(this);

	filterModel_ = new QSortFilterProxyModel(this);
	connect(ui.lineEdit, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);

	filterModel_->setFilterKeyColumn(3);
	filterModel_->setSourceModel(model_);
	ui.tableView->setModel(filterModel_);

	ui.tableView->verticalHeader()->hide();
	ui.tableView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

	buttonAnalyze_ = new QPushButton(QIcon::fromTheme("edit-find"), tr("Analyze"));
	buttonGraph_   = new QPushButton(QIcon::fromTheme("distribute-graph"), tr("&Graph Selected Blocks"));
	connect(buttonAnalyze_, &QPushButton::clicked, this, [this]() {
		buttonAnalyze_->setEnabled(false);
		ui.progressBar->setValue(0);
		ui.tableView->setUpdatesEnabled(false);

		if (edb::v1::debuggeeIs32Bit()) {
			doFind<edb::value32>();
		} else {
			doFind<edb::value64>();
		}

		ui.tableView->setUpdatesEnabled(true);
		ui.progressBar->setValue(100);
		buttonAnalyze_->setEnabled(true);
	});

	connect(buttonGraph_, &QPushButton::clicked, this, [this]() {
#ifdef ENABLE_GRAPH
		constexpr int MaxNodes = 5000;

		auto graph = new GraphWidget(nullptr);
		graph->setAttribute(Qt::WA_DeleteOnClose);

		do {
			QMap<edb::address_t, GraphNode *> nodes;
			QStack<const ResultViewModel::Result *> result_stack;
			QSet<const ResultViewModel::Result *> seen_results;

			QMap<edb::address_t, const ResultViewModel::Result *> result_map = createResultMap();

			// seed our search with the selected blocks
			const QItemSelectionModel *const selModel = ui.tableView->selectionModel();
			const QModelIndexList sel                 = selModel->selectedRows();
			if (sel.size() != 0) {
				for (const QModelIndex &index : sel) {
					const QModelIndex idx = filterModel_->mapToSource(index);
					auto item             = static_cast<ResultViewModel::Result *>(idx.internalPointer());
					result_stack.push(item);
					seen_results.insert(item);
				}
			}

			while (!result_stack.isEmpty()) {
				const ResultViewModel::Result *const result = result_stack.pop();

				GraphNode *node = new GraphNode(graph, edb::v1::format_pointer(result->address), result->type == ResultViewModel::Result::Busy ? Qt::lightGray : Qt::red);

				nodes.insert(result->address, node);

				for (edb::address_t pointer : result->pointers) {
					const ResultViewModel::Result *next_result = result_map[pointer];
					if (!seen_results.contains(next_result)) {
						seen_results.insert(next_result);
						result_stack.push(next_result);
					}
				}
			}
			qDebug("[Heap Analyzer] Done Processing %d Nodes", nodes.size());

			if (nodes.size() > MaxNodes) {
				qDebug("[Heap Analyzer] Too Many Nodes! (%d)", nodes.size());
				delete graph;
				return;
			}

			Q_FOREACH (const ResultViewModel::Result *result, result_map) {
				const edb::address_t addr = result->address;
				if (nodes.contains(addr)) {
					for (edb::address_t pointer : result->pointers) {
						new GraphEdge(nodes[addr], nodes[pointer]);
					}
				}
			}
			qDebug("[Heap Analyzer] Done Processing Edges");
		} while (0);

		graph->layout();
		graph->show();
#endif
	});

	ui.buttonBox->addButton(buttonGraph_, QDialogButtonBox::ActionRole);
	ui.buttonBox->addButton(buttonAnalyze_, QDialogButtonBox::ActionRole);

#ifdef ENABLE_GRAPH
	buttonGraph_->setEnabled(true);
#else
	buttonGraph_->setEnabled(false);
#endif
}

/**
 * @brief DialogHeap::showEvent
 */
void DialogHeap::showEvent(QShowEvent *) {
	model_->clearResults();
	ui.progressBar->setValue(0);
}

/**
 * @brief DialogHeap::on_tableView_doubleClicked
 * @param index
 */
void DialogHeap::on_tableView_doubleClicked(const QModelIndex &index) {
	const QModelIndex idx = filterModel_->mapToSource(index);
	if (auto item = static_cast<ResultViewModel::Result *>(idx.internalPointer())) {
		edb::v1::dump_data_range(item->address, item->address + item->size, false);
	}
}

/**
 * @brief DialogHeap::processPotentialPointers
 * @param targets
 * @param index
 */
void DialogHeap::processPotentialPointers(const QHash<edb::address_t, edb::address_t> &targets, const QModelIndex &index) {

	if (auto result = static_cast<ResultViewModel::Result *>(index.internalPointer())) {

		std::vector<edb::address_t> pointers;

		if (IProcess *process = edb::v1::debugger_core->process()) {
			if (result->dataType == ResultViewModel::Result::Unknown) {
				edb::address_t pointer(0);
				edb::address_t block_ptr = block_start(*result);
				edb::address_t block_end = block_ptr + result->size;

				while (block_ptr < block_end) {

					if (process->readBytes(block_ptr, &pointer, edb::v1::pointer_size())) {
						auto it = targets.find(pointer);
						if (it != targets.end()) {
							pointers.push_back(it.value());
						}
					}

					block_ptr += edb::v1::pointer_size();
				}

				if (!pointers.empty()) {
					model_->setPointerData(index, pointers);
				}
			}
		}
	}
}

/**
 * @brief DialogHeap::detectPointers
 */
void DialogHeap::detectPointers() {

	qDebug() << "[Heap Analyzer] detecting pointers in heap blocks";

	QHash<edb::address_t, edb::address_t> targets;

	qDebug() << "[Heap Analyzer] collecting possible targets addresses";
	for (int row = 0; row < model_->rowCount(); ++row) {
		QModelIndex index = model_->index(row, 0);
		if (auto result = static_cast<ResultViewModel::Result *>(index.internalPointer())) {
			edb::address_t block_ptr = block_start(*result);
			edb::address_t block_end = block_ptr + result->size;
			while (block_ptr < block_end) {
				targets.insert(block_ptr, result->address);
				block_ptr += edb::v1::pointer_size();
			}
		}
	}

	qDebug() << "[Heap Analyzer] linking blocks to taget addresses";
	for (int row = 0; row < model_->rowCount(); ++row) {
		QModelIndex index = model_->index(row, 0);
		processPotentialPointers(targets, index);
	}
}

/**
 * @brief DialogHeap::collectBlocks
 * @param start_address
 * @param end_address
 */
template <class Addr>
void DialogHeap::collectBlocks(edb::address_t start_address, edb::address_t end_address) {
	model_->clearResults();
	ui.labelFree->setText(tr("Free Blocks: ?"));
	ui.labelBusy->setText(tr("Busy Blocks: ?"));
	ui.labelTotal->setText(tr("Total: ?"));

	int64_t freeBlocks = 0;
	int64_t busyBlocks = 0;

	if (IProcess *process = edb::v1::debugger_core->process()) {
		const int min_string_length = edb::v1::config().min_string_length;

		if (start_address != 0 && end_address != 0) {
#if defined(Q_OS_LINUX) || defined(Q_OS_FREEBSD) || defined(Q_OS_OPENBSD)
			malloc_chunk<Addr> currentChunk;
			malloc_chunk<Addr> nextChunk;
			edb::address_t currentChunkAddress = start_address;

			const edb::address_t how_many = end_address - start_address;
			while (currentChunkAddress != end_address) {
				// read in the current chunk..
				process->readBytes(currentChunkAddress, &currentChunk, sizeof(currentChunk));

				// figure out the address of the next chunk
				const edb::address_t nextChunkAddress = next_chunk(currentChunkAddress, currentChunk);

				// is this the last chunk (if so, it's the 'top')
				if (nextChunkAddress == end_address) {
					model_->addResult({currentChunkAddress, currentChunk.chunkSize(), ResultViewModel::Result::Top, ResultViewModel::Result::Unknown, {}, {}});
				} else {

					// make sure we aren't following a broken heap...
					if (nextChunkAddress > end_address || nextChunkAddress < start_address) {
						break;
					}

					QString data;
					ResultViewModel::Result::DataType data_type = ResultViewModel::Result::Unknown;

					// read in the next chunk
					process->readBytes(nextChunkAddress, &nextChunk, sizeof(nextChunk));

					// if this block is a container for an ascii string, display it...
					// there is a lot of room for improvement here, but it's a start
					QString asciiData;
					QString utf16Data;
					int asciisz;
					int utf16sz;
					if (edb::v1::get_ascii_string_at_address(
							block_start(currentChunkAddress),
							asciiData,
							min_string_length,
							currentChunk.chunkSize(),
							asciisz)) {

						data      = asciiData;
						data_type = ResultViewModel::Result::Ascii;
					} else if (edb::v1::get_utf16_string_at_address(
								   block_start(currentChunkAddress),
								   utf16Data,
								   min_string_length,
								   currentChunk.chunkSize(),
								   utf16sz)) {
						data      = utf16Data;
						data_type = ResultViewModel::Result::Utf16;
					} else {

						using std::memcmp;

						uint8_t bytes[16];
						process->readBytes(block_start(currentChunkAddress), bytes, sizeof(bytes));

						if (memcmp(bytes, "\x89\x50\x4e\x47", 4) == 0) {
							data_type = ResultViewModel::Result::Png;
						} else if (memcmp(bytes, "\x2f\x2a\x20\x58\x50\x4d\x20\x2a\x2f", 9) == 0) {
							data_type = ResultViewModel::Result::Xpm;
						} else if (memcmp(bytes, "\x42\x5a", 2) == 0) {
							data_type = ResultViewModel::Result::Bzip;
						} else if (memcmp(bytes, "\x1f\x9d", 2) == 0) {
							data_type = ResultViewModel::Result::Compress;
						} else if (memcmp(bytes, "\x1f\x8b", 2) == 0) {
							data_type = ResultViewModel::Result::Gzip;
						}
					}

					// TODO(eteran): should this be unsigned int? Or should it be sizeof(value32)/sizeof(value64)?
					const ResultViewModel::Result r{
						currentChunkAddress,
						currentChunk.chunkSize() + sizeof(unsigned int),
						nextChunk.prevInUse() ? ResultViewModel::Result::Busy : ResultViewModel::Result::Free,
						data_type,
						data,
						{}};

					if (nextChunk.prevInUse()) {
						++busyBlocks;
					} else {
						++freeBlocks;
					}

					model_->addResult(r);
				}

				// avoif self referencing blocks
				if (currentChunkAddress == nextChunkAddress) {
					break;
				}

				currentChunkAddress = nextChunkAddress;

				ui.progressBar->setValue(util::percentage(currentChunkAddress - start_address, how_many));
			}

			detectPointers();

			ui.labelFree->setText(tr("Free Blocks: %1").arg(freeBlocks));
			ui.labelBusy->setText(tr("Busy Blocks: %1").arg(busyBlocks));
			ui.labelTotal->setText(tr("Total: %1").arg(freeBlocks + busyBlocks));

#else
#error "Unsupported Platform"
#endif
		}
	}
}

/**
 * @brief DialogHeap::findHeapStartHeuristic
 * @param end_address
 * @param offset
 * @return
 */
edb::address_t DialogHeap::findHeapStartHeuristic(edb::address_t end_address, size_t offset) const {
	const edb::address_t start_address = end_address - offset;

	const edb::address_t heap_symbol = start_address - 4 * edb::v1::pointer_size();

	edb::address_t test_addr(0);
	if (IProcess *process = edb::v1::debugger_core->process()) {
		process->readBytes(heap_symbol, &test_addr, edb::v1::pointer_size());

		if (test_addr != edb::v1::debugger_core->pageSize()) {
			return 0;
		}

		return start_address;
	}

	return 0;
}

/**
 * @brief DialogHeap::do_find
 */
template <class Addr>
void DialogHeap::doFind() {
	// get both the libc and ld symbols of __curbrk
	// this will be the 'before/after libc' addresses

	if (IProcess *process = edb::v1::debugger_core->process()) {
		edb::address_t start_address = 0;
		edb::address_t end_address   = 0;

		QString libcName;
		QString ldName;

		get_library_names(&libcName, &ldName);
#if defined(Q_OS_LINUX) || defined(Q_OS_FREEBSD) || defined(Q_OS_OPENBSD)

		if (std::shared_ptr<Symbol> s = edb::v1::symbol_manager().find(libcName + "::__curbrk")) {
			end_address = s->address;
		} else {
			qDebug() << "[Heap Analyzer] __curbrk symbol not found in libc, falling back on heuristic! This may or may not work.";
		}

		if (std::shared_ptr<Symbol> s = edb::v1::symbol_manager().find(ldName + "::__curbrk")) {
			start_address = s->address;
		} else {

			qDebug() << "[Heap Analyzer] __curbrk symbol not found in ld, falling back on heuristic! This may or may not work.";

			for (edb::address_t offset = 0x0000; offset != 0x1000; offset += edb::v1::pointer_size()) {
				start_address = findHeapStartHeuristic(end_address, offset);
				if (start_address != 0) {
					break;
				}
			}
		}

		if (start_address != 0 && end_address != 0) {
			qDebug() << "[Heap Analyzer] heap start symbol : " << edb::v1::format_pointer(start_address);
			qDebug() << "[Heap Analyzer] heap end symbol   : " << edb::v1::format_pointer(end_address);

			// read the contents of those symbols
			process->readBytes(end_address, &end_address, edb::v1::pointer_size());
			process->readBytes(start_address, &start_address, edb::v1::pointer_size());
		}

		// just assume it's the bounds of the [heap] memory region for now
		if (start_address == 0 || end_address == 0) {

			const QList<std::shared_ptr<IRegion>> &regions = edb::v1::memory_regions().regions();

			auto it = std::find_if(regions.begin(), regions.end(), [](const std::shared_ptr<IRegion> &region) {
				return region->name() == "[heap]";
			});

			if (it != regions.end()) {
				qDebug() << "Found a memory region named '[heap]', assuming that it provides sane bounds";

				if (start_address == 0) {
					start_address = (*it)->start();
				}

				if (end_address == 0) {
					end_address = (*it)->end();
				}
			}
		}

		// ok, I give up
		if (start_address == 0 || end_address == 0) {
			QMessageBox::critical(this, tr("Could not calculate heap bounds"), tr("Failed to calculate the bounds of the heap."));
			return;
		}

#else
#error "Unsupported Platform"
#endif

		qDebug() << "[Heap Analyzer] heap start : " << edb::v1::format_pointer(start_address);
		qDebug() << "[Heap Analyzer] heap end   : " << edb::v1::format_pointer(end_address);

		collectBlocks<Addr>(start_address, end_address);
	}
}

/**
 * @brief DialogHeap::createResultMap
 * @return
 */
QMap<edb::address_t, const ResultViewModel::Result *> DialogHeap::createResultMap() const {

	const QVector<ResultViewModel::Result> &results = model_->results();
	QMap<edb::address_t, const ResultViewModel::Result *> result_map;

	// first we make a nice index for our results, this is likely redundant,
	// but won't take long
	for (const ResultViewModel::Result &result : results) {
		result_map.insert(result.address, &result);
	}

	return result_map;
}

}

```

`plugins/HeapAnalyzer/DialogHeap.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_HEAP_H_20061101_
#define DIALOG_HEAP_H_20061101_

#include "ResultViewModel.h"
#include "Types.h"
#include "ui_DialogHeap.h"
#include <QDialog>

class QSortFilterProxyModel;

namespace HeapAnalyzerPlugin {

class DialogHeap : public QDialog {
	Q_OBJECT

public:
	explicit DialogHeap(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogHeap() override = default;

public Q_SLOTS:
	void on_tableView_doubleClicked(const QModelIndex &index);

private:
	void showEvent(QShowEvent *event) override;

private:
	void detectPointers();
	void processPotentialPointers(const QHash<edb::address_t, edb::address_t> &targets, const QModelIndex &index);
	edb::address_t findHeapStartHeuristic(edb::address_t end_address, size_t offset) const;
	QMap<edb::address_t, const ResultViewModel::Result *> createResultMap() const;

private:
	template <class Addr>
	void collectBlocks(edb::address_t start_address, edb::address_t end_address);

	template <class Addr>
	void doFind();

private:
	Ui::DialogHeap ui;
	ResultViewModel *model_             = nullptr;
	QSortFilterProxyModel *filterModel_ = nullptr;
	QPushButton *buttonAnalyze_         = nullptr;
	QPushButton *buttonGraph_           = nullptr;
};

}

#endif

```

`plugins/HeapAnalyzer/DialogHeap.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>HeapAnalyzerPlugin::DialogHeap</class>
 <widget class="QDialog" name="HeapAnalyzerPlugin::DialogHeap">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>792</width>
    <height>454</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Heap Analyzer</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="label_2">
     <property name="text">
      <string>Results:</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="labelFree">
       <property name="text">
        <string>Free Blocks: ?</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QLabel" name="labelBusy">
       <property name="text">
        <string>Busy Blocks: ?</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_2">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QLabel" name="labelTotal">
       <property name="text">
        <string>Total: ?</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QLineEdit" name="lineEdit">
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QTableView" name="tableView">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::ContiguousSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBar">
     <property name="value">
      <number>0</number>
     </property>
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>tableView</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>HeapAnalyzerPlugin::DialogHeap</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>723</x>
     <y>356</y>
    </hint>
    <hint type="destinationlabel">
     <x>668</x>
     <y>339</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>HeapAnalyzerPlugin::DialogHeap</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>758</x>
     <y>355</y>
    </hint>
    <hint type="destinationlabel">
     <x>353</x>
     <y>339</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/HeapAnalyzer/HeapAnalyzer.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "HeapAnalyzer.h"
#include "DialogHeap.h"
#include "edb.h"
#include <QMenu>

namespace HeapAnalyzerPlugin {

/**
 * @brief HeapAnalyzer::HeapAnalyzer
 * @param parent
 */
HeapAnalyzer::HeapAnalyzer(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief HeapAnalyzer::~HeapAnalyzer
 */
HeapAnalyzer::~HeapAnalyzer() {
	delete dialog_;
}

/**
 * @brief HeapAnalyzer::menu
 * @param parent
 * @return
 */
QMenu *HeapAnalyzer::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("HeapAnalyzer"), parent);
		menu_->addAction(tr("&Heap Analyzer"), this, SLOT(showMenu()), QKeySequence(tr("Ctrl+H")));
	}

	return menu_;
}

/**
 * @brief HeapAnalyzer::showMenu
 */
void HeapAnalyzer::showMenu() {

	if (!dialog_) {
		dialog_ = new DialogHeap(edb::v1::debugger_ui);
	}

	dialog_->show();
}

}

```

`plugins/HeapAnalyzer/HeapAnalyzer.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef HEAP_ANALYZER_H_20060430_
#define HEAP_ANALYZER_H_20060430_

#include "IPlugin.h"

class QMenu;
class QDialog;

namespace HeapAnalyzerPlugin {

class HeapAnalyzer : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit HeapAnalyzer(QObject *parent = nullptr);
	~HeapAnalyzer() override;

public:
	QMenu *menu(QWidget *parent = nullptr) override;

public Q_SLOTS:
	void showMenu();

private:
	QMenu *menu_              = nullptr;
	QPointer<QDialog> dialog_ = nullptr;
};

}

#endif

```

`plugins/HeapAnalyzer/ResultViewModel.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ResultViewModel.h"
#include "edb.h"
#include <algorithm>

namespace HeapAnalyzerPlugin {

/**
 * @brief ResultViewModel::ResultViewModel
 * @param parent
 */
ResultViewModel::ResultViewModel(QObject *parent)
	: QAbstractItemModel(parent) {
}

/**
 * @brief ResultViewModel::headerData
 * @param section
 * @param orientation
 * @param role
 * @return
 */
QVariant ResultViewModel::headerData(int section, Qt::Orientation orientation, int role) const {

	if (role == Qt::DisplayRole && orientation == Qt::Horizontal) {
		switch (section) {
		case 0:
			return tr("Block");
		case 1:
			return tr("Size");
		case 2:
			return tr("Type");
		case 3:
			return tr("Data");
		}
	}

	return QVariant();
}

/**
 * @brief ResultViewModel::data
 * @param index
 * @param role
 * @return
 */
QVariant ResultViewModel::data(const QModelIndex &index, int role) const {

	if (!index.isValid()) {
		return QVariant();
	}

	if (role != Qt::DisplayRole) {
		return QVariant();
	}

	const Result &result = results_[index.row()];

	switch (index.column()) {
	case 0:
		return edb::v1::format_pointer(result.address);
	case 1:
		return edb::v1::format_pointer(result.size);
	case 2:
		switch (result.type) {
		case Result::Top:
			return tr("Top");
		case Result::Busy:
			return tr("Busy");
		case Result::Free:
			return tr("Free");
		}
		return QVariant();
	case 3: {
		switch (result.dataType) {
		case Result::Pointer: {
			QStringList pointers;
			if (edb::v1::debuggeeIs32Bit()) {
				std::transform(result.pointers.begin(), result.pointers.end(), std::back_inserter(pointers), [](const edb::address_t pointer) -> QString {
					return QString("dword ptr [%1]").arg(edb::v1::format_pointer(pointer));
				});
			} else {
				std::transform(result.pointers.begin(), result.pointers.end(), std::back_inserter(pointers), [](const edb::address_t pointer) -> QString {
					return QString("qword ptr [%1]").arg(edb::v1::format_pointer(pointer));
				});
			}
			return pointers.join("|");
		}
		case Result::Png:
			return tr("PNG IMAGE");
		case Result::Xpm:
			return tr("XPM IMAGE");
		case Result::Bzip:
			return tr("BZIP FILE");
		case Result::Compress:
			return tr("COMPRESS FILE");
		case Result::Gzip:
			return tr("GZIP FILE");
		case Result::Ascii:
			return tr("ASCII \"%1\"").arg(result.data);
		case Result::Utf16:
			return tr("UTF-16 \"%1\"").arg(result.data);
		case Result::Unknown:
			return QVariant();
		}
		return QVariant();
	}
	default:
		return QVariant();
	}
}

/**
 * @brief ResultViewModel::addResult
 * @param r
 */
void ResultViewModel::addResult(const Result &r) {
	beginInsertRows(QModelIndex(), rowCount(), rowCount());
	results_.push_back(r);
	endInsertRows();
}

/**
 * @brief ResultViewModel::clearResults
 */
void ResultViewModel::clearResults() {
	beginResetModel();
	results_.clear();
	endResetModel();
}

/**
 * @brief ResultViewModel::index
 * @param row
 * @param column
 * @param parent
 * @return
 */
QModelIndex ResultViewModel::index(int row, int column, const QModelIndex &parent) const {

	Q_UNUSED(parent)

	if (row >= results_.size()) {
		return QModelIndex();
	}

	if (column >= 4) {
		return QModelIndex();
	}

	if (row >= 0) {
		return createIndex(row, column, const_cast<Result *>(&results_[row]));
	} else {
		return createIndex(row, column);
	}
}

/**
 * @brief ResultViewModel::parent
 * @param index
 * @return
 */
QModelIndex ResultViewModel::parent(const QModelIndex &index) const {
	Q_UNUSED(index)
	return QModelIndex();
}

/**
 * @brief ResultViewModel::rowCount
 * @param parent
 * @return
 */
int ResultViewModel::rowCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return results_.size();
}

/**
 * @brief ResultViewModel::columnCount
 * @param parent
 * @return
 */
int ResultViewModel::columnCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return 4;
}

/**
 * @brief ResultViewModel::setPointerData
 * @param index
 * @param data
 */
void ResultViewModel::setPointerData(const QModelIndex &index, const std::vector<edb::address_t> &pointers) {
	if (!index.isValid()) {
		return;
	}

	Result &result = results_[index.row()];

	result.pointers = pointers;
	result.dataType = Result::Pointer;
	Q_EMIT dataChanged(index, index);
}

}

```

`plugins/HeapAnalyzer/ResultViewModel.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef RESULT_VIEW_MODEL_H_20070419_
#define RESULT_VIEW_MODEL_H_20070419_

#include "Types.h"
#include <QAbstractItemModel>
#include <QVector>
#include <vector>

namespace HeapAnalyzerPlugin {

class ResultViewModel : public QAbstractItemModel {
	Q_OBJECT

public:
	struct Result {

		enum DataType {
			Unknown,
			Pointer,
			Png,
			Xpm,
			Bzip,
			Compress,
			Gzip,
			Ascii,
			Utf16
		};

		enum NodeType {
			Top,
			Free,
			Busy
		};

		edb::address_t address = 0;
		edb::address_t size    = 0;
		NodeType type;
		DataType dataType = Unknown;
		QString data;
		std::vector<edb::address_t> pointers;
	};

public:
	explicit ResultViewModel(QObject *parent = nullptr);

public:
	QVariant data(const QModelIndex &index, int role) const override;
	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex &index) const override;
	int rowCount(const QModelIndex &parent = QModelIndex()) const override;
	int columnCount(const QModelIndex &parent = QModelIndex()) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;

public:
	void addResult(const Result &r);
	void clearResults();
	void setPointerData(const QModelIndex &index, const std::vector<edb::address_t> &pointers);

public:
	const QVector<Result> &results() const { return results_; }

private:
	QVector<Result> results_;
};

}

#endif

```

`plugins/InstructionInspector/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "InstructionInspector")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	Plugin.cpp
	Plugin.h
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/InstructionInspector/Plugin.cpp`:

```cpp
/*
Copyright (C) 2016 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Plugin.h"
#include "Configuration.h"
#include "IDebugger.h"
#include "Util.h"
#include "edb.h"

#include <QDebug>
#include <QDir>
#include <QMenu>
#include <QMessageBox>
#include <QProcess>
#include <QPushButton>
#include <QSplitter>
#include <QTemporaryFile>
#include <QTextBrowser>
#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QVBoxLayout>
#include <QtGlobal>

#include <algorithm>
#include <cctype>
#include <cstddef>
#include <iomanip>
#include <map>
#include <sstream>
#include <utility>

#ifdef Q_OS_UNIX
#include <elf.h>
// TODO(eteran): refactor this in terms of "libELF" so we are more portable
#endif

#include <capstone/capstone.h>

namespace InstructionInspector {
namespace {

struct NormalizeFailure {};

/**
 * @brief printBytes
 * @param ptr
 * @param size
 * @param printZeros
 * @return
 */
std::string printBytes(const void *ptr, std::size_t size, bool printZeros = true) {

	std::ostringstream str;
	str << std::setfill('0') << std::uppercase << std::hex;
	const auto bytes = reinterpret_cast<const unsigned char *>(ptr);

	for (std::size_t i = 0; i < size; ++i) {
		if (!str.str().empty()) {
			str << ' ';
		}

		if (bytes[i] || printZeros) {
			str << std::setw(2) << static_cast<unsigned>(bytes[i]);
		}
	}

	return str.str();
}

/**
 * @brief toHex
 * @param x
 * @param Signed
 * @return
 */
std::string toHex(unsigned long long x, bool Signed = false) {
	bool negative = false;

	if (Signed && static_cast<long long>(x) < 0) {
		x = ~x + 1;

		if (~x + 1 != x) {
			negative = true;
		}
	}

	std::ostringstream str;
	str << std::hex << (negative ? "-" : "") << "0x" << std::uppercase << x;
	return str.str();
}

#if defined(EDB_ARM32)
/**
 * @brief toFloatString
 * @param x
 * @return
 */
std::string toFloatString(double x) {
	std::ostringstream str;
	str.precision(17);
	str << x;
	return str.str();
}
#endif

/**
 * @brief uppercase
 * @param text
 * @return
 */
std::string uppercase(std::string text) {
	std::transform(text.begin(), text.end(), text.begin(), [](int ch) { return std::toupper(ch); });
	return text;
}

/**
 * @brief getGroupNames
 * @param csh
 * @param insn_
 * @return
 */
std::vector<std::string> getGroupNames(csh csh, const cs_insn *insn_) {

	std::vector<std::string> groupNames;
	for (int g = 0; g < insn_->detail->groups_count; ++g) {
		const auto grp = insn_->detail->groups[g];

		if (!grp) {
			groupNames.emplace_back("INVALID");
			continue;
		}

		if (const auto groupName = cs_group_name(csh, grp)) {
			groupNames.emplace_back(uppercase(groupName));
		} else {
			groupNames.emplace_back(toHex(grp));
		}
	}

	return groupNames;
}

/**
 * @brief printReg
 * @param csh
 * @param reg
 * @param canBeZero
 * @return
 */
std::string printReg(csh csh, int reg, bool canBeZero = false) {
	if (!reg) {
		return canBeZero ? "" : "INVALID";
	}

	if (const auto regName = cs_reg_name(csh, reg)) {
		return uppercase(regName);
	} else {
		return toHex(reg);
	}
}

#if 0
/**
 * @brief printRegs
 * @param csh
 * @param regsBuffer
 * @param size
 * @return
 */
std::string printRegs(csh csh, const uint16_t *regsBuffer, std::size_t size) {

	std::ostringstream str;
	for (std::size_t r = 0; r < size; ++r) {
		if (!str.str().empty()) {
			str << ",";
		}

		str << printReg(csh, regsBuffer[r]);
	}

	const std::string string = str.str();

	if (string.empty()) {
		return "(none)";
	}

	return string;
}
#endif

#if CS_API_MAJOR >= 4
/**
 * @brief printXOP_CC
 * @param cc
 * @return
 */
std::string printXOP_CC(x86_xop_cc cc) {
	static const std::map<x86_xop_cc, const char *> codes{
		{X86_XOP_CC_INVALID, "INVALID"},
		{X86_XOP_CC_LT, "LT"},
		{X86_XOP_CC_LE, "LE"},
		{X86_XOP_CC_GT, "GT"},
		{X86_XOP_CC_GE, "GE"},
		{X86_XOP_CC_EQ, "EQ"},
		{X86_XOP_CC_NEQ, "NEQ"},
		{X86_XOP_CC_FALSE, "FALSE"},
		{X86_XOP_CC_TRUE, "TRUE"},
	};

	const auto found = codes.find(cc);
	if (found == codes.end()) {
		return toHex(cc);
	}
	return found->second;
}
#endif

/**
 * @brief printSSE_CC
 * @param cc
 * @return
 */
std::string printSSE_CC(x86_sse_cc cc) {
	static const std::map<x86_sse_cc, const char *> codes{
		{X86_SSE_CC_INVALID, "INVALID"},
		{X86_SSE_CC_EQ, "EQ"},
		{X86_SSE_CC_LT, "LT"},
		{X86_SSE_CC_LE, "LE"},
		{X86_SSE_CC_UNORD, "UNORD"},
		{X86_SSE_CC_NEQ, "NEQ"},
		{X86_SSE_CC_NLT, "NLT"},
		{X86_SSE_CC_NLE, "NLE"},
		{X86_SSE_CC_ORD, "ORD"},
	};

	const auto found = codes.find(cc);
	if (found == codes.end()) {
		return toHex(cc);
	}

	return found->second;
}

/**
 * @brief printAVX_CC
 * @param cc
 * @return
 */
std::string printAVX_CC(x86_avx_cc cc) {

	static const std::map<x86_avx_cc, const char *> codes{
		{X86_AVX_CC_INVALID, "INVALID"},
		{X86_AVX_CC_EQ, "EQ"},
		{X86_AVX_CC_LT, "LT"},
		{X86_AVX_CC_LE, "LE"},
		{X86_AVX_CC_UNORD, "UNORD"},
		{X86_AVX_CC_NEQ, "NEQ"},
		{X86_AVX_CC_NLT, "NLT"},
		{X86_AVX_CC_NLE, "NLE"},
		{X86_AVX_CC_ORD, "ORD"},
		{X86_AVX_CC_EQ_UQ, "EQ_UQ"},
		{X86_AVX_CC_NGE, "NGE"},
		{X86_AVX_CC_NGT, "NGT"},
		{X86_AVX_CC_FALSE, "FALSE"},
		{X86_AVX_CC_NEQ_OQ, "NEQ_OQ"},
		{X86_AVX_CC_GE, "GE"},
		{X86_AVX_CC_GT, "GT"},
		{X86_AVX_CC_TRUE, "TRUE"},
		{X86_AVX_CC_EQ_OS, "EQ_OS"},
		{X86_AVX_CC_LT_OQ, "LT_OQ"},
		{X86_AVX_CC_LE_OQ, "LE_OQ"},
		{X86_AVX_CC_UNORD_S, "UNORD_S"},
		{X86_AVX_CC_NEQ_US, "NEQ_US"},
		{X86_AVX_CC_NLT_UQ, "NLT_UQ"},
		{X86_AVX_CC_NLE_UQ, "NLE_UQ"},
		{X86_AVX_CC_ORD_S, "ORD_S"},
		{X86_AVX_CC_EQ_US, "EQ_US"},
		{X86_AVX_CC_NGE_UQ, "NGE_UQ"},
		{X86_AVX_CC_NGT_UQ, "NGT_UQ"},
		{X86_AVX_CC_FALSE_OS, "FALSE_OS"},
		{X86_AVX_CC_NEQ_OS, "NEQ_OS"},
		{X86_AVX_CC_GE_OQ, "GE_OQ"},
		{X86_AVX_CC_GT_OQ, "GT_OQ"},
		{X86_AVX_CC_TRUE_US, "TRUE_US"},
	};

	const auto found = codes.find(cc);
	if (found == codes.end()) {
		return toHex(cc);
	}

	return found->second;
}

/**
 * @brief printAVX_RM
 * @param cc
 * @return
 */
std::string printAVX_RM(x86_avx_rm cc) {
	static const std::map<x86_avx_rm, const char *> codes{
		{X86_AVX_RM_INVALID, "invalid"},
		{X86_AVX_RM_RN, "to nearest"},
		{X86_AVX_RM_RD, "down"},
		{X86_AVX_RM_RU, "up"},
		{X86_AVX_RM_RZ, "toward zero"},
	};

	const auto found = codes.find(cc);
	if (found == codes.end()) {
		return toHex(cc);
	}

	return found->second;
}

#if CS_API_MAJOR >= 4
/**
 * @brief getChangedEFLAGSNames
 * @param efl
 * @return
 */
std::vector<std::string> getChangedEFLAGSNames(std::uint64_t efl) {
	std::vector<std::string> flags;

	if (efl & X86_EFLAGS_MODIFY_AF) {
		flags.emplace_back("MODIFY_AF");
		efl &= ~X86_EFLAGS_MODIFY_AF;
	}
	if (efl & X86_EFLAGS_MODIFY_CF) {
		flags.emplace_back("MODIFY_CF");
		efl &= ~X86_EFLAGS_MODIFY_CF;
	}
	if (efl & X86_EFLAGS_MODIFY_SF) {
		flags.emplace_back("MODIFY_SF");
		efl &= ~X86_EFLAGS_MODIFY_SF;
	}
	if (efl & X86_EFLAGS_MODIFY_ZF) {
		flags.emplace_back("MODIFY_ZF");
		efl &= ~X86_EFLAGS_MODIFY_ZF;
	}
	if (efl & X86_EFLAGS_MODIFY_PF) {
		flags.emplace_back("MODIFY_PF");
		efl &= ~X86_EFLAGS_MODIFY_PF;
	}
	if (efl & X86_EFLAGS_MODIFY_OF) {
		flags.emplace_back("MODIFY_OF");
		efl &= ~X86_EFLAGS_MODIFY_OF;
	}
	if (efl & X86_EFLAGS_MODIFY_TF) {
		flags.emplace_back("MODIFY_TF");
		efl &= ~X86_EFLAGS_MODIFY_TF;
	}
	if (efl & X86_EFLAGS_MODIFY_IF) {
		flags.emplace_back("MODIFY_IF");
		efl &= ~X86_EFLAGS_MODIFY_IF;
	}
	if (efl & X86_EFLAGS_MODIFY_DF) {
		flags.emplace_back("MODIFY_DF");
		efl &= ~X86_EFLAGS_MODIFY_DF;
	}
	if (efl & X86_EFLAGS_MODIFY_NT) {
		flags.emplace_back("MODIFY_NT");
		efl &= ~X86_EFLAGS_MODIFY_NT;
	}
	if (efl & X86_EFLAGS_MODIFY_RF) {
		flags.emplace_back("MODIFY_RF");
		efl &= ~X86_EFLAGS_MODIFY_RF;
	}
	if (efl & X86_EFLAGS_PRIOR_OF) {
		flags.emplace_back("PRIOR_OF");
		efl &= ~X86_EFLAGS_PRIOR_OF;
	}
	if (efl & X86_EFLAGS_PRIOR_SF) {
		flags.emplace_back("PRIOR_SF");
		efl &= ~X86_EFLAGS_PRIOR_SF;
	}
	if (efl & X86_EFLAGS_PRIOR_ZF) {
		flags.emplace_back("PRIOR_ZF");
		efl &= ~X86_EFLAGS_PRIOR_ZF;
	}
	if (efl & X86_EFLAGS_PRIOR_AF) {
		flags.emplace_back("PRIOR_AF");
		efl &= ~X86_EFLAGS_PRIOR_AF;
	}
	if (efl & X86_EFLAGS_PRIOR_PF) {
		flags.emplace_back("PRIOR_PF");
		efl &= ~X86_EFLAGS_PRIOR_PF;
	}
	if (efl & X86_EFLAGS_PRIOR_CF) {
		flags.emplace_back("PRIOR_CF");
		efl &= ~X86_EFLAGS_PRIOR_CF;
	}
	if (efl & X86_EFLAGS_PRIOR_TF) {
		flags.emplace_back("PRIOR_TF");
		efl &= ~X86_EFLAGS_PRIOR_TF;
	}
	if (efl & X86_EFLAGS_PRIOR_IF) {
		flags.emplace_back("PRIOR_IF");
		efl &= ~X86_EFLAGS_PRIOR_IF;
	}
	if (efl & X86_EFLAGS_PRIOR_DF) {
		flags.emplace_back("PRIOR_DF");
		efl &= ~X86_EFLAGS_PRIOR_DF;
	}
	if (efl & X86_EFLAGS_PRIOR_NT) {
		flags.emplace_back("PRIOR_NT");
		efl &= ~X86_EFLAGS_PRIOR_NT;
	}
	if (efl & X86_EFLAGS_RESET_OF) {
		flags.emplace_back("RESET_OF");
		efl &= ~X86_EFLAGS_RESET_OF;
	}
	if (efl & X86_EFLAGS_RESET_CF) {
		flags.emplace_back("RESET_CF");
		efl &= ~X86_EFLAGS_RESET_CF;
	}
	if (efl & X86_EFLAGS_RESET_DF) {
		flags.emplace_back("RESET_DF");
		efl &= ~X86_EFLAGS_RESET_DF;
	}
	if (efl & X86_EFLAGS_RESET_IF) {
		flags.emplace_back("RESET_IF");
		efl &= ~X86_EFLAGS_RESET_IF;
	}
	if (efl & X86_EFLAGS_RESET_SF) {
		flags.emplace_back("RESET_SF");
		efl &= ~X86_EFLAGS_RESET_SF;
	}
	if (efl & X86_EFLAGS_RESET_AF) {
		flags.emplace_back("RESET_AF");
		efl &= ~X86_EFLAGS_RESET_AF;
	}
	if (efl & X86_EFLAGS_RESET_TF) {
		flags.emplace_back("RESET_TF");
		efl &= ~X86_EFLAGS_RESET_TF;
	}
	if (efl & X86_EFLAGS_RESET_NT) {
		flags.emplace_back("RESET_NT");
		efl &= ~X86_EFLAGS_RESET_NT;
	}
	if (efl & X86_EFLAGS_RESET_PF) {
		flags.emplace_back("RESET_PF");
		efl &= ~X86_EFLAGS_RESET_PF;
	}
	if (efl & X86_EFLAGS_SET_CF) {
		flags.emplace_back("SET_CF");
		efl &= ~X86_EFLAGS_SET_CF;
	}
	if (efl & X86_EFLAGS_SET_DF) {
		flags.emplace_back("SET_DF");
		efl &= ~X86_EFLAGS_SET_DF;
	}
	if (efl & X86_EFLAGS_SET_IF) {
		flags.emplace_back("SET_IF");
		efl &= ~X86_EFLAGS_SET_IF;
	}
	if (efl & X86_EFLAGS_TEST_OF) {
		flags.emplace_back("TEST_OF");
		efl &= ~X86_EFLAGS_TEST_OF;
	}
	if (efl & X86_EFLAGS_TEST_SF) {
		flags.emplace_back("TEST_SF");
		efl &= ~X86_EFLAGS_TEST_SF;
	}
	if (efl & X86_EFLAGS_TEST_ZF) {
		flags.emplace_back("TEST_ZF");
		efl &= ~X86_EFLAGS_TEST_ZF;
	}
	if (efl & X86_EFLAGS_TEST_PF) {
		flags.emplace_back("TEST_PF");
		efl &= ~X86_EFLAGS_TEST_PF;
	}
	if (efl & X86_EFLAGS_TEST_CF) {
		flags.emplace_back("TEST_CF");
		efl &= ~X86_EFLAGS_TEST_CF;
	}
	if (efl & X86_EFLAGS_TEST_NT) {
		flags.emplace_back("TEST_NT");
		efl &= ~X86_EFLAGS_TEST_NT;
	}
	if (efl & X86_EFLAGS_TEST_DF) {
		flags.emplace_back("TEST_DF");
		efl &= ~X86_EFLAGS_TEST_DF;
	}
	if (efl & X86_EFLAGS_UNDEFINED_OF) {
		flags.emplace_back("UNDEFINED_OF");
		efl &= ~X86_EFLAGS_UNDEFINED_OF;
	}
	if (efl & X86_EFLAGS_UNDEFINED_SF) {
		flags.emplace_back("UNDEFINED_SF");
		efl &= ~X86_EFLAGS_UNDEFINED_SF;
	}
	if (efl & X86_EFLAGS_UNDEFINED_ZF) {
		flags.emplace_back("UNDEFINED_ZF");
		efl &= ~X86_EFLAGS_UNDEFINED_ZF;
	}
	if (efl & X86_EFLAGS_UNDEFINED_PF) {
		flags.emplace_back("UNDEFINED_PF");
		efl &= ~X86_EFLAGS_UNDEFINED_PF;
	}
	if (efl & X86_EFLAGS_UNDEFINED_AF) {
		flags.emplace_back("UNDEFINED_AF");
		efl &= ~X86_EFLAGS_UNDEFINED_AF;
	}
	if (efl & X86_EFLAGS_UNDEFINED_CF) {
		flags.emplace_back("UNDEFINED_CF");
		efl &= ~X86_EFLAGS_UNDEFINED_CF;
	}

	if (efl) {
		flags.emplace_back(toHex(efl));
	}
	return flags;
}
#endif

#if defined(EDB_ARM32)
/**
 * @brief printCond
 * @param cc
 * @return
 */
std::string printCond(arm_cc cc) {
	static const std::map<arm_cc, const char *> types{
		{ARM_CC_INVALID, "invalid"},
		{ARM_CC_EQ, "EQ"},
		{ARM_CC_NE, "NE"},
		{ARM_CC_HS, "HS"},
		{ARM_CC_LO, "LO"},
		{ARM_CC_MI, "MI"},
		{ARM_CC_PL, "PL"},
		{ARM_CC_VS, "VS"},
		{ARM_CC_VC, "VC"},
		{ARM_CC_HI, "HI"},
		{ARM_CC_LS, "LS"},
		{ARM_CC_GE, "GE"},
		{ARM_CC_LT, "LT"},
		{ARM_CC_GT, "GT"},
		{ARM_CC_LE, "LE"},
		{ARM_CC_AL, "AL"},
	};

	const auto found = types.find(cc);
	if (found == types.end()) {
		return toHex(cc);
	}
	return found->second;
}
#endif

/**
 * @brief printOpType
 * @param op
 * @return
 */
std::string printOpType(const x86_op_type &op) {

	static const std::map<x86_op_type, const char *> types{
		{X86_OP_INVALID, "invalid"},
		{X86_OP_REG, "register"},
		{X86_OP_IMM, "immediate"},
		{X86_OP_MEM, "memory"},
	};

	const auto found = types.find(op);
	if (found == types.end()) {
		return toHex(op);
	}
	return found->second;
}

#if defined(EDB_ARM32)
/**
 * @brief printShiftType
 * @param op
 * @return
 */
std::string printShiftType(const arm_shifter &op) {

	static const std::map<arm_shifter, const char *> types{
		{ARM_SFT_INVALID, "invalid"},
		{ARM_SFT_ASR, "ASR"},
		{ARM_SFT_LSL, "LSL"},
		{ARM_SFT_LSR, "LSR"},
		{ARM_SFT_ROR, "ROR"},
		{ARM_SFT_RRX, "RRX"},
		{ARM_SFT_ASR_REG, "ASR with register"},
		{ARM_SFT_LSL_REG, "LSL with register"},
		{ARM_SFT_LSR_REG, "LSR with register"},
		{ARM_SFT_ROR_REG, "ROR with register"},
		{ARM_SFT_RRX_REG, "RRX with register"},
	};

	const auto found = types.find(op);
	if (found == types.end()) {
		return toHex(op);
	}
	return found->second;
}

/**
 * @brief printOpType
 * @param op
 * @return
 */
std::string printOpType(const arm_setend_type &op) {

	static const std::map<arm_setend_type, const char *> types{
		{ARM_SETEND_INVALID, "invalid"},
		{ARM_SETEND_BE, "BE"},
		{ARM_SETEND_LE, "LE"},
	};

	const auto found = types.find(op);
	if (found == types.end()) {
		return toHex(op);
	}
	return found->second;
}

/**
 * @brief printOpType
 * @param op
 * @return
 */
std::string printOpType(const arm_op_type &op) {

	static const std::map<arm_op_type, const char *> types{
		{ARM_OP_INVALID, "invalid"},
		{ARM_OP_REG, "register"},
		{ARM_OP_IMM, "immediate"},
		{ARM_OP_MEM, "memory"},
		{ARM_OP_FP, "floating-point"},
		{ARM_OP_CIMM, "C-Immediate"},
		{ARM_OP_PIMM, "P-Immediate"},
		{ARM_OP_SETEND, "operand for SETEND"},
		{ARM_OP_SYSREG, "MSR/MSR special register"},
	};

	const auto found = types.find(op);
	if (found == types.end()) {
		return toHex(op);
	}
	return found->second;
}
#endif

/**
 * @brief printAVX_Bcast
 * @param bc
 * @return
 */
std::string printAVX_Bcast(x86_avx_bcast bc) {

	static const std::map<x86_avx_bcast, const char *> types{
		{X86_AVX_BCAST_INVALID, "invalid"},
		{X86_AVX_BCAST_2, "{1to2}"},
		{X86_AVX_BCAST_4, "{1to4}"},
		{X86_AVX_BCAST_8, "{1to8}"},
		{X86_AVX_BCAST_16, "{1to16}"},
	};
	const auto found = types.find(bc);
	if (found == types.end()) {
		return toHex(bc);
	}
	return found->second;
}

#if CS_API_MAJOR >= 4
/**
 * @brief printAccessMode
 * @param mode
 * @return
 */
std::string printAccessMode(unsigned mode) {
	std::ostringstream str;

	if (mode & CS_AC_READ) {
		if (!str.str().empty()) {
			str << "+";
		}
		str << "read";
		mode &= ~CS_AC_READ;
	}

	if (mode & CS_AC_WRITE) {
		if (!str.str().empty()) {
			str << "+";
		}
		str << "write";
		mode &= ~CS_AC_WRITE;
	}

	if (mode) {
		if (!str.str().empty()) {
			str << "+";
		}
		str << toHex(mode);
	}

	const std::string string = str.str();
	if (string.empty()) {
		return "none";
	}

	return string;
}
#endif

/**
 * @brief normalizeOBJDUMP
 * @param text
 * @param bits
 * @return
 */
QString normalizeOBJDUMP(const QString &text, int bits) {
	auto parts = text.split('\t');
#if defined(EDB_X86) || defined(EDB_X86_64)
	if (parts.size() != 3) return text + " ; unexpected format";
#elif defined(EDB_ARM32)
	if (parts.size() < 3) return text + " ; unexpected format";
#else
	return text + " ; WARNING: InstructionInspector's normalization is not implemented for this arch";
#endif

	auto &addr   = parts[0];
	auto &bytes  = parts[1];
	auto &disasm = parts[2];
	addr         = addr.trimmed().toUpper();

	// left removes colon
	addr   = addr.left(addr.size() - 1).rightJustified(bits / 4, '0');
	bytes  = bytes.trimmed().toUpper();
	disasm = disasm.trimmed().replace(QRegExp("  +"), " ");

#if defined(EDB_ARM32)
	// ARM objdump prints instruction bytes as a word instead of separate bytes. We won't
	// change this format, but will align the disassembly.
	if (bytes.size() > 2)
		bytes = bytes.leftJustified(bytes.size() * 3 / 2 - 1);

	// operands and comments are separated by a one or more tabs on ARM
	for (unsigned i = 3; i < parts.size(); ++i)
		disasm += " " + parts[i];
#endif
	return addr + "   " + bytes + "   " + disasm;
}

/**
 * @brief runOBJDUMP
 * @param bytes
 * @param address
 * @return
 */
std::string runOBJDUMP(const std::vector<std::uint8_t> &bytes, edb::address_t address) {

	const std::string processName = "objdump";
	const auto bits               = edb::v1::debuggeeIs32Bit() ? 32 : 64;

	QTemporaryFile binary(QDir::tempPath() + "/edb_insn_inspector_temp_XXXXXX.bin");

	if (!binary.open()) {
		return "; Failed to create binary file";
	}

	const int size = bytes.size();

	if (binary.write(reinterpret_cast<const char *>(bytes.data()), size) != size) {
		return "; Failed to write to binary file";
	}

	binary.close();
	QProcess process;
	process.start(processName.c_str(), {
		"-D",
			"--target=binary",
#if defined(EDB_X86) || defined(EDB_X86_64)
			"--insn-width=15",
			"--architecture=i386" + QString(bits == 64 ? ":x86-64" : ""),
			"-M",
			"intel,"
			"intel-mnemonic",
#elif defined(EDB_ARM32)
								   "--insn-width=4",
								   "-m",
								   "arm",
								   edb::v1::debugger_core->cpuMode() == IDebugger::CpuMode::Thumb ? "-Mforce-thumb" : "-Mno-force-thumb",
#else
#error "Not implemented"
#endif
			"--adjust-vma=" + address.toPointerString(), binary.fileName()
	});

	if (process.waitForFinished()) {
		if (process.exitCode() != 0)
			return ("; got response: \"" + process.readAllStandardError() + "\"").constData();
		if (process.exitStatus() != QProcess::NormalExit)
			return "; process crashed";

		const auto output  = QString::fromUtf8(process.readAllStandardOutput()).split('\n');
		const auto addrStr = address.toHexString().toLower().replace(QRegExp("^0+"), "");

		QString result;
		for (auto &line : output) {
			if (line.contains(QRegExp("^ *" + addrStr + ":\t[^\t]+\t"))) {
				result = line;
				break;
			}
		}

		if (result.isEmpty()) {
			// Try truncating higher bits of address: some versions of objconv can't --adjust-vma to
			// 64-bit values even with --architecture=i386:x86-64 (namely, 32-bit binutils 2.26.20160125)
			if (bits == 64 && address > UINT32_MAX) {
				return runOBJDUMP(bytes, address & UINT32_MAX) + " ; WARNING: origin had to be truncated for objdump";
			}

			return ("; failed to find disassembly. stdout: \"" + output.join("\n") + "\"").toStdString();
		}

		return normalizeOBJDUMP(result, bits).toStdString();
	} else if (process.error() == QProcess::FailedToStart) {
		return "; Failed to start " + processName;
	}

	return "; Unknown error while running " + processName;
}

#if defined(EDB_X86) || defined(EDB_X86_64)
/**
 * @brief normalizeNDISASM
 * @param text
 * @param bits
 * @return
 */
QString normalizeNDISASM(const QString &text, int bits) {

	auto lines = text.split('\n');
	Q_ASSERT(!lines.isEmpty());
	auto parts = lines.takeFirst().replace(QRegExp("  +"), "\t").split('\t');

	if (parts.size() != 3)
		return text + " ; unexpected format 1";

	auto &addr   = parts[0];
	auto &bytes  = parts[1];
	auto &disasm = parts[2];

	addr  = addr.rightJustified(bits / 4, '0');
	bytes = bytes.trimmed();

	// connect the rest of lines to bytes
	for (auto &line : lines) {
		if (!line.contains(QRegExp("^ +-[0-9a-fA-F]+$"))) {
			return text + " ; unexpected format 2";
		}

		line = line.trimmed();
		bytes += line.rightRef(line.size() - 1); // remove leading '-'
	}

	bytes.replace(QRegExp("(..)"), "\\1 ");
	return addr + "   " + bytes.trimmed() + "   " + disasm.trimmed();
}

/**
 * @brief runNDISASM
 * @param bytes
 * @param address
 * @return
 */
std::string runNDISASM(const std::vector<std::uint8_t> &bytes, edb::address_t address) {

	const std::string processName = "ndisasm";
	const auto bits               = edb::v1::debuggeeIs32Bit() ? 32 : 64;

	QTemporaryFile binary(QDir::tempPath() + "/edb_insn_inspector_temp_XXXXXX.bin");

	if (!binary.open()) {
		return "; Failed to create binary file";
	}

	const int size = bytes.size();

	if (binary.write(reinterpret_cast<const char *>(bytes.data()), size) != size) {
		return "; Failed to write to binary file";
	}

	binary.close();
	QProcess process;
	process.start(processName.c_str(), {"-o", address.toPointerString(), "-b", std::to_string(bits).c_str(), binary.fileName()});

	if (process.waitForFinished()) {
		if (process.exitCode() != 0) {
			return ("; got response: \"" + process.readAllStandardError() + "\"").constData();
		}

		if (process.exitStatus() != QProcess::NormalExit) {
			return "; process crashed";
		}

		auto output    = QString::fromUtf8(process.readAllStandardOutput()).split('\n');
		QString result = output.takeFirst();

		for (auto &line : output) {
			if (line.contains(QRegExp("^ +-[0-9a-fA-F]+$"))) {
				result += "\n" + line;
			} else {
				break;
			}
		}

		return normalizeNDISASM(result, bits).toStdString();
	} else if (process.error() == QProcess::FailedToStart)
		return "; Failed to start " + processName;
	return "; Unknown error while running " + processName;
}

/**
 * @brief normalizeOBJCONV
 * @param text
 * @param bits
 * @return
 */
std::pair<QString, std::size_t /*insnLength*/> normalizeOBJCONV(const QString &text, int bits) {

	QRegExp expectedFormat("^ +([^;]+); ([0-9a-fA-F]+) _ (.*)");
	if (expectedFormat.indexIn(text, 0) == -1) {
		throw NormalizeFailure{};
	}

	const auto addr   = expectedFormat.cap(2).rightJustified(bits / 4, '0');
	auto bytes        = expectedFormat.cap(3).trimmed();
	const auto disasm = expectedFormat.cap(1).trimmed().replace(QRegExp("  +"), " ");
	const auto result = addr + "   " + bytes + "   " + disasm;

	bytes.replace(QRegExp("[^0-9a-fA-F]"), "");
	const std::size_t insnLength = bytes.length() / 2;
	return std::make_pair(result, insnLength);
}

/**
 * @brief runOBJCONV
 * @param bytes
 * @param address
 * @return
 */
std::string runOBJCONV(std::vector<std::uint8_t> bytes, edb::address_t address) {
	const std::string processName = "objconv";
	const auto bits               = edb::v1::debuggeeIs32Bit() ? 32 : 64;

	QString binaryFileName;
	{
		QTemporaryFile binary(QDir::tempPath() + "/edb_insn_inspector_temp_XXXXXX.bin");
		if (!binary.open()) {
			return "; Failed to create binary file";
		}

		{
#ifdef Q_OS_UNIX
			if (bits == 32) {
				struct FileData {
					Elf32_Ehdr elfHeader;
					Elf32_Phdr programHeader;
					Elf32_Shdr zerothSectionHeader = {};
					Elf32_Shdr codeSectionHeader;
					Elf32_Shdr stringTableSectionHeader;
					// start of zero fill + instruction
				} fileData;

				fileData.elfHeader = Elf32_Ehdr{
					{(unsigned char)ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3, ELFCLASS32, ELFDATA2LSB, EV_CURRENT},
					ET_EXEC,
					EM_386,
					EV_CURRENT,
					Elf32_Addr(address.toUint()),            // entry point
					offsetof(FileData, programHeader),       // program header table offset
					offsetof(FileData, zerothSectionHeader), // section header table offset
					0,                                       // flags
					sizeof(Elf32_Ehdr),                      // size of ELF header...
					sizeof(Elf32_Phdr),
					1, // number of program headers
					sizeof(Elf32_Shdr),
					3, // number of section headers (one for zeroth, another for ours,third string
					// table (which is only needed for objconv, not for correct ELF file))
					2 // string table index in section header table (could be SHN_UNDEF, but objconv is picky)
				};

				const edb::value32 insnAddr(address);

				// aligned on page boundary and one page before
				// Loading the file one page earlier to make it possible to have
				// code origin even at the beginning of actual page where ELF
				// header would otherwise be
				const auto pageSize         = 4096u;
				const edb::value32 fileAddr = (insnAddr & ~(pageSize - 1)) - pageSize;

				fileData.programHeader = Elf32_Phdr{
					PT_LOAD,
					0,                             // start of file is beginning of segment
					Elf32_Addr(fileAddr.toUint()), // vaddr of the segment
					0,                             // paddr of the segment, irrelevant
					2 * pageSize,                  // size of file image of the segment
					2 * pageSize,                  // size of memory image of the segment
					PF_R | PF_X,
					0 // no alignment requirements
				};

				fileData.codeSectionHeader = Elf32_Shdr{
					0, // index of name in string table
					SHT_PROGBITS,
					SHF_ALLOC | SHF_EXECINSTR,
					Elf32_Addr(address.toUint()),
					insnAddr - fileAddr, // section offset in file
					Elf32_Addr(bytes.size()),
					SHN_UNDEF, // sh_link
					0,         // sh_info
					0,         // alignment constraints: 0 or 1 mean unaligned
					0          // no fixed-size entries in this section
				};

				fileData.stringTableSectionHeader = Elf32_Shdr{
					0, // index of name in string table
					SHT_STRTAB,
					0,
					0,
					offsetof(FileData, zerothSectionHeader), // section offset in file: at the zeroth section header,
					// which starts with zeros
					1,         // single byte should be enough
					SHN_UNDEF, // sh_link
					0,         // sh_info
					0,         // alignment constraints: 0 or 1 mean unaligned
					0          // no fixed-size entries in this section
				};

				binary.write(reinterpret_cast<const char *>(&fileData), sizeof(fileData));
				binary.seek(insnAddr - fileAddr);
				binary.write(reinterpret_cast<const char *>(bytes.data()), bytes.size());
			} else if (bits == 64) {
				// FIXME: the file generated here is actually broken: I don't know why, but trying to run it will lead
				// to "Exec format error"
				struct FileData {
					Elf64_Ehdr elfHeader;
					Elf64_Phdr programHeader;
					Elf64_Shdr zerothSectionHeader = {};
					Elf64_Shdr codeSectionHeader;
					Elf64_Shdr stringTableSectionHeader;
					// start of zero fill + instruction
				} fileData;

				fileData.elfHeader = Elf64_Ehdr{
					{(unsigned char)ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3, ELFCLASS64, ELFDATA2LSB, EV_CURRENT},
					ET_EXEC,
					EM_386,
					EV_CURRENT,
					Elf64_Addr(address.toUint()),            // entry point
					offsetof(FileData, programHeader),       // program header table offset
					offsetof(FileData, zerothSectionHeader), // section header table offset
					0,                                       // flags
					sizeof(Elf64_Ehdr),                      // size of ELF header...
					sizeof(Elf64_Phdr),
					1, // number of program headers
					sizeof(Elf64_Shdr),
					3, // number of section headers (one for zeroth, another for ours,third string
					// table (which is only needed for objconv, not for correct ELF file))
					2 // string table index in section header table (could be SHN_UNDEF, but objconv is picky)
				};

				const edb::value64 insnAddr(address);
				// aligned on page boundary and one page before
				// Loading the file one page earlier to make it possible to have
				// code origin even at the beginning of actual page where ELF
				// header would otherwise be
				const auto pageSize         = 4096ull;
				const edb::value64 fileAddr = (insnAddr & ~(pageSize - 1)) - pageSize;

				fileData.programHeader = Elf64_Phdr{
					PT_LOAD,
					PF_R | PF_X,                   // NOTE: This field is placed differently than in Elf32_Phdr!!!
					0,                             // start of file is beginning of segment
					Elf64_Addr(fileAddr.toUint()), // vaddr of the segment
					0,                             // paddr of the segment, irrelevant
					2 * pageSize,                  // size of file image of the segment
					2 * pageSize,                  // size of memory image of the segment
					0                              // no alignment requirements
				};

				fileData.codeSectionHeader = Elf64_Shdr{
					0, // index of name in string table
					SHT_PROGBITS,
					SHF_ALLOC | SHF_EXECINSTR,
					Elf64_Addr(address.toUint()),
					insnAddr - fileAddr, // section offset in file
					bytes.size(),
					SHN_UNDEF, // sh_link
					0,         // sh_info
					0,         // alignment constraints: 0 or 1 mean unaligned
					0          // no fixed-size entries in this section
				};

				fileData.stringTableSectionHeader = Elf64_Shdr{
					0, // index of name in string table
					SHT_STRTAB,
					0,
					0,
					offsetof(FileData, zerothSectionHeader), // section offset in file: at the zeroth section header,
					// which starts with zeros
					1,         // single byte should be enough
					SHN_UNDEF, // sh_link
					0,         // sh_info
					0,         // alignment constraints: 0 or 1 mean unaligned
					0          // no fixed-size entries in this section
				};

				binary.write(reinterpret_cast<const char *>(&fileData), sizeof(fileData));
				binary.seek(insnAddr - fileAddr);
				binary.write(reinterpret_cast<const char *>(bytes.data()), bytes.size());
			} else {
				return "; " + std::to_string(bits) + " bit?.. Not implemented.";
			}
#endif
		}

		binary.close();
		binary.setPermissions(QFile::ExeOwner | QFile::ReadOwner | QFile::WriteOwner);
		// We have to destroy the QTemporaryFile object, otherwise for some reason we get
		// "Text file busy" when trying to run the binary. So will remove it manually.
		binary.setAutoRemove(false);
		binaryFileName = binary.fileName();
	}

	QProcess process;
	process.start(processName.c_str(), {"-fnasm", binaryFileName, "/dev/stdout"});

	const bool success = process.waitForFinished();
	QFile::remove(binaryFileName);

	if (success) {
		const auto output = process.readAllStandardOutput();
		const auto err    = process.readAllStandardError();

		if (process.exitCode() != 0) {
			return ("; got response: \"" + err + "\"").constData();
		}

		if (process.exitStatus() != QProcess::NormalExit) {
			return "; process crashed";
		}

		const auto lines = output.split('\n');
		QString result;
		enum class LookingFor { FunctionBegin,
								Instruction } mode = LookingFor::FunctionBegin;
		const auto addrFormatted                   = address.toHexString().toUpper().replace(QRegExp("^0+"), "");
		const auto addrTruncatedFormatted          = (address & UINT32_MAX).toHexString().toUpper().replace(QRegExp("^0+"), "");

		for (int L = 0; L < lines.size(); ++L) {
			const auto line = QString::fromUtf8(lines[L]);
			switch (mode) {
			case LookingFor::FunctionBegin:
				if (line.contains(QRegExp("^; Instruction set:"))) {
					result += line + '\n';
					continue;
				}

				if (line.contains(QRegExp("^SECTION.* execute"))) {
					mode = LookingFor::Instruction;
					continue;
				}
				break;
			case LookingFor::Instruction:
				if (line.startsWith("; ")) {
					// Filter useless notes
					if (line.contains("Function does not end with "))
						continue;
					if (line.contains("without relocation"))
						continue;

					result += line + '\n';
				}

				if (line.contains(QRegExp("  +[^;]+; 0*" + addrFormatted + " _")) || line.contains(QRegExp("  +[^;]+; 0*" + addrTruncatedFormatted + " _"))) { // XXX: objconv truncates all addresses to 32 bits
					try {
						QString normalized;
						std::size_t insnLength;
						std::tie(normalized, insnLength) = normalizeOBJCONV(line, bits);

						if (insnLength != bytes.size()) {
							// Avoid getting wrong "Instruction set: " print due to subsequent bytes possibly forming
							// some extended-ISA instruction
							bytes.resize(insnLength);
							return runOBJCONV(bytes, address);
						}

						result += normalized;
						return result.toStdString();
					} catch (NormalizeFailure &) {
						return "; !Failed to normalize\n" + QString::fromUtf8(output).toStdString();
					}
				}

				if (line.contains(QRegExp("^  +db "))) {
					auto lines = result.split('\n');
					for (int i = 0; i < result.size(); ++i)
						if (lines[i].startsWith("; Instruction set:")) {
							lines.removeAt(i);
							break;
						}
					return (lines.join("\n") + address.toHexString().toUpper() + "   " + line.trimmed()).toStdString();
				}
				break;
			}
		}

		return ("; Couldn't locate disassembly, stdout:\n\"" + output + "\"\nstderr:\n\"" + err + "\"").constData();
	} else if (process.error() == QProcess::FailedToStart) {
		return "; Failed to start " + processName;
	}

	return "; Unknown error while running " + processName;
}
#endif

}

class Disassembler {
private:
	csh csh_;
	cs_insn *insn_ = nullptr;

public:
	struct InitFailure {
		const char *error;
	};

	explicit Disassembler(cs_mode mode) {
		cs_err result = cs_open(
#if defined(EDB_X86) || defined(EDB_X86_64)
			CS_ARCH_X86
#elif defined(EDB_ARM32)
			CS_ARCH_ARM
#elif defined(EDB_ARM64)
			CS_ARCH_ARM64
#else
#error "What to pass to capstone?"
#endif
			,
			mode, &csh_);

		if (result != CS_ERR_OK) {
			throw InitFailure{cs_strerror(result)};
		}

		cs_option(csh_, CS_OPT_DETAIL, CS_OPT_ON);
		cs_option(csh_, CS_OPT_SYNTAX, edb::v1::config().syntax == Configuration::Syntax::Intel ? CS_OPT_SYNTAX_INTEL : CS_OPT_SYNTAX_ATT);
	}

	cs_insn *disassemble(const std::uint8_t *buf, std::size_t size, edb::address_t address) {
		if (insn_) {
			cs_free(insn_, 1);
		}

		if (cs_disasm(csh_, buf, size, address, 1, &insn_)) {
			return insn_;
		} else {
			return nullptr;
		}
	}

	~Disassembler() {
		if (insn_) {
			cs_free(insn_, 1);
		}

		cs_close(&csh_);
	}

	csh handle() const {
		return csh_;
	}
};

/**
 * @brief Plugin::Plugin
 * @param parent
 */
Plugin::Plugin(QObject *parent)
	: QObject(parent), menuAction_(new QAction("Inspect instruction (Capstone info)", this)) {

	connect(menuAction_, &QAction::triggered, this, [this](bool) {
		showDialog();
	});
}

/**
 * @brief Plugin::menu
 * @return
 */
QMenu *Plugin::menu(QWidget *) {
	return nullptr;
}

/**
 * @brief Plugin::cpuContextMenu
 * @return
 */
QList<QAction *> Plugin::cpuContextMenu() {
	return {menuAction_};
}

/**
 * @brief InstructionDialog::InstructionDialog
 * @param parent
 * @param f
 */
InstructionDialog::InstructionDialog(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	setWindowTitle("Instruction Inspector");
	address_ = edb::v1::cpu_selected_address();
	const cs_mode mode =
#if defined(EDB_X86) || defined(EDB_X86_64)
		edb::v1::debuggeeIs32Bit() ? CS_MODE_32 : CS_MODE_64
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
		// FIXME(ARM): we also have possible values:
		//	* CS_MODE_ARM,
		//	* CS_MODE_THUMB,
		//	* CS_MODE_MCLASS,
		//	* CS_MODE_V8,
		//	and need to select the right one. Also need to choose from
		//	* CS_MODE_LITTLE_ENDIAN and
		//	* CS_MODE_BIG_ENDIAN
		static_cast<cs_mode>((edb::v1::debugger_core->cpuMode() == IDebugger::CpuMode::Thumb ? CS_MODE_THUMB : CS_MODE_ARM) | CS_MODE_LITTLE_ENDIAN)
#else
#error "What value should mode have?"
#endif
		;

	disassembler_ = new Disassembler(mode);

	uint8_t buffer[edb::Instruction::MaxSize];
	if (const int bufSize = edb::v1::get_instruction_bytes(address_, buffer)) {

		insnBytes_      = std::vector<std::uint8_t>(buffer, buffer + bufSize);
		const auto insn = disassembler_->disassemble(buffer, bufSize, address_);
		insn_           = insn;
		tree_           = new QTreeWidget;
		layout_         = new QVBoxLayout;

		setLayout(layout_);
		layout_->addWidget(tree_);
		buttonCompare_ = new QPushButton("Compare disassemblers");
		layout_->addWidget(buttonCompare_);

		connect(buttonCompare_, &QPushButton::clicked, this, [this](bool) {
			compareDisassemblers();
		});

		tree_->setUniformRowHeights(true);
		tree_->setColumnCount(2);
		tree_->setHeaderLabels({"Field", "Value"});

		// Workaround for impossibility of default parameters in C++11 lambdas
		struct Add {
			QTreeWidget *const tree_;
			explicit Add(QTreeWidget *tree)
				: tree_(tree) {
			}

			void operator()(const QStringList &sl, QTreeWidgetItem *parent = nullptr) const {
				tree_->addTopLevelItem(new QTreeWidgetItem(parent, sl));
			}
		} add(tree_);

		if (!insn) {
			add({"Bad instruction", "Failed to disassemble instruction at address " + edb::v1::format_pointer(address_)});
			add({"Bytes", printBytes(&insnBytes_[0], insnBytes_.size()).c_str()});
		} else {
			add({"Address", toHex(insn->address).c_str()});
			add({"Bytes", printBytes(insn->bytes, insn->size).c_str()});
			add({"Mnemonic", insn->mnemonic});
			add({"Operands string", insn->op_str});

			const auto groupNames = getGroupNames(disassembler_->handle(), insn);
			add({"Groups"});
			auto *const groups = tree_->topLevelItem(tree_->topLevelItemCount() - 1);

			for (const auto &group : groupNames) {
				add({group.c_str()}, groups);
			}

			{
				add({"Regs implicitly read"});
				auto *const regsRead = tree_->topLevelItem(tree_->topLevelItemCount() - 1);
				for (int r = 0; r < insn->detail->regs_read_count; ++r) {
					add({printReg(disassembler_->handle(), insn->detail->regs_read[r]).c_str()}, regsRead);
				}
			}

			{
				add({"Regs implicitly written"});
				auto *const regsWritten = tree_->topLevelItem(tree_->topLevelItemCount() - 1);
				for (int r = 0; r < insn->detail->regs_write_count; ++r) {
					add({printReg(disassembler_->handle(), insn->detail->regs_write[r]).c_str()}, regsWritten);
				}
			}
#if defined(EDB_X86) || defined(EDB_X86_64)
			add({"Prefixes", printBytes(insn->detail->x86.prefix, sizeof(insn->detail->x86.prefix), false).c_str()});
			add({"Opcode", printBytes(insn->detail->x86.opcode, sizeof(insn->detail->x86.opcode)).c_str()});

			if (insn->detail->x86.rex) {
				add({"REX", printBytes(&insn->detail->x86.rex, 1).c_str()});
			}

			add({"AddrSize", std::to_string(+insn->detail->x86.addr_size).c_str()});
			add({"ModRM", printBytes(&insn->detail->x86.modrm, 1).c_str()});
			add({"SIB", printBytes(&insn->detail->x86.sib, 1).c_str()});

			auto *const sib = tree_->topLevelItem(tree_->topLevelItemCount() - 1);
			add({"Displacement", toHex(insn->detail->x86.disp, true).c_str()}, sib);

			add({"index", printReg(disassembler_->handle(), insn->detail->x86.sib_index, true).c_str()}, sib);
			add({"scale", std::to_string(+insn->detail->x86.sib_scale).c_str()}, sib);
			add({"base", printReg(disassembler_->handle(), insn->detail->x86.sib_base, true).c_str()}, sib);

#if CS_API_MAJOR >= 4
			if (insn->detail->x86.xop_cc) {
				add({"XOP condition", printXOP_CC(insn->detail->x86.xop_cc).c_str()});
			}
#endif
			if (insn->detail->x86.sse_cc) {
				add({"SSE condition", printSSE_CC(insn->detail->x86.sse_cc).c_str()});
			}
			if (insn->detail->x86.avx_cc) {
				add({"AVX condition", printAVX_CC(insn->detail->x86.avx_cc).c_str()});
			}

			add({"SAE", insn->detail->x86.avx_sae ? "yes" : "no"});

			if (insn->detail->x86.avx_rm) {
				add({"AVX rounding", printAVX_RM(insn->detail->x86.avx_rm).c_str()});
			}

#if CS_API_MAJOR >= 4
			const auto changedEflagsNames = getChangedEFLAGSNames(insn->detail->x86.eflags);
			add({"EFLAGS"});
			auto *const eflags = tree_->topLevelItem(tree_->topLevelItemCount() - 1);
			for (auto efl : changedEflagsNames) {
				add({efl.c_str()}, eflags);
			}
#endif
			add({"Operands"});
			auto *const operands = tree_->topLevelItem(tree_->topLevelItemCount() - 1);
			for (int op = 0; op < insn->detail->x86.op_count; ++op) {

				const auto &operand = insn->detail->x86.operands[op];
				add({("#" + std::to_string(op + 1)).c_str()}, operands);

				auto *const curOpItem = operands->child(op);
				add({"Type", printOpType(operand.type).c_str()}, curOpItem);

				switch (operand.type) {
				case X86_OP_REG:
					add({"Register", printReg(disassembler_->handle(), operand.reg).c_str()}, curOpItem);
					break;
				case X86_OP_IMM:
					add({"Immediate", toHex(operand.imm).c_str()}, curOpItem);
					break;
				case X86_OP_MEM:
					add({"Segment", printReg(disassembler_->handle(), operand.mem.segment, true).c_str()}, curOpItem);
					add({"Base", printReg(disassembler_->handle(), operand.mem.base, true).c_str()}, curOpItem);
					add({"Index", printReg(disassembler_->handle(), operand.mem.index, true).c_str()}, curOpItem);
					add({"Scale", std::to_string(operand.mem.scale).c_str()}, curOpItem);
					add({"Displacement", toHex(operand.mem.disp, true).c_str()}, curOpItem);
					break;
				default:
					break;
				}

				add({"Size", (std::to_string(operand.size * 8) + " bit").c_str()}, curOpItem);
#if CS_API_MAJOR >= 4
				add({"Access", printAccessMode(operand.access).c_str()}, curOpItem);
#endif
				if (operand.avx_bcast) {
					add({"AVX Broadcast", printAVX_Bcast(operand.avx_bcast).c_str()}, curOpItem);
				}

				add({"AVX opmask", (operand.avx_zero_opmask ? "zeroing" : "merging")}, curOpItem);
			}
#elif defined(EDB_ARM32)
			add({"User mode regs", insn->detail->arm.usermode ? "True" : "False"});
			add({"Vector size", std::to_string(insn->detail->arm.vector_size).c_str()});
			// TODO: vector_data
			// TODO: cps_mode
			// TODO: cps_flag
			add({"Condition", printCond(insn->detail->arm.cc).c_str()});
			add({"Updates flags", insn->detail->arm.update_flags ? "True" : "False"});
			add({"Write-back", insn->detail->arm.writeback ? "True" : "False"});

			// TODO: mem_barrier
			add({"Operands"});

			auto *const operands = tree_->topLevelItem(tree_->topLevelItemCount() - 1);

			for (int op = 0; op < insn->detail->arm.op_count; ++op) {
				const auto &operand = insn->detail->arm.operands[op];
				add({("#" + std::to_string(op + 1)).c_str()}, operands);
				auto *const curOpItem = operands->child(op);

				if (operand.vector_index != -1) {
					add({"Vector index", std::to_string(operand.vector_index).c_str()}, curOpItem);
				}

				if (operand.shift.type) {
					add({"Shift type", printShiftType(operand.shift.type).c_str()}, curOpItem);
					add({"Shift", std::to_string(operand.shift.value).c_str()}, curOpItem);
				}

				add({"Type", printOpType(operand.type).c_str()}, curOpItem);

				switch (operand.type) {
				case ARM_OP_SYSREG:
				case ARM_OP_REG:
					add({"Register", printReg(disassembler_->handle(), operand.reg).c_str()}, curOpItem);
					break;
				case ARM_OP_CIMM:
				case ARM_OP_PIMM:
				case ARM_OP_IMM:
					add({"Immediate", toHex(util::to_unsigned(operand.imm)).c_str()}, curOpItem);
					break;
				case ARM_OP_FP:
					add({"Float", toFloatString(operand.fp).c_str()}, curOpItem);
					break;
				case ARM_OP_MEM:
					add({"Base", printReg(disassembler_->handle(), operand.mem.base, true).c_str()}, curOpItem);
					add({"Index", printReg(disassembler_->handle(), operand.mem.index, true).c_str()}, curOpItem);
					add({"Scale", std::to_string(operand.mem.scale).c_str()}, curOpItem);
					add({"Displacement", toHex(operand.mem.disp, true).c_str()}, curOpItem);
#if CS_API_MAJOR >= 4
					add({"Left shift", std::to_string(operand.mem.lshift).c_str()}, curOpItem);
#endif
					break;
				case ARM_OP_SETEND:
					add({"Type", printOpType(operand.setend).c_str()}, curOpItem);
					break;
				}

				add({"Subtracted", operand.subtracted ? "True" : "False"}, curOpItem);
#if CS_API_MAJOR >= 4
				add({"Access", printAccessMode(operand.access).c_str()}, curOpItem);
				if (operand.neon_lane != -1) {
					add({"NEON lane", std::to_string(operand.neon_lane).c_str()}, curOpItem);
				}
#endif
			}
#endif
		}

		tree_->expandAll();
		tree_->resizeColumnToContents(0);
	} else {
		QMessageBox::critical(
			edb::v1::debugger_ui,
			tr("Error reading instruction"),
			tr("Failed to read instruction at address %1").arg(edb::v1::format_pointer(address_)));
		throw InstructionReadFailure{};
	}
}

/**
 * @brief InstructionDialog::compareDisassemblers
 */
void InstructionDialog::compareDisassemblers() {

	std::ostringstream message;
	message << "capstone:\n";

	if (const auto insn = static_cast<cs_insn *>(insn_)) {
		message << address_.toHexString().toUpper().toStdString()
				<< "   " << printBytes(insn->bytes, insn->size)
				<< "   " << insn->mnemonic << " " << insn->op_str;
	} else {
		message << address_.toHexString().toUpper().toStdString()
				<< "   " << printBytes(insnBytes_.data(), 1)
				<< "   db " << toHex(insnBytes_[0]);
	}

#if defined(EDB_X86) || defined(EDB_X86_64)
	message << "\n\n";
	message << "ndisasm:\n";
	message << runNDISASM(insnBytes_, address_);
#endif
	message << "\n\n";
	message << "objdump:\n";
	message << runOBJDUMP(insnBytes_, address_);
#if defined(EDB_X86) || defined(EDB_X86_64)
	message << "\n\n";
	message << "objconv:\n";
	message << runOBJCONV(insnBytes_, address_);
#endif

	buttonCompare_->deleteLater();

	constexpr int initialTextBrowserSize = 200;
	auto splitter                        = new QSplitter(this);
	splitter->setOrientation(Qt::Vertical);
	splitter->addWidget(tree_);
	splitter->addWidget(disassemblies_ = new QTextBrowser);
	splitter->setSizes({height() - initialTextBrowserSize, initialTextBrowserSize});
	layout_->addWidget(splitter);

	QFont font(disassemblies_->font());
	font.setStyleHint(QFont::TypeWriter);
	font.setFamily("Monospace");

	disassemblies_->setFont(font);
	disassemblies_->setText(message.str().c_str());
}

/**
 * @brief InstructionDialog::~InstructionDialog
 */
InstructionDialog::~InstructionDialog() {
	delete disassembler_;
}

/**
 * @brief Plugin::showDialog
 */
void Plugin::showDialog() const {
	try {
		const auto dialog = new InstructionDialog(edb::v1::debugger_ui);
		dialog->setAttribute(Qt::WA_DeleteOnClose);
		dialog->resize(800, 500); // TODO: make it depend on size hints
		dialog->show();
	} catch (Disassembler::InitFailure &ex) {
		QMessageBox::critical(
			edb::v1::debugger_ui,
			tr("Capstone error"),
			tr("Failed to initialize Capstone: %1").arg(ex.error));
	} catch (...) {
	}
}

}

```

`plugins/InstructionInspector/Plugin.h`:

```h
/*
Copyright (C) 2016 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef INSTRUCTION_INSPECTOR_PLUGIN_H_20160418_
#define INSTRUCTION_INSPECTOR_PLUGIN_H_20160418_

#include "IPlugin.h"
#include "edb.h"
#include <QDialog>
#include <vector>

class QTreeWidget;
class QPushButton;
class QVBoxLayout;
class QTextBrowser;

namespace InstructionInspector {

class Disassembler;

class InstructionDialog : public QDialog {
	Q_OBJECT

public:
	struct DisassemblyFailure {};
	struct InstructionReadFailure {};

public:
	explicit InstructionDialog(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~InstructionDialog() override;

private Q_SLOTS:
	void compareDisassemblers();

private:
	QTreeWidget *tree_           = nullptr;
	QPushButton *buttonCompare_  = nullptr;
	QVBoxLayout *layout_         = nullptr;
	QTextBrowser *disassemblies_ = nullptr;
	void *insn_                  = nullptr;
	Disassembler *disassembler_  = nullptr;
	edb::address_t address_;
	std::vector<std::uint8_t> insnBytes_;
};

class Plugin : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Ruslan Kabatsayev")
	Q_CLASSINFO("email", "b7.10110111@gmail.com")

public:
	explicit Plugin(QObject *parent = nullptr);
	QMenu *menu(QWidget *parent = nullptr) override;
	QList<QAction *> cpuContextMenu() override;

private:
	void showDialog() const;

private:
	QAction *menuAction_ = nullptr;
};

}

#endif

```

`plugins/ODbgRegisterView/BitFieldDescription.cpp`:

```cpp

#include "BitFieldDescription.h"
#include <QString>

namespace ODbgRegisterView {

BitFieldDescription::BitFieldDescription(int textWidth, const std::vector<QString> &valueNames, const std::vector<QString> &setValueTexts, const std::function<bool(unsigned, unsigned)> &valueEqualComparator)
	: textWidth(textWidth), valueNames(valueNames), setValueTexts(setValueTexts), valueEqualComparator(valueEqualComparator) {
}

}

```

`plugins/ODbgRegisterView/BitFieldDescription.h`:

```h

#ifndef BIT_FIELD_DESCRIPTION_H_20191119_
#define BIT_FIELD_DESCRIPTION_H_20191119_

#include <functional>
#include <vector>

class QString;

namespace ODbgRegisterView {

struct BitFieldDescription {
	int textWidth;
	std::vector<QString> valueNames;
	std::vector<QString> setValueTexts;
	std::function<bool(unsigned, unsigned)> const valueEqualComparator;

	BitFieldDescription(
		int textWidth, const std::vector<QString> &valueNames, const std::vector<QString> &setValueTexts, const std::function<bool(unsigned, unsigned)> &valueEqualComparator = [](unsigned a, unsigned b) { return a == b; });
};

}

#endif

```

`plugins/ODbgRegisterView/BitFieldFormatter.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "BitFieldFormatter.h"
#include "BitFieldDescription.h"
#include "RegisterView.h"

namespace ODbgRegisterView {

BitFieldFormatter::BitFieldFormatter(const BitFieldDescription &bfd)
	: valueNames(bfd.valueNames) {
}

QString BitFieldFormatter::operator()(const QString &str) const {
	assert(str.length());
	if (str.isEmpty()) {
		return str; // for release builds have defined behavior
	}

	if (str[0] == '?') {
		return "????";
	}

	bool parseOK    = false;
	const int value = str.toInt(&parseOK);
	if (!parseOK) {
		return "????";
	}

	assert(0 <= value);
	assert(std::size_t(value) < valueNames.size());
	return valueNames[value];
}

}

```

`plugins/ODbgRegisterView/BitFieldFormatter.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef BIT_FIELD_FORMATTER_H_20191119_
#define BIT_FIELD_FORMATTER_H_20191119_

#include <QString>
#include <vector>

namespace ODbgRegisterView {

struct BitFieldDescription;

class BitFieldFormatter {
public:
	explicit BitFieldFormatter(const BitFieldDescription &bfd);
	QString operator()(const QString &text) const;

private:
	std::vector<QString> valueNames;
};

}

#endif

```

`plugins/ODbgRegisterView/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "ODbgRegisterView")

find_package(Qt5 5.0.0 REQUIRED Widgets)

set(PluginSources
	BitFieldDescription.cpp
	BitFieldDescription.h
	BitFieldFormatter.cpp
	BitFieldFormatter.h
	Canvas.cpp
	Canvas.h
	DialogEditGPR.cpp
	DialogEditGPR.h
	DialogEditSimdRegister.cpp
	DialogEditSimdRegister.h
	EntryGridKeyUpDownEventFilter.cpp
	EntryGridKeyUpDownEventFilter.h
	FieldWidget.cpp
	FieldWidget.h
	FpuValueField.h
	GprEdit.cpp
	GprEdit.h
	MultiBitFieldWidget.cpp
	MultiBitFieldWidget.h
	NumberEdit.cpp
	NumberEdit.h
	ODbgRV_Common.h
	ODbgRV_Util.h	
	Plugin.cpp
	Plugin.h
	RegisterGroup.cpp
	RegisterGroup.h
	RegisterView.cpp
	RegisterView.h
	SimdValueManager.cpp
	SimdValueManager.h
	ValueField.cpp
	ValueField.h
	VolatileNameField.cpp
	VolatileNameField.h
)

if(TARGET_ARCH_FAMILY_X86)

	set(PLUGIN_INCLUDES
		arch/x86-generic
	)
	
	set(PluginSources
		${PluginSources}
		arch/x86-generic/x86Groups.cpp
		arch/x86-generic/x86Groups.h
		arch/x86-generic/x86FPUValueField.cpp
		arch/x86-generic/Float80Edit.cpp
		arch/x86-generic/Float80Edit.h
		arch/x86-generic/DialogEditFPU.cpp
		arch/x86-generic/DialogEditFPU.h
		arch/x86-generic/ODbgRV_x86Common.h
	)
elseif(TARGET_ARCH_FAMILY_ARM)

	set(PLUGIN_INCLUDES
		arch/arm-generic
	)

	set(PluginSources
		${PluginSources}
		arch/arm-generic/armGroups.cpp
		arch/arm-generic/armGroups.h
	)
endif()

add_library(${PluginName} SHARED ${PluginSources})

target_include_directories(${PluginName} PRIVATE
	${CMAKE_CURRENT_SOURCE_DIR}
	${PLUGIN_INCLUDES}
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/ODbgRegisterView/Canvas.cpp`:

```cpp

#include "Canvas.h"
#include "ODbgRV_Util.h"

#include <QMouseEvent>
#include <QVBoxLayout>

namespace ODbgRegisterView {

Canvas::Canvas(QWidget *parent, Qt::WindowFlags f)
	: QWidget(parent, f) {

	setObjectName("RegViewCanvas");
	const auto canvasLayout = new QVBoxLayout(this);
	canvasLayout->setSpacing(letter_size(parent->font()).height() / 2);
	canvasLayout->setContentsMargins(parent->contentsMargins());
	canvasLayout->setAlignment(Qt::AlignTop);
	setLayout(canvasLayout);
	setBackgroundRole(QPalette::Base);
	setAutoFillBackground(true);
}

void Canvas::mousePressEvent(QMouseEvent *event) {
	event->ignore();
}

}

```

`plugins/ODbgRegisterView/Canvas.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef CANVAS_H_20151031_
#define CANVAS_H_20151031_

#include <QWidget>

namespace ODbgRegisterView {

class Canvas : public QWidget {
	Q_OBJECT
public:
	explicit Canvas(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());

protected:
	void mousePressEvent(QMouseEvent *event) override;
};

}

#endif

```

`plugins/ODbgRegisterView/DialogEditGPR.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogEditGPR.h"
#include "EntryGridKeyUpDownEventFilter.h"
#include "GprEdit.h"
#include "util/Container.h"

#include <QDebug>
#include <QDialogButtonBox>
#include <QGridLayout>
#include <QLabel>
#include <cmath>
#include <cstring>
#include <tuple>
#include <type_traits>

namespace ODbgRegisterView {

DialogEditGPR::DialogEditGPR(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	setWindowTitle(tr("Modify Register"));
	setModal(true);
	const auto allContentsGrid = new QGridLayout();

	// Register name labels
	for (std::size_t c = 0; c < ENTRY_COLS; ++c) {
		auto &label = columnLabel(static_cast<Column>(FIRST_ENTRY_COL + c));
		label       = new QLabel(this);
		label->setAlignment(Qt::AlignCenter);
		allContentsGrid->addWidget(label, GPR_LABELS_ROW, FIRST_ENTRY_COL + c);
	}

	{
		static const auto formatNames = util::make_array(tr("Hexadecimal"), tr("Signed"), tr("Unsigned"), tr("Character"));
		// Format labels
		for (std::size_t f = 0; f < formatNames.size(); ++f) {
			auto &label = rowLabel(static_cast<Row>(FIRST_ENTRY_ROW + f));
			label       = new QLabel(formatNames[f], this);
			allContentsGrid->addWidget(label, FIRST_ENTRY_ROW + f, FORMAT_LABELS_COL);
		}
	}

	// All entries but char
	{
		static const auto offsetsInInteger = util::make_array<std::size_t>(0u, 0u, 0u, 1u, 0u);
		static const auto integerSizes     = util::make_array<std::size_t>(8u, 4u, 2u, 1u, 1u);
		static_assert(std::tuple_size<decltype(integerSizes)>::value == DialogEditGPR::ENTRY_COLS, "integerSizes length doesn't equal ENTRY_COLS");
		static_assert(std::tuple_size<decltype(offsetsInInteger)>::value == DialogEditGPR::ENTRY_COLS, "offsetsInInteger length doesn't equal ENTRY_COLS");
		static const auto formats = util::make_array(GprEdit::Format::Hex, GprEdit::Format::Signed, GprEdit::Format::Unsigned);
		for (std::size_t f = 0; f < formats.size(); ++f) {
			for (std::size_t c = 0; c < ENTRY_COLS; ++c) {
				auto &entry = this->entry(static_cast<Row>(FIRST_ENTRY_ROW + f), static_cast<Column>(FIRST_ENTRY_COL + c));
				entry       = new GprEdit(offsetsInInteger[c], integerSizes[c], formats[f], this);
				connect(entry, &GprEdit::textEdited, this, &DialogEditGPR::onTextEdited);
				entry->installEventFilter(this);
				allContentsGrid->addWidget(entry, FIRST_ENTRY_ROW + f, FIRST_ENTRY_COL + c);
			}
		}
	}

	// High byte char
	{
		auto &charHigh = entry(CHAR_ROW, GPR8H_COL);
		charHigh       = new GprEdit(1, 1, GprEdit::Format::Character, this);
		connect(charHigh, &GprEdit::textEdited, this, &DialogEditGPR::onTextEdited);
		charHigh->installEventFilter(this);
		allContentsGrid->addWidget(charHigh, CHAR_ROW, GPR8H_COL);
	}

	// Low byte char
	{
		auto &charLow = entry(CHAR_ROW, GPR8L_COL);
		charLow       = new GprEdit(0, 1, GprEdit::Format::Character, this);
		connect(charLow, &GprEdit::textEdited, this, &DialogEditGPR::onTextEdited);
		charLow->installEventFilter(this);
		allContentsGrid->addWidget(charLow, CHAR_ROW, GPR8L_COL);
	}

	resetLayout();

	const auto okCancel = new QDialogButtonBox(this);
	okCancel->setStandardButtons(QDialogButtonBox::Cancel | QDialogButtonBox::Ok);
	connect(okCancel, &QDialogButtonBox::accepted, this, &DialogEditGPR::accept);
	connect(okCancel, &QDialogButtonBox::rejected, this, &DialogEditGPR::reject);

	const auto dialogLayout = new QVBoxLayout(this);
	dialogLayout->addLayout(allContentsGrid);
	dialogLayout->addWidget(okCancel);

	for (std::size_t entry = 1; entry < entries_.size(); ++entry) {
		setTabOrder(entries_[entry - 1], entries_[entry]);
	}
}

GprEdit *&DialogEditGPR::entry(DialogEditGPR::Row row, DialogEditGPR::Column col) {

	if (row < ENTRY_ROWS)
		return entries_.at((row - FIRST_ENTRY_ROW) * ENTRY_COLS + (col - FIRST_ENTRY_COL));
	if (col == GPR8H_COL)
		return *(entries_.end() - 2);
	if (col == GPR8L_COL)
		return entries_.back();

	Q_ASSERT("Invalid row&col specified" && 0);
	return entries_.front(); // silence the compiler
}

void DialogEditGPR::updateAllEntriesExcept(GprEdit *notUpdated) {

	for (auto entry : entries_) {
		if (entry != notUpdated && !entry->isHidden()) {
			entry->setGPRValue(value_);
		}
	}
}

QLabel *&DialogEditGPR::columnLabel(DialogEditGPR::Column col) {
	return labels_.at(col - FIRST_ENTRY_COL);
}

QLabel *&DialogEditGPR::rowLabel(DialogEditGPR::Row row) {
	return labels_.at(ENTRY_COLS + row - FIRST_ENTRY_ROW);
}

void DialogEditGPR::hideColumn(DialogEditGPR::Column col) {
	Row fMax = col == GPR8L_COL || col == GPR8H_COL ? ENTRY_ROWS : FULL_LENGTH_ROWS;
	for (std::size_t f = 0; f < fMax; ++f) {
		entry(static_cast<Row>(FIRST_ENTRY_ROW + f), col)->hide();
	}
	columnLabel(col)->hide();
}

void DialogEditGPR::hideRow(Row row) {
	rowLabel(row)->hide();
	if (row == CHAR_ROW) {
		entry(row, GPR8L_COL)->hide();
		entry(row, GPR8H_COL)->hide();
	} else {
		for (std::size_t c = 0; c < FULL_LENGTH_ROWS; ++c) {
			entry(row, static_cast<Column>(FIRST_ENTRY_COL + c))->hide();
		}
	}
}

void DialogEditGPR::resetLayout() {
	for (auto entry : entries_) {
		entry->show();
	}

	for (auto label : labels_) {
		label->show();
	}

	static const auto colLabelStrings = util::make_array("R?X", "E?X", "?X", "?H", "?L");
	static_assert(std::tuple_size<decltype(colLabelStrings)>::value == ENTRY_COLS, "Number of labels not equal to number of entry columns");

	for (std::size_t c = 0; c < ENTRY_COLS; ++c) {
		columnLabel(static_cast<Column>(GPR64_COL + c))->setText(colLabelStrings[c]);
	}
}

void DialogEditGPR::setupEntriesAndLabels() {

	resetLayout();

	switch (bitSize_) {
	case 8:
		hideColumn(GPR8H_COL);
		hideColumn(GPR16_COL);
		[[fallthrough]];
	case 16:
		hideColumn(GPR32_COL);
		[[fallthrough]];
	case 32:
		hideColumn(GPR64_COL);
		[[fallthrough]];
	case 64:
		break;
	default:
		Q_ASSERT("Unsupported bitSize" && 0);
	}

	const QString regName = reg_.name().toUpper();

	if (bitSize_ == 64)
		columnLabel(GPR64_COL)->setText(regName);
	else if (bitSize_ == 32)
		columnLabel(GPR32_COL)->setText(regName);
	else if (bitSize_ == 16)
		columnLabel(GPR16_COL)->setText(regName);
	else
		columnLabel(GPR8L_COL)->setText(regName);

	static const auto x86GPRsWithHighBytesAddressable    = util::make_array<QString>("EAX", "ECX", "EDX", "EBX", "RAX", "RCX", "RDX", "RBX");
	static const auto x86GPRsWithHighBytesNotAddressable = util::make_array<QString>("ESP", "EBP", "ESI", "EDI", "RSP", "RBP", "RSI", "RDI");
	static const auto upperGPRs64                        = util::make_array<QString>("R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15");

	bool x86GPR     = false;
	bool upperGPR64 = false;
	using util::contains;

	if (contains(x86GPRsWithHighBytesNotAddressable, regName)) {
		x86GPR = true;
		hideColumn(GPR8H_COL);
		if (bitSize_ == 32) {
			hideColumn(GPR8L_COL); // In 32 bit mode low bytes also can't be addressed
			hideRow(CHAR_ROW);
		}
	} else if (contains(x86GPRsWithHighBytesAddressable, regName)) {
		x86GPR = true;
	} else if (contains(upperGPRs64, regName)) {
		upperGPR64 = true;
	}

	if (x86GPR) {
		if (bitSize_ == 64) {
			columnLabel(GPR32_COL)->setText("E" + regName.mid(1));
		}

		columnLabel(GPR16_COL)->setText(regName.mid(1));
		columnLabel(GPR8H_COL)->setText(regName.mid(1, 1) + "H");

		if (bitSize_ == 64 && !contains(x86GPRsWithHighBytesAddressable, regName)) {
			columnLabel(GPR8L_COL)->setText(regName.mid(1) + "L");
		} else {
			columnLabel(GPR8L_COL)->setText(regName.mid(1, 1) + "L");
		}
	} else if (upperGPR64) {
		columnLabel(GPR32_COL)->setText(regName + "D");
		columnLabel(GPR16_COL)->setText(regName + "W");
		columnLabel(GPR8L_COL)->setText(regName + "B");
		hideColumn(GPR8H_COL);
	} else {
		// These have hex only format
		hideColumn(GPR8H_COL);

		if (bitSize_ != 8) {
			hideColumn(GPR8L_COL);
		}

		if (bitSize_ != 16) {
			hideColumn(GPR16_COL);
		}

		if (bitSize_ != 32) {
			hideColumn(GPR32_COL);
		}

		hideRow(SIGNED_ROW);
		hideRow(UNSIGNED_ROW);
		hideRow(CHAR_ROW);
	}
}

void DialogEditGPR::setupFocus() {
	for (auto entry : entries_) {
		if (!entry->isHidden()) {
			entry->setFocus(Qt::OtherFocusReason);
			break;
		}
	}
}

bool DialogEditGPR::eventFilter(QObject *obj, QEvent *event) {
	return entry_grid_key_event_filter(this, obj, event);
}

void DialogEditGPR::setValue(const Register &newReg) {
	reg_     = newReg;
	value_   = reg_.valueAsInteger();
	bitSize_ = reg_.bitSize();
	setupEntriesAndLabels();
	setWindowTitle(tr("Modify %1").arg(reg_.name().toUpper()));
	updateAllEntriesExcept(nullptr);
	setupFocus();
}

Register DialogEditGPR::value() const {
	Register ret(reg_);
	ret.setScalarValue(value_);
	return ret;
}

void DialogEditGPR::onTextEdited(const QString &) {
	auto edit = dynamic_cast<GprEdit *>(sender());
	edit->updateGPRValue(value_);
	updateAllEntriesExcept(edit);
}

}

```

`plugins/ODbgRegisterView/DialogEditGPR.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_EDIT_GPR_H_20151011_
#define DIALOG_EDIT_GPR_H_20151011_

#include "Register.h"
#include <QDialog>
#include <array>
#include <cstddef>
#include <cstdint>

class QLabel;

namespace ODbgRegisterView {

class GprEdit;

class DialogEditGPR : public QDialog {
	Q_OBJECT

public:
	explicit DialogEditGPR(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());

public:
	Register value() const;
	void setValue(const Register &reg);

private Q_SLOTS:
	void onTextEdited(const QString &);

private:
	enum Column {
		FORMAT_LABELS_COL,
		FIRST_ENTRY_COL,
		GPR64_COL = FIRST_ENTRY_COL,
		GPR32_COL,
		GPR16_COL,
		GPR8H_COL,
		GPR8L_COL,

		TOTAL_COLS,
		ENTRY_COLS = TOTAL_COLS - 1,
		CHAR_COLS  = 2
	};

	enum Row {
		GPR_LABELS_ROW,
		FIRST_ENTRY_ROW,
		HEX_ROW = FIRST_ENTRY_ROW,
		SIGNED_ROW,
		UNSIGNED_ROW,
		LAST_FULL_LENGTH_ROW = UNSIGNED_ROW,
		CHAR_ROW,

		ROW_AFTER_ENTRIES,

		FULL_LENGTH_ROWS = LAST_FULL_LENGTH_ROW - FIRST_ENTRY_ROW + 1,
		ENTRY_ROWS       = ROW_AFTER_ENTRIES - FIRST_ENTRY_ROW
	};

protected:
	bool eventFilter(QObject *, QEvent *) override;

private:
	void updateAllEntriesExcept(GprEdit *notUpdated);
	void hideColumn(Column col);
	void hideRow(Row row);
	void setupEntriesAndLabels();
	void resetLayout();
	QLabel *&columnLabel(Column col);
	QLabel *&rowLabel(Row row);
	GprEdit *&entry(Row row, Column col);
	void setupFocus();

private:
	std::array<QLabel *, ENTRY_COLS + ENTRY_ROWS> labels_                    = {{nullptr}};
	std::array<GprEdit *, FULL_LENGTH_ROWS *ENTRY_COLS + CHAR_COLS> entries_ = {{nullptr}};
	std::uint64_t value_;
	std::size_t bitSize_ = 0;
	Register reg_;
};

}

#endif

```

`plugins/ODbgRegisterView/DialogEditSimdRegister.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogEditSimdRegister.h"
#include "EntryGridKeyUpDownEventFilter.h"
#include "FloatX.h"
#include "NumberEdit.h"
#include "QLongValidator.h"
#include "QULongValidator.h"

#include <QApplication>
#include <QDebug>
#include <QDialogButtonBox>
#include <QGridLayout>
#include <QKeyEvent>
#include <QLabel>
#include <QLineEdit>
#include <QRadioButton>
#include <QRegExp>
#include <QRegExpValidator>
#include <cstring>
#include <limits>
#include <type_traits>

namespace ODbgRegisterView {

template <std::size_t NumEntries, class Func>
void DialogEditSimdRegister::setupEntries(const QString &label, std::array<NumberEdit *, NumEntries> &entries, int row, Func slot, int naturalWidthInChars) {

	auto contentsGrid = qobject_cast<QGridLayout *>(layout());

	contentsGrid->addWidget(new QLabel(label, this), row, ENTRIES_FIRST_COL - 1);
	for (std::size_t entryIndex = 0; entryIndex < NumEntries; ++entryIndex) {
		auto &entry             = entries[entryIndex];
		const int bytesPerEntry = NumBytes / NumEntries;
		entry                   = new NumberEdit(ENTRIES_FIRST_COL + bytesPerEntry * (NumEntries - 1 - entryIndex), bytesPerEntry, this);
		entry->setNaturalWidthInChars(naturalWidthInChars);
		connect(entry, &NumberEdit::textEdited, this, slot);
		entry->installEventFilter(this);
	}
}

DialogEditSimdRegister::DialogEditSimdRegister(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f),
	  byteHexValidator_(new QRegExpValidator(QRegExp("[0-9a-fA-F]{0,2}"), this)),
	  wordHexValidator_(new QRegExpValidator(QRegExp("[0-9a-fA-F]{0,4}"), this)),
	  dwordHexValidator_(new QRegExpValidator(QRegExp("[0-9a-fA-F]{0,8}"), this)),
	  qwordHexValidator_(new QRegExpValidator(QRegExp("[0-9a-fA-F]{0,16}"), this)),
	  byteSignedValidator_(new QLongValidator(INT8_MIN, INT8_MAX, this)),
	  wordSignedValidator_(new QLongValidator(INT16_MIN, INT16_MAX, this)),
	  dwordSignedValidator_(new QLongValidator(INT32_MIN, INT32_MAX, this)),
	  qwordSignedValidator_(new QLongValidator(INT64_MIN, INT64_MAX, this)),
	  byteUnsignedValidator_(new QULongValidator(0, UINT8_MAX, this)),
	  wordUnsignedValidator_(new QULongValidator(0, UINT16_MAX, this)),
	  dwordUnsignedValidator_(new QULongValidator(0, UINT32_MAX, this)),
	  qwordUnsignedValidator_(new QULongValidator(0, UINT64_MAX, this)),
	  float32Validator_(new FloatXValidator<float>(this)),
	  float64Validator_(new FloatXValidator<double>(this)),
	  intMode_(NumberDisplayMode::Hex) {

	setWindowTitle(tr("Edit SIMD Register"));
	setModal(true);
	const auto allContentsGrid = new QGridLayout(this);

	for (int byteIndex = 0; byteIndex < NumBytes; ++byteIndex) {
		columnLabels_[byteIndex] = new QLabel(std::to_string(byteIndex).c_str(), this);
		columnLabels_[byteIndex]->setAlignment(Qt::AlignCenter);
		allContentsGrid->addWidget(columnLabels_[byteIndex], BYTE_INDICES_ROW, ENTRIES_FIRST_COL + NumBytes - 1 - byteIndex);
	}

	setupEntries(
		tr("Byte"), bytes_, BYTES_ROW, [this]() {
			onByteEdited();
		},
		4);

	setupEntries(
		tr("Word"), words_, WORDS_ROW, [this]() {
			onWordEdited();
		},
		6);

	setupEntries(
		tr("Doubleword"), dwords_, DWORDS_ROW, [this]() {
			onDwordEdited();
		},
		11);
	setupEntries(
		tr("Quadword"), qwords_, QWORDS_ROW, [this]() {
			onQwordEdited();
		},
		21);
	setupEntries(
		tr("float32"), floats32_, FLOATS32_ROW, [this]() {
			onFloat32Edited();
		},
		14);
	setupEntries(
		tr("float64"), floats64_, FLOATS64_ROW, [this]() {
			onFloat64Edited();
		},
		24);

	for (const auto &entry : floats32_) {
		entry->setValidator(float32Validator_);
	}

	for (const auto &entry : floats64_) {
		entry->setValidator(float64Validator_);
	}

	hexSignOKCancelLayout_ = new QHBoxLayout();

	{
		const auto hexSignRadiosLayout = new QVBoxLayout();
		radioHex_                      = new QRadioButton(tr("Hexadecimal"), this);
		connect(radioHex_, &QRadioButton::toggled, this, &DialogEditSimdRegister::onHexToggled);
		// setChecked must be called after connecting of toggled()
		// in order to set validators for integer editors
		radioHex_->setChecked(true);

		hexSignRadiosLayout->addWidget(radioHex_);

		radioSigned_ = new QRadioButton(tr("Signed"), this);
		connect(radioSigned_, &QRadioButton::toggled, this, &DialogEditSimdRegister::onSignedToggled);
		hexSignRadiosLayout->addWidget(radioSigned_);

		radioUnsigned_ = new QRadioButton(tr("Unsigned"), this);
		connect(radioUnsigned_, &QRadioButton::toggled, this, &DialogEditSimdRegister::onUnsignedToggled);
		hexSignRadiosLayout->addWidget(radioUnsigned_);

		hexSignOKCancelLayout_->addLayout(hexSignRadiosLayout);
	}

	{
		const auto okCancelLayout = new QVBoxLayout();
		okCancelLayout->addItem(new QSpacerItem(20, 40, QSizePolicy::Minimum, QSizePolicy::Expanding));

		okCancel_ = new QDialogButtonBox(QDialogButtonBox::Cancel | QDialogButtonBox::Ok, Qt::Horizontal, this);
		connect(okCancel_, &QDialogButtonBox::accepted, this, &DialogEditSimdRegister::accept);
		connect(okCancel_, &QDialogButtonBox::rejected, this, &DialogEditSimdRegister::reject);
		okCancelLayout->addWidget(okCancel_);

		hexSignOKCancelLayout_->addLayout(okCancelLayout);
	}

	resetLayout();

	for (int byte = NumBytes - 1; byte > 0; --byte) {
		setTabOrder(bytes_[byte], bytes_[byte - 1]);
	}
	setTabOrder(bytes_.back(), words_.front());

	for (int word = NumBytes / 2 - 1; word > 0; --word) {
		setTabOrder(words_[word], words_[word - 1]);
	}
	setTabOrder(words_.back(), dwords_.front());

	for (int dword = NumBytes / 4 - 1; dword > 0; --dword) {
		setTabOrder(dwords_[dword], dwords_[dword - 1]);
	}
	setTabOrder(dwords_.back(), qwords_.front());

	for (int qword = NumBytes / 8 - 1; qword > 0; --qword) {
		setTabOrder(qwords_[qword], qwords_[qword - 1]);
	}
	setTabOrder(qwords_.back(), floats32_.front());

	for (int float32 = NumBytes / 4 - 1; float32 > 0; --float32) {
		setTabOrder(floats32_[float32], floats32_[float32 - 1]);
	}
	setTabOrder(floats32_.back(), floats64_.front());

	for (int float64 = NumBytes / 8 - 1; float64 > 0; --float64) {
		setTabOrder(floats64_[float64], floats64_[float64 - 1]);
	}
	setTabOrder(floats64_.front(), radioHex_);

	setTabOrder(radioHex_, radioSigned_);
	setTabOrder(radioSigned_, radioUnsigned_);
	setTabOrder(radioUnsigned_, okCancel_);
}

template <typename T>
void DialogEditSimdRegister::updateFloatEntries(const std::array<NumberEdit *, NumBytes / sizeof(T)> &entries, NumberEdit *notUpdated) {

	for (std::size_t i = 0; i < entries.size(); ++i) {
		if (entries[i] == notUpdated) {
			continue;
		}

		T value;
		std::memcpy(&value, &value_[i * sizeof(value)], sizeof(value));
		entries[i]->setText(format_float(value));
	}
}

template <typename T>
void DialogEditSimdRegister::updateIntegralEntries(const std::array<NumberEdit *, NumBytes / sizeof(T)> &entries, NumberEdit *notUpdated) {

	for (std::size_t i = 0; i < entries.size(); ++i) {
		if (entries[i] == notUpdated) {
			continue;
		}

		T value;
		std::memcpy(&value, &value_[i * sizeof(value)], sizeof(value));
		formatInteger(entries[i], value);
	}
}

void DialogEditSimdRegister::updateAllEntriesExcept(NumberEdit *notUpdated) {

	if (!reg_) {
		return;
	}

	updateIntegralEntries<std::uint8_t>(bytes_, notUpdated);
	updateIntegralEntries<std::uint16_t>(words_, notUpdated);
	updateIntegralEntries<std::uint32_t>(dwords_, notUpdated);
	updateIntegralEntries<std::uint64_t>(qwords_, notUpdated);
	updateFloatEntries<edb::value32>(floats32_, notUpdated);
	updateFloatEntries<edb::value64>(floats64_, notUpdated);
}

void DialogEditSimdRegister::resetLayout() {

	auto layout = qobject_cast<QGridLayout *>(this->layout());

	for (int col = ENTRIES_FIRST_COL; col < TOTAL_COLS; ++col) {
		int i = NumBytes - 1 - (col - ENTRIES_FIRST_COL);

		columnLabels_[i]->show();

		const auto &byte = bytes_[i];
		layout->addWidget(byte, BYTES_ROW, byte->column(), 1, byte->colSpan());
		byte->show();

		const auto &word = words_[i / 2];
		layout->addWidget(word, WORDS_ROW, word->column(), 1, word->colSpan());
		word->show();

		const auto &dword = dwords_[i / 4];
		layout->addWidget(dword, DWORDS_ROW, dword->column(), 1, dword->colSpan());
		dword->show();

		const auto &qword = qwords_[i / 8];
		layout->addWidget(qword, QWORDS_ROW, qword->column(), 1, qword->colSpan());
		qword->show();

		const auto &float32 = floats32_[i / 4];
		layout->addWidget(float32, FLOATS32_ROW, float32->column(), 1, float32->colSpan());
		float32->show();

		const auto &float64 = floats64_[i / 8];
		layout->addWidget(float64, FLOATS64_ROW, float64->column(), 1, float64->colSpan());
		float64->show();
	}

	for (int row = ENTRIES_FIRST_ROW; row < ROW_AFTER_ENTRIES; ++row)
		layout->itemAtPosition(row, LABELS_COL)->widget()->show();

	layout->removeItem(hexSignOKCancelLayout_);
	hexSignOKCancelLayout_->setParent(nullptr);
	layout->addLayout(hexSignOKCancelLayout_, ROW_AFTER_ENTRIES, ENTRIES_FIRST_COL, 1, NumBytes);
}

void DialogEditSimdRegister::hideColumns(EntriesCols afterLastToHide) {

	auto layout = qobject_cast<QGridLayout *>(this->layout());

	for (int col = ENTRIES_FIRST_COL; col < afterLastToHide; ++col) {
		int i = NumBytes - 1 - (col - ENTRIES_FIRST_COL);
		Q_ASSERT(0 < i && std::size_t(i) < bytes_.size());

		columnLabels_[i]->hide();

		// Spanned entries shouldn't just be hidden. If they are still in the grid,
		// then we get extra spacing between invisible columns, which is unwanted.
		// So we have to also remove them from the layout.
		layout->removeWidget(bytes_[i]);
		bytes_[i]->hide();

		layout->removeWidget(words_[i / 2]);
		words_[i / 2]->hide();

		layout->removeWidget(dwords_[i / 4]);
		dwords_[i / 4]->hide();

		layout->removeWidget(qwords_[i / 8]);
		qwords_[i / 8]->hide();

		layout->removeWidget(floats32_[i / 4]);
		floats32_[i / 4]->hide();

		layout->removeWidget(floats64_[i / 8]);
		floats64_[i / 8]->hide();
	}

	layout->removeItem(hexSignOKCancelLayout_);
	hexSignOKCancelLayout_->setParent(nullptr);
	layout->addLayout(hexSignOKCancelLayout_, ROW_AFTER_ENTRIES, afterLastToHide, 1, TOTAL_COLS - afterLastToHide);
}

void DialogEditSimdRegister::hideRows(EntriesRows rowToHide) {

	auto layout = qobject_cast<QGridLayout *>(this->layout());

	for (int col = 0; col < TOTAL_COLS; ++col) {
		const auto item = layout->itemAtPosition(rowToHide, col);
		if (item && item->widget()) {
			item->widget()->hide();
		}
	}
}

bool DialogEditSimdRegister::eventFilter(QObject *obj, QEvent *event) {
	return entry_grid_key_event_filter(this, obj, event);
}

void DialogEditSimdRegister::setValue(const Register &newReg) {
	resetLayout();
	assert(newReg.bitSize() <= 8 * sizeof(value_));
	reg_ = newReg;
	util::mark_memory(&value_, value_.size());
	if (QRegExp("mm[0-7]").exactMatch(reg_.name())) {
		const auto value = reg_.value<edb::value64>();
		std::memcpy(&value_, &value, sizeof(value));
		hideColumns(MMX_FIRST_COL);
		// MMX registers are never used in float computations, so hide useless rows
		hideRows(FLOATS32_ROW);
		hideRows(FLOATS64_ROW);
	} else if (QRegExp("xmm[0-9]+").exactMatch(reg_.name())) {
		const auto value = reg_.value<edb::value128>();
		std::memcpy(&value_, &value, sizeof(value));
		hideColumns(XMM_FIRST_COL);
	} else if (QRegExp("ymm[0-9]+").exactMatch(reg_.name())) {
		const auto value = reg_.value<edb::value256>();
		std::memcpy(&value_, &value, sizeof(value));
		hideColumns(YMM_FIRST_COL);
	} else
		qCritical() << "DialogEditSimdRegister::setValue(" << reg_.name() << "): register type unsupported";
	setWindowTitle(tr("Modify %1").arg(reg_.name().toUpper()));
	updateAllEntriesExcept(nullptr);
}

void DialogEditSimdRegister::set_current_element(RegisterViewModelBase::Model::ElementSize size, NumberDisplayMode format, int elementIndex) {
	using namespace RegisterViewModelBase;
	if (format != intMode_ && format != NumberDisplayMode::Float) {
		switch (format) {
		case NumberDisplayMode::Hex:
			radioHex_->setChecked(true);
			break;
		case NumberDisplayMode::Signed:
			radioSigned_->setChecked(true);
			break;
		case NumberDisplayMode::Unsigned:
			radioUnsigned_->setChecked(true);
			break;
		case NumberDisplayMode::Float:
			break; // silence the compiler, we'll never get here
		}
	}

	NumberEdit *edit = bytes_[0];

	if (format == NumberDisplayMode::Float) {
		edit = floats32_[0];
		if (size == Model::ElementSize::DWORD)
			edit = floats32_[elementIndex];
		else if (size == Model::ElementSize::QWORD)
			edit = floats64_[elementIndex];
	} else {
		switch (size) {
		case Model::ElementSize::BYTE:
			edit = bytes_[elementIndex];
			break;
		case Model::ElementSize::WORD:
			edit = words_[elementIndex];
			break;
		case Model::ElementSize::DWORD:
			edit = dwords_[elementIndex];
			break;
		case Model::ElementSize::QWORD:
			edit = qwords_[elementIndex];
			break;
		default:
			EDB_PRINT_AND_DIE("Unexpected size ", static_cast<long>(size));
		}
	}
	edit->setFocus(Qt::OtherFocusReason);
}

std::uint64_t DialogEditSimdRegister::readInteger(const NumberEdit *const edit) const {
	bool ok;
	switch (intMode_) {
	case NumberDisplayMode::Hex:
		return edit->text().toULongLong(&ok, 16);
	case NumberDisplayMode::Signed:
		return edit->text().toLongLong(&ok);
	case NumberDisplayMode::Unsigned:
		return edit->text().toULongLong(&ok);
	default:
		Q_ASSERT("Unexpected integer display mode" && 0);
		return 0xbadbadbadbadbad1;
	}
}

template <typename Integer>
void DialogEditSimdRegister::formatInteger(NumberEdit *const edit, Integer integer) const {
	switch (intMode_) {
	case NumberDisplayMode::Hex:
		edit->setText(QString("%1").arg(integer, 2 * sizeof(integer), 16, QChar('0')));
		break;
	case NumberDisplayMode::Signed:
		using Int    = typename std::remove_reference<Integer>::type;
		using Signed = typename std::make_signed<Int>::type;

		edit->setText(QString("%1").arg(static_cast<Signed>(integer)));
		break;
	case NumberDisplayMode::Unsigned:
		edit->setText(QString("%1").arg(integer));
		break;
	default:
		Q_ASSERT("Unexpected integer display mode" && 0);
		return;
	}
}

template <typename Integer>
void DialogEditSimdRegister::onIntegerEdited(QObject *sender, const std::array<NumberEdit *, NumBytes / sizeof(Integer)> &elements) {
	const auto changedElementEdit = qobject_cast<NumberEdit *>(sender);
	std::size_t elementIndex      = std::find(elements.begin(), elements.end(), changedElementEdit) - elements.begin();
	Integer value                 = readInteger(elements[elementIndex]);
	std::memcpy(&value_[elementIndex * sizeof(value)], &value, sizeof(value));
	updateAllEntriesExcept(elements[elementIndex]);
}

template <typename Float>
void DialogEditSimdRegister::onFloatEdited(QObject *sender, const std::array<NumberEdit *, NumBytes / sizeof(Float)> &elements) {
	const auto changedFloatEdit = qobject_cast<NumberEdit *>(sender);
	std::size_t floatIndex      = std::find(elements.begin(), elements.end(), changedFloatEdit) - elements.begin();
	bool ok                     = false;
	auto value                  = read_float<Float>(elements[floatIndex]->text(), ok);
	if (ok) {
		std::memcpy(&value_[floatIndex * sizeof(value)], &value, sizeof(value));
		updateAllEntriesExcept(elements[floatIndex]);
	}
}

void DialogEditSimdRegister::onByteEdited() {
	onIntegerEdited<std::uint8_t>(sender(), bytes_);
}

void DialogEditSimdRegister::onWordEdited() {
	onIntegerEdited<std::uint16_t>(sender(), words_);
}

void DialogEditSimdRegister::onDwordEdited() {
	onIntegerEdited<std::uint32_t>(sender(), dwords_);
}

void DialogEditSimdRegister::onQwordEdited() {
	onIntegerEdited<std::uint64_t>(sender(), qwords_);
}

void DialogEditSimdRegister::onFloat32Edited() {
	onFloatEdited<float>(sender(), floats32_);
}

void DialogEditSimdRegister::onFloat64Edited() {
	onFloatEdited<double>(sender(), floats64_);
}

void DialogEditSimdRegister::onHexToggled(bool checked) {
	if ((checked && intMode_ != NumberDisplayMode::Hex) || !bytes_.front()->validator()) {
		intMode_ = NumberDisplayMode::Hex;
		for (const auto &byte : bytes_)
			byte->setValidator(byteHexValidator_);
		for (const auto &word : words_)
			word->setValidator(wordHexValidator_);
		for (const auto &dword : dwords_)
			dword->setValidator(dwordHexValidator_);
		for (const auto &qword : qwords_)
			qword->setValidator(qwordHexValidator_);
		updateAllEntriesExcept(nullptr);
	}
}

void DialogEditSimdRegister::onSignedToggled(bool checked) {
	if ((checked && intMode_ != NumberDisplayMode::Signed) || !bytes_.front()->validator()) {
		intMode_ = NumberDisplayMode::Signed;
		for (const auto &byte : bytes_)
			byte->setValidator(byteSignedValidator_);
		for (const auto &word : words_)
			word->setValidator(wordSignedValidator_);
		for (const auto &dword : dwords_)
			dword->setValidator(dwordSignedValidator_);
		for (const auto &qword : qwords_)
			qword->setValidator(qwordSignedValidator_);
		updateAllEntriesExcept(nullptr);
	}
}

void DialogEditSimdRegister::onUnsignedToggled(bool checked) {
	if ((checked && intMode_ != NumberDisplayMode::Unsigned) || !bytes_.front()->validator()) {
		intMode_ = NumberDisplayMode::Unsigned;
		for (const auto &byte : bytes_)
			byte->setValidator(byteUnsignedValidator_);
		for (const auto &word : words_)
			word->setValidator(wordUnsignedValidator_);
		for (const auto &dword : dwords_)
			dword->setValidator(dwordUnsignedValidator_);
		for (const auto &qword : qwords_)
			qword->setValidator(qwordUnsignedValidator_);
		updateAllEntriesExcept(nullptr);
	}
}

Register DialogEditSimdRegister::value() const {
	Register out(reg_);
	out.setValueFrom(value_);
	return out;
}

}

```

`plugins/ODbgRegisterView/DialogEditSimdRegister.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_EDIT_SIMD_REGISTER_H_20151010_
#define DIALOG_EDIT_SIMD_REGISTER_H_20151010_

#include "Register.h"
#include "RegisterViewModelBase.h"
#include "Util.h"
#include <QDialog>
#include <array>
#include <cstddef>
#include <cstdint>

class QLabel;
class QDialogButtonBox;
class QHBoxLayout;
class QLongValidator;
class QRadioButton;
class QRegExpValidator;
class QULongValidator;
class QValidator;

namespace ODbgRegisterView {

class NumberEdit;

class DialogEditSimdRegister : public QDialog {
	Q_OBJECT

private:
	static constexpr int NumBytes = 256 / 8;

	enum EntriesRows {
		BYTE_INDICES_ROW,
		BYTES_ROW,
		ENTRIES_FIRST_ROW = BYTES_ROW,
		WORDS_ROW,
		DWORDS_ROW,
		QWORDS_ROW,
		FLOATS32_ROW,
		FLOATS64_ROW,

		ROW_AFTER_ENTRIES
	};

	enum EntriesCols {
		LABELS_COL,
		ENTRIES_FIRST_COL,
		YMM_FIRST_COL = ENTRIES_FIRST_COL,
		XMM_FIRST_COL = YMM_FIRST_COL + 16,
		MMX_FIRST_COL = XMM_FIRST_COL + 8,
		TOTAL_COLS    = MMX_FIRST_COL + 8
	};

public:
	explicit DialogEditSimdRegister(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	void setValue(const Register &value);
	void set_current_element(RegisterViewModelBase::Model::ElementSize size, NumberDisplayMode format, int elementIndex);
	Register value() const;

protected:
	bool eventFilter(QObject *, QEvent *) override;

private:
	template <std::size_t NumEntries, class Func>
	void setupEntries(const QString &label, std::array<NumberEdit *, NumEntries> &entries, int row, Func slot, int naturalWidthInChars);

	std::uint64_t readInteger(const NumberEdit *edit) const;

	template <typename Integer>
	void formatInteger(NumberEdit *edit, Integer integer) const;

	void updateAllEntriesExcept(NumberEdit *notUpdated);
	void hideColumns(EntriesCols preLast);
	void hideRows(EntriesRows rowToHide);
	void resetLayout();

private:
	template <typename Integer>
	void onIntegerEdited(QObject *sender, const std::array<NumberEdit *, NumBytes / sizeof(Integer)> &elements);

	template <typename Float>
	void onFloatEdited(QObject *sender, const std::array<NumberEdit *, NumBytes / sizeof(Float)> &elements);

	template <typename T>
	void updateIntegralEntries(const std::array<NumberEdit *, NumBytes / sizeof(T)> &entries, NumberEdit *notUpdated);

	template <typename T>
	void updateFloatEntries(const std::array<NumberEdit *, NumBytes / sizeof(T)> &entries, NumberEdit *notUpdated);

private Q_SLOTS:
	void onByteEdited();
	void onWordEdited();
	void onDwordEdited();
	void onQwordEdited();
	void onFloat32Edited();
	void onFloat64Edited();
	void onHexToggled(bool checked);
	void onSignedToggled(bool checked);
	void onUnsignedToggled(bool checked);

private:
	QHBoxLayout *hexSignOKCancelLayout_;
	QDialogButtonBox *okCancel_;
	QRadioButton *radioHex_;
	QRadioButton *radioSigned_;
	QRadioButton *radioUnsigned_;
	std::array<NumberEdit *, NumBytes / 8> floats64_;
	std::array<NumberEdit *, NumBytes / 4> floats32_;
	std::array<NumberEdit *, NumBytes / 8> qwords_;
	std::array<NumberEdit *, NumBytes / 4> dwords_;
	std::array<NumberEdit *, NumBytes / 2> words_;
	std::array<NumberEdit *, NumBytes> bytes_;
	std::array<QLabel *, NumBytes> columnLabels_;

	QRegExpValidator *byteHexValidator_;
	QRegExpValidator *wordHexValidator_;
	QRegExpValidator *dwordHexValidator_;
	QRegExpValidator *qwordHexValidator_;

	QLongValidator *byteSignedValidator_;
	QLongValidator *wordSignedValidator_;
	QLongValidator *dwordSignedValidator_;
	QLongValidator *qwordSignedValidator_;

	QULongValidator *byteUnsignedValidator_;
	QULongValidator *wordUnsignedValidator_;
	QULongValidator *dwordUnsignedValidator_;
	QULongValidator *qwordUnsignedValidator_;

	QValidator *float32Validator_;
	QValidator *float64Validator_;

	NumberDisplayMode intMode_;
	std::array<std::uint8_t, NumBytes> value_;
	Register reg_;
};

}

#endif

```

`plugins/ODbgRegisterView/EntryGridKeyUpDownEventFilter.cpp`:

```cpp
#include "EntryGridKeyUpDownEventFilter.h"

#include <QKeyEvent>
#include <QLineEdit>
#include <QWidget>
#include <algorithm>
#include <cassert>
#include <vector>

namespace ODbgRegisterView {

bool entry_grid_key_event_filter(QWidget *parent, QObject *obj, QEvent *event) {

	auto entry = qobject_cast<QLineEdit *>(obj);
	if (!entry || event->type() != QEvent::KeyPress) {
		return false;
	}

	auto keyEvent = static_cast<QKeyEvent *>(event);

	const auto key = keyEvent->key();
	if (key != Qt::Key_Up && key != Qt::Key_Down)
		return false;

	// subtraction of 1 from x prevents selection of entry to the right-top/bottom instead directly top/bottom
	const auto pos      = entry->pos() - QPoint(1, 0);
	const auto children = parent->findChildren<QLineEdit *>();

	// Find the neighbors above/below the current entry
	std::vector<QLineEdit *> neighbors;
	for (auto *const child : children) {
		if (!child->isVisible())
			continue;
		if (key == Qt::Key_Up && child->y() >= pos.y())
			continue;
		if (key == Qt::Key_Down && child->y() <= pos.y())
			continue;
		neighbors.emplace_back(child);
	}

	if (neighbors.empty()) {
		return false;
	}

	// Bring the vertically closest neighbors to the front
	const auto y = pos.y();
	std::sort(neighbors.begin(), neighbors.end(), [y](QLineEdit *a, QLineEdit *b) {
		return std::abs(y - a->y()) < std::abs(y - b->y());
	});

	// Remove those too far vertically, so that they don't interfere with later calculations
	const auto verticallyClosestY = neighbors.front()->y();
	neighbors.erase(std::remove_if(neighbors.begin(), neighbors.end(), [verticallyClosestY](QLineEdit *e) {
						return e->y() != verticallyClosestY;
					}),
					neighbors.end());

	assert(!neighbors.empty());
	const auto x            = pos.x();
	const auto bestNeighbor = *std::min_element(neighbors.begin(), neighbors.end(), [x](QLineEdit *a, QLineEdit *b) {
		return std::abs(x - a->x()) < std::abs(x - b->x());
	});

	bestNeighbor->setFocus(Qt::TabFocusReason);
	return true;
}

}

```

`plugins/ODbgRegisterView/EntryGridKeyUpDownEventFilter.h`:

```h

#ifndef ENTRY_GRID_KEY_UP_DOWN_EVENT_FILTER_H_20170705_
#define ENTRY_GRID_KEY_UP_DOWN_EVENT_FILTER_H_20170705_

class QWidget;
class QObject;
class QEvent;

namespace ODbgRegisterView {

bool entry_grid_key_event_filter(QWidget *parent, QObject *obj, QEvent *event);

}

#endif

```

`plugins/ODbgRegisterView/FieldWidget.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ODbgRV_Util.h"
#include "RegisterView.h"

namespace ODbgRegisterView {

QString FieldWidget::text() const {
	if (!index_.isValid() && !this->isEnabled())
		return QLabel::text();
	const auto text = index_.data();
	if (!text.isValid())
		return QString(width() / letter_size(font()).width() - 1, QChar('?'));
	return text.toString();
}

int FieldWidget::lineNumber() const {
	const auto charSize = letter_size(font());
	return field_position(this).y() / charSize.height();
}

int FieldWidget::columnNumber() const {
	const auto charSize = letter_size(font());
	return field_position(this).x() / charSize.width();
}

void FieldWidget::init(int fieldWidth) {
	setObjectName("FieldWidget");
	const auto charSize = letter_size(font());
	setFixedHeight(charSize.height());
	if (fieldWidth > 0)
		setFixedWidth(fieldWidth * charSize.width());
	setDisabled(true);
}

FieldWidget::FieldWidget(int fieldWidth, const QModelIndex &index, QWidget *parent, Qt::WindowFlags f)
	: QLabel("Fw???", parent, f), index_(index), fieldWidth_(fieldWidth) {

	init(fieldWidth);
}

FieldWidget::FieldWidget(int fieldWidth, const QString &fixedText, QWidget *parent, Qt::WindowFlags f)
	: QLabel(fixedText, parent, f), fieldWidth_(fieldWidth) {

	init(fieldWidth); // NOTE: fieldWidth!=fixedText.length() in general
}

FieldWidget::FieldWidget(const QString &fixedText, QWidget *parent, Qt::WindowFlags f)
	: QLabel(fixedText, parent, f), fieldWidth_(fixedText.length()) {

	init(fixedText.length());
}

int FieldWidget::fieldWidth() const {
	return fieldWidth_;
}

void FieldWidget::adjustToData() {
	QLabel::setText(text());
	adjustSize();
}

ODBRegView *FieldWidget::regView() const {
	const auto parent = parentWidget()        // group
							->parentWidget()  // canvas
							->parentWidget()  // viewport
							->parentWidget(); // regview

	return checked_cast<ODBRegView>(parent);
}

RegisterGroup *FieldWidget::group() const {
	return checked_cast<RegisterGroup>(parentWidget());
}

}

```

`plugins/ODbgRegisterView/FieldWidget.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef FIELD_WIDGET_H_20170818_
#define FIELD_WIDGET_H_20170818_

#include <QLabel>
#include <QModelIndex>

namespace ODbgRegisterView {

class ODBRegView;
class RegisterGroup;

class FieldWidget : public QLabel {
	Q_OBJECT

	void init(int fieldWidth);

protected:
	QPersistentModelIndex index_;
	int fieldWidth_;

	ODBRegView *regView() const;
	RegisterGroup *group() const;

public:
	FieldWidget(int fieldWidth, const QModelIndex &index_, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	FieldWidget(int fieldWidth, const QString &fixedText, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	explicit FieldWidget(const QString &fixedText, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());

public:
	virtual QString text() const;
	int lineNumber() const;
	int columnNumber() const;
	int fieldWidth() const;

public Q_SLOTS:
	virtual void adjustToData();
};

}

#endif

```

`plugins/ODbgRegisterView/FpuValueField.h`:

```h

#ifndef FPU_VALUE_FIELD_H_20191119_
#define FPU_VALUE_FIELD_H_20191119_

#include "ValueField.h"

namespace ODbgRegisterView {

#if defined(EDB_X86) || defined(EDB_X86_64)
class FpuValueField final : public ValueField {
	Q_OBJECT

private:
	int showAsRawActionIndex;
	int showAsFloatActionIndex;

	FieldWidget *commentWidget;
	int row;
	int column;

	QPersistentModelIndex tagValueIndex;

	bool groupDigits = false;

public:
	// Will add itself and commentWidget to the group and renew their positions as needed
	FpuValueField(int fieldWidth, const QModelIndex &regValueIndex, const QModelIndex &tagValueIndex, RegisterGroup *group, FieldWidget *commentWidget, int row, int column);

public Q_SLOTS:
	void showFPUAsRaw();
	void showFPUAsFloat();
	void displayFormatChanged();
	void updatePalette() override;
};
#endif

}

#endif

```

`plugins/ODbgRegisterView/GprEdit.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "GprEdit.h"
#include "QLongValidator.h"
#include "QULongValidator.h"
#include "util/Font.h"
#include <QApplication>
#include <QRegExpValidator>
#include <cmath>
#include <cstring>

namespace ODbgRegisterView {
namespace {

const QRegExpValidator byteHexValidator(QRegExp("[0-9a-fA-F]{0,2}"));
const QRegExpValidator wordHexValidator(QRegExp("[0-9a-fA-F]{0,4}"));
const QRegExpValidator dwordHexValidator(QRegExp("[0-9a-fA-F]{0,8}"));
const QRegExpValidator qwordHexValidator(QRegExp("[0-9a-fA-F]{0,16}"));
const QLongValidator byteSignedValidator(INT8_MIN, INT8_MAX);
const QLongValidator wordSignedValidator(INT16_MIN, INT16_MAX);
const QLongValidator dwordSignedValidator(INT32_MIN, INT32_MAX);
const QLongValidator qwordSignedValidator(INT64_MIN, INT64_MAX);
const QULongValidator byteUnsignedValidator(0, UINT8_MAX);
const QULongValidator wordUnsignedValidator(0, UINT16_MAX);
const QULongValidator dwordUnsignedValidator(0, UINT32_MAX);
const QULongValidator qwordUnsignedValidator(0, UINT64_MAX);

const std::map<int, const QRegExpValidator *> hexValidators = {
	{1, &byteHexValidator},
	{2, &wordHexValidator},
	{4, &dwordHexValidator},
	{8, &qwordHexValidator}};

const std::map<int, const QLongValidator *> signedValidators = {
	{1, &byteSignedValidator},
	{2, &wordSignedValidator},
	{4, &dwordSignedValidator},
	{8, &qwordSignedValidator}};

const std::map<int, const QULongValidator *> unsignedValidators = {
	{1, &byteUnsignedValidator},
	{2, &wordUnsignedValidator},
	{4, &dwordUnsignedValidator},
	{8, &qwordUnsignedValidator}};

}

void GprEdit::setupFormat(Format newFormat) {
	format_ = newFormat;
	switch (format_) {
	case Format::Hex:
		setValidator(hexValidators.at(integerSize_));
		naturalWidthInChars_ = 2 * integerSize_;
		break;
	case Format::Signed:
		setValidator(signedValidators.at(integerSize_));
		naturalWidthInChars_ = 1 + std::lround(integerSize_ * std::log10(256.));
		break;
	case Format::Unsigned:
		setValidator(unsignedValidators.at(integerSize_));
		naturalWidthInChars_ = std::lround(integerSize_ * std::log10(256.));
		break;
	case Format::Character:
		setMaxLength(1);
		break;
	default:
		Q_ASSERT("Unexpected format value" && 0);
	}
}

GprEdit::GprEdit(std::size_t offsetInInteger, std::size_t integerSize, Format format, QWidget *parent)
	: QLineEdit(parent), naturalWidthInChars_(2 * integerSize), integerSize_(integerSize), offsetInInteger_(offsetInInteger) {

	setupFormat(format);
}

void GprEdit::setGPRValue(std::uint64_t gprValue) {
	std::uint64_t value(0);
	signBit_ = format_ == Format::Signed ? 1ull << (8 * integerSize_ - 1) : 0;
	if ((gprValue >> 8 * offsetInInteger_) & signBit_)
		value = -1;
	std::memcpy(&value, reinterpret_cast<char *>(&gprValue) + offsetInInteger_, integerSize_);
	switch (format_) {
	case Format::Hex:
		setText(QString("%1").arg(value, naturalWidthInChars_, 16, QChar('0')));
		break;
	case Format::Signed:
		setText(QString("%1").arg(static_cast<std::int64_t>(value)));
		break;
	case Format::Unsigned:
		setText(QString("%1").arg(value));
		break;
	case Format::Character:
		setText(QChar(static_cast<char>(value)));
		break;
	}
}

void GprEdit::updateGPRValue(std::uint64_t &gpr) const {
	bool ok;
	std::uint64_t value;
	switch (format_) {
	case Format::Hex:
		value = text().toULongLong(&ok, 16);
		break;
	case Format::Signed:
		value = text().toLongLong(&ok);
		break;
	case Format::Unsigned:
		value = text().toULongLong(&ok);
		break;
	case Format::Character:
		value = text().toStdString()[0];
		break;
	default:
		Q_ASSERT("Unexpected format value" && 0);
	}
	std::memcpy(reinterpret_cast<char *>(&gpr) + offsetInInteger_, &value, integerSize_);
}

QSize GprEdit::sizeHint() const {

	const auto baseHint = QLineEdit::sizeHint();
	// taking long enough reference char to make enough room even in presence of inner shadows like in Oxygen style
	const auto charWidth       = Font::maxWidth(QFontMetrics(font()));
	const auto textMargins     = this->textMargins();
	const auto contentsMargins = this->contentsMargins();
	int customWidth            = charWidth * naturalWidthInChars_ + textMargins.left() + contentsMargins.left() + textMargins.right() + contentsMargins.right() + 1 * charWidth; // additional char to make edit field not too tight
	return QSize(customWidth, baseHint.height()).expandedTo(QApplication::globalStrut());
}

}

```

`plugins/ODbgRegisterView/GprEdit.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef GPR_EDIT_H_20190412_
#define GPR_EDIT_H_20190412_

#include <QLineEdit>

namespace ODbgRegisterView {

class GprEdit final : public QLineEdit {
	Q_OBJECT

public:
	enum class Format {
		Hex,
		Signed,
		Unsigned,
		Character
	};

public:
	GprEdit(std::size_t offsetInInteger, std::size_t integerSize, Format format, QWidget *parent = nullptr);

public:
	void setGPRValue(std::uint64_t gprValue);
	void updateGPRValue(std::uint64_t &gpr) const;

	QSize minimumSizeHint() const override {
		return sizeHint();
	}

	QSize sizeHint() const override;

private:
	void setupFormat(Format newFormat);

private:
	int naturalWidthInChars_;
	std::size_t integerSize_;
	std::size_t offsetInInteger_;
	Format format_;
	std::uint64_t signBit_;
};

}

#endif

```

`plugins/ODbgRegisterView/MultiBitFieldWidget.cpp`:

```cpp

#include "MultiBitFieldWidget.h"
#include "BitFieldDescription.h"
#include "BitFieldFormatter.h"
#include "ODbgRV_Util.h"
#include "RegisterView.h"

namespace ODbgRegisterView {

MultiBitFieldWidget::MultiBitFieldWidget(const QModelIndex &index, const BitFieldDescription &bfd, QWidget *parent, Qt::WindowFlags f)
	: ValueField(bfd.textWidth, index, BitFieldFormatter(bfd), parent, f), equal_(bfd.valueEqualComparator) {

	menuItems_.push_front(new_action_separator(this));

	for (std::size_t i = bfd.valueNames.size(); i-- > 0;) {
		const auto &text = bfd.setValueTexts[i];
		if (!text.isEmpty()) {
			auto action = new_action(text, this, [this, i]() {
				setValue(i);
			});

			menuItems_.push_front(action);
			valueActions_.push_front(menuItems_.front());
		} else
			valueActions_.push_front(nullptr);
	}
}

void MultiBitFieldWidget::setValue(int value) {

	using namespace RegisterViewModelBase;

	// TODO: Model: make it possible to set bit field itself, without manipulating parent directly
	//              I.e. set value without knowing field offset, then setData(fieldIndex,word)
	const auto regIndex = index_.parent().sibling(index_.parent().row(), ModelValueColumn);
	auto byteArr        = regIndex.data(Model::RawValueRole).toByteArray();

	if (byteArr.isEmpty())
		return;

	std::uint64_t word(0);
	std::memcpy(&word, byteArr.constData(), byteArr.size());
	const auto mask   = (1ull << (valid_variant(index_.data(Model::BitFieldLengthRole)).toInt() - 1)) * 2 - 1;
	const auto offset = valid_variant(index_.data(Model::BitFieldOffsetRole)).toInt();
	word              = (word & ~(mask << offset)) | (std::uint64_t(value) << offset);
	std::memcpy(byteArr.data(), &word, byteArr.size());
	model()->setData(regIndex, byteArr, Model::RawValueRole);
}

void MultiBitFieldWidget::adjustToData() {

	using namespace RegisterViewModelBase;

	ValueField::adjustToData();

	const auto byteArr = index_.data(Model::RawValueRole).toByteArray();
	std::uint64_t word(0);
	assert(unsigned(byteArr.size()) <= sizeof(word));
	std::memcpy(&word, byteArr.constData(), byteArr.size());

	for (int value = 0; value < valueActions_.size(); ++value) {
		const auto action = valueActions_[value];
		if (!action)
			continue;
		if (byteArr.isEmpty() || equal_(word, value))
			action->setVisible(false);
		else
			action->setVisible(true);
	}
}

}

```

`plugins/ODbgRegisterView/MultiBitFieldWidget.h`:

```h

#ifndef MULTI_BIT_FIELD_WIDGET_H_20191119_
#define MULTI_BIT_FIELD_WIDGET_H_20191119_

#include "ValueField.h"

namespace ODbgRegisterView {

struct BitFieldDescription;

class MultiBitFieldWidget final : public ValueField {
	Q_OBJECT

public:
	MultiBitFieldWidget(const QModelIndex &index, const BitFieldDescription &bfd, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());

public Q_SLOTS:
	void setValue(int value);
	void adjustToData() override;

private:
	QList<QAction *> valueActions_;
	std::function<bool(unsigned, unsigned)> equal_;
};

}

#endif

```

`plugins/ODbgRegisterView/NumberEdit.cpp`:

```cpp

#include "NumberEdit.h"
#include "util/Font.h"
#include <QApplication>

namespace ODbgRegisterView {

NumberEdit::NumberEdit(int column, int colSpan, QWidget *parent)
	: QLineEdit(parent), column_(column), colSpan_(colSpan) {
}

int NumberEdit::column() const {
	return column_;
}

int NumberEdit::colSpan() const {
	return colSpan_;
}

void NumberEdit::setNaturalWidthInChars(int nChars) {
	naturalWidthInChars_ = nChars;
}

QSize NumberEdit::minimumSizeHint() const {
	return sizeHint();
}

QSize NumberEdit::sizeHint() const {

	const auto baseHint = QLineEdit::sizeHint();
	// taking long enough reference char to make enough room even in presence of inner shadows like in Oxygen style
	const auto charWidth       = Font::maxWidth(QFontMetrics(font()));
	const auto textMargins     = this->textMargins();
	const auto contentsMargins = this->contentsMargins();
	int customWidth            = charWidth * naturalWidthInChars_ + textMargins.left() + contentsMargins.left() + textMargins.right() + contentsMargins.right();

	return QSize(customWidth, baseHint.height()).expandedTo(QApplication::globalStrut());
}

}

```

`plugins/ODbgRegisterView/NumberEdit.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef NUMBER_EDIT_H_20190412_
#define NUMBER_EDIT_H_20190412_

#include <QLineEdit>

namespace ODbgRegisterView {

class NumberEdit final : public QLineEdit {
	Q_OBJECT
public:
	NumberEdit(int column, int colSpan, QWidget *parent = nullptr);
	~NumberEdit() override = default;

public:
	int column() const;
	int colSpan() const;
	void setNaturalWidthInChars(int nChars);

public:
	QSize minimumSizeHint() const override;
	QSize sizeHint() const override;

private:
	int naturalWidthInChars_ = 17; // default roughly as in QLineEdit
	int column_;
	int colSpan_;
};

}

#endif

```

`plugins/ODbgRegisterView/ODbgRV_Common.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ODBG_REGISTER_VIEW_COMMON_H_20170817_
#define ODBG_REGISTER_VIEW_COMMON_H_20170817_

#include <QKeySequence>

namespace ODbgRegisterView {

constexpr Qt::Key SetToZeroKey = Qt::Key_Z;
constexpr Qt::Key DecrementKey = Qt::Key_Minus;
constexpr Qt::Key IncrementKey = Qt::Key_Plus;

static constexpr const char *GprCategoryName = "General Purpose";

}

#endif

```

`plugins/ODbgRegisterView/ODbgRV_Util.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ODBG_REG_VIEW_UTIL_H_20170817_
#define ODBG_REG_VIEW_UTIL_H_20170817_

#include "FieldWidget.h"
#include "RegisterGroup.h"
#include "RegisterViewModelBase.h"
#include "util/Font.h"
#include <QAction>

namespace ODbgRegisterView {

static constexpr int ModelNameColumn    = RegisterViewModelBase::Model::NAME_COLUMN;
static constexpr int ModelValueColumn   = RegisterViewModelBase::Model::VALUE_COLUMN;
static constexpr int ModelCommentColumn = RegisterViewModelBase::Model::COMMENT_COLUMN;

template <class T>
T valid_index(T index) {
	static_assert(std::is_same<const typename std::remove_reference<T>::type, const QModelIndex>::value ||
					  std::is_same<const typename std::remove_reference<T>::type, const QPersistentModelIndex>::value,
				  "Wrong type passed to valid_index");

	Q_ASSERT(index.isValid());
	return index;
}

template <class T, class P>
T *checked_cast(P p) {
	Q_ASSERT(dynamic_cast<T *>(p));
	return static_cast<T *>(p);
}

template <typename T>
constexpr T square(T v) {
	return v * v;
}

inline QPoint field_position(const FieldWidget *field) {
	// NOTE: mapToGlobal() is VERY slow, don't use it. Here we map to canvas, it's enough for all fields.
	return field->mapTo(field->parentWidget()->parentWidget(), QPoint());
}

// Square of Euclidean distance between two points
inline int distance_squared(const QPoint &w1, const QPoint &w2) {
	return square(w1.x() - w2.x()) + square(w1.y() - w2.y());
}

inline QSize letter_size(const QFont &font) {
	const QFontMetrics fontMetrics(font);
	const int width  = Font::maxWidth(fontMetrics);
	const int height = fontMetrics.height();
	return QSize(width, height);
}

inline QAction *new_action_separator(QObject *parent) {
	const auto sep = new QAction(parent);
	sep->setSeparator(true);
	return sep;
}

template <class Func>
inline QAction *new_action(const QString &text, QObject *parent, Func func) {
	const auto action = new QAction(text, parent);
	QObject::connect(action, &QAction::triggered, parent, func);
	return action;
}

// TODO: switch from string-based search to enum-based one (add a new Role to model data)
inline QModelIndex find_model_category(const RegisterViewModelBase::Model *model, const QString &catToFind) {
	for (int row = 0; row < model->rowCount(); ++row) {
		const QVariant cat = model->index(row, 0).data(ModelNameColumn);
		if (cat.isValid() && cat.toString() == catToFind) {
			return model->index(row, 0);
		}
	}

	return {};
}

// TODO: switch from string-based search to enum-based one (add a new Role to model data)
inline QModelIndex find_model_register(QModelIndex categoryIndex, const QString &regToFind, int column = ModelNameColumn) {

	const auto model = categoryIndex.model();
	for (int row = 0; row < model->rowCount(categoryIndex); ++row) {
		const auto regIndex = model->index(row, ModelNameColumn, categoryIndex);
		const auto name     = model->data(regIndex).toString();
		if (name.toUpper() == regToFind) {
			if (column == ModelNameColumn)
				return regIndex;
			return regIndex.sibling(regIndex.row(), column);
		}
	}
	return QModelIndex();
}

inline QModelIndex comment_index(const QModelIndex &nameIndex) {
	Q_ASSERT(nameIndex.isValid());
	return nameIndex.sibling(nameIndex.row(), ModelCommentColumn);
}

inline QModelIndex value_index(const QModelIndex &nameIndex) {
	Q_ASSERT(nameIndex.isValid());
	return nameIndex.sibling(nameIndex.row(), ModelValueColumn);
}

inline const QVariant &valid_variant(const QVariant &variant) {
	Q_ASSERT(variant.isValid());
	return variant;
}

}

#endif

```

`plugins/ODbgRegisterView/Plugin.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Plugin.h"
#include "ArchProcessor.h"
#include "QtHelper.h"
#include "RegisterView.h"
#include "edb.h"

#include <QCoreApplication>
#include <QDebug>
#include <QDockWidget>
#include <QMainWindow>
#include <QMenu>
#include <QSettings>

namespace ODbgRegisterView {
//Q_DECLARE_NAMESPACE_TR(ODbgRegisterView)

namespace {
const auto pluginName             = QLatin1String("ODbgRegisterView");
const auto dockNameSuffixTemplate = QString(" <%1>");
const auto dockObjectNameTemplate = QString(pluginName + "-%1");
const auto views                  = QLatin1String("views");
}

Plugin::Plugin(QObject *parent)
	: QObject(parent) {

	connect(QCoreApplication::instance(), &QCoreApplication::aboutToQuit, this, &Plugin::saveSettings);
}

QString Plugin::dockName() const {
	return tr("Registers");
}

void Plugin::setupDocks() {
	QSettings settings;
	settings.beginGroup(pluginName);

	if (settings.value(views + "/size").isValid()) {
		const int size = settings.beginReadArray(views);
		for (int i = 0; i < size; ++i) {
			settings.setArrayIndex(i);
			createRegisterView(settings.group());
		}
	} else {
		createRegisterView();
	}
}

void Plugin::saveSettings() const {
	QSettings settings;
	const int size      = registerViews_.size();
	const auto arrayKey = pluginName + "/" + views;
	settings.remove(arrayKey);
	settings.beginWriteArray(arrayKey, size);
	for (int i = 0; i < size; ++i) {
		settings.setArrayIndex(i);
		registerViews_[i]->saveState(settings.group());
	}
}

void Plugin::createRegisterView() {
	createRegisterView("");
}

void Plugin::createRegisterView(const QString &settingsGroup) {

	if (const auto mainWindow = edb::v1::debugger_ui->findChild<QMainWindow *>(QLatin1String("dockingRoot"))) {
		const auto regView = new ODBRegView(settingsGroup, mainWindow);
		registerViews_.emplace_back(regView);
		regView->setModel(&edb::v1::arch_processor().registerViewModel());

		const QString suffix          = registerViews_.size() > 1 ? dockNameSuffixTemplate.arg(registerViews_.size()) : "";
		auto *const regViewDockWidget = new QDockWidget(dockName() + suffix, mainWindow);
		const auto viewNumber         = registerViews_.size();
		regViewDockWidget->setObjectName(dockObjectNameTemplate.arg(viewNumber));
		regViewDockWidget->setWidget(regView);

		mainWindow->addDockWidget(Qt::RightDockWidgetArea, regViewDockWidget);

		QList<QDockWidget *> dockWidgets = mainWindow->findChildren<QDockWidget *>();
		for (QDockWidget *widget : dockWidgets) {
			if (widget != regViewDockWidget) {
				if (mainWindow->dockWidgetArea(widget) == Qt::RightDockWidgetArea) {
					mainWindow->tabifyDockWidget(widget, regViewDockWidget);

					// place the new doc widget OVER the one we tabbed with
					// register view is important...
					regViewDockWidget->show();
					regViewDockWidget->raise();
					break;
				}
			}
		}

		Q_ASSERT(menu_);
		const auto removeDockAction = new QAction(tr("Remove %1").arg(regViewDockWidget->windowTitle()), menu_);

		connect(removeDockAction, &QAction::triggered, this, [this, regViewDockWidget]() {
			removeDock(regViewDockWidget);
		});

		menuDeleteRegViewActions_.emplace_back(removeDockAction);
		menu_->addAction(removeDockAction);
	}
}

void Plugin::renumerateDocks() const {
	for (std::size_t i = 0; i < registerViews_.size(); ++i) {
		const auto view = registerViews_[i];
		Q_ASSERT(dynamic_cast<QDockWidget *>(view->parentWidget()));
		QWidget *dock = view->parentWidget();
		dock->setObjectName(dockObjectNameTemplate.arg(i + 1));
		dock->setWindowTitle(dockName() + (i ? dockNameSuffixTemplate.arg(i + 1) : ""));
	}
}

void Plugin::removeDock(QWidget *whatToRemove) {
	Q_ASSERT(dynamic_cast<QDockWidget *>(whatToRemove));
	const auto dockToRemove = static_cast<QDockWidget *>(whatToRemove);

	auto &views(registerViews_);
	const auto viewIter = std::find(views.begin(), views.end(), dockToRemove->widget());

	const auto viewIndex = viewIter - views.begin();
	const auto action    = menuDeleteRegViewActions_[viewIndex];

	whatToRemove->deleteLater();
	action->deleteLater();
	menu_->removeAction(action);
	views.erase(viewIter);
	menuDeleteRegViewActions_.erase(viewIndex + menuDeleteRegViewActions_.begin());

	renumerateDocks();
}

void Plugin::expandLSDown(bool checked) const {
	if (const auto mainWindow = qobject_cast<QMainWindow *>(edb::v1::debugger_ui)) {
		mainWindow->setCorner(Qt::BottomLeftCorner, checked ? Qt::LeftDockWidgetArea : Qt::BottomDockWidgetArea);
	}
}

void Plugin::expandRSDown(bool checked) const {
	if (const auto mainWindow = qobject_cast<QMainWindow *>(edb::v1::debugger_ui)) {
		mainWindow->setCorner(Qt::BottomRightCorner, checked ? Qt::RightDockWidgetArea : Qt::BottomDockWidgetArea);
	}
}

void Plugin::expandLSUp(bool checked) const {
	if (const auto mainWindow = qobject_cast<QMainWindow *>(edb::v1::debugger_ui)) {
		mainWindow->setCorner(Qt::TopLeftCorner, checked ? Qt::LeftDockWidgetArea : Qt::TopDockWidgetArea);
	}
}

void Plugin::expandRSUp(bool checked) const {
	if (const auto mainWindow = qobject_cast<QMainWindow *>(edb::v1::debugger_ui)) {
		mainWindow->setCorner(Qt::TopRightCorner, checked ? Qt::RightDockWidgetArea : Qt::TopDockWidgetArea);
	}
}

QMenu *Plugin::menu(QWidget *parent) {
	if (!menu_) {
		menu_ = new QMenu(tr("OllyDbg-like Register View"), parent);
		{
			const auto newRegisterView = new QAction(tr("New Register View"), menu_);
			connect(newRegisterView, &QAction::triggered, this, [this](bool) {
				createRegisterView();
			});

			menu_->addAction(newRegisterView);
		}
		// FIXME: setChecked calls currently don't really work, since at this stage mainWindow hasn't yet restored its state
		if (auto *const mainWindow = qobject_cast<QMainWindow *>(edb::v1::debugger_ui)) {
			{
				const auto expandLeftSideUp = new QAction(tr("Expand Left-Hand Side Dock Up"), menu_);
				expandLeftSideUp->setCheckable(true);
				expandLeftSideUp->setChecked(mainWindow->corner(Qt::TopLeftCorner) == Qt::LeftDockWidgetArea);
				connect(expandLeftSideUp, &QAction::toggled, this, &Plugin::expandLSUp);
				menu_->addAction(expandLeftSideUp);
			}
			{
				const auto expandLeftSideDown = new QAction(tr("Expand Left-Hand Side Dock Down"), menu_);
				expandLeftSideDown->setCheckable(true);
				expandLeftSideDown->setChecked(mainWindow->corner(Qt::BottomLeftCorner) == Qt::LeftDockWidgetArea);
				connect(expandLeftSideDown, &QAction::toggled, this, &Plugin::expandLSDown);
				menu_->addAction(expandLeftSideDown);
			}
			{
				const auto expandRightSideUp = new QAction(tr("Expand Right-Hand Side Dock Up"), menu_);
				expandRightSideUp->setCheckable(true);
				expandRightSideUp->setChecked(mainWindow->corner(Qt::TopRightCorner) == Qt::RightDockWidgetArea);
				connect(expandRightSideUp, &QAction::toggled, this, &Plugin::expandRSUp);
				menu_->addAction(expandRightSideUp);
			}
			{
				const auto expandRightSideDown = new QAction(tr("Expand Right-Hand Side Dock Down"), menu_);
				expandRightSideDown->setCheckable(true);
				expandRightSideDown->setChecked(mainWindow->corner(Qt::BottomRightCorner) == Qt::RightDockWidgetArea);
				connect(expandRightSideDown, &QAction::toggled, this, &Plugin::expandRSDown);
				menu_->addAction(expandRightSideDown);
			}
			menu_->addSeparator();
		}

		setupDocks();
	}

	return menu_;
}

}

```

`plugins/ODbgRegisterView/Plugin.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ODBG_REGISTER_VIEW_PLUGIN_H_20151230_
#define ODBG_REGISTER_VIEW_PLUGIN_H_20151230_

#include "IPlugin.h"
#include <vector>

namespace ODbgRegisterView {

class ODBRegView;

class Plugin : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Ruslan Kabatsayev")
	Q_CLASSINFO("email", "b7.10110111@gmail.com")

public:
	explicit Plugin(QObject *parent = nullptr);
	QMenu *menu(QWidget *parent = nullptr) override;

private:
	void setupDocks();
	void createRegisterView(const QString &settingsGroup);
	void renumerateDocks() const;
	void removeDock(QWidget *);
	void saveSettings() const;
	void expandRSUp(bool checked) const;
	void expandRSDown(bool checked) const;
	void expandLSUp(bool checked) const;
	void expandLSDown(bool checked) const;
	QString dockName() const;

private Q_SLOTS:
	void createRegisterView();

private:
	QMenu *menu_ = nullptr;
	std::vector<ODBRegView *> registerViews_;
	std::vector<QAction *> menuDeleteRegViewActions_;
};

}

#endif

```

`plugins/ODbgRegisterView/RegisterGroup.cpp`:

```cpp

#include "RegisterGroup.h"
#include "ODbgRV_Util.h"
#include "RegisterView.h"
#include "ValueField.h"

#include <QMouseEvent>

namespace ODbgRegisterView {

RegisterGroup::RegisterGroup(const QString &name, QWidget *parent, Qt::WindowFlags f)
	: QWidget(parent, f), name_(name) {

	setObjectName("RegisterGroup_" + name);
	{
		menuItems_.push_back(new_action_separator(this));
		menuItems_.push_back(new_action(tr("Hide %1", "register group").arg(name), this, [this]() {
			hide();
			regView()->groupHidden(this);
		}));
	}
}

void RegisterGroup::adjustWidth() {

	int widthNeeded = 0;

	Q_FOREACH (FieldWidget *field, fields()) {
		const auto widthToRequire = field->pos().x() + field->width();
		if (widthToRequire > widthNeeded)
			widthNeeded = widthToRequire;
	}

	setMinimumWidth(widthNeeded);
}

void RegisterGroup::showMenu(const QPoint &position, const QList<QAction *> &additionalItems) const {
	return regView()->showMenu(position, additionalItems + menuItems_);
}

void RegisterGroup::mousePressEvent(QMouseEvent *event) {
	if (event->button() == Qt::RightButton)
		showMenu(event->globalPos(), menuItems_);
	else
		event->ignore();
}

ODBRegView *RegisterGroup::regView() const {
	return checked_cast<ODBRegView>(parent()       // canvas
										->parent() // viewport
										->parent() // regview
	);
}

QMargins RegisterGroup::getFieldMargins() const {
	const auto charSize  = letter_size(font());
	const auto charWidth = charSize.width();
	// extra space for highlighting rectangle, so that single-digit fields are easier to target
	const auto marginLeft  = charWidth / 2;
	const auto marginRight = charWidth - marginLeft;
	return {marginLeft, 0, marginRight, 0};
}

void RegisterGroup::insert(FieldWidget *widget) {
	if (const auto value = qobject_cast<ValueField *>(widget)) {
		connect(value, &ValueField::selected, regView(), &ODBRegView::fieldSelected);
	}
}

void RegisterGroup::insert(int line, int column, FieldWidget *widget) {
	insert(widget);
	setupPositionAndSize(line, column, widget);

	widget->show();
}

void RegisterGroup::setupPositionAndSize(int line, int column, FieldWidget *widget) {
	widget->adjustToData();

	const auto margins = getFieldMargins();

	const auto charSize = letter_size(font());
	QPoint position(charSize.width() * column, charSize.height() * line);
	position -= QPoint(margins.left(), 0);

	QSize size(widget->size());
	size += QSize(margins.left() + margins.right(), 0);

	widget->setMinimumSize(size);
	widget->move(position);
	// FIXME: why are e.g. regnames like FSR truncated without the -1?
	widget->setContentsMargins({margins.left(), margins.top(), margins.right() - 1, margins.bottom()});

	const auto potentialNewWidth  = widget->pos().x() + widget->width();
	const auto potentialNewHeight = widget->pos().y() + widget->height();
	const auto oldMinSize         = minimumSize();
	if (potentialNewWidth > oldMinSize.width() || potentialNewHeight > oldMinSize.height()) {
		setMinimumSize(std::max(potentialNewWidth, oldMinSize.width()), std::max(potentialNewHeight, oldMinSize.height()));
	}
}

int RegisterGroup::lineAfterLastField() const {
	const auto fields      = this->fields();
	const auto bottomField = std::max_element(fields.begin(), fields.end(), [](FieldWidget *l, FieldWidget *r) { return l->pos().y() < r->pos().y(); });
	return bottomField == fields.end() ? 0 : (*bottomField)->pos().y() / (*bottomField)->height() + 1;
}

void RegisterGroup::appendNameValueComment(const QModelIndex &nameIndex,
										   const QString &tooltip,
										   bool insertComment) {

	assert(nameIndex.isValid());

	using namespace RegisterViewModelBase;

	const auto nameWidth = nameIndex.data(Model::FixedLengthRole).toInt();
	assert(nameWidth > 0);
	const auto valueIndex = nameIndex.sibling(nameIndex.row(), Model::VALUE_COLUMN);
	const auto valueWidth = valueIndex.data(Model::FixedLengthRole).toInt();
	assert(valueWidth > 0);

	const int line       = lineAfterLastField();
	int column           = 0;
	const auto nameField = new FieldWidget(nameWidth, nameIndex.data().toString(), this);
	insert(line, column, nameField);
	column += nameWidth + 1;
	const auto valueField = new ValueField(valueWidth, valueIndex, this);
	insert(line, column, valueField);
	if (!tooltip.isEmpty()) {
		nameField->setToolTip(tooltip);
		valueField->setToolTip(tooltip);
	}
	if (insertComment) {
		column += valueWidth + 1;
		const auto commentIndex = nameIndex.sibling(nameIndex.row(), Model::COMMENT_COLUMN);
		insert(line, column, new FieldWidget(0, commentIndex, this));
	}
}

QList<FieldWidget *> RegisterGroup::fields() const {
	const QObjectList children = this->children();
	QList<FieldWidget *> fields;
	for (QObject *child : children) {
		const auto field = qobject_cast<FieldWidget *>(child);
		if (field) {
			fields.append(field);
		}
	}
	return fields;
}

QList<ValueField *> RegisterGroup::valueFields() const {
	QList<ValueField *> allValues;

	Q_FOREACH (FieldWidget *field, fields()) {
		const auto value = qobject_cast<ValueField *>(field);
		if (value) {
			allValues.push_back(value);
		}
	}

	return allValues;
}

}

```

`plugins/ODbgRegisterView/RegisterGroup.h`:

```h

#ifndef REGISTER_GROUP_H_20191119_
#define REGISTER_GROUP_H_20191119_

#include <QWidget>

namespace ODbgRegisterView {

class SimdValueManager;
class FieldWidget;
class ValueField;
class ODBRegView;

class RegisterGroup : public QWidget {
	Q_OBJECT
	friend SimdValueManager;

public:
	explicit RegisterGroup(const QString &name_, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	QList<FieldWidget *> fields() const;
	QList<ValueField *> valueFields() const;
	void setIndices(const QList<QModelIndex> &indices);
	void insert(int line, int column, FieldWidget *widget);
	// Insert, but without moving to its place
	void insert(FieldWidget *widget);
	void setupPositionAndSize(int line, int column, FieldWidget *widget);
	void appendNameValueComment(const QModelIndex &nameIndex, const QString &tooltip = "", bool insertComment = true);
	void showMenu(const QPoint &position, const QList<QAction *> &additionalItems = {}) const;
	QMargins getFieldMargins() const;

public Q_SLOTS:
	void adjustWidth();

protected:
	void mousePressEvent(QMouseEvent *event) override;

private:
	int lineAfterLastField() const;
	ODBRegView *regView() const;

private:
	QList<QAction *> menuItems_;
	QString name_;
};

}

#endif

```

`plugins/ODbgRegisterView/RegisterView.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "RegisterView.h"
#include "BitFieldFormatter.h"
#include "Canvas.h"
#include "Configuration.h"
#include "DialogEditGPR.h"
#include "DialogEditSimdRegister.h"
#include "ODbgRV_Common.h"
#include "ODbgRV_Util.h"
#include "RegisterGroup.h"
#include "RegisterViewModelBase.h"
#include "SimdValueManager.h"
#include "State.h"
#include "ValueField.h"
#include "VolatileNameField.h"
#include "edb.h"
#include "util/Container.h"

#if defined(EDB_X86) || defined(EDB_X86_64)
#include "DialogEditFPU.h"
#include "ODbgRV_x86Common.h"
#include "x86Groups.h"
#elif defined(EDB_ARM32)
#include "armGroups.h"
#endif

#include <QApplication>
#include <QClipboard>
#include <QDebug>
#include <QMenu>
#include <QMouseEvent>
#include <QSettings>
#include <QShortcut>
#include <QVBoxLayout>
#include <algorithm>
#include <iostream>
#include <type_traits>

namespace ODbgRegisterView {
namespace {

// TODO: rFLAGS menu: Set Condition (O,P,NAE etc. - see ODB)
// TODO: FSR: Set Condition: G,L,E,Unordered
// TODO: Add option to show FPU in STi mode, both ST-ordered and R-ordered (physically)
// TODO: Update register comments after editing values
// TODO: Add a way to add back register group to RegView
// TODO: all TODOs scattered around sources
// TODO: "Undo" action, which returns to the state after last stopping of debuggee (visible only if register has been modified by the user)

constexpr auto RegisterGroupTypeNames = util::make_array<const char *>(
#if defined(EDB_X86) || defined(EDB_X86_64)
	"GPR",
	"rIP",
	"ExpandedEFL",
	"Segment",
	"EFL",
	"FPUData",
	"FPUWords",
	"FPULastOp",
	"Debug",
	"MMX",
	"SSEData",
	"AVXData",
	"MXCSR"
#elif defined(EDB_ARM32)
	"GPR",
	"CPSR",
	"ExpandedCPSR",
	"FPSCR"
#else
#error "Not implemented"
#endif
);

constexpr std::array allRegisterGroups = {
#if defined(EDB_X86) || defined(EDB_X86_64)
	ODBRegView::RegisterGroupType::GPR,
	ODBRegView::RegisterGroupType::rIP,
	ODBRegView::RegisterGroupType::ExpandedEFL,
	ODBRegView::RegisterGroupType::Segment,
	ODBRegView::RegisterGroupType::EFL,
	ODBRegView::RegisterGroupType::FPUData,
	ODBRegView::RegisterGroupType::FPUWords,
	ODBRegView::RegisterGroupType::FPULastOp,
	ODBRegView::RegisterGroupType::Debug,
	ODBRegView::RegisterGroupType::MMX,
	ODBRegView::RegisterGroupType::SSEData,
	ODBRegView::RegisterGroupType::AVXData,
	ODBRegView::RegisterGroupType::MXCSR,
#elif defined(EDB_ARM32)
	ODBRegView::RegisterGroupType::GPR,
	ODBRegView::RegisterGroupType::CPSR,
	ODBRegView::RegisterGroupType::ExpandedCPSR,
	ODBRegView::RegisterGroupType::FPSCR,
#else
#error "Not implemented"
#endif
};

static_assert(RegisterGroupTypeNames.size() == ODBRegView::RegisterGroupType::NUM_GROUPS, "Mismatch between number of register group types and names");

const auto SETTINGS_GROUPS_ARRAY_NODE = QLatin1String("visibleGroups");

ODBRegView::RegisterGroupType findGroup(const QString &str) {
	const auto &names  = RegisterGroupTypeNames;
	const auto foundIt = std::find(names.begin(), names.end(), str);

	if (foundIt == names.end())
		return ODBRegView::RegisterGroupType::NUM_GROUPS;

	return ODBRegView::RegisterGroupType(foundIt - names.begin());
}

RegisterGroup *createSIMDGroup(RegisterViewModelBase::Model *model, QWidget *parent, const QString &catName, const QString &regNamePrefix) {
	const auto catIndex = find_model_category(model, catName);
	if (!catIndex.isValid())
		return nullptr;
	const auto group = new RegisterGroup(catName, parent);
	for (int row = 0; row < model->rowCount(catIndex); ++row) {
		const auto nameIndex = valid_index(model->index(row, ModelNameColumn, catIndex));
		const auto name      = regNamePrefix + QString("%1").arg(row);
		if (!valid_variant(nameIndex.data()).toString().toUpper().startsWith(regNamePrefix)) {
			if (row == 0)
				return nullptr; // don't want empty groups
			break;
		}

		group->insert(row, 0, new FieldWidget(name, group));
		new SimdValueManager(row, nameIndex, group);
	}
	// This signal must be handled by group _after_ all `SimdValueManager`s handle their connection to this signal
	QObject::connect(
		model, &RegisterViewModelBase::Model::SIMDDisplayFormatChanged, group, [group]() {
			group->adjustWidth();
		},
		Qt::QueuedConnection);

	return group;
}

}

// -------------------------------- ODBRegView impl ----------------------------------------

void ODBRegView::mousePressEvent(QMouseEvent *event) {
	if (event->type() != QEvent::MouseButtonPress)
		return;

	if (event->button() == Qt::RightButton) {
		showMenu(event->globalPos());
		return;
	}

	if (event->button() == Qt::LeftButton) {
		Q_FOREACH (const auto field, valueFields()) {
			field->unselect();
		}
	}
}

void ODBRegView::updateFont() {
	QFont font;
	if (!font.fromString(edb::v1::config().registers_font)) {
		font = QFont("Monospace");
		font.setStyleHint(QFont::TypeWriter);
	}
	setFont(font);
}

void ODBRegView::fieldSelected() {
	Q_FOREACH (const auto field, valueFields())
		if (sender() != field)
			field->unselect();
	ensureWidgetVisible(static_cast<QWidget *>(sender()), 0, 0);
}

void ODBRegView::showMenu(const QPoint &position, const QList<QAction *> &additionalItems) const {
	QMenu menu;
	auto items = additionalItems + menuItems_;

	if (model_->activeIndex().isValid()) {
		QList<QAction *> debuggerActions;
		QMetaObject::invokeMethod(edb::v1::debugger_ui, "currentRegisterContextMenuItems", Qt::DirectConnection, Q_RETURN_ARG(QList<QAction *>, debuggerActions));
		items.push_back(nullptr);
		items.append(debuggerActions);
	}

	for (const auto action : items)
		if (action)
			menu.addAction(action);
		else
			menu.addSeparator();

	menu.exec(position);
}

void ODBRegView::settingsUpdated() {
	// this slot is now triggered whenever the settings dialog is closed,
	// so it's a good spot to update the fonts and anything else which
	// may be affected by user config
	updateFont();
	modelReset();
}

ODBRegView::ODBRegView(const QString &settingsGroup, QWidget *parent)
	: QScrollArea(parent),
	  hiddenGroupsMenu_{new QMenu(this)},
	  hiddenGroupsAction_{new QAction(tr("Show hidden group"), this)},
	  dialogEditGpr_(new DialogEditGPR(this)),
	  dialogEditSIMDReg_(new DialogEditSimdRegister(this)),
#if defined(EDB_X86) || defined(EDB_X86_64)
	  dialogEditFpu_(new DialogEditFPU(this))
#else
	  dialogEditFpu_(nullptr)
#endif
{
	setObjectName("ODBRegView");

	connect(&edb::v1::config(), &Configuration::settingsUpdated, this, &ODBRegView::settingsUpdated);

	updateFont();

	const auto canvas = new Canvas(this);
	setWidget(canvas);
	setWidgetResizable(true);

	{
		const auto sep = new QAction(this);
		sep->setSeparator(true);
		menuItems_.push_back(sep);
		menuItems_.push_back(new_action(tr("Copy all registers"), this, [this](bool) {
			copyAllRegisters();
		}));
		hiddenGroupsAction_->setMenu(hiddenGroupsMenu_);
		menuItems_.push_back(hiddenGroupsAction_);
	}

	QSettings settings;
	settings.beginGroup(settingsGroup);
	const auto groupListV = settings.value(SETTINGS_GROUPS_ARRAY_NODE);
	if (settings.group().isEmpty() || !groupListV.isValid()) {
		visibleGroupTypes_ = std::vector<RegisterGroupType>(allRegisterGroups.begin(), allRegisterGroups.end());
	} else {
		Q_FOREACH (const auto &grp, groupListV.toStringList()) {
			const auto group = findGroup(grp);
			if (group >= RegisterGroupType::NUM_GROUPS) {
				qWarning() << qPrintable(QString("Warning: failed to understand group %1").arg(group));
				continue;
			}
			visibleGroupTypes_.emplace_back(group);
		}
	}

	connect(new QShortcut(QKeySequence::Copy, this, nullptr, nullptr, Qt::WidgetShortcut), &QShortcut::activated, this, &ODBRegView::copyRegisterToClipboard);
}

void ODBRegView::copyRegisterToClipboard() const {
	const auto selected = selectedField();
	if (selected)
		selected->copyToClipboard();
}

DialogEditGPR *ODBRegView::gprEditDialog() const {
	return dialogEditGpr_;
}

DialogEditSimdRegister *ODBRegView::simdEditDialog() const {
	return dialogEditSIMDReg_;
}

DialogEditFPU *ODBRegView::fpuEditDialog() const {
	return dialogEditFpu_;
}

void ODBRegView::copyAllRegisters() {
	auto allFields = fields();
	std::sort(allFields.begin(), allFields.end(), [](const FieldWidget *f1, const FieldWidget *f2) {
		const auto f1Pos = field_position(f1);
		const auto f2Pos = field_position(f2);
		if (f1Pos.y() < f2Pos.y())
			return true;
		if (f1Pos.y() > f2Pos.y())
			return false;
		return f1Pos.x() < f2Pos.x();
	});

	QString text;
	int textLine   = 0;
	int textColumn = 0;

	for (const auto field : allFields) {
		while (field->lineNumber() > textLine) {
			++textLine;
			textColumn = 0;
			text       = text.trimmed() + '\n';
		}
		while (field->columnNumber() > textColumn) {
			++textColumn;
			text += ' ';
		}
		const QString fieldText = field->text();
		if (field->alignment() == Qt::AlignRight) {
			const int fwidth     = field->fieldWidth();
			const int spaceWidth = fwidth - fieldText.length();
			text += QString(spaceWidth, ' ');
			textColumn += spaceWidth;
		}
		text += fieldText;
		textColumn += fieldText.length();
	}

	QApplication::clipboard()->setText(text.trimmed());
}

void ODBRegView::groupHidden(RegisterGroup *group) {
	using namespace std;
	assert(util::contains(groups_, group));
	const auto groupPtrIter = std::find(groups_.begin(), groups_.end(), group);
	auto &groupPtr          = *groupPtrIter;
	groupPtr->deleteLater();
	groupPtr = nullptr;

	auto &types(visibleGroupTypes_);
	const auto groupType = static_cast<RegisterGroupType>(groupPtrIter - groups_.begin());
	types.erase(remove_if(types.begin(), types.end(), [=](const RegisterGroupType type) { return type == groupType; }), types.end());
	hiddenGroupsMenu_->addAction(RegisterGroupTypeNames[groupType], [=] { restoreHiddenGroup(groupType); });
	hiddenGroupsAction_->setVisible(true);
}

void ODBRegView::saveState(const QString &settingsGroup) const {
	QSettings settings;
	settings.beginGroup(settingsGroup);
	settings.remove(SETTINGS_GROUPS_ARRAY_NODE);
	QStringList groupTypes;
	for (auto type : visibleGroupTypes_)
		groupTypes << RegisterGroupTypeNames[type];
	settings.setValue(SETTINGS_GROUPS_ARRAY_NODE, groupTypes);
}

void ODBRegView::setModel(RegisterViewModelBase::Model *model) {
	model_ = model;
	connect(model, &RegisterViewModelBase::Model::modelReset, this, &ODBRegView::modelReset);
	connect(model, &RegisterViewModelBase::Model::dataChanged, this, &ODBRegView::modelUpdated);
	modelReset();
}

RegisterGroup *ODBRegView::makeGroup(RegisterGroupType type) {

	if (!model_->rowCount())
		return nullptr;

	std::vector<QModelIndex> nameValCommentIndices;

	using RegisterViewModelBase::Model;
	QString groupName;

	switch (type) {
	case RegisterGroupType::GPR: {
		groupName           = tr("GPRs");
		const auto catIndex = find_model_category(model_, GprCategoryName);
		if (!catIndex.isValid())
			break;
		for (int row = 0; row < model_->rowCount(catIndex); ++row)
			nameValCommentIndices.emplace_back(model_->index(row, ModelNameColumn, catIndex));
		break;
	}
#if defined(EDB_X86) || defined(EDB_X86_64)
	case RegisterGroupType::EFL:
		return create_eflags(model_, widget());
	case RegisterGroupType::ExpandedEFL:
		return create_expanded_eflags(model_, widget());
	case RegisterGroupType::FPUData:
		return create_fpu_data(model_, widget());
	case RegisterGroupType::FPUWords:
		return create_fpu_words(model_, widget());
	case RegisterGroupType::FPULastOp:
		return create_fpu_last_op(model_, widget());
	case RegisterGroupType::Debug:
		return create_debug_group(model_, widget());
	case RegisterGroupType::MXCSR:
		return create_mxcsr(model_, widget());
	case RegisterGroupType::MMX:
		return createSIMDGroup(model_, widget(), "MMX", "MM");
	case RegisterGroupType::SSEData:
		return createSIMDGroup(model_, widget(), "SSE", "XMM");
	case RegisterGroupType::AVXData:
		return createSIMDGroup(model_, widget(), "AVX", "YMM");
	case RegisterGroupType::Segment: {
		groupName           = tr("Segment Registers");
		const auto catIndex = find_model_category(model_, "Segment");
		if (!catIndex.isValid())
			break;
		for (int row = 0; row < model_->rowCount(catIndex); ++row)
			nameValCommentIndices.emplace_back(model_->index(row, ModelNameColumn, catIndex));
		break;
	}
	case RegisterGroupType::rIP: {
		groupName           = tr("Instruction Pointer");
		const auto catIndex = find_model_category(model_, "General Status");
		if (!catIndex.isValid())
			break;
		nameValCommentIndices.emplace_back(find_model_register(catIndex, "RIP"));
		nameValCommentIndices.emplace_back(find_model_register(catIndex, "EIP"));
		break;
	}
#elif defined(EDB_ARM32)
	case RegisterGroupType::CPSR:
		return createCPSR(model_, widget());
	case RegisterGroupType::ExpandedCPSR:
		return createExpandedCPSR(model_, widget());
	case RegisterGroupType::FPSCR:
		return createFPSCR(model_, widget());
#endif
	default:
		qWarning() << "Warning: unexpected register group type requested in" << Q_FUNC_INFO;
		return nullptr;
	}

	nameValCommentIndices.erase(std::remove_if(nameValCommentIndices.begin(), nameValCommentIndices.end(), [](const QModelIndex &index) { return !index.isValid(); }), nameValCommentIndices.end());

	if (nameValCommentIndices.empty()) {
		qWarning() << "Warning: failed to get any useful register indices for regGroupType" << static_cast<long>(type);
		return nullptr;
	}

	const auto group = new RegisterGroup(groupName, widget());
	for (const auto &index : nameValCommentIndices) {
		group->appendNameValueComment(index);
	}

	return group;
}

void ODBRegView::restoreHiddenGroup(const RegisterGroupType type) {
	visibleGroupTypes_.emplace_back(type);
	modelReset();
}

void ODBRegView::modelReset() {

	widget()->hide(); // prevent flicker while groups are added to/removed from the layout

	// not all groups may be in the layout, so delete them individually
	Q_FOREACH (const auto group, groups_) {
		if (group) {
			group->deleteLater();
		}
	}

	groups_.clear();

	const auto layout = static_cast<QVBoxLayout *>(widget()->layout());

	flagsAndSegments_ = std::make_unique<QHBoxLayout>();

	// (3/2+1/2)-letter - Total of 2-letter spacing. Fourth half-letter is from flag values extension.
	// Segment extensions at LHS of the widget don't influence minimumSize request, so no need to take
	// them into account.
	flagsAndSegments_->setSpacing(letter_size(this->font()).width() * 3 / 2);
	flagsAndSegments_->setContentsMargins(QMargins());
	flagsAndSegments_->setAlignment(Qt::AlignLeft);

	bool flagsAndSegsInserted = false;

	hiddenGroupsMenu_->clear();
	hiddenGroupsAction_->setVisible(false);
	for (int group = 0; group < RegisterGroupType::NUM_GROUPS; ++group) {

		const auto groupType = static_cast<RegisterGroupType>(group);
		if (util::contains(visibleGroupTypes_, groupType)) {
			const auto group = makeGroup(groupType);
			groups_.push_back(group);
			if (!group)
				continue;
#if defined(EDB_X86) || defined(EDB_X86_64)
			if (groupType == RegisterGroupType::Segment || groupType == RegisterGroupType::ExpandedEFL) {
				flagsAndSegments_->addWidget(group);
				if (!flagsAndSegsInserted) {
					layout->addLayout(flagsAndSegments_.get());
					flagsAndSegsInserted = true;
				}
			} else
#endif
				layout->addWidget(group);
		} else {
			groups_.push_back(nullptr);
			hiddenGroupsMenu_->addAction(RegisterGroupTypeNames[groupType], [=] { restoreHiddenGroup(groupType); });
			hiddenGroupsAction_->setVisible(true);
		}
	}

	widget()->show();
}

void ODBRegView::modelUpdated() {
	Q_FOREACH (FieldWidget *field, fields()) {
		field->adjustToData();
	}

	Q_FOREACH (RegisterGroup *group, groups_) {
		if (group) {
			group->adjustWidth();
		}
	}
}

QList<FieldWidget *> ODBRegView::fields() const {

	QList<FieldWidget *> allFields;
	for (RegisterGroup *group : groups_) {
		if (group) {
			allFields.append(group->fields());
		}
	}

	return allFields;
}

QList<ValueField *> ODBRegView::valueFields() const {

	QList<ValueField *> allValues;
	for (RegisterGroup *group : groups_) {
		if (group) {
			allValues.append(group->valueFields());
		}
	}

	return allValues;
}

void ODBRegView::updateFieldsPalette() {
	Q_FOREACH (ValueField *field, valueFields())
		field->updatePalette();
}

ValueField *ODBRegView::selectedField() const {
	Q_FOREACH (ValueField *field, valueFields()) {
		if (field->isSelected()) {
			return field;
		}
	}

	return nullptr;
}

void ODBRegView::selectAField() {
	const QList<ValueField *> fields = valueFields();
	if (!fields.isEmpty()) {
		fields.front()->select();
	}
}

void ODBRegView::keyPressEvent(QKeyEvent *event) {

	ValueField *selected = selectedField();

	switch (event->key()) {
	case Qt::Key_Up:
		if (selected && selected->up()) {
			selected->up()->select();
			return;
		}
		if (!selected)
			selectAField();
		break;
	case Qt::Key_Down:
		if (selected && selected->down()) {
			selected->down()->select();
			return;
		}
		if (!selected)
			selectAField();
		break;
	case Qt::Key_Left:
		if (selected && selected->left()) {
			selected->left()->select();
			return;
		}
		if (!selected)
			selectAField();
		break;
	case Qt::Key_Right:
		if (selected && selected->right()) {
			selected->right()->select();
			return;
		}
		if (!selected)
			selectAField();
		break;
	case Qt::Key_Enter:
	case Qt::Key_Return:
		if (selected) {
			selected->defaultAction();
			return;
		}
		break;
	case Qt::Key_Menu:
		if (selected)
			selected->showMenu(selected->mapToGlobal(selected->rect().bottomLeft()));
		else
			showMenu(mapToGlobal(QPoint()));
		break;
	case SetToZeroKey:
		if (selected) {
			selected->setZero();
			return;
		}
		break;
	case IncrementKey:
		if (selected) {
			selected->increment();
			return;
		}
		break;
	case DecrementKey:
		if (selected) {
			selected->decrement();
			return;
		}
		break;
	}
	QScrollArea::keyPressEvent(event);
}

}

```

`plugins/ODbgRegisterView/RegisterView.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ODBG_REGISTER_VIEW_H_20151230_
#define ODBG_REGISTER_VIEW_H_20151230_

#include "RegisterViewModelBase.h"

#include <QHBoxLayout>
#include <QPersistentModelIndex>
#include <QScrollArea>
#include <QString>

#include <memory>

class QMenu;
namespace ODbgRegisterView {

class DialogEditSimdRegister;
class DialogEditGPR;
class DialogEditFPU;
class RegisterGroup;
class ValueField;
class FieldWidget;

class ODBRegView : public QScrollArea {
	Q_OBJECT

public:
	enum RegisterGroupType : int {
#if defined(EDB_X86) || defined(EDB_X86_64)
		GPR,
		rIP,
		ExpandedEFL,
		Segment,
		EFL,
		FPUData,
		FPUWords,
		FPULastOp,
		Debug,
		MMX,
		SSEData,
		AVXData,
		MXCSR,
#elif defined(EDB_ARM32)
		GPR,
		CPSR,
		ExpandedCPSR,
		FPSCR,
#else
#error "Not implemented"
#endif
		NUM_GROUPS
	};

public:
	explicit ODBRegView(const QString &settings, QWidget *parent = nullptr);
	void setModel(RegisterViewModelBase::Model *model);
	QList<ValueField *> valueFields() const;
	QList<FieldWidget *> fields() const;
	void showMenu(const QPoint &position, const QList<QAction *> &additionalItems = {}) const;
	void saveState(const QString &settings) const;
	void groupHidden(RegisterGroup *group);
	DialogEditGPR *gprEditDialog() const;
	DialogEditSimdRegister *simdEditDialog() const;
	DialogEditFPU *fpuEditDialog() const;
	void selectAField();

private:
	RegisterGroup *makeGroup(RegisterGroupType type);
	void restoreHiddenGroup(RegisterGroupType type);

private:
	ValueField *selectedField() const;
	void updateFieldsPalette();
	void keyPressEvent(QKeyEvent *event) override;
	void mousePressEvent(QMouseEvent *event) override;
	void updateFont();

public Q_SLOTS:
	void fieldSelected();

private Q_SLOTS:
	void modelReset();
	void modelUpdated();
	void copyAllRegisters();
	void copyRegisterToClipboard() const;
	void settingsUpdated();

private:
	RegisterViewModelBase::Model *model_ = nullptr;
	QList<RegisterGroup *> groups_;
	std::unique_ptr<QHBoxLayout> flagsAndSegments_;
	std::vector<RegisterGroupType> visibleGroupTypes_;
	QList<QAction *> menuItems_;
	QMenu* hiddenGroupsMenu_;
	QAction* hiddenGroupsAction_;
	DialogEditGPR *dialogEditGpr_;
	DialogEditSimdRegister *dialogEditSIMDReg_;
	DialogEditFPU *dialogEditFpu_;
};

}

#endif

```

`plugins/ODbgRegisterView/SimdValueManager.cpp`:

```cpp

#include "SimdValueManager.h"
#include "ODbgRV_Util.h"
#include "ValueField.h"
#include "util/Container.h"

namespace ODbgRegisterView {

SimdValueManager::SimdValueManager(int lineInGroup, const QModelIndex &nameIndex, RegisterGroup *parent)
	: QObject(parent), regIndex_(nameIndex), lineInGroup_(lineInGroup) {

	setupMenu();

	assert(nameIndex.isValid());
	connect(nameIndex.model(), SIGNAL(SIMDDisplayFormatChanged()), this, SLOT(displayFormatChanged()));
	displayFormatChanged();
}

void SimdValueManager::fillGroupMenu() {
	const auto group = this->group();
	group->menuItems_.push_back(new_action_separator(this));
	group->menuItems_.push_back(menuItems_[VIEW_AS_BYTES]);
	group->menuItems_.push_back(menuItems_[VIEW_AS_WORDS]);
	group->menuItems_.push_back(menuItems_[VIEW_AS_DWORDS]);
	group->menuItems_.push_back(menuItems_[VIEW_AS_QWORDS]);
	group->menuItems_.push_back(new_action_separator(this));
	group->menuItems_.push_back(menuItems_[VIEW_AS_FLOAT32]);
	group->menuItems_.push_back(menuItems_[VIEW_AS_FLOAT64]);
	group->menuItems_.push_back(new_action_separator(this));
	group->menuItems_.push_back(menuItems_[VIEW_INT_AS_HEX]);
	group->menuItems_.push_back(menuItems_[VIEW_INT_AS_SIGNED]);
	group->menuItems_.push_back(menuItems_[VIEW_INT_AS_UNSIGNED]);
}

auto SimdValueManager::model() const -> Model * {
	const auto model = static_cast<const Model *>(regIndex_.model());
	// The model is not supposed to have been created as const object,
	// and our manipulations won't invalidate the index.
	// Thus cast the const away.
	return const_cast<Model *>(model);
}

void SimdValueManager::showAsInt(Model::ElementSize size) {
	model()->setChosenSIMDSize(regIndex_.parent(), size);
	model()->setChosenSIMDFormat(regIndex_.parent(), intMode_);
}

void SimdValueManager::showAsFloat(Model::ElementSize size) {
	model()->setChosenSIMDFormat(regIndex_.parent(), NumberDisplayMode::Float);

	switch (size) {
	case Model::ElementSize::DWORD:
		model()->setChosenSIMDSize(regIndex_.parent(), Model::ElementSize::DWORD);
		break;
	case Model::ElementSize::QWORD:
		model()->setChosenSIMDSize(regIndex_.parent(), Model::ElementSize::QWORD);
		break;
	default:
		EDB_PRINT_AND_DIE("Unexpected size: ", size);
	}
}

void SimdValueManager::setIntFormat(NumberDisplayMode format) {
	model()->setChosenSIMDFormat(regIndex_.parent(), format);
}

void SimdValueManager::setupMenu() {
	const auto group        = this->group();
	const auto validFormats = valid_variant(regIndex_.parent().data(Model::ValidSIMDFormatsRole)).value<std::vector<NumberDisplayMode>>();
	// Setup menu if we're the first value field creator
	if (group->valueFields().isEmpty()) {

		menuItems_.push_back(new_action(tr("View %1 as bytes").arg(group->name_), group, [this]() {
			showAsInt(Model::ElementSize::BYTE);
		}));

		menuItems_.push_back(new_action(tr("View %1 as words").arg(group->name_), group, [this]() {
			showAsInt(Model::ElementSize::WORD);
		}));

		menuItems_.push_back(new_action(tr("View %1 as doublewords").arg(group->name_), group, [this]() {
			showAsInt(Model::ElementSize::DWORD);
		}));

		menuItems_.push_back(new_action(tr("View %1 as quadwords").arg(group->name_), group, [this]() {
			showAsInt(Model::ElementSize::QWORD);
		}));

		if (util::contains(validFormats, NumberDisplayMode::Float)) {
			menuItems_.push_back(new_action(tr("View %1 as 32-bit floats").arg(group->name_), group, [this]() {
				showAsFloat(Model::ElementSize::DWORD);
			}));

			menuItems_.push_back(new_action(tr("View %1 as 64-bit floats").arg(group->name_), group, [this]() {
				showAsFloat(Model::ElementSize::QWORD);
			}));
		} else {
			// create empty elements to leave further items with correct indices
			menuItems_.push_back(new_action_separator(this));
			menuItems_.push_back(new_action_separator(this));
		}

		menuItems_.push_back(new_action(tr("View %1 integers as hex").arg(group->name_), group, [this]() {
			setIntFormat(NumberDisplayMode::Hex);
		}));

		menuItems_.push_back(new_action(tr("View %1 integers as signed").arg(group->name_), group, [this]() {
			setIntFormat(NumberDisplayMode::Signed);
		}));

		menuItems_.push_back(new_action(tr("View %1 integers as unsigned").arg(group->name_), group, [this]() {
			setIntFormat(NumberDisplayMode::Unsigned);
		}));

		fillGroupMenu();
	}
}

void SimdValueManager::updateMenu() {
	if (menuItems_.isEmpty())
		return;
	Q_FOREACH (auto item, menuItems_)
		item->setVisible(true);

	using RegisterViewModelBase::Model;
	switch (currentSize()) {
	case Model::ElementSize::BYTE:
		menuItems_[VIEW_AS_BYTES]->setVisible(false);
		break;
	case Model::ElementSize::WORD:
		menuItems_[VIEW_AS_WORDS]->setVisible(false);
		break;
	case Model::ElementSize::DWORD:
		if (currentFormat() != NumberDisplayMode::Float)
			menuItems_[VIEW_AS_DWORDS]->setVisible(false);
		else
			menuItems_[VIEW_AS_FLOAT32]->setVisible(false);
		break;
	case Model::ElementSize::QWORD:
		if (currentFormat() != NumberDisplayMode::Float)
			menuItems_[VIEW_AS_QWORDS]->setVisible(false);
		else
			menuItems_[VIEW_AS_FLOAT64]->setVisible(false);
		break;
	default:
		EDB_PRINT_AND_DIE("Unexpected current size: ", currentSize());
	}
	switch (currentFormat()) {
	case NumberDisplayMode::Float:
		menuItems_[VIEW_INT_AS_HEX]->setVisible(false);
		menuItems_[VIEW_INT_AS_SIGNED]->setVisible(false);
		menuItems_[VIEW_INT_AS_UNSIGNED]->setVisible(false);
		break;
	case NumberDisplayMode::Hex:
		menuItems_[VIEW_INT_AS_HEX]->setVisible(false);
		break;
	case NumberDisplayMode::Signed:
		menuItems_[VIEW_INT_AS_SIGNED]->setVisible(false);
		break;
	case NumberDisplayMode::Unsigned:
		menuItems_[VIEW_INT_AS_UNSIGNED]->setVisible(false);
		break;
	}
}

RegisterGroup *SimdValueManager::group() const {
	return checked_cast<RegisterGroup>(parent());
}

void SimdValueManager::displayFormatChanged() {
	const auto newFormat = currentFormat();

	if (newFormat != NumberDisplayMode::Float) {
		intMode_ = newFormat;
	}

	Q_FOREACH (const auto elem, elements_) {
		elem->deleteLater();
	}

	elements_.clear();

	using RegisterViewModelBase::Model;
	const auto model = regIndex_.model();

	const int sizeRow     = valid_variant(regIndex_.parent().data(Model::ChosenSIMDSizeRowRole)).toInt();
	QModelIndex sizeIndex = model->index(sizeRow, ModelNameColumn, regIndex_);
	const auto elemCount  = model->rowCount(sizeIndex);

	const auto regNameWidth = valid_variant(regIndex_.data(Model::FixedLengthRole)).toInt();
	int column              = regNameWidth + 1;
	const auto elemWidth    = valid_variant(model->index(0, ModelValueColumn, sizeIndex).data(Model::FixedLengthRole)).toInt();
	for (int elemN = elemCount - 1; elemN >= 0; --elemN) {
		const auto elemIndex = model->index(elemN, ModelValueColumn, sizeIndex);
		const auto field     = new ValueField(elemWidth, elemIndex, group());
		elements_.push_back(field);
		field->setAlignment(Qt::AlignRight);
		group()->insert(lineInGroup_, column, field);
		column += elemWidth + 1;
	}

	updateMenu();
}

RegisterViewModelBase::Model::ElementSize SimdValueManager::currentSize() const {
	using RegisterViewModelBase::Model;
	const int size = valid_variant(regIndex_.parent().data(Model::ChosenSIMDSizeRole)).toInt();
	return static_cast<Model::ElementSize>(size);
}

NumberDisplayMode SimdValueManager::currentFormat() const {
	using RegisterViewModelBase::Model;
	const int size = valid_variant(regIndex_.parent().data(Model::ChosenSIMDFormatRole)).toInt();
	return static_cast<NumberDisplayMode>(size);
}

}

```

`plugins/ODbgRegisterView/SimdValueManager.h`:

```h

#ifndef SIMD_VALUE_MANAGER_H_20191119_
#define SIMD_VALUE_MANAGER_H_20191119_

#include "RegisterGroup.h"
#include "RegisterViewModelBase.h"
#include "Util.h"

#include <QAction>
#include <QModelIndex>
#include <QObject>

namespace ODbgRegisterView {

class SimdValueManager : public QObject {
	Q_OBJECT
private:
	QPersistentModelIndex regIndex_;
	int lineInGroup_;
	QList<ValueField *> elements_;
	QList<QAction *> menuItems_;
	NumberDisplayMode intMode_ = NumberDisplayMode::Hex;

	enum MenuItemNumbers {
		VIEW_AS_BYTES,
		VIEW_AS_WORDS,
		VIEW_AS_DWORDS,
		VIEW_AS_QWORDS,

		VIEW_AS_FLOAT32,
		VIEW_AS_FLOAT64,

		VIEW_INT_AS_HEX,
		VIEW_INT_AS_SIGNED,
		VIEW_INT_AS_UNSIGNED,

		MENU_ITEMS_COUNT
	};

	using Model = RegisterViewModelBase::Model;
	Model *model() const;
	RegisterGroup *group() const;
	Model::ElementSize currentSize() const;
	NumberDisplayMode currentFormat() const;
	void setupMenu();
	void updateMenu();
	void fillGroupMenu();

public:
	SimdValueManager(int lineInGroup, const QModelIndex &nameIndex, RegisterGroup *parent = nullptr);

public Q_SLOTS:
	void displayFormatChanged();

private:
	void showAsInt(Model::ElementSize size);
	void showAsFloat(Model::ElementSize size);
	void setIntFormat(NumberDisplayMode format);
};

}

#endif

```

`plugins/ODbgRegisterView/ValueField.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ValueField.h"
#include "DialogEditGPR.h"
#include "DialogEditSimdRegister.h"
#include "ODbgRV_Common.h"
#include "ODbgRV_Util.h"
#include "RegisterGroup.h"
#include "RegisterView.h"
#include "util/Font.h"
#if defined(EDB_X86) || defined(EDB_X86_64)
#include "DialogEditFPU.h"
#include "ODbgRV_x86Common.h"
#endif

#include <QApplication>
#include <QClipboard>
#include <QMouseEvent>
#include <QPainter>
#include <QStyle>
#include <QStyleFactory>
#include <QStyleOptionViewItem>

namespace ODbgRegisterView {
namespace {
QStyle *flatStyle = nullptr;
}

ValueField::ValueField(int fieldWidth, const QModelIndex &index, QWidget *parent, Qt::WindowFlags f)
	: ValueField(
		  fieldWidth, index, [](const QString &s) { return s; }, parent, f) {
}

ValueField::ValueField(int fieldWidth, const QModelIndex &index, const std::function<QString(const QString &)> &valueFormatter, QWidget *parent, Qt::WindowFlags f)
	: FieldWidget(fieldWidth, index, parent, f), valueFormatter_(valueFormatter) {

	setObjectName("ValueField");
	setDisabled(false);
	setMouseTracking(true);

// Set some known style to avoid e.g. Oxygen's label transition animations, which
// break updating of colors such as "register changed" when single-stepping frequently
#define FLAT_STYLE_NAME "fusion"

	if (!flatStyle)
		flatStyle = QStyleFactory::create(FLAT_STYLE_NAME);

	assert(flatStyle);
	setStyle(flatStyle);

	using namespace RegisterViewModelBase;

	if (index.data(Model::IsNormalRegisterRole).toBool() || index.data(Model::IsSIMDElementRole).toBool()) {
		menuItems_.push_back(new_action(tr("&Modify") + QChar(0x2026), this, [this](bool) {
			defaultAction();
		}));

		menuItems_.back()->setShortcut(QKeySequence(Qt::Key_Enter));
	} else if (index.data(Model::IsBitFieldRole).toBool() && index.data(Model::BitFieldLengthRole).toInt() == 1) {
		menuItems_.push_back(new_action(tr("&Toggle"), this, [this](bool) {
			defaultAction();
		}));

		menuItems_.back()->setShortcut(QKeySequence(Qt::Key_Enter));
	}

	menuItems_.push_back(new_action(tr("&Copy to clipboard"), this, [this](bool) {
		copyToClipboard();
	}));

	menuItems_.back()->setShortcut(QKeySequence::Copy);

#if defined(EDB_X86) || defined(EDB_X86_64)
	if (index.sibling(index.row(), ModelNameColumn).data().toString() == FsrName) {
		menuItems_.push_back(new_action(tr("P&ush FPU stack"), this, [this](bool) {
			pushFPUStack();
		}));

		menuItems_.push_back(new_action(tr("P&op FPU stack"), this, [this](bool) {
			popFPUStack();
		}));
	}
#endif

	if (index.parent().data().toString() == GprCategoryName) {
		// These should be above others, so prepending instead of appending
		menuItems_.push_front(new_action(tr("In&vert"), this, [this](bool) {
			invert();
		}));

		setToOneAction_ = new_action(tr("Set to &1"), this, [this](bool) {
			setToOne();
		});

		menuItems_.push_front(setToOneAction_);

		setToZeroAction_ = new_action(tr("&Zero"), this, [this](bool) {
			setZero();
		});

		menuItems_.push_front(setToZeroAction_);

		menuItems_.front()->setShortcut(QKeySequence(SetToZeroKey));

		menuItems_.push_front(new_action(tr("&Decrement"), this, [this](bool) {
			decrement();
		}));

		menuItems_.front()->setShortcut(QKeySequence(DecrementKey));

		menuItems_.push_front(new_action(tr("&Increment"), this, [this](bool) {
			increment();
		}));

		menuItems_.front()->setShortcut(QKeySequence(IncrementKey));
	}
}

RegisterViewModelBase::Model *ValueField::model() const {
	using namespace RegisterViewModelBase;
	const auto model = static_cast<const Model *>(index_.model());
	// The model is not supposed to have been created as const object,
	// and our manipulations won't invalidate the index.
	// Thus cast the const away.
	return const_cast<Model *>(model);
}

ValueField *ValueField::bestNeighbor(const std::function<bool(const QPoint &, const ValueField *, const QPoint &)> &firstIsBetter) const {
	ValueField *result = nullptr;
	Q_FOREACH (const auto neighbor, regView()->valueFields()) {
		if (neighbor->isVisible() && firstIsBetter(field_position(neighbor), result, field_position(this))) {
			result = neighbor;
		}
	}
	return result;
}

ValueField *ValueField::up() const {
	return bestNeighbor([](const QPoint &nPos, const ValueField *up, const QPoint &fPos) {
		return nPos.y() < fPos.y() && (!up || distance_squared(nPos, fPos) < distance_squared(field_position(up), fPos));
	});
}

ValueField *ValueField::down() const {
	return bestNeighbor([](const QPoint &nPos, const ValueField *down, const QPoint &fPos) {
		return nPos.y() > fPos.y() && (!down || distance_squared(nPos, fPos) < distance_squared(field_position(down), fPos));
	});
}

ValueField *ValueField::left() const {
	return bestNeighbor([](const QPoint &nPos, const ValueField *left, const QPoint &fPos) {
		return nPos.y() == fPos.y() && nPos.x() < fPos.x() && (!left || left->x() < nPos.x());
	});
}

ValueField *ValueField::right() const {
	return bestNeighbor([](const QPoint &nPos, const ValueField *right, const QPoint &fPos) {
		return nPos.y() == fPos.y() && nPos.x() > fPos.x() && (!right || right->x() > nPos.x());
	});
}

QString ValueField::text() const {
	return valueFormatter_(FieldWidget::text());
}

bool ValueField::changed() const {
	if (!index_.isValid()) {
		return true;
	}

	return valid_variant(index_.data(RegisterViewModelBase::Model::RegisterChangedRole)).toBool();
}

QColor ValueField::fgColorForChangedField() const {
	return Qt::red; // TODO: read from user palette
}

bool ValueField::isSelected() const {
	return selected_;
}

void ValueField::editNormalReg(const QModelIndex &indexToEdit, const QModelIndex &clickedIndex) const {
	using namespace RegisterViewModelBase;

	const auto rV = model()->data(indexToEdit, Model::ValueAsRegisterRole);
	if (!rV.isValid()) {
		return;
	}

	auto r = rV.value<Register>();
	if (!r) {
		return;
	}

	if ((r.type() != Register::TYPE_SIMD) && r.bitSize() <= 64) {

		const auto gprEdit = regView()->gprEditDialog();
		gprEdit->setValue(r);
		if (gprEdit->exec() == QDialog::Accepted) {
			r = gprEdit->value();
			model()->setData(indexToEdit, QVariant::fromValue(r), Model::ValueAsRegisterRole);
		}
	} else if (r.type() == Register::TYPE_SIMD) {
		const auto simdEdit = regView()->simdEditDialog();
		simdEdit->setValue(r);
		const int size         = valid_variant(indexToEdit.parent().data(Model::ChosenSIMDSizeRole)).toInt();
		const int format       = valid_variant(indexToEdit.parent().data(Model::ChosenSIMDFormatRole)).toInt();
		const int elementIndex = clickedIndex.row();
		simdEdit->set_current_element(static_cast<Model::ElementSize>(size), static_cast<NumberDisplayMode>(format), elementIndex);
		if (simdEdit->exec() == QDialog::Accepted) {
			r = simdEdit->value();
			model()->setData(indexToEdit, QVariant::fromValue(r), Model::ValueAsRegisterRole);
		}
	}
#if defined(EDB_X86) || defined(EDB_X86_64)
	else if (r.type() == Register::TYPE_FPU) {
		const auto fpuEdit = regView()->fpuEditDialog();
		fpuEdit->setValue(r);
		if (fpuEdit->exec() == QDialog::Accepted) {
			r = fpuEdit->value();
			model()->setData(indexToEdit, QVariant::fromValue(r), Model::ValueAsRegisterRole);
		}
	}
#endif
}

QModelIndex ValueField::regIndex() const {
	using namespace RegisterViewModelBase;

	if (index_.data(Model::IsBitFieldRole).toBool()) {
		return index_;
	}

	if (index_.data(Model::IsNormalRegisterRole).toBool()) {
		return index_.sibling(index_.row(), ModelNameColumn);
	}

	return {};
}

void ValueField::defaultAction() {
	using namespace RegisterViewModelBase;
	if (index_.data(Model::IsBitFieldRole).toBool() && index_.data(Model::BitFieldLengthRole).toInt() == 1) {
		// toggle
		// TODO: Model: make it possible to set bit field itself, without manipulating parent directly
		//              I.e. set value without knowing field offset, then setData(fieldIndex,word)
		const auto regIndex = index_.parent().sibling(index_.parent().row(), ModelValueColumn);
		auto byteArr        = regIndex.data(Model::RawValueRole).toByteArray();
		if (byteArr.isEmpty())
			return;
		std::uint64_t word(0);
		std::memcpy(&word, byteArr.constData(), byteArr.size());
		const auto offset = valid_variant(index_.data(Model::BitFieldOffsetRole)).toInt();
		word ^= 1ull << offset;
		std::memcpy(byteArr.data(), &word, byteArr.size());
		model()->setData(regIndex, byteArr, Model::RawValueRole);
	} else if (index_.data(Model::IsNormalRegisterRole).toBool()) {
		editNormalReg(index_, index_);
	} else if (index_.data(Model::IsSIMDElementRole).toBool()) {
		editNormalReg(index_.parent().parent(), index_);
	} else if (index_.parent().data(Model::IsFPURegisterRole).toBool()) {
		editNormalReg(index_.parent(), index_);
	}
}

void ValueField::adjustToData() {
	if (index_.parent().data().toString() == GprCategoryName) {
		using RegisterViewModelBase::Model;
		auto byteArr = index_.data(Model::RawValueRole).toByteArray();
		if (byteArr.isEmpty()) {
			return;
		}

		std::uint64_t value(0);
		assert(byteArr.size() <= int(sizeof(value)));
		std::memcpy(&value, byteArr.constData(), byteArr.size());

		setToOneAction_->setVisible(value != 1u);
		setToZeroAction_->setVisible(value != 0u);
	}
	FieldWidget::adjustToData();
	updatePalette();
}

void ValueField::updatePalette() {
	if (changed()) {
		auto palette                = this->palette();
		const QColor changedFGColor = fgColorForChangedField();
		palette.setColor(foregroundRole(), changedFGColor);
		palette.setColor(QPalette::HighlightedText, changedFGColor);
		setPalette(palette);
	} else
		setPalette(QApplication::palette());

	QLabel::update();
}

void ValueField::enterEvent(QEvent *) {
	hovered_ = true;
	updatePalette();
}

void ValueField::leaveEvent(QEvent *) {
	hovered_ = false;
	updatePalette();
}

void ValueField::select() {
	if (selected_) {
		return;
	}

	selected_ = true;
	model()->setActiveIndex(regIndex());
	Q_EMIT selected();
	updatePalette();
}

void ValueField::showMenu(const QPoint &position) {
	group()->showMenu(position, menuItems_);
}

void ValueField::mousePressEvent(QMouseEvent *event) {
	if (event->button() & (Qt::LeftButton | Qt::RightButton)) {
		select();
	}

	if (event->button() == Qt::RightButton && event->type() != QEvent::MouseButtonDblClick) {
		showMenu(event->globalPos());
	}
}

void ValueField::unselect() {
	if (!selected_) {
		return;
	}

	selected_ = false;
	updatePalette();
}

void ValueField::mouseDoubleClickEvent(QMouseEvent *event) {
	mousePressEvent(event);
	defaultAction();
}

void ValueField::paintEvent(QPaintEvent *) {
	const auto regView = this->regView();
	QPainter painter(this);

	QStyleOptionViewItem option;

	option.rect                   = rect();
	option.showDecorationSelected = true;
	option.text                   = text();
	option.font                   = font();
	option.palette                = palette();
	option.textElideMode          = Qt::ElideNone;
	option.state |= QStyle::State_Enabled;
	option.displayAlignment = alignment();

	if (selected_) {
		option.state |= QStyle::State_Selected;
	}

	if (hovered_) {
		option.state |= QStyle::State_MouseOver;
	}

	if (regView->hasFocus()) {
		option.state |= QStyle::State_Active;
	}

	QApplication::style()->drawControl(QStyle::CE_ItemViewItem, &option, &painter);
}

namespace {

void add_to_top(RegisterViewModelBase::Model *model, const QModelIndex &fsrIndex, std::int16_t delta) {

	using namespace RegisterViewModelBase;

	// TODO: Model: make it possible to set bit field itself, without manipulating parent directly
	//              I.e. set value without knowing field offset, then setData(fieldIndex,word)
	auto byteArr = fsrIndex.data(Model::RawValueRole).toByteArray();
	if (byteArr.isEmpty())
		return;

	std::uint16_t word(0);
	assert(byteArr.size() == sizeof(word));
	std::memcpy(&word, byteArr.constData(), byteArr.size());
	const auto value = (word >> 11) & 7;
	word             = (word & ~0x3800) | (((value + delta) & 7) << 11);
	std::memcpy(byteArr.data(), &word, byteArr.size());
	model->setData(fsrIndex, byteArr, Model::RawValueRole);
}

}

#if defined(EDB_X86) || defined(EDB_X86_64)
void ValueField::pushFPUStack() {
	assert(index_.sibling(index_.row(), ModelNameColumn).data().toString() == FsrName);
	add_to_top(model(), index_, -1);
}

void ValueField::popFPUStack() {
	assert(index_.sibling(index_.row(), ModelNameColumn).data().toString() == FsrName);
	add_to_top(model(), index_, +1);
}
#endif

void ValueField::copyToClipboard() const {
	QApplication::clipboard()->setText(text());
}

namespace {

template <typename Op>
void change_gpr(const QModelIndex &index, RegisterViewModelBase::Model *const model, const Op &change) {

	if (index.parent().data().toString() != GprCategoryName) {
		return;
	}

	using RegisterViewModelBase::Model;
	auto byteArr = index.data(Model::RawValueRole).toByteArray();

	if (byteArr.isEmpty()) {
		return;
	}

	std::uint64_t value(0);
	assert(byteArr.size() <= int(sizeof(value)));
	std::memcpy(&value, byteArr.constData(), byteArr.size());
	value = change(value);
	std::memcpy(byteArr.data(), &value, byteArr.size());
	model->setData(index, byteArr, Model::RawValueRole);
}

}

void ValueField::decrement() {
	change_gpr(index_, model(), [](std::uint64_t v) {
		return v - 1;
	});
}

void ValueField::increment() {
	change_gpr(index_, model(), [](std::uint64_t v) {
		return v + 1;
	});
}

void ValueField::invert() {
	change_gpr(index_, model(), [](std::uint64_t v) {
		return ~v;
	});
}

void ValueField::setZero() {
	change_gpr(index_, model(), [](int) {
		return 0;
	});
}

void ValueField::setToOne() {
	change_gpr(index_, model(), [](int) {
		return 1;
	});
}

}

```

`plugins/ODbgRegisterView/ValueField.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef VALUE_FIELD_H_20170818_
#define VALUE_FIELD_H_20170818_

#include "FieldWidget.h"
#include "RegisterViewModelBase.h"

#include <functional>

class QAction;
class QMouseEvent;

namespace ODbgRegisterView {

class ValueField : public FieldWidget {
	Q_OBJECT

private:
	bool selected_ = false;
	bool hovered_  = false;
	std::function<QString(QString)> valueFormatter_;

	// For GPR
	QAction *setToZeroAction_ = nullptr;
	QAction *setToOneAction_  = nullptr;

protected:
	QList<QAction *> menuItems_;

private:
	void init();
	QColor fgColorForChangedField() const;
	void editNormalReg(const QModelIndex &indexToEdit, const QModelIndex &clickedIndex) const;

protected:
	RegisterViewModelBase::Model *model() const;
	bool changed() const;

	void enterEvent(QEvent *) override;
	void leaveEvent(QEvent *) override;
	void mousePressEvent(QMouseEvent *event) override;
	void mouseDoubleClickEvent(QMouseEvent *event) override;
	void paintEvent(QPaintEvent *event) override;

	ValueField *bestNeighbor(const std::function<bool(const QPoint &neighborPos, const ValueField *curResult, const QPoint &selfPos)> &firstIsBetter) const;

public:
	ValueField(int fieldWidth, const QModelIndex &index_, const std::function<QString(const QString &)> &valueFormatter_, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	ValueField(int fieldWidth, const QModelIndex &index_, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	ValueField *up() const;
	ValueField *down() const;
	ValueField *left() const;
	ValueField *right() const;

	bool isSelected() const;
	void showMenu(const QPoint &position);
	QString text() const override;
	QModelIndex regIndex() const;

public Q_SLOTS:
	void defaultAction();
#if defined(EDB_X86) || defined(EDB_X86_64)
	void pushFPUStack();
	void popFPUStack();
#endif
	void adjustToData() override;
	void select();
	void unselect();
	virtual void updatePalette();
	void copyToClipboard() const;
	void setZero();
	void setToOne();
	void increment();
	void decrement();
	void invert();

Q_SIGNALS:
	void selected();
};

}

#endif

```

`plugins/ODbgRegisterView/VolatileNameField.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "VolatileNameField.h"

namespace ODbgRegisterView {

VolatileNameField::VolatileNameField(int fieldWidth, const std::function<QString()> &valueFormatter, QWidget *parent, Qt::WindowFlags f)
	: FieldWidget(fieldWidth, "", parent, f), valueFormatter(valueFormatter) {
}

QString VolatileNameField::text() const {
	return valueFormatter();
}

}

```

`plugins/ODbgRegisterView/VolatileNameField.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef VOLATILE_NAME_FIELD_H_20151031_
#define VOLATILE_NAME_FIELD_H_20151031_

#include "FieldWidget.h"
#include <QString>
#include <functional>

namespace ODbgRegisterView {

class VolatileNameField : public FieldWidget {
	Q_OBJECT

private:
	std::function<QString()> valueFormatter;

public:
	VolatileNameField(int fieldWidth, const std::function<QString()> &valueFormatter, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	QString text() const override;
};

}

#endif

```

`plugins/ODbgRegisterView/arch/arm-generic/armGroups.cpp`:

```cpp
/*
Copyright (C) 2017 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "armGroups.h"
#include "BitFieldDescription.h"
#include "MultiBitFieldWidget.h"
#include "ODbgRV_Util.h"
#include "QtHelper.h"
#include "ValueField.h"
#include <QDebug>
#include <unordered_map>

namespace ODbgRegisterView {

Q_DECLARE_NAMESPACE_TR(ODbgRegisterView)

namespace {

const BitFieldDescription itBaseCondDescription = {
	2,
	{
		"EQ",
		"HS",
		"MI",
		"VS",
		"HI",
		"GE",
		"GT",
		"AL",
	},
	{
		tr("Set EQ"),
		tr("Set HS"),
		tr("Set MI"),
		tr("Set VS"),
		tr("Set HI"),
		tr("Set GE"),
		tr("Set GT"),
		tr("Set AL"),
	},
};

const BitFieldDescription fpscrSTRDescription = {
	3,
	{
		" 1 ",
		"D=1",
		"D=2",
		" 2 ",
	},
	{
		tr("Set stride to 1"),
		"",
		"",
		tr("Set stride to 2"),
	},
};

const BitFieldDescription fpscrLENDescription = {
	1,
	{
		// FPSCR[18:16] = LEN-1, while we want to show LEN value itself
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
	},
	{
		// FIXME: this is ugly. Maybe edit it as a number?
		tr("Set LEN to 1"),
		tr("Set LEN to 2"),
		tr("Set LEN to 3"),
		tr("Set LEN to 4"),
		tr("Set LEN to 5"),
		tr("Set LEN to 6"),
		tr("Set LEN to 7"),
		tr("Set LEN to 8"),
	},
};

const BitFieldDescription roundControlDescription = {
	4,
	{
		"NEAR",
		"DOWN",
		"  UP",
		"ZERO",
	},
	{
		tr("Round to nearest"),
		tr("Round down"),
		tr("Round up"),
		tr("Round toward zero"),
	},
};
}

RegisterGroup *createCPSR(RegisterViewModelBase::Model *model, QWidget *parent) {
	const auto catIndex = find_model_category(model, "General Status");
	if (!catIndex.isValid())
		return nullptr;
	auto nameIndex = find_model_register(catIndex, "CPSR");
	if (!nameIndex.isValid())
		return nullptr;
	const auto group    = new RegisterGroup("CPS", parent);
	const int nameWidth = 3;
	int column          = 0;
	group->insert(0, column, new FieldWidget("CPS", group));
	const auto valueWidth = 8;
	const auto valueIndex = nameIndex.sibling(nameIndex.row(), ModelValueColumn);
	column += nameWidth + 1;
	group->insert(0, column, new ValueField(
								 valueWidth, valueIndex, [](QString const &v) { return v.right(8); }, group));
	const auto commentIndex = nameIndex.sibling(nameIndex.row(), ModelCommentColumn);
	column += valueWidth + 1;
	group->insert(0, column, new FieldWidget(0, commentIndex, group));

	return group;
}

RegisterGroup *createExpandedCPSR(RegisterViewModelBase::Model *model, QWidget *parent) {
	using namespace RegisterViewModelBase;

	const auto catIndex = find_model_category(model, "General Status");
	if (!catIndex.isValid())
		return nullptr;
	auto regNameIndex = find_model_register(catIndex, "CPSR");
	if (!regNameIndex.isValid())
		return nullptr;
	const auto group                                            = new RegisterGroup(tr("Expanded CPSR"), parent);
	static const std::unordered_map<char, QString> flagTooltips = {
		{'N', tr("Negative result flag")},
		{'Z', tr("Zero result flag")},
		{'C', tr("Carry flag")},
		{'V', tr("Overflow flag")},
		{'Q', tr("Sticky saturation/overflow flag")},
		{'J', tr("Jazelle state flag")},
		{'E', tr("Big endian state flag")},
		{'T', tr("Thumb state flag")},
	};
	// NOTE: NZCV is intended to align with corresponding name/value fields in FPSCR
	for (int row = 0, groupCol = 28; row < model->rowCount(regNameIndex); ++row) {
		const auto flagNameIndex  = model->index(row, ModelNameColumn, regNameIndex);
		const auto flagValueIndex = model->index(row, ModelValueColumn, regNameIndex);
		const auto flagName       = model->data(flagNameIndex).toString().toUpper();
		if (flagName.length() != 1)
			continue;
		static const int flagNameWidth = 1;
		static const int valueWidth    = 1;
		const char name                = flagName[0].toLatin1();

		switch (name) {
		case 'N':
		case 'Z':
		case 'C':
		case 'V':
		case 'Q':
		case 'J':
		case 'E':
		case 'T': {
			const auto nameField = new FieldWidget(QChar(name), group);
			group->insert(0, groupCol, nameField);
			const auto valueField = new ValueField(valueWidth, flagValueIndex, group);
			group->insert(1, groupCol, valueField);
			groupCol -= 2;

			const auto tooltipStr = flagTooltips.at(name);
			nameField->setToolTip(tooltipStr);
			valueField->setToolTip(tooltipStr);

			break;
		}
		default:
			continue;
		}
	}
	{
		const auto geNameField = new FieldWidget(QLatin1String("GE"), group);
		geNameField->setToolTip(tr("Greater than or Equal flags"));
		group->insert(1, 0, geNameField);
		for (int geIndex = 3; geIndex > -1; --geIndex) {
			const int groupCol    = 5 + 2 * (3 - geIndex);
			const auto tooltipStr = QString("GE%1").arg(geIndex);
			{
				const auto nameField = new FieldWidget(QString::number(geIndex), group);
				group->insert(0, groupCol, nameField);
				nameField->setToolTip(tooltipStr);
			}
			const auto indexInModel = find_model_register(regNameIndex, QString("GE%1").arg(geIndex));
			if (!indexInModel.isValid())
				continue;
			const auto valueIndex = indexInModel.sibling(indexInModel.row(), ModelValueColumn);
			if (!valueIndex.isValid())
				continue;
			const auto valueField = new ValueField(1, valueIndex, group);
			group->insert(1, groupCol, valueField);
			valueField->setToolTip(tooltipStr);
		}
	}
	{
		int column = 0;
		enum { labelRow = 2,
			   valueRow };
		{
			const auto itNameField = new FieldWidget(QLatin1String("IT"), group);
			itNameField->setToolTip(tr("If-Then block state"));
			group->insert(valueRow, column, itNameField);
			column += 3;
		}
		{
			// Using textual names for instructions numbering to avoid confusion between base-0 and base-1 counting
			static const QString tooltips[] =
				{
					tr("Lowest bit of IT-block condition for first instruction"),
					tr("Lowest bit of IT-block condition for second instruction"),
					tr("Lowest bit of IT-block condition for third instruction"),
					tr("Lowest bit of IT-block condition for fourth instruction"),
					tr("Flag marking active four-instruction IT-block"),
				};
			for (int i = 4; i >= 0; --i, column += 2) {
				const auto nameIndex  = find_model_register(regNameIndex, QString("IT%1").arg(i));
				const auto valueIndex = nameIndex.sibling(nameIndex.row(), ModelValueColumn);
				if (!valueIndex.isValid())
					continue;
				const auto valueField = new ValueField(1, valueIndex, group);
				group->insert(valueRow, column, valueField);
				const auto tooltip = tooltips[4 - i];
				valueField->setToolTip(tooltip);
				const auto nameField = new FieldWidget(QString::number(i), group);
				group->insert(labelRow, column, nameField);
				nameField->setToolTip(tooltip);
			}
		}
		{
			const auto itBaseCondNameIndex  = find_model_register(regNameIndex, QString("ITbcond").toUpper());
			const auto itBaseCondValueIndex = itBaseCondNameIndex.sibling(itBaseCondNameIndex.row(), ModelValueColumn);
			if (itBaseCondValueIndex.isValid()) {
				const auto itBaseCondField = new MultiBitFieldWidget(itBaseCondValueIndex, itBaseCondDescription, group);
				group->insert(valueRow, column, itBaseCondField);
				const auto tooltip = tr("IT base condition");
				itBaseCondField->setToolTip(tooltip);
				const auto labelField = new FieldWidget("BC", group);
				group->insert(labelRow, column, labelField);
				labelField->setToolTip(tooltip);
			} else
				qWarning() << "Failed to find IT base condition index in the model";
			column += 3;
		}
	}
	return group;
}

void addDXUOZI(RegisterGroup *const group, QModelIndex const &fpscrIndex, int const startRow, int const startColumn) {

	static const QString exceptions = "DXUOZI";

	static const std::unordered_map<char, QPair<QString, QString>> excNames = {
		{'D', {"ID", tr("Input Denormal")}},
		{'X', {"IX", tr("Inexact")}},
		{'U', {"UF", tr("Underflow")}},
		{'O', {"OF", tr("Overflow")}},
		{'Z', {"DZ", tr("Zero Divide")}},
		{'I', {"IO", tr("Invalid Operation")}},
	};

	for (int exN = 0; exN < exceptions.length(); ++exN) {
		const QString ex          = exceptions[exN];
		const auto excAbbrevStart = excNames.at(ex[0].toLatin1()).first;
		const auto exAbbrev       = excAbbrevStart + "C";
		const auto enabAbbrev     = excAbbrevStart + "E";
		const auto excIndex       = valid_index(find_model_register(fpscrIndex, exAbbrev));
		const auto enabIndex      = valid_index(find_model_register(fpscrIndex, enabAbbrev));
		const int column          = startColumn + exN * 2;
		const auto nameField      = new FieldWidget(ex, group);
		group->insert(startRow, column, nameField);
		const auto excValueField = new ValueField(1, value_index(excIndex), group);
		group->insert(startRow + 1, column, excValueField);
		const auto enabValueField = new ValueField(1, value_index(enabIndex), group);
		group->insert(startRow + 2, column, enabValueField);

		const auto excName = excNames.at(ex[0].toLatin1()).second;
		nameField->setToolTip(excName);
		excValueField->setToolTip(excName + ' ' + tr("Exception flag") + " (" + exAbbrev + ")");
		enabValueField->setToolTip(excName + ' ' + tr("Exception Enable flag") + " (" + enabAbbrev + ")");
	}
}

RegisterGroup *createFPSCR(RegisterViewModelBase::Model *model, QWidget *parent) {
	using namespace RegisterViewModelBase;

	const auto catIndex = find_model_category(model, "VFP");
	if (!catIndex.isValid())
		return nullptr;
	const auto group        = new RegisterGroup("FSC", parent);
	const QString fpscrName = "FSC";
	const int fpscrRow = 0, nzcvLabelRow = fpscrRow;
	const int nzcvRow = fpscrRow, nzcvValueRow = nzcvRow + 1;
	int column = 0;

	const auto fpscrLabelField = new FieldWidget(fpscrName, group);
	fpscrLabelField->setToolTip(tr("Floating-point status and control register") + " (FPSCR)");
	group->insert(fpscrRow, column, fpscrLabelField);
	column += fpscrName.length() + 1;
	const auto fpscrIndex      = find_model_register(catIndex, "FPSCR", ModelValueColumn);
	const auto fpscrValueWidth = fpscrIndex.data(Model::FixedLengthRole).toInt();
	assert(fpscrValueWidth > 0);
	group->insert(fpscrRow, column, new ValueField(fpscrValueWidth, fpscrIndex, group));
	column += fpscrValueWidth + 2;

	{
		static const std::unordered_map<char, QString> nzcvDescriptions = {
			{'N', tr("LessThan flag")},
			{'Z', tr("Equal operands flag")},
			{'C', tr("GreaterThen/Equal/Unordered operands flag")},
			{'V', tr("Unordered operands flag")},
		};

		static const QString nzcv = "NZCV";

		for (int i = 0; i < nzcv.length(); ++i) {
			const auto flag      = nzcv[i];
			const auto flagIndex = valid_index(find_model_register(fpscrIndex, flag, ModelValueColumn));
			const auto nameField = new FieldWidget(flag, group);
			group->insert(nzcvRow, column, nameField);
			const auto flagValueField = new ValueField(1, value_index(flagIndex), group);
			group->insert(nzcvValueRow, column, flagValueField);

			const auto descr = nzcvDescriptions.at(flag.toLatin1());
			nameField->setToolTip(descr);
			flagValueField->setToolTip(descr);
			column += 2;
		}
	}

	column += 1;
	const auto excRow = fpscrRow + 1, enabRow = excRow + 1;
	group->insert(excRow, column, new FieldWidget("Err", group));
	group->insert(enabRow, column, new FieldWidget("Enab", group));
	column += 5;
	addDXUOZI(group, fpscrIndex, fpscrRow, column);

	{
		const int DXUOZIWidth = 6 * 2 - 1;
		group->insert(nzcvValueRow, column + DXUOZIWidth + 1, new FieldWidget(0, comment_index(fpscrIndex), group));
	}

	const QString dnName = "DN", fzName = "FZ", strName = "STR", lenName = "LEN";
	{
		column                  = fpscrName.length() - 1;
		const auto strNameField = new FieldWidget(strName, group);
		const auto strRow       = excRow;
		group->insert(strRow, column, strNameField);
		const auto strIndex      = find_model_register(fpscrIndex, "STR", ModelValueColumn);
		const auto strValueField = new MultiBitFieldWidget(strIndex, fpscrSTRDescription, group);
		column += strName.length();
		group->insert(strRow, column, strValueField);
		const auto strTooltip = tr("Stride (distance between successive values in a vector)");
		strNameField->setToolTip(strTooltip);
		strValueField->setToolTip(strTooltip);
		column += 3;
	}
	{
		const auto fzNameField = new FieldWidget(fzName, group);
		const auto fzRow       = excRow;
		group->insert(fzRow, column, fzNameField);
		const auto fzIndex      = find_model_register(fpscrIndex, "FZ", ModelValueColumn);
		const auto fzValueWidth = 1;
		const auto fzValueField = new ValueField(fzValueWidth, fzIndex, group);
		column += fzName.length() + 1;
		group->insert(fzRow, column, fzValueField);
		const auto fzTooltip = tr("Flush Denormals To Zero");
		fzNameField->setToolTip(fzTooltip);
		fzValueField->setToolTip(fzTooltip);
	}
	{
		column                  = fpscrName.length() - 1;
		const auto lenNameField = new FieldWidget(lenName, group);
		const auto lenRow       = enabRow;
		group->insert(lenRow, column, lenNameField);
		const auto lenIndex      = find_model_register(fpscrIndex, "LEN-1", ModelValueColumn);
		const auto lenValueField = new MultiBitFieldWidget(lenIndex, fpscrLENDescription, group);
		column += lenName.length() + 1;
		group->insert(lenRow, column, lenValueField);
		const auto lenTooltip = tr("Number of registers used by each vector");
		lenNameField->setToolTip(lenTooltip);
		lenValueField->setToolTip(lenTooltip);
		column += 2;
	}
	{
		const auto dnNameField = new FieldWidget(dnName, group);
		const auto dnRow       = enabRow;
		group->insert(dnRow, column, dnNameField);
		const auto dnIndex      = find_model_register(fpscrIndex, "DN", ModelValueColumn);
		const auto dnValueWidth = 1;
		const auto dnValueField = new ValueField(dnValueWidth, dnIndex, group);
		column += dnName.length() + 1;
		group->insert(dnRow, column, dnValueField);
		const auto dnTooltip = tr("Enable default NaN mode");
		dnNameField->setToolTip(dnTooltip);
		dnValueField->setToolTip(dnTooltip);
		column += 2;
	}

	{
		column += 1;
		const QString rndName = "Rnd";
		const auto rndRow     = enabRow;
		group->insert(rndRow, column, new FieldWidget(rndName, group));
		column += rndName.length() + 1;
		const auto rndValueField = new MultiBitFieldWidget(
			find_model_register(fpscrIndex, "RC", ModelValueColumn),
			roundControlDescription, group);
		group->insert(rndRow, column, rndValueField);
		rndValueField->setToolTip(tr("Rounding mode"));
	}

	return group;
}

}

```

`plugins/ODbgRegisterView/arch/arm-generic/armGroups.h`:

```h
/*
Copyright (C) 2017 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ODBG_REGISTER_VIEW_ARM_GROUPS_H_20170819_
#define ODBG_REGISTER_VIEW_ARM_GROUPS_H_20170819_

#include "RegisterView.h"

namespace ODbgRegisterView {

RegisterGroup *createCPSR(RegisterViewModelBase::Model *model, QWidget *parent);
RegisterGroup *createExpandedCPSR(RegisterViewModelBase::Model *model, QWidget *parent);
RegisterGroup *createFPSCR(RegisterViewModelBase::Model *model, QWidget *parent);

}

#endif

```

`plugins/ODbgRegisterView/arch/x86-generic/DialogEditFPU.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogEditFPU.h"
#include "EntryGridKeyUpDownEventFilter.h"
#include "Float80Edit.h"
#include "util/Float.h"

#include <QDebug>
#include <QDialogButtonBox>
#include <QGridLayout>
#include <QLabel>
#include <QLineEdit>
#include <QRegExp>
#include <QVBoxLayout>
#include <array>
#include <cmath>
#include <cstring>
#include <iomanip>
#include <iostream>

namespace ODbgRegisterView {
namespace {

long double readFloat(const QString &strInput, bool &ok) {
	ok = false;
	const QString str(strInput.toLower().trimmed());

	if (const auto value = util::full_string_to_float<long double>(str.toStdString())) {
		ok = true;
		return *value;
	}

	// OK, so either it is invalid/unfinished, or it's some special value
	// We still do want the user to be able to enter common special values
	long double value;

	static const std::array<std::uint8_t, 16> positiveInf{0, 0, 0, 0, 0, 0, 0, 0x80, 0xff, 0x7f, 0, 0, 0, 0, 0, 0};
	static const std::array<std::uint8_t, 16> negativeInf{0, 0, 0, 0, 0, 0, 0, 0x80, 0xff, 0xff, 0, 0, 0, 0, 0, 0};
	static const std::array<std::uint8_t, 16> positiveSNaN{0, 0, 0, 0, 0, 0, 0, 0x90, 0xff, 0x7f, 0, 0, 0, 0, 0, 0};
	static const std::array<std::uint8_t, 16> negativeSNaN{0, 0, 0, 0, 0, 0, 0, 0x90, 0xff, 0xff, 0, 0, 0, 0, 0, 0};

	// Indefinite values are used for QNaN
	static const std::array<std::uint8_t, 16> positiveQNaN{0, 0, 0, 0, 0, 0, 0, 0xc0, 0xff, 0x7f, 0, 0, 0, 0, 0, 0};
	static const std::array<std::uint8_t, 16> negativeQNaN{0, 0, 0, 0, 0, 0, 0, 0xc0, 0xff, 0xff, 0, 0, 0, 0, 0, 0};

	if (str == "+snan" || str == "snan")
		std::memcpy(&value, &positiveSNaN, sizeof(value));
	else if (str == "-snan")
		std::memcpy(&value, &negativeSNaN, sizeof(value));
	else if (str == "+qnan" || str == "qnan" || str == "nan")
		std::memcpy(&value, &positiveQNaN, sizeof(value));
	else if (str == "-qnan")
		std::memcpy(&value, &negativeQNaN, sizeof(value));
	else if (str == "+inf" || str == "inf")
		std::memcpy(&value, &positiveInf, sizeof(value));
	else if (str == "-inf")
		std::memcpy(&value, &negativeInf, sizeof(value));
	else
		return 0;

	ok = true;
	return value;
}
}

DialogEditFPU::DialogEditFPU(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f), floatEntry_(new ODbgRegisterView::Float80Edit(this)), hexEntry_(new QLineEdit(this)) {

	setWindowTitle(tr("Modify Register"));
	setModal(true);
	const auto allContentsGrid = new QGridLayout();

	allContentsGrid->addWidget(new QLabel(tr("Float"), this), 0, 0);
	allContentsGrid->addWidget(new QLabel(tr("Hex"), this), 1, 0);

	allContentsGrid->addWidget(floatEntry_, 0, 1);
	allContentsGrid->addWidget(hexEntry_, 1, 1);

	connect(floatEntry_, &Float80Edit::textEdited, this, &DialogEditFPU::onFloatEdited);
	connect(hexEntry_, &QLineEdit::textEdited, this, &DialogEditFPU::onHexEdited);

	hexEntry_->setValidator(new QRegExpValidator(QRegExp("[0-9a-fA-F ]{,20}"), this));
	connect(floatEntry_, &Float80Edit::defocussed, this, &DialogEditFPU::updateFloatEntry);

	hexEntry_->installEventFilter(this);
	floatEntry_->installEventFilter(this);

	const auto okCancel = new QDialogButtonBox(this);
	okCancel->setStandardButtons(QDialogButtonBox::Cancel | QDialogButtonBox::Ok);

	connect(okCancel, &QDialogButtonBox::accepted, this, &DialogEditFPU::accept);
	connect(okCancel, &QDialogButtonBox::rejected, this, &DialogEditFPU::reject);

	const auto dialogLayout = new QVBoxLayout(this);
	dialogLayout->addLayout(allContentsGrid);
	dialogLayout->addWidget(okCancel);

	setTabOrder(floatEntry_, hexEntry_);
	setTabOrder(hexEntry_, okCancel);
}

void DialogEditFPU::updateFloatEntry() {
	floatEntry_->setValue(value_);
}

void DialogEditFPU::updateHexEntry() {
	hexEntry_->setText(value_.toHexString());
}

bool DialogEditFPU::eventFilter(QObject *obj, QEvent *event) {
	return entry_grid_key_event_filter(this, obj, event);
}

void DialogEditFPU::setValue(const Register &newReg) {
	reg_   = newReg;
	value_ = reg_.value<edb::value80>();
	updateFloatEntry();
	updateHexEntry();
	setWindowTitle(tr("Modify %1").arg(reg_.name().toUpper()));
	floatEntry_->setFocus(Qt::OtherFocusReason);
}

Register DialogEditFPU::value() const {
	Register ret(reg_);
	ret.setValueFrom(value_);
	return ret;
}

void DialogEditFPU::onHexEdited(const QString &input) {
	QString readable(input.trimmed());
	readable.replace(' ', "");

	while (readable.size() < 20) {
		readable = '0' + readable;
	}

	const auto byteArray = QByteArray::fromHex(readable.toLatin1());
	auto source          = byteArray.constData();
	auto dest            = reinterpret_cast<unsigned char *>(&value_);

	for (std::size_t i = 0; i < sizeof(value_); ++i) {
		dest[i] = source[sizeof(value_) - i - 1];
	}

	updateFloatEntry();
}

void DialogEditFPU::onFloatEdited(const QString &str) {
	bool ok;
	const long double value = readFloat(str, ok);

	if (ok) {
		value_ = edb::value80(value);
	}

	updateHexEntry();
}

}

```

`plugins/ODbgRegisterView/arch/x86-generic/DialogEditFPU.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_EDIT_FPU_H_20151031_
#define DIALOG_EDIT_FPU_H_20151031_

#include "Register.h"
#include <QDialog>

class QLineEdit;

namespace ODbgRegisterView {

class Float80Edit;

class DialogEditFPU : public QDialog {
	Q_OBJECT

public:
	explicit DialogEditFPU(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	Register value() const;
	void setValue(const Register &reg);

private Q_SLOTS:
	void onHexEdited(const QString &);
	void onFloatEdited(const QString &);
	void updateFloatEntry();
	void updateHexEntry();

protected:
	bool eventFilter(QObject *, QEvent *) override;

private:
	Register reg_;

	edb::value80 value_;
	Float80Edit *floatEntry_ = nullptr;
	QLineEdit *hexEntry_     = nullptr;
};

}

#endif

```

`plugins/ODbgRegisterView/arch/x86-generic/Float80Edit.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Float80Edit.h"
#include "FloatX.h"
#include <QApplication>

namespace ODbgRegisterView {

Float80Edit::Float80Edit(QWidget *parent)
	: QLineEdit(parent) {

	setValidator(new FloatXValidator<long double>(this));
}

void Float80Edit::setValue(edb::value80 input) {
	setText(format_float(input));
}

QSize Float80Edit::sizeHint() const {
	const auto baseHint = QLineEdit::sizeHint();
	// Default size hint gives space for about 15-20 chars. We need about 30.
	return QSize(baseHint.width() * 2, baseHint.height()).expandedTo(QApplication::globalStrut());
}

void Float80Edit::focusOutEvent(QFocusEvent *e) {
	QLineEdit::focusOutEvent(e);
	Q_EMIT defocussed();
}

}

```

`plugins/ODbgRegisterView/arch/x86-generic/Float80Edit.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef FLOAT80_EDIT_H_20151031_
#define FLOAT80_EDIT_H_20151031_

#include "Types.h"
#include <QLineEdit>

namespace ODbgRegisterView {

class Float80Edit : public QLineEdit {
	Q_OBJECT

public:
	explicit Float80Edit(QWidget *parent = nullptr);
	void setValue(edb::value80 input);

public:
	QSize sizeHint() const override;

protected:
	void focusOutEvent(QFocusEvent *e) override;

Q_SIGNALS:
	void defocussed();
};

}

#endif

```

`plugins/ODbgRegisterView/arch/x86-generic/ODbgRV_x86Common.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef X86_COMMON_H_20170817_
#define X86_COMMON_H_20170817_

static constexpr unsigned FpuTagEmpty = 3;

static constexpr const char *FsrName = "FSR";
static constexpr const char *FcrName = "FCR";
static constexpr const char *FtrName = "FTR";

#endif

```

`plugins/ODbgRegisterView/arch/x86-generic/x86FPUValueField.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "FpuValueField.h"
#include "ODbgRV_Util.h"
#include "ODbgRV_x86Common.h"
#include "RegisterGroup.h"
#include "RegisterView.h"

namespace ODbgRegisterView {

FpuValueField::FpuValueField(int fieldWidth, const QModelIndex &regValueIndex, const QModelIndex &tagValueIndex, RegisterGroup *group, FieldWidget *commentWidget, int row, int column)
	: ValueField(
		  fieldWidth, regValueIndex,
		  [this](const QString &str) {
			  if (str.length() != 20)
				  return str;
			  if (groupDigits)
				  return str.left(4) + " " + str.mid(4, 8) + " " + str.right(8);
			  return str;
		  },
		  group),
	  commentWidget(commentWidget),
	  row(row),
	  column(column),
	  tagValueIndex(tagValueIndex) {

	Q_ASSERT(group);
	Q_ASSERT(commentWidget);
	showAsRawActionIndex = menuItems_.size();
	menuItems_.push_back(new_action(tr("View FPU as raw values"), this, [this](bool) {
		showFPUAsRaw();
	}));

	showAsFloatActionIndex = menuItems_.size();
	menuItems_.push_back(new_action(tr("View FPU as floats"), this, [this](bool) {
		showFPUAsFloat();
	}));

	group->insert(row, column, this);
	group->insert(commentWidget);
	// will be moved to its column in the next line
	group->setupPositionAndSize(row, 0, commentWidget);
	displayFormatChanged();
	connect(index_.model(), SIGNAL(FPUDisplayFormatChanged()), this, SLOT(displayFormatChanged()));
}

void FpuValueField::showFPUAsRaw() {
	model()->setChosenFPUFormat(index_.parent(), NumberDisplayMode::Hex);
}

void FpuValueField::showFPUAsFloat() {
	model()->setChosenFPUFormat(index_.parent(), NumberDisplayMode::Float);
}

void FpuValueField::displayFormatChanged() {

	using RegisterViewModelBase::Model;
	const auto format = static_cast<NumberDisplayMode>(valid_variant(index_.parent().data(Model::ChosenFPUFormatRole)).toInt());

	switch (format) {
	case NumberDisplayMode::Hex:
		menuItems_[showAsRawActionIndex]->setVisible(false);
		menuItems_[showAsFloatActionIndex]->setVisible(true);
		break;
	case NumberDisplayMode::Float:
		menuItems_[showAsRawActionIndex]->setVisible(true);
		menuItems_[showAsFloatActionIndex]->setVisible(false);
		break;
	default:
		menuItems_[showAsRawActionIndex]->setVisible(true);
		menuItems_[showAsFloatActionIndex]->setVisible(true);
		break;
	}

	const auto margins = group()->getFieldMargins();
	fieldWidth_        = valid_variant(index_.data(Model::FixedLengthRole)).toInt();

	Q_ASSERT(fieldWidth_ > 0);

	if (format == NumberDisplayMode::Hex) {
		groupDigits = true;
		fieldWidth_ += 2; // add some room for spaces between groups
	} else {
		groupDigits = false;
	}

	const auto charWidth = letter_size(font()).width();
	setFixedWidth(charWidth * fieldWidth_ + margins.left() + margins.right());
	commentWidget->move(x() + maximumWidth(), commentWidget->y());
}

void FpuValueField::updatePalette() {
	if (!changed() && tagValueIndex.data().toUInt() == FpuTagEmpty) {
		auto palette = group()->palette();
		palette.setColor(foregroundRole(), palette.color(QPalette::Disabled, QPalette::Text));
		setPalette(palette);
		QLabel::update();
	} else {
		ValueField::updatePalette();
	}
}

}

```

`plugins/ODbgRegisterView/arch/x86-generic/x86Groups.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "x86Groups.h"
#include "BitFieldDescription.h"
#include "FpuValueField.h"
#include "MultiBitFieldWidget.h"
#include "ODbgRV_Util.h"
#include "ODbgRV_x86Common.h"
#include "QtHelper.h"
#include "RegisterGroup.h"
#include "VolatileNameField.h"

#include <QDebug>
#include <unordered_map>

namespace ODbgRegisterView {

Q_DECLARE_NAMESPACE_TR(ODbgRegisterView)

namespace {

const BitFieldDescription fpuTagDescription = {
	7,
	{
		tr("valid"),
		tr("zero"),
		tr("special"),
		tr("empty"),
	},
	{
		tr("Tag as used"),
		tr(""),
		tr(""),
		tr("Tag as empty"),
	},
	[](unsigned a, unsigned b) {
		return (a == 3 || b == 3) ? (a == b) : true;
	},
};

const BitFieldDescription roundControlDescription = {
	4,
	{
		tr("NEAR"),
		tr("DOWN"),
		tr("  UP"),
		tr("ZERO"),
	},
	{
		tr("Round to nearest"),
		tr("Round down"),
		tr("Round up"),
		tr("Round toward zero"),
	},
};

const BitFieldDescription precisionControlDescription = {
	2,
	{
		tr("24"),
		tr("??"),
		tr("53"),
		tr("64"),
	},
	{
		tr("Set 24-bit precision"),
		tr(""),
		tr("Set 53-bit precision"),
		tr("Set 64-bit precision"),
	},
};

const BitFieldDescription debugRWDescription = {
	5,
	{
		tr("EXEC"),
		tr("WRITE"),
		tr("  IO"),
		tr(" R/W"),
	},
	{
		tr("Break on execution"),
		tr("Break on data write"),
		tr(""),
		tr("Break on data read/write"),
	},
};

const BitFieldDescription debugLenDescription = {
	1,
	{
		tr("1"),
		tr("2"),
		tr("8"),
		tr("4"),
	},
	{
		tr("Set 1-byte length"),
		tr("Set 2-byte length"),
		tr("Set 8-byte length"),
		tr("Set 4-byte length"),
	},
};

// Checks that FOP is in not in compatibility mode, i.e. is updated only on unmasked exception
// This function would return false for e.g. Pentium III or Atom, but returns true since Pentium 4.
// This can be made return false for such CPUs by setting bit 2 in IA32_MISC_ENABLE MSR.
bool fop_is_compatible() {
#ifdef __GNUG__
	char fenv[28];
	asm volatile("fldz\n"
				 "fstp %%st(0)\n"
				 "fstenv %0\n"
				 : "=m"(fenv)::"%st");
	std::uint16_t fop;
	std::memcpy(&fop, fenv + 18, sizeof(fop));
	return fop == 0;
#else
	// TODO(eteran): figure out a way to implement this for other compilers
	return true;
#endif
}

void add_rounding_mode(RegisterGroup *group, const QModelIndex &index, int row, int column) {
	assert(index.isValid());
	const auto rndValueField = new MultiBitFieldWidget(index, roundControlDescription, group);
	group->insert(row, column, rndValueField);
	rndValueField->setToolTip(tr("Rounding mode"));
}

void add_precision_mode(RegisterGroup *group, const QModelIndex &index, int row, int column) {
	assert(index.isValid());
	const auto precValueField = new MultiBitFieldWidget(index, precisionControlDescription, group);
	group->insert(row, column, precValueField);
	precValueField->setToolTip(tr("Precision mode: effective mantissa length"));
}

void add_puozdi(RegisterGroup *group, const QModelIndex &excRegIndex, const QModelIndex &maskRegIndex, int startRow, int startColumn) {

	static const QString exceptions = tr("PUOZDI");

	static const std::unordered_map<char, QString> excNames = {
		{'P', tr("Precision")},
		{'U', tr("Underflow")},
		{'O', tr("Overflow")},
		{'Z', tr("Zero Divide")},
		{'D', tr("Denormalized Operand")},
		{'I', tr("Invalid Operation")},
	};

	for (int exN = 0; exN < exceptions.length(); ++exN) {
		const QString ex         = exceptions[exN];
		const QString exAbbrev   = ex + "E";
		const QString maskAbbrev = ex + "M";

		const auto excIndex  = valid_index(find_model_register(excRegIndex, exAbbrev));
		const auto maskIndex = valid_index(find_model_register(maskRegIndex, maskAbbrev));

		const int column = startColumn + exN * 2;

		const auto nameField = new FieldWidget(ex, group);
		group->insert(startRow, column, nameField);

		const auto excValueField = new ValueField(1, value_index(excIndex), group);
		group->insert(startRow + 1, column, excValueField);

		const auto maskValueField = new ValueField(1, value_index(maskIndex), group);
		group->insert(startRow + 2, column, maskValueField);

		const QString excName = excNames.at(ex[0].toLatin1());
		nameField->setToolTip(excName);
		excValueField->setToolTip(excName + ' ' + tr("Exception") + " (" + exAbbrev + ")");
		maskValueField->setToolTip(excName + ' ' + tr("Exception Mask") + " (" + maskAbbrev + ")");
	}
}

}

RegisterGroup *create_eflags(RegisterViewModelBase::Model *model, QWidget *parent) {
	const auto catIndex = find_model_category(model, tr("General Status"));
	if (!catIndex.isValid())
		return nullptr;

	auto nameIndex = find_model_register(catIndex, tr("RFLAGS"));
	if (!nameIndex.isValid())
		nameIndex = find_model_register(catIndex, tr("EFLAGS"));

	if (!nameIndex.isValid())
		return nullptr;

	const auto group        = new RegisterGroup(tr("EFL"), parent);
	constexpr int NameWidth = 3;
	int column              = 0;
	group->insert(0, column, new FieldWidget(tr("EFL"), group));

	constexpr int ValueWidth = 8;
	const auto valueIndex    = nameIndex.sibling(nameIndex.row(), ModelValueColumn);
	column += NameWidth + 1;
	group->insert(0, column, new ValueField(
								 ValueWidth, valueIndex, [](const QString &v) {
									 return v.right(8);
								 },
								 group));

	const auto commentIndex = nameIndex.sibling(nameIndex.row(), ModelCommentColumn);
	column += ValueWidth + 1;
	group->insert(0, column, new FieldWidget(0, commentIndex, group));

	return group;
}

RegisterGroup *create_expanded_eflags(RegisterViewModelBase::Model *model, QWidget *parent) {
	const auto catIndex = find_model_category(model, tr("General Status"));
	if (!catIndex.isValid())
		return nullptr;

	auto regNameIndex = find_model_register(catIndex, "RFLAGS");
	if (!regNameIndex.isValid())
		regNameIndex = find_model_register(catIndex, "EFLAGS");

	if (!regNameIndex.isValid())
		return nullptr;

	const auto group = new RegisterGroup(tr("Expanded EFL"), parent);

	static const std::unordered_map<char, QString> flagTooltips = {
		{'C', tr("Carry flag") + " (CF)"},
		{'P', tr("Parity flag") + " (PF)"},
		{'A', tr("Auxiliary carry flag") + " (AF)"},
		{'Z', tr("Zero flag") + " (ZF)"},
		{'S', tr("Sign flag") + " (SF)"},
		{'T', tr("Trap flag") + " (TF)"},
		{'D', tr("Direction flag") + " (DF)"},
		{'O', tr("Overflow flag") + " (OF)"},
	};
	for (int row = 0, groupRow = 0; row < model->rowCount(regNameIndex); ++row) {
		const auto flagNameIndex  = model->index(row, ModelNameColumn, regNameIndex);
		const auto flagValueIndex = model->index(row, ModelValueColumn, regNameIndex);
		const auto flagName       = model->data(flagNameIndex).toString().toUpper();

		if (flagName.length() != 2 || flagName[1] != 'F') {
			continue;
		}

		constexpr int FlagNameWidth = 1;
		constexpr int ValueWidth    = 1;

		const char name = flagName[0].toLatin1();
		switch (name) {
		case 'C':
		case 'P':
		case 'A':
		case 'Z':
		case 'S':
		case 'T':
		case 'D':
		case 'O': {
			const auto nameField = new FieldWidget(QChar(name), group);
			group->insert(groupRow, 0, nameField);

			const auto valueField = new ValueField(ValueWidth, flagValueIndex, group);
			group->insert(groupRow, FlagNameWidth + 1, valueField);

			++groupRow;

			const auto tooltipStr = flagTooltips.at(name);
			nameField->setToolTip(tooltipStr);
			valueField->setToolTip(tooltipStr);

			break;
		}
		default:
			continue;
		}
	}

	return group;
}

RegisterGroup *create_fpu_data(RegisterViewModelBase::Model *model, QWidget *parent) {
	using RegisterViewModelBase::Model;

	const auto catIndex = find_model_category(model, "FPU");
	if (!catIndex.isValid()) {
		return nullptr;
	}

	const auto tagsIndex = find_model_register(catIndex, FtrName);
	if (!tagsIndex.isValid()) {
		qWarning() << "Warning: failed to find FTR in the model, refusing to continue making FPUData group";
		return nullptr;
	}

	const auto group          = new RegisterGroup(tr("FPU Data Registers"), parent);
	constexpr int FpuRegCount = 8;
	constexpr int NameWidth   = 3;
	constexpr int TagWidth    = 7;
	const auto fsrIndex       = valid_index(find_model_register(catIndex, FsrName));

	const QPersistentModelIndex topIndex = valid_index(find_model_register(fsrIndex, tr("TOP"), ModelValueColumn));

	for (int row = 0; row < FpuRegCount; ++row) {
		int column           = 0;
		const auto nameIndex = model->index(row, ModelNameColumn, catIndex);
		{
			const auto STiFormatter = [row, topIndex]() {
				const auto topByteArray = topIndex.data(Model::RawValueRole).toByteArray();
				if (topByteArray.isEmpty())
					return QString("R%1").arg(row);
				const auto top = topByteArray[0];
				assert(top >= 0);
				Q_ASSERT(top < 8);
				const auto stI = (row + 8 - top) % 8;
				return QString("ST%1").arg(stI);
			};
			const auto field = new VolatileNameField(NameWidth, STiFormatter, group);
			QObject::connect(model, &RegisterViewModelBase::Model::dataChanged, field, &VolatileNameField::adjustToData);
			group->insert(row, column, field);
			column += NameWidth + 1;
		}

		const auto tagValueIndex = valid_index(model->index(row, ModelValueColumn, tagsIndex));
		group->insert(row, column, new MultiBitFieldWidget(tagValueIndex, fpuTagDescription, group));
		column += TagWidth + 1;
		const auto regValueIndex = nameIndex.sibling(nameIndex.row(), ModelValueColumn);
		const int regValueWidth  = regValueIndex.data(Model::FixedLengthRole).toInt();
		Q_ASSERT(regValueWidth > 0);
		const auto regCommentIndex = model->index(row, ModelCommentColumn, catIndex);
		new FpuValueField(regValueWidth, regValueIndex, tagValueIndex, group, new FieldWidget(0, regCommentIndex, group), row, column);
	}

	return group;
}

RegisterGroup *create_fpu_words(RegisterViewModelBase::Model *model, QWidget *parent) {
	const auto catIndex = find_model_category(model, "FPU");
	if (!catIndex.isValid()) {
		return nullptr;
	}

	const auto group = new RegisterGroup(tr("FPU Status&&Control Registers"), parent);
	group->appendNameValueComment(find_model_register(catIndex, FtrName), tr("FPU Tag Register"), false);

	constexpr int FsrRow = 1;
	const auto fsrIndex  = find_model_register(catIndex, FsrName);
	group->appendNameValueComment(fsrIndex, tr("FPU Status Register"), false);

	constexpr int FcrRow = 2;
	const auto fcrIndex  = find_model_register(catIndex, FcrName);
	group->appendNameValueComment(fcrIndex, tr("FPU Control Register"), false);

	constexpr int wordNameWidth       = 3;
	constexpr int wordValWidth        = 4;
	constexpr int condPrecLabelColumn = wordNameWidth + 1 + wordValWidth + 1 + 1;
	constexpr int condPrecLabelWidth  = 4;

	group->insert(FsrRow, condPrecLabelColumn, new FieldWidget("Cond", group));
	group->insert(FcrRow, condPrecLabelColumn, new FieldWidget("Prec", group));

	constexpr int condPrecValColumn = condPrecLabelColumn + condPrecLabelWidth + 1;
	constexpr int roundModeWidth = 4, precModeWidth = 2;
	constexpr int roundModeColumn = condPrecValColumn;
	constexpr int precModeColumn  = roundModeColumn + roundModeWidth + 1;

	// This must be inserted before precision&rounding value fields, since they overlap this label
	group->insert(FcrRow, precModeColumn - 1, new FieldWidget(",", group));

	for (int condN = 3; condN >= 0; --condN) {
		const auto name           = QString("C%1").arg(condN);
		const auto condNNameIndex = valid_index(find_model_register(fsrIndex, name));
		const auto condNIndex     = valid_index(condNNameIndex.sibling(condNNameIndex.row(), ModelValueColumn));
		const int column          = condPrecValColumn + 2 * (3 - condN);
		const auto nameField      = new FieldWidget(QString("%1").arg(condN), group);
		group->insert(FsrRow - 1, column, nameField);

		const auto valueField = new ValueField(1, condNIndex, group);
		group->insert(FsrRow, column, valueField);

		nameField->setToolTip(name);
		valueField->setToolTip(name);
	}

	add_rounding_mode(group, find_model_register(fcrIndex, "RC", ModelValueColumn), FcrRow, roundModeColumn);
	add_precision_mode(group, find_model_register(fcrIndex, "PC", ModelValueColumn), FcrRow, precModeColumn);

	constexpr int ErrMaskColumn = precModeColumn + precModeWidth + 2;
	constexpr int ErrLabelWidth = 3;
	group->insert(FsrRow, ErrMaskColumn, new FieldWidget("Err", group));
	group->insert(FcrRow, ErrMaskColumn, new FieldWidget("Mask", group));

	constexpr int ESColumn = ErrMaskColumn + ErrLabelWidth + 1;
	constexpr int SFColumn = ESColumn + 2;
	const auto ESNameField = new FieldWidget("E", group);

	group->insert(FsrRow - 1, ESColumn, ESNameField);

	const auto SFNameField = new FieldWidget("S", group);
	group->insert(FsrRow - 1, SFColumn, SFNameField);

	const auto ESValueField = new ValueField(1, find_model_register(fsrIndex, "ES", ModelValueColumn), group);
	group->insert(FsrRow, ESColumn, ESValueField);

	const auto SFValueField = new ValueField(1, find_model_register(fsrIndex, "SF", ModelValueColumn), group);
	group->insert(FsrRow, SFColumn, SFValueField);

	{
		const auto ESTooltip = tr("Error Summary Status") + " (ES)";
		ESNameField->setToolTip(ESTooltip);
		ESValueField->setToolTip(ESTooltip);
	}

	{
		const auto SFTooltip = tr("Stack Fault") + " (SF)";
		SFNameField->setToolTip(SFTooltip);
		SFValueField->setToolTip(SFTooltip);
	}

	constexpr int PEPMColumn = SFColumn + 2;
	add_puozdi(group, fsrIndex, fcrIndex, FsrRow - 1, PEPMColumn);

	constexpr int PUOZDIWidth = 6 * 2 - 1;
	group->insert(FsrRow, PEPMColumn + PUOZDIWidth + 1, new FieldWidget(0, comment_index(fsrIndex), group));

	return group;
}

RegisterGroup *create_fpu_last_op(RegisterViewModelBase::Model *model, QWidget *parent) {
	using RegisterViewModelBase::Model;

	const auto catIndex = find_model_category(model, "FPU");
	if (!catIndex.isValid())
		return nullptr;

	const auto FIPIndex = find_model_register(catIndex, "FIP", ModelValueColumn);
	if (!FIPIndex.isValid())
		return nullptr;

	const auto FDPIndex = find_model_register(catIndex, "FDP", ModelValueColumn);
	if (!FDPIndex.isValid())
		return nullptr;

	const auto group = new RegisterGroup(tr("FPU Last Operation Registers"), parent);
	enum { lastInsnRow,
		   lastDataRow,
		   lastOpcodeRow };
	const QString lastInsnLabel   = "Last insn";
	const QString lastDataLabel   = "Last data";
	const QString lastOpcodeLabel = "Last opcode";
	const auto lastInsnLabelField = new FieldWidget(lastInsnLabel, group);
	group->insert(lastInsnRow, 0, lastInsnLabelField);
	const auto lastDataLabelField = new FieldWidget(lastDataLabel, group);
	group->insert(lastDataRow, 0, lastDataLabelField);
	const auto lastOpcodeLabelField = new FieldWidget(lastOpcodeLabel, group);
	group->insert(lastOpcodeRow, 0, lastOpcodeLabelField);

	lastInsnLabelField->setToolTip(tr("Last FPU instruction address"));
	lastDataLabelField->setToolTip(tr("Last FPU memory operand address"));

	// FIS & FDS are not maintained in 64-bit mode; Linux64 always saves state from
	// 64-bit mode, losing the values for 32-bit apps even if the CPU doesn't deprecate them
	// We'll show zero offsets in 32 bit mode for consistency with 32-bit kernels
	// In 64-bit mode, since segments are not maintained, we'll just show offsets
	const auto FIPwidth  = FDPIndex.data(Model::FixedLengthRole).toInt();
	const auto segWidth  = FIPwidth == 8 /*8chars=>32bit*/ ? 4 : 0;
	const auto segColumn = lastInsnLabel.length() + 1;

	if (segWidth) {
		// these two must be inserted first, because seg & offset value fields overlap these labels
		group->insert(lastInsnRow, segColumn + segWidth, new FieldWidget(":", group));
		group->insert(lastDataRow, segColumn + segWidth, new FieldWidget(":", group));

		const auto FISField = new ValueField(segWidth, find_model_register(catIndex, "FIS", ModelValueColumn), group);
		group->insert(lastInsnRow, segColumn, FISField);
		const auto FDSField = new ValueField(segWidth, find_model_register(catIndex, "FDS", ModelValueColumn), group);
		group->insert(lastDataRow, segColumn, FDSField);

		FISField->setToolTip(tr("Last FPU instruction selector"));
		FDSField->setToolTip(tr("Last FPU memory operand selector"));
	}

	const auto offsetWidth = FIPIndex.data(Model::FixedLengthRole).toInt();
	assert(offsetWidth > 0);
	const auto offsetColumn  = segColumn + segWidth + (segWidth ? 1 : 0);
	const auto FIPValueField = new ValueField(offsetWidth, FIPIndex, group);
	group->insert(lastInsnRow, offsetColumn, FIPValueField);
	const auto FDPValueField = new ValueField(offsetWidth, FDPIndex, group);
	group->insert(lastDataRow, offsetColumn, FDPValueField);

	FIPValueField->setToolTip(tr("Last FPU instruction offset"));
	FDPValueField->setToolTip(tr("Last FPU memory operand offset"));

	QPersistentModelIndex const FOPIndex = find_model_register(catIndex, "FOP", ModelValueColumn);
	QPersistentModelIndex const FSRIndex = find_model_register(catIndex, FsrName, ModelValueColumn);
	QPersistentModelIndex const FCRIndex = find_model_register(catIndex, FcrName, ModelValueColumn);
	bool fopRarelyUpdated                = fop_is_compatible();

	const auto FOPFormatter = [FOPIndex, FSRIndex, FCRIndex, FIPIndex, fopRarelyUpdated](const QString &str) -> QString {
		if (str.isEmpty() || str[0] == '?')
			return str;

		const auto rawFCR = FCRIndex.data(Model::RawValueRole).toByteArray();
		assert(rawFCR.size() <= long(sizeof(edb::value16)));
		if (rawFCR.isEmpty())
			return str;
		edb::value16 fcr(0);
		std::memcpy(&fcr, rawFCR.constData(), rawFCR.size());

		const auto rawFSR = FSRIndex.data(Model::RawValueRole).toByteArray();
		assert(rawFSR.size() <= long(sizeof(edb::value16)));
		if (rawFSR.isEmpty())
			return str;
		edb::value16 fsr(0);
		std::memcpy(&fsr, rawFSR.constData(), rawFSR.size());

		const auto rawFOP = FOPIndex.data(Model::RawValueRole).toByteArray();
		edb::value16 fop(0);
		assert(rawFOP.size() <= long(sizeof(edb::value16)));
		if (rawFOP.isEmpty())
			return str;
		if (rawFOP.size() != sizeof(edb::value16))
			return QString("????");
		std::memcpy(&fop, rawFOP.constData(), rawFOP.size());

		const auto rawFIP = FIPIndex.data(Model::RawValueRole).toByteArray();
		if (rawFIP.isEmpty())
			return str;
		edb::address_t fip(0);
		assert(rawFIP.size() <= long(sizeof(fip)));
		std::memcpy(&fip, rawFIP.constData(), rawFIP.size());

		const auto excMask           = fcr & 0x3f;
		const auto excActive         = fsr & 0x3f;
		const auto excActiveUnmasked = excActive & ~excMask;
		if (fop == 0 && ((fopRarelyUpdated && !excActiveUnmasked) || fip == 0))
			return QString("00 00");
		return edb::value8(0xd8 + rawFOP[1]).toHexString() + ' ' + edb::value8(rawFOP[0]).toHexString();
	};

	const auto FOPValueField = new ValueField(5, FOPIndex, FOPFormatter, group);
	group->insert(lastOpcodeRow, lastOpcodeLabel.length() + 1, FOPValueField);

	static const auto FOPTooltip = tr("Last FPU opcode");
	lastOpcodeLabelField->setToolTip(FOPTooltip);
	FOPValueField->setToolTip(FOPTooltip);

	return group;
}

RegisterGroup *create_debug_group(RegisterViewModelBase::Model *model, QWidget *parent) {
	using RegisterViewModelBase::Model;

	const auto catIndex = find_model_category(model, "Debug");
	if (!catIndex.isValid())
		return nullptr;

	const auto group = new RegisterGroup(tr("Debug Registers"), parent);

	const auto dr6Index   = valid_index(find_model_register(catIndex, "DR6"));
	const auto dr7Index   = valid_index(find_model_register(catIndex, "DR7"));
	const auto nameWidth  = 3;
	const auto valueWidth = value_index(dr6Index).data(Model::FixedLengthRole).toInt();
	assert(valueWidth > 0);

	const auto bitsSpacing   = 1;
	const auto BTooltip      = tr("Breakpoint Condition Detected");
	const auto LTooltip      = tr("Local Breakpoint Enable");
	const auto GTooltip      = tr("Global Breakpoint Enable");
	const auto typeTooltip   = tr("Breakpoint condition");
	const auto lenTooltip    = tr("Data breakpoint length");
	const auto lenDecodedStr = tr(" (bytes count from %1)");
	int row                  = 0;

	{
		int column = nameWidth + 1 + valueWidth + 2;

		const auto BLabelField = new FieldWidget("B", group);
		BLabelField->setToolTip(BTooltip + " (B0..B3)");
		group->insert(row, column, BLabelField);
		column += bitsSpacing + 1;

		const auto LLabelField = new FieldWidget("L", group);
		LLabelField->setToolTip(LTooltip + " (L0..L3)");
		group->insert(row, column, LLabelField);
		column += bitsSpacing + 1;

		const auto GLabelField = new FieldWidget("G", group);
		GLabelField->setToolTip(GTooltip + " (G0..G3)");
		group->insert(row, column, GLabelField);
		column += bitsSpacing + 1;

		const auto typeLabelField = new FieldWidget("Type", group);
		typeLabelField->setToolTip(typeTooltip + " (R/W0..R/W3)");
		group->insert(row, column, typeLabelField);
		column += bitsSpacing + 4;

		const auto lenLabelField = new FieldWidget("Len", group);
		lenLabelField->setToolTip(lenTooltip + lenDecodedStr.arg("LEN0..LEN3"));
		group->insert(row, column, lenLabelField);
		column += bitsSpacing + 3;

		++row;
	}

	for (int drI = 0; drI < 4; ++drI, ++row) {
		const auto name          = QString("DR%1").arg(drI);
		const auto DRiValueIndex = valid_index(find_model_register(catIndex, name, ModelValueColumn));
		int column               = 0;

		group->insert(row, column, new FieldWidget(name, group));
		column += nameWidth + 1;
		group->insert(row, column, new ValueField(valueWidth, DRiValueIndex, group));
		column += valueWidth + 2;
		{
			const auto BiName       = QString("B%1").arg(drI);
			const auto BiIndex      = valid_index(find_model_register(dr6Index, BiName, ModelValueColumn));
			const auto BiValueField = new ValueField(1, BiIndex, group);
			BiValueField->setToolTip(BTooltip + " (" + BiName + ")");
			group->insert(row, column, BiValueField);
			column += bitsSpacing + 1;
		}
		{
			const auto LiName       = QString("L%1").arg(drI);
			const auto LiIndex      = valid_index(find_model_register(dr7Index, LiName, ModelValueColumn));
			const auto LiValueField = new ValueField(1, LiIndex, group);
			LiValueField->setToolTip(LTooltip + " (" + LiName + ")");
			group->insert(row, column, LiValueField);
			column += bitsSpacing + 1;
		}
		{
			const auto GiName       = QString("G%1").arg(drI);
			const auto GiIndex      = valid_index(find_model_register(dr7Index, GiName, ModelValueColumn));
			const auto GiValueField = new ValueField(1, GiIndex, group);
			GiValueField->setToolTip(GTooltip + " (" + GiName + ")");
			group->insert(row, column, GiValueField);
			column += bitsSpacing + 1;
		}
		{
			const auto RWiName                   = QString("R/W%1").arg(drI);
			const QPersistentModelIndex RWiIndex = valid_index(find_model_register(dr7Index, RWiName, ModelValueColumn));
			const auto width                     = 5;
			const auto RWiValueField             = new MultiBitFieldWidget(RWiIndex, debugRWDescription, group);
			RWiValueField->setToolTip(typeTooltip + " (" + RWiName + ")");
			group->insert(row, column, RWiValueField);
			column += bitsSpacing + width;
		}
		{
			const auto LENiName                   = QString("LEN%1").arg(drI);
			const QPersistentModelIndex LENiIndex = valid_index(find_model_register(dr7Index, LENiName, ModelValueColumn));
			const auto LENiValueField             = new MultiBitFieldWidget(LENiIndex, debugLenDescription, group);
			LENiValueField->setToolTip(lenTooltip + lenDecodedStr.arg(LENiName));
			group->insert(row, column, LENiValueField);
		}
	}

	{
		int column = 0;
		group->insert(row, column, new FieldWidget("DR6", group));
		column += nameWidth + 1;
		group->insert(row, column, new ValueField(valueWidth, value_index(dr6Index), group));
		column += valueWidth + 2;
		const QString bsName   = "BS";
		const auto bsWidth     = bsName.length();
		const auto BSNameField = new FieldWidget(bsName, group);
		const auto BSTooltip   = tr("Single Step") + " (BS)";
		BSNameField->setToolTip(BSTooltip);
		group->insert(row, column, BSNameField);
		column += bsWidth + 1;
		const auto bsIndex      = find_model_register(dr6Index, bsName, ModelValueColumn);
		const auto BSValueField = new ValueField(1, bsIndex, group);
		BSValueField->setToolTip(BSTooltip);
		group->insert(row, column, BSValueField);

		++row;
	}

	{
		int column = 0;
		group->insert(row, column, new FieldWidget("DR7", group));
		column += nameWidth + 1;
		group->insert(row, column, new ValueField(valueWidth, value_index(dr7Index), group));
		column += valueWidth + 2;
		{
			const QString leName   = "LE";
			const auto leWidth     = leName.length();
			const auto LENameField = new FieldWidget(leName, group);
			const auto LETooltip   = tr("Local Exact Breakpoint Enable");
			LENameField->setToolTip(LETooltip);
			group->insert(row, column, LENameField);
			column += leWidth + 1;
			const auto leIndex      = find_model_register(dr7Index, leName, ModelValueColumn);
			const auto leValueWidth = 1;
			const auto LEValueField = new ValueField(leValueWidth, leIndex, group);
			LEValueField->setToolTip(LETooltip);
			group->insert(row, column, LEValueField);
			column += leValueWidth + 1;
		}
		{
			const QString geName   = "GE";
			const auto geWidth     = geName.length();
			const auto GENameField = new FieldWidget(geName, group);
			const auto GETooltip   = tr("Global Exact Breakpoint Enable");
			GENameField->setToolTip(GETooltip);
			group->insert(row, column, GENameField);
			column += geWidth + 1;
			const auto geIndex      = find_model_register(dr7Index, geName, ModelValueColumn);
			const auto geValueWidth = 1;
			const auto GEValueField = new ValueField(geValueWidth, geIndex, group);
			GEValueField->setToolTip(GETooltip);
			group->insert(row, column, GEValueField);
			column += geValueWidth + 1;
		}
	}

	return group;
}

RegisterGroup *create_mxcsr(RegisterViewModelBase::Model *model, QWidget *parent) {
	using namespace RegisterViewModelBase;

	const auto catIndex = find_model_category(model, "SSE");
	if (!catIndex.isValid())
		return nullptr;
	const auto group        = new RegisterGroup("MXCSR", parent);
	const QString mxcsrName = "MXCSR";

	int column         = 0;
	const int mxcsrRow = 1, fzRow = mxcsrRow, dazRow = mxcsrRow, excRow = mxcsrRow;
	const int rndRow  = fzRow + 1;
	const int maskRow = rndRow;

	group->insert(mxcsrRow, column, new FieldWidget(mxcsrName, group));
	column += mxcsrName.length() + 1;
	const auto mxcsrIndex      = find_model_register(catIndex, "MXCSR", ModelValueColumn);
	const auto mxcsrValueWidth = mxcsrIndex.data(Model::FixedLengthRole).toInt();
	assert(mxcsrValueWidth > 0);
	group->insert(mxcsrRow, column, new ValueField(mxcsrValueWidth, mxcsrIndex, group));
	column += mxcsrValueWidth + 2;
	// XXX: Sacrificing understandability of DAZ->DZ to align PUOZDI with FPU's.
	// Also FZ value is one char away from DAZ name, which is also no good.
	// Maybe following OllyDbg example here isn't a good idea.
	const QString fzName = "FZ", dazName = "DZ";
	const auto fzColumn    = column;
	const auto fzNameField = new FieldWidget(fzName, group);
	group->insert(fzRow, fzColumn, fzNameField);
	column += fzName.length() + 1;
	const auto fzIndex      = find_model_register(mxcsrIndex, "FZ", ModelValueColumn);
	const auto fzValueWidth = 1;
	const auto fzValueField = new ValueField(fzValueWidth, fzIndex, group);
	group->insert(fzRow, column, fzValueField);
	column += fzValueWidth + 1;
	const auto dazNameField = new FieldWidget(dazName, group);
	group->insert(dazRow, column, dazNameField);
	column += dazName.length() + 1;
	const auto dazIndex      = find_model_register(mxcsrIndex, "DAZ", ModelValueColumn);
	const auto dazValueWidth = 1;
	const auto dazValueField = new ValueField(dazValueWidth, dazIndex, group);
	group->insert(dazRow, column, dazValueField);
	column += dazValueWidth + 2;
	const QString excName = "Err";
	group->insert(excRow, column, new FieldWidget(excName, group));
	const QString maskName = "Mask";
	group->insert(maskRow, column, new FieldWidget(maskName, group));
	column += maskName.length() + 1;
	add_puozdi(group, mxcsrIndex, mxcsrIndex, excRow - 1, column);
	const auto rndNameColumn = fzColumn;
	const QString rndName    = "Rnd";
	group->insert(rndRow, rndNameColumn, new FieldWidget(rndName, group));
	const auto rndColumn = rndNameColumn + rndName.length() + 1;
	add_rounding_mode(group, find_model_register(mxcsrIndex, "RC", ModelValueColumn), rndRow, rndColumn);

	{
		const auto fzTooltip = tr("Flush Denormals To Zero (FTZ)");
		fzNameField->setToolTip(fzTooltip);
		fzValueField->setToolTip(fzTooltip);
	}
	{
		const auto dazTooltip = tr("Denormals Are Zeros (DAZ)");
		dazNameField->setToolTip(dazTooltip);
		dazValueField->setToolTip(dazTooltip);
	}

	return group;
}

}

```

`plugins/ODbgRegisterView/arch/x86-generic/x86Groups.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ODBG_REGISTER_VIEW_X86_GROUPS_H_20170817_
#define ODBG_REGISTER_VIEW_X86_GROUPS_H_20170817_

#include "RegisterView.h"

namespace ODbgRegisterView {

RegisterGroup *create_eflags(RegisterViewModelBase::Model *model, QWidget *parent);
RegisterGroup *create_expanded_eflags(RegisterViewModelBase::Model *model, QWidget *parent);
RegisterGroup *create_fpu_data(RegisterViewModelBase::Model *model, QWidget *parent);
RegisterGroup *create_fpu_words(RegisterViewModelBase::Model *model, QWidget *parent);
RegisterGroup *create_fpu_last_op(RegisterViewModelBase::Model *model, QWidget *parent);
RegisterGroup *create_debug_group(RegisterViewModelBase::Model *model, QWidget *parent);
RegisterGroup *create_mxcsr(RegisterViewModelBase::Model *model, QWidget *parent);

}

#endif

```

`plugins/OpcodeSearcher/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "OpcodeSearcher")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	DialogOpcodes.cpp
	DialogOpcodes.h
	DialogOpcodes.ui
	DialogResults.cpp
	DialogResults.h
	DialogResults.ui
	OpcodeSearcher.cpp
	OpcodeSearcher.h
	ResultsModel.cpp
	ResultsModel.h
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/OpcodeSearcher/DialogOpcodes.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogOpcodes.h"
#include "DialogResults.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IRegion.h"
#include "Instruction.h"
#include "MemoryRegions.h"
#include "ResultsModel.h"
#include "edb.h"
#include "util/Container.h"
#include "util/Math.h"

#include <QDebug>
#include <QHeaderView>
#include <QList>
#include <QListWidgetItem>
#include <QMessageBox>
#include <QPushButton>
#include <QSortFilterProxyModel>

#include <vector>

namespace OpcodeSearcherPlugin {
namespace {

using InstructionList = std::vector<edb::Instruction *>;

// we currently only support opcodes sequences up to 8 bytes big
using OpcodeData = std::array<uint8_t, sizeof(uint64_t)>;

/**
 * @brief add_result
 * @param resultsDialog
 * @param instructions
 * @param rva
 */
void add_result(DialogResults *resultsDialog, const InstructionList &instructions, edb::address_t rva) {
	if (!instructions.empty()) {

		auto it                       = instructions.begin();
		const edb::Instruction *inst1 = *it++;

		auto instruction_string = QString::fromStdString(edb::v1::formatter().toString(*inst1));

		for (; it != instructions.end(); ++it) {
			const edb::Instruction *inst = *it;
			instruction_string.append(QString("; %1").arg(QString::fromStdString(edb::v1::formatter().toString(*inst))));
		}

		resultsDialog->addResult({rva, instruction_string});
	}
}

/**
 * @brief test_deref_reg_to_ip
 * @param resultsDialog
 * @param data
 * @param start_address
 */
template <int Register>
void test_deref_reg_to_ip(DialogResults *resultsDialog, const OpcodeData &data, edb::address_t start_address) {
	const uint8_t *p    = data.data();
	const uint8_t *last = p + sizeof(data);

	edb::Instruction inst(p, last, 0);

	if (inst) {

		if (is_call(inst) || is_jump(inst)) {
			const auto op1 = inst[0];
			if (is_expression(op1)) {

				if (op1->mem.disp == 0) {

					if (op1->mem.base == Register && op1->mem.index == X86_REG_INVALID && op1->mem.scale == 1) {
						add_result(resultsDialog, {&inst}, start_address);
						return;
					}

					if (op1->mem.index == Register && op1->mem.base == X86_REG_INVALID && op1->mem.scale == 1) {
						add_result(resultsDialog, {&inst}, start_address);
						return;
					}
				}
			}
		}
	}
}

/**
 * @brief test_reg_to_ip
 * @param resultsDialog
 * @param data
 * @param start_address
 */
template <int Register, int StackRegister>
void test_reg_to_ip(DialogResults *resultsDialog, const OpcodeData &data, edb::address_t start_address) {

	const uint8_t *p    = data.data();
	const uint8_t *last = p + sizeof(data);

	edb::Instruction inst(p, last, 0);

	if (inst) {
		if (is_call(inst) || is_jump(inst)) {
			const auto op1 = inst[0];
			if (is_register(op1)) {
				if (op1->reg == Register) {
					add_result(resultsDialog, {&inst}, start_address);
					return;
				}
			}
		} else {
			const auto op1 = inst[0];
			switch (inst.operation()) {
			case X86_INS_PUSH:
				if (is_register(op1)) {
					if (op1->reg == Register) {

						p += inst.byteSize();
						edb::Instruction inst2(p, last, 0);
						if (inst2) {
							const auto op2 = inst2[0];

							if (is_ret(inst2)) {
								add_result(resultsDialog, {&inst, &inst2}, start_address);
							} else {
								switch (inst2.operation()) {
								case X86_INS_JMP:
								case X86_INS_CALL:

									if (is_expression(op2)) {

										if (op2->mem.disp == 0) {

											if (op2->mem.base == StackRegister && op2->mem.index == X86_REG_INVALID) {
												add_result(resultsDialog, {&inst, &inst2}, start_address);
												return;
											}

											if (op2->mem.index == StackRegister && op2->mem.base == X86_REG_INVALID) {
												add_result(resultsDialog, {&inst, &inst2}, start_address);
												return;
											}
										}
									}
									break;
								default:
									break;
								}
							}
						}
					}
				}
				break;
			default:
				break;
			}
		}
	}
}

/**
 * @brief test_esp_add_0
 * @param resultsDialog
 * @param data
 * @param start_address
 */
template <int StackRegister>
void test_esp_add_0(DialogResults *resultsDialog, const OpcodeData &data, edb::address_t start_address) {

	const uint8_t *p    = data.data();
	const uint8_t *last = p + sizeof(data);

	edb::Instruction inst(p, last, 0);

	if (inst) {
		const auto op1 = inst[0];
		if (is_ret(inst)) {
			add_result(resultsDialog, {&inst}, start_address);
		} else if (is_call(inst) || is_jump(inst)) {
			if (is_expression(op1)) {

				if (op1->mem.disp == 0) {

					if (op1->mem.base == StackRegister && op1->mem.index == X86_REG_INVALID) {
						add_result(resultsDialog, {&inst}, start_address);
						return;
					}

					if (op1->mem.index == StackRegister && op1->mem.base == X86_REG_INVALID) {
						add_result(resultsDialog, {&inst}, start_address);
						return;
					}
				}
			}
		} else {
			switch (inst.operation()) {
			case X86_INS_POP:
				if (is_register(op1)) {

					p += inst.byteSize();
					edb::Instruction inst2(p, last, 0);
					if (inst2) {
						const auto op2 = inst2[0];
						switch (inst2.operation()) {
						case X86_INS_JMP:
						case X86_INS_CALL:

							if (is_register(op2)) {

								if (op1->reg == op2->reg) {
									add_result(resultsDialog, {&inst, &inst2}, start_address);
								}
							}
							break;
						default:
							break;
						}
					}
				}
				break;
			default:
				break;
			}
		}
	}
}

/**
 * @brief test_esp_add_regx1
 * @param resultsDialog
 * @param data
 * @param start_address
 */
template <int StackRegister>
void test_esp_add_regx1(DialogResults *resultsDialog, const OpcodeData &data, edb::address_t start_address) {

	const uint8_t *p    = data.data();
	const uint8_t *last = p + sizeof(data);

	edb::Instruction inst(p, last, 0);

	if (inst) {
		const auto op1 = inst[0];
		if (is_call(inst) || is_jump(inst)) {
			if (is_expression(op1)) {

				if (op1->mem.disp == 4) {
					if (op1->mem.base == StackRegister && op1->mem.index == X86_REG_INVALID) {
						add_result(resultsDialog, {&inst}, start_address);
					} else if (op1->mem.base == X86_REG_INVALID && op1->mem.index == StackRegister && op1->mem.scale == 1) {
						add_result(resultsDialog, {&inst}, start_address);
					}
				}
			}
		} else {
			switch (inst.operation()) {
			case X86_INS_POP:

				if (!is_register(op1) || op1->reg != StackRegister) {
					p += inst.byteSize();
					edb::Instruction inst2(p, last, 0);
					if (inst2) {
						if (is_ret(inst2)) {
							add_result(resultsDialog, {&inst, &inst2}, start_address);
						}
					}
				}
				break;
			case X86_INS_SUB:
				if (is_register(op1) && op1->reg == StackRegister) {

					const auto op2 = inst[1];
					if (is_expression(op2)) {

						if (op2->imm == -static_cast<int>(sizeof(edb::reg_t))) {
							p += inst.byteSize();
							edb::Instruction inst2(p, last, 0);
							if (inst2) {
								if (is_ret(inst2)) {
									add_result(resultsDialog, {&inst, &inst2}, start_address);
								}
							}
						}
					}
				}
				break;
			case X86_INS_ADD:
				if (is_register(op1) && op1->reg == StackRegister) {

					const auto op2 = inst[1];
					if (is_expression(op2)) {

						if (op2->imm == sizeof(edb::reg_t)) {
							p += inst.byteSize();
							edb::Instruction inst2(p, last, 0);
							if (inst2) {
								if (is_ret(inst2)) {
									add_result(resultsDialog, {&inst, &inst2}, start_address);
								}
							}
						}
					}
				}
				break;

			default:
				break;
			}
		}
	}
}

/**
 * @brief test_esp_add_regx2
 * @param resultsDialog
 * @param data
 * @param start_address
 */
template <int StackRegister>
void test_esp_add_regx2(DialogResults *resultsDialog, const OpcodeData &data, edb::address_t start_address) {

	const uint8_t *p    = data.data();
	const uint8_t *last = p + sizeof(data);

	edb::Instruction inst(p, last, 0);

	if (inst) {
		const auto op1 = inst[0];
		if (is_call(inst) || is_jump(inst)) {
			if (is_expression(op1)) {

				if (op1->mem.disp == (sizeof(edb::reg_t) * 2)) {
					if (op1->mem.base == StackRegister && op1->mem.index == X86_REG_INVALID) {
						add_result(resultsDialog, {&inst}, start_address);
					} else if (op1->mem.base == X86_REG_INVALID && op1->mem.index == StackRegister && op1->mem.scale == 1) {
						add_result(resultsDialog, {&inst}, start_address);
					}
				}
			}
		} else {
			switch (inst.operation()) {
			case X86_INS_POP:

				if (!is_register(op1) || op1->reg != StackRegister) {
					p += inst.byteSize();
					edb::Instruction inst2(p, last, 0);
					if (inst2) {
						const auto op2 = inst2[0];
						switch (inst2.operation()) {
						case X86_INS_POP:

							if (!is_register(op2) || op2->reg != StackRegister) {
								p += inst2.byteSize();
								edb::Instruction inst3(p, last, 0);
								if (inst3) {
									if (is_ret(inst3)) {
										add_result(resultsDialog, {&inst, &inst2, &inst3}, start_address);
									}
								}
							}
							break;
						default:
							break;
						}
					}
				}
				break;
			case X86_INS_SUB:
				if (is_register(op1) && op1->reg == StackRegister) {

					const auto op2 = inst[1];
					if (is_expression(op2)) {

						if (op2->imm == -static_cast<int>(sizeof(edb::reg_t) * 2)) {
							p += inst.byteSize();
							edb::Instruction inst2(p, last, 0);
							if (inst2) {
								if (is_ret(inst2)) {
									add_result(resultsDialog, {&inst, &inst2}, start_address);
								}
							}
						}
					}
				}
				break;

			case X86_INS_ADD:
				if (is_register(op1) && op1->reg == StackRegister) {

					const auto op2 = inst[1];
					if (is_expression(op2)) {

						if (op2->imm == (sizeof(edb::reg_t) * 2)) {
							p += inst.byteSize();
							edb::Instruction inst2(p, last, 0);
							if (inst2) {
								if (is_ret(inst2)) {
									add_result(resultsDialog, {&inst, &inst2}, start_address);
								}
							}
						}
					}
				}
				break;

			default:
				break;
			}
		}
	}
}

/**
 * @brief test_esp_sub_regx1
 * @param resultsDialog
 * @param data
 * @param start_address
 */
template <int StackRegister>
void test_esp_sub_regx1(DialogResults *resultsDialog, const OpcodeData &data, edb::address_t start_address) {

	const uint8_t *p    = data.data();
	const uint8_t *last = p + sizeof(data);

	edb::Instruction inst(p, last, 0);

	if (inst) {
		const auto op1 = inst[0];
		if (is_call(inst) || is_jump(inst)) {
			if (is_expression(op1)) {

				if (op1->mem.disp == -static_cast<int>(sizeof(edb::reg_t))) {
					if (op1->mem.base == StackRegister && op1->mem.index == X86_REG_INVALID) {
						add_result(resultsDialog, {&inst}, start_address);
					} else if (op1->mem.base == X86_REG_INVALID && op1->mem.index == StackRegister && op1->mem.scale == 1) {
						add_result(resultsDialog, {&inst}, start_address);
					}
				}
			}
		} else {
			switch (inst.operation()) {
			case X86_INS_SUB:
				if (is_register(op1) && op1->reg == StackRegister) {

					const auto op2 = inst[1];
					if (is_expression(op2)) {

						if (op2->imm == static_cast<int>(sizeof(edb::reg_t))) {
							p += inst.byteSize();
							edb::Instruction inst2(p, last, 0);
							if (inst2) {
								if (is_ret(inst2)) {
									add_result(resultsDialog, {&inst, &inst2}, start_address);
								}
							}
						}
					}
				}
				break;

			case X86_INS_ADD:
				if (is_register(op1) && op1->reg == StackRegister) {

					const auto op2 = inst[1];
					if (is_expression(op2)) {

						if (op2->imm == -static_cast<int>(sizeof(edb::reg_t))) {
							p += inst.byteSize();
							edb::Instruction inst2(p, last, 0);
							if (inst2) {
								if (is_ret(inst2)) {
									add_result(resultsDialog, {&inst, &inst2}, start_address);
								}
							}
						}
					}
				}
				break;

			default:
				break;
			}
		}
	}
}

/**
 * @brief run_tests
 * @param resultsDialog
 * @param classtype
 * @param opcode
 * @param address
 */
void run_tests(DialogResults *resultsDialog, int classtype, const OpcodeData &opcode, edb::address_t address) {

#if defined(EDB_X86) || defined(EDB_X86_64)
	if (edb::v1::debuggeeIs32Bit()) {
		switch (classtype) {
		case 1:
			test_reg_to_ip<X86_REG_EAX, X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		case 2:
			test_reg_to_ip<X86_REG_EBX, X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		case 3:
			test_reg_to_ip<X86_REG_ECX, X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		case 4:
			test_reg_to_ip<X86_REG_EDX, X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		case 5:
			test_reg_to_ip<X86_REG_EBP, X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		case 6:
			test_reg_to_ip<X86_REG_ESP, X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		case 7:
			test_reg_to_ip<X86_REG_ESI, X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		case 8:
			test_reg_to_ip<X86_REG_EDI, X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		case 17:
			test_reg_to_ip<X86_REG_EAX, X86_REG_ESP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_EBX, X86_REG_ESP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_ECX, X86_REG_ESP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_EDX, X86_REG_ESP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_EBP, X86_REG_ESP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_ESP, X86_REG_ESP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_ESI, X86_REG_ESP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_EDI, X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		case 18:
			// [ESP] -> EIP
			test_esp_add_0<X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		case 19:
			// [ESP + 4] -> EIP
			test_esp_add_regx1<X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		case 20:
			// [ESP + 8] -> EIP
			test_esp_add_regx2<X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		case 21:
			// [ESP - 4] -> EIP
			test_esp_sub_regx1<X86_REG_ESP>(resultsDialog, opcode, address);
			break;
		}
	} else {
		switch (classtype) {
		case 1:
			test_reg_to_ip<X86_REG_RAX, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 2:
			test_reg_to_ip<X86_REG_RBX, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 3:
			test_reg_to_ip<X86_REG_RCX, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 4:
			test_reg_to_ip<X86_REG_RDX, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 5:
			test_reg_to_ip<X86_REG_RBP, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 6:
			test_reg_to_ip<X86_REG_RSP, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 7:
			test_reg_to_ip<X86_REG_RSI, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 8:
			test_reg_to_ip<X86_REG_RDI, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 9:
			test_reg_to_ip<X86_REG_R8, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 10:
			test_reg_to_ip<X86_REG_R9, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 11:
			test_reg_to_ip<X86_REG_R10, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 12:
			test_reg_to_ip<X86_REG_R11, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 13:
			test_reg_to_ip<X86_REG_R12, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 14:
			test_reg_to_ip<X86_REG_R13, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 15:
			test_reg_to_ip<X86_REG_R14, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 16:
			test_reg_to_ip<X86_REG_R15, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 17:
			test_reg_to_ip<X86_REG_RAX, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_RBX, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_RCX, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_RDX, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_RBP, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_RSP, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_RSI, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_RDI, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_R8, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_R9, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_R10, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_R11, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_R12, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_R13, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_R14, X86_REG_RSP>(resultsDialog, opcode, address);
			test_reg_to_ip<X86_REG_R15, X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 18:
			// [ESP] -> EIP
			test_esp_add_0<X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 19:
			// [ESP + 4] -> EIP
			test_esp_add_regx1<X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 20:
			// [ESP + 8] -> EIP
			test_esp_add_regx2<X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 21:
			// [ESP - 4] -> EIP
			test_esp_sub_regx1<X86_REG_RSP>(resultsDialog, opcode, address);
			break;
		case 22:
			test_deref_reg_to_ip<X86_REG_RAX>(resultsDialog, opcode, address);
			break;
		case 23:
			test_deref_reg_to_ip<X86_REG_RBX>(resultsDialog, opcode, address);
			break;
		case 24:
			test_deref_reg_to_ip<X86_REG_RCX>(resultsDialog, opcode, address);
			break;
		case 25:
			test_deref_reg_to_ip<X86_REG_RDX>(resultsDialog, opcode, address);
			break;
		case 26:
			test_deref_reg_to_ip<X86_REG_RBP>(resultsDialog, opcode, address);
			break;
		case 28:
			test_deref_reg_to_ip<X86_REG_RSI>(resultsDialog, opcode, address);
			break;
		case 29:
			test_deref_reg_to_ip<X86_REG_RDI>(resultsDialog, opcode, address);
			break;
		case 30:
			test_deref_reg_to_ip<X86_REG_R8>(resultsDialog, opcode, address);
			break;
		case 31:
			test_deref_reg_to_ip<X86_REG_R9>(resultsDialog, opcode, address);
			break;
		case 32:
			test_deref_reg_to_ip<X86_REG_R10>(resultsDialog, opcode, address);
			break;
		case 33:
			test_deref_reg_to_ip<X86_REG_R11>(resultsDialog, opcode, address);
			break;
		case 34:
			test_deref_reg_to_ip<X86_REG_R12>(resultsDialog, opcode, address);
			break;
		case 35:
			test_deref_reg_to_ip<X86_REG_R13>(resultsDialog, opcode, address);
			break;
		case 36:
			test_deref_reg_to_ip<X86_REG_R14>(resultsDialog, opcode, address);
			break;
		case 37:
			test_deref_reg_to_ip<X86_REG_R15>(resultsDialog, opcode, address);
			break;
		}
	}
#elif defined(EDB_ARM32)
	// TODO(eteran): implement
#elif defined(EDB_ARM64)
	// TODO(eteran): implement
#endif
}

}

/**
 * @brief DialogOpcodes::DialogOpcodes
 * @param parent
 * @param f
 */
DialogOpcodes::DialogOpcodes(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {
	ui.setupUi(this);
	ui.tableView->verticalHeader()->hide();
	ui.tableView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

	filterModel_ = new QSortFilterProxyModel(this);
	connect(ui.txtSearch, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);

	buttonFind_ = new QPushButton(QIcon::fromTheme("edit-find"), tr("Find"));
	connect(buttonFind_, &QPushButton::clicked, this, [this]() {
		buttonFind_->setEnabled(false);
		ui.progressBar->setValue(0);
		doFind();
		ui.progressBar->setValue(100);
		buttonFind_->setEnabled(true);
	});

	ui.buttonBox->addButton(buttonFind_, QDialogButtonBox::ActionRole);
}

/**
 * @brief DialogOpcodes::showEvent
 */
void DialogOpcodes::showEvent(QShowEvent *) {
	filterModel_->setFilterKeyColumn(3);
	filterModel_->setSourceModel(&edb::v1::memory_regions());
	ui.tableView->setModel(filterModel_);
	ui.progressBar->setValue(0);

	ui.comboBox->clear();

#if defined(EDB_X86) || defined(EDB_X86_64)
	if (edb::v1::debuggeeIs64Bit()) {
		ui.comboBox->addItem("RAX -> RIP", 1);
		ui.comboBox->addItem("RBX -> RIP", 2);
		ui.comboBox->addItem("RCX -> RIP", 3);
		ui.comboBox->addItem("RDX -> RIP", 4);
		ui.comboBox->addItem("RBP -> RIP", 5);
		ui.comboBox->addItem("RSP -> RIP", 6);
		ui.comboBox->addItem("RSI -> RIP", 7);
		ui.comboBox->addItem("RDI -> RIP", 8);
		ui.comboBox->addItem("R8 -> RIP", 9);
		ui.comboBox->addItem("R9 -> RIP", 10);
		ui.comboBox->addItem("R10 -> RIP", 11);
		ui.comboBox->addItem("R11 -> RIP", 12);
		ui.comboBox->addItem("R12 -> RIP", 13);
		ui.comboBox->addItem("R13 -> RIP", 14);
		ui.comboBox->addItem("R14 -> RIP", 15);
		ui.comboBox->addItem("R15 -> RIP", 16);
		ui.comboBox->addItem("ANY REGISTER -> RIP", 17);
		ui.comboBox->addItem("[RSP] -> RIP", 18);
		ui.comboBox->addItem("[RSP + 8] -> RIP", 19);
		ui.comboBox->addItem("[RSP + 16] -> RIP", 20);
		ui.comboBox->addItem("[RSP - 8] -> RIP", 21);
		ui.comboBox->addItem("[RAX] -> RIP", 22);
		ui.comboBox->addItem("[RBX] -> RIP", 23);
		ui.comboBox->addItem("[RCX] -> RIP", 24);
		ui.comboBox->addItem("[RDX] -> RIP", 25);
		ui.comboBox->addItem("[RBP] -> RIP", 26);
		ui.comboBox->addItem("[RSI] -> RIP", 28);
		ui.comboBox->addItem("[RDI] -> RIP", 29);
		ui.comboBox->addItem("[R8] -> RIP", 30);
		ui.comboBox->addItem("[R9] -> RIP", 31);
		ui.comboBox->addItem("[R10] -> RIP", 32);
		ui.comboBox->addItem("[R11] -> RIP", 33);
		ui.comboBox->addItem("[R12] -> RIP", 34);
		ui.comboBox->addItem("[R13] -> RIP", 35);
		ui.comboBox->addItem("[R14] -> RIP", 36);
		ui.comboBox->addItem("[R15] -> RIP", 37);
	} else {
		ui.comboBox->addItem("EAX -> EIP", 1);
		ui.comboBox->addItem("EBX -> EIP", 2);
		ui.comboBox->addItem("ECX -> EIP", 3);
		ui.comboBox->addItem("EDX -> EIP", 4);
		ui.comboBox->addItem("EBP -> EIP", 5);
		ui.comboBox->addItem("ESP -> EIP", 6);
		ui.comboBox->addItem("ESI -> EIP", 7);
		ui.comboBox->addItem("EDI -> EIP", 8);
		ui.comboBox->addItem("ANY REGISTER -> EIP", 17);
		ui.comboBox->addItem("[ESP] -> EIP", 18);
		ui.comboBox->addItem("[ESP + 4] -> EIP", 19);
		ui.comboBox->addItem("[ESP + 8] -> EIP", 20);
		ui.comboBox->addItem("[ESP - 4] -> EIP", 21);

		ui.comboBox->addItem("[EAX] -> EIP", 22);
		ui.comboBox->addItem("[EBX] -> EIP", 23);
		ui.comboBox->addItem("[ECX] -> EIP", 24);
		ui.comboBox->addItem("[EDX] -> EIP", 25);
		ui.comboBox->addItem("[EBP] -> EIP", 26);
		ui.comboBox->addItem("[ESI] -> EIP", 28);
		ui.comboBox->addItem("[EDI] -> EIP", 29);
	}
#elif defined(EDB_ARM32)
	// TODO(eteran): implement
#elif defined(EDB_ARM64)
	// TODO(eteran): implement
#endif
}

/**
 * @brief DialogOpcodes::doFind
 */
void DialogOpcodes::doFind() {

	const int classtype = ui.comboBox->itemData(ui.comboBox->currentIndex()).toInt();

	const QItemSelectionModel *const selModel = ui.tableView->selectionModel();
	const QModelIndexList sel                 = selModel->selectedRows();

	if (sel.size() == 0) {
		QMessageBox::critical(
			this,
			tr("No Region Selected"),
			tr("You must select a region which is to be scanned for the desired opcode."));
		return;
	}

	auto resultsDialog = new DialogResults(this);

	if (IProcess *process = edb::v1::debugger_core->process()) {
		for (const QModelIndex &selected_item : sel) {

			const QModelIndex index = filterModel_->mapToSource(selected_item);

			if (auto region = *reinterpret_cast<const std::shared_ptr<IRegion> *>(index.internalPointer())) {

				edb::address_t start_address     = region->start();
				edb::address_t address           = region->start();
				const edb::address_t end_address = region->end();
				const edb::address_t orig_start  = region->start();

				OpcodeData shift_buffer = {};

				// this will read the rest of the region
				size_t i = 0;
				while (start_address < end_address) {

					// create a reference to the bsa's data so we can pass it to the testXXXX functions
					// but only do so if we have read enough bytes to fill our shift buffer
					if (i >= shift_buffer.size()) {
						run_tests(resultsDialog, classtype, shift_buffer, address - shift_buffer.size());
					}

					uint8_t byte;
					process->readBytes(start_address, &byte, 1);
					util::shl(shift_buffer, byte);

					++start_address;

					ui.progressBar->setValue(util::percentage(address - orig_start, region->size()));
					++address;
					++i;
				}

				// test the stuff at the regions edge
				for (size_t i = 0; i < shift_buffer.size(); ++i) {

					// create a reference to the bsa's data so we can pass it to the testXXXX functions
					run_tests(resultsDialog, classtype, shift_buffer, address - shift_buffer.size());

					// we just shift in 0's and hope it doesn't give false positives
					util::shl(shift_buffer, 0x00);

					ui.progressBar->setValue(util::percentage(address - orig_start, region->size()));
					++address;
				}
			}
		}
	}

	if (resultsDialog->resultCount() == 0) {
		QMessageBox::information(this, tr("No Opcodes Found"), tr("No opcodes were found in the selected region."));
		delete resultsDialog;
	} else {
		resultsDialog->show();
	}
}

}

```

`plugins/OpcodeSearcher/DialogOpcodes.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_OPCODES_H_20061101_
#define DIALOG_OPCODES_H_20061101_

#include "ui_DialogOpcodes.h"
#include <QDialog>

class QSortFilterProxyModel;

namespace OpcodeSearcherPlugin {

class DialogResults;

class DialogOpcodes : public QDialog {
	Q_OBJECT

public:
	explicit DialogOpcodes(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogOpcodes() override = default;

private:
	void doFind();

private:
	void showEvent(QShowEvent *event) override;

private:
	Ui::DialogOpcodes ui;
	QSortFilterProxyModel *filterModel_ = nullptr;
	QPushButton *buttonFind_            = nullptr;
};

}

#endif

```

`plugins/OpcodeSearcher/DialogOpcodes.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>OpcodeSearcherPlugin::DialogOpcodes</class>
 <widget class="QDialog" name="OpcodeSearcherPlugin::DialogOpcodes">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>750</width>
    <height>400</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Opcode Search</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QLabel" name="label">
     <property name="text">
      <string>Regions To Search:</string>
     </property>
    </widget>
   </item>
   <item row="0" column="1" rowspan="3">
    <widget class="QGroupBox" name="groupBox">
     <property name="title">
      <string>What To Search For</string>
     </property>
     <layout class="QVBoxLayout">
      <property name="spacing">
       <number>6</number>
      </property>
      <item>
       <widget class="QRadioButton" name="radioButton">
        <property name="text">
         <string>&amp;Jump Equivalent</string>
        </property>
        <property name="checked">
         <bool>true</bool>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QComboBox" name="comboBox"/>
      </item>
      <item>
       <spacer>
        <property name="orientation">
         <enum>Qt::Vertical</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>20</width>
          <height>40</height>
         </size>
        </property>
       </spacer>
      </item>
     </layout>
    </widget>
   </item>
   <item row="1" column="0">
    <widget class="QLineEdit" name="txtSearch">
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item row="2" column="0">
    <widget class="QTableView" name="tableView">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
    </widget>
   </item>
   <item row="3" column="0" colspan="2">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
   <item row="4" column="0" colspan="2">
    <widget class="QProgressBar" name="progressBar">
     <property name="value">
      <number>0</number>
     </property>
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>txtSearch</tabstop>
  <tabstop>tableView</tabstop>
  <tabstop>radioButton</tabstop>
  <tabstop>comboBox</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>OpcodeSearcherPlugin::DialogOpcodes</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>190</x>
     <y>294</y>
    </hint>
    <hint type="destinationlabel">
     <x>172</x>
     <y>277</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>OpcodeSearcherPlugin::DialogOpcodes</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>294</x>
     <y>306</y>
    </hint>
    <hint type="destinationlabel">
     <x>303</x>
     <y>276</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/OpcodeSearcher/DialogResults.cpp`:

```cpp

#include "DialogResults.h"
#include "edb.h"
#include <QSortFilterProxyModel>

namespace OpcodeSearcherPlugin {

/**
 * @brief DialogResults::DialogResults
 * @param parent
 * @param f
 */
DialogResults::DialogResults(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
	ui.tableView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

	model_       = new ResultsModel(this);
	filterModel_ = new QSortFilterProxyModel(this);

	filterModel_->setFilterKeyColumn(1);
	filterModel_->setSourceModel(model_);
	ui.tableView->setModel(filterModel_);

	connect(ui.textFilter, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);
}

/**
 * @brief DialogResults::addResult
 * @param result
 */
void DialogResults::addResult(const ResultsModel::Result &result) {
	model_->addResult(result);
}

/**
 * @brief DialogResults::on_tableView_doubleClicked
 * @param index
 */
void DialogResults::on_tableView_doubleClicked(const QModelIndex &index) {
	if (index.isValid()) {
		const QModelIndex realIndex = filterModel_->mapToSource(index);
		if (realIndex.isValid()) {
			if (auto item = static_cast<ResultsModel::Result *>(realIndex.internalPointer())) {
				edb::v1::jump_to_address(item->address);
			}
		}
	}
}

/**
 * @brief DialogResults::resultCount
 * @return
 */
int DialogResults::resultCount() const {
	return model_->rowCount();
}

}

```

`plugins/OpcodeSearcher/DialogResults.h`:

```h

#ifndef OPCODE_SEARCHER_DIALOG_RESULTS_H_20191119_
#define OPCODE_SEARCHER_DIALOG_RESULTS_H_20191119_

#include "ResultsModel.h"
#include "ui_DialogResults.h"
#include <QDialog>
#include <QSortFilterProxyModel>

class QSortFilterProxyModel;

namespace OpcodeSearcherPlugin {

class DialogResults : public QDialog {
	Q_OBJECT

public:
	explicit DialogResults(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());

public:
	void addResult(const ResultsModel::Result &result);

private Q_SLOTS:
	void on_tableView_doubleClicked(const QModelIndex &index);

public:
	int resultCount() const;

private:
	Ui::DialogResults ui;
	ResultsModel *model_                = nullptr;
	QSortFilterProxyModel *filterModel_ = nullptr;
};

}

#endif

```

`plugins/OpcodeSearcher/DialogResults.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>OpcodeSearcherPlugin::DialogResults</class>
 <widget class="QDialog" name="OpcodeSearcherPlugin::DialogResults">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>690</width>
    <height>315</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Opcode Results</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="1" column="0">
    <widget class="QTableView" name="tableView">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="contextMenuPolicy">
      <enum>Qt::CustomContextMenu</enum>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
    </widget>
   </item>
   <item row="0" column="0" colspan="2">
    <widget class="QLineEdit" name="textFilter">
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item row="2" column="0" colspan="2">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>OpcodeSearcherPlugin::DialogResults</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>224</x>
     <y>326</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>OpcodeSearcherPlugin::DialogResults</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>292</x>
     <y>332</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/OpcodeSearcher/OpcodeSearcher.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "OpcodeSearcher.h"
#include "DialogOpcodes.h"
#include "edb.h"
#include <QMenu>

namespace OpcodeSearcherPlugin {

/**
 * @brief OpcodeSearcher::OpcodeSearcher
 * @param parent
 */
OpcodeSearcher::OpcodeSearcher(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief OpcodeSearcher::~OpcodeSearcher
 */
OpcodeSearcher::~OpcodeSearcher() {
	delete dialog_;
}

/**
 * @brief OpcodeSearcher::menu
 * @param parent
 * @return
 */
QMenu *OpcodeSearcher::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("OpcodeSearcher"), parent);
		menu_->addAction(tr("&Opcode Search"), this, SLOT(showMenu()), QKeySequence(tr("Ctrl+O")));
	}

	return menu_;
}

/**
 * @brief OpcodeSearcher::showMenu
 */
void OpcodeSearcher::showMenu() {

	if (!dialog_) {
		dialog_ = new DialogOpcodes(edb::v1::debugger_ui);
	}

	dialog_->show();
}

}

```

`plugins/OpcodeSearcher/OpcodeSearcher.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef OPCODE_SEARCHER_H_20060430_
#define OPCODE_SEARCHER_H_20060430_

#include "IPlugin.h"

class QMenu;
class QDialog;

namespace OpcodeSearcherPlugin {

class OpcodeSearcher : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit OpcodeSearcher(QObject *parent = nullptr);
	~OpcodeSearcher() override;

public:
	QMenu *menu(QWidget *parent = nullptr) override;

public Q_SLOTS:
	void showMenu();

private:
	QMenu *menu_              = nullptr;
	QPointer<QDialog> dialog_ = nullptr;
};

}

#endif

```

`plugins/OpcodeSearcher/ResultsModel.cpp`:

```cpp
/*
Copyright (C) 2006 - 2019 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ResultsModel.h"
#include "edb.h"
#include <algorithm>

namespace OpcodeSearcherPlugin {

/**
 * @brief ResultsModel::ResultsModel
 * @param parent
 */
ResultsModel::ResultsModel(QObject *parent)
	: QAbstractItemModel(parent) {
}

/**
 * @brief ResultsModel::headerData
 * @param section
 * @param orientation
 * @param role
 * @return
 */
QVariant ResultsModel::headerData(int section, Qt::Orientation orientation, int role) const {

	if (role == Qt::DisplayRole && orientation == Qt::Horizontal) {
		switch (section) {
		case 0:
			return tr("Address");
		case 1:
			return tr("Instruction");
		}
	}

	return QVariant();
}

/**
 * @brief ResultsModel::data
 * @param index
 * @param role
 * @return
 */
QVariant ResultsModel::data(const QModelIndex &index, int role) const {

	if (!index.isValid()) {
		return QVariant();
	}

	const Result &result = results_[index.row()];

	if (role == Qt::DisplayRole) {
		switch (index.column()) {
		case 0:
			return edb::v1::format_pointer(result.address);
		case 1:
			return result.instruction;
		default:
			return QVariant();
		}
	}

	return QVariant();
}

/**
 * @brief ResultsModel::addResult
 * @param r
 */
void ResultsModel::addResult(const Result &r) {
	beginInsertRows(QModelIndex(), rowCount(), rowCount());
	results_.push_back(r);
	endInsertRows();
}

/**
 * @brief ResultsModel::index
 * @param row
 * @param column
 * @param parent
 * @return
 */
QModelIndex ResultsModel::index(int row, int column, const QModelIndex &parent) const {

	Q_UNUSED(parent)

	if (row >= results_.size()) {
		return QModelIndex();
	}

	if (column >= 2) {
		return QModelIndex();
	}

	if (row >= 0) {
		return createIndex(row, column, const_cast<Result *>(&results_[row]));
	} else {
		return createIndex(row, column);
	}
}

/**
 * @brief ResultsModel::parent
 * @param index
 * @return
 */
QModelIndex ResultsModel::parent(const QModelIndex &index) const {
	Q_UNUSED(index)
	return QModelIndex();
}

/**
 * @brief ResultsModel::rowCount
 * @param parent
 * @return
 */
int ResultsModel::rowCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return results_.size();
}

/**
 * @brief ResultsModel::columnCount
 * @param parent
 * @return
 */
int ResultsModel::columnCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return 2;
}

/**
 * @brief ResultsModel::sort
 * @param column
 * @param order
 */
void ResultsModel::sort(int column, Qt::SortOrder order) {

	if (order == Qt::AscendingOrder) {
		switch (column) {
		case 0:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.address < s2.address; });
			break;
		case 1:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.instruction < s2.instruction; });
			break;
		}
	} else {
		switch (column) {
		case 0:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.address > s2.address; });
			break;
		case 1:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.instruction > s2.instruction; });
			break;
		}
	}

	Q_EMIT dataChanged(createIndex(0, 0, nullptr), createIndex(-1, -1, nullptr));
}

}

```

`plugins/OpcodeSearcher/ResultsModel.h`:

```h
/*
Copyright (C) 2006 - 2019 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef OPCODES_RESULTS_MODEL_H_20191119_
#define OPCODES_RESULTS_MODEL_H_20191119_

#include "Function.h"
#include "Types.h"
#include <QAbstractItemModel>
#include <QVector>

namespace OpcodeSearcherPlugin {

class ResultsModel : public QAbstractItemModel {
	Q_OBJECT

public:
	struct Result {
		edb::address_t address = 0;
		QString instruction;
	};

public:
	explicit ResultsModel(QObject *parent = nullptr);

public:
	QVariant data(const QModelIndex &index, int role) const override;
	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex &index) const override;
	int rowCount(const QModelIndex &parent = QModelIndex()) const override;
	int columnCount(const QModelIndex &parent = QModelIndex()) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
	void sort(int column, Qt::SortOrder order = Qt::AscendingOrder) override;

public:
	void addResult(const Result &r);

public:
	const QVector<Result> &results() const { return results_; }

private:
	QVector<Result> results_;
};

}

#endif

```

`plugins/ProcessProperties/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "ProcessProperties")

find_package(Qt5 5.0.0 REQUIRED Widgets Network)

add_library(${PluginName} SHARED
    DialogProcessProperties.cpp
    DialogProcessProperties.h
    DialogProcessProperties.ui
    DialogStrings.cpp
    DialogStrings.h
    DialogStrings.ui
    ProcessProperties.cpp
    ProcessProperties.h
    DialogResults.cpp
    DialogResults.h
    DialogResults.ui
    ResultsModel.cpp
    ResultsModel.h
)

target_link_libraries(${PluginName} Qt5::Widgets Qt5::Network edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/ProcessProperties/DialogProcessProperties.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogProcessProperties.h"
#include "Configuration.h"
#include "DialogStrings.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IRegion.h"
#include "ISymbolManager.h"
#include "MemoryRegions.h"
#include "Module.h"
#include "QtHelper.h"
#include "Symbol.h"
#include "edb.h"

#include <QDateTime>
#include <QDebug>
#include <QDesktopServices>
#include <QDir>
#include <QFileInfo>
#include <QHostAddress>
#include <QStringList>
#include <QStringListModel>
#include <QUrl>

#if defined(Q_OS_LINUX) || defined(Q_OS_FREEBSD) || defined(Q_OS_OPENBSD)
#include <arpa/inet.h>
#include <link.h>
#endif

namespace ProcessPropertiesPlugin {

Q_DECLARE_NAMESPACE_TR(ProcessPropertiesPlugin)

namespace {
/**
 * @brief arguments_to_string
 * @param args
 * @return
 */
QString arguments_to_string(const QList<QByteArray> &args) {
	QString ret;

	for (const QByteArray &arg : args) {
		ret.append(' ');
		ret.append(QString::fromUtf8(arg));
	}

	ret.remove(0, 1);
	return ret;
}

/**
 * @brief size_to_string
 * @param n
 * @return
 */
QString size_to_string(size_t n) {

	static constexpr size_t KiB = 1024;
	static constexpr size_t MiB = KiB * 1024;
	static constexpr size_t GiB = MiB * 1024;

	if (n < KiB) {
		return QString::number(n);
	} else if (n < MiB) {
		return QString::number(n / KiB) + tr(" KiB");
	} else if (n < GiB) {
		return QString::number(n / MiB) + tr(" MiB");
	} else {
		return QString::number(n / GiB) + tr(" GiB");
	}
}

#if defined(Q_OS_LINUX)
/**
 * @brief file_type
 * @param filename
 * @return
 */
QString file_type(const QString &filename) {
	const QFileInfo info(filename);
	const QString basename(info.completeBaseName());

	if (basename.startsWith("socket:")) {
		return tr("Socket");
	}

	if (basename.startsWith("pipe:")) {
		return tr("Pipe");
	}

	return tr("File");
}

/**
 * @brief tcp_socket_prcoessor
 * @param symlink
 * @param sock
 * @param lst
 * @return
 */
bool tcp_socket_prcoessor(QString *symlink, int sock, const QStringList &lst) {

	Q_ASSERT(symlink);

	if (lst.size() >= 13) {

		bool ok;
		const uint32_t local_address = ntohl(lst[1].toUInt(&ok, 16));
		if (ok) {
			const uint16_t local_port = lst[2].toUInt(&ok, 16);
			if (ok) {
				const uint32_t remote_address = ntohl(lst[3].toUInt(&ok, 16));
				if (ok) {
					const uint16_t remote_port = lst[4].toUInt(&ok, 16);
					if (ok) {
						const uint8_t state = lst[5].toUInt(&ok, 16);
						Q_UNUSED(state)
						if (ok) {
							const int inode = lst[13].toUInt(&ok, 10);
							if (ok) {
								if (inode == sock) {
									*symlink = QString("TCP: %1:%2 -> %3:%4")
												   .arg(QHostAddress(local_address).toString())
												   .arg(local_port)
												   .arg(QHostAddress(remote_address).toString())
												   .arg(remote_port);
									return true;
								}
							}
						}
					}
				}
			}
		}
	}
	return false;
}

/**
 * @brief udp_socket_processor
 * @param symlink
 * @param sock
 * @param lst
 * @return
 */
bool udp_socket_processor(QString *symlink, int sock, const QStringList &lst) {

	Q_ASSERT(symlink);

	if (lst.size() >= 13) {

		bool ok;
		const uint32_t local_address = ntohl(lst[1].toUInt(&ok, 16));
		if (ok) {
			const uint16_t local_port = lst[2].toUInt(&ok, 16);
			if (ok) {
				const uint32_t remote_address = ntohl(lst[3].toUInt(&ok, 16));
				if (ok) {
					const uint16_t remote_port = lst[4].toUInt(&ok, 16);
					if (ok) {
						const uint8_t state = lst[5].toUInt(&ok, 16);
						Q_UNUSED(state)
						if (ok) {
							const int inode = lst[13].toUInt(&ok, 10);
							if (ok) {
								if (inode == sock) {
									*symlink = QString("UDP: %1:%2 -> %3:%4")
												   .arg(QHostAddress(local_address).toString())
												   .arg(local_port)
												   .arg(QHostAddress(remote_address).toString())
												   .arg(remote_port);
									return true;
								}
							}
						}
					}
				}
			}
		}
	}
	return false;
}

/**
 * @brief unix_socket_processor
 * @param symlink
 * @param sock
 * @param lst
 * @return
 */
bool unix_socket_processor(QString *symlink, int sock, const QStringList &lst) {

	Q_ASSERT(symlink);

	if (lst.size() >= 6) {
		bool ok;
		// TODO(eteran): should this be toInt(...)?
		const int inode = lst[6].toUInt(&ok, 10);
		if (ok) {
			if (inode == sock) {
				*symlink = QString("UNIX [%1]").arg(lst[0]);
				return true;
			}
		}
	}
	return false;
}

/**
 * @brief process_socket_file
 * @param filename
 * @param symlink
 * @param sock
 * @param func
 * @return
 */
template <class F>
QString process_socket_file(const QString &filename, QString *symlink, int sock, F func) {

	Q_ASSERT(symlink);

	QFile net(filename);
	net.open(QIODevice::ReadOnly | QIODevice::Text);
	if (net.isOpen()) {
		QTextStream in(&net);
		QString line;

		// ditch first line, it is just table headings
		in.readLine();

		// read in the first line we care about
		line = in.readLine();

		// a null string means end of file (but not an empty string!)
		while (!line.isNull()) {

			QString lline(line);
#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
			const QStringList lst = lline.replace(":", " ").split(" ", Qt::SkipEmptyParts);
#else
			const QStringList lst = lline.replace(":", " ").split(" ", QString::SkipEmptyParts);
#endif

			if (func(symlink, sock, lst)) {
				break;
			}

			line = in.readLine();
		}
	}
	return *symlink;
}

/**
 * @brief process_socket_tcp
 * @param symlink
 * @return
 */
QString process_socket_tcp(QString *symlink) {

	Q_ASSERT(symlink);

	const QString socket_info(symlink->mid(symlink->indexOf("socket:[")));
	const int socket_number = socket_info.mid(8).remove("]").toUInt();

	return process_socket_file("/proc/net/tcp", symlink, socket_number, tcp_socket_prcoessor);
}

/**
 * @brief process_socket_unix
 * @param symlink
 * @return
 */
QString process_socket_unix(QString *symlink) {

	Q_ASSERT(symlink);

	const QString socket_info(symlink->mid(symlink->indexOf("socket:[")));
	const int socket_number = socket_info.mid(8).remove("]").toUInt();

	return process_socket_file("/proc/net/unix", symlink, socket_number, unix_socket_processor);
}

/**
 * @brief process_socket_udp
 * @param symlink
 * @return
 */
QString process_socket_udp(QString *symlink) {

	Q_ASSERT(symlink);

	const QString socket_info(symlink->mid(symlink->indexOf("socket:[")));
	const int socket_number = socket_info.mid(8).remove("]").toUInt();

	return process_socket_file("/proc/net/udp", symlink, socket_number, udp_socket_processor);
}
#endif

}

/**
 * @brief DialogProcessProperties::DialogProcessProperties
 * @param parent
 * @param f
 */
DialogProcessProperties::DialogProcessProperties(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
	ui.tableModules->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
	ui.tableMemory->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
	ui.threadTable->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

	threadsModel_  = new ThreadsModel(this);
	threadsFilter_ = new QSortFilterProxyModel(this);

	threadsFilter_->setSourceModel(threadsModel_);
	threadsFilter_->setFilterCaseSensitivity(Qt::CaseInsensitive);

	ui.threadTable->setModel(threadsFilter_);
}

/**
 * @brief DialogProcessProperties::updateGeneralPage
 */
void DialogProcessProperties::updateGeneralPage() {
	if (edb::v1::debugger_core) {
		if (IProcess *process = edb::v1::debugger_core->process()) {
			const QString exe = process->executable();
			const QString cwd = process->currentWorkingDirectory();

			std::shared_ptr<IProcess> parent = process->parent();
			const edb::pid_t parent_pid      = parent ? parent->pid() : 0;
			const QString parent_exe         = parent ? parent->executable() : QString();

			const QList<QByteArray> args = process->arguments();

			ui.editImage->setText(exe);

			// TODO(eteran): handle arguments with spaces
			ui.editCommand->setText(arguments_to_string(args));
			ui.editCurrentDirectory->setText(cwd);
			ui.editStarted->setText(process->startTime().toString("yyyy-MM-dd hh:mm:ss.z"));
			if (parent_pid) {
				ui.editParent->setText(QString("%1 (%2)").arg(parent_exe).arg(parent_pid));
			} else {
				ui.editParent->setText(QString());
			}
		} else {
			ui.editImage->setText(QString());
			ui.editCommand->setText(QString());
			ui.editCurrentDirectory->setText(QString());
			ui.editStarted->setText(QString());
			ui.editParent->setText(QString());
		}
	}
}

/**
 * @brief DialogProcessProperties::updateModulePage
 */
void DialogProcessProperties::updateModulePage() {

	ui.tableModules->clearContents();
	ui.tableModules->setRowCount(0);
	if (edb::v1::debugger_core) {
		if (IProcess *process = edb::v1::debugger_core->process()) {
			const QList<Module> modules = process->loadedModules();
			ui.tableModules->setSortingEnabled(false);
			for (const Module &m : modules) {
				const int row = ui.tableModules->rowCount();
				ui.tableModules->insertRow(row);
				ui.tableModules->setItem(row, 0, new QTableWidgetItem(edb::v1::format_pointer(m.baseAddress)));
				ui.tableModules->setItem(row, 1, new QTableWidgetItem(m.name));
			}
			ui.tableModules->setSortingEnabled(true);
		}
	}
}

/**
 * @brief DialogProcessProperties::updateMemoryPage
 */
void DialogProcessProperties::updateMemoryPage() {

	ui.tableMemory->clearContents();
	ui.tableMemory->setRowCount(0);

	if (edb::v1::debugger_core) {
		edb::v1::memory_regions().sync();
		const QList<std::shared_ptr<IRegion>> regions = edb::v1::memory_regions().regions();
		ui.tableMemory->setSortingEnabled(false);

		for (const std::shared_ptr<IRegion> &r : regions) {
			const int row = ui.tableMemory->rowCount();
			ui.tableMemory->insertRow(row);
			ui.tableMemory->setItem(row, 0, new QTableWidgetItem(edb::v1::format_pointer(r->start()))); // address
			ui.tableMemory->setItem(row, 1, new QTableWidgetItem(size_to_string(r->size())));           // size
			ui.tableMemory->setItem(row, 2, new QTableWidgetItem(QString("%1%2%3")                      // protection
																	 .arg(r->readable() ? 'r' : '-')
																	 .arg(r->writable() ? 'w' : '-')
																	 .arg(r->executable() ? 'x' : '-')));
			ui.tableMemory->setItem(row, 3, new QTableWidgetItem(r->name())); // name
		}
		ui.tableMemory->setSortingEnabled(true);
	}
}

/**
 * @brief DialogProcessProperties::on_txtSearchEnvironment_textChanged
 * @param text
 */
void DialogProcessProperties::on_txtSearchEnvironment_textChanged(const QString &text) {
	updateEnvironmentPage(text);
}

/**
 * @brief DialogProcessProperties::updateEnvironmentPage
 * @param filter
 */
void DialogProcessProperties::updateEnvironmentPage(const QString &filter) {
	// tableEnvironment

	ui.tableEnvironment->clearContents();
	ui.tableEnvironment->setSortingEnabled(false);
	ui.tableEnvironment->setRowCount(0);

	const QString lower_filter = filter.toLower();

#ifdef Q_OS_LINUX
	if (IProcess *process = edb::v1::debugger_core->process()) {
		QFile proc_environ(QString("/proc/%1/environ").arg(process->pid()));
		if (proc_environ.open(QIODevice::ReadOnly)) {
			QByteArray env = proc_environ.readAll();
			char *p        = env.data();
			char *ptr      = p;
			while (ptr != p + env.size()) {
				const QString env       = QString::fromUtf8(ptr);
				const QString env_name  = env.mid(0, env.indexOf("="));
				const QString env_value = env.mid(env.indexOf("=") + 1);

				if (lower_filter.isEmpty() || env_name.contains(lower_filter, Qt::CaseInsensitive)) {
					const int row = ui.tableEnvironment->rowCount();
					ui.tableEnvironment->insertRow(row);
					ui.tableEnvironment->setItem(row, 0, new QTableWidgetItem(env_name));
					ui.tableEnvironment->setItem(row, 1, new QTableWidgetItem(env_value));
				}

				ptr += qstrlen(ptr) + 1;
			}
		}
	}
#endif

	ui.tableEnvironment->setSortingEnabled(true);
}

/**
 * @brief DialogProcessProperties::updateHandles
 */
void DialogProcessProperties::updateHandles() {

	ui.tableHandles->setSortingEnabled(false);
	ui.tableHandles->setRowCount(0);

#ifdef Q_OS_LINUX
	if (IProcess *process = edb::v1::debugger_core->process()) {
		QDir dir(QString("/proc/%1/fd/").arg(process->pid()));
		const QFileInfoList entries = dir.entryInfoList(QStringList() << "[0-9]*");
		for (const QFileInfo &info : entries) {
			if (info.isSymLink()) {
				QString symlink(info.symLinkTarget());
				const QString type(file_type(symlink));

				if (type == tr("Socket")) {
					symlink = process_socket_tcp(&symlink);
					symlink = process_socket_udp(&symlink);
					symlink = process_socket_unix(&symlink);
				}

				if (type == tr("Pipe")) {
					symlink = tr("FIFO");
				}

				const int row = ui.tableHandles->rowCount();
				ui.tableHandles->insertRow(row);

				auto itemFD = new QTableWidgetItem;
				itemFD->setData(Qt::DisplayRole, info.fileName().toUInt());

				ui.tableHandles->setItem(row, 0, new QTableWidgetItem(type));
				ui.tableHandles->setItem(row, 1, itemFD);
				ui.tableHandles->setItem(row, 2, new QTableWidgetItem(symlink));
			}
		}
	}
#endif

	ui.tableHandles->setSortingEnabled(true);
}

/**
 * @brief DialogProcessProperties::showEvent
 */
void DialogProcessProperties::showEvent(QShowEvent *) {
	updateGeneralPage();
	updateMemoryPage();
	updateModulePage();
	updateHandles();
	updateThreads();
	updateEnvironmentPage(ui.txtSearchEnvironment->text());
}

/**
 * @brief DialogProcessProperties::on_btnParent_clicked
 */
void DialogProcessProperties::on_btnParent_clicked() {

	if (edb::v1::debugger_core) {
		if (IProcess *process = edb::v1::debugger_core->process()) {

			std::shared_ptr<IProcess> parent = process->parent();
			const QString parent_exe         = parent ? parent->executable() : QString();

			QFileInfo info(parent_exe);
			QDir dir = info.absoluteDir();
			QDesktopServices::openUrl(QUrl(tr("file://%1").arg(dir.absolutePath()), QUrl::TolerantMode));
		}
	}
}

/**
 * @brief DialogProcessProperties::on_btnImage_clicked
 */
void DialogProcessProperties::on_btnImage_clicked() {
	if (edb::v1::debugger_core) {
		QFileInfo info(ui.editImage->text());
		QDir dir = info.absoluteDir();
		QDesktopServices::openUrl(QUrl(tr("file://%1").arg(dir.absolutePath()), QUrl::TolerantMode));
	}
}

/**
 * @brief DialogProcessProperties::on_btnRefreshEnvironment_clicked
 */
void DialogProcessProperties::on_btnRefreshEnvironment_clicked() {
	updateEnvironmentPage(ui.txtSearchEnvironment->text());
}

/**
 * @brief DialogProcessProperties::on_btnRefreshHandles_clicked
 */
void DialogProcessProperties::on_btnRefreshHandles_clicked() {
	updateHandles();
}

/**
 * @brief DialogProcessProperties::on_btnStrings_clicked
 */
void DialogProcessProperties::on_btnStrings_clicked() {

	static auto dialog = new DialogStrings(edb::v1::debugger_ui);
	dialog->show();
}

/**
 * @brief DialogProcessProperties::on_btnRefreshMemory_clicked
 */
void DialogProcessProperties::on_btnRefreshMemory_clicked() {
	updateMemoryPage();
}

/**
 * @brief DialogProcessProperties::on_btnRefreshThreads_clicked
 */
void DialogProcessProperties::on_btnRefreshThreads_clicked() {
	updateThreads();
}

/**
 * @brief DialogProcessProperties::updateThreads
 */
void DialogProcessProperties::updateThreads() {
	threadsModel_->clear();

	if (IProcess *process = edb::v1::debugger_core->process()) {

		std::shared_ptr<IThread> current = process->currentThread();
		for (std::shared_ptr<IThread> &thread : process->threads()) {

			if (thread == current) {
				threadsModel_->addThread(thread, true);
			} else {
				threadsModel_->addThread(thread, false);
			}
		}
	}
}

}

```

`plugins/ProcessProperties/DialogProcessProperties.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_PROCESS_PROPERTIES_H_20120817_
#define DIALOG_PROCESS_PROPERTIES_H_20120817_

#include "ThreadsModel.h"
#include "ui_DialogProcessProperties.h"
#include <QDialog>
#include <QSortFilterProxyModel>

namespace ProcessPropertiesPlugin {

class DialogProcessProperties : public QDialog {
	Q_OBJECT

public:
	explicit DialogProcessProperties(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogProcessProperties() override = default;

public Q_SLOTS:
	void on_btnParent_clicked();
	void on_btnImage_clicked();
	void on_btnRefreshEnvironment_clicked();
	void on_btnRefreshHandles_clicked();
	void on_btnStrings_clicked();
	void on_btnRefreshThreads_clicked();
	void on_btnRefreshMemory_clicked();
	void on_txtSearchEnvironment_textChanged(const QString &text);

private:
	void updateGeneralPage();
	void updateMemoryPage();
	void updateModulePage();
	void updateHandles();
	void updateThreads();
	void updateEnvironmentPage(const QString &filter);

private:
	void showEvent(QShowEvent *event) override;

private:
	Ui::DialogProcessProperties ui;
	ThreadsModel *threadsModel_           = nullptr;
	QSortFilterProxyModel *threadsFilter_ = nullptr;
};

}

#endif

```

`plugins/ProcessProperties/DialogProcessProperties.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>ProcessPropertiesPlugin::DialogProcessProperties</class>
 <widget class="QDialog" name="ProcessPropertiesPlugin::DialogProcessProperties">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>714</width>
    <height>599</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Process Properties</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QTabWidget" name="tabWidget">
     <property name="currentIndex">
      <number>0</number>
     </property>
     <widget class="QWidget" name="tab">
      <attribute name="title">
       <string>General</string>
      </attribute>
      <layout class="QVBoxLayout" name="verticalLayout_2">
       <item>
        <widget class="QGroupBox" name="groupBox">
         <property name="title">
          <string>File</string>
         </property>
         <layout class="QGridLayout" name="gridLayout_2">
          <item row="0" column="0">
           <widget class="QLabel" name="label_6">
            <property name="text">
             <string>Image File Name:</string>
            </property>
           </widget>
          </item>
          <item row="1" column="0">
           <widget class="QLineEdit" name="editImage">
            <property name="text">
             <string/>
            </property>
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="1" column="1">
           <widget class="QToolButton" name="btnImage">
            <property name="text">
             <string>...</string>
            </property>
            <property name="icon">
             <iconset theme="document-open">
              <normaloff>.</normaloff>.</iconset>
            </property>
            <property name="arrowType">
             <enum>Qt::NoArrow</enum>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
       <item>
        <widget class="QGroupBox" name="groupBox_2">
         <property name="title">
          <string>Process</string>
         </property>
         <layout class="QGridLayout" name="gridLayout">
          <item row="0" column="0">
           <widget class="QLabel" name="label">
            <property name="text">
             <string>Command Line:</string>
            </property>
           </widget>
          </item>
          <item row="0" column="1" colspan="2">
           <widget class="QLineEdit" name="editCommand">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="1" column="0">
           <widget class="QLabel" name="label_2">
            <property name="text">
             <string>Current Directory:</string>
            </property>
           </widget>
          </item>
          <item row="1" column="1" colspan="2">
           <widget class="QLineEdit" name="editCurrentDirectory">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="2" column="0">
           <widget class="QLabel" name="label_3">
            <property name="text">
             <string>Started:</string>
            </property>
           </widget>
          </item>
          <item row="2" column="1" colspan="2">
           <widget class="QLineEdit" name="editStarted">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="3" column="0">
           <widget class="QLabel" name="label_5">
            <property name="text">
             <string>Parent:</string>
            </property>
           </widget>
          </item>
          <item row="3" column="1">
           <widget class="QLineEdit" name="editParent">
            <property name="readOnly">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="4" column="1">
           <spacer name="verticalSpacer">
            <property name="orientation">
             <enum>Qt::Vertical</enum>
            </property>
            <property name="sizeHint" stdset="0">
             <size>
              <width>20</width>
              <height>236</height>
             </size>
            </property>
           </spacer>
          </item>
          <item row="3" column="2">
           <widget class="QToolButton" name="btnParent">
            <property name="text">
             <string>...</string>
            </property>
            <property name="icon">
             <iconset theme="document-open">
              <normaloff>.</normaloff>.</iconset>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_4">
      <attribute name="title">
       <string>Threads</string>
      </attribute>
      <layout class="QGridLayout" name="gridLayout_5">
       <item row="0" column="0">
        <spacer name="horizontalSpacer_5">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>604</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
       <item row="0" column="1">
        <widget class="QPushButton" name="btnRefreshThreads">
         <property name="text">
          <string>Refresh</string>
         </property>
         <property name="icon">
          <iconset theme="view-refresh">
           <normaloff>.</normaloff>.</iconset>
         </property>
        </widget>
       </item>
       <item row="1" column="0" colspan="2">
        <widget class="QTableView" name="threadTable">
         <property name="font">
          <font>
           <family>Monospace</family>
           <pointsize>8</pointsize>
          </font>
         </property>
         <property name="editTriggers">
          <set>QAbstractItemView::NoEditTriggers</set>
         </property>
         <property name="alternatingRowColors">
          <bool>true</bool>
         </property>
         <property name="selectionMode">
          <enum>QAbstractItemView::SingleSelection</enum>
         </property>
         <property name="selectionBehavior">
          <enum>QAbstractItemView::SelectRows</enum>
         </property>
         <property name="sortingEnabled">
          <bool>true</bool>
         </property>
         <property name="wordWrap">
          <bool>false</bool>
         </property>
         <attribute name="horizontalHeaderStretchLastSection">
          <bool>true</bool>
         </attribute>
         <attribute name="verticalHeaderVisible">
          <bool>false</bool>
         </attribute>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_6">
      <attribute name="title">
       <string>Modules</string>
      </attribute>
      <layout class="QGridLayout" name="gridLayout_3">
       <item row="0" column="0">
        <spacer name="horizontalSpacer_2">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>610</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
       <item row="0" column="1">
        <widget class="QPushButton" name="btnRefreshModules">
         <property name="text">
          <string>Refresh</string>
         </property>
         <property name="icon">
          <iconset theme="view-refresh">
           <normaloff>.</normaloff>.</iconset>
         </property>
        </widget>
       </item>
       <item row="1" column="0" colspan="2">
        <widget class="QTableWidget" name="tableModules">
         <property name="font">
          <font>
           <family>Monospace</family>
           <pointsize>8</pointsize>
          </font>
         </property>
         <property name="editTriggers">
          <set>QAbstractItemView::NoEditTriggers</set>
         </property>
         <property name="alternatingRowColors">
          <bool>true</bool>
         </property>
         <property name="selectionMode">
          <enum>QAbstractItemView::SingleSelection</enum>
         </property>
         <property name="selectionBehavior">
          <enum>QAbstractItemView::SelectRows</enum>
         </property>
         <property name="sortingEnabled">
          <bool>true</bool>
         </property>
         <property name="wordWrap">
          <bool>false</bool>
         </property>
         <attribute name="horizontalHeaderStretchLastSection">
          <bool>true</bool>
         </attribute>
         <attribute name="verticalHeaderVisible">
          <bool>false</bool>
         </attribute>
         <column>
          <property name="text">
           <string>Base Address</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Name</string>
          </property>
         </column>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_7">
      <attribute name="title">
       <string>Memory</string>
      </attribute>
      <layout class="QGridLayout" name="gridLayout_4">
       <item row="0" column="0">
        <widget class="QPushButton" name="btnStrings">
         <property name="text">
          <string>Strings</string>
         </property>
        </widget>
       </item>
       <item row="0" column="1">
        <spacer name="horizontalSpacer">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>467</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
       <item row="0" column="2">
        <widget class="QPushButton" name="btnRefreshMemory">
         <property name="text">
          <string>Refresh</string>
         </property>
         <property name="icon">
          <iconset theme="view-refresh">
           <normaloff>.</normaloff>.</iconset>
         </property>
        </widget>
       </item>
       <item row="1" column="0" colspan="3">
        <widget class="QTableWidget" name="tableMemory">
         <property name="font">
          <font>
           <family>Monospace</family>
           <pointsize>8</pointsize>
          </font>
         </property>
         <property name="editTriggers">
          <set>QAbstractItemView::NoEditTriggers</set>
         </property>
         <property name="alternatingRowColors">
          <bool>true</bool>
         </property>
         <property name="selectionMode">
          <enum>QAbstractItemView::SingleSelection</enum>
         </property>
         <property name="selectionBehavior">
          <enum>QAbstractItemView::SelectRows</enum>
         </property>
         <property name="sortingEnabled">
          <bool>true</bool>
         </property>
         <property name="wordWrap">
          <bool>false</bool>
         </property>
         <attribute name="horizontalHeaderStretchLastSection">
          <bool>true</bool>
         </attribute>
         <attribute name="verticalHeaderVisible">
          <bool>false</bool>
         </attribute>
         <column>
          <property name="text">
           <string>Address</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Size</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Protection</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Name</string>
          </property>
         </column>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_8">
      <attribute name="title">
       <string>Environment</string>
      </attribute>
      <layout class="QVBoxLayout" name="verticalLayout_4">
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <item>
          <widget class="QLineEdit" name="txtSearchEnvironment">
           <property name="placeholderText">
            <string>Filter</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="btnRefreshEnvironment">
           <property name="text">
            <string>Refresh</string>
           </property>
           <property name="icon">
            <iconset theme="view-refresh">
             <normaloff>.</normaloff>.</iconset>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QTableWidget" name="tableEnvironment">
         <property name="font">
          <font>
           <family>Monospace</family>
           <pointsize>8</pointsize>
          </font>
         </property>
         <property name="editTriggers">
          <set>QAbstractItemView::NoEditTriggers</set>
         </property>
         <property name="alternatingRowColors">
          <bool>true</bool>
         </property>
         <property name="selectionMode">
          <enum>QAbstractItemView::SingleSelection</enum>
         </property>
         <property name="selectionBehavior">
          <enum>QAbstractItemView::SelectRows</enum>
         </property>
         <property name="sortingEnabled">
          <bool>true</bool>
         </property>
         <property name="wordWrap">
          <bool>false</bool>
         </property>
         <attribute name="horizontalHeaderStretchLastSection">
          <bool>true</bool>
         </attribute>
         <attribute name="verticalHeaderVisible">
          <bool>false</bool>
         </attribute>
         <column>
          <property name="text">
           <string>Name</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Value</string>
          </property>
         </column>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_9">
      <attribute name="title">
       <string>Handles</string>
      </attribute>
      <layout class="QVBoxLayout" name="verticalLayout_3">
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_3">
         <item>
          <spacer name="horizontalSpacer_4">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>40</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
         <item>
          <widget class="QPushButton" name="btnRefreshHandles">
           <property name="text">
            <string>Refresh</string>
           </property>
           <property name="icon">
            <iconset theme="view-refresh">
             <normaloff>.</normaloff>.</iconset>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QTableWidget" name="tableHandles">
         <property name="font">
          <font>
           <family>Monospace</family>
           <pointsize>8</pointsize>
          </font>
         </property>
         <property name="editTriggers">
          <set>QAbstractItemView::NoEditTriggers</set>
         </property>
         <property name="alternatingRowColors">
          <bool>true</bool>
         </property>
         <property name="selectionMode">
          <enum>QAbstractItemView::SingleSelection</enum>
         </property>
         <property name="selectionBehavior">
          <enum>QAbstractItemView::SelectRows</enum>
         </property>
         <property name="sortingEnabled">
          <bool>true</bool>
         </property>
         <property name="wordWrap">
          <bool>false</bool>
         </property>
         <attribute name="horizontalHeaderStretchLastSection">
          <bool>true</bool>
         </attribute>
         <attribute name="verticalHeaderVisible">
          <bool>false</bool>
         </attribute>
         <column>
          <property name="text">
           <string>Type</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Handle</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Name</string>
          </property>
         </column>
        </widget>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>ProcessPropertiesPlugin::DialogProcessProperties</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>650</x>
     <y>574</y>
    </hint>
    <hint type="destinationlabel">
     <x>439</x>
     <y>557</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>ProcessPropertiesPlugin::DialogProcessProperties</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>30</x>
     <y>571</y>
    </hint>
    <hint type="destinationlabel">
     <x>3</x>
     <y>554</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/ProcessProperties/DialogResults.cpp`:

```cpp

#include "DialogResults.h"
#include "edb.h"
#include <QSortFilterProxyModel>

namespace ProcessPropertiesPlugin {

/**
 * @brief DialogResults::DialogResults
 * @param parent
 * @param f
 */
DialogResults::DialogResults(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {
	ui.setupUi(this);
	ui.tableView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

	model_       = new ResultsModel(this);
	filterModel_ = new QSortFilterProxyModel(this);

	filterModel_->setFilterKeyColumn(2);
	filterModel_->setSourceModel(model_);
	ui.tableView->setModel(filterModel_);

	connect(ui.textFilter, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);
}

/**
 * @brief DialogResults::addResult
 * @param result
 */
void DialogResults::addResult(const ResultsModel::Result &result) {
	model_->addResult(result);
}

/**
 * @brief DialogResults::on_tableView_doubleClicked
 * @param index
 */
void DialogResults::on_tableView_doubleClicked(const QModelIndex &index) {
	if (index.isValid()) {
		const QModelIndex realIndex = filterModel_->mapToSource(index);
		if (realIndex.isValid()) {
			if (auto item = static_cast<ResultsModel::Result *>(realIndex.internalPointer())) {
				edb::v1::dump_data(item->address, false);
			}
		}
	}
}

/**
 * @brief DialogResults::resultCount
 * @return
 */
int DialogResults::resultCount() const {
	return model_->rowCount();
}

}

```

`plugins/ProcessProperties/DialogResults.h`:

```h

#ifndef PROCESS_PROPERTIES_DIALOG_RESULTS_H_20191119_
#define PROCESS_PROPERTIES_DIALOG_RESULTS_H_20191119_

#include "ResultsModel.h"
#include "ui_DialogResults.h"
#include <QDialog>
#include <QSortFilterProxyModel>

class QSortFilterProxyModel;

namespace ProcessPropertiesPlugin {

class DialogResults : public QDialog {
	Q_OBJECT

public:
	explicit DialogResults(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());

public:
	void addResult(const ResultsModel::Result &result);

private Q_SLOTS:
	void on_tableView_doubleClicked(const QModelIndex &index);

public:
	int resultCount() const;

private:
	Ui::DialogResults ui;
	ResultsModel *model_                = nullptr;
	QSortFilterProxyModel *filterModel_ = nullptr;
};

}

#endif

```

`plugins/ProcessProperties/DialogResults.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>ProcessPropertiesPlugin::DialogResults</class>
 <widget class="QDialog" name="ProcessPropertiesPlugin::DialogResults">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>690</width>
    <height>315</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Strings</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="1" column="0">
    <widget class="QTableView" name="tableView">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="contextMenuPolicy">
      <enum>Qt::CustomContextMenu</enum>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
    </widget>
   </item>
   <item row="0" column="0" colspan="2">
    <widget class="QLineEdit" name="textFilter">
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item row="2" column="0" colspan="2">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>ProcessPropertiesPlugin::DialogResults</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>224</x>
     <y>326</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>ProcessPropertiesPlugin::DialogResults</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>292</x>
     <y>332</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/ProcessProperties/DialogStrings.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogStrings.h"
#include "Configuration.h"
#include "DialogResults.h"
#include "IRegion.h"
#include "MemoryRegions.h"
#include "ResultsModel.h"
#include "edb.h"
#include "util/Math.h"

#include <QHeaderView>
#include <QMessageBox>
#include <QPushButton>
#include <QSortFilterProxyModel>

namespace ProcessPropertiesPlugin {

/**
 * @brief DialogStrings::DialogStrings
 * @param parent
 * @param f
 */
DialogStrings::DialogStrings(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
	ui.tableView->verticalHeader()->hide();
	ui.tableView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

	filterModel_ = new QSortFilterProxyModel(this);
	connect(ui.txtSearch, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);

	buttonFind_ = new QPushButton(QIcon::fromTheme("edit-find"), tr("Find"));
	connect(buttonFind_, &QPushButton::clicked, this, [this]() {
		buttonFind_->setEnabled(false);
		ui.progressBar->setValue(0);
		doFind();
		ui.progressBar->setValue(100);
		buttonFind_->setEnabled(true);
	});

	ui.buttonBox->addButton(buttonFind_, QDialogButtonBox::ActionRole);
}

/**
 * @brief DialogStrings::showEvent
 */
void DialogStrings::showEvent(QShowEvent *) {
	filterModel_->setFilterKeyColumn(3);
	filterModel_->setSourceModel(&edb::v1::memory_regions());
	ui.tableView->setModel(filterModel_);
	ui.progressBar->setValue(0);
}

/**
 * @brief DialogStrings::doFind
 */
void DialogStrings::doFind() {

	const int min_string_length = edb::v1::config().min_string_length;

	const QItemSelectionModel *const selection_model = ui.tableView->selectionModel();
	const QModelIndexList sel                        = selection_model->selectedRows();

	QString str;

	if (sel.size() == 0) {
		QMessageBox::critical(
			this,
			tr("No Region Selected"),
			tr("You must select a region which is to be scanned for strings."));
		return;
	}

	auto resultsDialog = new DialogResults(this);

	for (const QModelIndex &selected_item : sel) {

		const QModelIndex index = filterModel_->mapToSource(selected_item);

		if (auto region = *reinterpret_cast<const std::shared_ptr<IRegion> *>(index.internalPointer())) {

			edb::address_t start_address     = region->start();
			const edb::address_t end_address = region->end();
			const edb::address_t orig_start  = start_address;

			// do the search for this region!
			while (start_address < end_address) {

				int string_length = 0;
				bool ok           = edb::v1::get_ascii_string_at_address(start_address, str, min_string_length, 256, string_length);
				if (ok) {
					resultsDialog->addResult({start_address, str, ResultsModel::Result::Ascii});
				} else if (ui.search_unicode->isChecked()) {
					string_length = 0;
					ok            = edb::v1::get_utf16_string_at_address(start_address, str, min_string_length, 256, string_length);
					if (ok) {
						resultsDialog->addResult({start_address, str, ResultsModel::Result::Utf16});
					}
				}

				ui.progressBar->setValue(util::percentage((start_address - orig_start), region->size()));

				if (ok) {
					start_address += string_length;
				} else {
					++start_address;
				}
			}
		}
	}

	if (resultsDialog->resultCount() == 0) {
		QMessageBox::information(this, tr("No Strings Found"), tr("No strings were found in the selected region"));
		delete resultsDialog;
	} else {
		resultsDialog->show();
	}
}

}

```

`plugins/ProcessProperties/DialogStrings.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_STRINGS_H_20061101_
#define DIALOG_STRINGS_H_20061101_

#include "Types.h"
#include "ui_DialogStrings.h"
#include <QDialog>

class QSortFilterProxyModel;
class QListWidgetItem;

namespace ProcessPropertiesPlugin {

class DialogStrings : public QDialog {
	Q_OBJECT

public:
	explicit DialogStrings(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogStrings() override = default;

private:
	void showEvent(QShowEvent *event) override;

private:
	void doFind();

private:
	Ui::DialogStrings ui;
	QSortFilterProxyModel *filterModel_ = nullptr;
	QPushButton *buttonFind_            = nullptr;
};

}

#endif

```

`plugins/ProcessProperties/DialogStrings.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>ProcessPropertiesPlugin::DialogStrings</class>
 <widget class="QDialog" name="ProcessPropertiesPlugin::DialogStrings">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>702</width>
    <height>384</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>String Search</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="lblRegions">
     <property name="text">
      <string>Regions To Search:</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLineEdit" name="txtSearch">
     <property name="text">
      <string/>
     </property>
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QTableView" name="tableView">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
    </widget>
   </item>
   <item>
    <widget class="QCheckBox" name="search_unicode">
     <property name="text">
      <string>Include UTF-16 Results</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBar">
     <property name="value">
      <number>0</number>
     </property>
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>ProcessPropertiesPlugin::DialogStrings</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>644</x>
     <y>326</y>
    </hint>
    <hint type="destinationlabel">
     <x>671</x>
     <y>282</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>ProcessPropertiesPlugin::DialogStrings</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>532</x>
     <y>331</y>
    </hint>
    <hint type="destinationlabel">
     <x>516</x>
     <y>283</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/ProcessProperties/ProcessProperties.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ProcessProperties.h"
#include "DialogProcessProperties.h"
#include "edb.h"

#include <QMenu>

namespace ProcessPropertiesPlugin {

/**
 * @brief ProcessProperties::ProcessProperties
 * @param parent
 */
ProcessProperties::ProcessProperties(QObject *parent)
	: QObject(parent) {

	dialog_ = new DialogProcessProperties(edb::v1::debugger_ui);
}

/**
 * @brief ProcessProperties::~ProcessProperties
 */
ProcessProperties::~ProcessProperties() {
#if 0
	delete dialog_;
#endif
}

/**
 * @brief ProcessProperties::menu
 * @param parent
 * @return
 */
QMenu *ProcessProperties::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("Process Properties"), parent);
		menu_->addAction(tr("&Process Properties"), this, SLOT(showMenu()), QKeySequence(tr("Ctrl+P")));
		menu_->addAction(tr("Process &Strings"), dialog_, SLOT(on_btnStrings_clicked()), QKeySequence(tr("Ctrl+S")));
	}

	return menu_;
}

/**
 * @brief ProcessProperties::showMenu
 */
void ProcessProperties::showMenu() {
	dialog_->show();
}

}

```

`plugins/ProcessProperties/ProcessProperties.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef PROCESS_PROPERTIES_H_20100817_
#define PROCESS_PROPERTIES_H_20100817_

#include "IPlugin.h"

class QMenu;
class QDialog;

namespace ProcessPropertiesPlugin {

class ProcessProperties : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit ProcessProperties(QObject *parent = nullptr);
	~ProcessProperties() override;

public:
	QMenu *menu(QWidget *parent = nullptr) override;

public Q_SLOTS:
	void showMenu();

private:
	QMenu *menu_              = nullptr;
	QPointer<QDialog> dialog_ = nullptr;
};

}

#endif

```

`plugins/ProcessProperties/ResultsModel.cpp`:

```cpp
/*
Copyright (C) 2006 - 2019 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ResultsModel.h"
#include "edb.h"
#include <algorithm>

namespace ProcessPropertiesPlugin {

/**
 * @brief ResultsModel::ResultsModel
 * @param parent
 */
ResultsModel::ResultsModel(QObject *parent)
	: QAbstractItemModel(parent) {
}

/**
 * @brief ResultsModel::headerData
 * @param section
 * @param orientation
 * @param role
 * @return
 */
QVariant ResultsModel::headerData(int section, Qt::Orientation orientation, int role) const {

	if (role == Qt::DisplayRole && orientation == Qt::Horizontal) {
		switch (section) {
		case 0:
			return tr("Address");
		case 1:
			return tr("Type");
		case 2:
			return tr("String");
		}
	}

	return QVariant();
}

/**
 * @brief ResultsModel::data
 * @param index
 * @param role
 * @return
 */
QVariant ResultsModel::data(const QModelIndex &index, int role) const {

	if (!index.isValid()) {
		return QVariant();
	}

	const Result &result = results_[index.row()];

	if (role == Qt::DisplayRole) {
		switch (index.column()) {
		case 0:
			return edb::v1::format_pointer(result.address);
		case 1:
			switch (result.type) {
			case Result::Ascii:
				return tr("ASCII");
			case Result::Utf8:
				return tr("UTF8");
			case Result::Utf16:
				return tr("UTF16");
			case Result::Utf32:
				return tr("UTF32");
			}
			break;
		case 2:
			return result.string;
		default:
			return QVariant();
		}
	}

	return QVariant();
}

/**
 * @brief ResultsModel::addResult
 * @param r
 */
void ResultsModel::addResult(const Result &r) {
	beginInsertRows(QModelIndex(), rowCount(), rowCount());
	results_.push_back(r);
	endInsertRows();
}

/**
 * @brief ResultsModel::index
 * @param row
 * @param column
 * @param parent
 * @return
 */
QModelIndex ResultsModel::index(int row, int column, const QModelIndex &parent) const {

	Q_UNUSED(parent)

	if (row >= results_.size()) {
		return QModelIndex();
	}

	if (column >= 3) {
		return QModelIndex();
	}

	if (row >= 0) {
		return createIndex(row, column, const_cast<Result *>(&results_[row]));
	} else {
		return createIndex(row, column);
	}
}

/**
 * @brief ResultsModel::parent
 * @param index
 * @return
 */
QModelIndex ResultsModel::parent(const QModelIndex &index) const {
	Q_UNUSED(index)
	return QModelIndex();
}

/**
 * @brief ResultsModel::rowCount
 * @param parent
 * @return
 */
int ResultsModel::rowCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return results_.size();
}

/**
 * @brief ResultsModel::columnCount
 * @param parent
 * @return
 */
int ResultsModel::columnCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return 3;
}

/**
 * @brief ResultsModel::sort
 * @param column
 * @param order
 */
void ResultsModel::sort(int column, Qt::SortOrder order) {

	if (order == Qt::AscendingOrder) {
		switch (column) {
		case 0:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.address < s2.address; });
			break;
		case 1:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.type < s2.type; });
			break;
		case 2:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.string < s2.string; });
			break;
		}
	} else {
		switch (column) {
		case 0:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.address > s2.address; });
			break;
		case 1:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.type > s2.type; });
			break;
		case 2:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.string < s2.string; });
			break;
		}
	}

	Q_EMIT dataChanged(createIndex(0, 0, nullptr), createIndex(-1, -1, nullptr));
}

}

```

`plugins/ProcessProperties/ResultsModel.h`:

```h
/*
Copyright (C) 2006 - 2019 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PROCESS_PROPERTIES_RESULTS_MODEL_H_20191119_
#define PROCESS_PROPERTIES_RESULTS_MODEL_H_20191119_

#include "Function.h"
#include "Types.h"
#include <QAbstractItemModel>
#include <QVector>

namespace ProcessPropertiesPlugin {

class ResultsModel : public QAbstractItemModel {
	Q_OBJECT

public:
	struct Result {
		edb::address_t address = 0;
		QString string;
		enum {
			Ascii,
			Utf8,
			Utf16,
			Utf32,
		} type;
	};

public:
	explicit ResultsModel(QObject *parent = nullptr);

public:
	QVariant data(const QModelIndex &index, int role) const override;
	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex &index) const override;
	int rowCount(const QModelIndex &parent = QModelIndex()) const override;
	int columnCount(const QModelIndex &parent = QModelIndex()) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
	void sort(int column, Qt::SortOrder order = Qt::AscendingOrder) override;

public:
	void addResult(const Result &r);

public:
	const QVector<Result> &results() const { return results_; }

private:
	QVector<Result> results_;
};

}

#endif

```

`plugins/ROPTool/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "ROPTool")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
    DialogROPTool.cpp
    DialogROPTool.h
    DialogROPTool.ui
    ROPTool.cpp
    ROPTool.h
    DialogResults.ui
    DialogResults.cpp
    DialogResults.h
    ResultsModel.cpp
    ResultsModel.h
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/ROPTool/DialogROPTool.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogROPTool.h"
#include "ByteShiftArray.h"
#include "DialogResults.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IRegion.h"
#include "MemoryRegions.h"
#include "edb.h"
#include "util/Math.h"

#include <QDebug>
#include <QHeaderView>
#include <QMessageBox>
#include <QModelIndex>
#include <QPushButton>
#include <QSortFilterProxyModel>
#include <QStandardItemModel>

namespace ROPToolPlugin {

namespace {

/**
 * @brief get_gadget_role
 * @param inst
 * @return
 */
uint32_t get_gadget_role(const edb::Instruction &inst) {
	switch (inst.operation()) {
	case X86_INS_ADD:
	case X86_INS_ADC:
	case X86_INS_SUB:
	case X86_INS_SBB:
	case X86_INS_IMUL:
	case X86_INS_MUL:
	case X86_INS_IDIV:
	case X86_INS_DIV:
	case X86_INS_INC:
	case X86_INS_DEC:
	case X86_INS_NEG:
	case X86_INS_CMP:
	case X86_INS_DAA:
	case X86_INS_DAS:
	case X86_INS_AAA:
	case X86_INS_AAS:
	case X86_INS_AAM:
	case X86_INS_AAD:
		// ALU ops
		return 0x01;
	case X86_INS_PUSH:
	case X86_INS_PUSHAW:
	case X86_INS_PUSHAL:
	case X86_INS_POP:
	case X86_INS_POPAW:
	case X86_INS_POPAL:
		// stack ops
		return 0x02;
	case X86_INS_AND:
	case X86_INS_OR:
	case X86_INS_XOR:
	case X86_INS_NOT:
	case X86_INS_SAR:
	case X86_INS_SAL:
	case X86_INS_SHR:
	case X86_INS_SHL:
	case X86_INS_SHRD:
	case X86_INS_SHLD:
	case X86_INS_ROR:
	case X86_INS_ROL:
	case X86_INS_RCR:
	case X86_INS_RCL:
	case X86_INS_BT:
	case X86_INS_BTS:
	case X86_INS_BTR:
	case X86_INS_BTC:
	case X86_INS_BSF:
	case X86_INS_BSR:
		// logic ops
		return 0x04;
	case X86_INS_MOV:
	case X86_INS_MOVABS:
	case X86_INS_CMOVA:
	case X86_INS_CMOVAE:
	case X86_INS_CMOVB:
	case X86_INS_CMOVBE:
	case X86_INS_CMOVE:
	case X86_INS_CMOVG:
	case X86_INS_CMOVGE:
	case X86_INS_CMOVL:
	case X86_INS_CMOVLE:
	case X86_INS_CMOVNE:
	case X86_INS_CMOVNO:
	case X86_INS_CMOVNP:
	case X86_INS_CMOVNS:
	case X86_INS_CMOVO:
	case X86_INS_CMOVP:
	case X86_INS_CMOVS:
	case X86_INS_XCHG:
	case X86_INS_BSWAP:
	case X86_INS_XADD:
	case X86_INS_CMPXCHG:
	case X86_INS_CWD:
	case X86_INS_CDQ:
	case X86_INS_CQO:
	case X86_INS_CDQE:
	case X86_INS_CBW:
	case X86_INS_CWDE:
	case X86_INS_MOVSX:
	case X86_INS_MOVZX:
	case X86_INS_MOVSXD:
	case X86_INS_MOVBE:
	case X86_INS_MOVSB:
	case X86_INS_MOVSW:
	case X86_INS_MOVSD:
	case X86_INS_MOVSQ:
	case X86_INS_CMPSB:
	case X86_INS_CMPSW:
	case X86_INS_CMPSD:
	case X86_INS_CMPSQ:
	case X86_INS_SCASB:
	case X86_INS_SCASW:
	case X86_INS_SCASD:
	case X86_INS_SCASQ:
	case X86_INS_LODSB:
	case X86_INS_LODSW:
	case X86_INS_LODSD:
	case X86_INS_LODSQ:
	case X86_INS_STOSB:
	case X86_INS_STOSW:
	case X86_INS_STOSD:
	case X86_INS_STOSQ:
	case X86_INS_CMPXCHG8B:
	case X86_INS_CMPXCHG16B:
		// data ops
		return 0x08;
	default:
		// other ops
		return 0x10;
	}
}

// See issue #457, thanks mrexodia!
/**
 * @brief is_safe_64_nop_reg_op
 * @param op
 * @return
 */
bool is_safe_64_nop_reg_op(const edb::Operand &op) {

	if (op->type != X86_OP_REG) {
		return true; // a non-register is safe
	}

	if (edb::v1::debuggeeIs64Bit()) {
		switch (op->reg) {
		case X86_REG_EAX:
		case X86_REG_EBX:
		case X86_REG_ECX:
		case X86_REG_EDX:
		case X86_REG_EBP:
		case X86_REG_ESP:
		case X86_REG_ESI:
		case X86_REG_EDI:
			return false; // 32 bit register modifications clear the high part of the 64 bit register
		default:
			return true; // all other registers are safe
		}
	} else {
		return true;
	}
}

/**
 * @brief is_effective_nop
 * @param inst
 * @return
 */
bool is_effective_nop(const edb::Instruction &inst) {

	if (!inst) {
		return false;
	}

	// trivially a nop
	if (is_nop(inst)) {
		return true;
	}

	switch (inst->id) {
	case X86_INS_NOP:
	case X86_INS_PAUSE:
	case X86_INS_FNOP:
		// nop
		return true;
	case X86_INS_MOV:
	case X86_INS_CMOVA:
	case X86_INS_CMOVAE:
	case X86_INS_CMOVB:
	case X86_INS_CMOVBE:
	case X86_INS_CMOVE:
	case X86_INS_CMOVNE:
	case X86_INS_CMOVG:
	case X86_INS_CMOVGE:
	case X86_INS_CMOVL:
	case X86_INS_CMOVLE:
	case X86_INS_CMOVO:
	case X86_INS_CMOVNO:
	case X86_INS_CMOVP:
	case X86_INS_CMOVNP:
	case X86_INS_CMOVS:
	case X86_INS_CMOVNS:
	case X86_INS_MOVAPS:
	case X86_INS_MOVAPD:
	case X86_INS_MOVUPS:
	case X86_INS_MOVUPD:
	case X86_INS_XCHG:
		// mov edi, edi
		return inst[0]->type == X86_OP_REG && inst[1]->type == X86_OP_REG && inst[0]->reg == inst[1]->reg && is_safe_64_nop_reg_op(inst[0]);
	case X86_INS_LEA: {
		// lea eax, [eax + 0]
		auto reg = inst[0]->reg;
		auto mem = inst[1]->mem;
		return inst[0]->type == X86_OP_REG && inst[1]->type == X86_OP_MEM && mem.disp == 0 &&
			   ((mem.index == X86_REG_INVALID && mem.base == reg) ||
				(mem.index == reg && mem.base == X86_REG_INVALID && mem.scale == 1)) &&
			   is_safe_64_nop_reg_op(inst[0]);
	}
	case X86_INS_JMP:
	case X86_INS_JA:
	case X86_INS_JAE:
	case X86_INS_JB:
	case X86_INS_JBE:
	case X86_INS_JE:
	case X86_INS_JNE:
	case X86_INS_JG:
	case X86_INS_JGE:
	case X86_INS_JL:
	case X86_INS_JLE:
	case X86_INS_JO:
	case X86_INS_JNO:
	case X86_INS_JP:
	case X86_INS_JNP:
	case X86_INS_JS:
	case X86_INS_JNS:
	case X86_INS_JECXZ:
	case X86_INS_JRCXZ:
	case X86_INS_JCXZ:
		// jmp 0
		return inst[0]->type == X86_OP_IMM && static_cast<edb::address_t>(inst[0]->imm) == inst.rva() + inst.byteSize();
	case X86_INS_SHL:
	case X86_INS_SHR:
	case X86_INS_ROL:
	case X86_INS_ROR:
	case X86_INS_SAR:
	case X86_INS_SAL:
		// shl eax, 0
		return inst[1]->type == X86_OP_IMM && inst[1]->imm == 0 && is_safe_64_nop_reg_op(inst[0]);
	case X86_INS_SHLD:
	case X86_INS_SHRD:
		// shld eax, ebx, 0
		return inst[2]->type == X86_OP_IMM && inst[2]->imm == 0 && is_safe_64_nop_reg_op(inst[0]) && is_safe_64_nop_reg_op(inst[1]);
	default:
		return false;
	}
}

}

/**
 * @brief DialogROPTool::DialogROPTool
 * @param parent
 * @param f
 */
DialogROPTool::DialogROPTool(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
	ui.tableView->verticalHeader()->hide();
	ui.tableView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

	filterModel_ = new QSortFilterProxyModel(this);
	connect(ui.txtSearch, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);

	buttonFind_ = new QPushButton(QIcon::fromTheme("edit-find"), tr("Find"));
	connect(buttonFind_, &QPushButton::clicked, this, [this]() {
		buttonFind_->setEnabled(false);
		ui.progressBar->setValue(0);
		doFind();
		ui.progressBar->setValue(100);
		buttonFind_->setEnabled(true);
	});

	ui.buttonBox->addButton(buttonFind_, QDialogButtonBox::ActionRole);
}

/**
 * @brief DialogROPTool::showEvent
 */
void DialogROPTool::showEvent(QShowEvent *) {
	filterModel_->setFilterKeyColumn(3);
	filterModel_->setSourceModel(&edb::v1::memory_regions());
	ui.tableView->setModel(filterModel_);
	ui.progressBar->setValue(0);
}

/**
 * @brief DialogROPTool::addGadget
 * @param results
 * @param instructions
 */
void DialogROPTool::addGadget(DialogResults *results, const InstructionList &instructions) {

	if (!instructions.empty()) {

		auto it    = instructions.begin();
		auto inst1 = *it++;

		QString instruction_string = QString("%1").arg(QString::fromStdString(edb::v1::formatter().toString(*inst1)));
		for (; it != instructions.end(); ++it) {
			auto inst = *it;
			instruction_string.append(QString("; %1").arg(QString::fromStdString(edb::v1::formatter().toString(*inst))));
		}

		if (!ui.checkUnique->isChecked() || !uniqueResults_.contains(instruction_string)) {
			uniqueResults_.insert(instruction_string);

			// found a gadget
			// TODO(eteran): make this look for 1st non-NOP
			results->addResult({inst1->rva(), instruction_string, get_gadget_role(*inst1)});
		}
	}
}

/**
 * @brief DialogROPTool::doFind
 */
void DialogROPTool::doFind() {

	const QItemSelectionModel *const selModel = ui.tableView->selectionModel();
	const QModelIndexList sel                 = selModel->selectedRows();

	if (sel.size() == 0) {
		QMessageBox::critical(
			this,
			tr("No Region Selected"),
			tr("You must select a region which is to be scanned for gadgets."));
	} else {

		auto resultsDialog = new DialogResults(this);

		uniqueResults_.clear();

		if (IProcess *process = edb::v1::debugger_core->process()) {
			for (const QModelIndex &selected_item : sel) {

				const QModelIndex index = filterModel_->mapToSource(selected_item);
				if (auto region = *reinterpret_cast<const std::shared_ptr<IRegion> *>(index.internalPointer())) {

					edb::address_t start_address     = region->start();
					const edb::address_t end_address = region->end();
					const edb::address_t orig_start  = start_address;

					ByteShiftArray bsa(32);

					while (start_address < end_address) {

						// read in the next byte
						uint8_t byte;
						if (process->readBytes(start_address, &byte, 1)) {
							bsa << byte;

							const uint8_t *p       = bsa.data();
							const uint8_t *const l = p + bsa.size();
							edb::address_t rva     = start_address - bsa.size() + 1;

							InstructionList instruction_list;

							// eat up any NOPs in front...
							Q_FOREVER {
								auto inst = std::make_shared<edb::Instruction>(p, l, rva);
								if (!is_effective_nop(*inst)) {
									break;
								}

								instruction_list.push_back(inst);
								p += inst->byteSize();
								rva += inst->byteSize();
							}

							auto inst1 = std::make_shared<edb::Instruction>(p, l, rva);
							if (inst1->valid()) {
								instruction_list.push_back(inst1);

								if (is_int(*inst1) && is_immediate(inst1->operand(0)) && (inst1->operand(0)->imm & 0xff) == 0x80) {
									addGadget(resultsDialog, instruction_list);
								} else if (is_sysenter(*inst1)) {
									addGadget(resultsDialog, instruction_list);
								} else if (is_syscall(*inst1)) {
									addGadget(resultsDialog, instruction_list);
								} else if (is_ret(*inst1)) {
									ui.progressBar->setValue(util::percentage(start_address - orig_start, region->size()));
									++start_address;
									continue;
								} else {

									p += inst1->byteSize();
									rva += inst1->byteSize();

									// eat up any NOPs in between...
									Q_FOREVER {
										auto inst = std::make_shared<edb::Instruction>(p, l, rva);
										if (!is_effective_nop(*inst)) {
											break;
										}

										instruction_list.push_back(inst);
										p += inst->byteSize();
										rva += inst->byteSize();
									}

									auto inst2 = std::make_shared<edb::Instruction>(p, l, rva);

									if (is_ret(*inst2)) {
										instruction_list.push_back(inst2);
										addGadget(resultsDialog, instruction_list);
									} else if (inst2->valid() && inst2->operation() == X86_INS_POP) {
										instruction_list.push_back(inst2);
										p += inst2->byteSize();
										rva += inst2->byteSize();

										auto inst3 = std::make_shared<edb::Instruction>(p, l, rva);

										if (inst3->valid() && is_jump(*inst3)) {

											instruction_list.push_back(inst3);

											if (inst2->operandCount() == 1 && is_register(inst2->operand(0))) {
												if (inst3->operandCount() == 1 && is_register(inst3->operand(0))) {
													if (inst2->operand(0)->reg == inst3->operand(0)->reg) {
														addGadget(resultsDialog, instruction_list);
													}
												}
											}
										}
									}
								}

								// TODO(eteran): catch things like "add rsp, 8; jmp [rsp - 8]" and similar, it's rare,
								// but could happen
							}
						}

						ui.progressBar->setValue(util::percentage(start_address - orig_start, region->size()));
						++start_address;
					}
				}
			}
		}

		if (resultsDialog->resultCount() == 0) {
			QMessageBox::information(this, tr("No Results"), tr("No Rop Gadgets found in the selected region."));
			delete resultsDialog;
		} else {
			resultsDialog->show();
		}
	}
}

}

```

`plugins/ROPTool/DialogROPTool.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_ROPTOOL_H_20100817_
#define DIALOG_ROPTOOL_H_20100817_

#include "Instruction.h"
#include "Types.h"
#include "ui_DialogROPTool.h"

#include <QDialog>
#include <QList>
#include <QSet>
#include <QSortFilterProxyModel>
#include <memory>
#include <vector>

class QListWidgetItem;
class QModelIndex;
class QSortFilterProxyModel;
class QStandardItem;
class QStandardItemModel;

namespace ROPToolPlugin {

class ResultFilterProxy;
class DialogResults;

class DialogROPTool : public QDialog {
	Q_OBJECT

public:
	explicit DialogROPTool(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogROPTool() override = default;

private:
	using InstructionList = std::vector<std::shared_ptr<edb::Instruction>>;

private:
	void doFind();
	void addGadget(DialogResults *results, const InstructionList &instructions);

private:
	void showEvent(QShowEvent *event) override;

private:
	Ui::DialogROPTool ui;
	QSortFilterProxyModel *filterModel_ = nullptr;
	QSet<QString> uniqueResults_;
	QPushButton *buttonFind_ = nullptr;
};

}

#endif

```

`plugins/ROPTool/DialogROPTool.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>ROPToolPlugin::DialogROPTool</class>
 <widget class="QDialog" name="ROPToolPlugin::DialogROPTool">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>650</width>
    <height>400</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>ROP Gadget Search</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="label">
     <property name="text">
      <string>Regions To Search:</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLineEdit" name="txtSearch">
       <property name="placeholderText">
        <string>Filter</string>
       </property>
       <property name="clearButtonEnabled">
        <bool>true</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkUnique">
       <property name="text">
        <string>Unique Gadgets Only</string>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QTableView" name="tableView">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBar">
     <property name="value">
      <number>0</number>
     </property>
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>txtSearch</tabstop>
  <tabstop>tableView</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>ROPToolPlugin::DialogROPTool</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>497</x>
     <y>347</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>325</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>ROPToolPlugin::DialogROPTool</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>533</x>
     <y>341</y>
    </hint>
    <hint type="destinationlabel">
     <x>532</x>
     <y>324</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/ROPTool/DialogResults.cpp`:

```cpp

#include "DialogResults.h"
#include "ResultsModel.h"
#include "edb.h"
#include <QSortFilterProxyModel>

namespace ROPToolPlugin {

/**
 * @brief DialogResults::DialogResults
 * @param parent
 * @param f
 */
DialogResults::DialogResults(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
	ui.tableView->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

	model_       = new ResultsModel(this);
	filterModel_ = new QSortFilterProxyModel(this);

	resultFilter_ = new ResultFilterProxy(this);
	resultFilter_->setSourceModel(model_);

	filterModel_->setFilterKeyColumn(1);
	filterModel_->setSourceModel(resultFilter_);
	ui.tableView->setModel(filterModel_);

	connect(ui.textFilter, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);
	connect(ui.chkShowALU, &QCheckBox::stateChanged, this, [this](int state) {
		resultFilter_->setMask(0x01, state);
	});

	connect(ui.chkShowStack, &QCheckBox::stateChanged, this, [this](int state) {
		resultFilter_->setMask(0x02, state);
	});

	connect(ui.chkShowLogic, &QCheckBox::stateChanged, this, [this](int state) {
		resultFilter_->setMask(0x04, state);
	});

	connect(ui.chkShowData, &QCheckBox::stateChanged, this, [this](int state) {
		resultFilter_->setMask(0x08, state);
	});

	connect(ui.chkShowOther, &QCheckBox::stateChanged, this, [this](int state) {
		resultFilter_->setMask(0x10, state);
	});
}

/**
 * @brief DialogResults::addResult
 * @param result
 */
void DialogResults::addResult(const ResultsModel::Result &result) {
	model_->addResult(result);
}

/**
 * @brief DialogResults::on_tableView_doubleClicked
 * @param index
 */
void DialogResults::on_tableView_doubleClicked(const QModelIndex &index) {
	if (index.isValid()) {
		const QModelIndex realIndex = filterModel_->mapToSource(index);
		if (realIndex.isValid()) {
			const QModelIndex realIndex2 = resultFilter_->mapToSource(realIndex);
			if (auto item = static_cast<ResultsModel::Result *>(realIndex2.internalPointer())) {
				edb::v1::jump_to_address(item->address);
			}
		}
	}
}

/**
 * @brief DialogResults::resultCount
 * @return
 */
int DialogResults::resultCount() const {
	return model_->rowCount();
}

}

```

`plugins/ROPTool/DialogResults.h`:

```h

#ifndef ROP_TOOL_DIALOG_RESULTS_H_20191119_
#define ROP_TOOL_DIALOG_RESULTS_H_20191119_

#include "ResultsModel.h"
#include "ui_DialogResults.h"
#include <QDialog>
#include <QSortFilterProxyModel>

class QSortFilterProxyModel;

namespace ROPToolPlugin {

class ResultsModel;

class ResultFilterProxy : public QSortFilterProxyModel {
	Q_OBJECT
public:
	explicit ResultFilterProxy(QObject *parent = nullptr)
		: QSortFilterProxyModel(parent) {
	}

public:
	void setMask(uint32_t mask, bool value) {
		beginResetModel();
		if (value) {
			mask_ |= mask;
		} else {
			mask_ &= ~mask;
		}
		endResetModel();
	}

protected:
	bool filterAcceptsRow(int sourceRow, const QModelIndex &sourceParent) const override {
		QModelIndex index = sourceModel()->index(sourceRow, 0, sourceParent);
		if (index.isValid()) {
			if (auto result = reinterpret_cast<const ResultsModel::Result *>(index.internalPointer())) {
				if (result->role & mask_) {
					return true;
				}
			}
		}

		return false;
	}

private:
	uint32_t mask_ = 0xffffffff;
};

class DialogResults : public QDialog {
	Q_OBJECT

public:
	explicit DialogResults(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());

public:
	void addResult(const ResultsModel::Result &result);

private Q_SLOTS:
	void on_tableView_doubleClicked(const QModelIndex &index);

public:
	int resultCount() const;

private:
	Ui::DialogResults ui;
	ResultsModel *model_                = nullptr;
	QSortFilterProxyModel *filterModel_ = nullptr;
	ResultFilterProxy *resultFilter_    = nullptr;
};

}

#endif

```

`plugins/ROPTool/DialogResults.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>ROPToolPlugin::DialogResults</class>
 <widget class="QDialog" name="ROPToolPlugin::DialogResults">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>650</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>ROP Tool Results</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="1" column="0">
    <widget class="QTableView" name="tableView">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="contextMenuPolicy">
      <enum>Qt::CustomContextMenu</enum>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
    </widget>
   </item>
   <item row="1" column="1">
    <widget class="QGroupBox" name="groupBox">
     <property name="title">
      <string>Gadgets to Display</string>
     </property>
     <layout class="QVBoxLayout" name="verticalLayout">
      <item>
       <widget class="QCheckBox" name="chkShowALU">
        <property name="text">
         <string>ALU</string>
        </property>
        <property name="checked">
         <bool>true</bool>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QCheckBox" name="chkShowStack">
        <property name="text">
         <string>Stack</string>
        </property>
        <property name="checked">
         <bool>true</bool>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QCheckBox" name="chkShowLogic">
        <property name="text">
         <string>Logic</string>
        </property>
        <property name="checked">
         <bool>true</bool>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QCheckBox" name="chkShowData">
        <property name="text">
         <string>Data</string>
        </property>
        <property name="checked">
         <bool>true</bool>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QCheckBox" name="chkShowOther">
        <property name="text">
         <string>Other</string>
        </property>
        <property name="checked">
         <bool>true</bool>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="verticalSpacer">
        <property name="orientation">
         <enum>Qt::Vertical</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>20</width>
          <height>48</height>
         </size>
        </property>
       </spacer>
      </item>
     </layout>
    </widget>
   </item>
   <item row="0" column="0" colspan="2">
    <widget class="QLineEdit" name="textFilter">
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item row="2" column="0" colspan="2">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>ROPToolPlugin::DialogResults</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>224</x>
     <y>326</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>ROPToolPlugin::DialogResults</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>292</x>
     <y>332</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/ROPTool/ROPTool.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ROPTool.h"
#include "DialogROPTool.h"
#include "edb.h"
#include <QMenu>

namespace ROPToolPlugin {

/**
 * @brief ROPTool::ROPTool
 * @param parent
 */
ROPTool::ROPTool(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief ROPTool::~ROPTool
 */
ROPTool::~ROPTool() {
	delete dialog_;
}

/**
 * @brief ROPTool::menu
 * @param parent
 * @return
 */
QMenu *ROPTool::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("ROPTool"), parent);
		menu_->addAction(tr("&ROP Tool"), this, SLOT(showMenu()), QKeySequence(tr("Ctrl+Alt+R")));
	}

	return menu_;
}

/**
 * @brief ROPTool::showMenu
 */
void ROPTool::showMenu() {

	if (!dialog_) {
		dialog_ = new DialogROPTool(edb::v1::debugger_ui);
	}

	dialog_->show();
}

}

```

`plugins/ROPTool/ROPTool.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef ROPTOOL_H_20100817_
#define ROPTOOL_H_20100817_

#include "IPlugin.h"

class QMenu;
class QDialog;

namespace ROPToolPlugin {

class ROPTool : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit ROPTool(QObject *parent = nullptr);
	~ROPTool() override;

public:
	QMenu *menu(QWidget *parent = nullptr) override;

public Q_SLOTS:
	void showMenu();

private:
	QMenu *menu_              = nullptr;
	QPointer<QDialog> dialog_ = nullptr;
};

}

#endif

```

`plugins/ROPTool/ResultsModel.cpp`:

```cpp
/*
Copyright (C) 2006 - 2019 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ResultsModel.h"
#include "edb.h"
#include <algorithm>

namespace ROPToolPlugin {

/**
 * @brief ResultsModel::ResultsModel
 * @param parent
 */
ResultsModel::ResultsModel(QObject *parent)
	: QAbstractItemModel(parent) {
}

/**
 * @brief ResultsModel::headerData
 * @param section
 * @param orientation
 * @param role
 * @return
 */
QVariant ResultsModel::headerData(int section, Qt::Orientation orientation, int role) const {

	if (role == Qt::DisplayRole && orientation == Qt::Horizontal) {
		switch (section) {
		case 0:
			return tr("Address");
		case 1:
			return tr("Instruction");
		}
	}

	return QVariant();
}

/**
 * @brief ResultsModel::data
 * @param index
 * @param role
 * @return
 */
QVariant ResultsModel::data(const QModelIndex &index, int role) const {

	if (!index.isValid()) {
		return QVariant();
	}

	const Result &result = results_[index.row()];

	if (role == Qt::DisplayRole) {
		switch (index.column()) {
		case 0:
			return edb::v1::format_pointer(result.address);
		case 1:
			return result.instruction;
		default:
			return QVariant();
		}
	}

	return QVariant();
}

/**
 * @brief ResultsModel::addResult
 * @param r
 */
void ResultsModel::addResult(const Result &r) {
	beginInsertRows(QModelIndex(), rowCount(), rowCount());
	results_.push_back(r);
	endInsertRows();
}

/**
 * @brief ResultsModel::index
 * @param row
 * @param column
 * @param parent
 * @return
 */
QModelIndex ResultsModel::index(int row, int column, const QModelIndex &parent) const {

	Q_UNUSED(parent)

	if (row >= results_.size()) {
		return QModelIndex();
	}

	if (column >= 2) {
		return QModelIndex();
	}

	if (row >= 0) {
		return createIndex(row, column, const_cast<Result *>(&results_[row]));
	} else {
		return createIndex(row, column);
	}
}

/**
 * @brief ResultsModel::parent
 * @param index
 * @return
 */
QModelIndex ResultsModel::parent(const QModelIndex &index) const {
	Q_UNUSED(index)
	return QModelIndex();
}

/**
 * @brief ResultsModel::rowCount
 * @param parent
 * @return
 */
int ResultsModel::rowCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return results_.size();
}

/**
 * @brief ResultsModel::columnCount
 * @param parent
 * @return
 */
int ResultsModel::columnCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return 2;
}

/**
 * @brief ResultsModel::sort
 * @param column
 * @param order
 */
void ResultsModel::sort(int column, Qt::SortOrder order) {

	if (order == Qt::AscendingOrder) {
		switch (column) {
		case 0:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.address < s2.address; });
			break;
		case 1:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.instruction < s2.instruction; });
			break;
		}
	} else {
		switch (column) {
		case 0:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.address > s2.address; });
			break;
		case 1:
			std::sort(results_.begin(), results_.end(), [](const Result &s1, const Result &s2) { return s1.instruction > s2.instruction; });
			break;
		}
	}

	Q_EMIT dataChanged(createIndex(0, 0, nullptr), createIndex(-1, -1, nullptr));
}

}

```

`plugins/ROPTool/ResultsModel.h`:

```h
/*
Copyright (C) 2006 - 2019 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ROP_TOOL_RESULTS_MODEL_H_20191119_
#define ROP_TOOL_RESULTS_MODEL_H_20191119_

#include "Function.h"
#include "Types.h"
#include <QAbstractItemModel>
#include <QVector>

namespace ROPToolPlugin {

class ResultsModel : public QAbstractItemModel {
	Q_OBJECT
public:
	struct Result {
		edb::address_t address = 0;
		QString instruction;
		uint32_t role = 0x00;
	};

public:
	explicit ResultsModel(QObject *parent = nullptr);

public:
	QVariant data(const QModelIndex &index, int role) const override;
	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex &index) const override;
	int rowCount(const QModelIndex &parent = QModelIndex()) const override;
	int columnCount(const QModelIndex &parent = QModelIndex()) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
	void sort(int column, Qt::SortOrder order = Qt::AscendingOrder) override;

public:
	void addResult(const Result &r);

public:
	const QVector<Result> &results() const { return results_; }

private:
	QVector<Result> results_;
};

}

#endif

```

`plugins/References/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "References")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	DialogReferences.cpp
	DialogReferences.h
	DialogReferences.ui
	References.cpp
	References.h
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/References/DialogReferences.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogReferences.h"
#include "IDebugger.h"
#include "MemoryRegions.h"
#include "edb.h"
#include "util/Math.h"

#include <QMessageBox>
#include <QPushButton>
#include <QVector>

namespace ReferencesPlugin {

enum Role {
	TypeRole    = Qt::UserRole + 0,
	AddressRole = Qt::UserRole + 1
};

/**
 * @brief DialogReferences::DialogReferences
 * @param parent
 * @param f
 */
DialogReferences::DialogReferences(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
	connect(this, &DialogReferences::updateProgress, ui.progressBar, &QProgressBar::setValue);

	buttonFind_ = new QPushButton(QIcon::fromTheme("edit-find"), tr("Find"));
	connect(buttonFind_, &QPushButton::clicked, this, [this]() {
		buttonFind_->setEnabled(false);
		ui.progressBar->setValue(0);
		ui.listWidget->clear();
		doFind();
		ui.progressBar->setValue(100);
		buttonFind_->setEnabled(true);
	});

	ui.buttonBox->addButton(buttonFind_, QDialogButtonBox::ActionRole);
}

/**
 * @brief DialogReferences::showEvent
 */
void DialogReferences::showEvent(QShowEvent *) {
	ui.listWidget->clear();
	ui.progressBar->setValue(0);
}

/**
 * @brief DialogReferences::doFind
 */
void DialogReferences::doFind() {
	bool ok = false;
	edb::address_t address;
	const size_t page_size = edb::v1::debugger_core->pageSize();

	const QString text = ui.txtAddress->text();
	if (!text.isEmpty()) {
		ok = edb::v1::eval_expression(text, &address);
	}

	if (ok) {
		edb::v1::memory_regions().sync();
		const QList<std::shared_ptr<IRegion>> regions = edb::v1::memory_regions().regions();

		int i = 0;
		for (const std::shared_ptr<IRegion> &region : regions) {
			// a short circut for speading things up
			if (region->accessible() || !ui.chkSkipNoAccess->isChecked()) {

				const size_t page_count      = region->size() / page_size;
				const QVector<uint8_t> pages = edb::v1::read_pages(region->start(), page_count);

				if (!pages.isEmpty()) {
					const uint8_t *p               = &pages[0];
					const uint8_t *const pages_end = &pages[0] + region->size();

					while (p != pages_end) {

						if (pages_end - p < static_cast<int>(edb::v1::pointer_size())) {
							break;
						}

						const edb::address_t addr = p - &pages[0] + region->start();

						edb::address_t test_address(0);
						memcpy(&test_address, p, edb::v1::pointer_size());

						if (test_address == address) {
							auto item = new QListWidgetItem(edb::v1::format_pointer(addr));
							item->setData(TypeRole, 'D');
							item->setData(AddressRole, addr.toQVariant());
							ui.listWidget->addItem(item);
						}

						edb::Instruction inst(p, pages_end, addr);

						if (inst) {
							switch (inst.operation()) {
							case X86_INS_MOV:
								// instructions of the form: mov [ADDR], 0xNNNNNNNN
								Q_ASSERT(inst.operandCount() == 2);

								if (is_expression(inst[0])) {
									if (is_immediate(inst[1]) && static_cast<edb::address_t>(inst[1]->imm) == address) {
										auto item = new QListWidgetItem(edb::v1::format_pointer(addr));
										item->setData(TypeRole, 'C');
										item->setData(AddressRole, addr.toQVariant());
										ui.listWidget->addItem(item);
									}
								}

								break;
							case X86_INS_PUSH:
								// instructions of the form: push 0xNNNNNNNN
								Q_ASSERT(inst.operandCount() == 1);

								if (is_immediate(inst[0]) && static_cast<edb::address_t>(inst[0]->imm) == address) {
									auto item = new QListWidgetItem(edb::v1::format_pointer(addr));
									item->setData(TypeRole, 'C');
									item->setData(AddressRole, addr.toQVariant());
									ui.listWidget->addItem(item);
								}
								break;
							default:
								if (is_jump(inst) || is_call(inst)) {
									if (is_immediate(inst[0])) {
										if (static_cast<edb::address_t>(inst[0]->imm) == address) {
											auto item = new QListWidgetItem(edb::v1::format_pointer(addr));
											item->setData(TypeRole, 'C');
											item->setData(AddressRole, addr.toQVariant());
											ui.listWidget->addItem(item);
										}
									}
								}
								break;
							}
						}

						Q_EMIT updateProgress(util::percentage(i, regions.size(), p - &pages[0], region->size()));
						++p;
					}
				}

			} else {
				Q_EMIT updateProgress(util::percentage(i, regions.size()));
			}
			++i;
		}
	}
}

/**
 * @brief DialogReferences::on_listWidget_itemDoubleClicked
 *
 * follows the found item in the data view
 *
 * @param item
 */
void DialogReferences::on_listWidget_itemDoubleClicked(QListWidgetItem *item) {
	const edb::address_t addr = item->data(AddressRole).toULongLong();
	if (item->data(TypeRole).toChar() == 'D') {
		edb::v1::dump_data(addr, false);
	} else {
		edb::v1::jump_to_address(addr);
	}
}

}

```

`plugins/References/DialogReferences.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_REFERENCES_H_20061101_
#define DIALOG_REFERENCES_H_20061101_

#include "IRegion.h"
#include "Types.h"
#include "ui_DialogReferences.h"
#include <QDialog>

class QListWidgetItem;

namespace ReferencesPlugin {

class DialogReferences : public QDialog {
	Q_OBJECT

public:
	explicit DialogReferences(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogReferences() override = default;

public Q_SLOTS:
	void on_listWidget_itemDoubleClicked(QListWidgetItem *item);

Q_SIGNALS:
	void updateProgress(int);

private:
	void showEvent(QShowEvent *event) override;

private:
	void doFind();

private:
	Ui::DialogReferences ui;
	QPushButton *buttonFind_ = nullptr;
};

}

#endif

```

`plugins/References/DialogReferences.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>ReferencesPlugin::DialogReferences</class>
 <widget class="QDialog" name="ReferencesPlugin::DialogReferences">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>376</width>
    <height>383</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>References Search</string>
  </property>
  <layout class="QVBoxLayout">
   <item>
    <widget class="QLabel" name="label">
     <property name="text">
      <string>Find References To This Address:</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLineEdit" name="txtAddress">
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="label_2">
     <property name="text">
      <string>Results:</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QListWidget" name="listWidget">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QCheckBox" name="chkSkipNoAccess">
     <property name="text">
      <string>Skip Regions With No Access Rights</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QProgressBar" name="progressBar">
     <property name="value">
      <number>0</number>
     </property>
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>txtAddress</tabstop>
  <tabstop>listWidget</tabstop>
  <tabstop>chkSkipNoAccess</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>ReferencesPlugin::DialogReferences</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>369</x>
     <y>345</y>
    </hint>
    <hint type="destinationlabel">
     <x>375</x>
     <y>329</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>ReferencesPlugin::DialogReferences</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>136</x>
     <y>331</y>
    </hint>
    <hint type="destinationlabel">
     <x>232</x>
     <y>307</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/References/References.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "References.h"
#include "DialogReferences.h"
#include "edb.h"
#include <QMenu>

namespace ReferencesPlugin {

/**
 * @brief References::References
 * @param parent
 */
References::References(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief References::~References
 */
References::~References() {
	delete dialog_;
}

/**
 * @brief References::menu
 * @param parent
 * @return
 */
QMenu *References::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("Reference Searcher"), parent);
		menu_->addAction(tr("&Reference Search"), this, SLOT(showMenu()), QKeySequence(tr("Ctrl+R")));
	}

	return menu_;
}

/**
 * @brief References::showMenu
 */
void References::showMenu() {

	if (!dialog_) {
		dialog_ = new DialogReferences(edb::v1::debugger_ui);
	}

	dialog_->show();
}

}

```

`plugins/References/References.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef REFERENCES_H_20060430_
#define REFERENCES_H_20060430_

#include "IPlugin.h"

class QMenu;
class QDialog;

namespace ReferencesPlugin {

class References : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit References(QObject *parent = nullptr);
	~References() override;

public:
	QMenu *menu(QWidget *parent = nullptr) override;

public Q_SLOTS:
	void showMenu();

private:
	QMenu *menu_              = nullptr;
	QPointer<QDialog> dialog_ = nullptr;
};

}

#endif

```

`plugins/SymbolViewer/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

set(PluginName "SymbolViewer")

find_package(Qt5 5.0.0 REQUIRED Widgets)

add_library(${PluginName} SHARED
	DialogSymbolViewer.cpp
	DialogSymbolViewer.h
	DialogSymbolViewer.ui
	SymbolViewer.cpp
	SymbolViewer.h
)

target_link_libraries(${PluginName} Qt5::Widgets edb)

install (TARGETS ${PluginName} DESTINATION ${CMAKE_INSTALL_LIBDIR}/edb)

target_add_warnings(${PluginName})

set_property(TARGET ${PluginName} PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD 17)
set_property(TARGET ${PluginName} PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET ${PluginName} PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
set_property(TARGET ${PluginName} PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

```

`plugins/SymbolViewer/DialogSymbolViewer.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogSymbolViewer.h"
#include "Configuration.h"
#include "IDebugger.h"
#include "ISymbolManager.h"
#include "Symbol.h"
#include "Util.h"
#include "edb.h"

#include <QMenu>
#include <QPushButton>
#include <QSortFilterProxyModel>
#include <QStringListModel>

namespace SymbolViewerPlugin {

/**
 * @brief DialogSymbolViewer::DialogSymbolViewer
 * @param parent
 * @param f
 */
DialogSymbolViewer::DialogSymbolViewer(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);

	buttonRefresh_ = new QPushButton(QIcon::fromTheme("view-refresh"), tr("Refresh"));
	connect(buttonRefresh_, &QPushButton::clicked, this, [this]() {
		buttonRefresh_->setEnabled(false);
		doFind();
		buttonRefresh_->setEnabled(true);
	});

	ui.buttonBox->addButton(buttonRefresh_, QDialogButtonBox::ActionRole);

	ui.listView->setContextMenuPolicy(Qt::CustomContextMenu);

	model_       = new QStringListModel(this);
	filterModel_ = new QSortFilterProxyModel(this);

	filterModel_->setFilterKeyColumn(0);
	filterModel_->setSourceModel(model_);
	ui.listView->setModel(filterModel_);
	ui.listView->setUniformItemSizes(true);

	connect(ui.txtSearch, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);
}

/**
 * @brief DialogSymbolViewer::on_listView_doubleClicked
 *
 * follows the found item in the data view
 *
 * @param index
 */
void DialogSymbolViewer::on_listView_doubleClicked(const QModelIndex &index) {

	const QString s = index.data().toString();

	if (const Result<edb::address_t, QString> addr = edb::v1::string_to_address(s.split(":")[0])) {
		const std::shared_ptr<Symbol> sym = edb::v1::symbol_manager().find(*addr);

		if (sym && sym->isCode()) {
			edb::v1::jump_to_address(*addr);
		} else {
			edb::v1::dump_data(*addr, false);
		}
	}
}

/**
 * @brief DialogSymbolViewer::on_listView_customContextMenuRequested
 * @param pos
 */
void DialogSymbolViewer::on_listView_customContextMenuRequested(const QPoint &pos) {

	const QModelIndex index = ui.listView->indexAt(pos);
	if (index.isValid()) {

		const QString s = index.data().toString();

		if (const Result<edb::address_t, QString> addr = edb::v1::string_to_address(s.split(":")[0])) {

			QMenu menu;
			QAction *const action1 = menu.addAction(tr("&Follow In Disassembly"), this, SLOT(mnuFollowInCPU()));
			QAction *const action2 = menu.addAction(tr("&Follow In Dump"), this, SLOT(mnuFollowInDump()));
			QAction *const action3 = menu.addAction(tr("&Follow In Dump (New Tab)"), this, SLOT(mnuFollowInDumpNewTab()));
			QAction *const action4 = menu.addAction(tr("&Follow In Stack"), this, SLOT(mnuFollowInStack()));

			action1->setData(addr->toQVariant());
			action2->setData(addr->toQVariant());
			action3->setData(addr->toQVariant());
			action4->setData(addr->toQVariant());

			menu.exec(ui.listView->mapToGlobal(pos));
		}
	}
}

/**
 * @brief DialogSymbolViewer::mnuFollowInDump
 */
void DialogSymbolViewer::mnuFollowInDump() {
	if (auto action = qobject_cast<QAction *>(sender())) {
		const edb::address_t address = action->data().toULongLong();
		edb::v1::dump_data(address, false);
	}
}

/**
 * @brief DialogSymbolViewer::mnuFollowInDumpNewTab
 */
void DialogSymbolViewer::mnuFollowInDumpNewTab() {
	if (auto action = qobject_cast<QAction *>(sender())) {
		const edb::address_t address = action->data().toULongLong();
		edb::v1::dump_data(address, true);
	}
}

/**
 * @brief DialogSymbolViewer::mnuFollowInStack
 */
void DialogSymbolViewer::mnuFollowInStack() {
	if (auto action = qobject_cast<QAction *>(sender())) {
		const edb::address_t address = action->data().toULongLong();
		edb::v1::dump_stack(address, false);
	}
}

/**
 * @brief DialogSymbolViewer::mnuFollowInCPU
 */
void DialogSymbolViewer::mnuFollowInCPU() {
	if (auto action = qobject_cast<QAction *>(sender())) {
		const edb::address_t address = action->data().toULongLong();
		edb::v1::jump_to_address(address);
	}
}

/**
 * @brief DialogSymbolViewer::doFind
 */
void DialogSymbolViewer::doFind() {
	QStringList results;

	const std::vector<std::shared_ptr<Symbol>> symbols = edb::v1::symbol_manager().symbols();
	for (const std::shared_ptr<Symbol> &sym : symbols) {
		results << QString("%1: %2").arg(edb::v1::format_pointer(sym->address), sym->name);
	}

	model_->setStringList(results);
}

/**
 * @brief DialogSymbolViewer::showEvent
 */
void DialogSymbolViewer::showEvent(QShowEvent *) {
	buttonRefresh_->setEnabled(false);
	doFind();
	buttonRefresh_->setEnabled(true);
}

}

```

`plugins/SymbolViewer/DialogSymbolViewer.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_SYMBOL_VIEWER_H_20080812_
#define DIALOG_SYMBOL_VIEWER_H_20080812_

#include "Types.h"
#include "ui_DialogSymbolViewer.h"
#include <QDialog>

class QModelIndex;
class QPoint;
class QSortFilterProxyModel;
class QStringListModel;

namespace SymbolViewerPlugin {

class DialogSymbolViewer : public QDialog {
	Q_OBJECT

public:
	explicit DialogSymbolViewer(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogSymbolViewer() override = default;

public Q_SLOTS:
	void on_listView_doubleClicked(const QModelIndex &index);
	void on_listView_customContextMenuRequested(const QPoint &pos);

private Q_SLOTS:
	void mnuFollowInDump();
	void mnuFollowInDumpNewTab();
	void mnuFollowInStack();
	void mnuFollowInCPU();

private:
	void showEvent(QShowEvent *event) override;

private:
	void doFind();

private:
	Ui::DialogSymbolViewer ui;
	QStringListModel *model_            = nullptr;
	QSortFilterProxyModel *filterModel_ = nullptr;
	QPushButton *buttonRefresh_         = nullptr;
};

}

#endif

```

`plugins/SymbolViewer/DialogSymbolViewer.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>SymbolViewerPlugin::DialogSymbolViewer</class>
 <widget class="QDialog" name="SymbolViewerPlugin::DialogSymbolViewer">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>500</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Symbols</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="label">
     <property name="text">
      <string>Loaded Symbols:</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLineEdit" name="txtSearch">
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QListView" name="listView">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="showDropIndicator" stdset="0">
      <bool>false</bool>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>SymbolViewerPlugin::DialogSymbolViewer</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>195</x>
     <y>296</y>
    </hint>
    <hint type="destinationlabel">
     <x>524</x>
     <y>256</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>SymbolViewerPlugin::DialogSymbolViewer</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>121</x>
     <y>297</y>
    </hint>
    <hint type="destinationlabel">
     <x>521</x>
     <y>311</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`plugins/SymbolViewer/SymbolViewer.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "SymbolViewer.h"
#include "DialogSymbolViewer.h"
#include "edb.h"
#include <QMenu>

namespace SymbolViewerPlugin {

/**
 * @brief SymbolViewer::SymbolViewer
 * @param parent
 */
SymbolViewer::SymbolViewer(QObject *parent)
	: QObject(parent) {
}

/**
 * @brief SymbolViewer::~SymbolViewer
 */
SymbolViewer::~SymbolViewer() {
	delete dialog_;
}

/**
 * @brief SymbolViewer::menu
 * @param parent
 * @return
 */
QMenu *SymbolViewer::menu(QWidget *parent) {

	Q_ASSERT(parent);

	if (!menu_) {
		menu_ = new QMenu(tr("SymbolViewer"), parent);
		menu_->addAction(tr("&Symbol Viewer"), this, SLOT(showMenu()), QKeySequence(tr("Ctrl+Alt+S")));
	}

	return menu_;
}

/**
 * @brief SymbolViewer::showMenu
 */
void SymbolViewer::showMenu() {

	if (!dialog_) {
		dialog_ = new DialogSymbolViewer(edb::v1::debugger_ui);
	}

	dialog_->show();
}

}

```

`plugins/SymbolViewer/SymbolViewer.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef SYMBOL_VIEWER_H_20080812_
#define SYMBOL_VIEWER_H_20080812_

#include "IPlugin.h"

class QMenu;
class QDialog;

namespace SymbolViewerPlugin {

class SymbolViewer : public QObject, public IPlugin {
	Q_OBJECT
	Q_INTERFACES(IPlugin)
	Q_PLUGIN_METADATA(IID "edb.IPlugin/1.0")
	Q_CLASSINFO("author", "Evan Teran")
	Q_CLASSINFO("url", "http://www.codef00.com")

public:
	explicit SymbolViewer(QObject *parent = nullptr);
	~SymbolViewer() override;

public:
	QMenu *menu(QWidget *parent = nullptr) override;

public Q_SLOTS:
	void showMenu();

private:
	QMenu *menu_              = nullptr;
	QPointer<QDialog> dialog_ = nullptr;
};

}

#endif

```

`src/BasicBlock.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "BasicBlock.h"
#include "edb.h"

#include <QString>
#include <QTextStream>

/**
 * @brief BasicBlock::swap
 * @param other
 */
void BasicBlock::swap(BasicBlock &other) {
	using std::swap;
	swap(instructions_, other.instructions_);
	swap(references_, other.references_);
}

/**
 * @brief BasicBlock::push_back
 * @param inst
 */
void BasicBlock::push_back(const instruction_pointer &inst) {
	instructions_.push_back(inst);
}

/**
 * @brief BasicBlock::begin
 * @return
 */
BasicBlock::const_iterator BasicBlock::begin() const {
	return instructions_.begin();
}

/**
 * @brief BasicBlock::end
 * @return
 */
BasicBlock::const_iterator BasicBlock::end() const {
	return instructions_.end();
}

/**
 * @brief BasicBlock::begin
 * @return
 */
BasicBlock::iterator BasicBlock::begin() {
	return instructions_.begin();
}

/**
 * @brief BasicBlock::end
 * @return
 */
BasicBlock::iterator BasicBlock::end() {
	return instructions_.end();
}

/**
 * @brief BasicBlock::rbegin
 * @return
 */
BasicBlock::const_reverse_iterator BasicBlock::rbegin() const {
	return const_reverse_iterator(instructions_.end());
}

/**
 * @brief BasicBlock::rend
 * @return
 */
BasicBlock::const_reverse_iterator BasicBlock::rend() const {
	return const_reverse_iterator(instructions_.begin());
}

/**
 * @brief BasicBlock::rbegin
 * @return
 */
BasicBlock::reverse_iterator BasicBlock::rbegin() {
	return reverse_iterator(instructions_.end());
}

/**
 * @brief BasicBlock::rend
 * @return
 */
BasicBlock::reverse_iterator BasicBlock::rend() {
	return reverse_iterator(instructions_.begin());
}

/**
 * @brief BasicBlock::size
 * @return
 */
BasicBlock::size_type BasicBlock::size() const {
	return instructions_.size();
}

/**
 * @brief BasicBlock::empty
 * @return
 */
bool BasicBlock::empty() const {
	return instructions_.empty();
}

/**
 * @brief BasicBlock::operator []
 * @param pos
 * @return
 */
BasicBlock::reference BasicBlock::operator[](size_type pos) {
	Q_ASSERT(pos < instructions_.size());
	return instructions_[pos];
}

/**
 * @brief BasicBlock::operator []
 * @param pos
 * @return
 */
BasicBlock::const_reference BasicBlock::operator[](size_type pos) const {
	Q_ASSERT(pos < instructions_.size());
	return instructions_[pos];
}

/**
 * @brief BasicBlock::front
 * @return
 */
BasicBlock::reference BasicBlock::front() {
	Q_ASSERT(!empty());
	return *begin();
}

/**
 * @brief BasicBlock::front
 * @return
 */
BasicBlock::const_reference BasicBlock::front() const {
	Q_ASSERT(!empty());
	return *begin();
}

/**
 * @brief BasicBlock::back
 * @return
 */
BasicBlock::reference BasicBlock::back() {
	Q_ASSERT(!empty());
	return *rbegin();
}

/**
 * @brief BasicBlock::back
 * @return
 */
BasicBlock::const_reference BasicBlock::back() const {
	Q_ASSERT(!empty());
	return *rbegin();
}

/**
 * @brief BasicBlock::byteSize
 * @return
 */
BasicBlock::size_type BasicBlock::byteSize() const {
	size_type n = 0;
	for (const instruction_pointer &inst : instructions_) {
		n += inst->byteSize();
	}
	return n;
}

/**
 * @brief BasicBlock::firstAddress
 * @return
 */
edb::address_t BasicBlock::firstAddress() const {
	Q_ASSERT(!empty());
	return edb::address_t(front()->rva());
}

/**
 * @brief BasicBlock::lastAddress
 * @return
 */
edb::address_t BasicBlock::lastAddress() const {
	Q_ASSERT(!empty());
	return edb::address_t(back()->rva() + back()->byteSize());
}

/**
 * @brief BasicBlock::toString
 * @return
 */
QString BasicBlock::toString() const {
	QString text;
	QTextStream ts(&text);

	for (const instruction_pointer &inst : instructions_) {
		ts << edb::address_t(inst->rva()).toPointerString() << ": " << edb::v1::formatter().toString(*inst).c_str() << "\n";
	}

	return text;
}

/**
 * @brief BasicBlock::addReference
 * @param refsite
 * @param target
 */
void BasicBlock::addReference(edb::address_t refsite, edb::address_t target) {
	references_.push_back(std::make_pair(refsite, target));
}

/**
 * @brief BasicBlock::references
 * @return
 */
std::vector<std::pair<edb::address_t, edb::address_t>> BasicBlock::references() const {
	return references_;
}

```

`src/BinaryString.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "BinaryString.h"
#include "HexStringValidator.h"

#include <QStringList>

#include "ui_BinaryString.h"

namespace {

constexpr auto CharHexLength = 3; // "hh "

// magic numerator from Qt defaults
constexpr auto UnlimitedMaxLength = 32767 / CharHexLength;

}

/**
 * @brief BinaryString::setEntriesMaxLength
 * @param n
 */
void BinaryString::setEntriesMaxLength(int n) {

	ui->txtAscii->setMaxLength(n);
	ui->txtUTF16->setMaxLength(n / 2);
	ui->txtHex->setMaxLength(n * CharHexLength);
}

/**
 * @brief BinaryString::setMaxLength
 * @param n
 */
void BinaryString::setMaxLength(int n) {
	requestedMaxLength_ = n;
	if (n) {
		mode_ = Mode::LengthLimited;
		ui->keepSize->hide();
	} else {
		mode_ = Mode::MemoryEditing;
		n     = UnlimitedMaxLength;
		ui->keepSize->show();
	}
	setEntriesMaxLength(n);
}

/**
 * @brief BinaryString::BinaryString
 * @param parent
 * @param f
 */
BinaryString::BinaryString(QWidget *parent, Qt::WindowFlags f)
	: QWidget(parent, f), ui(new Ui::BinaryStringWidget) {

	ui->setupUi(this);
	ui->txtHex->setValidator(new HexStringValidator(this));
	ui->keepSize->setFocusPolicy(Qt::TabFocus);
	ui->txtHex->setFocus(Qt::OtherFocusReason);
	connect(ui->keepSize, &QCheckBox::stateChanged, this, &BinaryString::on_keepSize_stateChanged);
}

/**
 * @brief BinaryString::~BinaryString
 */
BinaryString::~BinaryString() {
	// NOTE(eteran): we CAN'T use std::unique_ptr here because it doesn't
	// support incomplete types
	delete ui;
}

/**
 * @brief BinaryString::on_keepSize_stateChanged
 * @param state
 */
void BinaryString::on_keepSize_stateChanged(int state) {

	Q_UNUSED(state)

	if (mode_ != Mode::MemoryEditing) return;

	// There's a comment in get_binary_string_from_user(), that max length must be set before value.
	// FIXME: do we need this here? What does "truncate incorrectly" mean there?
	// NOTE: not doing this for now
	if (ui->keepSize->checkState() == Qt::Unchecked)
		setEntriesMaxLength(UnlimitedMaxLength);
	else
		setEntriesMaxLength(valueOriginalLength_);
}

/**
 * @brief BinaryString::on_txtAscii_textEdited
 * @param text
 */
void BinaryString::on_txtAscii_textEdited(const QString &text) {

	const QByteArray p = text.toLatin1();
	QString textHex;
	QString textUTF16;
	QString temp;
	uint16_t utf16Char = 0;

	int counter = 0;

	for (uint8_t ch : p) {
		textHex += QString::asprintf("%02x ", ch & 0xff);
#if Q_BYTE_ORDER == Q_LITTLE_ENDIAN
		utf16Char = (utf16Char >> 8) | (ch << 8);
#else
		utf16Char = (utf16Char << 8) | ch;
#endif
		if (counter++ & 1) {
			textUTF16 += QChar(utf16Char);
		}
	}

	ui->txtHex->setText(textHex.simplified());
	ui->txtUTF16->setText(textUTF16);
}

/**
 * @brief BinaryString::on_txtUTF16_textEdited
 * @param text
 */
void BinaryString::on_txtUTF16_textEdited(const QString &text) {

	QString textAscii;
	QString textHex;
	QString temp;

	for (QChar i : text) {
		const uint16_t ch = i.unicode();

#if Q_BYTE_ORDER == Q_LITTLE_ENDIAN
		textAscii += ch & 0xff;
		textAscii += (ch >> 8) & 0xff;
		textHex += QString::asprintf("%02x %02x ", ch & 0xff, (ch >> 8) & 0xff);
#else
		textAscii += (ch >> 8) & 0xff;
		textAscii += ch & 0xff;
		textHex += QString::asprintf("%02x %02x ", (ch >> 8) & 0xff, ch & 0xff);
#endif
	}

	ui->txtHex->setText(textHex.simplified());
	ui->txtAscii->setText(textAscii);
}

/**
 * @brief BinaryString::on_txtHex_textEdited
 * @param text
 */
void BinaryString::on_txtHex_textEdited(const QString &text) {

	uint16_t utf16Char = 0;
	int counter        = 0;

	QString textAscii;
	QString textUTF16;

#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
	const QStringList list1 = text.split(" ", Qt::SkipEmptyParts);
#else
	const QStringList list1 = text.split(" ", QString::SkipEmptyParts);
#endif

	for (const QString &s : list1) {

		const uint8_t ch = s.toUInt(nullptr, 16);

#if Q_BYTE_ORDER == Q_LITTLE_ENDIAN
		utf16Char = (utf16Char >> 8) | (ch << 8);
#else
		utf16Char = (utf16Char << 8) | ch;
#endif

		textAscii += ch;

		if (counter++ & 1) {
			textUTF16 += QChar(utf16Char);
		}
	}

	ui->txtUTF16->setText(textUTF16);
	ui->txtAscii->setText(textAscii);
}

/**
 * @brief BinaryString::value
 * @return
 */
QByteArray BinaryString::value() const {

	QByteArray ret;
#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
	const QStringList list1 = ui->txtHex->text().split(" ", Qt::SkipEmptyParts);
#else
	const QStringList list1 = ui->txtHex->text().split(" ", QString::SkipEmptyParts);
#endif
	for (const QString &i : list1) {
		ret += static_cast<uint8_t>(i.toUInt(nullptr, 16));
	}

	return ret;
}

/**
 * @brief BinaryString::setValue
 * @param data
 */
void BinaryString::setValue(const QByteArray &data) {

	valueOriginalLength_ = data.size();
	on_keepSize_stateChanged(ui->keepSize->checkState());
	const auto temp = QString::fromLatin1(data.data(), data.size());

	ui->txtAscii->setText(temp);
	on_txtAscii_textEdited(temp);
}

/**
 * @brief BinaryString::setShowKeepSize
 * @param visible
 */
void BinaryString::setShowKeepSize(bool visible) {
	ui->keepSize->setVisible(visible);
}

/**
 * @brief BinaryString::showKeepSize
 * @return
 */
bool BinaryString::showKeepSize() const {
	return ui->keepSize->isVisible();
}

```

`src/BinaryString.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>BinaryStringWidget</class>
 <widget class="QWidget" name="BinaryStringWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>344</width>
    <height>105</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>BinaryString</string>
  </property>
  <layout class="QGridLayout">
   <item row="2" column="1">
    <widget class="QLineEdit" name="txtHex">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
    </widget>
   </item>
   <item row="0" column="1">
    <widget class="QLineEdit" name="txtAscii">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
    </widget>
   </item>
   <item row="1" column="0">
    <widget class="QLabel" name="lblUTF16">
     <property name="text">
      <string>UTF-16</string>
     </property>
     <property name="buddy">
      <cstring>txtUTF16</cstring>
     </property>
    </widget>
   </item>
   <item row="0" column="0">
    <widget class="QLabel" name="lblAscii">
     <property name="text">
      <string>ASCII</string>
     </property>
     <property name="buddy">
      <cstring>txtAscii</cstring>
     </property>
    </widget>
   </item>
   <item row="1" column="1">
    <widget class="QLineEdit" name="txtUTF16">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
    </widget>
   </item>
   <item row="2" column="0">
    <widget class="QLabel" name="lblHex">
     <property name="text">
      <string>Hex</string>
     </property>
     <property name="buddy">
      <cstring>txtHex</cstring>
     </property>
    </widget>
   </item>
   <item row="3" column="0" colspan="2">
    <widget class="QCheckBox" name="keepSize">
     <property name="text">
      <string>&amp;Keep size</string>
     </property>
     <property name="checked">
      <bool>true</bool>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>txtAscii</tabstop>
  <tabstop>txtUTF16</tabstop>
  <tabstop>txtHex</tabstop>
 </tabstops>
 <resources/>
 <connections/>
</ui>

```

`src/ByteShiftArray.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ByteShiftArray.h"
#include <climits>

//------------------------------------------------------------------------------
// Name: ByteShiftArray
// Desc: constructor
//------------------------------------------------------------------------------
ByteShiftArray::ByteShiftArray(int size)
	: maxSize_(size) {
}

//------------------------------------------------------------------------------
// Name: swap
// Desc:
//------------------------------------------------------------------------------
void ByteShiftArray::swap(ByteShiftArray &other) {
	using std::swap;
	swap(data_, other.data_);
	swap(maxSize_, other.maxSize_);
}

//------------------------------------------------------------------------------
// Name: shl
// Desc: shifts data left one byte and shifts in a 0
//------------------------------------------------------------------------------
ByteShiftArray &ByteShiftArray::shl() {

	if (data_.size() == maxSize_) {
		std::rotate(data_.begin(), data_.begin() + 1, data_.end());
		data_.back() = 0;
	} else {
		data_.push_back(0);
	}
	return *this;
}

//------------------------------------------------------------------------------
// Name: shr
// Desc: shifts data right one byte and shifts in a 0
//------------------------------------------------------------------------------
ByteShiftArray &ByteShiftArray::shr() {
	if (data_.size() == maxSize_) {
		for (int i = 0; i < data_.size() - 1; ++i) {
			data_[i + 1] = data_[i];
		}
		data_.first() = 0;
	} else {
		data_.push_front(0);
	}
	return *this;
}

//------------------------------------------------------------------------------
// Name: size
// Desc: returns size of this byte array
//------------------------------------------------------------------------------
int ByteShiftArray::size() const {
	return data_.size();
}

//------------------------------------------------------------------------------
// Name: operator[]
// Desc: returns and l-value version of an element in the byte array
//------------------------------------------------------------------------------
uint8_t &ByteShiftArray::operator[](std::size_t i) {
	Q_ASSERT(i < INT_MAX);
	return data_[static_cast<int>(i)];
}

//------------------------------------------------------------------------------
// Name: operator[]
// Desc: returns and r-value version of an element in the byte array
//------------------------------------------------------------------------------
uint8_t ByteShiftArray::operator[](std::size_t i) const {
	Q_ASSERT(i < INT_MAX);
	return data_[static_cast<int>(i)];
}

//------------------------------------------------------------------------------
// Name: data
// Desc: returns a read only pointer to the data this byte array holds
//------------------------------------------------------------------------------
const uint8_t *ByteShiftArray::data() const {
	return &data_[0];
}

//------------------------------------------------------------------------------
// Name: clear
// Desc: zeros out the byte array
//------------------------------------------------------------------------------
void ByteShiftArray::clear() {
	data_.fill(0);
}

//------------------------------------------------------------------------------
// Name: operator<<
// Desc:
//------------------------------------------------------------------------------
ByteShiftArray &ByteShiftArray::operator<<(uint8_t x) {
	shl();
	data_.back() = x;
	return *this;
}

```

`src/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)
include("GNUInstallDirs")

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)

find_package(Qt5 5.0.0 REQUIRED Widgets Xml XmlPatterns Svg)

qt5_add_resources(QRC_SOURCES
	res/debugger.qrc
	res/themes.qrc
	res/breeze-edb.qrc
	res/breeze-dark-edb.qrc
)

foreach(FILE IN LISTS QRC_SOURCES)
	set_property(SOURCE ${FILE} PROPERTY SKIP_UNITY_BUILD_INCLUSION ON)
endforeach()

set(edb_SRCS
	${QRC_SOURCES}

	BasicBlock.cpp
	BinaryString.cpp
	BinaryString.ui
	ByteShiftArray.cpp
	CommentServer.cpp
	CommentServer.h
	Configuration.cpp
	DataViewInfo.cpp
	DataViewInfo.h
	DebugEventHandlers.cpp
	DebugEventHandlers.h
	Debugger.cpp
	Debugger.h
	Debugger.ui
	DebuggerInternal.h
	DialogAbout.cpp
	DialogAbout.h
	DialogAbout.ui
	DialogArguments.cpp
	DialogArguments.h
	DialogArguments.ui
	DialogAttach.cpp
	DialogAttach.h
	DialogAttach.ui
	DialogInputBinaryString.cpp
	DialogInputBinaryString.h
	DialogInputBinaryString.ui
	DialogInputValue.cpp
	DialogInputValue.h
	DialogInputValue.ui
	DialogMemoryRegions.cpp
	DialogMemoryRegions.h
	DialogMemoryRegions.ui
	DialogOpenProgram.cpp
	DialogOpenProgram.h
	DialogOptions.cpp
	DialogOptions.h
	DialogOptions.ui
	DialogPlugins.cpp
	DialogPlugins.h
	DialogPlugins.ui
	DialogThreads.cpp
	DialogThreads.h
	DialogThreads.ui
	ExpressionDialog.cpp
	ExpressionDialog.h
	FixedFontSelector.cpp
	FixedFontSelector.h
	FixedFontSelector.ui
	FloatX.cpp
	Font.cpp
	Function.cpp
	HexStringValidator.cpp
	MemoryRegions.cpp
	PluginModel.cpp
	PluginModel.h
	ProcessModel.cpp
	ProcessModel.h
	QLongValidator.cpp
	QULongValidator.cpp
	RecentFileManager.cpp
	RecentFileManager.h
	RegionBuffer.cpp
	RegionBuffer.h
	Register.cpp
	RegisterViewModelBase.cpp
	State.cpp
	SymbolManager.cpp
	SymbolManager.h
	Theme.cpp
	ThreadsModel.cpp
	capstone-edb/Inspection.cpp
	capstone-edb/Instruction.cpp
	capstone-edb/include/Formatter.h
	capstone-edb/include/Inspection.h
	capstone-edb/include/Instruction.h
	capstone-edb/include/Operand.h
	edb.cpp
	main.cpp
	qhexview/QHexView
	qhexview/qhexview.cpp
	qhexview/qhexview.h
	session/SessionError.cpp
	session/SessionError.h
	session/SessionManager.cpp
	session/SessionManager.h
	widgets/NavigationHistory.cpp
	widgets/NavigationHistory.h
	widgets/QDisassemblyView.cpp
	widgets/QDisassemblyView.h
	widgets/RegisterViewDelegate.cpp
	widgets/RegisterViewDelegate.h
	widgets/SyntaxHighlighter.cpp
	widgets/SyntaxHighlighter.h
	widgets/TabWidget.cpp
	widgets/TabWidget.h

	${PROJECT_SOURCE_DIR}/include/API.h
	${PROJECT_SOURCE_DIR}/include/ArchProcessor.h
	${PROJECT_SOURCE_DIR}/include/BasicBlock.h
	${PROJECT_SOURCE_DIR}/include/BinaryString.h
	${PROJECT_SOURCE_DIR}/include/ByteShiftArray.h
	${PROJECT_SOURCE_DIR}/include/Configuration.h
	${PROJECT_SOURCE_DIR}/include/Expression.h
	${PROJECT_SOURCE_DIR}/include/FloatX.h
	${PROJECT_SOURCE_DIR}/include/Function.h
	${PROJECT_SOURCE_DIR}/include/HexStringValidator.h
	${PROJECT_SOURCE_DIR}/include/IAnalyzer.h
	${PROJECT_SOURCE_DIR}/include/IBinary.h
	${PROJECT_SOURCE_DIR}/include/IBreakpoint.h
	${PROJECT_SOURCE_DIR}/include/IDebugEvent.h
	${PROJECT_SOURCE_DIR}/include/IDebugEventHandler.h
	${PROJECT_SOURCE_DIR}/include/IDebugger.h
	${PROJECT_SOURCE_DIR}/include/IPlugin.h
	${PROJECT_SOURCE_DIR}/include/IProcess.h
	${PROJECT_SOURCE_DIR}/include/IRegion.h
	${PROJECT_SOURCE_DIR}/include/IState.h
	${PROJECT_SOURCE_DIR}/include/ISymbolGenerator.h
	${PROJECT_SOURCE_DIR}/include/ISymbolManager.h
	${PROJECT_SOURCE_DIR}/include/IThread.h
	${PROJECT_SOURCE_DIR}/include/Instruction.h
	${PROJECT_SOURCE_DIR}/include/MemoryRegions.h
	${PROJECT_SOURCE_DIR}/include/Module.h
	${PROJECT_SOURCE_DIR}/include/Patch.h
	${PROJECT_SOURCE_DIR}/include/Prototype.h
	${PROJECT_SOURCE_DIR}/include/QLongValidator.h
	${PROJECT_SOURCE_DIR}/include/QULongValidator.h
	${PROJECT_SOURCE_DIR}/include/QtHelper.h
	${PROJECT_SOURCE_DIR}/include/Register.h
	${PROJECT_SOURCE_DIR}/include/RegisterRef.h
	${PROJECT_SOURCE_DIR}/include/RegisterViewModelBase.h
	${PROJECT_SOURCE_DIR}/include/State.h
	${PROJECT_SOURCE_DIR}/include/Status.h
	${PROJECT_SOURCE_DIR}/include/Symbol.h
	${PROJECT_SOURCE_DIR}/include/Theme.h
	${PROJECT_SOURCE_DIR}/include/ThreadsModel.h
	${PROJECT_SOURCE_DIR}/include/Types.h
	${PROJECT_SOURCE_DIR}/include/Util.h
	${PROJECT_SOURCE_DIR}/include/Value.h
	${PROJECT_SOURCE_DIR}/include/edb.h
	${PROJECT_SOURCE_DIR}/include/string_hash.h
	${PROJECT_SOURCE_DIR}/include/util/Container.h
	${PROJECT_SOURCE_DIR}/include/util/Float.h
	${PROJECT_SOURCE_DIR}/include/util/Font.h
	${PROJECT_SOURCE_DIR}/include/util/Integer.h
	${PROJECT_SOURCE_DIR}/include/util/Math.h
	${PROJECT_SOURCE_DIR}/include/util/String.h
	${PROJECT_SOURCE_DIR}/include/util/Error.h
	${PROJECT_SOURCE_DIR}/include/version.h
)

if(TARGET_ARCH_FAMILY_X86)
	set(edb_SRCS
		${edb_SRCS}
		arch/x86-generic/ArchProcessor.cpp
		arch/x86-generic/RegisterViewModel.cpp
		arch/x86-generic/RegisterViewModel.h
		${PROJECT_SOURCE_DIR}/include/arch/x86-generic/ArchTypes.h
	)
elseif(TARGET_ARCH_FAMILY_ARM)
	set(edb_SRCS
		${edb_SRCS}
		arch/arm-generic/ArchProcessor.cpp
		arch/arm-generic/RegisterViewModel.cpp
		arch/arm-generic/RegisterViewModel.h
		${PROJECT_SOURCE_DIR}/include/arch/arm-generic/ArchTypes.h
	)
endif()

if(TARGET_PLATFORM_WINDOWS)
	enable_language(ASM_MASM)
	set(CMAKE_ASM_MASM_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /safeseh")

	set(edb_SRCS
		${edb_SRCS}
		LongDoubleX86.asm
		${PROJECT_SOURCE_DIR}/include/os/win32/OSTypes.h
	)
elseif(TARGET_PLATFORM_LINUX)
    set(edb_SRCS
        ${edb_SRCS}
		${PROJECT_SOURCE_DIR}/include/os/unix/OSTypes.h
        ${PROJECT_SOURCE_DIR}/include/os/unix/linux/linker.h
    )
endif()

if(GRAPHVIZ_FOUND)
	set(edb_SRCS
		${edb_SRCS}
		graph/GraphEdge.cpp
		graph/GraphicsScene.cpp
		graph/GraphicsScene.h
		graph/GraphNode.cpp
		graph/GraphWidget.cpp
		graph/GraphvizHelper.cpp
		graph/GraphvizHelper.h
		${PROJECT_SOURCE_DIR}/include/GraphWidget.h
		${PROJECT_SOURCE_DIR}/include/GraphEdge.h
		${PROJECT_SOURCE_DIR}/include/GraphNode.h
	)
endif()

add_executable(edb ${edb_SRCS})

if(GRAPHVIZ_FOUND)
	target_include_directories (edb
	PUBLIC
		${GRAPHVIZ_INCLUDE_DIRS}
	)

	target_link_libraries(edb
		${GRAPHVIZ_LIBRARIES}
	)
endif()

if(UNIX AND TARGET_ARCH_FAMILY_X86)
	# now we always have it :-)
	add_definitions("-DHAVE_GDTOA")
	if(GDTOA_FOUND)
		target_include_directories (edb
		PUBLIC
			${GDTOA_INCLUDE_DIRS}
		)

		target_link_libraries(edb
			${GDTOA_LIBRARIES}
		)
	else()
		target_link_libraries(edb
			gdtoa-desktop
		)
		
		add_dependencies(edb gdtoa_h)
	endif()
endif()

target_compile_definitions(edb PRIVATE
	-DDEFAULT_PLUGIN_PATH=\"${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}/edb\"
)

target_link_libraries(edb
	${CAPSTONE_LIBRARIES}
	Qt5::Widgets
	Qt5::Xml
	Qt5::XmlPatterns
	Qt5::Svg
	${DOUBLE_CONVERSION_LIBRARIES}
)

target_include_directories (edb PRIVATE
	"capstone-edb"
	"qhexview"
	"widgets"
	"session"
)


target_add_warnings(edb)

install (TARGETS edb DESTINATION ${CMAKE_INSTALL_BINDIR})

set_property(TARGET edb PROPERTY CXX_EXTENSIONS OFF)
set_property(TARGET edb PROPERTY CXX_STANDARD 17)
set_property(TARGET edb PROPERTY CXX_STANDARD_REQUIRED ON)
set_property(TARGET edb PROPERTY ENABLE_EXPORTS TRUE)
set_property(TARGET edb PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

add_subdirectory("${CMAKE_CURRENT_LIST_DIR}/test")

```

`src/CommentServer.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "CommentServer.h"
#include "Configuration.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "Instruction.h"
#include "edb.h"

namespace {

// a call can be anywhere from 2 to 7 bytes long depends on if there is a Mod/RM byte
// or a SIB byte, etc
// this is ignoring prefixes, fortunately, no calls have mandatory prefixes
// TODO(eteran): this is an arch specific concept
constexpr int CallMaxSize = 7;
constexpr int CallMinSize = 2;

}

/**
 * @brief CommentServer::setComment
 * @param address
 * @param comment
 */
void CommentServer::setComment(edb::address_t address, const QString &comment) {
	customComments_[address] = comment;
}

/**
 * @brief CommentServer::clear
 */
void CommentServer::clear() {
	customComments_.clear();
}

/**
 * @brief CommentServer::resolveFunctionCall
 * @param address
 * @return
 */
Result<QString, QString> CommentServer::resolveFunctionCall(edb::address_t address) const {

	// ok, we now want to locate the instruction before this one
	// so we need to look back a few bytes

	// TODO(eteran): portability warning, makes assumptions on the size of a call
	if (IProcess *process = edb::v1::debugger_core->process()) {

		uint8_t buffer[edb::Instruction::MaxSize];

		if (process->readBytes(address - CallMaxSize, buffer, sizeof(buffer))) {
			for (int i = (CallMaxSize - CallMinSize); i >= 0; --i) {
				edb::Instruction inst(buffer + i, buffer + sizeof(buffer), 0);
				if (is_call(inst)) {
					const QString symname = edb::v1::find_function_symbol(address);

					if (!symname.isEmpty()) {
						return tr("return to %1 <%2>").arg(edb::v1::format_pointer(address), symname);
					} else {
						return tr("return to %1").arg(edb::v1::format_pointer(address));
					}
				}
			}
		}
	}

	return make_unexpected(tr("Failed to resolve function call"));
}

/**
 * @brief CommentServer::resolveString
 * @param address
 * @return
 */
Result<QString, QString> CommentServer::resolveString(edb::address_t address) const {

	const int min_string_length   = edb::v1::config().min_string_length;
	constexpr int MaxStringLength = 256;

	int stringLen;
	QString temp;

	if (edb::v1::get_ascii_string_at_address(address, temp, min_string_length, MaxStringLength, stringLen)) {
		return tr("ASCII \"%1\"").arg(temp);
	} else if (edb::v1::get_utf16_string_at_address(address, temp, min_string_length, MaxStringLength, stringLen)) {
		return tr("UTF16 \"%1\"").arg(temp);
	}

	return make_unexpected(tr("Failed to resolve string"));
}

/**
 * @brief CommentServer::comment
 * @param address
 * @param size
 * @return
 */
QString CommentServer::comment(edb::address_t address, int size) const {

	if (IProcess *process = edb::v1::debugger_core->process()) {
		// if the view is currently looking at words which are a pointer in size
		// then see if it points to anything...
		if (size == static_cast<int>(edb::v1::pointer_size())) {
			edb::address_t value(0);
			if (process->readBytes(address, &value, edb::v1::pointer_size())) {

				auto it = customComments_.find(value);
				if (it != customComments_.end()) {
					return it.value();
				} else {
					if (Result<QString, QString> ret = resolveFunctionCall(value)) {
						return *ret;
					} else if (Result<QString, QString> ret = resolveString(value)) {
						return *ret;
					}
				}
			}
		}
	}

	return QString();
}

```

`src/CommentServer.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef COMMENT_SERVER_H_20070427_
#define COMMENT_SERVER_H_20070427_

#include "Status.h"
#include "Types.h"

#include <QCoreApplication>
#include <QHash>
#include <QString>

class CommentServer {
	Q_DECLARE_TR_FUNCTIONS(CommentServer)
public:
	void setComment(edb::address_t address, const QString &comment);
	QString comment(edb::address_t address, int size) const;
	void clear();

private:
	Result<QString, QString> resolveFunctionCall(edb::address_t address) const;
	Result<QString, QString> resolveString(edb::address_t address) const;

private:
	QHash<quint64, QString> customComments_;
};

#endif

```

`src/Configuration.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Configuration.h"
#include "edb.h"

#include <QCoreApplication>
#include <QDataStream>
#include <QDesktopServices>
#include <QDir>
#include <QFont>
#include <QSettings>
#include <QtDebug>

#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)

namespace {

QDataStream &operator<<(QDataStream &s, const IBreakpoint::TypeId &id) {
	return s << static_cast<int>(id);
}

QDataStream &operator>>(QDataStream &s, IBreakpoint::TypeId &id) {
	int value = 0;
	s >> value;
	id = static_cast<IBreakpoint::TypeId>(value);
	return s;
}

//------------------------------------------------------------------------------
// Name: getDefaultPluginPath
// Desc: return default path for plugins
//------------------------------------------------------------------------------
static QString getDefaultPluginPath() {
#ifdef DEFAULT_PLUGIN_PATH
	const QString default_plugin_path = DEFAULT_PLUGIN_PATH;
#else
	const QString edb_lib_dir    = QCoreApplication::applicationDirPath() + (EDB_IS_64_BIT ? "/../lib64/edb" : "/../lib/edb");
	const QString edb_binary_dir = QCoreApplication::applicationDirPath();
	// If the binary is in its installation directory, then look for plugins in their installation directory
	// Otherwise assume that we are in build directory, so the plugins are in the same directory as the binary
	const QString default_plugin_path = QRegExp(".*/bin/?$").exactMatch(edb_binary_dir) ? edb_lib_dir : edb_binary_dir;
#endif
	return default_plugin_path;
}

}

//------------------------------------------------------------------------------
// Name: Configuration
// Desc: constructor
//------------------------------------------------------------------------------
Configuration::Configuration(QObject *parent)
	: QObject(parent) {
	readSettings();
}

//------------------------------------------------------------------------------
// Name: ~Configuration
// Desc: destructor
//------------------------------------------------------------------------------
Configuration::~Configuration() {
	writeSettings();
}

//------------------------------------------------------------------------------
// Name: sendChangeNotification
// Desc: emits the settingsUpdated signal
//------------------------------------------------------------------------------
void Configuration::sendChangeNotification() {
	Q_EMIT settingsUpdated();
}

//------------------------------------------------------------------------------
// Name: read_settings
// Desc: read in the options from the file
//------------------------------------------------------------------------------
void Configuration::readSettings() {

	qRegisterMetaTypeStreamOperators<IBreakpoint::TypeId>("IBreakpoint::TypeId");

#ifdef Q_OS_WIN32
	const QString default_font = QFont("Courier New", 8).toString();
#elif defined(Q_OS_MACX)
	const QString default_font = QFont("Courier New", 10).toString();
#else
	const QString default_font = QFont("Monospace", 8).toString();
#endif

	QSettings settings;

	settings.beginGroup("General");
	close_behavior = static_cast<CloseBehavior>(settings.value("close_behavior").value<uint>());
	settings.endGroup();

	settings.beginGroup("Appearance");
	stack_font              = settings.value("appearance.stack.font", default_font).toString();
	data_font               = settings.value("appearance.data.font", default_font).toString();
	registers_font          = settings.value("appearance.registers.font", default_font).toString();
	disassembly_font        = settings.value("appearance.disassembly.font", default_font).toString();
	data_show_address       = settings.value("appearance.data.show_address.enabled", true).toBool();
	data_show_hex           = settings.value("appearance.data.show_hex.enabled", true).toBool();
	data_show_ascii         = settings.value("appearance.data.show_ascii.enabled", true).toBool();
	data_show_comments      = settings.value("appearance.data.show_comments.enabled", true).toBool();
	data_word_width         = settings.value("appearance.data.word_width", 1).value<int>();
	data_row_width          = settings.value("appearance.data.row_width", 16).value<int>();
	show_address_separator  = settings.value("appearance.address_colon.enabled", true).toBool();
	show_jump_arrow         = settings.value("appearance.show_jump_arrow.enabled", true).toBool();
	function_offsets_in_hex = settings.value("appearance.function_offsets_in_hex.enabled", false).toBool();
	theme_name              = settings.value("appearance.theme", "System").toString();

	settings.endGroup();

	settings.beginGroup("Debugging");
	initial_breakpoint      = static_cast<InitialBreakpoint>(settings.value("debugger.initial_breakpoint", MainSymbol).value<uint>());
	warn_on_no_exec_bp      = settings.value("debugger.BP_NX_warn.enabled", true).toBool();
	find_main               = settings.value("debugger.find_main.enabled", true).toBool();
	min_string_length       = settings.value("debugger.string_min", 4).value<uint>();
	tty_enabled             = settings.value("debugger.terminal.enabled", true).toBool();
	tty_command             = settings.value("debugger.terminal.command", "/usr/bin/xterm").toString();
	remove_stale_symbols    = settings.value("debugger.remove_stale_symbols.enabled", true).toBool();
	disableASLR             = settings.value("debugger.disableASLR.enabled", false).toBool();
	disableLazyBinding      = settings.value("debugger.disableLazyBinding.enabled", false).toBool();
	break_on_library_load   = settings.value("debugger.break_on_library_load_event.enabled", false).toBool();
	default_breakpoint_type = settings.value("debugger.default_breakpoint_type", QVariant::fromValue(IBreakpoint::TypeId::Automatic)).value<IBreakpoint::TypeId>();
	settings.endGroup();

	settings.beginGroup("Disassembly");
	syntax                                 = static_cast<Syntax>(settings.value("disassembly.syntax", Intel).value<uint>());
	syntax_highlighting_enabled            = settings.value("disassembly.syntax_highlighting_enabled", true).toBool();
	zeros_are_filling                      = settings.value("disassembly.zeros_are_filling.enabled", true).toBool();
	uppercase_disassembly                  = settings.value("disassembly.uppercase.enabled", false).toBool();
	small_int_as_decimal                   = settings.value("disassembly.small_int_as_decimal.enabled", false).toBool();
	tab_between_mnemonic_and_operands      = settings.value("disassembly.tab_between_mnemonic_and_operands.enabled", false).toBool();
	show_register_badges                   = settings.value("disassembly.show_register_badges.enabled", true).toBool();
	show_local_module_name_in_jump_targets = settings.value("disassembly.show_local_module_name_in_jump_targets.enabled", true).toBool();
	show_symbolic_addresses                = settings.value("disassembly.show_symbolic_addresses.enabled", true).toBool();
	simplify_rip_relative_targets          = settings.value("disassembly.simplify_rip_relative_targets.enabled", true).toBool();
	settings.endGroup();

	settings.beginGroup("Directories");

	QStringList cacheDirectories = QStandardPaths::standardLocations(QStandardPaths::CacheLocation);
	QString cacheDirectory       = !cacheDirectories.isEmpty() ? cacheDirectories[0] : QString();

	QString defaultSymbolPath  = QString("%1/%2").arg(cacheDirectory, "symbols");
	QString defaultSessionPath = QString("%1/%2").arg(cacheDirectory, "sessions");

	symbol_path  = settings.value("directory.symbol.path", defaultSymbolPath).toString();
	plugin_path  = settings.value("directory.plugin.path", getDefaultPluginPath()).toString();
	session_path = settings.value("directory.session.path", defaultSessionPath).toString();
	settings.endGroup();

	settings.beginGroup("Exceptions");
	enable_signals_message_box = settings.value("signals.show_message_box.enabled", true).toBool();

	QVariantList temp_ignored_exceptions = settings.value("signals.ignore_list", QVariantList()).toList();

	ignored_exceptions.clear();
	for (QVariant &exception : temp_ignored_exceptions) {
		ignored_exceptions.push_back(exception.toLongLong());
	}

	settings.endGroup();

	settings.beginGroup("Window");
	startup_window_location = static_cast<StartupWindowLocation>(settings.value("window.startup_window_location", SystemDefault).value<uint>());
	settings.endGroup();

	if (startup_window_location < 0 || startup_window_location > 2) {
		startup_window_location = SystemDefault;
	}

	// normalize values
	if (data_word_width != 1 && data_word_width != 2 && data_word_width != 4 && data_word_width != 8) {
		data_word_width = 1;
	}

	if (data_row_width != 1 && data_row_width != 2 && data_row_width != 4 && data_row_width != 8 && data_row_width != 16) {
		data_row_width = 16;
	}

	// Init capstone to some default settings
#if defined(EDB_X86) || defined(EDB_X86_64)
	CapstoneEDB::init(EDB_IS_64_BIT ? CapstoneEDB::Architecture::ARCH_AMD64 : CapstoneEDB::Architecture::ARCH_X86);
#elif defined(EDB_ARM32)
	CapstoneEDB::init(CapstoneEDB::Architecture::ARCH_ARM32_ARM);
#elif defined(EDB_ARM64)
	CapstoneEDB::init(CapstoneEDB::Architecture::ARCH_ARM64);
#else
#error "How to initialize Capstone?"
#endif
	CapstoneEDB::Formatter::FormatOptions options = edb::v1::formatter().options();
	options.capitalization                        = uppercase_disassembly ? CapstoneEDB::Formatter::UpperCase : CapstoneEDB::Formatter::LowerCase;
	options.syntax                                = static_cast<CapstoneEDB::Formatter::Syntax>(syntax);
	options.tabBetweenMnemonicAndOperands         = tab_between_mnemonic_and_operands;
	options.simplifyRIPRelativeTargets            = simplify_rip_relative_targets;
	edb::v1::formatter().setOptions(options);
}

//------------------------------------------------------------------------------
// Name: write_settings
// Desc: writes the options to the file
//------------------------------------------------------------------------------
void Configuration::writeSettings() {

	QSettings settings;

	settings.beginGroup("General");
	settings.setValue("close_behavior", close_behavior);
	settings.endGroup();

	settings.beginGroup("Appearance");
	settings.setValue("appearance.stack.font", stack_font);
	settings.setValue("appearance.data.font", data_font);
	settings.setValue("appearance.registers.font", registers_font);
	settings.setValue("appearance.disassembly.font", disassembly_font);
	settings.setValue("appearance.data.show_address.enabled", data_show_address);
	settings.setValue("appearance.data.show_hex.enabled", data_show_hex);
	settings.setValue("appearance.data.show_ascii.enabled", data_show_ascii);
	settings.setValue("appearance.data.show_comments.enabled", data_show_comments);
	settings.setValue("appearance.data.word_width", data_word_width);
	settings.setValue("appearance.data.row_width", data_row_width);
	settings.setValue("appearance.address_colon.enabled", show_address_separator);
	settings.setValue("appearance.show_jump_arrow.enabled", show_jump_arrow);
	settings.setValue("appearance.function_offsets_in_hex.enabled", function_offsets_in_hex);
	settings.setValue("appearance.theme", theme_name);
	settings.endGroup();

	settings.beginGroup("Debugging");
	settings.setValue("debugger.BP_NX_warn.enabled", warn_on_no_exec_bp);
	settings.setValue("debugger.string_min", min_string_length);
	settings.setValue("debugger.initial_breakpoint", initial_breakpoint);
	settings.setValue("debugger.find_main.enabled", find_main);
	settings.setValue("debugger.terminal.enabled", tty_enabled);
	settings.setValue("debugger.terminal.command", tty_command);
	settings.setValue("debugger.remove_stale_symbols.enabled", remove_stale_symbols);
	settings.setValue("debugger.disableASLR.enabled", disableASLR);
	settings.setValue("debugger.disableLazyBinding.enabled", disableLazyBinding);
	settings.setValue("debugger.break_on_library_load_event.enabled", break_on_library_load);
	settings.setValue("debugger.default_breakpoint_type", QVariant::fromValue(default_breakpoint_type));
	settings.endGroup();

	settings.beginGroup("Disassembly");
	settings.setValue("disassembly.syntax", syntax);
	settings.setValue("disassembly.syntax_highlighting_enabled", syntax_highlighting_enabled);
	settings.setValue("disassembly.zeros_are_filling.enabled", zeros_are_filling);
	settings.setValue("disassembly.uppercase.enabled", uppercase_disassembly);
	settings.setValue("disassembly.small_int_as_decimal.enabled", small_int_as_decimal);
	settings.setValue("disassembly.tab_between_mnemonic_and_operands.enabled", tab_between_mnemonic_and_operands);
	settings.setValue("disassembly.show_local_module_name_in_jump_targets.enabled", show_local_module_name_in_jump_targets);
	settings.setValue("disassembly.show_symbolic_addresses.enabled", show_symbolic_addresses);
	settings.setValue("disassembly.simplify_rip_relative_targets.enabled", simplify_rip_relative_targets);
	settings.setValue("disassembly.show_register_badges.enabled", show_register_badges);
	settings.endGroup();

	settings.beginGroup("Directories");
	settings.setValue("directory.symbol.path", symbol_path);
	if (plugin_path != getDefaultPluginPath()) {
		settings.setValue("directory.plugin.path", plugin_path);
	} else {
		settings.remove("directory.plugin.path");
	}
	settings.setValue("directory.session.path", session_path);
	settings.endGroup();

	settings.beginGroup("Exceptions");
	settings.setValue("signals.show_message_box.enabled", enable_signals_message_box);
	QVariantList temp_ignored_exceptions;

	Q_FOREACH (qlonglong exception, ignored_exceptions) {
		temp_ignored_exceptions.push_back(exception);
	}

	settings.setValue("signals.ignore_list", temp_ignored_exceptions);
	settings.endGroup();

	settings.beginGroup("Window");
	settings.setValue("window.startup_window_location", startup_window_location);
	settings.endGroup();
}

```

`src/DataViewInfo.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DataViewInfo.h"
#include "QHexView"
#include "RegionBuffer.h"

//------------------------------------------------------------------------------
// Name: DataViewInfo
// Desc:
//------------------------------------------------------------------------------
DataViewInfo::DataViewInfo(const std::shared_ptr<IRegion> &r)
	: region(r), stream(std::make_unique<RegionBuffer>(r)) {
}

DataViewInfo::DataViewInfo()
	: DataViewInfo(nullptr) {
}

//------------------------------------------------------------------------------
// Name: update
// Desc:
//------------------------------------------------------------------------------
void DataViewInfo::update() {

	Q_ASSERT(view);

	stream->setRegion(region);
	view->setAddressOffset(region->start());
	view->setData(stream.get());
}

```

`src/DataViewInfo.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DATA_VIEW_INFO_H_20100101_
#define DATA_VIEW_INFO_H_20100101_

#include <QtGlobal>
#include <memory>

class QHexView;
class RegionBuffer;
class IRegion;

class DataViewInfo {
public:
	explicit DataViewInfo(const std::shared_ptr<IRegion> &r);
	DataViewInfo();
	DataViewInfo(const DataViewInfo &) = delete;
	DataViewInfo &operator=(const DataViewInfo &) = delete;
	~DataViewInfo()                               = default;

public:
	std::shared_ptr<IRegion> region;
	std::shared_ptr<QHexView> view;
	std::unique_ptr<RegionBuffer> stream;

public:
	void update();
};

#endif

```

`src/DebugEventHandlers.cpp`:

```cpp
/*
Copyright (C) 2018 Ivan Sorokin
                   vanyacpp@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DebugEventHandlers.h"
#include "IDebugEventHandler.h"
#include "util/Error.h"

DebugEventHandlers::~DebugEventHandlers() {
	if (currentHandler_) {
		EDB_PRINT_AND_DIE("can not destroy debug events container while executing events");
	}

	if (!handlers_.empty()) {
		EDB_PRINT_AND_DIE("some debug event handlers weren't property removed");
	}
}

void DebugEventHandlers::add(IDebugEventHandler *handler) {
	if (!handler) {
		EDB_PRINT_AND_DIE("event handler can not be nullptr");
	}

	auto it = std::find(handlers_.begin(), handlers_.end(), handler);
	if (it != handlers_.end()) {
		EDB_PRINT_AND_DIE("the same event handler is added twice");
	}

	// DebugEventHandlers::add can be called inside DebugEventHandlers::execute.
	// Let's insert the handler in front so it is not called on the
	// event currently being executed
	handlers_.push_front(handler);
}

void DebugEventHandlers::remove(IDebugEventHandler *handler) {
	if (!handler) {
		EDB_PRINT_AND_DIE("event handler can not be nullptr");
	}

	auto it = std::find(handlers_.begin(), handlers_.end(), handler);
	if (it == handlers_.end()) {
		EDB_PRINT_AND_DIE("removal of an event that is not present");
	}

	// during execution only deletion of the current handler is supported
	if (currentHandler_ && currentHandler_ != handler) {
		EDB_PRINT_AND_DIE("removal of non-current event handler during execution");
	}

	handlers_.erase(it);
}

edb::EventStatus DebugEventHandlers::execute(const std::shared_ptr<IDebugEvent> &event) {
	if (currentHandler_) {
		EDB_PRINT_AND_DIE("recursive debug event execution is not allowed");
	}

	// if somehow no handler is run, then let's just assume we should stop...
	edb::EventStatus status = edb::DEBUG_STOP;

	try {
		// loop through all of the handlers, stopping when one thinks that it handled
		// the event
		for (auto it = handlers_.begin(), end = handlers_.end(); it != end;) {
			// increment before processing, so if it's deleted it's not a problem
			currentHandler_ = *it++;
			status          = currentHandler_->handleEvent(event);
			if (status != edb::DEBUG_NEXT_HANDLER) {
				break;
			}
		}
	} catch (...) {
		// reset current_handler_ to nullptr even if an exception was thrown
		currentHandler_ = nullptr;
		throw;
	}

	currentHandler_ = nullptr;

	// if this assert fails, the bottom handler (which is owned by us) did something terribly wrong :-/
	if (status == edb::DEBUG_NEXT_HANDLER) {
		EDB_PRINT_AND_DIE("the last event handler returned DEBUG_NEXT_HANDLER");
	}

	return status;
}

```

`src/DebugEventHandlers.h`:

```h
/*
Copyright (C) 2018 Ivan Sorokin
                   vanyacpp@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DEBUG_EVENT_HANDLERS_H_20180312_
#define DEBUG_EVENT_HANDLERS_H_20180312_

#include "Types.h"
#include <list>
#include <memory>

class IDebugEventHandler;
class IDebugEvent;

/*
This class is a container of IDebugEventHandler*. It supports three
operations:
1. add -- Adding IDebugEventHandler*
2. remove -- Removing IDebugEventHandler*
3. execute -- Iterating over added handlers and calling them

The reason why a simple standard container is not enough is that
handlers can be added/removed while the list is being iterated on.
Naive implement would cause accessing an invalid iterator in this
case.

This class supports adding new handlers during iteration. Removing
during iteration is also supported, but is restricted: only the
handler that is currectly being executed can be removed.

In order to support removing handlers during iteration the iterator
is incremented before calling corresponding handler.

Recursive calls to execute are forbidden.

Contract violations of this class are unrecoverable and cause
program termination (std::abort is called).
*/
class DebugEventHandlers {
public:
	DebugEventHandlers()                           = default;
	DebugEventHandlers(const DebugEventHandlers &) = delete;
	DebugEventHandlers &operator=(const DebugEventHandlers &) = delete;
	~DebugEventHandlers();

	void add(IDebugEventHandler *handler);
	void remove(IDebugEventHandler *handler);
	edb::EventStatus execute(const std::shared_ptr<IDebugEvent> &event);

private:
	/*
	list of registed handlers
	*/
	std::list<IDebugEventHandler *> handlers_;

	/*
	the current handler that is being executed
	nullptr means that none is being executed at the moment
	*/
	IDebugEventHandler *currentHandler_ = nullptr;
};

#endif

```

`src/Debugger.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Debugger.h"
#include "ArchProcessor.h"
#include "CommentServer.h"
#include "Configuration.h"
#include "DebuggerInternal.h"
#include "DialogAbout.h"
#include "DialogArguments.h"
#include "DialogAttach.h"
#include "DialogMemoryRegions.h"
#include "DialogOpenProgram.h"
#include "DialogOptions.h"
#include "DialogPlugins.h"
#include "DialogThreads.h"
#include "Expression.h"
#include "IAnalyzer.h"
#include "IBinary.h"
#include "IBreakpoint.h"
#include "IDebugEvent.h"
#include "IDebugger.h"
#include "IPlugin.h"
#include "IProcess.h"
#include "IThread.h"
#include "Instruction.h"
#include "MemoryRegions.h"
#include "QHexView"
#include "RecentFileManager.h"
#include "RegionBuffer.h"
#include "RegisterViewModelBase.h"
#include "SessionError.h"
#include "SessionManager.h"
#include "State.h"
#include "Symbol.h"
#include "SymbolManager.h"
#include "Theme.h"
#include "edb.h"

#if defined(Q_OS_LINUX)
#include "linker.h"
#endif

#include <QCloseEvent>
#include <QDateTime>
#include <QDesktopServices>
#include <QDesktopWidget>
#include <QDir>
#include <QDragEnterEvent>
#include <QDropEvent>
#include <QFileDialog>
#include <QFileInfo>
#include <QHBoxLayout>
#include <QInputDialog>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonParseError>
#include <QLabel>
#include <QMessageBox>
#include <QMimeData>
#include <QScreen>
#include <QSettings>
#include <QShortcut>
#include <QSplitter>
#include <QStringListModel>
#include <QTimer>
#include <QToolButton>
#include <QUrl>
#include <QVector>
#include <QtDebug>

#include <clocale>
#include <cstring>
#include <memory>
#include <random>

#if defined(Q_OS_UNIX)
#include <signal.h>
#endif

#include <sys/stat.h>
#include <sys/types.h>
#if defined(Q_OS_LINUX) || defined(Q_OS_OPENBSD) || defined(Q_OS_FREEBSD)
#include <fcntl.h>
#include <unistd.h>
#endif

namespace {

QPlainTextEdit *logger_instance = nullptr;

constexpr quint64 initial_bp_tag    = Q_UINT64_C(0x494e4954494e5433); // "INITINT3" in hex
constexpr quint64 stepover_bp_tag   = Q_UINT64_C(0x535445504f564552); // "STEPOVER" in hex
constexpr quint64 run_to_cursor_tag = Q_UINT64_C(0x474f544f48455245); // "GOTOHERE" in hex
#ifdef Q_OS_LINUX
constexpr quint64 ld_loader_tag = Q_UINT64_C(0x4c49424556454e54); // "LIBEVENT" in hex
#endif

template <class Addr>
void handle_library_event(IProcess *process, edb::address_t debug_pointer) {
#ifdef Q_OS_LINUX
	edb::linux_struct::r_debug<Addr> dynamic_info;
	const bool ok = (process->readBytes(debug_pointer, &dynamic_info, sizeof(dynamic_info)) == sizeof(dynamic_info));
	if (ok) {

		// NOTE(eteran): at least on my system, the name of
		//               what is being loaded is either in
		//               r8 or r13 depending on which event
		//               we are looking at.
		// TODO(eteran): find a way to get the name reliably

		switch (dynamic_info.r_state) {
		case edb::linux_struct::r_debug<Addr>::RT_CONSISTENT:
			// TODO(eteran): enable this once we are confident
#if 0
			edb::v1::memory_regions().sync();
#endif
			break;
		case edb::linux_struct::r_debug<Addr>::RT_ADD:
			// qDebug("LIBRARY LOAD EVENT");
			break;
		case edb::linux_struct::r_debug<Addr>::RT_DELETE:
			// qDebug("LIBRARY UNLOAD EVENT");
			break;
		}
	}
#else
	Q_UNUSED(process)
	Q_UNUSED(debug_pointer)
#endif
}

template <class Addr>
edb::address_t find_linker_hook_address(IProcess *process, edb::address_t debug_pointer) {
#ifdef Q_OS_LINUX
	edb::linux_struct::r_debug<Addr> dynamic_info;
	const bool ok = process->readBytes(debug_pointer, &dynamic_info, sizeof(dynamic_info));
	if (ok) {
		return edb::address_t::fromZeroExtended(dynamic_info.r_brk);
	}
#else
	Q_UNUSED(process)
	Q_UNUSED(debug_pointer)
#endif
	return edb::address_t(0);
}

//--------------------------------------------------------------------------
// Name: is_instruction_ret
//--------------------------------------------------------------------------
bool is_instruction_ret(edb::address_t address) {

	uint8_t buffer[edb::Instruction::MaxSize];
	if (const int size = edb::v1::get_instruction_bytes(address, buffer)) {
		edb::Instruction inst(buffer, buffer + size, address);
		return is_ret(inst);
	}
	return false;
}

class RunUntilRet : public IDebugEventHandler {
	Q_DECLARE_TR_FUNCTIONS(RunUntilRet)

public:
	//--------------------------------------------------------------------------
	// Name: RunUntilRet
	//--------------------------------------------------------------------------
	RunUntilRet() {
		edb::v1::add_debug_event_handler(this);
	}

	//--------------------------------------------------------------------------
	// Name: ~RunUntilRet
	//--------------------------------------------------------------------------
	~RunUntilRet() override {
		edb::v1::remove_debug_event_handler(this);

		for (const auto &bp : ownBreakpoints_) {
			if (!bp.second.expired()) {
				edb::v1::debugger_core->removeBreakpoint(bp.first);
			}
		}
	}

	//--------------------------------------------------------------------------
	// Name: pass_back_to_debugger
	// Desc: Makes the previous handler the event handler again and deletes this.
	//--------------------------------------------------------------------------
	virtual edb::EventStatus pass_back_to_debugger() {
		delete this;
		return edb::DEBUG_NEXT_HANDLER;
	}

	//--------------------------------------------------------------------------
	// Name: handle_event
	//--------------------------------------------------------------------------
	// TODO: Need to handle stop/pause button
	edb::EventStatus handleEvent(const std::shared_ptr<IDebugEvent> &event) override {

		if (!event->isTrap()) {
			return pass_back_to_debugger();
		}

		if (IProcess *process = edb::v1::debugger_core->process()) {

			State state;
			process->currentThread()->getState(&state);

			edb::address_t address               = state.instructionPointer();
			IDebugEvent::TRAP_REASON trap_reason = event->trapReason();
			IDebugEvent::REASON reason           = event->reason();

			qDebug() << QString("Event at address 0x%1").arg(address, 0, 16);

			/*
			 * An IDebugEvent::TRAP_BREAKPOINT can happen for the following reasons:
			 * 1. We hit a user-set breakpoint.
			 * 2. We hit an internal breakpoint due to our RunUntilRet algorithm.
			 * 3. We hit a syscall (this shouldn't be; it may be a ptrace bug).
			 * 4. We have exited in some form or another.
			 * First check for exit, then breakpoint (user-set, then internal; adjust for RIP in both cases),
			 * then finally for the syscall bug.
			 */
			if (trap_reason == IDebugEvent::TRAP_BREAKPOINT) {
				qDebug() << "Trap breakpoint";

				// Take care of exit/terminated conditions; address == 0 may suffice to catch all, but not 100% sure.
				if (reason == IDebugEvent::EVENT_EXITED || reason == IDebugEvent::EVENT_TERMINATED || address == 0) {
					qDebug() << "The process is no longer running.";
					return pass_back_to_debugger();
				}

				// Check the previous byte for 0xcc to see if it was an actual breakpoint
				std::shared_ptr<IBreakpoint> bp = edb::v1::find_triggered_breakpoint(address);

				// If there was a bp there, then we hit a block terminator as part of our RunUntilRet
				// algorithm, or it is a user-set breakpoint.
				if (bp && bp->enabled()) { // Isn't it always enabled if trap_reason is breakpoint, anyway?

					const edb::address_t prev_address = bp->address();

					bp->hit();

					// Adjust RIP since 1st byte was replaced with 0xcc and we are now 1 byte after it.
					state.setInstructionPointer(prev_address);
					process->currentThread()->setState(state);
					address = prev_address;

					// If it wasn't internal, it was a user breakpoint. Pass back to Debugger.
					if (!bp->internal()) {
						qDebug() << "Previous was not an internal breakpoint.";
						return pass_back_to_debugger();
					}
					qDebug() << "Previous was an internal breakpoint.";
					bp->disable();
					edb::v1::debugger_core->removeBreakpoint(bp->address());
				} else {
					// No breakpoint if it was a syscall; continue.
					return edb::DEBUG_CONTINUE;
				}
			}

			// If we are on our ret (or the instr after?), then ret.
			if (address == returnAddress_) {
				qDebug() << QString("On our terminator at 0x%1").arg(address, 0, 16);
				if (is_instruction_ret(address)) {
					qDebug() << "Found ret; passing back to debugger";
					return pass_back_to_debugger();
				} else {
					// If not a ret, then step so we can find the next block terminator.
					qDebug() << "Not ret. Single-stepping";
					return edb::DEBUG_CONTINUE_STEP;
				}
			}

			// If we stepped (either because it was the first event or because we hit a jmp/jcc),
			// then find the next block terminator and edb::DEBUG_CONTINUE.
			// TODO: What if we started on a ret? Set bp, then the proc runs away?
			uint8_t buffer[edb::Instruction::MaxSize];
			while (const int size = edb::v1::get_instruction_bytes(address, buffer)) {

				// Get the instruction
				edb::Instruction inst(buffer, buffer + size, 0);
				qDebug() << QString("Scanning for terminator at 0x%1: found %2").arg(address, 0, 16).arg(inst.mnemonic().c_str());

				// Check if it's a proper block terminator (ret/jmp/jcc/hlt)
				if (inst) {
					if (is_terminator(inst)) {
						qDebug() << QString("Found terminator %1 at 0x%2").arg(QString(inst.mnemonic().c_str())).arg(address, 0, 16);
						// If we already had a breakpoint there, then just continue.
						if (std::shared_ptr<IBreakpoint> bp = edb::v1::debugger_core->findBreakpoint(address)) {
							qDebug() << QString("Already a breakpoint at terminator 0x%1").arg(address, 0, 16);
							return edb::DEBUG_CONTINUE;
						}

						// Otherwise, attempt to set a breakpoint there and continue.
						if (std::shared_ptr<IBreakpoint> bp = edb::v1::debugger_core->addBreakpoint(address)) {
							ownBreakpoints_.emplace_back(address, bp);
							qDebug() << QString("Setting breakpoint at terminator 0x%1").arg(address, 0, 16);
							bp->setInternal(true);
							bp->setOneTime(true); // If the 0xcc get's rm'd on next event, then
												  // don't set it one time; we'll hande it manually
							returnAddress_ = address;
							return edb::DEBUG_CONTINUE;
						} else {
							QMessageBox::critical(edb::v1::debugger_ui,
												  tr("Error running until return"),
												  tr("Failed to set breakpoint on a block terminator at address %1.").arg(address.toPointerString()));
							return pass_back_to_debugger();
						}
					}
				} else {
					// Invalid instruction or some other problem. Pass it back to the debugger.
					QMessageBox::critical(edb::v1::debugger_ui,
										  tr("Error running until return"),
										  tr("Failed to disassemble instruction at address %1.").arg(address.toPointerString()));
					return pass_back_to_debugger();
				}

				address += inst.byteSize();
			}

			// If we end up out here, we've got bigger problems. Pass it back to the debugger.
			QMessageBox::critical(edb::v1::debugger_ui,
								  tr("Error running until return"),
								  tr("Stepped outside the loop, address=%1.").arg(address.toPointerString()));
			return pass_back_to_debugger();
		}

		qDebug() << "The process is no longer running.";
		return pass_back_to_debugger();
	}

private:
	std::vector<std::pair<edb::address_t, std::weak_ptr<IBreakpoint>>> ownBreakpoints_;
	edb::address_t lastCallReturn_ = 0;
	edb::address_t returnAddress_  = 0;
};

}

//------------------------------------------------------------------------------
// Name: Debugger
// Desc:
//------------------------------------------------------------------------------
Debugger::Debugger(QWidget *parent)
	: QMainWindow(parent),
	  ttyProc_(new QProcess(this)),
	  argumentsDialog_(new DialogArguments),
	  timer_(new QTimer(this)),
	  recentFileManager_(new RecentFileManager(this)),
	  stackViewInfo_(nullptr),
	  commentServer_(std::make_shared<CommentServer>()) {

	setupUi();

	// connect the timer to the debug event
	connect(timer_, &QTimer::timeout, this, &Debugger::nextDebugEvent);

	// create a context menu for the tab bar as well
	connect(tabWidget_, &TabWidget::customContextMenuRequested, this, &Debugger::tabContextMenu);

	// CPU Shortcuts
	gotoAddressAction_ = createAction(tr("&Goto Expression..."), QKeySequence(tr("Ctrl+G")), &Debugger::gotoTriggered);

	editCommentAction_           = createAction(tr("Add &Comment..."), QKeySequence(tr(";")), &Debugger::mnuCPUEditComment);
	toggleBreakpointAction_      = createAction(tr("&Toggle Breakpoint"), QKeySequence(tr("F2")), &Debugger::mnuCPUToggleBreakpoint);
	conditionalBreakpointAction_ = createAction(tr("Add &Conditional Breakpoint"), QKeySequence(tr("Shift+F2")), &Debugger::mnuCPUAddConditionalBreakpoint);
	runToThisLineAction_         = createAction(tr("R&un to this Line"), QKeySequence(tr("F4")), &Debugger::mnuCPURunToThisLine);
	runToLinePassAction_         = createAction(tr("Run to this Line (Pass Signal To Application)"), QKeySequence(tr("Shift+F4")), &Debugger::mnuCPURunToThisLinePassSignal);
	editBytesAction_             = createAction(tr("Binary &Edit..."), QKeySequence(tr("Ctrl+E")), &Debugger::mnuModifyBytes);
	fillWithZerosAction_         = createAction(tr("&Fill with 00's"), QKeySequence(), &Debugger::mnuCPUFillZero);
	fillWithNOPsAction_          = createAction(tr("Fill with &NOPs"), QKeySequence(), &Debugger::mnuCPUFillNop);
	setAddressLabelAction_       = createAction(tr("Set &Label..."), QKeySequence(tr(":")), &Debugger::mnuCPULabelAddress);
	followConstantInDumpAction_  = createAction(tr("Follow Constant In &Dump"), QKeySequence(), &Debugger::mnuCPUFollowInDump);
	followConstantInStackAction_ = createAction(tr("Follow Constant In &Stack"), QKeySequence(), &Debugger::mnuCPUFollowInStack);

	followAction_ = createAction(tr("&Follow"), QKeySequence(tr("Return")), [this]() {
		QWidget *const widget = QApplication::focusWidget();
		if (qobject_cast<QDisassemblyView *>(widget)) {
			mnuCPUFollow();
		} else {
			QKeyEvent *event = new QKeyEvent(QEvent::KeyPress, Qt::Key_Enter, Qt::NoModifier);
			QCoreApplication::postEvent(widget, event);
		}
	});

	// these get updated when we attach/run a new process, so it's OK to hard code them here
#if defined(EDB_X86_64)
	setRIPAction_  = createAction(tr("&Set %1 to this Instruction").arg("RIP"), QKeySequence(tr("Ctrl+*")), &Debugger::mnuCPUSetEIP);
	gotoRIPAction_ = createAction(tr("&Goto %1").arg("RIP"), QKeySequence(tr("*")), &Debugger::mnuCPUJumpToEIP);
#elif defined(EDB_X86)
	setRIPAction_       = createAction(tr("&Set %1 to this Instruction").arg("EIP"), QKeySequence(tr("Ctrl+*")), &Debugger::mnuCPUSetEIP);
	gotoRIPAction_      = createAction(tr("&Goto %1").arg("EIP"), QKeySequence(tr("*")), &Debugger::mnuCPUJumpToEIP);
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	setRIPAction_       = createAction(tr("&Set %1 to this Instruction").arg("PC"), QKeySequence(tr("Ctrl+*")), &Debugger::mnuCPUSetEIP);
	gotoRIPAction_      = createAction(tr("&Goto %1").arg("PC"), QKeySequence(tr("*")), &Debugger::mnuCPUJumpToEIP);
#else
#error "This doesn't initialize actions and will lead to crash"
#endif

	// Data Dump Shorcuts
	dumpFollowInCPUAction_   = createAction(tr("Follow Address In &CPU"), QKeySequence(), &Debugger::mnuDumpFollowInCPU);
	dumpFollowInDumpAction_  = createAction(tr("Follow Address In &Dump"), QKeySequence(), &Debugger::mnuDumpFollowInDump);
	dumpFollowInStackAction_ = createAction(tr("Follow Address In &Stack"), QKeySequence(), &Debugger::mnuDumpFollowInStack);
	dumpSaveToFileAction_    = createAction(tr("&Save To File"), QKeySequence(), &Debugger::mnuDumpSaveToFile);

	// Register View Shortcuts
	registerFollowInDumpAction_    = createAction(tr("&Follow In Dump"), QKeySequence(), &Debugger::mnuRegisterFollowInDump);
	registerFollowInDumpTabAction_ = createAction(tr("&Follow In Dump (New Tab)"), QKeySequence(), &Debugger::mnuRegisterFollowInDumpNewTab);
	registerFollowInStackAction_   = createAction(tr("&Follow In Stack"), QKeySequence(), &Debugger::mnuRegisterFollowInStack);

	// Stack View Shortcuts
	stackFollowInCPUAction_   = createAction(tr("Follow Address In &CPU"), QKeySequence(), &Debugger::mnuStackFollowInCPU);
	stackFollowInDumpAction_  = createAction(tr("Follow Address In &Dump"), QKeySequence(), &Debugger::mnuStackFollowInDump);
	stackFollowInStackAction_ = createAction(tr("Follow Address In &Stack"), QKeySequence(), &Debugger::mnuStackFollowInStack);

	// these get updated when we attach/run a new process, so it's OK to hard code them here
#if defined(EDB_X86_64)
	stackGotoRSPAction_ = createAction(tr("Goto %1").arg("RSP"), QKeySequence(), &Debugger::mnuStackGotoESP);
	stackGotoRBPAction_ = createAction(tr("Goto %1").arg("RBP"), QKeySequence(), &Debugger::mnuStackGotoEBP);
	stackPushAction_    = createAction(tr("&Push %1").arg("QWORD"), QKeySequence(), &Debugger::mnuStackPush);
	stackPopAction_     = createAction(tr("P&op %1").arg("QWORD"), QKeySequence(), &Debugger::mnuStackPop);
#elif defined(EDB_X86)
	stackGotoRSPAction_ = createAction(tr("Goto %1").arg("ESP"), QKeySequence(), &Debugger::mnuStackGotoESP);
	stackGotoRBPAction_ = createAction(tr("Goto %1").arg("EBP"), QKeySequence(), &Debugger::mnuStackGotoEBP);
	stackPushAction_    = createAction(tr("&Push %1").arg("DWORD"), QKeySequence(), &Debugger::mnuStackPush);
	stackPopAction_     = createAction(tr("P&op %1").arg("DWORD"), QKeySequence(), &Debugger::mnuStackPop);
#elif defined(EDB_ARM32)
	stackGotoRSPAction_ = createAction(tr("Goto %1").arg("SP"), QKeySequence(), &Debugger::mnuStackGotoESP);
	stackGotoRBPAction_ = createAction(tr("Goto %1").arg("FP"), QKeySequence(), &Debugger::mnuStackGotoEBP);
	stackGotoRBPAction_->setDisabled(true); // FIXME(ARM): this just stubs it out since it likely won't really work
	stackPushAction_ = createAction(tr("&Push %1").arg("DWORD"), QKeySequence(), &Debugger::mnuStackPush);
	stackPushAction_->setDisabled(true); // FIXME(ARM): this just stubs it out since it likely won't really work
	stackPopAction_ = createAction(tr("P&op %1").arg("DWORD"), QKeySequence(), &Debugger::mnuStackPop);
	stackPopAction_->setDisabled(true); // FIXME(ARM): this just stubs it out since it likely won't really work
#elif defined(EDB_ARM64)
	stackGotoRSPAction_ = createAction(tr("Goto %1").arg("SP"), QKeySequence(), &Debugger::mnuStackGotoESP);
	stackGotoRSPAction_->setDisabled(true); // FIXME(ARM): this just stubs it out since it likely won't really work
	stackGotoRBPAction_ = createAction(tr("Goto %1").arg("FP"), QKeySequence(), &Debugger::mnuStackGotoEBP);
	stackGotoRBPAction_->setDisabled(true); // FIXME(ARM): this just stubs it out since it likely won't really work
	stackPushAction_ = createAction(tr("&Push %1").arg("QWORD"), QKeySequence(), &Debugger::mnuStackPush);
	stackPushAction_->setDisabled(true); // FIXME(ARM): this just stubs it out since it likely won't really work
	stackPopAction_ = createAction(tr("P&op %1").arg("QWORD"), QKeySequence(), &Debugger::mnuStackPop);
	stackPopAction_->setDisabled(true); // FIXME(ARM): this just stubs it out since it likely won't really work
#else
#error "This doesn't initialize actions and will lead to crash"
#endif

	// set these to have no meaningful "data" (yet)
	followConstantInDumpAction_->setData(qlonglong(0));
	followConstantInStackAction_->setData(qlonglong(0));

	setAcceptDrops(true);

	// setup the list model for instruction details list
	listModel_ = new QStringListModel(this);
	listView_->setModel(listModel_);

	// setup the recent file manager
	ui.action_Recent_Files->setMenu(recentFileManager_->createMenu());
	connect(recentFileManager_, &RecentFileManager::fileSelected, this, &Debugger::openFile);

	// make us the default event handler
	edb::v1::add_debug_event_handler(this);

	// enable the arch processor
#if 0
	ui.registerList->setModel(&edb::v1::arch_processor().get_register_view_model());
	edb::v1::arch_processor().setup_register_view();
#endif

	// default the working directory to ours
	workingDirectory_ = QDir().absolutePath();

	// let the plugins setup their menus
	finishPluginSetup();

	// Make sure number formatting and reading code behaves predictably when using standard C++ facilities.
	// NOTE: this should only be done after the plugins have finished loading, since some dynamic libraries
	// (e.g. libkdecore), which are indirectly loaded by the plugins, re-set locale to "" once again. (This
	// first time is QApplication.)
	std::setlocale(LC_NUMERIC, "C");
}

//------------------------------------------------------------------------------
// Name: ~Debugger
// Desc:
//------------------------------------------------------------------------------
Debugger::~Debugger() {

	for (QObject *plugin : edb::v1::plugin_list()) {
		if (auto p = qobject_cast<IPlugin *>(plugin)) {
			p->fini();
		}
	}

	// kill our xterm and wait for it to die
	ttyProc_->kill();
	ttyProc_->waitForFinished(3000);
	edb::v1::remove_debug_event_handler(this);
}

template <class F>
QAction *Debugger::createAction(const QString &text, const QKeySequence &keySequence, F func) {
	auto action = new QAction(text, this);
	action->setShortcut(keySequence);
	addAction(action);
	connect(action, &QAction::triggered, this, func);
	return action;
}

//------------------------------------------------------------------------------
// Name: update_menu_state
// Desc:
//------------------------------------------------------------------------------
void Debugger::updateMenuState(GuiState state) {

	switch (state) {
	case Paused:
		ui.actionRun_Until_Return->setEnabled(true);
		ui.action_Restart->setEnabled(true);
		ui.action_Run->setEnabled(true);
		ui.action_Pause->setEnabled(false);
		ui.action_Step_Into->setEnabled(true);
		ui.action_Step_Over->setEnabled(true);
		ui.actionStep_Out->setEnabled(true);
		ui.action_Step_Into_Pass_Signal_To_Application->setEnabled(true);
		ui.action_Step_Over_Pass_Signal_To_Application->setEnabled(true);
		ui.action_Run_Pass_Signal_To_Application->setEnabled(true);
		ui.action_Detach->setEnabled(true);
		ui.action_Kill->setEnabled(true);
		tabCreate_->setEnabled(true);
		status_->setText(tr("paused"));
		status_->repaint();
		break;
	case Running:
		ui.actionRun_Until_Return->setEnabled(false);
		ui.action_Restart->setEnabled(false);
		ui.action_Run->setEnabled(false);
		ui.action_Pause->setEnabled(true);
		ui.action_Step_Into->setEnabled(false);
		ui.action_Step_Over->setEnabled(false);
		ui.actionStep_Out->setEnabled(false);
		ui.action_Step_Into_Pass_Signal_To_Application->setEnabled(false);
		ui.action_Step_Over_Pass_Signal_To_Application->setEnabled(false);
		ui.action_Run_Pass_Signal_To_Application->setEnabled(false);
		ui.action_Detach->setEnabled(true);
		ui.action_Kill->setEnabled(true);
		tabCreate_->setEnabled(true);
		status_->setText(tr("running"));
		status_->repaint();
		break;
	case Terminated:
		ui.actionRun_Until_Return->setEnabled(false);
		ui.action_Restart->setEnabled(recentFileManager_->entryCount() > 0);
		ui.action_Run->setEnabled(false);
		ui.action_Pause->setEnabled(false);
		ui.action_Step_Into->setEnabled(false);
		ui.action_Step_Over->setEnabled(false);
		ui.actionStep_Out->setEnabled(false);
		ui.action_Step_Into_Pass_Signal_To_Application->setEnabled(false);
		ui.action_Step_Over_Pass_Signal_To_Application->setEnabled(false);
		ui.action_Run_Pass_Signal_To_Application->setEnabled(false);
		ui.action_Detach->setEnabled(false);
		ui.action_Kill->setEnabled(false);
		tabCreate_->setEnabled(false);
		status_->setText(tr("terminated"));
		status_->repaint();
		break;
	}

	guiState_ = state;
}

//------------------------------------------------------------------------------
// Name: create_tty
// Desc: creates a TTY object for our command line I/O
//------------------------------------------------------------------------------
QString Debugger::createTty() {

	QString result_tty = ttyFile_;

#if defined(Q_OS_LINUX) || defined(Q_OS_OPENBSD) || defined(Q_OS_FREEBSD)
	// we attempt to reuse an open output window
	if (edb::v1::config().tty_enabled && ttyProc_->state() != QProcess::Running) {
		const QString command = edb::v1::config().tty_command;

		if (!command.isEmpty()) {

			// ok, creating a new one...
			// first try to get a 'unique' filename, i would love to use a system
			// temp file API... but there doesn't seem to be one which will create
			// a pipe...only ordinary files!
			std::random_device rd;
			std::mt19937 mt(rd());
			const auto temp_pipe = QString("%1/edb_temp_file_%2_%3").arg(QDir::tempPath()).arg(mt()).arg(getpid());

			// make sure it isn't already there, and then make the pipe
			::unlink(qPrintable(temp_pipe));
			::mkfifo(qPrintable(temp_pipe), S_IRUSR | S_IWUSR);

			// this is a basic shell script which will output the tty to a file (the pipe),
			// ignore kill sigs, close all standard IO, and then just hang
			const auto shell_script = QString(
										  "tty > %1;"
										  "trap \"\" INT QUIT TSTP;"
										  "exec<&-; exec>&-;"
										  "while :; do sleep 3600; done")
										  .arg(temp_pipe);

			// parse up the command from the options, white space delimited
			QStringList proc_args     = edb::v1::parse_command_line(command);
			const QString tty_command = proc_args.takeFirst().trimmed();

			// start constructing the arguments for the term
			const QFileInfo command_info(tty_command);

			if (command_info.fileName() == "gnome-terminal") {
				// NOTE(eteran): gnome-terminal at some point dropped support for -e
				// in favor of using "everything after --"
				// See issue: https://github.com/eteran/edb-debugger/issues/774
				proc_args << "--hide-menubar"
						  << "--title" << tr("edb output")
						  << "--";
			} else if (command_info.fileName() == "konsole") {
				proc_args << "--hide-menubar"
						  << "--title" << tr("edb output")
						  << "--nofork"
						  << "--hold"
						  << "-e";
			} else {
				proc_args << "-title" << tr("edb output")
						  << "-hold"
						  << "-e";
			}

			proc_args << "sh"
					  << "-c" << QString("%1").arg(shell_script);

			qDebug() << "Running Terminal: " << tty_command;
			qDebug() << "Terminal Args: " << proc_args;

			// make the tty process object and connect it's death signal to our cleanup
			connect(ttyProc_, SIGNAL(finished(int, QProcess::ExitStatus)), SLOT(ttyProcFinished(int, QProcess::ExitStatus)));

			ttyProc_->start(tty_command, proc_args);

			if (ttyProc_->waitForStarted(3000)) {

				// try to read from the pipe, but with a 2 second timeout
				int fd = open(qPrintable(temp_pipe), O_RDWR);
				if (fd != -1) {
					fd_set set;
					FD_ZERO(&set);    // clear the set
					FD_SET(fd, &set); // add our file descriptor to the set

					struct timeval timeout;
					timeout.tv_sec  = 2;
					timeout.tv_usec = 0;

					char buf[256] = {};
					const int rv  = select(fd + 1, &set, nullptr, nullptr, &timeout);
					switch (rv) {
					case -1:
						qDebug() << "An error occured while attempting to get the TTY of the terminal sub-process";
						break;
					case 0:
						qDebug() << "A Timeout occured while attempting to get the TTY of the terminal sub-process";
						break;
					default:
						if (read(fd, buf, sizeof(buf)) != -1) {
							result_tty = QString(buf).trimmed();
						}
						break;
					}

					::close(fd);
				}

			} else {
				qDebug().nospace() << "Could not launch the desired terminal [" << tty_command << "], please check that it exists and you have proper permissions.";
			}

			// cleanup, god i wish there was an easier way than this!
			::unlink(qPrintable(temp_pipe));
		}
	}
#endif

	qDebug() << "Terminal process has TTY: " << result_tty;

	return result_tty;
}

//------------------------------------------------------------------------------
// Name: tty_proc_finished
// Desc: cleans up the data associated with a TTY when the terminal dies
//------------------------------------------------------------------------------
void Debugger::ttyProcFinished(int exit_code, QProcess::ExitStatus exit_status) {
	Q_UNUSED(exit_code)
	Q_UNUSED(exit_status)

	ttyFile_.clear();
}

//------------------------------------------------------------------------------
// Name: current_tab
// Desc:
//------------------------------------------------------------------------------
int Debugger::currentTab() const {
	return tabWidget_->currentIndex();
}

//------------------------------------------------------------------------------
// Name: current_data_view_info
// Desc:
//------------------------------------------------------------------------------
std::shared_ptr<DataViewInfo> Debugger::currentDataViewInfo() const {
	return dataRegions_[currentTab()];
}

//------------------------------------------------------------------------------
// Name: set_debugger_caption
// Desc: sets the caption part to also show the application name and pid
//------------------------------------------------------------------------------
void Debugger::setDebuggerCaption(const QString &appname) {
	setWindowTitle(tr("edb - %1 [%2]").arg(appname).arg(edb::v1::debugger_core->process()->pid()));
}

//------------------------------------------------------------------------------
// Name: delete_data_tab
// Desc:
//------------------------------------------------------------------------------
void Debugger::deleteDataTab() {
	const int current = currentTab();

	// get a pointer to the info we need (before removing it from the list!)
	// this seems redundant to current_data_view_info(), but we need the
	// index too, so may as well waste one line to avoid duplicate work
	std::shared_ptr<DataViewInfo> info = dataRegions_[current];

	// remove it from the list
	dataRegions_.remove(current);

	// remove the tab associated with it
	tabWidget_->removeTab(current);
}

//------------------------------------------------------------------------------
// Name: create_data_tab
// Desc:
//------------------------------------------------------------------------------
void Debugger::createDataTab() {
	const int current = currentTab();

	// duplicate the current region
	auto new_data_view = std::make_shared<DataViewInfo>((current != -1) ? dataRegions_[current]->region : nullptr);

	auto hexview = std::make_shared<QHexView>();

	Theme theme = Theme::load();

	QColor addressForegroundColor = theme.text[Theme::Address].foreground().color();
	QColor alternatingByteColor   = theme.text[Theme::AlternatingByte].foreground().color();
	QColor nonPrintableTextColor  = theme.text[Theme::NonPrintingCharacter].foreground().color();
	hexview->setAddressColor(addressForegroundColor);
	hexview->setAlternateWordColor(alternatingByteColor);
	hexview->setNonPrintableTextColor(nonPrintableTextColor);

	// QColor coldZoneColor_         = Qt::gray;
	// QColor lineColor_             = Qt::black;

	new_data_view->view = hexview;

	// setup the context menu
	hexview->setContextMenuPolicy(Qt::CustomContextMenu);
	connect(hexview.get(), &QHexView::customContextMenuRequested, this, &Debugger::mnuDumpContextMenu);

	// show the initial data for this new view
	if (new_data_view->region) {
		hexview->setAddressOffset(new_data_view->region->start());
	} else {
		hexview->setAddressOffset(0);
	}

	// NOTE(eteran): for issue #522, allow comments in data view when single word width
	hexview->setCommentServer(commentServer_.get());

	hexview->setData(new_data_view->stream.get());

	const Configuration &config = edb::v1::config();

	// set the default view options
	hexview->setShowAddress(config.data_show_address);
	hexview->setShowHexDump(config.data_show_hex);
	hexview->setShowAsciiDump(config.data_show_ascii);
	hexview->setShowComments(config.data_show_comments);
	hexview->setRowWidth(config.data_row_width);
	hexview->setWordWidth(config.data_word_width);
	hexview->setShowAddressSeparator(config.show_address_separator);

	// Setup data views according to debuggee bitness
	if (edb::v1::debuggeeIs64Bit()) {
		hexview->setAddressSize(QHexView::Address64);
	} else {
		hexview->setAddressSize(QHexView::Address32);
	}

	// set the default font
	QFont dump_font;
	dump_font.fromString(config.data_font);
	hexview->setFont(dump_font);

	dataRegions_.push_back(new_data_view);

	// create the tab!
	if (new_data_view->region) {
		tabWidget_->addTab(hexview.get(), tr("%1-%2").arg(
											  edb::v1::format_pointer(new_data_view->region->start()),
											  edb::v1::format_pointer(new_data_view->region->end())));
	} else {
		tabWidget_->addTab(hexview.get(), tr("%1-%2").arg(
											  edb::v1::format_pointer(edb::address_t(0)),
											  edb::v1::format_pointer(edb::address_t(0))));
	}

	tabWidget_->setCurrentIndex(tabWidget_->count() - 1);
}

//------------------------------------------------------------------------------
// Name: finish_plugin_setup
// Desc: finalizes plugin setup by adding each to the menu, we can do this now
//       that we have a GUI widget to attach it to
//------------------------------------------------------------------------------
void Debugger::finishPluginSetup() {

	// call the init function for each plugin, this is done after
	// ALL plugins are loaded in case there are inter-plugin dependencies
	for (QObject *plugin : edb::v1::plugin_list()) {
		if (auto p = qobject_cast<IPlugin *>(plugin)) {
			p->init();
		}
	}

	// setup the menu for all plugins that which to do so
	QPointer<DialogOptions> options = qobject_cast<DialogOptions *>(edb::v1::dialog_options());
	for (QObject *plugin : edb::v1::plugin_list()) {
		if (auto p = qobject_cast<IPlugin *>(plugin)) {
			if (QMenu *const menu = p->menu(this)) {
				ui.menu_Plugins->addMenu(menu);
			}

			if (QWidget *const options_page = p->optionsPage()) {
				if (options) {
					options->addOptionsPage(options_page);
				}
			}

			// setup the shortcuts for these actions
			const QList<QAction *> register_actions = p->registerContextMenu();
			const QList<QAction *> cpu_actions      = p->cpuContextMenu();
			const QList<QAction *> stack_actions    = p->stackContextMenu();
			const QList<QAction *> data_actions     = p->dataContextMenu();
			const QList<QAction *> actions          = register_actions + cpu_actions + stack_actions + data_actions;

			for (QAction *action : actions) {
				QKeySequence shortcut = action->shortcut();
				if (!shortcut.isEmpty()) {
					connect(new QShortcut(shortcut, this), &QShortcut::activated, action, &QAction::trigger);
				}
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: get_goto_expression
// Desc:
//------------------------------------------------------------------------------
Result<edb::address_t, QString> Debugger::getGotoExpression() {

	std::optional<edb::address_t> address = edb::v2::get_expression_from_user(tr("Goto Expression"), tr("Expression:"));
	if (address) {
		return *address;
	} else {
		return make_unexpected(tr("No Address"));
	}
}

//------------------------------------------------------------------------------
// Name: get_follow_register
// Desc:
//------------------------------------------------------------------------------
Result<edb::reg_t, QString> Debugger::getFollowRegister() const {

	const Register reg = activeRegister();
	if (!reg || reg.bitSize() > 8 * sizeof(edb::address_t)) {
		return make_unexpected(tr("No Value"));
	}

	return reg.valueAsAddress();
}

//------------------------------------------------------------------------------
// Name: goto_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::gotoTriggered() {
	QWidget *const widget = QApplication::focusWidget();
	if (auto hexview = qobject_cast<QHexView *>(widget)) {
		if (hexview == stackView_.get()) {
			mnuStackGotoAddress();
		} else {
			mnuDumpGotoAddress();
		}
	} else if (qobject_cast<QDisassemblyView *>(widget)) {
		mnuCPUJumpToAddress();
	}
}

//------------------------------------------------------------------------------
// Name: setup_ui
// Desc: creates the UI
//------------------------------------------------------------------------------
void Debugger::setupUi() {
	// setup the global pointers as early as possible.
	// NOTE:  this should never be changed after this point
	// NOTE:  this is important that this happens BEFORE any components which
	// read settings as it could end up being a memory leak (and therefore never
	// calling it's destructor which writes the settings to disk!).
	edb::v1::debugger_ui = this;

	ui.setupUi(this);

	splitter_ = new QSplitter(this);
	splitter_->setObjectName(QLatin1String("mainSplitter"));
	splitter_->setOrientation(Qt::Vertical);

	{
		logger_ = new QPlainTextEdit(this);
		logger_->setObjectName(QLatin1String("logView"));
		logger_->setReadOnly(true);
		QFont font("monospace");
		font.setStyleHint(QFont::TypeWriter);
		logger_->setFont(font);
		logger_->setWordWrapMode(QTextOption::WrapMode::NoWrap);
		logger_->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
		logger_instance = logger_;

		qInstallMessageHandler([](QtMsgType type, const QMessageLogContext &, const QString &message) {
			const QString text = [type, &message]() {
				switch (type) {
				case QtDebugMsg:
					return tr("DEBUG %1").arg(message);
				case QtInfoMsg:
					return tr("INFO  %1").arg(message);
				case QtWarningMsg:
					return tr("WARN  %1").arg(message);
				case QtCriticalMsg:
					return tr("ERROR %1").arg(message);
				case QtFatalMsg:
					return tr("FATAL %1").arg(message);
				default:
					Q_UNREACHABLE();
				}
			}();

			logger_instance->appendPlainText(text);
			std::cerr << message.toUtf8().constData() << "\n"; // this may be useful as a crash log
		});

		auto toolButton = static_cast<QToolButton *>(ui.toolBar->widgetForAction(ui.action_Debug_Logger));

		toolButton->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
		connect(ui.action_Debug_Logger, &QAction::triggered, this, [this](bool checked) {
			logger_->setVisible(checked);
		});
	}

	mainWindow_ = new QMainWindow(this);
	mainWindow_->setObjectName(QLatin1String("subMainWindow"));
	mainWindow_->setWindowFlags(Qt::Widget);
	mainWindow_->layout()->setContentsMargins(3, 3, 3, 3);
	mainWindow_->setObjectName(QLatin1String("dockingRoot"));

	cpuView_ = new QDisassemblyView;
	cpuView_->setObjectName(QLatin1String("cpuView"));

	listView_ = new QListView;
	listView_->setObjectName(QLatin1String("listView"));

	QFont font;
	font.setFamily(QLatin1String("Monospace"));
	font.setPointSize(10);
	listView_->setFont(font);
	listView_->setEditTriggers(QAbstractItemView::NoEditTriggers);
	listView_->setFixedHeight(listView_->fontMetrics().height() * 4);

	auto cpu_splitter = new QSplitter(this);
	cpu_splitter->setObjectName(QLatin1String("cpuSplitter"));
	cpu_splitter->setOrientation(Qt::Vertical);

	cpu_splitter->addWidget(cpuView_);
	cpu_splitter->addWidget(listView_);
	mainWindow_->setCentralWidget(cpu_splitter);

	splitter_->addWidget(mainWindow_);
	splitter_->addWidget(logger_);
	splitter_->setChildrenCollapsible(false);

	// data dock
	dataDock_ = new QDockWidget(this);
	dataDock_->setObjectName(QLatin1String("dataDock"));
	tabWidget_ = new TabWidget(this);
	tabWidget_->setObjectName(QLatin1String("tabWidget"));

	dataDock_->setWidget(tabWidget_);
	mainWindow_->addDockWidget(Qt::BottomDockWidgetArea, dataDock_);
	dataDock_->setWindowTitle(tr("Data Dump"));

	// stack dock
	stackDock_ = new QDockWidget(this);
	stackDock_->setObjectName(QLatin1String("stackDock"));
	mainWindow_->addDockWidget(Qt::BottomDockWidgetArea, stackDock_);
	stackDock_->setWindowTitle(tr("Stack"));

	setCentralWidget(splitter_);

	status_ = new QLabel(this);
	status_->setObjectName(QLatin1String("statusLabel"));
	ui.statusbar->insertPermanentWidget(0, status_);

	// add toggles for the dock windows
	ui.menu_View->addAction(dataDock_->toggleViewAction());
	ui.menu_View->addAction(stackDock_->toggleViewAction());
	ui.menu_View->addAction(ui.toolBar->toggleViewAction());

	ui.action_Restart->setEnabled(recentFileManager_->entryCount() > 0);

	// make sure our widgets use custom context menus
	cpuView_->setContextMenuPolicy(Qt::CustomContextMenu);

	setupStackView();
	setupTabButtons();

	mnuDumpCreateTab();

	// apply any fonts we may have stored
	applyDefaultFonts();

	// apply the default setting for showing address separators
	applyDefaultShowSeparator();

	connect(cpuView_, &QDisassemblyView::breakPointToggled, this, &Debugger::breakPointToggled_triggered);
	connect(cpuView_, &QDisassemblyView::customContextMenuRequested, this, &Debugger::customContextMenuRequested_triggered);
}

//------------------------------------------------------------------------------
// Name: setup_stack_view
// Desc:
//------------------------------------------------------------------------------
void Debugger::setupStackView() {

	stackView_ = std::make_shared<QHexView>();

	Theme theme = Theme::load();

	QColor addressForegroundColor = theme.text[Theme::Address].foreground().color();
	QColor alternatingByteColor   = theme.text[Theme::AlternatingByte].foreground().color();
	QColor nonPrintableTextColor  = theme.text[Theme::NonPrintingCharacter].foreground().color();

	stackView_->setAddressColor(addressForegroundColor);
	stackView_->setAlternateWordColor(alternatingByteColor);
	stackView_->setNonPrintableTextColor(nonPrintableTextColor);

	stackView_->setUserConfigRowWidth(false);
	stackView_->setUserConfigWordWidth(false);

	stackDock_->setWidget(stackView_.get());

	// setup the context menu
	stackView_->setContextMenuPolicy(Qt::CustomContextMenu);
	connect(stackView_.get(), &QHexView::customContextMenuRequested, this, &Debugger::mnuStackContextMenu);

	// we placed a view in the designer, so just set it here
	// this may get transitioned to heap allocated, we'll see
	stackViewInfo_.view = stackView_;

	// setup the comment server for the stack viewer
	stackView_->setCommentServer(commentServer_.get());
}

//------------------------------------------------------------------------------
// Name: closeEvent
// Desc: triggered on main window close, saves window state
//------------------------------------------------------------------------------
void Debugger::closeEvent(QCloseEvent *event) {

	// make sure sessions still get recorded even if they just close us
	const QString filename = sessionFilename();
	if (!filename.isEmpty()) {
		SessionManager::instance().saveSession(filename);
	}

	if (IDebugger *core = edb::v1::debugger_core) {
		core->endDebugSession();
	}

	// ensure that the detach event fires so that everyone who cases will be notified
	Q_EMIT detachEvent();

	QSettings settings;
	const QByteArray state = saveState();
	settings.beginGroup("Window");
	settings.setValue("window.logger.visible", logger_->isVisible());
	settings.setValue("window.state", state);
	settings.setValue("window.view.state", mainWindow_->saveState());
	settings.setValue("window.width", width());
	settings.setValue("window.height", height());
	settings.setValue("window.x", x());
	settings.setValue("window.y", y());
	settings.setValue("window.stack.show_address.enabled", stackView_->showAddress());
	settings.setValue("window.stack.show_hex.enabled", stackView_->showHexDump());
	settings.setValue("window.stack.show_ascii.enabled", stackView_->showAsciiDump());
	settings.setValue("window.stack.show_comments.enabled", stackView_->showComments());

	QByteArray dissassemblyState = cpuView_->saveState();
	settings.setValue("window.disassembly.state", dissassemblyState);

	QByteArray splitterState = splitter_->saveState();
	settings.setValue("window.splitter.state", splitterState);

	settings.endGroup();
	event->accept();
}

//------------------------------------------------------------------------------
// Name: showEvent
// Desc: triggered on show, restores window state
//------------------------------------------------------------------------------
void Debugger::showEvent(QShowEvent *) {

	QSettings settings;
	settings.beginGroup("Window");
	const QByteArray splitterState = settings.value("window.splitter.state").toByteArray();
	const QByteArray viewState     = settings.value("window.view.state").toByteArray();
	const QByteArray state         = settings.value("window.state").toByteArray();
	const int width                = settings.value("window.width", -1).toInt();
	const int height               = settings.value("window.height", -1).toInt();
	const int x                    = settings.value("window.x", -1).toInt();
	const int y                    = settings.value("window.y", -1).toInt();

	if (width != -1) {
		resize(width, size().height());
	}

	if (height != -1) {
		resize(size().width(), height);
	}

	const bool loggerVisible = settings.value("window.logger.visible").toBool();

	const Configuration &config = edb::v1::config();
	switch (config.startup_window_location) {
	case Configuration::SystemDefault:
		break;
	case Configuration::Centered: {
		QDesktopWidget desktop;
#if QT_VERSION >= QT_VERSION_CHECK(5, 11, 0)
		QScreen *screen = QGuiApplication::primaryScreen();
		QRect sg        = screen->geometry();
#else
        QRect sg = desktop.screenGeometry();
#endif
		int x = (sg.width() - this->width()) / 2;
		int y = (sg.height() - this->height()) / 2;
		move(x, y);
	} break;
	case Configuration::Restore:
		if (x != -1 && y != -1) {
			move(x, y);
		}
		break;
	}

	stackView_->setShowAddress(settings.value("window.stack.show_address.enabled", true).toBool());
	stackView_->setShowHexDump(settings.value("window.stack.show_hex.enabled", true).toBool());
	stackView_->setShowAsciiDump(settings.value("window.stack.show_ascii.enabled", true).toBool());
	stackView_->setShowComments(settings.value("window.stack.show_comments.enabled", true).toBool());

	int row_width  = 1;
	int word_width = edb::v1::pointer_size();

	stackView_->setRowWidth(row_width);
	stackView_->setWordWidth(word_width);

	QByteArray disassemblyState = settings.value("window.disassembly.state").toByteArray();
	cpuView_->restoreState(disassemblyState);

	settings.endGroup();
	restoreState(state);
	mainWindow_->restoreState(viewState);
	splitter_->restoreState(splitterState);

	logger_->setVisible(loggerVisible);
	ui.action_Debug_Logger->setChecked(loggerVisible);
}

//------------------------------------------------------------------------------
// Name: dragEnterEvent
// Desc: triggered when dragging data onto the main window
//------------------------------------------------------------------------------
void Debugger::dragEnterEvent(QDragEnterEvent *event) {
	const QMimeData *mimeData = event->mimeData();

	// check for our needed mime type (file)
	// make sure it's only one file
	if (mimeData->hasUrls() && mimeData->urls().size() == 1) {
		// extract the local path of the file
		QList<QUrl> urls = mimeData->urls();
		QUrl url         = urls[0].toLocalFile();
		if (!url.isEmpty()) {
			event->accept();
		}
	}
}

//------------------------------------------------------------------------------
// Name: dropEvent
// Desc: triggered when data was dropped onto the main window
//------------------------------------------------------------------------------
void Debugger::dropEvent(QDropEvent *event) {
	const QMimeData *mimeData = event->mimeData();

	if (mimeData->hasUrls() && mimeData->urls().size() == 1) {
		QList<QUrl> urls = mimeData->urls();
		const QString s  = urls[0].toLocalFile();
		if (!s.isEmpty()) {
			Q_ASSERT(edb::v1::debugger_core);

			commonOpen(s, QList<QByteArray>(), QString(), QString());
		}
	}
}

//------------------------------------------------------------------------------
// Name: on_actionAbout_QT_triggered
// Desc: shows an About Qt dialog box
//------------------------------------------------------------------------------
void Debugger::on_actionAbout_QT_triggered() {
	QMessageBox::aboutQt(this, tr("About Qt"));
}

//------------------------------------------------------------------------------
// Name: apply_default_fonts
// Desc: applies the configuration's fonts to all necessary widgets
//------------------------------------------------------------------------------
void Debugger::applyDefaultFonts() {

	QFont font;
	const Configuration &config = edb::v1::config();

	// set some default fonts
	if (font.fromString(config.stack_font)) {
		stackView_->setFont(font);
	}

	if (font.fromString(config.registers_font)) {
#if 0
		ui.registerList->setFont(font);
#endif
	}

	if (font.fromString(config.disassembly_font)) {
		cpuView_->setFont(font);
	}

	if (font.fromString(config.data_font)) {
		Q_FOREACH (const std::shared_ptr<DataViewInfo> &data_view, dataRegions_) {
			data_view->view->setFont(font);
		}
	}
}

/**
 * creates the add/remove tab buttons in the data view
 *
 * @brief Debugger::setupTabButtons
 */
void Debugger::setupTabButtons() {
	// add the corner widgets to the data view
	tabCreate_ = new QToolButton(tabWidget_);
	tabDelete_ = new QToolButton(tabWidget_);

	tabCreate_->setToolButtonStyle(Qt::ToolButtonIconOnly);
	tabDelete_->setToolButtonStyle(Qt::ToolButtonIconOnly);
	tabCreate_->setIcon(QIcon::fromTheme("tab-new"));
	tabDelete_->setIcon(QIcon::fromTheme("tab-close"));
	tabCreate_->setAutoRaise(true);
	tabDelete_->setAutoRaise(true);
	tabCreate_->setEnabled(false);
	tabDelete_->setEnabled(false);

	tabWidget_->setCornerWidget(tabCreate_, Qt::TopLeftCorner);
	tabWidget_->setCornerWidget(tabDelete_, Qt::TopRightCorner);

	connect(tabCreate_, &QToolButton::clicked, this, &Debugger::mnuDumpCreateTab);
	connect(tabDelete_, &QToolButton::clicked, this, &Debugger::mnuDumpDeleteTab);
}

/**
 * @brief Debugger::activeRegister
 * @return
 */
Register Debugger::activeRegister() const {
	const auto &model = edb::v1::arch_processor().registerViewModel();
	const auto index  = model.activeIndex();
	if (!index.data(RegisterViewModelBase::Model::IsNormalRegisterRole).toBool()) {
		return {};
	}

	const auto regName = index.sibling(index.row(), RegisterViewModelBase::Model::NAME_COLUMN).data().toString();
	if (regName.isEmpty()) {
		return {};
	}

	if (IDebugger *core = edb::v1::debugger_core) {
		if (IProcess *process = core->process()) {
			State state;
			process->currentThread()->getState(&state);
			return state[regName];
		}
	}
	return {};
}

//------------------------------------------------------------------------------
// Name: on_registerList_customContextMenuRequested
// Desc: context menu handler for register view
//------------------------------------------------------------------------------
QList<QAction *> Debugger::currentRegisterContextMenuItems() const {
	QList<QAction *> allActions;
	const auto reg = activeRegister();
	if (reg.type() & (Register::TYPE_GPR | Register::TYPE_IP)) {

		QList<QAction *> actions;
		actions << registerFollowInDumpAction_;
		actions << registerFollowInDumpTabAction_;
		actions << registerFollowInStackAction_;

		allActions.append(actions);
	}
	allActions.append(getPluginContextMenuItems(&IPlugin::registerContextMenu));
	return allActions;
}

// Flag-toggling functions.  Not sure if this is the best solution, but it works.

//------------------------------------------------------------------------------
// Name: toggle_flag
// Desc: toggles flag register at bit position pos
// Param: pos The position of the flag bit to toggle
//------------------------------------------------------------------------------
void Debugger::toggleFlag(int pos) {
	// TODO Maybe this should just return w/o action if no process is loaded.

	// Get the state and get the flag register
	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			State state;
			thread->getState(&state);
			edb::reg_t flags = state.flags();

			// Toggle the flag
			flags ^= (1 << pos);
			state.setFlags(flags);
			thread->setState(state);

			updateUi();
			refreshUi();
		}
	}
}

//------------------------------------------------------------------------------
// Name: breakPointToggled_triggered
// Desc: handler for toggling the breakpoints
//------------------------------------------------------------------------------
void Debugger::breakPointToggled_triggered(edb::address_t address) {
	edb::v1::toggle_breakpoint(address);
}

//------------------------------------------------------------------------------
// Name: on_action_About_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_About_triggered() {

	QPointer<DialogAbout> dlg = new DialogAbout(this);
	dlg->exec();
	delete dlg;
}

//------------------------------------------------------------------------------
// Name: apply_default_show_separator
// Desc:
//------------------------------------------------------------------------------
void Debugger::applyDefaultShowSeparator() {
	const bool show = edb::v1::config().show_address_separator;

	cpuView_->setShowAddressSeparator(show);
	stackView_->setShowAddressSeparator(show);
	Q_FOREACH (const std::shared_ptr<DataViewInfo> &data_view, dataRegions_) {
		data_view->view->setShowAddressSeparator(show);
	}
}

//------------------------------------------------------------------------------
// Name: on_action_Configure_Debugger_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Configure_Debugger_triggered() {

	edb::v1::dialog_options()->exec();

	// reload symbols in case they changed, or our symbol files changes
	edb::v1::reload_symbols();

	// re-read the memory region information
	edb::v1::memory_regions().sync();

	// apply the selected fonts
	applyDefaultFonts();

	// apply changes to the GUI options
	applyDefaultShowSeparator();

	// show changes
	refreshUi();
}

//----------------------------------------------------------------------
// Name: stepOver
//----------------------------------------------------------------------
template <class F1, class F2>
void Debugger::stepOver(F1 run_func, F2 step_func) {

	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			State state;
			thread->getState(&state);

			const edb::address_t ip = state.instructionPointer();
			uint8_t buffer[edb::Instruction::MaxSize];
			if (const int sz = edb::v1::get_instruction_bytes(ip, buffer)) {
				edb::Instruction inst(buffer, buffer + sz, 0);
				if (inst && edb::v1::arch_processor().canStepOver(inst)) {

					// add a temporary breakpoint at the instruction just
					// after the call
					if (std::shared_ptr<IBreakpoint> bp = edb::v1::debugger_core->addBreakpoint(ip + inst.byteSize())) {
						bp->setInternal(true);
						bp->setOneTime(true);
						bp->tag = stepover_bp_tag;
						run_func();
						return;
					}
				}
			}
		}
	}

	// if all else fails, it's a step into
	step_func();
}

//------------------------------------------------------------------------------
// Name: follow_memory
// Desc:
//------------------------------------------------------------------------------
template <class F>
void Debugger::followMemory(edb::address_t address, F follow_func) {
	if (!follow_func(address)) {
		QMessageBox::critical(this,
							  tr("No Memory Found"),
							  tr("There appears to be no memory at that location (<strong>%1</strong>)").arg(edb::v1::format_pointer(address)));
	}
}

//------------------------------------------------------------------------------
// Name: follow_register_in_dump
// Desc:
//------------------------------------------------------------------------------
void Debugger::followRegisterInDump(bool tabbed) {

	if (const Result<edb::address_t, QString> address = getFollowRegister()) {
		if (!edb::v1::dump_data(*address, tabbed)) {
			QMessageBox::critical(this,
								  tr("No Memory Found"),
								  tr("There appears to be no memory at that location (<strong>%1</strong>)").arg(edb::v1::format_pointer(address.value())));
		}
	}
}

//------------------------------------------------------------------------------
// Name: mnuStackGotoESP
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuStackGotoESP() {
	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			State state;
			thread->getState(&state);
			followMemory(state.stackPointer(), [](edb::address_t address) {
				return edb::v1::dump_stack(address);
			});
		}
	}
}

//------------------------------------------------------------------------------
// Name: mnuStackGotoEBP
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuStackGotoEBP() {
	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			State state;
			thread->getState(&state);
			followMemory(state.framePointer(), [](edb::address_t address) {
				return edb::v1::dump_stack(address);
			});
		}
	}
}

//------------------------------------------------------------------------------
// Name: mnuCPUJumpToEIP
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPUJumpToEIP() {
	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			State state;
			thread->getState(&state);
			followMemory(state.instructionPointer(), [](edb::address_t address) {
				return edb::v1::jump_to_address(address);
			});
		}
	}
}

//------------------------------------------------------------------------------
// Name: mnuCPUJumpToAddress
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPUJumpToAddress() {

	if (const Result<edb::address_t, QString> address = getGotoExpression()) {
		followMemory(*address, [](edb::address_t address) {
			return edb::v1::jump_to_address(address);
		});
	}
}

//------------------------------------------------------------------------------
// Name: mnuDumpGotoAddress
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuDumpGotoAddress() {
	if (const Result<edb::address_t, QString> address = getGotoExpression()) {
		followMemory(*address, [](edb::address_t address) {
			return edb::v1::dump_data(address);
		});
	}
}

//------------------------------------------------------------------------------
// Name: mnuStackGotoAddress
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuStackGotoAddress() {
	if (const Result<edb::address_t, QString> address = getGotoExpression()) {
		followMemory(*address, [](edb::address_t address) {
			return edb::v1::dump_stack(address);
		});
	}
}

//------------------------------------------------------------------------------
// Name: mnuRegisterFollowInStack
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuRegisterFollowInStack() {

	if (const Result<edb::address_t, QString> address = getFollowRegister()) {
		followMemory(*address, [](edb::address_t address) {
			return edb::v1::dump_stack(address);
		});
	}
}

//------------------------------------------------------------------------------
// Name: getFollowAddress
// Desc:
//------------------------------------------------------------------------------
template <class Ptr>
Result<edb::address_t, QString> Debugger::getFollowAddress(const Ptr &hexview) {

	Q_ASSERT(hexview);

	const size_t pointer_size = edb::v1::pointer_size();

	if (hexview->hasSelectedText()) {
		const QByteArray data = hexview->selectedBytes();

		if (data.size() == static_cast<int>(pointer_size)) {
			edb::address_t d(0);
			std::memcpy(&d, data.data(), pointer_size);

			return d;
		}
	}

	QMessageBox::critical(this,
						  tr("Invalid Selection"),
						  tr("Please select %1 bytes to use this function.").arg(pointer_size));

	return make_unexpected(tr("Invalid Selection"));
}

//------------------------------------------------------------------------------
// Name: followInStack
// Desc:
//------------------------------------------------------------------------------
template <class Ptr>
void Debugger::followInStack(const Ptr &hexview) {

	if (const Result<edb::address_t, QString> address = getFollowAddress(hexview)) {
		followMemory(*address, [](edb::address_t address) {
			return edb::v1::dump_stack(address);
		});
	}
}

//------------------------------------------------------------------------------
// Name: followInDump
// Desc:
//------------------------------------------------------------------------------
template <class Ptr>
void Debugger::followInDump(const Ptr &hexview) {

	if (const Result<edb::address_t, QString> address = getFollowAddress(hexview)) {
		followMemory(*address, [](edb::address_t address) {
			return edb::v1::dump_data(address);
		});
	}
}

//------------------------------------------------------------------------------
// Name: followInCpu
// Desc:
//------------------------------------------------------------------------------
template <class Ptr>
void Debugger::followInCpu(const Ptr &hexview) {

	if (const Result<edb::address_t, QString> address = getFollowAddress(hexview)) {
		followMemory(*address, [](edb::address_t address) {
			return edb::v1::jump_to_address(address);
		});
	}
}

//------------------------------------------------------------------------------
// Name: mnuDumpFollowInCPU
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuDumpFollowInCPU() {
	followInCpu(qobject_cast<QHexView *>(tabWidget_->currentWidget()));
}

//------------------------------------------------------------------------------
// Name: mnuDumpFollowInDump
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuDumpFollowInDump() {
	followInDump(qobject_cast<QHexView *>(tabWidget_->currentWidget()));
}

//------------------------------------------------------------------------------
// Name: mnuDumpFollowInStack
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuDumpFollowInStack() {
	followInStack(qobject_cast<QHexView *>(tabWidget_->currentWidget()));
}

//------------------------------------------------------------------------------
// Name: mnuStackFollowInDump
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuStackFollowInDump() {
	followInDump(stackView_);
}

//------------------------------------------------------------------------------
// Name: mnuStackFollowInCPU
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuStackFollowInCPU() {
	followInCpu(stackView_);
}

//------------------------------------------------------------------------------
// Name: mnuStackFollowInStack
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuStackFollowInStack() {
	followInStack(stackView_);
}

//------------------------------------------------------------------------------
// Name: on_actionApplication_Arguments_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_actionApplication_Arguments_triggered() {
	argumentsDialog_->exec();
}

//------------------------------------------------------------------------------
// Name: on_actionApplication_Working_Directory_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_actionApplication_Working_Directory_triggered() {
	const QString new_dir = QFileDialog::getExistingDirectory(
		this,
		tr("Application Working Directory"),
		QString(),
		QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);

	if (!new_dir.isEmpty()) {
		workingDirectory_ = new_dir;
	}
}

//------------------------------------------------------------------------------
// Name: mnuStackPush
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuStackPush() {
	Register value(edb::v1::debuggeeIs32Bit() ? make_Register("", edb::value32(0), Register::TYPE_GPR) : make_Register("", edb::value64(0), Register::TYPE_GPR));

	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			State state;
			thread->getState(&state);

			// ask for a replacement
			if (edb::v1::get_value_from_user(value, tr("Enter value to push"))) {

				// if they said ok, do the push, just like the hardware would do
				edb::v1::push_value(&state, value.valueAsInteger());

				// update the state
				thread->setState(state);
				updateUi();
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: mnuStackPop
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuStackPop() {
	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			State state;
			thread->getState(&state);
			edb::v1::pop_value(&state);
			thread->setState(state);
			updateUi();
		}
	}
}

//------------------------------------------------------------------------------
// Name: customContextMenuRequested_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::customContextMenuRequested_triggered(const QPoint &pos) {
	QMenu menu;

	auto displayMenu = new QMenu(tr("Display"), &menu);
	displayMenu->addAction(QIcon::fromTheme(QString::fromUtf8("view-restore")), tr("Restore Column Defaults"), cpuView_, SLOT(resetColumns()));

	auto editMenu = new QMenu(tr("&Edit"), &menu);
	editMenu->addAction(editBytesAction_);
	editMenu->addAction(fillWithZerosAction_);
	editMenu->addAction(fillWithNOPsAction_);

	menu.addMenu(displayMenu);
	menu.addMenu(editMenu);

	menu.addAction(editCommentAction_);
	menu.addAction(setAddressLabelAction_);

	menu.addAction(gotoAddressAction_);
	menu.addAction(gotoRIPAction_);

	const edb::address_t address = cpuView_->selectedAddress();
	int size                     = cpuView_->selectedSize();

	if (IProcess *process = edb::v1::debugger_core->process()) {

		Q_UNUSED(process)

		uint8_t buffer[edb::Instruction::MaxSize + 1];
		if (edb::v1::get_instruction_bytes(address, buffer, &size)) {
			edb::Instruction inst(buffer, buffer + size, address);
			if (inst) {

				if (is_call(inst) || is_jump(inst)) {
					if (is_immediate(inst[0])) {
						menu.addAction(followAction_);
					}

					/*
					if(is_expression(inst.operand(0))) {
						if(inst.operand(0).expression().base == edb::Operand::REG_RIP && inst.operand(0).expression().index == edb::Operand::REG_NULL && inst.operand(0).expression().scale == 1) {
							menu.addAction(followAction_);
							followAction_->setData(static_cast<qlonglong>(address + inst.operand(0).displacement()));
						}
					}
					*/
				} else {
					for (std::size_t i = 0; i < inst.operandCount(); ++i) {
						if (is_immediate(inst[i])) {
							menu.addAction(followConstantInDumpAction_);
							menu.addAction(followConstantInStackAction_);

							followConstantInDumpAction_->setData(static_cast<qlonglong>(util::to_unsigned(inst[i]->imm)));
							followConstantInStackAction_->setData(static_cast<qlonglong>(util::to_unsigned(inst[i]->imm)));
						}
					}
				}
			}
		}
	}

	menu.addSeparator();
	menu.addAction(setRIPAction_);
	menu.addAction(runToThisLineAction_);
	menu.addAction(runToLinePassAction_);
	menu.addSeparator();
	menu.addSeparator();
	menu.addAction(toggleBreakpointAction_);
	menu.addAction(conditionalBreakpointAction_);

	addPluginContextMenu(&menu, &IPlugin::cpuContextMenu);

	menu.exec(cpuView_->viewport()->mapToGlobal(pos));
}

//------------------------------------------------------------------------------
// Name: mnuCPUFollow
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPUFollow() {

	const edb::address_t address = cpuView_->selectedAddress();
	int size                     = cpuView_->selectedSize();
	uint8_t buffer[edb::Instruction::MaxSize + 1];
	if (!edb::v1::get_instruction_bytes(address, buffer, &size))
		return;

	const edb::Instruction inst(buffer, buffer + size, address);
	if (!is_call(inst) && !is_jump(inst))
		return;
	if (!is_immediate(inst[0]))
		return;

	const edb::address_t addressToFollow = util::to_unsigned(inst[0]->imm);
	if (auto action = qobject_cast<QAction *>(sender())) {
		Q_UNUSED(action)
		followMemory(addressToFollow, edb::v1::jump_to_address);
	}
}

//------------------------------------------------------------------------------
// Name: mnuCPUFollowInDump
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPUFollowInDump() {
	if (auto action = qobject_cast<QAction *>(sender())) {
		const edb::address_t address = action->data().toULongLong();
		followMemory(address, [](edb::address_t address) {
			return edb::v1::dump_data(address);
		});
	}
}

//------------------------------------------------------------------------------
// Name: mnuCPUFollowInStack
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPUFollowInStack() {
	if (auto action = qobject_cast<QAction *>(sender())) {
		const edb::address_t address = action->data().toULongLong();
		followMemory(address, [](edb::address_t address) {
			return edb::v1::dump_stack(address);
		});
	}
}

//------------------------------------------------------------------------------
// Name: mnuStackToggleLock
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuStackToggleLock(bool locked) {
	stackViewLocked_ = locked;
}

//------------------------------------------------------------------------------
// Name: mnuStackContextMenu
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuStackContextMenu(const QPoint &pos) {

	QMenu *const menu = stackView_->createStandardContextMenu();

	menu->addSeparator();
	menu->addAction(stackFollowInCPUAction_);
	menu->addAction(stackFollowInDumpAction_);
	menu->addAction(stackFollowInStackAction_);
	menu->addAction(gotoAddressAction_);
	menu->addAction(stackGotoRSPAction_);
	menu->addAction(stackGotoRBPAction_);

	menu->addSeparator();
	menu->addAction(editBytesAction_);
	menu->addSeparator();
	menu->addAction(stackPushAction_);
	menu->addAction(stackPopAction_);

	// lockable stack feature
	menu->addSeparator();
	auto action = new QAction(tr("&Lock Stack"), this);
	action->setCheckable(true);
	action->setChecked(stackViewLocked_);
	menu->addAction(action);
	connect(action, &QAction::toggled, this, &Debugger::mnuStackToggleLock);

	addPluginContextMenu(menu, &IPlugin::stackContextMenu);

	menu->exec(stackView_->mapToGlobal(pos));
	delete menu;
}

//------------------------------------------------------------------------------
// Name: mnuDumpContextMenu
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuDumpContextMenu(const QPoint &pos) {
	auto s = qobject_cast<QHexView *>(sender());

	Q_ASSERT(s);

	QMenu *const menu = s->createStandardContextMenu();
	menu->addSeparator();
	menu->addAction(dumpFollowInCPUAction_);
	menu->addAction(dumpFollowInDumpAction_);
	menu->addAction(dumpFollowInStackAction_);
	menu->addAction(gotoAddressAction_);
	menu->addSeparator();
	menu->addAction(editBytesAction_);
	menu->addSeparator();
	menu->addAction(dumpSaveToFileAction_);

	addPluginContextMenu(menu, &IPlugin::dataContextMenu);

	menu->exec(s->mapToGlobal(pos));
	delete menu;
}

//------------------------------------------------------------------------------
// Name: mnuDumpSaveToFile
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuDumpSaveToFile() {
	auto s = qobject_cast<QHexView *>(tabWidget_->currentWidget());

	Q_ASSERT(s);

	const QString filename = QFileDialog::getSaveFileName(
		this,
		tr("Save File"),
		lastOpenDirectory_);

	if (!filename.isEmpty()) {
		QFile file(filename);
		file.open(QIODevice::WriteOnly);
		if (file.isOpen()) {
			file.write(s->allBytes());
		}
	}
}

//------------------------------------------------------------------------------
// Name: cpu_fill
// Desc:
//------------------------------------------------------------------------------
void Debugger::cpuFill(uint8_t byte) {
	const edb::address_t address = cpuView_->selectedAddress();
	const unsigned int size      = cpuView_->selectedSize();

	if (size != 0) {
		if (IProcess *process = edb::v1::debugger_core->process()) {
			if (edb::v1::overwrite_check(address, size)) {
				QByteArray bytes(size, byte);

				process->writeBytes(address, bytes.data(), size);

				// do a refresh, not full update
				refreshUi();
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: mnuCPUEditComment
// Desc: Adds/edits a comment at the selected address.
//------------------------------------------------------------------------------
void Debugger::mnuCPUEditComment() {
	const edb::address_t address = cpuView_->selectedAddress();

	bool got_text;
	const QString comment = QInputDialog::getText(
		this,
		tr("Edit Comment"),
		tr("Comment:"),
		QLineEdit::Normal,
		cpuView_->getComment(address),
		&got_text);

	// If we got a comment, add it.
	if (got_text && !comment.isEmpty()) {
		cpuView_->addComment(address, comment);
	} else if (got_text && comment.isEmpty()) {
		// If the user backspaced the comment, remove the comment since
		// there's no need for a null string to take space in the hash.
		cpuView_->removeComment(address);
	} else {
		// The only other real case is that we didn't got_text.  No change.
		return;
	}

	refreshUi();
}

//------------------------------------------------------------------------------
// Name: mnuCPURemoveComment
// Desc: Removes a comment at the selected address.
//------------------------------------------------------------------------------
void Debugger::mnuCPURemoveComment() {
	const edb::address_t address = cpuView_->selectedAddress();
	cpuView_->removeComment(address);
	refreshUi();
}

//------------------------------------------------------------------------------
// Name: run_to_this_line
// Desc:
//------------------------------------------------------------------------------
void Debugger::runToThisLine(ExceptionResume pass_signal) {
	const edb::address_t address    = cpuView_->selectedAddress();
	std::shared_ptr<IBreakpoint> bp = edb::v1::find_breakpoint(address);
	if (!bp) {
		bp = edb::v1::create_breakpoint(address);
		if (!bp) return;
		bp->setOneTime(true);
		bp->setInternal(true);
		bp->tag = run_to_cursor_tag;
	}

	resumeExecution(pass_signal, Run, ResumeFlag::None);
}

//------------------------------------------------------------------------------
// Name: mnuCPURunToThisLinePassSignal
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPURunToThisLinePassSignal() {
	runToThisLine(PassException);
}

//------------------------------------------------------------------------------
// Name: mnuCPURunToThisLine
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPURunToThisLine() {
	runToThisLine(IgnoreException);
}

//------------------------------------------------------------------------------
// Name: mnuCPUToggleBreakpoint
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPUToggleBreakpoint() {
	const edb::address_t address = cpuView_->selectedAddress();
	edb::v1::toggle_breakpoint(address);
}

//------------------------------------------------------------------------------
// Name: mnuCPUAddConditionalBreakpoint
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPUAddConditionalBreakpoint() {
	bool ok;
	const edb::address_t address = cpuView_->selectedAddress();

	const QString condition = QInputDialog::getText(this, tr("Set Breakpoint Condition"), tr("Expression:"), QLineEdit::Normal, QString(), &ok);
	if (ok) {
		if (std::shared_ptr<IBreakpoint> bp = edb::v1::create_breakpoint(address)) {
			if (!condition.isEmpty()) {
				bp->condition = condition;
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: mnuCPURemoveBreakpoint
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPURemoveBreakpoint() {
	const edb::address_t address = cpuView_->selectedAddress();
	edb::v1::remove_breakpoint(address);
}

//------------------------------------------------------------------------------
// Name: mnuCPUFillZero
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPUFillZero() {
	cpuFill(0x00);
}

//------------------------------------------------------------------------------
// Name: mnuCPUFillNop
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPUFillNop() {
	if (IDebugger *core = edb::v1::debugger_core) {
		cpuFill(core->nopFillByte());
	}
}

//------------------------------------------------------------------------------
// Name: mnuCPULabelAddress
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPULabelAddress() {

	const edb::address_t address = cpuView_->selectedAddress();

	bool ok;
	const QString text = QInputDialog::getText(
		this,
		tr("Set Label"),
		tr("Label:"),
		QLineEdit::Normal,
		edb::v1::symbol_manager().findAddressName(address),
		&ok);

	if (ok) {
		edb::v1::symbol_manager().setLabel(address, text);
		refreshUi();
	}
}

//------------------------------------------------------------------------------
// Name: mnuCPUSetEIP
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPUSetEIP() {
	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {
			const edb::address_t address = cpuView_->selectedAddress();
			State state;
			thread->getState(&state);
			state.setInstructionPointer(address);
			thread->setState(state);
			updateUi();
		}
	}
}

//------------------------------------------------------------------------------
// Name: mnuCPUModify
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuCPUModify() {
	const edb::address_t address = cpuView_->selectedAddress();
	const unsigned int size      = cpuView_->selectedSize();

	uint8_t buf[edb::Instruction::MaxSize];

	Q_ASSERT(size <= sizeof(buf));

	if (IProcess *process = edb::v1::debugger_core->process()) {
		const bool ok = process->readBytes(address, buf, size);
		if (ok) {
			QByteArray bytes = QByteArray::fromRawData(reinterpret_cast<const char *>(buf), size);
			if (edb::v1::get_binary_string_from_user(bytes, tr("Edit Binary String"))) {
				edb::v1::modify_bytes(address, bytes.size(), bytes, 0x00);
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: modifyBytes
// Desc:
//------------------------------------------------------------------------------
template <class Ptr>
void Debugger::modifyBytes(const Ptr &hexview) {
	if (hexview) {
		const edb::address_t address = hexview->selectedBytesAddress();
		QByteArray bytes             = hexview->selectedBytes();

		if (edb::v1::get_binary_string_from_user(bytes, tr("Edit Binary String"))) {
			edb::v1::modify_bytes(address, bytes.size(), bytes, 0x00);
		}
	}
}

//------------------------------------------------------------------------------
// Name: mnuDumpModify
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuModifyBytes() {

	QWidget *const focusedWidget = QApplication::focusWidget();
	if (focusedWidget == cpuView_) {
		mnuCPUModify();
	} else if (focusedWidget == stackView_.get()) {
		mnuStackModify();
	} else {
		// not CPU or Stack, assume one of the data views..
		mnuDumpModify();
	}
}

//------------------------------------------------------------------------------
// Name: mnuDumpModify
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuDumpModify() {
	modifyBytes(qobject_cast<QHexView *>(tabWidget_->currentWidget()));
}

//------------------------------------------------------------------------------
// Name: mnuStackModify
// Desc:
//------------------------------------------------------------------------------
void Debugger::mnuStackModify() {
	modifyBytes(stackView_);
}

//------------------------------------------------------------------------------
// Name: breakpoint_condition_true
// Desc:
//------------------------------------------------------------------------------
bool Debugger::isBreakpointConditionTrue(const QString &condition) {

	if (std::optional<edb::address_t> condition_value = edb::v2::eval_expression(condition)) {
		return *condition_value;
	}
	return true;
}

//------------------------------------------------------------------------------
// Name: handle_trap
// Desc: returns true if we should resume as if this trap never happened
//------------------------------------------------------------------------------
edb::EventStatus Debugger::handleTrap(const std::shared_ptr<IDebugEvent> &event) {

	// we just got a trap event, there are a few possible causes
	// #1: we hit a 0xcc breakpoint, if so, then we want to stop
	// #2: we did a step
	// #3: we hit a 0xcc naturally in the program
	// #4: we hit a hardware breakpoint!
	IProcess *process = edb::v1::debugger_core->process();
	Q_ASSERT(process);

	State state;
	process->currentThread()->getState(&state);

	// look it up in our breakpoint list, make sure it is one of OUR int3s!
	// if it is, we need to backup EIP and pause ourselves
	const std::shared_ptr<IBreakpoint> bp = event->trapReason() == IDebugEvent::TRAP_STEPPING ? nullptr : edb::v1::find_triggered_breakpoint(state.instructionPointer());

	if (bp && bp->enabled()) {

		const edb::address_t previous_ip = bp->address();

		// TODO: check if the breakpoint was corrupted?
		bp->hit();

		// back up eip the size of a breakpoint, since we executed a breakpoint
		// instead of the real code that belongs there
		state.setInstructionPointer(previous_ip);
		process->currentThread()->setState(state);

#if defined(Q_OS_LINUX)
		// test if we have hit our internal LD hook BP. If so, read in the r_debug
		// struct so we can get the state, then we can just resume
		// TODO(eteran): add an option to let the user stop of debug events
		if (bp->internal() && bp->tag == ld_loader_tag) {

			if (dynamicInfoBreakpointSet_) {
				if (debugtPointer_) {
					if (edb::v1::debuggeeIs32Bit()) {
						handle_library_event<uint32_t>(process, debugtPointer_);
					} else {
						handle_library_event<uint64_t>(process, debugtPointer_);
					}
				}
			}

			if (edb::v1::config().break_on_library_load) {
				return edb::DEBUG_STOP;
			} else {
				return edb::DEBUG_CONTINUE_BP;
			}
		}
#endif

		const QString condition = bp->condition;

		// handle conditional breakpoints
		if (!condition.isEmpty()) {
			if (!isBreakpointConditionTrue(condition)) {
				return edb::DEBUG_CONTINUE_BP;
			}
		}

		// if it's a one time breakpoint then we should remove it upon
		// triggering, this is mainly used for situations like step over

		if (bp->oneTime()) {
			edb::v1::debugger_core->removeBreakpoint(bp->address());
		}
	}

	return edb::DEBUG_STOP;
}

//------------------------------------------------------------------------------
// Name: handle_event_stopped
// Desc:
//------------------------------------------------------------------------------
edb::EventStatus Debugger::handleEventStopped(const std::shared_ptr<IDebugEvent> &event) {

	// ok we just came in from a stop, we need to test some things,
	// generally, we will want to check if it was a step, if it was, was it
	// because we just hit a break point or because we wanted to run, but had
	// to step first in case were were on a breakpoint already...

	edb::v1::clear_status();

	if (event->isKill()) {
		QMessageBox::information(
			this,
			tr("Application Killed"),
			tr("The debugged application was killed."));

		on_action_Detach_triggered();
		return edb::DEBUG_STOP;
	}

	if (event->isError()) {
		const IDebugEvent::Message message = event->errorDescription();
		edb::v1::set_status(message.statusMessage, 0);
		if (edb::v1::config().enable_signals_message_box)
			QMessageBox::information(this, message.caption, message.message);
		return edb::DEBUG_STOP;
	}

	if (event->isTrap()) {
		return handleTrap(event);
	}

	if (event->isStop()) {
		// user asked to pause the debugged process
		return edb::DEBUG_STOP;
	}

	Q_ASSERT(edb::v1::debugger_core);
	QMap<qlonglong, QString> known_exceptions = edb::v1::debugger_core->exceptions();
	auto it                                   = known_exceptions.find(event->code());

	if (it != known_exceptions.end()) {

		const Configuration &config = edb::v1::config();

		QString exception_name = it.value();

		edb::v1::set_status(tr("%1 signal received. Shift+Step/Run to pass to program, Step/Run to ignore").arg(exception_name), 0);
		if (config.enable_signals_message_box) {
			QMessageBox::information(this, tr("Debug Event"),
									 tr(
										 "<p>The debugged application has received a debug event-> <strong>%1 (%2)</strong></p>"
										 "<p>If you would like to pass this event to the application press Shift+[F7/F8/F9]</p>"
										 "<p>If you would like to ignore this event, press [F7/F8/F9]</p>")
										 .arg(event->code())
										 .arg(exception_name));
		}
	} else {
		edb::v1::set_status(tr("Signal received: %1. Shift+Step/Run to pass to program, Step/Run to ignore").arg(event->code()), 0);
		if (edb::v1::config().enable_signals_message_box) {
			QMessageBox::information(this, tr("Debug Event"),
									 tr(
										 "<p>The debugged application has received a debug event-> <strong>%1</strong></p>"
										 "<p>If you would like to pass this event to the application press Shift+[F7/F8/F9]</p>"
										 "<p>If you would like to ignore this event, press [F7/F8/F9]</p>")
										 .arg(event->code()));
		}
	}

	return edb::DEBUG_STOP;
}

//------------------------------------------------------------------------------
// Name: handle_event_terminated
// Desc:
//------------------------------------------------------------------------------
edb::EventStatus Debugger::handleEventTerminated(const std::shared_ptr<IDebugEvent> &event) {
	on_action_Detach_triggered();
	QMessageBox::information(
		this,
		tr("Application Terminated"),
		tr("The debugged application was terminated with exit code %1.").arg(event->code()));

	return edb::DEBUG_STOP;
}

//------------------------------------------------------------------------------
// Name: handle_event_exited
// Desc:
//------------------------------------------------------------------------------
edb::EventStatus Debugger::handleEventExited(const std::shared_ptr<IDebugEvent> &event) {
	on_action_Detach_triggered();
	QMessageBox::information(
		this,
		tr("Application Exited"),
		tr("The debugged application exited normally with exit code %1.").arg(event->code()));

	return edb::DEBUG_STOP;
}

//------------------------------------------------------------------------------
// Name: handle_event
// Desc:
//------------------------------------------------------------------------------
edb::EventStatus Debugger::handleEvent(const std::shared_ptr<IDebugEvent> &event) {

	Q_ASSERT(edb::v1::debugger_core);

	edb::EventStatus status;
	switch (event->reason()) {
	// either a syncronous event (STOPPED)
	// or an asyncronous event (SIGNALED)
	case IDebugEvent::EVENT_STOPPED:
		status = handleEventStopped(event);
		break;

	case IDebugEvent::EVENT_TERMINATED:
		status = handleEventTerminated(event);
		break;

	// normal exit
	case IDebugEvent::EVENT_EXITED:
		status = handleEventExited(event);
		break;

	default:
		Q_ASSERT(false);
		return edb::DEBUG_EXCEPTION_NOT_HANDLED;
	}

	Q_ASSERT(!(reenableBreakpointStep_ && reenableBreakpointRun_));

	// re-enable any breakpoints we previously disabled
	if (reenableBreakpointStep_) {
		reenableBreakpointStep_->enable();
		reenableBreakpointStep_ = nullptr;
	} else if (reenableBreakpointRun_) {
		reenableBreakpointRun_->enable();
		reenableBreakpointRun_ = nullptr;
		status                 = edb::DEBUG_CONTINUE;
	}

	return status;
}

//------------------------------------------------------------------------------
// Name: update_tab_caption
// Desc:
//------------------------------------------------------------------------------
void Debugger::updateTabCaption(const std::shared_ptr<QHexView> &view, edb::address_t start, edb::address_t end) {
	const int index       = tabWidget_->indexOf(view.get());
	const QString caption = tabWidget_->data(index).toString();

	if (caption.isEmpty()) {
		tabWidget_->setTabText(index, tr("%1-%2").arg(edb::v1::format_pointer(start), edb::v1::format_pointer(end)));
	} else {
		tabWidget_->setTabText(index, tr("[%1] %2-%3").arg(caption, edb::v1::format_pointer(start), edb::v1::format_pointer(end)));
	}
}

//------------------------------------------------------------------------------
// Name: update_data
// Desc:
//------------------------------------------------------------------------------
void Debugger::updateData(const std::shared_ptr<DataViewInfo> &v) {

	Q_ASSERT(v);

	const std::shared_ptr<QHexView> &view = v->view;

	Q_ASSERT(view);

	v->update();

	updateTabCaption(view, v->region->start(), v->region->end());
}

//------------------------------------------------------------------------------
// Name: clear_data
// Desc:
//------------------------------------------------------------------------------
void Debugger::clearData(const std::shared_ptr<DataViewInfo> &v) {

	Q_ASSERT(v);

	const std::shared_ptr<QHexView> &view = v->view;

	Q_ASSERT(view);

	view->clear();
	view->scrollTo(0);

	updateTabCaption(view, 0, 0);
}

//------------------------------------------------------------------------------
// Name: do_jump_to_address
// Desc:
//------------------------------------------------------------------------------
void Debugger::doJumpToAddress(edb::address_t address, const std::shared_ptr<IRegion> &r, bool scrollTo) {

	cpuView_->setRegion(r);
	if (scrollTo && !cpuView_->addressShown(address)) {
		cpuView_->scrollTo(address);
	}
	cpuView_->setSelectedAddress(address);
}

//------------------------------------------------------------------------------
// Name: update_disassembly
// Desc:
//------------------------------------------------------------------------------
void Debugger::updateDisassembly(edb::address_t address, const std::shared_ptr<IRegion> &r) {
	cpuView_->setCurrentAddress(address);
	doJumpToAddress(address, r, true);
	listModel_->setStringList(edb::v1::arch_processor().updateInstructionInfo(address));
}

//------------------------------------------------------------------------------
// Name: update_stack_view
// Desc:
//------------------------------------------------------------------------------
void Debugger::updateStackView(const State &state) {
	if (!edb::v1::dump_stack(state.stackPointer(), !stackViewLocked_)) {
		stackView_->clear();
		stackView_->scrollTo(0);
	}
}

//------------------------------------------------------------------------------
// Name: update_cpu_view
// Desc:
//------------------------------------------------------------------------------
std::shared_ptr<IRegion> Debugger::updateCpuView(const State &state) {
	const edb::address_t address = state.instructionPointer();

	if (std::shared_ptr<IRegion> region = edb::v1::memory_regions().findRegion(address)) {
		updateDisassembly(address, region);
		return region;
	} else {
		cpuView_->clear();
		cpuView_->scrollTo(0);
		listModel_->setStringList(QStringList());
		return nullptr;
	}
}

//------------------------------------------------------------------------------
// Name: update_data_views
// Desc:
//------------------------------------------------------------------------------
void Debugger::updateDataViews() {

	// update all data views with the current region data
	Q_FOREACH (const std::shared_ptr<DataViewInfo> &info, dataRegions_) {

		// make sure the regions are still valid..
		if (info->region && edb::v1::memory_regions().findRegion(info->region->start())) {
			updateData(info);
		} else {
			clearData(info);
		}
	}
}

//------------------------------------------------------------------------------
// Name: refresh_gui
// Desc: refreshes all the different displays
//------------------------------------------------------------------------------
void Debugger::refreshUi() {

	cpuView_->update();
	stackView_->update();

	Q_FOREACH (const std::shared_ptr<DataViewInfo> &info, dataRegions_) {
		info->view->update();
	}

	if (edb::v1::debugger_core) {
		State state;

		if (IProcess *process = edb::v1::debugger_core->process()) {
			if (std::shared_ptr<IThread> thread = process->currentThread()) {
				thread->getState(&state);
			}
		}

		listModel_->setStringList(edb::v1::arch_processor().updateInstructionInfo(state.instructionPointer()));
	}
}

//------------------------------------------------------------------------------
// Name: update_gui
// Desc: updates all the different displays
//------------------------------------------------------------------------------
void Debugger::updateUi() {

	if (edb::v1::debugger_core) {

		State state;
		if (IProcess *process = edb::v1::debugger_core->process()) {
			if (std::shared_ptr<IThread> thread = process->currentThread()) {
				thread->getState(&state);
			}
		}

		updateDataViews();
		updateStackView(state);

		if (const std::shared_ptr<IRegion> region = updateCpuView(state)) {
			edb::v1::arch_processor().updateRegisterView(region->name(), state);
		} else {
			edb::v1::arch_processor().updateRegisterView(QString(), state);
		}
	}

	// Signal all connected slots that the GUI has been updated.
	// Useful for plugins with windows that should updated after
	// hitting breakpoints, Step Over, etc.
	Q_EMIT uiUpdated();
}

//------------------------------------------------------------------------------
// Name: resume_status
// Desc:
//------------------------------------------------------------------------------
edb::EventStatus Debugger::resumeStatus(bool pass_exception) {

	if (pass_exception && lastEvent_ && lastEvent_->stopped() && !lastEvent_->isTrap()) {
		return edb::DEBUG_EXCEPTION_NOT_HANDLED;
	} else {
		return edb::DEBUG_CONTINUE;
	}
}

//------------------------------------------------------------------------------
// Name: resume_execution
// Desc: resumes execution, handles the situation of being on a breakpoint as well
//------------------------------------------------------------------------------
void Debugger::resumeExecution(ExceptionResume pass_exception, DebugMode mode, ResumeFlag flags) {

	edb::v1::clear_status();
	Q_ASSERT(edb::v1::debugger_core);

	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (std::shared_ptr<IThread> thread = process->currentThread()) {

			// if necessary pass the trap to the application, otherwise just resume
			// as normal
			const edb::EventStatus status = resumeStatus(pass_exception == PassException);

			// if we are on a breakpoint, disable it
			std::shared_ptr<IBreakpoint> bp;
			if (flags != ResumeFlag::Forced) {
				State state;
				thread->getState(&state);
				bp = edb::v1::debugger_core->findBreakpoint(state.instructionPointer());
				if (bp) {
					bp->disable();
				}
			}

			edb::v1::arch_processor().aboutToResume();

			if (mode == Step) {
				reenableBreakpointStep_ = bp;
				const auto stepStatus   = thread->step(status);
				if (!stepStatus) {
					QMessageBox::critical(this, tr("Error"), tr("Failed to step thread: %1").arg(stepStatus.error()));
					return;
				}
			} else if (mode == Run) {
				reenableBreakpointRun_ = bp;
				if (bp) {
					const auto stepStatus = thread->step(status);
					if (!stepStatus) {
						QMessageBox::critical(this, tr("Error"), tr("Failed to step thread: %1").arg(stepStatus.error()));
						return;
					}
				} else {
					const auto resumeStatus = process->resume(status);
					if (!resumeStatus) {
						QMessageBox::critical(this, tr("Error"), tr("Failed to resume process: %1").arg(resumeStatus.error()));
						return;
					}
				}
			}

			// set the state to 'running'
			updateMenuState(Running);
		}
	}
}

//------------------------------------------------------------------------------
// Name: on_action_Run_Pass_Signal_To_Application_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Run_Pass_Signal_To_Application_triggered() {
	resumeExecution(PassException, Run, ResumeFlag::None);
}

//------------------------------------------------------------------------------
// Name: on_action_Step_Into_Pass_Signal_To_Application_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Step_Into_Pass_Signal_To_Application_triggered() {
	resumeExecution(PassException, Step, ResumeFlag::None);
}

//------------------------------------------------------------------------------
// Name: on_action_Run_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Run_triggered() {
	resumeExecution(IgnoreException, Run, ResumeFlag::None);
}

//------------------------------------------------------------------------------
// Name: on_action_Step_Into_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Step_Into_triggered() {
	resumeExecution(IgnoreException, Step, ResumeFlag::None);
}

//------------------------------------------------------------------------------
// Name: on_action_Detach_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Detach_triggered() {
	detachFromProcess(NoKillOnDetach);
}

//------------------------------------------------------------------------------
// Name: on_action_Kill_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Kill_triggered() {
	detachFromProcess(KillOnDetach);
}

//------------------------------------------------------------------------------
// Name: on_action_Step_Over_Pass_Signal_To_Application_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Step_Over_Pass_Signal_To_Application_triggered() {
	stepOver([this]() { on_action_Run_Pass_Signal_To_Application_triggered(); },
			 [this]() { on_action_Step_Into_Pass_Signal_To_Application_triggered(); });
}

//------------------------------------------------------------------------------
// Name: on_action_Step_Over_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Step_Over_triggered() {
	stepOver([this]() { on_action_Run_triggered(); },
			 [this]() { on_action_Step_Into_triggered(); });
}

//------------------------------------------------------------------------------
// Name: on_actionStep_Out_triggered
// Desc: Step out is the same as run until return, in our context.
//------------------------------------------------------------------------------
void Debugger::on_actionStep_Out_triggered() {
	on_actionRun_Until_Return_triggered();
}

//------------------------------------------------------------------------------
// Name: on_actionRun_Until_Return_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_actionRun_Until_Return_triggered() {

	new RunUntilRet();

	// Step over rather than resume in MODE_STEP so that we can avoid stepping into calls.
	// TODO: If we are sitting on the call and it has a bp, it steps over for some reason...
	stepOver([this]() { on_action_Run_triggered(); },
			 [this]() { on_action_Step_Into_triggered(); });
}

//------------------------------------------------------------------------------
// Name: on_action_Pause_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Pause_triggered() {
	Q_ASSERT(edb::v1::debugger_core);
	if (IProcess *process = edb::v1::debugger_core->process()) {
		process->pause();
	}
}

//------------------------------------------------------------------------------
// Name: cleanup_debugger
// Desc:
//------------------------------------------------------------------------------
void Debugger::cleanupDebugger() {

	timer_->stop();

	cpuView_->clearComments();
	edb::v1::memory_regions().clear();
	edb::v1::symbol_manager().clear();
	edb::v1::arch_processor().reset();

	// clear up the data view
	while (tabWidget_->count() > 1) {
		mnuDumpDeleteTab();
	}

	tabWidget_->setData(0, QString());

	Q_ASSERT(!dataRegions_.isEmpty());
	dataRegions_.first()->region = nullptr;

	Q_EMIT detachEvent();

	setWindowTitle(tr("edb"));

	updateUi();
}

//------------------------------------------------------------------------------
// Name: session_filename
// Desc:
//------------------------------------------------------------------------------
QString Debugger::sessionFilename() const {

	static bool show_path_notice = true;

	QString session_path = edb::v1::config().session_path;
	if (session_path.isEmpty()) {
		if (show_path_notice) {
			qDebug() << "No session path specified. Please set it in the preferences to enable sessions.";
			show_path_notice = false;
		}
		return QString();
	}

	if (!programExecutable_.isEmpty()) {
		QFileInfo info(programExecutable_);

		if (info.isRelative()) {
			info.makeAbsolute();
		}

		auto path          = tr("%1/%2").arg(session_path, info.absolutePath());
		const QString name = info.fileName();

		// ensure that the sub-directory exists
		QDir().mkpath(path);

		return tr("%1/%2.edb").arg(path, name);
	}

	return QString();
}

//------------------------------------------------------------------------------
// Name: detach_from_process
// Desc:
//------------------------------------------------------------------------------
void Debugger::detachFromProcess(DetachAction kill) {

	const QString filename = sessionFilename();
	if (!filename.isEmpty()) {
		SessionManager::instance().saveSession(filename);
	}

	programExecutable_.clear();

	if (edb::v1::debugger_core) {
		if (kill == KillOnDetach)
			edb::v1::debugger_core->kill();
		else
			edb::v1::debugger_core->detach();
	}

	lastEvent_ = nullptr;

	cleanupDebugger();
	updateMenuState(Terminated);
}

//------------------------------------------------------------------------------
// Name: set_initial_debugger_state
// Desc: resets all of the basic data to sane defaults
//------------------------------------------------------------------------------
void Debugger::setInitialDebuggerState() {

	updateMenuState(Paused);
	timer_->start(0);

	edb::v1::symbol_manager().clear();
	edb::v1::memory_regions().sync();

	Q_ASSERT(dataRegions_.size() > 0);

	dataRegions_.first()->region = edb::v1::primary_data_region();

	if (IAnalyzer *const analyzer = edb::v1::analyzer()) {
		analyzer->invalidateAnalysis();
	}

	reenableBreakpointRun_  = nullptr;
	reenableBreakpointStep_ = nullptr;

#ifdef Q_OS_LINUX
	debugtPointer_            = 0;
	dynamicInfoBreakpointSet_ = false;
#endif

	IProcess *process = edb::v1::debugger_core->process();

	const QString executable = process ? process->executable() : QString();

	setDebuggerCaption(executable);

	programExecutable_.clear();
	if (!executable.isEmpty()) {
		programExecutable_ = executable;
	}

	const QString filename = sessionFilename();
	if (!filename.isEmpty()) {

		SessionManager &session_manager = SessionManager::instance();

		if (Result<void, SessionError> session_error = session_manager.loadSession(filename)) {
			QVariantList comments_data = session_manager.comments();
			cpuView_->restoreComments(comments_data);
		} else {
			QMessageBox::warning(
				this,
				tr("Error Loading Session"),
				session_error.error().message);
		}
	}

	// create our binary info object for the primary code module
	binaryInfo_ = edb::v1::get_binary_info(edb::v1::primary_code_region());

	commentServer_->clear();
	commentServer_->setComment(process->entryPoint(), "<entry point>");
}

//------------------------------------------------------------------------------
// Name: test_native_binary
// Desc:
//------------------------------------------------------------------------------
void Debugger::testNativeBinary() {
	if (EDB_IS_32_BIT && binaryInfo_ && !binaryInfo_->native()) {
		QMessageBox::warning(
			this,
			tr("Not A Native Binary"),
			tr("The program you just attached to was built for a different architecture than the one that edb was built for. "
			   "For example a AMD64 binary on EDB built for IA32. "
			   "This is not fully supported yet, so you may need to use a version of edb that was compiled for the same architecture as your target program"));
	}
}

//------------------------------------------------------------------------------
// Name: set_initial_breakpoint
// Desc: sets the initial breakpoint so we can stop at the entry point of the
//       application
//------------------------------------------------------------------------------
void Debugger::setInitialBreakpoint(const QString &s) {

	edb::address_t entryPoint = 0;

	if (edb::v1::config().initial_breakpoint == Configuration::MainSymbol) {
		const QString mainSymbol          = QFileInfo(s).fileName() + "!main";
		const std::shared_ptr<Symbol> sym = edb::v1::symbol_manager().find(mainSymbol);

		if (sym) {
			entryPoint = sym->address;
		} else if (edb::v1::config().find_main) {
			entryPoint = edb::v1::locate_main_function();
		}
	}

	if (entryPoint == 0 || edb::v1::config().initial_breakpoint == Configuration::EntryPoint) {
		entryPoint = edb::v1::debugger_core->process()->entryPoint();
	}

	if (entryPoint != 0) {
		if (std::shared_ptr<IBreakpoint> bp = edb::v1::debugger_core->addBreakpoint(entryPoint)) {
			bp->setOneTime(true);
			bp->setInternal(true);
			bp->tag = initial_bp_tag;
		}
	}
}

//------------------------------------------------------------------------------
// Name: on_action_Restart_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Restart_triggered() {

	Q_ASSERT(edb::v1::debugger_core);
	if (edb::v1::debugger_core->process()) {

		workingDirectory_      = edb::v1::debugger_core->process()->currentWorkingDirectory();
		QList<QByteArray> args = edb::v1::debugger_core->process()->arguments();
		const QString exe      = edb::v1::debugger_core->process()->executable();
		const QString in       = edb::v1::debugger_core->process()->stardardInput();
		const QString out      = edb::v1::debugger_core->process()->stardardOutput();

		if (!args.empty()) {
			args.removeFirst();
		}

		if (!exe.isEmpty()) {
			detachFromProcess(KillOnDetach);
			commonOpen(exe, args, in, out);
		}
	} else {
		// TODO(eteran) pulling from the recent file mananger "works", but has
		// a weird side effect, in that you can "restart" a process before you have
		// run ANY, as long as your history isn't empty
		const RecentFileManager::RecentFile file = recentFileManager_->mostRecent();
		if (commonOpen(file.first, file.second, QString(), QString())) {
			argumentsDialog_->setArguments(file.second);
		}
	}
}

//------------------------------------------------------------------------------
// Name: setup_data_views
// Desc:
//------------------------------------------------------------------------------
void Debugger::setupDataViews() {

	// Setup data views according to debuggee bitness
	if (edb::v1::debuggeeIs64Bit()) {
		stackView_->setAddressSize(QHexView::Address64);
		Q_FOREACH (const std::shared_ptr<DataViewInfo> &data_view, dataRegions_) {
			data_view->view->setAddressSize(QHexView::Address64);
		}
	} else {
		stackView_->setAddressSize(QHexView::Address32);
		Q_FOREACH (const std::shared_ptr<DataViewInfo> &data_view, dataRegions_) {
			data_view->view->setAddressSize(QHexView::Address32);
		}
	}

	// Update stack word width
	stackView_->setWordWidth(edb::v1::pointer_size());
}

//------------------------------------------------------------------------------
// Name: common_open
// Desc:
//------------------------------------------------------------------------------
bool Debugger::commonOpen(const QString &s, const QList<QByteArray> &args, const QString &input, const QString &output) {

	// ensure that the previous running process (if any) is dealth with...
	detachFromProcess(KillOnDetach);

	bool ret = false;
	ttyFile_ = createTty();

	QString process_input  = input.isNull() ? ttyFile_ : input;
	QString process_output = output.isNull() ? ttyFile_ : output;

	if (const Status status = edb::v1::debugger_core->open(s, workingDirectory_, args, process_input, process_output)) {
		attachComplete();
		setInitialBreakpoint(s);
		ret = true;
	} else {
		QMessageBox::critical(
			this,
			tr("Could Not Open"),
			tr("Failed to open and attach to process:\n%1.").arg(status.error()));
	}

	updateUi();
	return ret;
}

//------------------------------------------------------------------------------
// Name: execute
// Desc:
//------------------------------------------------------------------------------
void Debugger::execute(const QString &program, const QList<QByteArray> &args, const QString &input, const QString &output) {
	if (commonOpen(program, args, input, output)) {
		recentFileManager_->addFile(program, args);
		argumentsDialog_->setArguments(args);
	}
}

//------------------------------------------------------------------------------
// Name: open_file
// Desc:
//------------------------------------------------------------------------------
void Debugger::openFile(const QString &filename, const QList<QByteArray> &args) {
	if (!filename.isEmpty()) {
		lastOpenDirectory_ = QFileInfo(filename).canonicalFilePath();

		execute(filename, args, QString(), QString());
	}
}

//------------------------------------------------------------------------------
// Name: attach
// Desc:
//------------------------------------------------------------------------------
void Debugger::attach(edb::pid_t pid) {
#if defined(Q_OS_UNIX)
	edb::pid_t current_pid = getpid();
	while (current_pid != 0) {
		if (current_pid == pid) {

			int ret = QMessageBox::question(this,
											tr("Attaching to parent"),
											tr("You are attempting to attach to a process which is a parent of edb, sometimes, this can lead to deadlocks. Do you want to proceed?"),
											QMessageBox::Yes | QMessageBox::No);
			if (ret != QMessageBox::Yes) {
				return;
			}
		}
		current_pid = edb::v1::debugger_core->parentPid(current_pid);
	}
#endif

	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (pid == process->pid()) {
			QMessageBox::critical(
				this,
				tr("Attach"),
				tr("You are already debugging that process!"));
			return;
		}
	}

	if (const auto status = edb::v1::debugger_core->attach(pid)) {

		workingDirectory_ = edb::v1::debugger_core->process()->currentWorkingDirectory();

		QList<QByteArray> args = edb::v1::debugger_core->process()->arguments();

		if (!args.empty()) {
			args.removeFirst();
		}

		argumentsDialog_->setArguments(args);
		attachComplete();
	} else {
		QMessageBox::critical(this, tr("Attach"), tr("Failed to attach to process: %1").arg(status.error()));
	}

	updateUi();
}

//------------------------------------------------------------------------------
// Name: attachComplete
// Desc:
//------------------------------------------------------------------------------
void Debugger::attachComplete() {
	setInitialDebuggerState();

	testNativeBinary();

	setupDataViews();

	QString ip   = edb::v1::debugger_core->instructionPointer().toUpper();
	QString sp   = edb::v1::debugger_core->stackPointer().toUpper();
	QString bp   = edb::v1::debugger_core->framePointer().toUpper();
	QString word = edb::v1::debuggeeIs64Bit() ? "QWORD" : "DWORD";

	setRIPAction_->setText(tr("&Set %1 to this Instruction").arg(ip));
	gotoRIPAction_->setText(tr("&Goto %1").arg(ip));
	stackGotoRSPAction_->setText(tr("Goto %1").arg(sp));
	stackGotoRBPAction_->setText(tr("Goto %1").arg(bp));
	stackPushAction_->setText(tr("&Push %1").arg(word));
	stackPopAction_->setText(tr("P&op %1").arg(word));

	Q_EMIT attachEvent();
}

//------------------------------------------------------------------------------
// Name: on_action_Open_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Open_triggered() {

	static auto dialog = new DialogOpenProgram(this, tr("Choose a file"), lastOpenDirectory_);

	// Set a sensible default dir
	if (recentFileManager_->entryCount() > 0) {
		const RecentFileManager::RecentFile file = recentFileManager_->mostRecent();
		const QDir dir                           = QFileInfo(file.first).dir();
		if (dir.exists()) {
			dialog->setDirectory(dir);
		}
	}

	if (dialog->exec() == QDialog::Accepted) {

		argumentsDialog_->setArguments(dialog->arguments());
		QStringList files      = dialog->selectedFiles();
		const QString filename = files.front();
		workingDirectory_      = dialog->workingDirectory();
		openFile(filename, dialog->arguments());
	}
}

//------------------------------------------------------------------------------
// Name: on_action_Attach_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Attach_triggered() {

	QPointer<DialogAttach> dlg = new DialogAttach(this);

	if (dlg->exec() == QDialog::Accepted) {
		if (dlg) {
			if (const Result<edb::pid_t, QString> pid = dlg->selectedPid()) {
				attach(*pid);
			}
		}
	}

	delete dlg;
}

//------------------------------------------------------------------------------
// Name: on_action_Memory_Regions_triggered
// Desc: displays the memory regions dialog, and optionally dumps some data
//------------------------------------------------------------------------------
void Debugger::on_action_Memory_Regions_triggered() {
	static QPointer<DialogMemoryRegions> dlg = new DialogMemoryRegions(this);
	dlg->show();
}

//------------------------------------------------------------------------------
// Name: on_action_Threads_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Threads_triggered() {
	static QPointer<DialogThreads> dlg = new DialogThreads(this);
	dlg->show();
}

//------------------------------------------------------------------------------
// Name: mnuDumpCreateTab
// Desc: duplicates the current tab creating a new one
//------------------------------------------------------------------------------
void Debugger::mnuDumpCreateTab() {
	createDataTab();
	tabDelete_->setEnabled(tabWidget_->count() > 1);
}

//------------------------------------------------------------------------------
// Name: mnuDumpDeleteTab
// Desc: handles removing of a memory view tab
//------------------------------------------------------------------------------
void Debugger::mnuDumpDeleteTab() {
	deleteDataTab();
	tabDelete_->setEnabled(tabWidget_->count() > 1);
}

//------------------------------------------------------------------------------
// Name: getPluginContextMenuItems
// Desc: Returns context menu items using supplied function to call for each plugin.
//       NULL pointer items mean "create separator here".
//------------------------------------------------------------------------------
template <class F>
QList<QAction *> Debugger::getPluginContextMenuItems(const F &f) const {
	QList<QAction *> actions;

	for (QObject *plugin : edb::v1::plugin_list()) {
		if (auto p = qobject_cast<IPlugin *>(plugin)) {
			const QList<QAction *> acts = (p->*f)();
			if (!acts.isEmpty()) {
				actions.push_back(nullptr);
				actions.append(acts);
			}
		}
	}
	return actions;
}

//------------------------------------------------------------------------------
// Name: addPluginContextMenu
// Desc:
//------------------------------------------------------------------------------
template <class F, class T>
void Debugger::addPluginContextMenu(const T &menu, const F &f) {
	for (QObject *plugin : edb::v1::plugin_list()) {
		if (auto p = qobject_cast<IPlugin *>(plugin)) {
			const QList<QAction *> acts = (p->*f)();
			if (!acts.isEmpty()) {
				menu->addSeparator();
				menu->addActions(acts);
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: on_action_Plugins_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Plugins_triggered() {
	static auto dlg = new DialogPlugins(this);
	dlg->show();
}

//------------------------------------------------------------------------------
// Name: jump_to_address
// Desc:
//------------------------------------------------------------------------------
bool Debugger::jumpToAddress(edb::address_t address) {

	if (std::shared_ptr<IRegion> region = edb::v1::memory_regions().findRegion(address)) {
		doJumpToAddress(address, region, true);
		return true;
	}

	return false;
}

//------------------------------------------------------------------------------
// Name: dump_data_range
// Desc:
//------------------------------------------------------------------------------
bool Debugger::dumpDataRange(edb::address_t address, edb::address_t end_address, bool new_tab) {

	if (std::shared_ptr<IRegion> region = edb::v1::memory_regions().findRegion(address)) {
		if (new_tab) {
			mnuDumpCreateTab();
		}

		if (std::shared_ptr<DataViewInfo> info = currentDataViewInfo()) {
			info->region = std::shared_ptr<IRegion>(region->clone());

			if (info->region->contains(end_address)) {
				info->region->setEnd(end_address);
			}

			if (info->region->contains(address)) {
				info->region->setStart(address);
			}

			updateData(info);
			return true;
		}
	}

	return false;
}

//------------------------------------------------------------------------------
// Name: dump_data
// Desc:
//------------------------------------------------------------------------------
bool Debugger::dumpData(edb::address_t address, bool new_tab) {

	if (std::shared_ptr<IRegion> region = edb::v1::memory_regions().findRegion(address)) {
		if (new_tab) {
			mnuDumpCreateTab();
		}

		std::shared_ptr<DataViewInfo> info = currentDataViewInfo();

		if (info) {
			info->region = region;
			updateData(info);
			info->view->scrollTo(address - info->region->start());
			return true;
		}
	}

	return false;
}

//------------------------------------------------------------------------------
// Name: dump_stack
// Desc:
//------------------------------------------------------------------------------
bool Debugger::dumpStack(edb::address_t address, bool scroll_to) {
	const std::shared_ptr<IRegion> last_region = stackViewInfo_.region;
	stackViewInfo_.region                      = edb::v1::memory_regions().findRegion(address);

	if (stackViewInfo_.region) {
		stackViewInfo_.update();

		if (IProcess *process = edb::v1::debugger_core->process()) {
			if (std::shared_ptr<IThread> thread = process->currentThread()) {

				State state;
				thread->getState(&state);
				stackView_->setColdZoneEnd(state.stackPointer());

				if (scroll_to || stackViewInfo_.region->equals(last_region)) {
					stackView_->scrollTo(address - stackViewInfo_.region->start());
				}
				return true;
			}
		}
	}

	return false;
}

//------------------------------------------------------------------------------
// Name: tab_context_menu
// Desc:
//------------------------------------------------------------------------------
void Debugger::tabContextMenu(int index, const QPoint &pos) {
	QMenu menu;
	QAction *const actionAdd   = menu.addAction(tr("&Set Label"));
	QAction *const actionClear = menu.addAction(tr("&Clear Label"));
	QAction *const chosen      = menu.exec(tabWidget_->mapToGlobal(pos));

	if (chosen == actionAdd) {
		bool ok;
		const QString text = QInputDialog::getText(
			this,
			tr("Set Caption"),
			tr("Caption:"),
			QLineEdit::Normal,
			tabWidget_->data(index).toString(),
			&ok);

		if (ok && !text.isEmpty()) {
			tabWidget_->setData(index, text);
		}
	} else if (chosen == actionClear) {
		tabWidget_->setData(index, QString());
	}

	updateUi();
}

//------------------------------------------------------------------------------
// Name: next_debug_event
// Desc:
//------------------------------------------------------------------------------
void Debugger::nextDebugEvent() {

	using namespace std::chrono_literals;

	// TODO(eteran): come up with a nice system to inject a debug event
	//               into the system, for example on windows, we want
	//               to deliver real "memory map updated" events, but
	//               on linux, (at least for now), I would want to send
	//               a fake one before every event so it is always up to
	//               date.

	Q_ASSERT(edb::v1::debugger_core);

	if (std::shared_ptr<IDebugEvent> e = edb::v1::debugger_core->waitDebugEvent(10ms)) {

		lastEvent_ = e;

		// TODO(eteran): disable this in favor of only doing it on library load events
		//               once we are confident. We should be able to just enclose it inside
		//               an "if(!dynamic_info_bp_set_) {" test (since we still want to
		//               do this when the hook isn't set.
		edb::v1::memory_regions().sync();

#if defined(Q_OS_LINUX)
		if (!dynamicInfoBreakpointSet_) {
			if (IProcess *process = edb::v1::debugger_core->process()) {
				if (debugtPointer_ == 0) {
					if ((debugtPointer_ = process->debugPointer()) != 0) {
						edb::address_t r_brk = edb::v1::debuggeeIs32Bit() ? find_linker_hook_address<uint32_t>(process, debugtPointer_) : find_linker_hook_address<uint64_t>(process, debugtPointer_);

						if (r_brk) {
							// TODO(eteran): this is equivalent to ld-2.23.so!_dl_debug_state
							// maybe we should prefer setting this by symbol if possible?
							if (std::shared_ptr<IBreakpoint> bp = edb::v1::debugger_core->addBreakpoint(r_brk)) {
								bp->setInternal(true);
								bp->tag                   = ld_loader_tag;
								dynamicInfoBreakpointSet_ = true;
							}
						}
					}
				}
			}
		}
#endif

		Q_EMIT debugEvent();

		const edb::EventStatus status = edb::v1::execute_debug_event_handlers(e);
		switch (status) {
		case edb::DEBUG_STOP:
			updateUi();
			updateMenuState(edb::v1::debugger_core->process() ? Paused : Terminated);
			break;
		case edb::DEBUG_CONTINUE:
			resumeExecution(IgnoreException, Run, ResumeFlag::Forced);
			break;
		case edb::DEBUG_CONTINUE_BP:
			resumeExecution(IgnoreException, Run, ResumeFlag::None);
			break;
		case edb::DEBUG_CONTINUE_STEP:
			resumeExecution(IgnoreException, Step, ResumeFlag::Forced);
			break;
		case edb::DEBUG_EXCEPTION_NOT_HANDLED:
			resumeExecution(PassException, Run, ResumeFlag::Forced);
			break;
		case edb::DEBUG_NEXT_HANDLER:
			// NOTE(eteran): I don't think this is reachable...
			break;
		}
	}
}

//------------------------------------------------------------------------------
// Name: on_action_Help_triggered
// Desc:
//------------------------------------------------------------------------------
void Debugger::on_action_Help_triggered() {
	QDesktopServices::openUrl(QUrl("https://github.com/eteran/edb-debugger/wiki", QUrl::TolerantMode));
}

//------------------------------------------------------------------------------
// Name: statusLabel
// Desc:
//------------------------------------------------------------------------------
QLabel *Debugger::statusLabel() const {
	return status_;
}

```

`src/Debugger.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DEBUGGER_H_20090811_
#define DEBUGGER_H_20090811_

#include "DataViewInfo.h"
#include "IDebugEventHandler.h"
#include "OSTypes.h"
#include "QDisassemblyView.h"
#include "QHexView"
#include "TabWidget.h"

#include <QDockWidget>
#include <QMainWindow>
#include <QProcess>
#include <QVector>

#include <memory>

#include "ui_Debugger.h"

template <class T, class E>
class Result;

class CommentServer;
class DialogArguments;
class IBinary;
class IBreakpoint;
class IDebugEvent;
class IPlugin;
class RecentFileManager;
class TabWidget;

class QDisassemblyView;
class QDockWidget;
class QDragEnterEvent;
class QDropEvent;
class QLabel;
class QListView;
class QMainWindow;
class QPlainTextEdit;
class QSplitter;
class QStringListModel;
class QTimer;
class QToolButton;

class Debugger : public QMainWindow, public IDebugEventHandler {
	Q_OBJECT
public:
	explicit Debugger(QWidget *parent = nullptr);
	Debugger(const Debugger &)            = delete;
	Debugger &operator=(const Debugger &) = delete;
	~Debugger() override;

private:
	enum class ResumeFlag {
		None   = 0,
		Forced = 1,
	};

	enum DebugMode {
		Step,
		Trace,
		Run
	};

	enum ExceptionResume {
		IgnoreException,
		PassException
	};

	enum DetachAction {
		NoKillOnDetach,
		KillOnDetach
	};

	enum GuiState {
		Paused,
		Running,
		Terminated
	};

public:
	std::shared_ptr<DataViewInfo> currentDataViewInfo() const;
	bool dumpData(edb::address_t address, bool new_tab);
	bool dumpDataRange(edb::address_t address, edb::address_t end_address, bool new_tab);
	bool dumpStack(edb::address_t address, bool scroll_to);
	bool jumpToAddress(edb::address_t address);
	int currentTab() const;
	void attach(edb::pid_t pid);
	void clearData(const std::shared_ptr<DataViewInfo> &v);
	void execute(const QString &s, const QList<QByteArray> &args, const QString &input, const QString &output);
	void refreshUi();
	void updateData(const std::shared_ptr<DataViewInfo> &v);
	void updateUi();
	QLabel *statusLabel() const;
	Register activeRegister() const;

Q_SIGNALS:
	void uiUpdated();

	// TODO(eteran): maybe this is better off as a single event
	//               with a type passed?
	void debugEvent();
	void detachEvent();
	void attachEvent();

public Q_SLOTS:
	// the autoconnected slots
	void on_actionAbout_QT_triggered();
	void on_actionApplication_Arguments_triggered();
	void on_actionApplication_Working_Directory_triggered();
	void on_actionRun_Until_Return_triggered();
	void on_actionStep_Out_triggered();
	void on_action_About_triggered();
	void on_action_Attach_triggered();
	void on_action_Configure_Debugger_triggered();
	void on_action_Detach_triggered();
	void on_action_Help_triggered();
	void on_action_Kill_triggered();
	void on_action_Memory_Regions_triggered();
	void on_action_Open_triggered();
	void on_action_Pause_triggered();
	void on_action_Plugins_triggered();
	void on_action_Restart_triggered();
	void on_action_Run_Pass_Signal_To_Application_triggered();
	void on_action_Run_triggered();
	void on_action_Step_Into_Pass_Signal_To_Application_triggered();
	void on_action_Step_Into_triggered();
	void on_action_Step_Over_Pass_Signal_To_Application_triggered();
	void on_action_Step_Over_triggered();
	void on_action_Threads_triggered();

private:
	void toggleFlag(int);
	void runToThisLine(ExceptionResume pass_signal);

private Q_SLOTS:
	// the manually connected general slots
	void mnuModifyBytes();

private Q_SLOTS:
	// the manually connected CPU slots
	void mnuCPUEditComment();
	void mnuCPURemoveComment();
	void mnuCPURunToThisLine();
	void mnuCPURunToThisLinePassSignal();
	void mnuCPUToggleBreakpoint();
	void mnuCPUAddConditionalBreakpoint();
	void mnuCPUFillNop();
	void mnuCPUFillZero();
	void mnuCPUFollow();
	void mnuCPUFollowInDump();
	void mnuCPUFollowInStack();
	void mnuCPUJumpToAddress();
	void mnuCPUJumpToEIP();
	void mnuCPUModify();
	void mnuCPURemoveBreakpoint();
	void mnuCPUSetEIP();
	void mnuCPULabelAddress();
	void breakPointToggled_triggered(edb::address_t);
	void customContextMenuRequested_triggered(const QPoint &);

private Q_SLOTS:
	// the manually connected Register slots
	QList<QAction *> currentRegisterContextMenuItems() const;
	void mnuRegisterFollowInDump() { followRegisterInDump(false); }
	void mnuRegisterFollowInDumpNewTab() { followRegisterInDump(true); }
	void mnuRegisterFollowInStack();

private Q_SLOTS:
	// the manually connected Dump slots
	void mnuDumpContextMenu(const QPoint &pos);
	void mnuDumpCreateTab();
	void mnuDumpDeleteTab();
	void mnuDumpFollowInCPU();
	void mnuDumpFollowInDump();
	void mnuDumpFollowInStack();
	void mnuDumpGotoAddress();
	void mnuDumpModify();
	void mnuDumpSaveToFile();

private Q_SLOTS:
	// the manually connected Stack slots
	void mnuStackContextMenu(const QPoint &);
	void mnuStackFollowInCPU();
	void mnuStackFollowInDump();
	void mnuStackFollowInStack();
	void mnuStackGotoAddress();
	void mnuStackGotoEBP();
	void mnuStackGotoESP();
	void mnuStackModify();
	void mnuStackPop();
	void mnuStackPush();
	void mnuStackToggleLock(bool locked);

private Q_SLOTS:
	void gotoTriggered();
	void nextDebugEvent();
	void openFile(const QString &filename, const QList<QByteArray> &args);
	void tabContextMenu(int index, const QPoint &pos);
	void ttyProcFinished(int exit_code, QProcess::ExitStatus exit_status);

private:
	void closeEvent(QCloseEvent *event) override;
	void dragEnterEvent(QDragEnterEvent *event) override;
	void dropEvent(QDropEvent *event) override;
	void showEvent(QShowEvent *event) override;

public:
	edb::EventStatus handleEvent(const std::shared_ptr<IDebugEvent> &event) override;

private:
	QString createTty();
	QString sessionFilename() const;
	Result<edb::address_t, QString> getGotoExpression();
	Result<edb::reg_t, QString> getFollowRegister() const;
	bool commonOpen(const QString &s, const QList<QByteArray> &args, const QString &input, const QString &output);
	bool isBreakpointConditionTrue(const QString &condition);
	edb::EventStatus handleEventExited(const std::shared_ptr<IDebugEvent> &event);
	edb::EventStatus handleEventStopped(const std::shared_ptr<IDebugEvent> &event);
	edb::EventStatus handleEventTerminated(const std::shared_ptr<IDebugEvent> &event);
	edb::EventStatus handleTrap(const std::shared_ptr<IDebugEvent> &event);
	edb::EventStatus resumeStatus(bool pass_exception);
	std::shared_ptr<IRegion> updateCpuView(const State &state);
	void applyDefaultFonts();
	void applyDefaultShowSeparator();
	void attachComplete();
	void cleanupDebugger();
	void cpuFill(uint8_t byte);
	void createDataTab();
	void deleteDataTab();
	void detachFromProcess(DetachAction kill);
	void doJumpToAddress(edb::address_t address, const std::shared_ptr<IRegion> &r, bool scroll_to);
	void finishPluginSetup();
	void followRegisterInDump(bool tabbed);
	void loadSession(const QString &session_file);
	void resumeExecution(ExceptionResume pass_exception, DebugMode mode, ResumeFlag flags);
	void saveSession(const QString &session_file);
	void setDebuggerCaption(const QString &appname);
	void setInitialBreakpoint(const QString &s);
	void setInitialDebuggerState();
	void setupDataViews();
	void setupStackView();
	void setupTabButtons();
	void setupUi();
	void testNativeBinary();
	void updateDataViews();
	void updateDisassembly(edb::address_t address, const std::shared_ptr<IRegion> &r);
	void updateMenuState(GuiState state);
	void updateStackView(const State &state);
	void updateTabCaption(const std::shared_ptr<QHexView> &view, edb::address_t start, edb::address_t end);

private:
	template <class F>
	QAction *createAction(const QString &text, const QKeySequence &keySequence, F slotPtr);

	template <class F>
	void followMemory(edb::address_t address, F follow_func);

	template <class Ptr>
	Result<edb::address_t, QString> getFollowAddress(const Ptr &hexview);

	template <class F>
	QList<QAction *> getPluginContextMenuItems(const F &f) const;

	template <class F, class T>
	void addPluginContextMenu(const T &menu, const F &f);

	template <class Ptr>
	void followInCpu(const Ptr &hexview);

	template <class Ptr>
	void followInDump(const Ptr &hexview);

	template <class Ptr>
	void followInStack(const Ptr &hexview);

	template <class Ptr>
	void modifyBytes(const Ptr &hexview);

	template <class F1, class F2>
	void stepOver(F1 run_func, F2 step_func);

public:
	Ui::Debugger ui;
	QDisassemblyView *cpuView_ = nullptr;
	QListView *listView_       = nullptr;
	QDockWidget *dataDock_     = nullptr;
	QDockWidget *stackDock_    = nullptr;
	TabWidget *tabWidget_      = nullptr;
	QMainWindow *mainWindow_   = nullptr;
	QPlainTextEdit *logger_    = nullptr;
	QSplitter *splitter_       = nullptr;

private:
	GuiState guiState_                    = Terminated;
	QProcess *ttyProc_                    = nullptr;
	DialogArguments *argumentsDialog_     = nullptr;
	QLabel *status_                       = nullptr;
	QStringListModel *listModel_          = nullptr;
	QTimer *timer_                        = nullptr;
	QToolButton *tabCreate_               = nullptr;
	QToolButton *tabDelete_               = nullptr;
	RecentFileManager *recentFileManager_ = nullptr;
	bool stackViewLocked_                 = false;

#if defined(Q_OS_LINUX)
	edb::address_t debugtPointer_  = 0;
	bool dynamicInfoBreakpointSet_ = false;
#endif

private:
	DataViewInfo stackViewInfo_;
	QString lastOpenDirectory_;
	QString programExecutable_;
	QString ttyFile_;
	QString workingDirectory_;
	QVector<std::shared_ptr<DataViewInfo>> dataRegions_;
	std::shared_ptr<IBreakpoint> reenableBreakpointRun_;
	std::shared_ptr<IBreakpoint> reenableBreakpointStep_;
	std::shared_ptr<CommentServer> commentServer_;
	std::shared_ptr<QHexView> stackView_;
	std::shared_ptr<const IDebugEvent> lastEvent_;
	std::unique_ptr<IBinary> binaryInfo_;

private:
	QAction *gotoAddressAction_;
	QAction *editCommentAction_;
	QAction *editBytesAction_;
	QAction *toggleBreakpointAction_;
	QAction *conditionalBreakpointAction_;
	QAction *runToThisLineAction_;
	QAction *runToLinePassAction_;
	QAction *fillWithZerosAction_;
	QAction *fillWithNOPsAction_;
	QAction *setAddressLabelAction_;
	QAction *followConstantInDumpAction_;
	QAction *followConstantInStackAction_;
	QAction *followAction_;
	QAction *setRIPAction_;
	QAction *gotoRIPAction_;
	QAction *dumpFollowInCPUAction_;
	QAction *dumpFollowInDumpAction_;
	QAction *dumpFollowInStackAction_;
	QAction *dumpSaveToFileAction_;
	QAction *registerFollowInDumpAction_;
	QAction *registerFollowInDumpTabAction_;
	QAction *registerFollowInStackAction_;
	QAction *stackFollowInCPUAction_;
	QAction *stackFollowInDumpAction_;
	QAction *stackFollowInStackAction_;
	QAction *stackGotoRSPAction_;
	QAction *stackGotoRBPAction_;
	QAction *stackPushAction_;
	QAction *stackPopAction_;
};

#endif

```

`src/Debugger.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>Debugger</class>
 <widget class="QMainWindow" name="Debugger">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>800</width>
    <height>700</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>edb</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout"/>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>800</width>
     <height>30</height>
    </rect>
   </property>
   <widget class="QMenu" name="menu_help">
    <property name="title">
     <string>&amp;Help</string>
    </property>
    <addaction name="action_Help"/>
    <addaction name="separator"/>
    <addaction name="action_About"/>
    <addaction name="actionAbout_QT"/>
   </widget>
   <widget class="QMenu" name="menu_View">
    <property name="title">
     <string>&amp;View</string>
    </property>
    <addaction name="action_Memory_Regions"/>
    <addaction name="action_Threads"/>
    <addaction name="actionApplication_Arguments"/>
    <addaction name="separator"/>
    <addaction name="action_Debug_Logger"/>
   </widget>
   <widget class="QMenu" name="menu_Plugins">
    <property name="title">
     <string>&amp;Plugins</string>
    </property>
    <addaction name="action_Plugins"/>
    <addaction name="separator"/>
   </widget>
   <widget class="QMenu" name="menu_Options">
    <property name="title">
     <string>&amp;Options</string>
    </property>
    <addaction name="action_Configure_Debugger"/>
    <addaction name="actionApplication_Working_Directory"/>
   </widget>
   <widget class="QMenu" name="menu_File">
    <property name="title">
     <string>&amp;File</string>
    </property>
    <addaction name="action_Open"/>
    <addaction name="action_Attach"/>
    <addaction name="action_Recent_Files"/>
    <addaction name="separator"/>
    <addaction name="actionE_xit"/>
   </widget>
   <widget class="QMenu" name="menu_Debug">
    <property name="title">
     <string>&amp;Debug</string>
    </property>
    <addaction name="action_Run"/>
    <addaction name="action_Pause"/>
    <addaction name="action_Restart"/>
    <addaction name="action_Detach"/>
    <addaction name="action_Kill"/>
    <addaction name="separator"/>
    <addaction name="action_Step_Into"/>
    <addaction name="action_Step_Over"/>
    <addaction name="separator"/>
    <addaction name="action_Run_Pass_Signal_To_Application"/>
    <addaction name="action_Step_Into_Pass_Signal_To_Application"/>
    <addaction name="action_Step_Over_Pass_Signal_To_Application"/>
    <addaction name="separator"/>
    <addaction name="actionRun_Until_Return"/>
   </widget>
   <addaction name="menu_File"/>
   <addaction name="menu_View"/>
   <addaction name="menu_Debug"/>
   <addaction name="menu_Plugins"/>
   <addaction name="menu_Options"/>
   <addaction name="menu_help"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <widget class="QToolBar" name="toolBar">
   <property name="windowTitle">
    <string>ToolBar</string>
   </property>
   <property name="orientation">
    <enum>Qt::Horizontal</enum>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
   <addaction name="action_Pause"/>
   <addaction name="action_Step_Into"/>
   <addaction name="action_Step_Over"/>
   <addaction name="actionStep_Out"/>
   <addaction name="action_Run"/>
   <addaction name="separator"/>
   <addaction name="action_Debug_Logger"/>
  </widget>
  <action name="action_Open">
   <property name="icon">
    <iconset theme="document-open">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>&amp;Open</string>
   </property>
   <property name="shortcut">
    <string>F3</string>
   </property>
  </action>
  <action name="action_Attach">
   <property name="text">
    <string>&amp;Attach</string>
   </property>
   <property name="shortcut">
    <string>Shift+F3</string>
   </property>
  </action>
  <action name="actionE_xit">
   <property name="icon">
    <iconset theme="application-exit">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>E&amp;xit</string>
   </property>
   <property name="shortcut">
    <string>Alt+X</string>
   </property>
  </action>
  <action name="action_Memory_Regions">
   <property name="icon">
    <iconset theme="memory-slot">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>&amp;Memory Regions</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+M</string>
   </property>
  </action>
  <action name="action_Single_Step">
   <property name="text">
    <string>&amp;Step Into</string>
   </property>
   <property name="shortcut">
    <string/>
   </property>
  </action>
  <action name="action_Run">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset theme="debug-run">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>&amp;Run</string>
   </property>
   <property name="shortcut">
    <string>F9</string>
   </property>
  </action>
  <action name="action_Pause">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset theme="debug-pause">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>&amp;Pause</string>
   </property>
   <property name="shortcut">
    <string>F11</string>
   </property>
  </action>
  <action name="action_Restart">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset theme="debug-restart">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>R&amp;estart</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+F2</string>
   </property>
  </action>
  <action name="action_Detach">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>&amp;Detach</string>
   </property>
   <property name="iconText">
    <string>Detach</string>
   </property>
   <property name="toolTip">
    <string>Detach</string>
   </property>
  </action>
  <action name="action_Step_Into">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset theme="debug-step-into">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>&amp;Step Into</string>
   </property>
   <property name="shortcut">
    <string>F7</string>
   </property>
  </action>
  <action name="action_Step_Over">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset theme="debug-step-over">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>Step &amp;Over</string>
   </property>
   <property name="shortcut">
    <string>F8</string>
   </property>
  </action>
  <action name="action_About">
   <property name="icon">
    <iconset theme="help-about">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>&amp;About</string>
   </property>
  </action>
  <action name="action_Help">
   <property name="enabled">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset theme="help-contents">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>&amp;Help</string>
   </property>
   <property name="shortcut">
    <string>F1</string>
   </property>
  </action>
  <action name="action_Configure_Debugger">
   <property name="icon">
    <iconset theme="configure">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>&amp;Preferences</string>
   </property>
  </action>
  <action name="actionAbout_QT">
   <property name="text">
    <string>About &amp;Qt</string>
   </property>
   <property name="toolTip">
    <string>About Qt</string>
   </property>
  </action>
  <action name="action_Breakpoint_Manager">
   <property name="text">
    <string>&amp;Breakpoint Manager</string>
   </property>
  </action>
  <action name="actionApplication_Arguments">
   <property name="text">
    <string>Application &amp;Arguments</string>
   </property>
  </action>
  <action name="actionRun_Until_Return">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="text">
    <string>Run &amp;Until Return</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+F9</string>
   </property>
  </action>
  <action name="action_Step_Into_Pass_Signal_To_Application">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset theme="debug-step-into">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>Step &amp;Into (Pass Signal To Application)</string>
   </property>
   <property name="shortcut">
    <string>Shift+F7</string>
   </property>
  </action>
  <action name="action_Step_Over_Pass_Signal_To_Application">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset theme="debug-step-over">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>Step O&amp;ver (Pass Signal To Application)</string>
   </property>
   <property name="shortcut">
    <string>Shift+F8</string>
   </property>
  </action>
  <action name="action_Run_Pass_Signal_To_Application">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset theme="debug-run">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>Ru&amp;n (Pass Signal To Application)</string>
   </property>
   <property name="shortcut">
    <string>Shift+F9</string>
   </property>
  </action>
  <action name="action_Recent_Files">
   <property name="icon">
    <iconset theme="document-open-recent">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>&amp;Recent Files</string>
   </property>
  </action>
  <action name="actionApplication_Working_Directory">
   <property name="text">
    <string>Application &amp;Working Directory</string>
   </property>
  </action>
  <action name="action_Kill">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset theme="debug-close">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>&amp;Kill</string>
   </property>
  </action>
  <action name="action_Plugins">
   <property name="icon">
    <iconset theme="plugin">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>&amp;Plugins</string>
   </property>
  </action>
  <action name="action_Threads">
   <property name="text">
    <string>&amp;Threads</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+T</string>
   </property>
  </action>
  <action name="actionStep_Out">
   <property name="enabled">
    <bool>false</bool>
   </property>
   <property name="icon">
    <iconset theme="debug-step-out">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>Step &amp;Out</string>
   </property>
   <property name="toolTip">
    <string>Step Out</string>
   </property>
  </action>
  <action name="action_Debug_Logger">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset theme="dialog-information">
     <normaloff>.</normaloff>.</iconset>
   </property>
   <property name="text">
    <string>Debug Logger</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>actionE_xit</sender>
   <signal>triggered()</signal>
   <receiver>Debugger</receiver>
   <slot>close()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>-1</x>
     <y>-1</y>
    </hint>
    <hint type="destinationlabel">
     <x>494</x>
     <y>437</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`src/DebuggerInternal.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DEBUGGER_INTERNAL_H_20100301_
#define DEBUGGER_INTERNAL_H_20100301_

class QString;
class QObject;

// these are global utility functions which are not part of the exported API

namespace edb {
namespace internal {

bool register_plugin(const QString &filename, QObject *plugin);
void load_function_db();

}
}

#endif

```

`src/DialogAbout.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogAbout.h"
#include "version.h"

//------------------------------------------------------------------------------
// Name: DialogAbout
// Desc: constructor
//------------------------------------------------------------------------------
DialogAbout::DialogAbout(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {
	ui.setupUi(this);
	ui.labelVersion->setText(tr("Version: %1<br>\n"
								"Compiled: %2<br>\n"
								"Git Commit: <a href=\"https://github.com/eteran/edb-debugger/commit/%3\">%3</a>")
								 .arg(EDB_VERSION_STRING, __DATE__, GIT_BRANCH));
}

```

`src/DialogAbout.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_ABOUT_H_20150802_
#define DIALOG_ABOUT_H_20150802_

#include "ui_DialogAbout.h"
#include <QDialog>

class DialogAbout final : public QDialog {
	Q_OBJECT

public:
	explicit DialogAbout(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogAbout() override = default;

private:
	Ui::DialogAbout ui;
};

#endif

```

`src/DialogAbout.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogAbout</class>
 <widget class="QDialog" name="DialogAbout">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>600</width>
    <height>410</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>About edb</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string/>
       </property>
       <property name="pixmap">
        <pixmap resource="debugger.qrc">:/debugger/images/edb100-logo.png</pixmap>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLabel" name="labelVersion">
       <property name="font">
        <font>
         <weight>75</weight>
         <bold>true</bold>
        </font>
       </property>
       <property name="text">
        <string>Version: %1
Compiled: %2
Git Commit: %3</string>
       </property>
       <property name="textFormat">
        <enum>Qt::RichText</enum>
       </property>
       <property name="alignment">
        <set>Qt::AlignRight|Qt::AlignTop|Qt::AlignTrailing</set>
       </property>
       <property name="openExternalLinks">
        <bool>true</bool>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QTabWidget" name="tabWidget">
     <property name="currentIndex">
      <number>0</number>
     </property>
     <widget class="QWidget" name="tab">
      <attribute name="title">
       <string>About</string>
      </attribute>
      <layout class="QGridLayout" name="gridLayout">
       <item row="0" column="0">
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
p, li { white-space: pre-wrap; }
&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Noto Sans'; font-size:10pt; font-weight:400; font-style:normal;&quot;&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;edb (Evan's Debugger) is designed to be an easy to use, modular, and cross platform debugger.&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;More information and updates can be found at &lt;a href=&quot;https://github.com/eteran/edb-debugger&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#2980b9;&quot;&gt;https://github.com/eteran/edb-debugger&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;You can also report bugs an feature requests at &lt;a href=&quot;https://github.com/eteran/edb-debugger/issues&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#2980b9;&quot;&gt;https://github.com/eteran/edb-debugger/issues&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Some icons provided by &lt;a href=&quot;https://icons8.com/license/&quot;&gt;https://icons8.com/license/&lt;/a&gt;&lt;/p&gt;


&lt;p style=&quot; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Written by &lt;a href=&quot;mailto:evan.teran@gmail.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#2980b9;&quot;&gt;Evan Teran&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
         </property>
         <property name="textFormat">
          <enum>Qt::AutoText</enum>
         </property>
         <property name="alignment">
          <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
         </property>
         <property name="wordWrap">
          <bool>true</bool>
         </property>
         <property name="openExternalLinks">
          <bool>true</bool>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByKeyboard|Qt::LinksAccessibleByMouse</set>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_2">
      <attribute name="title">
       <string>Contributors</string>
      </attribute>
      <layout class="QGridLayout" name="gridLayout_2">
       <item row="0" column="0">
        <widget class="QPlainTextEdit" name="plainTextEdit">
         <property name="readOnly">
          <bool>true</bool>
         </property>
         <property name="plainText">
          <string>Original Author
--------------------

Evan teran &lt;evan.teran@gmail.com&gt;

Contributors
-----------------

Ruslan Kabatsayev &lt;https://github.com/10110111&gt;
Fernando Mercês &lt;http://mentebinaria.com.br&gt;
Nicoleau Fabien
&quot;Northern-Lights&quot; &lt;https://github.com/Northern-Lights&gt;
Aaron Opfer
Mohd Shahril &lt;https://github.com/shahril96&gt;
</string>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources>
  <include location="debugger.qrc"/>
 </resources>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>DialogAbout</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>222</x>
     <y>398</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>DialogAbout</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>290</x>
     <y>404</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`src/DialogArguments.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogArguments.h"
#include <QListWidgetItem>

//------------------------------------------------------------------------------
// Name: DialogArguments
// Desc:
//------------------------------------------------------------------------------
DialogArguments::DialogArguments(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {
	ui.setupUi(this);
}

//------------------------------------------------------------------------------
// Name: arguments
// Desc:
//------------------------------------------------------------------------------
QList<QByteArray> DialogArguments::arguments() const {
	QList<QByteArray> ret;
	for (int i = 0; i < ui.listWidget->count(); ++i) {
		ret << ui.listWidget->item(i)->text().toUtf8();
	}
	return ret;
}

//------------------------------------------------------------------------------
// Name: set_arguments
// Desc:
//------------------------------------------------------------------------------
void DialogArguments::setArguments(const QList<QByteArray> &args) {
	ui.listWidget->clear();

	QStringList l;
	for (const QByteArray &ba : args) {
		l << QString::fromUtf8(ba.constData());
	}

	ui.listWidget->addItems(l);
}

```

`src/DialogArguments.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_ARGUMENTS_H_20090609_
#define DIALOG_ARGUMENTS_H_20090609_

#include "ui_DialogArguments.h"
#include <QDialog>

class DialogArguments : public QDialog {
	Q_OBJECT

public:
	explicit DialogArguments(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogArguments() override = default;

public:
	QList<QByteArray> arguments() const;
	void setArguments(const QList<QByteArray> &args);

private:
	Ui::DialogArguments ui;
};

#endif

```

`src/DialogArguments.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogArguments</class>
 <widget class="QDialog" name="DialogArguments">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>454</width>
    <height>250</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Application Arguments</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QListWidget" name="listWidget">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>DialogArguments</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>252</x>
     <y>245</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>DialogArguments</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>320</x>
     <y>245</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`src/DialogAttach.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogAttach.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "ProcessModel.h"
#include "edb.h"
#include "util/String.h"

#include <QHeaderView>
#include <QMap>
#include <QSortFilterProxyModel>

#ifdef Q_OS_WIN32
namespace {

int getuid() {
	return 0;
}

}
#else
#include <unistd.h>
#endif

//------------------------------------------------------------------------------
// Name: DialogAttach
// Desc: constructor
//------------------------------------------------------------------------------
DialogAttach::DialogAttach(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);

	processModel_ = new ProcessModel(this);

	processNameFilter_ = new QSortFilterProxyModel(this);
	processNameFilter_->setSourceModel(processModel_);
	processNameFilter_->setFilterCaseSensitivity(Qt::CaseInsensitive);
	processNameFilter_->setFilterKeyColumn(2);

	processPidFilter_ = new QSortFilterProxyModel(this);
	processPidFilter_->setSourceModel(processNameFilter_);
	processPidFilter_->setFilterCaseSensitivity(Qt::CaseInsensitive);
	processPidFilter_->setFilterKeyColumn(0);

	ui.processes_table->setModel(processPidFilter_);
}

//------------------------------------------------------------------------------
// Name: on_filter_textChanged
// Desc:
//------------------------------------------------------------------------------
void DialogAttach::on_filter_textChanged(const QString &filter) {

	if (util::is_numeric(filter)) {
		processPidFilter_->setFilterFixedString(filter);
		processNameFilter_->setFilterFixedString(QString());
	} else {
		processNameFilter_->setFilterFixedString(filter);
		processPidFilter_->setFilterFixedString(QString());
	}
}

//------------------------------------------------------------------------------
// Name: updateList
// Desc:
//------------------------------------------------------------------------------
void DialogAttach::updateList() {

	if (isHidden()) {
		updateTimer_.stop();
		return;
	}

	const auto selected_pid = selectedPid();

	processModel_->clear();

	if (edb::v1::debugger_core) {
		QMap<edb::pid_t, std::shared_ptr<IProcess>> procs = edb::v1::debugger_core->enumerateProcesses();

		const edb::uid_t user_id = getuid();
		const bool filterUID     = ui.filter_uid->isChecked();

		for (const std::shared_ptr<IProcess> &process : procs) {
			if (!filterUID || process->uid() == user_id) {
				processModel_->addProcess(process);
			}
		}
	}

	if (selected_pid) {
		const auto pid          = selected_pid.value();
		const auto *const model = ui.processes_table->model();
		for (int row = 0; row < model->rowCount(); ++row) {
			if (static_cast<edb::pid_t>(model->index(row, 0).data().toUInt()) == pid) {
				ui.processes_table->selectRow(row);
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: showEvent
// Desc:
//------------------------------------------------------------------------------
void DialogAttach::showEvent(QShowEvent *event) {
	Q_UNUSED(event)
	updateList();
	connect(&updateTimer_, &QTimer::timeout, this, &DialogAttach::updateList);
	updateTimer_.start(1000);
}

//------------------------------------------------------------------------------
// Name: on_filter_uid_clicked
// Desc:
//------------------------------------------------------------------------------
void DialogAttach::on_filter_uid_clicked(bool checked) {
	Q_UNUSED(checked)
	updateList();
}

//------------------------------------------------------------------------------
// Name: on_processes_table_doubleClicked
// Desc:
//------------------------------------------------------------------------------
void DialogAttach::on_processes_table_doubleClicked(const QModelIndex &) {
	if (selectedPid()) {
		accept();
	}
}

//------------------------------------------------------------------------------
// Name: selected_pid
// Desc:
//------------------------------------------------------------------------------
Result<edb::pid_t, QString> DialogAttach::selectedPid() const {

	const QItemSelectionModel *const selModel = ui.processes_table->selectionModel();
	const QModelIndexList sel                 = selModel->selectedRows();

	if (sel.size() == 1) {
		const QModelIndex index = processNameFilter_->mapToSource(processPidFilter_->mapToSource(sel[0]));
		return processModel_->data(index, Qt::UserRole).toInt();
	}

	return make_unexpected(tr("No Selection"));
}

```

`src/DialogAttach.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_ATTACH_H_20091218_
#define DIALOG_ATTACH_H_20091218_

#include "OSTypes.h"

#include <QDialog>
#include <QTimer>

#include "ui_DialogAttach.h"

template <class T, class E>
class Result;

class ProcessModel;
class QSortFilterProxyModel;
class QModelIndex;

class DialogAttach final : public QDialog {
	Q_OBJECT

public:
	explicit DialogAttach(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogAttach() override = default;

private:
	void showEvent(QShowEvent *event) override;

private:
	void updateList();

public Q_SLOTS:
	void on_filter_uid_clicked(bool checked);
	void on_filter_textChanged(const QString &filter);
	void on_processes_table_doubleClicked(const QModelIndex &index);

public:
	Result<edb::pid_t, QString> selectedPid() const;

private:
	Ui::DialogAttach ui;
	ProcessModel *processModel_               = nullptr;
	QSortFilterProxyModel *processNameFilter_ = nullptr;
	QSortFilterProxyModel *processPidFilter_  = nullptr;
	QTimer updateTimer_;
};

#endif

```

`src/DialogAttach.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>DialogAttach</class>
 <widget class="QDialog" name="DialogAttach">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>600</width>
    <height>272</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Attach To Process</string>
  </property>
  <property name="sizeGripEnabled">
   <bool>true</bool>
  </property>
  <property name="modal">
   <bool>true</bool>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="2">
    <widget class="QCheckBox" name="filter_uid">
     <property name="text">
      <string>Only Show Entries For My &amp;UID</string>
     </property>
    </widget>
   </item>
   <item row="2" column="0" colspan="3">
    <widget class="QDialogButtonBox" name="button_box">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
   <item row="1" column="0" colspan="3">
    <widget class="QTableView" name="processes_table">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
    </widget>
   </item>
   <item row="0" column="0" colspan="2">
    <widget class="QLineEdit" name="filter">
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>filter</tabstop>
  <tabstop>filter_uid</tabstop>
  <tabstop>processes_table</tabstop>
  <tabstop>button_box</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>button_box</sender>
   <signal>accepted()</signal>
   <receiver>DialogAttach</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>463</x>
     <y>244</y>
    </hint>
    <hint type="destinationlabel">
     <x>443</x>
     <y>230</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>button_box</sender>
   <signal>rejected()</signal>
   <receiver>DialogAttach</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>554</x>
     <y>250</y>
    </hint>
    <hint type="destinationlabel">
     <x>545</x>
     <y>231</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`src/DialogInputBinaryString.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogInputBinaryString.h"

//------------------------------------------------------------------------------
// Name: DialogInputBinaryString
// Desc: constructor
//------------------------------------------------------------------------------
DialogInputBinaryString::DialogInputBinaryString(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);
}

//------------------------------------------------------------------------------
// Name: binary_string
// Desc: returns the binary string we wrap around
//------------------------------------------------------------------------------
BinaryString *DialogInputBinaryString::binaryString() const {
	return ui.binaryString;
}

```

`src/DialogInputBinaryString.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_INPUT_BINARY_STRING_H_20061127_
#define DIALOG_INPUT_BINARY_STRING_H_20061127_

#include <QDialog>

#include "ui_DialogInputBinaryString.h"

class BinaryString;

class DialogInputBinaryString : public QDialog {
	Q_OBJECT

public:
	explicit DialogInputBinaryString(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogInputBinaryString() override = default;

public:
	BinaryString *binaryString() const;

private:
	Ui::DialogInputBinaryString ui;
};

#endif

```

`src/DialogInputBinaryString.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0" >
 <author>Evan Teran</author>
 <class>DialogInputBinaryString</class>
 <widget class="QDialog" name="DialogInputBinaryString" >
  <property name="geometry" >
   <rect>
    <x>0</x>
    <y>0</y>
    <width>243</width>
    <height>165</height>
   </rect>
  </property>
  <property name="windowTitle" >
   <string>Input Binary String</string>
  </property>
  <layout class="QVBoxLayout" >
   <item>
    <widget class="BinaryString" name="binaryString" />
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox" >
     <property name="orientation" >
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons" >
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <customwidgets>
  <customwidget>
   <class>BinaryString</class>
   <extends>QFrame</extends>
   <header>BinaryString.h</header>
   <container>1</container>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>DialogInputBinaryString</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel" >
     <x>104</x>
     <y>138</y>
    </hint>
    <hint type="destinationlabel" >
     <x>39</x>
     <y>122</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>DialogInputBinaryString</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel" >
     <x>213</x>
     <y>146</y>
    </hint>
    <hint type="destinationlabel" >
     <x>212</x>
     <y>124</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`src/DialogInputValue.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogInputValue.h"
#include "QLongValidator.h"
#include "QULongValidator.h"
#include "Register.h"
#include "edb.h"

#include <QDebug>
#include <QRegExpValidator>

#include <limits>

//------------------------------------------------------------------------------
// Name: DialogInputValue
// Desc:
//------------------------------------------------------------------------------
DialogInputValue::DialogInputValue(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);

	// Apply some defaults
	ui.hexInput->setValidator(new QRegExpValidator(QRegExp("[A-Fa-f0-9]{0,16}"), this));
	ui.signedInput->setValidator(new QLongValidator(std::numeric_limits<long long>::min(), std::numeric_limits<long long>::max(), this));
	ui.unsignedInput->setValidator(new QULongValidator(0, std::numeric_limits<unsigned long long>::max(), this));
}

//------------------------------------------------------------------------------
// Name: value
// Desc:
//------------------------------------------------------------------------------
edb::reg_t DialogInputValue::value() const {
	bool ok;
	return mask_ & edb::reg_t::fromHexString(ui.hexInput->text(), &ok);
}

//------------------------------------------------------------------------------
// Name: setValue
// Desc:
//------------------------------------------------------------------------------
void DialogInputValue::setValue(Register &reg) {
	if (reg.bitSize() > sizeof(edb::reg_t) * 8) {
		qWarning() << "Warning: DialogInputValue::setValue(tooLargeRegister): such large registers are not supported yet";
		return;
	}

	ui.hexInput->setText(reg.toHexString());
	ui.signedInput->setText(QString("%1").arg(reg.valueAsSignedInteger()));
	ui.unsignedInput->setText(QString("%1").arg(reg.valueAsInteger()));

	const auto regex                = QString("[A-Fa-f0-9]{0,%1}").arg(reg.bitSize() / 4);
	const std::uint64_t unsignedMax = (reg.bitSize() == 64 ? -1 : (1ull << (reg.bitSize())) - 1); // Avoid UB
	const std::int64_t signedMin    = 1ull << (reg.bitSize() - 1);
	const std::int64_t signedMax    = unsignedMax >> 1;
	mask_                           = unsignedMax;
	valueLength_                    = reg.bitSize() / 8;

	ui.hexInput->setValidator(new QRegExpValidator(QRegExp(regex), this));
	ui.signedInput->setValidator(new QLongValidator(signedMin, signedMax, this));
	ui.unsignedInput->setValidator(new QULongValidator(0, unsignedMax, this));
}

//------------------------------------------------------------------------------
// Name: on_hexInput_textEdited
// Desc:
//------------------------------------------------------------------------------
void DialogInputValue::on_hexInput_textEdited(const QString &s) {
	bool ok;
	auto value = edb::reg_t::fromHexString(s, &ok);

	if (!ok) {
		value = 0;
	}

	ui.signedInput->setText(value.signExtended(valueLength_).signedToString());
	ui.unsignedInput->setText(value.unsignedToString());
}

//------------------------------------------------------------------------------
// Name: on_signedInput_textEdited
// Desc:
//------------------------------------------------------------------------------
void DialogInputValue::on_signedInput_textEdited(const QString &s) {
	bool ok;
	auto value = edb::reg_t::fromSignedString(s, &ok);

	if (!ok) {
		value = 0;
	}

	ui.hexInput->setText(value.toHexString());
	ui.unsignedInput->setText(value.unsignedToString());
}

//------------------------------------------------------------------------------
// Name: on_unsignedInput_textEdited
// Desc:
//------------------------------------------------------------------------------
void DialogInputValue::on_unsignedInput_textEdited(const QString &s) {
	bool ok;
	auto value = edb::reg_t::fromString(s, &ok);

	if (!ok) {
		value = 0;
	}

	ui.hexInput->setText(value.toHexString());
	ui.signedInput->setText(value.signedToString());
}

```

`src/DialogInputValue.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_INPUT_VALUE_H_20061101_
#define DIALOG_INPUT_VALUE_H_20061101_

#include "Types.h"

#include <QDialog>

#include "ui_DialogInputValue.h"

class Register;

class DialogInputValue : public QDialog {
	Q_OBJECT

public:
	explicit DialogInputValue(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogInputValue() override = default;

public Q_SLOTS:
	void on_hexInput_textEdited(const QString &);
	void on_signedInput_textEdited(const QString &);
	void on_unsignedInput_textEdited(const QString &);

public:
	edb::reg_t value() const;
	void setValue(Register &reg);

private:
	Ui::DialogInputValue ui;
	edb::reg_t mask_         = -1ll;
	std::size_t valueLength_ = sizeof(std::uint64_t);
};

#endif

```

`src/DialogInputValue.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0" >
 <author>Evan Teran</author>
 <class>DialogInputValue</class>
 <widget class="QDialog" name="DialogInputValue" >
  <property name="geometry" >
   <rect>
    <x>0</x>
    <y>0</y>
    <width>228</width>
    <height>198</height>
   </rect>
  </property>
  <property name="sizePolicy" >
   <sizepolicy vsizetype="Fixed" hsizetype="Fixed" >
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="windowTitle" >
   <string>Input Value</string>
  </property>
  <property name="modal" >
   <bool>true</bool>
  </property>
  <layout class="QVBoxLayout" >
   <item>
    <widget class="QLabel" name="label" >
     <property name="text" >
      <string>Hexdecimal</string>
     </property>
     <property name="buddy" >
      <cstring>hexInput</cstring>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLineEdit" name="hexInput" />
   </item>
   <item>
    <widget class="QLabel" name="label_2" >
     <property name="text" >
      <string>Signed</string>
     </property>
     <property name="buddy" >
      <cstring>signedInput</cstring>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLineEdit" name="signedInput" />
   </item>
   <item>
    <widget class="QLabel" name="label_3" >
     <property name="text" >
      <string>Unsigned</string>
     </property>
     <property name="buddy" >
      <cstring>unsignedInput</cstring>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLineEdit" name="unsignedInput" />
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox" >
     <property name="orientation" >
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons" >
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>hexInput</tabstop>
  <tabstop>signedInput</tabstop>
  <tabstop>unsignedInput</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>DialogInputValue</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel" >
     <x>95</x>
     <y>176</y>
    </hint>
    <hint type="destinationlabel" >
     <x>55</x>
     <y>157</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>DialogInputValue</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel" >
     <x>168</x>
     <y>176</y>
    </hint>
    <hint type="destinationlabel" >
     <x>177</x>
     <y>158</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`src/DialogMemoryRegions.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogMemoryRegions.h"
#include "IDebugger.h"
#include "IRegion.h"
#include "MemoryRegions.h"
#include "edb.h"

#include <QDebug>
#include <QHeaderView>
#include <QItemSelectionModel>
#include <QMenu>
#include <QSortFilterProxyModel>
#include <QString>

//------------------------------------------------------------------------------
// Name: DialogMemoryRegions
// Desc:
//------------------------------------------------------------------------------
DialogMemoryRegions::DialogMemoryRegions(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {
	ui.setupUi(this);

	ui.regions_table->verticalHeader()->hide();
	ui.regions_table->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
	filterModel_ = new QSortFilterProxyModel(this);

	connect(ui.filter, &QLineEdit::textChanged, filterModel_, &QSortFilterProxyModel::setFilterFixedString);
}

//------------------------------------------------------------------------------
// Name: showEvent
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::showEvent(QShowEvent *) {

	filterModel_->setFilterKeyColumn(3);
	filterModel_->setSourceModel(&edb::v1::memory_regions());
	ui.regions_table->setModel(filterModel_);
}

//------------------------------------------------------------------------------
// Name: on_regions_table_customContextMenuRequested
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::on_regions_table_customContextMenuRequested(const QPoint &pos) {

	QMenu menu;
	auto access_menu = new QMenu(tr("Set Access"), this);
	access_menu->addAction(tr("No Access"), this, SLOT(setAccessNone()));   // ---
	access_menu->addAction(tr("Read Only"), this, SLOT(setAccessR()));      // r--
	access_menu->addAction(tr("Write Only"), this, SLOT(setAccessW()));     // -w-
	access_menu->addAction(tr("Execute Only"), this, SLOT(setAccessX()));   // --x
	access_menu->addAction(tr("Read/Write"), this, SLOT(setAccessRW()));    // rw-
	access_menu->addAction(tr("Read/Execute"), this, SLOT(setAccessRX()));  // r-x
	access_menu->addAction(tr("Write/Execute"), this, SLOT(setAccessWX())); // -wx
	access_menu->addAction(tr("Full Access"), this, SLOT(setAccessRWX()));  // rwx

	menu.addMenu(access_menu);
	menu.addSeparator();
	menu.addAction(tr("View in &CPU"), this, SLOT(viewInCpu()));
	menu.addAction(tr("View in &Stack"), this, SLOT(viewInStack()));
	menu.addAction(tr("View in &Dump"), this, SLOT(viewInDump()));
	menu.exec(ui.regions_table->mapToGlobal(pos));
}

//------------------------------------------------------------------------------
// Name: selected_region
// Desc:
//------------------------------------------------------------------------------
std::shared_ptr<IRegion> DialogMemoryRegions::selectedRegion() const {
	const QItemSelectionModel *const selModel = ui.regions_table->selectionModel();
	const QModelIndexList sel                 = selModel->selectedRows();

	if (sel.size() == 1) {
		const QModelIndex index = filterModel_->mapToSource(sel[0]);
		return *reinterpret_cast<std::shared_ptr<IRegion> *>(index.internalPointer());
	}

	return {};
}

//------------------------------------------------------------------------------
// Name: set_permissions
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::setPermissions(bool read, bool write, bool execute) {
	if (std::shared_ptr<IRegion> region = selectedRegion()) {
		region->setPermissions(read, write, execute);
		edb::v1::memory_regions().sync();
	}
}

//------------------------------------------------------------------------------
// Name: set_access_none
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::setAccessNone() {
	setPermissions(false, false, false);
}

//------------------------------------------------------------------------------
// Name: set_access_r
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::setAccessR() {
	setPermissions(true, false, false);
}

//------------------------------------------------------------------------------
// Name: set_access_w
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::setAccessW() {
	setPermissions(false, true, false);
}

//------------------------------------------------------------------------------
// Name: set_access_x
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::setAccessX() {
	setPermissions(false, false, true);
}

//------------------------------------------------------------------------------
// Name: set_access_rw
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::setAccessRW() {
	setPermissions(true, true, false);
}

//------------------------------------------------------------------------------
// Name: set_access_rx
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::setAccessRX() {
	setPermissions(true, false, true);
}

//------------------------------------------------------------------------------
// Name: set_access_wx
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::setAccessWX() {
	setPermissions(false, true, true);
}

//------------------------------------------------------------------------------
// Name: set_access_rwx
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::setAccessRWX() {
	setPermissions(true, true, true);
}

//------------------------------------------------------------------------------
// Name: view_in_cpu
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::viewInCpu() {
	if (std::shared_ptr<IRegion> region = selectedRegion()) {
		edb::v1::jump_to_address(region->start());
	}
}

//------------------------------------------------------------------------------
// Name: view_in_stack
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::viewInStack() {
	if (std::shared_ptr<IRegion> region = selectedRegion()) {
		edb::v1::dump_stack(region->start(), true);
	}
}

//------------------------------------------------------------------------------
// Name: view_in_dump
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::viewInDump() {
	if (std::shared_ptr<IRegion> region = selectedRegion()) {
		edb::v1::dump_data(region->start(), true);
	}
}

//------------------------------------------------------------------------------
// Name: on_regions_table_doubleClicked
// Desc:
//------------------------------------------------------------------------------
void DialogMemoryRegions::on_regions_table_doubleClicked(const QModelIndex &index) {
	Q_UNUSED(index)
	if (std::shared_ptr<IRegion> region = selectedRegion()) {
		if (region->executable()) {
			edb::v1::jump_to_address(region->start());
		} else {
			edb::v1::dump_data(region->start(), true);
		}
	}
}

```

`src/DialogMemoryRegions.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_MEMORY_REGIONS_H_20061101_
#define DIALOG_MEMORY_REGIONS_H_20061101_

#include <QDialog>

#include <memory>

#include "ui_DialogMemoryRegions.h"

class IRegion;

class QSortFilterProxyModel;
class QModelIndex;

class DialogMemoryRegions : public QDialog {
	Q_OBJECT
public:
	explicit DialogMemoryRegions(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogMemoryRegions() override = default;

private:
	void showEvent(QShowEvent *event) override;

private Q_SLOTS:
	void on_regions_table_customContextMenuRequested(const QPoint &pos);
	void on_regions_table_doubleClicked(const QModelIndex &index);
	void setAccessNone();
	void setAccessR();
	void setAccessW();
	void setAccessX();
	void setAccessRW();
	void setAccessRX();
	void setAccessWX();
	void setAccessRWX();
	void viewInCpu();
	void viewInStack();
	void viewInDump();

private:
	std::shared_ptr<IRegion> selectedRegion() const;
	void setPermissions(bool read, bool write, bool execute);

private:
	Ui::DialogMemoryRegions ui;
	QSortFilterProxyModel *filterModel_ = nullptr;
};

#endif

```

`src/DialogMemoryRegions.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>DialogMemoryRegions</class>
 <widget class="QDialog" name="DialogMemoryRegions">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>632</width>
    <height>321</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Memory Regions</string>
  </property>
  <property name="sizeGripEnabled">
   <bool>true</bool>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLineEdit" name="filter">
     <property name="placeholderText">
      <string>Filter</string>
     </property>
     <property name="clearButtonEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QTableView" name="regions_table">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="contextMenuPolicy">
      <enum>Qt::CustomContextMenu</enum>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="button_box">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>filter</tabstop>
  <tabstop>regions_table</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>button_box</sender>
   <signal>rejected()</signal>
   <receiver>DialogMemoryRegions</receiver>
   <slot>close()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>457</x>
     <y>307</y>
    </hint>
    <hint type="destinationlabel">
     <x>481</x>
     <y>289</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>button_box</sender>
   <signal>accepted()</signal>
   <receiver>DialogMemoryRegions</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>230</x>
     <y>298</y>
    </hint>
    <hint type="destinationlabel">
     <x>228</x>
     <y>278</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`src/DialogOpenProgram.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogOpenProgram.h"
#include "edb.h"

#include <QDebug>
#include <QGridLayout>
#include <QLabel>
#include <QLineEdit>
#include <QPushButton>

/**
 * @brief DialogOpenProgram::DialogOpenProgram
 * @param parent
 * @param caption
 * @param directory
 * @param filter
 */
DialogOpenProgram::DialogOpenProgram(QWidget *parent, const QString &caption, const QString &directory, const QString &filter)
	: QFileDialog(parent, caption, directory, filter),
	  argsEdit_(new QLineEdit(this)),
	  workDir_(new QLineEdit(QDir::currentPath(), this)) {

	setOptions(QFileDialog::DontUseNativeDialog);

	auto layout = qobject_cast<QGridLayout *>(this->layout());

	// We want to be sure that the layout is as we expect it
	if (layout && layout->rowCount() == 4 && layout->columnCount() == 3) {
		setFileMode(QFileDialog::ExistingFile);

		const int rowCount = layout->rowCount();
		QPushButton *const browseDirButton(new QPushButton(tr("&Browse..."), this));

		const auto argsLabel = new QLabel(tr("Program &arguments:"), this);
		argsLabel->setBuddy(argsEdit_);
		layout->addWidget(argsLabel, rowCount, 0);
		layout->addWidget(argsEdit_, rowCount, 1);

		const auto workDirLabel = new QLabel(tr("Working &directory:"), this);
		workDirLabel->setBuddy(workDir_);
		layout->addWidget(workDirLabel, rowCount + 1, 0);
		layout->addWidget(workDir_, rowCount + 1, 1);
		layout->addWidget(browseDirButton, rowCount + 1, 2);

		connect(browseDirButton, &QPushButton::clicked, this, &DialogOpenProgram::browsePressed);
	} else {
		qWarning() << tr("Failed to setup program arguments and working directory entries for file open dialog, please report and be sure to tell your Qt version");
	}
}

/**
 * @brief DialogOpenProgram::browsePressed
 */
void DialogOpenProgram::browsePressed() {
	const QString dir = QFileDialog::getExistingDirectory(this, tr("Choose program working directory"), workDir_->text());
	if (!dir.isEmpty()) {
		workDir_->setText(dir);
	}
}

/**
 * @brief DialogOpenProgram::arguments
 * @return
 */
QList<QByteArray> DialogOpenProgram::arguments() const {
	const QStringList args = edb::v1::parse_command_line(argsEdit_->text());
	QList<QByteArray> ret;
	for (const QString &arg : args) {
		ret << arg.toLocal8Bit();
	}
	return ret;
}

/**
 * @brief DialogOpenProgram::workingDirectory
 * @return
 */
QString DialogOpenProgram::workingDirectory() const {
	return workDir_->text();
}

```

`src/DialogOpenProgram.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_OPEN_PROGRAM_H_20151117_
#define DIALOG_OPEN_PROGRAM_H_20151117_

#include <QFileDialog>
#include <QList>

class QLineEdit;
class QByteArray;

class DialogOpenProgram : public QFileDialog {
	Q_OBJECT

public:
	explicit DialogOpenProgram(QWidget *parent = nullptr, const QString &caption = QString(), const QString &directory = QString(), const QString &filter = QString());

public:
	QList<QByteArray> arguments() const;
	QString workingDirectory() const;

private Q_SLOTS:
	void browsePressed();

private:
	QLineEdit *argsEdit_;
	QLineEdit *workDir_;
};

#endif

```

`src/DialogOptions.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogOptions.h"
#include "Configuration.h"
#include "IDebugger.h"
#include "Theme.h"
#include "edb.h"

#include <QCloseEvent>
#include <QDebug>
#include <QFileDialog>
#include <QFont>
#include <QFontDialog>
#include <QToolBox>

namespace {

//------------------------------------------------------------------------------
// Name: width_to_index
// Desc:
//------------------------------------------------------------------------------
constexpr int width_to_index(int n) {
	switch (n) {
	case 16:
		return 4;
	case 8:
		return 3;
	case 4:
		return 2;
	case 2:
		return 1;
	default:
		return 0;
	}
}
}

//------------------------------------------------------------------------------
// Name: DialogOptions
// Desc:
//------------------------------------------------------------------------------
DialogOptions::DialogOptions(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);

	ui.comboTheme->addItem(tr("System"), "System");
	ui.comboTheme->addItem(tr("Dark [Built-in]"), "Dark [Built-in]");
	ui.comboTheme->addItem(tr("Light [Built-in]"), "Light [Built-in]");
}

//------------------------------------------------------------------------------
// Name: font_from_dialog
// Desc:
//------------------------------------------------------------------------------
QString DialogOptions::fontFromDialog(const QString &default_font) {
	QFont old_font;
	old_font.fromString(default_font);
	return QFontDialog::getFont(nullptr, old_font, this).toString();
}

//------------------------------------------------------------------------------
// Name: addOptionsPage
// Desc:
//------------------------------------------------------------------------------
void DialogOptions::addOptionsPage(QWidget *page) {

	if (!toolbox_) {
		delete ui.tabWidget->findChild<QLabel *>("label_plugins");
		QWidget *const tab        = ui.tabWidget->findChild<QLabel *>("tab_plugins");
		QGridLayout *const layout = ui.tabWidget->findChild<QGridLayout *>("tab_plugins_layout");
		toolbox_                  = new QToolBox(tab);
		layout->addWidget(toolbox_, 0, 0, 1, 1);
	}

	toolbox_->addItem(page, QIcon::fromTheme("plugin"), page->windowTitle());
}

//------------------------------------------------------------------------------
// Name: directoryFromDialog
// Desc:
//------------------------------------------------------------------------------
QString DialogOptions::directoryFromDialog() {
	return QFileDialog::getExistingDirectory(
		this,
		tr("Choose a directory"),
		QString(),
		QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
}

//------------------------------------------------------------------------------
// Name: on_btnTTY_clicked
// Desc:
//------------------------------------------------------------------------------
void DialogOptions::on_btnTTY_clicked() {
	const QString filename = QFileDialog::getOpenFileName(
		this,
		tr("Choose Your Terminal Program"));

	ui.txtTTY->setText(filename);
}

//------------------------------------------------------------------------------
// Name: on_btnSymbolDir_clicked
// Desc:
//------------------------------------------------------------------------------
void DialogOptions::on_btnSymbolDir_clicked() {
	const QString s = directoryFromDialog();

	if (!s.isEmpty()) {
		ui.txtSymbolDir->setText(s);
	}
}

//------------------------------------------------------------------------------
// Name: on_btnSessionDir_clicked
// Desc:
//------------------------------------------------------------------------------
void DialogOptions::on_btnSessionDir_clicked() {
	const QString s = directoryFromDialog();

	if (!s.isEmpty()) {
		ui.txtSessionDir->setText(s);
	}
}

//------------------------------------------------------------------------------
// Name: on_btnPluginDir_clicked
// Desc:
//------------------------------------------------------------------------------
void DialogOptions::on_btnPluginDir_clicked() {
	const QString s = directoryFromDialog();

	if (!s.isEmpty()) {
		ui.txtPluginDir->setText(s);
	}
}

//------------------------------------------------------------------------------
// Name: showEvent
// Desc:
//------------------------------------------------------------------------------
void DialogOptions::showEvent(QShowEvent *event) {

	QDialog::showEvent(event);

	const Configuration &config = edb::v1::config();

	ui.chkHexOffsets->setChecked(config.function_offsets_in_hex);

	ui.rdoSytntaxATT->setChecked(config.syntax == Configuration::Att);
	ui.rdoSytntaxIntel->setChecked(config.syntax != Configuration::Att);

	ui.rdoDetach->setChecked(config.close_behavior == Configuration::Detach);
	ui.rdoKill->setChecked(config.close_behavior == Configuration::Kill);
	ui.rdoReverseCapture->setChecked(config.close_behavior == Configuration::KillIfLaunchedDetachIfAttached);

	ui.rdoBPEntry->setChecked(config.initial_breakpoint == Configuration::EntryPoint);
	ui.rdoBPMain->setChecked(config.initial_breakpoint != Configuration::EntryPoint);

	ui.chkTTY->setChecked(config.tty_enabled);
	ui.txtTTY->setText(config.tty_command);

	ui.chkDeleteStaleSymbols->setChecked(config.remove_stale_symbols);
	ui.chkDisableASLR->setChecked(config.disableASLR);
	ui.chkDisableLazyBinding->setChecked(config.disableLazyBinding);

	ui.chkBreakOnLibraryLoad->setChecked(config.break_on_library_load);

	ui.chkZerosAreFilling->setChecked(config.zeros_are_filling);
	ui.chkRegisterBadges->setChecked(config.show_register_badges);
	ui.chkUppercase->setChecked(config.uppercase_disassembly);
	ui.chkSyntaxHighlighting->setChecked(config.syntax_highlighting_enabled);

	ui.chkFindMain->setChecked(config.find_main);
	ui.chkWarnDataBreakpoint->setChecked(config.warn_on_no_exec_bp);

	ui.spnMinString->setValue(config.min_string_length);

	ui.stackFont->setCurrentFont(config.stack_font);
	ui.dataFont->setCurrentFont(config.data_font);
	ui.registerFont->setCurrentFont(config.registers_font);
	ui.disassemblyFont->setCurrentFont(config.disassembly_font);

	ui.txtSymbolDir->setText(config.symbol_path);
	ui.txtPluginDir->setText(config.plugin_path);
	ui.txtSessionDir->setText(config.session_path);

	ui.chkDataShowAddress->setChecked(config.data_show_address);
	ui.chkDataShowHex->setChecked(config.data_show_hex);
	ui.chkDataShowAscii->setChecked(config.data_show_ascii);
	ui.chkDataShowComments->setChecked(config.data_show_comments);
	ui.cmbDataWordWidth->setCurrentIndex(width_to_index(config.data_word_width));
	ui.cmbDataRowWidth->setCurrentIndex(width_to_index(config.data_row_width));

	ui.chkAddressColon->setChecked(config.show_address_separator);

	ui.chkShowJumpArrow->setChecked(config.show_jump_arrow);

	ui.signalsMessageBoxEnable->setChecked(config.enable_signals_message_box);

	ui.chkTabBetweenMnemonicAndOperands->setChecked(config.tab_between_mnemonic_and_operands);
	ui.chkShowLocalModuleName->setChecked(config.show_local_module_name_in_jump_targets);
	ui.chkShowSymbolicAddresses->setChecked(config.show_symbolic_addresses);
	ui.chkSimplifyRIPRelativeTargets->setChecked(config.simplify_rip_relative_targets);

	ui.rdoPlaceDefault->setChecked(config.startup_window_location == Configuration::SystemDefault);
	ui.rdoPlaceCentered->setChecked(config.startup_window_location == Configuration::Centered);
	ui.rdoPlaceRestore->setChecked(config.startup_window_location == Configuration::Restore);

	ui.listIgnoredExceptions->clear();
	if (edb::v1::debugger_core) {
		QMap<qlonglong, QString> known_exceptions = edb::v1::debugger_core->exceptions();

		for (auto it = known_exceptions.begin(); it != known_exceptions.end(); ++it) {
			auto item = new QListWidgetItem(*it, ui.listIgnoredExceptions);
			item->setFlags(item->flags() | Qt::ItemIsUserCheckable);

			if (config.ignored_exceptions.contains(it.key())) {
				item->setCheckState(Qt::Checked);
			} else {
				item->setCheckState(Qt::Unchecked);
			}
			item->setData(Qt::UserRole, it.key());
		}
	}

	if (IDebugger *core = edb::v1::debugger_core) {
		const auto &bps  = core->supportedBreakpointTypes();
		const auto combo = ui.cmbDefaultBreakpointType;
		combo->clear();
		const auto chosen = config.default_breakpoint_type;
		for (const auto &type : bps) {
			combo->addItem(type.description, QVariant::fromValue(type.type));
			if (type.type == chosen)
				combo->setCurrentIndex(combo->count() - 1);
		}
	}

	// setup the theme list ONCE
	if (currentThemeName_.isEmpty()) {
		QStringList themes = Theme::userThemes();
		for (QString &theme : themes) {
			QString name = Theme::themeName(theme);
			ui.comboTheme->addItem(name, theme);
		}

		int index = ui.comboTheme->findData(config.theme_name);
		if (index == -1) {
			qDebug("Theme not found, defaulting to System");
			index = 0;
		}
		ui.comboTheme->setCurrentIndex(index);
	}

	currentThemeName_ = ui.comboTheme->currentData().toString();
}

//------------------------------------------------------------------------------
// Name: closeEvent
// Desc:
//------------------------------------------------------------------------------
void DialogOptions::closeEvent(QCloseEvent *event) {

	Configuration &config = edb::v1::config();

	if (ui.rdoSytntaxIntel->isChecked()) {
		config.syntax = Configuration::Intel;
	} else if (ui.rdoSytntaxATT->isChecked()) {
		config.syntax = Configuration::Att;
	}

	config.tab_between_mnemonic_and_operands      = ui.chkTabBetweenMnemonicAndOperands->isChecked();
	config.show_local_module_name_in_jump_targets = ui.chkShowLocalModuleName->isChecked();
	config.show_symbolic_addresses                = ui.chkShowSymbolicAddresses->isChecked();
	config.simplify_rip_relative_targets          = ui.chkSimplifyRIPRelativeTargets->isChecked();

	if (ui.rdoDetach->isChecked()) {
		config.close_behavior = Configuration::Detach;
	} else if (ui.rdoKill->isChecked()) {
		config.close_behavior = Configuration::Kill;
	} else if (ui.rdoReverseCapture->isChecked()) {
		config.close_behavior = Configuration::KillIfLaunchedDetachIfAttached;
	}

	config.stack_font              = ui.stackFont->currentFont().toString();
	config.data_font               = ui.dataFont->currentFont().toString();
	config.registers_font          = ui.registerFont->currentFont().toString();
	config.disassembly_font        = ui.disassemblyFont->currentFont().toString();
	config.tty_command             = ui.txtTTY->text();
	config.tty_enabled             = ui.chkTTY->isChecked();
	config.remove_stale_symbols    = ui.chkDeleteStaleSymbols->isChecked();
	config.disableASLR             = ui.chkDisableASLR->isChecked();
	config.disableLazyBinding      = ui.chkDisableLazyBinding->isChecked();
	config.break_on_library_load   = ui.chkBreakOnLibraryLoad->isChecked();
	config.default_breakpoint_type = ui.cmbDefaultBreakpointType->itemData(ui.cmbDefaultBreakpointType->currentIndex()).value<IBreakpoint::TypeId>();

	config.function_offsets_in_hex = ui.chkHexOffsets->isChecked();
	config.show_jump_arrow         = ui.chkShowJumpArrow->isChecked();

	config.zeros_are_filling           = ui.chkZerosAreFilling->isChecked();
	config.show_register_badges        = ui.chkRegisterBadges->isChecked();
	config.uppercase_disassembly       = ui.chkUppercase->isChecked();
	config.syntax_highlighting_enabled = ui.chkSyntaxHighlighting->isChecked();

	config.symbol_path  = ui.txtSymbolDir->text();
	config.plugin_path  = ui.txtPluginDir->text();
	config.session_path = ui.txtSessionDir->text();

	if (ui.rdoBPMain->isChecked()) {
		config.initial_breakpoint = Configuration::MainSymbol;
	} else if (ui.rdoBPEntry->isChecked()) {
		config.initial_breakpoint = Configuration::EntryPoint;
	}

	config.warn_on_no_exec_bp = ui.chkWarnDataBreakpoint->isChecked();
	config.find_main          = ui.chkFindMain->isChecked();

	config.show_address_separator = ui.chkAddressColon->isChecked();

	config.min_string_length = ui.spnMinString->value();

	config.data_show_address  = ui.chkDataShowAddress->isChecked();
	config.data_show_hex      = ui.chkDataShowHex->isChecked();
	config.data_show_ascii    = ui.chkDataShowAscii->isChecked();
	config.data_show_comments = ui.chkDataShowComments->isChecked();
	config.data_word_width    = 1 << ui.cmbDataWordWidth->currentIndex();
	config.data_row_width     = 1 << ui.cmbDataRowWidth->currentIndex();

	CapstoneEDB::Formatter::FormatOptions options = edb::v1::formatter().options();
	options.capitalization                        = config.uppercase_disassembly ? CapstoneEDB::Formatter::UpperCase : CapstoneEDB::Formatter::LowerCase;
	options.syntax                                = static_cast<CapstoneEDB::Formatter::Syntax>(config.syntax);
	options.tabBetweenMnemonicAndOperands         = config.tab_between_mnemonic_and_operands;
	options.simplifyRIPRelativeTargets            = config.simplify_rip_relative_targets;
	edb::v1::formatter().setOptions(options);

	config.enable_signals_message_box = ui.signalsMessageBoxEnable->isChecked();

	if (ui.rdoPlaceDefault->isChecked()) {
		config.startup_window_location = Configuration::SystemDefault;
	} else if (ui.rdoPlaceCentered->isChecked()) {
		config.startup_window_location = Configuration::Centered;
	} else if (ui.rdoPlaceRestore->isChecked()) {
		config.startup_window_location = Configuration::Restore;
	}

	config.ignored_exceptions.clear();
	for (int i = 0; i < ui.listIgnoredExceptions->count(); ++i) {
		auto item = ui.listIgnoredExceptions->item(i);
		if (item->checkState() == Qt::Checked) {
			config.ignored_exceptions.push_back(item->data(Qt::UserRole).toLongLong());
		}
	}

	if (IDebugger *core = edb::v1::debugger_core) {
		core->setIgnoredExceptions(config.ignored_exceptions);
	}

	QString newThemeName = ui.comboTheme->currentData().toString();
	currentThemeName_    = newThemeName;
	config.theme_name    = newThemeName;

	config.sendChangeNotification();
	event->accept();
}

//------------------------------------------------------------------------------
// Name: accept
// Desc:
//------------------------------------------------------------------------------
void DialogOptions::accept() {
	close();
}

```

`src/DialogOptions.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_OPTIONS_H_20061101_
#define DIALOG_OPTIONS_H_20061101_

#include <QDialog>

#include "ui_DialogOptions.h"

class QToolBox;

class DialogOptions final : public QDialog {
	Q_OBJECT
public:
	explicit DialogOptions(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogOptions() override = default;

public Q_SLOTS:
	void on_btnSymbolDir_clicked();
	void on_btnPluginDir_clicked();
	void on_btnTTY_clicked();
	void on_btnSessionDir_clicked();

protected:
	void closeEvent(QCloseEvent *event) override;
	void accept() override;

public:
	void showEvent(QShowEvent *event) override;
	void addOptionsPage(QWidget *page);

private:
	QString fontFromDialog(const QString &default_font);
	QString directoryFromDialog();

private:
	Ui::DialogOptions ui;
	QToolBox *toolbox_ = nullptr;
	QString currentThemeName_;
};

#endif

```

`src/DialogOptions.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <author>Evan Teran</author>
 <class>DialogOptions</class>
 <widget class="QDialog" name="DialogOptions">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>681</width>
    <height>643</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Preferences</string>
  </property>
  <layout class="QVBoxLayout">
   <item>
    <widget class="QTabWidget" name="tabWidget">
     <property name="tabShape">
      <enum>QTabWidget::Rounded</enum>
     </property>
     <property name="currentIndex">
      <number>0</number>
     </property>
     <widget class="QWidget" name="tab">
      <attribute name="title">
       <string>General</string>
      </attribute>
      <layout class="QVBoxLayout" name="verticalLayout_6">
       <item>
        <widget class="QGroupBox" name="groupBox_3">
         <property name="title">
          <string>Close Behaviour</string>
         </property>
         <layout class="QVBoxLayout">
          <property name="spacing">
           <number>6</number>
          </property>
          <item>
           <widget class="QRadioButton" name="rdoDetach">
            <property name="text">
             <string>&amp;Detach From Debugged Application</string>
            </property>
            <property name="checked">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QRadioButton" name="rdoKill">
            <property name="text">
             <string>&amp;Kill Debugged Application</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QRadioButton" name="rdoReverseCapture">
            <property name="text">
             <string>Detach If Debugged Application Was Attached &amp;To, Kill If Launched</string>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
       <item>
        <widget class="QGroupBox" name="groupBox_6">
         <property name="title">
          <string>Window Placement On Startup</string>
         </property>
         <layout class="QVBoxLayout" name="verticalLayout_5">
          <item>
           <widget class="QRadioButton" name="rdoPlaceDefault">
            <property name="text">
             <string>S&amp;ystem Default</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QRadioButton" name="rdoPlaceCentered">
            <property name="text">
             <string>Centered on Desktop</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QRadioButton" name="rdoPlaceRestore">
            <property name="text">
             <string>Restore Pre&amp;vious Location</string>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
       <item>
        <spacer>
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>20</width>
           <height>40</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_2">
      <attribute name="title">
       <string>Appearance</string>
      </attribute>
      <layout class="QGridLayout" name="gridLayout">
       <item row="1" column="0">
        <widget class="QGroupBox" name="groupBox_5">
         <property name="title">
          <string>Default Data View Settings</string>
         </property>
         <layout class="QGridLayout">
          <item row="0" column="0" colspan="3">
           <widget class="QCheckBox" name="chkDataShowAddress">
            <property name="text">
             <string>Show Address</string>
            </property>
           </widget>
          </item>
          <item row="1" column="0" colspan="3">
           <widget class="QCheckBox" name="chkDataShowHex">
            <property name="text">
             <string>Show Hex</string>
            </property>
           </widget>
          </item>
          <item row="2" column="0" colspan="3">
           <widget class="QCheckBox" name="chkDataShowAscii">
            <property name="text">
             <string>Show ASCII</string>
            </property>
           </widget>
          </item>
          <item row="3" column="0" colspan="3">
           <widget class="QCheckBox" name="chkDataShowComments">
            <property name="text">
             <string>Show Comments</string>
            </property>
           </widget>
          </item>
          <item row="4" column="0">
           <widget class="QLabel" name="label_2">
            <property name="text">
             <string>Word Width</string>
            </property>
           </widget>
          </item>
          <item row="4" column="1">
           <widget class="QComboBox" name="cmbDataWordWidth">
            <item>
             <property name="text">
              <string>1 Byte</string>
             </property>
            </item>
            <item>
             <property name="text">
              <string>2 Bytes</string>
             </property>
            </item>
            <item>
             <property name="text">
              <string>4 Bytes</string>
             </property>
            </item>
            <item>
             <property name="text">
              <string>8 Bytes</string>
             </property>
            </item>
           </widget>
          </item>
          <item row="4" column="2">
           <spacer>
            <property name="orientation">
             <enum>Qt::Horizontal</enum>
            </property>
            <property name="sizeHint" stdset="0">
             <size>
              <width>321</width>
              <height>25</height>
             </size>
            </property>
           </spacer>
          </item>
          <item row="5" column="0">
           <widget class="QLabel" name="label_6">
            <property name="text">
             <string>Row Width</string>
            </property>
           </widget>
          </item>
          <item row="5" column="1">
           <widget class="QComboBox" name="cmbDataRowWidth">
            <item>
             <property name="text">
              <string>1 Byte</string>
             </property>
            </item>
            <item>
             <property name="text">
              <string>2 Bytes</string>
             </property>
            </item>
            <item>
             <property name="text">
              <string>4 Bytes</string>
             </property>
            </item>
            <item>
             <property name="text">
              <string>8 Bytes</string>
             </property>
            </item>
            <item>
             <property name="text">
              <string>16 Bytes</string>
             </property>
            </item>
           </widget>
          </item>
          <item row="5" column="2">
           <spacer>
            <property name="orientation">
             <enum>Qt::Horizontal</enum>
            </property>
            <property name="sizeHint" stdset="0">
             <size>
              <width>321</width>
              <height>25</height>
             </size>
            </property>
           </spacer>
          </item>
         </layout>
        </widget>
       </item>
       <item row="1" column="1">
        <layout class="QVBoxLayout" name="verticalLayout_2">
         <item>
          <widget class="QCheckBox" name="chkAddressColon">
           <property name="text">
            <string>Show Colons in Addresses</string>
           </property>
           <property name="checked">
            <bool>true</bool>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="chkHexOffsets">
           <property name="text">
            <string>Show Function Offsets in Hexdecimal</string>
           </property>
          </widget>
         </item>
         <item>
          <spacer name="verticalSpacer">
           <property name="orientation">
            <enum>Qt::Vertical</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>20</width>
             <height>40</height>
            </size>
           </property>
          </spacer>
         </item>
        </layout>
       </item>
       <item row="3" column="0" colspan="2">
        <widget class="QLabel" name="label_15">
         <property name="palette">
          <palette>
           <active>
            <colorrole role="WindowText">
             <brush brushstyle="SolidPattern">
              <color alpha="255">
               <red>170</red>
               <green>0</green>
               <blue>0</blue>
              </color>
             </brush>
            </colorrole>
           </active>
           <inactive>
            <colorrole role="WindowText">
             <brush brushstyle="SolidPattern">
              <color alpha="255">
               <red>170</red>
               <green>0</green>
               <blue>0</blue>
              </color>
             </brush>
            </colorrole>
           </inactive>
           <disabled>
            <colorrole role="WindowText">
             <brush brushstyle="SolidPattern">
              <color alpha="127">
               <red>255</red>
               <green>255</green>
               <blue>255</blue>
              </color>
             </brush>
            </colorrole>
           </disabled>
          </palette>
         </property>
         <property name="font">
          <font>
           <weight>75</weight>
           <bold>true</bold>
          </font>
         </property>
         <property name="text">
          <string>NOTE: Changes to the theme will take effect after restarting edb.</string>
         </property>
         <property name="alignment">
          <set>Qt::AlignCenter</set>
         </property>
        </widget>
       </item>
       <item row="4" column="0" colspan="2">
        <spacer>
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>578</width>
           <height>201</height>
          </size>
         </property>
        </spacer>
       </item>
       <item row="2" column="0" colspan="2">
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <item>
          <widget class="QLabel" name="label_14">
           <property name="text">
            <string>Theme:</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QComboBox" name="comboTheme"/>
         </item>
        </layout>
       </item>
       <item row="0" column="0" colspan="2">
        <layout class="QGridLayout">
         <item row="1" column="1">
          <widget class="FixedFontSelector" name="dataFont" native="true"/>
         </item>
         <item row="3" column="1">
          <widget class="FixedFontSelector" name="disassemblyFont" native="true"/>
         </item>
         <item row="2" column="1">
          <widget class="FixedFontSelector" name="registerFont" native="true"/>
         </item>
         <item row="3" column="0">
          <widget class="QLabel" name="label_10">
           <property name="text">
            <string>Default Disassembly View Font</string>
           </property>
          </widget>
         </item>
         <item row="0" column="0">
          <widget class="QLabel" name="label_9">
           <property name="text">
            <string>Default Stack View Font</string>
           </property>
          </widget>
         </item>
         <item row="2" column="0">
          <widget class="QLabel" name="label_12">
           <property name="text">
            <string>Default Register View Font</string>
           </property>
          </widget>
         </item>
         <item row="1" column="0">
          <widget class="QLabel" name="label_11">
           <property name="text">
            <string>Default Memory Dump View Font</string>
           </property>
          </widget>
         </item>
         <item row="0" column="1">
          <widget class="FixedFontSelector" name="stackFont" native="true"/>
         </item>
        </layout>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_3">
      <attribute name="title">
       <string>Debugging</string>
      </attribute>
      <layout class="QVBoxLayout" name="verticalLayout_4">
       <item>
        <widget class="QGroupBox" name="groupBox_2">
         <property name="title">
          <string>Initial Breakpoint</string>
         </property>
         <layout class="QVBoxLayout">
          <property name="spacing">
           <number>6</number>
          </property>
          <item>
           <widget class="QRadioButton" name="rdoBPEntry">
            <property name="text">
             <string>Application Entry Point</string>
            </property>
            <property name="checked">
             <bool>false</bool>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QRadioButton" name="rdoBPMain">
            <property name="text">
             <string>&quot;main&quot; symbol (when possible)</string>
            </property>
            <property name="checked">
             <bool>true</bool>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkWarnDataBreakpoint">
         <property name="text">
          <string>Warn when setting breakpoint in non-executable region</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkFindMain">
         <property name="text">
          <string>Use heuristic to find &quot;main&quot; symbol when it is not found in symbol file</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkDeleteStaleSymbols">
         <property name="text">
          <string>Delete Stale Symbol Files</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkDisableASLR">
         <property name="text">
          <string>Disable Address Space Layout Randomization (ASLR)</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkDisableLazyBinding">
         <property name="text">
          <string>Disable lazy binding of dynamic symbols</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkBreakOnLibraryLoad">
         <property name="text">
          <string>Break on Library Load Events</string>
         </property>
        </widget>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout">
         <item>
          <widget class="QLabel" name="label_13">
           <property name="text">
            <string>Default &amp;breakpoint type</string>
           </property>
           <property name="buddy">
            <cstring>cmbDefaultBreakpointType</cstring>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QComboBox" name="cmbDefaultBreakpointType"/>
         </item>
         <item>
          <spacer name="horizontalSpacer">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>40</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
        </layout>
       </item>
       <item>
        <layout class="QHBoxLayout">
         <item>
          <widget class="QLabel" name="label_5">
           <property name="text">
            <string>Minimum &amp;length for string detection</string>
           </property>
           <property name="buddy">
            <cstring>spnMinString</cstring>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QSpinBox" name="spnMinString"/>
         </item>
         <item>
          <spacer>
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>40</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QGroupBox" name="groupBox_4">
         <property name="title">
          <string>Command Line IO</string>
         </property>
         <layout class="QGridLayout">
          <item row="0" column="0" colspan="3">
           <widget class="QCheckBox" name="chkTTY">
            <property name="text">
             <string>Open a terminal to provide program input and output</string>
            </property>
            <property name="checked">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item row="1" column="0">
           <widget class="QLabel" name="label">
            <property name="text">
             <string>&amp;Terminal Program:</string>
            </property>
            <property name="buddy">
             <cstring>txtTTY</cstring>
            </property>
           </widget>
          </item>
          <item row="1" column="1">
           <widget class="QLineEdit" name="txtTTY">
            <property name="text">
             <string>/usr/bin/xterm</string>
            </property>
           </widget>
          </item>
          <item row="1" column="2">
           <widget class="QToolButton" name="btnTTY">
            <property name="text">
             <string>...</string>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
       <item>
        <spacer>
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>578</width>
           <height>31</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
      <zorder>chkDisableASLR</zorder>
      <zorder>chkDisableLazyBinding</zorder>
      <zorder>groupBox_2</zorder>
      <zorder>chkWarnDataBreakpoint</zorder>
      <zorder>chkFindMain</zorder>
      <zorder>groupBox_4</zorder>
      <zorder>chkDeleteStaleSymbols</zorder>
      <zorder>chkBreakOnLibraryLoad</zorder>
     </widget>
     <widget class="QWidget" name="tab_6">
      <attribute name="title">
       <string>Signals/Exceptions</string>
      </attribute>
      <layout class="QVBoxLayout" name="verticalLayout_3">
       <item>
        <widget class="QCheckBox" name="signalsMessageBoxEnable">
         <property name="text">
          <string>Alert about signals with a message box</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_8">
         <property name="text">
          <string>Ignore (pass to program) the following exceptions:</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QListWidget" name="listIgnoredExceptions">
         <property name="editTriggers">
          <set>QAbstractItemView::NoEditTriggers</set>
         </property>
         <property name="alternatingRowColors">
          <bool>true</bool>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_4">
      <attribute name="title">
       <string>Disassembly</string>
      </attribute>
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <widget class="QGroupBox" name="groupBox">
         <property name="title">
          <string>Disassembly Syntax</string>
         </property>
         <layout class="QVBoxLayout">
          <property name="spacing">
           <number>6</number>
          </property>
          <item>
           <widget class="QRadioButton" name="rdoSytntaxIntel">
            <property name="text">
             <string>Inte&amp;l</string>
            </property>
            <property name="checked">
             <bool>true</bool>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QRadioButton" name="rdoSytntaxATT">
            <property name="enabled">
             <bool>true</bool>
            </property>
            <property name="text">
             <string>AT&amp;&amp;&amp;T</string>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkZerosAreFilling">
         <property name="text">
          <string>Instruction &quot;add [eax], al&quot; (0x00 0x00) is &quot;Filling&quot; on x86</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkRegisterBadges">
         <property name="text">
          <string>Show when registers are pointing to a visible address</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkShowJumpArrow">
         <property name="text">
          <string>Show jump arrows</string>
         </property>
         <property name="checked">
          <bool>false</bool>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkUppercase">
         <property name="text">
          <string>Disassemble in uppercase</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkTabBetweenMnemonicAndOperands">
         <property name="text">
          <string>Tab between mnemonic and operands</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkShowLocalModuleName">
         <property name="text">
          <string>Show local module name in jump targets</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkShowSymbolicAddresses">
         <property name="text">
          <string>Show symbolic addresses</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkSimplifyRIPRelativeTargets">
         <property name="text">
          <string>Show RIP-relative targets as [rel TargetAddress] instead of [rip+Displacement]</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="chkSyntaxHighlighting">
         <property name="text">
          <string>Enable syntax highlighting</string>
         </property>
        </widget>
       </item>
       <item>
        <spacer>
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>561</width>
           <height>206</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_5">
      <attribute name="title">
       <string>Directories</string>
      </attribute>
      <layout class="QVBoxLayout">
       <item>
        <layout class="QGridLayout">
         <item row="0" column="0">
          <widget class="QLabel" name="label_3">
           <property name="text">
            <string>Symbol Directory</string>
           </property>
           <property name="buddy">
            <cstring>txtSymbolDir</cstring>
           </property>
          </widget>
         </item>
         <item row="0" column="1">
          <widget class="QLineEdit" name="txtSymbolDir"/>
         </item>
         <item row="0" column="2">
          <widget class="QToolButton" name="btnSymbolDir">
           <property name="text">
            <string>...</string>
           </property>
          </widget>
         </item>
         <item row="1" column="0">
          <widget class="QLabel" name="label_4">
           <property name="text">
            <string>Plugin Directory</string>
           </property>
           <property name="buddy">
            <cstring>txtPluginDir</cstring>
           </property>
          </widget>
         </item>
         <item row="1" column="1">
          <widget class="QLineEdit" name="txtPluginDir"/>
         </item>
         <item row="1" column="2">
          <widget class="QToolButton" name="btnPluginDir">
           <property name="text">
            <string>...</string>
           </property>
          </widget>
         </item>
         <item row="2" column="0">
          <widget class="QLabel" name="label_7">
           <property name="text">
            <string>Session Directory</string>
           </property>
           <property name="buddy">
            <cstring>txtSessionDir</cstring>
           </property>
          </widget>
         </item>
         <item row="2" column="1">
          <widget class="QLineEdit" name="txtSessionDir"/>
         </item>
         <item row="2" column="2">
          <widget class="QToolButton" name="btnSessionDir">
           <property name="text">
            <string>...</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <spacer>
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>578</width>
           <height>101</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tab_plugins">
      <attribute name="title">
       <string>Plugin Options</string>
      </attribute>
      <layout class="QGridLayout" name="tab_plugins_layout">
       <item row="0" column="0">
        <widget class="QLabel" name="label_plugins">
         <property name="text">
          <string>No Plugin Option Pages</string>
         </property>
         <property name="alignment">
          <set>Qt::AlignCenter</set>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <customwidgets>
  <customwidget>
   <class>FixedFontSelector</class>
   <extends>QWidget</extends>
   <header>FixedFontSelector.h</header>
   <container>1</container>
  </customwidget>
 </customwidgets>
 <tabstops>
  <tabstop>tabWidget</tabstop>
  <tabstop>rdoDetach</tabstop>
  <tabstop>rdoKill</tabstop>
  <tabstop>chkDataShowAddress</tabstop>
  <tabstop>chkDataShowHex</tabstop>
  <tabstop>chkDataShowAscii</tabstop>
  <tabstop>chkDataShowComments</tabstop>
  <tabstop>cmbDataWordWidth</tabstop>
  <tabstop>cmbDataRowWidth</tabstop>
  <tabstop>rdoBPEntry</tabstop>
  <tabstop>rdoBPMain</tabstop>
  <tabstop>chkWarnDataBreakpoint</tabstop>
  <tabstop>chkFindMain</tabstop>
  <tabstop>spnMinString</tabstop>
  <tabstop>chkTTY</tabstop>
  <tabstop>txtTTY</tabstop>
  <tabstop>btnTTY</tabstop>
  <tabstop>rdoSytntaxIntel</tabstop>
  <tabstop>rdoSytntaxATT</tabstop>
  <tabstop>chkZerosAreFilling</tabstop>
  <tabstop>chkUppercase</tabstop>
  <tabstop>txtSymbolDir</tabstop>
  <tabstop>btnSymbolDir</tabstop>
  <tabstop>txtPluginDir</tabstop>
  <tabstop>btnPluginDir</tabstop>
  <tabstop>txtSessionDir</tabstop>
  <tabstop>btnSessionDir</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>chkTTY</sender>
   <signal>toggled(bool)</signal>
   <receiver>txtTTY</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>103</x>
     <y>431</y>
    </hint>
    <hint type="destinationlabel">
     <x>251</x>
     <y>468</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>chkTTY</sender>
   <signal>toggled(bool)</signal>
   <receiver>btnTTY</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>119</x>
     <y>425</y>
    </hint>
    <hint type="destinationlabel">
     <x>656</x>
     <y>452</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>DialogOptions</receiver>
   <slot>close()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>306</x>
     <y>534</y>
    </hint>
    <hint type="destinationlabel">
     <x>300</x>
     <y>193</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>DialogOptions</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>380</x>
     <y>508</y>
    </hint>
    <hint type="destinationlabel">
     <x>379</x>
     <y>497</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`src/DialogPlugins.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogPlugins.h"
#include "IPlugin.h"
#include "PluginModel.h"
#include "edb.h"

#include <QMetaClassInfo>
#include <QSortFilterProxyModel>

//------------------------------------------------------------------------------
// Name: DialogPlugins
// Desc:
//------------------------------------------------------------------------------
DialogPlugins::DialogPlugins(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);

	pluginModel_  = new PluginModel(this);
	pluginFilter_ = new QSortFilterProxyModel(this);

	pluginFilter_->setSourceModel(pluginModel_);
	pluginFilter_->setFilterCaseSensitivity(Qt::CaseInsensitive);

	ui.plugins_table->setModel(pluginFilter_);
}

//------------------------------------------------------------------------------
// Name: showEvent
// Desc:
//------------------------------------------------------------------------------
void DialogPlugins::showEvent(QShowEvent *) {

	QMap<QString, QObject *> plugins = edb::v1::plugin_list();

	pluginModel_->clear();

	for (auto it = plugins.begin(); it != plugins.end(); ++it) {

		const QString &filename = it.key();
		QString plugin_name;
		QString author;
		QString url;

		// get a QObject from the plugin
		if (QObject *const p = it.value()) {
			const QMetaObject *const meta = p->metaObject();
			plugin_name                   = meta->className();
			const int author_index        = meta->indexOfClassInfo("author");
			if (author_index != -1) {
				author = meta->classInfo(author_index).value();
			}

			const int url_index = meta->indexOfClassInfo("url");
			if (url_index != -1) {
				url = meta->classInfo(url_index).value();
			}
		}

		pluginModel_->addPlugin(filename, plugin_name, author, url);
	}

	ui.plugins_table->resizeColumnsToContents();
}

```

`src/DialogPlugins.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_PLUGINS_H_20080926_
#define DIALOG_PLUGINS_H_20080926_

#include <QDialog>

#include "ui_DialogPlugins.h"

class QSortFilterProxyModel;
class PluginModel;

class DialogPlugins : public QDialog {
	Q_OBJECT

public:
	explicit DialogPlugins(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	DialogPlugins(const DialogPlugins &) = delete;
	DialogPlugins &operator=(const DialogPlugins &) = delete;
	~DialogPlugins() override                       = default;

public:
	void showEvent(QShowEvent *) override;

private:
	Ui::DialogPlugins ui;
	PluginModel *pluginModel_            = nullptr;
	QSortFilterProxyModel *pluginFilter_ = nullptr;
};

#endif

```

`src/DialogPlugins.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogPlugins</class>
 <widget class="QDialog" name="DialogPlugins">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>791</width>
    <height>350</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Plugins</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="1" column="0">
    <widget class="QDialogButtonBox" name="button_box">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
   <item row="0" column="0">
    <widget class="QTableView" name="plugins_table">
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>button_box</sender>
   <signal>accepted()</signal>
   <receiver>DialogPlugins</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>252</x>
     <y>345</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>button_box</sender>
   <signal>rejected()</signal>
   <receiver>DialogPlugins</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>320</x>
     <y>345</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`src/DialogThreads.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "DialogThreads.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IThread.h"
#include "ThreadsModel.h"
#include "edb.h"

#include <QHeaderView>
#include <QSortFilterProxyModel>

//------------------------------------------------------------------------------
// Name: DialogThreads
// Desc:
//------------------------------------------------------------------------------
DialogThreads::DialogThreads(QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	ui.setupUi(this);

	threadsModel_  = new ThreadsModel(this);
	threadsFilter_ = new QSortFilterProxyModel(this);

	threadsFilter_->setSourceModel(threadsModel_);
	threadsFilter_->setFilterCaseSensitivity(Qt::CaseInsensitive);

	ui.thread_table->setModel(threadsFilter_);

	connect(edb::v1::debugger_ui, SIGNAL(debugEvent()), this, SLOT(updateThreads()));
	connect(edb::v1::debugger_ui, SIGNAL(detachEvent()), this, SLOT(updateThreads()));
	connect(edb::v1::debugger_ui, SIGNAL(attachEvent()), this, SLOT(updateThreads()));
}

//------------------------------------------------------------------------------
// Name: showEvent
// Desc:
//------------------------------------------------------------------------------
void DialogThreads::showEvent(QShowEvent *) {
	updateThreads();
}

//------------------------------------------------------------------------------
// Name: on_thread_table_doubleClicked
// Desc:
//------------------------------------------------------------------------------
void DialogThreads::on_thread_table_doubleClicked(const QModelIndex &index) {

	const QModelIndex internal_index = threadsFilter_->mapToSource(index);
	if (auto item = reinterpret_cast<ThreadsModel::Item *>(internal_index.internalPointer())) {
		if (std::shared_ptr<IThread> thread = item->thread) {
			if (IProcess *process = edb::v1::debugger_core->process()) {
				process->setCurrentThread(*thread);
				updateThreads();
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: updateThreads
// Desc:
//------------------------------------------------------------------------------
void DialogThreads::updateThreads() {
	threadsModel_->clear();

	if (IProcess *process = edb::v1::debugger_core->process()) {
		std::shared_ptr<IThread> current = process->currentThread();

		for (std::shared_ptr<IThread> &thread : process->threads()) {

			if (thread == current) {
				threadsModel_->addThread(thread, true);
			} else {
				threadsModel_->addThread(thread, false);
			}
		}
	}

	ui.thread_table->horizontalHeader()->resizeSections(QHeaderView::Stretch);
}

```

`src/DialogThreads.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef DIALOG_THREADS_H_20101026_
#define DIALOG_THREADS_H_20101026_

#include <QDialog>

#include "ui_DialogThreads.h"

class ThreadsModel;
class QSortFilterProxyModel;
class QModelIndex;

class DialogThreads : public QDialog {
	Q_OBJECT
public:
	DialogThreads(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~DialogThreads() override = default;

private Q_SLOTS:
	void on_thread_table_doubleClicked(const QModelIndex &index);
	void updateThreads();

public:
	void showEvent(QShowEvent *) override;

private:
	Ui::DialogThreads ui;
	ThreadsModel *threadsModel_           = nullptr;
	QSortFilterProxyModel *threadsFilter_ = nullptr;
};

#endif

```

`src/DialogThreads.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DialogThreads</class>
 <widget class="QDialog" name="DialogThreads">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>800</width>
    <height>350</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Threads</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="1" column="0">
    <widget class="QDialogButtonBox" name="button_box">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Close</set>
     </property>
    </widget>
   </item>
   <item row="0" column="0">
    <widget class="QTableView" name="thread_table">
     <property name="font">
      <font>
       <family>Monospace</family>
       <pointsize>8</pointsize>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>button_box</sender>
   <signal>accepted()</signal>
   <receiver>DialogThreads</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>252</x>
     <y>345</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>button_box</sender>
   <signal>rejected()</signal>
   <receiver>DialogThreads</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>320</x>
     <y>345</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`src/ExpressionDialog.cpp`:

```cpp
/*
Copyright (C) 2006 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ExpressionDialog.h"
#include "Expression.h"
#include "ISymbolManager.h"
#include "Symbol.h"
#include "edb.h"

#include <QCompleter>
#include <QPushButton>

ExpressionDialog::ExpressionDialog(const QString &title, const QString &prompt, QWidget *parent, Qt::WindowFlags f)
	: QDialog(parent, f) {

	setWindowTitle(title);

	layout_     = new QVBoxLayout(this);
	labelText_  = new QLabel(prompt, this);
	labelError_ = new QLabel(this);
	expression_ = new QLineEdit(this);
	buttonBox_  = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, Qt::Horizontal, this);

	connect(buttonBox_, &QDialogButtonBox::accepted, this, &ExpressionDialog::accept);
	connect(buttonBox_, &QDialogButtonBox::rejected, this, &ExpressionDialog::reject);

	layout_->addWidget(labelText_);
	layout_->addWidget(expression_);
	layout_->addWidget(labelError_);
	layout_->addWidget(buttonBox_);

	paletteError_.setColor(QPalette::WindowText, Qt::red);
	labelError_->setPalette(paletteError_);

	buttonBox_->button(QDialogButtonBox::Ok)->setEnabled(false);

	setLayout(layout_);

	connect(expression_, &QLineEdit::textChanged, this, &ExpressionDialog::on_text_changed);
	expression_->selectAll();

	std::vector<std::shared_ptr<Symbol>> symbols = edb::v1::symbol_manager().symbols();
	QStringList allLabels;

	for (const std::shared_ptr<Symbol> &sym : symbols) {
		allLabels.append(sym->name_no_prefix);
	}

	allLabels.append(edb::v1::symbol_manager().labels().values());

	QCompleter *completer = new QCompleter(allLabels, this);
	expression_->setCompleter(completer);
	allLabels.clear();
}

void ExpressionDialog::on_text_changed(const QString &text) {
	QHash<edb::address_t, QString> labels = edb::v1::symbol_manager().labels();
	edb::address_t resAddr                = labels.key(text);

	bool retval = false;

	if (resAddr) {
		lastAddress_ = resAddr;
		retval       = true;
	} else {
		Expression<edb::address_t> expr(text, edb::v1::get_variable, edb::v1::get_value);

		Result<edb::address_t, ExpressionError> address = expr.evaluate();
		if (address) {
			labelError_->clear();
			retval       = true;
			lastAddress_ = *address;
		} else {
			labelError_->setText(address.error().what());
			retval = false;
		}
	}

	buttonBox_->button(QDialogButtonBox::Ok)->setEnabled(retval);
}

edb::address_t ExpressionDialog::getAddress() {
	return lastAddress_;
}

```

`src/ExpressionDialog.h`:

```h
/*
Copyright (C) 2014 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef EXPRESSION_DIALOG_H_20191119_
#define EXPRESSION_DIALOG_H_20191119_

#include "Types.h"

#include <QDialog>
#include <QDialogButtonBox>
#include <QLabel>
#include <QLineEdit>
#include <QPalette>
#include <QVBoxLayout>

class QString;

class ExpressionDialog final : public QDialog {
	Q_OBJECT

public:
	explicit ExpressionDialog(const QString &title, const QString &prompt, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());

public:
	edb::address_t getAddress();

private Q_SLOTS:
	void on_text_changed(const QString &text);

private:
	QVBoxLayout *layout_         = nullptr;
	QLabel *labelText_           = nullptr;
	QLabel *labelError_          = nullptr;
	QLineEdit *expression_       = nullptr;
	QDialogButtonBox *buttonBox_ = nullptr;
	QPalette paletteError_;
	edb::address_t lastAddress_;
};

#endif

```

`src/FixedFontSelector.cpp`:

```cpp
/*
Copyright (C) 2014 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "FixedFontSelector.h"
#include <QtDebug>

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
FixedFontSelector::FixedFontSelector(QWidget *parent, Qt::WindowFlags f)
	: QWidget(parent, f) {

	ui.setupUi(this);

	Q_FOREACH (int size, QFontDatabase::standardSizes()) {
		ui.fontSize->addItem(QString("%1").arg(size), size);
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
QFont FixedFontSelector::currentFont() {
	return ui.fontCombo->currentFont();
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
void FixedFontSelector::setCurrentFont(const QString &font) {

	QFont f;
	f.fromString(font);
	setCurrentFont(f);
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
void FixedFontSelector::setCurrentFont(const QFont &font) {
	ui.fontCombo->setCurrentFont(font);
	int n = ui.fontSize->findData(font.pointSize());
	if (n != -1) {
		ui.fontSize->setCurrentIndex(n);
	}
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
void FixedFontSelector::on_fontCombo_currentFontChanged(const QFont &font) {
	Q_EMIT currentFontChanged(font);
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
void FixedFontSelector::on_fontSize_currentIndexChanged(int index) {

	QFont font = ui.fontCombo->currentFont();
	font.setPointSize(ui.fontSize->itemData(index).toInt());
	ui.fontCombo->setCurrentFont(font);

	Q_EMIT currentFontChanged(font);
}

```

`src/FixedFontSelector.h`:

```h
/*
Copyright (C) 2014 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef FIXED_FONT_SELECTOR_H_20191119_
#define FIXED_FONT_SELECTOR_H_20191119_

#include <QWidget>

#include "ui_FixedFontSelector.h"

class FixedFontSelector : public QWidget {
	Q_OBJECT

public:
	explicit FixedFontSelector(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~FixedFontSelector() override = default;

public:
	QFont currentFont();

public Q_SLOTS:
	void setCurrentFont(const QFont &font);
	void setCurrentFont(const QString &font);

private Q_SLOTS:
	void on_fontCombo_currentFontChanged(const QFont &font);
	void on_fontSize_currentIndexChanged(int index);

Q_SIGNALS:
	void currentFontChanged(const QFont &font);

private:
	Ui::FixedFontSelector ui;
};

#endif

```

`src/FixedFontSelector.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FixedFontSelector</class>
 <widget class="QWidget" name="FixedFontSelector">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>306</width>
    <height>24</height>
   </rect>
  </property>
  <layout class="QHBoxLayout">
   <property name="margin">
    <number>0</number>
   </property>
   <item>
    <widget class="QFontComboBox" name="fontCombo">
     <property name="sizePolicy">
      <sizepolicy hsizetype="MinimumExpanding" vsizetype="Fixed">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="editable">
      <bool>false</bool>
     </property>
     <property name="fontFilters">
      <set>QFontComboBox::MonospacedFonts</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QComboBox" name="fontSize"/>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`src/FloatX.cpp`:

```cpp
/*
Copyright (C) 2017 - 2017 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "FloatX.h"
#include "util/Float.h"

#include <iomanip>
#include <sstream>

#if defined(HAVE_DOUBLE_CONVERSION)
#include <double-conversion/double-conversion.h>
#endif

#if defined(HAVE_GDTOA)
#if __has_include(<gdtoa-functions-renamed.h>)
#include <gdtoa-functions-renamed.h>
#elif __has_include(<gdtoa-desktop.h>)
#include <gdtoa-desktop.h>
#else
#error "gdtoa-desktop not found! Please make sure your submodules are up to date by running: git submodule update --init --recursive"
// undef this macro to suppress an further related errors. This initial error message should be what the user focuses on
#undef HAVE_GDTOA
#endif
#endif

#ifdef _MSC_VER
extern "C" EDB_EXPORT void __fastcall float64_to_float80(const void *src, void *dest);

// NOTE(eteran): this thin wrapper function make look pointless... and it REALLY does.
// However, I could not get plugins to be able to see the functions defined in .asm files
// unless I wrapped them in a concrete function like this. It's dumb, but it works
void convert_real64_to_real80(const void *src, void *dst) {
	float64_to_float80(src, dst);
}
#endif

namespace {

template <class T>
struct SpecialValues;

template <>
struct SpecialValues<double> {
	static constexpr std::array<std::uint8_t, 8> positiveInf{{0, 0, 0, 0, 0, 0, 0xf0, 0x7f}};
	static constexpr std::array<std::uint8_t, 8> negativeInf{{0, 0, 0, 0, 0, 0, 0xf0, 0xff}};
	static constexpr std::array<std::uint8_t, 8> positiveSNaN{{0, 0, 0, 0, 0, 0, 0xfc, 0x7f}};
	static constexpr std::array<std::uint8_t, 8> negativeSNaN{{0, 0, 0, 0, 0, 0, 0xfc, 0xff}};
	static constexpr std::array<std::uint8_t, 8> positiveQNaN{{0, 0, 0, 0, 0, 0, 0xf8, 0x7f}};
	static constexpr std::array<std::uint8_t, 8> negativeQNaN{{0, 0, 0, 0, 0, 0, 0xf8, 0xff}};
};

template <>
struct SpecialValues<float> {
	static constexpr std::array<std::uint8_t, 4> positiveInf{{0, 0, 0x80, 0x7f}};
	static constexpr std::array<std::uint8_t, 4> negativeInf{{0, 0, 0x80, 0xff}};
	static constexpr std::array<std::uint8_t, 4> positiveSNaN{{0, 0, 0xe0, 0x7f}};
	static constexpr std::array<std::uint8_t, 4> negativeSNaN{{0, 0, 0xe0, 0xff}};
	static constexpr std::array<std::uint8_t, 4> positiveQNaN{{0, 0, 0xc0, 0x7f}};
	static constexpr std::array<std::uint8_t, 4> negativeQNaN{{0, 0, 0xc0, 0xff}};
};

#ifndef _MSC_VER
#if defined(EDB_X86) || defined(EDB_X86_64)
template <>
struct SpecialValues<long double> {

	static_assert(std::numeric_limits<long double>::digits == 64 && std::numeric_limits<long double>::max_exponent == 16384,
				  "Expected to have x87 80-bit long double");

	static constexpr std::array<std::uint8_t, 16> positiveInf{{0, 0, 0, 0, 0, 0, 0, 0x80, 0xff, 0x7f, 0, 0, 0, 0, 0, 0}};
	static constexpr std::array<std::uint8_t, 16> negativeInf{{0, 0, 0, 0, 0, 0, 0, 0x80, 0xff, 0xff, 0, 0, 0, 0, 0, 0}};
	static constexpr std::array<std::uint8_t, 16> positiveSNaN{{0, 0, 0, 0, 0, 0, 0, 0x90, 0xff, 0x7f, 0, 0, 0, 0, 0, 0}};
	static constexpr std::array<std::uint8_t, 16> negativeSNaN{{0, 0, 0, 0, 0, 0, 0, 0x90, 0xff, 0xff, 0, 0, 0, 0, 0, 0}};
	static constexpr std::array<std::uint8_t, 16> positiveQNaN{{0, 0, 0, 0, 0, 0, 0, 0xc0, 0xff, 0x7f, 0, 0, 0, 0, 0, 0}};
	static constexpr std::array<std::uint8_t, 16> negativeQNaN{{0, 0, 0, 0, 0, 0, 0, 0xc0, 0xff, 0xff, 0, 0, 0, 0, 0, 0}};
};
#endif
#endif

constexpr std::array<std::uint8_t, 4> SpecialValues<float>::positiveInf;
constexpr std::array<std::uint8_t, 4> SpecialValues<float>::negativeInf;
constexpr std::array<std::uint8_t, 4> SpecialValues<float>::positiveSNaN;
constexpr std::array<std::uint8_t, 4> SpecialValues<float>::negativeSNaN;
constexpr std::array<std::uint8_t, 4> SpecialValues<float>::positiveQNaN;
constexpr std::array<std::uint8_t, 4> SpecialValues<float>::negativeQNaN;

constexpr std::array<std::uint8_t, 8> SpecialValues<double>::positiveInf;
constexpr std::array<std::uint8_t, 8> SpecialValues<double>::negativeInf;
constexpr std::array<std::uint8_t, 8> SpecialValues<double>::positiveSNaN;
constexpr std::array<std::uint8_t, 8> SpecialValues<double>::negativeSNaN;
constexpr std::array<std::uint8_t, 8> SpecialValues<double>::positiveQNaN;
constexpr std::array<std::uint8_t, 8> SpecialValues<double>::negativeQNaN;

#ifndef _MSC_VER
#if defined(EDB_X86) || defined(EDB_X86_64)
constexpr std::array<std::uint8_t, 16> SpecialValues<long double>::positiveInf;
constexpr std::array<std::uint8_t, 16> SpecialValues<long double>::negativeInf;
constexpr std::array<std::uint8_t, 16> SpecialValues<long double>::positiveSNaN;
constexpr std::array<std::uint8_t, 16> SpecialValues<long double>::negativeSNaN;
constexpr std::array<std::uint8_t, 16> SpecialValues<long double>::positiveQNaN;
constexpr std::array<std::uint8_t, 16> SpecialValues<long double>::negativeQNaN;
#endif
#endif

float to_real(edb::value32 value) {
	float result;
	std::memcpy(&result, &value, sizeof(result));
	return result;
}

double to_real(edb::value64 value) {
	double result;
	std::memcpy(&result, &value, sizeof(result));
	return result;
}

long double to_real(edb::value80 value) {
	return value.toFloatValue();
}

template <unsigned MantissaLength, typename FloatHolder>
FloatValueClass ieee_classify(FloatHolder value) {

	constexpr auto ExpLength = 8 * sizeof(value) - MantissaLength - 1;
	constexpr auto ExpMax    = (1u << ExpLength) - 1;
	constexpr auto QNaN_mask = 1ull << (MantissaLength - 1);

	const auto mantissa = value & ((1ull << MantissaLength) - 1);
	const auto exponent = (value >> MantissaLength) & ExpMax;

	if (exponent == ExpMax) {
		if (mantissa == 0u) {
			return FloatValueClass::Infinity; // |S|11..11|00..00|
		} else if (mantissa & QNaN_mask) {
			return FloatValueClass::QNaN; // |S|11..11|1XX..XX|
		} else {
			return FloatValueClass::SNaN; // |S|11..11|0XX..XX|
		}
	} else if (exponent == 0u) {
		if (mantissa == 0u) {
			return FloatValueClass::Zero; // |S|00..00|00..00|
		} else {
			return FloatValueClass::Denormal; // |S|00..00|XX..XX|
		}
	} else {
		return FloatValueClass::Normal;
	}
}

#if defined(HAVE_GDTOA)
/*
 * gdtoa_g_?fmt functions do generally a good job at formatting the numbers in
 * a form close to that specified in ECMAScript specification (actually the
 * spec even references this implementation in 7.1.12.1/note3). There are two
 * issues though with the function, one small and one bigger.
 *
 * The small issue is that this function prints numbers x such that 1e-5<|x|<1
 * without leading zeros (contrary to the spec). It's easy to fix up, and it's
 * the first thing the following function does.
 *
 * The bigger issue is that the specification prescribes to print large numbers
 * smaller than 1e21 in fixed-point format, and append zeros(!) instead of
 * actual digits present in the closest representable integer to the base part.
 *
 * This can be quite a problem for our users, because it can give a false sense
 * of precision. E.g., consider the number 1.2345678912345678e20. Closest
 * representable IEEE 754 binary64 number is 123456789123456778240. Next
 * representable is 123456789123456794624. Yet gdtoa_g_dfmt (following
 * ECMAScript) formats it as 123456789123456780000, which, having so many
 * trailing zeros, misleads the user into thinking that all the digits are
 * significant (the user may think that e.g. 123456789123456781000 or even
 * 123456789123456780001 are representable too).
 *
 * The following function tries to ensure that such situations never occur: it
 * takes numeric_limits::digits10 digits as the maximum length of integers (or
 * maximum value of exponent+1 for fractions) for fixed-point format, and if the
 * number formatted into 'buffer' is larger than that, it converts the result
 * into exponential format, removing any trailing zeros.
 *
 * Note that in principle, we could use gdtoa_gdtoa directly and format the
 * number ourselves. But this would result in even more logic to 1) prepare
 * arguments, 2) actually do the formatting; total of both might be just as
 * convoluted as the current post-processing logic.
 */
const char *fixup_g_Yfmt(char *buffer, int digits10) {

	const size_t len = std::strlen(buffer);
	const char x0    = buffer[0];
	const char x1    = buffer[1];

	if (x0 == '.' || (x0 == '-' && x1 == '.')) {
		// ".235" or "-.235" forms are unreadable, so insert leading zero
		const size_t posToInsert = x0 == '.' ? 0 : 1;
		// Give space for the zero: move the remaining line with terminating zero to the right
		std::memmove(buffer + posToInsert + 1, buffer + posToInsert, len + 1 - posToInsert);
		buffer[posToInsert] = '0';
		return buffer;
	}

	// We want exponential format for numbers which are too imprecise for fixed-point format.
	// If we find a number with more than digits10 digits before point, we must fix it.
	int digitCount = 0;
	int pointPos   = -1;
	for (int i = 0; i < static_cast<int>(len); ++i) {
		const char c = buffer[i];
		// If it's already in exponential format, it's fine, just return it
		if (c == 'e') {
			return buffer;
		}

		if (c == '.') {
			pointPos = i;
			continue;
		} else if ('0' <= c && c <= '9') {
			++digitCount;
		}
	}

	// If point wasn't found, assume it's at the end of the number
	if (pointPos < 0) {
		pointPos = len;
	}

	const int signChars = buffer[0] == '-';
	const int exp       = pointPos - signChars - 1;
	if (exp + 1 > digits10) {

		// Yes, the format is too precise for actual value, need to shift the
		// point to the second position and append e+XX to the resulting string.
		char *const buf = buffer + signChars;

		// NOTE: don't attempt to replace this loop with memmove: you'll get
		// confused trying to work out size of data to move.
		// The original string may contain a point, may not contain any. In the
		// former case we must move everything including the null terminator. In
		// the latter case only the chunk up to the original point needs moving.
		const int lenWithNull = len + 1;

		char next = buf[1];
		for (int i = 0; i < lenWithNull - signChars; ++i) {
			// Avoid writing the point; after this, there's no more need to shift
			if (next == '.') {
				break;
			}
			std::swap(next, buf[i + 1]);
		}

		buf[1] = '.';

		// Now after all the mess with present/absent point, it's better to
		// re-calculate length of the current buffer content
		auto len = std::strlen(buf);

		// Remove trailing zeros
		while (buf[len - 1] == '0') {
			--len;
		}

		// Append the exponent
		buf[len]     = 'e';
		buf[len + 1] = '+';
		buf[len + 2] = exp / 10 + '0';
		buf[len + 3] = exp % 10 + '0';
		buf[len + 4] = 0;
	}

	return buffer;
}
#endif

}

template <class Float>
Float read_float(const QString &input, bool &ok) {

	ok = false;
	const QString str(input.toLower().trimmed());
	if (const auto value = util::full_string_to_float<Float>(str.toStdString())) {
		ok = true;
		return *value;
	}

	// OK, so either it is invalid/unfinished, or it's some special value
	// We still do want the user to be able to enter common special values
	Float value;
	if (str == "+snan" || str == "snan") {
		std::memcpy(&value, &SpecialValues<Float>::positiveSNaN, sizeof(value));
	} else if (str == "-snan") {
		std::memcpy(&value, &SpecialValues<Float>::negativeSNaN, sizeof(value));
	} else if (str == "+qnan" || str == "qnan" || str == "nan") {
		std::memcpy(&value, &SpecialValues<Float>::positiveQNaN, sizeof(value));
	} else if (str == "-qnan") {
		std::memcpy(&value, &SpecialValues<Float>::negativeQNaN, sizeof(value));
	} else if (str == "+inf" || str == "inf") {
		std::memcpy(&value, &SpecialValues<Float>::positiveInf, sizeof(value));
	} else if (str == "-inf") {
		std::memcpy(&value, &SpecialValues<Float>::negativeInf, sizeof(value));
	} else {
		return 0;
	}

	ok = true;
	return value;
}

template EDB_EXPORT float read_float<float>(const QString &input, bool &ok);
template EDB_EXPORT double read_float<double>(const QString &input, bool &ok);

#ifndef _MSC_VER
#if defined(EDB_X86) || defined(EDB_X86_64)
template long double read_float<long double>(const QString &input, bool &ok);
#endif
#endif

FloatValueClass float_type(edb::value32 value) {
	return ieee_classify<23>(value);
}

FloatValueClass float_type(edb::value64 value) {
	return ieee_classify<52>(value);
}

FloatValueClass float_type(edb::value80 value) {
	constexpr auto MantissaLength = 64;
	constexpr auto ExpLength      = 8 * sizeof(value) - MantissaLength - 1;
	constexpr auto IntegerBitOnly = 1ull << (MantissaLength - 1);
	constexpr auto QNaN_mask      = 3ull << (MantissaLength - 2);
	constexpr auto ExpMax         = (1u << ExpLength) - 1;

	const auto exponent      = value.exponent();
	const auto mantissa      = value.mantissa();
	const bool integerBitSet = mantissa & IntegerBitOnly;

	// This is almost as ieee_classify, but also takes integer bit (not present in
	// IEEE754 format) into account to detect unsupported values
	if (exponent == ExpMax) {
		if (mantissa == IntegerBitOnly) {
			return FloatValueClass::Infinity; // |S|11..11|1.000..0|
		} else if ((mantissa & QNaN_mask) == QNaN_mask) {
			return FloatValueClass::QNaN; // |S|11..11|1.1XX..X|
		} else if ((mantissa & QNaN_mask) == IntegerBitOnly) {
			return FloatValueClass::SNaN; // |S|11..11|1.0XX..X|
		} else {
			return FloatValueClass::Unsupported; // all exp bits set, but integer bit reset - pseudo-NaN/Inf
		}
	} else if (exponent == 0u) {
		if (mantissa == 0u) {
			return FloatValueClass::Zero; // |S|00..00|00..00|
		} else {
			if (!integerBitSet) {
				return FloatValueClass::Denormal; // |S|00..00|0.XXXX..X|
			} else {
				return FloatValueClass::PseudoDenormal; // |S|00..00|1.XXXX..X|
			}
		}
	} else {
		if (integerBitSet) {
			return FloatValueClass::Normal;
		} else {
			return FloatValueClass::Unsupported; // integer bit reset but exp is as if normal - unnormal
		}
	}
}

template <typename Float>
QValidator::State FloatXValidator<Float>::validate(QString &input, int &) const {

	if (input.isEmpty()) {
		return QValidator::Intermediate;
	}

	// The input may be in hex format. std::istream doesn't support extraction
	// of hexfloat, but std::strto[f,d,ld] do. (see wg21.link/lwg2381)
	if (const auto v = util::full_string_to_float<Float>(input.toStdString())) {
		return QValidator::Acceptable;
	}

	// OK, so we failed to read it or it is unfinished. Let's check whether it's intermediate or invalid.
	QRegExp basicFormat("[+-]?[0-9]*\\.?[0-9]*(e([+-]?[0-9]*)?)?");
	QRegExp specialFormat("[+-]?[sq]?nan|[+-]?inf", Qt::CaseInsensitive);
	QRegExp hexfloatFormat("[+-]?0x[0-9a-f]*\\.?[0-9a-f]*(p([+-]?[0-9]*)?)?", Qt::CaseInsensitive);
	QRegExp specialFormatUnfinished("[+-]?[sq]?(n(an?)?)?|[+-]?(i(nf?)?)?", Qt::CaseInsensitive);

	if (hexfloatFormat.exactMatch(input)) {
		return QValidator::Intermediate;
	}

	if (basicFormat.exactMatch(input)) {
		return QValidator::Intermediate;
	}

	if (specialFormat.exactMatch(input)) {
		return QValidator::Acceptable;
	}

	if (specialFormatUnfinished.exactMatch(input)) {
		return QValidator::Intermediate;
	}

	// All possible options are exhausted, so consider the input invalid
	return QValidator::Invalid;
}

template QValidator::State FloatXValidator<float>::validate(QString &input, int &) const;
template QValidator::State FloatXValidator<double>::validate(QString &input, int &) const;
template QValidator::State FloatXValidator<long double>::validate(QString &input, int &) const;

template <typename Float>
EDB_EXPORT QString format_float(Float value) {

	const auto type    = float_type(value);
	QString specialStr = "???? ";

	switch (type) {
	case FloatValueClass::Zero:
		return value.negative() ? "-0.0" : "0.0";

	case FloatValueClass::PseudoDenormal:
		if constexpr (sizeof(value) >= 10) {
			Q_ASSERT(sizeof(value) == 10);

			// Convert to supported value as the CPU would. Otherwise glibc takes it wrong.
			const uint16_t exponent = value.negative() ? 0x8001 : 0x0001;

			// NOTE(eteran): hushes a warning from GCC >= 8.2
			auto ptr = reinterpret_cast<char *>(&value) + 8;

			std::memcpy(ptr, &exponent, sizeof(exponent));
		}
		[[fallthrough]];
	case FloatValueClass::Normal:
	case FloatValueClass::Denormal: {
#ifdef HAVE_DOUBLE_CONVERSION
		constexpr bool isDouble = std::is_same<Float, edb::value64>::value;
		constexpr bool isFloat  = std::is_same<Float, edb::value32>::value;
		if constexpr (isDouble || isFloat) {
			using namespace double_conversion;

			char buffer[64];
			DoubleToStringConverter conv(DoubleToStringConverter::EMIT_POSITIVE_EXPONENT_SIGN, "inf", "nan", 'e', -4, isDouble ? 15 : 6, 0, 0);

			StringBuilder builder(buffer, sizeof(buffer));
			bool ret = false;

			if constexpr (isDouble) {
				double d;
				std::memcpy(&d, &value, sizeof(d));
				ret = conv.ToShortest(d, &builder);
			} else {
				// isFloat
				float f;
				std::memcpy(&f, &value, sizeof(f));
				ret = conv.ToShortestSingle(f, &builder);
			}

			if (ret && builder.Finalize()) {
				const QString result = buffer;
				if (result.size() == 1 && result[0].isDigit()) {
					return result + ".0"; // avoid printing small whole numbers as integers
				}

				return result;
			}
		}
#endif
#if defined(HAVE_GDTOA)
		if constexpr (std::is_same<Float, edb::value80>::value) {
			char buffer[64] = {};
			gdtoa_g_xfmt(buffer, &value, -1, sizeof buffer);
			fixup_g_Yfmt(buffer, std::numeric_limits<long double>::digits10);

			const QString result = buffer;
			if (result.size() == 1 && result[0].isDigit()) {
				return result + ".0"; // avoid printing small whole numbers as integers
			}

			return result;
		}
#endif
		std::ostringstream ss;
		ss << std::setprecision(std::numeric_limits<decltype(to_real(value))>::max_digits10) << to_real(value);

		const auto result = QString::fromStdString(ss.str());
		if (result.size() == 1 && result[0].isDigit()) {
			return result + ".0"; // avoid printing small whole numbers as integers
		}

		return result;
	}
	case FloatValueClass::Infinity:
		return QString(value.negative() ? "-" : "+") + "INF";
	case FloatValueClass::QNaN:
		specialStr = QString(value.negative() ? "-" : "+") + "QNAN ";
		break;
	case FloatValueClass::SNaN:
		specialStr = QString(value.negative() ? "-" : "+") + "SNAN ";
		break;
	case FloatValueClass::Unsupported:
		specialStr = QString(value.negative() ? "-" : "+") + "BAD ";
		break;
	}

	// If we are here, then the value is special
	auto hexStr = value.toHexString();

	const QChar groupSeparator(' ');
	if (hexStr.size() > 8) {
		hexStr.insert(hexStr.size() - 8, groupSeparator);
	}

	if (hexStr.size() > 16 + 1) { // +1 to take into account already inserted first separator
		hexStr.insert(hexStr.size() - 16 - 1, groupSeparator);
	}

	return specialStr + hexStr;
}

template EDB_EXPORT QString format_float<edb::value32>(edb::value32);
template EDB_EXPORT QString format_float<edb::value64>(edb::value64);
template EDB_EXPORT QString format_float<edb::value80>(edb::value80);

```

`src/Font.cpp`:

```cpp

#include "util/Font.h"
#include <QFont>
#include <QFontMetrics>

namespace Font {

QFont fromString(const QString &fontName) {
	QFont font;
	font.fromString(fontName);
	font.setStyleName(QString());
#if QT_VERSION < QT_VERSION_CHECK(5, 15, 0)
	font.setStyleStrategy(QFont::ForceIntegerMetrics);
#endif
	return font;
}

int maxWidth(const QFontMetrics &fm) {
	return Font::characterWidth(fm, QLatin1Char('X'));
}

int characterWidth(const QFontMetrics &fm, QChar ch) {
#if QT_VERSION >= QT_VERSION_CHECK(5, 11, 0)
	return fm.horizontalAdvance(ch);
#else
	return fm.width(ch);
#endif
}

int stringWidth(const QFontMetrics &fm, const QString &s) {
#if QT_VERSION >= QT_VERSION_CHECK(5, 11, 0)
	return fm.horizontalAdvance(s);
#else
	return fm.width(s);
#endif
}

}

```

`src/Function.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Function.h"

/**
 * @brief Function::swap
 * @param other
 */
void Function::swap(Function &other) {
	using std::swap;
	swap(referenceCount_, other.referenceCount_);
	swap(type_, other.type_);
	swap(blocks_, other.blocks_);
}

/**
 * @brief Function::insert
 * @param bb
 */
void Function::insert(const BasicBlock &bb) {
	blocks_[bb.firstAddress()] = bb;
}

/**
 * @brief Function::entryAddress
 * @return
 */
edb::address_t Function::entryAddress() const {
	return front().firstAddress();
}

/**
 * @brief Function::endAddress
 * @return
 */
edb::address_t Function::endAddress() const {
	return back().lastAddress() - 1;
}

/**
 * @brief Function::lastInstruction
 * @return
 */
edb::address_t Function::lastInstruction() const {
	return back().back()->rva();
}

/**
 * @brief Function::referenceCount
 * @return
 */
int Function::referenceCount() const {
	return referenceCount_;
}

/**
 * @brief Function::back
 * @return
 */
Function::const_reference Function::back() const {
	Q_ASSERT(!empty());
	return rbegin()->second;
}

/**
 * @brief Function::front
 * @return
 */
Function::const_reference Function::front() const {
	Q_ASSERT(!empty());
	return begin()->second;
}

/**
 * @brief Function::back
 * @return
 */
Function::reference Function::back() {
	Q_ASSERT(!empty());
	return rbegin()->second;
}

/**
 * @brief Function::front
 * @return
 */
Function::reference Function::front() {
	Q_ASSERT(!empty());
	return begin()->second;
}

/**
 * @brief Function::begin
 * @return
 */
Function::const_iterator Function::begin() const {
	return blocks_.begin();
}

/**
 * @brief Function::end
 * @return
 */
Function::const_iterator Function::end() const {
	return blocks_.end();
}

/**
 * @brief Function::rbegin
 * @return
 */
Function::const_reverse_iterator Function::rbegin() const {
	return const_reverse_iterator(blocks_.end());
}

/**
 * @brief Function::rend
 * @return
 */
Function::const_reverse_iterator Function::rend() const {
	return const_reverse_iterator(blocks_.begin());
}

/**
 * @brief Function::begin
 * @return
 */
Function::iterator Function::begin() {
	return blocks_.begin();
}

/**
 * @brief Function::end
 * @return
 */
Function::iterator Function::end() {
	return blocks_.end();
}

/**
 * @brief Function::rbegin
 * @return
 */
Function::reverse_iterator Function::rbegin() {
	return reverse_iterator(blocks_.end());
}

/**
 * @brief Function::rend
 * @return
 */
Function::reverse_iterator Function::rend() {
	return reverse_iterator(blocks_.begin());
}

/**
 * @brief Function::empty
 * @return
 */
bool Function::empty() const {
	return blocks_.empty();
}

/**
 * @brief Function::size
 * @return
 */
Function::size_type Function::size() const {
	return blocks_.size();
}

/**
 * @brief Function::addReference
 */
void Function::addReference() {
	++referenceCount_;
}
/**
 * @brief Function::type
 * @return
 */
Function::Type Function::type() const {
	return type_;
}

/**
 * @brief Function::setType
 * @param t
 */
void Function::setType(Type t) {
	type_ = t;
}

```

`src/HexStringValidator.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "HexStringValidator.h"

#include <QString>

#include <cctype> // for std::isxdigit

//------------------------------------------------------------------------------
// Name: HexStringValidator
// Desc: constructor
//------------------------------------------------------------------------------
HexStringValidator::HexStringValidator(QObject *parent)
	: QValidator(parent) {
}

//------------------------------------------------------------------------------
// Name: fixup
// Desc:
//------------------------------------------------------------------------------
void HexStringValidator::fixup(QString &input) const {
	QString temp;
	int index = 0;

	for (QChar ch : input) {
		const int c = ch.toLatin1();
		if (c < 0x80 && std::isxdigit(c)) {

			if (index != 0 && (index & 1) == 0) {
				temp += ' ';
			}

			temp += ch.toUpper();
			++index;
		}
	}

	input = temp;
}

//------------------------------------------------------------------------------
// Name: validate
// Desc:
//------------------------------------------------------------------------------
QValidator::State HexStringValidator::validate(QString &input, int &pos) const {
	if (!input.isEmpty()) {
		// TODO: can we detect if the char which was JUST deleted
		// (if any was deleted) was a space? and special case this?
		// as to not have the minor bug in this case?

		const int char_pos = pos - input.leftRef(pos).count(' ');
		int chars          = 0;
		fixup(input);

		pos = 0;

		while (chars != char_pos) {
			if (input[pos] != ' ') {
				++chars;
			}
			++pos;
		}

		// favor the right side of a space
		if (input[pos] == ' ') {
			++pos;
		}
	}
	return QValidator::Acceptable;
}

```

`src/LongDoubleX86.asm`:

```asm
PUBLIC long_double_to_double
PUBLIC float64_to_float80

ALIAS <@long_double_to_double@8> = <long_double_to_double>
ALIAS <@float64_to_float80@8> = <float64_to_float80>

IFDEF EDB_X86

.386

_TEXT SEGMENT

long_double_to_double PROC NEAR; FASTCALL
fld TBYTE PTR [ecx]
fstp QWORD PTR [edx]
ret
long_double_to_double ENDP

float64_to_float80 PROC NEAR; FASTCALL
fld QWORD PTR [ecx]
fstp TBYTE PTR [edx]
ret
float64_to_float80 ENDP

_TEXT ENDS

ELSE

_TEXT SEGMENT

long_double_to_double PROC
fld TBYTE PTR [rcx]
fstp QWORD PTR [rdx]
ret
long_double_to_double ENDP

float64_to_float80 PROC
fld QWORD PTR [rcx]
fstp TBYTE PTR [rdx]
ret
float64_to_float80 ENDP

_TEXT ENDS

ENDIF

END

```

`src/MemoryRegions.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "MemoryRegions.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IRegion.h"
#include "ISymbolManager.h"
#include "edb.h"

#include <QDebug>

//------------------------------------------------------------------------------
// Name: MemoryRegions
// Desc: constructor
//------------------------------------------------------------------------------
MemoryRegions::MemoryRegions()
	: QAbstractItemModel(nullptr) {
}

//------------------------------------------------------------------------------
// Name: clear
// Desc:
//------------------------------------------------------------------------------
void MemoryRegions::clear() {
	beginResetModel();
	regions_.clear();
	endResetModel();
}

//------------------------------------------------------------------------------
// Name: sync
// Desc: reads a memory map file line by line
//------------------------------------------------------------------------------
void MemoryRegions::sync() {

	beginResetModel();

	QList<std::shared_ptr<IRegion>> regions;

	if (edb::v1::debugger_core) {
		if (IProcess *process = edb::v1::debugger_core->process()) {
			regions = process->regions();
			Q_FOREACH (const std::shared_ptr<IRegion> &region, regions) {
				// if the region has a name, is mapped starting
				// at the beginning of the file, and is executable, sounds
				// like a module mapping!
				if (!region->name().isEmpty()) {
					if (region->executable()) {

						// NOTE(eteran): region start is not good enough, we need **module** start
						edb::address_t base = region->start();
						Q_FOREACH (const std::shared_ptr<IRegion> &r, regions) {
							if (r->name() == region->name()) {
								base = std::min(base, r->start());
							}
						}

						edb::v1::symbol_manager().loadSymbolFile(region->name(), base);
					}
				}
			}
		}
	}

	std::swap(regions_, regions);
	endResetModel();
}

//------------------------------------------------------------------------------
// Name: find_region
// Desc:
//------------------------------------------------------------------------------
std::shared_ptr<IRegion> MemoryRegions::findRegion(edb::address_t address) const {

	auto it = std::find_if(regions_.begin(), regions_.end(), [address](const std::shared_ptr<IRegion> &region) {
		return region->contains(address);
	});

	if (it != regions_.end()) {
		return *it;
	}

	return nullptr;
}

//------------------------------------------------------------------------------
// Name: data
// Desc:
//------------------------------------------------------------------------------
QVariant MemoryRegions::data(const QModelIndex &index, int role) const {

	if (index.isValid() && role == Qt::DisplayRole) {

		const std::shared_ptr<IRegion> &region = regions_[index.row()];

		switch (index.column()) {
		case 0:
			return edb::v1::format_pointer(region->start());
		case 1:
			return edb::v1::format_pointer(region->end());
		case 2:
			return QString("%1%2%3").arg(region->readable() ? 'r' : '-').arg(region->writable() ? 'w' : '-').arg(region->executable() ? 'x' : '-');
		case 3:
			return region->name();
		}
	}

	return QVariant();
}

//------------------------------------------------------------------------------
// Name: index
// Desc:
//------------------------------------------------------------------------------
QModelIndex MemoryRegions::index(int row, int column, const QModelIndex &parent) const {
	Q_UNUSED(parent)

	if (row >= rowCount(parent) || column >= columnCount(parent)) {
		return QModelIndex();
	}

	return createIndex(row, column, const_cast<std::shared_ptr<IRegion> *>(&regions_[row]));
}

//------------------------------------------------------------------------------
// Name: parent
// Desc:
//------------------------------------------------------------------------------
QModelIndex MemoryRegions::parent(const QModelIndex &index) const {
	Q_UNUSED(index)
	return QModelIndex();
}

//------------------------------------------------------------------------------
// Name: rowCount
// Desc:
//------------------------------------------------------------------------------
int MemoryRegions::rowCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return regions_.size();
}

//------------------------------------------------------------------------------
// Name: columnCount
// Desc:
//------------------------------------------------------------------------------
int MemoryRegions::columnCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return 4;
}

//------------------------------------------------------------------------------
// Name: headerData
// Desc:
//------------------------------------------------------------------------------
QVariant MemoryRegions::headerData(int section, Qt::Orientation orientation, int role) const {
	if (role == Qt::DisplayRole && orientation == Qt::Horizontal) {
		switch (section) {
		case 0:
			return tr("Start Address");
		case 1:
			return tr("End Address");
		case 2:
			return tr("Permissions");
		case 3:
			return tr("Name");
		}
	}

	return QVariant();
}

```

`src/PluginModel.cpp`:

```cpp
/*
Copyright (C) 2014 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "PluginModel.h"

#include <QtAlgorithms>

//------------------------------------------------------------------------------
// Name: PluginModel
// Desc:
//------------------------------------------------------------------------------
PluginModel::PluginModel(QObject *parent)
	: QAbstractItemModel(parent) {
}

//------------------------------------------------------------------------------
// Name: index
// Desc:
//------------------------------------------------------------------------------
QModelIndex PluginModel::index(int row, int column, const QModelIndex &parent) const {
	Q_UNUSED(parent)

	if (row >= rowCount(parent) || column >= columnCount(parent)) {
		return QModelIndex();
	}

	if (row >= 0) {
		return createIndex(row, column, const_cast<Item *>(&items_[row]));
	} else {
		return createIndex(row, column);
	}
}

//------------------------------------------------------------------------------
// Name: parent
// Desc:
//------------------------------------------------------------------------------
QModelIndex PluginModel::parent(const QModelIndex &index) const {
	Q_UNUSED(index)
	return QModelIndex();
}

//------------------------------------------------------------------------------
// Name: data
// Desc:
//------------------------------------------------------------------------------
QVariant PluginModel::data(const QModelIndex &index, int role) const {

	if (index.isValid()) {

		const Item &item = items_[index.row()];

		if (role == Qt::DisplayRole) {
			switch (index.column()) {
			case 0:
				return item.filename;
			case 1:
				return item.plugin;
			case 2:
				return item.author;
			case 3:
				return item.url;
			}
		}
	}

	return QVariant();
}

//------------------------------------------------------------------------------
// Name: headerData
// Desc:
//------------------------------------------------------------------------------
QVariant PluginModel::headerData(int section, Qt::Orientation orientation, int role) const {

	if (role == Qt::DisplayRole && orientation == Qt::Horizontal) {
		switch (section) {
		case 0:
			return tr("File Name");
		case 1:
			return tr("Plugin Name");
		case 2:
			return tr("Author");
		case 3:
			return tr("Website");
		}
	}

	return QVariant();
}

//------------------------------------------------------------------------------
// Name: columnCount
// Desc:
//------------------------------------------------------------------------------
int PluginModel::columnCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return 4;
}

//------------------------------------------------------------------------------
// Name: rowCount
// Desc:
//------------------------------------------------------------------------------
int PluginModel::rowCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return items_.size();
}

//------------------------------------------------------------------------------
// Name: addPlugin
// Desc:
//------------------------------------------------------------------------------
void PluginModel::addPlugin(const QString &filename, const QString &plugin, const QString &author, const QString &url) {
	beginInsertRows(QModelIndex(), rowCount(), rowCount());

	const Item item = {
		filename,
		plugin,
		author,
		url,
	};

	items_.push_back(item);
	endInsertRows();
}

//------------------------------------------------------------------------------
// Name: clear
// Desc:
//------------------------------------------------------------------------------
void PluginModel::clear() {
	beginResetModel();
	items_.clear();
	endResetModel();
}

```

`src/PluginModel.h`:

```h
/*
Copyright (C) 2014 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PLUGIN_MODEL_H_20191119_
#define PLUGIN_MODEL_H_20191119_

#include <QAbstractItemModel>
#include <QString>
#include <QVector>

class PluginModel final : public QAbstractItemModel {
	Q_OBJECT

public:
	struct Item {
		QString filename;
		QString plugin;
		QString author;
		QString url;
	};

public:
	explicit PluginModel(QObject *parent = nullptr);
	~PluginModel() override = default;

public:
	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex &index) const override;
	QVariant data(const QModelIndex &index, int role) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
	int columnCount(const QModelIndex &parent = QModelIndex()) const override;
	int rowCount(const QModelIndex &parent = QModelIndex()) const override;

public:
	void addPlugin(const QString &filename, const QString &plugin, const QString &author, const QString &url);
	void clear();

private:
	QVector<Item> items_;
};

#endif

```

`src/ProcessModel.cpp`:

```cpp
/*
Copyright (C) 2014 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ProcessModel.h"
#include "IProcess.h"

#include <QtAlgorithms>

ProcessModel::ProcessModel(QObject *parent)
	: QAbstractItemModel(parent) {
}

QModelIndex ProcessModel::index(int row, int column, const QModelIndex &parent) const {
	Q_UNUSED(parent)

	if (row >= rowCount(parent) || column >= columnCount(parent)) {
		return QModelIndex();
	}

	if (row >= 0) {
		return createIndex(row, column, const_cast<Item *>(&items_[row]));
	} else {
		return createIndex(row, column);
	}
}

QModelIndex ProcessModel::parent(const QModelIndex &index) const {
	Q_UNUSED(index)
	return QModelIndex();
}

QVariant ProcessModel::data(const QModelIndex &index, int role) const {

	if (index.isValid()) {

		const Item &item = items_[index.row()];

		if (role == Qt::DisplayRole) {
			switch (index.column()) {
			case 0:
				return QVariant::fromValue(item.pid);
			case 1:
				return item.user;
			case 2:
				return item.name;
			}
		} else if (role == Qt::UserRole) {
			return QVariant::fromValue(item.pid);
		}
	}

	return QVariant();
}

QVariant ProcessModel::headerData(int section, Qt::Orientation orientation, int role) const {

	if (role == Qt::DisplayRole && orientation == Qt::Horizontal) {
		switch (section) {
		case 0:
			return tr("PID");
		case 1:
			return tr("UID");
		case 2:
			return tr("Name");
		}
	}

	return QVariant();
}

int ProcessModel::columnCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return 3;
}

int ProcessModel::rowCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return items_.size();
}

void ProcessModel::addProcess(const std::shared_ptr<IProcess> &process) {
	beginInsertRows(QModelIndex(), rowCount(), rowCount());

	const Item item = {
		process->pid(),
		process->uid(),
		process->user(),
		process->name(),
	};

	items_.push_back(item);
	endInsertRows();
}

void ProcessModel::clear() {
	beginResetModel();
	items_.clear();
	endResetModel();
}

```

`src/ProcessModel.h`:

```h
/*
Copyright (C) 2014 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef PROCESS_MODEL_H_20191119_
#define PROCESS_MODEL_H_20191119_

#include "OSTypes.h"

#include <QAbstractItemModel>
#include <QString>
#include <QVector>

#include <memory>

class IProcess;

class ProcessModel final : public QAbstractItemModel {
	Q_OBJECT

public:
	struct Item {
		edb::pid_t pid;
		edb::uid_t uid;
		QString user;
		QString name;
	};

public:
	explicit ProcessModel(QObject *parent = nullptr);
	~ProcessModel() override = default;

public:
	QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex &index) const override;
	QVariant data(const QModelIndex &index, int role) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
	int columnCount(const QModelIndex &parent = QModelIndex()) const override;
	int rowCount(const QModelIndex &parent = QModelIndex()) const override;

public:
	void addProcess(const std::shared_ptr<IProcess> &process);
	void clear();

private:
	QVector<Item> items_;
};

#endif

```

`src/QLongValidator.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "QLongValidator.h"

//------------------------------------------------------------------------------
// Name: QLongValidator
// Desc:
//------------------------------------------------------------------------------
QLongValidator::QLongValidator(QObject *parent)
	: QValidator(parent) {
}

//------------------------------------------------------------------------------
// Name: QLongValidator
// Desc:
//------------------------------------------------------------------------------
QLongValidator::QLongValidator(QLongValidator::value_type minimum, QLongValidator::value_type maximum, QObject *parent)
	: QValidator(parent), minimum_(minimum), maximum_(maximum) {
}

//------------------------------------------------------------------------------
// Name: bottom
// Desc:
//------------------------------------------------------------------------------
QLongValidator::value_type QLongValidator::bottom() const {
	return minimum_;
}

//------------------------------------------------------------------------------
// Name: setBottom
// Desc:
//------------------------------------------------------------------------------
void QLongValidator::setBottom(QLongValidator::value_type bottom) {
	minimum_ = bottom;
}

//------------------------------------------------------------------------------
// Name: setRange
// Desc:
//------------------------------------------------------------------------------
void QLongValidator::setRange(QLongValidator::value_type bottom, QLongValidator::value_type top) {
	setBottom(bottom);
	setTop(top);
}

//------------------------------------------------------------------------------
// Name: setTop
// Desc:
//------------------------------------------------------------------------------
void QLongValidator::setTop(QLongValidator::value_type top) {
	maximum_ = top;
}

//------------------------------------------------------------------------------
// Name: top
// Desc:
//------------------------------------------------------------------------------
QLongValidator::value_type QLongValidator::top() const {
	return maximum_;
}

//------------------------------------------------------------------------------
// Name: validate
// Desc:
//------------------------------------------------------------------------------
QValidator::State QLongValidator::validate(QString &input, int &pos) const {
	Q_UNUSED(pos)

	if (input.isEmpty()) {
		return QValidator::Acceptable;
	}

	if (input == "-") {
		return QValidator::Intermediate;
	}

	bool ok;
	const value_type temp = input.toLongLong(&ok);
	if (!ok) {
		return QValidator::Invalid;
	}

	return (temp >= bottom() && temp <= top()) ? QValidator::Acceptable : QValidator::Invalid;
}

```

`src/QULongValidator.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "QULongValidator.h"

//------------------------------------------------------------------------------
// Name: QULongValidator
// Desc:
//------------------------------------------------------------------------------
QULongValidator::QULongValidator(QObject *parent)
	: QValidator(parent) {
}

//------------------------------------------------------------------------------
// Name: QULongValidator
// Desc:
//------------------------------------------------------------------------------
QULongValidator::QULongValidator(QULongValidator::value_type minimum, QULongValidator::value_type maximum, QObject *parent)
	: QValidator(parent), minimum_(minimum), maximum_(maximum) {
}

//------------------------------------------------------------------------------
// Name: bottom
// Desc:
//------------------------------------------------------------------------------
QULongValidator::value_type QULongValidator::bottom() const {
	return minimum_;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
void QULongValidator::setBottom(QULongValidator::value_type bottom) {
	minimum_ = bottom;
}

//------------------------------------------------------------------------------
// Name: setRange
// Desc:
//------------------------------------------------------------------------------
void QULongValidator::setRange(QULongValidator::value_type bottom, QULongValidator::value_type top) {
	setBottom(bottom);
	setTop(top);
}

//------------------------------------------------------------------------------
// Name: setTop
// Desc:
//------------------------------------------------------------------------------
void QULongValidator::setTop(QULongValidator::value_type top) {
	maximum_ = top;
}

//------------------------------------------------------------------------------
// Name: top
// Desc:
//------------------------------------------------------------------------------
QULongValidator::value_type QULongValidator::top() const {
	return maximum_;
}

//------------------------------------------------------------------------------
// Name: validate
// Desc:
//------------------------------------------------------------------------------
QValidator::State QULongValidator::validate(QString &input, int &pos) const {
	Q_UNUSED(pos)

	if (input.isEmpty()) {
		return QValidator::Acceptable;
	}

	bool ok;
	const value_type temp = input.toULongLong(&ok);
	if (!ok) {
		return QValidator::Invalid;
	}

	return (temp >= bottom() && temp <= top()) ? QValidator::Acceptable : QValidator::Invalid;
}

```

`src/RecentFileManager.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "RecentFileManager.h"

#include <QAction>
#include <QFileInfo>
#include <QMenu>
#include <QSettings>

#include <algorithm>

namespace {
constexpr int MaxRecentFiles = 8;
}

//------------------------------------------------------------------------------
// Name: RecentFileManager
// Desc: constructor
//------------------------------------------------------------------------------
RecentFileManager::RecentFileManager(QWidget *parent, Qt::WindowFlags f)
	: QWidget(parent, f) {

	QSettings settings;
	settings.beginGroup("Recent");
	const int size = settings.beginReadArray("recent.files");

	for (int i = 0; i < size; ++i) {
		settings.setArrayIndex(i);
		const auto file = settings.value("file").toString();

		if (file.isEmpty()) {
			continue;
		}

		const int size = settings.beginReadArray("arguments");

		QList<QByteArray> args;
		for (int i = 0; i < size; ++i) {
			settings.setArrayIndex(i);
			args.push_back(settings.value("arg").toByteArray());
		}

		settings.endArray();
		files_.push_back(std::make_pair(file, args));
	}

	settings.endArray();
	settings.endGroup();
}

//------------------------------------------------------------------------------
// Name: ~RecentFileManager
// Desc: destructor
//------------------------------------------------------------------------------
RecentFileManager::~RecentFileManager() {
	QSettings settings;
	settings.beginGroup("Recent");
	settings.beginWriteArray("recent.files");

	for (int i = 0; i < files_.size(); ++i) {
		const auto &file = files_[i];
		settings.setArrayIndex(i);
		settings.setValue("file", QVariant::fromValue(file.first));
		settings.beginWriteArray("arguments");

		for (int i = 0; i < file.second.size(); ++i) {
			settings.setArrayIndex(i);
			settings.setValue("arg", file.second[i]);
		}
		settings.endArray();
	}

	settings.endArray();
	settings.endGroup();
}

//------------------------------------------------------------------------------
// Name: clear
// Desc:
//------------------------------------------------------------------------------
void RecentFileManager::clear() {
	files_.clear();
	if (menu_) {
		menu_->clear();
		menu_->addSeparator();
		menu_->addAction(tr("Clear &Menu"), this, SLOT(clear()));
	}
}

//------------------------------------------------------------------------------
// Name: createMenu
// Desc:
//------------------------------------------------------------------------------
QMenu *RecentFileManager::createMenu() {

	if (!menu_) {
		menu_ = new QMenu(this);
		update();
	}

	return menu_;
}

//------------------------------------------------------------------------------
// Name: formatEntry
// Desc:
//------------------------------------------------------------------------------
QString RecentFileManager::formatEntry(const RecentFile &file) {
	QString str = file.first;
	for (const auto &arg : file.second) {
		str += " " + QString(arg);
	}
	return str;
}

//------------------------------------------------------------------------------
// Name: update
// Desc:
//------------------------------------------------------------------------------
void RecentFileManager::update() {
	if (menu_) {
		menu_->clear();

		Q_FOREACH (const auto &file, files_) {
			if (QAction *const action = menu_->addAction(formatEntry(file), this, SLOT(itemSelected()))) {
				action->setData(QVariant::fromValue(file));
			}
		}

		menu_->addSeparator();
		menu_->addAction(tr("Clear &Menu"), this, SLOT(clear()));
	}
}

//------------------------------------------------------------------------------
// Name: mostRecent
// Desc:
//------------------------------------------------------------------------------
RecentFileManager::RecentFile RecentFileManager::mostRecent() const {
	if (files_.isEmpty()) return {};
	return files_.front();
}

//------------------------------------------------------------------------------
// Name: entryCount
// Desc:
//------------------------------------------------------------------------------
int RecentFileManager::entryCount() const {
	return files_.size();
}

//------------------------------------------------------------------------------
// Name: itemSelected
// Desc:
//------------------------------------------------------------------------------
void RecentFileManager::itemSelected() {
	if (auto action = qobject_cast<QAction *>(sender())) {
		const auto file = action->data().value<RecentFile>();
		Q_EMIT fileSelected(file.first, file.second);
	}
}

//------------------------------------------------------------------------------
// Name: addFile
// Desc:
//------------------------------------------------------------------------------
void RecentFileManager::addFile(const QString &file, const QList<QByteArray> &args) {

	QFileInfo fi(file);
	QString path = fi.absoluteFilePath();

	// update recent file list, we remove all entries for this file (if any)
	// and then push the file on the front, ensuring that the recently run
	// entries are higher in the list
	files_.erase(std::remove_if(files_.begin(), files_.end(), [&path](const RecentFile &file) {
					 return file.first == path;
				 }),
				 files_.end());

	files_.push_front(std::make_pair(path, args));

	// make sure we don't add more than the max
	while (files_.size() > MaxRecentFiles) {
		files_.pop_back();
	}
	update();
}

```

`src/RecentFileManager.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef RECENT_FILE_MANAGER_H_20070430_
#define RECENT_FILE_MANAGER_H_20070430_

#include <QByteArray>
#include <QMetaType>
#include <QWidget>
#include <utility>

class QMenu;
class QWidget;
class QString;

class RecentFileManager : public QWidget {
	Q_OBJECT
public:
	using RecentFile = std::pair<QString, QList<QByteArray>>;

public:
	explicit RecentFileManager(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
	~RecentFileManager() override;

public:
	void addFile(const QString &file, const QList<QByteArray> &args);
	QMenu *createMenu();
	RecentFile mostRecent() const;
	int entryCount() const;

public Q_SLOTS:
	void clear();
	void itemSelected();

Q_SIGNALS:
	void fileSelected(const QString &, const QList<QByteArray> &);

private:
	void update();
	static QString formatEntry(const RecentFile &file);

private:
	QList<RecentFile> files_;
	QMenu *menu_ = nullptr;
};

Q_DECLARE_METATYPE(RecentFileManager::RecentFile)

#endif

```

`src/RegionBuffer.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "RegionBuffer.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "edb.h"

//------------------------------------------------------------------------------
// Name: RegionBuffer
// Desc:
//------------------------------------------------------------------------------
RegionBuffer::RegionBuffer(const std::shared_ptr<IRegion> &region)
	: QIODevice(), region_(region) {

	setOpenMode(QIODevice::ReadOnly);
}

//------------------------------------------------------------------------------
// Name: RegionBuffer
// Desc:
//------------------------------------------------------------------------------
RegionBuffer::RegionBuffer(const std::shared_ptr<IRegion> &region, QObject *parent)
	: QIODevice(parent), region_(region) {

	setOpenMode(QIODevice::ReadOnly);
}

//------------------------------------------------------------------------------
// Name: set_region
// Desc:
//------------------------------------------------------------------------------
void RegionBuffer::setRegion(const std::shared_ptr<IRegion> &region) {
	region_ = region;
	reset();
}

//------------------------------------------------------------------------------
// Name: readData
// Desc:
//------------------------------------------------------------------------------
qint64 RegionBuffer::readData(char *data, qint64 maxSize) {

	if (region_) {
		if (IProcess *process = edb::v1::debugger_core->process()) {
			const edb::address_t start = region_->start() + pos();
			const edb::address_t end   = region_->start() + region_->size();

			if (start + maxSize > end) {
				maxSize = end - start;
			}

			if (maxSize == 0) {
				return 0;
			}

			if (process->readBytes(start, data, maxSize)) {
				return maxSize;
			} else {
				return -1;
			}
		}
	}

	return -1;
}

//------------------------------------------------------------------------------
// Name: writeData
// Desc:
//------------------------------------------------------------------------------
qint64 RegionBuffer::writeData(const char *, qint64) {
	return -1;
}

```

`src/RegionBuffer.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef REGION_BUFFER_H_20101111_
#define REGION_BUFFER_H_20101111_

#include "IRegion.h"

#include <QIODevice>

#include <memory>

class IRegion;

class RegionBuffer final : public QIODevice {
	Q_OBJECT
public:
	explicit RegionBuffer(const std::shared_ptr<IRegion> &region);
	RegionBuffer(const std::shared_ptr<IRegion> &region, QObject *parent);

public:
	void setRegion(const std::shared_ptr<IRegion> &region);

public:
	qint64 readData(char *data, qint64 maxSize) override;
	qint64 writeData(const char *, qint64) override;
	qint64 size() const override { return region_ ? region_->size() : 0; }
	bool isSequential() const override { return false; }

private:
	std::shared_ptr<IRegion> region_;
};

#endif

```

`src/Register.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Register.h"
#include "Util.h"

/**
 * @brief Register::Register
 */
Register::Register() {
	util::mark_memory(&value_, sizeof(value_));
}

/**
 * @brief Register::operator ==
 * @param rhs
 * @return
 */
bool Register::operator==(const Register &rhs) const {
	if (!valid() && !rhs.valid()) {
		return true;
	} else {
		return name_ == rhs.name_ && value_ == rhs.value_ && type_ == rhs.type_ && bitSize_ == rhs.bitSize_;
	}
}

/**
 * @brief Register::toHexString
 * @return
 */
QString Register::toHexString() const {
	if (!valid()) {
		return tr("<undefined>");
	}

	if (bitSize_ % 8) {
		return tr("(Error: bad register length %1 bits)").arg(bitSize_);
	}

	return value_.toHexString().right(bitSize_ / 4); // TODO: trimming should be moved to valueXX::toHexString()
}

/**
 * @brief Register::operator !=
 * @param rhs
 * @return
 */
bool Register::operator!=(const Register &rhs) const {
	return !(*this == rhs);
}

/**
 * @brief Register::setScalarValue
 * @param newValue
 */
void Register::setScalarValue(std::uint64_t newValue) {

	auto from = reinterpret_cast<const char *>(&newValue);
	auto to   = reinterpret_cast<char *>(&value_);
	std::memcpy(to, from, bitSize_ / 8);
}

/**
 * @brief Register::valueAsAddress
 * @return
 */
edb::address_t Register::valueAsAddress() const {
	// This function only makes sense for GPRs
	assert(bitSize_ <= 8 * sizeof(edb::address_t));
	edb::address_t result(0LL);

	auto from = reinterpret_cast<const char *>(&value_);
	auto to   = reinterpret_cast<char *>(&result);
	std::memcpy(to, from, bitSize_ / 8);

	return result;
}

```

`src/RegisterViewModelBase.cpp`:

```cpp
/*
Copyright (C) 2017 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include "RegisterViewModelBase.h"
#include "FloatX.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IThread.h"
#include "State.h"
#include "Types.h"
#include "edb.h"
#include "util/Container.h"

#include <QBrush>
#include <QDebug>
#include <QSettings>
#include <QString>
#include <QtGlobal>

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <memory>
#include <numeric>

namespace RegisterViewModelBase {

namespace {

template <class T1, class T2>
T1 *checked_cast(T2 object) {
	Q_ASSERT(dynamic_cast<T1 *>(object));
	return static_cast<T1 *>(object);
}

RegisterViewItem *get_item(const QModelIndex &index) {
	if (!index.isValid()) {
		return nullptr;
	}

	return static_cast<RegisterViewItem *>(index.internalPointer());
}

QString toString(const edb::value80 &value, NumberDisplayMode format) {
	switch (format) {
	case NumberDisplayMode::Float:
		return format_float(value);
	case NumberDisplayMode::Hex:
		return value.toHexString();
	default:
		return QString("bug: format=%1").arg(static_cast<int>(format));
	}
}

// Sets register with name `name` to value `value`
// Returns whether it succeeded
// If succeeded, `resultingValue` is set to what the function got back after setting
// `resultingValue` can differ from `value` if e.g. the kernel doesn't allow to flip some
// bits of the register, like EFLAGS on x86.
template <typename T>
bool set_debugee_register(const QString &name, const T &value, T &resultingValue) {

	if (IDebugger *core = edb::v1::debugger_core) {

		IProcess *process = core->process();
		Q_ASSERT(process);

		State state;
		// read
		process->currentThread()->getState(&state);
		Register reg = state[name];

		if (!reg) {
			qWarning() << qPrintable(QString("Warning: failed to get register %1 (in function `%2`)").arg(name).arg(Q_FUNC_INFO));
			return false;
		}

		Q_ASSERT(reg.bitSize() == 8 * sizeof(T));

		const auto origValue = reg.value<T>();
		if (origValue == value) {
			return true; // do nothing if it's not different, it'll help us check result
		}

		// modify
		reg.setValueFrom(value);

		// write
		state.setRegister(reg);
		process->currentThread()->setState(state);

		// check
		process->currentThread()->getState(&state);
		const Register resultReg = state[name];

		if (!resultReg) {
			return false;
		}

		resultingValue = resultReg.value<T>();

		return resultingValue != origValue; // success if we changed it
	}

	return false;
}

}

// ----------------- RegisterViewItem impl ---------------------------

void RegisterViewItem::init(RegisterViewItem *parent, int row) {
	parentItem = parent;
	row_       = row;
}

// ---------------- CategoriesHolder impl ------------------------------

CategoriesHolder::CategoriesHolder()
	: RegisterViewItem("") {
}

int CategoriesHolder::childCount() const {

	return std::accumulate(categories.cbegin(), categories.cend(), 0, [](const int &psum, const std::unique_ptr<RegisterViewModelBase::Category> &cat) {
		return psum + cat->visible();
	});
}

QVariant CategoriesHolder::data(int /*column*/) const {
	return {};
}

QByteArray CategoriesHolder::rawValue() const {
	return {};
}

RegisterViewItem *CategoriesHolder::child(int visibleRow) {

	// return visible row #visibleRow
	for (std::size_t row = 0; row < categories.size(); ++row) {
		if (categories[row]->visible()) {
			--visibleRow;
		}

		if (visibleRow == -1) {
			return categories[row].get();
		}
	}

	return nullptr;
}

template <typename CategoryType>
CategoryType *CategoriesHolder::insert(const QString &name) {

	categories.emplace_back(std::make_unique<CategoryType>(name, categories.size()));
	return static_cast<CategoryType *>(categories.back().get());
}

SIMDCategory *CategoriesHolder::insertSimd(const QString &name, const std::vector<NumberDisplayMode> &validFormats) {
	auto cat = std::make_unique<SIMDCategory>(name, categories.size(), validFormats);
	auto ret = cat.get();
	categories.emplace_back(std::move(cat));
	return ret;
}

// ---------------- Model impl -------------------

Model::Model(QObject *parent)
	: QAbstractItemModel(parent), rootItem(new CategoriesHolder) {
}

void Model::setActiveIndex(const QModelIndex &newActiveIndex) {
	activeIndex_ = newActiveIndex;
}

QModelIndex Model::activeIndex() const {
	return activeIndex_;
}

QModelIndex Model::index(int row, int column, const QModelIndex &parent) const {

	if (!hasIndex(row, column, parent)) {
		return QModelIndex();
	}

	RegisterViewItem *parentItem;
	if (!parent.isValid()) {
		parentItem = rootItem.get();
	} else {
		parentItem = static_cast<RegisterViewItem *>(parent.internalPointer());
	}

	if (auto childItem = parentItem->child(row)) {
		return createIndex(row, column, childItem);
	} else {
		return QModelIndex();
	}
}

int Model::rowCount(const QModelIndex &parent) const {
	const RegisterViewItem *item = parent.isValid() ? get_item(parent) : rootItem.get();
	return item->childCount();
}

int Model::columnCount(const QModelIndex &) const {
	return 3; // all items reserve 3 columns: regName, value, comment
}

QModelIndex Model::parent(const QModelIndex &index) const {

	if (!index.isValid()) {
		return QModelIndex();
	}

	RegisterViewItem *parent = get_item(index)->parent();
	if (!parent || parent == rootItem.get()) {
		return QModelIndex();
	}

	return createIndex(parent->row(), 0, parent);
}

Qt::ItemFlags Model::flags(const QModelIndex &index) const {

	if (!index.isValid()) {
		return Qt::NoItemFlags;
	}

	return Qt::ItemIsEnabled | Qt::ItemIsSelectable | (index.column() == 1 ? Qt::ItemIsEditable : Qt::NoItemFlags);
}

QVariant Model::data(const QModelIndex &index, int role) const {

	const RegisterViewItem *item = get_item(index);
	if (!item) {
		return {};
	}

	switch (role) {
	case Qt::DisplayRole:
		return item->data(index.column());

	case Qt::ForegroundRole:
		if (index.column() != VALUE_COLUMN || !item->changed()) {
			return {}; // default color for unchanged register and for non-value column
		}
		return QBrush(Qt::red); // TODO: use user palette

	case RegisterChangedRole:
		return item->changed();

	case FixedLengthRole:
		if (index.column() == NAME_COLUMN) {
			return item->name().size();
		} else if (index.column() == VALUE_COLUMN) {
			return item->valueMaxLength();
		} else {
			return {};
		}

	case RawValueRole: {
		if (index.column() != VALUE_COLUMN) {
			return {};
		}

		const QByteArray ret = item->rawValue();
		if (ret.size()) {
			return ret;
		}

		return {};
	}
	case ChosenSIMDSizeRole:
		if (auto simdCat = dynamic_cast<const SIMDCategory *>(item)) {
			return static_cast<int>(simdCat->chosenSize());
		}

		return {};

	case ChosenSIMDFormatRole:
		if (auto simdCat = dynamic_cast<const SIMDCategory *>(item)) {
			return static_cast<int>(simdCat->chosenFormat());
		}

		return {};

	case ChosenSIMDSizeRowRole:
		if (auto simdCat = dynamic_cast<const SIMDCategory *>(item)) {
			switch (simdCat->chosenSize()) {
			case ElementSize::BYTE:
				return BYTES_ROW;
			case ElementSize::WORD:
				return WORDS_ROW;
			case ElementSize::DWORD:
				return DWORDS_ROW;
			case ElementSize::QWORD:
				return QWORDS_ROW;
			}
		}

		return {};

	case ChosenFPUFormatRole:
		if (auto fpuCat = dynamic_cast<const FPUCategory *>(item)) {
			return static_cast<int>(fpuCat->chosenFormat());
		}
		return {};

	case ChosenFPUFormatRowRole:
		if (auto fpuCat = dynamic_cast<const FPUCategory *>(item)) {
			switch (fpuCat->chosenFormat()) {
			case NumberDisplayMode::Float:
				return FPU_FLOAT_ROW;
			case NumberDisplayMode::Hex:
				return FPU_HEX_ROW;
			default:
				return {};
			}
		}
		return {};

	case ChosenSIMDFormatRowRole:
		if (auto simdCat = dynamic_cast<const SIMDCategory *>(item)) {
			switch (simdCat->chosenFormat()) {
			case NumberDisplayMode::Hex:
				return SIMD_HEX_ROW;
			case NumberDisplayMode::Signed:
				return SIMD_SIGNED_ROW;
			case NumberDisplayMode::Unsigned:
				return SIMD_UNSIGNED_ROW;
			case NumberDisplayMode::Float:
				return SIMD_FLOAT_ROW;
			}
		}
		return {};

	case ValidSIMDFormatsRole:
		if (auto simdCat = dynamic_cast<const SIMDCategory *>(item)) {
			return QVariant::fromValue(simdCat->validFormats());
		}
		return {};
	case IsNormalRegisterRole: {
		// Normal register is defined by its hierarchy level:
		// root(invalid index)->category->register
		// If level is not like this, it's not a normal register

		// parent should be category
		if (!index.parent().isValid()) {
			return false;
		}

		// parent of category is root, i.e. invalid index
		if (index.parent().parent().isValid()) {
			return false;
		}

		return true;
	}
	case IsFPURegisterRole:
		return !!dynamic_cast<const GenericFPURegister *>(item);

	case IsBitFieldRole:
		return !!dynamic_cast<const BitFieldProperties *>(item);

	case IsSIMDElementRole:
		return !!dynamic_cast<const SIMDElement *>(item);

	case BitFieldOffsetRole:
		if (auto bitField = dynamic_cast<const BitFieldProperties *>(item)) {
			return bitField->offset();
		}
		return {};

	case BitFieldLengthRole:
		if (auto bitField = dynamic_cast<const BitFieldProperties *>(item)) {
			return bitField->length();
		}
		return {};

	case ValueAsRegisterRole:
		if (IDebugger *core = edb::v1::debugger_core) {
			const auto name = index.sibling(index.row(), NAME_COLUMN).data().toString();
			if (name.isEmpty()) {
				return {};
			}

			State state;

			// read
			if (IProcess *process = core->process()) {
				process->currentThread()->getState(&state);
			}
			return QVariant::fromValue(state[name]);
		}
		break;

	default:
		return {};
	}
	return {};
}

bool Model::setData(const QModelIndex &index, const QVariant &data, int role) {
	RegisterViewItem *item       = get_item(index);
	const QModelIndex valueIndex = index.sibling(index.row(), VALUE_COLUMN);
	bool ok                      = false;

	switch (role) {
	case Qt::EditRole:
	case RawValueRole:
		if (this->data(index, IsNormalRegisterRole).toBool()) {
			auto reg = checked_cast<AbstractRegisterItem>(item);
			if (role == Qt::EditRole && data.type() == QVariant::String) {
				ok = reg->setValue(data.toString());
			} else if (data.type() == QVariant::ByteArray) {
				ok = reg->setValue(data.toByteArray());
			}
		}
		break;
	case ValueAsRegisterRole: {
		auto regItem = checked_cast<AbstractRegisterItem>(item);
		assert(data.isValid());
		assert(index.isValid());

		const auto name = index.sibling(index.row(), NAME_COLUMN).data().toString();
		Q_UNUSED(name)

		const auto regVal = data.value<Register>();
		assert(name.toLower() == regVal.name().toLower());

		ok = regItem->setValue(regVal);
		break;
	}
	}

	if (ok) {
		Q_EMIT dataChanged(valueIndex, valueIndex);
		if (rowCount(valueIndex)) {
			Q_EMIT dataChanged(this->index(0, VALUE_COLUMN, valueIndex),
							   this->index(rowCount(valueIndex), COMMENT_COLUMN, valueIndex));
		}
		return true;
	}

	return false;
}

void Model::setChosenSIMDSize(const QModelIndex &index, ElementSize const newSize) {
	const auto cat = get_item(index);
	Q_ASSERT(cat);

	const auto simdCat = dynamic_cast<SIMDCategory *>(cat);
	Q_ASSERT(simdCat);

	// Not very crash-worthy problem, just don't do anything in release mode
	if (!simdCat) {
		return;
	}

	simdCat->setChosenSize(newSize);
	Q_EMIT SIMDDisplayFormatChanged();

	// Make treeviews update root register items with default view
	const auto valueIndex = index.sibling(index.row(), VALUE_COLUMN);
	Q_EMIT dataChanged(valueIndex, valueIndex);
}

void Model::setChosenSIMDFormat(const QModelIndex &index, NumberDisplayMode const newFormat) {
	const auto cat = get_item(index);
	Q_ASSERT(cat);

	const auto simdCat = dynamic_cast<SIMDCategory *>(cat);
	Q_ASSERT(simdCat);

	// Not very crash-worthy problem, just don't do anything in release mode
	if (!simdCat) {
		return;
	}

	simdCat->setChosenFormat(newFormat);
	Q_EMIT SIMDDisplayFormatChanged();

	// Make treeviews update root register items with default view
	const auto valueIndex = index.sibling(index.row(), VALUE_COLUMN);
	Q_EMIT dataChanged(valueIndex, valueIndex);
}

void Model::setChosenFPUFormat(const QModelIndex &index, NumberDisplayMode const newFormat) {
	const auto cat = get_item(index);
	Q_ASSERT(cat);

	const auto fpuCat = dynamic_cast<FPUCategory *>(cat);
	Q_ASSERT(fpuCat);

	// Not very crash-worthy problem, just don't do anything in release mode
	if (!fpuCat) {
		return;
	}

	fpuCat->setChosenFormat(newFormat);
	Q_EMIT FPUDisplayFormatChanged();

	// Make treeviews update root register items with default view
	const auto valueIndex = index.sibling(index.row(), VALUE_COLUMN);
	Q_EMIT dataChanged(valueIndex, valueIndex);
}

void Model::hideAll() {
	for (const auto &cat : rootItem->categories) {
		cat->hide();
	}
}

Category *Model::addCategory(const QString &name) {
	return rootItem->insert(name);
}

SIMDCategory *Model::addSIMDCategory(const QString &name, const std::vector<NumberDisplayMode> &validFormats) {
	return rootItem->insertSimd(name, validFormats);
}

FPUCategory *Model::addFPUCategory(const QString &name) {
	return rootItem->insert<FPUCategory>(name);
}

void Model::hide(Category *cat) {
	cat->hide();
}

void Model::show(Category *cat) {
	cat->show();
}

void Model::saveValues() {
	for (const auto &cat : rootItem->categories) {
		cat->saveValues();
	}
}

// -------------------- Category impl --------------------

Category::Category(const QString &name, int row)
	: RegisterViewItem(name) {
	init(nullptr, row);
}

Category::Category(Category &&other) noexcept
	: RegisterViewItem(std::move(other.name_)) {
	parentItem = other.parentItem;
	row_       = other.row_;
	registers  = std::move(other.registers);
}

int Category::childCount() const {
	return registers.size();
}

RegisterViewItem *Category::child(int row) {
	if (row < 0 || row >= childCount()) {
		return nullptr;
	}

	return registers[row].get();
}

QVariant Category::data(int column) const {
	if (column == 0) {
		return name_;
	}

	return {};
}

QByteArray Category::rawValue() const {
	return {};
}

void Category::hide() {
	visible_ = false;
	for (const auto &reg : registers) {
		reg->invalidate();
	}
}

void Category::show() {
	visible_ = true;
}

bool Category::visible() const {
	return visible_;
}

void Category::addRegister(std::unique_ptr<AbstractRegisterItem> reg) {
	registers.emplace_back(std::move(reg));
	registers.back()->init(this, registers.size() - 1);
}

AbstractRegisterItem *Category::getRegister(std::size_t i) const {
	return registers[i].get();
}

void Category::saveValues() {
	for (auto &reg : registers)
		reg->saveValue();
}

// -------------------- RegisterItem impl ------------------------
template <typename T>
RegisterItem<T>::RegisterItem(const QString &name)
	: AbstractRegisterItem(name) {
	invalidate();
}

template <typename T>
void RegisterItem<T>::invalidate() {

	util::mark_memory(&value_, sizeof(value_));
	util::mark_memory(&prevValue_, sizeof(prevValue_));

	comment_.clear();
	valueKnown_     = false;
	prevValueKnown_ = false;
}

template <typename T>
bool RegisterItem<T>::valid() const {
	return valueKnown_;
}

template <typename T>
bool RegisterItem<T>::changed() const {
	return !valueKnown_ || !prevValueKnown_ || prevValue_ != value_;
}

template <typename T>
void RegisterItem<T>::saveValue() {
	prevValue_      = value_;
	prevValueKnown_ = valueKnown_;
}

template <typename T>
int RegisterItem<T>::childCount() const {
	return 0;
}

template <typename T>
RegisterViewItem *RegisterItem<T>::child(int) {
	return nullptr; // simple register item has no children
}

template <typename T>
QString RegisterItem<T>::valueString() const {
	if (!this->valueKnown_) {
		return "???";
	}

	return this->value_.toHexString();
}

template <typename T>
QVariant RegisterItem<T>::data(int column) const {
	switch (column) {
	case Model::NAME_COLUMN:
		return this->name_;
	case Model::VALUE_COLUMN:
		return valueString();
	case Model::COMMENT_COLUMN:
		return this->comment_;
	}
	return {};
}

template <typename T>
QByteArray RegisterItem<T>::rawValue() const {
	if (!this->valueKnown_) {
		return {};
	}
	return QByteArray(reinterpret_cast<const char *>(&this->value_), sizeof(this->value_));
}

template <typename T>
bool RegisterItem<T>::setValue(const Register &reg) {
	assert(reg.bitSize() == 8 * sizeof(T));
	return set_debugee_register<T>(reg.name(), reg.value<T>(), value_);
}

template <typename T>
bool RegisterItem<T>::setValue(const QByteArray &newValue) {
	T value;
	std::memcpy(&value, newValue.constData(), newValue.size());
	return set_debugee_register<T>(name(), value, value_);
}

template <typename T>
typename std::enable_if<(sizeof(T) > sizeof(std::uint64_t)), bool>::type setValue(T & /*valueToSet*/, const QString & /*name*/, const QString & /*valueStr*/) {
	qWarning() << "FIXME: unimplemented" << Q_FUNC_INFO;
	return false; // TODO: maybe do set?.. would be arch-dependent then due to endianness
}

template <typename T>
typename std::enable_if<sizeof(T) <= sizeof(std::uint64_t), bool>::type setValue(T &valueToSet, const QString &name, const QString &valueStr) {
	bool ok          = false;
	const auto value = T::fromHexString(valueStr, &ok);

	if (!ok) {
		return false;
	}

	return set_debugee_register(name, value, valueToSet);
}

template <typename T>
bool RegisterItem<T>::setValue(const QString &valueStr) {
	// TODO: ask ArchProcessor to actually set it and return true only if done
	return RegisterViewModelBase::setValue(value_, name(), valueStr);
}

template class RegisterItem<edb::value16>;
template class RegisterItem<edb::value32>;
template class RegisterItem<edb::value64>;
template class RegisterItem<edb::value80>;
template class RegisterItem<edb::value128>;
template class RegisterItem<edb::value256>;

// -------------------- SimpleRegister impl -----------------------

template <typename T>
void SimpleRegister<T>::update(const T &value, const QString &comment) {
	this->value_      = value;
	this->comment_    = comment;
	this->valueKnown_ = true;
}

template <typename T>
int SimpleRegister<T>::valueMaxLength() const {
	return 2 * sizeof(T);
}

template class SimpleRegister<edb::value16>;
template class SimpleRegister<edb::value32>;
template class SimpleRegister<edb::value64>;
template class SimpleRegister<edb::value80>;
template class SimpleRegister<edb::value128>;
template class SimpleRegister<edb::value256>;

// ---------------- BitFieldItem impl -----------------------

template <typename UnderlyingType>
BitFieldItem<UnderlyingType>::BitFieldItem(const BitFieldDescriptionEx &descr)
	: RegisterViewItem(descr.name), offset_(descr.offset), length_(descr.length), explanations(descr.explanations) {
	Q_ASSERT(8 * sizeof(UnderlyingType) >= length_);
	Q_ASSERT(explanations.size() == 0 || explanations.size() == 2u << (length_ - 1));
}

template <typename UnderlyingType>
FlagsRegister<UnderlyingType> *BitFieldItem<UnderlyingType>::reg() const {
	return checked_cast<FlagsRegister<UnderlyingType>>(this->parent());
}

template <typename UnderlyingType>
UnderlyingType BitFieldItem<UnderlyingType>::lengthToMask() const {
	return 2 * (1ull << (length_ - 1)) - 1;
}

template <typename UnderlyingType>
UnderlyingType BitFieldItem<UnderlyingType>::calcValue(UnderlyingType regVal) const {
	return (regVal >> offset_) & lengthToMask();
}

template <typename UnderlyingType>
UnderlyingType BitFieldItem<UnderlyingType>::value() const {
	return calcValue(reg()->value_);
}

template <typename UnderlyingType>
UnderlyingType BitFieldItem<UnderlyingType>::prevValue() const {
	return calcValue(reg()->prevValue_);
}

template <typename UnderlyingType>
int BitFieldItem<UnderlyingType>::valueMaxLength() const {
	return std::ceil(length_ / 4.); // number of nibbles
}

template <typename UnderlyingType>
bool BitFieldItem<UnderlyingType>::changed() const {
	return !reg()->valueKnown_ || !reg()->prevValueKnown_ || value() != prevValue();
}

template <typename UnderlyingType>
QVariant BitFieldItem<UnderlyingType>::data(int column) const {
	const auto str = reg()->valid() ? value().toHexString() : QString(sizeof(UnderlyingType) * 2, '?');
	switch (column) {
	case Model::NAME_COLUMN:
		return name();
	case Model::VALUE_COLUMN:
		Q_ASSERT(str.size() > 0);
		return str.right(std::ceil(length_ / 4.));
	case Model::COMMENT_COLUMN:
		if (explanations.empty()) {
			return {};
		}
		return reg()->valid() ? explanations[value()] : QString();
	}
	return {};
}

template <typename UnderlyingType>
QByteArray BitFieldItem<UnderlyingType>::rawValue() const {
	const auto val = value();
	return QByteArray(reinterpret_cast<const char *>(&val), sizeof(val));
}

template <typename UnderlyingType>
unsigned BitFieldItem<UnderlyingType>::length() const {
	return length_;
}

template <typename UnderlyingType>
unsigned BitFieldItem<UnderlyingType>::offset() const {
	return offset_;
}

// ---------------- FlagsRegister impl ------------------------

template <typename StoredType>
FlagsRegister<StoredType>::FlagsRegister(const QString &name, const std::vector<BitFieldDescriptionEx> &bitFields)
	: SimpleRegister<StoredType>(name) {

	for (auto &field : bitFields) {
		fields.emplace_back(field);
		fields.back().init(this, fields.size() - 1);
	}
}

template <typename StoredType>
int FlagsRegister<StoredType>::childCount() const {
	return fields.size();
}

template <typename StoredType>
RegisterViewItem *FlagsRegister<StoredType>::child(int row) {
	return &fields[row];
}

template class FlagsRegister<edb::value16>;
template class FlagsRegister<edb::value32>;
template class FlagsRegister<edb::value64>;

// --------------------- SIMDFormatItem impl -----------------------

template <class StoredType, class SizingType>
QString SIMDFormatItem<StoredType, SizingType>::name(NumberDisplayMode format) const {

	switch (format) {
	case NumberDisplayMode::Hex:
		return "hex";
	case NumberDisplayMode::Signed:
		return "signed";
	case NumberDisplayMode::Unsigned:
		return "unsigned";
	case NumberDisplayMode::Float:
		return "float";
	}
	Q_UNREACHABLE();
}

template <class StoredType, class SizingType>
SIMDFormatItem<StoredType, SizingType>::SIMDFormatItem(NumberDisplayMode format)
	: RegisterViewItem(name(format)), format_(format) {
}

template <class StoredType, class SizingType>
NumberDisplayMode SIMDFormatItem<StoredType, SizingType>::format() const {
	return format_;
}

template <class StoredType, class SizingType>
bool SIMDFormatItem<StoredType, SizingType>::changed() const {
	return parent()->changed();
}

template <class SizingType>
typename std::enable_if<(sizeof(SizingType) >= sizeof(float) && sizeof(SizingType) != sizeof(edb::value80)), QString>::type toString(SizingType value, NumberDisplayMode format) {
	return format == NumberDisplayMode::Float ? format_float(value) : util::format_int(value, format);
}

template <class SizingType>
typename std::enable_if<sizeof(SizingType) < sizeof(float), QString>::type toString(SizingType value, NumberDisplayMode format) {
	return format == NumberDisplayMode::Float ? "(too small element width for float)" : util::format_int(value, format);
}

template <class StoredType, class SizingType>
QVariant SIMDFormatItem<StoredType, SizingType>::data(int column) const {

	switch (column) {
	case Model::NAME_COLUMN:
		return this->name();

	case Model::VALUE_COLUMN:
		if (const auto parent = dynamic_cast<SIMDSizedElement<StoredType, SizingType> *>(this->parent())) {
			return parent->valid() ? toString(parent->value(), format_) : "???";
		}

		if (const auto parent = dynamic_cast<FPURegister<SizingType> *>(this->parent())) {
			return parent->valid() ? toString(parent->value(), format_) : "???";
		}

		EDB_PRINT_AND_DIE("failed to detect parent type");

	case Model::COMMENT_COLUMN:
		return {};
	}

	return {};
}

template <class StoredType, class SizingType>
QByteArray SIMDFormatItem<StoredType, SizingType>::rawValue() const {
	return this->parent()->rawValue();
}

template <>
int SIMDFormatItem<edb::value80, edb::value80>::valueMaxLength() const {

	// TODO(eteran): we need a sensible implementation for non-80-bit long double support
#ifndef _MSC_VER
	Q_ASSERT(sizeof(edb::value80) <= sizeof(long double));
#endif
	switch (format_) {
	case NumberDisplayMode::Hex:
		return 2 * sizeof(edb::value80);
	case NumberDisplayMode::Float:
		return max_printed_length<long double>();
	default:
		EDB_PRINT_AND_DIE("Unexpected format: ", static_cast<long>(format_));
	}
}

template <class StoredType, class SizingType>
int SIMDFormatItem<StoredType, SizingType>::valueMaxLength() const {

	using Unsigned = typename SizingType::InnerValueType;
	using Signed   = typename std::make_signed<Unsigned>::type;

	switch (format_) {
	case NumberDisplayMode::Hex:
		return 2 * sizeof(SizingType);
	case NumberDisplayMode::Signed:
		return max_printed_length<Signed>();
	case NumberDisplayMode::Unsigned:
		return max_printed_length<Unsigned>();
	case NumberDisplayMode::Float:
		switch (sizeof(SizingType)) {
		case sizeof(float):
			return max_printed_length<float>();
		case sizeof(double):
			return max_printed_length<double>();
		default:
			if (sizeof(SizingType) < sizeof(float)) {
				return 0;
			}
			EDB_PRINT_AND_DIE("Unexpected sizing type's size for format float: ", sizeof(SizingType));
		}
	}

	Q_UNREACHABLE();
}

// --------------------- SIMDSizedElement  impl -------------------------

template <class StoredType, class SizingType>
SIMDSizedElement<StoredType, SizingType>::SIMDSizedElement(const QString &name, const std::vector<NumberDisplayMode> &validFormats)
	: RegisterViewItem(name) {

	for (const auto format : validFormats) {
		if (format != NumberDisplayMode::Float || sizeof(SizingType) >= sizeof(float)) {
			// The order must be as expected by other functions
			Q_ASSERT(format != NumberDisplayMode::Float || formats.size() == Model::SIMD_FLOAT_ROW);
			Q_ASSERT(format != NumberDisplayMode::Hex || formats.size() == Model::SIMD_HEX_ROW);
			Q_ASSERT(format != NumberDisplayMode::Signed || formats.size() == Model::SIMD_SIGNED_ROW);
			Q_ASSERT(format != NumberDisplayMode::Unsigned || formats.size() == Model::SIMD_UNSIGNED_ROW);

			formats.emplace_back(format);
			formats.back().init(this, formats.size() - 1);
		}
	}
}

template <class StoredType, class SizingType>
RegisterViewItem *SIMDSizedElement<StoredType, SizingType>::child(int row) {
	return &formats[row];
}

template <class StoredType, class SizingType>
int SIMDSizedElement<StoredType, SizingType>::childCount() const {
	return formats.size();
}

template <class StoredType, class SizingType>
SIMDRegister<StoredType> *SIMDSizedElement<StoredType, SizingType>::reg() const {
	return checked_cast<SIMDRegister<StoredType>>(this->parent()->parent());
}

template <class StoredType, class SizingType>
bool SIMDSizedElement<StoredType, SizingType>::valid() const {
	return reg()->valueKnown_;
}

template <class StoredType, class SizingType>
QString SIMDSizedElement<StoredType, SizingType>::valueString() const {
	if (!valid()) {
		return "??";
	}
	return toString(value(), reg()->category()->chosenFormat());
}

template <class StoredType, class SizingType>
int SIMDSizedElement<StoredType, SizingType>::valueMaxLength() const {
	for (const auto &format : formats) {
		if (format.format() == reg()->category()->chosenFormat()) {
			return format.valueMaxLength();
		}
	}
	return 0;
}

template <class StoredType, class SizingType>
SizingType SIMDSizedElement<StoredType, SizingType>::value() const {
	std::size_t offset = this->row() * sizeof(SizingType);
	return SizingType(reg()->value_, offset);
}

template <class StoredType, class SizingType>
QVariant SIMDSizedElement<StoredType, SizingType>::data(int column) const {
	switch (column) {
	case Model::NAME_COLUMN:
		return this->name_;
	case Model::VALUE_COLUMN:
		return valueString();
	case Model::COMMENT_COLUMN:
		return {};
	}
	return {};
}

template <class StoredType, class SizingType>
QByteArray SIMDSizedElement<StoredType, SizingType>::rawValue() const {
	const auto value = this->value();
	return QByteArray(reinterpret_cast<const char *>(&value), sizeof(value));
}

template <class StoredType, class SizingType>
bool SIMDSizedElement<StoredType, SizingType>::changed() const {
	const auto reg           = this->reg();
	const std::size_t offset = this->row() * sizeof(SizingType);

	return !reg->valueKnown_ || !reg->prevValueKnown_ || SizingType(reg->prevValue_, offset) != SizingType(reg->value_, offset);
}

// --------------------- SIMDSizedElementsContainer impl -------------------------

template <class StoredType>
template <class SizeType, class... Args>
void SIMDSizedElementsContainer<StoredType>::addElement(Args &&...args) {
	using Element = SIMDSizedElement<StoredType, SizeType>;

	elements.emplace_back(std::make_unique<Element>(std::forward<Args>(args)...));
}

template <class StoredType>
SIMDSizedElementsContainer<StoredType>::SIMDSizedElementsContainer(const QString &name, std::size_t size, const std::vector<NumberDisplayMode> &validFormats)
	: RegisterViewItem(name) {

	for (unsigned elemN = 0; elemN < sizeof(StoredType) / size; ++elemN) {
		const auto name = QString("#%1").arg(elemN);
		switch (size) {
		case sizeof(edb::value8):
			addElement<edb::value8>(name, validFormats);
			break;
		case sizeof(edb::value16):
			addElement<edb::value16>(name, validFormats);
			break;
		case sizeof(edb::value32):
			addElement<edb::value32>(name, validFormats);
			break;
		case sizeof(edb::value64):
			addElement<edb::value64>(name, validFormats);
			break;
		default:
			EDB_PRINT_AND_DIE("Unexpected element size ", static_cast<long>(size));
		}
		elements.back()->init(this, elemN);
	}
}

template <class StoredType>
SIMDSizedElementsContainer<StoredType>::SIMDSizedElementsContainer(SIMDSizedElementsContainer &&other) noexcept
	: RegisterViewItem(other), elements(std::move(other.elements)) {
}

template <class StoredType>
RegisterViewItem *SIMDSizedElementsContainer<StoredType>::child(int row) {
	Q_ASSERT(unsigned(row) < elements.size());
	return elements[row].get();
}

template <class StoredType>
int SIMDSizedElementsContainer<StoredType>::childCount() const {
	return elements.size();
}

template <class StoredType>
QVariant SIMDSizedElementsContainer<StoredType>::data(int column) const {
	switch (column) {
	case Model::NAME_COLUMN:
		return this->name_;
	case Model::VALUE_COLUMN: {
		const auto width = elements[0]->valueMaxLength();
		QString str;

		static_assert(Q_BYTE_ORDER == Q_LITTLE_ENDIAN, "This piece of code relies on little endian byte order");

		for (auto it = elements.rbegin(); it != elements.rend(); ++it) {
			const std::unique_ptr<RegisterViewModelBase::RegisterViewItem> &elem = *it;
			str += elem->data(column).toString().rightJustified(width + 1);
		}

		return str;
	}
	case Model::COMMENT_COLUMN:
		return {};
	default:
		return {};
	}
}

template <class StoredType>
QByteArray SIMDSizedElementsContainer<StoredType>::rawValue() const {
	return this->parent()->rawValue();
}

template <class StoredType>
bool SIMDSizedElementsContainer<StoredType>::changed() const {
	for (auto &elem : elements) {
		if (elem->changed()) {
			return true;
		}
	}

	return false;
}

// --------------------- SIMDRegister impl -------------------------

template <class StoredType>
SIMDRegister<StoredType>::SIMDRegister(const QString &name, const std::vector<NumberDisplayMode> &validFormats)
	: SimpleRegister<StoredType>(name) {

	static const auto sizeNames = util::make_array(
		QObject::tr("bytes"),
		QObject::tr("words"),
		QObject::tr("dwords"),
		QObject::tr("qwords"));

	// NOTE: If you change order, don't forget about enum SizesOrder and places where it's used
	for (unsigned shift = 0; (1u << shift) <= sizeof(std::uint64_t); ++shift) {
		const auto size = 1u << shift;
		sizedElementContainers.emplace_back(sizeNames[shift], size, validFormats);
		sizedElementContainers.back().init(this, shift);
	}
}

template <class StoredType>
int SIMDRegister<StoredType>::childCount() const {
	return sizedElementContainers.size();
}

template <class StoredType>
RegisterViewItem *SIMDRegister<StoredType>::child(int row) {
	Q_ASSERT(static_cast<size_t>(row) < sizedElementContainers.size());
	return &sizedElementContainers[row];
}

template <class StoredType>
SIMDCategory *SIMDRegister<StoredType>::category() const {
	const auto cat = this->parent();
	return checked_cast<SIMDCategory>(cat);
}

template <class StoredType>
QVariant SIMDRegister<StoredType>::data(int column) const {

	if (column != Model::VALUE_COLUMN) {
		return RegisterItem<StoredType>::data(column);
	}

	const auto chosenSize = category()->chosenSize();
	switch (chosenSize) {
	case Model::ElementSize::BYTE:
		return sizedElementContainers[Model::BYTES_ROW].data(column);
	case Model::ElementSize::WORD:
		return sizedElementContainers[Model::WORDS_ROW].data(column);
	case Model::ElementSize::DWORD:
		return sizedElementContainers[Model::DWORDS_ROW].data(column);
	case Model::ElementSize::QWORD:
		return sizedElementContainers[Model::QWORDS_ROW].data(column);
	}
	Q_UNREACHABLE();
}

template class SIMDRegister<edb::value64>;
template class SIMDRegister<edb::value128>;
template class SIMDRegister<edb::value256>;

// ----------------------------- FPURegister impl ---------------------------

template <class FloatType>
FPURegister<FloatType>::FPURegister(const QString &name)
	: SimpleRegister<FloatType>(name) {
	formats.emplace_back(NumberDisplayMode::Hex);
	formats.back().init(this, Model::FPU_HEX_ROW);
	formats.emplace_back(NumberDisplayMode::Float);
	formats.back().init(this, Model::FPU_FLOAT_ROW);
}

template <class FloatType>
void FPURegister<FloatType>::update(const FloatType &newValue, const QString &newComment) {
	SimpleRegister<FloatType>::update(newValue, newComment);
}

template <class FloatType>
void FPURegister<FloatType>::saveValue() {
	SimpleRegister<FloatType>::saveValue();
}

template <class FloatType>
int FPURegister<FloatType>::childCount() const {
	return formats.size();
}

template <class FloatType>
RegisterViewItem *FPURegister<FloatType>::child(int row) {
	Q_ASSERT(static_cast<size_t>(row) < formats.size());
	return &formats[row];
}

template <class FloatType>
FloatType FPURegister<FloatType>::value() const {
	return this->value_;
}

template <class FloatType>
QString FPURegister<FloatType>::valueString() const {
	if (!this->valid()) {
		return "??";
	}
	return toString(value(), category()->chosenFormat());
}

template <class FloatType>
FPUCategory *FPURegister<FloatType>::category() const {
	const auto cat = this->parent();
	return checked_cast<FPUCategory>(cat);
}

template <class FloatType>
int FPURegister<FloatType>::valueMaxLength() const {
	for (const auto &format : formats) {
		if (format.format() == category()->chosenFormat()) {
			return format.valueMaxLength();
		}
	}
	return 0;
}

template class FPURegister<edb::value80>;

// ---------------------------- SIMDCategory impl ------------------------------
const auto settingsMainKey     = QLatin1String("RegisterViewModelBase");
const auto settingsFormatKey   = QLatin1String("format");
const auto settingsSIMDSizeKey = QLatin1String("size");

SIMDCategory::SIMDCategory(const QString &name, int row, const std::vector<NumberDisplayMode> &validFormats)
	: Category(name, row), validFormats_(validFormats) {

	QSettings settings;
	settings.beginGroup(settingsMainKey + "/" + name);

	const auto defaultFormat = NumberDisplayMode::Hex;
	chosenFormat_            = static_cast<NumberDisplayMode>(settings.value(settingsFormatKey, static_cast<int>(defaultFormat)).toInt());

	if (!util::contains(validFormats, chosenFormat_)) {
		chosenFormat_ = defaultFormat;
	}

	chosenSize_ = static_cast<Model::ElementSize>(settings.value(settingsSIMDSizeKey, static_cast<int>(Model::ElementSize::WORD)).toInt());
}

SIMDCategory::~SIMDCategory() {

	QSettings settings;
	settings.beginGroup(settingsMainKey + "/" + name());

	// Simple guard against rewriting settings which didn't change between
	// categories with the same name (but e.g. different bitness)
	// FIXME: this won't work correctly in general if multiple categories changed settings
	if (formatChanged_) {
		settings.setValue(settingsFormatKey, static_cast<int>(chosenFormat_));
	}

	if (sizeChanged_) {
		settings.setValue(settingsSIMDSizeKey, static_cast<int>(chosenSize_));
	}
}

NumberDisplayMode SIMDCategory::chosenFormat() const {
	return chosenFormat_;
}

Model::ElementSize SIMDCategory::chosenSize() const {
	return chosenSize_;
}

void SIMDCategory::setChosenFormat(NumberDisplayMode newFormat) {
	formatChanged_ = true;
	chosenFormat_  = newFormat;
}

void SIMDCategory::setChosenSize(Model::ElementSize newSize) {
	sizeChanged_ = true;
	chosenSize_  = newSize;
}

const std::vector<NumberDisplayMode> &SIMDCategory::validFormats() const {
	return validFormats_;
}

// ----------------------------- FPUCategory impl ---------------------------

FPUCategory::FPUCategory(const QString &name, int row)
	: Category(name, row) {

	QSettings settings;
	settings.beginGroup(settingsMainKey + "/" + name);
	const auto defaultFormat = NumberDisplayMode::Float;

	chosenFormat_ = static_cast<NumberDisplayMode>(settings.value(settingsFormatKey, static_cast<int>(defaultFormat)).toInt());

	if (chosenFormat_ != NumberDisplayMode::Float && chosenFormat_ != NumberDisplayMode::Hex) {
		chosenFormat_ = defaultFormat;
	}
}

FPUCategory::~FPUCategory() {
	QSettings settings;
	settings.beginGroup(settingsMainKey + "/" + name());
	if (formatChanged_) {
		settings.setValue(settingsFormatKey, static_cast<int>(chosenFormat_));
	}
}

void FPUCategory::setChosenFormat(NumberDisplayMode newFormat) {
	formatChanged_ = true;
	chosenFormat_  = newFormat;
}

NumberDisplayMode FPUCategory::chosenFormat() const {
	return chosenFormat_;
}

// -----------------------------------------------

void Model::dataUpdateFinished() {
	Q_EMIT dataChanged(
		index(0, 1 /*names don't change*/, QModelIndex()),
		index(rowCount() - 1, NUM_COLS - 1, QModelIndex()));
}

}

```

`src/State.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "State.h"
#include "IDebugger.h"
#include "IState.h"
#include "edb.h"

#include <QtAlgorithms>

/**
 * @brief State::State
 */
State::State()
	: impl_(edb::v1::debugger_core ? edb::v1::debugger_core->createState() : nullptr) {
}

/**
 * @brief State::~State
 */
State::~State() = default;

/**
 * @brief State::State
 * @param other
 */
State::State(const State &other)
	: impl_(other.impl_ ? other.impl_->clone() : nullptr) {
}

/**
 * @brief State::State
 * @param other
 */
State::State(State &&other) noexcept
	: impl_(std::move(other.impl_)) {
}

/**
 * @brief State::swap
 * @param other
 */
void State::swap(State &other) {
	using std::swap;
	swap(impl_, other.impl_);
}

/**
 * @brief State::operator =
 * @param rhs
 * @return
 */
State &State::operator=(State &&rhs) noexcept {
	if (this != &rhs) {
		impl_ = std::move(rhs.impl_);
	}
	return *this;
}

/**
 * @brief State::operator =
 * @param rhs
 * @return
 */
State &State::operator=(const State &rhs) {
	if (this != &rhs) {
		State(rhs).swap(*this);
	}
	return *this;
}

/**
 * @brief State::clear
 */
void State::clear() {
	if (impl_) {
		impl_->clear();
	}
}

/**
 * @brief State::empty
 * @return
 */
bool State::empty() const {
	if (impl_) {
		return impl_->empty();
	}
	return true;
}

/**
 * @brief State::instructionPointerRegister
 * @return
 */
Register State::instructionPointerRegister() const {
	if (impl_) {
		return impl_->instructionPointerRegister();
	}
	return Register();
}

/**
 * @brief State::instructionPointer
 * @return
 */
edb::address_t State::instructionPointer() const {
	if (impl_) {
		return impl_->instructionPointer();
	}
	return edb::address_t(0);
}

/**
 * @brief State::stackPointer
 * @return
 */
edb::address_t State::stackPointer() const {
	if (impl_) {
		return impl_->stackPointer();
	}
	return edb::address_t(0);
}

/**
 * @brief State::framePointer
 * @return
 */
edb::address_t State::framePointer() const {
	if (impl_) {
		return impl_->framePointer();
	}
	return edb::address_t(0);
}

/**
 * @brief State::flagsRegister
 * @return
 */
Register State::flagsRegister() const {
	if (impl_) {
		return impl_->flagsRegister();
	}
	return Register();
}

/**
 * @brief State::flags
 * @return
 */
edb::reg_t State::flags() const {
	if (impl_) {
		return impl_->flags();
	}
	return edb::reg_t(0);
}

/**
 * @brief State::value
 * @param reg
 * @return the value of a register based on it's name
 */
Register State::value(const QString &reg) const {
	if (impl_) {
		return impl_->value(reg);
	}
	return Register();
}

/**
 * @brief State::operator []
 * @param reg
 * @return
 */
Register State::operator[](const QString &reg) const {
	if (impl_) {
		return impl_->value(reg);
	}
	return Register();
}

/**
 * @brief State::setRegister
 * @param reg
 */
void State::setRegister(const Register &reg) {
	if (impl_) {
		impl_->setRegister(reg);
	}
}

/**
 * @brief State::setRegister
 * @param name
 * @param value
 */
void State::setRegister(const QString &name, edb::reg_t value) {
	if (impl_) {
		impl_->setRegister(name, value);
	}
}

/**
 * @brief State::adjustStack
 * @param bytes
 */
void State::adjustStack(int bytes) {
	if (impl_) {
		impl_->adjustStack(bytes);
	}
}

/**
 * @brief State::setInstructionPointer
 * @param value
 */
void State::setInstructionPointer(edb::address_t value) {
	if (impl_) {
		impl_->setInstructionPointer(value);
	}
}

/**
 * @brief State::flagsToString
 * @return
 */
QString State::flagsToString() const {
	if (impl_) {
		return impl_->flagsToString();
	}
	return QString();
}

/**
 * @brief State::flagsToString
 * @param flags
 * @return
 */
QString State::flagsToString(edb::reg_t flags) const {
	if (impl_) {
		return impl_->flagsToString(flags);
	}
	return QString();
}

/**
 * @brief State::setFlags
 * @param flags
 */
void State::setFlags(edb::reg_t flags) {
	if (impl_) {
		return impl_->setFlags(flags);
	}
}

/**
 * @brief State::debugRegister
 * @param n
 * @return
 */
edb::reg_t State::debugRegister(size_t n) const {
	if (impl_) {
		return impl_->debugRegister(n);
	}
	return edb::reg_t(0);
}

/**
 * @brief State::setDebugRegister
 * @param n
 * @param value
 */
void State::setDebugRegister(size_t n, edb::reg_t value) {
	if (impl_) {
		impl_->setDebugRegister(n, value);
	}
}

/**
 * @brief State::archRegister
 * @param type
 * @param n
 * @return
 */
Register State::archRegister(uint64_t type, size_t n) const {
	if (impl_) {
		return impl_->archRegister(type, n);
	}
	return Register();
}

#if defined(EDB_X86) || defined(EDB_X86_64)
/**
 * @brief State::fpuStackPointer
 * @return
 */
int State::fpuStackPointer() const {
	if (impl_) {
		return impl_->fpuStackPointer();
	}
	return 0;
}

/**
 * @brief State::fpuRegister
 * @param n
 * @return
 */
edb::value80 State::fpuRegister(size_t n) const {
	if (impl_) {
		return impl_->fpuRegister(n);
	}
	return edb::value80(std::array<std::uint8_t, 10>({0, 0, 0, 0, 0, 0, 0, 0, 0, 0}));
}

/**
 * @brief State::fpuRegisterIsEmpty
 * @param n
 * @return
 */
bool State::fpuRegisterIsEmpty(std::size_t n) const {
	if (impl_) {
		return impl_->fpuRegisterIsEmpty(n);
	}
	return true;
}

/**
 * @brief State::fpuStatusWord
 * @return
 */
edb::value16 State::fpuStatusWord() const {
	if (impl_) {
		return impl_->fpuStatusWord();
	}
	return edb::value16(0);
}

/**
 * @brief State::fpuControlWord
 * @return
 */
edb::value16 State::fpuControlWord() const {
	if (impl_) {
		return impl_->fpuControlWord();
	}
	return edb::value16(0);
}

/**
 * @brief State::fpuTagWord
 * @return
 */
edb::value16 State::fpuTagWord() const {
	if (impl_) {
		return impl_->fpuTagWord();
	}
	return edb::value16(0);
}

/**
 * @brief State::fpuRegisterTagString
 * @param n
 * @return
 */
QString State::fpuRegisterTagString(std::size_t n) const {
	if (impl_) {
		return impl_->fpuRegisterTagString(n);
	}
	return QString();
}
#endif

/**
 * @brief State::gpRegister
 * @param n
 * @return
 */
Register State::gpRegister(size_t n) const {
	if (impl_) {
		return impl_->gpRegister(n);
	}
	return Register();
}

```

`src/SymbolManager.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "SymbolManager.h"
#include "Configuration.h"
#include "ISymbolGenerator.h"
#include "Symbol.h"
#include "edb.h"

#include <QDir>
#include <QFile>
#include <QMessageBox>
#include <QProcess>
#include <QtDebug>

#include <fstream>
#include <iostream>
#include <istream>

//------------------------------------------------------------------------------
// Name: clear
// Desc:
//------------------------------------------------------------------------------
void SymbolManager::clear() {
	symbolFiles_.clear();
	symbols_.clear();
	symbolsByAddress_.clear();
	symbolsByFile_.clear();
	symbolsByName_.clear();
	labels_.clear();
	labelsByName_.clear();
}

//------------------------------------------------------------------------------
// Name: loadSymbolFile
// Desc:
//------------------------------------------------------------------------------
void SymbolManager::loadSymbolFile(const QString &filename, edb::address_t base) {

	const QString symbol_directory = edb::v1::config().symbol_path;

	if (symbol_directory.isEmpty()) {
		if (showPathNotice_) {
			qDebug() << "No symbol path specified. Please set it in the preferences to enable symbols.";
			showPathNotice_ = false;
		}
		return;
	}

	// ensure that the directory exists
	QDir().mkpath(symbol_directory);

	QFileInfo info(filename);

	if (info.exists() && info.isReadable()) {

		if (info.isRelative()) {
			info.makeAbsolute();
		}

		const QString path = QString("%1/%2").arg(symbol_directory, info.absolutePath());
		const QString name = info.fileName();

		// ensure that the sub-directory exists
		QDir().mkpath(path);

		if (!symbolFiles_.contains(info.absoluteFilePath())) {
			const QString map_file = QString("%1/%2.map").arg(path, name);

			if (processSymbolFile(map_file, base, filename, true)) {
				symbolFiles_.insert(info.absoluteFilePath());
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: find
// Desc:
//------------------------------------------------------------------------------
const std::shared_ptr<Symbol> SymbolManager::find(const QString &name) const {

	auto it = symbolsByName_.find(name);
	if (it != symbolsByName_.end()) {
		return it.value();
	}

	// slow path... look for any symbol which matches the name, but skipping the prefix
	// we can make this faster later at the cost of yet another hash table if we
	// feel the need
	auto it2 = std::find_if(symbols_.begin(), symbols_.end(), [&name](const std::shared_ptr<Symbol> &symbol) {
		return symbol->name_no_prefix == name;
	});

	if (it2 != symbols_.end()) {
		return *it2;
	}

	return nullptr;
}

//------------------------------------------------------------------------------
// Name: find
// Desc:
//------------------------------------------------------------------------------
const std::shared_ptr<Symbol> SymbolManager::find(edb::address_t address) const {
	auto it = symbolsByAddress_.find(address);
	return (it != symbolsByAddress_.end()) ? it.value() : nullptr;
}

//------------------------------------------------------------------------------
// Name: findNearSymbol
// Desc:
//------------------------------------------------------------------------------
const std::shared_ptr<Symbol> SymbolManager::findNearSymbol(edb::address_t address) const {

	auto it = symbolsByAddress_.lowerBound(address);
	if (it != symbolsByAddress_.end()) {

		// not an exact match, we should backup one
		if (address != it.value()->address) {
			// not safe to backup!, return early
			if (it == symbolsByAddress_.begin()) {
				return nullptr;
			}
			--it;
		}

		if (const std::shared_ptr<Symbol> sym = it.value()) {
			if (address >= sym->address && address < sym->address + sym->size) {
				return sym;
			}
		}
	}

	return nullptr;
}

//------------------------------------------------------------------------------
// Name: addSymbol
// Desc:
//------------------------------------------------------------------------------
void SymbolManager::addSymbol(const std::shared_ptr<Symbol> &symbol) {
	Q_ASSERT(symbol);
	symbols_.push_back(symbol);
	symbolsByAddress_[symbol->address] = symbol;
	symbolsByName_[symbol->name]       = symbol;
	symbolsByFile_[symbol->file].push_back(symbol);
}

//------------------------------------------------------------------------------
// Name: processSymbolFile
// Desc:
// Note: returning false means 'try again', true means, 'we loaded what we could'
//------------------------------------------------------------------------------
bool SymbolManager::processSymbolFile(const QString &f, edb::address_t base, const QString &library_filename, bool allow_retry) {

	// TODO(eteran): support filename starting with "http://" being fetched from a web server

	QFile symbolFile(f);
	if (symbolFile.size() == 0) {
		symbolFile.remove();
	}

	std::ifstream file(qPrintable(f));
	if (file) {
		edb::v1::set_status(tr("Loading symbols: %1").arg(f), 0);
		edb::address_t sym_start;
		edb::address_t sym_end;
		std::string sym_name;
		std::string date;
		std::string md5;
		std::string filename;

		if (std::getline(file, date)) {
			file >> md5 >> std::ws;
			std::getline(file, filename);
			if (file) {

				const QByteArray file_md5   = QByteArray::fromHex(md5.c_str());
				const QByteArray actual_md5 = edb::v1::get_file_md5(library_filename);

				if (file_md5 != actual_md5) {
					qDebug() << "Your symbol file for" << library_filename << "appears to not match the actual file, perhaps you should rebuild your symbols?";
					const Configuration &config = edb::v1::config();
					if (config.remove_stale_symbols) {
						symbolFile.remove();

						if (allow_retry) {
							return processSymbolFile(f, base, library_filename, false);
						}
					}
					edb::v1::clear_status();
					return false;
				}

				const QFileInfo info(QString::fromStdString(filename));
				const QString prefix = info.fileName();
				char sym_type;

				while (true) {
					file >> std::hex >> sym_start >> std::hex >> sym_end >> sym_type;
					// For symbol name we can't use operator>>() as it may have spaces if demangled
					// Thus, get the rest of the line as the symbol name
					std::getline(file, sym_name);

					if (!file) {
						if (!file.eof()) qWarning() << "WARNING: File" << f << "seems corrupt";
						break;
					}

					auto sym = std::make_shared<Symbol>();

					sym->file           = f;
					sym->name_no_prefix = QString::fromStdString(sym_name).trimmed();
					sym->name           = QString("%1!%2").arg(prefix, sym->name_no_prefix);
					sym->address        = sym_start;
					sym->size           = sym_end;
					sym->type           = sym_type;

					// fixup the base address based on where it is loaded
					if (sym->address < base) {
						sym->address += base;
					}

					addSymbol(sym);
				}
				edb::v1::clear_status();
				return true;
			}
		}
	} else if (symbolGenerator_) {
		edb::v1::set_status(tr("Auto-Generating Symbol File: %1").arg(f), 0);
		bool generatedOK = symbolGenerator_->generateSymbolFile(library_filename, f);
		edb::v1::clear_status();
		if (generatedOK) {
			return false;
		}
	}

	// TODO(eteran): should we return false and try again later?
	edb::v1::clear_status();
	return true;
}

//------------------------------------------------------------------------------
// Name: symbols
// Desc:
//------------------------------------------------------------------------------
const std::vector<std::shared_ptr<Symbol>> SymbolManager::symbols() const {
	return symbols_;
}

//------------------------------------------------------------------------------
// Name: setSymbolGenerator
// Desc:
//------------------------------------------------------------------------------
void SymbolManager::setSymbolGenerator(ISymbolGenerator *generator) {
	symbolGenerator_ = generator;
}

//------------------------------------------------------------------------------
// Name: setLabel
// Desc: a label is like a symbol, but can be set/unset by users. They will take
//       precidence over symbols (since this is the name that the user really
//       wants to call this address). And only apply to code
//------------------------------------------------------------------------------
void SymbolManager::setLabel(edb::address_t address, const QString &label) {
	if (label.isEmpty()) {
		labelsByName_.remove(labels_[address]);
		labels_.remove(address);
	} else {

		if (labelsByName_.contains(label) && labelsByName_[label] != address) {
			QMessageBox::warning(
				edb::v1::debugger_ui,
				tr("Duplicate Label"),
				tr("You are attempting to give two seperate addresses the same label, this is not supported."));
			return;
		}

		labels_[address]     = label;
		labelsByName_[label] = address;
	}
}

//------------------------------------------------------------------------------
// Name: findAddressName
// Desc:
//------------------------------------------------------------------------------
QString SymbolManager::findAddressName(edb::address_t address, bool prefixed) {
	auto it = labels_.find(address);
	if (it != labels_.end()) {
		return it.value();
	}

	if (const std::shared_ptr<Symbol> sym = find(address)) {
		return prefixed ? sym->name : sym->name_no_prefix;
	}

	return QString();
}

//------------------------------------------------------------------------------
// Name: labels
// Desc:
//------------------------------------------------------------------------------
QHash<edb::address_t, QString> SymbolManager::labels() const {
	return labels_;
}

//------------------------------------------------------------------------------
// Name: files
// Desc:
//------------------------------------------------------------------------------
QStringList SymbolManager::files() const {
	return symbolsByFile_.keys();
}

```

`src/SymbolManager.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef SYMBOL_MANAGER_H_20060814_
#define SYMBOL_MANAGER_H_20060814_

#include "ISymbolManager.h"

#include <QCoreApplication>
#include <QHash>
#include <QMap>
#include <QSet>

class QString;

class SymbolManager final : public ISymbolManager {
	Q_DECLARE_TR_FUNCTIONS(SymbolManager)

public:
	SymbolManager() = default;

public:
	const std::vector<std::shared_ptr<Symbol>> symbols() const override;
	const std::shared_ptr<Symbol> find(const QString &name) const override;
	const std::shared_ptr<Symbol> find(edb::address_t address) const override;
	const std::shared_ptr<Symbol> findNearSymbol(edb::address_t address) const override;
	void addSymbol(const std::shared_ptr<Symbol> &symbol) override;
	void clear() override;
	void loadSymbolFile(const QString &filename, edb::address_t base) override;
	void setSymbolGenerator(ISymbolGenerator *generator) override;
	void setLabel(edb::address_t address, const QString &label) override;
	QString findAddressName(edb::address_t address, bool prefixed = true) override;
	QHash<edb::address_t, QString> labels() const override;
	QStringList files() const override;

private:
	bool processSymbolFile(const QString &f, edb::address_t base, const QString &library_filename, bool allow_retry);

private:
	QSet<QString> symbolFiles_;
	std::vector<std::shared_ptr<Symbol>> symbols_;
	QMap<edb::address_t, std::shared_ptr<Symbol>> symbolsByAddress_;
	QHash<QString, QList<std::shared_ptr<Symbol>>> symbolsByFile_;
	QHash<QString, std::shared_ptr<Symbol>> symbolsByName_;
	QHash<edb::address_t, QString> labels_;
	QHash<QString, edb::address_t> labelsByName_;
	ISymbolGenerator *symbolGenerator_ = nullptr;
	bool showPathNotice_               = true;
};

#endif

```

`src/Theme.cpp`:

```cpp
/*
Copyright (C) 2020 - 2020 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Theme.h"
#include "Configuration.h"
#include "edb.h"
#include <QApplication>
#include <QDir>
#include <QPalette>
#include <QSettings>
#include <QStandardPaths>

namespace {

/**
 * @brief Theme::userThemes
 * @return
 */
QString themeDirectory() {
	static const QString configDir = QStandardPaths::writableLocation(QStandardPaths::GenericConfigLocation);
	return QString("%1/%2/%3").arg(configDir, QApplication::organizationName(), QLatin1String("themes"));
}

/**
 * @brief readColor
 * @param settings
 * @param name
 * @param defaultValue
 * @return
 */
QColor readColor(QSettings &settings, const QString &name, const QColor &defaultValue = QColor()) {

	QVariant variant = settings.value(name);

	auto color = variant.value<QColor>();
	if (color.isValid()) {
		return color;
	}

	return defaultValue;
}

/**
 * @brief readFormat
 * @param settings
 * @param name
 * @param defaultValue
 * @return
 */
QTextCharFormat readFormat(QSettings &settings, const QString &name, const QTextCharFormat &defaultValue = QTextCharFormat()) {

	QTextCharFormat format;
	format.setForeground(readColor(settings, QString("%1.foreground").arg(name), defaultValue.foreground().color()));
	format.setBackground(readColor(settings, QString("%1.background").arg(name), defaultValue.background().color()));
	format.setFontWeight(settings.value(QString("%1.weight").arg(name), defaultValue.fontWeight()).toInt());
	format.setFontItalic(settings.value(QString("%1.italic").arg(name), defaultValue.fontItalic()).toBool());
	format.setFontUnderline(settings.value(QString("%1.underline").arg(name), defaultValue.fontUnderline()).toBool());
	return format;
}

// we do this immediately invoked lambda being assigned to a static stuff
// to make it so the theme is read once even if this function is called several times
Theme readTheme(QSettings &settings, const Theme &baseTheme = Theme()) {
	Theme theme;

	settings.beginGroup("Theme");
	// General application palette
	theme.palette[Theme::Window]                  = readColor(settings, "palette.window", baseTheme.palette[Theme::Window]);
	theme.palette[Theme::WindowDisabled]          = readColor(settings, "palette.window.disabled", baseTheme.palette[Theme::WindowDisabled]);
	theme.palette[Theme::WindowText]              = readColor(settings, "palette.windowtext", baseTheme.palette[Theme::WindowText]);
	theme.palette[Theme::WindowTextDisabled]      = readColor(settings, "palette.windowtext.disabled", baseTheme.palette[Theme::WindowTextDisabled]);
	theme.palette[Theme::Base]                    = readColor(settings, "palette.base", baseTheme.palette[Theme::Base]);
	theme.palette[Theme::BaseDisabled]            = readColor(settings, "palette.base.disabled", baseTheme.palette[Theme::BaseDisabled]);
	theme.palette[Theme::AlternateBase]           = readColor(settings, "palette.alternatebase", baseTheme.palette[Theme::AlternateBase]);
	theme.palette[Theme::AlternateBaseDisabled]   = readColor(settings, "palette.alternatebase.disabled", baseTheme.palette[Theme::AlternateBaseDisabled]);
	theme.palette[Theme::ToolTipBase]             = readColor(settings, "palette.tooltipbase", baseTheme.palette[Theme::ToolTipBase]);
	theme.palette[Theme::ToolTipBaseDisabled]     = readColor(settings, "palette.tooltipbase.disabled", baseTheme.palette[Theme::ToolTipBaseDisabled]);
	theme.palette[Theme::ToolTipText]             = readColor(settings, "palette.tooltiptext", baseTheme.palette[Theme::ToolTipText]);
	theme.palette[Theme::ToolTipTextDisabled]     = readColor(settings, "palette.tooltiptext.disabled", baseTheme.palette[Theme::ToolTipTextDisabled]);
	theme.palette[Theme::Text]                    = readColor(settings, "palette.text", baseTheme.palette[Theme::Text]);
	theme.palette[Theme::TextDisabled]            = readColor(settings, "palette.text.disabled", baseTheme.palette[Theme::TextDisabled]);
	theme.palette[Theme::Button]                  = readColor(settings, "palette.button", baseTheme.palette[Theme::Button]);
	theme.palette[Theme::ButtonDisabled]          = readColor(settings, "palette.button.disabled", baseTheme.palette[Theme::ButtonDisabled]);
	theme.palette[Theme::ButtonText]              = readColor(settings, "palette.buttontext", baseTheme.palette[Theme::ButtonText]);
	theme.palette[Theme::ButtonTextDisabled]      = readColor(settings, "palette.buttontext.disabled", baseTheme.palette[Theme::ButtonTextDisabled]);
	theme.palette[Theme::BrightText]              = readColor(settings, "palette.brighttext", baseTheme.palette[Theme::BrightText]);
	theme.palette[Theme::BrightTextDisabled]      = readColor(settings, "palette.brighttext.disabled", baseTheme.palette[Theme::BrightTextDisabled]);
	theme.palette[Theme::Highlight]               = readColor(settings, "palette.highlight", baseTheme.palette[Theme::Highlight]);
	theme.palette[Theme::HighlightDisabled]       = readColor(settings, "palette.highlight.disabled", baseTheme.palette[Theme::HighlightDisabled]);
	theme.palette[Theme::HighlightedText]         = readColor(settings, "palette.highlightedtext", baseTheme.palette[Theme::HighlightedText]);
	theme.palette[Theme::HighlightedTextDisabled] = readColor(settings, "palette.highlightedtext.disabled", baseTheme.palette[Theme::HighlightedTextDisabled]);
	theme.palette[Theme::Link]                    = readColor(settings, "palette.link", baseTheme.palette[Theme::Link]);
	theme.palette[Theme::LinkDisabled]            = readColor(settings, "palette.link.disabled", baseTheme.palette[Theme::LinkDisabled]);
	theme.palette[Theme::LinkVisited]             = readColor(settings, "palette.linkvisited", baseTheme.palette[Theme::LinkVisited]);
	theme.palette[Theme::LinkVisitedDisabled]     = readColor(settings, "palette.linkvisited.disabled", baseTheme.palette[Theme::LinkVisitedDisabled]);
	theme.palette[Theme::Light]                   = readColor(settings, "palette.light", baseTheme.palette[Theme::Light]);
	theme.palette[Theme::LightDisabled]           = readColor(settings, "palette.light.disabled", baseTheme.palette[Theme::LightDisabled]);
	theme.palette[Theme::Midlight]                = readColor(settings, "palette.midlight", baseTheme.palette[Theme::Midlight]);
	theme.palette[Theme::MidlightDisabled]        = readColor(settings, "palette.midlight.disabled", baseTheme.palette[Theme::MidlightDisabled]);
	theme.palette[Theme::Dark]                    = readColor(settings, "palette.dark", baseTheme.palette[Theme::Dark]);
	theme.palette[Theme::DarkDisabled]            = readColor(settings, "palette.dark.disabled", baseTheme.palette[Theme::DarkDisabled]);
	theme.palette[Theme::Mid]                     = readColor(settings, "palette.mid", baseTheme.palette[Theme::Mid]);
	theme.palette[Theme::MidDisabled]             = readColor(settings, "palette.mid.disabled", baseTheme.palette[Theme::MidDisabled]);
	theme.palette[Theme::Shadow]                  = readColor(settings, "palette.shadow", baseTheme.palette[Theme::Shadow]);
	theme.palette[Theme::ShadowDisabled]          = readColor(settings, "palette.shadow.disabled", baseTheme.palette[Theme::ShadowDisabled]);

	// various text/syntax settings
	theme.text[Theme::Address]              = readFormat(settings, "address", baseTheme.text[Theme::Address]);
	theme.text[Theme::AlternatingByte]      = readFormat(settings, "alternating_byte", baseTheme.text[Theme::AlternatingByte]);
	theme.text[Theme::Arithmetic]           = readFormat(settings, "arithmetic", baseTheme.text[Theme::Arithmetic]);
	theme.text[Theme::Brackets]             = readFormat(settings, "brackets", baseTheme.text[Theme::Brackets]);
	theme.text[Theme::Comma]                = readFormat(settings, "comma", baseTheme.text[Theme::Comma]);
	theme.text[Theme::Comparison]           = readFormat(settings, "comparison", baseTheme.text[Theme::Comparison]);
	theme.text[Theme::Constant]             = readFormat(settings, "constant", baseTheme.text[Theme::Constant]);
	theme.text[Theme::DataXfer]             = readFormat(settings, "data_xfer", baseTheme.text[Theme::DataXfer]);
	theme.text[Theme::Data]                 = readFormat(settings, "data", baseTheme.text[Theme::Data]);
	theme.text[Theme::Filling]              = readFormat(settings, "filling", baseTheme.text[Theme::Filling]);
	theme.text[Theme::FlowCtrl]             = readFormat(settings, "flow_ctrl", baseTheme.text[Theme::FlowCtrl]);
	theme.text[Theme::Function]             = readFormat(settings, "function", baseTheme.text[Theme::Function]);
	theme.text[Theme::Logic]                = readFormat(settings, "logic", baseTheme.text[Theme::Logic]);
	theme.text[Theme::NonPrintingCharacter] = readFormat(settings, "non_printing_character", baseTheme.text[Theme::NonPrintingCharacter]);
	theme.text[Theme::Operator]             = readFormat(settings, "operator", baseTheme.text[Theme::Operator]);
	theme.text[Theme::Prefix]               = readFormat(settings, "prefix", baseTheme.text[Theme::Prefix]);
	theme.text[Theme::Ptr]                  = readFormat(settings, "ptr", baseTheme.text[Theme::Ptr]);
	theme.text[Theme::Register]             = readFormat(settings, "register", baseTheme.text[Theme::Register]);
	theme.text[Theme::Shift]                = readFormat(settings, "shift", baseTheme.text[Theme::Shift]);
	theme.text[Theme::Stack]                = readFormat(settings, "stack", baseTheme.text[Theme::Stack]);
	theme.text[Theme::System]               = readFormat(settings, "system", baseTheme.text[Theme::System]);
	theme.text[Theme::TakenJump]            = readFormat(settings, "taken_jump", baseTheme.text[Theme::TakenJump]);

	// misc settings
	theme.misc[Theme::Badge] = readFormat(settings, "badge", baseTheme.misc[Theme::Badge]);

	settings.endGroup();

	return theme;
}

/**
 * @brief readSystemTheme
 * @return
 */
Theme readSystemTheme() {
	if (QApplication::palette().window().color().lightnessF() >= 0.5) {
		QSettings settings(":/themes/system-light.ini", QSettings::IniFormat);
		return readTheme(settings);
	} else {
		QSettings settings(":/themes/system-dark.ini", QSettings::IniFormat);
		return readTheme(settings);
	}
}

/**
 * @brief readTheme
 * @return
 */
Theme readTheme() {

	// Ensure that the directory exists, this will help users know where to put the theme files
	QDir().mkpath(themeDirectory());

	Theme system = readSystemTheme();

	QString theme_name = edb::v1::config().theme_name;

	// Handle the built-in themese
	if (theme_name == "System") {
		return system;
	} else if (theme_name == "Dark [Built-in]") {
		QSettings settings(":/themes/dark.ini", QSettings::IniFormat);
		return readTheme(settings, system);
	} else if (theme_name == "Light [Built-in]") {
		QSettings settings(":/themes/light.ini", QSettings::IniFormat);
		return readTheme(settings, system);
	}

	QString themeFile = themeDirectory() + QDir::separator() + theme_name;
	QSettings settings(themeFile, QSettings::IniFormat);
	return readTheme(settings, system);
}

}

/**
 * @brief Theme::load
 * @return
 */
Theme Theme::load() {

	// we do this function indirection to make it so the theme is
	// read once even if this function is called several times
	static Theme theme = readTheme();
	return theme;
}

/**
 * @brief Theme::userThemes
 * @return
 */
QStringList Theme::userThemes() {
	QDir directory(themeDirectory());
	return directory.entryList(QStringList() << "*.ini", QDir::Files);
}

/**
 * @brief Theme::themeName
 * @param theme_file
 * @return
 */
QString Theme::themeName(const QString &theme_file) {
	QString themeFile = themeDirectory() + QDir::separator() + theme_file;
	QSettings settings(themeFile, QSettings::IniFormat);

	settings.beginGroup("Meta");
	QString name = settings.value("name", theme_file).toString();
	settings.endGroup();
	return name;
}

```

`src/ThreadsModel.cpp`:

```cpp
/*
Copyright (C) 2014 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ThreadsModel.h"
#include "IThread.h"
#include "edb.h"

#include <QtAlgorithms>

ThreadsModel::ThreadsModel(QObject *parent)
	: QAbstractItemModel(parent) {
}

QModelIndex ThreadsModel::index(int row, int column, const QModelIndex &parent) const {
	Q_UNUSED(parent)

	if (row >= rowCount(parent) || column >= columnCount(parent)) {
		return QModelIndex();
	}

	if (row >= 0) {
		return createIndex(row, column, const_cast<Item *>(&items_[row]));
	} else {
		return createIndex(row, column);
	}
}

QModelIndex ThreadsModel::parent(const QModelIndex &index) const {
	Q_UNUSED(index)
	return QModelIndex();
}

QVariant ThreadsModel::data(const QModelIndex &index, int role) const {

	if (index.isValid()) {

		const Item &item = items_[index.row()];

		if (role == Qt::DisplayRole) {
			switch (index.column()) {
			case 0:
				if (item.current) {
					return tr("*%1").arg(item.thread->tid());
				} else {
					return QVariant::fromValue(item.thread->tid());
				}
			case 1:
				return item.thread->priority();
			case 2: {
				const QString default_region_name;
				const QString symname = edb::v1::find_function_symbol(item.thread->instructionPointer(), default_region_name);

				if (!symname.isEmpty()) {
					return QString("%1 <%2>").arg(edb::v1::format_pointer(item.thread->instructionPointer()), symname);
				} else {
					return QString("%1").arg(edb::v1::format_pointer(item.thread->instructionPointer()));
				}
			}
			case 3:
				return item.thread->runState();
			case 4:
				return item.thread->name();
			}
		} else if (role == Qt::UserRole) {
			return QVariant::fromValue(item.thread->tid());
		}
	}

	return QVariant();
}

QVariant ThreadsModel::headerData(int section, Qt::Orientation orientation, int role) const {

	if (role == Qt::DisplayRole && orientation == Qt::Horizontal) {
		switch (section) {
		case 0:
			return tr("ID");
		case 1:
			return tr("Priority");
		case 2:
			return tr("Instruction Pointer");
		case 3:
			return tr("State");
		case 4:
			return tr("Name");
		}
	}

	return QVariant();
}

int ThreadsModel::columnCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return 5;
}

int ThreadsModel::rowCount(const QModelIndex &parent) const {
	Q_UNUSED(parent)
	return items_.size();
}

void ThreadsModel::addThread(const std::shared_ptr<IThread> &thread, bool current) {
	beginInsertRows(QModelIndex(), rowCount(), rowCount());

	const Item item = {
		thread,
		current,
	};

	items_.push_back(item);
	endInsertRows();
}

void ThreadsModel::clear() {
	beginResetModel();
	items_.clear();
	endResetModel();
}

```

`src/arch/arm-generic/ArchProcessor.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com
Copyright (C) 2017 - 2017 Ruslan Kabatsayev
                          b7.10110111@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ArchProcessor.h"
#include "Configuration.h"
#include "IDebugger.h"
#include "RegisterViewModel.h"
#include "State.h"
#include "Util.h"
#include "edb.h"

#include <QWidget>
#include <cstdint>

using std::uint32_t;

namespace {
static constexpr size_t GPR_COUNT = 16;
}

int capstoneRegToGPRIndex(int capstoneReg, bool &ok) {

	ok           = false;
	int regIndex = -1;
	// NOTE: capstone registers are stupidly not in continuous order
	switch (capstoneReg) {
	case ARM_REG_R0:
		regIndex = 0;
		break;
	case ARM_REG_R1:
		regIndex = 1;
		break;
	case ARM_REG_R2:
		regIndex = 2;
		break;
	case ARM_REG_R3:
		regIndex = 3;
		break;
	case ARM_REG_R4:
		regIndex = 4;
		break;
	case ARM_REG_R5:
		regIndex = 5;
		break;
	case ARM_REG_R6:
		regIndex = 6;
		break;
	case ARM_REG_R7:
		regIndex = 7;
		break;
	case ARM_REG_R8:
		regIndex = 8;
		break;
	case ARM_REG_R9:
		regIndex = 9;
		break;
	case ARM_REG_R10:
		regIndex = 10;
		break;
	case ARM_REG_R11:
		regIndex = 11;
		break;
	case ARM_REG_R12:
		regIndex = 12;
		break;
	case ARM_REG_R13:
		regIndex = 13;
		break;
	case ARM_REG_R14:
		regIndex = 14;
		break;
	case ARM_REG_R15:
		regIndex = 15;
		break;
	default:
		return -1;
	}
	ok = true;
	return regIndex;
}

Result<edb::address_t, QString> getOperandValueGPR(const edb::Instruction &insn, const edb::Operand &operand, const State &state) {

	bool ok;
	const auto regIndex = capstoneRegToGPRIndex(operand->reg, ok);
	if (!ok) {
		return make_unexpected(QObject::tr("bad operand register for instruction %1: %2.").arg(insn.mnemonic().c_str()).arg(operand->reg));
	}

	const auto reg = state.gpRegister(regIndex);
	if (!reg) {
		return make_unexpected(QObject::tr("failed to get register r%1.").arg(regIndex));
	}

	return reg.valueAsAddress();
}

Result<edb::address_t, QString> adjustR15Value(const edb::Instruction &insn, const int regIndex, edb::address_t value) {

	if (regIndex == 15) {
		// Even if current state's PC weren't on this instruction, the instruction still refers to
		// self, so use `insn` instead of `state` to get the value.
		const auto cpuMode = edb::v1::debugger_core->cpuMode();
		switch (cpuMode) {
		case IDebugger::CpuMode::ARM32:
			value = insn.rva() + 8;
			break;
		case IDebugger::CpuMode::Thumb:
			value = insn.rva() + 4;
			break;
		default:
			return make_unexpected(QObject::tr("calculating effective address in modes other than ARM and Thumb is not supported."));
		}
	}

	return value;
}

uint32_t shift(uint32_t x, arm_shifter type, uint32_t shiftAmount, bool carryFlag) {
	constexpr uint32_t HighBit = 1u << 31;
	const uint32_t N           = shiftAmount;

	switch (type) {
	case ARM_SFT_INVALID:
		return x;
	case ARM_SFT_ASR:
	case ARM_SFT_ASR_REG:
		assert(N >= 1 && N <= 32);
		// NOTE: unlike on x86, shift by 32 bits on ARM is not a NOP: it sets all bits to sign bit
		return N == 32 ? -((x & HighBit) >> 31) : x >> N | ~(((x & HighBit) >> N) - 1);
	case ARM_SFT_LSL:
	case ARM_SFT_LSL_REG:
		assert(N >= 0 && N <= 31);
		return x << N;
	case ARM_SFT_LSR:
	case ARM_SFT_LSR_REG:
		// NOTE: unlike on x86, shift by 32 bits on ARM is not a NOP: it clears the value
		return N == 32 ? 0 : x >> N;
	case ARM_SFT_ROR:
	case ARM_SFT_ROR_REG: {
		assert(N >= 1 && N <= 31);
		constexpr unsigned mask = 8 * sizeof x - 1;
		return x >> N | x << ((-N) & mask);
	}
	case ARM_SFT_RRX:
	case ARM_SFT_RRX_REG:
		return uint32_t(carryFlag) << 31 | x >> 1;
	}
	assert(!"Must not reach here!");
	return x;
}

// NOTE: this function shouldn't be used for operands other than those used as addresses.
// E.g. for "STM Rn,{regs...}" this function shouldn't try to get the value of any of the {regs...}.
// Also note that undefined instructions like "STM PC, {regs...}" aren't checked here.
Result<edb::address_t, QString> ArchProcessor::getEffectiveAddress(const edb::Instruction &insn, const edb::Operand &operand, const State &state) const {

	if (!operand || !insn) {
		return make_unexpected(QObject::tr("operand is invalid"));
	}

	const auto op = insn.operation();
	if (is_register(operand)) {
		bool ok;
		const auto regIndex = capstoneRegToGPRIndex(operand->reg, ok);
		if (!ok) return make_unexpected(QObject::tr("bad operand register for instruction %1: %2.").arg(insn.mnemonic().c_str()).arg(operand->reg));
		const auto reg = state.gpRegister(regIndex);
		if (!reg) return make_unexpected(QObject::tr("failed to get register r%1.").arg(regIndex));
		auto value = reg.valueAsAddress();
		return adjustR15Value(insn, regIndex, value);
	} else if (is_expression(operand)) {
		bool ok;
		Register baseR, indexR, cpsrR;

		const auto baseIndex = capstoneRegToGPRIndex(operand->mem.base, ok);
		// base must be valid
		if (!ok || !(baseR = state.gpRegister(baseIndex)))
			return make_unexpected(QObject::tr("failed to get register r%1.").arg(baseIndex));

		const auto indexIndex = capstoneRegToGPRIndex(operand->mem.index, ok);
		if (ok) // index register may be irrelevant, only try to get it if its index is valid
		{
			if (!(indexR = state.gpRegister(indexIndex)))
				return make_unexpected(QObject::tr("failed to get register r%1.").arg(indexIndex));
		}

		cpsrR = state.flagsRegister();
		if (!cpsrR && (operand->shift.type == ARM_SFT_RRX || operand->shift.type == ARM_SFT_RRX_REG))
			return make_unexpected(QObject::tr("failed to get CPSR."));
		const bool C = cpsrR ? cpsrR.valueAsInteger() & 0x20000000 : false;

		edb::address_t addr = baseR.valueAsAddress();
		// TODO(eteran): why does making this const cause an error on the return? Bug in conversion constructor for Result?
		if (auto adjustedRes = adjustR15Value(insn, baseIndex, addr)) {
			addr = adjustedRes.value() + operand->mem.disp;
			if (indexR) {
				addr += operand->mem.scale * shift(indexR.valueAsAddress(), operand->shift.type, operand->shift.value, C);
			}

			return addr;
		} else
			return adjustedRes;
	}

	return make_unexpected(QObject::tr("getting effective address for operand %1 of instruction %2 is not implemented").arg(operand.index() + 1).arg(insn.mnemonic().c_str()));
}

edb::address_t ArchProcessor::getEffectiveAddress(const edb::Instruction &inst, const edb::Operand &op, const State &state, bool &ok) const {

	ok                = false;
	const auto result = getEffectiveAddress(inst, op, state);
	if (!result) return 0;
	return result.value();
}

RegisterViewModel &getModel() {
	return static_cast<RegisterViewModel &>(edb::v1::arch_processor().registerViewModel());
}

ArchProcessor::ArchProcessor() {
	if (edb::v1::debugger_core) {
		connect(edb::v1::debugger_ui, SIGNAL(attachEvent()), this, SLOT(justAttached()));
	}
}

QStringList ArchProcessor::updateInstructionInfo(edb::address_t address) {
	Q_UNUSED(address)
	QStringList ret;
	return ret;
}

bool ArchProcessor::canStepOver(const edb::Instruction &inst) const {
	return inst && (is_call(inst) || is_interrupt(inst) || !modifies_pc(inst));
}

bool ArchProcessor::isFilling(const edb::Instruction &inst) const {
	Q_UNUSED(inst)
	return false;
}

void ArchProcessor::reset() {
}

void ArchProcessor::aboutToResume() {
	getModel().saveValues();
}

void ArchProcessor::setupRegisterView() {

	if (edb::v1::debugger_core) {
		updateRegisterView(QString(), State());
	}
}

QString pcComment(Register const &reg, QString const &default_region_name) {
	const auto symname = edb::v1::find_function_symbol(reg.valueAsAddress(), default_region_name);
	return symname.isEmpty() ? symname : '<' + symname + '>';
}

QString gprComment(Register const &reg) {

	QString regString;
	int stringLength;
	QString comment;
	if (edb::v1::get_ascii_string_at_address(reg.valueAsAddress(), regString, edb::v1::config().min_string_length, 256, stringLength))
		comment = QString("ASCII \"%1\"").arg(regString);
	else if (edb::v1::get_utf16_string_at_address(reg.valueAsAddress(), regString, edb::v1::config().min_string_length, 256, stringLength))
		comment = QString("UTF16 \"%1\"").arg(regString);
	return comment;
}

void updateGPRs(RegisterViewModel &model, State const &state, QString const &default_region_name) {
	for (std::size_t i = 0; i < GPR_COUNT; ++i) {
		const auto reg = state.gpRegister(i);
		Q_ASSERT(!!reg);
		Q_ASSERT(reg.bitSize() == 32);
		QString comment;
		if (i != 15)
			comment = gprComment(reg);
		else
			comment = pcComment(reg, default_region_name);
		model.updateGPR(i, reg.value<edb::value32>(), comment);
	}
}

bool is_jcc_taken(const edb::reg_t cpsr, edb::Instruction::ConditionCode cond) {
	const bool N = (cpsr & 0x80000000) != 0;
	const bool Z = (cpsr & 0x40000000) != 0;
	const bool C = (cpsr & 0x20000000) != 0;
	const bool V = (cpsr & 0x10000000) != 0;

	bool taken = false;
	switch (cond & 0xe) {
	case 0x0:
		taken = Z;
		break;
	case 0x2:
		taken = C;
		break;
	case 0x4:
		taken = N;
		break;
	case 0x6:
		taken = V;
		break;
	case 0x8:
		taken = C && !Z;
		break;
	case 0xa:
		taken = N == V;
		break;
	case 0xc:
		taken = !Z && (N == V);
		break;
	case 0xe:
		taken = true;
		break;
	}

	if (cond & 1)
		taken = !taken;

	return taken;
}

static const QLatin1String jumpConditionMnemonics[] = {
	QLatin1String("EQ"),
	QLatin1String("NE"),
	QLatin1String("HS"),
	QLatin1String("LO"),
	QLatin1String("MI"),
	QLatin1String("PL"),
	QLatin1String("VS"),
	QLatin1String("VC"),
	QLatin1String("HI"),
	QLatin1String("LS"),
	QLatin1String("GE"),
	QLatin1String("LT"),
	QLatin1String("GT"),
	QLatin1String("LE"),
	QLatin1String("AL"),
	QLatin1String("??"),
};

QString cpsrComment(edb::reg_t flags) {
	QString comment = "(";
	for (int cond = 0; cond < 0x10 - 2; ++cond) // we're not interested in AL or UNDEFINED conditions
		if (is_jcc_taken(flags, static_cast<edb::Instruction::ConditionCode>(cond)))
			comment += jumpConditionMnemonics[cond] + ',';
	comment[comment.size() - 1] = ')';
	return comment;
}

void updateCPSR(RegisterViewModel &model, State const &state) {
	const auto flags = state.flagsRegister();
	Q_ASSERT(!!flags);
	const auto comment = cpsrComment(flags.valueAsInteger());
	model.updateCPSR(flags.value<edb::value32>(), comment);
}

QString fpscrComment(edb::reg_t fpscr) {
	const auto nzcv = fpscr >> 28;
	switch (nzcv) {
	case 2:
		return "(GT)";
	case 3:
		return "(Unordered)";
	case 6:
		return "(EQ)";
	case 8:
		return "(LT)";
	default:
		return "";
	}
}

void updateVFP(RegisterViewModel &model, State const &state) {
	const auto fpscr = state["fpscr"];
	if (fpscr) {
		const auto comment = fpscrComment(fpscr.valueAsInteger());
		model.updateFPSCR(fpscr.value<edb::value32>(), comment);
	}
}

void ArchProcessor::updateRegisterView(const QString &default_region_name, const State &state) {

	auto &model = getModel();
	if (state.empty()) {
		model.setCpuMode(RegisterViewModel::CpuMode::UNKNOWN);
		return;
	}

	model.setCpuMode(RegisterViewModel::CpuMode::Defined);

	updateGPRs(model, state, default_region_name);
	updateCPSR(model, state);
	updateVFP(model, state);

	if (justAttached_) {
		model.saveValues();
		justAttached_ = false;
	}
	model.dataUpdateFinished();
}

RegisterViewModelBase::Model &ArchProcessor::registerViewModel() const {
	static RegisterViewModel model(0);
	return model;
}

void ArchProcessor::justAttached() {
	justAttached_ = true;
}

bool ArchProcessor::isExecuted(const edb::Instruction &inst, const State &state) const {
	return is_jcc_taken(state.flags(), inst.conditionCode());
}

```

`src/arch/arm-generic/RegisterViewModel.cpp`:

```cpp
/*
Copyright (C) 2017 - 2017 Evan Teran
                          evan.teran@gmail.com
Copyright (C) 2017 - 2017 Ruslan Kabatsayev
                          b7.10110111@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "RegisterViewModel.h"
#include <QDebug>
#include <typeinfo>

namespace {

using GPR   = RegisterViewModelBase::SimpleRegister<edb::value32>;
using CPSR  = RegisterViewModelBase::FlagsRegister<edb::value32>;
using FPSCR = RegisterViewModelBase::FlagsRegister<edb::value32>;

std::vector<RegisterViewModelBase::BitFieldDescriptionEx> cpsrDescription = {
	{QLatin1String("M"), 0, 5},
	{QLatin1String("T"), 5, 1},
	{QLatin1String("F"), 6, 1},
	{QLatin1String("I"), 7, 1},
	{QLatin1String("A"), 8, 1},
	{QLatin1String("E"), 9, 1},
	{QLatin1String("IT2"), 10, 1},
	{QLatin1String("IT3"), 11, 1},
	{QLatin1String("IT4"), 12, 1},
	{QLatin1String("ITbcond"), 13, 3},
	{QLatin1String("GE0"), 16, 1},
	{QLatin1String("GE1"), 17, 1},
	{QLatin1String("GE2"), 18, 1},
	{QLatin1String("GE3"), 19, 1},
	{QLatin1String("J"), 24, 1},
	{QLatin1String("IT0"), 25, 1},
	{QLatin1String("IT1"), 26, 1},
	{QLatin1String("Q"), 27, 1},
	{QLatin1String("V"), 28, 1},
	{QLatin1String("C"), 29, 1},
	{QLatin1String("Z"), 30, 1},
	{QLatin1String("N"), 31, 1},
};

static const std::vector<QString> roundingStrings = {
	QObject::tr("Rounding to nearest"),
	QObject::tr("Rounding to Plus infinity"),
	QObject::tr("Rounding to Minus infinity"),
	QObject::tr("Rounding toward zero"),
};

std::vector<RegisterViewModelBase::BitFieldDescriptionEx> fpscrDescription = {
	{QLatin1String("IOC"), 0, 1},
	{QLatin1String("DZC"), 1, 1},
	{QLatin1String("OFC"), 2, 1},
	{QLatin1String("UFC"), 3, 1},
	{QLatin1String("IXC"), 4, 1},
	{QLatin1String("IDC"), 7, 1},
	{QLatin1String("IOE"), 8, 1},
	{QLatin1String("DZE"), 9, 1},
	{QLatin1String("OFE"), 10, 1},
	{QLatin1String("UFE"), 11, 1},
	{QLatin1String("IXE"), 12, 1},
	{QLatin1String("IDE"), 15, 1},
	{QLatin1String("LEN-1"), 16, 3},
	{QLatin1String("STR"), 20, 2},
	{QLatin1String("RC"), 22, 2, roundingStrings},
	{QLatin1String("FZ"), 24, 1},
	{QLatin1String("DN"), 25, 1},
	{QLatin1String("V"), 28, 1},
	{QLatin1String("C"), 29, 1},
	{QLatin1String("Z"), 30, 1},
	{QLatin1String("N"), 31, 1},
};

enum {
	CPSR_ROW,
	FPSCR_ROW = 0,
};

}

QVariant RegisterViewModel::data(QModelIndex const &index, int role) const {
	if (role == FixedLengthRole) {
		using namespace RegisterViewModelBase;
		const auto reg  = static_cast<RegisterViewItem *>(index.internalPointer());
		const auto name = reg->data(NAME_COLUMN).toString();
		if (index.column() == NAME_COLUMN && name.length() >= 2) {
			const QString nameLower = name.toLower();
			if ((nameLower[0] == 'r' && '0' <= nameLower[1] && nameLower[1] <= '9') ||
				nameLower == "sp" || nameLower == "lr" || nameLower == "pc")
				return 3;
		}
	}
	return Model::data(index, role);
}

void addGPRs(RegisterViewModelBase::Category *gprs) {
	gprs->addRegister(std::make_unique<GPR>("R0"));
	gprs->addRegister(std::make_unique<GPR>("R1"));
	gprs->addRegister(std::make_unique<GPR>("R2"));
	gprs->addRegister(std::make_unique<GPR>("R3"));
	gprs->addRegister(std::make_unique<GPR>("R4"));
	gprs->addRegister(std::make_unique<GPR>("R5"));
	gprs->addRegister(std::make_unique<GPR>("R6"));
	gprs->addRegister(std::make_unique<GPR>("R7"));
	gprs->addRegister(std::make_unique<GPR>("R8"));
	gprs->addRegister(std::make_unique<GPR>("R9"));
	gprs->addRegister(std::make_unique<GPR>("R10"));
	gprs->addRegister(std::make_unique<GPR>("R11"));
	gprs->addRegister(std::make_unique<GPR>("R12"));
	gprs->addRegister(std::make_unique<GPR>("SP"));
	gprs->addRegister(std::make_unique<GPR>("LR"));
	gprs->addRegister(std::make_unique<GPR>("PC"));
}

void addGenStatusRegs(RegisterViewModelBase::Category *cat) {
	cat->addRegister(std::make_unique<CPSR>("CPSR", cpsrDescription));
}

void addVFPRegs(RegisterViewModelBase::Category *cat) {
	cat->addRegister(std::make_unique<FPSCR>("FPSCR", fpscrDescription));
	// TODO: add data registers: Sn, Dn, Qn...
}

RegisterViewModel::RegisterViewModel(int cpuSuppFlags, QObject *parent)
	: RegisterViewModelBase::Model(parent),
	  gprs(addCategory(tr("General Purpose"))),
	  genStatusRegs(addCategory(tr("General Status"))),
	  vfpRegs(addFPUCategory(tr("VFP"))) {

	addGPRs(gprs);
	addGenStatusRegs(genStatusRegs);
	addVFPRegs(vfpRegs);

	setCpuMode(CpuMode::UNKNOWN);
}

void invalidate(RegisterViewModelBase::Category *cat, int row, const char *nameToCheck) {
	if (!cat) return;
	Q_ASSERT(row < cat->childCount());
	const auto reg = cat->getRegister(row);
	Q_ASSERT(!nameToCheck || reg->name() == nameToCheck);
	Q_UNUSED(nameToCheck)
	reg->invalidate();
}

template <typename RegType, typename ValueType>
void updateRegister(RegisterViewModelBase::Category *cat, int row, ValueType value, QString const &comment, const char *nameToCheck = 0) {
	const auto reg = cat->getRegister(row);
	if (!dynamic_cast<RegType *>(reg)) {
		qWarning() << "Failed to update register " << reg->name() << ": failed to convert register passed to expected type " << typeid(RegType).name();
		invalidate(cat, row, nameToCheck);
		return;
	}
	Q_ASSERT(!nameToCheck || reg->name() == nameToCheck);
	Q_UNUSED(nameToCheck)
	static_cast<RegType *>(reg)->update(value, comment);
}

void RegisterViewModel::updateGPR(std::size_t i, edb::value32 val, QString const &comment) {
	Q_ASSERT(int(i) < gprs->childCount());
	updateRegister<GPR>(gprs, i, val, comment);
}

void RegisterViewModel::updateCPSR(edb::value32 val, QString const &comment) {
	updateRegister<CPSR>(genStatusRegs, CPSR_ROW, val, comment);
}

void RegisterViewModel::updateFPSCR(edb::value32 val, QString const &comment) {
	updateRegister<FPSCR>(vfpRegs, FPSCR_ROW, val, comment);
}

void RegisterViewModel::showAll() {
	gprs->show();
	genStatusRegs->show();
	vfpRegs->show();
}

void RegisterViewModel::setCpuMode(CpuMode newMode) {
	if (mode == newMode) return;

	beginResetModel();
	mode = newMode;
	switch (newMode) {
	case CpuMode::UNKNOWN:
		hideAll();
		break;
	case CpuMode::Defined:
		showAll();
		break;
	default:
		EDB_PRINT_AND_DIE("Invalid newMode value ", (long)newMode);
	}
	endResetModel();
}

```

`src/arch/arm-generic/RegisterViewModel.h`:

```h
/*
Copyright (C) 2017 - 2017 Evan Teran
                          evan.teran@gmail.com
Copyright (C) 2017 - 2017 Ruslan Kabatsayev
                          b7.10110111@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ARM_REGISTER_VIEW_MODEL_H_20170813_
#define ARM_REGISTER_VIEW_MODEL_H_20170813_

#include "RegisterViewModelBase.h"
#include "Types.h"

class RegisterViewModel : public RegisterViewModelBase::Model {
	Q_OBJECT

private:
	RegisterViewModelBase::Category *gprs;
	RegisterViewModelBase::Category *genStatusRegs;
	RegisterViewModelBase::Category *vfpRegs;

public:
	enum class CpuMode {
		UNKNOWN,
		Defined,
	};

public:
	explicit RegisterViewModel(int CPUFeaturesPresent, QObject *parent = nullptr);
	QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
	void setCpuMode(CpuMode mode);
	// NOTE: all these functions only change data, they don't emit dataChanged!
	// Use dataUpdateFinished() to have dataChanged emitted.
	void updateGPR(std::size_t i, edb::value32 val, const QString &comment = QString());
	void updateCPSR(edb::value32 val, const QString &comment = QString());
	void updateFPSCR(edb::value32 val, const QString &comment = QString());

private:
	void showAll();
	CpuMode mode = static_cast<CpuMode>(-1);
};

#endif

```

`src/arch/x86-generic/ArchProcessor.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ArchProcessor.h"
#include "Configuration.h"
#include "FloatX.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IThread.h"
#include "Instruction.h"
#include "Prototype.h"
#include "RegisterViewModel.h"
#include "State.h"
#include "Util.h"
#include "edb.h"
#include "string_hash.h"

#include <QApplication>
#include <QDebug>
#include <QDomDocument>
#include <QFile>
#include <QVector>
#include <QWidget>
#include <QXmlQuery>

#include <cctype>
#include <climits>
#include <cmath>
#include <cstring>
#include <memory>

#ifdef Q_OS_LINUX
#include "errno-names-linux.h"
#include <asm/unistd.h>
#endif

namespace ILP32 {

constexpr std::int32_t toInt(std::uint64_t x) {
	return x;
}
constexpr std::uint32_t toUInt(std::uint64_t x) {
	return x;
}
constexpr std::int32_t toLong(std::uint64_t x) {
	return x;
}
constexpr std::uint32_t toULong(std::uint64_t x) {
	return x;
}

}

namespace LP64 {

constexpr std::int32_t toInt(std::uint64_t x) {
	return x;
}
constexpr std::uint32_t toUInt(std::uint64_t x) {
	return x;
}
constexpr std::int64_t toLong(std::uint64_t x) {
	return x;
}
constexpr std::uint64_t toULong(std::uint64_t x) {
	return x;
}

}

namespace {

using std::size_t;

enum RegisterIndex {
	rAX = 0,
	rCX = 1,
	rDX = 2,
	rBX = 3,
	rSP = 4,
	rBP = 5,
	rSI = 6,
	rDI = 7,
	R8  = 8,
	R9  = 9,
	R10 = 10,
	R11 = 11,
	R12 = 12,
	R13 = 13,
	R14 = 14,
	R15 = 15,
};

enum SegmentRegisterIndex {
	ES,
	CS,
	SS,
	DS,
	FS,
	GS,
};

constexpr size_t MAX_DEBUG_REGS_COUNT = 8;
constexpr size_t GPR32_COUNT          = 8;
constexpr size_t GPR64_COUNT          = 16;
constexpr size_t SSE32_COUNT          = GPR32_COUNT;
constexpr size_t SSE64_COUNT          = GPR64_COUNT;
constexpr size_t AVX32_COUNT          = SSE32_COUNT;
constexpr size_t AVX64_COUNT          = SSE64_COUNT;
constexpr size_t MAX_FPU_REGS_COUNT   = 8;
constexpr size_t MAX_MMX_REGS_COUNT   = MAX_FPU_REGS_COUNT;

using edb::v1::debuggeeIs32Bit;
using edb::v1::debuggeeIs64Bit;

int func_param_regs_count() {
	return debuggeeIs32Bit() ? 0 : 6;
}

using MMWord  = edb::value64;
using XMMWord = edb::value128;
using YMMWord = edb::value256;
using ZMMWord = edb::value512;

template <typename T>
std::string register_name(const T &val) {
	return edb::v1::formatter().registerName(val);
}

template <typename T>
QString syscallErrName(T err) {
#ifdef Q_OS_LINUX
	std::size_t index = -err;

	if (index >= errnoNames.size()) {
		return "";
	}

	if (errnoNames[index]) {
		return errnoNames[index];
	}
#else
	Q_UNUSED(err)
#endif
	return "";
}

//------------------------------------------------------------------------------
// Name: format_pointer
// Desc:
//------------------------------------------------------------------------------
QString format_pointer(int pointer_level, edb::reg_t arg, QChar type) {

	Q_UNUSED(type)
	Q_UNUSED(pointer_level)

	if (arg == 0) {
		return "NULL";
	} else {
		return edb::v1::format_pointer(arg);
	}
}

//------------------------------------------------------------------------------
// Name: format_integer
// Desc:
//------------------------------------------------------------------------------
QString format_integer(int pointer_level, edb::reg_t arg, QChar type) {
	if (pointer_level > 0) {
		return format_pointer(pointer_level, arg, type);
	}

	switch (type.toLatin1()) {
	case 'w':
		return "0x" + QString::number(static_cast<wchar_t>(arg), 16);
	case 'b':
		return arg ? "true" : "false";
	case 'c':
		if (arg < 0x80u && (std::isprint(arg) || std::isspace(arg))) {
			return QString("'%1'").arg(static_cast<char>(arg));
		} else {
			return QString("'\\x%1'").arg(static_cast<uint16_t>(arg), 2, 16);
		}
	case 'a':
		// signed char; since we're formatting as hex, we want to avoid sign
		// extension done inside QString::number (happening due to the cast to
		// qlonglong inside QString::setNum, which used in QString::number).
		// Similarly for other shorter-than-long-long signed types.
	case 'h':
		return "0x" + QString::number(static_cast<unsigned char>(arg), 16);
	case 's':
	case 't':
		return "0x" + QString::number(static_cast<unsigned short>(arg), 16);
	case 'i':
	case 'j':
		return "0x" + QString::number(debuggeeIs32Bit() ? ILP32::toUInt(arg) : LP64::toUInt(arg), 16);
	case 'l':
	case 'm':
		return "0x" + QString::number(debuggeeIs32Bit() ? ILP32::toULong(arg) : LP64::toULong(arg), 16);
	case 'x':
		return "0x" + QString::number(static_cast<long long>(arg), 16);
	case 'y':
		return "0x" + QString::number(static_cast<long unsigned long>(arg), 16);
	case 'n':
	case 'o':
	default:
		return format_pointer(pointer_level, arg, type);
	}
}

//------------------------------------------------------------------------------
// Name: format_integer
// Desc:
//------------------------------------------------------------------------------
QString format_char(int pointer_level, edb::address_t arg, QChar type) {

	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (pointer_level == 1) {
			if (arg == 0) {
				return "NULL";
			} else {
				QString string_param;
				int string_length;

				if (edb::v1::get_ascii_string_at_address(arg, string_param, edb::v1::config().min_string_length, 256, string_length)) {
					return QString("<%1> \"%2\"").arg(edb::v1::format_pointer(arg), string_param);
				} else {
					char character;
					process->readBytes(arg, &character, sizeof(character));
					if (character == '\0') {
						return QString("<%1> \"\"").arg(edb::v1::format_pointer(arg));
					} else {
						return QString("<%1>").arg(edb::v1::format_pointer(arg));
					}
				}
			}
		} else {
			return format_integer(pointer_level, arg, type);
		}
	}

	return "?";
}

//------------------------------------------------------------------------------
// Name: format_argument
// Desc:
//------------------------------------------------------------------------------
QString format_argument(const QString &type, const Register &arg) {

	if (!arg) return QObject::tr("(failed to get value)");
	int pointer_level = 0;
	for (QChar ch : type) {

		if (ch == 'P') {
			++pointer_level;
		} else if (ch == 'r' || ch == 'V' || ch == 'K') {
			// skip things like const, volatile, restrict, they don't effect
			// display for us
			continue;
		} else {
			switch (ch.toLatin1()) {
			case 'v':
				return format_pointer(pointer_level, arg.valueAsAddress(), ch);
			case 'w':
				return format_integer(pointer_level, arg.valueAsInteger(), ch);
			case 'b':
				return format_integer(pointer_level, arg.valueAsSignedInteger(), ch);
			case 'c':
				return format_char(pointer_level, arg.valueAsAddress(), ch);
			case 'a':
				return format_integer(pointer_level, arg.valueAsSignedInteger(), ch);
			case 'h':
				return format_integer(pointer_level, arg.valueAsInteger(), ch);
			case 's':
				return format_integer(pointer_level, arg.valueAsSignedInteger(), ch);
			case 't':
				return format_integer(pointer_level, arg.valueAsInteger(), ch);
			case 'i':
				return format_integer(pointer_level, arg.valueAsSignedInteger(), ch);
			case 'j':
				return format_integer(pointer_level, arg.valueAsInteger(), ch);
			case 'l':
				return format_integer(pointer_level, arg.valueAsSignedInteger(), ch);
			case 'm':
				return format_integer(pointer_level, arg.valueAsInteger(), ch);
			case 'x':
				return format_integer(pointer_level, arg.valueAsSignedInteger(), ch);
			case 'y':
				return format_integer(pointer_level, arg.valueAsInteger(), ch);
			case 'n':
				return format_integer(pointer_level, arg.valueAsSignedInteger(), ch);
			case 'o':
				return format_integer(pointer_level, arg.valueAsSignedInteger(), ch);
			case 'f':
			case 'd':
			case 'e':
			case 'g':
			case 'z':
			default:
				break;
			}
		}
	}

	return format_pointer(pointer_level, arg.valueAsAddress(), 'x');
}

template <class T>
void resolve_function_parameters_helper(T parameter_registers, const State &state, const QString &symname, int offset, QStringList &ret) {
	static const QString prefix(QLatin1String("!"));

	if (IProcess *process = edb::v1::debugger_core->process()) {
		// we will always be removing the last 2 chars '+0' from the string as well
		// as chopping the region prefix we like to prepend to symbols
		QString func_name;
		const int colon_index = symname.indexOf(prefix);

		if (colon_index != -1) {
			func_name = symname.left(symname.length() - 2).mid(colon_index + prefix.size());
		}

		// safe not to check for -1, it means 'rest of string' for the mid function
		func_name = func_name.mid(0, func_name.indexOf("@"));

		if (const edb::Prototype *const info = edb::v1::get_function_info(func_name)) {

			QStringList arguments;
			int i = 0;
			for (const edb::Argument &argument : info->arguments) {

				Register arg;
				if (i + 1 > func_param_regs_count()) {
					size_t arg_i_position = (i - func_param_regs_count()) * edb::v1::pointer_size();
					edb::reg_t value(0);
					process->readBytes(state.stackPointer() + offset + arg_i_position, &value, edb::v1::pointer_size());
					arg = edb::v1::debuggeeIs64Bit() ? make_Register<64>("", value, Register::TYPE_GPR) : make_Register<32>("", value, Register::TYPE_GPR);
				} else {
					arg = state[parameter_registers[i]];
				}

				arguments << format_argument(argument.type, arg);
				++i;
			}

			ret << QString("%1(%2)").arg(func_name, arguments.join(", "));
		}
	}
}

//------------------------------------------------------------------------------
// Name: resolve_function_parameters
// Desc:
//------------------------------------------------------------------------------
void resolve_function_parameters(const State &state, const QString &symname, int offset, QStringList &ret) {

	/*
	 * The calling convention of the AMD64 application binary interface is
	 * followed on Linux and other non-Microsoft operating systems.
	 * The registers RDI, RSI, RDX, RCX, R8 and R9 are used for integer and
	 * pointer arguments while XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6 and
	 * XMM7 are used for floating point arguments. As in the Microsoft x64
	 * calling convention, additional arguments are pushed onto the stack and
	 * the return value is stored in RAX.
	 */
	static const std::array<const char *, 6> parameter_registers_x64 = {
		"rdi",
		"rsi",
		"rdx",
		"rcx",
		"r8",
		"r9"};

	static const std::array<const char *, 0> parameter_registers_x86 = {};

	if (debuggeeIs64Bit()) {
		resolve_function_parameters_helper(parameter_registers_x64, state, symname, offset, ret);
	} else {
		resolve_function_parameters_helper(parameter_registers_x86, state, symname, offset, ret);
	}
}

//------------------------------------------------------------------------------
// Name: is_jcc_taken
// Desc:
//------------------------------------------------------------------------------
bool is_jcc_taken(const edb::reg_t efl, edb::Instruction::ConditionCode cond) {

	const bool cf = (efl & 0x0001) != 0;
	const bool pf = (efl & 0x0004) != 0;
	const bool zf = (efl & 0x0040) != 0;
	const bool sf = (efl & 0x0080) != 0;
	const bool of = (efl & 0x0800) != 0;

	bool taken = false;

	switch (cond & 0x0e) {
	case 0x00:
		taken = of;
		break;
	case 0x02:
		taken = cf;
		break;
	case 0x04:
		taken = zf;
		break;
	case 0x06:
		taken = cf || zf;
		break;
	case 0x08:
		taken = sf;
		break;
	case 0x0a:
		taken = pf;
		break;
	case 0x0c:
		taken = sf != of;
		break;
	case 0x0e:
		taken = zf || sf != of;
		break;
	}

	if (cond & 0x01) {
		taken = !taken;
	}

	return taken;
}

//------------------------------------------------------------------------------
// Name: is_jcc_taken
// Desc:
//------------------------------------------------------------------------------
bool is_jcc_taken(const State &state, edb::Instruction::ConditionCode cond) {

	if (cond == edb::Instruction::CC_UNCONDITIONAL) return true;
	if (cond == edb::Instruction::CC_RCXZ) return state.gpRegister(rCX).value<edb::value64>() == 0;
	if (cond == edb::Instruction::CC_ECXZ) return state.gpRegister(rCX).value<edb::value32>() == 0;
	if (cond == edb::Instruction::CC_CXZ) return state.gpRegister(rCX).value<edb::value16>() == 0;

	return is_jcc_taken(state.flags(), cond);
}

static const QLatin1String jumpConditionMnemonics[] = {
	QLatin1String("O"), QLatin1String("NO"),
	QLatin1String("B"), QLatin1String("AE"),
	QLatin1String("E"), QLatin1String("NE"),
	QLatin1String("BE"), QLatin1String("A"),
	QLatin1String("S"), QLatin1String("NS"),
	QLatin1String("P"), QLatin1String("NP"),
	QLatin1String("L"), QLatin1String("GE"),
	QLatin1String("LE"), QLatin1String("G")};

//------------------------------------------------------------------------------
// Name: analyze_cmov
// Desc:
//------------------------------------------------------------------------------
void analyze_cmov(const State &state, const edb::Instruction &inst, QStringList &ret) {

	const bool taken = is_jcc_taken(state, inst.conditionCode());

	if (taken) {
		ret << ArchProcessor::tr("move performed");
	} else {
		ret << ArchProcessor::tr("move NOT performed");
	}
}

//------------------------------------------------------------------------------
// Name: analyze_jump
// Desc:
//------------------------------------------------------------------------------
void analyze_jump(const State &state, const edb::Instruction &inst, QStringList &ret) {

	bool taken = false;

	if (is_conditional_jump(inst)) {
		taken = is_jcc_taken(state, inst.conditionCode());
	}

	if (taken) {
		ret << ArchProcessor::tr("jump taken");
	} else {
		ret << ArchProcessor::tr("jump NOT taken");
	}
}

//------------------------------------------------------------------------------
// Name: analyze_return
// Desc:
//------------------------------------------------------------------------------
void analyze_return(const State &state, const edb::Instruction &inst, QStringList &ret) {

	Q_UNUSED(inst)

	if (IProcess *process = edb::v1::debugger_core->process()) {
		edb::address_t return_address(0);
		process->readBytes(state.stackPointer(), &return_address, edb::v1::pointer_size());

		const QString symname = edb::v1::find_function_symbol(return_address);
		if (!symname.isEmpty()) {
			ret << ArchProcessor::tr("return to %1 <%2>").arg(edb::v1::format_pointer(return_address), symname);
		} else {
			ret << ArchProcessor::tr("return to %1").arg(edb::v1::format_pointer(return_address));
		}
	}
}

//------------------------------------------------------------------------------
// Name: analyze_call
// Desc:
//------------------------------------------------------------------------------
void analyze_call(const State &state, const edb::Instruction &inst, QStringList &ret) {

	if (IProcess *process = edb::v1::debugger_core->process()) {

		if (const auto operand = inst[0]) {

			bool ok;
			const edb::address_t effective_address = edb::v1::arch_processor().getEffectiveAddress(inst, operand, state, ok);
			if (!ok) return;
			const auto temp_operand = QString::fromStdString(edb::v1::formatter().toString(operand));

			if (is_immediate(operand)) {
				int offset;
				const QString symname = edb::v1::find_function_symbol(effective_address, QString(), &offset);

				if (!symname.isEmpty()) {
					ret << QString("%1 = %2 <%3>").arg(temp_operand, edb::v1::format_pointer(effective_address), symname);

					if (offset == 0) {
						if (is_call(inst)) {
							resolve_function_parameters(state, symname, 0, ret);
						} else {
							resolve_function_parameters(state, symname, 4, ret);
						}
					}

				} else {
#if 0
					ret << QString("%1 = %2").arg(temp_operand, edb::v1::format_pointer(effective_address));
#endif
				}
			} else if (is_register(operand)) {
				int offset;
				const QString symname = edb::v1::find_function_symbol(effective_address, QString(), &offset);
				if (!symname.isEmpty()) {
					ret << QString("%1 = %2 <%3>").arg(temp_operand, edb::v1::format_pointer(effective_address), symname);

					if (offset == 0) {
						if (is_call(inst)) {
							resolve_function_parameters(state, symname, 0, ret);
						} else {
							resolve_function_parameters(state, symname, 4, ret);
						}
					}

				} else {
					ret << QString("%1 = %2").arg(temp_operand, edb::v1::format_pointer(effective_address));
				}
			} else if (is_expression(operand)) {
				edb::address_t target(0);

				if (process->readBytes(effective_address, &target, edb::v1::pointer_size())) {
					int offset;
					const QString symname = edb::v1::find_function_symbol(target, QString(), &offset);
					if (!symname.isEmpty()) {
						ret << QString("%1 = [%2] = %3 <%4>").arg(temp_operand, edb::v1::format_pointer(effective_address), edb::v1::format_pointer(target), symname);

						if (offset == 0) {
							if (is_call(inst)) {
								resolve_function_parameters(state, symname, 0, ret);
							} else {
								resolve_function_parameters(state, symname, 4, ret);
							}
						}

					} else {
						ret << QString("%1 = [%2] = %3").arg(temp_operand, edb::v1::format_pointer(effective_address), edb::v1::format_pointer(target));
					}
				} else {
					// could not read from the address
					ret << QString("%1 = [%2] = ?").arg(temp_operand, edb::v1::format_pointer(effective_address));
				}
			}
		}
	}
}

bool isFPU_BCD(const edb::Instruction &inst) {

	const auto op = inst.operation();
	return op == X86_INS_FBLD ||
		   op == X86_INS_FBSTP;
}

QString formatBCD(const edb::value80 &v) {

	auto hex = v.toHexString();
	// Low bytes which contain 18 digits must be decimal. If not, return the raw hex value.
	if (hex.mid(2).contains(QRegExp("[A-Fa-f]")))
		return "0x" + hex;
	hex.replace(QRegExp("^..0*"), "");
	return (v.negative() ? '-' + hex : hex) + " (BCD)";
}

template <typename ValueType>
QString formatPackedFloat(const char *data, std::size_t size) {

	QString str;
	for (std::size_t offset = 0; offset < size; offset += sizeof(ValueType)) {

		ValueType value;
		std::memcpy(&value, data + offset, sizeof(value));
		if (!str.isEmpty()) str += ", ";
		str += format_float(value);
	}
	return size == sizeof(ValueType) ? str : '{' + str + '}';
}

//------------------------------------------------------------------------------
// Name: analyze_operands
// Desc:
//------------------------------------------------------------------------------
void analyze_operands(const State &state, const edb::Instruction &inst, QStringList &ret) {

	Q_UNUSED(inst)

	if (IProcess *process = edb::v1::debugger_core->process()) {

		for (std::size_t j = 0; j < inst.operandCount(); ++j) {

			const auto operand = inst[j];

			if (operand) {

				QString temp_operand = QString::fromStdString(edb::v1::formatter().toString(operand));

				if (is_immediate(operand)) {
#if 0
					bool ok;
					const edb::address_t effective_address = edb::v1::arch_processor().getEffectiveAddress(inst, operand, state, ok);
					if (!ok) return;
					ret << QString("%1 = %2").arg(temp_operand).arg(edb::v1::format_pointer(effective_address));
#endif
				} else if (is_register(operand)) {
					Register reg = state[QString::fromStdString(edb::v1::formatter().toString(operand))];
					QString valueString;
					if (!reg)
						valueString = ArchProcessor::tr("(Error: obtained invalid register value from State)");
					else {
						if (reg.type() == Register::TYPE_FPU && reg.bitSize() == 80)
							valueString = format_float(reg.value<edb::value80>());
						else if (is_SIMD_SS(operand)) {
							valueString = format_float(reg.value<edb::value32>());
							temp_operand += "_ss";
						} else if (is_SIMD_SD(operand)) {
							valueString = format_float(reg.value<edb::value64>());
							temp_operand += "_sd";
						} else if (is_SIMD_PS(operand))
							valueString = formatPackedFloat<edb::value32>(reg.rawData(), reg.bitSize() / 8);
						else if (is_SIMD_PD(operand))
							valueString = formatPackedFloat<edb::value64>(reg.rawData(), reg.bitSize() / 8);
						else {
							const bool simdSI  = is_SIMD_SI(operand);
							const bool simdUSI = !simdSI && is_SIMD_USI(operand);
							if ((simdSI || simdUSI) && (reg.bitSize() == 32 || reg.bitSize() == 64)) {
								const auto mode = simdUSI ? NumberDisplayMode::Unsigned : NumberDisplayMode::Signed;
								std::int64_t signedValue;
								if (reg.bitSize() == 32) {
									signedValue = reg.value<edb::value32>();
									valueString = util::format_int(reg.value<edb::value32>(), mode);
								} else {
									signedValue = reg.value<edb::value64>();
									valueString = util::format_int(reg.value<edb::value64>(), mode);
								}
								// FIXME: we have to explicitly say it's decimal because EDB is pretty inconsistent
								// even across values in analysis view about its use of 0x prefix
								// Use of hexadecimal format here is pretty much pointless since the number here is
								// expected to be used in usual numeric computations, not as address or similar
								if (signedValue > 9 || signedValue < -9)
									valueString += " (decimal)";
							} else
								valueString = "0x" + reg.toHexString();
						}
					}
					ret << QString("%1 = %2").arg(temp_operand, valueString);
				} else if (is_expression(operand)) {
					bool ok;
					const edb::address_t effective_address = edb::v1::arch_processor().getEffectiveAddress(inst, operand, state, ok);
					if (!ok) continue;
					edb::value256 target;

					if (process->readBytes(effective_address, &target, sizeof(target))) {

						switch (operand->size) {
						case 1:
							ret << QString("%1 = [%2] = 0x%3").arg(temp_operand, edb::v1::format_pointer(effective_address), edb::value8(target).toHexString());
							break;
						case 2: {
							const edb::value16 value(target);
							QString valueStr;
							if (is_fpu_taking_integer(inst)) {
								valueStr = util::format_int(value, NumberDisplayMode::Signed);
								// FIXME: we have to explicitly say it's decimal because EDB is pretty inconsistent
								// even across values in analysis view about its use of 0x prefix
								// Use of hexadecimal format here is pretty much pointless since the number here is
								// expected to be used in usual numeric computations, not as address or similar
								const std::int16_t signedValue = value;
								if (signedValue > 9 || signedValue < -9)
									valueStr += " (decimal)";
							} else
								valueStr = "0x" + value.toHexString();
							ret << QString("%1 = [%2] = %3").arg(temp_operand, edb::v1::format_pointer(effective_address), valueStr);
							break;
						}
						case 4: {
							const edb::value32 value(target);
							const bool simdSI  = is_SIMD_SI(operand);
							const bool simdUSI = !simdSI && is_SIMD_USI(operand);
							QString valueStr;
							if (is_fpu_taking_float(inst) || is_SIMD_SS(operand))
								valueStr = format_float(value);
							else if (is_fpu_taking_integer(inst) || simdSI || simdUSI) {
								valueStr = util::format_int(value, simdUSI ? NumberDisplayMode::Unsigned : NumberDisplayMode::Signed);
								// FIXME: we have to explicitly say it's decimal because EDB is pretty inconsistent
								// even across values in analysis view about its use of 0x prefix
								// Use of hexadecimal format here is pretty much pointless since the number here is
								// expected to be used in usual numeric computations, not as address or similar
								const std::int32_t signedValue = value;
								if (signedValue > 9 || signedValue < -9)
									valueStr += " (decimal)";
							} else if (is_SIMD_PS(operand))
								valueStr = formatPackedFloat<edb::value32>(reinterpret_cast<const char *>(&target), sizeof(edb::value64));
							else if (is_SIMD_PD(operand))
								valueStr = formatPackedFloat<edb::value64>(reinterpret_cast<const char *>(&target), sizeof(edb::value64));
							else
								valueStr = "0x" + value.toHexString();
							ret << QString("%1 = [%2] = %3").arg(temp_operand, edb::v1::format_pointer(effective_address), valueStr);
							break;
						}
						case 8: {
							const edb::value64 value(target);
							const bool simdSI  = is_SIMD_SI(operand);
							const bool simdUSI = !simdSI && is_SIMD_USI(operand);
							QString valueStr;
							if (is_fpu_taking_float(inst) || is_SIMD_SD(operand))
								valueStr = format_float(value);
							else if (is_fpu_taking_integer(inst) || simdSI || simdUSI) {
								valueStr = util::format_int(value, simdUSI ? NumberDisplayMode::Unsigned : NumberDisplayMode::Signed);
								// FIXME: we have to explicitly say it's decimal because EDB is pretty inconsistent
								// even across values in analysis view about its use of 0x prefix
								// Use of hexadecimal format here is pretty much pointless since the number here is
								// expected to be used in usual numeric computations, not as address or similar
								const std::int64_t signedValue = value;
								if (signedValue > 9 || signedValue < -9)
									valueStr += " (decimal)";
							} else
								valueStr = "0x" + value.toHexString();
							ret << QString("%1 = [%2] = %3").arg(temp_operand, edb::v1::format_pointer(effective_address), valueStr);
							break;
						}
						case 10: {
							const edb::value80 value(target);
							const QString valueStr = is_fpu(inst) ? isFPU_BCD(inst) ? formatBCD(value) : format_float(value) : "0x" + value.toHexString();
							ret << QString("%1 = [%2] = %3").arg(temp_operand, edb::v1::format_pointer(effective_address), valueStr);
							break;
						}
						case 16: {
							QString valueString;
							if (is_SIMD_PS(operand))
								valueString = formatPackedFloat<edb::value32>(reinterpret_cast<const char *>(&target), sizeof(edb::value128));
							else if (is_SIMD_PD(operand))
								valueString = formatPackedFloat<edb::value64>(reinterpret_cast<const char *>(&target), sizeof(edb::value128));
							else
								valueString = "0x" + edb::value128(target).toHexString();
							ret << QString("%1 = [%2] = %3").arg(temp_operand, edb::v1::format_pointer(effective_address), valueString);
							break;
						}
						case 32: {
							QString valueString;
							if (is_SIMD_PS(operand))
								valueString = formatPackedFloat<edb::value32>(reinterpret_cast<const char *>(&target), sizeof(edb::value256));
							else if (is_SIMD_PD(operand))
								valueString = formatPackedFloat<edb::value64>(reinterpret_cast<const char *>(&target), sizeof(edb::value256));
							else
								valueString = "0x" + edb::value256(target).toHexString();
							ret << QString("%1 = [%2] = %3").arg(temp_operand, edb::v1::format_pointer(effective_address), valueString);
							break;
						}
						default:
							ret << QString("%1 = [%2] = 0x%3").arg(temp_operand, edb::v1::format_pointer(effective_address), QString("<Error: unexpected size; low bytes form %2>").arg(target.toHexString()));
							break;
						}
					} else {
						ret << QString("%1 = [%2] = ?").arg(temp_operand, edb::v1::format_pointer(effective_address));
					}
				}
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: analyze_jump_targets
// Desc:
//------------------------------------------------------------------------------
void analyze_jump_targets(const edb::Instruction &inst, QStringList &ret) {
	const edb::address_t address       = inst.rva();
	const edb::address_t start_address = address - 128;
	const edb::address_t end_address   = address + 127;

	uint8_t buffer[edb::Instruction::MaxSize];

	for (edb::address_t addr = start_address; addr < end_address; ++addr) {
		if (const int sz = edb::v1::get_instruction_bytes(addr, buffer)) {
			edb::Instruction inst(buffer, buffer + sz, addr);
			if (is_jump(inst)) {
				const auto operand = inst[0];

				if (is_immediate(operand)) {
					const edb::address_t target = operand->imm;

					if (target == address) {
						ret << ArchProcessor::tr("possible jump from %1").arg(edb::v1::format_pointer(addr));
					}
				}
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: analyze_syscall
// Desc:
//------------------------------------------------------------------------------
void analyze_syscall(const State &state, const edb::Instruction &inst, QStringList &ret, std::uint64_t regAX) {
	Q_UNUSED(inst)
	Q_UNUSED(ret)
	Q_UNUSED(state)

#ifdef Q_OS_LINUX
	const bool isX32 = regAX & __X32_SYSCALL_BIT;
	regAX &= ~__X32_SYSCALL_BIT;

	QString syscall_entry;
	QDomDocument syscall_xml;
	QFile file(":/debugger/xml/syscalls.xml");
	if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {

		QXmlQuery query;
		query.setFocus(&file);
		const QString arch = debuggeeIs64Bit() ? "x86-64" : "x86";
		query.setQuery(QString("syscalls[@version='1.0']/linux[@arch='" + arch + "']/syscall[index=%1]").arg(regAX));
		if (query.isValid()) {
			query.evaluateTo(&syscall_entry);
		}
		file.close();
	}

	if (!syscall_entry.isEmpty()) {
		syscall_xml.setContent("" + syscall_entry + "");
		QDomElement root = syscall_xml.documentElement();

		QStringList arguments;

		for (QDomElement argument = root.firstChildElement("argument"); !argument.isNull(); argument = argument.nextSiblingElement("argument")) {
			const QString argument_type     = argument.attribute("type");
			const QString argument_register = argument.attribute("register");
			if (argument_register == "ebp" && inst.operation() == X86_INS_SYSENTER) {
				if (IProcess *process = edb::v1::debugger_core->process()) {
					char buf[4];
					if (process->readBytes(state.stackPointer(), buf, sizeof(buf)) != sizeof(buf)) {
						arguments << QObject::tr("(failed to read [esp])");
						continue;
					}
					std::uint32_t value;
					std::memcpy(&value, buf, sizeof(value));
					arguments << format_argument(argument_type, make_Register<32>("[esp]", value, Register::TYPE_GPR));
					continue;
				}
			}
			const auto reg = state[argument_register];
			if (reg) {
				arguments << format_argument(argument_type, reg);
				continue;
			} else {
				// If we failed, this may be a pair of reg32a:reg32b
				const auto regs = argument_register.split(':');
				if (regs.size() != 2 || regs[0].isEmpty() || regs[0][0] != 'e' || regs[1].isEmpty() || regs[1][0] != 'e') {
					arguments << QObject::tr("(failed to obtain %1)").arg(argument_register);
					continue;
				}
				const auto regHi = state[regs[0]], regLo = state[regs[1]];
				if (!regHi || !regLo || regHi.bitSize() != 32 || regLo.bitSize() != 32) {
					arguments << QObject::tr("(failed to obtain %1)").arg(argument_register);
					continue;
				}
				const auto value = regHi.valueAsInteger() << 32 | regLo.valueAsInteger();
				arguments << format_argument(argument_type, make_Register<64>(argument_register, value, Register::TYPE_GPR));
			}
		}

		ret << ArchProcessor::tr("SYSCALL: %1%2(%3)").arg(isX32 ? "x32:" : "", root.attribute("name"), arguments.join(","));
	}
#else
	Q_UNUSED(regAX)
#endif
}

QString gprComment(const Register &reg) {
	QString regString;
	int stringLength;
	QString comment;
	if (edb::v1::get_ascii_string_at_address(reg.valueAsAddress(), regString, edb::v1::config().min_string_length, 256, stringLength))
		comment = QString("ASCII \"%1\"").arg(regString);
	else if (edb::v1::get_utf16_string_at_address(reg.valueAsAddress(), regString, edb::v1::config().min_string_length, 256, stringLength))
		comment = QString("UTF16 \"%1\"").arg(regString);
	return comment;
}

RegisterViewModel &getModel() {
	return static_cast<RegisterViewModel &>(edb::v1::arch_processor().registerViewModel());
}

void updateGPRs(RegisterViewModel &model, const State &state, bool is64Bit) {
	if (is64Bit) {
		for (std::size_t i = 0; i < GPR64_COUNT; ++i) {
			const auto reg = state.gpRegister(i);
			if (!reg) {
				continue;
			}

			Q_ASSERT(reg.bitSize() == 64);
			QString comment;
			if (i == 0) {
				const auto origAX = state["orig_rax"].valueAsSignedInteger();
				if (origAX != -1) {
					comment            = "orig: " + edb::value64(origAX).toHexString();
					const auto errName = syscallErrName(reg.value<edb::value64>());
					if (!errName.isEmpty())
						comment = "-" + errName + "; " + comment;
				}
			}
			if (comment.isEmpty())
				comment = gprComment(reg);
			model.updateGPR(i, reg.value<edb::value64>(), comment);
		}
	} else {
		for (std::size_t i = 0; i < GPR32_COUNT; ++i) {
			const auto reg = state.gpRegister(i);
			if (!reg) {
				continue;
			}
			Q_ASSERT(reg.bitSize() == 32);
			QString comment;
			if (i == 0) {
				const auto origAX = state["orig_eax"].valueAsSignedInteger();
				if (origAX != -1) {
					comment            = "orig: " + edb::value32(origAX).toHexString();
					const auto errName = syscallErrName(reg.value<edb::value32>());
					if (!errName.isEmpty())
						comment = "-" + errName + "; " + comment;
				}
			}
			if (comment.isEmpty())
				comment = gprComment(reg);
			model.updateGPR(i, reg.value<edb::value32>(), comment);
		}
	}
}

QString rIPcomment(edb::address_t rIP, const QString &default_region_name) {
	const auto symname = edb::v1::find_function_symbol(rIP, default_region_name);
	return symname.isEmpty() ? symname : '<' + symname + '>';
}

QString eflagsComment(edb::reg_t flags) {
	QString comment = "(";
	for (int cond = 0; cond < 0x10; ++cond)
		if (is_jcc_taken(flags, static_cast<edb::Instruction::ConditionCode>(cond)))
			comment += jumpConditionMnemonics[cond] + ',';
	comment[comment.size() - 1] = ')';
	return comment;
}

void updateGeneralStatusRegs(RegisterViewModel &model, const State &state, bool is64Bit, const QString &default_region_name) {
	const auto ip    = state.instructionPointerRegister();
	const auto flags = state.flagsRegister();
	Q_ASSERT(!!ip);
	Q_ASSERT(!!flags);
	const auto ipComment    = rIPcomment(ip.valueAsAddress(), default_region_name);
	const auto flagsComment = eflagsComment(flags.valueAsInteger());
	if (is64Bit) {
		model.updateIP(ip.value<edb::value64>(), ipComment);
		model.updateFlags(flags.value<edb::value64>(), flagsComment);
	} else {
		model.updateIP(ip.value<edb::value32>(), ipComment);
		model.updateFlags(flags.value<edb::value32>(), flagsComment);
	}
}

QString FPUStackFaultDetail(uint16_t statusWord) {
	const bool invalidOperationException = statusWord & 0x01;
	const bool C1                        = statusWord & (1 << 9);
	const bool stackFault                = statusWord & 0x40;
	if (invalidOperationException && stackFault)
		return C1 ? QObject::tr("Stack overflow") : QObject::tr("Stack underflow");
	return "";
}

QString FPUComparExplain(uint16_t statusWord) {
	const bool C0 = statusWord & (1 << 8);
	const bool C2 = statusWord & (1 << 10);
	const bool C3 = statusWord & (1 << 14);
	if (C3 == 0 && C2 == 0 && C0 == 0) return "GT";
	if (C3 == 0 && C2 == 0 && C0 == 1) return "LT";
	if (C3 == 1 && C2 == 0 && C0 == 0) return "EQ";
	if (C3 == 1 && C2 == 1 && C0 == 1) return QObject::tr("Unordered", "result of FPU comparison instruction");
	return "";
}

QString FPUExplainPE(uint16_t statusWord) {
	if (statusWord & (1 << 5)) {
		const bool C1 = statusWord & (1 << 9);
		return C1 ? QObject::tr("Rounded UP") : QObject::tr("Rounded DOWN");
	}
	return "";
}

QString FSRComment(uint16_t statusWord) {

	const auto stackFaultDetail = FPUStackFaultDetail(statusWord);
	const auto comparisonResult = FPUComparExplain(statusWord);
	const auto comparComment    = comparisonResult.isEmpty() ? "" : '(' + comparisonResult + ')';
	const auto peExplanation    = FPUExplainPE(statusWord);

	auto comment = comparComment;
	if (comment.length() && stackFaultDetail.length()) comment += ", ";
	comment += stackFaultDetail;
	if (comment.length() && peExplanation.length()) comment += ", ";
	comment += peExplanation;
	return comment.trimmed();
}

void updateSegRegs(RegisterViewModel &model, const State &state) {
	static const QString sregs[] = {"es", "cs", "ss", "ds", "fs", "gs"};
	for (std::size_t i = 0; i < sizeof(sregs) / sizeof(sregs[0]); ++i) {
		QString sreg(sregs[i]);
		const auto sregValue = state[sreg].value<edb::seg_reg_t>();
		const Register base  = state[sregs[i] + "_base"];
		QString comment;
		if (edb::v1::debuggeeIs32Bit() || i >= FS) {
			if (base)
				comment = QString("(%1)").arg(base.valueAsAddress().toHexString());
			else if (edb::v1::debuggeeIs32Bit() && sregValue == 0)
				comment = "NULL";
			else
				comment = "(?)";
		}
		model.updateSegReg(i, sregValue, comment);
	}
}

void updateFPURegs(RegisterViewModel &model, const State &state) {
	for (std::size_t i = 0; i < MAX_FPU_REGS_COUNT; ++i) {
		const auto reg     = state.fpuRegister(i);
		const auto comment = float_type(reg) == FloatValueClass::PseudoDenormal ? QObject::tr("pseudo-denormal") : "";
		model.updateFPUReg(i, reg, comment);
	}
	model.updateFCR(state.fpuControlWord());
	const auto fsr = state.fpuStatusWord();
	model.updateFSR(fsr, FSRComment(fsr));
	model.updateFTR(state.fpuTagWord());
	{
		const Register FIS = state["FIS"];
		if (FIS)
			model.updateFIS(FIS.value<edb::value16>());
		else
			model.invalidateFIS();
	}
	{
		const Register FDS = state["FDS"];
		if (FDS)
			model.updateFDS(FDS.value<edb::value16>());
		else
			model.invalidateFDS();
	}
	{
		const Register FIP = state["FIP"];
		if (FIP.bitSize() == 64)
			model.updateFIP(FIP.value<edb::value64>());
		else if (FIP.bitSize() == 32)
			model.updateFIP(FIP.value<edb::value32>());
		else
			model.invalidateFIP();
	}
	{
		const Register FDP = state["FDP"];
		if (FDP.bitSize() == 64)
			model.updateFDP(FDP.value<edb::value64>());
		else if (FDP.bitSize() == 32)
			model.updateFDP(FDP.value<edb::value32>());
		else
			model.invalidateFDP();
	}
	{
		const Register FOP = state["fopcode"];
		if (FOP) {
			const auto value = FOP.value<edb::value16>();
			// Yes, FOP is a big-endian view of the instruction
			const auto comment = value > 0x7ff ? QString("?!!") : QObject::tr("Insn: %1 %2").arg((edb::value8(value >> 8) + 0xd8).toHexString(), edb::value8(value).toHexString());
			model.updateFOP(value, comment);
		} else
			model.invalidateFOP();
	}
}

void updateDebugRegs(RegisterViewModel &model, const State &state) {
	for (std::size_t i = 0; i < MAX_DEBUG_REGS_COUNT; ++i) {
		const edb::reg_t reg = state.debugRegister(i);
		if (edb::v1::debuggeeIs32Bit())
			model.updateDR(i, edb::value32(reg));
		else
			model.updateDR(i, reg);
	}
}

void updateMMXRegs(RegisterViewModel &model, const State &state) {
	for (std::size_t i = 0; i < MAX_MMX_REGS_COUNT; ++i) {
		const auto reg = state.archRegister(edb::string_hash("mmx"), i);

		if (!!reg) {
			model.updateMMXReg(i, reg.value<MMWord>());
		} else {
			model.invalidateMMXReg(i);
		}
	}
}

void updateSSEAVXRegs(RegisterViewModel &model, const State &state, bool hasSSE, bool hasAVX) {

	if (!hasSSE) {
		return;
	}

	const std::size_t max = edb::v1::debuggeeIs32Bit() ? AVX32_COUNT : AVX64_COUNT;

	for (std::size_t i = 0; i < max; ++i) {
		if (hasAVX) {
			const auto reg = state.archRegister(edb::string_hash("ymm"), i);
			if (!reg) {
				model.invalidateAVXReg(i);
			} else {
				model.updateAVXReg(i, reg.value<YMMWord>());
			}
		} else if (hasSSE) {
			const auto reg = state.archRegister(edb::string_hash("xmm"), i);
			if (!reg) {
				model.invalidateSSEReg(i);
			} else {
				model.updateSSEReg(i, reg.value<XMMWord>());
			}
		}
	}

	const auto mxcsr = state["mxcsr"];
	if (!mxcsr) {
		model.invalidateMXCSR();
	} else {
		model.updateMXCSR(mxcsr.value<edb::value32>());
	}
}

bool falseSyscallReturn(const State &state, std::int64_t origAX) {
	// Prevent reporting of returns from execve() when the process has just launched
	if (EDB_IS_32_BIT && origAX == 11) {
		return state.gpRegister(rAX).valueAsInteger() == 0 &&
			   state.gpRegister(rCX).valueAsInteger() == 0 &&
			   state.gpRegister(rDX).valueAsInteger() == 0 &&
			   state.gpRegister(rBX).valueAsInteger() == 0 &&
			   state.gpRegister(rBP).valueAsInteger() == 0 &&
			   state.gpRegister(rSI).valueAsInteger() == 0 &&
			   state.gpRegister(rDI).valueAsInteger() == 0;
	} else if (EDB_IS_64_BIT && origAX == 59) {
		return state.gpRegister(rAX).valueAsInteger() == 0 &&
			   state.gpRegister(rCX).valueAsInteger() == 0 &&
			   state.gpRegister(rDX).valueAsInteger() == 0 &&
			   state.gpRegister(rBX).valueAsInteger() == 0 &&
			   state.gpRegister(rBP).valueAsInteger() == 0 &&
			   state.gpRegister(rSI).valueAsInteger() == 0 &&
			   state.gpRegister(rDI).valueAsInteger() == 0 &&
			   state.gpRegister(R8).valueAsInteger() == 0 &&
			   state.gpRegister(R9).valueAsInteger() == 0 &&
			   state.gpRegister(R10).valueAsInteger() == 0 &&
			   state.gpRegister(R11).valueAsInteger() == 0 &&
			   state.gpRegister(R12).valueAsInteger() == 0 &&
			   state.gpRegister(R13).valueAsInteger() == 0 &&
			   state.gpRegister(R14).valueAsInteger() == 0 &&
			   state.gpRegister(R15).valueAsInteger() == 0;
	}
	return false;
}

}

//------------------------------------------------------------------------------
// Name: getEffectiveAddress
// Desc:
//------------------------------------------------------------------------------
Result<edb::address_t, QString> ArchProcessor::getEffectiveAddress(const edb::Instruction &inst, const edb::Operand &op, const State &state) const {

	edb::address_t ret = 0;
	// TODO: get registers by index, not string! too slow

	if (op) {
		if (is_register(op)) {
			ret = state[QString::fromStdString(edb::v1::formatter().toString(op))].valueAsAddress();
		} else if (is_expression(op)) {
			const Register baseR  = state[QString::fromStdString(register_name(op->mem.base))];
			const Register indexR = state[QString::fromStdString(register_name(op->mem.index))];
			edb::address_t base   = 0;
			edb::address_t index  = 0;

			if (!baseR) {
				if (op->mem.base != X86_REG_INVALID)
					return make_unexpected(tr("failed to acquire base register from state"));
			} else {
				base = baseR.valueAsAddress();
			}

			if (!indexR) {
				if (op->mem.index != X86_REG_INVALID)
					return make_unexpected(tr("failed to acquire index register from state"));
			} else {
				if (indexR.type() != Register::TYPE_GPR)
					return make_unexpected(tr("only general-purpose register is supported as index register"));
				index = indexR.valueAsAddress();
			}

			// This only makes sense for x86_64, but doesn't hurt on x86
			if (op->mem.base == X86_REG_RIP) {
				base += inst.byteSize();
			}

			ret = base + index * op->mem.scale + op->mem.disp;

			std::size_t segRegIndex = op->mem.segment;

			// handle implicit segments on 32-bit (capstone doesn't call them out explicitly)
			if (segRegIndex == X86_REG_INVALID && !debuggeeIs64Bit()) {
				switch (op->mem.base) {
				case X86_REG_BP:
				case X86_REG_SP:
				case X86_REG_EBP:
				case X86_REG_ESP:
					segRegIndex = X86_REG_SS;
					break;
				default:
					segRegIndex = X86_REG_DS;
					break;
				}
			}

			if (segRegIndex != X86_REG_INVALID) {

				const Register segBase = [&segRegIndex, &state]() {
					switch (segRegIndex) {
					case X86_REG_ES:
						return state[QLatin1String("es_base")];
					case X86_REG_CS:
						return state[QLatin1String("cs_base")];
					case X86_REG_SS:
						return state[QLatin1String("ss_base")];
					case X86_REG_DS:
						return state[QLatin1String("ds_base")];
					case X86_REG_FS:
						return state[QLatin1String("fs_base")];
					case X86_REG_GS:
						return state[QLatin1String("gs_base")];
					default:
						return Register();
					}
				}();

				if (!segBase) return make_unexpected(QObject::tr("failed to obtain segment base")); // no way to reliably compute address
				ret += segBase.valueAsAddress();
			}
		} else if (is_immediate(op)) {
			const Register csBase = state["cs_base"];
			if (!csBase) return make_unexpected(QObject::tr("failed to obtain CS segment base")); // no way to reliably compute address
			ret = op->imm + csBase.valueAsAddress();
		}
	}

	ret.normalize();
	return ret;
}

edb::address_t ArchProcessor::getEffectiveAddress(const edb::Instruction &inst, const edb::Operand &op, const State &state, bool &ok) const {

	ok                = false;
	const auto result = getEffectiveAddress(inst, op, state);
	if (!result) return 0;
	ok = true;
	return result.value();
}

//------------------------------------------------------------------------------
// Name: ArchProcessor
// Desc:
//------------------------------------------------------------------------------
ArchProcessor::ArchProcessor() {
	if (edb::v1::debugger_core) {
		hasMmx_ = edb::v1::debugger_core->hasExtension(edb::string_hash("MMX"));
		hasXmm_ = edb::v1::debugger_core->hasExtension(edb::string_hash("XMM"));
		hasYmm_ = edb::v1::debugger_core->hasExtension(edb::string_hash("YMM"));
		connect(edb::v1::debugger_ui, SIGNAL(attachEvent()), this, SLOT(justAttached()));
	} else {
		hasMmx_ = false;
		hasXmm_ = false;
		hasYmm_ = false;
	}
}

//------------------------------------------------------------------------------
// Name: setup_register_view
// Desc:
//------------------------------------------------------------------------------
void ArchProcessor::setupRegisterView() {

	if (edb::v1::debugger_core) {

		updateRegisterView(QString(), State());
	}
}

//------------------------------------------------------------------------------
// Name: reset
// Desc:
//------------------------------------------------------------------------------
void ArchProcessor::reset() {

	if (edb::v1::debugger_core) {
		updateRegisterView(QString(), State());
	}
}

//------------------------------------------------------------------------------
// Name: update_register_view
// Desc:
//------------------------------------------------------------------------------
void ArchProcessor::updateRegisterView(const QString &default_region_name, const State &state) {

	auto &model = getModel();

	const auto ip = state.instructionPointerRegister();

	if (!ip) {
		model.setCpuMode(RegisterViewModel::CpuMode::UNKNOWN);
		return;
	}
	const bool is64Bit = (ip.bitSize() == 64);
	Q_ASSERT(is64Bit || ip.bitSize() == 32);

	model.setCpuMode(is64Bit ? RegisterViewModel::CpuMode::AMD64 : RegisterViewModel::CpuMode::IA32);
	updateGPRs(model, state, is64Bit);
	updateGeneralStatusRegs(model, state, is64Bit, default_region_name);
	updateSegRegs(model, state);
	updateFPURegs(model, state);
	updateDebugRegs(model, state);
	updateMMXRegs(model, state);
	updateSSEAVXRegs(model, state, hasXmm_, hasYmm_);

	if (justAttached_) {
		model.saveValues();
		justAttached_ = false;
	}
	model.dataUpdateFinished();
}

void ArchProcessor::aboutToResume() {
	getModel().saveValues();
}

void ArchProcessor::justAttached() {
	justAttached_ = true;
}

//------------------------------------------------------------------------------
// Name: update_instruction_info
// Desc:
//------------------------------------------------------------------------------
QStringList ArchProcessor::updateInstructionInfo(edb::address_t address) {

	QStringList ret;

	Q_ASSERT(edb::v1::debugger_core);

	if (IProcess *process = edb::v1::debugger_core->process()) {
		uint8_t buffer[edb::Instruction::MaxSize];

		if (process->readBytes(address, buffer, sizeof(buffer))) {
			edb::Instruction inst(buffer, buffer + sizeof(buffer), address);
			if (inst) {

				State state;
				process->currentThread()->getState(&state);

				std::int64_t origAX;
				if (debuggeeIs64Bit()) {
					origAX = state["orig_rax"].valueAsSignedInteger();
				} else {
					origAX = state["orig_eax"].valueAsSignedInteger();
				}

				const std::uint64_t rax = state.gpRegister(rAX).valueAsSignedInteger();

				if (origAX != -1 && !falseSyscallReturn(state, origAX)) {

					// FIXME: this all doesn't work correctly when we're on the first instruction of a signal handler
					// The registers there don't correspond to arguments of the syscall, and it's not correct to say the
					// debuggee _returned_ from the syscall, since it's just interrupted the syscall to handle the signal
					analyze_syscall(state, inst, ret, origAX);
#ifdef Q_OS_LINUX
					enum {
						// restart if no handler or if SA_RESTART is set, can be seen when interrupting e.g. waitpid
						ERESTARTSYS = 512,
						// restart unconditionally
						ERESTARTNOINTR = 513,
						// restart if no handler
						ERESTARTNOHAND = 514,
						// restart by sys_restart_syscall, can be seen when interrupting e.g. nanosleep
						ERESTART_RESTARTBLOCK = 516,
					};
					const auto err         = rax >= -4095UL ? -rax : 0;
					const bool interrupted = err == EINTR ||
											 err == ERESTARTSYS ||
											 err == ERESTARTNOINTR ||
											 err == ERESTARTNOHAND ||
											 err == ERESTART_RESTARTBLOCK;

					if (ret.size() && ret.back().startsWith("SYSCALL")) {
						if (interrupted)
							ret.back() = "Interrupted " + ret.back();
						else
							ret.back() = "Returned from " + ret.back();
					}
					// FIXME: actually only ERESTARTNOINTR guarantees reexecution. But it seems the other ERESTART* signals
					// won't go into user space, so whatever the state of signal handlers, the tracee should never appear
					// to see these signals. So I guess it's OK to assume that tha syscall _will_ be restarted by the kernel.
					if (interrupted && err != EINTR)
						ret << QString("Syscall will be restarted on next step/run");
#else
					Q_UNUSED(rax)
#endif
				}

				// figure out the instruction type and display some information about it
				// TODO: handle SETcc, LOOPcc, REPcc OP
				if (is_conditional_move(inst)) {

					analyze_cmov(state, inst, ret);

				} else if (is_ret(inst)) {

					analyze_return(state, inst, ret);

				} else if (is_jump(inst) || is_call(inst)) {

					if (is_conditional_jump(inst))
						analyze_jump(state, inst, ret);
					analyze_call(state, inst, ret);
				} else if (is_int(inst)) {
#ifdef Q_OS_LINUX
					if ((inst[0]->imm & 0xff) == 0x80) {

						analyze_syscall(state, inst, ret, state.gpRegister(rAX).valueAsInteger());
					} else {

						analyze_operands(state, inst, ret);
					}
#endif
				} else if (is_syscall(inst) || is_sysenter(inst)) {

					analyze_syscall(state, inst, ret, state.gpRegister(rAX).valueAsInteger());

				} else {

					analyze_operands(state, inst, ret);
				}

				analyze_jump_targets(inst, ret);
			}
		}

		// eliminate duplicates
		ret.sort();
		ret.erase(std::unique(ret.begin(), ret.end()), ret.end());
	}
	return ret;
}

//------------------------------------------------------------------------------
// Name: can_step_over
// Desc:
//------------------------------------------------------------------------------
bool ArchProcessor::canStepOver(const edb::Instruction &inst) const {
	return inst && (is_call(inst) || is_repeat(inst));
}

//------------------------------------------------------------------------------
// Name: is_filling
// Desc:
//------------------------------------------------------------------------------
bool ArchProcessor::isFilling(const edb::Instruction &inst) const {
	bool ret = false;

	// fetch the operands
	if (inst) {

		switch (inst.operation()) {
		case X86_INS_NOP:
		case X86_INS_INT3:
			ret = true;
			break;

		case X86_INS_LEA:

			Q_ASSERT(inst.operandCount() >= 2);

			if (is_register(inst[0]) && is_expression(inst[1])) {
				int reg1 = inst[0]->reg;

				if (inst[1]->mem.scale == 1) {
					if (inst[1]->mem.disp == 0) {
						int reg2;
						if (inst[1]->mem.base == X86_REG_INVALID) {
							reg2 = inst[1]->mem.index;
							ret  = (reg1 == reg2);
						} else if (inst[1]->mem.index == X86_REG_INVALID) {
							reg2 = inst[1]->mem.base;
							ret  = (reg1 == reg2);
						}
					}
				}
			}
			break;

		case X86_INS_MOV:

			Q_ASSERT(inst.operandCount() >= 2);

			if (is_register(inst[0]) && is_register(inst[1])) {
				ret = (inst[0]->reg == inst[1]->reg);
			}
			break;

		default:
			break;
		}

		if (!ret) {
			if (edb::v1::config().zeros_are_filling) {
				ret = (QByteArray::fromRawData(reinterpret_cast<const char *>(inst.bytes()), inst.byteSize()) == QByteArray::fromRawData("\x00\x00", 2));
			}
		}
	} else {
		ret = (inst.byteSize() == 1 && inst.bytes()[0] == 0x00);
	}

	return ret;
}

//------------------------------------------------------------------------------
// Name: register_view_model
// Desc:
//------------------------------------------------------------------------------
RegisterViewModelBase::Model &ArchProcessor::registerViewModel() const {
	static RegisterViewModel model(hasMmx_ * RegisterViewModel::CPUFeatureBits::MMX |
								   hasXmm_ * RegisterViewModel::CPUFeatureBits::SSE |
								   hasYmm_ * RegisterViewModel::CPUFeatureBits::AVX);
	return model;
}

bool ArchProcessor::isExecuted(const edb::Instruction &inst, const State &state) const {
	return is_jcc_taken(state, inst.conditionCode());
}

```

`src/arch/x86-generic/RegisterViewModel.cpp`:

```cpp
/*
Copyright (C) 2017 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "RegisterViewModel.h"
#include "Util.h"

#include <cstdint>
#include <typeinfo>

#include <QDebug>
#include <QList>

void invalidate(RegisterViewModelBase::Category *cat, int row, const char *nameToCheck = nullptr);

namespace {

template <std::size_t BitSize>
struct Regs;

template <>
struct Regs<32> {
	using GPR   = RegisterViewModelBase::SimpleRegister<edb::value32>;
	using IP    = GPR;
	using FLAGS = RegisterViewModelBase::FlagsRegister<edb::value32>;
	static constexpr char namePrefix() { return 'E'; }
};

template <>
struct Regs<64> {
	using GPR   = RegisterViewModelBase::SimpleRegister<edb::value64>;
	using IP    = GPR;
	using FLAGS = RegisterViewModelBase::FlagsRegister<edb::value64>;
	static constexpr char namePrefix() { return 'R'; }
};

constexpr std::size_t FPU_REG_COUNT   = 8;
constexpr std::size_t MMX_REG_COUNT   = FPU_REG_COUNT;
constexpr std::size_t SSE_REG_COUNT32 = 8;
constexpr std::size_t SSE_REG_COUNT64 = 16;
constexpr std::size_t AVX_REG_COUNT32 = 8;
constexpr std::size_t AVX_REG_COUNT64 = 16;
constexpr std::size_t DBG_REG_COUNT   = 8;

enum {
	RIP_ROW,
	EIP_ROW = RIP_ROW,
	RFLAGS_ROW,
	EFLAGS_ROW = RFLAGS_ROW,
	FCR_ROW    = FPU_REG_COUNT + 0,
	FSR_ROW,
	FTR_ROW,
	FOP_ROW,
	FIS_ROW,
	FIP_ROW,
	FDS_ROW,
	FDP_ROW,
};

using GPR32      = typename Regs<32>::GPR;
using GPR64      = typename Regs<64>::GPR;
using EFLAGS     = typename Regs<32>::FLAGS;
using RFLAGS     = typename Regs<64>::FLAGS;
using EIP        = typename Regs<32>::IP;
using RIP        = typename Regs<64>::IP;
using FPUReg     = RegisterViewModelBase::FPURegister<edb::value80>;
using FPUWord    = RegisterViewModelBase::FlagsRegister<edb::value16>;
using FOPCReg    = RegisterViewModelBase::SimpleRegister<edb::value16>;
using SegmentReg = RegisterViewModelBase::SimpleRegister<edb::value16>;
using MMXReg     = RegisterViewModelBase::SIMDRegister<edb::value64>;
using SSEReg     = RegisterViewModelBase::SIMDRegister<edb::value128>;
using AVXReg     = RegisterViewModelBase::SIMDRegister<edb::value256>;
using MXCSR      = RegisterViewModelBase::FlagsRegister<edb::value32>;

const std::vector<RegisterViewModelBase::BitFieldDescriptionEx> flagsDescription = {
	{QLatin1String("CF"), 0, 1},
	{QLatin1String("PF"), 2, 1},
	{QLatin1String("AF"), 4, 1},
	{QLatin1String("ZF"), 6, 1},
	{QLatin1String("SF"), 7, 1},
	{QLatin1String("TF"), 8, 1},
	{QLatin1String("IF"), 9, 1},
	{QLatin1String("DF"), 10, 1},
	{QLatin1String("OF"), 11, 1},
	// these commented out system flags are always zeroed by the kernel before giving out to debugger
	//	{QLatin1String("IOPL"),12,2},
	//	{QLatin1String("NT"),14,1},
	{QLatin1String("RF"), 16, 1}, // is debugger-visibly set on e.g. CLI instruction segfault
								  //	{QLatin1String("VM"),17,1},
	{QLatin1String("AC"), 18, 1}, // this one can be set by the application and is visible to debugger
								  //	{QLatin1String("VIF"),19,1},
								  //	{QLatin1String("VIP"),20,1},
	{QLatin1String("ID"), 21, 1}, // this one can be set by the application and is visible to debugger
};

const std::vector<QString> roundingStrings = {
	QObject::tr("Rounding to nearest"),
	QObject::tr("Rounding down"),
	QObject::tr("Rounding up"),
	QObject::tr("Rounding toward zero"),
};

const std::vector<RegisterViewModelBase::BitFieldDescriptionEx> FCRDescription = {
	{QLatin1String("IM"), 0, 1},
	{QLatin1String("DM"), 1, 1},
	{QLatin1String("ZM"), 2, 1},
	{QLatin1String("OM"), 3, 1},
	{QLatin1String("UM"), 4, 1},
	{QLatin1String("PM"), 5, 1},
	{QLatin1String("PC"), 8, 2, {QObject::tr("Single precision (24 bit complete mantissa)"), QString(), QObject::tr("Double precision (53 bit complete mantissa)"), QObject::tr("Extended precision (64 bit mantissa)")}},
	{QLatin1String("RC"), 10, 2, roundingStrings},
	{QLatin1String("X"), 12, 1},
};

const std::vector<RegisterViewModelBase::BitFieldDescriptionEx> FSRDescription = {
	{QLatin1String("IE"), 0, 1},
	{QLatin1String("DE"), 1, 1},
	{QLatin1String("ZE"), 2, 1},
	{QLatin1String("OE"), 3, 1},
	{QLatin1String("UE"), 4, 1},
	{QLatin1String("PE"), 5, 1},
	{QLatin1String("SF"), 6, 1},
	{QLatin1String("ES"), 7, 1},
	{QLatin1String("C0"), 8, 1},
	{QLatin1String("C1"), 9, 1},
	{QLatin1String("C2"), 10, 1},
	{QLatin1String("TOP"), 11, 3},
	{QLatin1String("C3"), 14, 1},
	{QLatin1String("B"), 15, 1},
};

const std::vector<QString> tagStrings = {
	QObject::tr("Valid"),
	QObject::tr("Zero"),
	QObject::tr("Special"),
	QObject::tr("Empty"),
};

const std::vector<RegisterViewModelBase::BitFieldDescriptionEx> FTRDescription = {
	{QLatin1String("T0"), 0, 2, tagStrings},
	{QLatin1String("T1"), 2, 2, tagStrings},
	{QLatin1String("T2"), 4, 2, tagStrings},
	{QLatin1String("T3"), 6, 2, tagStrings},
	{QLatin1String("T4"), 8, 2, tagStrings},
	{QLatin1String("T5"), 10, 2, tagStrings},
	{QLatin1String("T6"), 12, 2, tagStrings},
	{QLatin1String("T7"), 14, 2, tagStrings},
};

const std::vector<RegisterViewModelBase::BitFieldDescriptionEx> MXCSRDescription = {
	{QLatin1String("IE"), 0, 1},
	{QLatin1String("DE"), 1, 1},
	{QLatin1String("ZE"), 2, 1},
	{QLatin1String("OE"), 3, 1},
	{QLatin1String("UE"), 4, 1},
	{QLatin1String("PE"), 5, 1},
	{QLatin1String("DAZ"), 6, 1},
	{QLatin1String("IM"), 7, 1},
	{QLatin1String("DM"), 8, 1},
	{QLatin1String("ZM"), 9, 1},
	{QLatin1String("OM"), 10, 1},
	{QLatin1String("UM"), 11, 1},
	{QLatin1String("PM"), 12, 1},
	{QLatin1String("RC"), 13, 2, roundingStrings},
	{QLatin1String("FZ"), 15, 1},
};

const std::vector<RegisterViewModelBase::BitFieldDescriptionEx> DR6Description = {
	{"B0", 0, 1},
	{"B1", 1, 1},
	{"B2", 2, 1},
	{"B3", 3, 1},
	{"BD", 13, 1},
	{"BS", 14, 1},
	{"BT", 15, 1},
	{"RTM", 16, 1},
};

const std::vector<QString> DR7_RW = {
	QObject::tr("Execution"),
	QObject::tr("Data Writes"),
	QObject::tr("I/O"),
	QObject::tr("Data R/W"),
};

const std::vector<QString> DR7_LEN = {
	QObject::tr("1 byte"),
	QObject::tr("2 bytes"),
	QObject::tr("8 bytes"), // sic!
	QObject::tr("4 bytes"),
};

std::vector<RegisterViewModelBase::BitFieldDescriptionEx> DR7Description = {
	{QLatin1String("L0"), 0, 1},
	{QLatin1String("G0"), 1, 1},
	{QLatin1String("L1"), 2, 1},
	{QLatin1String("G1"), 3, 1},
	{QLatin1String("L2"), 4, 1},
	{QLatin1String("G2"), 5, 1},
	{QLatin1String("L3"), 6, 1},
	{QLatin1String("G3"), 7, 1},
	{QLatin1String("LE"), 8, 1},
	{QLatin1String("GE"), 9, 1},
	{QLatin1String("RTM"), 11, 1},
	{QLatin1String("GD"), 13, 1},
	{QLatin1String("R/W0"), 16, 2, DR7_RW},
	{QLatin1String("LEN0"), 18, 2, DR7_LEN},
	{QLatin1String("R/W1"), 20, 2, DR7_RW},
	{QLatin1String("LEN1"), 22, 2, DR7_LEN},
	{QLatin1String("R/W2"), 24, 2, DR7_RW},
	{QLatin1String("LEN2"), 26, 2, DR7_LEN},
	{QLatin1String("R/W3"), 28, 2, DR7_RW},
	{QLatin1String("LEN3"), 30, 2, DR7_LEN},
};

void addGPRs32(RegisterViewModelBase::Category *gprs32) {
	gprs32->addRegister(std::make_unique<Regs<32>::GPR>("EAX"));
	gprs32->addRegister(std::make_unique<Regs<32>::GPR>("ECX"));
	gprs32->addRegister(std::make_unique<Regs<32>::GPR>("EDX"));
	gprs32->addRegister(std::make_unique<Regs<32>::GPR>("EBX"));
	gprs32->addRegister(std::make_unique<Regs<32>::GPR>("ESP"));
	gprs32->addRegister(std::make_unique<Regs<32>::GPR>("EBP"));
	gprs32->addRegister(std::make_unique<Regs<32>::GPR>("ESI"));
	gprs32->addRegister(std::make_unique<Regs<32>::GPR>("EDI"));
}

void addGPRs64(RegisterViewModelBase::Category *gprs64) {
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("RAX"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("RCX"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("RDX"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("RBX"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("RSP"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("RBP"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("RSI"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("RDI"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("R8"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("R9"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("R10"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("R11"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("R12"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("R13"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("R14"));
	gprs64->addRegister(std::make_unique<Regs<64>::GPR>("R15"));
}

template <std::size_t bitSize>
void addGenStatusRegs(RegisterViewModelBase::Category *cat) {
	using Rs = Regs<bitSize>;
	cat->addRegister(std::make_unique<typename Rs::IP>(Rs::namePrefix() + QString("IP")));
	cat->addRegister(std::make_unique<typename Rs::FLAGS>(Rs::namePrefix() + QString("FLAGS"), flagsDescription));
}

void addSegRegs(RegisterViewModelBase::Category *cat) {
	cat->addRegister(std::make_unique<SegmentReg>("ES"));
	cat->addRegister(std::make_unique<SegmentReg>("CS"));
	cat->addRegister(std::make_unique<SegmentReg>("SS"));
	cat->addRegister(std::make_unique<SegmentReg>("DS"));
	cat->addRegister(std::make_unique<SegmentReg>("FS"));
	cat->addRegister(std::make_unique<SegmentReg>("GS"));
}

template <std::size_t bitSize>
void addFPURegs(RegisterViewModelBase::Category *fpuRegs) {
	for (std::size_t i = 0; i < FPU_REG_COUNT; ++i) {
		fpuRegs->addRegister(std::make_unique<FPUReg>(QString("R%1").arg(i)));
	}
	fpuRegs->addRegister(std::make_unique<FPUWord>("FCR", FCRDescription));
	fpuRegs->addRegister(std::make_unique<FPUWord>("FSR", FSRDescription));
	fpuRegs->addRegister(std::make_unique<FPUWord>("FTR", FTRDescription));
	fpuRegs->addRegister(std::make_unique<FOPCReg>("FOP"));
	using Rs = Regs<bitSize>;
	fpuRegs->addRegister(std::make_unique<SegmentReg>("FIS"));
	fpuRegs->addRegister(std::make_unique<typename Rs::IP>("FIP"));
	fpuRegs->addRegister(std::make_unique<SegmentReg>("FDS"));
	fpuRegs->addRegister(std::make_unique<typename Rs::IP>("FDP"));
}

template <std::size_t bitSize>
void addDebugRegs(RegisterViewModelBase::Category *dbgRegs) {
	using Rs = Regs<bitSize>;
	for (std::size_t i = 0; i < 4; ++i) {
		dbgRegs->addRegister(std::make_unique<typename Rs::IP>(QString("DR%1").arg(i)));
	}

	dbgRegs->addRegister(std::make_unique<typename Rs::FLAGS>(QString("DR6"), DR6Description));
	dbgRegs->addRegister(std::make_unique<typename Rs::FLAGS>(QString("DR7"), DR7Description));
}

const std::vector<NumberDisplayMode> MMXFormats = {
	NumberDisplayMode::Hex,
	NumberDisplayMode::Signed,
	NumberDisplayMode::Unsigned,
};

const std::vector<NumberDisplayMode> SSEAVXFormats = {
	NumberDisplayMode::Hex,
	NumberDisplayMode::Signed,
	NumberDisplayMode::Unsigned,
	NumberDisplayMode::Float,
};

void addMMXRegs(RegisterViewModelBase::SIMDCategory *mmxRegs) {
	using namespace RegisterViewModelBase;
	// TODO: MMXReg should have possibility to be shown in byte/word/dword signed/unsigned/hex formats
	for (std::size_t i = 0; i < MMX_REG_COUNT; ++i) {
		mmxRegs->addRegister(std::make_unique<MMXReg>(QString("MM%1").arg(i), MMXFormats));
	}
}

void addSSERegs(RegisterViewModelBase::SIMDCategory *sseRegs, unsigned regCount) {
	for (std::size_t i = 0; i < regCount; ++i) {
		sseRegs->addRegister(std::make_unique<SSEReg>(QString("XMM%1").arg(i), SSEAVXFormats));
	}

	sseRegs->addRegister(std::make_unique<MXCSR>("MXCSR", MXCSRDescription));
}

void addAVXRegs(RegisterViewModelBase::SIMDCategory *avxRegs, unsigned regCount) {
	for (std::size_t i = 0; i < regCount; ++i) {
		avxRegs->addRegister(std::make_unique<AVXReg>(QString("YMM%1").arg(i), SSEAVXFormats));
	}
	avxRegs->addRegister(std::make_unique<MXCSR>("MXCSR", MXCSRDescription));
}

}

/**
 * @brief RegisterViewModel::data
 * @param index
 * @param role
 * @return
 */
QVariant RegisterViewModel::data(const QModelIndex &index, int role) const {
	if (role == FixedLengthRole) {

		using namespace RegisterViewModelBase;

		const auto reg  = static_cast<RegisterViewItem *>(index.internalPointer());
		const auto name = reg->data(NAME_COLUMN).toString();

		if (index.column() == NAME_COLUMN) {
			if (name == "R8" || name == "R9") {
				return 3;
			}

			if (name.startsWith("XMM") || name.startsWith("YMM")) {
				if (mode == CpuMode::IA32) return 4;
				if (mode == CpuMode::AMD64) return 5;
				return {};
			}
		}
	}
	return Model::data(index, role);
}

/**
 * @brief RegisterViewModel::RegisterViewModel
 * @param cpuSuppFlags
 * @param parent
 */
RegisterViewModel::RegisterViewModel(int cpuSuppFlags, QObject *parent)
	: RegisterViewModelBase::Model(parent),
	  gprs32(addCategory(tr("General Purpose"))),
	  gprs64(addCategory(tr("General Purpose"))),
	  genStatusRegs32(addCategory(tr("General Status"))),
	  genStatusRegs64(addCategory(tr("General Status"))),
	  segRegs(addCategory(tr("Segment"))),
	  dbgRegs32(addCategory(tr("Debug"))),
	  dbgRegs64(addCategory(tr("Debug"))),
	  fpuRegs32(addFPUCategory(tr("FPU"))),
	  fpuRegs64(addFPUCategory(tr("FPU"))),
	  mmxRegs(addSIMDCategory(tr("MMX"), MMXFormats)),
	  sseRegs32(addSIMDCategory(tr("SSE"), SSEAVXFormats)),
	  sseRegs64(addSIMDCategory(tr("SSE"), SSEAVXFormats)),
	  avxRegs32(addSIMDCategory(tr("AVX"), SSEAVXFormats)),
	  avxRegs64(addSIMDCategory(tr("AVX"), SSEAVXFormats)) {
	addGPRs32(gprs32);
	addGPRs64(gprs64);

	addGenStatusRegs<32>(genStatusRegs32);
	addGenStatusRegs<64>(genStatusRegs64);

	addSegRegs(segRegs);

	addFPURegs<32>(fpuRegs32);
	addFPURegs<64>(fpuRegs64);

	addDebugRegs<32>(dbgRegs32);
	addDebugRegs<64>(dbgRegs64);

	if (cpuSuppFlags & CPUFeatureBits::MMX) {
		addMMXRegs(mmxRegs);
	}

	if (cpuSuppFlags & CPUFeatureBits::SSE) {
		addSSERegs(sseRegs32, SSE_REG_COUNT32);
		addSSERegs(sseRegs64, SSE_REG_COUNT64);
	}

	if (cpuSuppFlags & CPUFeatureBits::AVX) {
		addAVXRegs(avxRegs32, AVX_REG_COUNT32);
		addAVXRegs(avxRegs64, AVX_REG_COUNT64);
	}

	setCpuMode(CpuMode::UNKNOWN);
}

template <typename RegType, typename ValueType>
void updateRegister(RegisterViewModelBase::Category *cat, int row, ValueType value, const QString &comment, const char *nameToCheck = nullptr) {
	const auto reg = cat->getRegister(row);
	if (!dynamic_cast<RegType *>(reg)) {
		qWarning() << "Failed to update register " << reg->name() << ": failed to convert register passed to expected type " << typeid(RegType).name();
		invalidate(cat, row, nameToCheck);
		return;
	}
	Q_ASSERT(!nameToCheck || reg->name() == nameToCheck);
	Q_UNUSED(nameToCheck)
	static_cast<RegType *>(reg)->update(value, comment);
}

void RegisterViewModel::updateGPR(std::size_t i, edb::value32 val, const QString &comment) {
	Q_ASSERT(int(i) < gprs32->childCount());
	updateRegister<GPR32>(gprs32, static_cast<int>(i), val, comment);
}

void RegisterViewModel::updateGPR(std::size_t i, edb::value64 val, const QString &comment) {
	Q_ASSERT(int(i) < gprs64->childCount());
	updateRegister<GPR64>(gprs64, static_cast<int>(i), val, comment);
}

void RegisterViewModel::updateIP(edb::value64 value, const QString &comment) {
	updateRegister<RIP>(genStatusRegs64, RIP_ROW, value, comment, "RIP");
}

void RegisterViewModel::updateIP(edb::value32 value, const QString &comment) {
	updateRegister<EIP>(genStatusRegs32, EIP_ROW, value, comment, "EIP");
}

void RegisterViewModel::updateFlags(edb::value64 value, const QString &comment) {
	updateRegister<RFLAGS>(genStatusRegs64, RFLAGS_ROW, value, comment);
}

void RegisterViewModel::updateFlags(edb::value32 value, const QString &comment) {
	updateRegister<EFLAGS>(genStatusRegs32, EFLAGS_ROW, value, comment);
}

void RegisterViewModel::updateSegReg(std::size_t i, edb::value16 value, const QString &comment) {
	updateRegister<SegmentReg>(segRegs, i, value, comment);
}

RegisterViewModelBase::FPUCategory *RegisterViewModel::getFPUcat() const {
	switch (mode) {
	case CpuMode::IA32:
		return fpuRegs32;
	case CpuMode::AMD64:
		return fpuRegs64;
	default:
		return nullptr;
	}
}

void RegisterViewModel::updateFPUReg(std::size_t i, edb::value80 value, const QString &comment) {
	const auto cat = getFPUcat();
	Q_ASSERT(int(i) < cat->childCount());
	updateRegister<FPUReg>(cat, static_cast<int>(i), value, comment);
}

void RegisterViewModel::updateFCR(edb::value16 value, const QString &comment) {
	updateRegister<FPUWord>(getFPUcat(), FCR_ROW, value, comment, "FCR");
}

void RegisterViewModel::updateFTR(edb::value16 value, const QString &comment) {
	updateRegister<FPUWord>(getFPUcat(), FTR_ROW, value, comment, "FTR");
}

void RegisterViewModel::updateFSR(edb::value16 value, const QString &comment) {
	updateRegister<FPUWord>(getFPUcat(), FSR_ROW, value, comment, "FSR");
}

void invalidate(RegisterViewModelBase::Category *cat, int row, const char *nameToCheck) {
	if (!cat) return;
	Q_ASSERT(row < cat->childCount());
	const auto reg = cat->getRegister(row);
	Q_ASSERT(!nameToCheck || reg->name() == nameToCheck);
	Q_UNUSED(nameToCheck)
	reg->invalidate();
}

void RegisterViewModel::invalidateFIP() {
	invalidate(getFPUcat(), FIP_ROW, "FIP");
}
void RegisterViewModel::invalidateFDP() {
	invalidate(getFPUcat(), FDP_ROW, "FDP");
}
void RegisterViewModel::invalidateFIS() {
	invalidate(getFPUcat(), FIS_ROW, "FIS");
}
void RegisterViewModel::invalidateFDS() {
	invalidate(getFPUcat(), FDS_ROW, "FDS");
}
void RegisterViewModel::invalidateFOP() {
	invalidate(getFPUcat(), FOP_ROW, "FOP");
}

void RegisterViewModel::updateFIP(edb::value32 value, const QString &comment) {
	updateRegister<EIP>(getFPUcat(), FIP_ROW, value, comment);
}
void RegisterViewModel::updateFIP(edb::value64 value, const QString &comment) {
	updateRegister<RIP>(getFPUcat(), FIP_ROW, value, comment);
}
void RegisterViewModel::updateFDP(edb::value32 value, const QString &comment) {
	updateRegister<EIP>(getFPUcat(), FDP_ROW, value, comment);
}
void RegisterViewModel::updateFDP(edb::value64 value, const QString &comment) {
	updateRegister<RIP>(getFPUcat(), FDP_ROW, value, comment);
}

void RegisterViewModel::updateFOP(edb::value16 value, const QString &comment) {
	updateRegister<FOPCReg>(getFPUcat(), FOP_ROW, value, comment);
}

void RegisterViewModel::updateFIS(edb::value16 value, const QString &comment) {
	updateRegister<SegmentReg>(getFPUcat(), FIS_ROW, value, comment, "FIS");
}
void RegisterViewModel::updateFDS(edb::value16 value, const QString &comment) {
	updateRegister<SegmentReg>(getFPUcat(), FDS_ROW, value, comment, "FDS");
}

void RegisterViewModel::updateDR(std::size_t i, edb::value32 value, const QString &comment) {
	Q_ASSERT(i < DBG_REG_COUNT);
	if (i < 4)
		updateRegister<EIP>(dbgRegs32, i, value, comment);
	else if (i >= 6)
		updateRegister<EFLAGS>(dbgRegs32, i - 2, value, comment);
}
void RegisterViewModel::updateDR(std::size_t i, edb::value64 value, const QString &comment) {
	Q_ASSERT(i < DBG_REG_COUNT);
	if (i < 4)
		updateRegister<RIP>(dbgRegs64, i, value, comment);
	else if (i >= 6)
		updateRegister<RFLAGS>(dbgRegs64, i - 2, value, comment);
}

void RegisterViewModel::updateMMXReg(std::size_t i, edb::value64 value, const QString &comment) {
	Q_ASSERT(i < MMX_REG_COUNT);
	if (!mmxRegs->childCount()) return;
	updateRegister<MMXReg>(mmxRegs, static_cast<int>(i), value, comment);
}
void RegisterViewModel::invalidateMMXReg(std::size_t i) {
	Q_ASSERT(i < MMX_REG_COUNT);
	if (!mmxRegs->childCount()) return;
	invalidate(mmxRegs, i);
}

std::tuple<RegisterViewModelBase::Category * /*sse*/,
		   RegisterViewModelBase::Category * /*avx*/,
		   unsigned /*maxRegs*/>
RegisterViewModel::getSSEparams() const {
	RegisterViewModelBase::Category *sseCat = nullptr;
	RegisterViewModelBase::Category *avxCat = nullptr;
	unsigned sseRegMax                      = 0;
	switch (mode) {
	case CpuMode::IA32:
		sseRegMax = SSE_REG_COUNT32;
		sseCat    = sseRegs32;
		avxCat    = avxRegs32;
		break;
	case CpuMode::AMD64:
		sseRegMax = SSE_REG_COUNT64;
		sseCat    = sseRegs64;
		avxCat    = avxRegs64;
		break;
	default:
		break;
	}
	return std::make_tuple(sseCat, avxCat, sseRegMax);
}

void RegisterViewModel::updateSSEReg(std::size_t i, edb::value128 value, const QString &comment) {
	RegisterViewModelBase::Category *sseCat, *avxCat;
	unsigned sseRegMax;
	std::tie(sseCat, avxCat, sseRegMax) = getSSEparams();
	Q_ASSERT(i < sseRegMax);
	if (!sseCat->childCount()) return;
	updateRegister<SSEReg>(sseCat, static_cast<int>(i), value, comment);
	// To avoid showing stale data in case this is called when AVX state is supported
	if (avxCat->childCount()) invalidate(avxCat, i);
}
void RegisterViewModel::invalidateSSEReg(std::size_t i) {
	RegisterViewModelBase::Category *sseCat, *avxCat;
	std::size_t sseRegMax;
	std::tie(sseCat, avxCat, sseRegMax) = getSSEparams();
	Q_ASSERT(i < sseRegMax);
	if (!sseCat->childCount()) return;
	invalidate(sseCat, i);
	// To avoid showing stale data in case this is called when AVX state is supported
	if (avxCat->childCount()) invalidate(avxCat, i);
}

void RegisterViewModel::updateAVXReg(std::size_t i, edb::value256 value, const QString &comment) {
	RegisterViewModelBase::Category *sseCat, *avxCat;
	unsigned avxRegMax;
	std::tie(sseCat, avxCat, avxRegMax) = getSSEparams();
	if (i >= avxRegMax) {
		qWarning() << Q_FUNC_INFO << ": i>AVXmax";
		return;
	}
	// update aliases
	updateRegister<SSEReg>(sseCat, static_cast<int>(i), edb::value128(value), comment);
	// update actual registers
	updateRegister<AVXReg>(avxCat, static_cast<int>(i), value, comment);
}
void RegisterViewModel::invalidateAVXReg(std::size_t i) {
	RegisterViewModelBase::Category *sseCat, *avxCat;
	std::size_t avxRegMax;
	std::tie(sseCat, avxCat, avxRegMax) = getSSEparams();
	Q_ASSERT(i < avxRegMax);
	// invalidate aliases
	invalidate(sseCat, i);
	// invalidate actual registers
	invalidate(avxCat, i);
}

void RegisterViewModel::updateMXCSR(edb::value32 value, const QString &comment) {
	RegisterViewModelBase::Category *sseCat, *avxCat;
	std::size_t avxRegMax;
	std::tie(sseCat, avxCat, avxRegMax) = getSSEparams();
	updateRegister<MXCSR>(sseCat, sseCat->childCount() - 1, value, comment, "MXCSR");
	if (avxCat->childCount())
		updateRegister<MXCSR>(avxCat, avxCat->childCount() - 1, value, comment, "MXCSR");
}
void RegisterViewModel::invalidateMXCSR() {
	RegisterViewModelBase::Category *sseCat, *avxCat;
	std::size_t avxRegMax;
	std::tie(sseCat, avxCat, avxRegMax) = getSSEparams();
	invalidate(sseCat, sseCat->childCount() - 1, "MXCSR");
	if (avxCat->childCount())
		invalidate(avxCat, avxCat->childCount() - 1, "MXCSR");
}

void RegisterViewModel::hide64BitModeCategories() {
	gprs64->hide();
	genStatusRegs64->hide();
	fpuRegs64->hide();
	dbgRegs64->hide();
	if (sseRegs64->childCount()) sseRegs64->hide();
	if (avxRegs64->childCount()) avxRegs64->hide();
}

void RegisterViewModel::hide32BitModeCategories() {
	gprs32->hide();
	genStatusRegs32->hide();
	fpuRegs32->hide();
	dbgRegs32->hide();
	if (sseRegs32->childCount()) sseRegs32->hide();
	if (avxRegs32->childCount()) avxRegs32->hide();
}

void RegisterViewModel::show64BitModeCategories() {
	gprs64->show();
	genStatusRegs64->show();
	fpuRegs64->show();
	dbgRegs64->show();
	if (sseRegs64->childCount()) sseRegs64->show();
	if (avxRegs64->childCount()) avxRegs64->show();
}

void RegisterViewModel::show32BitModeCategories() {
	gprs32->show();
	genStatusRegs32->show();
	fpuRegs32->show();
	dbgRegs32->show();
	if (sseRegs32->childCount()) sseRegs32->show();
	if (avxRegs32->childCount()) avxRegs32->show();
}

void RegisterViewModel::hideGenericCategories() {
	segRegs->hide();
	mmxRegs->hide();
}

void RegisterViewModel::showGenericCategories() {
	segRegs->show();
	if (mmxRegs->childCount()) mmxRegs->show();
}

void RegisterViewModel::setCpuMode(CpuMode newMode) {
	if (mode == newMode) return;

	beginResetModel();
	mode = newMode;
	switch (newMode) {
	case CpuMode::UNKNOWN:
		hideAll();
		break;
	case CpuMode::IA32:
		hide64BitModeCategories();
		show32BitModeCategories();
		showGenericCategories();
		break;
	case CpuMode::AMD64:
		hide32BitModeCategories();
		show64BitModeCategories();
		showGenericCategories();
		break;
	default:
		EDB_PRINT_AND_DIE("Invalid newMode value ", (long)newMode);
	}
	endResetModel();
}

```

`src/arch/x86-generic/RegisterViewModel.h`:

```h
/*
Copyright (C) 2017 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef X86_REGISTER_VIEW_MODEL_H_20151213_
#define X86_REGISTER_VIEW_MODEL_H_20151213_

#include "RegisterViewModelBase.h"
#include "Types.h"

class RegisterViewModel : public RegisterViewModelBase::Model {
	Q_OBJECT

private:
	// Relying on categories being there for the whole lifetime of the model
	RegisterViewModelBase::Category *gprs32;
	RegisterViewModelBase::Category *gprs64;
	RegisterViewModelBase::Category *genStatusRegs32;
	RegisterViewModelBase::Category *genStatusRegs64;
	RegisterViewModelBase::Category *segRegs;
	RegisterViewModelBase::Category *dbgRegs32;
	RegisterViewModelBase::Category *dbgRegs64;
	RegisterViewModelBase::FPUCategory *fpuRegs32;
	RegisterViewModelBase::FPUCategory *fpuRegs64;
	RegisterViewModelBase::SIMDCategory *mmxRegs;
	RegisterViewModelBase::SIMDCategory *sseRegs32;
	RegisterViewModelBase::SIMDCategory *sseRegs64;
	RegisterViewModelBase::SIMDCategory *avxRegs32;
	RegisterViewModelBase::SIMDCategory *avxRegs64;

public:
	enum class CpuMode {
		UNKNOWN,
		IA32,
		AMD64
	};

	// scoped enum, but allowing to implicitly covert to int
	struct CPUFeatureBits {
		enum Value {
			MMX = 1,
			SSE = 2,
			AVX = 4
		};
	};

	explicit RegisterViewModel(int CPUFeaturesPresent, QObject *parent = nullptr);
	QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
	void setCpuMode(CpuMode mode);

	// NOTE: all these functions only change data, they don't emit dataChanged!
	// Use dataUpdateFinished() to have dataChanged emitted.
	void updateGPR(std::size_t i, edb::value32 val, const QString &comment = QString());
	void updateGPR(std::size_t i, edb::value64 val, const QString &comment = QString());
	void updateIP(edb::value32, const QString &comment = QString());
	void updateIP(edb::value64, const QString &comment = QString());
	void updateFlags(edb::value32, const QString &comment = QString());
	void updateFlags(edb::value64, const QString &comment = QString());
	void updateSegReg(std::size_t i, edb::value16, const QString &comment = QString());
	void updateFPUReg(std::size_t i, edb::value80, const QString &comment = QString());
	void updateFCR(edb::value16, const QString &comment = QString());
	void updateFSR(edb::value16, const QString &comment = QString());
	void updateFTR(edb::value16, const QString &comment = QString());
	void invalidateFIP();
	void invalidateFDP();
	void invalidateFIS();
	void invalidateFDS();
	void invalidateFOP();
	void updateFIP(edb::value32, const QString &comment = QString());
	void updateFIP(edb::value64, const QString &comment = QString());
	void updateFDP(edb::value32, const QString &comment = QString());
	void updateFDP(edb::value64, const QString &comment = QString());
	void updateFIS(edb::value16, const QString &comment = QString());
	void updateFDS(edb::value16, const QString &comment = QString());
	void updateFOP(edb::value16, const QString &comment = QString());
	void updateDR(std::size_t i, edb::value32, const QString &comment = QString());
	void updateDR(std::size_t i, edb::value64, const QString &comment = QString());
	void updateMMXReg(std::size_t i, edb::value64, const QString &comment = QString());
	void invalidateMMXReg(std::size_t i);
	void updateSSEReg(std::size_t i, edb::value128, const QString &comment = QString());
	void invalidateSSEReg(std::size_t i);
	void updateAVXReg(std::size_t i, edb::value256, const QString &comment = QString());
	void invalidateAVXReg(std::size_t i);
	void updateMXCSR(edb::value32, const QString &comment = QString());
	void invalidateMXCSR();

private:
	void hide64BitModeCategories();
	void hide32BitModeCategories();
	void show64BitModeCategories();
	void show32BitModeCategories();
	void hideGenericCategories();
	void showGenericCategories();
	std::tuple<RegisterViewModelBase::Category * /*sse*/, RegisterViewModelBase::Category * /*avx*/, unsigned /*maxRegs*/> getSSEparams() const;
	RegisterViewModelBase::FPUCategory *getFPUcat() const;
	CpuMode mode = static_cast<CpuMode>(-1); // TODO(eteran): why not CpuMode::UNKNOWN?
};

#endif

```

`src/arch/x86-generic/errno-names-linux.h`:

```h
/*
Copyright (C) 2017 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ERRNO_NAMES_LINUX_H_20160514_
#define ERRNO_NAMES_LINUX_H_20160514_

#include <array>

namespace {

std::array<const char *, 531> errnoNames = {
	nullptr,                 /*  0  */
	"EPERM",                 /*  1  */
	"ENOENT",                /*  2  */
	"ESRCH",                 /*  3  */
	"EINTR",                 /*  4  */
	"EIO",                   /*  5  */
	"ENXIO",                 /*  6  */
	"E2BIG",                 /*  7  */
	"ENOEXEC",               /*  8  */
	"EBADF",                 /*  9  */
	"ECHILD",                /* 10  */
	"EAGAIN",                /* 11  */
	"ENOMEM",                /* 12  */
	"EACCES",                /* 13  */
	"EFAULT",                /* 14  */
	"ENOTBLK",               /* 15  */
	"EBUSY",                 /* 16  */
	"EEXIST",                /* 17  */
	"EXDEV",                 /* 18  */
	"ENODEV",                /* 19  */
	"ENOTDIR",               /* 20  */
	"EISDIR",                /* 21  */
	"EINVAL",                /* 22  */
	"ENFILE",                /* 23  */
	"EMFILE",                /* 24  */
	"ENOTTY",                /* 25  */
	"ETXTBSY",               /* 26  */
	"EFBIG",                 /* 27  */
	"ENOSPC",                /* 28  */
	"ESPIPE",                /* 29  */
	"EROFS",                 /* 30  */
	"EMLINK",                /* 31  */
	"EPIPE",                 /* 32  */
	"EDOM",                  /* 33  */
	"ERANGE",                /* 34  */
	"EDEADLK",               /* 35  */
	"ENAMETOOLONG",          /* 36  */
	"ENOLCK",                /* 37  */
	"ENOSYS",                /* 38  */
	"ENOTEMPTY",             /* 39  */
	"ELOOP",                 /* 40  */
	nullptr,                 /* 41  */
	"ENOMSG",                /* 42  */
	"EIDRM",                 /* 43  */
	"ECHRNG",                /* 44  */
	"EL2NSYNC",              /* 45  */
	"EL3HLT",                /* 46  */
	"EL3RST",                /* 47  */
	"ELNRNG",                /* 48  */
	"EUNATCH",               /* 49  */
	"ENOCSI",                /* 50  */
	"EL2HLT",                /* 51  */
	"EBADE",                 /* 52  */
	"EBADR",                 /* 53  */
	"EXFULL",                /* 54  */
	"ENOANO",                /* 55  */
	"EBADRQC",               /* 56  */
	"EBADSLT",               /* 57  */
	nullptr,                 /* 58  */
	"EBFONT",                /* 59  */
	"ENOSTR",                /* 60  */
	"ENODATA",               /* 61  */
	"ETIME",                 /* 62  */
	"ENOSR",                 /* 63  */
	"ENONET",                /* 64  */
	"ENOPKG",                /* 65  */
	"EREMOTE",               /* 66  */
	"ENOLINK",               /* 67  */
	"EADV",                  /* 68  */
	"ESRMNT",                /* 69  */
	"ECOMM",                 /* 70  */
	"EPROTO",                /* 71  */
	"EMULTIHOP",             /* 72  */
	"EDOTDOT",               /* 73  */
	"EBADMSG",               /* 74  */
	"EOVERFLOW",             /* 75  */
	"ENOTUNIQ",              /* 76  */
	"EBADFD",                /* 77  */
	"EREMCHG",               /* 78  */
	"ELIBACC",               /* 79  */
	"ELIBBAD",               /* 80  */
	"ELIBSCN",               /* 81  */
	"ELIBMAX",               /* 82  */
	"ELIBEXEC",              /* 83  */
	"EILSEQ",                /* 84  */
	"ERESTART",              /* 85  */
	"ESTRPIPE",              /* 86  */
	"EUSERS",                /* 87  */
	"ENOTSOCK",              /* 88  */
	"EDESTADDRREQ",          /* 89  */
	"EMSGSIZE",              /* 90  */
	"EPROTOTYPE",            /* 91  */
	"ENOPROTOOPT",           /* 92  */
	"EPROTONOSUPPORT",       /* 93  */
	"ESOCKTNOSUPPORT",       /* 94  */
	"EOPNOTSUPP",            /* 95  */
	"EPFNOSUPPORT",          /* 96  */
	"EAFNOSUPPORT",          /* 97  */
	"EADDRINUSE",            /* 98  */
	"EADDRNOTAVAIL",         /* 99  */
	"ENETDOWN",              /* 100 */
	"ENETUNREACH",           /* 101 */
	"ENETRESET",             /* 102 */
	"ECONNABORTED",          /* 103 */
	"ECONNRESET",            /* 104 */
	"ENOBUFS",               /* 105 */
	"EISCONN",               /* 106 */
	"ENOTCONN",              /* 107 */
	"ESHUTDOWN",             /* 108 */
	"ETOOMANYREFS",          /* 109 */
	"ETIMEDOUT",             /* 110 */
	"ECONNREFUSED",          /* 111 */
	"EHOSTDOWN",             /* 112 */
	"EHOSTUNREACH",          /* 113 */
	"EALREADY",              /* 114 */
	"EINPROGRESS",           /* 115 */
	"ESTALE",                /* 116 */
	"EUCLEAN",               /* 117 */
	"ENOTNAM",               /* 118 */
	"ENAVAIL",               /* 119 */
	"EISNAM",                /* 120 */
	"EREMOTEIO",             /* 121 */
	"EDQUOT",                /* 122 */
	"ENOMEDIUM",             /* 123 */
	"EMEDIUMTYPE",           /* 124 */
	"ECANCELED",             /* 125 */
	"ENOKEY",                /* 126 */
	"EKEYEXPIRED",           /* 127 */
	"EKEYREVOKED",           /* 128 */
	"EKEYREJECTED",          /* 129 */
	"EOWNERDEAD",            /* 130 */
	"ENOTRECOVERABLE",       /* 131 */
	nullptr,                 /* 132 */
	nullptr,                 /* 133 */
	nullptr,                 /* 134 */
	nullptr,                 /* 135 */
	nullptr,                 /* 136 */
	nullptr,                 /* 137 */
	nullptr,                 /* 138 */
	nullptr,                 /* 139 */
	nullptr,                 /* 140 */
	nullptr,                 /* 141 */
	nullptr,                 /* 142 */
	nullptr,                 /* 143 */
	nullptr,                 /* 144 */
	nullptr,                 /* 145 */
	nullptr,                 /* 146 */
	nullptr,                 /* 147 */
	nullptr,                 /* 148 */
	nullptr,                 /* 149 */
	nullptr,                 /* 150 */
	nullptr,                 /* 151 */
	nullptr,                 /* 152 */
	nullptr,                 /* 153 */
	nullptr,                 /* 154 */
	nullptr,                 /* 155 */
	nullptr,                 /* 156 */
	nullptr,                 /* 157 */
	nullptr,                 /* 158 */
	nullptr,                 /* 159 */
	nullptr,                 /* 160 */
	nullptr,                 /* 161 */
	nullptr,                 /* 162 */
	nullptr,                 /* 163 */
	nullptr,                 /* 164 */
	nullptr,                 /* 165 */
	nullptr,                 /* 166 */
	nullptr,                 /* 167 */
	nullptr,                 /* 168 */
	nullptr,                 /* 169 */
	nullptr,                 /* 170 */
	nullptr,                 /* 171 */
	nullptr,                 /* 172 */
	nullptr,                 /* 173 */
	nullptr,                 /* 174 */
	nullptr,                 /* 175 */
	nullptr,                 /* 176 */
	nullptr,                 /* 177 */
	nullptr,                 /* 178 */
	nullptr,                 /* 179 */
	nullptr,                 /* 180 */
	nullptr,                 /* 181 */
	nullptr,                 /* 182 */
	nullptr,                 /* 183 */
	nullptr,                 /* 184 */
	nullptr,                 /* 185 */
	nullptr,                 /* 186 */
	nullptr,                 /* 187 */
	nullptr,                 /* 188 */
	nullptr,                 /* 189 */
	nullptr,                 /* 190 */
	nullptr,                 /* 191 */
	nullptr,                 /* 192 */
	nullptr,                 /* 193 */
	nullptr,                 /* 194 */
	nullptr,                 /* 195 */
	nullptr,                 /* 196 */
	nullptr,                 /* 197 */
	nullptr,                 /* 198 */
	nullptr,                 /* 199 */
	nullptr,                 /* 200 */
	nullptr,                 /* 201 */
	nullptr,                 /* 202 */
	nullptr,                 /* 203 */
	nullptr,                 /* 204 */
	nullptr,                 /* 205 */
	nullptr,                 /* 206 */
	nullptr,                 /* 207 */
	nullptr,                 /* 208 */
	nullptr,                 /* 209 */
	nullptr,                 /* 210 */
	nullptr,                 /* 211 */
	nullptr,                 /* 212 */
	nullptr,                 /* 213 */
	nullptr,                 /* 214 */
	nullptr,                 /* 215 */
	nullptr,                 /* 216 */
	nullptr,                 /* 217 */
	nullptr,                 /* 218 */
	nullptr,                 /* 219 */
	nullptr,                 /* 220 */
	nullptr,                 /* 221 */
	nullptr,                 /* 222 */
	nullptr,                 /* 223 */
	nullptr,                 /* 224 */
	nullptr,                 /* 225 */
	nullptr,                 /* 226 */
	nullptr,                 /* 227 */
	nullptr,                 /* 228 */
	nullptr,                 /* 229 */
	nullptr,                 /* 230 */
	nullptr,                 /* 231 */
	nullptr,                 /* 232 */
	nullptr,                 /* 233 */
	nullptr,                 /* 234 */
	nullptr,                 /* 235 */
	nullptr,                 /* 236 */
	nullptr,                 /* 237 */
	nullptr,                 /* 238 */
	nullptr,                 /* 239 */
	nullptr,                 /* 240 */
	nullptr,                 /* 241 */
	nullptr,                 /* 242 */
	nullptr,                 /* 243 */
	nullptr,                 /* 244 */
	nullptr,                 /* 245 */
	nullptr,                 /* 246 */
	nullptr,                 /* 247 */
	nullptr,                 /* 248 */
	nullptr,                 /* 249 */
	nullptr,                 /* 250 */
	nullptr,                 /* 251 */
	nullptr,                 /* 252 */
	nullptr,                 /* 253 */
	nullptr,                 /* 254 */
	nullptr,                 /* 255 */
	nullptr,                 /* 256 */
	nullptr,                 /* 257 */
	nullptr,                 /* 258 */
	nullptr,                 /* 259 */
	nullptr,                 /* 260 */
	nullptr,                 /* 261 */
	nullptr,                 /* 262 */
	nullptr,                 /* 263 */
	nullptr,                 /* 264 */
	nullptr,                 /* 265 */
	nullptr,                 /* 266 */
	nullptr,                 /* 267 */
	nullptr,                 /* 268 */
	nullptr,                 /* 269 */
	nullptr,                 /* 270 */
	nullptr,                 /* 271 */
	nullptr,                 /* 272 */
	nullptr,                 /* 273 */
	nullptr,                 /* 274 */
	nullptr,                 /* 275 */
	nullptr,                 /* 276 */
	nullptr,                 /* 277 */
	nullptr,                 /* 278 */
	nullptr,                 /* 279 */
	nullptr,                 /* 280 */
	nullptr,                 /* 281 */
	nullptr,                 /* 282 */
	nullptr,                 /* 283 */
	nullptr,                 /* 284 */
	nullptr,                 /* 285 */
	nullptr,                 /* 286 */
	nullptr,                 /* 287 */
	nullptr,                 /* 288 */
	nullptr,                 /* 289 */
	nullptr,                 /* 290 */
	nullptr,                 /* 291 */
	nullptr,                 /* 292 */
	nullptr,                 /* 293 */
	nullptr,                 /* 294 */
	nullptr,                 /* 295 */
	nullptr,                 /* 296 */
	nullptr,                 /* 297 */
	nullptr,                 /* 298 */
	nullptr,                 /* 299 */
	nullptr,                 /* 300 */
	nullptr,                 /* 301 */
	nullptr,                 /* 302 */
	nullptr,                 /* 303 */
	nullptr,                 /* 304 */
	nullptr,                 /* 305 */
	nullptr,                 /* 306 */
	nullptr,                 /* 307 */
	nullptr,                 /* 308 */
	nullptr,                 /* 309 */
	nullptr,                 /* 310 */
	nullptr,                 /* 311 */
	nullptr,                 /* 312 */
	nullptr,                 /* 313 */
	nullptr,                 /* 314 */
	nullptr,                 /* 315 */
	nullptr,                 /* 316 */
	nullptr,                 /* 317 */
	nullptr,                 /* 318 */
	nullptr,                 /* 319 */
	nullptr,                 /* 320 */
	nullptr,                 /* 321 */
	nullptr,                 /* 322 */
	nullptr,                 /* 323 */
	nullptr,                 /* 324 */
	nullptr,                 /* 325 */
	nullptr,                 /* 326 */
	nullptr,                 /* 327 */
	nullptr,                 /* 328 */
	nullptr,                 /* 329 */
	nullptr,                 /* 330 */
	nullptr,                 /* 331 */
	nullptr,                 /* 332 */
	nullptr,                 /* 333 */
	nullptr,                 /* 334 */
	nullptr,                 /* 335 */
	nullptr,                 /* 336 */
	nullptr,                 /* 337 */
	nullptr,                 /* 338 */
	nullptr,                 /* 339 */
	nullptr,                 /* 340 */
	nullptr,                 /* 341 */
	nullptr,                 /* 342 */
	nullptr,                 /* 343 */
	nullptr,                 /* 344 */
	nullptr,                 /* 345 */
	nullptr,                 /* 346 */
	nullptr,                 /* 347 */
	nullptr,                 /* 348 */
	nullptr,                 /* 349 */
	nullptr,                 /* 350 */
	nullptr,                 /* 351 */
	nullptr,                 /* 352 */
	nullptr,                 /* 353 */
	nullptr,                 /* 354 */
	nullptr,                 /* 355 */
	nullptr,                 /* 356 */
	nullptr,                 /* 357 */
	nullptr,                 /* 358 */
	nullptr,                 /* 359 */
	nullptr,                 /* 360 */
	nullptr,                 /* 361 */
	nullptr,                 /* 362 */
	nullptr,                 /* 363 */
	nullptr,                 /* 364 */
	nullptr,                 /* 365 */
	nullptr,                 /* 366 */
	nullptr,                 /* 367 */
	nullptr,                 /* 368 */
	nullptr,                 /* 369 */
	nullptr,                 /* 370 */
	nullptr,                 /* 371 */
	nullptr,                 /* 372 */
	nullptr,                 /* 373 */
	nullptr,                 /* 374 */
	nullptr,                 /* 375 */
	nullptr,                 /* 376 */
	nullptr,                 /* 377 */
	nullptr,                 /* 378 */
	nullptr,                 /* 379 */
	nullptr,                 /* 380 */
	nullptr,                 /* 381 */
	nullptr,                 /* 382 */
	nullptr,                 /* 383 */
	nullptr,                 /* 384 */
	nullptr,                 /* 385 */
	nullptr,                 /* 386 */
	nullptr,                 /* 387 */
	nullptr,                 /* 388 */
	nullptr,                 /* 389 */
	nullptr,                 /* 390 */
	nullptr,                 /* 391 */
	nullptr,                 /* 392 */
	nullptr,                 /* 393 */
	nullptr,                 /* 394 */
	nullptr,                 /* 395 */
	nullptr,                 /* 396 */
	nullptr,                 /* 397 */
	nullptr,                 /* 398 */
	nullptr,                 /* 399 */
	nullptr,                 /* 400 */
	nullptr,                 /* 401 */
	nullptr,                 /* 402 */
	nullptr,                 /* 403 */
	nullptr,                 /* 404 */
	nullptr,                 /* 405 */
	nullptr,                 /* 406 */
	nullptr,                 /* 407 */
	nullptr,                 /* 408 */
	nullptr,                 /* 409 */
	nullptr,                 /* 410 */
	nullptr,                 /* 411 */
	nullptr,                 /* 412 */
	nullptr,                 /* 413 */
	nullptr,                 /* 414 */
	nullptr,                 /* 415 */
	nullptr,                 /* 416 */
	nullptr,                 /* 417 */
	nullptr,                 /* 418 */
	nullptr,                 /* 419 */
	nullptr,                 /* 420 */
	nullptr,                 /* 421 */
	nullptr,                 /* 422 */
	nullptr,                 /* 423 */
	nullptr,                 /* 424 */
	nullptr,                 /* 425 */
	nullptr,                 /* 426 */
	nullptr,                 /* 427 */
	nullptr,                 /* 428 */
	nullptr,                 /* 429 */
	nullptr,                 /* 430 */
	nullptr,                 /* 431 */
	nullptr,                 /* 432 */
	nullptr,                 /* 433 */
	nullptr,                 /* 434 */
	nullptr,                 /* 435 */
	nullptr,                 /* 436 */
	nullptr,                 /* 437 */
	nullptr,                 /* 438 */
	nullptr,                 /* 439 */
	nullptr,                 /* 440 */
	nullptr,                 /* 441 */
	nullptr,                 /* 442 */
	nullptr,                 /* 443 */
	nullptr,                 /* 444 */
	nullptr,                 /* 445 */
	nullptr,                 /* 446 */
	nullptr,                 /* 447 */
	nullptr,                 /* 448 */
	nullptr,                 /* 449 */
	nullptr,                 /* 450 */
	nullptr,                 /* 451 */
	nullptr,                 /* 452 */
	nullptr,                 /* 453 */
	nullptr,                 /* 454 */
	nullptr,                 /* 455 */
	nullptr,                 /* 456 */
	nullptr,                 /* 457 */
	nullptr,                 /* 458 */
	nullptr,                 /* 459 */
	nullptr,                 /* 460 */
	nullptr,                 /* 461 */
	nullptr,                 /* 462 */
	nullptr,                 /* 463 */
	nullptr,                 /* 464 */
	nullptr,                 /* 465 */
	nullptr,                 /* 466 */
	nullptr,                 /* 467 */
	nullptr,                 /* 468 */
	nullptr,                 /* 469 */
	nullptr,                 /* 470 */
	nullptr,                 /* 471 */
	nullptr,                 /* 472 */
	nullptr,                 /* 473 */
	nullptr,                 /* 474 */
	nullptr,                 /* 475 */
	nullptr,                 /* 476 */
	nullptr,                 /* 477 */
	nullptr,                 /* 478 */
	nullptr,                 /* 479 */
	nullptr,                 /* 480 */
	nullptr,                 /* 481 */
	nullptr,                 /* 482 */
	nullptr,                 /* 483 */
	nullptr,                 /* 484 */
	nullptr,                 /* 485 */
	nullptr,                 /* 486 */
	nullptr,                 /* 487 */
	nullptr,                 /* 488 */
	nullptr,                 /* 489 */
	nullptr,                 /* 490 */
	nullptr,                 /* 491 */
	nullptr,                 /* 492 */
	nullptr,                 /* 493 */
	nullptr,                 /* 494 */
	nullptr,                 /* 495 */
	nullptr,                 /* 496 */
	nullptr,                 /* 497 */
	nullptr,                 /* 498 */
	nullptr,                 /* 499 */
	nullptr,                 /* 500 */
	nullptr,                 /* 501 */
	nullptr,                 /* 502 */
	nullptr,                 /* 503 */
	nullptr,                 /* 504 */
	nullptr,                 /* 505 */
	nullptr,                 /* 506 */
	nullptr,                 /* 507 */
	nullptr,                 /* 508 */
	nullptr,                 /* 509 */
	nullptr,                 /* 510 */
	nullptr,                 /* 511 */
	"ERESTARTSYS",           /* 512 */
	"ERESTARTNOINTR",        /* 513 */
	"ERESTARTNOHAND",        /* 514 */
	"ENOIOCTLCMD",           /* 515 */
	"ERESTART_RESTARTBLOCK", /* 516 */
	nullptr,                 /* 517 */
	nullptr,                 /* 518 */
	nullptr,                 /* 519 */
	nullptr,                 /* 520 */
	"EBADHANDLE",            /* 521 */
	"ENOTSYNC",              /* 522 */
	"EBADCOOKIE",            /* 523 */
	"ENOTSUPP",              /* 524 */
	"ETOOSMALL",             /* 525 */
	"ESERVERFAULT",          /* 526 */
	"EBADTYPE",              /* 527 */
	"EJUKEBOX",              /* 528 */
	"EIOCBQUEUED",           /* 529 */
	"EIOCBRETRY",            /* 530 */
};
}

#endif

```

`src/capstone-edb/Inspection.cpp`:

```cpp

#include "Instruction.h"
#include "util/Container.h"

namespace CapstoneEDB {

bool is_repeat(const Instruction &insn) {
	if (!insn)
		return false;
	const auto &prefixes = insn->detail->x86.prefix;
	return (prefixes[0] == X86_PREFIX_REP || prefixes[0] == X86_PREFIX_REPNE);
}

bool is_terminator(const Instruction &insn) {
	return is_halt(insn) || is_jump(insn) || is_return(insn);
}

bool is_register(const Operand &operand) {
	return operand && static_cast<cs_op_type>(operand->type) == CS_OP_REG;
}

bool is_expression(const Operand &operand) {
	return operand && static_cast<cs_op_type>(operand->type) == CS_OP_MEM;
}

bool is_immediate(const Operand &operand) {
	return operand && static_cast<cs_op_type>(operand->type) == CS_OP_IMM;
}

bool is_halt(const Instruction &insn) {
	return insn && insn.operation() == X86_INS_HLT;
}

bool is_sysenter(const Instruction &insn) {
	return insn && insn.operation() == X86_INS_SYSENTER;
}

bool is_syscall(const Instruction &insn) {
	return insn && insn.operation() == X86_INS_SYSCALL;
}

bool is_interrupt(const Instruction &insn) {
	if (!insn) return false;
	const int op = insn.operation();
	return op == X86_INS_INT || op == X86_INS_INT1 || op == X86_INS_INT3 || op == X86_INS_INTO;
}

bool is_ret(const Instruction &insn) {
	return insn && insn.operation() == X86_INS_RET;
}

bool is_int(const Instruction &insn) {
	return insn && insn.operation() == X86_INS_INT;
}

bool is_nop(const Instruction &insn) {
	if (!insn) return false;
	return insn.operation() == X86_INS_NOP;
}

bool is_conditional_set(const Instruction &insn) {
	if (!insn) return false;

	switch (insn.operation()) {
	case X86_INS_SETAE:
	case X86_INS_SETA:
	case X86_INS_SETBE:
	case X86_INS_SETB:
	case X86_INS_SETE:
	case X86_INS_SETGE:
	case X86_INS_SETG:
	case X86_INS_SETLE:
	case X86_INS_SETL:
	case X86_INS_SETNE:
	case X86_INS_SETNO:
	case X86_INS_SETNP:
	case X86_INS_SETNS:
	case X86_INS_SETO:
	case X86_INS_SETP:
	case X86_INS_SETS:
		return true;
	default:
		return false;
	}
}

bool is_unconditional_jump(const Instruction &insn) {
	return insn && (insn.operation() == X86_INS_JMP || insn.operation() == X86_INS_LJMP);
}

bool is_conditional_jump(const Instruction &insn) {
	if (!insn) return false;

	switch (insn.operation()) {
	case X86_INS_JAE:
	case X86_INS_JA:
	case X86_INS_JBE:
	case X86_INS_JB:
	case X86_INS_JCXZ:
	case X86_INS_JECXZ:
	case X86_INS_JE:
	case X86_INS_JGE:
	case X86_INS_JG:
	case X86_INS_JLE:
	case X86_INS_JL:
	case X86_INS_JNE:
	case X86_INS_JNO:
	case X86_INS_JNP:
	case X86_INS_JNS:
	case X86_INS_JO:
	case X86_INS_JP:
	case X86_INS_JRCXZ:
	case X86_INS_JS:
		return true;
	default:
		return false;
	}
}

bool is_conditional_fpu_move(const Instruction &insn) {
	if (!insn) return false;

	switch (insn.operation()) {
	case X86_INS_FCMOVBE:
	case X86_INS_FCMOVB:
	case X86_INS_FCMOVE:
	case X86_INS_FCMOVNBE:
	case X86_INS_FCMOVNB:
	case X86_INS_FCMOVNE:
	case X86_INS_FCMOVNU:
	case X86_INS_FCMOVU:
		return true;
	default:
		return false;
	}
}

bool is_conditional_gpr_move(const Instruction &insn) {
	if (!insn) return false;

	switch (insn.operation()) {
	case X86_INS_CMOVA:
	case X86_INS_CMOVAE:
	case X86_INS_CMOVB:
	case X86_INS_CMOVBE:
	case X86_INS_CMOVE:
	case X86_INS_CMOVG:
	case X86_INS_CMOVGE:
	case X86_INS_CMOVL:
	case X86_INS_CMOVLE:
	case X86_INS_CMOVNE:
	case X86_INS_CMOVNO:
	case X86_INS_CMOVNP:
	case X86_INS_CMOVNS:
	case X86_INS_CMOVO:
	case X86_INS_CMOVP:
	case X86_INS_CMOVS:
		return true;
	default:
		return false;
	}
}

bool is_fpu(const Instruction &insn) {
	return insn && ((insn->detail->x86.opcode[0] & 0xd8) == 0xd8);
}

bool is_conditional_move(const Instruction &insn) {
	return is_conditional_fpu_move(insn) || is_conditional_gpr_move(insn);
}

bool is_fpu_taking_float(const Instruction &insn) {
	if (!insn)
		return false;

	if (!is_fpu(insn))
		return false;

	const auto modrm = insn->detail->x86.modrm;

	if (modrm > 0xbf)
		return true; // always works with st(i) in this case

	const auto ro = (modrm >> 3) & 7;
	switch (insn->detail->x86.opcode[0]) {
	case 0xd8:
	case 0xdc:
		return true;
	case 0xdb:
		return ro == 5 || ro == 7;
	case 0xd9:
	case 0xdd:
		return ro == 0 || ro == 2 || ro == 3;
	default:
		return false;
	}
}

bool is_fpu_taking_integer(const Instruction &insn) {
	if (!insn)
		return false;
	if (!is_fpu(insn))
		return false;

	const auto modrm = insn->detail->x86.modrm;

	if (modrm > 0xbf)
		return false; // always works with st(i) in this case

	const auto ro = (modrm >> 3) & 7;

	switch (insn->detail->x86.opcode[0]) {
	case 0xda:
		return true;
	case 0xdb:
		return 0 <= ro && ro <= 3;
	case 0xdd:
		return ro == 1;
	case 0xde:
		return true;
	case 0xdf:
		return (0 <= ro && ro <= 3) || ro == 5 || ro == 7;
	default:
		return false;
	}
}

bool is_fpu_taking_bcd(const Instruction &insn) {
	if (!insn)
		return false;
	if (!is_fpu(insn))
		return false;

	const auto modrm = insn->detail->x86.modrm;
	if (modrm > 0xbf)
		return false; // always works with st(i) in this case

	const auto ro = (modrm >> 3) & 7;
	return insn->detail->x86.opcode[0] == 0xdf && (ro == 4 || ro == 6);
}

bool is_simd(const Instruction &insn) {
	if (!insn)
		return false;

	const x86_insn_group simdGroups[] = {
		X86_GRP_3DNOW,
		X86_GRP_AVX,
		X86_GRP_AVX2,
		X86_GRP_AVX512,
		X86_GRP_FMA,
		X86_GRP_FMA4,
		X86_GRP_MMX,
		X86_GRP_SSE1,
		X86_GRP_SSE2,
		X86_GRP_SSE3,
		X86_GRP_SSE41,
		X86_GRP_SSE42,
		X86_GRP_SSE4A,
		X86_GRP_SSSE3,
		X86_GRP_XOP,
		X86_GRP_CDI,
		X86_GRP_ERI,
		X86_GRP_PFI,
		X86_GRP_VLX,
		X86_GRP_NOVLX,
	};

	for (auto g = 0; g < insn->detail->groups_count; ++g) {
		if (util::contains(simdGroups, insn->detail->groups[g])) {
			return true;
		}
	}

	return false;
}

}

```

`src/capstone-edb/Instruction.cpp`:

```cpp
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Instruction.h"

#include <QRegExp>
#include <QRegularExpression>
#include <QString>
#include <QStringList>

#include <algorithm>
#include <cassert>
#include <cctype>
#include <cstring>
#include <sstream>
#include <stdexcept>
#include <vector>

namespace CapstoneEDB {

namespace {

constexpr int MaxOperands = 3;

Architecture capstoneArch = Architecture::ARCH_X86;
bool capstoneInitialized  = false;
csh csh                   = 0;
Formatter activeFormatter;

#if defined(EDB_X86) || defined(EDB_X86_64)
/**
 * @brief is_simd_register
 * @param operand
 * @return
 */
bool is_simd_register(const Operand &operand) {

	if (operand->type != X86_OP_REG)
		return false;

	const auto reg = operand->reg;

	if (X86_REG_MM0 <= reg && reg <= X86_REG_MM7)
		return true;
	if (X86_REG_XMM0 <= reg && reg <= X86_REG_XMM31)
		return true;
	if (X86_REG_YMM0 <= reg && reg <= X86_REG_YMM31)
		return true;
	if (X86_REG_ZMM0 <= reg && reg <= X86_REG_ZMM31)
		return true;

	return false;
}

/**
 * @brief apriori_not_simd
 * @param insn
 * @param operand
 * @return
 */
bool apriori_not_simd(const Instruction &insn, const Operand &operand) {

	if (!is_simd(insn))
		return true;

	if (operand->type == X86_OP_REG && !is_simd_register(operand))
		return true;
	if (operand->type == X86_OP_IMM)
		return true;

	return false;
}

/**
 * @brief KxRegisterPresent
 * @param insn
 * @return
 */
bool KxRegisterPresent(const Instruction &insn) {
	const size_t operandCount = insn.operandCount();

	for (std::size_t i = 0; i < operandCount; ++i) {
		const auto op = insn[i];
		if (op->type == X86_OP_REG && X86_REG_K0 <= op->reg && op->reg <= X86_REG_K7) {
			return true;
		}
	}
	return false;
}

/**
 * @brief simdOperandNormalizedNumberInInstruction
 * @param insn
 * @param operand
 * @param canBeNonSIMD
 * @return
 */
std::size_t simdOperandNormalizedNumberInInstruction(const Instruction &insn, const Operand &operand, bool canBeNonSIMD = false) {

	if (!canBeNonSIMD)
		assert(!apriori_not_simd(insn, operand));

	size_t number             = operand.index();
	const size_t operandCount = insn.operandCount();

	// normalized number is according to Intel order
	if (activeFormatter.options().syntax == Formatter::SyntaxAtt) {
		assert(number < operandCount);
		number = operandCount - 1 - number;
	}

	if (number > 0 && KxRegisterPresent(insn)) {
		--number;
	}

	return number;
}
#endif

/**
 * @brief isX86_64
 * @return
 */
bool isX86_64() {
	return capstoneArch == Architecture::ARCH_AMD64;
}

/**
 * @brief to_operands
 * @param str
 * @return
 */
std::vector<std::string> to_operands(QString str) {

	// Remove any decorations: we want just operands themselves
	static const QRegularExpression re(",?\\{[^}]*\\}");
	str.replace(re, "");

	QStringList betweenCommas = str.split(",");
	std::vector<std::string> operands;

	// Have to work around inconvenient AT&T syntax for SIB, that's why so complicated logic
	for (auto it = betweenCommas.begin(); it != betweenCommas.end(); ++it) {

		QString &current(*it);

		// We've split operand string by commas, but there may be SIB scheme
		// in the form (B,I,S) or (B) or (I,S). Let's find missing parts of it.
		if (it->contains("(") && !it->contains(")")) {

			std::logic_error matchFailed("failed to find matching ')'");

			// the next part must exist and have continuation of SIB scheme
			if (std::next(it) == betweenCommas.end()) {
				throw matchFailed;
			}

			current += ",";
			current += *(++it);

			// This may still be not enough
			if (current.contains("(") && !current.contains(")")) {
				if (std::next(it) == betweenCommas.end()) {
					throw matchFailed;
				}

				current += ",";
				current += *(++it);
			}

			// The expected SIB string has at most three components.
			// If we still haven't found closing parenthesis, we're screwed
			if (current.contains("(") && !current.contains(")")) {
				throw matchFailed;
			}
		}
		operands.push_back(current.trimmed().toStdString());
	}

	if (operands.size() > MaxOperands) {
		throw std::logic_error("got more than " + std::to_string(MaxOperands) + " operands");
	}

	return operands;
}

}

bool init(Architecture arch) {

	capstoneArch = arch;

	if (capstoneInitialized) {
		cs_close(&csh);
	}

	capstoneInitialized = false;

	const cs_err result = [arch]() {
		switch (arch) {
		case Architecture::ARCH_AMD64:
			return cs_open(CS_ARCH_X86, CS_MODE_64, &csh);
		case Architecture::ARCH_X86:
			return cs_open(CS_ARCH_X86, CS_MODE_32, &csh);
		case Architecture::ARCH_ARM32_ARM:
			return cs_open(CS_ARCH_ARM, CS_MODE_ARM, &csh);
		case Architecture::ARCH_ARM32_THUMB:
			return cs_open(CS_ARCH_ARM, CS_MODE_THUMB, &csh);
		case Architecture::ARCH_ARM64:
			return cs_open(CS_ARCH_ARM64, CS_MODE_ARM, &csh);
		default:
			return CS_ERR_ARCH;
		}
	}();

	if (result != CS_ERR_OK) {
		return false;
	}

	capstoneInitialized = true;

	cs_option(csh, CS_OPT_DETAIL, CS_OPT_ON);

	// Set selected formatting options on reinit
	activeFormatter.setOptions(activeFormatter.options());
	return true;
}

Instruction::Instruction(Instruction &&other) noexcept
	: insn_(other.insn_), byte0_(other.byte0_), rva_(other.rva_) {

	other.insn_  = nullptr;
	other.byte0_ = 0;
	other.rva_   = 0;
}

Instruction &Instruction::operator=(Instruction &&rhs) noexcept {
	insn_      = rhs.insn_;
	byte0_     = rhs.byte0_;
	rva_       = rhs.rva_;
	rhs.insn_  = nullptr;
	rhs.byte0_ = 0;
	rhs.rva_   = 0;
	return *this;
}

Instruction::~Instruction() {
	if (insn_) {
		cs_free(insn_, 1);
	}
}

Instruction::Instruction(const void *first, const void *last, uint64_t rva) noexcept
	: rva_(rva) {

	assert(capstoneInitialized);
	auto codeBegin = static_cast<const uint8_t *>(first);
	auto codeEnd   = static_cast<const uint8_t *>(last);

	byte0_ = codeBegin[0];

	cs_insn *insn = nullptr;
	if (first < last && cs_disasm(csh, codeBegin, codeEnd - codeBegin, rva, 1, &insn)) {
		insn_ = insn;
#if defined(EDB_ARM32)
		if (insn_->detail->arm.op_count >= 2) {
			// XXX: this is a work around capstone bug #1013
			auto &op = insn_->detail->arm.operands[1];
			if (op.type == ARM_OP_MEM && op.subtracted && op.mem.scale == 1)
				op.mem.scale = -1;
		}
#endif
	} else {
		insn_ = nullptr;
	}
}

Operand Instruction::operator[](size_t n) const {
	if (!valid())
		return Operand();
	if (n > operandCount())
		return Operand();

#if defined(EDB_X86) || defined(EDB_X86_64)
	return Operand(this, &insn_->detail->x86.operands[n], n);
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	return Operand(this, &insn_->detail->arm.operands[n], n);
#else
#error "What to return here?"
#endif
}

Operand Instruction::operand(size_t n) const {
	if (!valid())
		return Operand();
	if (n > operandCount())
		return Operand();

#if defined(EDB_X86) || defined(EDB_X86_64)
	return Operand(this, &insn_->detail->x86.operands[n], n);
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	return Operand(this, &insn_->detail->arm.operands[n], n);
#else
#error "What to return here?"
#endif
}

Instruction::ConditionCode Instruction::conditionCode() const {

#if defined(EDB_X86) || defined(EDB_X86_64)
	switch (operation()) {
	// J*CXZ
	case X86_INS_JRCXZ:
		return CC_RCXZ;
	case X86_INS_JECXZ:
		return CC_ECXZ;
	case X86_INS_JCXZ:
		return CC_CXZ;
	// FPU conditional move
	case X86_INS_FCMOVBE:
		return CC_BE;
	case X86_INS_FCMOVB:
		return CC_B;
	case X86_INS_FCMOVE:
		return CC_E;
	case X86_INS_FCMOVNBE:
		return CC_NBE;
	case X86_INS_FCMOVNB:
		return CC_NB;
	case X86_INS_FCMOVNE:
		return CC_NE;
	case X86_INS_FCMOVNU:
		return CC_NP;
	case X86_INS_FCMOVU:
		return CC_P;
	// TODO: handle LOOPcc, REPcc OP
	default:
		if (is_conditional_gpr_move(*this) || is_conditional_jump(*this) || is_conditional_set(*this)) {
			const uint8_t *opcode = insn_->detail->x86.opcode;
			if (opcode[0] == 0x0f)
				return static_cast<ConditionCode>(opcode[1] & 0xf);
			return static_cast<ConditionCode>(opcode[0] & 0xf);
		}
	}
	return CC_UNCONDITIONAL;
#elif defined(EDB_ARM32)
	switch (insn_->detail->arm.cc) {
	case ARM_CC_EQ:
		return CC_EQ;
	case ARM_CC_NE:
		return CC_NE;
	case ARM_CC_HS:
		return CC_HS;
	case ARM_CC_LO:
		return CC_LO;
	case ARM_CC_MI:
		return CC_MI;
	case ARM_CC_PL:
		return CC_PL;
	case ARM_CC_VS:
		return CC_VS;
	case ARM_CC_VC:
		return CC_VC;
	case ARM_CC_HI:
		return CC_HI;
	case ARM_CC_LS:
		return CC_LS;
	case ARM_CC_GE:
		return CC_GE;
	case ARM_CC_LT:
		return CC_LT;
	case ARM_CC_GT:
		return CC_GT;
	case ARM_CC_LE:
		return CC_LE;
	case ARM_CC_AL:
		return CC_AL;
	default:
		return CC_AL;
	}
#else
#error "Not implemented"
#endif
}

void Instruction::swap(Instruction &other) {
	using std::swap;
	swap(insn_, other.insn_);
	swap(byte0_, other.byte0_);
	swap(rva_, other.rva_);
}

QString Formatter::adjustInstructionText(const Instruction &insn) const {

	QString operands(insn->op_str);

	// Remove extra spaces
	operands.replace(" + ", "+");
	operands.replace(" - ", "-");

	operands.replace(QRegExp("\\bxword "), "tbyte ");
	operands.replace(QRegExp("(word|byte) ptr "), "\\1 ");

#if defined(EDB_X86) || defined(EDB_X86_64)
	if (activeFormatter.options().simplifyRIPRelativeTargets && isX86_64() && (insn->detail->x86.modrm & 0xc7) == 0x05) {
		QRegExp ripRel("\\brip ?[+-] ?((0x)?[0-9a-fA-F]+)\\b");
		operands.replace(ripRel, "rel 0x" + QString::number(insn->detail->x86.disp + insn->address + insn->size, 16));
	}

	if (insn.operandCount() == 2 && insn->id != X86_INS_MOVZX && insn->id != X86_INS_MOVSX &&
		((insn[0]->type == X86_OP_REG && insn[1]->type == X86_OP_MEM) || (insn[1]->type == X86_OP_REG && insn[0]->type == X86_OP_MEM))) {
		operands.replace(QRegExp("(\\b.?(mm)?word|byte)\\b( ptr)? "), "");
	}
#endif
	return operands;
}

void Formatter::setOptions(const Formatter::FormatOptions &options) {
	assert(capstoneInitialized);

	options_ = options;

#if defined(EDB_X86) || defined(EDB_X86_64)
	if (options.syntax == SyntaxAtt) {
		cs_option(csh, CS_OPT_SYNTAX, CS_OPT_SYNTAX_ATT);
	} else {
		cs_option(csh, CS_OPT_SYNTAX, CS_OPT_SYNTAX_INTEL);
	}
#elif defined(EDB_ARM32) // FIXME(ARM): does this apply to AArch64?
	// TODO: make this optional. Don't forget to reflect this in register view!
	cs_option(csh, CS_OPT_SYNTAX, CS_OPT_SYNTAX_NOREGNAME);
#endif

	activeFormatter = *this;
}

std::string Formatter::toString(const Instruction &insn) const {

	enum {
		Tab1Size = 8,
		Tab2Size = 11,
	};

	if (!insn) {
		char buf[32];
		if (options_.tabBetweenMnemonicAndOperands) {
			snprintf(buf, sizeof(buf), "%-*s0x%02x", Tab1Size, "db", insn.byte0_);
		} else {
			snprintf(buf, sizeof(buf), "db 0x%02x", insn.byte0_);
		}

		std::string str(buf);
		checkCapitalize(str);
		return str;
	}

	std::ostringstream s;
	s << insn->mnemonic;
	std::string space = " ";
	if (options_.tabBetweenMnemonicAndOperands) {
		const auto pos = s.tellp();
		const auto pad = pos < Tab1Size ? Tab1Size - pos : pos < Tab2Size ? Tab2Size - pos
																		  : 1;
		space          = std::string(pad, ' ');
	}
	if (insn.operandCount() > 0) // prevent addition of trailing whitespace
	{
		s << space << adjustInstructionText(insn).toStdString();
	} else if (insn->op_str[0] != 0) {
		// This may happen for instructions like IT in Thumb-2: e.g. ITT NE
		s << space << insn->op_str;
	}

	auto str = s.str();
	checkCapitalize(str);
	return str;
}

void Formatter::checkCapitalize(std::string &str, bool canContainHex) const {
	if (options_.capitalization == UpperCase) {
		std::transform(str.begin(), str.end(), str.begin(), ::toupper);
		if (canContainHex) {
			QString qstr = QString::fromStdString(str);

			const QRegularExpression re("\\b0X([0-9A-F]+)\\b");
			qstr.replace(re, "0x\\1");

			str = qstr.toStdString();
		}
	}
}

std::string Formatter::toString(const Operand &operand) const {
	if (!operand)
		return "(bad)";

	std::string str;

	const Instruction &insn = *operand.owner();

	const std::size_t totalOperands       = insn.operandCount();
	const std::size_t numberInInstruction = operand.index();
#if defined(EDB_X86) || defined(EDB_X86_64)
	if (operand->type == X86_OP_REG) {
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	if (operand->type == ARM_OP_REG) {
#endif
		str = registerName(operand->reg);
	} else if (totalOperands == 1) {
		str = insn->op_str;
	} else {
		// Capstone doesn't provide a way to get operand string, so we try
		// to extract it from the formatted all-operands string
		try {
			const auto operands = to_operands(insn->op_str);

			if (operands.size() <= numberInInstruction) {
				throw std::logic_error("got less than " + std::to_string(numberInInstruction) + " operands");
			}

			str = operands[numberInInstruction];
		} catch (const std::logic_error &error) {
			return std::string("(error splitting operands string: ") + error.what() + ")";
		}
	}

	checkCapitalize(str);
	return str;
}

std::string Formatter::registerName(unsigned int reg) const {
	assert(capstoneInitialized);
	const char *raw = cs_reg_name(csh, reg);
	if (!raw)
		return "(invalid register)";
	std::string str(raw);
	checkCapitalize(str, false);
	return str;
}

bool is_SIMD_PS(const Operand &operand) {
#if defined(EDB_X86) || defined(EDB_X86_64)
	const Instruction &insn = *operand.owner();

	if (apriori_not_simd(insn, operand))
		return false;

	const auto number = simdOperandNormalizedNumberInInstruction(insn, operand);

	switch (insn->id) {
	case X86_INS_ADDPS:
	case X86_INS_VADDPS:
	case X86_INS_ADDSUBPS:
	case X86_INS_VADDSUBPS:
	case X86_INS_ANDNPS:
	case X86_INS_VANDNPS:
	case X86_INS_ANDPS:
	case X86_INS_VANDPS:
	case X86_INS_BLENDPS:  // imm8 isn't a SIMD reg, so ok
	case X86_INS_VBLENDPS: // imm8 isn't a SIMD reg, so ok
	case X86_INS_CMPPS:    // imm8 isn't a SIMD reg, so ok
	case X86_INS_VCMPPS:   // imm8 isn't a SIMD reg, so ok
	case X86_INS_DIVPS:
	case X86_INS_VDIVPS:
	case X86_INS_DPPS:       // imm8 isn't a SIMD reg, so ok
	case X86_INS_VDPPS:      // imm8 isn't a SIMD reg, so ok
	case X86_INS_INSERTPS:   // imm8 isn't a SIMD reg, so ok
	case X86_INS_VINSERTPS:  // imm8 isn't a SIMD reg, so ok
	case X86_INS_EXTRACTPS:  // imm8 isn't a SIMD reg, so ok
	case X86_INS_VEXTRACTPS: // imm8 isn't a SIMD reg, so ok
	case X86_INS_MOVAPS:
	case X86_INS_VMOVAPS:
	case X86_INS_ORPS:
	case X86_INS_VORPS:
	case X86_INS_XORPS:
	case X86_INS_VXORPS:
	case X86_INS_HADDPS:
	case X86_INS_VHADDPS:
	case X86_INS_HSUBPS:
	case X86_INS_VHSUBPS:
	case X86_INS_MAXPS:
	case X86_INS_VMAXPS:
	case X86_INS_MINPS:
	case X86_INS_VMINPS:
	case X86_INS_MOVHLPS:
	case X86_INS_VMOVHLPS:
	case X86_INS_MOVHPS:
	case X86_INS_VMOVHPS:
	case X86_INS_MOVLHPS:
	case X86_INS_VMOVLHPS:
	case X86_INS_MOVLPS:
	case X86_INS_VMOVLPS:
	case X86_INS_MOVMSKPS:  // GPR isn't a SIMD reg, so ok
	case X86_INS_VMOVMSKPS: // GPR isn't a SIMD reg, so ok
	case X86_INS_MOVNTPS:
	case X86_INS_VMOVNTPS:
	case X86_INS_MOVUPS:
	case X86_INS_VMOVUPS:
	case X86_INS_MULPS:
	case X86_INS_VMULPS:
	case X86_INS_RCPPS:
	case X86_INS_VRCPPS:
	case X86_INS_ROUNDPS:  // imm8 isn't a SIMD reg, so ok
	case X86_INS_VROUNDPS: // imm8 isn't a SIMD reg, so ok
	case X86_INS_RSQRTPS:
	case X86_INS_VRSQRTPS:
	case X86_INS_SHUFPS:  // imm8 isn't a SIMD reg, so ok
	case X86_INS_VSHUFPS: // imm8 isn't a SIMD reg, so ok
	case X86_INS_SQRTPS:
	case X86_INS_VSQRTPS:
	case X86_INS_SUBPS:
	case X86_INS_VSUBPS:
	case X86_INS_UNPCKHPS:
	case X86_INS_VUNPCKHPS:
	case X86_INS_UNPCKLPS:
	case X86_INS_VUNPCKLPS:
	case X86_INS_VBLENDMPS:
#if CS_API_MAJOR >= 4
	case X86_INS_VCOMPRESSPS:
	case X86_INS_VEXP2PS:
	case X86_INS_VEXPANDPS:
#endif
	case X86_INS_VFMADD132PS:
	case X86_INS_VFMADD213PS:
	case X86_INS_VFMADD231PS:
	case X86_INS_VFMADDPS: // FMA4 (AMD). XMM/YMM/mem operands only, ok
	case X86_INS_VFMADDSUB132PS:
	case X86_INS_VFMADDSUB213PS:
	case X86_INS_VFMADDSUB231PS:
	case X86_INS_VFMADDSUBPS:
	case X86_INS_VFMSUB132PS:
	case X86_INS_VFMSUBADD132PS:
	case X86_INS_VFMSUBADD213PS:
	case X86_INS_VFMSUBADD231PS:
	case X86_INS_VFMSUBADDPS: // FMA4 (AMD). Seems to have only XMM/YMM/mem operands (?)
	case X86_INS_VFMSUB213PS:
	case X86_INS_VFMSUB231PS:
	case X86_INS_VFMSUBPS: // FMA4?
	case X86_INS_VFNMADD132PS:
	case X86_INS_VFNMADD213PS:
	case X86_INS_VFNMADD231PS:
	case X86_INS_VFNMADDPS: // FMA4?
	case X86_INS_VFNMSUB132PS:
	case X86_INS_VFNMSUB213PS:
	case X86_INS_VFNMSUB231PS:
	case X86_INS_VFNMSUBPS: // FMA4?
	case X86_INS_VFRCZPS:
	case X86_INS_VRCP14PS:
	case X86_INS_VRCP28PS:
	case X86_INS_VRNDSCALEPS:
	case X86_INS_VRSQRT14PS:
	case X86_INS_VRSQRT28PS:
	case X86_INS_VTESTPS:
		return true;

	case X86_INS_VGATHERDPS:
	case X86_INS_VGATHERQPS:
		// second operand is VSIB, it's not quite PS;
		// third operand, if present (VEX-encoded version) is mask
		return number == 0;
	case X86_INS_VGATHERPF0DPS:
	case X86_INS_VGATHERPF0QPS:
	case X86_INS_VGATHERPF1DPS:
	case X86_INS_VGATHERPF1QPS:
	case X86_INS_VSCATTERPF0DPS:
	case X86_INS_VSCATTERPF0QPS:
	case X86_INS_VSCATTERPF1DPS:
	case X86_INS_VSCATTERPF1QPS:
		return false; // VSIB is not quite PS
	case X86_INS_VSCATTERDPS:
	case X86_INS_VSCATTERQPS:
		return number == 1; // first operand is VSIB, it's not quite PS

	case X86_INS_CVTDQ2PS:
	case X86_INS_VCVTDQ2PS:
	case X86_INS_CVTPD2PS:
	case X86_INS_VCVTPD2PS:
	case X86_INS_CVTPI2PS:
	case X86_INS_VCVTPH2PS:
	case X86_INS_VCVTUDQ2PS:
		return number == 0;
	case X86_INS_CVTPS2DQ:
	case X86_INS_VCVTPS2DQ:
	case X86_INS_CVTPS2PD:
	case X86_INS_VCVTPS2PD:
	case X86_INS_CVTPS2PI:
	case X86_INS_VCVTPS2PH:
	// case X86_INS_VCVTPS2QQ: // FIXME: Capstone seems to not support it
	case X86_INS_VCVTPS2UDQ:
		// case X86_INS_VCVTPS2UQQ: // FIXME: Capstone seems to not support it
		return number == 1;
	case X86_INS_BLENDVPS: // third operand (<XMM0> in docs) is mask
		return number != 2;
	case X86_INS_VBLENDVPS: // fourth operand (xmm4 in docs) is mask
		return number != 3;
	case X86_INS_VMASKMOVPS: // second (but not third) operand is mask
		return number != 1;
	case X86_INS_VPERMI2PS: // first operand is indices
		return number != 0;
	case X86_INS_VPERMILPS: // third operand is control (can be [xyz]mm register or imm8)
		return number != 2;
	case X86_INS_VPERMT2PS: // second operand is indices
	case X86_INS_VPERMPS:   // second operand is indices
		return number != 1;
	case X86_INS_VPERMIL2PS: // XOP (AMD). Fourth operand is selector
		return number != 3;
	case X86_INS_VRCPSS:
	case X86_INS_VRCP14SS:
	case X86_INS_VRCP28SS:
	case X86_INS_VROUNDSS:
	case X86_INS_VRSQRTSS:
	case X86_INS_VSQRTSS:
	case X86_INS_VRNDSCALESS:
	case X86_INS_VRSQRT14SS:
	case X86_INS_VRSQRT28SS:
	case X86_INS_VCVTSD2SS:
	case X86_INS_VCVTSI2SS:
	case X86_INS_VCVTUSI2SS:
		// These are SS, but high PS are copied from second operand to first.
		// I.e. second operand is PS, and thus first one (destination) is also PS.
		// Only third operand is actually SS.
		return number < 2;
	case X86_INS_VBROADCASTSS: // dest is PS, src is SS
		return number == 0;

	default:
		return false;
	}
#else
	(void)operand;
	return false;
#endif
}

bool is_SIMD_PD(const Operand &operand) {

#if defined(EDB_X86) || defined(EDB_X86_64)
	const Instruction &insn = *operand.owner();

	if (apriori_not_simd(insn, operand))
		return false;

	const auto number = simdOperandNormalizedNumberInInstruction(insn, operand);

	switch (insn->id) {
	case X86_INS_ADDPD:
	case X86_INS_VADDPD:
	case X86_INS_ADDSUBPD:
	case X86_INS_VADDSUBPD:
	case X86_INS_ANDNPD:
	case X86_INS_VANDNPD:
	case X86_INS_ANDPD:
	case X86_INS_VANDPD:
	case X86_INS_BLENDPD:  // imm8 isn't a SIMD reg, so ok
	case X86_INS_VBLENDPD: // imm8 isn't a SIMD reg, so ok
	case X86_INS_CMPPD:    // imm8 isn't a SIMD reg, so ok
	case X86_INS_VCMPPD:   // imm8 isn't a SIMD reg, so ok
	case X86_INS_DIVPD:
	case X86_INS_VDIVPD:
	case X86_INS_DPPD:  // imm8 isn't a SIMD reg, so ok
	case X86_INS_VDPPD: // imm8 isn't a SIMD reg, so ok
	case X86_INS_MOVAPD:
	case X86_INS_VMOVAPD:
	case X86_INS_ORPD:
	case X86_INS_VORPD:
	case X86_INS_XORPD:
	case X86_INS_VXORPD:
	case X86_INS_HADDPD:
	case X86_INS_VHADDPD:
	case X86_INS_HSUBPD:
	case X86_INS_VHSUBPD:
	case X86_INS_MAXPD:
	case X86_INS_VMAXPD:
	case X86_INS_MINPD:
	case X86_INS_VMINPD:
	case X86_INS_MOVHPD:
	case X86_INS_VMOVHPD:
	case X86_INS_MOVLPD:
	case X86_INS_VMOVLPD:
	case X86_INS_MOVMSKPD:  // GPR isn't a SIMD reg, so ok
	case X86_INS_VMOVMSKPD: // GPR isn't a SIMD reg, so ok
	case X86_INS_MOVNTPD:
	case X86_INS_VMOVNTPD:
	case X86_INS_MOVUPD:
	case X86_INS_VMOVUPD:
	case X86_INS_MULPD:
	case X86_INS_VMULPD:
	case X86_INS_ROUNDPD:  // imm8 isn't a SIMD reg, so ok
	case X86_INS_VROUNDPD: // imm8 isn't a SIMD reg, so ok
	case X86_INS_SHUFPD:   // imm8 isn't a SIMD reg, so ok
	case X86_INS_VSHUFPD:  // imm8 isn't a SIMD reg, so ok
	case X86_INS_SQRTPD:
	case X86_INS_VSQRTPD:
	case X86_INS_SUBPD:
	case X86_INS_VSUBPD:
	case X86_INS_UNPCKHPD:
	case X86_INS_VUNPCKHPD:
	case X86_INS_UNPCKLPD:
	case X86_INS_VUNPCKLPD:
	case X86_INS_VBLENDMPD:
#if CS_API_MAJOR >= 4
	case X86_INS_VCOMPRESSPD:
	case X86_INS_VEXP2PD:
	case X86_INS_VEXPANDPD:
#endif
	case X86_INS_VFMADD132PD:
	case X86_INS_VFMADD213PD:
	case X86_INS_VFMADD231PD:
	case X86_INS_VFMADDPD: // FMA4 (AMD). XMM/YMM/mem operands only (?)
	case X86_INS_VFMADDSUB132PD:
	case X86_INS_VFMADDSUB213PD:
	case X86_INS_VFMADDSUB231PD:
	case X86_INS_VFMADDSUBPD:
	case X86_INS_VFMSUB132PD:
	case X86_INS_VFMSUBADD132PD:
	case X86_INS_VFMSUBADD213PD:
	case X86_INS_VFMSUBADD231PD:
	case X86_INS_VFMSUBADDPD: // FMA4 (AMD). Seems to have only XMM/YMM/mem operands (?)
	case X86_INS_VFMSUBPD:    // FMA4?
	case X86_INS_VFMSUB213PD:
	case X86_INS_VFMSUB231PD:
	case X86_INS_VFNMADD132PD:
	case X86_INS_VFNMADDPD: // FMA4?
	case X86_INS_VFNMADD213PD:
	case X86_INS_VFNMADD231PD:
	case X86_INS_VFNMSUB132PD:
	case X86_INS_VFNMSUBPD: // FMA4?
	case X86_INS_VFNMSUB213PD:
	case X86_INS_VFNMSUB231PD:
	case X86_INS_VFRCZPD:
	case X86_INS_VRCP14PD:
	case X86_INS_VRCP28PD:
	case X86_INS_VRNDSCALEPD:
	case X86_INS_VRSQRT14PD:
	case X86_INS_VRSQRT28PD:
	case X86_INS_VTESTPD:
		return true;

	case X86_INS_VGATHERDPD:
	case X86_INS_VGATHERQPD:
		// second operand is VSIB, it's not quite PD;
		// third operand, if present (VEX-encoded version) is mask
		return number == 0;
	case X86_INS_VGATHERPF0DPD:
	case X86_INS_VGATHERPF0QPD:
	case X86_INS_VGATHERPF1DPD:
	case X86_INS_VGATHERPF1QPD:
	case X86_INS_VSCATTERPF0DPD:
	case X86_INS_VSCATTERPF0QPD:
	case X86_INS_VSCATTERPF1DPD:
	case X86_INS_VSCATTERPF1QPD:
		return false; // VSIB is not quite PD
	case X86_INS_VSCATTERDPD:
	case X86_INS_VSCATTERQPD:
		return number == 1; // first operand is VSIB, it's not quite PD

	case X86_INS_CVTDQ2PD:
	case X86_INS_VCVTDQ2PD:
	case X86_INS_CVTPS2PD:
	case X86_INS_VCVTPS2PD:
	case X86_INS_CVTPI2PD:
	case X86_INS_VCVTUDQ2PD:
		return number == 0;
	case X86_INS_CVTPD2DQ:
	case X86_INS_VCVTPD2DQ:
	case X86_INS_CVTPD2PI:
	case X86_INS_CVTPD2PS:
	case X86_INS_VCVTPD2PS:
	// case X86_INS_VCVTPD2QQ: // FIXME: Capstone seems to not support it
	case X86_INS_VCVTPD2UDQ:
		// case X86_INS_VCVTPD2UQQ: // FIXME: Capstone seems to not support it
		return number == 1;
	case X86_INS_BLENDVPD: // third operand is mask
		return number != 2;
	case X86_INS_VBLENDVPD: // fourth operand is mask
		return number != 3;
	case X86_INS_VMASKMOVPD: // second (but not third) operand is mask
		return number != 1;
	case X86_INS_VPERMI2PD: // first operand is indices
		return number != 0;
	case X86_INS_VPERMT2PD: // second operand is indices
		return number != 1;
	case X86_INS_VPERMILPD: // third operand is control (can be [xyz]mm register or imm8)
		return number != 2;
	case X86_INS_VPERMPD: // if third operand is not imm8, then second is indices (always in VPERMPS)
		assert(insn.operandCount() == 3);
		if (insn[2]->type != X86_OP_IMM)
			return number != 1;
		else
			return true;
	case X86_INS_VPERMIL2PD: // XOP (AMD). Fourth operand is selector (?)
		return number != 3;
	case X86_INS_VRCP14SD:
	case X86_INS_VRCP28SD:
	case X86_INS_VROUNDSD:
	case X86_INS_VSQRTSD:
	case X86_INS_VRNDSCALESD:
	case X86_INS_VRSQRT14SD:
	case X86_INS_VRSQRT28SD:
	case X86_INS_VCVTSS2SD:
	case X86_INS_VCVTSI2SD:
	case X86_INS_VCVTUSI2SD:
		// These are SD, but high PD are copied from second operand to first.
		// I.e. second operand is PD, and thus first one (destination) is also PD.
		// Only third operand is actually SD.
		return number < 2;
	case X86_INS_VBROADCASTSD: // dest is PD, src is SD
		return number == 0;
	default:
		return false;
	}
#else
	(void)operand;
	return false;
#endif
}

bool is_SIMD_SS(const Operand &operand) {
#if defined(EDB_X86) || defined(EDB_X86_64)
	const Instruction &insn = *operand.owner();

	if (apriori_not_simd(insn, operand))
		return false;

	const auto number = simdOperandNormalizedNumberInInstruction(insn, operand);

	switch (insn->id) {
	case X86_INS_ADDSS:
	case X86_INS_VADDSS:
	case X86_INS_CMPSS:  // imm8 isn't a SIMD reg, so ok
	case X86_INS_VCMPSS: // imm8 isn't a SIMD reg, so ok
	case X86_INS_COMISS:
	case X86_INS_VCOMISS:
	case X86_INS_DIVSS:
	case X86_INS_VDIVSS:
	case X86_INS_UCOMISS:
	case X86_INS_VUCOMISS:
	case X86_INS_MAXSS:
	case X86_INS_VMAXSS:
	case X86_INS_MINSS:
	case X86_INS_VMINSS:
	case X86_INS_MOVNTSS: // SSE4a (AMD)
	case X86_INS_MOVSS:
	case X86_INS_VMOVSS:
	case X86_INS_MULSS:
	case X86_INS_VMULSS:
	case X86_INS_RCPSS:   // SS, unlike VEX-encoded version
	case X86_INS_RSQRTSS: // SS, unlike VEX-encoded version
	case X86_INS_ROUNDSS: // imm8 isn't a SIMD reg, so ok
	case X86_INS_SQRTSS:  // SS, unlike VEX-encoded version
	case X86_INS_SUBSS:
	case X86_INS_VSUBSS:
	case X86_INS_VFMADD213SS:
	case X86_INS_VFMADD132SS:
	case X86_INS_VFMADD231SS:
	case X86_INS_VFMADDSS: // AMD?
	case X86_INS_VFMSUB213SS:
	case X86_INS_VFMSUB132SS:
	case X86_INS_VFMSUB231SS:
	case X86_INS_VFMSUBSS: // AMD?
	case X86_INS_VFNMADD213SS:
	case X86_INS_VFNMADD132SS:
	case X86_INS_VFNMADD231SS:
	case X86_INS_VFNMADDSS: // AMD?
	case X86_INS_VFNMSUB213SS:
	case X86_INS_VFNMSUB132SS:
	case X86_INS_VFNMSUB231SS:
	case X86_INS_VFNMSUBSS: // AMD?
	case X86_INS_VFRCZSS:   // AMD?
		return true;

	case X86_INS_VCVTSS2SD:
		return number == 2;
	case X86_INS_CVTSS2SD:
	case X86_INS_CVTSS2SI:
	case X86_INS_VCVTSS2SI:
	case X86_INS_VCVTSS2USI:
		return number == 1;
	case X86_INS_CVTSD2SS: // SS, unlike VEX-encoded version
	case X86_INS_CVTSI2SS: // SS, unlike VEX-encoded version
		return number == 0;
	case X86_INS_VCVTSD2SS:
	case X86_INS_VCVTSI2SS:
	case X86_INS_VCVTUSI2SS:
		// These instructions are SS, but high PS are copied from second operand to first,
		// so second operand is PS, thus first too. Third operand is not SS by its meaning.
		return false;
	case X86_INS_VRCPSS:
	case X86_INS_VRCP14SS:
	case X86_INS_VRCP28SS:
	case X86_INS_VROUNDSS:
	case X86_INS_VRSQRTSS:
	case X86_INS_VSQRTSS:
	case X86_INS_VRNDSCALESS:
	case X86_INS_VRSQRT14SS:
	case X86_INS_VRSQRT28SS:
		// These are SS, but high PS are copied from second operand to first.
		// I.e. second operand is PS, and thus first one (destination) is also PS.
		// Only third operand is actually SS.
		return number == 2;
	case X86_INS_VBROADCASTSS: // dest is PS, src is SS
		return number == 1;
	default:
		return false;
	}
#else
	(void)operand;
	return false;
#endif
}

bool is_SIMD_SD(const Operand &operand) {

#if defined(EDB_X86) || defined(EDB_X86_64)
	const Instruction &insn = *operand.owner();

	if (apriori_not_simd(insn, operand))
		return false;

	const auto number = simdOperandNormalizedNumberInInstruction(insn, operand);

	switch (insn->id) {
	case X86_INS_ADDSD:
	case X86_INS_VADDSD:
	case X86_INS_CMPSD:  // imm8 isn't a SIMD reg, so ok
	case X86_INS_VCMPSD: // imm8 isn't a SIMD reg, so ok
	case X86_INS_COMISD:
	case X86_INS_VCOMISD:
	case X86_INS_DIVSD:
	case X86_INS_VDIVSD:
	case X86_INS_UCOMISD:
	case X86_INS_VUCOMISD:
	case X86_INS_MAXSD:
	case X86_INS_VMAXSD:
	case X86_INS_MINSD:
	case X86_INS_VMINSD:
	case X86_INS_MOVNTSD: // SSE4a (AMD)
	case X86_INS_MOVSD:
	case X86_INS_VMOVSD:
	case X86_INS_MULSD:
	case X86_INS_VMULSD:
	case X86_INS_ROUNDSD: // imm8 isn't a SIMD reg, so ok
	case X86_INS_SQRTSD:  // SD, unlike VEX-encoded version
	case X86_INS_SUBSD:
	case X86_INS_VSUBSD:
	case X86_INS_VFMADD213SD:
	case X86_INS_VFMADD132SD:
	case X86_INS_VFMADD231SD:
	case X86_INS_VFMADDSD: // AMD?
	case X86_INS_VFMSUB213SD:
	case X86_INS_VFMSUB132SD:
	case X86_INS_VFMSUB231SD:
	case X86_INS_VFMSUBSD: // AMD?
	case X86_INS_VFNMADD213SD:
	case X86_INS_VFNMADD132SD:
	case X86_INS_VFNMADD231SD:
	case X86_INS_VFNMADDSD: // AMD?
	case X86_INS_VFNMSUB213SD:
	case X86_INS_VFNMSUB132SD:
	case X86_INS_VFNMSUB231SD:
	case X86_INS_VFNMSUBSD: // AMD?
	case X86_INS_VFRCZSD:   // AMD?
		return true;

	case X86_INS_VCVTSD2SS:
		return number == 2;
	case X86_INS_CVTSD2SS:
	case X86_INS_CVTSD2SI:
	case X86_INS_VCVTSD2SI:
	case X86_INS_VCVTSD2USI:
		return number == 1;
	case X86_INS_CVTSS2SD: // SD, unlike VEX-encoded version
	case X86_INS_CVTSI2SD: // SD, unlike VEX-encoded version
		return number == 0;
	case X86_INS_VCVTSS2SD:
	case X86_INS_VCVTSI2SD:
	case X86_INS_VCVTUSI2SD:
		// These instructions are SD, but high PD are copied from second operand to first,
		// so second operand is PD, thus first too. Third operand is not SD by its meaning.
		return false;
	case X86_INS_VRCP14SD:
	case X86_INS_VRCP28SD:
	case X86_INS_VROUNDSD:
	case X86_INS_VSQRTSD:
	case X86_INS_VRNDSCALESD:
	case X86_INS_VRSQRT14SD:
	case X86_INS_VRSQRT28SD:
		// These are SD, but high PD are copied from second operand to first.
		// I.e. second operand is PD, and thus first one (destination) is also PD.
		// Only third operand is actually SD.
		return number == 2;
	case X86_INS_VBROADCASTSD: // dest is PD, src is SD
		return number == 1;
	default:
		return false;
	}
#else
	(void)operand;
	return false;
#endif
}

bool is_SIMD_SI(const Operand &operand) {

#if defined(EDB_X86) || defined(EDB_X86_64)
	const Instruction &insn = *operand.owner();
	const auto number       = simdOperandNormalizedNumberInInstruction(insn, operand, true);

	switch (insn->id) {
	case X86_INS_VCVTSI2SS:
	case X86_INS_VCVTSI2SD:
		return number == 2;
	case X86_INS_CVTSI2SS:
	case X86_INS_CVTSI2SD:
		return number == 1;
	case X86_INS_CVTSS2SI:
	case X86_INS_VCVTSS2SI:
	case X86_INS_CVTSD2SI:
	case X86_INS_VCVTSD2SI:
		return number == 0;
	default:
		return false;
	}
#else
	(void)operand;
	return false;
#endif
}

bool is_SIMD_USI(const Operand &operand) {
#if defined(EDB_X86) || defined(EDB_X86_64)
	const Instruction &insn = *operand.owner();
	const auto number       = simdOperandNormalizedNumberInInstruction(insn, operand, true);

	switch (insn->id) {
	case X86_INS_VCVTUSI2SS:
	case X86_INS_VCVTUSI2SD:
		return number == 2;
	case X86_INS_VCVTSS2USI:
	case X86_INS_VCVTSD2USI:
		return number == 0;
	default:
		return false;
	}
#else
	(void)operand;
	return false;
#endif
}

bool is_return(const Instruction &insn) {
	if (!insn) return false;
	return cs_insn_group(csh, insn.native(), CS_GRP_RET);
}

bool is_jump(const Instruction &insn) {
	if (!insn) return false;
	return cs_insn_group(csh, insn.native(), CS_GRP_JUMP);
}

bool is_call(const Instruction &insn) {
	if (!insn) return false;
	return cs_insn_group(csh, insn.native(), CS_GRP_CALL);
}

bool modifies_pc(const Instruction &insn) {
	if (is_call(insn) || is_jump(insn) || is_interrupt(insn))
		return true;
#if defined(EDB_X86) || defined(EDB_X86_64)
	return false;
#elif defined(EDB_ARM32)
	const auto &detail = *insn->detail;
	for (uint8_t i = 0; i < detail.regs_write_count; ++i)
		if (detail.regs_write[i] == ARM_REG_PC)
			return true;
	const auto &arm = detail.arm;
	for (uint8_t i = 0; i < arm.op_count; ++i) {
		const auto &op = arm.operands[i];
#if CS_API_MAJOR >= 4
		if (op.access == CS_AC_WRITE && op.type == CS_OP_REG && op.reg == ARM_REG_PC)
			return true;
#endif
		if (op.type == ARM_OP_MEM && insn.native()->detail->arm.writeback && op.mem.base == ARM_REG_PC)
			return true;
	}
	return false;
#else
#error "Not implemented"
#endif
}

}

```

`src/capstone-edb/include/Formatter.h`:

```h

#ifndef FORMATTER_H_20191119_
#define FORMATTER_H_20191119_

#include "API.h"
#include <string>
class QString;

namespace CapstoneEDB {

class Operand;
class Instruction;

class EDB_EXPORT Formatter {
public:
	enum Syntax {
		SyntaxIntel,
		SyntaxAtt
	};

	enum Capitalization {
		UpperCase,
		LowerCase
	};

	struct FormatOptions {
		Syntax syntax;
		Capitalization capitalization;
		bool tabBetweenMnemonicAndOperands;
		bool simplifyRIPRelativeTargets;
	};

public:
	std::string toString(const Instruction &insn) const;
	std::string toString(const Operand &operand) const;
	std::string registerName(unsigned int reg) const;

	FormatOptions options() const {
		return options_;
	}

	void setOptions(const FormatOptions &options);

private:
	void checkCapitalize(std::string &str, bool canContainHex = true) const;
	QString adjustInstructionText(const Instruction &instruction) const;

private:
	FormatOptions options_ = {SyntaxIntel, LowerCase, false, true};
};

}

#endif

```

`src/capstone-edb/include/Inspection.h`:

```h

#ifndef INSPECTION_H_20191119_
#define INSPECTION_H_20191119_

#include "API.h"

namespace CapstoneEDB {

class Formatter;
class Instruction;
class Operand;

EDB_EXPORT bool modifies_pc(const Instruction &insn);
EDB_EXPORT bool is_call(const Instruction &insn);
EDB_EXPORT bool is_conditional_jump(const Instruction &insn);
EDB_EXPORT bool is_halt(const Instruction &insn);
EDB_EXPORT bool is_jump(const Instruction &insn);
EDB_EXPORT bool is_repeat(const Instruction &insn);
EDB_EXPORT bool is_ret(const Instruction &insn);

// Check that instruction is x86-64 syscall
EDB_EXPORT bool is_syscall(const Instruction &insn);

// Check that instruction is P5 sysenter
EDB_EXPORT bool is_sysenter(const Instruction &insn);

// Check that instruction is any type of return
EDB_EXPORT bool is_return(const Instruction &insn);

// Check for any type of interrupt, including int3 etc.
EDB_EXPORT bool is_interrupt(const Instruction &insn);

// Check that instruction is retn (x86 0xC3)
EDB_EXPORT bool is_ret(const Instruction &insn);

// Check that instruction is int N (x86 0xCD N)
EDB_EXPORT bool is_int(const Instruction &insn);

// Check that instruction is any type of jump
EDB_EXPORT bool is_jump(const Instruction &insn);

EDB_EXPORT bool is_nop(const Instruction &insn);
EDB_EXPORT bool is_conditional_set(const Instruction &insn);
EDB_EXPORT bool is_unconditional_jump(const Instruction &insn);
EDB_EXPORT bool is_conditional_jump(const Instruction &insn);

EDB_EXPORT bool is_terminator(const Instruction &insn);
EDB_EXPORT bool is_unconditional_jump(const Instruction &insn);

EDB_EXPORT bool is_conditional_fpu_move(const Instruction &insn);
EDB_EXPORT bool is_conditional_gpr_move(const Instruction &insn);
EDB_EXPORT bool is_fpu(const Instruction &insn);
EDB_EXPORT bool is_conditional_move(const Instruction &insn);

// Check that instruction is an FPU instruction, taking only floating-point operands
EDB_EXPORT bool is_fpu_taking_float(const Instruction &insn);

// Check that instruction is an FPU instruction, one of operands of which is an integer
EDB_EXPORT bool is_fpu_taking_integer(const Instruction &insn);

// Check that instruction is an FPU instruction, one of operands of which is a packed BCD
EDB_EXPORT bool is_fpu_taking_bcd(const Instruction &insn);

// Check that instruction comes from any SIMD ISA extension
EDB_EXPORT bool is_simd(const Instruction &insn);

EDB_EXPORT bool is_expression(const Operand &operand);
EDB_EXPORT bool is_immediate(const Operand &operand);
EDB_EXPORT bool is_register(const Operand &operand);
EDB_EXPORT bool is_SIMD_PD(const Operand &operand);
EDB_EXPORT bool is_SIMD_PS(const Operand &operand);
EDB_EXPORT bool is_SIMD_SD(const Operand &operand);
EDB_EXPORT bool is_SIMD_SS(const Operand &operand);
EDB_EXPORT bool is_SIMD_SI(const Operand &operand);
EDB_EXPORT bool is_SIMD_USI(const Operand &operand);

}

#endif

```

`src/capstone-edb/include/Instruction.h`:

```h
/*
Copyright (C) 2015 Ruslan Kabatsayev <b7.10110111@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef INSTRUCTION_H_20150908_
#define INSTRUCTION_H_20150908_

#include "API.h"
#include "Formatter.h"
#include "Operand.h"
#include <capstone/capstone.h>
#include <cstdint>
#include <string>

class QString;

namespace CapstoneEDB {

enum class Architecture {
	ARCH_X86,
	ARCH_AMD64,
	ARCH_ARM32_ARM,
	ARCH_ARM32_THUMB,
	ARCH_ARM64
};

bool init(Architecture arch);

class Instruction;
class Formatter;

class EDB_EXPORT Instruction {
	friend class Formatter;
	friend class Operand;

public:
#if defined(EDB_X86) || defined(EDB_X86_64)
	static constexpr std::size_t MaxSize = 15;
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	static constexpr std::size_t MaxSize = 4;
#endif

public:
	Instruction(const void *first, const void *end, uint64_t rva) noexcept;
	Instruction(const Instruction &) = delete;
	Instruction &operator=(const Instruction &) = delete;
	Instruction(Instruction &&) noexcept;
	Instruction &operator=(Instruction &&) noexcept;
	~Instruction();

public:
	bool valid() const {
		return insn_;
	}

	explicit operator bool() const {
		return valid();
	}

public:
	int operation() const { return insn_ ? insn_->id : 0; }
	std::size_t operandCount() const {
#if defined(EDB_X86) || defined(EDB_X86_64)
		return insn_ ? insn_->detail->x86.op_count : 0;
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
		return insn_ ? insn_->detail->arm.op_count : 0;
#else
#error "What to return here?"
#endif
	}
	std::size_t byteSize() const { return insn_ ? insn_->size : 1; }
	uint64_t rva() const { return insn_ ? insn_->address : rva_; }
	std::string mnemonic() const { return insn_ ? insn_->mnemonic : std::string(); }
	const uint8_t *bytes() const { return insn_ ? insn_->bytes : &byte0_; }

public:
	Operand operator[](size_t n) const;
	Operand operand(size_t n) const;

public:
	const cs_insn *native() const {
		return insn_;
	}

public:
	cs_insn *operator->() { return insn_; }
	const cs_insn *operator->() const { return insn_; }

public:
	void swap(Instruction &other);

public:
	enum ConditionCode : uint8_t {
#if defined(EDB_X86) || defined(EDB_X86_64)
		CC_UNCONDITIONAL = 0x10, // value must be higher than 0xF
		CC_CXZ,
		CC_ECXZ,
		CC_RCXZ,

		CC_B   = 2,
		CC_C   = CC_B,
		CC_E   = 4,
		CC_Z   = CC_E,
		CC_NA  = 6,
		CC_BE  = CC_NA,
		CC_S   = 8,
		CC_P   = 0xA,
		CC_PE  = CC_P,
		CC_L   = 0xC,
		CC_NGE = CC_L,
		CC_LE  = 0xE,
		CC_NG  = CC_LE,

		CC_NB  = CC_B | 1,
		CC_AE  = CC_NB,
		CC_NE  = CC_E | 1,
		CC_NZ  = CC_NE,
		CC_A   = CC_NA | 1,
		CC_NBE = CC_A,
		CC_NS  = CC_S | 1,
		CC_NP  = CC_P | 1,
		CC_PO  = CC_NP,
		CC_NL  = CC_L | 1,
		CC_GE  = CC_NL,
		CC_NLE = CC_LE | 1,
		CC_G   = CC_NLE
#elif defined(EDB_ARM32)
		CC_EQ = 0,
		CC_NE,
		CC_HS,
		CC_LO,
		CC_MI,
		CC_PL,
		CC_VS,
		CC_VC,
		CC_HI,
		CC_LS,
		CC_GE,
		CC_LT,
		CC_GT,
		CC_LE,
		CC_AL,
#else
#error "Not implemented"
#endif
	};

	ConditionCode conditionCode() const;

private:
	cs_insn *insn_ = nullptr;

	// we have our own copies of this data so we can give something meaningful
	// even during a failed disassembly
	uint8_t byte0_ = 0;
	uint64_t rva_  = 0;
};

}

#include "Inspection.h"

#endif

```

`src/capstone-edb/include/Operand.h`:

```h

#ifndef OPERAND_H_20191119_
#define OPERAND_H_20191119_

#include <capstone/capstone.h>

namespace CapstoneEDB {

class Formatter;
class Instruction;

// NOTE(eteran): Operand is a non-owning class that exists for API purposes
//               it doesn't make sense to store instances of it long term as
//               they are only valid as long as the associated Instruction
//               object is
class Operand {
	friend class Formatter;
	friend class Instruction;

#if defined(EDB_X86) || defined(EDB_X86_64)
	using op_type = cs_x86_op;
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
	using op_type = cs_arm_op;
#endif

private:
	Operand(const Instruction *instruction, op_type *operand, size_t index)
		: owner_(instruction), operand_(operand), index_(index) {
	}

public:
	Operand()                = default;
	Operand(const Operand &) = default;
	Operand &operator=(const Operand &) = default;
	~Operand()                          = default;

public:
	bool valid() const { return operand_; }
	explicit operator bool() const { return valid(); }
	const op_type *operator->() const { return operand_; }
	const op_type *native() const { return operand_; }
	size_t index() const { return index_; }

public:
	const Instruction *owner() const {
		return owner_;
	}

private:
	const Instruction *owner_ = nullptr;
	op_type *operand_         = nullptr;
	size_t index_             = 0;
};

}

#endif

```

`src/edb.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "edb.h"
#include "ArchProcessor.h"
#include "BinaryString.h"
#include "Configuration.h"
#include "DebugEventHandlers.h"
#include "Debugger.h"
#include "DebuggerInternal.h"
#include "DialogInputBinaryString.h"
#include "DialogInputValue.h"
#include "DialogOptions.h"
#include "Expression.h"
#include "ExpressionDialog.h"
#include "IBreakpoint.h"
#include "IDebugger.h"
#include "IPlugin.h"
#include "IProcess.h"
#include "IRegion.h"
#include "IThread.h"
#include "MemoryRegions.h"
#include "Prototype.h"
#include "QHexView"
#include "QtHelper.h"
#include "State.h"
#include "Symbol.h"
#include "SymbolManager.h"
#include "version.h"

#include <QAction>
#include <QAtomicPointer>
#include <QByteArray>
#include <QCompleter>
#include <QCoreApplication>
#include <QCryptographicHash>
#include <QDomDocument>
#include <QFile>
#include <QFileInfo>
#include <QMessageBox>

#include <QDebug>
#include <cctype>

IDebugger *edb::v1::debugger_core = nullptr;
QWidget *edb::v1::debugger_ui     = nullptr;

namespace edb {

Q_DECLARE_NAMESPACE_TR(edb)

namespace {

using BinaryInfoList = QList<IBinary::create_func_ptr_t>;

DebugEventHandlers g_DebugEventHandlers;
QAtomicPointer<IAnalyzer> g_Analyzer = nullptr;
QMap<QString, QObject *> g_GeneralPlugins;
BinaryInfoList g_BinaryInfoList;
CapstoneEDB::Formatter g_Formatter;

QHash<QString, edb::Prototype> g_FunctionDB;

Debugger *ui() {
	return qobject_cast<Debugger *>(edb::v1::debugger_ui);
}

bool function_symbol_base(edb::address_t address, QString *value, int *offset) {

	Q_ASSERT(value);
	Q_ASSERT(offset);

	if (const std::shared_ptr<Symbol> s = edb::v1::symbol_manager().findNearSymbol(address)) {
		*value  = s->name;
		*offset = address - s->address;
		return true;
	}

	*offset = 0;
	return false;
}
}

namespace internal {

//------------------------------------------------------------------------------
// Name: register_plugin
// Desc:
//------------------------------------------------------------------------------
bool register_plugin(const QString &filename, QObject *plugin) {
	if (!g_GeneralPlugins.contains(filename)) {
		g_GeneralPlugins[filename] = plugin;
		return true;
	}

	return false;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
void load_function_db() {
	QFile file(":/debugger/xml/functions.xml");
	QDomDocument doc;

	if (file.open(QIODevice::ReadOnly)) {
		if (doc.setContent(&file)) {
			QDomElement root     = doc.firstChildElement("functions");
			QDomElement function = root.firstChildElement("function");
			for (; !function.isNull(); function = function.nextSiblingElement("function")) {

				Prototype func;
				func.name     = function.attribute("name");
				func.type     = function.attribute("type");
				func.noreturn = function.attribute("noreturn", "false") == "true";

				QDomElement argument = function.firstChildElement("argument");
				for (; !argument.isNull(); argument = argument.nextSiblingElement("argument")) {

					Argument arg;
					arg.name = argument.attribute("name");
					arg.type = argument.attribute("type");
					func.arguments.push_back(arg);
				}

				g_FunctionDB[func.name] = func;
			}
		}
	}
}

}

namespace v1 {

bool debuggeeIs32Bit() {
	return pointer_size() == sizeof(std::uint32_t);
}
bool debuggeeIs64Bit() {
	return pointer_size() == sizeof(std::uint64_t);
}

//------------------------------------------------------------------------------
// Name: set_cpu_selected_address
// Desc:
//------------------------------------------------------------------------------
void set_cpu_selected_address(address_t address) {
	ui()->cpuView_->setSelectedAddress(address);
	ui()->cpuView_->update();
}

//------------------------------------------------------------------------------
// Name: cpu_selected_address
// Desc:
//------------------------------------------------------------------------------
address_t cpu_selected_address() {
	return ui()->cpuView_->selectedAddress();
}

//------------------------------------------------------------------------------
// Name: current_cpu_view_region
// Desc:
//------------------------------------------------------------------------------
std::shared_ptr<IRegion> current_cpu_view_region() {
	return ui()->cpuView_->region();
}

//------------------------------------------------------------------------------
// Name: repaint_cpu_view
// Desc:
//------------------------------------------------------------------------------
void repaint_cpu_view() {
	Debugger *const gui = ui();
	Q_ASSERT(gui);
	gui->cpuView_->update();
}

//------------------------------------------------------------------------------
// Name: symbol_manager
// Desc:
//------------------------------------------------------------------------------
ISymbolManager &symbol_manager() {
	static SymbolManager g_SymbolManager;
	return g_SymbolManager;
}

//------------------------------------------------------------------------------
// Name: memory_regions
// Desc:
//------------------------------------------------------------------------------
MemoryRegions &memory_regions() {
	static MemoryRegions g_MemoryRegions;
	return g_MemoryRegions;
}

//------------------------------------------------------------------------------
// Name: arch_processor
// Desc:
//------------------------------------------------------------------------------
ArchProcessor &arch_processor() {
	static ArchProcessor g_ArchProcessor;
	return g_ArchProcessor;
}

//------------------------------------------------------------------------------
// Name: set_analyzer
// Desc:
//------------------------------------------------------------------------------
IAnalyzer *set_analyzer(IAnalyzer *p) {
	Q_ASSERT(p);
	return g_Analyzer.fetchAndStoreAcquire(p);
}

//------------------------------------------------------------------------------
// Name: analyzer
// Desc:
//------------------------------------------------------------------------------
IAnalyzer *analyzer() {
#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
	return g_Analyzer.loadRelaxed();
#else
	return g_Analyzer.load();
#endif
}

//------------------------------------------------------------------------------
// Name: execute_debug_event_handlers
// Desc:
//------------------------------------------------------------------------------
EventStatus execute_debug_event_handlers(const std::shared_ptr<IDebugEvent> &e) {
	return g_DebugEventHandlers.execute(e);
}

//------------------------------------------------------------------------------
// Name: add_debug_event_handler
// Desc:
//------------------------------------------------------------------------------
void add_debug_event_handler(IDebugEventHandler *p) {
	g_DebugEventHandlers.add(p);
}

//------------------------------------------------------------------------------
// Name: remove_debug_event_handler
// Desc:
//------------------------------------------------------------------------------
void remove_debug_event_handler(IDebugEventHandler *p) {
	g_DebugEventHandlers.remove(p);
}

//------------------------------------------------------------------------------
// Name: jump_to_address
// Desc: sets the disassembly display to a given address, returning success
//       status
//------------------------------------------------------------------------------
bool jump_to_address(address_t address) {
	Debugger *const gui = ui();
	Q_ASSERT(gui);
	return gui->jumpToAddress(address);
}

//------------------------------------------------------------------------------
// Name: dump_data_range
// Desc: shows a given address through a given end address in the data view,
//       optionally in a new tab
//------------------------------------------------------------------------------
bool dump_data_range(address_t address, address_t end_address, bool new_tab) {
	Debugger *const gui = ui();
	Q_ASSERT(gui);
	return gui->dumpDataRange(address, end_address, new_tab);
}

//------------------------------------------------------------------------------
// Name: dump_data_range
// Desc: shows a given address through a given end address in the data view
//------------------------------------------------------------------------------
bool dump_data_range(address_t address, address_t end_address) {
	return dump_data_range(address, end_address, false);
}

//------------------------------------------------------------------------------
// Name: dump_stack
// Desc:
//------------------------------------------------------------------------------
bool dump_stack(address_t address) {
	return dump_stack(address, true);
}

//------------------------------------------------------------------------------
// Name: dump_stack
// Desc: shows a given address in the stack view
//------------------------------------------------------------------------------
bool dump_stack(address_t address, bool scroll_to) {
	Debugger *const gui = ui();
	Q_ASSERT(gui);
	return gui->dumpStack(address, scroll_to);
}

//------------------------------------------------------------------------------
// Name: dump_data
// Desc: shows a given address in the data view, optionally in a new tab
//------------------------------------------------------------------------------
bool dump_data(address_t address, bool new_tab) {
	Debugger *const gui = ui();
	Q_ASSERT(gui);
	return gui->dumpData(address, new_tab);
}

//------------------------------------------------------------------------------
// Name: dump_data
// Desc: shows a given address in the data view
//------------------------------------------------------------------------------
bool dump_data(address_t address) {
	return dump_data(address, false);
}

//------------------------------------------------------------------------------
// Name: set_breakpoint_condition
// Desc:
//------------------------------------------------------------------------------
void set_breakpoint_condition(address_t address, const QString &condition) {

	if (std::shared_ptr<IBreakpoint> bp = find_breakpoint(address)) {
		bp->condition = condition;
	}
}

//------------------------------------------------------------------------------
// Name: get_breakpoint_condition
// Desc:
//------------------------------------------------------------------------------
QString get_breakpoint_condition(address_t address) {
	QString ret;

	if (std::shared_ptr<IBreakpoint> bp = find_breakpoint(address)) {
		ret = bp->condition;
	}

	return ret;
}

//------------------------------------------------------------------------------
// Name: create_breakpoint
// Desc: adds a breakpoint at a given address
//------------------------------------------------------------------------------
std::shared_ptr<IBreakpoint> create_breakpoint(address_t address) {

	std::shared_ptr<IBreakpoint> bp;

	memory_regions().sync();
	if (std::shared_ptr<IRegion> region = memory_regions().findRegion(address)) {
		int ret = QMessageBox::Yes;

		if (!region->executable() && config().warn_on_no_exec_bp) {
			ret = QMessageBox::question(
				nullptr,
				tr("Suspicious breakpoint"),
				tr("You want to place a breakpoint in a non-executable region.\n"
				   "An INT3 breakpoint set on data will not execute and may cause incorrect results or crashes.\n"
				   "Do you really want to set a breakpoint here?"),
				QMessageBox::Yes | QMessageBox::No);
		} else {
			uint8_t buffer[Instruction::MaxSize + 1];
			if (const int size = get_instruction_bytes(address, buffer)) {
				Instruction inst(buffer, buffer + size, address);
				if (!inst) {
					ret = QMessageBox::question(
						nullptr,
						tr("Suspicious breakpoint"),
						tr("It looks like you may be setting an INT3 breakpoint on data.\n"
						   "An INT3 breakpoint set on data will not execute and may cause incorrect results or crashes.\n"
						   "Do you really want to set a breakpoint here?"),
						QMessageBox::Yes | QMessageBox::No);
				}
			}
		}

		if (ret == QMessageBox::Yes) {
			bp = debugger_core->addBreakpoint(address);
			if (!bp) {
				QMessageBox::critical(
					nullptr,
					tr("Error Setting Breakpoint"),
					tr("Failed to set breakpoint at address %1").arg(address.toPointerString()));
				return bp;
			}
			repaint_cpu_view();
		}

	} else {
		QMessageBox::critical(
			nullptr,
			tr("Error Setting Breakpoint"),
			tr("Sorry, but setting a breakpoint which is not in a valid region is not allowed."));
	}

	return bp;
}

//------------------------------------------------------------------------------
// Name: enable_breakpoint
// Desc:
//------------------------------------------------------------------------------
address_t enable_breakpoint(address_t address) {
	if (address != 0) {
		std::shared_ptr<IBreakpoint> bp = find_breakpoint(address);
		if (bp && bp->enable()) {
			return address;
		}
	}
	return 0;
}

//------------------------------------------------------------------------------
// Name: disable_breakpoint
// Desc:
//------------------------------------------------------------------------------
address_t disable_breakpoint(address_t address) {
	if (address != 0) {
		std::shared_ptr<IBreakpoint> bp = find_breakpoint(address);
		if (bp && bp->disable()) {
			return address;
		}
	}
	return 0;
}

//------------------------------------------------------------------------------
// Name: toggle_breakpoint
// Desc: toggles the existence of a breakpoint at a given address
//------------------------------------------------------------------------------
void toggle_breakpoint(address_t address) {
	if (find_breakpoint(address)) {
		remove_breakpoint(address);
	} else {
		create_breakpoint(address);
	}
}

//------------------------------------------------------------------------------
// Name: remove_breakpoint
// Desc: removes a breakpoint
//------------------------------------------------------------------------------
void remove_breakpoint(address_t address) {
	debugger_core->removeBreakpoint(address);
	repaint_cpu_view();
}

//------------------------------------------------------------------------------
// Name: eval_expression
// Desc:
//------------------------------------------------------------------------------
bool eval_expression(const QString &expression, address_t *value) {

	Q_ASSERT(value);

	Expression<address_t> expr(expression, get_variable, get_value);

	const Result<edb::address_t, ExpressionError> address = expr.evaluate();
	if (address) {
		*value = *address;
		return true;
	} else {
		QMessageBox::critical(debugger_ui, tr("Error In Expression!"), address.error().what());
		return false;
	}
}

//------------------------------------------------------------------------------
// Name: get_expression_from_user
// Desc:
//------------------------------------------------------------------------------
bool get_expression_from_user(const QString &title, const QString &prompt, address_t *value) {

	bool retval      = false;
	auto inputDialog = std::make_unique<ExpressionDialog>(title, prompt, edb::v1::debugger_ui);

	if (inputDialog->exec()) {
		*value = inputDialog->getAddress();
		retval = true;
	}

	return retval;
}

//------------------------------------------------------------------------------
// Name: get_value_from_user
// Desc:
//------------------------------------------------------------------------------
bool get_value_from_user(Register &value) {
	return get_value_from_user(value, tr("Input Value"));
}

//------------------------------------------------------------------------------
// Name: get_value_from_user
// Desc:
//------------------------------------------------------------------------------
bool get_value_from_user(Register &value, const QString &title) {

	static auto dlg = new DialogInputValue(debugger_ui);
	bool ret        = false;

	dlg->setWindowTitle(title);
	dlg->setValue(value);
	if (dlg->exec() == QDialog::Accepted) {
		value.setScalarValue(dlg->value());
		ret = true;
	}

	return ret;
}

//------------------------------------------------------------------------------
// Name: get_binary_string_from_user
// Desc:
//------------------------------------------------------------------------------
bool get_binary_string_from_user(QByteArray &value, const QString &title, int max_length) {

	static auto dlg = new DialogInputBinaryString(debugger_ui);

	bool ret = false;

	dlg->setWindowTitle(title);

	BinaryString *const bs = dlg->binaryString();

	// set the max length BEFORE the value! (or else we truncate incorrectly)
	if (value.length() <= max_length) {
		bs->setMaxLength(max_length);
	}

	bs->setValue(value);

	if (dlg->exec() == QDialog::Accepted) {
		value = bs->value();
		ret   = true;
	}

	return ret;
}

//------------------------------------------------------------------------------
// Name: dialog_options
// Desc: returns a pointer to the options dialog
//------------------------------------------------------------------------------
QPointer<QDialog> dialog_options() {
	static QPointer<QDialog> dialog = new DialogOptions(debugger_ui);
	return dialog;
}

//------------------------------------------------------------------------------
// Name: config
// Desc:
//------------------------------------------------------------------------------
Configuration &config() {
	static Configuration g_Configuration;
	return g_Configuration;
}

//------------------------------------------------------------------------------
// Name: get_human_string_at_address
// Desc: attempts to create a summary of the content at address appropriate for
// display in a user interface.
// Note: strings are comprised of printable characters and whitespace.
// Note: found_length is needed because we replace characters which need an
//       escape char with the escape sequence (thus the resultant string may be
//       longer than the original). found_length is the original length.
//------------------------------------------------------------------------------

bool get_human_string_at_address(address_t address, QString &s) {
	bool ret = false;
	if (address > 0x10000ULL) { // FIXME use page size
		QString string_param;
		int string_length;

		if (get_ascii_string_at_address(address, string_param, edb::v1::config().min_string_length, 256, string_length)) {
			ret = true;
			s.append(
				QString("ASCII \"%1\" ").arg(string_param));
		} else if (get_utf16_string_at_address(address, string_param, edb::v1::config().min_string_length, 256, string_length)) {
			ret = true;
			s.append(
				QString("UTF16 \"%1\" ").arg(string_param));
		}
	}
	return ret;
}

//------------------------------------------------------------------------------
// Name: get_ascii_string_at_address
// Desc: attempts to get a string at a given address whose length is >= min_length
//       and < max_length
// Note: strings are comprised of printable characters and whitespace.
// Note: found_length is needed because we replace characters which need an
//       escape char with the escape sequence (thus the resultant string may be
//       longer than the original). found_length is the original length.
//------------------------------------------------------------------------------
bool get_ascii_string_at_address(address_t address, QString &s, int min_length, int max_length, int &found_length) {

	bool is_string = false;

	if (debugger_core) {
		if (IProcess *process = debugger_core->process()) {
			s.clear();

			if (min_length <= max_length) {
				while (max_length--) {
					char ch;
					if (!process->readBytes(address++, &ch, sizeof(ch))) {
						break;
					}

					const int ascii_char = static_cast<unsigned char>(ch);
					if (ascii_char < 0x80 && (std::isprint(ascii_char) || std::isspace(ascii_char))) {
						s += ch;
					} else {
						break;
					}
				}
			}

			is_string = s.length() >= min_length;

			if (is_string) {
				found_length = s.length();
				s.replace("\r", "\\r");
				s.replace("\n", "\\n");
				s.replace("\t", "\\t");
				s.replace("\v", "\\v");
				s.replace("\"", "\\\"");
			}
		}
	}

	return is_string;
}

//------------------------------------------------------------------------------
// Name: get_utf16_string_at_address
// Desc: attempts to get a string at a given address whose length os >= min_length
//       and < max_length
// Note: strings are comprised of printable characters and whitespace.
// Note: found_length is needed because we replace characters which need an
//       escape char with the escape sequence (thus the resultant string may be
//       longer than the original). found_length is the original length.
//------------------------------------------------------------------------------
bool get_utf16_string_at_address(address_t address, QString &s, int min_length, int max_length, int &found_length) {
	bool is_string = false;
	if (debugger_core) {
		if (IProcess *process = debugger_core->process()) {
			s.clear();

			if (min_length <= max_length) {
				while (max_length--) {

					uint16_t val;
					if (!process->readBytes(address, &val, sizeof(val))) {
						break;
					}

					address += sizeof(val);

					QChar ch(val);

					// for now, we only acknowledge ASCII chars encoded as unicode
					const int ascii_char = ch.toLatin1();
					if (ascii_char >= 0x20 && ascii_char < 0x80) {
						s += ch;
					} else {
						break;
					}
				}
			}

			is_string = s.length() >= min_length;

			if (is_string) {
				found_length = s.length();
				s.replace("\r", "\\r");
				s.replace("\n", "\\n");
				s.replace("\t", "\\t");
				s.replace("\v", "\\v");
				s.replace("\"", "\\\"");
			}
		}
	}
	return is_string;
}

//------------------------------------------------------------------------------
// Name: find_function_symbol
// Desc:
//------------------------------------------------------------------------------
QString find_function_symbol(address_t address, const QString &default_value, int *offset) {

	QString symname(default_value);
	int off;

	if (function_symbol_base(address, &symname, &off)) {

		if (config().function_offsets_in_hex) {
			symname = QString("%1+0x%2").arg(symname).arg(off, 0, 16);
		} else {
			symname = QString("%1+%2").arg(symname).arg(off, 0, 10);
		}

		if (offset) {
			*offset = off;
		}
	}

	return symname;
}

//------------------------------------------------------------------------------
// Name: find_function_symbol
// Desc:
//------------------------------------------------------------------------------
QString find_function_symbol(address_t address, const QString &default_value) {
	return find_function_symbol(address, default_value, nullptr);
}

//------------------------------------------------------------------------------
// Name: find_function_symbol
// Desc:
//------------------------------------------------------------------------------
QString find_function_symbol(address_t address) {
	return find_function_symbol(address, QString(), nullptr);
}

//------------------------------------------------------------------------------
// Name: get_variable
// Desc:
//------------------------------------------------------------------------------
address_t get_variable(const QString &s, bool *ok, ExpressionError *err) {

	Q_ASSERT(debugger_core);
	Q_ASSERT(ok);
	Q_ASSERT(err);

	if (IProcess *process = debugger_core->process()) {

		State state;
		process->currentThread()->getState(&state);
		const Register reg = state.value(s);
		*ok                = reg.valid();
		if (!*ok) {
			if (const std::shared_ptr<Symbol> sym = edb::v1::symbol_manager().find(s)) {
				*ok = true;
				return sym->address;
			}

			*err = ExpressionError(ExpressionError::UnknownVariable);
			return 0;
		}

		// FIXME: should this really return segment base, not selector?
		// FIXME: if it's really meant to return base, then need to check whether
		//        State::operator[]() returned valid Register
		if (reg.name() == "fs") {
			return state["fs_base"].valueAsAddress();
		} else if (reg.name() == "gs") {
			return state["gs_base"].valueAsAddress();
		}

		if (reg.bitSize() > 8 * sizeof(edb::address_t)) {
			*err = ExpressionError(ExpressionError::UnknownVariable);
			return 0;
		}

		return reg.valueAsAddress();
	}

	*err = ExpressionError(ExpressionError::UnknownVariable);
	return 0;
}

//------------------------------------------------------------------------------
// Name: get_value
// Desc:
//------------------------------------------------------------------------------
address_t get_value(address_t address, bool *ok, ExpressionError *err) {

	Q_ASSERT(debugger_core);
	Q_ASSERT(ok);
	Q_ASSERT(err);

	address_t ret = 0;
	*ok           = false;

	if (IProcess *process = edb::v1::debugger_core->process()) {
		*ok = process->readBytes(address, &ret, pointer_size());

		if (!*ok) {
			*err = ExpressionError(ExpressionError::CannotReadMemory);
		}
	}

	return ret;
}

//------------------------------------------------------------------------------
// Name: get_instruction_bytes
// Desc: attempts to read at most size bytes.
//------------------------------------------------------------------------------
bool get_instruction_bytes(address_t address, uint8_t *buf, int *size) {

	Q_ASSERT(debugger_core);
	Q_ASSERT(size);
	Q_ASSERT(*size >= 0);

	if (IProcess *process = edb::v1::debugger_core->process()) {
		*size = process->readBytes(address, buf, *size);
		if (*size) {
			return true;
		}
	}

	return false;
}

//------------------------------------------------------------------------------
// Name: get_instruction_bytes
// Desc: attempts to read at most size bytes.
//------------------------------------------------------------------------------
bool get_instruction_bytes(address_t address, uint8_t *buf, size_t *size) {

	Q_ASSERT(debugger_core);
	Q_ASSERT(size);

	if (IProcess *process = edb::v1::debugger_core->process()) {
		*size = process->readBytes(address, buf, *size);
		if (*size) {
			return true;
		}
	}

	return false;
}

//------------------------------------------------------------------------------
// Name: get_binary_info
// Desc: gets an object which knows how to analyze the binary file provided
//       or NULL if none-found.
// Note: the caller is responsible for deleting the object!
//------------------------------------------------------------------------------
std::unique_ptr<IBinary> get_binary_info(const std::shared_ptr<IRegion> &region) {
	Q_FOREACH (IBinary::create_func_ptr_t f, g_BinaryInfoList) {
		try {
			std::unique_ptr<IBinary> p((*f)(region));
			// reorder the list to put this successful plugin
			// in front.
			if (g_BinaryInfoList[0] != f) {
				g_BinaryInfoList.removeOne(f);
				g_BinaryInfoList.push_front(f);
			}
			return p;

		} catch (const std::exception &) {
			// let's just ignore it...
		}
	}

#if 0
	qDebug() << "Failed to find any binary parser for region"
		<< QString::number(region->start(), 16);
#endif
	return nullptr;
}

//------------------------------------------------------------------------------
// Name: locate_main_function
// Desc:
// Note: this currently only works for glibc linked elf files
//------------------------------------------------------------------------------
address_t locate_main_function() {

	if (debugger_core) {
		if (IProcess *process = debugger_core->process()) {
			const address_t main_func = process->calculateMain();
			if (main_func != 0) {
				return main_func;
			} else {
				return process->entryPoint();
			}
		}
	}

	return 0;
}

//------------------------------------------------------------------------------
// Name: plugin_list
// Desc:
//------------------------------------------------------------------------------
const QMap<QString, QObject *> &plugin_list() {
	return g_GeneralPlugins;
}

//------------------------------------------------------------------------------
// Name: find_plugin_by_name
// Desc: gets a pointer to a plugin based on it's classname
//------------------------------------------------------------------------------
IPlugin *find_plugin_by_name(const QString &name) {
	Q_FOREACH (QObject *p, g_GeneralPlugins) {
		if (name == p->metaObject()->className()) {
			return qobject_cast<IPlugin *>(p);
		}
	}
	return nullptr;
}

//------------------------------------------------------------------------------
// Name: reload_symbols
// Desc:
//------------------------------------------------------------------------------
void reload_symbols() {
	symbol_manager().clear();
}

//------------------------------------------------------------------------------
// Name: get_function_info
// Desc:
//------------------------------------------------------------------------------
const Prototype *get_function_info(const QString &function) {

	auto it = g_FunctionDB.find(function);
	if (it != g_FunctionDB.end()) {
		return &(it.value());
	}

	return nullptr;
}

//------------------------------------------------------------------------------
// Name: primary_data_region
// Desc: returns the main .data section of the main executable module
// Note: make sure that memory regions has been sync'd first or you will likely
//       get a null-region result
//------------------------------------------------------------------------------
std::shared_ptr<IRegion> primary_data_region() {

	if (debugger_core) {
		if (IProcess *process = debugger_core->process()) {
			const address_t address = process->dataAddress();
			memory_regions().sync();
			if (std::shared_ptr<IRegion> region = memory_regions().findRegion(address)) {
				return region;
			}
		}
	}

	qDebug() << "primary data region not found!";
	return nullptr;
}

//------------------------------------------------------------------------------
// Name: primary_code_region
// Desc: returns the main .text section of the main executable module
// Note: make sure that memory regions has been sync'd first or you will likely
//       get a null-region result
//------------------------------------------------------------------------------
std::shared_ptr<IRegion> primary_code_region() {

#if defined(Q_OS_LINUX)
	if (debugger_core) {
		if (IProcess *process = debugger_core->process()) {
			const address_t address = process->codeAddress();
			memory_regions().sync();
			if (std::shared_ptr<IRegion> region = memory_regions().findRegion(address)) {
				return region;
			}
		}
	}
#else
	const QString process_executable = debugger_core->process()->name();

	memory_regions().sync();
	const QList<std::shared_ptr<IRegion>> r = memory_regions().regions();
	for (const std::shared_ptr<IRegion> &region : r) {
		if (region->executable() && region->name() == process_executable) {
			return region;
		}
	}
#endif
	return nullptr;
}

//------------------------------------------------------------------------------
// Name: pop_value
// Desc:
//------------------------------------------------------------------------------
void pop_value(State *state) {
	Q_ASSERT(state);
	state->adjustStack(pointer_size());
}

//------------------------------------------------------------------------------
// Name: push_value
// Desc:
//------------------------------------------------------------------------------
void push_value(State *state, reg_t value) {
	Q_ASSERT(state);

	if (IProcess *process = edb::v1::debugger_core->process()) {
		state->adjustStack(-static_cast<int>(pointer_size()));
		process->writeBytes(state->stackPointer(), &value, pointer_size());
	}
}

//------------------------------------------------------------------------------
// Name: register_binary_info
// Desc:
//------------------------------------------------------------------------------
void register_binary_info(IBinary::create_func_ptr_t fptr) {
	if (!g_BinaryInfoList.contains(fptr)) {
		g_BinaryInfoList.push_back(fptr);
	}
}

//------------------------------------------------------------------------------
// Name: edb_version
// Desc: returns an integer comparable version of our current version string
//------------------------------------------------------------------------------
quint32 edb_version() {
	return int_version(EDB_VERSION_STRING);
}

//------------------------------------------------------------------------------
// Name: overwrite_check
// Desc:
//------------------------------------------------------------------------------
bool overwrite_check(address_t address, size_t size) {
	bool firstConflict = true;
	for (address_t addr = address; addr != (address + size); ++addr) {
		std::shared_ptr<IBreakpoint> bp = find_breakpoint(addr);

		if (bp && bp->enabled()) {
			if (firstConflict) {
				const int ret = QMessageBox::question(
					nullptr,
					tr("Overwritting breakpoint"),
					tr("You are attempting to modify bytes which overlap with a software breakpoint. Doing this will implicitly remove any breakpoints which are a conflict. Are you sure you want to do this?"),
					QMessageBox::Yes | QMessageBox::No);

				if (ret == QMessageBox::No) {
					return false;
				}
				firstConflict = false;
			}

			remove_breakpoint(addr);
		}
	}
	return true;
}

//------------------------------------------------------------------------------
// Name: update_ui
// Desc:
//------------------------------------------------------------------------------
void update_ui() {
	// force a full update
	Debugger *const gui = ui();
	Q_ASSERT(gui);
	gui->updateUi();
}

//------------------------------------------------------------------------------
// Name: modify_bytes
// Desc:
//------------------------------------------------------------------------------
bool modify_bytes(address_t address, size_t size, QByteArray &bytes, uint8_t fill) {

	if (!edb::v1::overwrite_check(address, size)) {
		return false;
	}

	if (IProcess *process = edb::v1::debugger_core->process()) {
		if (size != 0) {
			// fill bytes
			while (bytes.size() < static_cast<int>(size)) {
				bytes.push_back(fill);
			}

			process->writeBytes(address, bytes.data(), size);

			// do a refresh, not full update
			Debugger *const gui = ui();
			Q_ASSERT(gui);
			gui->refreshUi();
		}
	}

	return true;
}

//------------------------------------------------------------------------------
// Name: get_md5
// Desc:
//------------------------------------------------------------------------------
QByteArray get_md5(const QVector<uint8_t> &bytes) {
	return get_md5(&bytes[0], bytes.size());
}

//------------------------------------------------------------------------------
// Name: get_md5
// Desc:
//------------------------------------------------------------------------------
QByteArray get_md5(const void *p, size_t n) {
	auto b = QByteArray::fromRawData(reinterpret_cast<const char *>(p), n);
	return QCryptographicHash::hash(b, QCryptographicHash::Md5);
}

//------------------------------------------------------------------------------
// Name: get_file_md5
// Desc: returns a byte array representing the MD5 of a file
//------------------------------------------------------------------------------
QByteArray get_file_md5(const QString &s) {

	QFile file(s);
	file.open(QIODevice::ReadOnly);
	if (file.isOpen()) {
		if (file.size() != 0) {
			QCryptographicHash hasher(QCryptographicHash::Md5);
			hasher.addData(file.readAll());
			return hasher.result();
		}
	}

	return QByteArray();
}

//------------------------------------------------------------------------------
// Name: symlink_target
// Desc:
//------------------------------------------------------------------------------
QString symlink_target(const QString &s) {
	return QFileInfo(s).symLinkTarget();
}

//------------------------------------------------------------------------------
// Name: int_version
// Desc: returns an integer comparable version of a version string in x.y.z
//       format, or 0 if error
//------------------------------------------------------------------------------
quint32 int_version(const QString &s) {

	ulong ret              = 0;
	const QStringList list = s.split(".");
	if (list.size() == 3) {
		bool ok[3];
		const unsigned int maj = list[0].toUInt(&ok[0]);
		const unsigned int min = list[1].toUInt(&ok[1]);
		const unsigned int rev = list[2].toUInt(&ok[2]);
		if (ok[0] && ok[1] && ok[2]) {
			ret = (maj << 12) | (min << 8) | (rev);
		}
	}
	return ret;
}

//------------------------------------------------------------------------------
// Name: parse_command_line
// Desc:
//------------------------------------------------------------------------------
QStringList parse_command_line(const QString &cmdline) {

	QStringList args;
	QString arg;

	int bcount     = 0;
	bool in_quotes = false;

	auto s = cmdline.begin();

	while (s != cmdline.end()) {
		if (!in_quotes && s->isSpace()) {

			// Close the argument and copy it
			args << arg;
			arg.clear();

			// skip the remaining spaces
			do {
				++s;
			} while (s->isSpace());

			// Start with a new argument
			bcount = 0;
		} else if (*s == '\\') {

			// '\\'
			arg += *s++;
			++bcount;

		} else if (*s == '"') {

			// '"'
			if ((bcount & 1) == 0) {
				/* Preceded by an even number of '\', this is half that
				 * number of '\', plus a quote which we erase.
				 */

				arg.chop(bcount / 2);
				in_quotes = !in_quotes;
			} else {
				/* Preceded by an odd number of '\', this is half that
				 * number of '\' followed by a '"'
				 */

				arg.chop(bcount / 2 + 1);
				arg += '"';
			}

			++s;
			bcount = 0;
		} else {
			arg += *s++;
			bcount = 0;
		}
	}

	if (!arg.isEmpty()) {
		args << arg;
	}

	return args;
}

//------------------------------------------------------------------------------
// Name: string_to_address
// Desc:
//------------------------------------------------------------------------------
Result<address_t, QString> string_to_address(const QString &s) {
	QString hex(s);
	hex.replace("0x", "");

	bool ok;
	address_t r = edb::address_t::fromHexString(hex.left(2 * sizeof(edb::address_t)), &ok);
	if (ok) {
		return r;
	}

	return make_unexpected(tr("Error converting string to address"));
}

//------------------------------------------------------------------------------
// Name: format_bytes
// Desc:
//------------------------------------------------------------------------------
QString format_bytes(const uint8_t *buffer, size_t count) {
	return v2::format_bytes(buffer, count);
}

//------------------------------------------------------------------------------
// Name: format_bytes
// Desc:
//------------------------------------------------------------------------------
QString format_bytes(const QByteArray &x) {
	return v2::format_bytes(x.data(), x.size());
}

//------------------------------------------------------------------------------
// Name: format_bytes
// Desc:
//------------------------------------------------------------------------------
QString format_bytes(uint8_t byte) {
	char buf[4];
	qsnprintf(buf, sizeof(buf), "%02x", byte & 0xff);
	return QLatin1String(buf);
}

//------------------------------------------------------------------------------
// Name: format_pointer
// Desc:
//------------------------------------------------------------------------------
QString format_pointer(address_t p) {
	return p.toPointerString();
}

//------------------------------------------------------------------------------
// Name: current_data_view_address
// Desc:
//------------------------------------------------------------------------------
address_t current_data_view_address() {
	return qobject_cast<QHexView *>(ui()->tabWidget_->currentWidget())->firstVisibleAddress();
}

//------------------------------------------------------------------------------
// Name: set_status
// Desc:
//------------------------------------------------------------------------------
void set_status(const QString &message, int timeoutMillisecs) {
	ui()->ui.statusbar->showMessage(message, timeoutMillisecs);
	// FIXME: For some reason, despite showMessage() calls repaint, there's some
	// hysteresis in actual look of the status bar: in a busy loop of calls to set_status()
	// it updates to previous content. In some cases it even doesn't actually update.
	// This happens at least on Qt 4.
	// Manual call to repaint makes it show the correct text immediately.
	// TODO(eteran): still true in Qt5.x?
	ui()->ui.statusbar->repaint();
}

void clear_status() {
	ui()->ui.statusbar->clearMessage();
	// FIXME: same comment applies as in set_status()
	// TODO(eteran): still true in Qt5.x?
	ui()->ui.statusbar->repaint();
}

//------------------------------------------------------------------------------
// Name: find_breakpoint
// Desc:
//------------------------------------------------------------------------------
std::shared_ptr<IBreakpoint> find_breakpoint(address_t address) {
	if (debugger_core) {
		return debugger_core->findBreakpoint(address);
	}
	return nullptr;
}

//------------------------------------------------------------------------------
// Name: find_triggered_breakpoint
// Desc:
//------------------------------------------------------------------------------
std::shared_ptr<IBreakpoint> find_triggered_breakpoint(address_t address) {
	if (debugger_core) {
		return debugger_core->findTriggeredBreakpoint(address);
	}
	return nullptr;
}

//------------------------------------------------------------------------------
// Name: pointer_size
// Desc:
//------------------------------------------------------------------------------
size_t pointer_size() {

	if (debugger_core) {
		return debugger_core->pointerSize();
	}

	// default to sizeof the native pointer for sanity!
	return sizeof(void *);
}

//------------------------------------------------------------------------------
// Name: disassembly_widget
// Desc:
//------------------------------------------------------------------------------
QAbstractScrollArea *disassembly_widget() {
	return ui()->cpuView_;
}

//------------------------------------------------------------------------------
// Name: read_pages
// Desc:
//------------------------------------------------------------------------------
QVector<uint8_t> read_pages(address_t address, size_t page_count) {

	if (debugger_core) {
		if (IProcess *process = edb::v1::debugger_core->process()) {
			try {
				const size_t page_size = debugger_core->pageSize();
				QVector<uint8_t> pages(page_count * page_size);

				if (process->readPages(address, pages.data(), page_count)) {
					return pages;
				}

			} catch (const std::bad_alloc &) {
				QMessageBox::critical(
					nullptr,
					tr("Memory Allocation Error"),
					tr("Unable to satisfy memory allocation request for requested region"));
			}
		}
	}

	return {};
}

//------------------------------------------------------------------------------
// Name: disassemble_address
// Desc: will return a QString where isNull is true on failure
//------------------------------------------------------------------------------
QString disassemble_address(address_t address) {
	uint8_t buffer[edb::Instruction::MaxSize];
	if (const int size = edb::v1::get_instruction_bytes(address, buffer)) {
		edb::Instruction inst(buffer, buffer + size, address);
		if (inst) {
			return QString::fromStdString(g_Formatter.toString(inst));
		}
	}

	return {};
}

//------------------------------------------------------------------------------
// Name: formatter
// Desc: returns a reference to the global instruction formatter
//------------------------------------------------------------------------------
CapstoneEDB::Formatter &formatter() {
	return g_Formatter;
}

//------------------------------------------------------------------------------
// Name: selected_stack_address
// Desc: returns the address of the selection or (address_t)-1
//------------------------------------------------------------------------------
address_t selected_stack_address() {

	if (auto hexview = qobject_cast<QHexView *>(ui()->stackDock_->widget())) {
		if (hexview->hasSelectedText()) {
			return hexview->selectedBytesAddress();
		}
	}

	return address_t(-1);
}

//------------------------------------------------------------------------------
// Name: selected_stack_size
// Desc: returns the size of the selection or 0
//------------------------------------------------------------------------------
size_t selected_stack_size() {
	if (auto hexview = qobject_cast<QHexView *>(ui()->stackDock_->widget())) {
		if (hexview->hasSelectedText()) {
			return hexview->selectedBytesSize();
		}
	}

	return 0;
}

//------------------------------------------------------------------------------
// Name: selected_stack_address
// Desc: returns the address of the selection or (address_t)-1
//------------------------------------------------------------------------------
address_t selected_data_address() {
	if (auto hexview = qobject_cast<QHexView *>(ui()->tabWidget_->currentWidget())) {
		if (hexview->hasSelectedText()) {
			return hexview->selectedBytesAddress();
		}
	}

	return address_t(-1);
}

//------------------------------------------------------------------------------
// Name: selected_data_size
// Desc: returns the size of the selection or 0
//------------------------------------------------------------------------------
size_t selected_data_size() {
	if (auto hexview = qobject_cast<QHexView *>(ui()->tabWidget_->currentWidget())) {
		if (hexview->hasSelectedText()) {
			return hexview->selectedBytesSize();
		}
	}

	return 0;
}

}

namespace v2 {

//------------------------------------------------------------------------------
// Name: eval_expression
// Desc:
//------------------------------------------------------------------------------
std::optional<edb::address_t> eval_expression(const QString &expression) {

	Expression<address_t> expr(expression, v1::get_variable, v1::get_value);

	const Result<edb::address_t, ExpressionError> address = expr.evaluate();
	if (address) {
		return *address;
	} else {
		QMessageBox::critical(v1::debugger_ui, tr("Error In Expression!"), address.error().what());
		return {};
	}
}

//------------------------------------------------------------------------------
// Name: get_expression_from_user
// Desc:
//------------------------------------------------------------------------------
std::optional<edb::address_t> get_expression_from_user(const QString &title, const QString &prompt) {

	auto inputDialog = std::make_unique<ExpressionDialog>(title, prompt, edb::v1::debugger_ui);

	if (inputDialog->exec()) {
		return inputDialog->getAddress();
	}

	return {};
}

//------------------------------------------------------------------------------
// Name: format_bytes
// Desc:
//------------------------------------------------------------------------------
QString format_bytes(const void *buffer, size_t count) {
	QString bytes;

	if (count != 0) {
		bytes.reserve(count * 4);

		auto it  = static_cast<const uint8_t *>(buffer);
		auto end = it + count;

		char buf[4];
		qsnprintf(buf, sizeof(buf), "%02x", *it++ & 0xff);
		bytes += buf;

		while (it != end) {
			qsnprintf(buf, sizeof(buf), " %02x", *it++ & 0xff);
			bytes += buf;
		}
	}

	return bytes;
}

}
}

```

`src/graph/GraphEdge.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "GraphEdge.h"
#include "GraphNode.h"
#include "GraphWidget.h"

#include <QGraphicsPolygonItem>
#include <QPainter>
#include <QtDebug>

namespace {

constexpr int LineThickness = 2;
constexpr int EdgeZValue    = 1;

//------------------------------------------------------------------------------
// Name: create_arrow
// Desc:
//------------------------------------------------------------------------------
QPolygonF create_arrow(QLineF line, int size) {
	// we want a short line at the END of this line
	line = QLineF(line.p2(), line.p1());
	line.setLength(size);
	line = QLineF(line.p2(), line.p1());

	QLineF n(line.normalVector());
	QPointF o(n.dx() / 3.0, n.dy() / 3.0);

	QPolygonF polygon;
	polygon.append(line.p1() + o);
	polygon.append(line.p2());
	polygon.append(line.p1() - o);
	return polygon;
}

}

//------------------------------------------------------------------------------
// Name: GraphEdge
// Desc:
//------------------------------------------------------------------------------
GraphEdge::GraphEdge(GraphNode *from, GraphNode *to, const QColor &color, QGraphicsItem *parent)
	: QGraphicsItemGroup(parent), from_(from), to_(to), graph_(from->graph_), color_(color) {

	setFlag(QGraphicsItem::ItemHasNoContents, true);

	Q_ASSERT(from->graph_ == to->graph_);

	// we don't want this object to interfere with the line's events
	setAcceptHoverEvents(false);

	from_->addEdge(this);
	to_->addEdge(this);

	graph_->scene()->addItem(this);

	edge_ = agedge(graph_->graph_, from->node_, to->node_, nullptr, true);
}

//------------------------------------------------------------------------------
// Name: ~GraphEdge
// Desc:
//------------------------------------------------------------------------------
GraphEdge::~GraphEdge() {

	from_->removeEdge(this);
	to_->removeEdge(this);

	clear();
}

//------------------------------------------------------------------------------
// Name: from
// Desc:
//------------------------------------------------------------------------------
GraphNode *GraphEdge::from() const {
	return from_;
}

//------------------------------------------------------------------------------
// Name: to
// Desc:
//------------------------------------------------------------------------------
GraphNode *GraphEdge::to() const {
	return to_;
}

//------------------------------------------------------------------------------
// Name: GraphEdge
// Desc:
//------------------------------------------------------------------------------
void GraphEdge::clear() {
	const QList<QGraphicsItem *> items = childItems();
	qDeleteAll(items);
}

//------------------------------------------------------------------------------
// Name: shortenLineToNode
// Desc:
//------------------------------------------------------------------------------
QLineF GraphEdge::shortenLineToNode(QLineF line) {
	QRectF nodeRect = to_->sceneBoundingRect();

	// get the 4 lines tha tmake up the rect
	const QLineF polyLines[4] = {
		QLineF(nodeRect.topLeft(), nodeRect.bottomLeft()),
		QLineF(nodeRect.topLeft(), nodeRect.topRight()),
		QLineF(nodeRect.topRight(), nodeRect.bottomRight()),
		QLineF(nodeRect.bottomRight(), nodeRect.bottomLeft())};

	// for any that intersect, shorten the line appropriately
	for (int i = 0; i < 4; ++i) {
		QPointF intersectPoint;
#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
		QLineF::IntersectType intersectType = polyLines[i].intersects(line, &intersectPoint);
#else
		QLineF::IntersectType intersectType = polyLines[i].intersect(line, &intersectPoint);
#endif
		if (intersectType == QLineF::BoundedIntersection) {
			line.setP2(intersectPoint);
		}
	}

	return line;
}

//------------------------------------------------------------------------------
// Name: createLineSegment
// Desc:
//------------------------------------------------------------------------------
QGraphicsLineItem *GraphEdge::createLineSegment(const QLineF &line, const QPen &pen) {
	auto l = new QGraphicsLineItem(line, this);
	l->setPen(pen);
	l->setAcceptHoverEvents(true);
	l->setZValue(EdgeZValue);
	return l;
}

//------------------------------------------------------------------------------
// Name: createLineSegment
// Desc:
//------------------------------------------------------------------------------
QGraphicsLineItem *GraphEdge::createLineSegment(const QPointF &p1, const QPointF &p2, const QPen &pen) {
	return createLineSegment(QLineF(p1, p2), pen);
}

//------------------------------------------------------------------------------
// Name: createLine
// Desc:
//------------------------------------------------------------------------------
void GraphEdge::createLine() {
	clear();

	const QPointF p1 = from_->sceneBoundingRect().center();
	const QPointF p2 = to_->sceneBoundingRect().center();
	const QPen pen(lineColor(), lineThickness(), Qt::SolidLine, Qt::RoundCap);
	const QLineF line = shortenLineToNode(QLineF(p1, p2));
	auto segment      = createLineSegment(line, pen);
	addToGroup(segment);
	addArrowHead(line);
}

//------------------------------------------------------------------------------
// Name: syncState
// Desc:
//------------------------------------------------------------------------------
void GraphEdge::syncState() {
	createLine();
}

//------------------------------------------------------------------------------
// Name: addArrowHead
// Desc:
//------------------------------------------------------------------------------
QGraphicsPolygonItem *GraphEdge::addArrowHead(const QLineF &line, int lineThickness, const QColor &color, int ZValue) {

	const int arrowHeadSize = std::max(lineThickness * 5, 20);

	QPolygonF arrow = create_arrow(line, arrowHeadSize);
	auto arrowHead  = new QGraphicsPolygonItem(this);
	arrowHead->setPolygon(arrow);
	arrowHead->setPen(QPen(color));
	arrowHead->setBrush(QBrush(color));
	arrowHead->setZValue(ZValue);
	addToGroup(arrowHead);
	return arrowHead;
}

//------------------------------------------------------------------------------
// Name: addArrowHead
// Desc:
//------------------------------------------------------------------------------
QGraphicsPolygonItem *GraphEdge::addArrowHead(const QLineF &line) {
	return addArrowHead(line, lineThickness(), lineColor(), EdgeZValue);
}

//------------------------------------------------------------------------------
// Name: updateLines
// Desc: replaces all of the lines with a single straight line
//------------------------------------------------------------------------------
void GraphEdge::updateLines() {

	if (!childItems().empty()) {
		createLine();
	}
}

//------------------------------------------------------------------------------
// Name: lineThickness
// Desc:
//------------------------------------------------------------------------------
int GraphEdge::lineThickness() const {
	return LineThickness;
}

//------------------------------------------------------------------------------
// Name: lineColor
// Desc:
//------------------------------------------------------------------------------
QColor GraphEdge::lineColor() const {
	return color_;
}

```

`src/graph/GraphNode.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "GraphNode.h"
#include "Configuration.h"
#include "GraphEdge.h"
#include "GraphWidget.h"
#include "GraphvizHelper.h"
#include "SyntaxHighlighter.h"
#include "edb.h"

#include <QAbstractTextDocumentLayout>
#include <QGraphicsColorizeEffect>
#include <QPainter>
#include <QPainterPath>
#include <QtDebug>

#include <cmath>

namespace {

const QColor TextColor   = Qt::black;
const QColor BorderColor = Qt::blue;
const QColor SelectColor = Qt::lightGray;
const QString NodeFont   = "Monospace";

}

//------------------------------------------------------------------------------
// Name: GraphNode
// Desc:
//------------------------------------------------------------------------------
GraphNode::GraphNode(GraphWidget *graph, const QString &text, const QColor &color)
	: color_(color), graph_(graph) {

	setFlag(QGraphicsItem::ItemIsMovable, true);
	setFlag(QGraphicsItem::ItemIsSelectable, true);
	setFlag(QGraphicsItem::ItemSendsGeometryChanges, true);
	setAcceptHoverEvents(true);
	setCacheMode(QGraphicsItem::DeviceCoordinateCache);
	setZValue(NodeZValue);

	drawLabel(text);

	graph->scene()->addItem(this);

	QString name = QString("Node%1").arg(reinterpret_cast<uintptr_t>(this));
	node_        = _agnode(graph->graph_, name);

	_agset(node_, "fixedsize", "0");
	_agset(node_, "width", QString("%1").arg(boundingRect().width() / 96.0));
	_agset(node_, "height", QString("%1").arg(boundingRect().height() / 96.0));
}

//------------------------------------------------------------------------------
// Name: ~GraphNode
// Desc:
//------------------------------------------------------------------------------
GraphNode::~GraphNode() {

	// NOTE(eteran): we use Q_FOREACH because it operates on a *copy*
	// of the list, which is important because deleting an
	// edge removes it from the list
	Q_FOREACH (GraphEdge *const edge, edges_) {
		delete edge;
	}
}

//------------------------------------------------------------------------------
// Name: boundingRect
// Desc:
//------------------------------------------------------------------------------
QRectF GraphNode::boundingRect() const {
	constexpr int weight = 2;
	const int width      = std::log2(weight) * BorderScaleFactor;
	return picture_.boundingRect().adjusted(-width, -width, +width, +width);
}

//------------------------------------------------------------------------------
// Name: paint
// Desc:
//------------------------------------------------------------------------------
void GraphNode::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) {

	Q_UNUSED(option)
	Q_UNUSED(widget)

	painter->save();

	// draw border
	painter->setPen(BorderColor);
	painter->setBrush(BorderColor);
	painter->drawRect(boundingRect());

	// draw background
	painter->setPen(QPen(color_));
	painter->setBrush(QBrush(color_));
	painter->drawRect(picture_.boundingRect());

	if (isSelected()) {
		painter->setPen(QPen(Qt::DashLine));
		painter->drawRect(boundingRect().adjusted(+4, +4, -4, -4));
	}

	// draw contents
	painter->restore();
	picture_.play(painter);
}

//------------------------------------------------------------------------------
// Name: paint
// Desc:
//------------------------------------------------------------------------------
QVariant GraphNode::itemChange(GraphicsItemChange change, const QVariant &value) {
	if (!graph_->inLayout_) {

		switch (change) {
		case ItemPositionChange:
			for (const auto edge : edges_) {
				edge->updateLines();
			}
			break;
		default:
			break;
		}
	}

	return QGraphicsItem::itemChange(change, value);
}

//------------------------------------------------------------------------------
// Name: addEdge
// Desc:
//------------------------------------------------------------------------------
void GraphNode::addEdge(GraphEdge *edge) {
	edges_.insert(edge);
}

//------------------------------------------------------------------------------
// Name: removeEdge
// Desc:
//------------------------------------------------------------------------------
void GraphNode::removeEdge(GraphEdge *edge) {
	edges_.remove(edge);
}

//------------------------------------------------------------------------------
// Name: drawLabel
// Desc:
//------------------------------------------------------------------------------
void GraphNode::drawLabel(const QString &text) {

	const bool syntax_highlighting_enabled = edb::v1::config().syntax_highlighting_enabled;

	QPainter painter(&picture_);
	painter.setBrush(QBrush(color_));
	painter.setPen(TextColor);

	// Since I always just take the points from graph_ and pass them to Qt
	// as pixel I also have to set the pixel size of the font.
	QFont font(NodeFont);
	font.setPixelSize(LabelFontSize);

	if (!font.exactMatch()) {
		QFontInfo fontinfo(font);
		qWarning("replacing font '%s' by font '%s'", qPrintable(font.family()), qPrintable(fontinfo.family()));
	}

	painter.setFont(font);

	QFontMetricsF fm(painter.font());

	// just to calculate the proper bounding box
	QRectF textBoundingRect = fm.boundingRect(QRectF(), Qt::AlignLeft | Qt::AlignTop, text);

	// set some reasonable minimums
	if (textBoundingRect.width() < NodeWidth) {
		textBoundingRect.setWidth(NodeWidth);
	}

	if (textBoundingRect.height() < NodeHeight) {
		textBoundingRect.setHeight(NodeHeight);
	}

	QRectF adjustedBoundingBox = textBoundingRect.adjusted(-2, -2, +2, +2);

	// set the bounding box and then really draw it
	picture_.setBoundingRect(adjustedBoundingBox.toRect());

	if (syntax_highlighting_enabled) {

		// create the text layout
		QTextLayout textLayout(text, painter.font());

		textLayout.setTextOption(QTextOption(Qt::AlignLeft | Qt::AlignTop));

		textLayout.beginLayout();

		int y             = 0;
		QStringList lines = text.split(QLatin1Char('\n'));
		for (const QString &l : lines) {
			QTextLine line = textLayout.createLine();

			if (!line.isValid()) {
				break;
			}

			line.setNumColumns(l.length());
			line.setPosition(QPoint(0, y));
			y += fm.lineSpacing();
		}

		textLayout.endLayout();

		// now the render the text at the location given
		SyntaxHighlighter highlighter;
		textLayout.draw(&painter, adjustedBoundingBox.topLeft(), highlighter.highlightBlock(text), adjustedBoundingBox);
	} else {
		painter.drawText(adjustedBoundingBox, Qt::AlignLeft | Qt::AlignTop, text);
	}
}

//------------------------------------------------------------------------------
// Name: hoverEnterEvent
// Desc:
//------------------------------------------------------------------------------
void GraphNode::hoverEnterEvent(QGraphicsSceneHoverEvent *e) {
	Q_UNUSED(e)
}

//------------------------------------------------------------------------------
// Name: hoverLeaveEvent
// Desc:
//------------------------------------------------------------------------------
void GraphNode::hoverLeaveEvent(QGraphicsSceneHoverEvent *e) {
	Q_UNUSED(e)
}

```

`src/graph/GraphWidget.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "GraphWidget.h"
#include "GraphEdge.h"
#include "GraphNode.h"
#include "GraphicsScene.h"
#include "GraphvizHelper.h"

#include <QAbstractAnimation>
#include <QDebug>
#include <QGraphicsOpacityEffect>
#include <QGraphicsSceneMouseEvent>
#include <QHBoxLayout>
#include <QKeyEvent>
#include <QLabel>
#include <QPropertyAnimation>
#include <QScrollBar>
#include <QWheelEvent>

#include <graphviz/cgraph.h>
#include <graphviz/gvc.h>

#include <cmath>

namespace {

constexpr int ScenePadding  = 30000;
constexpr qreal ZoomFactor  = 1.2;
constexpr qreal MinimumZoom = 0.001;
constexpr qreal MaximumZoom = 8.000;
}

namespace {

qreal graph_height(Agraph_t *graph) {
	return GD_bb(graph).UR.y;
}

QPointF to_point(pointf p, qreal gheight) {
	return QPointF(p.x, gheight - p.y);
}

QPointF center_to_origin(const QPointF &p, qreal width, qreal height) {
	return QPointF(p.x() - width / 2, p.y() - height / 2);
}

}

//------------------------------------------------------------------------------
// Name: GraphWidget
// Desc:
//------------------------------------------------------------------------------
GraphWidget::GraphWidget(QWidget *parent)
	: QGraphicsView(parent) {

#if 0
	setViewport(new QGLWidget(QGLFormat(QGL::SampleBuffers)));
#endif
	setDragMode(ScrollHandDrag);

	setScene(new GraphicsScene(this));

	// Setup the HUD
	HUDLabel_ = new QLabel(this);
	HUDLabel_->hide();
	HUDLabel_->setAlignment(Qt::AlignHCenter | Qt::AlignVCenter);
	HUDLabel_->setFont(QFont("FreeSans", 32));
	HUDLabel_->setAttribute(Qt::WA_TransparentForMouseEvents);

	HUDLayout_ = new QHBoxLayout(this);
	HUDLayout_->addWidget(HUDLabel_);

	context_ = gvContext();
	graph_   = _agopen("GraphName", Agstrictdirected);

	//Set graph attributes
	setGraphAttribute("overlap", "prism");
	setGraphAttribute("pad", "0,2");
	setGraphAttribute("dpi", "96,0");
	setGraphAttribute("nodesep", "2,5");
	setGraphAttribute("nslimit", "1");
	setGraphAttribute("nslimit1", "1");
	setGraphAttribute("splines", "line"); // ugly but should be much faster

	//Set default attributes for the future nodes
	setNodeAttribute("fixedsize", "false");
	setNodeAttribute("label", "");
	setNodeAttribute("regular", "true");

	//Divide the wanted width by the DPI to get the value in points
	QString nodePtsWidth = QString("%1").arg(NodeWidth / _agget(graph_, "dpi", "96,0").toDouble());
	//GV uses , instead of . for the separator in floats
	setNodeAttribute("width", nodePtsWidth.replace('.', ","));

	// set font
	QFont font = QFont("Arial");
	setGraphAttribute("fontname", font.family());
	setGraphAttribute("fontsize", QString("%1").arg(font.pointSizeF()));

	setNodeAttribute("fontname", font.family());
	setNodeAttribute("fontsize", QString("%1").arg(font.pointSizeF()));

	setEdgeAttribute("fontname", font.family());
	setEdgeAttribute("fontsize", QString("%1").arg(font.pointSizeF()));
}

//------------------------------------------------------------------------------
// Name: setGraphAttribute
// Desc:
//------------------------------------------------------------------------------
void GraphWidget::setGraphAttribute(const QString name, const QString value) {
	_agset(graph_, name, value);
}

//------------------------------------------------------------------------------
// Name: setNodeAttribute
// Desc:
//------------------------------------------------------------------------------
void GraphWidget::setNodeAttribute(const QString name, const QString value) {
	_agnodeattr(graph_, name, value);
}

//------------------------------------------------------------------------------
// Name: setEdgeAttribute
// Desc:
//------------------------------------------------------------------------------
void GraphWidget::setEdgeAttribute(const QString name, const QString value) {
	_agedgeattr(graph_, name, value);
}

//------------------------------------------------------------------------------
// Name: layout
// Desc:
//------------------------------------------------------------------------------
void GraphWidget::setHUDNotification(const QString &s, int duration) {

	HUDLabel_->setText(s);
	HUDLabel_->show();

	auto effect = new QGraphicsOpacityEffect(this);
	effect->setOpacity(1);
	HUDLabel_->setGraphicsEffect(effect);

	auto animation = new QPropertyAnimation(this);
	animation->setTargetObject(effect);
	animation->setPropertyName("opacity");
	animation->setDuration(duration);
	animation->setStartValue(effect->opacity());
	animation->setEndValue(0);
	animation->setEasingCurve(QEasingCurve::OutQuad);
	animation->start(QAbstractAnimation::DeleteWhenStopped);

	connect(animation, &QPropertyAnimation::finished, HUDLabel_, &QLabel::hide);
}

//------------------------------------------------------------------------------
// Name: layout
// Desc:
//------------------------------------------------------------------------------
void GraphWidget::layout() {

	inLayout_ = true;

	qDebug() << "Starting Layout Engine";

	gvFreeLayout(context_, graph_);
	gvLayout(context_, graph_, "dot");

	Q_FOREACH (QGraphicsItem *item, items()) {
		if (auto node = qgraphicsitem_cast<GraphNode *>(item)) {
			qreal gheight = graph_height(graph_);
			if (auto internalNode = node->node_) {
				QPointF point = to_point(ND_coord(internalNode), gheight);
				node->setPos(center_to_origin(point, node->boundingRect().width(), node->boundingRect().height()));
			}
		}
	}

	Q_FOREACH (QGraphicsItem *item, items()) {
		if (auto edge = qgraphicsitem_cast<GraphEdge *>(item)) {
			edge->syncState();
		}
	}

	qDebug() << "Layout Complete";

	// make the scene HUGE so it feels like you can just scroll forever
	scene()->setSceneRect(sceneRect().adjusted(-ScenePadding, -ScenePadding, +ScenePadding, +ScenePadding));

	inLayout_ = false;
}

//------------------------------------------------------------------------------
// Name: ~GraphWidget
// Desc:
//------------------------------------------------------------------------------
GraphWidget::~GraphWidget() {
	gvFreeLayout(context_, graph_);
	agclose(graph_);
	gvFreeContext(context_);
}

//------------------------------------------------------------------------------
// Name: keyPressEvent
// Desc:
//------------------------------------------------------------------------------
void GraphWidget::keyPressEvent(QKeyEvent *event) {

	switch (event->key()) {
	case Qt::Key_Plus:
		setScale(ZoomFactor);
		break;
	case Qt::Key_Minus:
		setScale(1.0 / ZoomFactor);
		break;
	case Qt::Key_Asterisk:
		rotate(10.0);
		break;
	case Qt::Key_Slash:
		rotate(-10.0);
		break;
	case Qt::Key_Home:
		centerOn(scene()->sceneRect().center());
		break;
	case Qt::Key_L:
		layout();
		break;
	case Qt::Key_Control:
		if (!event->isAutoRepeat()) {
			setDragMode(QGraphicsView::RubberBandDrag);
		}
		break;
	default:
		break;
	}

	QGraphicsView::keyPressEvent(event);
}

//------------------------------------------------------------------------------
// Name: keyReleaseEvent
// Desc:
//------------------------------------------------------------------------------
void GraphWidget::keyReleaseEvent(QKeyEvent *event) {

	switch (event->key()) {
	case Qt::Key_Control:
		if (!event->isAutoRepeat()) {
			setDragMode(QGraphicsView::ScrollHandDrag);
		}
		break;
	default:
		break;
	}

	QGraphicsView::keyReleaseEvent(event);
}

//------------------------------------------------------------------------------
// Name: wheelEvent
// Desc:
//------------------------------------------------------------------------------
void GraphWidget::wheelEvent(QWheelEvent *event) {
	setScale(std::pow(2.0, +event->angleDelta().y() / 240.0));
}

//------------------------------------------------------------------------------
// Name: zoom
// Desc:
//------------------------------------------------------------------------------
void GraphWidget::setScale(qreal factor) {
	const qreal f = std::sqrt(transform().determinant());
	factor        = qBound(MinimumZoom / f, factor, MaximumZoom / f);
	scale(factor, factor);
	Q_EMIT zoomEvent(factor, f);
}

//------------------------------------------------------------------------------
// Name: contextMenuEvent
// Desc:
//------------------------------------------------------------------------------
void GraphWidget::contextMenuEvent(QContextMenuEvent *event) {

	QGraphicsItem *const item = itemAt(event->pos());

	if (auto node = qgraphicsitem_cast<GraphNode *>(item)) {
		Q_EMIT nodeContextMenuEvent(event, node);
	} else if (const auto node = qgraphicsitem_cast<QGraphicsLineItem *>(item)) {
		auto parent = node->parentItem();
		if (const auto edge = qgraphicsitem_cast<GraphEdge *>(parent)) {
			Q_UNUSED(edge)
		}
	} else {
		Q_EMIT backgroundContextMenuEvent(event);
	}
}

//------------------------------------------------------------------------------
// Name: mouseDoubleClickEvent
// Desc:
//------------------------------------------------------------------------------
void GraphWidget::mouseDoubleClickEvent(QMouseEvent *event) {

	QGraphicsItem *const item = itemAt(event->pos());

	if (auto node = qgraphicsitem_cast<GraphNode *>(item)) {
		Q_EMIT nodeDoubleClickEvent(event, node);
	} else if (const auto node = qgraphicsitem_cast<QGraphicsLineItem *>(item)) {
		auto parent = node->parentItem();
		if (const auto edge = qgraphicsitem_cast<GraphEdge *>(parent)) {
			Q_UNUSED(edge)
		}
	} else {
	}
}

//------------------------------------------------------------------------------
// Name: clear
// Desc:
//------------------------------------------------------------------------------
void GraphWidget::clear() {
	qDeleteAll(scene()->items());
}

```

`src/graph/GraphicsScene.cpp`:

```cpp
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "GraphicsScene.h"

#include <QGraphicsSceneHelpEvent>
#include <QtDebug>

//------------------------------------------------------------------------------
// Name: GraphicsScene
// Desc: constructor
//------------------------------------------------------------------------------
GraphicsScene::GraphicsScene(QObject *parent)
	: QGraphicsScene(parent) {
}

//------------------------------------------------------------------------------
// Name: GraphicsScene
// Desc: constructor
//------------------------------------------------------------------------------
GraphicsScene::GraphicsScene(const QRectF &sceneRect, QObject *parent)
	: QGraphicsScene(sceneRect, parent) {
}

//------------------------------------------------------------------------------
// Name: GraphicsScene
// Desc: constructor
//------------------------------------------------------------------------------
GraphicsScene::GraphicsScene(qreal x, qreal y, qreal width, qreal height, QObject *parent)
	: QGraphicsScene(x, y, width, height, parent) {
}

//------------------------------------------------------------------------------
// Name: GraphicsScene
// Desc: tooltip event propagator
//------------------------------------------------------------------------------
void GraphicsScene::helpEvent(QGraphicsSceneHelpEvent *helpEvent) {

	QGraphicsItem *const item = itemAt(helpEvent->scenePos(), QTransform());
	Q_EMIT itemHelpEvent(helpEvent, item);
	helpEvent->ignore();
}

```

`src/graph/GraphicsScene.h`:

```h
/*
Copyright (C) 2015 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef GRAPHICS_SCENE_H_20191119_
#define GRAPHICS_SCENE_H_20191119_

#include <QGraphicsScene>

class GraphicsScene : public QGraphicsScene {
	Q_OBJECT
public:
	explicit GraphicsScene(QObject *parent = nullptr);
	explicit GraphicsScene(const QRectF &sceneRect, QObject *parent = nullptr);
	GraphicsScene(qreal x, qreal y, qreal width, qreal height, QObject *parent = nullptr);
	~GraphicsScene() override = default;

Q_SIGNALS:
	void itemHelpEvent(QGraphicsSceneHelpEvent *helpEvent, QGraphicsItem *item);

protected:
	void helpEvent(QGraphicsSceneHelpEvent *helpEvent) override;
};

#endif

```

`src/graph/GraphvizHelper.cpp`:

```cpp

#include "GraphvizHelper.h"

Agnode_t *_agnode(Agraph_t *g, QString name) {
	return agnode(g, name.toLocal8Bit().data(), true);
}

/// Directly use agsafeset which always works, contrarily to agset
int _agset(void *object, QString attr, QString value) {
	return agsafeset(
		object,
		attr.toLocal8Bit().data(),
		value.toLocal8Bit().data(),
		value.toLocal8Bit().data());
}

Agraph_t *_agopen(QString name, Agdesc_t kind) {
	return agopen(name.toLocal8Bit().data(), kind, nullptr);
}

/// Add an alternative value parameter to the method for getting an object's attribute
QString _agget(void *object, QString attr, QString alt) {
	QString str = agget(object, attr.toLocal8Bit().data());

	// TODO(eteran): use isNull()?
	if (str == QString())
		return alt;
	else
		return str;
}

Agsym_t *_agnodeattr(Agraph_t *g, QString name, QString value) {
	return agattr(
		g,
		AGNODE,
		name.toLocal8Bit().data(),
		value.toLocal8Bit().data());
}

Agsym_t *_agedgeattr(Agraph_t *g, QString name, QString value) {
	return agattr(
		g,
		AGEDGE,
		name.toLocal8Bit().data(),
		value.toLocal8Bit().data());
}

```

`src/graph/GraphvizHelper.h`:

```h

#ifndef GRAPHVIZ_HELPER_H_20190412_
#define GRAPHVIZ_HELPER_H_20190412_

#include <QString>
#include <graphviz/cgraph.h>
#include <graphviz/gvc.h>

Agnode_t *_agnode(Agraph_t *g, QString name);
int _agset(void *object, QString attr, QString value);
Agsym_t *_agnodeattr(Agraph_t *g, QString name, QString value);
Agsym_t *_agedgeattr(Agraph_t *g, QString name, QString value);
QString _agget(void *object, QString attr, QString alt = QString());
Agraph_t *_agopen(QString name, Agdesc_t kind);

#endif

```

`src/main.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
						  evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Configuration.h"
#include "Debugger.h"
#include "DebuggerInternal.h"
#include "IDebugger.h"
#include "IPlugin.h"
#include "QtHelper.h"
#include "Theme.h"
#include "edb.h"
#include "version.h"

#include <QApplication>
#include <QDir>
#include <QLibrary>
#include <QLibraryInfo>
#include <QMessageBox>
#include <QPluginLoader>
#include <QTranslator>
#include <QtDebug>

#include <ctime>
#include <iostream>
#include <optional>

namespace {

Q_DECLARE_NAMESPACE_TR(edb)

struct LaunchArguments {

	// if we are attaching
	std::optional<edb::pid_t> attach_pid;

	// if we are running
	QList<QByteArray> run_args;
	QString run_app;
	QString run_stdin;
	QString run_stdout;
};

/**
 * displays a usage statement then exits
 *
 * @brief usage
 */
[[noreturn]] void usage() {

	QStringList args = qApp->arguments();
	std::cerr << "Usage: " << qPrintable(args[0]) << " [OPTIONS]\n";
	std::cerr << '\n';
	std::cerr << " --attach <pid>            : attach to running process\n";
	std::cerr << " --run <program> (args...) : execute specified <program> with <args>\n";
	std::cerr << " --stdin <filename>        : set the STDIN of the target process (MUST preceed --run)\n";
	std::cerr << " --stdout <filename>       : set the STDOUT of the target process (MUST preceed --run)\n";
	std::cerr << " --version                 : output version information and exit\n";
	std::cerr << " --dump-version            : display terse version string and exit\n";
	std::cerr << " --help                    : display this help and exit\n";

	for (QObject *plugin : edb::v1::plugin_list()) {
		if (auto p = qobject_cast<IPlugin *>(plugin)) {
			const QString s = p->extraArguments();
			if (!s.isEmpty()) {
				std::cerr << '\n';
				std::cerr << qPrintable(plugin->metaObject()->className()) << '\n';
				std::cerr << qPrintable(s) << '\n';
			}
		}
	}

	std::cerr << std::flush;
	std::exit(-1);
}

/**
 * @brief validate_launch_arguments
 * @param launch_args
 */
void validate_launch_arguments(const LaunchArguments &launch_args) {
	if (!launch_args.run_app.isEmpty() && launch_args.attach_pid) {
		std::cerr << "ERROR: Cannot specify both --attach and --run\n\n";
		usage();
	}

	if ((!launch_args.run_stdin.isEmpty() || !launch_args.run_stdout.isEmpty()) && launch_args.run_app.isEmpty()) {
		std::cerr << "ERROR: --stdin and --stdout MUST be combined with --run\n\n";
		usage();
	}
}

/**
 * attempts to load all plugins in a given directory
 *
 * @brief load_plugins
 * @param directory
 */
void load_plugins(const QString &directory) {

	QDir plugins_dir(qApp->applicationDirPath());

	// TODO(eteran): attempt to detect the same plugin being loaded twice
	// NOTE(eteran): if the plugins directory doesn't exist at all, this CD
	//               will fail and stay in the current directory. This actually
	//               is VERY nice behavior for us since it will allow
	//               running from the build directory without further config
	plugins_dir.cd(directory);

	Q_FOREACH (const QString &file_name, plugins_dir.entryList(QDir::Files)) {
		if (QLibrary::isLibrary(file_name)) {
			const QString full_path = plugins_dir.absoluteFilePath(file_name);
			QPluginLoader loader(full_path);
			loader.setLoadHints(QLibrary::ExportExternalSymbolsHint);

			if (QObject *const plugin = loader.instance()) {
				if (auto core_plugin = qobject_cast<IDebugger *>(plugin)) {
					if (!edb::v1::debugger_core) {
						edb::v1::debugger_core = core_plugin;

						// load in the settings that the core needs
						edb::v1::debugger_core->setIgnoredExceptions(edb::v1::config().ignored_exceptions);
					}
				} else if (qobject_cast<IPlugin *>(plugin)) {
					if (edb::internal::register_plugin(full_path, plugin)) {
					}
				}
			} else {
				qDebug() << "[load_plugins]" << qPrintable(loader.errorString());
			}
		}
	}
}

/**
 * starts the main debugger code
 *
 * @brief start_debugger
 * @param launch_args
 * @return
 */
int start_debugger(const LaunchArguments &launch_args) {

	edb::internal::load_function_db();

	// create the main window object
	Debugger debugger;

	qDebug() << "Starting edb version:" << EDB_VERSION_STRING;
	qDebug("Please Report Bugs & Requests At: https://github.com/eteran/edb-debugger/issues");

	// ok things are initialized to a reasonable degree, let's show the main window
	debugger.show();

	if (!edb::v1::debugger_core) {
		QMessageBox::warning(
			nullptr,
			tr("edb Failed To Load A Necessary Plugin"),
			tr("Failed to successfully load the debugger core plugin. Please make sure it exists and that the plugin path is correctly configured.\n"
			   "This is normal if edb has not been previously run or the configuration file has been removed."));

		edb::v1::dialog_options()->exec();

		QMessageBox::warning(
			nullptr,
			tr("edb"),
			tr("edb will now close. If you were successful in specifying the location of the debugger core plugin, please run edb again."));

		// TODO: detect if they corrected the issue and try again
		return -1;
	} else {
		// have we been asked to attach to a given program?
		if (launch_args.attach_pid) {
			debugger.attach(*launch_args.attach_pid);
		} else if (!launch_args.run_app.isEmpty()) {
			debugger.execute(launch_args.run_app, launch_args.run_args, launch_args.run_stdin, launch_args.run_stdout);
		}

		return qApp->exec();
	}
}

/**
 * @brief load_translations
 */
void load_translations() {
	// load some translations
	QTranslator qtTranslator;
	qtTranslator.load("qt_" + QLocale::system().name(), QLibraryInfo::location(QLibraryInfo::TranslationsPath));
	qApp->installTranslator(&qtTranslator);

	QTranslator myappTranslator;
	myappTranslator.load("edb_" + QLocale::system().name());
	qApp->installTranslator(&myappTranslator);
}

// See QtCreator: src/libs/utils/theme/theme.cpp

// If you copy QPalette, default values stay at default, even if that default is different
// within the context of different widgets. Create deep copy.
QPalette copyPalette(const QPalette &p) {
	QPalette res;
	for (int group = 0; group < QPalette::NColorGroups; ++group) {
		for (int role = 0; role < QPalette::NColorRoles; ++role) {
			res.setBrush(QPalette::ColorGroup(group),
						 QPalette::ColorRole(role),
						 p.brush(QPalette::ColorGroup(group), QPalette::ColorRole(role)));
		}
	}
	return res;
}

QPalette initialPalette() {
	static QPalette palette = copyPalette(QApplication::palette());
	return palette;
}

QPalette themePalette() {

	QPalette pal = initialPalette();

	Theme theme = Theme::load();

	const static struct {
		Theme::Palette paletteIndex;
		QPalette::ColorRole paletteColorRole;
		QPalette::ColorGroup paletteColorGroup;
		bool setColorRoleAsBrush;
	} mapping[] = {
		{Theme::Palette::Window, QPalette::Window, QPalette::All, false},
		{Theme::Palette::WindowDisabled, QPalette::Window, QPalette::Disabled, false},
		{Theme::Palette::WindowText, QPalette::WindowText, QPalette::All, true},
		{Theme::Palette::WindowTextDisabled, QPalette::WindowText, QPalette::Disabled, true},
		{Theme::Palette::Base, QPalette::Base, QPalette::All, false},
		{Theme::Palette::BaseDisabled, QPalette::Base, QPalette::Disabled, false},
		{Theme::Palette::AlternateBase, QPalette::AlternateBase, QPalette::All, false},
		{Theme::Palette::AlternateBaseDisabled, QPalette::AlternateBase, QPalette::Disabled, false},
		{Theme::Palette::ToolTipBase, QPalette::ToolTipBase, QPalette::All, true},
		{Theme::Palette::ToolTipBaseDisabled, QPalette::ToolTipBase, QPalette::Disabled, true},
		{Theme::Palette::ToolTipText, QPalette::ToolTipText, QPalette::All, false},
		{Theme::Palette::ToolTipTextDisabled, QPalette::ToolTipText, QPalette::Disabled, false},
		{Theme::Palette::Text, QPalette::Text, QPalette::All, true},
		{Theme::Palette::TextDisabled, QPalette::Text, QPalette::Disabled, true},
		{Theme::Palette::Button, QPalette::Button, QPalette::All, false},
		{Theme::Palette::ButtonDisabled, QPalette::Button, QPalette::Disabled, false},
		{Theme::Palette::ButtonText, QPalette::ButtonText, QPalette::All, true},
		{Theme::Palette::ButtonTextDisabled, QPalette::ButtonText, QPalette::Disabled, true},
		{Theme::Palette::BrightText, QPalette::BrightText, QPalette::All, false},
		{Theme::Palette::BrightTextDisabled, QPalette::BrightText, QPalette::Disabled, false},
		{Theme::Palette::Highlight, QPalette::Highlight, QPalette::All, true},
		{Theme::Palette::HighlightDisabled, QPalette::Highlight, QPalette::Disabled, true},
		{Theme::Palette::HighlightedText, QPalette::HighlightedText, QPalette::All, true},
		{Theme::Palette::HighlightedTextDisabled, QPalette::HighlightedText, QPalette::Disabled, true},
		{Theme::Palette::Link, QPalette::Link, QPalette::All, false},
		{Theme::Palette::LinkDisabled, QPalette::Link, QPalette::Disabled, false},
		{Theme::Palette::LinkVisited, QPalette::LinkVisited, QPalette::All, false},
		{Theme::Palette::LinkVisitedDisabled, QPalette::LinkVisited, QPalette::Disabled, false},
		{Theme::Palette::Light, QPalette::Light, QPalette::All, false},
		{Theme::Palette::LightDisabled, QPalette::Light, QPalette::Disabled, false},
		{Theme::Palette::Midlight, QPalette::Midlight, QPalette::All, false},
		{Theme::Palette::MidlightDisabled, QPalette::Midlight, QPalette::Disabled, false},
		{Theme::Palette::Dark, QPalette::Dark, QPalette::All, false},
		{Theme::Palette::DarkDisabled, QPalette::Dark, QPalette::Disabled, false},
		{Theme::Palette::Mid, QPalette::Mid, QPalette::All, false},
		{Theme::Palette::MidDisabled, QPalette::Mid, QPalette::Disabled, false},
		{Theme::Palette::Shadow, QPalette::Shadow, QPalette::All, false},
		{Theme::Palette::ShadowDisabled, QPalette::Shadow, QPalette::Disabled, false}};

	for (auto entry : mapping) {
		const QColor themeColor = theme.palette[entry.paletteIndex];
		// Use original color if color is not defined in theme.
		if (themeColor.isValid()) {
			if (entry.setColorRoleAsBrush)
				// TODO: Find out why sometimes setBrush is used
				pal.setBrush(entry.paletteColorGroup, entry.paletteColorRole, themeColor);
			else
				pal.setColor(entry.paletteColorGroup, entry.paletteColorRole, themeColor);
		}
	}

	return pal;
}

}

/**
 * @brief main
 * @param argc
 * @param argv
 * @return
 */
int main(int argc, char *argv[]) {

	QT_REQUIRE_VERSION(argc, argv, "5.9.0");

	QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
	QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);

	QApplication app(argc, argv);
	QApplication::setWindowIcon(QIcon(":/debugger/images/edb48-logo.png"));

	// setup organization info so settings go in right place
	QApplication::setOrganizationName("codef00.com");
	QApplication::setOrganizationDomain("codef00.com");
	QApplication::setApplicationName("edb");
	QApplication::setApplicationVersion(EDB_VERSION_STRING);

	load_translations();

	// look for some plugins..
	load_plugins(edb::v1::config().plugin_path);

	QStringList args = app.arguments();

	// call the parseArguments function for each plugin
	for (QObject *plugin : edb::v1::plugin_list()) {
		if (auto p = qobject_cast<IPlugin *>(plugin)) {

			const IPlugin::ArgumentStatus r = p->parseArguments(args);
			switch (r) {
			case IPlugin::ARG_ERROR:
				usage();
			case IPlugin::ARG_EXIT:
				std::exit(0);
			default:
				break;
			}
		}
	}

	LaunchArguments launch_args;

	for (int i = 1; i < args.size(); ++i) {

		if (args[i] == "--version") {
			std::cout << "edb version: " << EDB_VERSION_STRING << std::endl;
			return 0;
		} else if (args[i] == "--dump-version") {
			std::cout << EDB_VERSION_STRING << std::endl;
			return 0;
		} else if (args[i] == "--attach") {
			++i;
			if (i >= args.size()) {
				usage();
			}
			launch_args.attach_pid = args[i].toUInt();
		} else if (args[i] == "--run") {
			++i;
			if (i >= args.size()) {
				usage();
			}

			launch_args.run_app = args[i++];

			for (; i < args.size(); ++i) {
				// NOTE(eteran): we are using argv here, not args, because
				// we want to avoid any unicode conversions
				launch_args.run_args.push_back(argv[i]);
			}
		} else if (args[i] == "--stdin") {
			++i;
			if (i >= args.size()) {
				usage();
			}
			launch_args.run_stdin = args[i];
		} else if (args[i] == "--stdout") {
			++i;
			if (i >= args.size()) {
				usage();
			}
			launch_args.run_stdout = args[i];
		} else {
			usage();
		}
	}

	validate_launch_arguments(launch_args);

	QApplication::setPalette(themePalette());

	// Light/Dark icons on all platforms
	if (QApplication::palette().window().color().lightnessF() >= 0.5) {
		QIcon::setThemeName(QLatin1String("breeze-edb"));
	} else {
		QIcon::setThemeName(QLatin1String("breeze-dark-edb"));
	}

	return start_debugger(launch_args);
}

```

`src/res/breeze-dark-edb.qrc`:

```qrc
<RCC>
    <qresource prefix="/icons/breeze-dark-edb">
        <file alias="index.theme">icons/breeze-dark-edb/index.theme</file>
		<file alias="16x16/tab-new.png">icons/breeze-dark-edb/16x16/tab-new.png</file>
		<file alias="16x16/tab-close.png">icons/breeze-dark-edb/16x16/tab-close.png</file>
		<file alias="16x16/application-exit.svg">icons/breeze-dark-edb/16x16/application-exit.svg</file>
		<file alias="16x16/code-context.svg">icons/breeze-dark-edb/16x16/code-context.svg</file>
		<file alias="16x16/configure.svg">icons/breeze-dark-edb/16x16/configure.svg</file>
		<file alias="16x16/dialog-close.svg">icons/breeze-dark-edb/16x16/dialog-close.svg</file>
		<file alias="16x16/document-export.svg">icons/breeze-dark-edb/16x16/document-export.svg</file>
		<file alias="16x16/document-import.svg">icons/breeze-dark-edb/16x16/document-import.svg</file>
		<file alias="16x16/document-open-recent.svg">icons/breeze-dark-edb/16x16/document-open-recent.svg</file>
		<file alias="16x16/document-open.svg">icons/breeze-dark-edb/16x16/document-open.svg</file>
		<file alias="16x16/edit-clear-list.svg">icons/breeze-dark-edb/16x16/edit-clear-list.svg</file>
		<file alias="16x16/edit-find.svg">icons/breeze-dark-edb/16x16/edit-find.svg</file>
		<file alias="16x16/edit-undo.svg">icons/breeze-dark-edb/16x16/edit-undo.svg</file>
		<file alias="16x16/help-about.svg">icons/breeze-dark-edb/16x16/help-about.svg</file>
		<file alias="16x16/help-contents.svg">icons/breeze-dark-edb/16x16/help-contents.svg</file>
		<file alias="16x16/list-add.svg">icons/breeze-dark-edb/16x16/list-add.svg</file>
		<file alias="16x16/list-remove.svg">icons/breeze-dark-edb/16x16/list-remove.svg</file>
		<file alias="16x16/view-refresh.svg">icons/breeze-dark-edb/16x16/view-refresh.svg</file>
		<file alias="16x16/view-restore.svg">icons/breeze-dark-edb/16x16/view-restore.svg</file>
		<file alias="24x24/distribute-graph.svg">icons/breeze-dark-edb/24x24/distribute-graph.svg</file>
		<file alias="64x64/debug-close.png">icons/breeze-dark-edb/64x64/debug-close.png</file>
		<file alias="64x64/debug-kill.png">icons/breeze-dark-edb/64x64/debug-kill.png</file>
		<file alias="64x64/debug-pause.png">icons/breeze-dark-edb/64x64/debug-pause.png</file>
		<file alias="64x64/debug-restart.png">icons/breeze-dark-edb/64x64/debug-restart.png</file>
		<file alias="64x64/debug-run.png">icons/breeze-dark-edb/64x64/debug-run.png</file>
		<file alias="64x64/debug-step-into.png">icons/breeze-dark-edb/64x64/debug-step-into.png</file>
		<file alias="64x64/debug-step-out.png">icons/breeze-dark-edb/64x64/debug-step-out.png</file>
		<file alias="64x64/debug-step-over.png">icons/breeze-dark-edb/64x64/debug-step-over.png</file>
		<file alias="64x64/memory-slot.png">icons/breeze-dark-edb/64x64/memory-slot.png</file>
		<file alias="64x64/plugin.png">icons/breeze-dark-edb/64x64/plugin.png</file>
    </qresource>
</RCC>

```

`src/res/breeze-edb.qrc`:

```qrc
<RCC>
	<qresource prefix="/icons/breeze-edb">
		<file alias="index.theme">icons/breeze-edb/index.theme</file>
		<file alias="16x16/tab-new.png">icons/breeze-edb/16x16/tab-new.png</file>
		<file alias="16x16/tab-close.png">icons/breeze-edb/16x16/tab-close.png</file>
		<file alias="16x16/application-exit.svg">icons/breeze-edb/16x16/application-exit.svg</file>
		<file alias="16x16/code-context.svg">icons/breeze-edb/16x16/code-context.svg</file>
		<file alias="16x16/configure.svg">icons/breeze-edb/16x16/configure.svg</file>
		<file alias="16x16/dialog-close.svg">icons/breeze-edb/16x16/dialog-close.svg</file>
		<file alias="16x16/document-export.svg">icons/breeze-edb/16x16/document-export.svg</file>
		<file alias="16x16/document-import.svg">icons/breeze-edb/16x16/document-import.svg</file>
		<file alias="16x16/document-open-recent.svg">icons/breeze-edb/16x16/document-open-recent.svg</file>
		<file alias="16x16/document-open.svg">icons/breeze-edb/16x16/document-open.svg</file>
		<file alias="16x16/edit-clear-list.svg">icons/breeze-edb/16x16/edit-clear-list.svg</file>
		<file alias="16x16/edit-find.svg">icons/breeze-edb/16x16/edit-find.svg</file>
		<file alias="16x16/edit-undo.svg">icons/breeze-edb/16x16/edit-undo.svg</file>
		<file alias="16x16/help-about.svg">icons/breeze-edb/16x16/help-about.svg</file>
		<file alias="16x16/help-contents.svg">icons/breeze-edb/16x16/help-contents.svg</file>
		<file alias="16x16/list-add.svg">icons/breeze-edb/16x16/list-add.svg</file>
		<file alias="16x16/list-remove.svg">icons/breeze-edb/16x16/list-remove.svg</file>
		<file alias="16x16/view-refresh.svg">icons/breeze-edb/16x16/view-refresh.svg</file>
		<file alias="16x16/view-restore.svg">icons/breeze-edb/16x16/view-restore.svg</file>
		<file alias="24x24/distribute-graph.svg">icons/breeze-edb/24x24/distribute-graph.svg</file>
		<file alias="64x64/debug-close.png">icons/breeze-edb/64x64/debug-close.png</file>
		<file alias="64x64/debug-kill.png">icons/breeze-edb/64x64/debug-kill.png</file>
		<file alias="64x64/debug-pause.png">icons/breeze-edb/64x64/debug-pause.png</file>
		<file alias="64x64/debug-restart.png">icons/breeze-edb/64x64/debug-restart.png</file>
		<file alias="64x64/debug-run.png">icons/breeze-edb/64x64/debug-run.png</file>
		<file alias="64x64/debug-step-into.png">icons/breeze-edb/64x64/debug-step-into.png</file>
		<file alias="64x64/debug-step-out.png">icons/breeze-edb/64x64/debug-step-out.png</file>
		<file alias="64x64/debug-step-over.png">icons/breeze-edb/64x64/debug-step-over.png</file>
		<file alias="64x64/memory-slot.png">icons/breeze-edb/64x64/memory-slot.png</file>
		<file alias="64x64/plugin.png">icons/breeze-edb/64x64/plugin.png</file>
	</qresource>
</RCC>

```

`src/res/debugger.qrc`:

```qrc
<RCC>
    <qresource prefix="/debugger">
        <file>images/edb100-logo.png</file>
        <file>images/edb48-logo.png</file>
        <file>xml/functions.xml</file>
        <file>xml/syscalls.xml</file>
        <file>images/arrow-right.svg</file>
        <file>images/arrow-right-red.svg</file>
        <file>images/breakpoint.svg</file>
    </qresource>
</RCC>

```

`src/res/edb.rc`:

```rc
IDI_MAIN                ICON                    "images\\edb.ico"

```

`src/res/icons/breeze-dark-edb/16x16/application-exit.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      .ColorScheme-NegativeText {
        color:#da4453;
      }
      </style>
  </defs>
  <path
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     class="ColorScheme-NegativeText"
     d="m2 2v12h12v-12zm1 3h10v8h-10zm3 3v2h4v-2z"
      />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/code-context.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 6 2 C 4.895478 2 4 2.8954778 4 4 L 4 6 L 4 7 C 4 7.2761493 3.7761423 7.5 3.5 7.5 L 3 7.5 L 3 8.5 L 3.5 8.5 C 3.7761423 8.5 4 8.7238507 4 9 L 4 10 L 4 11 L 4 12 C 4 13.104597 4.8954307 14 6 14 L 7 14 L 7 13 L 6 13 C 5.4477157 13 5 12.552299 5 12 L 5 11 L 5 10 L 5 9 C 5 8.617501 4.8607153 8.2649743 4.625 8 C 4.8607153 7.7350257 5 7.382499 5 7 L 5 6 L 5 5.71875 L 5 4 C 5 3.4477014 5.4477765 3 6 3 L 7 3 L 7 2 L 6 2 z M 9 2 L 9 3 L 10 3 C 10.552224 3 11 3.4477014 11 4 L 11 5.71875 L 11 6 L 11 7 C 11 7.382499 11.139285 7.7350257 11.375 8 C 11.139285 8.2649743 11 8.617501 11 9 L 11 10 L 11 11 L 11 12 C 11 12.552299 10.552284 13 10 13 L 9 13 L 9 14 L 10 14 C 11.104569 14 12 13.104597 12 12 L 12 11 L 12 10 L 12 9 C 12 8.7238507 12.223858 8.5 12.5 8.5 L 13 8.5 L 13 7.5 L 12.5 7.5 C 12.223858 7.5 12 7.2761493 12 7 L 12 6 L 12 4 C 12 2.8954778 11.104522 2 10 2 L 9 2 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/configure.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
       d="M 10 2.5 C 9.0680195 2.5 8.2844627 3.1373007 8.0625 4 L 2 4 L 2 5 L 8.0625 5 C 8.2844627 5.8626993 9.0680195 6.5 10 6.5 C 10.931981 6.5 11.715537 5.8626993 11.9375 5 L 14 5 L 14 4 L 11.9375 4 C 11.715537 3.1373007 10.931981 2.5 10 2.5 z M 5 9.5 C 4.0680191 9.5 3.2844626 10.137301 3.0625 11 L 2 11 L 2 12 L 3.0625 12 C 3.2844626 12.862699 4.0680191 13.5 5 13.5 C 5.9319809 13.5 6.7155374 12.862699 6.9375 12 L 7 12 L 9 12 L 14 12 L 14 11 L 9 11 L 7 11 L 6.9375 11 C 6.7155374 10.137301 5.9319809 9.5 5 9.5 z M 5 10.5 C 5.55228 10.5 6 10.94772 6 11.5 C 6 12.05228 5.55228 12.5 5 12.5 C 4.44772 12.5 4 12.05228 4 11.5 C 4 10.94772 4.44772 10.5 5 10.5 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/dialog-close.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      .ColorScheme-NegativeText {
        color:#da4453;
      }
      </style>
  </defs>
  <path
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     class="ColorScheme-NegativeText"
    d="M 8,2 A 6,6 0 0 0 2,8 6,6 0 0 0 8,14 6,6 0 0 0 14,8 6,6 0 0 0 8,2 Z M 5.70703,5 8,7.29297 10.29297,5 11,5.70703 8.70703,8 11,10.29297 10.29297,11 8,8.70703 5.70703,11 5,10.29297 7.29297,8 5,5.70703 5.70703,5 Z"
        />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/dialog-information.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
    <path 
        style="fill:currentColor;fill-opacity:1;stroke:none" 
          d="M 2 2 L 2 12 L 5 15 L 5 12 L 14 12 L 14 2 L 2 2 z M 3 3 L 13 3 L 13 11 L 3 11 L 3 3 z M 7 4 L 7 5 L 9 5 L 9 4 L 7 4 z M 7 6 L 7 10 L 9 10 L 9 6 L 7 6 z "
          id="rect4163" 
          class="ColorScheme-Text"/>
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/document-export.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
       d="M 3 2 L 3 11 L 3 12 L 5 12 L 7.0859375 12 L 6.4140625 12.671875 L 5.4648438 13.621094 L 6.171875 14.328125 L 7.1210938 13.378906 L 9 11.5 L 7.1210938 9.6210938 L 6.171875 8.671875 L 5.4648438 9.3789062 L 6.4140625 10.328125 L 7.0859375 11 L 5 11 L 4 11 L 4 3 L 12 3 L 12 13 L 9 13 L 9 14 L 13 14 L 13 2 L 3 2 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/document-import.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
       d="m 434.71429,533.79074 v 9 1 h -2 -2.08594 l 0.67188,0.67188 0.94922,0.94921 -0.70704,0.70704 -0.94921,-0.94922 -1.87891,-1.87891 1.87891,-1.87891 0.94921,-0.94921 0.70704,0.70703 -0.94922,0.94922 -0.67188,0.67187 h 2.08594 1 v -8 h -8 v 10 h 3 v 1 h -4 v -12 z"
       transform="translate(-421.71429,-531.79074)"
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/document-open-recent.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 3 2 L 3 3 L 3 13 L 3 14 L 6 14 L 6 13 L 4 13 L 4 3 L 6 3 L 7 3 L 9 3 L 11 3 L 12 3 L 12 5 L 13 5 L 13 2 L 12 2 L 9 2 L 7 2 L 6 2 L 3 2 z M 10 6 C 7.784 6 6 7.784 6 10 C 6 12.216 7.784 14 10 14 C 12.216 14 14 12.216 14 10 C 14 7.784 12.216 6 10 6 z M 10 7 C 11.66199 7 13 8.338 13 10 C 13 11.662 11.66199 13 10 13 C 8.33801 13 7 11.662 7 10 C 7 8.338 8.33801 7 10 7 z M 9 8 L 9 10 L 9 11 L 10 11 L 11 11 L 11 10 L 10 10 L 10 8 L 9 8 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/document-open.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 2 2 L 2 3 L 2 6 L 2 7 L 2 13 L 2 14 L 14 14 L 14 13 L 14 6 L 14 5 L 14 4 L 9.0078125 4 L 7.0078125 2 L 7 2.0078125 L 7 2 L 3 2 L 2 2 z M 3 3 L 6.5917969 3 L 7.59375 4 L 7 4 L 7 4.0078125 L 6.9921875 4 L 4.9921875 6 L 3 6 L 3 3 z M 3 7 L 13 7 L 13 13 L 3 13 L 3 7 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/edit-clear-list.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 6 2 L 0.70703125 7.2929688 L 0 8 L 0.70703125 8.7070312 L 6 14 L 15 14 L 16 14 L 16 2 L 15 2 L 6 2 z M 8.0019531 5 L 10.011719 7.0097656 L 12.021484 5 L 13.011719 5.9902344 L 11.001953 8 L 13.011719 10.009766 L 12.021484 11 L 10.011719 8.9902344 L 8.0019531 11 L 7.0117188 10.009766 L 9.0214844 8 L 7.0117188 5.9902344 L 8.0019531 5 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/edit-find.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 6.5 2 C 4.007 2 2 4.01 2 6.5 C 2 8.993 4.01 11 6.5 11 C 7.5636432 11 8.5263409 10.618801 9.2949219 10.005859 L 13.292969 14.003906 L 14 13.296875 L 10.001953 9.2988281 C 10.617604 8.529048 11 7.565338 11 6.5 C 11 4.007 8.99 2 6.5 2 z M 6.5 3 C 8.439 3 10 4.561 10 6.5 C 10 8.439 8.439 10 6.5 10 C 4.561 10 3 8.439 3 6.5 C 3 4.561 4.561 3 6.5 3 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/edit-undo.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 6.5 2 L 3.21875 5.28125 L 3 5.5 L 3.21875 5.71875 L 6.5 9 L 7.21875 8.28125 L 4.90625 6 L 6 6 L 7.1875 6 L 8 6 L 8.5 6 C 10.432998 6 12 7.5669984 12 9.5 C 12 11.433002 10.432998 13 8.5 13 L 8 13 L 7 13 L 7 14 L 8 14 L 8.5 14 C 10.985283 14 13 11.985252 13 9.5 C 13 7.0147479 10.985283 5 8.5 5 L 8 5 L 7.1875 5 L 6 5 L 4.90625 5 L 7.21875 2.71875 L 6.5 2 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/help-about.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="m7.5 3c-3.038 0-5.5 2.462-5.5 5.5 0 3.038 2.462 5.5 5.5 5.5 3.038 0 5.5-2.462 5.5-5.5 0-3.038-2.462-5.5-5.5-5.5m0 1c2.485 0 4.5 2.01 4.5 4.5 0 2.485-2.01 4.5-4.5 4.5-2.485 0-4.5-2.01-4.5-4.5 0-2.485 2.01-4.5 4.5-4.5m-.5 1v1h1v-1zm0 2v5h1v-5z"
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/help-contents.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path 
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 8 2 A 6 6 0 0 0 2 8 A 6 6 0 0 0 8 14 A 6 6 0 0 0 14 8 A 6 6 0 0 0 8 2 z M 2 3 L 2 5 L 4 3 L 2 3 z M 8 3 A 5 5 0 0 1 10.390625 3.609375 L 8.8691406 5.1308594 A 3 3 0 0 0 8 5 A 3 3 0 0 0 7.1308594 5.1308594 L 5.6132812 3.6132812 A 5 5 0 0 1 8 3 z M 12 3 L 14 5 L 14 3 L 12 3 z M 3.609375 5.609375 L 5.1308594 7.1308594 A 3 3 0 0 0 5 8 A 3 3 0 0 0 5.1308594 8.8691406 L 3.6132812 10.386719 A 5 5 0 0 1 3 8 A 5 5 0 0 1 3.609375 5.609375 z M 12.386719 5.6132812 A 5 5 0 0 1 13 8 A 5 5 0 0 1 12.390625 10.390625 L 10.869141 8.8691406 A 3 3 0 0 0 11 8 A 3 3 0 0 0 10.869141 7.1308594 L 12.386719 5.6132812 z M 8 6 A 2 2 0 0 1 10 8 A 2 2 0 0 1 8 10 A 2 2 0 0 1 6 8 A 2 2 0 0 1 8 6 z M 7.1308594 10.869141 A 3 3 0 0 0 8 11 A 3 3 0 0 0 8.8691406 10.869141 L 10.386719 12.386719 A 5 5 0 0 1 8 13 A 5 5 0 0 1 5.609375 12.390625 L 7.1308594 10.869141 z M 2 11 L 2 13 L 4 13 L 2 11 z M 14 11 L 12 13 L 14 13 L 14 11 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/list-add.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 7 3.0058594 L 7 8 L 2 8 L 2 8.9980469 L 7 8.9980469 L 7 14.007812 L 8 14.007812 L 8 8.9980469 L 13 8.9980469 L 13 8 L 8 8 L 8 3.0058594 L 7 3.0058594 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/list-remove.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 3,7 3,9 13,9 13,7 3,7 Z"
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/view-refresh.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
       d="M 8 2 C 6.8911827 2 5.8599294 2.3193334 4.96875 2.84375 L 5.53125 3.40625 L 5.71875 3.59375 L 7.65625 5.53125 L 8.375 4.8125 L 6.75 3.1875 C 6.94534 3.1364099 7.1398623 3.0897842 7.34375 3.0625 C 7.3961563 3.0547113 7.4470287 3.0373165 7.5 3.03125 C 7.6680854 3.01418 7.827411 3 8 3 C 10.761424 3 13 5.2385759 13 8 C 13 8.243024 12.97155 8.4855082 12.9375 8.71875 C 12.917545 8.8549993 12.905714 8.9925532 12.875 9.125 C 12.80805 9.4115815 12.708353 9.672624 12.59375 9.9375 C 12.580478 9.9681753 12.576374 10.000899 12.5625 10.03125 C 12.521539 10.122908 12.454245 10.194583 12.40625 10.28125 C 12.401797 10.289291 12.410582 10.304303 12.40625 10.3125 L 13.15625 11.03125 C 13.680667 10.140071 14 9.108818 14 8 C 14 4.6862909 11.313707 2 8 2 z M 2.84375 4.96875 C 2.3193332 5.8599294 2 6.891182 2 8 C 2 11.313709 4.6862934 14 8 14 C 9.1088173 14 10.140071 13.680667 11.03125 13.15625 L 10.46875 12.59375 L 10.28125 12.40625 L 8.34375 10.5 L 7.65625 11.1875 L 9.25 12.8125 C 9.05466 12.86359 8.8601377 12.910216 8.65625 12.9375 C 8.6038437 12.945289 8.5529713 12.962684 8.5 12.96875 C 8.3319146 12.98582 8.172589 13 8 13 C 7.827411 13 7.6680854 12.98582 7.5 12.96875 C 7.3319147 12.95168 7.162744 12.939552 7 12.90625 C 4.7215847 12.440019 3 10.416246 3 8 C 3 7.7517374 3.0275593 7.5198138 3.0625 7.28125 C 3.0824555 7.1450007 3.0942865 7.0074468 3.125 6.875 C 3.1919502 6.5884185 3.2916465 6.327376 3.40625 6.0625 C 3.4192426 6.031782 3.4239145 5.9991506 3.4375 5.96875 C 3.4781185 5.8798895 3.5461122 5.8040145 3.59375 5.71875 L 3.59375 5.6875 L 2.84375 4.96875 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/16x16/view-restore.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
       d="M 6 2 L 8 4 L 10 2 L 6 2 z M 8 4 L 4 4 L 4 8 L 4 12 L 8 12 L 12 12 L 12 8 L 12 4 L 8 4 z M 12 8 L 14 10 L 14 6 L 12 8 z M 8 12 L 6 14 L 10 14 L 8 12 z M 4 8 L 2 6 L 2 10 L 4 8 z M 5 6 L 11 6 L 11 11 L 5 11 L 5 6 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/24x24/dialog-information.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      </style>
  </defs>
  <g transform="translate(1,1)">
    <path style="fill:currentColor;fill-opacity:1;stroke:none" d="M 3 3 L 3 15 L 6 19 L 6 16 L 6 15 L 19 15 L 19 3 L 3 3 z M 4 4 L 18 4 L 18 14 L 4 14 L 4 4 z M 10 5 L 10 6 L 12 6 L 12 5 L 10 5 z M 10 7 L 10 13 L 12 13 L 12 7 L 10 7 z " class="ColorScheme-Text"/>
  </g>
</svg>

```

`src/res/icons/breeze-dark-edb/24x24/distribute-graph.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#eff0f1;
      }
      .ColorScheme-Highlight {
        color:#3daee9;
      }
      </style>
  </defs>
 <path 
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 8.6875 5.6113281 L 3.6875 9.6113281 L 4.3125 10.390625 L 9.3125 6.390625 L 8.6875 5.6113281 z M 10.384766 5.6816406 L 9.6152344 6.3203125 L 14.615234 12.320312 L 15.384766 11.681641 L 10.384766 5.6816406 z M 19.583984 5.7226562 L 15.583984 11.722656 L 16.416016 12.277344 L 20.416016 6.2773438 L 19.583984 5.7226562 z M 3 10.998047 L 3 17.998047 L 4 17.998047 L 4 10.998047 L 3 10.998047 z M 4 17.998047 L 4 18.998047 L 10 18.998047 L 10 17.998047 L 4 17.998047 z M 14.609375 12.689453 L 10.609375 17.689453 L 11.390625 18.3125 L 15.390625 13.3125 L 14.609375 12.689453 z M 16.390625 12.689453 L 15.609375 13.3125 L 19.609375 18.3125 L 20.390625 17.689453 L 16.390625 12.689453 z "
     class="ColorScheme-Text"
     />
 <path 
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 9.5 4 A 1.4999959 1.5 0 0 0 8 5.5 A 1.4999959 1.5 0 0 0 9.5 7 A 1.4999959 1.5 0 0 0 11 5.5 A 1.4999959 1.5 0 0 0 9.5 4 z M 20.5 4 A 1.4999959 1.5 0 0 0 19 5.5 A 1.4999959 1.5 0 0 0 20.5 7 A 1.4999959 1.5 0 0 0 22 5.5 A 1.4999959 1.5 0 0 0 20.5 4 z M 3.5 9 A 1.4999959 1.5 0 0 0 2 10.5 A 1.4999959 1.5 0 0 0 3.5 12 A 1.4999959 1.5 0 0 0 5 10.5 A 1.4999959 1.5 0 0 0 3.5 9 z M 15.5 11 A 1.4999959 1.5 0 0 0 14 12.5 A 1.4999959 1.5 0 0 0 15.5 14 A 1.4999959 1.5 0 0 0 17 12.5 A 1.4999959 1.5 0 0 0 15.5 11 z M 3.5 17 A 1.4999959 1.5 0 0 0 2 18.5 A 1.4999959 1.5 0 0 0 3.5 20 A 1.4999959 1.5 0 0 0 5 18.5 A 1.4999959 1.5 0 0 0 3.5 17 z M 10.5 17 A 1.4999959 1.5 0 0 0 9 18.5 A 1.4999959 1.5 0 0 0 10.5 20 A 1.4999959 1.5 0 0 0 12 18.5 A 1.4999959 1.5 0 0 0 10.5 17 z M 20.5 17 A 1.4999959 1.5 0 0 0 19 18.5 A 1.4999959 1.5 0 0 0 20.5 20 A 1.4999959 1.5 0 0 0 22 18.5 A 1.4999959 1.5 0 0 0 20.5 17 z "
     class="ColorScheme-Highlight"
     />
</svg>

```

`src/res/icons/breeze-dark-edb/64x64/dialog-information.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<!-- Created with Inkscape (http://www.inkscape.org/) -->
<svg width="64" version="1.1" xmlns="http://www.w3.org/2000/svg" height="64" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
 <defs id="defs3811">
  <linearGradient inkscape:collect="always" xlink:href="#linearGradient4143" id="linearGradient4416" y1="43.999989" y2="6.999989" x2="0" gradientUnits="userSpaceOnUse" gradientTransform="matrix(-1.4054053 0 0 1.4054053 804.69502 154.09579)"/>
  <linearGradient inkscape:collect="always" id="linearGradient4143">
   <stop style="stop-color:#197cf1" id="stop4145"/>
   <stop offset="1" style="stop-color:#20bcfa" id="stop4147"/>
  </linearGradient>
  <linearGradient inkscape:collect="always" id="linearGradient4290">
   <stop style="stop-color:#7cbaf8" id="stop4292"/>
   <stop offset="1" style="stop-color:#f4fcff" id="stop4294"/>
  </linearGradient>
  <linearGradient inkscape:collect="always" id="linearGradient4144" xlink:href="#linearGradient4290" y1="29.999973" y2="2" gradientUnits="userSpaceOnUse" x2="0" gradientTransform="matrix(2 0 0 2 735.85719 152.93361)"/>
  <linearGradient inkscape:collect="always" id="linearGradient4227">
   <stop style="stop-color:#292c2f" id="stop4229"/>
   <stop offset="1" style="stop-opacity:0" id="stop4231"/>
  </linearGradient>
  <linearGradient inkscape:collect="always" id="linearGradient4191" xlink:href="#linearGradient4227" y1="9" y2="23" x1="9.00001" gradientUnits="userSpaceOnUse" x2="23.00004" gradientTransform="matrix(2 0 0 2 -0.99999 -5)"/>
 </defs>
 <metadata id="metadata3814"/>
 <g inkscape:label="Layer 1" inkscape:groupmode="layer" id="layer1" transform="matrix(1 0 0 1 -736.85718 -157.93361)">
  <path inkscape:connector-curvature="0" style="fill:url(#linearGradient4416);fill-rule:evenodd" id="path4445" d="m 794.85718,163.93361 0,37.94594 -25.29727,0 -14.05412,14.05406 0,-14.05406 -12.64861,0 0,-37.94594 z"/>
  <path style="fill:url(#linearGradient4191);opacity:0.2;fill-rule:evenodd" id="path4184" d="M 33 13 L 29 17 L 33 21 L 29 37 L 35.945312 43.945312 L 58 43.945312 L 58 38 L 33 13 z " transform="matrix(1 0 0 1 736.85718 157.93361)"/>
  <path inkscape:connector-curvature="0" style="fill:url(#linearGradient4144)" id="rect4133" d="m 765.85719,170.93361 0,4 4,0 0,-4 z m 0,8 0,16 4,0 0,-16 z"/>
  <path style="fill:#0c69cf;fill-rule:evenodd" id="path4256" d="M 6 42.945312 L 6 43.945312 L 18.648438 43.945312 L 18.648438 42.945312 L 6 42.945312 z M 32.703125 42.945312 L 18.648438 57 L 18.648438 58 L 32.703125 43.945312 L 58 43.945312 L 58 42.945312 L 32.703125 42.945312 z " transform="matrix(1 0 0 1 736.85718 157.93361)"/>
 </g>
</svg>

```

`src/res/icons/breeze-dark-edb/index.theme`:

```theme
[Icon Theme]
Name=Breeze Dark edb
Comment=Breeze Dark Icon Theme for edb
Inherits=breeze-dark
Directories=16x16,24x24,64x64

[16x16]
Size=16

[24x24]
Size=24

[64x64]
Size=64

```

`src/res/icons/breeze-edb/16x16/application-exit.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      .ColorScheme-NegativeText {
        color:#da4453;
      }
      </style>
  </defs>
  <path
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     class="ColorScheme-NegativeText"
     d="m2 2v12h12v-12zm1 3h10v8h-10zm3 3v2h4v-2z"
      />
</svg>

```

`src/res/icons/breeze-edb/16x16/code-context.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 6 2 C 4.895478 2 4 2.8954778 4 4 L 4 6 L 4 7 C 4 7.2761493 3.7761423 7.5 3.5 7.5 L 3 7.5 L 3 8.5 L 3.5 8.5 C 3.7761423 8.5 4 8.7238507 4 9 L 4 10 L 4 11 L 4 12 C 4 13.104597 4.8954307 14 6 14 L 7 14 L 7 13 L 6 13 C 5.4477157 13 5 12.552299 5 12 L 5 11 L 5 10 L 5 9 C 5 8.617501 4.8607153 8.2649743 4.625 8 C 4.8607153 7.7350257 5 7.382499 5 7 L 5 6 L 5 5.71875 L 5 4 C 5 3.4477014 5.4477765 3 6 3 L 7 3 L 7 2 L 6 2 z M 9 2 L 9 3 L 10 3 C 10.552224 3 11 3.4477014 11 4 L 11 5.71875 L 11 6 L 11 7 C 11 7.382499 11.139285 7.7350257 11.375 8 C 11.139285 8.2649743 11 8.617501 11 9 L 11 10 L 11 11 L 11 12 C 11 12.552299 10.552284 13 10 13 L 9 13 L 9 14 L 10 14 C 11.104569 14 12 13.104597 12 12 L 12 11 L 12 10 L 12 9 C 12 8.7238507 12.223858 8.5 12.5 8.5 L 13 8.5 L 13 7.5 L 12.5 7.5 C 12.223858 7.5 12 7.2761493 12 7 L 12 6 L 12 4 C 12 2.8954778 11.104522 2 10 2 L 9 2 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/configure.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
       d="M 10 2.5 C 9.0680195 2.5 8.2844627 3.1373007 8.0625 4 L 2 4 L 2 5 L 8.0625 5 C 8.2844627 5.8626993 9.0680195 6.5 10 6.5 C 10.931981 6.5 11.715537 5.8626993 11.9375 5 L 14 5 L 14 4 L 11.9375 4 C 11.715537 3.1373007 10.931981 2.5 10 2.5 z M 5 9.5 C 4.0680191 9.5 3.2844626 10.137301 3.0625 11 L 2 11 L 2 12 L 3.0625 12 C 3.2844626 12.862699 4.0680191 13.5 5 13.5 C 5.9319809 13.5 6.7155374 12.862699 6.9375 12 L 7 12 L 9 12 L 14 12 L 14 11 L 9 11 L 7 11 L 6.9375 11 C 6.7155374 10.137301 5.9319809 9.5 5 9.5 z M 5 10.5 C 5.55228 10.5 6 10.94772 6 11.5 C 6 12.05228 5.55228 12.5 5 12.5 C 4.44772 12.5 4 12.05228 4 11.5 C 4 10.94772 4.44772 10.5 5 10.5 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/dialog-close.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      .ColorScheme-NegativeText {
        color:#da4453;
      }
      </style>
  </defs>
  <path
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     class="ColorScheme-NegativeText"
    d="M 8,2 A 6,6 0 0 0 2,8 6,6 0 0 0 8,14 6,6 0 0 0 14,8 6,6 0 0 0 8,2 Z M 5.70703,5 8,7.29297 10.29297,5 11,5.70703 8.70703,8 11,10.29297 10.29297,11 8,8.70703 5.70703,11 5,10.29297 7.29297,8 5,5.70703 5.70703,5 Z"
        />
</svg>

```

`src/res/icons/breeze-edb/16x16/dialog-information.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
    <path 
        style="fill:currentColor;fill-opacity:1;stroke:none" 
          d="M 2 2 L 2 12 L 5 15 L 5 12 L 14 12 L 14 2 L 2 2 z M 3 3 L 13 3 L 13 11 L 3 11 L 3 3 z M 7 4 L 7 5 L 9 5 L 9 4 L 7 4 z M 7 6 L 7 10 L 9 10 L 9 6 L 7 6 z "
          id="rect4163" 
          class="ColorScheme-Text"/>
</svg>

```

`src/res/icons/breeze-edb/16x16/document-export.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
       d="M 3 2 L 3 11 L 3 12 L 5 12 L 7.0859375 12 L 6.4140625 12.671875 L 5.4648438 13.621094 L 6.171875 14.328125 L 7.1210938 13.378906 L 9 11.5 L 7.1210938 9.6210938 L 6.171875 8.671875 L 5.4648438 9.3789062 L 6.4140625 10.328125 L 7.0859375 11 L 5 11 L 4 11 L 4 3 L 12 3 L 12 13 L 9 13 L 9 14 L 13 14 L 13 2 L 3 2 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/document-import.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
       d="m 434.71429,533.79074 v 9 1 h -2 -2.08594 l 0.67188,0.67188 0.94922,0.94921 -0.70704,0.70704 -0.94921,-0.94922 -1.87891,-1.87891 1.87891,-1.87891 0.94921,-0.94921 0.70704,0.70703 -0.94922,0.94922 -0.67188,0.67187 h 2.08594 1 v -8 h -8 v 10 h 3 v 1 h -4 v -12 z"
       transform="translate(-421.71429,-531.79074)"
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/document-open-recent.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 3 2 L 3 3 L 3 13 L 3 14 L 6 14 L 6 13 L 4 13 L 4 3 L 6 3 L 7 3 L 9 3 L 11 3 L 12 3 L 12 5 L 13 5 L 13 2 L 12 2 L 9 2 L 7 2 L 6 2 L 3 2 z M 10 6 C 7.784 6 6 7.784 6 10 C 6 12.216 7.784 14 10 14 C 12.216 14 14 12.216 14 10 C 14 7.784 12.216 6 10 6 z M 10 7 C 11.66199 7 13 8.338 13 10 C 13 11.662 11.66199 13 10 13 C 8.33801 13 7 11.662 7 10 C 7 8.338 8.33801 7 10 7 z M 9 8 L 9 10 L 9 11 L 10 11 L 11 11 L 11 10 L 10 10 L 10 8 L 9 8 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/document-open.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 2 2 L 2 3 L 2 6 L 2 7 L 2 13 L 2 14 L 14 14 L 14 13 L 14 6 L 14 5 L 14 4 L 9.0078125 4 L 7.0078125 2 L 7 2.0078125 L 7 2 L 3 2 L 2 2 z M 3 3 L 6.5917969 3 L 7.59375 4 L 7 4 L 7 4.0078125 L 6.9921875 4 L 4.9921875 6 L 3 6 L 3 3 z M 3 7 L 13 7 L 13 13 L 3 13 L 3 7 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/edit-clear-list.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 6 2 L 0.70703125 7.2929688 L 0 8 L 0.70703125 8.7070312 L 6 14 L 15 14 L 16 14 L 16 2 L 15 2 L 6 2 z M 8.0019531 5 L 10.011719 7.0097656 L 12.021484 5 L 13.011719 5.9902344 L 11.001953 8 L 13.011719 10.009766 L 12.021484 11 L 10.011719 8.9902344 L 8.0019531 11 L 7.0117188 10.009766 L 9.0214844 8 L 7.0117188 5.9902344 L 8.0019531 5 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/edit-find.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 6.5 2 C 4.007 2 2 4.01 2 6.5 C 2 8.993 4.01 11 6.5 11 C 7.5636432 11 8.5263409 10.618801 9.2949219 10.005859 L 13.292969 14.003906 L 14 13.296875 L 10.001953 9.2988281 C 10.617604 8.529048 11 7.565338 11 6.5 C 11 4.007 8.99 2 6.5 2 z M 6.5 3 C 8.439 3 10 4.561 10 6.5 C 10 8.439 8.439 10 6.5 10 C 4.561 10 3 8.439 3 6.5 C 3 4.561 4.561 3 6.5 3 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/edit-undo.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 6.5 2 L 3.21875 5.28125 L 3 5.5 L 3.21875 5.71875 L 6.5 9 L 7.21875 8.28125 L 4.90625 6 L 6 6 L 7.1875 6 L 8 6 L 8.5 6 C 10.432998 6 12 7.5669984 12 9.5 C 12 11.433002 10.432998 13 8.5 13 L 8 13 L 7 13 L 7 14 L 8 14 L 8.5 14 C 10.985283 14 13 11.985252 13 9.5 C 13 7.0147479 10.985283 5 8.5 5 L 8 5 L 7.1875 5 L 6 5 L 4.90625 5 L 7.21875 2.71875 L 6.5 2 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/help-about.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="m7.5 3c-3.038 0-5.5 2.462-5.5 5.5 0 3.038 2.462 5.5 5.5 5.5 3.038 0 5.5-2.462 5.5-5.5 0-3.038-2.462-5.5-5.5-5.5m0 1c2.485 0 4.5 2.01 4.5 4.5 0 2.485-2.01 4.5-4.5 4.5-2.485 0-4.5-2.01-4.5-4.5 0-2.485 2.01-4.5 4.5-4.5m-.5 1v1h1v-1zm0 2v5h1v-5z"
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/help-contents.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path 
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 8 2 A 6 6 0 0 0 2 8 A 6 6 0 0 0 8 14 A 6 6 0 0 0 14 8 A 6 6 0 0 0 8 2 z M 2 3 L 2 5 L 4 3 L 2 3 z M 8 3 A 5 5 0 0 1 10.390625 3.609375 L 8.8691406 5.1308594 A 3 3 0 0 0 8 5 A 3 3 0 0 0 7.1308594 5.1308594 L 5.6132812 3.6132812 A 5 5 0 0 1 8 3 z M 12 3 L 14 5 L 14 3 L 12 3 z M 3.609375 5.609375 L 5.1308594 7.1308594 A 3 3 0 0 0 5 8 A 3 3 0 0 0 5.1308594 8.8691406 L 3.6132812 10.386719 A 5 5 0 0 1 3 8 A 5 5 0 0 1 3.609375 5.609375 z M 12.386719 5.6132812 A 5 5 0 0 1 13 8 A 5 5 0 0 1 12.390625 10.390625 L 10.869141 8.8691406 A 3 3 0 0 0 11 8 A 3 3 0 0 0 10.869141 7.1308594 L 12.386719 5.6132812 z M 8 6 A 2 2 0 0 1 10 8 A 2 2 0 0 1 8 10 A 2 2 0 0 1 6 8 A 2 2 0 0 1 8 6 z M 7.1308594 10.869141 A 3 3 0 0 0 8 11 A 3 3 0 0 0 8.8691406 10.869141 L 10.386719 12.386719 A 5 5 0 0 1 8 13 A 5 5 0 0 1 5.609375 12.390625 L 7.1308594 10.869141 z M 2 11 L 2 13 L 4 13 L 2 11 z M 14 11 L 12 13 L 14 13 L 14 11 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/list-add.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 7 3.0058594 L 7 8 L 2 8 L 2 8.9980469 L 7 8.9980469 L 7 14.007812 L 8 14.007812 L 8 8.9980469 L 13 8.9980469 L 13 8 L 8 8 L 8 3.0058594 L 7 3.0058594 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/list-remove.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 3,7 3,9 13,9 13,7 3,7 Z"
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/view-refresh.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
       d="M 8 2 C 6.8911827 2 5.8599294 2.3193334 4.96875 2.84375 L 5.53125 3.40625 L 5.71875 3.59375 L 7.65625 5.53125 L 8.375 4.8125 L 6.75 3.1875 C 6.94534 3.1364099 7.1398623 3.0897842 7.34375 3.0625 C 7.3961563 3.0547113 7.4470287 3.0373165 7.5 3.03125 C 7.6680854 3.01418 7.827411 3 8 3 C 10.761424 3 13 5.2385759 13 8 C 13 8.243024 12.97155 8.4855082 12.9375 8.71875 C 12.917545 8.8549993 12.905714 8.9925532 12.875 9.125 C 12.80805 9.4115815 12.708353 9.672624 12.59375 9.9375 C 12.580478 9.9681753 12.576374 10.000899 12.5625 10.03125 C 12.521539 10.122908 12.454245 10.194583 12.40625 10.28125 C 12.401797 10.289291 12.410582 10.304303 12.40625 10.3125 L 13.15625 11.03125 C 13.680667 10.140071 14 9.108818 14 8 C 14 4.6862909 11.313707 2 8 2 z M 2.84375 4.96875 C 2.3193332 5.8599294 2 6.891182 2 8 C 2 11.313709 4.6862934 14 8 14 C 9.1088173 14 10.140071 13.680667 11.03125 13.15625 L 10.46875 12.59375 L 10.28125 12.40625 L 8.34375 10.5 L 7.65625 11.1875 L 9.25 12.8125 C 9.05466 12.86359 8.8601377 12.910216 8.65625 12.9375 C 8.6038437 12.945289 8.5529713 12.962684 8.5 12.96875 C 8.3319146 12.98582 8.172589 13 8 13 C 7.827411 13 7.6680854 12.98582 7.5 12.96875 C 7.3319147 12.95168 7.162744 12.939552 7 12.90625 C 4.7215847 12.440019 3 10.416246 3 8 C 3 7.7517374 3.0275593 7.5198138 3.0625 7.28125 C 3.0824555 7.1450007 3.0942865 7.0074468 3.125 6.875 C 3.1919502 6.5884185 3.2916465 6.327376 3.40625 6.0625 C 3.4192426 6.031782 3.4239145 5.9991506 3.4375 5.96875 C 3.4781185 5.8798895 3.5461122 5.8040145 3.59375 5.71875 L 3.59375 5.6875 L 2.84375 4.96875 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/16x16/view-restore.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
 <path style="fill:currentColor;fill-opacity:1;stroke:none" 
       d="M 6 2 L 8 4 L 10 2 L 6 2 z M 8 4 L 4 4 L 4 8 L 4 12 L 8 12 L 12 12 L 12 8 L 12 4 L 8 4 z M 12 8 L 14 10 L 14 6 L 12 8 z M 8 12 L 6 14 L 10 14 L 8 12 z M 4 8 L 2 6 L 2 10 L 4 8 z M 5 6 L 11 6 L 11 11 L 5 11 L 5 6 z "
     class="ColorScheme-Text"
     />
</svg>

```

`src/res/icons/breeze-edb/24x24/dialog-information.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      </style>
  </defs>
  <g transform="translate(1,1)">
    <path style="opacity:1;fill:currentColor;fill-opacity:1;stroke:none" d="M 3,4 3,16 6,20 6,17 6,16 19,16 19,4 3,4 Z M 4,5 18,5 18,15 4,15 4,5 Z m 6,1 0,1 2,0 0,-1 -2,0 z m 0,2 0,6 2,0 0,-6 -2,0 z" class="ColorScheme-Text"/>
  </g>
</svg>

```

`src/res/icons/breeze-edb/24x24/distribute-graph.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <defs id="defs3051">
    <style type="text/css" id="current-color-scheme">
      .ColorScheme-Text {
        color:#232629;
      }
      .ColorScheme-Highlight {
        color:#3daee9;
      }
      </style>
  </defs>
 <path 
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 8.6875 5.6113281 L 3.6875 9.6113281 L 4.3125 10.390625 L 9.3125 6.390625 L 8.6875 5.6113281 z M 10.384766 5.6816406 L 9.6152344 6.3203125 L 14.615234 12.320312 L 15.384766 11.681641 L 10.384766 5.6816406 z M 19.583984 5.7226562 L 15.583984 11.722656 L 16.416016 12.277344 L 20.416016 6.2773438 L 19.583984 5.7226562 z M 3 10.998047 L 3 17.998047 L 4 17.998047 L 4 10.998047 L 3 10.998047 z M 4 17.998047 L 4 18.998047 L 10 18.998047 L 10 17.998047 L 4 17.998047 z M 14.609375 12.689453 L 10.609375 17.689453 L 11.390625 18.3125 L 15.390625 13.3125 L 14.609375 12.689453 z M 16.390625 12.689453 L 15.609375 13.3125 L 19.609375 18.3125 L 20.390625 17.689453 L 16.390625 12.689453 z "
     class="ColorScheme-Text"
     />
 <path 
     style="fill:currentColor;fill-opacity:1;stroke:none" 
     d="M 9.5 4 A 1.4999959 1.5 0 0 0 8 5.5 A 1.4999959 1.5 0 0 0 9.5 7 A 1.4999959 1.5 0 0 0 11 5.5 A 1.4999959 1.5 0 0 0 9.5 4 z M 20.5 4 A 1.4999959 1.5 0 0 0 19 5.5 A 1.4999959 1.5 0 0 0 20.5 7 A 1.4999959 1.5 0 0 0 22 5.5 A 1.4999959 1.5 0 0 0 20.5 4 z M 3.5 9 A 1.4999959 1.5 0 0 0 2 10.5 A 1.4999959 1.5 0 0 0 3.5 12 A 1.4999959 1.5 0 0 0 5 10.5 A 1.4999959 1.5 0 0 0 3.5 9 z M 15.5 11 A 1.4999959 1.5 0 0 0 14 12.5 A 1.4999959 1.5 0 0 0 15.5 14 A 1.4999959 1.5 0 0 0 17 12.5 A 1.4999959 1.5 0 0 0 15.5 11 z M 3.5 17 A 1.4999959 1.5 0 0 0 2 18.5 A 1.4999959 1.5 0 0 0 3.5 20 A 1.4999959 1.5 0 0 0 5 18.5 A 1.4999959 1.5 0 0 0 3.5 17 z M 10.5 17 A 1.4999959 1.5 0 0 0 9 18.5 A 1.4999959 1.5 0 0 0 10.5 20 A 1.4999959 1.5 0 0 0 12 18.5 A 1.4999959 1.5 0 0 0 10.5 17 z M 20.5 17 A 1.4999959 1.5 0 0 0 19 18.5 A 1.4999959 1.5 0 0 0 20.5 20 A 1.4999959 1.5 0 0 0 22 18.5 A 1.4999959 1.5 0 0 0 20.5 17 z "
     class="ColorScheme-Highlight"
     />
</svg>

```

`src/res/icons/breeze-edb/64x64/dialog-information.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<!-- Created with Inkscape (http://www.inkscape.org/) -->
<svg width="64" version="1.1" xmlns="http://www.w3.org/2000/svg" height="64" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
 <defs id="defs3811">
  <linearGradient inkscape:collect="always" xlink:href="#linearGradient4143" id="linearGradient4416" y1="43.999989" y2="6.999989" x2="0" gradientUnits="userSpaceOnUse" gradientTransform="matrix(-1.4054053 0 0 1.4054053 804.69502 154.09579)"/>
  <linearGradient inkscape:collect="always" id="linearGradient4143">
   <stop style="stop-color:#197cf1" id="stop4145"/>
   <stop offset="1" style="stop-color:#20bcfa" id="stop4147"/>
  </linearGradient>
  <linearGradient inkscape:collect="always" id="linearGradient4290">
   <stop style="stop-color:#7cbaf8" id="stop4292"/>
   <stop offset="1" style="stop-color:#f4fcff" id="stop4294"/>
  </linearGradient>
  <linearGradient inkscape:collect="always" id="linearGradient4144" xlink:href="#linearGradient4290" y1="29.999973" y2="2" gradientUnits="userSpaceOnUse" x2="0" gradientTransform="matrix(2 0 0 2 735.85719 152.93361)"/>
  <linearGradient inkscape:collect="always" id="linearGradient4227">
   <stop style="stop-color:#292c2f" id="stop4229"/>
   <stop offset="1" style="stop-opacity:0" id="stop4231"/>
  </linearGradient>
  <linearGradient inkscape:collect="always" id="linearGradient4191" xlink:href="#linearGradient4227" y1="9" y2="23" x1="9.00001" gradientUnits="userSpaceOnUse" x2="23.00004" gradientTransform="matrix(2 0 0 2 -0.99999 -5)"/>
 </defs>
 <metadata id="metadata3814"/>
 <g inkscape:label="Layer 1" inkscape:groupmode="layer" id="layer1" transform="matrix(1 0 0 1 -736.85718 -157.93361)">
  <path inkscape:connector-curvature="0" style="fill:url(#linearGradient4416);fill-rule:evenodd" id="path4445" d="m 794.85718,163.93361 0,37.94594 -25.29727,0 -14.05412,14.05406 0,-14.05406 -12.64861,0 0,-37.94594 z"/>
  <path style="fill:url(#linearGradient4191);opacity:0.2;fill-rule:evenodd" id="path4184" d="M 33 13 L 29 17 L 33 21 L 29 37 L 35.945312 43.945312 L 58 43.945312 L 58 38 L 33 13 z " transform="matrix(1 0 0 1 736.85718 157.93361)"/>
  <path inkscape:connector-curvature="0" style="fill:url(#linearGradient4144)" id="rect4133" d="m 765.85719,170.93361 0,4 4,0 0,-4 z m 0,8 0,16 4,0 0,-16 z"/>
  <path style="fill:#0c69cf;fill-rule:evenodd" id="path4256" d="M 6 42.945312 L 6 43.945312 L 18.648438 43.945312 L 18.648438 42.945312 L 6 42.945312 z M 32.703125 42.945312 L 18.648438 57 L 18.648438 58 L 32.703125 43.945312 L 58 43.945312 L 58 42.945312 L 32.703125 42.945312 z " transform="matrix(1 0 0 1 736.85718 157.93361)"/>
 </g>
</svg>

```

`src/res/icons/breeze-edb/index.theme`:

```theme
[Icon Theme]
Name=Breeze edb
Comment=Breeze Icon Theme for edb
Inherits=breeze
Directories=16x16,24x24,64x64

[16x16]
Size=16

[24x24]
Size=24

[64x64]
Size=64

```

`src/res/icons/edb/index.theme`:

```theme
[Icon Theme]
Name=edb Theme
Comment=Icon Theme for edb
Inherits=breeze-edb
Directories=16x16,24x24,64x64
 
[16x16]
Size=16

[24x24]
Size=24

[64x64]
Size=64

```

`src/res/images/arrow-right-red.svg`:

```svg
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="0 0 1000 1000">
    <g transform="matrix(1 0 0 -1 0 800)">
	    <path fill="red" d="M78 266v156q0 19 13 32t32 13h239v118q0 26 14 33q5 2 10 2q11 0 26 -11l286 -225q20 -16 20 -40t-20 -40l-286 -225q-15 -11 -26 -11q-5 0 -10 2q-14 7 -14 33v118h-239q-19 0 -32 13t-13 32z" />
    </g>
</svg>

```

`src/res/images/arrow-right.svg`:

```svg
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="0 0 1000 1000">
    <g transform="matrix(1 0 0 -1 0 800)">
	    <path fill="green" d="M78 266v156q0 19 13 32t32 13h239v118q0 26 14 33q5 2 10 2q11 0 26 -11l286 -225q20 -16 20 -40t-20 -40l-286 -225q-15 -11 -26 -11q-5 0 -10 2q-14 7 -14 33v118h-239q-19 0 -32 13t-13 32z" />
    </g>
</svg>

```

`src/res/images/breakpoint.svg`:

```svg
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg viewBox="0 0 1000 1000" xmlns="http://www.w3.org/2000/svg" version="1.1">
	<circle cx="500" cy="500" r="300" fill="red" />
</svg>

```

`src/res/lang/edb_en.ts`:

```ts
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE TS>
<TS version="2.0" language="en_US">
<context>
    <name>ArchProcessor</name>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="648"/>
        <source>General Purpose</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="673"/>
        <source>Segments</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="682"/>
        <source>FPU</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="693"/>
        <source>Debug</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="705"/>
        <source>MMX</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="718"/>
        <source>XMM</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="363"/>
        <source>move performed</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="365"/>
        <source>move NOT performed</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="396"/>
        <source>jump taken</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="398"/>
        <source>jump NOT taken</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="414"/>
        <source>return to %1 &lt;%2&gt;</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="416"/>
        <source>return to %1</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="570"/>
        <source>possible jump from 0x%1</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../arch/x86_64/ArchProcessor.cpp" line="615"/>
        <source>SYSCALL: %1(%2)</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>BinaryStringWidget</name>
    <message>
        <location filename="../BinaryString.ui" line="15"/>
        <source>BinaryString</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../BinaryString.ui" line="39"/>
        <source>UTF-16</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../BinaryString.ui" line="49"/>
        <source>ASCII</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../BinaryString.ui" line="68"/>
        <source>Hex</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>CommentServer</name>
    <message>
        <location filename="../CommentServer.cpp" line="87"/>
        <source>return to %1 &lt;%2&gt;</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../CommentServer.cpp" line="89"/>
        <source>return to %1</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../CommentServer.cpp" line="115"/>
        <source>ASCII &quot;%1&quot;</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../CommentServer.cpp" line="117"/>
        <source>UTF16 &quot;%1&quot;</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>Debugger</name>
    <message>
        <location filename="../Debugger.ui" line="15"/>
        <location filename="../Debugger.cpp" line="2172"/>
        <source>edb</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="48"/>
        <location filename="../Debugger.ui" line="320"/>
        <source>&amp;Help</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="57"/>
        <source>&amp;View</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="65"/>
        <location filename="../Debugger.ui" line="430"/>
        <source>&amp;Plugins</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="72"/>
        <source>&amp;Options</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="80"/>
        <source>&amp;File</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="90"/>
        <source>&amp;Debug</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="117"/>
        <source>Registers</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="134"/>
        <source>1</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="144"/>
        <source>Data Dump</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="155"/>
        <source>00000000-00000000</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="166"/>
        <source>Stack</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="177"/>
        <source>ToolBar</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="199"/>
        <source>&amp;Open</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="204"/>
        <source>&amp;Attach</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="209"/>
        <source>E&amp;xit</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="214"/>
        <source>&amp;Memory Regions</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="217"/>
        <source>Ctrl+M</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="222"/>
        <location filename="../Debugger.ui" line="289"/>
        <source>&amp;Step Into</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="237"/>
        <source>&amp;Run</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="240"/>
        <source>F9</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="252"/>
        <source>&amp;Pause</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="255"/>
        <source>F11</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="263"/>
        <source>&amp;Restart</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="271"/>
        <source>&amp;Detach</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="274"/>
        <location filename="../Debugger.ui" line="277"/>
        <source>Detach</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="292"/>
        <source>F7</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="304"/>
        <source>&amp;Step Over</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="307"/>
        <source>F8</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="312"/>
        <source>&amp;About</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="323"/>
        <source>F1</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="331"/>
        <source>&amp;Toggle Breakpoint</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="334"/>
        <source>F2</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="339"/>
        <source>&amp;Preferences</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="344"/>
        <source>About &amp;QT</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="349"/>
        <source>&amp;Breakpoint Manager</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="354"/>
        <source>Application &amp;Arguments</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="362"/>
        <source>Run &amp;Until Return</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="374"/>
        <source>&amp;Step Into (Pass Signal To Application)</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="377"/>
        <source>Shift+F7</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="389"/>
        <source>&amp;Step Over (Pass Signal To Application)</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="392"/>
        <source>Shift+F8</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="404"/>
        <source>&amp;Run (Pass Signal To Application)</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="407"/>
        <source>Shift+F9</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="412"/>
        <source>&amp;Recent Files</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="417"/>
        <source>Application &amp;Working Directory</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="425"/>
        <source>&amp;Kill</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="435"/>
        <source>&amp;Threads</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.ui" line="438"/>
        <source>Ctrl+T</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="210"/>
        <source>Ctrl+G</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="268"/>
        <source>paused</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="283"/>
        <source>running</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="298"/>
        <source>terminated</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="347"/>
        <location filename="../Debugger.cpp" line="349"/>
        <location filename="../Debugger.cpp" line="351"/>
        <source>edb output</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="419"/>
        <source>edb - %1 [%2]</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="487"/>
        <location filename="../Debugger.cpp" line="491"/>
        <location filename="../Debugger.cpp" line="1853"/>
        <source>%1-%2</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="542"/>
        <source>Goto Address</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="542"/>
        <source>Address:</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="783"/>
        <source>About Qt</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="851"/>
        <source>&amp;Follow In Dump</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="852"/>
        <source>&amp;Follow In Dump (New Tab)</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="853"/>
        <source>&amp;Follow In Stack</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="880"/>
        <source>Register Value</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="897"/>
        <source>About edb</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="898"/>
        <source>&lt;p&gt;edb (Evan&apos;s Debugger) is designed to be an easy to use, modular, and cross platform debugger.&lt;/p&gt;&lt;p&gt;More information and updates can be found at &lt;a href=&quot;https://github.com/eteran/edb-debugger&quot;&gt;https://github.com/eteran/edb-debugger&lt;/a&gt;&lt;/p&gt;&lt;p&gt;You can also report bugs an feature requests at &lt;a href=&quot;https://github.com/eteran/edb-debugger/issues&quot;&gt;https://github.com/eteran/edb-debugger/issues&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Written by Evan Teran.&lt;/p&gt;&lt;p&gt;version: %1&lt;/p&gt;</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="999"/>
        <location filename="../Debugger.cpp" line="1013"/>
        <source>No Memory Found</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1000"/>
        <location filename="../Debugger.cpp" line="1014"/>
        <source>There appears to be no memory at that location (&lt;strong&gt;0x%1&lt;/strong&gt;)</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1124"/>
        <source>Invalid Selection</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1125"/>
        <source>Please select %1 bytes to use this function.</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1232"/>
        <source>Application Working Directory</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1251"/>
        <source>Enter value to push</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1284"/>
        <source>Set Address &amp;Label</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1287"/>
        <location filename="../Debugger.cpp" line="1405"/>
        <location filename="../Debugger.cpp" line="1445"/>
        <source>&amp;Goto Address</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1289"/>
        <source>&amp;Goto %1</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1307"/>
        <source>&amp;Follow</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1323"/>
        <source>Follow Constant In &amp;Dump</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1326"/>
        <source>Follow Constant In &amp;Stack</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1337"/>
        <source>&amp;Set %1 to this Instruction</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1340"/>
        <location filename="../Debugger.cpp" line="1412"/>
        <location filename="../Debugger.cpp" line="1447"/>
        <source>&amp;Edit Bytes</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1341"/>
        <source>&amp;Fill with 00&apos;s</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1342"/>
        <source>Fill with &amp;NOPs</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1344"/>
        <source>&amp;Add Breakpoint</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1345"/>
        <source>Add &amp;Conditional Breakpoint</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1346"/>
        <source>&amp;Remove Breakpoint</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1402"/>
        <location filename="../Debugger.cpp" line="1442"/>
        <source>Follow Address In &amp;CPU</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1403"/>
        <location filename="../Debugger.cpp" line="1443"/>
        <source>Follow Address In &amp;Dump</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1404"/>
        <location filename="../Debugger.cpp" line="1444"/>
        <source>Follow Address In &amp;Stack</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1407"/>
        <location filename="../Debugger.cpp" line="1408"/>
        <source>Goto %1</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1414"/>
        <source>&amp;Push %1</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1415"/>
        <source>P&amp;op %1</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1419"/>
        <source>&amp;Lock Stack</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1449"/>
        <source>&amp;Save To File</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1468"/>
        <source>Save File</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1516"/>
        <source>Set Breakpoint Condition</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1516"/>
        <source>Expression:</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1562"/>
        <source>Set Label</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1563"/>
        <source>Labe:</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1722"/>
        <source>Application Killed</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1723"/>
        <source>The debugged application was killed.</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1751"/>
        <source>Debug Event</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1752"/>
        <source>&lt;p&gt;The debugged application has received a debug event-&gt; &lt;strong&gt;%1&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;If you would like to pass this event to the application press Shift+[F7/F8/F9]&lt;/p&gt;&lt;p&gt;If you would like to ignore this event, press [F7/F8/F9]&lt;/p&gt;</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1768"/>
        <source>Application Terminated</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1769"/>
        <source>The debugged application was terminated with exit code %1.</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1782"/>
        <source>Application Exited</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1783"/>
        <source>The debugged application exited normally with exit code %1.</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1855"/>
        <source>[%1] %2-%3</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2278"/>
        <source>Not A Native Binary</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2279"/>
        <source>The program you just attached to was built for a different architecture than the one that edb was built for. For example a 32-bit binary on x86-64. This is not supported yet, so you may need to use a version of edb that was compiled for the same architecture as your target program</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2355"/>
        <location filename="../Debugger.cpp" line="2369"/>
        <source>Could Not Open</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2356"/>
        <source>The specified file (%1) does not appear to exist, please check privileges and try again.</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2370"/>
        <source>Failed to open and attach to process, please check privileges and try again.</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2418"/>
        <location filename="../Debugger.cpp" line="2429"/>
        <location filename="../Debugger.cpp" line="2450"/>
        <source>Attach</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2419"/>
        <source>You may not debug a process which is a parent of the edb process.</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2430"/>
        <source>You are already debugging that process!</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2450"/>
        <source>Failed to attach to process, please check privileges and try again.</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2468"/>
        <source>Choose a file</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2673"/>
        <source>&amp;Set Label</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2674"/>
        <source>&amp;Clear Label</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2681"/>
        <source>Set Caption</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="2682"/>
        <source>Caption:</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>DialogArguments</name>
    <message>
        <location filename="../DialogArguments.ui" line="14"/>
        <source>Application Arguments</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogArguments.ui" line="34"/>
        <location filename="../DialogArguments.ui" line="69"/>
        <source>+</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogArguments.ui" line="45"/>
        <location filename="../DialogArguments.ui" line="80"/>
        <source>-</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogArguments.cpp" line="45"/>
        <source>New Argument</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>DialogAttach</name>
    <message>
        <location filename="../DialogAttach.ui" line="15"/>
        <source>Attach To Process</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogAttach.ui" line="27"/>
        <source>Filter</source>
        <oldsource>Filter:</oldsource>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogAttach.ui" line="37"/>
        <source>Only Show Entries For My UID</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>DialogInputBinaryString</name>
    <message>
        <location filename="../DialogInputBinaryString.ui" line="15"/>
        <source>Input Binary String</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>DialogInputValue</name>
    <message>
        <location filename="../DialogInputValue.ui" line="21"/>
        <source>Input Value</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogInputValue.ui" line="30"/>
        <source>Hexdecimal</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogInputValue.ui" line="43"/>
        <source>Signed</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogInputValue.ui" line="56"/>
        <source>Unsigned</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>DialogMemoryRegions</name>
    <message>
        <location filename="../DialogMemoryRegions.ui" line="15"/>
        <source>Memory Regions</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.ui" line="24"/>
        <source>Filter</source>
        <oldsource>Filter:</oldsource>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.cpp" line="76"/>
        <source>Set Access</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.cpp" line="77"/>
        <source>No Access</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.cpp" line="78"/>
        <source>Read Only</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.cpp" line="79"/>
        <source>Write Only</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.cpp" line="80"/>
        <source>Execute Only</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.cpp" line="81"/>
        <source>Read/Write</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.cpp" line="82"/>
        <source>Read/Execute</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.cpp" line="83"/>
        <source>Write/Execute</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.cpp" line="84"/>
        <source>Full Access</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.cpp" line="88"/>
        <source>View in &amp;CPU</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.cpp" line="89"/>
        <source>View in &amp;Stack</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogMemoryRegions.cpp" line="90"/>
        <source>View in &amp;Dump</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>DialogOptions</name>
    <message>
        <location filename="../DialogOptions.ui" line="15"/>
        <source>Preferences</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="28"/>
        <source>General</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="37"/>
        <source>Close Behaviour</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="46"/>
        <source>Detach From Debugged Application</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="56"/>
        <source>Kill Debugged Application</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="80"/>
        <source>Appearance</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="416"/>
        <location filename="../DialogOptions.ui" line="551"/>
        <location filename="../DialogOptions.ui" line="571"/>
        <location filename="../DialogOptions.ui" line="591"/>
        <source>...</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="97"/>
        <source>Default Disassembly View Font</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="104"/>
        <source>Default Stack View Font</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="111"/>
        <source>Default Register View Font</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="118"/>
        <source>Default Memory Dump View Font</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="130"/>
        <source>Default Data View Settings</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="136"/>
        <source>Show Address</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="143"/>
        <source>Show Hex</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="150"/>
        <source>Show ASCII</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="157"/>
        <source>Show Comments</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="164"/>
        <source>Word Width</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="172"/>
        <location filename="../DialogOptions.ui" line="216"/>
        <source>1 Byte</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="177"/>
        <location filename="../DialogOptions.ui" line="221"/>
        <source>2 Bytes</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="182"/>
        <location filename="../DialogOptions.ui" line="226"/>
        <source>4 Bytes</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="187"/>
        <location filename="../DialogOptions.ui" line="231"/>
        <source>8 Bytes</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="208"/>
        <source>Row Width</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="236"/>
        <source>16 Bytes</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="262"/>
        <source>Show Colons in Addresses</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="301"/>
        <source>Debugging</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="307"/>
        <source>Initial Breakpoint</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="316"/>
        <source>Application Entry Point</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="326"/>
        <source>&quot;main&quot; symbol (when possible)</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="339"/>
        <source>Warn when setting breakpoint in non-executable region</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="346"/>
        <source>Use heuristic to find &quot;main&quot; symbol when it is not found in symbol file</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="355"/>
        <source>Minimum length for string detection</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="383"/>
        <source>Command Line IO</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="389"/>
        <source>Open a terminal to provide program input and output</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="399"/>
        <source>Terminal Program:</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="409"/>
        <source>/usr/bin/xterm</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="440"/>
        <source>Signals/Exceptions</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="446"/>
        <source>Ignore (pass to program) the following exceptions:</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="464"/>
        <source>Disassembly</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="470"/>
        <source>Disassembly Syntax</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="479"/>
        <source>Intel</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="492"/>
        <source>AT&amp;&amp;T</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="502"/>
        <source>Instruction &quot;add byte ptr[eax], al&quot; (0x00 0x00) is &quot;Filling&quot; on x86</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="509"/>
        <source>Disassemble in uppercase</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="530"/>
        <source>Directories</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="538"/>
        <source>Symbol Directory</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="558"/>
        <source>Plugin Directory</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="578"/>
        <source>Session Directory</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="614"/>
        <source>Plugin Options</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.ui" line="620"/>
        <source>No Plugin Option Pages</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.cpp" line="99"/>
        <source>Choose a directory</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../DialogOptions.cpp" line="111"/>
        <source>Choose Your Terminal Program</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>DialogPlugins</name>
    <message>
        <location filename="../DialogPlugins.ui" line="14"/>
        <source>Plugins</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>DialogThreads</name>
    <message>
        <location filename="../DialogThreads.ui" line="14"/>
        <source>Threads</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>MemoryRegions</name>
    <message>
        <location filename="../MemoryRegions.cpp" line="162"/>
        <source>Start Address</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../MemoryRegions.cpp" line="163"/>
        <source>End Address</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../MemoryRegions.cpp" line="164"/>
        <source>Permissions</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../MemoryRegions.cpp" line="165"/>
        <source>Name</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>PluginModel</name>
    <message>
        <location filename="../PluginModel.cpp" line="99"/>
        <source>File Name</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../PluginModel.cpp" line="101"/>
        <source>Plugin Name</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../PluginModel.cpp" line="103"/>
        <source>Author</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../PluginModel.cpp" line="105"/>
        <source>Website</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>ProcessModel</name>
    <message>
        <location filename="../ProcessModel.cpp" line="76"/>
        <source>PID</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../ProcessModel.cpp" line="78"/>
        <source>UID</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../ProcessModel.cpp" line="80"/>
        <source>Name</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>QDisassemblyView</name>
    <message>
        <location filename="../widgets/QDisassemblyView.cpp" line="636"/>
        <source>invalid</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>QHexView</name>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="219"/>
        <source>Set &amp;Font</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="221"/>
        <source>Show A&amp;ddress</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="222"/>
        <source>Show &amp;Hex</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="223"/>
        <source>Show &amp;Ascii</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="224"/>
        <source>Show &amp;Comments</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="228"/>
        <source>Set Word Width</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="229"/>
        <source>1 Byte</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="230"/>
        <source>2 Bytes</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="231"/>
        <source>4 Bytes</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="232"/>
        <source>8 Bytes</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="243"/>
        <source>Set Row Width</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="244"/>
        <source>1 Word</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="245"/>
        <source>2 Words</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="246"/>
        <source>4 Words</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="247"/>
        <source>8 Words</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="248"/>
        <source>16 Words</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../qhexview/qhexview.cpp" line="263"/>
        <source>&amp;Copy Selection To Clipboard</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>RecentFileManager</name>
    <message>
        <location filename="../RecentFileManager.cpp" line="57"/>
        <location filename="../RecentFileManager.cpp" line="90"/>
        <source>Clear &amp;Menu</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>ThreadsModel</name>
    <message>
        <location filename="../ThreadsModel.cpp" line="57"/>
        <source>*%1</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../ThreadsModel.cpp" line="75"/>
        <source>Thread ID</source>
        <translation></translation>
    </message>
</context>
<context>
    <name>edb</name>
    <message>
        <location filename="../edb.cpp" line="340"/>
        <location filename="../edb.cpp" line="353"/>
        <source>Suspicious breakpoint</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../edb.cpp" line="341"/>
        <source>You want to place a breakpoint in a non-executable region.
An INT3 breakpoint set on data will not execute and may cause incorrect results or crashes.
Do you really want to set a breakpoint here?</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../edb.cpp" line="354"/>
        <source>It looks like you may be setting an INT3 breakpoint on data.
An INT3 breakpoint set on data will not execute and may cause incorrect results or crashes.
Do you really want to set a breakpoint here?</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../edb.cpp" line="372"/>
        <source>Error Setting Breakpoint</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../edb.cpp" line="373"/>
        <source>Sorry, but setting a breakpoint which is not in a valid region is not allowed.</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../edb.cpp" line="443"/>
        <source>Error In Expression!</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../edb.cpp" line="467"/>
        <source>Input Value</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../edb.cpp" line="935"/>
        <source>Overwritting breakpoint</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../edb.cpp" line="936"/>
        <source>You are attempting to modify bytes which overlap with a software breakpoint. Doing this will implicitly remove any breakpoints which are a conflict. Are you sure you want to do this?</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../edb.cpp" line="1238"/>
        <source>Memroy Allocation Error</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../edb.cpp" line="1239"/>
        <source>Unable to satisfy memory allocation request for requested region-&gt;</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../Debugger.cpp" line="1602"/>
        <location filename="../Debugger.cpp" line="1621"/>
        <source>Edit Binary String</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../main.cpp" line="96"/>
        <source>edb Failed To Load A Necessary Plugin</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../main.cpp" line="97"/>
        <source>Failed to successfully load the debugger core plugin. Please make sure it exists and that the plugin path is correctly configured.
This is normal if edb has not been previously run or the configuration file has been removed.</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../main.cpp" line="105"/>
        <source>edb</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../main.cpp" line="106"/>
        <source>edb will now close. If you were successful in specifying the location of the debugger core plugin, please run edb again.</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../SymbolManager.cpp" line="246"/>
        <source>Duplicate Label</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../SymbolManager.cpp" line="247"/>
        <source>You are attempting to give two seperate addresses the same label, this is not supported.</source>
        <translation type="unfinished"></translation>
    </message>
</context>
</TS>

```

`src/res/themes.qrc`:

```qrc
<RCC>
    <qresource prefix="/">
        <file>themes/system-light.ini</file>
        <file>themes/system-dark.ini</file>
		<file>themes/dark.ini</file>
		<file>themes/light.ini</file>
    </qresource>
</RCC>

```

`src/res/themes/dark.ini`:

```ini
[Theme]
address.foreground=#ba86c0
alternating_byte.foreground=grey
arithmetic.background=transparent
arithmetic.foreground=#569cd6
arithmetic.italic=false
arithmetic.underline=false
arithmetic.weight=50
badge.background=blue
badge.foreground=white
brackets.background=transparent
brackets.foreground=#b5cea8
brackets.italic=false
brackets.underline=false
brackets.weight=75
comma.background=transparent
comma.foreground=#b5cea8
comma.italic=false
comma.underline=false
comma.weight=75
comparison.background=transparent
comparison.foreground=#569cd6
comparison.italic=false
comparison.underline=false
comparison.weight=50
constant.background=transparent
constant.foreground=#ce7b48
constant.italic=false
constant.underline=false
constant.weight=50
data.background=transparent
data.foreground=white
data.italic=false
data.underline=false
data.weight=50
data_xfer.background=transparent
data_xfer.foreground=#569cd6
data_xfer.italic=false
data_xfer.underline=false
data_xfer.weight=50
filling.foreground=gray
flow_ctrl.background=transparent
flow_ctrl.foreground=green
flow_ctrl.italic=false
flow_ctrl.underline=false
flow_ctrl.weight=100
function.background=transparent
function.foreground=green
function.italic=false
function.underline=false
function.weight=100
logic.background=transparent
logic.foreground=#569cd6
logic.italic=false
logic.underline=false
logic.weight=50
non_printing_character.foreground=#569cd6
operator.background=transparent
operator.foreground=#ce7b48
operator.italic=false
operator.underline=false
operator.weight=50
palette.alternatebase.disabled=#ff2f3338
palette.alternatebase=#ff31363b
palette.base.disabled=#ff212427
palette.base=#ff232629
palette.brighttext.disabled=#ffffffff
palette.brighttext=#ffffffff
palette.button.disabled=#ff2f3338
palette.button=#ff31363b
palette.buttontext.disabled=#ff6e7275
palette.buttontext=#ffeff0f1
palette.dark.disabled=#ff1b1e21
palette.dark=#ff1d2023
palette.highlight.disabled=#ff2f3338
palette.highlight=#ff3daee9
palette.highlightedtext.disabled=#ff6e7275
palette.highlightedtext=#ffeff0f1
palette.light.disabled=#ff444b51
palette.light=#ff464d54
palette.link.disabled=#ff234257
palette.link=#ff2980b9
palette.linkvisited.disabled=#ff404648
palette.linkvisited=#ff7f8c8d
palette.mid.disabled=#ff292d32
palette.mid=#ff2b3034
palette.midlight.disabled=#ff3a4046
palette.midlight=#ff3c4248
palette.shadow.disabled=#ff141618
palette.shadow=#ff151719
palette.text.disabled=#ff65686a
palette.text=#ffeff0f1
palette.tooltipbase.disabled=#ff31363b
palette.tooltipbase=#ff31363b
palette.tooltiptext.disabled=#ffeff0f1
palette.tooltiptext=#ffeff0f1
palette.window.disabled=#ff2f3338
palette.window=#ff31363b
palette.windowtext.disabled=#ff6e7275
palette.windowtext=#ffeff0f1
prefix.background=transparent
prefix.foreground=#ce7b48
prefix.italic=false
prefix.underline=false
prefix.weight=75
ptr.background=transparent
ptr.foreground=darkGreen
ptr.italic=false
ptr.underline=false
ptr.weight=50
register.background=transparent
register.foreground=darkgreen
register.italic=false
register.underline=false
register.weight=75
shift.background=transparent
shift.foreground=#569cd6
shift.italic=false
shift.underline=false
shift.weight=50
stack.background=transparent
stack.foreground=#569cd6
stack.italic=false
stack.underline=false
stack.weight=50
system.background=transparent
system.foreground=#569cd6
system.italic=false
system.underline=false
system.weight=75
taken_jump.foreground=red

```

`src/res/themes/light.ini`:

```ini
[Theme]
address.foreground=red
alternating_byte.foreground=blue
arithmetic.background=transparent
arithmetic.foreground=blue
arithmetic.italic=false
arithmetic.underline=false
arithmetic.weight=50
badge.background=blue
badge.foreground=white
brackets.background=transparent
brackets.foreground=blue
brackets.italic=false
brackets.underline=false
brackets.weight=75
comma.background=transparent
comma.foreground=blue
comma.italic=false
comma.underline=false
comma.weight=75
comparison.background=transparent
comparison.foreground=blue
comparison.italic=false
comparison.underline=false
comparison.weight=50
constant.background=transparent
constant.foreground=black
constant.italic=false
constant.underline=false
constant.weight=50
data.background=transparent
data.foreground=black
data.italic=false
data.underline=false
data.weight=50
data_xfer.background=transparent
data_xfer.foreground=blue
data_xfer.italic=false
data_xfer.underline=false
data_xfer.weight=50
filling.foreground=gray
flow_ctrl.background=yellow
flow_ctrl.foreground=blue
flow_ctrl.italic=false
flow_ctrl.underline=false
flow_ctrl.weight=50
function.background=yellow
function.foreground=blue
function.italic=false
function.underline=false
function.weight=50
logic.background=transparent
logic.foreground=blue
logic.italic=false
logic.underline=false
logic.weight=50
non_printing_character.foreground=red
operator.background=transparent
operator.foreground=blue
operator.italic=false
operator.underline=false
operator.weight=50
palette.alternatebase.disabled=#ffe3e5e7
palette.alternatebase=#ffeff0f1
palette.base.disabled=#fff0f0f0
palette.base=#fffcfcfc
palette.brighttext.disabled=#ffffffff
palette.brighttext=#ffffffff
palette.button.disabled=#ffe3e5e7
palette.button=#ffeff0f1
palette.buttontext.disabled=#ffa0a1a2
palette.buttontext=#ff232627
palette.dark.disabled=#ff82878c
palette.dark=#ff888e93
palette.highlight.disabled=#ffe3e5e7
palette.highlight=#ff3daee9
palette.highlightedtext.disabled=#ffa0a1a2
palette.highlightedtext=#fffcfcfc
palette.light.disabled=#ffffffff
palette.light=#ffffffff
palette.link.disabled=#ffa2c8e0
palette.link=#ff2980b9
palette.linkvisited.disabled=#ffc7cbcb
palette.linkvisited=#ff7f8c8d
palette.mid.disabled=#ffbbc0c5
palette.mid=#ffc4c8cc
palette.midlight.disabled=#ffebedee
palette.midlight=#fff6f7f7
palette.shadow.disabled=#ff474a4c
palette.shadow=#ff474a4c
palette.text.disabled=#ffa8a9a9
palette.text=#ff232627
palette.tooltipbase.disabled=#ff232627
palette.tooltipbase=#ff232627
palette.tooltiptext.disabled=#fffcfcfc
palette.tooltiptext=#fffcfcfc
palette.window.disabled=#ffe3e5e7
palette.window=#ffeff0f1
palette.windowtext.disabled=#ffa0a1a2
palette.windowtext=#ff232627
prefix.background=transparent
prefix.foreground=black
prefix.italic=false
prefix.underline=false
prefix.weight=75
ptr.background=transparent
ptr.foreground=darkGreen
ptr.italic=false
ptr.underline=false
ptr.weight=50
register.background=transparent
register.foreground=red
register.italic=false
register.underline=false
register.weight=75
shift.background=transparent
shift.foreground=blue
shift.italic=false
shift.underline=false
shift.weight=50
stack.background=transparent
stack.foreground=blue
stack.italic=false
stack.underline=false
stack.weight=50
system.background=transparent
system.foreground=blue
system.italic=false
system.underline=false
system.weight=75
taken_jump.foreground=red

```

`src/res/themes/system-dark.ini`:

```ini
[Theme]
address.foreground=#ba86c0
alternating_byte.foreground=grey
arithmetic.background=transparent
arithmetic.foreground=#569cd6
arithmetic.italic=false
arithmetic.underline=false
arithmetic.weight=50
badge.background=blue
badge.foreground=white
brackets.background=transparent
brackets.foreground=#b5cea8
brackets.italic=false
brackets.underline=false
brackets.weight=75
comma.background=transparent
comma.foreground=#b5cea8
comma.italic=false
comma.underline=false
comma.weight=75
comparison.background=transparent
comparison.foreground=#569cd6
comparison.italic=false
comparison.underline=false
comparison.weight=50
constant.background=transparent
constant.foreground=#ce7b48
constant.italic=false
constant.underline=false
constant.weight=50
data.background=transparent
data.foreground=white
data.italic=false
data.underline=false
data.weight=50
data_xfer.background=transparent
data_xfer.foreground=#569cd6
data_xfer.italic=false
data_xfer.underline=false
data_xfer.weight=50
filling.foreground=gray
flow_ctrl.background=transparent
flow_ctrl.foreground=green
flow_ctrl.italic=false
flow_ctrl.underline=false
flow_ctrl.weight=100
function.background=transparent
function.foreground=green
function.italic=false
function.underline=false
function.weight=100
logic.background=transparent
logic.foreground=#569cd6
logic.italic=false
logic.underline=false
logic.weight=50
non_printing_character.foreground=#569cd6
operator.background=transparent
operator.foreground=#ce7b48
operator.italic=false
operator.underline=false
operator.weight=50
prefix.background=transparent
prefix.foreground=#ce7b48
prefix.italic=false
prefix.underline=false
prefix.weight=75
ptr.background=transparent
ptr.foreground=darkGreen
ptr.italic=false
ptr.underline=false
ptr.weight=50
register.background=transparent
register.foreground=darkgreen
register.italic=false
register.underline=false
register.weight=75
shift.background=transparent
shift.foreground=#569cd6
shift.italic=false
shift.underline=false
shift.weight=50
stack.background=transparent
stack.foreground=#569cd6
stack.italic=false
stack.underline=false
stack.weight=50
system.background=transparent
system.foreground=#569cd6
system.italic=false
system.underline=false
system.weight=75
taken_jump.foreground=red

```

`src/res/themes/system-light.ini`:

```ini
[Theme]
address.foreground=red
alternating_byte.foreground=blue
arithmetic.background=transparent
arithmetic.foreground=blue
arithmetic.italic=false
arithmetic.underline=false
arithmetic.weight=50
badge.background=blue
badge.foreground=white
brackets.background=transparent
brackets.foreground=blue
brackets.italic=false
brackets.underline=false
brackets.weight=75
comma.background=transparent
comma.foreground=blue
comma.italic=false
comma.underline=false
comma.weight=75
comparison.background=transparent
comparison.foreground=blue
comparison.italic=false
comparison.underline=false
comparison.weight=50
constant.background=transparent
constant.foreground=black
constant.italic=false
constant.underline=false
constant.weight=50
data.background=transparent
data.foreground=black
data.italic=false
data.underline=false
data.weight=50
data_xfer.background=transparent
data_xfer.foreground=blue
data_xfer.italic=false
data_xfer.underline=false
data_xfer.weight=50
filling.foreground=gray
flow_ctrl.background=yellow
flow_ctrl.foreground=blue
flow_ctrl.italic=false
flow_ctrl.underline=false
flow_ctrl.weight=50
function.background=yellow
function.foreground=blue
function.italic=false
function.underline=false
function.weight=50
logic.background=transparent
logic.foreground=blue
logic.italic=false
logic.underline=false
logic.weight=50
non_printing_character.foreground=red
operator.background=transparent
operator.foreground=blue
operator.italic=false
operator.underline=false
operator.weight=50
prefix.background=transparent
prefix.foreground=black
prefix.italic=false
prefix.underline=false
prefix.weight=75
ptr.background=transparent
ptr.foreground=darkGreen
ptr.italic=false
ptr.underline=false
ptr.weight=50
register.background=transparent
register.foreground=red
register.italic=false
register.underline=false
register.weight=75
shift.background=transparent
shift.foreground=blue
shift.italic=false
shift.underline=false
shift.weight=50
stack.background=transparent
stack.foreground=blue
stack.italic=false
stack.underline=false
stack.weight=50
system.background=transparent
system.foreground=blue
system.italic=false
system.underline=false
system.weight=75
taken_jump.foreground=red

```

`src/res/xml/functions.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
	we use a broken out version of the IA-64 name mangling system:

	<type>
		::= <CV-qualifiers> <type>
		::= P <type>	# pointer-to
		::= R <type>	# reference-to
		::= O <type>	# rvalue reference-to (C++0x)
		::= C <type>	# complex pair (C 2000)
		::= G <type>	# imaginary (C 2000)
		::= U <source-name> <type>	# vendor extended type qualifier

	<CV-qualifiers> ::= [r] [V] [K] #(C99) restrict, volatile, const
	<ref-qualifier> ::= R           # & ref-qualifier
	<ref-qualifier> ::= O           # && ref-qualifier

	<builtin-type>
		::= v	# void
		::= w	# wchar_t
		::= b	# bool
		::= c	# char
		::= a	# signed char
		::= h	# unsigned char
		::= s	# short
		::= t	# unsigned short
		::= i	# int
		::= j	# unsigned int
		::= l	# long
		::= m	# unsigned long
		::= x	# long long, __int64
		::= y	# unsigned long long, __int64
		::= n	# __int128
		::= o	# unsigned __int128
		::= f	# float
		::= d	# double
		::= e	# long double, __float80
		::= g	# __float128
		::= z	# ellipsis
		::= Dd # IEEE 754r decimal floating point (64 bits)
		::= De # IEEE 754r decimal floating point (128 bits)
		::= Df # IEEE 754r decimal floating point (32 bits)
		::= Dh # IEEE 754r half-precision floating point (16 bits)
		::= Di # char32_t
		::= Ds # char16_t
		::= Da # auto
		::= Dc # decltype(auto)
		::= Dn # std::nullptr_t (i.e., decltype(nullptr))
		::= u <source-name>	# vendor extended type


Generically:
we support "uZ" for "size_t" for now

For example:

PKc = "const char *"
Pc  = "char *"
P4FILE = "FILE *"

-->
<functions version="1.0">
	<!-- assert.h -->
	<function type="v" name="__assert_fail" noreturn="true">
		<argument type="PKc" name="assertion" />
		<argument type="PKc" name="file" />
		<argument type="j" name="line" />
		<argument type="PKc" name="function" />
	</function>

	<!-- complex.h -->

	<!-- ctype.h -->
	<function name="isalnum" type="i"><argument type="i" name="c"/></function>
	<function name="isalpha" type="i"><argument type="i" name="c"/></function>
	<function name="islower" type="i"><argument type="i" name="c"/></function>
	<function name="isupper" type="i"><argument type="i" name="c"/></function>
	<function name="isdigit" type="i"><argument type="i" name="c"/></function>
	<function name="isxdigit" type="i"><argument type="i" name="c"/></function>
	<function name="iscntrl" type="i"><argument type="i" name="c"/></function>
	<function name="isgraph" type="i"><argument type="i" name="c"/></function>
	<function name="isspace" type="i"><argument type="i" name="c"/></function>
	<function name="isblank" type="i"><argument type="i" name="c"/></function>
	<function name="isprint" type="i"><argument type="i" name="c"/></function>
	<function name="ispunct" type="i"><argument type="i" name="c"/></function>
	<function name="tolower" type="i"><argument type="i" name="c"/></function>
	<function name="toupper" type="i"><argument type="i" name="c"/></function>

	<!-- errno.h -->
	<function type="Pi" name="__errno_location"></function>

	<!-- fenv.h -->

	<!-- float.h -->

	<!-- inttypes.h -->

	<!-- iso646.h -->

	<!-- limits.h -->

	<!-- locale.h -->
	<function name="setlocale" type="Pc"><argument type="i" name="category"/><argument type="PKc" name="locale"/></function>
	<function name="localeconv" type="P5lconv"></function>

	<!-- math.h -->
	<function name="abs" type="i"><argument type="i" name="n"/></function>
	<function name="acos" type="d"><argument type="d" name="x"/></function>
	<function name="acosf" type="f"><argument type="f" name="x"/></function>
	<function name="acosh" type="d"><argument type="d" name="x"/></function>
	<function name="acoshf" type="f"><argument type="f" name="x"/></function>
	<function name="acoshl" type="e"><argument type="e" name="x" /></function>
	<function name="acosl" type="e"><argument type="e" name="x" /></function>
	<function name="asin" type="d"><argument type="d" name="x"/></function>
	<function name="asinf" type="f"><argument type="f" name="x"/></function>
	<function name="asinh" type="d"><argument type="d" name="x"/></function>
	<function name="asinhf" type="f"><argument type="f" name="x"/></function>
	<function name="asinhl" type="e"><argument type="e" name="x" /></function>
	<function name="asinl" type="e"><argument type="e" name="x" /></function>
	<function name="atan" type="d"><argument type="d" name="x"/></function>
	<function name="atan2" type="d"><argument type="d" name="x"/><argument type="d" name="y"/></function>
	<function name="atan2f" type="f"><argument type="f" name="x"/><argument type="f" name="y"/></function>
	<function name="atan2l" type="e"><argument type="e" name="x" /><argument type="e" name="y" /></function>
	<function name="atanf" type="f"><argument type="f" name="x"/></function>
	<function name="atanh" type="d"><argument type="d" name="x"/></function>
	<function name="atanhf" type="f"><argument type="f" name="x"/></function>
	<function name="atanhl" type="e"><argument type="e" name="x" /></function>
	<function name="atanl" type="e"><argument type="e" name="x" /></function>
	<function name="cbrt" type="d"><argument type="d" name="x"/></function>
	<function name="cbrtf" type="f"><argument type="f" name="x"/></function>
	<function name="cbrtl" type="e"><argument type="e" name="x" /></function>
	<function name="ceil" type="d"><argument type="d" name="x"/></function>
	<function name="ceilf" type="f"><argument type="f" name="x"/></function>
	<function name="ceill" type="e"><argument type="e" name="x" /></function>
	<function name="copysign" type="d"><argument type="d" name="x"/><argument type="d" name="y"/></function>
	<function name="copysignf" type="f"><argument type="f" name="x"/><argument type="f" name="y"/></function>
	<function name="copysignl" type="e"><argument type="e" name="x" /><argument type="e" name="y" /></function>
	<function name="cos" type="d"><argument type="d" name="x"/></function>
	<function name="cosf" type="f"><argument type="f" name="x"/></function>
	<function name="cosh" type="d"><argument type="d" name="x"/></function>
	<function name="coshf" type="f"><argument type="f" name="x"/></function>
	<function name="coshl" type="e"><argument type="e" name="x" /></function>
	<function name="cosl" type="e"><argument type="e" name="x" /></function>
	<function name="erf" type="d"><argument type="d" name="x"/></function>
	<function name="erfc" type="d"><argument type="d" name="x"/></function>
	<function name="erfcf" type="f"><argument type="f" name="x"/></function>
	<function name="erfcl" type="e"><argument type="e" name="x" /></function>
	<function name="erff" type="f"><argument type="f" name="x"/></function>
	<function name="erfl" type="e"><argument type="e" name="x" /></function>
	<function name="exp" type="d"><argument type="d" name="x"/></function>
	<function name="exp2" type="d"><argument type="d" name="x"/></function>
	<function name="exp2f" type="f"><argument type="f" name="x"/></function>
	<function name="exp2l" type="e"><argument type="e" name="x" /></function>
	<function name="expf" type="f"><argument type="f" name="x"/></function>
	<function name="expl" type="e"><argument type="e" name="x" /></function>
	<function name="expm1" type="d"><argument type="d" name="x"/></function>
	<function name="expm1f" type="f"><argument type="f" name="x"/></function>
	<function name="expm1l" type="e"><argument type="e" name="x" /></function>
	<function name="fabs" type="d"><argument type="d" name="arg"/></function>
	<function name="fabsf" type="f"><argument type="f" name="arg"/></function>
	<function name="fabsl" type="e"><argument type="e" name="arg"/></function>
	<function name="fdim" type="d"><argument type="d" name="x"/><argument type="d" name="y"/></function>
	<function name="fdimf" type="f"><argument type="f" name="x"/><argument type="f" name="y"/></function>
	<function name="fdiml" type="e"><argument type="e" name="x" /><argument type="e" name="y" /></function>
	<function name="floor" type="d"><argument type="d" name="x"/></function>
	<function name="floorf" type="f"><argument type="f" name="x"/></function>
	<function name="floorl" type="e"><argument type="e" name="x" /></function>
	<function name="fma" type="d"><argument type="d" name="x"/><argument type="d" name="y"/><argument type="d" name="z"/></function>
	<function name="fmaf" type="f"><argument type="f" name="x"/><argument type="f" name="y"/><argument type="f" name="z"/></function>
	<function name="fmax" type="d"><argument type="d" name="x"/><argument type="d" name="y"/></function>
	<function name="fmaxf" type="f"><argument type="f" name="x"/><argument type="f" name="y"/></function>
	<function name="fmaxl" type="e"><argument type="e" name="x" /><argument type="e" name="y" /></function>
	<function name="fmin" type="d"><argument type="d" name="x"/><argument type="d" name="y"/></function>
	<function name="fminf" type="f"><argument type="f" name="x"/><argument type="f" name="y"/></function>
	<function name="fminl" type="e"><argument type="e" name="x" /><argument type="e" name="y" /></function>
	<function name="fmod" type="d"><argument type="d" name="x"/><argument type="d" name="y"/></function>
	<function name="fmodf" type="f"><argument type="f" name="x"/><argument type="f" name="y"/></function>
	<function name="fmodl" type="e"><argument type="e" name="x" /><argument type="e" name="y" /></function>
	<function name="frexp" type="d"><argument type="d" name="x"/><argument type="Pi" name="exp"/></function>
	<function name="frexpf" type="f"><argument type="f" name="x"/><argument type="Pi" name="exp"/></function>
	<function name="hypot" type="d"><argument type="d" name="x"/><argument type="d" name="y"/></function>
	<function name="hypotf" type="f"><argument type="f" name="x"/><argument type="f" name="y"/></function>
	<function name="hypotl" type="e"><argument type="e" name="x" /><argument type="e" name="y" /></function>
	<function name="j0" type="d"><argument type="d" name="x"/></function>
	<function name="j1" type="d"><argument type="d" name="x"/></function>
	<function name="jn" type="d"><argument type="i" name="x"/><argument type="d" name="y"/></function>
	<function name="labs" type="l"><argument type="l" name="n"/></function>
	<function name="ldexp" type="d"><argument type="d" name="x"/><argument type="Pi" name="y"/></function>
	<function name="ldexpf" type="f"><argument type="f" name="x"/><argument type="i" name="y"/></function>
	<function name="lgamma" type="d"><argument type="d" name="x"/></function>
	<function name="lgammaf" type="f"><argument type="f" name="x"/></function>
	<function name="lgammal" type="e"><argument type="e" name="x" /></function>
	<function name="llabs" type="x"><argument type="x" name="n"/></function>
	<function name="log" type="d"><argument type="d" name="x"/></function>
	<function name="log10" type="d"><argument type="d" name="x"/></function>
	<function name="log10f" type="f"><argument type="f" name="x"/></function>
	<function name="log10l" type="e"><argument type="e" name="x" /></function>
	<function name="log1p" type="d"><argument type="d" name="x"/></function>
	<function name="log1pf" type="f"><argument type="f" name="x"/></function>
	<function name="log1pl" type="e"><argument type="e" name="x" /></function>
	<function name="log2" type="d"><argument type="d" name="x"/></function>
	<function name="log2f" type="f"><argument type="f" name="x"/></function>
	<function name="log2l" type="e"><argument type="e" name="x" /></function>
	<function name="logb" type="d"><argument type="d" name="x"/></function>
	<function name="logbf" type="f"><argument type="f" name="x"/></function>
	<function name="logbl" type="e"><argument type="e" name="x" /></function>
	<function name="logf" type="f"><argument type="f" name="x"/></function>
	<function name="logl" type="e"><argument type="e" name="x" /></function>
	<function name="modf" type="d"><argument type="d" name="x"/><argument type="Pd" name="y"/></function>
	<function name="modff" type="f"><argument type="f" name="x"/><argument type="Pf" name="y"/></function>
	<function name="nan" type="d"><argument type="PKc" name="s"/></function>
	<function name="nanf" type="f"><argument type="PKc" name="s"/></function>
	<function name="nearbyint" type="d"><argument type="d" name="x"/></function>
	<function name="nearbyintf" type="f"><argument type="f" name="x"/></function>
	<function name="nearbyintl" type="e"><argument type="e" name="x" /></function>
	<function name="nextafter" type="d"><argument type="d" name="x"/><argument type="d" name="y"/></function>
	<function name="nextafterf" type="f"><argument type="f" name="x"/><argument type="f" name="y"/></function>
	<function name="nextafterl" type="e"><argument type="e" name="x" /><argument type="e" name="y" /></function>
	<function name="nexttoward" type="d"><argument type="d" name="x"/><argument type="d" name="y"/></function>
	<function name="nexttowardf" type="f"><argument type="f" name="x"/><argument type="f" name="y"/></function>
	<function name="nexttowardl" type="e"><argument type="e" name="x" /><argument type="e" name="y" /></function>
	<function name="pow" type="d"><argument type="d" name="x"/><argument type="d" name="y"/></function>
	<function name="powf" type="f"><argument type="f" name="x"/><argument type="f" name="y"/></function>
	<function name="powl" type="e"><argument type="e" name="x" /><argument type="e" name="y" /></function>
	<function name="remainder" type="d"><argument type="d" name="x"/><argument type="d" name="y"/></function>
	<function name="remainderf" type="f"><argument type="f" name="x"/><argument type="f" name="y"/></function>
	<function name="remainderl" type="e"><argument type="e" name="x" /><argument type="e" name="y" /></function>
	<function name="remquo" type="d"><argument type="d" name="x"/><argument type="d" name="y"/><argument type="Pi" name="quo"/></function>
	<function name="remquof" type="f"><argument type="f" name="x"/><argument type="f" name="y"/><argument type="Pi" name="quo"/></function>
	<function name="rint" type="d"><argument type="d" name="x"/></function>
	<function name="rintf" type="f"><argument type="f" name="x"/></function>
	<function name="rintl" type="e"><argument type="e" name="x" /></function>
	<function name="round" type="d"><argument type="d" name="x"/></function>
	<function name="roundf" type="f"><argument type="f" name="x"/></function>
	<function name="roundl" type="e"><argument type="e" name="x" /></function>
	<function name="scalb" type="d"><argument type="d" name="x"/><argument type="d" name="y"/></function>
	<function name="scalbln" type="d"><argument type="d" name="x"/><argument type="l" name="y"/></function>
	<function name="scalblnf" type="f"><argument type="f" name="x"/><argument type="l" name="y"/></function>
	<function name="scalbn" type="d"><argument type="d" name="x"/><argument type="Pi" name="y"/></function>
	<function name="scalbnf" type="f"><argument type="f" name="x"/><argument type="i" name="y"/></function>
	<function name="sin" type="d"><argument type="d" name="x"/></function>
	<function name="sinf" type="f"><argument type="f" name="x"/></function>
	<function name="sinh" type="d"><argument type="d" name="x"/></function>
	<function name="sinhf" type="f"><argument type="f" name="x"/></function>
	<function name="sinhl" type="e"><argument type="e" name="x" /></function>
	<function name="sinl" type="e"><argument type="e" name="x" /></function>
	<function name="sqrt" type="d"><argument type="d" name="x"/></function>
	<function name="sqrtf" type="f"><argument type="f" name="x"/></function>
	<function name="sqrtl" type="e"><argument type="e" name="x" /></function>
	<function name="tan" type="d"><argument type="d" name="x"/></function>
	<function name="tanf" type="f"><argument type="f" name="x"/></function>
	<function name="tanh" type="d"><argument type="d" name="x"/></function>
	<function name="tanhf" type="f"><argument type="f" name="x"/></function>
	<function name="tanhl" type="e"><argument type="e" name="x" /></function>
	<function name="tanl" type="e"><argument type="e" name="x" /></function>
	<function name="tgamma" type="d"><argument type="d" name="x"/></function>
	<function name="tgammaf" type="f"><argument type="f" name="x"/></function>
	<function name="tgammal" type="e"><argument type="e" name="x" /></function>
	<function name="trunc" type="d"><argument type="d" name="x"/></function>
	<function name="truncf" type="f"><argument type="f" name="x"/></function>
	<function name="truncl" type="e"><argument type="e" name="x" /></function>
	<function name="y0" type="d"><argument type="d" name="x"/></function>
	<function name="y1" type="d"><argument type="d" name="x"/></function>
	<function name="yn" type="d"><argument type="i" name="x"/><argument type="d" name="y"/></function>
	<function name="ilogb" type="i"><argument type="d" name="x" /></function>
	<function name="ilogbf" type="i"><argument type="f" name="x" /></function>
	<function name="ilogbl" type="i"><argument type="e" name="x" /></function>
	<function name="lrint" type="l"><argument type="d" name="x" /></function>
	<function name="lrintf" type="l"><argument type="f" name="x" /></function>
	<function name="lrintl" type="l"><argument type="e" name="x" /></function>
	<function name="lround" type="l"><argument type="d" name="x" /></function>
	<function name="lroundf" type="l"><argument type="f" name="x" /></function>
	<function name="lroundl" type="l"><argument type="e" name="x" /></function>
	<function name="llrint" type="x"><argument type="d" name="x" /></function>
	<function name="llrintf" type="x"><argument type="f" name="x" /></function>
	<function name="llrintl" type="x"><argument type="e" name="x" /></function>
	<function name="llround" type="x"><argument type="d" name="x" /></function>
	<function name="llroundf" type="x"><argument type="f" name="x" /></function>
	<function name="llroundl" type="x"><argument type="e" name="x" /></function>
	<function name="nanl" type="e"><argument type="PKc" name="x" /></function>
	<!--
	long double fmal(long double, long double, long double);
	long double frexpl(long double value, int *);
	long double ldexpl(long double, int);
	long double modfl(long double, long double *);
	long double remquol(long double, long double, int *);
	long double scalblnl(long double, long);
	long double scalbnl(long double, int);
	intmax_t imaxabs(intmax_t n);
	-->
	<!-- setjmp.h -->
	<function name="setjmp" type="i"><argument type="P" name="env"/></function>
	<function name="longjmp" type="v"><argument type="P" name="env"/><argument type="i" name="status"/></function>
	<!-- signal.h -->
	<function name="signal" type="P"><argument type="i" name="sig"/><argument type="P" name="handler"/></function>
	<function name="raise" type="i"><argument type="i" name="sig"/></function>
	<!-- stdalign.h -->
	<!-- stdarg.h -->
	<!-- stdatomic.h -->
	<!-- stdbool.h -->
	<!-- stddef.h -->
	<!-- stdint.h -->
	<!-- stdio.h -->
	<function name="ctermid" type="Pc"><argument type="Pc" name="s" /></function>
	<function name="fclose" type="i"><argument type="P4FILE" name="stream" /></function>
	<function name="feof" type="i"><argument type="P4FILE" name="stream" /></function>
	<function name="ferror" type="i"><argument type="P4FILE" name="stream" /></function>
	<function name="fflush" type="i"><argument type="P4FILE" name="stream" /></function>
	<function name="fgetc" type="i"><argument type="P4FILE" name="stream" /></function>
	<function name="fileno" type="i"><argument type="P4FILE" name="stream" /></function>
	<function name="ftrylockfile" type="i"><argument type="P4FILE" name="stream" /></function>
	<function name="getc" type="i"><argument type="P4FILE" name="stream" /></function>
	<function name="getc_unlocked" type="i"><argument type="P4FILE" name="stream" /></function>
	<function name="gets" type="Pc"><argument type="Pc" name="s" /></function>
	<function name="pclose" type="i"><argument type="P4FILE" name="stream" /></function>
	<function name="putchar" type="i"><argument type="i" name="ch" /></function>
	<function name="putchar_unlocked" type="i"><argument type="i" name="ch" /></function>
	<function name="puts" type="i"><argument type="PKc" name="s" /></function>
	<function name="remove" type="i"><argument type="PKc" name="s" /></function>
	<function name="tmpnam" type="Pc"><argument type="Pc" name="s" /></function>
	<function name="fputc" type="i"><argument type="i" name="ch" /><argument type="P4FILE" name="stream" /></function>
	<function name="putc" type="i"><argument type="i" name="ch" /><argument type="P4FILE" name="stream" /></function>
	<function name="putc_unlocked" type="i"><argument type="i" name="ch" /><argument type="P4FILE" name="stream" /></function>
	<function name="ungetc" type="i"><argument type="i" name="ch" /><argument type="P4FILE" name="stream" /></function>
	<function name="getchar" type="i"></function>
	<function name="getchar_unlocked" type="i"></function>

	<!--
	FILE    *fdopen(int, const char *);
	FILE    *fopen(const char *, const char *);
	FILE    *freopen(const char *, const char *, FILE *);
	FILE    *popen(const char *, const char *);
	FILE    *tmpfile(void);
	char    *fgets(char *, int, FILE *);
	char    *tempnam(const char *, const char *);
	int      fgetpos(FILE *, fpos_t *);
	int      fprintf(FILE *, const char *, ...);
	int      fputs(const char *, FILE *);
	int      fscanf(FILE *, const char *, ...);
	int      fseek(FILE *, long, int);
	int      fseeko(FILE *, off_t, int);
	int      fsetpos(FILE *, const fpos_t *);
	int      printf(const char *, ...);
	int      rename(const char *, const char *);
	int      scanf(const char *, ...);
	int      setvbuf(FILE *, char *, int, size_t);
	int      snprintf(char *, size_t, const char *, ...);
	int      sprintf(char *, const char *, ...);
	int      sscanf(const char *, const char *, int ...);
	int      vfprintf(FILE *, const char *, va_list);
	int      vfscanf(FILE *, const char *, va_list);
	int      vprintf(const char *, va_list);
	int      vscanf(const char *, va_list);
	int      vsnprintf(char *, size_t, const char *, va_list;
	int      vsprintf(char *, const char *, va_list);
	int      vsscanf(const char *, const char *, va_list arg);
	long     ftell(FILE *);
	off_t    ftello(FILE *);
	size_t   fread(void *, size_t, size_t, FILE *);
	size_t   fwrite(const void *, size_t, size_t, FILE *);
	void     clearerr(FILE *);
	void     flockfile(FILE *);
	void     funlockfile(FILE *);
	void     perror(const char *);
	void     rewind(FILE *);
	void     setbuf(FILE *, char *);
	-->

	<!-- string.h -->
	<function name="memchr" type="Pv"><argument type="PKv" name="s1" /><argument type="i" name="ch" /><argument type="uZ" name="n" /></function>
	<function name="memcmp" type="i"><argument type="PKv" name="s1" /><argument type="PKv" name="s2" /><argument type="uZ" name="s3" /></function>
	<function name="memcpy" type="Pv"><argument type="Pv" name="dest" /><argument type="PKc" name="src" /><argument type="uZ" name="n" /></function>
	<function name="memmove" type="Pv"><argument type="Pv" name="dest" /><argument type="PKc" name="src" /><argument type="uZ" name="n" /></function>
	<function name="memset" type="Pv"><argument type="Pv" name="dest" /><argument type="i" name="ch" /><argument type="uZ" name="n" /></function>
	<function name="strcat" type="Pc"><argument type="Pc" name="s1" /><argument type="PKc" name="s2" /></function>
	<function name="strchr" type="Pc"><argument type="PKc" name="s1" /><argument type="i" name="ch" /></function>
	<function name="strcmp" type="i"><argument type="PKc" name="s1" /><argument type="PKc" name="s2" /></function>
	<function name="strcoll" type="i"><argument type="PKc" name="s1" /><argument type="PKc" name="s2" /></function>
	<function name="strcpy" type="Pc"><argument type="Pc" name="s1" /><argument type="PKc" name="s2" /></function>
	<function name="strcspn" type="uZ"><argument type="PKc" name="s1" /><argument type="PKc" name="s2" /></function>
	<function name="strdup" type="Pc"><argument type="PKc" name="s" /></function>
	<function name="strerror" type="Pc"><argument type="i" name="n" /></function>
	<function name="strlen" type="uZ"><argument type="PKc" name="s" /></function>
	<function name="strncat" type="Pc"><argument type="Pc" name="s1" /><argument type="PKc" name="s2" /><argument type="uZ" name="s3" /></function>
	<function name="strncmp" type="i"><argument type="PKc" name="s1" /><argument type="PKc" name="s2" /><argument type="uZ" name="s3" /></function>
	<function name="strncpy" type="Pc"><argument type="Pc" name="s1" /><argument type="PKc" name="s2" /><argument type="uZ" name="s3" /></function>
	<function name="strpbrk" type="Pc"><argument type="PKc" name="s1" /><argument type="PKc" name="s2" /></function>
	<function name="strrchr" type="Pc"><argument type="PKc" name="s" /><argument type="i" name="c" /></function>
	<function name="strspn" type="uZ"><argument type="PKc" name="s1" /><argument type="PKc" name="s2" /></function>
	<function name="strstr" type="Pc"><argument type="PKc" name="s1" /><argument type="PKc" name="s2" /></function>
	<function name="strtok" type="Pc"><argument type="Pc" name="s1" /><argument type="PKc" name="s2" /></function>
	<function name="strtok_r" type="Pc"><argument type="Pc" name="s1" /><argument type="PKc" name="s2" /><argument type="PPc" name="s3" /></function>

	<!--
	int     *strerror_r(int, char *, size_t);
	size_t   strxfrm(char *, const char *, size_t);
	void    *memccpy(void *, const void *, int, size_t);
	-->

	<!-- stdlib.h -->
	<function type="Pc" name="getenv"><argument type="PKc" name="s" /></function>
	<function type="Pc" name="mktemp"><argument type="Pc" name="s" /></function>
	<function type="Pc" name="setstate"><argument type="PKc" name="s" /></function>
	<function type="i" name="abs"><argument type="i" name="n" /></function>
	<function type="i" name="atoi"><argument type="PKc" name="s" /></function>
	<function type="i" name="grantpt"><argument type="i" name="n" /></function>
	<function type="i" name="mkstemp"><argument type="Pc" name="s" /></function>
	<function type="i" name="posix_openpt"><argument type="i" name="n" /></function>
	<function type="i" name="putenv"><argument type="Pc" name="s" /></function>
	<function type="i" name="rand"></function>
	<function type="i" name="system"><argument type="PKc" name="s" /></function>
	<function type="i" name="unlockpt"><argument type="i" name="n" /></function>
	<function type="i" name="unsetenv"><argument type="PKc" name="s" /></function>
	<function type="v" name="_Exit" noreturn="true" ><argument type="i" name="x" /></function>
	<function type="v" name="abort" noreturn="true" ></function>
	<function type="v" name="exit" noreturn="true" ><argument type="i" name="x" /></function>
	<function type="i" name="atexit"><argument type="PFvv" name="function" /></function>


	<!--
	char         *initstate(unsigned, char *, size_t);
	char         *l64a(long);
	char         *ptsname(int);
	char         *realpath(const char *, char *);
	div_t         div(int, int);
	double        atof(const char *);
	double        drand48(void);
	double        erand48(unsigned short[3]);
	double        strtod(const char *, char **);
	float         strtof(const char *, char **);
	int           getsubopt(char **, char *const *, char **);
	int           mblen(const char *, size_t);
	int           mbtowc(wchar_t *, const char *, size_t);
	int           posix_memalign(void **, size_t, size_t);
	int           rand_r(unsigned *);
	int           setenv(const char *, const char *, int);
	int           wctomb(char *, wchar_t);
	ldiv_t        ldiv(long, long);
	lldiv_t       lldiv(long long, long long);
	long          a64l(const char *);
	long          atol(const char *);
	long          jrand48(unsigned short[3]);
	long          labs(long);
	long          lrand48(void);
	long          mrand48(void);
	long          nrand48(unsigned short[3]);
	long          random(void);
	long          strtol(const char *, char **, int);
	long double   strtold(const char *, char **);
	long long     atoll(const char *);
	long long     llabs(long long);
	long long     strtoll(const char *, char **, int);
	size_t        mbstowcs(wchar_t *, const char *, size_t);
	size_t        wcstombs(char *, const wchar_t *, size_t);
	unsigned long long strtoull(const char *, char **, int);
	unsigned long strtoul(const char *, char **, int);
	unsigned short seed48(unsigned short[3]);
	void          free(void *);
	void          lcong48(unsigned short[7]);
	void          qsort(void *, size_t, size_t, int (*)(const void *, const void *));
	void          setkey(const char *);
	void          srand(unsigned);
	void          srand48(long);
	void          srandom(unsigned);
	void         *bsearch(const void *, const void *, size_t, size_t, int (*)(const void *, const void *));
	void         *calloc(size_t, size_t);
	void         *malloc(size_t);
	void         *realloc(void *, size_t);
	-->

	<function type="v" name="_exit" noreturn="true" >
		<argument type="i" name="x" />
	</function>


	<function type="v" name="__assert_fail_base" noreturn="true">
		<argument type="PKc" name="fmt," />
		<argument type="PKc" name="assertion" />
		<argument type="PKc" name="file" />
		<argument type="j" name="line" />
		<argument type="PKc" name="function" />
	</function>

	<function type="v" name="_dl_signal_error" noreturn="true">
		<argument type="i" name="errcode," />
		<argument type="PKc" name="objname," />
		<argument type="PKc" name="occation," />
		<argument type="PKc" name="errstring" />
	</function>

	<function type="v" name="_dl_reloc_bad_type" noreturn="true">
		<argument type="Pv" name="map" />
		<argument type="j" name="type" />
		<argument type="i" name="plt" />
	</function>

	<function type="v" name="__stack_chk_fail" noreturn="true" ></function>

	<function type="v" name="_dl_signal_cerror">
		<argument type="i" name="errcode," />
		<argument type="PKc" name="objname," />
		<argument type="PKc" name="occation," />
		<argument type="PKc" name="errstring" />
	</function>

	<function type="i" name="__libc_start_main">
		<argument type="PFiiPPcS0_E" name="main" />
		<argument type="i" name="argc" />
		<argument type="PPc" name="ubp_av" />
		<argument type="PFvvE" name="init" />
		<argument type="PFvvE" name="fini" />
		<argument type="PFvvE" name="rtld_fini" />
		<argument type="Pv" name="stack_end" />
	</function>

	<function type="v" name="_Unwind_Resume" noreturn="true">
		<argument type="Pv" name="object" />
	</function>

    <function type="Pv" name="_dl_start"> <!-- return type is really ElfW(Addr) "-->
    	<argument type="Pv" name="arg" />
    </function>
</functions>

```

`src/res/xml/syscalls.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<syscalls version="1.0">
	<linux arch="x86">
		<syscall name="restart_syscall">
			<index>0</index>
		</syscall>
		<syscall name="exit">
			<index>1</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="fork">
			<index>2</index>
		</syscall>
		<syscall name="read">
			<index>3</index>
			<argument type="j" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="write">
			<index>4</index>
			<argument type="j" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="open">
			<index>5</index>
			<argument type="Pc" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="t" register="edx"/>
		</syscall>
		<syscall name="close">
			<index>6</index>
			<argument type="j" register="ebx"/>
		</syscall>
		<syscall name="waitpid">
			<index>7</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="creat">
			<index>8</index>
			<argument type="Pc" register="ebx"/>
			<argument type="t" register="ecx"/>
		</syscall>
		<syscall name="link">
			<index>9</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
		</syscall>
		<syscall name="unlink">
			<index>10</index>
			<argument type="Pc" register="ebx"/>
		</syscall>
		<syscall name="execve">
			<index>11</index>
			<argument type="Pc" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="chdir">
			<index>12</index>
			<argument type="Pc" register="ebx"/>
		</syscall>
		<syscall name="time">
			<index>13</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="mknod">
			<index>14</index>
			<argument type="Pc" register="ebx"/>
			<argument type="t" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="chmod">
			<index>15</index>
			<argument type="Pc" register="ebx"/>
			<argument type="t" register="ecx"/>
		</syscall>
		<syscall name="lchown">
			<index>16</index>
			<argument type="Pc" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="break">
			<index>17</index>
		</syscall>
		<syscall name="oldstat">
			<index>18</index>
			<argument type="Pc" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="lseek">
			<index>19</index>
			<argument type="j" register="ebx"/>
			<argument type="l" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="getpid">
			<index>20</index>
		</syscall>
		<syscall name="mount">
			<index>21</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="Pc" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="P" register="edi"/>
		</syscall>
		<syscall name="umount">
			<index>22</index>
			<argument type="Pc" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="setuid">
			<index>23</index>
			<argument type="j" register="ebx"/>
		</syscall>
		<syscall name="getuid">
			<index>24</index>
		</syscall>
		<syscall name="stime">
			<index>25</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="ptrace">
			<index>26</index>
			<argument type="l" register="ebx"/>
			<argument type="l" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
		</syscall>
		<syscall name="alarm">
			<index>27</index>
			<argument type="j" register="ebx"/>
		</syscall>
		<syscall name="oldfstat">
			<index>28</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="pause">
			<index>29</index>
		</syscall>
		<syscall name="utime">
			<index>30</index>
			<argument type="Pc" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="stty">
			<index>31</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="gtty">
			<index>32</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="access">
			<index>33</index>
			<argument type="Pc" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="nice">
			<index>34</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="ftime">
			<index>35</index>
		</syscall>
		<syscall name="sync">
			<index>36</index>
		</syscall>
		<syscall name="kill">
			<index>37</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="rename">
			<index>38</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
		</syscall>
		<syscall name="mkdir">
			<index>39</index>
			<argument type="Pc" register="ebx"/>
			<argument type="t" register="ecx"/>
		</syscall>
		<syscall name="rmdir">
			<index>40</index>
			<argument type="Pc" register="ebx"/>
		</syscall>
		<syscall name="dup">
			<index>41</index>
			<argument type="j" register="ebx"/>
		</syscall>
		<syscall name="pipe">
			<index>42</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="times">
			<index>43</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="prof">
			<index>44</index>
		</syscall>
		<syscall name="brk">
			<index>45</index>
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="setgid">
			<index>46</index>
			<argument type="j" register="ebx"/>
		</syscall>
		<syscall name="getgid">
			<index>47</index>
		</syscall>
		<syscall name="signal">
			<index>48</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="geteuid">
			<index>49</index>
		</syscall>
		<syscall name="getegid">
			<index>50</index>
		</syscall>
		<syscall name="acct">
			<index>51</index>
			<argument type="Pc" register="ebx"/>
		</syscall>
		<syscall name="umount2">
			<index>52</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="lock">
			<index>53</index>
		</syscall>
		<syscall name="ioctl">
			<index>54</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="fcntl">
			<index>55</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="mpx">
			<index>56</index>
		</syscall>
		<syscall name="setpgid">
			<index>57</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="ulimit">
			<index>58</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="oldolduname">
			<index>59</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="umask">
			<index>60</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="chroot">
			<index>61</index>
			<argument type="Pc" register="ebx"/>
		</syscall>
		<syscall name="ustat">
			<index>62</index>
			<argument type="j" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="dup2">
			<index>63</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="getppid">
			<index>64</index>
		</syscall>
		<syscall name="getpgrp">
			<index>65</index>
		</syscall>
		<syscall name="setsid">
			<index>66</index>
		</syscall>
		<syscall name="sigaction">
			<index>67</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="sgetmask">
			<index>68</index>
		</syscall>
		<syscall name="ssetmask">
			<index>69</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="setreuid">
			<index>70</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="setregid">
			<index>71</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="sigsuspend">
			<index>72</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="sigpending">
			<index>73</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="sethostname">
			<index>74</index>
			<argument type="Pc" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="setrlimit">
			<index>75</index>
			<argument type="j" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="getrlimit">
			<index>76</index>
			<argument type="j" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="getrusage">
			<index>77</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="gettimeofday">
			<index>78</index>
			<argument type="P" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="settimeofday">
			<index>79</index>
			<argument type="P" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="getgroups">
			<index>80</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="setgroups">
			<index>81</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="select">
			<index>82</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="P" register="edi"/>
		</syscall>
		<syscall name="symlink">
			<index>83</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
		</syscall>
		<syscall name="oldlstat">
			<index>84</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="readlink">
			<index>85</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="uselib">
			<index>86</index>
			<argument type="Pc" register="ebx"/>
		</syscall>
		<syscall name="swapon">
			<index>87</index>
			<argument type="Pc" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="reboot">
			<index>88</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="readdir">
			<index>89</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="mmap">
			<index>90</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="munmap">
			<index>91</index>
			<argument type="m" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="truncate">
			<index>92</index>
			<argument type="Pc" register="ebx"/>
			<argument type="l" register="ecx"/>
		</syscall>
		<syscall name="ftruncate">
			<index>93</index>
			<argument type="j" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="fchmod">
			<index>94</index>
			<argument type="j" register="ebx"/>
			<argument type="t" register="ecx"/>
		</syscall>
		<syscall name="fchown">
			<index>95</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="getpriority">
			<index>96</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="setpriority">
			<index>97</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="profil">
			<index>98</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
		</syscall>
		<syscall name="statfs">
			<index>99</index>
			<argument type="Pc" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="fstatfs">
			<index>100</index>
			<argument type="j" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="ioperm">
			<index>101</index>
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="socketcall">
			<index>102</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="syslog">
			<index>103</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="setitimer">
			<index>104</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="getitimer">
			<index>105</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="stat">
			<index>106</index>
			<argument type="Pc" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="lstat">
			<index>107</index>
			<argument type="Pc" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="fstat">
			<index>108</index>
			<argument type="j" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="olduname">
			<index>109</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="iopl">
			<index>110</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="vhangup">
			<index>111</index>
		</syscall>
		<syscall name="idle">
			<index>112</index>
		</syscall>
		<syscall name="vm86old">
			<index>113</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="wait4">
			<index>114</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="swapoff">
			<index>115</index>
			<argument type="Pc" register="ebx"/>
		</syscall>
		<syscall name="sysinfo">
			<index>116</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="ipc">
			<index>117</index>
			<argument type="j" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="P" register="edi"/>
			<argument type="l" register="ebp"/>
		</syscall>
		<syscall name="fsync">
			<index>118</index>
			<argument type="j" register="ebx"/>
		</syscall>
		<syscall name="sigreturn">
			<index>119</index>
		</syscall>
		<syscall name="clone">
			<index>120</index>
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="P" register="edi"/>
		</syscall>
		<syscall name="setdomainname">
			<index>121</index>
			<argument type="Pc" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="uname">
			<index>122</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="modify_ldt">
			<index>123</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="adjtimex">
			<index>124</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="mprotect">
			<index>125</index>
			<argument type="m" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="sigprocmask">
			<index>126</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="create_module">
			<index>127</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="init_module">
			<index>128</index>
			<argument type="P" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="Pc" register="edx"/>
		</syscall>
		<syscall name="delete_module">
			<index>129</index>
			<argument type="Pc" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="get_kernel_syms">
			<index>130</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="quotactl">
			<index>131</index>
			<argument type="j" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="getpgid">
			<index>132</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="fchdir">
			<index>133</index>
			<argument type="j" register="ebx"/>
		</syscall>
		<syscall name="bdflush">
			<index>134</index>
			<argument type="i" register="ebx"/>
			<argument type="l" register="ecx"/>
		</syscall>
		<syscall name="sysfs">
			<index>135</index>
			<argument type="i" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="personality">
			<index>136</index>
			<argument type="j" register="ebx"/>
		</syscall>
		<syscall name="afs_syscall">
			<index>137</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="setfsuid">
			<index>138</index>
			<argument type="j" register="ebx"/>
		</syscall>
		<syscall name="setfsgid">
			<index>139</index>
			<argument type="j" register="ebx"/>
		</syscall>
		<syscall name="_llseek">
			<index>140</index>
			<argument type="j" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="j" register="edi"/>
		</syscall>
		<syscall name="getdents">
			<index>141</index>
			<argument type="j" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="_newselect">
			<index>142</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="flock">
			<index>143</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="msync">
			<index>144</index>
			<argument type="m" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="readv">
			<index>145</index>
			<argument type="m" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="writev">
			<index>146</index>
			<argument type="m" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="getsid">
			<index>147</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="fdatasync">
			<index>148</index>
			<argument type="j" register="ebx"/>
		</syscall>
		<syscall name="_sysctl">
			<index>149</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="mlock">
			<index>150</index>
			<argument type="m" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="munlock">
			<index>151</index>
			<argument type="m" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="mlockall">
			<index>152</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="munlockall">
			<index>153</index>
		</syscall>
		<syscall name="sched_setparam">
			<index>154</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="sched_getparam">
			<index>155</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="sched_setscheduler">
			<index>156</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="sched_getscheduler">
			<index>157</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="sched_yield">
			<index>158</index>
		</syscall>
		<syscall name="sched_get_priority_max">
			<index>159</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="sched_get_priority_min">
			<index>160</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="sched_rr_get_interval">
			<index>161</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="nanosleep">
			<index>162</index>
			<argument type="P" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="mremap">
			<index>163</index>
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="setresuid">
			<index>164</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="getresuid">
			<index>165</index>
			<argument type="P" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="vm86">
			<index>166</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="query_module">
			<index>167</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="poll">
			<index>168</index>
			<argument type="P" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="nfsservctl">
			<index>169</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="setresgid">
			<index>170</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="getresgid">
			<index>171</index>
			<argument type="P" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="prctl">
			<index>172</index>
			<argument type="i" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="rt_sigreturn">
			<index>173</index>
		</syscall>
		<syscall name="rt_sigaction">
			<index>174</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="rt_sigprocmask">
			<index>175</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="rt_sigpending">
			<index>176</index>
			<argument type="P" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="rt_sigtimedwait">
			<index>177</index>
			<argument type="P" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="rt_sigqueueinfo">
			<index>178</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="rt_sigsuspend">
			<index>179</index>
			<argument type="P" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="pread64">
			<index>180</index>
			<argument type="j" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="x" register="edi:esi"/>
		</syscall>
		<syscall name="pwrite64">
			<index>181</index>
			<argument type="j" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="x" register="edi:esi"/>
		</syscall>
		<syscall name="chown">
			<index>182</index>
			<argument type="Pc" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="getcwd">
			<index>183</index>
			<argument type="Pc" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="capget">
			<index>184</index>
			<argument type="P" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="capset">
			<index>185</index>
			<argument type="P" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="sigaltstack">
			<index>186</index>
			<argument type="P" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="sendfile">
			<index>187</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="getpmsg">
			<index>188</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="putpmsg">
			<index>189</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="vfork">
			<index>190</index>
		</syscall>
		<syscall name="ugetrlimit">
			<index>191</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="mmap2">
			<index>192</index>
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
			<argument type="m" register="ebp"/>
		</syscall>
		<syscall name="truncate64">
			<index>193</index>
			<argument type="Pc" register="ebx"/>
			<argument type="x" register="edx:ecx"/>
		</syscall>
		<syscall name="ftruncate64">
			<index>194</index>
			<argument type="j" register="ebx"/>
			<argument type="x" register="edx:ecx"/>
		</syscall>
		<syscall name="stat64">
			<index>195</index>
			<argument type="Pc" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="lstat64">
			<index>196</index>
			<argument type="Pc" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="fstat64">
			<index>197</index>
			<argument type="m" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="lchown32">
			<index>198</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="getuid32">
			<index>199</index>
		</syscall>
		<syscall name="getgid32">
			<index>200</index>
		</syscall>
		<syscall name="geteuid32">
			<index>201</index>
		</syscall>
		<syscall name="getegid32">
			<index>202</index>
		</syscall>
		<syscall name="setreuid32">
			<index>203</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="setregid32">
			<index>204</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="getgroups32">
			<index>205</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="setgroups32">
			<index>206</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="fchown32">
			<index>207</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="setresuid32">
			<index>208</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="getresuid32">
			<index>209</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="setresgid32">
			<index>210</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="getresgid32">
			<index>211</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="chown32">
			<index>212</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="setuid32">
			<index>213</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="setgid32">
			<index>214</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="setfsuid32">
			<index>215</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="setfsgid32">
			<index>216</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="pivot_root">
			<index>217</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
		</syscall>
		<syscall name="mincore">
			<index>218</index>
			<argument type="m" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="madvise">
			<index>219</index>
			<argument type="m" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="getdents64">
			<index>220</index>
			<argument type="j" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="fcntl64">
			<index>221</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="gettid">
			<index>224</index>
		</syscall>
		<syscall name="readahead">
			<index>225</index>
			<argument type="i" register="ebx"/>
			<argument type="x" register="edx:ecx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="setxattr">
			<index>226</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="j" register="esi"/>
			<argument type="i" register="edi"/>
		</syscall>
		<syscall name="lsetxattr">
			<index>227</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="j" register="esi"/>
			<argument type="i" register="edi"/>
		</syscall>
		<syscall name="fsetxattr">
			<index>228</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="j" register="esi"/>
			<argument type="i" register="edi"/>
		</syscall>
		<syscall name="getxattr">
			<index>229</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="lgetxattr">
			<index>230</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="fgetxattr">
			<index>231</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="listxattr">
			<index>232</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="llistxattr">
			<index>233</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="flistxattr">
			<index>234</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="removexattr">
			<index>235</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
		</syscall>
		<syscall name="lremovexattr">
			<index>236</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
		</syscall>
		<syscall name="fremovexattr">
			<index>237</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
		</syscall>
		<syscall name="tkill">
			<index>238</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="sendfile64">
			<index>239</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="futex">
			<index>240</index>
			<argument type="P" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="P" register="edi"/>
			<argument type="j" register="ebp"/>
		</syscall>
		<syscall name="sched_setaffinity">
			<index>241</index>
			<argument type="i" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="sched_getaffinity">
			<index>242</index>
			<argument type="i" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="set_thread_area">
			<index>243</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="get_thread_area">
			<index>244</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="io_setup">
			<index>245</index>
			<argument type="j" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="io_destroy">
			<index>246</index>
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="io_getevents">
			<index>247</index>
			<argument type="m" register="ebx"/>
			<argument type="l" register="ecx"/>
			<argument type="l" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="P" register="edi"/>
		</syscall>
		<syscall name="io_submit">
			<index>248</index>
			<argument type="m" register="ebx"/>
			<argument type="l" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="io_cancel">
			<index>249</index>
			<argument type="m" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="fadvise64">
			<index>250</index>
			<argument type="i" register="ebx"/>
			<argument type="x" register="edx:ecx"/>
			<argument type="j" register="esi"/>
			<argument type="i" register="edi"/>
		</syscall>
		<syscall name="exit_group">
			<index>252</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="lookup_dcookie">
			<index>253</index>
			<argument type="y" register="ecx:ebx"/>
			<argument type="Pc" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="epoll_create">
			<index>254</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="epoll_ctl">
			<index>255</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="epoll_wait">
			<index>256</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="i" register="esi"/>
		</syscall>
		<syscall name="remap_file_pages">
			<index>257</index>
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="set_tid_address">
			<index>258</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="timer_create">
			<index>259</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="timer_settime">
			<index>260</index>
			<argument type="P" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="timer_gettime">
			<index>261</index>
			<argument type="P" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="timer_getoverrun">
			<index>262</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="timer_delete">
			<index>263</index>
			<argument type="P" register="ebx"/>
		</syscall>
		<syscall name="clock_settime">
			<index>264</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="clock_gettime">
			<index>265</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="clock_getres">
			<index>266</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="clock_nanosleep">
			<index>267</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="statfs64">
			<index>268</index>
			<argument type="Pc" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="fstatfs64">
			<index>269</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="tgkill">
			<index>270</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="utimes">
			<index>271</index>
			<argument type="Pc" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="fadvise64_64">
			<index>272</index>
			<argument type="i" register="ebx"/>
			<argument type="x" register="edx:ecx"/>
			<argument type="x" register="edi:esi"/>
			<argument type="i" register="ebp"/>
		</syscall>
		<syscall name="vserver">
			<index>273</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="mbind">
			<index>274</index>
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="m" register="edi"/>
			<argument type="j" register="ebp"/>
		</syscall>
		<syscall name="get_mempolicy">
			<index>275</index>
			<argument type="P" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="set_mempolicy">
			<index>276</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="mq_open">
			<index>277</index>
			<argument type="Pc" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="t" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="mq_unlink">
			<index>278</index>
			<argument type="Pc" register="ebx"/>
		</syscall>
		<syscall name="mq_timedsend">
			<index>279</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="j" register="esi"/>
			<argument type="P" register="edi"/>
		</syscall>
		<syscall name="mq_timedreceive">
			<index>280</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="P" register="edi"/>
		</syscall>
		<syscall name="mq_notify">
			<index>281</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="mq_getsetattr">
			<index>282</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="kexec_load">
			<index>283</index>
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="m" register="esi"/>
		</syscall>
		<syscall name="waitid">
			<index>284</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="i" register="esi"/>
			<argument type="P" register="edi"/>
		</syscall>
		<syscall name="add_key">
			<index>286</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="j" register="esi"/>
			<argument type="i" register="edi"/>
		</syscall>
		<syscall name="request_key">
			<index>287</index>
			<argument type="Pc" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="Pc" register="edx"/>
			<argument type="i" register="esi"/>
		</syscall>
		<syscall name="keyctl">
			<index>288</index>
			<argument type="i" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="ioprio_set">
			<index>289</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="ioprio_get">
			<index>290</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="inotify_init">
			<index>291</index>
		</syscall>
		<syscall name="inotify_add_watch">
			<index>292</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="inotify_rm_watch">
			<index>293</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="migrate_pages">
			<index>294</index>
			<argument type="i" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="openat">
			<index>295</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="t" register="esi"/>
		</syscall>
		<syscall name="mkdirat">
			<index>296</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="t" register="edx"/>
		</syscall>
		<syscall name="mknodat">
			<index>297</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="t" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="fchownat">
			<index>298</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="j" register="esi"/>
			<argument type="i" register="edi"/>
		</syscall>
		<syscall name="futimesat">
			<index>299</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="fstatat64">
			<index>300</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="i" register="esi"/>
		</syscall>
		<syscall name="unlinkat">
			<index>301</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="renameat">
			<index>302</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="Pc" register="esi"/>
		</syscall>
		<syscall name="linkat">
			<index>303</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="Pc" register="esi"/>
			<argument type="i" register="edi"/>
		</syscall>
		<syscall name="symlinkat">
			<index>304</index>
			<argument type="Pc" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="Pc" register="edx"/>
		</syscall>
		<syscall name="readlinkat">
			<index>305</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="Pc" register="edx"/>
			<argument type="i" register="esi"/>
		</syscall>
		<syscall name="fchmodat">
			<index>306</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="t" register="edx"/>
		</syscall>
		<syscall name="faccessat">
			<index>307</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="pselect6">
			<index>308</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="P" register="edi"/>
			<argument type="P" register="ebp"/>
		</syscall>
		<syscall name="ppoll">
			<index>309</index>
			<argument type="P" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="j" register="edi"/>
		</syscall>
		<syscall name="unshare">
			<index>310</index>
			<argument type="m" register="ebx"/>
		</syscall>
		<syscall name="set_robust_list">
			<index>311</index>
			<argument type="P" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="get_robust_list">
			<index>312</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="splice">
			<index>313</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="j" register="edi"/>
			<argument type="j" register="ebp"/>
		</syscall>
		<syscall name="sync_file_range">
			<index>314</index>
			<argument type="i" register="ebx"/>
			<argument type="x" register="edx:ecx"/>
			<argument type="x" register="edi:esi"/>
			<argument type="j" register="ebp"/>
		</syscall>
		<syscall name="tee">
			<index>315</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="vmsplice">
			<index>316</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="move_pages">
			<index>317</index>
			<argument type="i" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="P" register="edi"/>
			<argument type="i" register="ebp"/>
		</syscall>
		<syscall name="getcpu">
			<index>318</index>
			<argument type="P" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="epoll_pwait">
			<index>319</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="i" register="esi"/>
			<argument type="P" register="edi"/>
			<argument type="j" register="ebp"/>
		</syscall>
		<syscall name="utimensat">
			<index>320</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="i" register="esi"/>
		</syscall>
		<syscall name="signalfd">
			<index>321</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="timerfd_create">
			<index>322</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="eventfd">
			<index>323</index>
			<argument type="j" register="ebx"/>
		</syscall>
		<syscall name="fallocate">
			<index>324</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="x" register="esi:edx"/>
			<argument type="x" register="ebp:edi"/>
		</syscall>
		<syscall name="timerfd_settime">
			<index>325</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="timerfd_gettime">
			<index>326</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="signalfd4">
			<index>327</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="i" register="esi"/>
		</syscall>
		<syscall name="eventfd2">
			<index>328</index>
			<argument type="j" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="epoll_create1">
			<index>329</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="dup3">
			<index>330</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="pipe2">
			<index>331</index>
			<argument type="P" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="inotify_init1">
			<index>332</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="preadv">
			<index>333</index>
			<argument type="m" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="pwritev">
			<index>334</index>
			<argument type="m" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="rt_tgsigqueueinfo">
			<index>335</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="perf_event_open">
			<index>336</index>
			<argument type="P" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="i" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="recvmmsg">
			<index>337</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="j" register="esi"/>
			<argument type="P" register="edi"/>
		</syscall>
		<syscall name="fanotify_init">
			<index>338</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="fanotify_mark">
			<index>339</index>
			<argument type="i" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="y" register="esi:edx"/>
			<argument type="i" register="edi"/>
			<argument type="Pc" register="ebp"/>
		</syscall>
		<syscall name="prlimit64">
			<index>340</index>
			<argument type="i" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="name_to_handle_at">
			<index>341</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="i" register="edi"/>
		</syscall>
		<syscall name="open_by_handle_at">
			<index>342</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="clock_adjtime">
			<index>343</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
		</syscall>
		<syscall name="syncfs">
			<index>344</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="sendmmsg">
			<index>345</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="setns">
			<index>346</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="process_vm_readv">
			<index>347</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="m" register="edi"/>
			<argument type="m" register="ebp"/>
		</syscall>
		<syscall name="process_vm_writev">
			<index>348</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="m" register="edi"/>
			<argument type="m" register="ebp"/>
		</syscall>
		<syscall name="kcmp">
			<index>349</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="finit_module">
			<index>350</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="sched_setattr">
			<index>351</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="sched_getattr">
			<index>352</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="renameat2">
			<index>353</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="Pc" register="esi"/>
			<argument type="j" register="edi"/>
		</syscall>
		<syscall name="seccomp">
			<index>354</index>
			<argument type="j" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="Pc" register="edx"/>
		</syscall>
		<syscall name="getrandom">
			<index>355</index>
			<argument type="Pc" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="memfd_create">
			<index>356</index>
			<argument type="Pc" register="ebx"/>
			<argument type="j" register="ecx"/>
		</syscall>
		<syscall name="bpf">
			<index>357</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="execveat">
			<index>358</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="i" register="edi"/>
		</syscall>
		<syscall name="socket">
			<index>359</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="socketpair">
			<index>360</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="bind">
			<index>361</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="connect">
			<index>362</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="listen">
			<index>363</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="accept4">
			<index>364</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
			<argument type="i" register="esi"/>
		</syscall>
		<syscall name="getsockopt">
			<index>365</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="Pc" register="esi"/>
			<argument type="P" register="edi"/>
		</syscall>
		<syscall name="setsockopt">
			<index>366</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="Pc" register="esi"/>
			<argument type="i" register="edi"/>
		</syscall>
		<syscall name="getsockname">
			<index>367</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="getpeername">
			<index>368</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="sendto">
			<index>369</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="j" register="esi"/>
			<argument type="P" register="edi"/>
			<argument type="i" register="ebp"/>
		</syscall>
		<syscall name="sendmsg">
			<index>370</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="recvfrom">
			<index>371</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="j" register="esi"/>
			<argument type="P" register="edi"/>
			<argument type="P" register="ebp"/>
		</syscall>
		<syscall name="recvmsg">
			<index>372</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="shutdown">
			<index>373</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="userfaultfd">
			<index>374</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="membarrier">
			<index>375</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="mlock2">
			<index>376</index>
			<argument type="m" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="copy_file_range">
			<index>377</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="P" register="esi"/>
			<argument type="j" register="edi"/>
			<argument type="j" register="ebp"/>
		</syscall>
		<syscall name="preadv2">
			<index>378</index>
			<argument type="m" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
			<argument type="i" register="ebp"/>
		</syscall>
		<syscall name="pwritev2">
			<index>379</index>
			<argument type="m" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
			<argument type="i" register="ebp"/>
		</syscall>
		<syscall name="pkey_mprotect">
			<index>380</index>
			<argument type="m" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="i" register="esi"/>
		</syscall>
		<syscall name="pkey_alloc">
			<index>381</index>
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="pkey_free">
			<index>382</index>
			<argument type="i" register="ebx"/>
		</syscall>
		<syscall name="statx">
			<index>383</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="j" register="esi"/>
			<argument type="P" register="edi"/>
		</syscall>
		<syscall name="arch_prctl">
			<index>384</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="socket">
			<index>401</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="bind">
			<index>402</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="connect">
			<index>403</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="listen">
			<index>404</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="accept">
			<index>405</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="getsockname">
			<index>406</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="getpeername">
			<index>407</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="socketpair">
			<index>408</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
		</syscall>
		<syscall name="send">
			<index>409</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="recv">
			<index>410</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="j" register="esi"/>
		</syscall>
		<syscall name="sendto">
			<index>411</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
			<argument type="m" register="ebp"/>
		</syscall>
		<syscall name="recvfrom">
			<index>412</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
			<argument type="m" register="ebp"/>
		</syscall>
		<syscall name="shutdown">
			<index>413</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
		</syscall>
		<syscall name="setsockopt">
			<index>414</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="getsockopt">
			<index>415</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="sendmsg">
			<index>416</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="recvmsg">
			<index>417</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
		</syscall>
		<syscall name="accept4">
			<index>418</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
		</syscall>
		<syscall name="recvmmsg">
			<index>419</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
			<argument type="m" register="edi"/>
		</syscall>
		<syscall name="sendmmsg">
			<index>420</index>
		<!-- This entry only lists parameters with generic types - unsigned long -->
			<argument type="m" register="ebx"/>
			<argument type="m" register="ecx"/>
			<argument type="m" register="edx"/>
			<argument type="m" register="esi"/>
		</syscall>
		<syscall name="semop">
			<index>422</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
		</syscall>
		<syscall name="semget">
			<index>423</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="semctl">
			<index>424</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="i" register="edx"/>
			<argument type="m" register="esi"/>
		</syscall>
		<syscall name="semtimedop">
			<index>425</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="P" register="esi"/>
		</syscall>
		<syscall name="msgsnd">
			<index>432</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="i" register="esi"/>
		</syscall>
		<syscall name="msgrcv">
			<index>433</index>
			<argument type="i" register="ebx"/>
			<argument type="P" register="ecx"/>
			<argument type="j" register="edx"/>
			<argument type="l" register="esi"/>
			<argument type="i" register="edi"/>
		</syscall>
		<syscall name="msgget">
			<index>434</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
		</syscall>
		<syscall name="msgctl">
			<index>435</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
		<syscall name="shmat">
			<index>442</index>
			<argument type="i" register="ebx"/>
			<argument type="Pc" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="shmdt">
			<index>443</index>
			<argument type="Pc" register="ebx"/>
		</syscall>
		<syscall name="shmget">
			<index>444</index>
			<argument type="i" register="ebx"/>
			<argument type="j" register="ecx"/>
			<argument type="i" register="edx"/>
		</syscall>
		<syscall name="shmctl">
			<index>445</index>
			<argument type="i" register="ebx"/>
			<argument type="i" register="ecx"/>
			<argument type="P" register="edx"/>
		</syscall>
	</linux>
	<linux arch="x86-64">
		<syscall name="read">
			<index>0</index>
			<argument type="j" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="write">
			<index>1</index>
			<argument type="j" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="open">
			<index>2</index>
			<argument type="Pc" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="t" register="rdx"/>
		</syscall>
		<syscall name="close">
			<index>3</index>
			<argument type="j" register="rdi"/>
		</syscall>
		<syscall name="stat">
			<index>4</index>
			<argument type="Pc" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="fstat">
			<index>5</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="lstat">
			<index>6</index>
			<argument type="Pc" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="poll">
			<index>7</index>
			<argument type="P" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="lseek">
			<index>8</index>
			<argument type="j" register="rdi"/>
			<argument type="x" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="mmap">
			<index>9</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
			<argument type="y" register="r9"/>
		</syscall>
		<syscall name="mprotect">
			<index>10</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="munmap">
			<index>11</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
		</syscall>
		<syscall name="brk">
			<index>12</index>
			<argument type="y" register="rdi"/>
		</syscall>
		<syscall name="rt_sigaction">
			<index>13</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="y" register="r10"/>
		</syscall>
		<syscall name="rt_sigprocmask">
			<index>14</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="y" register="r10"/>
		</syscall>
		<syscall name="rt_sigreturn">
			<index>15</index>
		</syscall>
		<syscall name="ioctl">
			<index>16</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="pread64">
			<index>17</index>
			<argument type="j" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="x" register="r10"/>
		</syscall>
		<syscall name="pwrite64">
			<index>18</index>
			<argument type="j" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="x" register="r10"/>
		</syscall>
		<syscall name="readv">
			<index>19</index>
			<argument type="y" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="writev">
			<index>20</index>
			<argument type="y" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="access">
			<index>21</index>
			<argument type="Pc" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="pipe">
			<index>22</index>
			<argument type="P" register="rdi"/>
		</syscall>
		<syscall name="select">
			<index>23</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="P" register="r8"/>
		</syscall>
		<syscall name="sched_yield">
			<index>24</index>
		</syscall>
		<syscall name="mremap">
			<index>25</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="msync">
			<index>26</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="mincore">
			<index>27</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="madvise">
			<index>28</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="shmget">
			<index>29</index>
			<argument type="i" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="shmat">
			<index>30</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="shmctl">
			<index>31</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="dup">
			<index>32</index>
			<argument type="j" register="rdi"/>
		</syscall>
		<syscall name="dup2">
			<index>33</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
		</syscall>
		<syscall name="pause">
			<index>34</index>
		</syscall>
		<syscall name="nanosleep">
			<index>35</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="getitimer">
			<index>36</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="alarm">
			<index>37</index>
			<argument type="j" register="rdi"/>
		</syscall>
		<syscall name="setitimer">
			<index>38</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="getpid">
			<index>39</index>
		</syscall>
		<syscall name="sendfile">
			<index>40</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="y" register="r10"/>
		</syscall>
		<syscall name="socket">
			<index>41</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="connect">
			<index>42</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="accept">
			<index>43</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="sendto">
			<index>44</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="j" register="r10"/>
			<argument type="P" register="r8"/>
			<argument type="i" register="r9"/>
		</syscall>
		<syscall name="recvfrom">
			<index>45</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="j" register="r10"/>
			<argument type="P" register="r8"/>
			<argument type="P" register="r9"/>
		</syscall>
		<syscall name="sendmsg">
			<index>46</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="recvmsg">
			<index>47</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="shutdown">
			<index>48</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="bind">
			<index>49</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="listen">
			<index>50</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="getsockname">
			<index>51</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="getpeername">
			<index>52</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="socketpair">
			<index>53</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="setsockopt">
			<index>54</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="Pc" register="r10"/>
			<argument type="i" register="r8"/>
		</syscall>
		<syscall name="getsockopt">
			<index>55</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="Pc" register="r10"/>
			<argument type="P" register="r8"/>
		</syscall>
		<syscall name="clone">
			<index>56</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="fork">
			<index>57</index>
		</syscall>
		<syscall name="vfork">
			<index>58</index>
		</syscall>
		<syscall name="execve">
			<index>59</index>
			<argument type="Pc" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="exit">
			<index>60</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="wait4">
			<index>61</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="kill">
			<index>62</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="uname">
			<index>63</index>
			<argument type="P" register="rdi"/>
		</syscall>
		<syscall name="semget">
			<index>64</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="semop">
			<index>65</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="semctl">
			<index>66</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="y" register="r10"/>
		</syscall>
		<syscall name="shmdt">
			<index>67</index>
			<argument type="Pc" register="rdi"/>
		</syscall>
		<syscall name="msgget">
			<index>68</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="msgsnd">
			<index>69</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="i" register="r10"/>
		</syscall>
		<syscall name="msgrcv">
			<index>70</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="x" register="r10"/>
			<argument type="i" register="r8"/>
		</syscall>
		<syscall name="msgctl">
			<index>71</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="fcntl">
			<index>72</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="flock">
			<index>73</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
		</syscall>
		<syscall name="fsync">
			<index>74</index>
			<argument type="j" register="rdi"/>
		</syscall>
		<syscall name="fdatasync">
			<index>75</index>
			<argument type="j" register="rdi"/>
		</syscall>
		<syscall name="truncate">
			<index>76</index>
			<argument type="Pc" register="rdi"/>
			<argument type="x" register="rsi"/>
		</syscall>
		<syscall name="ftruncate">
			<index>77</index>
			<argument type="j" register="rdi"/>
			<argument type="y" register="rsi"/>
		</syscall>
		<syscall name="getdents">
			<index>78</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="getcwd">
			<index>79</index>
			<argument type="Pc" register="rdi"/>
			<argument type="y" register="rsi"/>
		</syscall>
		<syscall name="chdir">
			<index>80</index>
			<argument type="Pc" register="rdi"/>
		</syscall>
		<syscall name="fchdir">
			<index>81</index>
			<argument type="j" register="rdi"/>
		</syscall>
		<syscall name="rename">
			<index>82</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
		</syscall>
		<syscall name="mkdir">
			<index>83</index>
			<argument type="Pc" register="rdi"/>
			<argument type="t" register="rsi"/>
		</syscall>
		<syscall name="rmdir">
			<index>84</index>
			<argument type="Pc" register="rdi"/>
		</syscall>
		<syscall name="creat">
			<index>85</index>
			<argument type="Pc" register="rdi"/>
			<argument type="t" register="rsi"/>
		</syscall>
		<syscall name="link">
			<index>86</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
		</syscall>
		<syscall name="unlink">
			<index>87</index>
			<argument type="Pc" register="rdi"/>
		</syscall>
		<syscall name="symlink">
			<index>88</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
		</syscall>
		<syscall name="readlink">
			<index>89</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="chmod">
			<index>90</index>
			<argument type="Pc" register="rdi"/>
			<argument type="t" register="rsi"/>
		</syscall>
		<syscall name="fchmod">
			<index>91</index>
			<argument type="j" register="rdi"/>
			<argument type="t" register="rsi"/>
		</syscall>
		<syscall name="chown">
			<index>92</index>
			<argument type="Pc" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="fchown">
			<index>93</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="lchown">
			<index>94</index>
			<argument type="Pc" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="umask">
			<index>95</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="gettimeofday">
			<index>96</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="getrlimit">
			<index>97</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="getrusage">
			<index>98</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="sysinfo">
			<index>99</index>
			<argument type="P" register="rdi"/>
		</syscall>
		<syscall name="times">
			<index>100</index>
			<argument type="P" register="rdi"/>
		</syscall>
		<syscall name="ptrace">
			<index>101</index>
			<argument type="x" register="rdi"/>
			<argument type="x" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
		</syscall>
		<syscall name="getuid">
			<index>102</index>
		</syscall>
		<syscall name="syslog">
			<index>103</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="getgid">
			<index>104</index>
		</syscall>
		<syscall name="setuid">
			<index>105</index>
			<argument type="j" register="rdi"/>
		</syscall>
		<syscall name="setgid">
			<index>106</index>
			<argument type="j" register="rdi"/>
		</syscall>
		<syscall name="geteuid">
			<index>107</index>
		</syscall>
		<syscall name="getegid">
			<index>108</index>
		</syscall>
		<syscall name="setpgid">
			<index>109</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="getppid">
			<index>110</index>
		</syscall>
		<syscall name="getpgrp">
			<index>111</index>
		</syscall>
		<syscall name="setsid">
			<index>112</index>
		</syscall>
		<syscall name="setreuid">
			<index>113</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
		</syscall>
		<syscall name="setregid">
			<index>114</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
		</syscall>
		<syscall name="getgroups">
			<index>115</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="setgroups">
			<index>116</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="setresuid">
			<index>117</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="getresuid">
			<index>118</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="setresgid">
			<index>119</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="getresgid">
			<index>120</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="getpgid">
			<index>121</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="setfsuid">
			<index>122</index>
			<argument type="j" register="rdi"/>
		</syscall>
		<syscall name="setfsgid">
			<index>123</index>
			<argument type="j" register="rdi"/>
		</syscall>
		<syscall name="getsid">
			<index>124</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="capget">
			<index>125</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="capset">
			<index>126</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="rt_sigpending">
			<index>127</index>
			<argument type="P" register="rdi"/>
			<argument type="y" register="rsi"/>
		</syscall>
		<syscall name="rt_sigtimedwait">
			<index>128</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="y" register="r10"/>
		</syscall>
		<syscall name="rt_sigqueueinfo">
			<index>129</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="rt_sigsuspend">
			<index>130</index>
			<argument type="P" register="rdi"/>
			<argument type="y" register="rsi"/>
		</syscall>
		<syscall name="sigaltstack">
			<index>131</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="utime">
			<index>132</index>
			<argument type="Pc" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="mknod">
			<index>133</index>
			<argument type="Pc" register="rdi"/>
			<argument type="t" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="uselib">
			<index>134</index>
			<argument type="Pc" register="rdi"/>
		</syscall>
		<syscall name="personality">
			<index>135</index>
			<argument type="j" register="rdi"/>
		</syscall>
		<syscall name="ustat">
			<index>136</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="statfs">
			<index>137</index>
			<argument type="Pc" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="fstatfs">
			<index>138</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="sysfs">
			<index>139</index>
			<argument type="i" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="getpriority">
			<index>140</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="setpriority">
			<index>141</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="sched_setparam">
			<index>142</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="sched_getparam">
			<index>143</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="sched_setscheduler">
			<index>144</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="sched_getscheduler">
			<index>145</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="sched_get_priority_max">
			<index>146</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="sched_get_priority_min">
			<index>147</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="sched_rr_get_interval">
			<index>148</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="mlock">
			<index>149</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
		</syscall>
		<syscall name="munlock">
			<index>150</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
		</syscall>
		<syscall name="mlockall">
			<index>151</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="munlockall">
			<index>152</index>
		</syscall>
		<syscall name="vhangup">
			<index>153</index>
		</syscall>
		<syscall name="modify_ldt">
			<index>154</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="pivot_root">
			<index>155</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
		</syscall>
		<syscall name="_sysctl">
			<index>156</index>
			<argument type="P" register="rdi"/>
		</syscall>
		<syscall name="prctl">
			<index>157</index>
			<argument type="i" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="arch_prctl">
			<index>158</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
		</syscall>
		<syscall name="adjtimex">
			<index>159</index>
			<argument type="P" register="rdi"/>
		</syscall>
		<syscall name="setrlimit">
			<index>160</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="chroot">
			<index>161</index>
			<argument type="Pc" register="rdi"/>
		</syscall>
		<syscall name="sync">
			<index>162</index>
		</syscall>
		<syscall name="acct">
			<index>163</index>
			<argument type="Pc" register="rdi"/>
		</syscall>
		<syscall name="settimeofday">
			<index>164</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="mount">
			<index>165</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="Pc" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="P" register="r8"/>
		</syscall>
		<syscall name="umount2">
			<index>166</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
		</syscall>
		<syscall name="swapon">
			<index>167</index>
			<argument type="Pc" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="swapoff">
			<index>168</index>
			<argument type="Pc" register="rdi"/>
		</syscall>
		<syscall name="reboot">
			<index>169</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="sethostname">
			<index>170</index>
			<argument type="Pc" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="setdomainname">
			<index>171</index>
			<argument type="Pc" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="iopl">
			<index>172</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
		</syscall>
		<syscall name="ioperm">
			<index>173</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="create_module">
			<index>174</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
		</syscall>
		<syscall name="init_module">
			<index>175</index>
			<argument type="P" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="Pc" register="rdx"/>
		</syscall>
		<syscall name="delete_module">
			<index>176</index>
			<argument type="Pc" register="rdi"/>
			<argument type="j" register="rsi"/>
		</syscall>
		<syscall name="get_kernel_syms">
			<index>177</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
		</syscall>
		<syscall name="query_module">
			<index>178</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="quotactl">
			<index>179</index>
			<argument type="j" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="nfsservctl">
			<index>180</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="getpmsg">
			<index>181</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="putpmsg">
			<index>182</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="afs_syscall">
			<index>183</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="tuxcall">
			<index>184</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="security">
			<index>185</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="gettid">
			<index>186</index>
		</syscall>
		<syscall name="readahead">
			<index>187</index>
			<argument type="i" register="rdi"/>
			<argument type="x" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="setxattr">
			<index>188</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="i" register="r8"/>
		</syscall>
		<syscall name="lsetxattr">
			<index>189</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="i" register="r8"/>
		</syscall>
		<syscall name="fsetxattr">
			<index>190</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="i" register="r8"/>
		</syscall>
		<syscall name="getxattr">
			<index>191</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="y" register="r10"/>
		</syscall>
		<syscall name="lgetxattr">
			<index>192</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="y" register="r10"/>
		</syscall>
		<syscall name="fgetxattr">
			<index>193</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="y" register="r10"/>
		</syscall>
		<syscall name="listxattr">
			<index>194</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="llistxattr">
			<index>195</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="flistxattr">
			<index>196</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="removexattr">
			<index>197</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
		</syscall>
		<syscall name="lremovexattr">
			<index>198</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
		</syscall>
		<syscall name="fremovexattr">
			<index>199</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
		</syscall>
		<syscall name="tkill">
			<index>200</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="time">
			<index>201</index>
			<argument type="P" register="rdi"/>
		</syscall>
		<syscall name="futex">
			<index>202</index>
			<argument type="P" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="P" register="r8"/>
			<argument type="j" register="r9"/>
		</syscall>
		<syscall name="sched_setaffinity">
			<index>203</index>
			<argument type="i" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="sched_getaffinity">
			<index>204</index>
			<argument type="i" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="set_thread_area">
			<index>205</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
		</syscall>
		<syscall name="io_setup">
			<index>206</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="io_destroy">
			<index>207</index>
			<argument type="y" register="rdi"/>
		</syscall>
		<syscall name="io_getevents">
			<index>208</index>
			<argument type="y" register="rdi"/>
			<argument type="x" register="rsi"/>
			<argument type="x" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="P" register="r8"/>
		</syscall>
		<syscall name="io_submit">
			<index>209</index>
			<argument type="y" register="rdi"/>
			<argument type="x" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="io_cancel">
			<index>210</index>
			<argument type="y" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="get_thread_area">
			<index>211</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
		</syscall>
		<syscall name="lookup_dcookie">
			<index>212</index>
			<argument type="y" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="epoll_create">
			<index>213</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="epoll_ctl_old">
			<index>214</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
		</syscall>
		<syscall name="epoll_wait_old">
			<index>215</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
		</syscall>
		<syscall name="remap_file_pages">
			<index>216</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="getdents64">
			<index>217</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="set_tid_address">
			<index>218</index>
			<argument type="P" register="rdi"/>
		</syscall>
		<syscall name="restart_syscall">
			<index>219</index>
		</syscall>
		<syscall name="semtimedop">
			<index>220</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="fadvise64">
			<index>221</index>
			<argument type="i" register="rdi"/>
			<argument type="x" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="i" register="r10"/>
		</syscall>
		<syscall name="timer_create">
			<index>222</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="timer_settime">
			<index>223</index>
			<argument type="P" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="timer_gettime">
			<index>224</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="timer_getoverrun">
			<index>225</index>
			<argument type="P" register="rdi"/>
		</syscall>
		<syscall name="timer_delete">
			<index>226</index>
			<argument type="P" register="rdi"/>
		</syscall>
		<syscall name="clock_settime">
			<index>227</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="clock_gettime">
			<index>228</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="clock_getres">
			<index>229</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="clock_nanosleep">
			<index>230</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="exit_group">
			<index>231</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="epoll_wait">
			<index>232</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="i" register="r10"/>
		</syscall>
		<syscall name="epoll_ctl">
			<index>233</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="tgkill">
			<index>234</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="utimes">
			<index>235</index>
			<argument type="Pc" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="vserver">
			<index>236</index>
		<!-- This entry only lists parameters with generic types - unsigned long long -->
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="mbind">
			<index>237</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="y" register="r8"/>
			<argument type="j" register="r9"/>
		</syscall>
		<syscall name="set_mempolicy">
			<index>238</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="get_mempolicy">
			<index>239</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="mq_open">
			<index>240</index>
			<argument type="Pc" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="t" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="mq_unlink">
			<index>241</index>
			<argument type="Pc" register="rdi"/>
		</syscall>
		<syscall name="mq_timedsend">
			<index>242</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="j" register="r10"/>
			<argument type="P" register="r8"/>
		</syscall>
		<syscall name="mq_timedreceive">
			<index>243</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="P" register="r8"/>
		</syscall>
		<syscall name="mq_notify">
			<index>244</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="mq_getsetattr">
			<index>245</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="kexec_load">
			<index>246</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="y" register="r10"/>
		</syscall>
		<syscall name="waitid">
			<index>247</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="i" register="r10"/>
			<argument type="P" register="r8"/>
		</syscall>
		<syscall name="add_key">
			<index>248</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="i" register="r8"/>
		</syscall>
		<syscall name="request_key">
			<index>249</index>
			<argument type="Pc" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="Pc" register="rdx"/>
			<argument type="i" register="r10"/>
		</syscall>
		<syscall name="keyctl">
			<index>250</index>
			<argument type="i" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="ioprio_set">
			<index>251</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="ioprio_get">
			<index>252</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="inotify_init">
			<index>253</index>
		</syscall>
		<syscall name="inotify_add_watch">
			<index>254</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="inotify_rm_watch">
			<index>255</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="migrate_pages">
			<index>256</index>
			<argument type="i" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="openat">
			<index>257</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="t" register="r10"/>
		</syscall>
		<syscall name="mkdirat">
			<index>258</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="t" register="rdx"/>
		</syscall>
		<syscall name="mknodat">
			<index>259</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="t" register="rdx"/>
			<argument type="j" register="r10"/>
		</syscall>
		<syscall name="fchownat">
			<index>260</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
			<argument type="i" register="r8"/>
		</syscall>
		<syscall name="futimesat">
			<index>261</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="newfstatat">
			<index>262</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="i" register="r10"/>
		</syscall>
		<syscall name="unlinkat">
			<index>263</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="renameat">
			<index>264</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="Pc" register="r10"/>
		</syscall>
		<syscall name="linkat">
			<index>265</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="Pc" register="r10"/>
			<argument type="i" register="r8"/>
		</syscall>
		<syscall name="symlinkat">
			<index>266</index>
			<argument type="Pc" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="Pc" register="rdx"/>
		</syscall>
		<syscall name="readlinkat">
			<index>267</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="Pc" register="rdx"/>
			<argument type="i" register="r10"/>
		</syscall>
		<syscall name="fchmodat">
			<index>268</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="t" register="rdx"/>
		</syscall>
		<syscall name="faccessat">
			<index>269</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="pselect6">
			<index>270</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="P" register="r8"/>
			<argument type="P" register="r9"/>
		</syscall>
		<syscall name="ppoll">
			<index>271</index>
			<argument type="P" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="unshare">
			<index>272</index>
			<argument type="y" register="rdi"/>
		</syscall>
		<syscall name="set_robust_list">
			<index>273</index>
			<argument type="P" register="rdi"/>
			<argument type="y" register="rsi"/>
		</syscall>
		<syscall name="get_robust_list">
			<index>274</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="splice">
			<index>275</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="y" register="r8"/>
			<argument type="j" register="r9"/>
		</syscall>
		<syscall name="tee">
			<index>276</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="j" register="r10"/>
		</syscall>
		<syscall name="sync_file_range">
			<index>277</index>
			<argument type="i" register="rdi"/>
			<argument type="x" register="rsi"/>
			<argument type="x" register="rdx"/>
			<argument type="j" register="r10"/>
		</syscall>
		<syscall name="vmsplice">
			<index>278</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="j" register="r10"/>
		</syscall>
		<syscall name="move_pages">
			<index>279</index>
			<argument type="i" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="P" register="r8"/>
			<argument type="i" register="r9"/>
		</syscall>
		<syscall name="utimensat">
			<index>280</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="i" register="r10"/>
		</syscall>
		<syscall name="epoll_pwait">
			<index>281</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="i" register="r10"/>
			<argument type="P" register="r8"/>
			<argument type="y" register="r9"/>
		</syscall>
		<syscall name="signalfd">
			<index>282</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
		</syscall>
		<syscall name="timerfd_create">
			<index>283</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="eventfd">
			<index>284</index>
			<argument type="j" register="rdi"/>
		</syscall>
		<syscall name="fallocate">
			<index>285</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="x" register="rdx"/>
			<argument type="x" register="r10"/>
		</syscall>
		<syscall name="timerfd_settime">
			<index>286</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="timerfd_gettime">
			<index>287</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="accept4">
			<index>288</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="i" register="r10"/>
		</syscall>
		<syscall name="signalfd4">
			<index>289</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="i" register="r10"/>
		</syscall>
		<syscall name="eventfd2">
			<index>290</index>
			<argument type="j" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="epoll_create1">
			<index>291</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="dup3">
			<index>292</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="pipe2">
			<index>293</index>
			<argument type="P" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="inotify_init1">
			<index>294</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="preadv">
			<index>295</index>
			<argument type="y" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="pwritev">
			<index>296</index>
			<argument type="y" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="rt_tgsigqueueinfo">
			<index>297</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="perf_event_open">
			<index>298</index>
			<argument type="P" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="i" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="recvmmsg">
			<index>299</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
			<argument type="P" register="r8"/>
		</syscall>
		<syscall name="fanotify_init">
			<index>300</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
		</syscall>
		<syscall name="fanotify_mark">
			<index>301</index>
			<argument type="i" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="i" register="r10"/>
			<argument type="Pc" register="r8"/>
		</syscall>
		<syscall name="prlimit64">
			<index>302</index>
			<argument type="i" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="name_to_handle_at">
			<index>303</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="i" register="r8"/>
		</syscall>
		<syscall name="open_by_handle_at">
			<index>304</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="clock_adjtime">
			<index>305</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="syncfs">
			<index>306</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="sendmmsg">
			<index>307</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
		</syscall>
		<syscall name="setns">
			<index>308</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="getcpu">
			<index>309</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="process_vm_readv">
			<index>310</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="y" register="r8"/>
			<argument type="y" register="r9"/>
		</syscall>
		<syscall name="process_vm_writev">
			<index>311</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="y" register="r8"/>
			<argument type="y" register="r9"/>
		</syscall>
		<syscall name="kcmp">
			<index>312</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="finit_module">
			<index>313</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="sched_setattr">
			<index>314</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="sched_getattr">
			<index>315</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
		</syscall>
		<syscall name="renameat2">
			<index>316</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="Pc" register="r10"/>
			<argument type="j" register="r8"/>
		</syscall>
		<syscall name="seccomp">
			<index>317</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="Pc" register="rdx"/>
		</syscall>
		<syscall name="getrandom">
			<index>318</index>
			<argument type="Pc" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="memfd_create">
			<index>319</index>
			<argument type="Pc" register="rdi"/>
			<argument type="j" register="rsi"/>
		</syscall>
		<syscall name="kexec_file_load">
			<index>320</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="Pc" register="r10"/>
			<argument type="y" register="r8"/>
		</syscall>
		<syscall name="bpf">
			<index>321</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="execveat">
			<index>322</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="i" register="r8"/>
		</syscall>
		<syscall name="userfaultfd">
			<index>323</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="membarrier">
			<index>324</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
		</syscall>
		<syscall name="mlock2">
			<index>325</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="i" register="rdx"/>
		</syscall>
		<syscall name="copy_file_range">
			<index>326</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="y" register="r8"/>
			<argument type="j" register="r9"/>
		</syscall>
		<syscall name="preadv2">
			<index>327</index>
			<argument type="y" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
			<argument type="i" register="r9"/>
		</syscall>
		<syscall name="pwritev2">
			<index>328</index>
			<argument type="y" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="y" register="r10"/>
			<argument type="y" register="r8"/>
			<argument type="i" register="r9"/>
		</syscall>
		<syscall name="pkey_mprotect">
			<index>329</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
			<argument type="y" register="rdx"/>
			<argument type="i" register="r10"/>
		</syscall>
		<syscall name="pkey_alloc">
			<index>330</index>
			<argument type="y" register="rdi"/>
			<argument type="y" register="rsi"/>
		</syscall>
		<syscall name="pkey_free">
			<index>331</index>
			<argument type="i" register="rdi"/>
		</syscall>
		<syscall name="statx">
			<index>332</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
			<argument type="P" register="r8"/>
		</syscall>
		<!-- x32-specific syscall numbers -->
		<syscall name="rt_sigaction">
			<index>512</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="j" register="r10"/>
		</syscall>
		<syscall name="rt_sigreturn">
			<index>513</index>
		</syscall>
		<syscall name="ioctl">
			<index>514</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="readv">
			<index>515</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="writev">
			<index>516</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="recvfrom">
			<index>517</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
			<argument type="P" register="r8"/>
			<argument type="P" register="r9"/>
		</syscall>
		<syscall name="sendmsg">
			<index>518</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="recvmsg">
			<index>519</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
		</syscall>
		<syscall name="execve">
			<index>520</index>
			<argument type="Pc" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="ptrace">
			<index>521</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
		</syscall>
		<syscall name="rt_sigpending">
			<index>522</index>
			<argument type="P" register="rdi"/>
			<argument type="j" register="rsi"/>
		</syscall>
		<syscall name="rt_sigtimedwait">
			<index>523</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="j" register="r10"/>
		</syscall>
		<syscall name="rt_sigqueueinfo">
			<index>524</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="sigaltstack">
			<index>525</index>
			<argument type="P" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="timer_create">
			<index>526</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="mq_notify">
			<index>527</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="kexec_load">
			<index>528</index>
			<argument type="j" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="j" register="r10"/>
		</syscall>
		<syscall name="waitid">
			<index>529</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="i" register="r10"/>
			<argument type="P" register="r8"/>
		</syscall>
		<syscall name="set_robust_list">
			<index>530</index>
			<argument type="P" register="rdi"/>
			<argument type="j" register="rsi"/>
		</syscall>
		<syscall name="get_robust_list">
			<index>531</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="vmsplice">
			<index>532</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
		</syscall>
		<syscall name="move_pages">
			<index>533</index>
			<argument type="i" register="rdi"/>
			<argument type="j" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="P" register="r8"/>
			<argument type="i" register="r9"/>
		</syscall>
		<syscall name="preadv">
			<index>534</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
			<argument type="j" register="r8"/>
		</syscall>
		<syscall name="pwritev">
			<index>535</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
			<argument type="j" register="r8"/>
		</syscall>
		<syscall name="rt_tgsigqueueinfo">
			<index>536</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="P" register="r10"/>
		</syscall>
		<syscall name="recvmmsg">
			<index>537</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
			<argument type="P" register="r8"/>
		</syscall>
		<syscall name="sendmmsg">
			<index>538</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
		</syscall>
		<syscall name="process_vm_readv">
			<index>539</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="j" register="r8"/>
			<argument type="j" register="r9"/>
		</syscall>
		<syscall name="process_vm_writev">
			<index>540</index>
			<argument type="i" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="j" register="r8"/>
			<argument type="j" register="r9"/>
		</syscall>
		<syscall name="setsockopt">
			<index>541</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="Pc" register="r10"/>
			<argument type="i" register="r8"/>
		</syscall>
		<syscall name="getsockopt">
			<index>542</index>
			<argument type="i" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="i" register="rdx"/>
			<argument type="Pc" register="r10"/>
			<argument type="P" register="r8"/>
		</syscall>
		<syscall name="io_setup">
			<index>543</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
		</syscall>
		<syscall name="io_submit">
			<index>544</index>
			<argument type="y" register="rdi"/>
			<argument type="i" register="rsi"/>
			<argument type="P" register="rdx"/>
		</syscall>
		<syscall name="execveat">
			<index>545</index>
			<argument type="i" register="rdi"/>
			<argument type="Pc" register="rsi"/>
			<argument type="P" register="rdx"/>
			<argument type="P" register="r10"/>
			<argument type="i" register="r8"/>
		</syscall>
		<syscall name="preadv2">
			<index>546</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
			<argument type="j" register="r8"/>
			<argument type="i" register="r9"/>
		</syscall>
		<syscall name="pwritev2">
			<index>547</index>
			<argument type="j" register="rdi"/>
			<argument type="P" register="rsi"/>
			<argument type="j" register="rdx"/>
			<argument type="j" register="r10"/>
			<argument type="j" register="r8"/>
			<argument type="i" register="r9"/>
		</syscall>
	</linux>
</syscalls>

```

`src/session/SessionError.cpp`:

```cpp
/*
Copyright (C) 2006 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "SessionError.h"

```

`src/session/SessionError.h`:

```h
/*
Copyright (C) 2014 - 2016 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef SESSION_ERROR_H_20170929_
#define SESSION_ERROR_H_20170929_

#include <QString>

class SessionError {
public:
	enum ErrorCode {
		NoError            = 0,
		UnknownError       = 1,
		NotAnObject        = 2,
		InvalidSessionFile = 3,
	};

public:
	ErrorCode err = NoError;
	QString message;
};

#endif

```

`src/session/SessionManager.cpp`:

```cpp
/*
Copyright (C) 2006 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "SessionManager.h"
#include "IPlugin.h"
#include "edb.h"

#include <QDateTime>
#include <QDebug>
#include <QFile>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonParseError>
#include <QMessageBox>

namespace {

constexpr int SessionFileVersion = 1;
const auto SessionFileIdString   = QLatin1String("edb-session");

}

/**
 * @brief SessionManager::instance
 * @return
 */
SessionManager &SessionManager::instance() {
	static SessionManager inst;
	return inst;
}

/**
 * @brief SessionManager::loadSession
 * @param filename
 * @return
 */
Result<void, SessionError> SessionManager::loadSession(const QString &filename) {

	QFile file(filename);
	if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
		// the checks for open() and exists() are racy, but
		// this is fine as it affects only whether we show an
		// error message or not
		if (!file.exists()) {
			// file doesn't exists means this is the first time we
			// opened the debuggee and there is no session file for
			// it yet

			// return success as we don't want showing error message
			// in this case
			return {};
		} else {
			SessionError session_error;
			session_error.err     = SessionError::InvalidSessionFile;
			session_error.message = tr("Failed to open session file. %1").arg(file.errorString());
			return make_unexpected(session_error);
		}
	}

	QByteArray json = file.readAll();
	QJsonParseError error;
	auto doc = QJsonDocument::fromJson(json, &error);
	if (error.error != QJsonParseError::NoError) {
		SessionError session_error;
		session_error.err     = SessionError::UnknownError;
		session_error.message = tr("An error occured while loading session JSON file. %1").arg(error.errorString());
		return make_unexpected(session_error);
	}

	if (!doc.isObject()) {
		SessionError session_error;
		session_error.err     = SessionError::NotAnObject;
		session_error.message = tr("Session file is invalid. Not an object.");
		return make_unexpected(session_error);
	}

	QJsonObject object = doc.object();
	sessionData_       = object.toVariantMap();

	QString id  = sessionData_["id"].toString();
	QString ts  = sessionData_["timestamp"].toString();
	int version = sessionData_["version"].toInt();

	Q_UNUSED(ts)

	if (id != SessionFileIdString || version > SessionFileVersion) {
		SessionError session_error;
		session_error.err     = SessionError::InvalidSessionFile;
		session_error.message = tr("Session file is invalid.");
		return make_unexpected(session_error);
	}

	qDebug("Loading session file");
	loadPluginData(); //First, load the plugin-data
	return {};
}

/**
 * @brief SessionManager::saveSession
 * @param filename
 */
void SessionManager::saveSession(const QString &filename) {

	qDebug("Saving session file");

	QVariantMap plugin_data;

	for (QObject *plugin : edb::v1::plugin_list()) {
		if (auto p = qobject_cast<IPlugin *>(plugin)) {
			if (const QMetaObject *const meta = plugin->metaObject()) {
				QString name     = meta->className();
				QVariantMap data = p->saveState();

				if (!data.empty()) {
					plugin_data[name] = data;
				}
			}
		}
	}

	sessionData_["version"]     = SessionFileVersion;
	sessionData_["id"]          = SessionFileIdString; // just so we can sanity check things
	sessionData_["timestamp"]   = QDateTime::currentDateTimeUtc();
	sessionData_["plugin-data"] = plugin_data;

	auto object = QJsonObject::fromVariantMap(sessionData_);
	QJsonDocument doc(object);

	QByteArray json = doc.toJson();
	QFile file(filename);

	if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {
		file.write(json);
	}
}

/**
 * @brief SessionManager::loadPluginData
 */
void SessionManager::loadPluginData() {

	qDebug("Loading plugin-data");

	QVariantMap plugin_data = sessionData_["plugin-data"].toMap();
	for (auto it = plugin_data.begin(); it != plugin_data.end(); ++it) {
		for (QObject *plugin : edb::v1::plugin_list()) {
			if (auto p = qobject_cast<IPlugin *>(plugin)) {
				if (const QMetaObject *const meta = plugin->metaObject()) {
					QString name     = meta->className();
					QVariantMap data = it.value().toMap();

					if (name == it.key()) {
						p->restoreState(data);
						break;
					}
				}
			}
		}
	}
}

/**
 * @brief SessionManager::comments
 * @return all comments from the sessionData_
 */
QVariantList SessionManager::comments() const {
	return sessionData_["comments"].toList();
}

/**
* Adds a comment to the session_data
* @param c (struct in Types.h)
*/
void SessionManager::addComment(const Comment &c) {

	QVariantList comments_data = sessionData_["comments"].toList();

	QVariantMap comment;
	comment["address"] = c.address.toHexString();
	comment["comment"] = c.comment;

	//Check if we already have an entry with the same address and overwrite it
	auto it = std::find_if(comments_data.begin(), comments_data.end(), [&comment](QVariant entry) {
		QVariantMap data = entry.toMap();
		return data["address"] == comment["address"];
	});

	if (it != comments_data.end()) {
		*it = comment;
	} else {
		comments_data.push_back(comment);
	}

	sessionData_["comments"] = comments_data;
}

/**
* Removes a comment from the session_data
* @param address
*/
void SessionManager::removeComment(edb::address_t address) {
	QString hexAddressString   = address.toHexString();
	QVariantList comments_data = sessionData_["comments"].toList();

	auto it = std::find_if(comments_data.begin(), comments_data.end(), [&hexAddressString](QVariant entry) {
		QVariantMap data = entry.toMap();
		return data["address"] == hexAddressString;
	});

	if (it != comments_data.end()) {
		comments_data.erase(it);
	}

	sessionData_["comments"] = comments_data;
}

```

`src/session/SessionManager.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef SESSION_MANAGER_H_20170928_
#define SESSION_MANAGER_H_20170928_

#include "SessionError.h"
#include "Status.h"
#include "Types.h"

#include <QCoreApplication>
#include <QString>
#include <QVariant>

class SessionManager {
	Q_DECLARE_TR_FUNCTIONS(SessionManager)

private:
	SessionManager() = default;

public:
	SessionManager(const SessionManager &) = delete;
	SessionManager &operator=(const SessionManager &) = delete;

public:
	static SessionManager &instance();

public:
	Result<void, SessionError> loadSession(const QString &filename);
	void saveSession(const QString &filename);
	QVariantList comments() const;
	void addComment(const Comment &c);
	void removeComment(edb::address_t address);

private:
	void loadPluginData();

private:
	QVariantMap sessionData_;
};

#endif

```

`src/test/CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.1)

add_executable(ValueTest
	Test.cpp
)

target_link_libraries(ValueTest
	edb
)

set_property(TARGET ValueTest PROPERTY RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}")
set_property(TARGET ValueTest PROPERTY CXX_STANDARD 17)
set_property(TARGET ValueTest PROPERTY CXX_STANDARD_REQUIRED ON)

add_test(
	NAME ValueTest
	COMMAND $<TARGET_FILE:ValueTest>
)

```

`src/test/Test.cpp`:

```cpp

#include "Value.h"
#include <cstdlib>

#define TEST(expr)                                                  \
	do {                                                            \
		if (!(expr)) {                                              \
			fprintf(stderr, "FAILED: [@%d] %s\n", __LINE__, #expr); \
			abort();                                                \
		}                                                           \
	} while (0)

namespace {

void testSignExtension() {

	edb::value64 v64;

	// should sign extend
	v64 = 0xff;
	TEST(v64.signExtended(1) == 0xffffffffffffffff);

	v64 = 0xffff;
	TEST(v64.signExtended(2) == 0xffffffffffffffff);

	v64 = 0xffffff;
	TEST(v64.signExtended(3) == 0xffffffffffffffff);

	v64 = 0xffffffff;
	TEST(v64.signExtended(4) == 0xffffffffffffffff);

	v64 = 0xffffffffff;
	TEST(v64.signExtended(5) == 0xffffffffffffffff);

	v64 = 0xffffffffffff;
	TEST(v64.signExtended(6) == 0xffffffffffffffff);

	v64 = 0xffffffffffffff;
	TEST(v64.signExtended(7) == 0xffffffffffffffff);

	v64 = 0xffffffffffffffff;
	TEST(v64.signExtended(8) == 0xffffffffffffffff);

	//shouldn't!
	v64 = 0x7f;
	TEST(v64.signExtended(1) == 0x000000000000007f);

	v64 = 0x7fff;
	TEST(v64.signExtended(2) == 0x0000000000007fff);

	v64 = 0x7fffff;
	TEST(v64.signExtended(3) == 0x00000000007fffff);

	v64 = 0x7fffffff;
	TEST(v64.signExtended(4) == 0x000000007fffffff);

	v64 = 0x7fffffffff;
	TEST(v64.signExtended(5) == 0x0000007fffffffff);

	v64 = 0x7fffffffffff;
	TEST(v64.signExtended(6) == 0x00007fffffffffff);

	v64 = 0x7fffffffffffff;
	TEST(v64.signExtended(7) == 0x007fffffffffffff);

	v64 = 0x7fffffffffffffff;
	TEST(v64.signExtended(8) == 0x7fffffffffffffff);
}

void testAssignment() {
	edb::value64 v64;
	TEST(v64 == 0);

	v64 = 10;
	TEST(v64 == 10);

	v64 += 50;
	TEST(v64 == 60);

	++v64;
	TEST(v64 == 61);

	TEST(v64++ == 61);
	TEST(v64 == 62);

	--v64;
	TEST(v64 == 61);
}

void testFromString() {
	edb::value64 v64;
	v64 = edb::value64::fromHexString("0123456789abcdef");
	TEST(v64 == 0x0123456789abcdef);

	v64 = edb::value64::fromSignedString("-10");
	TEST(v64 == 0xfffffffffffffff6);

	v64 = edb::value64::fromCString("07777777777");
	TEST(v64 == 07777777777);
}

void testConstruction() {
	edb::value8 v8;
	edb::value16 v16;
	edb::value32 v32;
	edb::value64 v64;
	edb::value128 v128;
	edb::value256 v256;
	edb::value512 v512;

	(void)v8;
	(void)v16;
	(void)v32;
	(void)v64;
	(void)v128;
	(void)v256;
	(void)v512;
}

void testToString() {
	edb::value64 v64;
	v64 = edb::value64::fromHexString("0123456789abcdef");
	TEST(v64 == 0x0123456789abcdef);

	QString str = v64.toHexString();
	TEST(str == "0123456789abcdef");

	QString str2 = v64.toString();
	TEST(str2 == "81985529216486895");
}

}

int main() {
	testConstruction();
	testAssignment();
	testFromString();
	testSignExtension();
	testToString();
}

```

`src/widgets/NavigationHistory.cpp`:

```cpp
/*
Copyright (C) 2017 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "NavigationHistory.h"

NavigationHistory::NavigationHistory(int count)
	: maxCount_(count) {
}

void NavigationHistory::add(edb::address_t address) {
	if (list_.size() == maxCount_) {
		list_.removeFirst();
		--pos_;
	}

	if (!list_.isEmpty()) {
		if (lastop_ == LASTOP_PREV && address == list_.at(pos_))
			return;
		if (lastop_ == LASTOP_NEXT && address == list_.at(pos_ - 1))
			return;
		for (int i = list_.size() - 1; i >= pos_; i--) {
			if (address == list_.at(i))
				return;
		}
	}

	pos_ = list_.size();
	list_.append(address);
	lastop_ = LASTOP_NONE;
}

edb::address_t NavigationHistory::getNext() {
	if (list_.isEmpty()) {
		return edb::address_t(0);
	}

	if (pos_ != (list_.size() - 1)) {
		++pos_;
	}

	lastop_ = LASTOP_NEXT;
	return list_.at(pos_);
}

edb::address_t NavigationHistory::getPrev() {
	if (list_.isEmpty()) {
		return edb::address_t(0);
	}

	if (pos_ != 0) {
		--pos_;
	}

	lastop_ = LASTOP_PREV;
	return list_.at(pos_);
}

```

`src/widgets/NavigationHistory.h`:

```h
/*
Copyright (C) 2017 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef NAVIGATION_HISTORY_H_20191119_
#define NAVIGATION_HISTORY_H_20191119_

#include "edb.h"

#include <QList>

class NavigationHistory {

	enum LASTOP {
		LASTOP_NONE = 0,
		LASTOP_PREV,
		LASTOP_NEXT
	};

public:
	explicit NavigationHistory(int count = 100);
	void add(edb::address_t address);
	edb::address_t getNext();
	edb::address_t getPrev();

private:
	QList<edb::address_t> list_;
	int pos_ = 0;
	int maxCount_;
	LASTOP lastop_ = LASTOP_NONE;
};

#endif

```

`src/widgets/QDisassemblyView.cpp`:

```cpp
/*
Copyright (C) 2006 - 2016 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "QDisassemblyView.h"
#include "ArchProcessor.h"
#include "Configuration.h"
#include "Function.h"
#include "IAnalyzer.h"
#include "IDebugger.h"
#include "IProcess.h"
#include "IRegion.h"
#include "ISymbolManager.h"
#include "IThread.h"
#include "Instruction.h"
#include "MemoryRegions.h"
#include "SessionManager.h"
#include "State.h"
#include "SyntaxHighlighter.h"
#include "Theme.h"
#include "edb.h"
#include "util/Font.h"

#include <QAbstractItemDelegate>
#include <QApplication>
#include <QDebug>
#include <QElapsedTimer>
#include <QMouseEvent>
#include <QPainter>
#include <QPixmap>
#include <QScrollBar>
#include <QSettings>
#include <QTextLayout>
#include <QToolTip>
#include <QtGlobal>

#include <QDebug>

#include <algorithm>
#include <climits>
#include <cmath>

namespace {

struct WidgetState1 {
	int version;
	int line1;
	int line2;
	int line3;
	int line4;
};

constexpr int DefaultByteWidth = 8;

struct show_separator_tag {};

template <class T>
struct address_format {
	static QString format_address(T address, const show_separator_tag &) {
		if constexpr (sizeof(T) == sizeof(uint32_t)) {
			static char buffer[10];
			qsnprintf(buffer, sizeof(buffer), "%04x:%04x", (address >> 16) & 0xffff, address & 0xffff);
			return QString::fromLatin1(buffer, sizeof(buffer) - 1);
		} else if constexpr (sizeof(T) == sizeof(uint64_t)) {
			return edb::value32(address >> 32).toHexString() + ":" + edb::value32(address).toHexString();
		}
	}

	static QString format_address(T address) {
		if constexpr (sizeof(T) == sizeof(uint32_t)) {
			static char buffer[9];
			qsnprintf(buffer, sizeof(buffer), "%04x%04x", (address >> 16) & 0xffff, address & 0xffff);
			return QString::fromLatin1(buffer, sizeof(buffer) - 1);
		} else if constexpr (sizeof(T) == sizeof(uint64_t)) {
			return edb::value64(address).toHexString();
		}
	}
};

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
template <class T>
QString format_address(T address, bool show_separator) {
	if (show_separator)
		return address_format<T>::format_address(address, show_separator_tag());
	else
		return address_format<T>::format_address(address);
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
bool near_line(int x, int linex) {
	return std::abs(x - linex) < 3;
}

//------------------------------------------------------------------------------
// Name:
// Desc:
//------------------------------------------------------------------------------
int instruction_size(const uint8_t *buffer, std::size_t size) {
	edb::Instruction inst(buffer, buffer + size, 0);
	return inst.byteSize();
}

//------------------------------------------------------------------------------
// Name: format_instruction_bytes
// Desc:
//------------------------------------------------------------------------------
QString format_instruction_bytes(const edb::Instruction &inst) {
	auto bytes = QByteArray::fromRawData(reinterpret_cast<const char *>(inst.bytes()), inst.byteSize());
	return edb::v1::format_bytes(bytes);
}

//------------------------------------------------------------------------------
// Name: format_instruction_bytes
// Desc:
//------------------------------------------------------------------------------
QString format_instruction_bytes(const edb::Instruction &inst, int maxStringPx, const QFontMetrics &metrics) {
	const QString byte_buffer = format_instruction_bytes(inst);
	return metrics.elidedText(byte_buffer, Qt::ElideRight, maxStringPx);
}

bool target_is_local(edb::address_t targetAddress, edb::address_t insnAddress) {

	const auto insnRegion   = edb::v1::memory_regions().findRegion(insnAddress);
	const auto targetRegion = edb::v1::memory_regions().findRegion(targetAddress);
	return !insnRegion->name().isEmpty() && targetRegion && insnRegion->name() == targetRegion->name();
}

}

//------------------------------------------------------------------------------
// Name: QDisassemblyView
// Desc: constructor
//------------------------------------------------------------------------------
QDisassemblyView::QDisassemblyView(QWidget *parent)
	: QAbstractScrollArea(parent),
	  highlighter_(new SyntaxHighlighter(this)),
	  breakpointRenderer_(QLatin1String(":/debugger/images/breakpoint.svg")),
	  currentRenderer_(QLatin1String(":/debugger/images/arrow-right.svg")),
	  currentBpRenderer_(QLatin1String(":/debugger/images/arrow-right-red.svg")),
	  syntaxCache_(256) {

	// TODO(eteran): it makes more sense for these to have setters/getters and it just be told
	// by the parent what these colors should be
	Theme theme = Theme::load();

	takenJumpColor_         = theme.text[Theme::TakenJump].foreground().color();
	fillingBytesColor_      = theme.text[Theme::Filling].foreground().color();
	addressForegroundColor_ = theme.text[Theme::Address].foreground().color();
	badgeBackgroundColor_   = theme.misc[Theme::Badge].background().color();
	badgeForegroundColor_   = theme.misc[Theme::Badge].foreground().color();

	setShowAddressSeparator(true);

	setFont(QFont("Monospace", 8));
	setMouseTracking(true);
	setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);

	connect(verticalScrollBar(), &QScrollBar::actionTriggered, this, &QDisassemblyView::scrollbarActionTriggered);
}

//------------------------------------------------------------------------------
// Name:
//------------------------------------------------------------------------------
void QDisassemblyView::resetColumns() {
	line1_ = 0;
	line2_ = 0;
	line3_ = 0;
	line4_ = 0;
	update();
}

//------------------------------------------------------------------------------
// Name: keyPressEvent
//------------------------------------------------------------------------------
void QDisassemblyView::keyPressEvent(QKeyEvent *event) {
	if (event->matches(QKeySequence::MoveToStartOfDocument)) {
		verticalScrollBar()->setValue(0);
	} else if (event->matches(QKeySequence::MoveToEndOfDocument)) {
		verticalScrollBar()->setValue(verticalScrollBar()->maximum());
	} else if (event->matches(QKeySequence::MoveToNextLine)) {
		const edb::address_t selected = selectedAddress();
		const int idx                 = showAddresses_.indexOf(selected);
		if (selected != 0 && idx > 0 && idx < showAddresses_.size() - 1 - partialLastLine_) {
			setSelectedAddress(showAddresses_[idx + 1]);
		} else {
			const int current_offset = selected - addressOffset_;
			if (current_offset + 1 >= static_cast<int>(region_->size())) {
				return;
			}

			const edb::address_t next_address = addressOffset_ + followingInstructions(current_offset, 1);
			if (!addressShown(next_address)) {
				scrollTo(showAddresses_.size() > 1 ? showAddresses_[showAddresses_.size() / 3] : next_address);
			}

			setSelectedAddress(next_address);
		}
	} else if (event->matches(QKeySequence::MoveToPreviousLine)) {
		const edb::address_t selected = selectedAddress();
		const int idx                 = showAddresses_.indexOf(selected);
		if (selected != 0 && idx > 0) {
			// we already know the previous instruction
			setSelectedAddress(showAddresses_[idx - 1]);
		} else {
			const int current_offset = selected - addressOffset_;
			if (current_offset <= 0) {
				return;
			}

			const edb::address_t new_address = addressOffset_ + previousInstructions(current_offset, 1);
			if (!addressShown(new_address)) {
				scrollTo(new_address);
			}
			setSelectedAddress(new_address);
		}
	} else if (event->matches(QKeySequence::MoveToNextPage) || event->matches(QKeySequence::MoveToPreviousPage)) {
		const int selectedLine = getSelectedLineNumber();
		if (event->matches(QKeySequence::MoveToNextPage)) {
			scrollbarActionTriggered(QAbstractSlider::SliderPageStepAdd);
		} else {
			scrollbarActionTriggered(QAbstractSlider::SliderPageStepSub);
		}
		updateDisassembly(instructions_.size());

		if (showAddresses_.size() > selectedLine) {
			setSelectedAddress(showAddresses_[selectedLine]);
		}
	} else if (event->key() == Qt::Key_Minus) {
		edb::address_t prev_addr = history_.getPrev();
		if (prev_addr != 0) {
			edb::v1::jump_to_address(prev_addr);
		}
	} else if (event->key() == Qt::Key_Plus) {
		edb::address_t next_addr = history_.getNext();
		if (next_addr != 0) {
			edb::v1::jump_to_address(next_addr);
		}
	} else if (event->key() == Qt::Key_Down && (event->modifiers() & Qt::ControlModifier)) {
		const int address = verticalScrollBar()->value();
		verticalScrollBar()->setValue(address + 1);
	} else if (event->key() == Qt::Key_Up && (event->modifiers() & Qt::ControlModifier)) {
		const int address = verticalScrollBar()->value();
		verticalScrollBar()->setValue(address - 1);
	}
}

//------------------------------------------------------------------------------
// Name: previous_instructions
// Desc: attempts to find the address of the instruction 1 instructions
//       before <current_address>
// Note: <current_address> is a 0 based value relative to the begining of the
//       current region, not an absolute address within the program
//------------------------------------------------------------------------------
int QDisassemblyView::previousInstruction(IAnalyzer *analyzer, int current_address) {

	// If we have an analyzer, and the current address is within a function
	// then first we find the begining of that function.
	// Then, we attempt to disassemble from there until we run into
	// the address we were on (stopping one instruction early).
	// this allows us to identify with good accuracy where the
	// previous instruction was making upward scrolling more functional.
	//
	// If all else fails, fall back on the old heuristic which works "ok"
	if (analyzer) {
		edb::address_t address = addressOffset_ + current_address;

		// find the containing function
		if (Result<edb::address_t, QString> function_address = analyzer->findContainingFunction(address)) {

			if (address != *function_address) {
				edb::address_t function_start = *function_address;

				// disassemble from function start until the NEXT address is where we started
				while (true) {
					uint8_t buf[edb::Instruction::MaxSize];

					size_t buf_size = sizeof(buf);
					if (region_) {
						buf_size = std::min<size_t>((function_start - region_->base()), sizeof(buf));
					}

					if (edb::v1::get_instruction_bytes(function_start, buf, &buf_size)) {
						const edb::Instruction inst(buf, buf + buf_size, function_start);
						if (!inst) {
							break;
						}

						// if the NEXT address would be our target, then
						// we are at the previous instruction!
						if (function_start + inst.byteSize() >= current_address + addressOffset_) {
							break;
						}

						function_start += inst.byteSize();
					} else {
						break;
					}
				}

				current_address = (function_start - addressOffset_);
				return current_address;
			}
		}
	}

	// fall back on the old heuristic
	// iteration goal: to get exactly one new line above current instruction line
	edb::address_t address = addressOffset_ + current_address;

	for (int i = static_cast<int>(edb::Instruction::MaxSize); i > 0; --i) {
		edb::address_t prev_address = address - i;
		if (address >= addressOffset_) {

			uint8_t buf[edb::Instruction::MaxSize];
			int size               = sizeof(buf);
			Result<int, QString> n = getInstructionSize(prev_address, buf, &size);
			if (n && *n == i) {
				return current_address - i;
			}
		}
	}

	// ensure that we make progress even if no instruction could be decoded
	return current_address - 1;
}

//------------------------------------------------------------------------------
// Name: previous_instructions
// Desc: attempts to find the address of the instruction <count> instructions
//       before <current_address>
// Note: <current_address> is a 0 based value relative to the begining of the
//       current region, not an absolute address within the program
//------------------------------------------------------------------------------
int QDisassemblyView::previousInstructions(int current_address, int count) {

	IAnalyzer *const analyzer = edb::v1::analyzer();

	for (int i = 0; i < count; ++i) {
		current_address = previousInstruction(analyzer, current_address);
	}

	return current_address;
}

int QDisassemblyView::followingInstruction(int current_address) {
	uint8_t buf[edb::Instruction::MaxSize + 1];

	// do the longest read we can while still not passing the region end
	size_t buf_size = sizeof(buf);
	if (region_) {
		buf_size = std::min<size_t>((region_->end() - current_address), sizeof(buf));
	}

	// read in the bytes...
	if (!edb::v1::get_instruction_bytes(addressOffset_ + current_address, buf, &buf_size)) {
		return current_address + 1;
	} else {
		const edb::Instruction inst(buf, buf + buf_size, current_address);
		return current_address + inst.byteSize();
	}
}

//------------------------------------------------------------------------------
// Name: following_instructions
// Note: <current_address> is a 0 based value relative to the begining of the
//       current region, not an absolute address within the program
//------------------------------------------------------------------------------
int QDisassemblyView::followingInstructions(int current_address, int count) {

	for (int i = 0; i < count; ++i) {
		current_address = followingInstruction(current_address);
	}

	return current_address;
}

//------------------------------------------------------------------------------
// Name: wheelEvent
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::wheelEvent(QWheelEvent *e) {

	const int dy           = e->angleDelta().y();
	const int scroll_count = dy / 120;

	// Ctrl+Wheel scrolls by single bytes
	if (e->modifiers() & Qt::ControlModifier) {
		int address = verticalScrollBar()->value();
		verticalScrollBar()->setValue(address - scroll_count);
		e->accept();
		return;
	}

	const int abs_scroll_count = std::abs(scroll_count);

	if (dy > 0) {
		// scroll up
		int address = verticalScrollBar()->value();
		address     = previousInstructions(address, abs_scroll_count);
		verticalScrollBar()->setValue(address);
	} else {
		// scroll down
		int address = verticalScrollBar()->value();
		address     = followingInstructions(address, abs_scroll_count);
		verticalScrollBar()->setValue(address);
	}
}

//------------------------------------------------------------------------------
// Name: scrollbar_action_triggered
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::scrollbarActionTriggered(int action) {

	if (QApplication::keyboardModifiers() & Qt::ControlModifier) {
		return;
	}

	switch (action) {
	case QAbstractSlider::SliderSingleStepSub: {
		int address = verticalScrollBar()->value();
		address     = previousInstructions(address, 1);
		verticalScrollBar()->setSliderPosition(address);
	} break;
	case QAbstractSlider::SliderPageStepSub: {
		int address = verticalScrollBar()->value();
		address     = previousInstructions(address, verticalScrollBar()->pageStep());
		verticalScrollBar()->setSliderPosition(address);
	} break;
	case QAbstractSlider::SliderSingleStepAdd: {
		int address = verticalScrollBar()->value();
		address     = followingInstructions(address, 1);
		verticalScrollBar()->setSliderPosition(address);
	} break;
	case QAbstractSlider::SliderPageStepAdd: {
		int address = verticalScrollBar()->value();
		address     = followingInstructions(address, verticalScrollBar()->pageStep());
		verticalScrollBar()->setSliderPosition(address);
	} break;

	case QAbstractSlider::SliderToMinimum:
	case QAbstractSlider::SliderToMaximum:
	case QAbstractSlider::SliderMove:
	case QAbstractSlider::SliderNoAction:
	default:
		break;
	}
}

//------------------------------------------------------------------------------
// Name: setShowAddressSeparator
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::setShowAddressSeparator(bool value) {
	showAddressSeparator_ = value;
}

//------------------------------------------------------------------------------
// Name: formatAddress
// Desc:
//------------------------------------------------------------------------------
QString QDisassemblyView::formatAddress(edb::address_t address) const {
	if (edb::v1::debuggeeIs32Bit())
		return format_address<quint32>(address.toUint(), showAddressSeparator_);
	else
		return format_address(address, showAddressSeparator_);
}

//------------------------------------------------------------------------------
// Name: update
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::update() {
	viewport()->update();
	Q_EMIT signalUpdated();
}

//------------------------------------------------------------------------------
// Name: addressShown
// Desc: returns true if a given address is in the visible range
//------------------------------------------------------------------------------
bool QDisassemblyView::addressShown(edb::address_t address) const {
	const auto idx = showAddresses_.indexOf(address);
	// if the last line is only partially rendered, consider it outside the
	// viewport.
	return (idx > 0 && idx < showAddresses_.size() - 1 - partialLastLine_);
}

//------------------------------------------------------------------------------
// Name: setCurrentAddress
// Desc: sets the 'current address' (where EIP is usually)
//------------------------------------------------------------------------------
void QDisassemblyView::setCurrentAddress(edb::address_t address) {
	currentAddress_ = address;
}

//------------------------------------------------------------------------------
// Name: setRegion
// Desc: sets the memory region we are viewing
//------------------------------------------------------------------------------
void QDisassemblyView::setRegion(const std::shared_ptr<IRegion> &r) {

	// You may wonder when we use r's compare instead of region_
	// well, the compare function will test if the parameter is NULL
	// so if we it this way, region_ can be NULL and this code is still
	// correct :-)
	// We also check for !r here because we want to be able to reset the
	// the region to nothing. It's fairly harmless to reset an already
	// reset region, so we don't bother check that condition
	if ((r && !r->equals(region_)) || (!r)) {
		region_ = r;
		setAddressOffset(region_ ? region_->start() : edb::address_t(0));
		updateScrollbars();
		Q_EMIT regionChanged();

		if (line2_ != 0 && line2_ < autoLine2()) {
			line2_ = 0;
		}
	}
	update();
}

//------------------------------------------------------------------------------
// Name: clear
// Desc: clears the display
//------------------------------------------------------------------------------
void QDisassemblyView::clear() {
	setRegion(nullptr);
}

//------------------------------------------------------------------------------
// Name: setAddressOffset
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::setAddressOffset(edb::address_t address) {
	addressOffset_ = address;
}

//------------------------------------------------------------------------------
// Name: scrollTo
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::scrollTo(edb::address_t address) {
	verticalScrollBar()->setValue(address - addressOffset_);
}

//------------------------------------------------------------------------------
// Name: instructionString
// Desc:
//------------------------------------------------------------------------------
QString QDisassemblyView::instructionString(const edb::Instruction &inst) const {
	QString opcode = QString::fromStdString(edb::v1::formatter().toString(inst));

	if (is_call(inst) || is_jump(inst)) {
		if (inst.operandCount() == 1) {
			const auto oper = inst[0];
			if (is_immediate(oper)) {

				const bool showSymbolicAddresses = edb::v1::config().show_symbolic_addresses;

				static const QRegExp addrPattern(QLatin1String("#?0x[0-9a-fA-F]+"));
				const edb::address_t target = oper->imm;

				const bool showLocalModuleNames = edb::v1::config().show_local_module_name_in_jump_targets;
				const bool prefixed             = showLocalModuleNames || !target_is_local(target, inst.rva());
				QString sym                     = edb::v1::symbol_manager().findAddressName(target, prefixed);

				if (sym.isEmpty() && target == inst.byteSize() + inst.rva()) {
					sym = showSymbolicAddresses ? tr("<next instruction>") : tr("next instruction");
				} else if (sym.isEmpty() && target == inst.rva()) {
					sym = showSymbolicAddresses ? tr("$") : tr("current instruction");
				}

				if (!sym.isEmpty()) {
					if (showSymbolicAddresses)
						opcode.replace(addrPattern, sym);
					else
						opcode.append(QString(" <%2>").arg(sym));
				}
			}
		}
	}

	return opcode;
}

//------------------------------------------------------------------------------
// Name: drawInstruction
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::drawInstruction(QPainter &painter, const edb::Instruction &inst, const DrawingContext *ctx, int y, bool selected) {

	painter.save();

	const bool is_filling      = edb::v1::arch_processor().isFilling(inst);
	const int x                = fontWidth_ + fontWidth_ + ctx->l3 + (fontWidth_ / 2);
	const int inst_pixel_width = ctx->l4 - x;

	const bool syntax_highlighting_enabled = edb::v1::config().syntax_highlighting_enabled && !selected;

	QString opcode = instructionString(inst);

	if (is_filling) {
		if (syntax_highlighting_enabled) {
			painter.setPen(fillingBytesColor_);
		}

		opcode = painter.fontMetrics().elidedText(opcode, Qt::ElideRight, inst_pixel_width);

		painter.drawText(
			x,
			y,
			opcode.length() * fontWidth_,
			ctx->lineHeight,
			Qt::AlignVCenter,
			opcode);
	} else {

		// NOTE(eteran): do this early, so that elided text still gets the part shown
		// properly highlighted
		QVector<QTextLayout::FormatRange> highlightData;
		if (syntax_highlighting_enabled) {
			highlightData = highlighter_->highlightBlock(opcode);
		}

		opcode = painter.fontMetrics().elidedText(opcode, Qt::ElideRight, inst_pixel_width);

		if (syntax_highlighting_enabled) {

			QPixmap *map = syntaxCache_[opcode];
			if (!map) {

				// create the text layout
				QTextLayout textLayout(opcode, painter.font());

				textLayout.setTextOption(QTextOption(Qt::AlignVCenter));

				textLayout.beginLayout();

				// generate the lines one at a time
				// setting the positions as we go
				Q_FOREVER {
					QTextLine line = textLayout.createLine();

					if (!line.isValid()) {
						break;
					}

					line.setPosition(QPoint(0, 0));
				}

				textLayout.endLayout();

				map = new QPixmap(QSize(opcode.length() * fontWidth_, ctx->lineHeight) * devicePixelRatio());
				map->setDevicePixelRatio(devicePixelRatio());
				map->fill(Qt::transparent);
				QPainter cache_painter(map);
				cache_painter.setPen(painter.pen());
				cache_painter.setFont(painter.font());

				// now the render the text at the location given
				textLayout.draw(&cache_painter, QPoint(0, 0), highlightData);
				syntaxCache_.insert(opcode, map);
			}
			painter.drawPixmap(x, y, *map);
		} else {
			QRectF rectangle(x, y, opcode.length() * fontWidth_, ctx->lineHeight);
			painter.drawText(rectangle, Qt::AlignVCenter, opcode);
		}
	}

	painter.restore();
}

//------------------------------------------------------------------------------
// Name: paint_line_bg
// Desc: A helper function for painting a rectangle representing a background
// color of one or more lines in the disassembly view.
//------------------------------------------------------------------------------
void QDisassemblyView::paintLineBg(QPainter &painter, QBrush brush, int line, int num_lines) {
	const auto lh = lineHeight();
	painter.fillRect(0, lh * line, width(), lh * num_lines, brush);
}

//------------------------------------------------------------------------------
// Name: get_line_of_address
// Desc: A helper function which sets line to the line on which addr appears,
// or returns false if that line does not appear to exist.
//------------------------------------------------------------------------------
std::optional<unsigned int> QDisassemblyView::getLineOfAddress(edb::address_t addr) const {

	if (!showAddresses_.isEmpty()) {
		if (addr >= showAddresses_[0] && addr <= showAddresses_[showAddresses_.size() - 1]) {
			int pos = std::find(showAddresses_.begin(), showAddresses_.end(), addr) - showAddresses_.begin();
			if (pos < showAddresses_.size()) { // address was found
				return pos;
			}
		}
	}

	return {};
}

//------------------------------------------------------------------------------
// Name: updateDisassembly
// Desc: Updates instructions_, show_addresses_, partial_last_line_
//		 Returns update for number of lines_to_render
//------------------------------------------------------------------------------
int QDisassemblyView::updateDisassembly(int lines_to_render) {
	instructions_.clear();
	showAddresses_.clear();

	int bufsize                        = instructionBuffer_.size();
	uint8_t *inst_buf                  = &instructionBuffer_[0];
	const edb::address_t start_address = addressOffset_ + verticalScrollBar()->value();

	if (!edb::v1::get_instruction_bytes(start_address, inst_buf, &bufsize)) {
		qDebug() << "Failed to read" << bufsize << "bytes from" << QString::number(start_address, 16);
		lines_to_render = 0;
	}

	instructions_.reserve(lines_to_render);
	showAddresses_.reserve(lines_to_render);

	const int max_offset = std::min(int(region_->end() - start_address), bufsize);

	int line   = 0;
	int offset = 0;

	while (line < lines_to_render && offset < max_offset) {
		edb::address_t address = start_address + offset;
		instructions_.emplace_back(
			&inst_buf[offset],  // instruction bytes
			&inst_buf[bufsize], // end of buffer
			address             // address of instruction
		);
		showAddresses_.push_back(address);

		if (instructions_[line].valid()) {
			offset += instructions_[line].byteSize();
		} else {
			++offset;
		}
		line++;
	}
	Q_ASSERT(line <= lines_to_render);
	if (lines_to_render != line) {
		lines_to_render  = line;
		partialLastLine_ = false;
	}

	lines_to_render = line;
	return lines_to_render;
}

//------------------------------------------------------------------------------
// Name: getSelectedLineNumber
// Desc:
//------------------------------------------------------------------------------
int QDisassemblyView::getSelectedLineNumber() const {

	for (size_t line = 0; line < instructions_.size(); ++line) {
		if (instructions_[line].rva() == selectedAddress()) {
			return static_cast<int>(line);
		}
	}

	return 65535; // can't accidentally hit this;
}

//------------------------------------------------------------------------------
// Name: drawHeaderAndBackground
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::drawHeaderAndBackground(QPainter &painter, const DrawingContext *ctx, const std::unique_ptr<IBinary> &binary_info) {

	painter.save();

	// HEADER & ALTERNATION BACKGROUND PAINTING STEP
	// paint the header gray
	int line = 0;
	if (binary_info) {
		auto header_size                  = binary_info->headerSize();
		edb::address_t header_end_address = region_->start() + header_size;
		// Find the number of lines we need to paint with the header
		while (line < ctx->linesToRender && header_end_address > showAddresses_[line]) {
			line++;
		}
		paintLineBg(painter, QBrush(Qt::lightGray), 0, line);
	}

	line += 1;
	if (line != ctx->linesToRender) {
		const QBrush alternated_base_color = palette().alternateBase();
		if (alternated_base_color != palette().base()) {
			while (line < ctx->linesToRender) {
				paintLineBg(painter, alternated_base_color, line);
				line += 2;
			}
		}
	}

	if (ctx->selectedLines < ctx->linesToRender) {
		paintLineBg(painter, palette().color(ctx->group, QPalette::Highlight), ctx->selectedLines);
	}

	painter.restore();
}

//------------------------------------------------------------------------------
// Name: drawRegiserBadges
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::drawRegiserBadges(QPainter &painter, DrawingContext *ctx) {

	painter.save();
	if (IProcess *process = edb::v1::debugger_core->process()) {

		if (process->isPaused()) {

			State state;
			process->currentThread()->getState(&state);

			std::vector<QString> badge_labels(ctx->linesToRender);
			{
				unsigned int reg_num = 0;
				Register reg;
				reg = state.gpRegister(reg_num);

				while (reg.valid()) {
					// Does addr appear here?
					edb::address_t addr = reg.valueAsAddress();

					if (std::optional<unsigned int> line = getLineOfAddress(addr)) {
						if (!badge_labels[*line].isEmpty()) {
							badge_labels[*line].append(", ");
						}
						badge_labels[*line].append(reg.name());
					}

					// what about [addr]?
					if (process->readBytes(addr, &addr, edb::v1::pointer_size())) {
						if (std::optional<unsigned int> line = getLineOfAddress(addr)) {
							if (!badge_labels[*line].isEmpty()) {
								badge_labels[*line].append(", ");
							}
							badge_labels[*line].append("[" + reg.name() + "]");
						}
					}

					reg = state.gpRegister(++reg_num);
				}
			}

			painter.setPen(badgeForegroundColor_);

			for (int line = 0; line < ctx->linesToRender; line++) {
				if (!badge_labels[line].isEmpty()) {

					int width          = badge_labels[line].length() * fontWidth_ + fontWidth_ / 2;
					int height         = ctx->lineHeight;
					int triangle_point = line1() - 3;
					int x              = triangle_point - (height / 2) - width;
					int y              = line * ctx->lineHeight;

					// if badge is not in viewpoint, then don't draw
					if (x < 0) {
						continue;
					}

					ctx->lineBadgeWidth[line] = line1() - x;

					QRect bounds(x, y, width, height);

					// draw a rectangle + box around text
					QPainterPath path;
					path.addRect(bounds);
					path.moveTo(bounds.x() + bounds.width(), bounds.y());                   // top right
					path.lineTo(triangle_point, bounds.y() + bounds.height() / 2);          // triangle point
					path.lineTo(bounds.x() + bounds.width(), bounds.y() + bounds.height()); // bottom right
					painter.fillPath(path, badgeBackgroundColor_);

					painter.drawText(
						bounds.x() + fontWidth_ / 4,
						line * ctx->lineHeight,
						fontWidth_ * badge_labels[line].size(),
						ctx->lineHeight,
						Qt::AlignVCenter,
						(edb::v1::config().uppercase_disassembly ? badge_labels[line].toUpper() : badge_labels[line]));
				}
			}
		}
	}
	painter.restore();
}

//------------------------------------------------------------------------------
// Name: drawSymbolNames
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::drawSymbolNames(QPainter &painter, const DrawingContext *ctx) {
	painter.save();

	painter.setPen(palette().color(ctx->group, QPalette::Text));
	const int x     = ctx->l1 + autoLine2();
	const int width = ctx->l2 - x;
	if (width > 0) {
		for (int line = 0; line < ctx->linesToRender; line++) {

			if (ctx->selectedLines != line) {
				auto address      = showAddresses_[line];
				const QString sym = edb::v1::symbol_manager().findAddressName(address);
				if (!sym.isEmpty()) {
					const QString symbol_buffer = painter.fontMetrics().elidedText(sym, Qt::ElideRight, width);

					painter.drawText(
						x,
						line * ctx->lineHeight,
						width,
						ctx->lineHeight,
						Qt::AlignVCenter,
						symbol_buffer);
				}
			}
		}

		if (ctx->selectedLines < ctx->linesToRender) {
			int line = ctx->selectedLines;
			painter.setPen(palette().color(ctx->group, QPalette::HighlightedText));
			auto address      = showAddresses_[line];
			const QString sym = edb::v1::symbol_manager().findAddressName(address);
			if (!sym.isEmpty()) {
				const QString symbol_buffer = painter.fontMetrics().elidedText(sym, Qt::ElideRight, width);

				painter.drawText(
					x,
					line * ctx->lineHeight,
					width,
					ctx->lineHeight,
					Qt::AlignVCenter,
					symbol_buffer);
			}
		}
	}

	painter.restore();
}

//------------------------------------------------------------------------------
// Name: drawSidebarElements
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::drawSidebarElements(QPainter &painter, const DrawingContext *ctx) {

	painter.save();
	painter.setPen(addressForegroundColor_);

	const auto icon_x     = ctx->l1 + 1;
	const auto addr_x     = icon_x + iconWidth_;
	const auto addr_width = ctx->l2 - addr_x;

	auto paint_address_lambda = [&](int line) {
		auto address = showAddresses_[line];

		const bool has_breakpoint = (edb::v1::find_breakpoint(address) != nullptr);
		const bool is_eip         = address == currentAddress_;

		// TODO(eteran): if highlighted render the BP/Arrow in a more readable color!
		QSvgRenderer *icon = nullptr;
		if (is_eip) {
			icon = has_breakpoint ? &currentBpRenderer_ : &currentRenderer_;
		} else if (has_breakpoint) {
			icon = &breakpointRenderer_;
		}

		if (icon) {
			icon->render(&painter, QRectF(icon_x, line * ctx->lineHeight + 1, iconWidth_, iconHeight_));
		}

		const QString address_buffer = formatAddress(address);
		// draw the address
		painter.drawText(
			addr_x,
			line * ctx->lineHeight,
			addr_width,
			ctx->lineHeight,
			Qt::AlignVCenter,
			address_buffer);
	};

	// paint all but the highlighted address
	for (int line = 0; line < ctx->linesToRender; line++) {
		if (ctx->selectedLines != line) {
			paint_address_lambda(line);
		}
	}

	// paint the highlighted address
	if (ctx->selectedLines < ctx->linesToRender) {
		painter.setPen(palette().color(ctx->group, QPalette::HighlightedText));
		paint_address_lambda(ctx->selectedLines);
	}

	painter.restore();
}

//------------------------------------------------------------------------------
// Name: drawInstructionBytes
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::drawInstructionBytes(QPainter &painter, const DrawingContext *ctx) {

	painter.save();

	const int bytes_width = ctx->l3 - ctx->l2 - fontWidth_ / 2;
	const auto metrics    = painter.fontMetrics();

	auto painter_lambda = [&](const edb::Instruction &inst, int line) {
		const QString byte_buffer = format_instruction_bytes(
			inst,
			bytes_width,
			metrics);

		painter.drawText(
			ctx->l2 + (fontWidth_ / 2),
			line * ctx->lineHeight,
			bytes_width,
			ctx->lineHeight,
			Qt::AlignVCenter,
			byte_buffer);
	};

	painter.setPen(palette().color(ctx->group, QPalette::Text));

	for (int line = 0; line < ctx->linesToRender; line++) {

		auto &&inst = instructions_[line];
		if (ctx->selectedLines != line) {
			painter_lambda(inst, line);
		}
	}

	if (ctx->selectedLines < ctx->linesToRender) {
		painter.setPen(palette().color(ctx->group, QPalette::HighlightedText));
		painter_lambda(instructions_[ctx->selectedLines], ctx->selectedLines);
	}

	painter.restore();
}

//------------------------------------------------------------------------------
// Name: drawFunctionMarkers
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::drawFunctionMarkers(QPainter &painter, const DrawingContext *ctx) {

	painter.save();

	IAnalyzer *const analyzer = edb::v1::analyzer();
	const int x               = ctx->l3 + fontWidth_;
	if (analyzer && ctx->l4 - x > fontWidth_ / 2) {
		painter.setPen(QPen(palette().color(ctx->group, QPalette::WindowText), 2));
		int next_line = 0;

		if (ctx->linesToRender != 0 && !showAddresses_.isEmpty()) {
			analyzer->forFuncsInRange(showAddresses_[0], showAddresses_[ctx->linesToRender - 1], [&](const Function *func) {
				auto entry_addr = func->entryAddress();
				auto end_addr   = func->endAddress();
				int start_line;

				// Find the start and draw the corner
				for (start_line = next_line; start_line < ctx->linesToRender; start_line++) {
					if (showAddresses_[start_line] == entry_addr) {
						auto y = start_line * ctx->lineHeight;
						// half of a horizontal
						painter.drawLine(
							x,
							y + ctx->lineHeight / 2,
							x + fontWidth_ / 2,
							y + ctx->lineHeight / 2);

						// half of a vertical
						painter.drawLine(
							x,
							y + ctx->lineHeight / 2,
							x,
							y + ctx->lineHeight);

						start_line++;
						break;
					}
					if (showAddresses_[start_line] > entry_addr) {
						break;
					}
				}

				int end_line;

				// find the end and draw the other corner
				for (end_line = start_line; end_line < ctx->linesToRender; end_line++) {
					auto adjusted_end_addr = showAddresses_[end_line] + instructions_[end_line].byteSize() - 1;
					if (adjusted_end_addr == end_addr) {
						auto y = end_line * ctx->lineHeight;

						// half of a vertical
						painter.drawLine(
							x,
							y,
							x,
							y + ctx->lineHeight / 2);

						// half of a horizontal
						painter.drawLine(
							x,
							y + ctx->lineHeight / 2,
							ctx->l3 + (fontWidth_ / 2) + fontWidth_,
							y + ctx->lineHeight / 2);

						next_line = end_line;
						break;
					}

					if (adjusted_end_addr > end_addr) {
						next_line = end_line;
						break;
					}
				}

				// draw the straight line between them
				if (start_line != end_line) {
					painter.drawLine(x, start_line * ctx->lineHeight, x, end_line * ctx->lineHeight);
				}
				return true;
			});
		}
	}

	painter.restore();
}

//------------------------------------------------------------------------------
// Name: drawComments
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::drawComments(QPainter &painter, const DrawingContext *ctx) {

	painter.save();

	auto x_pos         = ctx->l4 + fontWidth_ + (fontWidth_ / 2);
	auto comment_width = width() - x_pos;

	for (int line = 0; line < ctx->linesToRender; line++) {
		auto address = showAddresses_[line];

		if (ctx->selectedLines == line) {
			painter.setPen(palette().color(ctx->group, QPalette::HighlightedText));
		} else {
			painter.setPen(palette().color(ctx->group, QPalette::Text));
		}

		QString annotation = comments_.value(address, QString(""));
		auto &&inst        = instructions_[line];
		if (annotation.isEmpty() && inst && !is_jump(inst) && !is_call(inst)) {
			// draw ascii representations of immediate constants
			size_t op_count = inst.operandCount();
			for (size_t op_idx = 0; op_idx < op_count; op_idx++) {
				auto oper                    = inst[op_idx];
				edb::address_t ascii_address = 0;
				if (is_immediate(oper)) {
					ascii_address = oper->imm;
				} else if (
					is_expression(oper) &&
					oper->mem.index == X86_REG_INVALID &&
					oper->mem.disp != 0) {
					if (oper->mem.base == X86_REG_RIP) {
						ascii_address += address + inst.byteSize() + oper->mem.disp;
					} else if (oper->mem.base == X86_REG_INVALID && oper->mem.disp > 0) {
						ascii_address = oper->mem.disp;
					}
				}

				QString string_param;
				if (edb::v1::get_human_string_at_address(ascii_address, string_param)) {
					annotation.append(string_param);
				}
			}
		}

		painter.drawText(
			x_pos,
			line * ctx->lineHeight,
			comment_width,
			ctx->lineHeight,
			Qt::AlignLeft,
			annotation);
	}

	painter.restore();
}

//------------------------------------------------------------------------------
// Name: drawJumpArrows
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::drawJumpArrows(QPainter &painter, const DrawingContext *ctx) {

	std::vector<JumpArrow> jump_arrow_vec;

	for (int line = 0; line < ctx->linesToRender; ++line) {

		auto &&inst = instructions_[line];
		if (is_jump(inst) && is_immediate(inst[0])) {

			const edb::address_t target = inst[0]->imm;
			if (target != inst.rva()) {           // TODO: draw small arrow if jmp points to itself
				if (region()->contains(target)) { // make sure jmp target is in current memory region

					JumpArrow jump_arrow;
					jump_arrow.sourceLine                = line;
					jump_arrow.target                    = target;
					jump_arrow.destInViewport            = false;
					jump_arrow.destInMiddleOfInstruction = false;
					jump_arrow.destLine                  = INT_MAX;

					// check if dst address is in viewport
					for (int i = 0; i < ctx->linesToRender; ++i) {

						if (instructions_[i].rva() == target) {
							jump_arrow.destLine       = i;
							jump_arrow.destInViewport = true;
							break;
						}

						if (i < ctx->linesToRender - 1) {
							// if target is in middle of instruction
							if (target > instructions_[i].rva() && target < instructions_[i + 1].rva()) {
								jump_arrow.destLine                  = i + 1;
								jump_arrow.destInMiddleOfInstruction = true;
								jump_arrow.destInViewport            = true;
								break;
							}
						}
					}

					// if jmp target not in viewpoint, its value should be near INT_MAX
					jump_arrow.distance         = std::abs(jump_arrow.destLine - jump_arrow.sourceLine);
					jump_arrow.horizontalLength = -1; // will be recalculate back below

					jump_arrow_vec.push_back(jump_arrow);
				}
			}
		}
	}

	// sort all jmp data in ascending order
	std::sort(jump_arrow_vec.begin(), jump_arrow_vec.end(),
			  [](const JumpArrow &a, const JumpArrow &b) -> bool {
				  return a.distance < b.distance;
			  });

	auto isLineOverlap = [&](int line1_head, int line1_tail, int line2_head, int line2_tail, bool edge_overlap) -> bool {
		int jump1_arrow_min = std::min(line1_head, line1_tail);
		int jump1_arrow_max = std::max(line1_head, line1_tail);
		int jump2_arrow_min = std::min(line2_head, line2_tail);
		int jump2_arrow_max = std::max(line2_head, line2_tail);

		bool prevArrowAboveCurrArrow;
		bool prevArrowBelowCurrArrow;

		if (edge_overlap) {
			prevArrowAboveCurrArrow = jump2_arrow_max > jump1_arrow_max && jump2_arrow_min >= jump1_arrow_max;
			prevArrowBelowCurrArrow = jump2_arrow_min < jump1_arrow_min && jump2_arrow_max <= jump1_arrow_min;
		} else {
			prevArrowAboveCurrArrow = jump2_arrow_max > jump1_arrow_max && jump2_arrow_min > jump1_arrow_max;
			prevArrowBelowCurrArrow = jump2_arrow_min < jump1_arrow_min && jump2_arrow_max < jump1_arrow_min;
		}

		// are both conditions false? (which means these two jump arrows overlap)
		return !(prevArrowAboveCurrArrow || prevArrowBelowCurrArrow);
	};

	// find suitable arrow horizontal length
	for (size_t jump_arrow_idx = 0; jump_arrow_idx < jump_arrow_vec.size(); jump_arrow_idx++) {

		JumpArrow &jump_arrow = jump_arrow_vec[jump_arrow_idx];
		bool is_dst_upward    = jump_arrow.target < instructions_[jump_arrow.sourceLine].rva();
		int jump_arrow_dst    = jump_arrow.destInViewport ? jump_arrow.destLine * ctx->lineHeight : (is_dst_upward ? 0 : viewport()->height());

		int size_block     = fontWidth_ * 2;
		int start_at_block = size_block;
		int badge_line     = -1;

		if (ctx->lineBadgeWidth.find(jump_arrow.sourceLine) != ctx->lineBadgeWidth.end()) {
			badge_line = jump_arrow.sourceLine;
		} else if (ctx->lineBadgeWidth.find(jump_arrow.destLine) != ctx->lineBadgeWidth.end()) {
			badge_line = jump_arrow.destLine;
		}

		// check if current arrow overlaps with register badge
		for (const auto &each_badge : ctx->lineBadgeWidth) {

			bool is_overlap_with_badge = isLineOverlap(
				jump_arrow.sourceLine * ctx->lineHeight + 1,
				jump_arrow_dst - 1,
				each_badge.first * ctx->lineHeight,
				(each_badge.first + 1) * ctx->lineHeight,
				true);

			if (is_overlap_with_badge) {
				badge_line = each_badge.first;
				break;
			}
		}

		if (badge_line != -1) {
			start_at_block = size_block + size_block * (ctx->lineBadgeWidth.at(badge_line) / size_block);
		}

		// first-fit search for horizontal length position to place new arrow
		for (int current_selected_len = start_at_block;; current_selected_len += size_block) {

			bool is_length_good = true;

			// check if current arrow overlaps with previous arrow
			for (size_t jump_arrow_prev_idx = 0; jump_arrow_prev_idx < jump_arrow_idx && is_length_good; jump_arrow_prev_idx++) {

				const JumpArrow &jump_arrow_prev = jump_arrow_vec[jump_arrow_prev_idx];

				bool is_dst_upward_prev = jump_arrow_prev.target < instructions_[jump_arrow_prev.sourceLine].rva();
				int jump_arrow_prev_dst = jump_arrow_prev.destInViewport ? jump_arrow_prev.destLine * ctx->lineHeight : (is_dst_upward_prev ? 0 : viewport()->height());

				bool jumps_overlap = isLineOverlap(
					jump_arrow.sourceLine * ctx->lineHeight,
					jump_arrow_dst,
					jump_arrow_prev.sourceLine * ctx->lineHeight,
					jump_arrow_prev_dst,
					false);

				// if jump blocks overlap and this horizontal length has been taken before
				if (jumps_overlap && current_selected_len == jump_arrow_prev.horizontalLength) {
					is_length_good = false;
				}
			}

			// current_selected_len is not good, search next
			if (!is_length_good) {
				continue;
			}

			jump_arrow.horizontalLength = current_selected_len;
			break;
		}
	}

	// get current process state
	State state;
	IProcess *process = edb::v1::debugger_core->process();
	process->currentThread()->getState(&state);

	painter.save();
	painter.setRenderHint(QPainter::Antialiasing, true);

	for (const JumpArrow &jump_arrow : jump_arrow_vec) {

		bool is_dst_upward = jump_arrow.target < instructions_[jump_arrow.sourceLine].rva();

		// horizontal line
		int end_x   = ctx->l1 - 3;
		int start_x = end_x - jump_arrow.horizontalLength;

		// vertical line
		int src_y = jump_arrow.sourceLine * ctx->lineHeight + (fontHeight_ / 2);
		int dst_y;

		if (jump_arrow.destInMiddleOfInstruction) {
			dst_y = jump_arrow.destLine * ctx->lineHeight;
		} else {
			dst_y = jump_arrow.destLine * ctx->lineHeight + (fontHeight_ / 2);
		}

		QColor arrow_color = palette().color(ctx->group, QPalette::Text);
		double arrow_width = 1.0;
		auto arrow_style   = Qt::DashLine;

		if (ctx->selectedLines == jump_arrow.sourceLine || ctx->selectedLines == jump_arrow.destLine) {
			arrow_width = 2.0; // enlarge arrow width
		}

		bool conditional_jmp   = is_conditional_jump(instructions_[jump_arrow.sourceLine]);
		bool unconditional_jmp = is_unconditional_jump(instructions_[jump_arrow.sourceLine]);

		// if direct jmp, then draw in solid line
		if (unconditional_jmp) {
			arrow_style = Qt::SolidLine;
		}

		// if direct jmp (src) is selected, then draw arrow in red
		if (unconditional_jmp && ctx->selectedLines == jump_arrow.sourceLine) {
			arrow_color = takenJumpColor_;
		}

		// if direct jmp (dst) is selected, then draw arrow in red
		if (unconditional_jmp && ctx->selectedLines == jump_arrow.destLine) {
			if (showAddresses_[jump_arrow.destLine] != currentAddress_) { // if eip
				arrow_color = takenJumpColor_;
			}
		}

		// if current conditional jump is taken, then draw arrow in red
		if (showAddresses_[jump_arrow.sourceLine] == currentAddress_) { // if eip
			if (conditional_jmp) {
				if (edb::v1::arch_processor().isExecuted(instructions_[jump_arrow.sourceLine], state)) {
					arrow_color = takenJumpColor_;
				}
			}
		}

		// Align both 1px and 2px lines to pixel grid. This requires different offset in even-width and odd-width case.
		const auto arrow_pixel_offset = std::fmod(arrow_width, 2.) == 1 ? 0.5 : 0;
		painter.save();
		painter.translate(arrow_pixel_offset, arrow_pixel_offset);

		painter.setPen(QPen(arrow_color, arrow_width, arrow_style));

		int src_reg_badge_width = 0;
		int dst_reg_badge_width = 0;

		if (ctx->lineBadgeWidth.find(jump_arrow.sourceLine) != ctx->lineBadgeWidth.end()) {
			src_reg_badge_width = ctx->lineBadgeWidth.at(jump_arrow.sourceLine);
		} else if (ctx->lineBadgeWidth.find(jump_arrow.destLine) != ctx->lineBadgeWidth.end()) {
			dst_reg_badge_width = ctx->lineBadgeWidth.at(jump_arrow.destLine);
		}

		if (jump_arrow.destInViewport) {

			QPoint points[] = {
				QPoint(end_x - src_reg_badge_width, src_y),
				QPoint(start_x, src_y),
				QPoint(start_x, dst_y),
				QPoint(end_x - dst_reg_badge_width - fontWidth_ / 3, dst_y)};

			painter.drawPolyline(points, 4);

			// draw arrow tips
			QPainterPath path;
			path.moveTo(end_x - dst_reg_badge_width, dst_y);
			path.lineTo(end_x - dst_reg_badge_width - (fontWidth_ / 2), dst_y - (fontHeight_ / 3));
			path.lineTo(end_x - dst_reg_badge_width - (fontWidth_ / 2), dst_y + (fontHeight_ / 3));
			path.lineTo(end_x - dst_reg_badge_width, dst_y);
			painter.fillPath(path, QBrush(arrow_color));

		} else if (is_dst_upward) { // if dst out of viewport, and arrow facing upward

			QPoint points[] = {
				QPoint(end_x - src_reg_badge_width, src_y),
				QPoint(start_x, src_y),
				QPoint(start_x, fontWidth_ / 3)};

			painter.drawPolyline(points, 3);

			// draw arrow tips
			QPainterPath path;
			path.moveTo(start_x, 0);
			path.lineTo(start_x - (fontWidth_ / 2), fontHeight_ / 3);
			path.lineTo(start_x + (fontWidth_ / 2), fontHeight_ / 3);
			path.lineTo(start_x, 0);
			painter.fillPath(path, QBrush(arrow_color));

		} else { // if dst out of viewport, and arrow facing downward

			QPoint points[] = {
				QPoint(end_x - src_reg_badge_width, src_y),
				QPoint(start_x, src_y),
				QPoint(start_x, viewport()->height() - fontWidth_ / 3)};

			painter.drawPolyline(points, 3);

			// draw arrow tips
			QPainterPath path;
			path.moveTo(start_x, viewport()->height() - 1);
			path.lineTo(start_x - (fontWidth_ / 2), viewport()->height() - (fontHeight_ / 3) - 1);
			path.lineTo(start_x + (fontWidth_ / 2), viewport()->height() - (fontHeight_ / 3) - 1);
			path.lineTo(start_x, viewport()->height() - 1);
			painter.fillPath(path, QBrush(arrow_color));
		}

		painter.restore();
	}

	painter.restore();
}

//------------------------------------------------------------------------------
// Name: drawDisassembly
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::drawDisassembly(QPainter &painter, const DrawingContext *ctx) {

	painter.save();

	painter.setPen(palette().color(ctx->group, QPalette::Text));
	for (int line = 0; line < ctx->linesToRender; line++) {
		if (ctx->selectedLines == line) {
			QPen prevPen = painter.pen();
			painter.setPen(palette().color(ctx->group, QPalette::HighlightedText));
			drawInstruction(painter, instructions_[line], ctx, line * ctx->lineHeight, true);
			painter.setPen(prevPen);
		} else {
			drawInstruction(painter, instructions_[line], ctx, line * ctx->lineHeight, false);
		}
	}

	painter.restore();
}

//------------------------------------------------------------------------------
// Name: paintEvent
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::drawDividers(QPainter &painter, const DrawingContext *ctx) {

	painter.save();

	const QPen divider_pen = palette().color(ctx->group, QPalette::WindowText);
	painter.setPen(divider_pen);

	if (edb::v1::config().show_jump_arrow || edb::v1::config().show_register_badges) {
		painter.drawLine(ctx->l1, 0, ctx->l1, height());
	}

	painter.drawLine(ctx->l2, 0, ctx->l2, height());
	painter.drawLine(ctx->l3, 0, ctx->l3, height());
	painter.drawLine(ctx->l4, 0, ctx->l4, height());

	painter.restore();
}

//------------------------------------------------------------------------------
// Name: paintEvent
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::paintEvent(QPaintEvent *) {

	if (!region_) {
		return;
	}

	const size_t region_size = region_->size();
	if (region_size == 0) {
		return;
	}

	QElapsedTimer timer;
	timer.start();

	QPainter painter(viewport());

	const int line_height = this->lineHeight();
	int lines_to_render   = viewport()->height() / line_height;

	// Possibly render another instruction just outside the viewport
	if (viewport()->height() % line_height > 0) {
		lines_to_render++;
		partialLastLine_ = true;
	} else {
		partialLastLine_ = false;
	}

	const auto binary_info = edb::v1::get_binary_info(region_);
	const auto group       = hasFocus() ? QPalette::Active : QPalette::Inactive;

	lines_to_render         = updateDisassembly(lines_to_render);
	const int selected_line = getSelectedLineNumber();

	DrawingContext context = {
		line1(),
		line2(),
		line3(),
		line4(),
		lines_to_render,
		selected_line,
		line_height,
		group,
		std::map<int, int>()};

	drawHeaderAndBackground(painter, &context, binary_info);

	if (edb::v1::config().show_register_badges) {
		drawRegiserBadges(painter, &context);
	}

	drawSymbolNames(painter, &context);

	// SELECTION, BREAKPOINT, EIP & ADDRESS
	drawSidebarElements(painter, &context);

	// INSTRUCTION BYTES AND RELJMP INDICATOR RENDERING
	drawInstructionBytes(painter, &context);

	drawFunctionMarkers(painter, &context);
	drawComments(painter, &context);

	if (edb::v1::config().show_jump_arrow) {
		drawJumpArrows(painter, &context);
	}

	drawDisassembly(painter, &context);
	drawDividers(painter, &context);

	const int64_t renderTime = timer.elapsed();
	if (renderTime > 50) {
		qDebug() << "Painting took longer than desired: " << renderTime << "ms";
	}
}

//------------------------------------------------------------------------------
// Name: setFont
// Desc: overloaded version of setFont, calculates font metrics for later
//------------------------------------------------------------------------------
void QDisassemblyView::setFont(const QFont &f) {
	syntaxCache_.clear();

	QFont newFont(f);

	// NOTE(eteran): fix for #414 ?
#if QT_VERSION < QT_VERSION_CHECK(5, 15, 0)
	newFont.setStyleStrategy(QFont::ForceIntegerMetrics);
#endif

	// TODO: assert that we are using a fixed font & find out if we care?
	QAbstractScrollArea::setFont(newFont);

	// recalculate all of our metrics/offsets
	const QFontMetrics metrics(newFont);
	fontWidth_  = Font::maxWidth(metrics);
	fontHeight_ = metrics.lineSpacing() + 1;

	// NOTE(eteran): we let the icons be a bit wider than the font itself, since things
	// like arrows don't tend to have square bounds. A ratio of 2:1 seems to look pretty
	// good on my setup.
	iconWidth_  = fontWidth_ * 2;
	iconHeight_ = fontHeight_;

	updateScrollbars();
}

//------------------------------------------------------------------------------
// Name: resizeEvent
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::resizeEvent(QResizeEvent *) {
	updateScrollbars();

	const int line_height     = this->lineHeight();
	const int lines_to_render = 1 + (viewport()->height() / line_height);

	instructionBuffer_.resize(edb::Instruction::MaxSize * lines_to_render);

	// Make PageUp/PageDown scroll through the whole page, but leave the line at
	// the top/bottom visible
	verticalScrollBar()->setPageStep(lines_to_render - 1);
}

//------------------------------------------------------------------------------
// Name: line_height
// Desc:
//------------------------------------------------------------------------------
int QDisassemblyView::lineHeight() const {
	return std::max({fontHeight_, iconHeight_});
}

//------------------------------------------------------------------------------
// Name: updateScrollbars
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::updateScrollbars() {
	if (region_) {
		const int total_lines    = region_->size();
		const int viewable_lines = viewport()->height() / lineHeight();
		const int scroll_max     = (total_lines > viewable_lines) ? total_lines - 1 : 0;

		verticalScrollBar()->setMaximum(scroll_max);
	} else {
		verticalScrollBar()->setMaximum(0);
	}
}

//------------------------------------------------------------------------------
// Name: line0
// Desc:
//------------------------------------------------------------------------------
int QDisassemblyView::line0() const {
	return line0_;
}

//------------------------------------------------------------------------------
// Name: line1
// Desc:
//------------------------------------------------------------------------------
int QDisassemblyView::line1() const {

	if (!edb::v1::config().show_jump_arrow) {

		// allocate space for register badge
		// 4 (maximum register name for GPR) + overhead
		return edb::v1::config().show_register_badges ? (5 * fontWidth_ + fontWidth_ / 2) : 0;

	} else if (line1_ == 0) {
		return 15 * fontWidth_;
	} else {
		return line1_;
	}
}

//------------------------------------------------------------------------------
// Name: auto_line2
// Desc:
//------------------------------------------------------------------------------
int QDisassemblyView::autoLine2() const {
	const int elements = addressLength();
	return (elements * fontWidth_) + (fontWidth_ / 2) + iconWidth_ + 1;
}

//------------------------------------------------------------------------------
// Name: line2
// Desc:
//------------------------------------------------------------------------------
int QDisassemblyView::line2() const {
	if (line2_ == 0) {
		return line1() + autoLine2();
	} else {
		return line2_;
	}
}

//------------------------------------------------------------------------------
// Name: line3
// Desc:
//------------------------------------------------------------------------------
int QDisassemblyView::line3() const {
	if (line3_ == 0) {
		return line2() + (DefaultByteWidth * 3) * fontWidth_;
	} else {
		return line3_;
	}
}

//------------------------------------------------------------------------------
// Name: line4
// Desc:
//------------------------------------------------------------------------------
int QDisassemblyView::line4() const {
	if (line4_ == 0) {
		return line3() + 50 * fontWidth_;
	} else {
		return line4_;
	}
}

//------------------------------------------------------------------------------
// Name: address_length
// Desc:
//------------------------------------------------------------------------------
int QDisassemblyView::addressLength() const {
	const int address_len = edb::v1::pointer_size() * CHAR_BIT / 4;
	return address_len + (showAddressSeparator_ ? 1 : 0);
}

//------------------------------------------------------------------------------
// Name: addressFromPoint
// Desc:
//------------------------------------------------------------------------------
edb::address_t QDisassemblyView::addressFromPoint(const QPoint &pos) const {

	Q_ASSERT(region_);

	const edb::address_t address = addressFromCoord(pos.x(), pos.y()) + addressOffset_;
	if (address >= region_->end()) {
		return 0;
	}
	return address;
}

//------------------------------------------------------------------------------
// Name: get_instruction_size
// Desc:
//------------------------------------------------------------------------------
Result<int, QString> QDisassemblyView::getInstructionSize(edb::address_t address, uint8_t *buf, int *size) const {

	Q_ASSERT(buf);
	Q_ASSERT(size);

	if (*size >= 0) {
		bool ok = edb::v1::get_instruction_bytes(address, buf, size);

		if (ok) {
			return instruction_size(buf, *size);
		}
	}

	return make_unexpected(tr("Failed to get instruciton size"));
}

//------------------------------------------------------------------------------
// Name: get_instruction_size
// Desc:
//------------------------------------------------------------------------------
Result<int, QString> QDisassemblyView::getInstructionSize(edb::address_t address) const {

	Q_ASSERT(region_);

	uint8_t buf[edb::Instruction::MaxSize];

	// do the longest read we can while still not crossing region end
	int buf_size = sizeof(buf);
	if (region_->end() != 0 && address + buf_size > region_->end()) {

		if (address <= region_->end()) {
			buf_size = region_->end() - address;
		} else {
			buf_size = 0;
		}
	}

	return getInstructionSize(address, buf, &buf_size);
}

//------------------------------------------------------------------------------
// Name: address_from_coord
// Desc:
//------------------------------------------------------------------------------
edb::address_t QDisassemblyView::addressFromCoord(int x, int y) const {
	Q_UNUSED(x)

	const int line         = y / lineHeight();
	edb::address_t address = verticalScrollBar()->value();

	// add up all the instructions sizes up to the line we want
	for (int i = 0; i < line; ++i) {

		Result<int, QString> size = getInstructionSize(addressOffset_ + address);
		if (size) {
			address += (*size != 0) ? *size : 1;
		} else {
			address += 1;
		}
	}

	return address;
}

//------------------------------------------------------------------------------
// Name: mouseDoubleClickEvent
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::mouseDoubleClickEvent(QMouseEvent *event) {
	if (region_) {
		if (event->button() == Qt::LeftButton) {
			if (event->x() < line2()) {
				const edb::address_t address = addressFromPoint(event->pos());

				if (region_->contains(address)) {
					Q_EMIT breakPointToggled(address);
					update();
				}
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: event
// Desc:
//------------------------------------------------------------------------------
bool QDisassemblyView::event(QEvent *event) {

	if (region_) {
		if (event->type() == QEvent::ToolTip) {
			bool show = false;

			auto helpEvent = static_cast<QHelpEvent *>(event);

			if (helpEvent->x() >= line2() && helpEvent->x() < line3()) {

				const edb::address_t address = addressFromPoint(helpEvent->pos());

				uint8_t buf[edb::Instruction::MaxSize];

				// do the longest read we can while still not passing the region end
				size_t buf_size = std::min<edb::address_t>((region_->end() - address), sizeof(buf));
				if (edb::v1::get_instruction_bytes(address, buf, &buf_size)) {
					const edb::Instruction inst(buf, buf + buf_size, address);
					const QString byte_buffer = format_instruction_bytes(inst);

					if ((line2() + byte_buffer.size() * fontWidth_) > line3()) {
						QToolTip::showText(helpEvent->globalPos(), byte_buffer);
						show = true;
					}
				}
			}

			if (!show) {
				QToolTip::showText(QPoint(), QString());
				event->ignore();
				return true;
			}
		}
	}

	return QAbstractScrollArea::event(event);
}

//------------------------------------------------------------------------------
// Name: mouseReleaseEvent
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::mouseReleaseEvent(QMouseEvent *event) {

	Q_UNUSED(event)

	movingLine1_      = false;
	movingLine2_      = false;
	movingLine3_      = false;
	movingLine4_      = false;
	selectingAddress_ = false;

	setCursor(Qt::ArrowCursor);
	update();
}

//------------------------------------------------------------------------------
// Name: updateSelectedAddress
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::updateSelectedAddress(QMouseEvent *event) {

	if (region_) {
		setSelectedAddress(addressFromPoint(event->pos()));
	}
}

//------------------------------------------------------------------------------
// Name: mousePressEvent
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::mousePressEvent(QMouseEvent *event) {
	const int event_x = event->x() - line0();
	if (region_) {
		if (event->button() == Qt::LeftButton) {
			if (near_line(event_x, line1()) && edb::v1::config().show_jump_arrow) {
				movingLine1_ = true;
			} else if (near_line(event_x, line2())) {
				movingLine2_ = true;
			} else if (near_line(event_x, line3())) {
				movingLine3_ = true;
			} else if (near_line(event_x, line4())) {
				movingLine4_ = true;
			} else {
				updateSelectedAddress(event);
				selectingAddress_ = true;
			}
		} else {
			updateSelectedAddress(event);
		}
	}
}

//------------------------------------------------------------------------------
// Name: mouseMoveEvent
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::mouseMoveEvent(QMouseEvent *event) {

	if (region_) {
		const int x_pos = event->x() - line0();

		if (movingLine1_) {
			if (line2_ == 0) {
				line2_ = line2();
			}
			const int min_line1 = 0;
			const int max_line1 = line2() - fontWidth_;
			line1_              = std::clamp(x_pos, min_line1, max_line1);
			update();
		} else if (movingLine2_) {
			if (line3_ == 0) {
				line3_ = line3();
			}
			const int min_line2 = line1() + iconWidth_;
			const int max_line2 = line3() - fontWidth_;
			line2_              = std::clamp(x_pos, min_line2, max_line2);
			update();
		} else if (movingLine3_) {
			if (line4_ == 0) {
				line4_ = line4();
			}
			const int min_line3 = line2() + fontWidth_ + fontWidth_ / 2;
			const int max_line3 = line4() - fontWidth_;
			line3_              = std::clamp(x_pos, min_line3, max_line3);
			update();
		} else if (movingLine4_) {
			const int min_line4 = line3() + fontWidth_;
			const int max_line4 = width() - 1 - (verticalScrollBar()->width() + 3);
			line4_              = std::clamp(x_pos, min_line4, max_line4);
			update();
		} else {
			if ((near_line(x_pos, line1()) && edb::v1::config().show_jump_arrow) ||
				near_line(x_pos, line2()) ||
				near_line(x_pos, line3()) ||
				near_line(x_pos, line4())) {
				setCursor(Qt::SplitHCursor);
			} else {
				setCursor(Qt::ArrowCursor);
				if (selectingAddress_) {
					updateSelectedAddress(event);
				}
			}
		}
	}
}

//------------------------------------------------------------------------------
// Name: selectedAddress
// Desc:
//------------------------------------------------------------------------------
edb::address_t QDisassemblyView::selectedAddress() const {
	return selectedInstructionAddress_;
}

//------------------------------------------------------------------------------
// Name: setSelectedAddress
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::setSelectedAddress(edb::address_t address) {

	if (region_) {
		history_.add(address);
		const Result<int, QString> size = getInstructionSize(address);

		if (size) {
			selectedInstructionAddress_ = address;
			selectedInstructionSize_    = *size;
		} else {
			selectedInstructionAddress_ = 0;
			selectedInstructionSize_    = 0;
		}

		update();
	}
}

//------------------------------------------------------------------------------
// Name: selectedSize
// Desc:
//------------------------------------------------------------------------------
int QDisassemblyView::selectedSize() const {
	return selectedInstructionSize_;
}

//------------------------------------------------------------------------------
// Name: region
// Desc:
//------------------------------------------------------------------------------
std::shared_ptr<IRegion> QDisassemblyView::region() const {
	return region_;
}

//------------------------------------------------------------------------------
// Name: add_comment
// Desc: Adds a comment to the comment hash.
//------------------------------------------------------------------------------
void QDisassemblyView::addComment(edb::address_t address, QString comment) {
	qDebug("Insert Comment");
	Comment temp_comment = {
		address,
		comment};
	SessionManager::instance().addComment(temp_comment);
	comments_.insert(address, comment);
}

//------------------------------------------------------------------------------
// Name: remove_comment
// Desc: Removes a comment from the comment hash and returns the number of comments removed.
//------------------------------------------------------------------------------
int QDisassemblyView::removeComment(edb::address_t address) {
	SessionManager::instance().removeComment(address);
	return comments_.remove(address);
}

//------------------------------------------------------------------------------
// Name: get_comment
// Desc: Returns a comment assigned for an address or a blank string if there is none.
//------------------------------------------------------------------------------
QString QDisassemblyView::getComment(edb::address_t address) {
	return comments_.value(address, QString(""));
}

//------------------------------------------------------------------------------
// Name: clear_comments
// Desc: Clears all comments in the comment hash.
//------------------------------------------------------------------------------
void QDisassemblyView::clearComments() {
	comments_.clear();
}

//------------------------------------------------------------------------------
// Name: saveState
// Desc:
//------------------------------------------------------------------------------
QByteArray QDisassemblyView::saveState() const {

	const WidgetState1 state = {
		sizeof(WidgetState1),
		line1_,
		line2_,
		line3_,
		line4_,
	};

	char buf[sizeof(WidgetState1)];
	memcpy(buf, &state, sizeof(buf));

	return QByteArray(buf, sizeof(buf));
}

//------------------------------------------------------------------------------
// Name: restoreState
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::restoreState(const QByteArray &stateBuffer) {

	WidgetState1 state;

	if (stateBuffer.size() >= static_cast<int>(sizeof(WidgetState1))) {
		memcpy(&state, stateBuffer.data(), sizeof(WidgetState1));

		if (state.version >= static_cast<int>(sizeof(WidgetState1))) {
			line1_ = state.line1;
			line2_ = state.line2;
			line3_ = state.line3;
			line4_ = state.line4;
		}
	}
}
//------------------------------------------------------------------------------
// Name: restoreComments
// Desc:
//------------------------------------------------------------------------------
void QDisassemblyView::restoreComments(QVariantList &comments_data) {
	qDebug("restoreComments");
	for (auto it = comments_data.begin(); it != comments_data.end(); ++it) {
		QVariantMap data = it->toMap();
		if (const Result<edb::address_t, QString> addr = edb::v1::string_to_address(data["address"].toString())) {
			comments_.insert(*addr, data["comment"].toString());
		}
	}
}

```

`src/widgets/QDisassemblyView.h`:

```h
/*
Copyright (C) 2006 - 2017 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef QDISASSEMBLY_VIEW_H_20061101_
#define QDISASSEMBLY_VIEW_H_20061101_

#include "NavigationHistory.h"
#include "Types.h"

#include <QAbstractScrollArea>
#include <QAbstractSlider>
#include <QCache>
#include <QPainterPath>
#include <QPixmap>
#include <QSvgRenderer>

#include <memory>
#include <optional>
#include <vector>

template <class T, class E>
class Result;

class IRegion;
class IAnalyzer;
class QPainter;
class QTextDocument;
class SyntaxHighlighter;

class QDisassemblyView final : public QAbstractScrollArea {
	Q_OBJECT

private:
	struct DrawingContext {
		int l1;
		int l2;
		int l3;
		int l4;
		int linesToRender;
		int selectedLines;
		int lineHeight;
		QPalette::ColorGroup group;
		std::map<int, int> lineBadgeWidth; // for jmp drawing
	};

public:
	explicit QDisassemblyView(QWidget *parent = nullptr);
	~QDisassemblyView() override = default;

protected:
	bool event(QEvent *event) override;
	void mouseDoubleClickEvent(QMouseEvent *event) override;
	void mouseMoveEvent(QMouseEvent *event) override;
	void mousePressEvent(QMouseEvent *event) override;
	void mouseReleaseEvent(QMouseEvent *event) override;
	void paintEvent(QPaintEvent *event) override;
	void wheelEvent(QWheelEvent *e) override;
	void keyPressEvent(QKeyEvent *event) override;
	void resizeEvent(QResizeEvent *event) override;

public:
	QByteArray saveState() const;
	QString getComment(edb::address_t address);
	bool addressShown(edb::address_t address) const;
	edb::address_t addressFromPoint(const QPoint &pos) const;
	edb::address_t selectedAddress() const;
	int removeComment(edb::address_t address);
	int selectedSize() const;
	std::shared_ptr<IRegion> region() const;
	void addComment(edb::address_t address, QString comment);
	void clearComments();
	void restoreComments(QVariantList &);
	void restoreState(const QByteArray &stateBuffer);
	void setSelectedAddress(edb::address_t address);

Q_SIGNALS:
	void signalUpdated();
	void breakPointToggled(edb::address_t address);
	void regionChanged();

public Q_SLOTS:
	void setFont(const QFont &f);
	void scrollTo(edb::address_t address);
	void setRegion(const std::shared_ptr<IRegion> &r);
	void setCurrentAddress(edb::address_t address);
	void clear();
	void update();
	void setShowAddressSeparator(bool value);
	void resetColumns();

private:
	void scrollbarActionTriggered(int action);
	QString formatAddress(edb::address_t address) const;
	QString instructionString(const edb::Instruction &inst) const;
	Result<int, QString> getInstructionSize(edb::address_t address) const;
	Result<int, QString> getInstructionSize(edb::address_t address, uint8_t *buf, int *size) const;
	std::optional<unsigned int> getLineOfAddress(edb::address_t addr) const;
	edb::address_t addressFromCoord(int x, int y) const;
	int addressLength() const;
	int autoLine2() const;
	int line0() const;
	int line1() const;
	int line2() const;
	int line3() const;
	int line4() const;
	int lineHeight() const;
	int previousInstructions(int current_address, int count);
	int previousInstruction(IAnalyzer *analyzer, int current_address);
	int followingInstructions(int current_address, int count);
	int followingInstruction(int current_address);
	int updateDisassembly(int lines_to_render);
	int getSelectedLineNumber() const;
	void paintLineBg(QPainter &painter, QBrush brush, int line, int num_lines = 1);
	void setAddressOffset(edb::address_t address);
	void updateScrollbars();
	void updateSelectedAddress(QMouseEvent *event);

	void drawInstruction(QPainter &painter, const edb::Instruction &inst, const DrawingContext *ctx, int y, bool selected);
	void drawHeaderAndBackground(QPainter &painter, const DrawingContext *ctx, const std::unique_ptr<IBinary> &binary_info);
	void drawRegiserBadges(QPainter &painter, DrawingContext *ctx);
	void drawSymbolNames(QPainter &painter, const DrawingContext *ctx);
	void drawSidebarElements(QPainter &painter, const DrawingContext *ctx);
	void drawInstructionBytes(QPainter &painter, const DrawingContext *ctx);
	void drawFunctionMarkers(QPainter &painter, const DrawingContext *ctx);
	void drawComments(QPainter &painter, const DrawingContext *ctx);
	void drawJumpArrows(QPainter &painter, const DrawingContext *ctx);
	void drawDisassembly(QPainter &painter, const DrawingContext *ctx);
	void drawDividers(QPainter &painter, const DrawingContext *ctx);

private:
	edb::address_t addressOffset_{0};
	edb::address_t selectedInstructionAddress_{0};
	edb::address_t currentAddress_{0};
	int fontHeight_                = 0; // height of a character in this font
	int fontWidth_                 = 0; // width of a character in this font
	int iconWidth_                 = 0;
	int iconHeight_                = 0;
	int line0_                     = 0;
	int line1_                     = 0;
	int line2_                     = 0;
	int line3_                     = 0;
	int line4_                     = 0;
	int selectedInstructionSize_   = 0;
	bool movingLine1_              = false;
	bool movingLine2_              = false;
	bool movingLine3_              = false;
	bool movingLine4_              = false;
	bool selectingAddress_         = false;
	bool partialLastLine_          = false;
	QColor addressForegroundColor_ = Qt::red;
	QColor fillingBytesColor_      = Qt::gray;
	QColor badgeBackgroundColor_   = Qt::blue;
	QColor badgeForegroundColor_   = Qt::white;
	QColor takenJumpColor_         = Qt::red;

private:
	std::shared_ptr<IRegion> region_;
	QVector<edb::address_t> showAddresses_;
	std::vector<CapstoneEDB::Instruction> instructions_;
	SyntaxHighlighter *highlighter_;
	bool showAddressSeparator_;
	QHash<edb::address_t, QString> comments_;
	NavigationHistory history_;
	QSvgRenderer breakpointRenderer_;
	QSvgRenderer currentRenderer_;
	QSvgRenderer currentBpRenderer_;
	std::vector<uint8_t> instructionBuffer_;
	QCache<QString, QPixmap> syntaxCache_;

private:
	struct JumpArrow {

		int sourceLine;

		edb::address_t target;

		// if target is visible in viewport
		bool destInViewport;

		// only valid is dst_in_viewport is true
		bool destInMiddleOfInstruction;

		// if dst_in_viewport is false, then this param is ignored
		int destLine;

		// if dst_in_viewport is false, then the value here should be near INT_MAX
		size_t distance;

		// length of arrow horizontal
		int horizontalLength;
	};
};

#endif

```

`src/widgets/RegisterViewDelegate.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "RegisterViewDelegate.h"
#include <QTreeView>

//------------------------------------------------------------------------------
// Name: RegisterViewDelegate
// Desc:
//------------------------------------------------------------------------------
RegisterViewDelegate::RegisterViewDelegate(QTreeView *view, QWidget *parent)
	: QStyledItemDelegate(parent), view_(view) {
}

//------------------------------------------------------------------------------
// Name: paint
// Desc:
//------------------------------------------------------------------------------
void RegisterViewDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const {

	const QAbstractItemModel *const model = index.model();
	Q_ASSERT(model);

	if (!model->parent(index).isValid()) {
		// this is a top-level item.
		QStyleOptionButton buttonOption;

		buttonOption.state = option.state;
#ifdef Q_WS_MAC
		buttonOption.state |= QStyle::State_Raised;
#endif
		buttonOption.state &= ~QStyle::State_HasFocus;

		buttonOption.rect     = option.rect;
		buttonOption.palette  = option.palette;
		buttonOption.features = QStyleOptionButton::None;
		view_->style()->drawControl(QStyle::CE_PushButton, &buttonOption, painter, view_);

		static const int i = 9; // ### hardcoded in qcommonstyle.cpp
		const QRect &r     = option.rect;

		QStyleOption branchOption;
		branchOption.rect    = QRect(r.left() + i / 2, r.top() + (r.height() - i) / 2, i, i);
		branchOption.palette = option.palette;
		branchOption.state   = QStyle::State_Children;

		if (view_->isExpanded(index)) {
			branchOption.state |= QStyle::State_Open;
		}

		view_->style()->drawPrimitive(QStyle::PE_IndicatorBranch, &branchOption, painter, view_);

		// draw text
		const QRect textrect = QRect(r.left() + i * 2, r.top(), r.width() - ((5 * i) / 2), r.height());
		const QString text   = option.fontMetrics.elidedText(model->data(index, Qt::DisplayRole).toString(), Qt::ElideMiddle, textrect.width());
		view_->style()->drawItemText(painter, textrect, Qt::AlignCenter, option.palette, view_->isEnabled(), text);

	} else {
		QStyledItemDelegate::paint(painter, option, index);
	}
}

//------------------------------------------------------------------------------
// Name: sizeHint
// Desc:
//------------------------------------------------------------------------------
QSize RegisterViewDelegate::sizeHint(const QStyleOptionViewItem &opt, const QModelIndex &index) const {
	const QSize defaultHint = QStyledItemDelegate::sizeHint(opt, index) + QSize(2, 2);
	if (!index.model()->parent(index).isValid()) {
		QStyleOptionButton optButton;
		optButton.rect.setSize(opt.fontMetrics.size(Qt::TextShowMnemonic, "X"));
		const QSize buttonHint = view_->style()->sizeFromContents(QStyle::CT_PushButton, &optButton, optButton.rect.size());
		return QSize(defaultHint.width(), buttonHint.height());
	} else
		return defaultHint;
}

```

`src/widgets/RegisterViewDelegate.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef REGISTER_VIEW_DELEGATE_H_20070519_
#define REGISTER_VIEW_DELEGATE_H_20070519_

#include <QStyledItemDelegate>

class QTreeView;

class RegisterViewDelegate : public QStyledItemDelegate {
	Q_OBJECT

public:
	RegisterViewDelegate(QTreeView *view, QWidget *parent);
	RegisterViewDelegate(const RegisterViewDelegate &) = delete;
	RegisterViewDelegate &operator=(const RegisterViewDelegate &) = delete;
	~RegisterViewDelegate() override                              = default;

public:
	void paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const override;
	QSize sizeHint(const QStyleOptionViewItem &opt, const QModelIndex &index) const override;

private:
	QTreeView *view_;
};

#endif

```

`src/widgets/SyntaxHighlighter.cpp`:

```cpp
/*
Copyright (C) 2006 - 2016 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "SyntaxHighlighter.h"
#include "Theme.h"

/**
 * @brief SyntaxHighlighter::SyntaxHighlighter
 * @param parent
 */
SyntaxHighlighter::SyntaxHighlighter(QObject *parent)
	: QObject(parent) {

	createRules();
}

/**
 * @brief SyntaxHighlighter::HighlightingRule::HighlightingRule
 * @param regex
 * @param format
 */
SyntaxHighlighter::HighlightingRule::HighlightingRule(const QString &regex, const QTextCharFormat &fmt)
	: pattern(regex) {

	pattern.setCaseSensitivity(Qt::CaseInsensitive);
	format = fmt;
}

/**
 * @brief SyntaxHighlighter::createRules
 */
void SyntaxHighlighter::createRules() {

	Theme theme = Theme::load();

	// TODO: make these rules be implemented in a portable way
	// right now things are very much hard coded

	// TODO: support segments

	// comma
	rules_.emplace_back(
		"(?:,)",
		theme.text[Theme::Comma]);

	// expression brackets
	rules_.emplace_back(
		"(?:[\\(?:\\)\\[\\]])",
		theme.text[Theme::Brackets]);

	// math operators
	rules_.emplace_back(
		"\\b(?:[\\+\\-\\*])\\b",
		theme.text[Theme::Operator]);

	// registers
	// TODO: support ST(N)
	rules_.emplace_back(
#if defined(EDB_X86) || defined(EDB_X86_64)
		"\\b(?:(?:(?:e|r)?(?:ax|bx|cx|dx|bp|sp|si|di|ip))|(?:[abcd](?:l|h))|(?:sp|bp|si|di)l|(?:[cdefgs]s)|[xyz]?mm(?:[0-9]|[12][0-9]|3[01])|r(?:8|9|(?:1[0-5]))[dwb]?)\\b",
#elif defined(EDB_ARM32)
		"\\b(?:r(?:[0-9]|1[0-5])|sb|sl|fp|ip|sp|lr|pc|[sd][0-9]|[sdf](?:[12][0-9]|3[01])|q(?:[0-9]|1[0-5]))\\b",
#elif defined(EDB_ARM64)
		"\\b(?:[xw](?:[12]?[0-9]|3[01]))\\b" /* FIXME: stub, only GPRs here */,
#else
#error "What string should be here?"
#endif
		theme.text[Theme::Register]);

	// constants
	rules_.emplace_back(
#if defined(EDB_ARM32) || defined(EDB_ARM64)
		"#?" /* concatenated with general number pattern */
#endif
		"\\b(?:(?:0[0-7]*)|(?:0(?:x|X)[0-9a-fA-F]+)|(?:[1-9][0-9]*))\\b",
		theme.text[Theme::Constant]);

#if defined(EDB_X86) || defined(EDB_X86_64)
	// pointer modifiers
	rules_.emplace_back(
		"\\b(?:t?byte|(?:[xyz]mm|[qdf]?)word)(?: ptr)?\\b",
		theme.text[Theme::Ptr]);

	// prefix
	rules_.emplace_back(
		"\\b(?:lock|rep(?:ne)?)\\b",
		theme.text[Theme::Prefix]);
#endif

	// flow control
	rules_.emplace_back(
#if defined(EDB_X86) || defined(EDB_X86_64)
		"\\b(?:l?jmp[bswlqt]?|loopn?[ez]|(?:jn?(?:a|ae|b|be|c|e|g|ge|l|le|o|p|s|z)|j(?:pe|po|cxz|ecxz)))\\b",
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
		/* FIXME(ARM): there are also instructions like `add pc, pc, #5`, which
		 *             should also be considered flow control */
		"\\b(?:b(?:x|xj)?(?:eq|ne|cs|hs|cc|lo|mi|pl|vs|vc|hi|ls|ge|lt|gt|le)?)\\b",
#else
#error "What string should be here?"
#endif
		theme.text[Theme::FlowCtrl]);

	// function call
	rules_.emplace_back(
#if defined(EDB_X86) || defined(EDB_X86_64)
		"\\b(?:call|ret[nf]?)[bswlqt]?\\b",
#elif defined(EDB_ARM32) || defined(EDB_ARM64)
		"\\b(?:b(?:l|lx)(?:eq|ne|cs|hs|cc|lo|mi|pl|vs|vc|hi|ls|ge|lt|gt|le)?)\\b",
#else
#error "What string should be here?"
#endif
		theme.text[Theme::Function]);

#if defined(EDB_X86) || defined(EDB_X86_64)
	// FIXME(ARM): this is stubbed out

	// stack operations
	rules_.emplace_back(
		"\\b(?:pushf?|popf?|enter|leave)\\b",
		theme.text[Theme::Stack]);

	// comparison
	rules_.emplace_back(
		"\\b(?:cmp|test)[bswlqt]?\\b",
		theme.text[Theme::Comparison]);

	// data transfer
	rules_.emplace_back(
		"\\b(?:c?movs[bw]|lea|xchg|mov(?:[zs]x?)?)[bswlqt]?\\b",
		theme.text[Theme::DataXfer]);

	// arithmetic
	rules_.emplace_back(
		"\\b(?:add|sub|i?mul|i?div|neg|adc|sbb|inc|dec)[bswlqt]?\\b",
		theme.text[Theme::Arithmetic]);

	// logic
	rules_.emplace_back(
		"\\b(?:and|x?or|not)[bswlqt]?\\b",
		theme.text[Theme::Logic]);

	// shift
	rules_.emplace_back(
		"\\b(?:sh|sa|sc|ro)[rl][bswlqt]?\\b",
		theme.text[Theme::Shift]);

	// system
	rules_.emplace_back(
		"\\b(?:sti|cli|hlt|in|out|sysenter|sysexit|syscall|sysret|int)\\b",
		theme.text[Theme::System]);
#endif

	// data bytes
	rules_.emplace_back(
		"\\b(?:db|dw|dd|dq)\\b",
		theme.text[Theme::Data]);
}

/**
 * @brief SyntaxHighlighter::highlightBlock
 * @param text
 * @return
 */
QVector<QTextLayout::FormatRange> SyntaxHighlighter::highlightBlock(const QString &text) {

	QVector<QTextLayout::FormatRange> ranges;

	for (const HighlightingRule &rule : rules_) {
		int index = rule.pattern.indexIn(text);
		while (index >= 0) {
			const int length = rule.pattern.matchedLength();

			QTextLayout::FormatRange range;

			range.format = rule.format;
			range.start  = index;
			range.length = length;

			ranges.push_back(range);

			index = rule.pattern.indexIn(text, index + length);
		}
	}

	return ranges;
}

```

`src/widgets/SyntaxHighlighter.h`:

```h
/*
Copyright (C) 2006 - 2016 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef SYNTAX_HIGHLIGHTER_H_20191119_
#define SYNTAX_HIGHLIGHTER_H_20191119_

#include <QRegExp>
#include <QTextCharFormat>
#include <QTextLayout>
#include <QVector>
#include <vector>

class SyntaxHighlighter : public QObject {
	Q_OBJECT

public:
	explicit SyntaxHighlighter(QObject *parent = nullptr);

private:
	void createRules();

public:
	QVector<QTextLayout::FormatRange> highlightBlock(const QString &text);

private:
	struct HighlightingRule {
		HighlightingRule() = default;
		HighlightingRule(const QString &regex, const QTextCharFormat &fmt);

		QRegExp pattern;
		QTextCharFormat format;
	};

	std::vector<HighlightingRule> rules_;
};

#endif

```

`src/widgets/TabWidget.cpp`:

```cpp
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "TabWidget.h"

#include <QMouseEvent>
#include <QTabBar>

/**
 * @brief TabWidget::TabWidget
 * @param parent
 */
TabWidget::TabWidget(QWidget *parent)
	: QTabWidget(parent) {
}

/**
 * @brief TabWidget::setData
 * @param index
 * @param data
 */
void TabWidget::setData(int index, const QVariant &data) {
	tabBar()->setTabData(index, data);
}

/**
 * @brief TabWidget::data
 * @param index
 * @return
 */
QVariant TabWidget::data(int index) const {
	return tabBar()->tabData(index);
}

/**
 * @brief TabWidget::mousePressEvent
 * @param event
 */
void TabWidget::mousePressEvent(QMouseEvent *event) {
	if (event->button() != Qt::RightButton) {
		return;
	}

	const int tab = tabBar()->tabAt(event->pos());
	if (tab != -1) {
		Q_EMIT customContextMenuRequested(tab, event->pos());
	}
}

```

`src/widgets/TabWidget.h`:

```h
/*
Copyright (C) 2006 - 2015 Evan Teran
                          evan.teran@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef TAB_WIDGET_H_20080118_
#define TAB_WIDGET_H_20080118_

#include <QTabWidget>

class TabWidget : public QTabWidget {
	Q_OBJECT

public:
	explicit TabWidget(QWidget *parent = nullptr);
	~TabWidget() override = default;

Q_SIGNALS:
	void customContextMenuRequested(int, const QPoint &);

public:
	void setData(int index, const QVariant &data);
	QVariant data(int index) const;

protected:
	void mousePressEvent(QMouseEvent *event) override;
};

#endif

```