Project Path: arc_gmh5225_ac_eoxw8ni_

Source Tree:

```txt
arc_gmh5225_ac_eoxw8ni_
├── README.md
├── ac.sln
├── dblayout.drawio
├── driver
│   ├── apc.c
│   ├── apc.h
│   ├── arch.asm
│   ├── callbacks.c
│   ├── callbacks.h
│   ├── common.h
│   ├── cpp.hint
│   ├── crypt.c
│   ├── crypt.h
│   ├── driver.c
│   ├── driver.h
│   ├── driver.inf
│   ├── driver.vcxproj
│   ├── driver.vcxproj.filters
│   ├── hv.c
│   ├── hv.h
│   ├── hw.c
│   ├── hw.h
│   ├── ia32.h
│   ├── imports.c
│   ├── imports.h
│   ├── integrity.c
│   ├── integrity.h
│   ├── io.c
│   ├── io.h
│   ├── list.c
│   ├── list.h
│   ├── modules.c
│   ├── modules.h
│   ├── pool.c
│   ├── pool.h
│   ├── queue.c
│   ├── queue.h
│   ├── session.c
│   ├── session.h
│   ├── thread.c
│   ├── thread.h
│   └── types
│       └── types.h
├── module
│   ├── client
│   │   ├── message_queue.cpp
│   │   ├── message_queue.h
│   │   ├── pipe.cpp
│   │   └── pipe.h
│   ├── common.h
│   ├── dispatcher
│   │   ├── dispatcher.cpp
│   │   ├── dispatcher.h
│   │   ├── threadpool.cpp
│   │   ├── threadpool.h
│   │   ├── timer.cpp
│   │   └── timer.h
│   ├── helper.cpp
│   ├── helper.h
│   ├── imports.cpp
│   ├── imports.h
│   ├── kernel_interface
│   │   ├── kernel_interface.cpp
│   │   └── kernel_interface.h
│   ├── main.cpp
│   ├── module.cpp
│   ├── module.h
│   ├── module.vcxproj
│   └── module.vcxproj.filters
├── server
│   ├── Database
│   │   ├── Entity
│   │   │   ├── HardwareConfiguration.cs
│   │   │   ├── Report
│   │   │   │   ├── IReportEntity.cs
│   │   │   │   ├── ReportEntity.cs
│   │   │   │   └── Types
│   │   │   │       ├── AttachProcessEntity.cs
│   │   │   │       ├── HiddenSystemThreadEntity.cs
│   │   │   │       ├── IllegalHandleOperationEntity.cs
│   │   │   │       ├── InvalidProcessAllocationEntity.cs
│   │   │   │       ├── NmiCallbackEntity.cs
│   │   │   │       ├── PageProtectionEntity.cs
│   │   │   │       ├── PatternScanEntity.cs
│   │   │   │       ├── ProcessModuleIntegrityCheckEntity.cs
│   │   │   │       ├── StartAddressEntity.cs
│   │   │   │       └── SystemModuleValidationEntity.cs
│   │   │   └── User.cs
│   │   └── Model
│   │       ├── Model.cs
│   │       └── ModelContext.cs
│   ├── Helper.cs
│   ├── Message
│   │   ├── ClientReport.cs
│   │   ├── ClientRequest.cs
│   │   ├── ClientSend.cs
│   │   ├── IClientMessage.cs
│   │   └── MessageHandler.cs
│   ├── Program.cs
│   ├── Server.cs
│   ├── Types.cs
│   └── server.csproj
├── service
│   ├── Client.cs
│   ├── Program.cs
│   ├── Properties
│   │   └── launchSettings.json
│   ├── Worker.cs
│   ├── appsettings.Development.json
│   ├── appsettings.json
│   ├── helper.cs
│   └── service.csproj
└── test
    ├── cli
    │   ├── driver.h
    │   ├── main.cpp
    │   ├── testcli.vcxproj
    │   └── testcli.vcxproj.filters
    └── driver
        ├── common.hpp
        ├── driver.hpp
        ├── framework.hpp
        ├── main.cpp
        ├── patch.cpp
        ├── patch.hpp
        ├── testdrv.inf
        ├── testdrv.vcxproj
        └── testdrv.vcxproj.filters

```

`README.md`:

```md
# ac

open source anti cheat (lol) which I made for fun.

# features

- Attached thread detection
- Process module .text section integrity checks
- NMI stackwalking via isr iretq
- APC stackwalking via RtlCaptureStackBackTrace
- DPC stackwalking via RtlCaptureStackBackTrace
- Handle stripping via obj callbacks
- Process handle table enumeration
- System module device object verification
- System module .text integrity checks
- Unlinked process detection
- Removed thread PspCidTable entry detection
- Dispatch routine validation
- Extraction of hardware identifiers
- EPT hook detection
- Driver integrity checks both locally and over server
- Hypervisor detection
- HalDispatch and HalPrivateDispatch routine validation
- Dynamic import resolving & encryption
- Malicious PCI device detection via configuration space scanning

# planned features

- Heartbeat
- ntoskrnl integrity checks
- cr3 protection 
- string, packet and other encryption
- tpm ek extraction
- tpm spoofer detection
- pcileech firmware detection 
- testing program to test the features
- simple user mode logger + usermode logging overhaul
- data ptr detction (+ chained data ptr walking)
- lots more which I cant think of

# example

- I have recorded an example of the program running with CS2. Note that vac was obviously disabled. *If you decide to test with a steam game do not forget to launch in insecure mode*
- Shown are the kernel `VERBOSE` level logs in DebugView along with the usermode application console and some additional performance benchmarking things.
- (You can find the video here)[https://youtu.be/b3mH7w8pOxs]

# known issues

- [See the issues page](https://github.com/donnaskiez/ac/issues)
- Feel free to open a new issue if you find any bugs

# windows versions tested:

- Win10 22H2
- Win11 22H2

# how to build

Requires [Visual Studio](https://visualstudio.microsoft.com/downloads/) and the [WDK](https://learn.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk) for compilation.

## test signing mode

Before we continue, ensure you enable test signing mode as this driver is not signed.

1. Open a command prompt as Administrator
2. Enter the following commands:

```bash
bcdedit -set TESTSIGNING on
bcdedit /debug on
```

3. Restart Windows

## building and running the project

1. Clone the project i.e `git clone git@github.com:donnaskiez/ac.git`
2. Open the project in visual studio
3. Select `Release - No Server - Win10` or `Release - No Server - Win11` depending on the version of Windows you will be running the driver on.
4. Build the project in visual studio, if you experience any build issues - check the drivers project settings are the following:
	- `Inf2Cat -> General -> Use Local Time` to `Yes`
	- `C/C++ -> Treat Warnings As Errors` to `No`
	- `C/C++ -> Spectre Mitigation` to `Disabled`
5. Move the `driver.sys` file located in `ac\x64\Release - No Server\` into the `Windows\System32\Drivers` directory
	- You can rename the driver if you would like
6. Use the [OSR Loader](https://www.osronline.com/article.cfm%5Earticle=157.htm) and select `driver.sys` (or whatever you named it) that you moved to the Windows drivers folder. *DO NOT REGISTER THE SERVICE YET*.
7. Under `Service Start` select `System`. This is VERY important!
8. Click `Register Service`. *Do NOT click* `Start Service`!
9. Restart Windows. 
10. Once restarted, open the program you would like to protect. This could be anything i.e cs2, notepad etc.
	- if you do use a game to test, ensure the games anti-cheat is turned off before testing
11. Open your dll injector of choice (I simply use [Process Hacker](https://processhacker.sourceforge.io/))
12. Inject the dll found in `ac\x64\Release - No Server\` named `user.dll` into the target program

Logs will be printed to both the terminal output and the kernel debugger. See below for configuring kernel debugger output.

Note: The server is not needed for the program to function properly.

# how to configure kernel debugging output

The kernel driver is setup to log at 4 distinct levels:

```C
#define LOG_ERROR_LEVEL  
#define LOG_WARNING_LEVEL
#define LOG_INFO_LEVEL   
#define LOG_VERBOSE_LEVEL
```

As the names suggest, `ERROR_LEVEL` is for errors, `WARNING_LEVEL` is for warnings. `INFO_LEVEL` is for general information regarding what requests the driver is processing and `VERBOSE_LEVEL` contains very detailed information for each request.

## creating the registry key

If you are unfamiliar with the kernel debugging mask, you probably need to set one up. If you already have a debugging mask setup, you can skip to `setting the mask` below.

1. Open the Registry Editor
2. Copy and pase `Computer\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager` into the bar at the top and press enter
3. On the left hand side, right click `Session Manager` and select `New -> Key`
4. Name the key `Debug Print Filter`
5. On the left hand side you should now see `Debug Print Filter`, right click and select `New -> DWORD (32 bit) Value`
6. Name the key `DEFAULT`

## setting the mask

1. Within the `Debug Print Filter` registry, double click the key named `DEFAULT`
2. Determine the level(s) of logging you would like to see. For most people interested I would set either `INFO_LEVEL` or `VERBOSE_LEVEL`. Remember that if you set `INFO_LEVEL`, you will see all `INFO_LEVEL`, `WARNING_LEVEL` and `ERROR_LEVEL` logs. Ie you see all logs above and including your set level.

```
ERROR_LEVEL    = 0x3
WARNING_LEVEL  = 0x7
INFO_LEVEL     = 0xf
VERBOSE_LEVEL  = 0x1f
```

3. Enter the value for the given logging level (seen above)
4. Click `Ok` and restart Windows.

## filtering debug output

If you choose to use `INFO_LEVEL` or `VERBOSE_LEVEL` there may be many logs from the kernel so we want to filter them out.

### windbg

With WinDbg connected to the target:

1. Pause the target using the `Break` button
2. Use the command: `.ofilter donna-ac*`

### debugview

1. Click `Edit -> Filter/Highlight`
2. Set the `Include` string to `donna-ac*`

# contact

feel free to dm me on discord or uc @donnaskiez
```

`ac.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.5.33502.453
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "driver", "driver\driver.vcxproj", "{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "service", "service\service.csproj", "{6228E9DD-E1EA-45D8-8054-A00FC2D63414}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "server", "server\server.csproj", "{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "testdrv", "test\driver\testdrv.vcxproj", "{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "module", "module\module.vcxproj", "{3B18467A-4358-45EF-81B1-5C6F9B0B6728}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release - No Server - Win10|Any CPU = Release - No Server - Win10|Any CPU
		Release - No Server - Win10|ARM64 = Release - No Server - Win10|ARM64
		Release - No Server - Win10|x64 = Release - No Server - Win10|x64
		Release - No Server - Win10|x86 = Release - No Server - Win10|x86
		Release - No Server - Win11|Any CPU = Release - No Server - Win11|Any CPU
		Release - No Server - Win11|ARM64 = Release - No Server - Win11|ARM64
		Release - No Server - Win11|x64 = Release - No Server - Win11|x64
		Release - No Server - Win11|x86 = Release - No Server - Win11|x86
		Release|Any CPU = Release|Any CPU
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Debug|Any CPU.ActiveCfg = Debug|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Debug|Any CPU.Build.0 = Debug|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Debug|Any CPU.Deploy.0 = Debug|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Debug|ARM64.Build.0 = Debug|ARM64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Debug|x64.ActiveCfg = Debug|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Debug|x64.Build.0 = Debug|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Debug|x64.Deploy.0 = Debug|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Debug|x86.ActiveCfg = Debug|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Debug|x86.Build.0 = Debug|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Debug|x86.Deploy.0 = Debug|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win10|Any CPU.ActiveCfg = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win10|Any CPU.Build.0 = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win10|Any CPU.Deploy.0 = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win10|ARM64.ActiveCfg = Release - Win10|ARM64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win10|ARM64.Build.0 = Release - Win10|ARM64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win10|ARM64.Deploy.0 = Release - Win10|ARM64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win10|x64.ActiveCfg = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win10|x64.Build.0 = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win10|x64.Deploy.0 = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win10|x86.ActiveCfg = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win10|x86.Build.0 = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win10|x86.Deploy.0 = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win11|Any CPU.ActiveCfg = Release - Win11|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win11|Any CPU.Build.0 = Release - Win11|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win11|Any CPU.Deploy.0 = Release - Win11|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win11|ARM64.ActiveCfg = Release - Win10|ARM64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win11|ARM64.Build.0 = Release - Win10|ARM64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win11|ARM64.Deploy.0 = Release - Win10|ARM64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win11|x64.ActiveCfg = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win11|x64.Build.0 = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win11|x64.Deploy.0 = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win11|x86.ActiveCfg = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win11|x86.Build.0 = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release - No Server - Win11|x86.Deploy.0 = Release - Win10|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release|Any CPU.ActiveCfg = Release|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release|Any CPU.Build.0 = Release|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release|Any CPU.Deploy.0 = Release|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release|ARM64.ActiveCfg = Release|ARM64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release|ARM64.Build.0 = Release|ARM64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release|ARM64.Deploy.0 = Release|ARM64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release|x64.ActiveCfg = Release|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release|x64.Build.0 = Release|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release|x64.Deploy.0 = Release|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release|x86.ActiveCfg = Release|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release|x86.Build.0 = Release|x64
		{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}.Release|x86.Deploy.0 = Release|x64
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Debug|ARM64.Build.0 = Debug|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Debug|x64.ActiveCfg = Debug|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Debug|x64.Build.0 = Debug|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Debug|x86.ActiveCfg = Debug|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Debug|x86.Build.0 = Debug|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win10|Any CPU.ActiveCfg = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win10|Any CPU.Build.0 = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win10|ARM64.ActiveCfg = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win10|ARM64.Build.0 = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win10|x64.ActiveCfg = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win10|x64.Build.0 = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win10|x86.ActiveCfg = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win10|x86.Build.0 = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win11|Any CPU.ActiveCfg = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win11|Any CPU.Build.0 = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win11|ARM64.ActiveCfg = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win11|ARM64.Build.0 = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win11|x64.ActiveCfg = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win11|x64.Build.0 = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win11|x86.ActiveCfg = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release - No Server - Win11|x86.Build.0 = Release - No Server|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release|Any CPU.Build.0 = Release|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release|ARM64.ActiveCfg = Release|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release|ARM64.Build.0 = Release|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release|x64.ActiveCfg = Release|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release|x64.Build.0 = Release|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release|x86.ActiveCfg = Release|Any CPU
		{6228E9DD-E1EA-45D8-8054-A00FC2D63414}.Release|x86.Build.0 = Release|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Debug|ARM64.Build.0 = Debug|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Debug|x64.ActiveCfg = Debug|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Debug|x64.Build.0 = Debug|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Debug|x86.ActiveCfg = Debug|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Debug|x86.Build.0 = Debug|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win10|Any CPU.ActiveCfg = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win10|Any CPU.Build.0 = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win10|ARM64.ActiveCfg = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win10|ARM64.Build.0 = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win10|x64.ActiveCfg = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win10|x64.Build.0 = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win10|x86.ActiveCfg = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win10|x86.Build.0 = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win11|Any CPU.ActiveCfg = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win11|Any CPU.Build.0 = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win11|ARM64.ActiveCfg = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win11|ARM64.Build.0 = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win11|x64.ActiveCfg = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win11|x64.Build.0 = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win11|x86.ActiveCfg = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release - No Server - Win11|x86.Build.0 = Release - No Server|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release|Any CPU.Build.0 = Release|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release|ARM64.ActiveCfg = Release|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release|ARM64.Build.0 = Release|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release|x64.ActiveCfg = Release|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release|x64.Build.0 = Release|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release|x86.ActiveCfg = Release|Any CPU
		{4D0777F0-2D3D-4FD7-9C0F-CD4DEC1A99E9}.Release|x86.Build.0 = Release|Any CPU
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Debug|Any CPU.ActiveCfg = Debug|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Debug|Any CPU.Build.0 = Debug|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Debug|Any CPU.Deploy.0 = Debug|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Debug|ARM64.Build.0 = Debug|ARM64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Debug|x64.ActiveCfg = Debug|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Debug|x64.Build.0 = Debug|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Debug|x64.Deploy.0 = Debug|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Debug|x86.ActiveCfg = Debug|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Debug|x86.Build.0 = Debug|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Debug|x86.Deploy.0 = Debug|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win10|Any CPU.ActiveCfg = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win10|Any CPU.Build.0 = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win10|Any CPU.Deploy.0 = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win10|ARM64.ActiveCfg = Release - No Server|ARM64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win10|ARM64.Build.0 = Release - No Server|ARM64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win10|ARM64.Deploy.0 = Release - No Server|ARM64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win10|x64.ActiveCfg = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win10|x64.Build.0 = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win10|x64.Deploy.0 = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win10|x86.ActiveCfg = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win10|x86.Build.0 = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win10|x86.Deploy.0 = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win11|Any CPU.ActiveCfg = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win11|Any CPU.Build.0 = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win11|Any CPU.Deploy.0 = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win11|ARM64.ActiveCfg = Release - No Server|ARM64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win11|ARM64.Build.0 = Release - No Server|ARM64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win11|ARM64.Deploy.0 = Release - No Server|ARM64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win11|x64.ActiveCfg = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win11|x64.Build.0 = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win11|x64.Deploy.0 = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win11|x86.ActiveCfg = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win11|x86.Build.0 = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release - No Server - Win11|x86.Deploy.0 = Release - No Server|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release|Any CPU.ActiveCfg = Release|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release|Any CPU.Build.0 = Release|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release|Any CPU.Deploy.0 = Release|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release|ARM64.ActiveCfg = Release|ARM64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release|ARM64.Build.0 = Release|ARM64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release|ARM64.Deploy.0 = Release|ARM64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release|x64.ActiveCfg = Release|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release|x64.Build.0 = Release|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release|x64.Deploy.0 = Release|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release|x86.ActiveCfg = Release|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release|x86.Build.0 = Release|x64
		{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}.Release|x86.Deploy.0 = Release|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Debug|Any CPU.ActiveCfg = Debug|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Debug|Any CPU.Build.0 = Debug|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Debug|ARM64.ActiveCfg = Debug|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Debug|ARM64.Build.0 = Debug|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Debug|x64.ActiveCfg = Debug|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Debug|x64.Build.0 = Debug|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Debug|x86.ActiveCfg = Debug|Win32
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Debug|x86.Build.0 = Debug|Win32
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win10|Any CPU.ActiveCfg = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win10|Any CPU.Build.0 = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win10|ARM64.ActiveCfg = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win10|ARM64.Build.0 = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win10|x64.ActiveCfg = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win10|x64.Build.0 = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win10|x86.ActiveCfg = Release - No Server|Win32
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win10|x86.Build.0 = Release - No Server|Win32
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win11|Any CPU.ActiveCfg = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win11|Any CPU.Build.0 = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win11|ARM64.ActiveCfg = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win11|ARM64.Build.0 = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win11|x64.ActiveCfg = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win11|x64.Build.0 = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win11|x86.ActiveCfg = Release - No Server|Win32
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release - No Server - Win11|x86.Build.0 = Release - No Server|Win32
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release|Any CPU.ActiveCfg = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release|Any CPU.Build.0 = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release|ARM64.ActiveCfg = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release|ARM64.Build.0 = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release|x64.ActiveCfg = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release|x64.Build.0 = Release - No Server|x64
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release|x86.ActiveCfg = Release - No Server|Win32
		{3B18467A-4358-45EF-81B1-5C6F9B0B6728}.Release|x86.Build.0 = Release - No Server|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5F2C89ED-CBEA-4DAD-8576-94C53821D2E8}
	EndGlobalSection
EndGlobal

```

`dblayout.drawio`:

```drawio
<mxfile host="app.diagrams.net" modified="2023-09-07T11:40:22.850Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36" etag="zxLKc88AkFicnfjyOcSN" version="21.7.2" type="device">
  <diagram name="Page-1" id="lGA2o3BVWdjGpJAT47dB">
    <mxGraphModel dx="1434" dy="790" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="3Gc6Ea0flFLE_1pXqOZ2-15" value="&lt;div style=&quot;box-sizing:border-box;width:100%;background:#e4e4e4;padding:2px;&quot;&gt;User&lt;/div&gt;&lt;table style=&quot;width:100%;font-size:1em;&quot; cellpadding=&quot;2&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;PK&lt;/td&gt;&lt;td&gt;UserId&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FK1&lt;/td&gt;&lt;td&gt;HardwareId&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Steam64Id&lt;br&gt;Banned&lt;br&gt;&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;" style="verticalAlign=top;align=left;overflow=fill;html=1;whiteSpace=wrap;" vertex="1" parent="1">
          <mxGeometry x="60" y="290" width="180" height="145" as="geometry" />
        </mxCell>
        <mxCell id="3Gc6Ea0flFLE_1pXqOZ2-16" value="&lt;div style=&quot;box-sizing:border-box;width:100%;background:#e4e4e4;padding:2px;&quot;&gt;User&lt;/div&gt;&lt;table style=&quot;width:100%;font-size:1em;&quot; cellpadding=&quot;2&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;PK&lt;/td&gt;&lt;td&gt;UserId&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FK1&lt;/td&gt;&lt;td&gt;HardwareId&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;Steam64Id&lt;br&gt;Banned&lt;br&gt;&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;" style="verticalAlign=top;align=left;overflow=fill;html=1;whiteSpace=wrap;" vertex="1" parent="1">
          <mxGeometry x="360" y="290" width="180" height="145" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>

```

`driver/apc.c`:

```c
#include "apc.h"

#include "driver.h"
#include "imports.h"

VOID
GetApcContextByIndex(_Out_ PVOID* Context, _In_ INT Index)
{
    AcquireDriverConfigLock();
    *Context = GetApcContextArray()[Index];
    ReleaseDriverConfigLock();
}

VOID
GetApcContext(_Out_ PVOID* Context, _In_ LONG ContextIdentifier)
{
    AcquireDriverConfigLock();

    for (INT index = 0; index < MAXIMUM_APC_CONTEXTS; index++) {
        PAPC_CONTEXT_HEADER header = GetApcContextArray()[index];

        if (!header)
            continue;

        if (header->context_id != ContextIdentifier)
            continue;

        *Context = header;
        goto unlock;
    }
unlock:
    ReleaseDriverConfigLock();
}

/*
 * No need to hold the lock here as the thread freeing the APCs will
 * already hold the configuration lock. We also dont want to release and
 * reclaim the lock before calling this function since we need to ensure
 * we hold the lock during the entire decrement and free process.
 */
BOOLEAN
FreeApcContextStructure(_Out_ PAPC_CONTEXT_HEADER Context)
{
    DEBUG_VERBOSE("All APCs executed, freeing context structure");

    for (INT index = 0; index < MAXIMUM_APC_CONTEXTS; index++) {
        PUINT64 entry = GetApcContextArray();

        if (entry[index] != Context)
            continue;

        if (Context->count > 0)
            return FALSE;

        ImpExFreePoolWithTag(Context, POOL_TAG_APC);
        entry[index] = NULL;
        return TRUE;
    }

    return FALSE;
}

VOID
IncrementApcCount(_In_ LONG ContextId)
{
    PAPC_CONTEXT_HEADER header = NULL;
    GetApcContext(&header, ContextId);

    if (!header)
        return;

    /* i actually dont think we need this lock here */
    AcquireDriverConfigLock();
    header->count += 1;
    ReleaseDriverConfigLock();
}

VOID
FreeApcAndDecrementApcCount(_Inout_ PRKAPC Apc, _In_ LONG ContextId)
{
    PAPC_CONTEXT_HEADER context = NULL;

    ImpExFreePoolWithTag(Apc, POOL_TAG_APC);
    GetApcContext(&context, ContextId);

    if (!context)
        return;

    AcquireDriverConfigLock();
    context->count -= 1;
    ReleaseDriverConfigLock();
}

/*
 * The reason we use a query model rather then checking the count of queued APCs
 * after each APC free and decrement is that the lock will be recursively
 * acquired by freeing threads (i.e executing APCs) rather then APC allocation
 * threads. The reason for this being that freeing threads are executing at a
 * higher IRQL then the APC allocation thread, hence they are granted higher
 * priority by the scheduler when determining which thread will accquire the
 * lock next:
 *
 * [+] Freeing thread -> ApcKernelRoutine IRQL: 1 (APC_LEVEL)
 * [+] Allocation thread -> ValidateThreadViaKernelApcCallback IRQL: 0
 * (PASSIVE_LEVEL)
 *
 * As a result, once an APC is executed and reaches the freeing stage, it will
 * acquire the lock and decrement it. Then, if atleast 1 APC execution thread is
 * waiting on the lock, it will be prioritised due to its higher IRQL and the
 * cycle will continue. Eventually, the count will reach 0 due to recursive
 * acquisition by the executing APC threads and then the function will free the
 * APC context structure. This will then cause a bug check the next time a
 * thread accesses the context structure and hence not good :c.
 *
 * So to combat this, we add in a flag specifying whether or not an allocation
 * of APCs is in progress, and even if the count is 0 we will not free the
 * context structure until the count is 0 and allocation_in_progress is 0. We
 * can then call this function alongside other query callbacks via IOCTL to
 * constantly monitor the status of open APC contexts.
 */
NTSTATUS
QueryActiveApcContextsForCompletion()
{
    for (INT index = 0; index < MAXIMUM_APC_CONTEXTS; index++) {
        PAPC_CONTEXT_HEADER entry = NULL;
        GetApcContextByIndex(&entry, index);
        AcquireDriverConfigLock();

        if (!entry)
            goto increment;

        if (entry->count > 0 || entry->allocation_in_progress == TRUE)
            goto increment;

        switch (entry->context_id) {
        case APC_CONTEXT_ID_STACKWALK:
            FreeApcStackwalkApcContextInformation(entry);
            FreeApcContextStructure(entry);
            break;
        }

    increment:
        ReleaseDriverConfigLock();
    }
    return STATUS_SUCCESS;
}

VOID
InsertApcContext(_In_ PVOID Context)
{
    if (IsDriverUnloading())
        return STATUS_UNSUCCESSFUL;

    AcquireDriverConfigLock();
    PAPC_CONTEXT_HEADER header = Context;

    for (INT index = 0; index < MAXIMUM_APC_CONTEXTS; index++) {
        PUINT64 entry = GetApcContextArray();

        if (entry[index] == NULL) {
            entry[index] = Context;
            goto end;
        }
    }
end:
    ReleaseDriverConfigLock();
}

/*
 * The driver config structure holds an array of pointers to APC context
 * structures. These APC context structures are unique to each APC operation
 * that this driver will perform. For example, a single context will manage all
 * APCs that are used to stackwalk, whilst another context will be used to
 * manage all APCs used to query a threads memory for example.
 *
 * Due to the nature of APCs, its important to keep a total or count of the
 * number of APCs we have allocated and queued to threads. This information is
 * stored in the APC_CONTEXT_HEADER which all APC context structures will
 * contain as the first entry in their structure. It holds the ContextId which
 * is a unique identifier for the type of APC operation it is managing aswell as
 * the number of currently queued APCs.
 *
 * When an APC is allocated a queued, we increment this count. When an APC is
 * completed and freed, we decrement this counter and free the APC itself. If
 * all APCs have been freed and the counter is 0,the following objects will be
 * freed:
 *
 * 1. Any additional allocations used by the APC stored in the context structure
 * 2. The APC context structure for the given APC operation
 * 3. The APC context entry in g_DriverConfig->>apc_contexts will be zero'd.
 *
 * It's important to remember that the driver can unload when pending APC's have
 * not been freed due to the limitations windows places on APCs, however I am in
 * the process of finding a solution for this.
 */
BOOLEAN
DrvUnloadFreeAllApcContextStructures()
{
    AcquireDriverConfigLock();

    for (INT index = 0; index < MAXIMUM_APC_CONTEXTS; index++) {
        PUINT64 entry = GetApcContextArray();

        if (entry[index] == NULL)
            continue;

        PAPC_CONTEXT_HEADER context = entry[index];

        if (context->count > 0) {
            ReleaseDriverConfigLock();
            return FALSE;
        }

        ImpExFreePoolWithTag(entry, POOL_TAG_APC);
    }
unlock:
    ReleaseDriverConfigLock();
    return TRUE;
}
```

`driver/apc.h`:

```h
#ifndef APC_H
#define APC_H

#include "common.h"

#include "apc.h"

#include "driver.h"
#include "imports.h"

VOID
GetApcContextByIndex(_Out_ PVOID* Context, _In_ INT Index);

VOID
GetApcContext(_Out_ PVOID* Context, _In_ LONG ContextIdentifier);

BOOLEAN
FreeApcContextStructure(_Out_ PAPC_CONTEXT_HEADER Context);

VOID
IncrementApcCount(_In_ LONG ContextId);

VOID
FreeApcAndDecrementApcCount(_Inout_ PRKAPC Apc, _In_ LONG ContextId);

NTSTATUS
QueryActiveApcContextsForCompletion();

VOID
InsertApcContext(_In_ PVOID Context);

BOOLEAN
DrvUnloadFreeAllApcContextStructures();

#endif
```

`driver/arch.asm`:

```asm
.code


; Tests the emulation of the INVD instruction
;
; source and references:
;
; https://secret.club/2020/04/13/how-anti-cheats-detect-system-emulation.html#invdwbinvd
; https://www.felixcloutier.com/x86/invd
; https://www.felixcloutier.com/x86/wbinvd
;
; Returns int

TestINVDEmulation PROC

	pushfq
	cli
	push 1					; push some dummy data onto the stack which will exist in writeback cache
	wbinvd					; flush the internal cpu caches and write back all modified cache 
							; lines to main memory
	mov byte ptr [rsp], 0	; set our dummy value to 0, this takes place inside writeback memory
	invd					; flush the internal caches, however this instruction will not write 
							; back to system memory as opposed to wbinvd, meaning our previous 
							; instruction which only operated on cached writeback data and not
							; system memory has been invalidated. 
	pop rax					; on a real system as a result of our data update instruction being
							; invalidated, the result will be 1. On a system that does not
							; properly implement INVD, the result will be 0 as the instruction does
							; not properly flush the caches.
	xor rax, 1				; invert result so function returns same way as all verification methods
	popfq
	ret

TestINVDEmulation ENDP

END
```

`driver/callbacks.c`:

```c
#include "callbacks.h"

#include "driver.h"

#include "queue.h"
#include "pool.h"
#include "thread.h"
#include "modules.h"
#include "imports.h"
#include "list.h"
#include "session.h"

STATIC
BOOLEAN
EnumHandleCallback(_In_ PHANDLE_TABLE       HandleTable,
                   _In_ PHANDLE_TABLE_ENTRY Entry,
                   _In_ HANDLE              Handle,
                   _In_ PVOID               Context);

#ifdef ALLOC_PRAGMA
#    pragma alloc_text(PAGE, ObPostOpCallbackRoutine)
#    pragma alloc_text(PAGE, ObPreOpCallbackRoutine)
#    pragma alloc_text(PAGE, EnumHandleCallback)
#    pragma alloc_text(PAGE, EnumerateProcessHandles)
#    pragma alloc_text(PAGE, InitialiseThreadList)
#    pragma alloc_text(PAGE, ExUnlockHandleTableEntry)
#endif

/*
 * Its important on unload we dereference any objects to ensure the kernels
 * reference count remains correct.
 */
VOID
CleanupProcessListFreeCallback(_In_ PPROCESS_LIST_ENTRY ProcessListEntry)
{
    ImpObDereferenceObject(ProcessListEntry->parent);
    ImpObDereferenceObject(ProcessListEntry->process);
}

VOID
CleanupThreadListFreeCallback(_In_ PTHREAD_LIST_ENTRY ThreadListEntry)
{
    ImpObDereferenceObject(ThreadListEntry->thread);
    ImpObDereferenceObject(ThreadListEntry->owning_process);
}

VOID
UnregisterProcessCreateNotifyRoutine()
{
    PPROCESS_LIST_HEAD list = GetProcessList();
    InterlockedExchange(&list->active, FALSE);
    ImpPsSetCreateProcessNotifyRoutine(ProcessCreateNotifyRoutine, TRUE);
}

VOID
UnregisterImageLoadNotifyRoutine()
{
    PDRIVER_LIST_HEAD list = GetDriverList();
    InterlockedExchange(&list->active, FALSE);
    PsRemoveLoadImageNotifyRoutine(ImageLoadNotifyRoutineCallback);
}

VOID
UnregisterThreadCreateNotifyRoutine()
{
    PTHREAD_LIST_HEAD list = GetThreadList();
    InterlockedExchange(&list->active, FALSE);
    ImpPsRemoveCreateThreadNotifyRoutine(ThreadCreateNotifyRoutine);
}

/*
 * While ExDeleteLookasideListEx already frees each item, we wanna allow
 * ourselves to reduce the reference count to any objects we are referencing.
 */
VOID
CleanupProcessListOnDriverUnload()
{
    PPROCESS_LIST_HEAD list = GetProcessList();
    DEBUG_VERBOSE("Freeing process list");
    for (;;) {
        if (!LookasideListFreeFirstEntry(
                &list->start, &list->lock, CleanupProcessListFreeCallback)) {
            ExDeleteLookasideListEx(&list->lookaside_list);
            return;
        }
    }
}

VOID
CleanupThreadListOnDriverUnload()
{
    PTHREAD_LIST_HEAD list = GetThreadList();
    DEBUG_VERBOSE("Freeing thread list!");
    for (;;) {
        if (!LookasideListFreeFirstEntry(
                &list->start, &list->lock, CleanupThreadListFreeCallback)) {
            ExDeleteLookasideListEx(&list->lookaside_list);
            return;
        }
    }
}

VOID
CleanupDriverListOnDriverUnload()
{
    PDRIVER_LIST_HEAD list = GetDriverList();
    for (;;) {
        if (!ListFreeFirstEntry(&list->start, &list->lock, NULL))
            return;
    }
}

VOID
EnumerateThreadListWithCallbackRoutine(
    _In_ THREADLIST_CALLBACK_ROUTINE CallbackRoutine, _In_opt_ PVOID Context)
{
    PTHREAD_LIST_HEAD list = GetThreadList();
    ImpKeAcquireGuardedMutex(&list->lock);

    if (!CallbackRoutine)
        goto unlock;

    PTHREAD_LIST_ENTRY entry = list->start.Next;

    while (entry) {
        CallbackRoutine(entry, Context);
        entry = entry->list.Next;
    }

unlock:
    ImpKeReleaseGuardedMutex(&list->lock);
}

VOID
EnumerateProcessListWithCallbackRoutine(
    _In_ PROCESSLIST_CALLBACK_ROUTINE CallbackRoutine, _In_opt_ PVOID Context)
{
    PPROCESS_LIST_HEAD list = GetProcessList();
    ImpKeAcquireGuardedMutex(&list->lock);

    if (!CallbackRoutine)
        goto unlock;

    PPROCESS_LIST_ENTRY entry = list->start.Next;

    while (entry) {
        CallbackRoutine(entry, Context);
        entry = entry->list.Next;
    }

unlock:
    ImpKeReleaseGuardedMutex(&list->lock);
}

VOID
EnumerateDriverListWithCallbackRoutine(
    _In_ DRIVERLIST_CALLBACK_ROUTINE CallbackRoutine, _In_opt_ PVOID Context)
{
    PDRIVER_LIST_HEAD list = GetDriverList();
    ImpKeAcquireGuardedMutex(&list->lock);

    if (!CallbackRoutine)
        goto unlock;

    PDRIVER_LIST_ENTRY entry = list->start.Next;

    while (entry) {
        CallbackRoutine(entry, Context);
        entry = entry->list.Next;
    }

unlock:
    ImpKeReleaseGuardedMutex(&list->lock);
}

VOID
DriverListEntryToExtendedModuleInfo(_In_ PDRIVER_LIST_ENTRY         Entry,
                                    _Out_ PRTL_MODULE_EXTENDED_INFO Extended)
{
    Extended->ImageBase = Entry->ImageBase;
    Extended->ImageSize = Entry->ImageSize;
    RtlCopyMemory(
        Extended->FullPathName, Entry->path, sizeof(Extended->FullPathName));
}

NTSTATUS
InitialiseDriverList()
{
    PAGED_CODE();

    NTSTATUS                  status       = STATUS_UNSUCCESSFUL;
    SYSTEM_MODULES            modules      = {0};
    PDRIVER_LIST_ENTRY        entry        = NULL;
    PRTL_MODULE_EXTENDED_INFO module_entry = NULL;
    PDRIVER_LIST_HEAD         list         = GetDriverList();

    InterlockedExchange(&list->active, TRUE);
    ListInit(&list->start, &list->lock);
    InitializeListHead(&list->deferred_list);

    list->can_hash_x86       = FALSE;
    list->deferred_work_item = IoAllocateWorkItem(GetDriverDeviceObject());

    if (!list->deferred_work_item)
        return STATUS_INSUFFICIENT_RESOURCES;

    status = GetSystemModuleInformation(&modules);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetSystemModuleInformation failed with status %x", status);
        return status;
    }

    /* skip hal.dll and ntoskrnl.exe */
    for (INT index = 2; index < modules.module_count; index++) {
        entry = ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                                   sizeof(DRIVER_LIST_ENTRY),
                                   POOL_TAG_DRIVER_LIST);

        if (!entry)
            continue;

        module_entry = &((PRTL_MODULE_EXTENDED_INFO)modules.address)[index];

        entry->hashed    = TRUE;
        entry->ImageBase = module_entry->ImageBase;
        entry->ImageSize = module_entry->ImageSize;

        RtlCopyMemory(entry->path,
                      module_entry->FullPathName,
                      sizeof(module_entry->FullPathName));

        status = HashModule(module_entry, entry->text_hash);

        if (status == STATUS_INVALID_IMAGE_WIN_32) {
            DEBUG_ERROR("32 bit module not hashed, will hash later. %x",
                        status);
            entry->hashed = FALSE;
            entry->x86    = TRUE;
            InsertHeadList(&list->deferred_list, &entry->deferred_entry);
        }
        else if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("HashModule failed with status %x", status);
            entry->hashed = FALSE;
        }

        ListInsert(&list->start, entry, &list->lock);
    }

    list->active = TRUE;

end:
    if (modules.address)
        ImpExFreePoolWithTag(modules.address, SYSTEM_MODULES_POOL);

    return STATUS_SUCCESS;
}

/*
 * I actually think a spinlock here for the driver list is what we want rather
 * then a mutex, but implementing a spinlock has its challenges... todo: have a
 * think!
 */
VOID
FindDriverEntryByBaseAddress(_In_ PVOID                ImageBase,
                             _Out_ PDRIVER_LIST_ENTRY* Entry)
{
    PDRIVER_LIST_HEAD list = GetDriverList();
    ImpKeAcquireGuardedMutex(&list->lock);
    *Entry = NULL;

    PDRIVER_LIST_ENTRY entry = (PDRIVER_LIST_ENTRY)list->start.Next;

    while (entry) {
        if (entry->ImageBase == ImageBase) {
            *Entry = entry;
            goto unlock;
        }

        entry = entry->list.Next;
    }
unlock:
    ImpKeReleaseGuardedMutex(&list->lock);
}

VOID
ImageLoadNotifyRoutineCallback(_In_opt_ PUNICODE_STRING FullImageName,
                               _In_ HANDLE              ProcessId,
                               _In_ PIMAGE_INFO         ImageInfo)
{
    NTSTATUS                 status             = STATUS_UNSUCCESSFUL;
    PDRIVER_LIST_ENTRY       entry              = NULL;
    RTL_MODULE_EXTENDED_INFO module             = {0};
    PDRIVER_LIST_HEAD        list               = GetDriverList();
    ANSI_STRING              ansi_path          = {0};
    UINT32                   ansi_string_length = 0;

    if (InterlockedExchange(&list->active, list->active) == FALSE)
        return;

    if (ImageInfo->SystemModeImage == FALSE)
        return;

    FindDriverEntryByBaseAddress(ImageInfo->ImageBase, &entry);

    if (entry)
        return;

    entry = ExAllocatePool2(
        POOL_FLAG_NON_PAGED, sizeof(DRIVER_LIST_ENTRY), POOL_TAG_DRIVER_LIST);

    if (!entry)
        return;

    entry->hashed    = TRUE;
    entry->x86       = FALSE;
    entry->ImageBase = ImageInfo->ImageBase;
    entry->ImageSize = ImageInfo->ImageSize;

    module.ImageBase = ImageInfo->ImageBase;
    module.ImageSize = ImageInfo->ImageSize;

    if (FullImageName) {
        status = RtlUnicodeStringToAnsiString(&ansi_path, FullImageName, TRUE);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("RtlUnicodeStringToAnsiString failed with status %x",
                        status);
            goto hash;
        }

        if (ansi_path.Length > sizeof(module.FullPathName)) {
            RtlFreeAnsiString(&ansi_path);
            goto hash;
        }

        RtlCopyMemory(module.FullPathName, ansi_path.Buffer, ansi_path.Length);
        RtlCopyMemory(entry->path, ansi_path.Buffer, ansi_path.Length);

        RtlFreeAnsiString(&ansi_path);
    }

    DEBUG_VERBOSE("New system image ansi: %s", entry->path);

hash:
    status = HashModule(&module, &entry->text_hash);

    if (status == STATUS_INVALID_IMAGE_WIN_32) {
        DEBUG_ERROR("32 bit module not hashed, will hash later. %x", status);
        entry->x86    = TRUE;
        entry->hashed = FALSE;
    }
    else if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("HashModule failed with status %x", status);
        entry->hashed = FALSE;
    }

    ListInsert(&list->start, entry, &list->lock);
}

NTSTATUS
InitialiseProcessList()
{
    NTSTATUS           status = STATUS_UNSUCCESSFUL;
    PPROCESS_LIST_HEAD list   = GetProcessList();

    status = ExInitializeLookasideListEx(&list->lookaside_list,
                                         NULL,
                                         NULL,
                                         POOL_NX_ALLOCATION,
                                         0,
                                         sizeof(PROCESS_LIST_ENTRY),
                                         POOL_TAG_PROCESS_LIST,
                                         0);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ExInitializeLookasideListEx failed with status %x",
                    status);
        return status;
    }

    InterlockedExchange(&list->active, TRUE);
    ListInit(&list->start, &list->lock);
    return status;
}

NTSTATUS
InitialiseThreadList()
{
    NTSTATUS          status = STATUS_UNSUCCESSFUL;
    PTHREAD_LIST_HEAD list   = GetThreadList();

    status = ExInitializeLookasideListEx(&list->lookaside_list,
                                         NULL,
                                         NULL,
                                         POOL_NX_ALLOCATION,
                                         0,
                                         sizeof(THREAD_LIST_ENTRY),
                                         POOL_TAG_PROCESS_LIST,
                                         0);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ExInitializeLookasideListEx failed with status %x",
                    status);
        return status;
    }

    InterlockedExchange(&list->active, TRUE);
    ListInit(&list->start, &list->lock);
    return status;
}

VOID
FindProcessListEntryByProcess(_In_ PKPROCESS             Process,
                              _Out_ PPROCESS_LIST_ENTRY* Entry)
{
    PPROCESS_LIST_HEAD list = GetProcessList();
    ImpKeAcquireGuardedMutex(&list->lock);
    *Entry = NULL;

    PPROCESS_LIST_ENTRY entry = (PPROCESS_LIST_ENTRY)list->start.Next;

    while (entry) {
        if (entry->process == Process) {
            *Entry = entry;
            goto unlock;
        }

        entry = entry->list.Next;
    }
unlock:
    ImpKeReleaseGuardedMutex(&list->lock);
}

VOID
FindThreadListEntryByThreadAddress(_In_ PKTHREAD             Thread,
                                   _Out_ PTHREAD_LIST_ENTRY* Entry)
{
    PTHREAD_LIST_HEAD list = GetThreadList();
    ImpKeAcquireGuardedMutex(&list->lock);
    *Entry = NULL;

    PTHREAD_LIST_ENTRY entry = (PTHREAD_LIST_ENTRY)list->start.Next;

    while (entry) {
        if (entry->thread == Thread) {
            *Entry = entry;
            goto unlock;
        }

        entry = entry->list.Next;
    }
unlock:
    ImpKeReleaseGuardedMutex(&list->lock);
}

VOID
ProcessCreateNotifyRoutine(_In_ HANDLE  ParentId,
                           _In_ HANDLE  ProcessId,
                           _In_ BOOLEAN Create)
{
    PPROCESS_LIST_ENTRY entry        = NULL;
    PKPROCESS           parent       = NULL;
    PKPROCESS           process      = NULL;
    PPROCESS_LIST_HEAD  list         = GetProcessList();
    PDRIVER_LIST_HEAD   driver_list  = GetDriverList();
    LPCSTR              process_name = NULL;

    if (!list->active)
        return;

    ImpPsLookupProcessByProcessId(ParentId, &parent);
    ImpPsLookupProcessByProcessId(ProcessId, &process);

    if (!parent || !process)
        return;

    process_name = ImpPsGetProcessImageFileName(process);

    if (Create) {
        entry = ExAllocateFromLookasideListEx(&list->lookaside_list);

        if (!entry)
            return;

        ImpObfReferenceObject(parent);
        ImpObfReferenceObject(process);

        entry->parent  = parent;
        entry->process = process;

        ListInsert(&list->start, entry, &list->lock);

        /*
         * Notify to our driver that we can hash x86 modules, and hash
         * any x86 modules that werent hashed.
         */
        if (!strcmp(process_name, "winlogon.exe")) {
            driver_list->can_hash_x86 = TRUE;
            IoQueueWorkItem(driver_list->deferred_work_item,
                            DeferredModuleHashingCallback,
                            NormalWorkQueue,
                            NULL);
        }
    }
    else {
        FindProcessListEntryByProcess(process, &entry);

        if (!entry)
            return;

        ImpObDereferenceObject(entry->parent);
        ImpObDereferenceObject(entry->process);

        LookasideListRemoveEntry(&list->start, entry, &list->lock);
    }
}

VOID
ThreadCreateNotifyRoutine(_In_ HANDLE  ProcessId,
                          _In_ HANDLE  ThreadId,
                          _In_ BOOLEAN Create)
{
    PTHREAD_LIST_ENTRY entry   = NULL;
    PKTHREAD           thread  = NULL;
    PKPROCESS          process = NULL;
    PTHREAD_LIST_HEAD  list    = GetThreadList();

    /* ensure we don't insert new entries if we are unloading */
    if (!list->active)
        return;

    ImpPsLookupThreadByThreadId(ThreadId, &thread);
    ImpPsLookupProcessByProcessId(ProcessId, &process);

    if (!thread || !process)
        return;

    if (Create) {
        entry = ExAllocateFromLookasideListEx(&list->lookaside_list);

        if (!entry)
            return;

        ImpObfReferenceObject(thread);
        ImpObfReferenceObject(process);

        entry->thread         = thread;
        entry->owning_process = process;
        entry->apc            = NULL;
        entry->apc_queued     = FALSE;

        ListInsert(&list->start, &entry->list, &list->lock);
    }
    else {
        FindThreadListEntryByThreadAddress(thread, &entry);

        if (!entry)
            return;

        ImpObDereferenceObject(entry->thread);
        ImpObDereferenceObject(entry->owning_process);

        LookasideListRemoveEntry(&list->start, entry, &list->lock);
    }
}

VOID
ObPostOpCallbackRoutine(_In_ PVOID RegistrationContext,
                        _In_ POB_POST_OPERATION_INFORMATION
                            OperationInformation)
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(RegistrationContext);
    UNREFERENCED_PARAMETER(OperationInformation);
}

// https://www.sysnative.com/forums/threads/object-headers-handles-and-types.34987/
#define GET_OBJECT_HEADER_FROM_HANDLE(x) ((x << 4) | 0xffff000000000000);

OB_PREOP_CALLBACK_STATUS
ObPreOpCallbackRoutine(_In_ PVOID                         RegistrationContext,
                       _In_ POB_PRE_OPERATION_INFORMATION OperationInformation)
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(RegistrationContext);

    /* access mask to completely strip permissions */
    ACCESS_MASK deny_access = SYNCHRONIZE | PROCESS_TERMINATE;

    /*
     * This callback routine is executed in the context of the thread that
     * is requesting to open said handle
     */
    PEPROCESS process_creator        = PsGetCurrentProcess();
    PEPROCESS protected_process      = NULL;
    PEPROCESS target_process         = (PEPROCESS)OperationInformation->Object;
    HANDLE    process_creator_id     = ImpPsGetProcessId(process_creator);
    LONG      protected_process_id   = 0;
    LPCSTR    process_creator_name   = NULL;
    LPCSTR    target_process_name    = NULL;
    LPCSTR    protected_process_name = NULL;
    POB_CALLBACKS_CONFIG configuration = NULL;

    /*
     * This is to prevent the condition where the thread executing this
     * function is scheduled whilst we are cleaning up the callbacks on
     * driver unload. We must hold the driver config lock to ensure the pool
     * containing the callback configuration lock is not freed
     */
    SessionGetCallbackConfiguration(&configuration);

    if (!configuration)
        return OB_PREOP_SUCCESS;

    ImpKeAcquireGuardedMutex(&configuration->lock);
    SessionGetProcessId(&protected_process_id);
    SessionGetProcess(&protected_process);

    if (!protected_process_id || !protected_process)
        goto end;

    process_creator_name   = ImpPsGetProcessImageFileName(process_creator);
    target_process_name    = ImpPsGetProcessImageFileName(target_process);
    protected_process_name = ImpPsGetProcessImageFileName(protected_process);

    if (!protected_process_name || !target_process_name)
        goto end;

    if (strcmp(protected_process_name, target_process_name))
        goto end;
    /*
     * WerFault is some windows 11 application that cries when it
     * cant get a handle, so well allow it for now... todo; learn
     * more about it
     *
     * todo: perform stricter checks rather then the image name.
     * perhapds check some certificate or something.
     */
    if (!strcmp(process_creator_name, "lsass.exe") ||
        !strcmp(process_creator_name, "csrss.exe") ||
        !strcmp(process_creator_name, "WerFault.exe") ||
        !strcmp(process_creator_name, "MsMpEng.exe") ||
        !strcmp(process_creator_name, target_process_name)) {
        /* We will downgrade these handles later */
        // DEBUG_LOG("Handles created by CSRSS, LSASS and
        // WerFault are allowed for now...");
    }
    else if (target_process == process_creator) {
        // DEBUG_LOG("handles made by NOTEPAD r okay :)");
        /* handles created by the game (notepad) are okay */
    }
    else {
        OperationInformation->Parameters->CreateHandleInformation
            .DesiredAccess = deny_access;
        OperationInformation->Parameters->DuplicateHandleInformation
            .DesiredAccess = deny_access;

        /*
         * These processes will constantly open handles to any
         * open process for various reasons, so we will still
         * strip them but we won't report them.. for now
         * atleast.
         */

        if (!strcmp(process_creator_name, "Discord.exe") ||
            !strcmp(process_creator_name, "svchost.exe") ||
            !strcmp(process_creator_name, "explorer.exe"))
            goto end;

        // POPEN_HANDLE_FAILURE_REPORT report =
        //     ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
        //                        sizeof(OPEN_HANDLE_FAILURE_REPORT),
        //                        REPORT_POOL_TAG);

        // if (!report)
        //         goto end;

        // report->report_code      =
        // REPORT_ILLEGAL_HANDLE_OPERATION;
        // report->is_kernel_handle =
        // OperationInformation->KernelHandle;
        // report->process_id       = process_creator_id;
        // report->thread_id        = ImpPsGetCurrentThreadId();
        // report->access =
        //     OperationInformation->Parameters->CreateHandleInformation.DesiredAccess;

        // RtlCopyMemory(report->process_name,
        //               process_creator_name,
        //               HANDLE_REPORT_PROCESS_NAME_MAX_LENGTH);

        // if (!NT_SUCCESS(
        //         IrpQueueCompleteIrp(report,
        //         sizeof(OPEN_HANDLE_FAILURE_REPORT))))
        //{
        //         DEBUG_ERROR("IrpQueueCompleteIrp failed with
        //         no status."); goto end;
        // }
    }

end:

    ImpKeReleaseGuardedMutex(&configuration->lock);
    return OB_PREOP_SUCCESS;
}

/* stolen from ReactOS xD */
VOID NTAPI
ExUnlockHandleTableEntry(IN PHANDLE_TABLE       HandleTable,
                         IN PHANDLE_TABLE_ENTRY HandleTableEntry)
{
    INT64 old_value;
    PAGED_CODE();

    /* Set the lock bit and make sure it wasn't earlier */
    old_value = InterlockedOr((PLONG)&HandleTableEntry->VolatileLowValue, 1);

    /* Unblock any waiters */
    ImpExfUnblockPushLock(&HandleTable->HandleContentionEvent, NULL);
}

static UNICODE_STRING OBJECT_TYPE_PROCESS = RTL_CONSTANT_STRING(L"Process");
static UNICODE_STRING OBJECT_TYPE_THREAD  = RTL_CONSTANT_STRING(L"Thread");

STATIC
BOOLEAN
EnumHandleCallback(_In_ PHANDLE_TABLE       HandleTable,
                   _In_ PHANDLE_TABLE_ENTRY Entry,
                   _In_ HANDLE              Handle,
                   _In_ PVOID               Context)
{
    PAGED_CODE();

    PVOID        object                 = NULL;
    PVOID        object_header          = NULL;
    POBJECT_TYPE object_type            = NULL;
    PEPROCESS    process                = NULL;
    PEPROCESS    protected_process      = NULL;
    LPCSTR       process_name           = NULL;
    LPCSTR       protected_process_name = NULL;
    ACCESS_MASK  handle_access_mask     = 0;

    object_header = GET_OBJECT_HEADER_FROM_HANDLE(Entry->ObjectPointerBits);

    /* Object header is the first 30 bytes of the object */
    object = (uintptr_t)object_header + OBJECT_HEADER_SIZE;

    object_type = ImpObGetObjectType(object);

    /* TODO: check for threads aswell */
    if (ImpRtlCompareUnicodeString(
            &object_type->Name, &OBJECT_TYPE_PROCESS, TRUE)) {
        goto end;
    }

    process      = (PEPROCESS)object;
    process_name = ImpPsGetProcessImageFileName(process);

    SessionGetProcess(&protected_process);

    protected_process_name = ImpPsGetProcessImageFileName(protected_process);

    if (strcmp(process_name, protected_process_name))
        goto end;

    DEBUG_VERBOSE(
        "Handle references our protected process with access mask: %lx",
        (ACCESS_MASK)Entry->GrantedAccessBits);

    handle_access_mask = (ACCESS_MASK)Entry->GrantedAccessBits;

    /* These permissions can be stripped from every process
     * including CSRSS and LSASS */
    if (handle_access_mask & PROCESS_CREATE_PROCESS) {
        Entry->GrantedAccessBits &= ~PROCESS_CREATE_PROCESS;
        DEBUG_VERBOSE("Stripped PROCESS_CREATE_PROCESS");
    }

    if (handle_access_mask & PROCESS_CREATE_THREAD) {
        Entry->GrantedAccessBits &= ~PROCESS_CREATE_THREAD;
        DEBUG_VERBOSE("Stripped PROCESS_CREATE_THREAD");
    }

    if (handle_access_mask & PROCESS_DUP_HANDLE) {
        Entry->GrantedAccessBits &= ~PROCESS_DUP_HANDLE;
        DEBUG_VERBOSE("Stripped PROCESS_DUP_HANDLE");
    }

    if (handle_access_mask & PROCESS_QUERY_INFORMATION) {
        Entry->GrantedAccessBits &= ~PROCESS_QUERY_INFORMATION;
        DEBUG_VERBOSE("Stripped PROCESS_QUERY_INFORMATION");
    }

    if (handle_access_mask & PROCESS_QUERY_LIMITED_INFORMATION) {
        Entry->GrantedAccessBits &= ~PROCESS_QUERY_LIMITED_INFORMATION;
        DEBUG_VERBOSE("Stripped PROCESS_QUERY_LIMITED_INFORMATION");
    }

    if (handle_access_mask & PROCESS_VM_READ) {
        Entry->GrantedAccessBits &= ~PROCESS_VM_READ;
        DEBUG_VERBOSE("Stripped PROCESS_VM_READ");
    }

    if (!strcmp(process_name, "csrss.exe") ||
        !strcmp(process_name, "lsass.exe")) {
        DEBUG_VERBOSE(
            "Required system process allowed, only stripping some permissions");
        goto end;
    }

    /* Permissions beyond here can only be stripped from non
     * critical processes */
    if (handle_access_mask & PROCESS_SET_INFORMATION) {
        Entry->GrantedAccessBits &= ~PROCESS_SET_INFORMATION;
        DEBUG_VERBOSE("Stripped PROCESS_SET_INFORMATION");
    }

    if (handle_access_mask & PROCESS_SET_QUOTA) {
        Entry->GrantedAccessBits &= ~PROCESS_SET_QUOTA;
        DEBUG_VERBOSE("Stripped PROCESS_SET_QUOTA");
    }

    if (handle_access_mask & PROCESS_SUSPEND_RESUME) {
        Entry->GrantedAccessBits &= ~PROCESS_SUSPEND_RESUME;
        DEBUG_VERBOSE("Stripped PROCESS_SUSPEND_RESUME ");
    }

    if (handle_access_mask & PROCESS_TERMINATE) {
        Entry->GrantedAccessBits &= ~PROCESS_TERMINATE;
        DEBUG_VERBOSE("Stripped PROCESS_TERMINATE");
    }

    if (handle_access_mask & PROCESS_VM_OPERATION) {
        Entry->GrantedAccessBits &= ~PROCESS_VM_OPERATION;
        DEBUG_VERBOSE("Stripped PROCESS_VM_OPERATION");
    }

    if (handle_access_mask & PROCESS_VM_WRITE) {
        Entry->GrantedAccessBits &= ~PROCESS_VM_WRITE;
        DEBUG_VERBOSE("Stripped PROCESS_VM_WRITE");
    }

    POPEN_HANDLE_FAILURE_REPORT report =
        ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                           sizeof(OPEN_HANDLE_FAILURE_REPORT),
                           REPORT_POOL_TAG);

    if (!report)
        goto end;

    /*
     * Using the same report structure as the ObRegisterCallbacks
     * report since both of these reports are closely related by the
     * fact they are triggered by a process either opening a handle
     * to our protected process or have a valid open handle to it. I
     * also don't think its worth creating another queue
     * specifically for open handle reports since they will be rare.
     */
    report->report_code      = REPORT_ILLEGAL_HANDLE_OPERATION;
    report->is_kernel_handle = 0;
    report->process_id       = ImpPsGetProcessId(process);
    report->thread_id        = 0;
    report->access           = handle_access_mask;

    RtlCopyMemory(&report->process_name,
                  process_name,
                  HANDLE_REPORT_PROCESS_NAME_MAX_LENGTH);

    if (!NT_SUCCESS(
            IrpQueueCompleteIrp(report, sizeof(OPEN_HANDLE_FAILURE_REPORT)))) {
        DEBUG_ERROR("IrpQueueCompleteIrp failed with no status.");
        goto end;
    }

end:
    ExUnlockHandleTableEntry(HandleTable, Entry);
    return FALSE;
}

NTSTATUS
EnumerateProcessHandles(_In_ PPROCESS_LIST_ENTRY ProcessListEntry,
                        _In_opt_ PVOID           Context)
{
    /* Handles are stored in pageable memory */
    PAGED_CODE();

    UNREFERENCED_PARAMETER(Context);

    if (!ProcessListEntry)
        return STATUS_INVALID_PARAMETER;

    if (ProcessListEntry->process == PsInitialSystemProcess)
        return STATUS_SUCCESS;

    PHANDLE_TABLE handle_table =
        *(PHANDLE_TABLE*)((uintptr_t)ProcessListEntry->process +
                          EPROCESS_HANDLE_TABLE_OFFSET);

    if (!handle_table)
        return STATUS_INVALID_ADDRESS;

    if (!ImpMmIsAddressValid(handle_table))
        return STATUS_INVALID_ADDRESS;

#pragma warning(push)
#pragma warning(suppress : 6387)

    BOOLEAN result =
        ImpExEnumHandleTable(handle_table, EnumHandleCallback, NULL, NULL);

#pragma warning(pop)

    return STATUS_SUCCESS;
}

#define REPEAT_TIME_10_SEC 10000

ULONG value = 10;

VOID
TimerObjectWorkItemRoutine(_In_ PDEVICE_OBJECT DeviceObject,
                           _In_opt_ PVOID      Context)
{
    NTSTATUS          status = STATUS_UNSUCCESSFUL;
    PTIMER_OBJECT     timer  = (PTIMER_OBJECT)Context;
    PDRIVER_LIST_HEAD list   = GetDriverList();

    if (!list->active)
        goto end;

    DEBUG_VERBOSE("Integrity check timer callback invoked.");

    if (!ValidateOurDriversDispatchRoutines()) {
        DEBUG_VERBOSE("l");
    }

    status = ValidateOurDriverImage();

    if (!NT_SUCCESS(status))
        DEBUG_ERROR("ValidateOurDriverImage failed with status %x", status);

end:
    InterlockedExchange(&timer->state, FALSE);
}

/*
 * This routine is executed every x seconds, and is run at IRQL = DISPATCH_LEVEL
 */
VOID
TimerObjectCallbackRoutine(_In_ PKDPC     Dpc,
                           _In_opt_ PVOID DeferredContext,
                           _In_opt_ PVOID SystemArgument1,
                           _In_opt_ PVOID SystemArgument2)
{
    PTIMER_OBJECT timer = (PTIMER_OBJECT)DeferredContext;

    if (!HasDriverLoaded())
        return;

    /* we dont want to queue our work item if it hasnt executed */
    if (timer->state)
        return;

    /* we queue a work item because DPCs run at IRQL = DISPATCH_LEVEL and we
     * need certain routines which cannot be run at an IRQL this high.*/
    InterlockedExchange(&timer->state, TRUE);
    IoQueueWorkItem(timer->work_item,
                    TimerObjectWorkItemRoutine,
                    BackgroundWorkQueue,
                    timer);
}

NTSTATUS
InitialiseTimerObject(_Out_ PTIMER_OBJECT Timer)
{
    LARGE_INTEGER due_time = {0};
    LONG          period   = 0;

    due_time.QuadPart = ABSOLUTE(SECONDS(5));

    Timer->work_item = IoAllocateWorkItem(GetDriverDeviceObject());

    if (!Timer->work_item)
        return STATUS_MEMORY_NOT_ALLOCATED;

    KeInitializeDpc(&Timer->dpc, TimerObjectCallbackRoutine, Timer);
    KeInitializeTimer(&Timer->timer);
    KeSetTimerEx(&Timer->timer, due_time, REPEAT_TIME_10_SEC, &Timer->dpc);

    DEBUG_VERBOSE("Successfully initialised global timer callback.");
    return STATUS_SUCCESS;
}

VOID
CleanupDriverTimerObjects(_Out_ PTIMER_OBJECT Timer)
{
    /* this routine blocks until all queued DPCs on all processors have
     * executed. */
    KeFlushQueuedDpcs();

    /* wait for our work item to complete */
    while (Timer->state)
        YieldProcessor();

    /* now its safe to free and cancel our timers, pools etc. */
    KeCancelTimer(&Timer->timer);
    IoFreeWorkItem(Timer->work_item);

    DEBUG_VERBOSE("Freed timer objects.");
}

VOID
UnregisterProcessObCallbacks()
{
    PAGED_CODE();
    PACTIVE_SESSION config = GetActiveSession();
    AcquireDriverConfigLock();

    if (config->callback_configuration.registration_handle) {
        ImpObUnRegisterCallbacks(
            config->callback_configuration.registration_handle);
        config->callback_configuration.registration_handle = NULL;
    }

    ReleaseDriverConfigLock();
}

NTSTATUS
RegisterProcessObCallbacks()
{
    PAGED_CODE();

    NTSTATUS        status = STATUS_UNSUCCESSFUL;
    PACTIVE_SESSION config = GetActiveSession();

    DEBUG_VERBOSE("Enabling ObRegisterCallbacks.");
    AcquireDriverConfigLock();

    OB_CALLBACK_REGISTRATION          callback_registration  = {0};
    OB_OPERATION_REGISTRATION         operation_registration = {0};
    PCREATE_PROCESS_NOTIFY_ROUTINE_EX notify_routine         = {0};

    operation_registration.ObjectType = PsProcessType;
    operation_registration.Operations |= OB_OPERATION_HANDLE_CREATE;
    operation_registration.Operations |= OB_OPERATION_HANDLE_DUPLICATE;
    operation_registration.PreOperation  = ObPreOpCallbackRoutine;
    operation_registration.PostOperation = ObPostOpCallbackRoutine;

    callback_registration.Version               = OB_FLT_REGISTRATION_VERSION;
    callback_registration.OperationRegistration = &operation_registration;
    callback_registration.OperationRegistrationCount = 1;
    callback_registration.RegistrationContext        = NULL;

    status = ImpObRegisterCallbacks(
        &callback_registration,
        &config->callback_configuration.registration_handle);

    if (!NT_SUCCESS(status))
        DEBUG_ERROR("ObRegisterCallbacks failed with status %x", status);

    ReleaseDriverConfigLock();
    return status;
}

VOID
InitialiseObCallbacksConfiguration(_Out_ PACTIVE_SESSION ProcessConfig)
{
    ImpKeInitializeGuardedMutex(&ProcessConfig->callback_configuration.lock);
}
```

`driver/callbacks.h`:

```h
#ifndef CALLBACKS_H
#define CALLBACKS_H

#include "driver.h"
#include "common.h"

#include <wdf.h>

typedef void (*THREADLIST_CALLBACK_ROUTINE)(
    _In_ PTHREAD_LIST_ENTRY ThreadListEntry, _In_opt_ PVOID Context);

typedef void (*PROCESSLIST_CALLBACK_ROUTINE)(
    _In_ PPROCESS_LIST_ENTRY ProcessListEntry, _In_opt_ PVOID Context);

#define DRIVER_PATH_LENGTH  0x100
#define SHA_256_HASH_LENGTH 32

typedef struct _DRIVER_LIST_ENTRY {
    SINGLE_LIST_ENTRY list;
    PVOID             ImageBase;
    ULONG             ImageSize;
    BOOLEAN           hashed;
    BOOLEAN           x86;
    CHAR              path[DRIVER_PATH_LENGTH];
    CHAR              text_hash[SHA_256_HASH_LENGTH];

    /*
     * This LIST_ENTRY is to be used for modules where the hashing needs to
     * be deferred. For example, when x86 modules can't be hashed on driver
     * load.
     */
    LIST_ENTRY deferred_entry;

} DRIVER_LIST_ENTRY, *PDRIVER_LIST_ENTRY;

typedef void (*DRIVERLIST_CALLBACK_ROUTINE)(
    _In_ PDRIVER_LIST_ENTRY DriverListEntry, _In_opt_ PVOID Context);

NTSTATUS
InitialiseDriverList();

VOID NTAPI
ExUnlockHandleTableEntry(IN PHANDLE_TABLE       HandleTable,
                         IN PHANDLE_TABLE_ENTRY HandleTableEntry);

VOID
ObPostOpCallbackRoutine(_In_ PVOID RegistrationContext,
                        _In_ POB_POST_OPERATION_INFORMATION
                            OperationInformation);

OB_PREOP_CALLBACK_STATUS
ObPreOpCallbackRoutine(_In_ PVOID                         RegistrationContext,
                       _In_ POB_PRE_OPERATION_INFORMATION OperationInformation);

NTSTATUS
EnumerateProcessHandles(_In_ PPROCESS_LIST_ENTRY ProcessListEntry,
                        _In_opt_ PVOID           Context);

NTSTATUS
InitialiseThreadList();

NTSTATUS
InitialiseProcessList();

VOID
ThreadCreateNotifyRoutine(_In_ HANDLE  ProcessId,
                          _In_ HANDLE  ThreadId,
                          _In_ BOOLEAN Create);

VOID
ProcessCreateNotifyRoutine(_In_ HANDLE  ParentId,
                           _In_ HANDLE  ProcessId,
                           _In_ BOOLEAN Create);

VOID
CleanupThreadListOnDriverUnload();

VOID
FindThreadListEntryByThreadAddress(_In_ PKTHREAD               Thread,
                                   _Inout_ PTHREAD_LIST_ENTRY* Entry);

VOID
FindProcessListEntryByProcess(_In_ PKPROCESS               Process,
                              _Inout_ PPROCESS_LIST_ENTRY* Entry);

VOID
EnumerateThreadListWithCallbackRoutine(
    _In_ THREADLIST_CALLBACK_ROUTINE CallbackRoutine, _In_opt_ PVOID Context);

VOID
EnumerateProcessListWithCallbackRoutine(
    _In_ PROCESSLIST_CALLBACK_ROUTINE CallbackRoutine, _In_opt_ PVOID Context);

VOID
FindDriverEntryByBaseAddress(_In_ PVOID                ImageBase,
                             _Out_ PDRIVER_LIST_ENTRY* Entry);

VOID
CleanupProcessListOnDriverUnload();

VOID
CleanupDriverListOnDriverUnload();

VOID
ImageLoadNotifyRoutineCallback(_In_opt_ PUNICODE_STRING FullImageName,
                               _In_ HANDLE              ProcessId,
                               _In_ PIMAGE_INFO         ImageInfo);

NTSTATUS
InitialiseTimerObject(_Out_ PTIMER_OBJECT Timer);

VOID
CleanupDriverTimerObjects(_Out_ PTIMER_OBJECT Timer);

VOID
UnregisterProcessCreateNotifyRoutine();

VOID
UnregisterImageLoadNotifyRoutine();

VOID
UnregisterThreadCreateNotifyRoutine();

VOID
UnregisterProcessObCallbacks();

NTSTATUS
RegisterProcessObCallbacks();

VOID
InitialiseObCallbacksConfiguration(_Out_ PACTIVE_SESSION ProcessConfig);

VOID
EnumerateDriverListWithCallbackRoutine(
    _In_ DRIVERLIST_CALLBACK_ROUTINE CallbackRoutine, _In_opt_ PVOID Context);

VOID
DriverListEntryToExtendedModuleInfo(_In_ PDRIVER_LIST_ENTRY         Entry,
                                    _Out_ PRTL_MODULE_EXTENDED_INFO Extended);

#endif

```

`driver/common.h`:

```h
#ifndef COMMON_H
#define COMMON_H

#include <ntifs.h>
#include <wdftypes.h>
#include "io.h"

#include "types/types.h"

/*
 * For numbers < 32, these are equivalent to 0ul < x.
 *
 * For an item to be printed, its bitwise AND'd with the set filter. If the
 * result is non zero the log will be printed.
 */
#define LOG_ERROR_LEVEL   1
#define LOG_WARNING_LEVEL 2
#define LOG_INFO_LEVEL    3
#define LOG_VERBOSE_LEVEL 4

#define DPFLTR_MASK 0x80000000

#define DEBUG_ERROR(fmt, ...)                      \
    DbgPrintEx(DPFLTR_DEFAULT_ID,                  \
               LOG_ERROR_LEVEL,                    \
               "donna-ac : [ERROR] ::: " fmt "\n", \
               ##__VA_ARGS__)

#define DEBUG_WARNING(fmt, ...)                    \
    DbgPrintEx(DPFLTR_DEFAULT_ID,                  \
               LOG_WARNING_LEVEL,                  \
               "donna-ac : [WARNING] : " fmt "\n", \
               ##__VA_ARGS__)

#define DEBUG_INFO(fmt, ...)                       \
    DbgPrintEx(DPFLTR_DEFAULT_ID,                  \
               LOG_INFO_LEVEL,                     \
               "donna-ac : [INFO] :::: " fmt "\n", \
               ##__VA_ARGS__)

#define DEBUG_VERBOSE(fmt, ...)                    \
    DbgPrintEx(DPFLTR_DEFAULT_ID,                  \
               LOG_VERBOSE_LEVEL,                  \
               "donna-ac : [VERBOSE] : " fmt "\n", \
               ##__VA_ARGS__)

#define STATIC static
#define INLINE inline

#define MAX_MODULE_PATH 256

/*
 * Interlocked intrinsics are only atomic with respect to other InterlockedXxx
 * functions, so all reads and writes to the THREAD_LIST->active flag must be
 * with Interlocked instrinsics to ensure atomicity.
 */
typedef struct _THREAD_LIST_HEAD {
    SINGLE_LIST_ENTRY start;
    volatile BOOLEAN  active;
    KGUARDED_MUTEX    lock;
    LOOKASIDE_LIST_EX lookaside_list;

} THREAD_LIST_HEAD, *PTHREAD_LIST_HEAD;

typedef struct _PROCESS_LIST_HEAD {
    SINGLE_LIST_ENTRY start;
    volatile BOOLEAN  active;
    KGUARDED_MUTEX    lock;
    LOOKASIDE_LIST_EX lookaside_list;

} PROCESS_LIST_HEAD, *PPROCESS_LIST_HEAD;

typedef struct _DRIVER_LIST_HEAD {
    SINGLE_LIST_ENTRY start;
    volatile ULONG    count;
    volatile BOOLEAN  active;
    KGUARDED_MUTEX    lock;

    /* modules that need to be hashed later. */
    PIO_WORKITEM  deferred_work_item;
    LIST_ENTRY    deferred_list;
    volatile LONG can_hash_x86;

} DRIVER_LIST_HEAD, *PDRIVER_LIST_HEAD;

typedef struct _THREAD_LIST_ENTRY {
    SINGLE_LIST_ENTRY list;
    PKTHREAD          thread;
    PKPROCESS         owning_process;
    BOOLEAN           apc_queued;
    PKAPC             apc;

} THREAD_LIST_ENTRY, *PTHREAD_LIST_ENTRY;

typedef struct _PROCESS_LIST_ENTRY {
    SINGLE_LIST_ENTRY list;
    PKPROCESS         process;
    PKPROCESS         parent;

} PROCESS_LIST_ENTRY, *PPROCESS_LIST_ENTRY;

/*
 * ioctl_flag consists of the first 16 bits of the Function part of the CTL code
 * cookie_value consists of a static 16 bit value generated by the user mode app
 * on startup which is then passed to the driver and stored.
 */
typedef union _SECURITY_COOKIE {
    struct {
        UINT32 ioctl_flag : 16;
        UINT32 cookie_value : 16;
    } bits;

    UINT32 flags;

} SECURITY_COOKIE, *PSECURITY_COOKIE;

typedef struct _TIMER_OBJECT {
    /*
     * state = 1: callback in progress
     * state = 0: no callback in progress (i.e safe to free and unregister)
     */
    volatile LONG state;

    KTIMER       timer;
    KDPC         dpc;
    PIO_WORKITEM work_item;

} TIMER_OBJECT, *PTIMER_OBJECT;

typedef enum _ENVIRONMENT_TYPE {
    NativeWindows = 0,
    Vmware,
    VirtualBox

} ENVIRONMENT_TYPE;

typedef enum _PROCESSOR_TYPE {
    Unknown = 0,
    GenuineIntel,
    AuthenticAmd

} PROCESSOR_TYPE;

#define VENDOR_STRING_MAX_LENGTH 256

#define DRIVER_PATH_MAX_LENGTH            512
#define MOTHERBOARD_SERIAL_CODE_LENGTH    64
#define DEVICE_DRIVE_0_SERIAL_CODE_LENGTH 64

#define MAX_REPORTS_PER_IRP 20

#define POOL_TAG_STRINGS 'strs'

#define IOCTL_STORAGE_QUERY_PROPERTY 0x002D1400

#define MAXIMUM_APC_CONTEXTS 10

typedef struct _SYSTEM_INFORMATION {
    CHAR               motherboard_serial[MOTHERBOARD_SERIAL_CODE_LENGTH];
    CHAR               drive_0_serial[DEVICE_DRIVE_0_SERIAL_CODE_LENGTH];
    CHAR               vendor[VENDOR_STRING_MAX_LENGTH];
    BOOLEAN            virtualised_environment;
    ENVIRONMENT_TYPE   environment;
    PROCESSOR_TYPE     processor;
    RTL_OSVERSIONINFOW os_information;

} SYSTEM_INFORMATION, *PSYSTEM_INFORMATION;

typedef struct _OB_CALLBACKS_CONFIG {
    PVOID          registration_handle;
    KGUARDED_MUTEX lock;

} OB_CALLBACKS_CONFIG, *POB_CALLBACKS_CONFIG;

typedef struct _DEFERRED_REPORT {
    LIST_ENTRY list_entry;
    PVOID      buffer;
    UINT32     buffer_size;

} DEFERRED_REPORT, *PDEFERRED_REPORT;

typedef struct _DEFERRED_REPORTS_LIST {
    LIST_ENTRY head;
    UINT32     count;
    KSPIN_LOCK lock;

} DEFERRED_REPORTS_LIST, *PDEFERRED_REPORTS_LIST;

typedef struct _IRP_QUEUE_HEAD {
    LIST_ENTRY            queue;
    volatile UINT32       count;
    IO_CSQ                csq;
    KSPIN_LOCK            lock;
    DEFERRED_REPORTS_LIST deferred_reports;

} IRP_QUEUE_HEAD, *PIRP_QUEUE_HEAD;

typedef struct _IRP_QUEUE_ENTRY {
    SINGLE_LIST_ENTRY entry;
    PIRP              irp;

} IRP_QUEUE_ENTRY, *PIRP_QUEUE_ENTRY;

/*
 * This structure can change at anytime based on whether
 * the target process to protect is open / closed / changes etc.
 */

#define AES_128_KEY_SIZE 16

typedef struct _ACTIVE_SESSION {
    BOOLEAN             is_session_active;
    PVOID               um_handle;
    PVOID               km_handle;
    PEPROCESS           process;
    OB_CALLBACKS_CONFIG callback_configuration;

    UINT32 session_cookie;
    CHAR   session_aes_key[AES_128_KEY_SIZE];

    struct SESSION_STATISTICS {
        UINT32 irps_processed;
        UINT32 report_count;
        UINT32 heartbeat_count;
    };

    KGUARDED_MUTEX lock;

} ACTIVE_SESSION, *PACTIVE_SESSION;

#define NMI_CONTEXT_POOL               '7331'
#define STACK_FRAMES_POOL              'loop'
#define INVALID_DRIVER_LIST_HEAD_POOL  'rwar'
#define INVALID_DRIVER_LIST_ENTRY_POOL 'gaah'
#define POOL_TAG_APC                   'apcc'
#define POOL_TAG_HW                    'hwhw'
#define POOL_TAG_DPC                   'apcc'
#define SYSTEM_MODULES_POOL            'halb'
#define THREAD_DATA_POOL               'doof'
#define PROC_AFFINITY_POOL             'eeee'
#define TEMP_BUFFER_POOL               'ffff'
#define DRIVER_PATH_POOL_TAG           'path'
#define POOL_TAG_INTEGRITY             'intg'
#define POOL_TAG_MODULE_MEMORY_BUF     'lolo'
#define POOL_TAG_MODULE_MEMORY_BUF_2   'leeo'
#define POOL_TAG_HASH_OBJECT           'hobj'
#define POOL_TAG_RESULTING_HASH        'hash'
#define POOL_TAG_SAVE_EX_REGIONS       'sexc'
#define POOL_DUMP_BLOCK_TAG            'dump'
#define POOL_DEBUGGER_DATA_TAG         'data'
#define PROCESS_ADDRESS_LIST_TAG       'addr'
#define ANALYSE_PROCESS_TAG            'anls'
#define INVALID_PROCESS_REPORT_TAG     'invd'
#define QUEUE_POOL_TAG                 'qqqq'
#define REPORT_QUEUE_TEMP_BUFFER_TAG   'temp'
#define REPORT_POOL_TAG                'repo'
#define MODULES_REPORT_POOL_TAG        'modu'
#define POOL_TAG_LIST_ITEM             'tsil'
#define POOL_TAG_THREAD_LIST           'list'
#define POOL_TAG_PROCESS_LIST          'plis'
#define POOL_TAG_DRIVER_LIST           'drvl'
#define POOL_TAG_IRP_QUEUE             'irpp'
#define POOL_TAG_TIMER                 'time'

#define IA32_APERF_MSR 0x000000E8

#define ERROR                 -1
#define STACK_FRAME_POOL_SIZE 0x200
#define NUMBER_HASH_BUCKETS   37

#define KTHREAD_STACK_BASE_OFFSET    0x030
#define KTHREAD_STACK_LIMIT_OFFSET   0x038
#define KTHREAD_THREADLIST_OFFSET    0x2f8
#define KTHREAD_APC_STATE_OFFSET     0x098
#define KTHREAD_START_ADDRESS_OFFSET 0x450
#define KTHREAD_MISC_FLAGS_OFFSET    0x074
#define KTHREAD_WAIT_IRQL_OFFSET     0x186
#define KTHREAD_PREVIOUS_MODE_OFFSET 0x232
#define KTHREAD_STATE_OFFSET         0x184

#define KTHREAD_MISC_FLAGS_APC_QUEUEABLE 14
#define KTHREAD_MISC_FLAGS_ALERTABLE     4

#define EPROCESS_PEAK_VIRTUAL_SIZE_OFFSET 0x490
#define EPROCESS_VAD_ROOT_OFFSET          0x7d8
#define EPROCESS_OBJECT_TABLE_OFFSET      0x570
#define EPROCESS_IMAGE_NAME_OFFSET        0x5a8
#define EPROCESS_PEB_OFFSET               0x550
#define EPROCESS_SECTION_BASE_OFFSET      0x520
#define EPROCESS_IMAGE_FILE_NAME_OFFSET   0x5a8
#define EPROCESS_HANDLE_TABLE_OFFSET      0x570
#define EPROCESS_PLIST_ENTRY_OFFSET       0x448

#define KPROCESS_THREADLIST_OFFSET           0x030
#define KPROCESS_DIRECTORY_TABLE_BASE_OFFSET 0x028

#define OBJECT_HEADER_SIZE              0x30
#define OBJECT_HEADER_TYPE_INDEX_OFFSET 0x018

#define POOL_HEADER_BLOCK_SIZE_OFFSET 0x02
#define POOL_HEADER_TAG_OFFSET        0x04

#define KPROCESS_OFFSET_FROM_POOL_HEADER_SIZE_1 0x70
#define KPROCESS_OFFSET_FROM_POOL_HEADER_SIZE_2 0x80
#define KPROCESS_OFFSET_FROM_POOL_HEADER_SIZE_3 0x30
#define EPROCESS_SIZE                           0xa40

#define KPCRB_CURRENT_THREAD 0x8

#define IA32_GS_BASE              0xc0000101
#define KPRCB_OFFSET_FROM_GS_BASE 0x180

#define MODULE_VALIDATION_FAILURE_MAX_REPORT_COUNT 20

#define IMAGE_DIRECTORY_ENTRY_EXPORT         0
#define IMAGE_DIRECTORY_ENTRY_IMPORT         1
#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3
#define IMAGE_DIRECTORY_ENTRY_SECURITY       4
#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5
#define IMAGE_DIRECTORY_ENTRY_DEBUG          6
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8 /* (MIPS GP) */
#define IMAGE_DIRECTORY_ENTRY_TLS            9
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11
#define IMAGE_DIRECTORY_ENTRY_IAT            12 /* Import Address Table */
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14

/*
 * Generic macros that allow you to quickly determine whether
 *  or not a page table entry is present or may forward to a
 *  large page of data, rather than another page table (applies
 *  only to PDPTEs and PDEs)
 *
 * Some nice macros courtesy of:
 * https://www.unknowncheats.me/forum/general-programming-and-reversing/523359-introduction-physical-memory.html
 */
#define IS_LARGE_PAGE(x)   ((BOOLEAN)((x >> 7) & 1))
#define IS_PAGE_PRESENT(x) ((BOOLEAN)(x & 1))

#define PAGE_1GB_SHIFT     30
#define PAGE_1GB_OFFSET(x) (x & (~(MAXUINT64 << PAGE_1GB_SHIFT)))

#define PAGE_2MB_SHIFT     21
#define PAGE_2MB_OFFSET(x) (x & (~(MAXUINT64 << PAGE_2MB_SHIFT)))

#define PAGE_4KB_SHIFT     12
#define PAGE_4KB_OFFSET(x) (x & (~(MAXUINT64 << PAGE_4KB_SHIFT)))

typedef struct _KAFFINITY_EX {
    USHORT    Count;
    USHORT    Size;
    ULONG     Reserved;
    ULONGLONG Bitmap[20];

} KAFFINITY_EX, *PKAFFINITY_EX;

typedef struct _OBJECT_DIRECTORY_ENTRY {
    struct _OBJECT_DIRECTORY_ENTRY* ChainLink;
    PVOID                           Object;
    ULONG                           HashValue;

} OBJECT_DIRECTORY_ENTRY, *POBJECT_DIRECTORY_ENTRY;

typedef struct _OBJECT_DIRECTORY {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK            Lock;
    struct _DEVICE_MAP*     DeviceMap;
    ULONG                   SessionId;
    PVOID                   NamespaceEntry;
    ULONG                   Flags;

} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;

typedef struct _DEVICE_MAP {
    struct _OBJECT_DIRECTORY* DosDevicesDirectory;
    struct _OBJECT_DIRECTORY* GlobalDosDevicesDirectory;
    ULONG                     ReferenceCount;
    ULONG                     DriveMap;
    UCHAR                     DriveType[32];

} DEVICE_MAP, *PDEVICE_MAP;

typedef struct _RTL_MODULE_EXTENDED_INFO {
    PVOID  ImageBase;
    ULONG  ImageSize;
    USHORT FileNameOffset;
    CHAR   FullPathName[0x100];

} RTL_MODULE_EXTENDED_INFO, *PRTL_MODULE_EXTENDED_INFO;

/*
Thread Information Block: (GS register)

        SEH frame:						0x00
        Stack Base:						0x08
        Stack Limit:					0x10
        SubSystemTib:					0x18
        Fiber Data:						0x20
        Arbitrary Data:					0x28
        TEB:							0x30
        Environment Pointer:			0x38
        Process ID:						0x40
        Current Thread ID:				0x48
        Active RPC Handle:				0x50
        Thread Local Storage Array:		0x58
        PEB:							0x60
        Last error number:				0x68
        Count Owned Critical Sections:  0x6C
        CSR Client Thread:				0x70
        Win32 Thread Information:		0x78
        ...
*/

typedef struct _OBJECT_TYPE {
    LIST_ENTRY     TypeList;
    UNICODE_STRING Name;
    PVOID          DefaultObject;
    UCHAR          Index;
    ULONG          TotalNumberOfObjects;
    ULONG          TotalNumberOfHandles;
    ULONG          HighWaterNumberOfObjects;
    ULONG          HighWaterNumberOfHandles;
    PVOID          TypeInfo; //_OBJECT_TYPE_INITIALIZER
    EX_PUSH_LOCK   TypeLock;
    ULONG          Key;
    LIST_ENTRY     CallbackList;

} OBJECT_TYPE, *POBJECT_TYPE;

typedef struct _PEB_LDR_DATA {
    BYTE       Reserved1[8];
    PVOID      Reserved2[3];
    LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY {
    PVOID          Reserved1[2];
    LIST_ENTRY     InMemoryOrderLinks;
    PVOID          Reserved2[2];
    PVOID          DllBase;
    PVOID          Reserved3[2];
    UNICODE_STRING FullDllName;
    BYTE           Reserved4[8];
    PVOID          Reserved5[3];
#pragma warning(push)
#pragma warning(disable : 4201) // we'll always use the Microsoft compiler
    union {
        ULONG CheckSum;
        PVOID Reserved6;
    } DUMMYUNIONNAME;
#pragma warning(pop)
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB {
    BYTE          Reserved1[2];
    BYTE          BeingDebugged;
    BYTE          Reserved2[1];
    PVOID         Reserved3[2];
    PPEB_LDR_DATA Ldr;
    PVOID         ProcessParameters;
    PVOID         Reserved4[3];
    PVOID         AtlThunkSListPtr;
    PVOID         Reserved5;
    ULONG         Reserved6;
    PVOID         Reserved7;
    ULONG         Reserved8;
    ULONG         AtlThunkSListPtr32;
    PVOID         Reserved9[45];
    BYTE          Reserved10[96];
    PVOID         PostProcessInitRoutine;
    BYTE          Reserved11[128];
    PVOID         Reserved12[1];
    ULONG         SessionId;
} PEB, *PPEB;

typedef struct _PEB32 {
    UCHAR InheritedAddressSpace;
    UCHAR ReadImageFileExecOptions;
    UCHAR BeingDebugged;
    UCHAR BitField;
    ULONG Mutant;
    ULONG ImageBaseAddress;
    ULONG Ldr;
    ULONG ProcessParameters;
    ULONG SubSystemData;
    ULONG ProcessHeap;
    ULONG FastPebLock;
    ULONG AtlThunkSListPtr;
    ULONG IFEOKey;
    ULONG CrossProcessFlags;
    ULONG UserSharedInfoPtr;
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    ULONG ApiSetMap;
} PEB32, *PPEB32;

typedef struct _PEB_LDR_DATA32 {
    ULONG        Length;
    UCHAR        Initialized;
    ULONG        SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32 {
    LIST_ENTRY32     InLoadOrderLinks;
    LIST_ENTRY32     InMemoryOrderLinks;
    LIST_ENTRY32     InInitializationOrderLinks;
    ULONG            DllBase;
    ULONG            EntryPoint;
    ULONG            SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    ULONG            Flags;
    USHORT           LoadCount;
    USHORT           TlsIndex;
    LIST_ENTRY32     HashLinks;
    ULONG            TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _HANDLE_TABLE_ENTRY_INFO {
    ULONG AuditMask;
    ULONG MaxRelativeAccessMask;

} HANDLE_TABLE_ENTRY_INFO, *PHANDLE_TABLE_ENTRY_INFO;

typedef union _EXHANDLE {
    struct {
        int TagBits : 2;
        int Index : 30;
    } u;
    void*     GenericHandleOverlay;
    ULONG_PTR Value;
} EXHANDLE, *PEXHANDLE;

#pragma warning(disable : 4214 4201)

#pragma pack(push, 1)
typedef struct _POOL_HEADER // Size=16
{
    union {
        struct {
            unsigned long PreviousSize : 8; // Size=4 Offset=0 BitOffset=0
                                            // BitCount=8
            unsigned long PoolIndex : 8;    // Size=4 Offset=0
                                            // BitOffset=8 BitCount=8
            unsigned long BlockSize : 8;    // Size=4 Offset=0
                                            // BitOffset=16 BitCount=8
            unsigned long PoolType : 8;     // Size=4 Offset=0
                                            // BitOffset=24 BitCount=8
        };
        unsigned long Ulong1; // Size=4 Offset=0
    };
    unsigned long PoolTag; // Size=4 Offset=4
    union {
        struct _EPROCESS* ProcessBilled; // Size=8 Offset=8
        struct {
            unsigned short AllocatorBackTraceIndex; // Size=2 Offset=8
            unsigned short PoolTagHash;             // Size=2 Offset=10
        };
    };
} POOL_HEADER, *PPOOL_HEADER;
#pragma pack(pop)

typedef struct _HANDLE_TABLE_ENTRY // Size=16
{
    union {
        ULONG_PTR                        VolatileLowValue; // Size=8 Offset=0
        ULONG_PTR                        LowValue;         // Size=8 Offset=0
        struct _HANDLE_TABLE_ENTRY_INFO* InfoTable;        // Size=8 Offset=0
        struct {
            ULONG_PTR Unlocked : 1;   // Size=8 Offset=0 BitOffset=0
                                      // BitCount=1
            ULONG_PTR RefCnt : 16;    // Size=8 Offset=0 BitOffset=1
                                      // BitCount=16
            ULONG_PTR Attributes : 3; // Size=8 Offset=0
                                      // BitOffset=17 BitCount=3
            ULONG_PTR
            ObjectPointerBits : 44; // Size=8 Offset=0 BitOffset=20
                                    // BitCount=44
        };
    };
    union {
        ULONG_PTR                   HighValue;           // Size=8 Offset=8
        struct _HANDLE_TABLE_ENTRY* NextFreeHandleEntry; // Size=8 Offset=8
        union _EXHANDLE             LeafHandleValue;     // Size=8 Offset=8
        struct {
            ULONG GrantedAccessBits : 25; // Size=4 Offset=8
                                          // BitOffset=0 BitCount=25
            ULONG NoRightsUpgrade : 1;    // Size=4 Offset=8
                                          // BitOffset=25 BitCount=1
            ULONG Spare : 6;              // Size=4 Offset=8 BitOffset=26
                                          // BitCount=6
        };
    };
    ULONG TypeInfo; // Size=4 Offset=12
} HANDLE_TABLE_ENTRY, *PHANDLE_TABLE_ENTRY;

typedef struct _HANDLE_TABLE_FREE_LIST {
    EX_PUSH_LOCK        FreeListLock;
    PHANDLE_TABLE_ENTRY FirstFreeHandleEntry;
    PHANDLE_TABLE_ENTRY LastFreeHandleEntry;
    LONG                HandleCount;
    ULONG               HighWaterMark;
} HANDLE_TABLE_FREE_LIST, *PHANDLE_TABLE_FREE_LIST;

typedef struct _HANDLE_TRACE_DB_ENTRY {
    CLIENT_ID ClientId;
    PVOID     Handle;
    ULONG     Type;
    PVOID     StackTrace[16];

} HANDLE_TRACE_DB_ENTRY, *PHANDLE_TRACE_DB_ENTRY;

typedef struct _HANDLE_TRACE_DEBUG_INFO {
    LONG                  RefCount;
    ULONG                 TableSize;
    ULONG                 BitMaskFlags;
    FAST_MUTEX            CloseCompactionLock;
    ULONG                 CurrentStackIndex;
    HANDLE_TRACE_DB_ENTRY TraceDb[1];

} HANDLE_TRACE_DEBUG_INFO, *PHANDLE_TRACE_DEBUG_INFO;

typedef struct _HANDLE_TABLE {
    ULONG      NextHandleNeedingPool;
    LONG       ExtraInfoPages;
    ULONGLONG  TableCode;
    PEPROCESS  QuotaProcess;
    LIST_ENTRY HandleTableList;
    ULONG      UniqueProcessId;
    union {
        ULONG Flags;
        struct {
            UCHAR StrictFIFO : 1;
            UCHAR EnableHandleExceptions : 1;
            UCHAR Rundown : 1;
            UCHAR Duplicated : 1;
            UCHAR RaiseUMExceptionOnInvalidHandleClose : 1;
        };
    };
    EX_PUSH_LOCK HandleContentionEvent;
    EX_PUSH_LOCK HandleTableLock;
    union {
        HANDLE_TABLE_FREE_LIST FreeLists[1];
        UCHAR                  ActualEntry[32];
    };

    struct _HANDLE_TRACE_DEBUG_INFO* DebugInfo;

} HANDLE_TABLE, *PHANDLE_TABLE;

typedef BOOLEAN (*EX_ENUMERATE_HANDLE_ROUTINE)(IN PHANDLE_TABLE_ENTRY
                                                         HandleTableEntry,
                                               IN HANDLE Handle,
                                               IN PVOID  EnumParameter);

typedef struct _OBJECT_CREATE_INFORMATION {
    ULONG                                Attributes;
    PVOID                                RootDirectory;
    CHAR                                 ProbeMode;
    ULONG                                PagedPoolCharge;
    ULONG                                NonPagedPoolCharge;
    ULONG                                SecurityDescriptorCharge;
    PVOID                                SecurityDescriptor;
    struct _SECURITY_QUALITY_OF_SERVICE* SecurityQos;
    struct _SECURITY_QUALITY_OF_SERVICE  SecurityQualityOfService;

} OBJECT_CREATE_INFORMATION, *POBJECT_CREATE_INFORMATION;

typedef struct _OBJECT_HEADER {
    LONGLONG PointerCount;
    union {
        LONGLONG HandleCount;
        PVOID    NextToFree;
    };
    EX_PUSH_LOCK Lock;
    UCHAR        TypeIndex;
    union {
        UCHAR TraceFlags;
        struct {
            UCHAR DbgRefTrace : 1;
            UCHAR DbgTracePermanent : 1;
        };
    };
    UCHAR InfoMask;
    union {
        UCHAR Flags;
        struct {
            UCHAR NewObject : 1;
            UCHAR KernelObject : 1;
            UCHAR KernelOnlyAccess : 1;
            UCHAR ExclusiveObject : 1;
            UCHAR PermanentObject : 1;
            UCHAR DefaultSecurityQuota : 1;
            UCHAR SingleHandleEntry : 1;
            UCHAR DeletedInline : 1;
        };
    };
    ULONG Reserved;
    union {
        POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID                      QuotaBlockCharged;
    };
    PVOID SecurityDescriptor;
    QUAD  Body;
} OBJECT_HEADER, *POBJECT_HEADER;

#define IMAGE_SCN_MEM_EXECUTE 0x20000000
#define IMAGE_SCN_MEM_READ    0x40000000
#define IMAGE_SCN_MEM_WRITE   0x80000000

#define IMAGE_SIZEOF_SHORT_NAME 8

typedef struct _IMAGE_SECTION_HEADER {
    unsigned char Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        unsigned long PhysicalAddress;
        unsigned long VirtualSize;
    } Misc;
    unsigned long  VirtualAddress;
    unsigned long  SizeOfRawData;
    unsigned long  PointerToRawData;
    unsigned long  PointerToRelocations;
    unsigned long  PointerToLinenumbers;
    unsigned short NumberOfRelocations;
    unsigned short NumberOfLinenumbers;
    unsigned long  Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_FILE_HEADER {
    unsigned short Machine;
    unsigned short NumberOfSections;
    unsigned long  TimeDateStamp;
    unsigned long  PointerToSymbolTable;
    unsigned long  NumberOfSymbols;
    unsigned short SizeOfOptionalHeader;
    unsigned short Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
    unsigned long VirtualAddress;
    unsigned long Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    unsigned short       Magic;
    unsigned char        MajorLinkerVersion;
    unsigned char        MinorLinkerVersion;
    unsigned long        SizeOfCode;
    unsigned long        SizeOfInitializedData;
    unsigned long        SizeOfUninitializedData;
    unsigned long        AddressOfEntryPoint;
    unsigned long        BaseOfCode;
    ULONGLONG            ImageBase;
    unsigned long        SectionAlignment;
    unsigned long        FileAlignment;
    unsigned short       MajorOperatingSystemVersion;
    unsigned short       MinorOperatingSystemVersion;
    unsigned short       MajorImageVersion;
    unsigned short       MinorImageVersion;
    unsigned short       MajorSubsystemVersion;
    unsigned short       MinorSubsystemVersion;
    unsigned long        Win32VersionValue;
    unsigned long        SizeOfImage;
    unsigned long        SizeOfHeaders;
    unsigned long        CheckSum;
    unsigned short       Subsystem;
    unsigned short       DllCharacteristics;
    ULONGLONG            SizeOfStackReserve;
    ULONGLONG            SizeOfStackCommit;
    ULONGLONG            SizeOfHeapReserve;
    ULONGLONG            SizeOfHeapCommit;
    unsigned long        LoaderFlags;
    unsigned long        NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef unsigned long  DWORD;
typedef unsigned short WORD;

typedef struct _IMAGE_OPTIONAL_HEADER32 {
    WORD                 Magic;
    BYTE                 MajorLinkerVersion;
    BYTE                 MinorLinkerVersion;
    DWORD                SizeOfCode;
    DWORD                SizeOfInitializedData;
    DWORD                SizeOfUninitializedData;
    DWORD                AddressOfEntryPoint;
    DWORD                BaseOfCode;
    DWORD                BaseOfData;
    DWORD                ImageBase;
    DWORD                SectionAlignment;
    DWORD                FileAlignment;
    WORD                 MajorOperatingSystemVersion;
    WORD                 MinorOperatingSystemVersion;
    WORD                 MajorImageVersion;
    WORD                 MinorImageVersion;
    WORD                 MajorSubsystemVersion;
    WORD                 MinorSubsystemVersion;
    DWORD                Win32VersionValue;
    DWORD                SizeOfImage;
    DWORD                SizeOfHeaders;
    DWORD                CheckSum;
    WORD                 Subsystem;
    WORD                 DllCharacteristics;
    DWORD                SizeOfStackReserve;
    DWORD                SizeOfStackCommit;
    DWORD                SizeOfHeapReserve;
    DWORD                SizeOfHeapCommit;
    DWORD                LoaderFlags;
    DWORD                NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_DOS_HEADER { // DOS .EXE header
    unsigned short e_magic;        // Magic number
    unsigned short e_cblp;         // Bytes on last page of file
    unsigned short e_cp;           // Pages in file
    unsigned short e_crlc;         // Relocations
    unsigned short e_cparhdr;      // Size of header in paragraphs
    unsigned short e_minalloc;     // Minimum extra paragraphs needed
    unsigned short e_maxalloc;     // Maximum extra paragraphs needed
    unsigned short e_ss;           // Initial (relative) SS value
    unsigned short e_sp;           // Initial SP value
    unsigned short e_csum;         // Checksum
    unsigned short e_ip;           // Initial IP value
    unsigned short e_cs;           // Initial (relative) CS value
    unsigned short e_lfarlc;       // File address of relocation table
    unsigned short e_ovno;         // Overlay number
    unsigned short e_res[4];       // Reserved words
    unsigned short e_oemid;        // OEM identifier (for e_oeminfo)
    unsigned short e_oeminfo;      // OEM information; e_oemid specific
    unsigned short e_res2[10];     // Reserved words
    LONG           e_lfanew;       // File address of new exe header
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _KLDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    PVOID      ExceptionTable;
    ULONG      ExceptionTableSize;
    // ULONG padding on IA64
    PVOID          GpValue;
    PVOID          NonPagedDebugInfo;
    PVOID          DllBase;
    PVOID          EntryPoint;
    ULONG          SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG          Flags;
    USHORT         LoadCount;
    USHORT         __Unused5;
    PVOID          SectionPointer;
    ULONG          CheckSum;
    // ULONG padding on IA64
    PVOID LoadedImports;
    PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;

typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD  MajorVersion;
    WORD  MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

typedef struct _LOCAL_NT_HEADER {
    unsigned long           Signature;
    IMAGE_FILE_HEADER       FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} LOCAL_NT_HEADER, *PLOCAL_NT_HEADER;

#define IMAGE_FIRST_SECTION(ntheader)                                        \
    ((PIMAGE_SECTION_HEADER)((ULONG_PTR)(ntheader) +                         \
                             FIELD_OFFSET(LOCAL_NT_HEADER, OptionalHeader) + \
                             ((ntheader))->FileHeader.SizeOfOptionalHeader))

/* creds: https://www.unknowncheats.me/forum/2602838-post2.html */

typedef struct _DBGKD_DEBUG_DATA_HEADER64 {
    LIST_ENTRY64 List;
    ULONG        OwnerTag;
    ULONG        Size;
} DBGKD_DEBUG_DATA_HEADER64, *PDBGKD_DEBUG_DATA_HEADER64;

typedef NTSTATUS(__stdcall* ZwQuerySystemInformation)(
    _In_ UINT32      SystemInformationClass,
    _Inout_ PVOID    SystemInformation,
    _In_ ULONG       SystemInformationLength,
    _Out_opt_ PULONG ReturnLength);

#define SYSTEM_BIGPOOL_INFORMATION_ID 0x42

typedef struct _SYSTEM_BIGPOOL_ENTRY {
    union {
        PVOID     VirtualAddress;
        ULONG_PTR NonPaged : 1;
    };
    SIZE_T SizeInBytes;
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
} SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
    ULONG Count;
    _Field_size_(Count) SYSTEM_BIGPOOL_ENTRY AllocatedInfo[1];
} SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _KDDEBUGGER_DATA64 {
    DBGKD_DEBUG_DATA_HEADER64 Header;
    ULONG64                   KernBase;
    ULONG64                   BreakpointWithStatus;
    ULONG64                   SavedContext;
    USHORT                    ThCallbackStack;
    USHORT                    NextCallback;
    USHORT                    FramePointer;
    USHORT                    PaeEnabled;
    ULONG64                   KiCallUserMode;
    ULONG64                   KeUserCallbackDispatcher;
    ULONG64                   PsLoadedModuleList;
    ULONG64                   PsActiveProcessHead;
    ULONG64                   PspCidTable;
    ULONG64                   ExpSystemResourcesList;
    ULONG64                   ExpPagedPoolDescriptor;
    ULONG64                   ExpNumberOfPagedPools;
    ULONG64                   KeTimeIncrement;
    ULONG64                   KeBugCheckCallbackListHead;
    ULONG64                   KiBugcheckData;
    ULONG64                   IopErrorLogListHead;
    ULONG64                   ObpRootDirectoryObject;
    ULONG64                   ObpTypeObjectType;
    ULONG64                   MmSystemCacheStart;
    ULONG64                   MmSystemCacheEnd;
    ULONG64                   MmSystemCacheWs;
    ULONG64                   MmPfnDatabase;
    ULONG64                   MmSystemPtesStart;
    ULONG64                   MmSystemPtesEnd;
    ULONG64                   MmSubsectionBase;
    ULONG64                   MmNumberOfPagingFiles;
    ULONG64                   MmLowestPhysicalPage;
    ULONG64                   MmHighestPhysicalPage;
    ULONG64                   MmNumberOfPhysicalPages;
    ULONG64                   MmMaximumNonPagedPoolInBytes;
    ULONG64                   MmNonPagedSystemStart;
    ULONG64                   MmNonPagedPoolStart;
    ULONG64                   MmNonPagedPoolEnd;
    ULONG64                   MmPagedPoolStart;
    ULONG64                   MmPagedPoolEnd;
    ULONG64                   MmPagedPoolInformation;
    ULONG64                   MmPageSize;
    ULONG64                   MmSizeOfPagedPoolInBytes;
    ULONG64                   MmTotalCommitLimit;
    ULONG64                   MmTotalCommittedPages;
    ULONG64                   MmSharedCommit;
    ULONG64                   MmDriverCommit;
    ULONG64                   MmProcessCommit;
    ULONG64                   MmPagedPoolCommit;
    ULONG64                   MmExtendedCommit;
    ULONG64                   MmZeroedPageListHead;
    ULONG64                   MmFreePageListHead;
    ULONG64                   MmStandbyPageListHead;
    ULONG64                   MmModifiedPageListHead;
    ULONG64                   MmModifiedNoWritePageListHead;
    ULONG64                   MmAvailablePages;
    ULONG64                   MmResidentAvailablePages;
    ULONG64                   PoolTrackTable;
    ULONG64                   NonPagedPoolDescriptor;
    ULONG64                   MmHighestUserAddress;
    ULONG64                   MmSystemRangeStart;
    ULONG64                   MmUserProbeAddress;
    ULONG64                   KdPrintCircularBuffer;
    ULONG64                   KdPrintCircularBufferEnd;
    ULONG64                   KdPrintWritePointer;
    ULONG64                   KdPrintRolloverCount;
    ULONG64                   MmLoadedUserImageList;
    ULONG64                   NtBuildLab;
    ULONG64                   KiNormalSystemCall;
    ULONG64                   KiProcessorBlock;
    ULONG64                   MmUnloadedDrivers;
    ULONG64                   MmLastUnloadedDriver;
    ULONG64                   MmTriageActionTaken;
    ULONG64                   MmSpecialPoolTag;
    ULONG64                   KernelVerifier;
    ULONG64                   MmVerifierData;
    ULONG64                   MmAllocatedNonPagedPool;
    ULONG64                   MmPeakCommitment;
    ULONG64                   MmTotalCommitLimitMaximum;
    ULONG64                   CmNtCSDVersion;
    ULONG64                   MmPhysicalMemoryBlock;
    ULONG64                   MmSessionBase;
    ULONG64                   MmSessionSize;
    ULONG64                   MmSystemParentTablePage;
    ULONG64                   MmVirtualTranslationBase;
    USHORT                    OffsetKThreadNextProcessor;
    USHORT                    OffsetKThreadTeb;
    USHORT                    OffsetKThreadKernelStack;
    USHORT                    OffsetKThreadInitialStack;
    USHORT                    OffsetKThreadApcProcess;
    USHORT                    OffsetKThreadState;
    USHORT                    OffsetKThreadBStore;
    USHORT                    OffsetKThreadBStoreLimit;
    USHORT                    SizeEProcess;
    USHORT                    OffsetEprocessPeb;
    USHORT                    OffsetEprocessParentCID;
    USHORT                    OffsetEprocessDirectoryTableBase;
    USHORT                    SizePrcb;
    USHORT                    OffsetPrcbDpcRoutine;
    USHORT                    OffsetPrcbCurrentThread;
    USHORT                    OffsetPrcbMhz;
    USHORT                    OffsetPrcbCpuType;
    USHORT                    OffsetPrcbVendorString;
    USHORT                    OffsetPrcbProcStateContext;
    USHORT                    OffsetPrcbNumber;
    USHORT                    SizeEThread;
    ULONG64                   KdPrintCircularBufferPtr;
    ULONG64                   KdPrintBufferSize;
    ULONG64                   KeLoaderBlock;
    USHORT                    SizePcr;
    USHORT                    OffsetPcrSelfPcr;
    USHORT                    OffsetPcrCurrentPrcb;
    USHORT                    OffsetPcrContainedPrcb;
    USHORT                    OffsetPcrInitialBStore;
    USHORT                    OffsetPcrBStoreLimit;
    USHORT                    OffsetPcrInitialStack;
    USHORT                    OffsetPcrStackLimit;
    USHORT                    OffsetPrcbPcrPage;
    USHORT                    OffsetPrcbProcStateSpecialReg;
    USHORT                    GdtR0Code;
    USHORT                    GdtR0Data;
    USHORT                    GdtR0Pcr;
    USHORT                    GdtR3Code;
    USHORT                    GdtR3Data;
    USHORT                    GdtR3Teb;
    USHORT                    GdtLdt;
    USHORT                    GdtTss;
    USHORT                    Gdt64R3CmCode;
    USHORT                    Gdt64R3CmTeb;
    ULONG64                   IopNumTriageDumpDataBlocks;
    ULONG64                   IopTriageDumpDataBlocks;
} KDDEBUGGER_DATA64, *PKDDEBUGGER_DATA64;

typedef struct _KDDEBUGGER_DATA_ADDITION64 {
    ULONG64 VfCrashDataBlock;
    ULONG64 MmBadPagesDetected;
    ULONG64 MmZeroedPageSingleBitErrorsDetected;
    ULONG64 EtwpDebuggerData;
    USHORT  OffsetPrcbContext;
    USHORT  OffsetPrcbMaxBreakpoints;
    USHORT  OffsetPrcbMaxWatchpoints;
    ULONG   OffsetKThreadStackLimit;
    ULONG   OffsetKThreadStackBase;
    ULONG   OffsetKThreadQueueListEntry;
    ULONG   OffsetEThreadIrpList;
    USHORT  OffsetPrcbIdleThread;
    USHORT  OffsetPrcbNormalDpcState;
    USHORT  OffsetPrcbDpcStack;
    USHORT  OffsetPrcbIsrStack;
    USHORT  SizeKDPC_STACK_FRAME;
    USHORT  OffsetKPriQueueThreadListHead;
    USHORT  OffsetKThreadWaitReason;
    USHORT  Padding;
    ULONG64 PteBase;
    ULONG64 RetpolineStubFunctionTable;
    ULONG   RetpolineStubFunctionTableSize;
    ULONG   RetpolineStubOffset;
    ULONG   RetpolineStubSize;
} KDDEBUGGER_DATA_ADDITION64, *PKDDEBUGGER_DATA_ADDITION64;

typedef struct _DUMP_HEADER {
    ULONG                      Signature;
    ULONG                      ValidDump;
    ULONG                      MajorVersion;
    ULONG                      MinorVersion;
    ULONG_PTR                  DirectoryTableBase;
    ULONG_PTR                  PfnDataBase;
    PLIST_ENTRY                PsLoadedModuleList;
    PLIST_ENTRY                PsActiveProcessHead;
    ULONG                      MachineImageType;
    ULONG                      NumberProcessors;
    ULONG                      BugCheckCode;
    ULONG_PTR                  BugCheckParameter1;
    ULONG_PTR                  BugCheckParameter2;
    ULONG_PTR                  BugCheckParameter3;
    ULONG_PTR                  BugCheckParameter4;
    CHAR                       VersionUser[32];
    struct _KDDEBUGGER_DATA64* KdDebuggerDataBlock;
} DUMP_HEADER, *PDUMP_HEADER;

typedef union _VIRTUAL_MEMORY_ADDRESS {
    struct {
        UINT64 PageIndex : 12; /* 0:11  */
        UINT64 PtIndex : 9;    /* 12:20 */
        UINT64 PdIndex : 9;    /* 21:29 */
        UINT64 PdptIndex : 9;  /* 30:38 */
        UINT64 Pml4Index : 9;  /* 39:47 */
        UINT64 Unused : 16;    /* 48:63 */

    } Bits;

    UINT64 BitAddress;

} VIRTUAL_ADDRESS, *PVIRTUAL_ADDRESS;

typedef union _PML4_ENTRY {
    struct {
        UINT64 Present : 1;          /* 0     */
        UINT64 ReadWrite : 1;        /* 1     */
        UINT64 UserSupervisor : 1;   /* 2     */
        UINT64 PageWriteThrough : 1; /* 3     */
        UINT64 PageCacheDisable : 1; /* 4     */
        UINT64 Accessed : 1;         /* 5     */
        UINT64 _Ignored0 : 1;        /* 6     */
        UINT64 _Reserved0 : 1;       /* 7     */
        UINT64 _Ignored1 : 4;        /* 11:8  */
        UINT64 PhysicalAddress : 40; /* 51:12 */
        UINT64 _Ignored2 : 11;       /* 62:52 */
        UINT64 ExecuteDisable : 1;   /* 63    */
    } Bits;
    UINT64 BitAddress;
} PML4E;

typedef union _PDPT_ENTRY {
    struct {
        UINT64 Present : 1;          /* 0     */
        UINT64 ReadWrite : 1;        /* 1     */
        UINT64 UserSupervisor : 1;   /* 2     */
        UINT64 PageWriteThrough : 1; /* 3     */
        UINT64 PageCacheDisable : 1; /* 4     */
        UINT64 Accessed : 1;         /* 5     */
        UINT64 _Ignored0 : 1;        /* 6     */
        UINT64 PageSize : 1;         /* 7     */
        UINT64 _Ignored1 : 4;        /* 11:8  */
        UINT64 PhysicalAddress : 40; /* 51:12 */
        UINT64 _Ignored2 : 11;       /* 62:52 */
        UINT64 ExecuteDisable : 1;   /* 63    */
    } Bits;
    UINT64 BitAddress;
} PDPTE;

typedef union _PD_ENTRY {
    struct {
        UINT64 Present : 1;          /* 0     */
        UINT64 ReadWrite : 1;        /* 1     */
        UINT64 UserSupervisor : 1;   /* 2     */
        UINT64 PageWriteThrough : 1; /* 3     */
        UINT64 PageCacheDisable : 1; /* 4     */
        UINT64 Accessed : 1;         /* 5     */
        UINT64 _Ignored0 : 1;        /* 6     */
        UINT64 PageSize : 1;         /* 7     */
        UINT64 _Ignored1 : 4;        /* 11:8  */
        UINT64 PhysicalAddress : 38; /* 49:12 */
        UINT64 _Reserved0 : 2;       /* 51:50 */
        UINT64 _Ignored2 : 11;       /* 62:52 */
        UINT64 ExecuteDisable : 1;   /* 63    */
    } Bits;
    UINT64 BitAddress;
} PDE;

typedef union _PT_ENTRY {
    struct {
        UINT64 Present : 1;            /* 0     */
        UINT64 ReadWrite : 1;          /* 1     */
        UINT64 UserSupervisor : 1;     /* 2     */
        UINT64 PageWriteThrough : 1;   /* 3     */
        UINT64 PageCacheDisable : 1;   /* 4     */
        UINT64 Accessed : 1;           /* 5     */
        UINT64 Dirty : 1;              /* 6     */
        UINT64 PageAttributeTable : 1; /* 7     */
        UINT64 Global : 1;             /* 8     */
        UINT64 _Ignored0 : 3;          /* 11:9  */
        UINT64 PhysicalAddress : 38;   /* 49:12 */
        UINT64 _Reserved0 : 2;         /* 51:50 */
        UINT64 _Ignored1 : 7;          /* 58:52 */
        UINT64 ProtectionKey : 4;      /* 62:59 */
        UINT64 ExecuteDisable : 1;     /* 63    */
    } Bits;
    UINT64 BitAddress;
} PTE;

typedef union _PDPT_ENTRY_LARGE {
    struct {
        UINT64 Present : 1;            /* 0     */
        UINT64 ReadWrite : 1;          /* 1     */
        UINT64 UserSupervisor : 1;     /* 2     */
        UINT64 PageWriteThrough : 1;   /* 3     */
        UINT64 PageCacheDisable : 1;   /* 4     */
        UINT64 Accessed : 1;           /* 5     */
        UINT64 Dirty : 1;              /* 6     */
        UINT64 PageSize : 1;           /* 7     */
        UINT64 Global : 1;             /* 8     */
        UINT64 _Ignored0 : 3;          /* 11:9  */
        UINT64 PageAttributeTable : 1; /* 12    */
        UINT64 _Reserved0 : 17;        /* 29:13 */
        UINT64 PhysicalAddress : 22;   /* 51:30 */
        UINT64 _Ignored1 : 7;          /* 58:52 */
        UINT64 ProtectionKey : 4;      /* 62:59 */
        UINT64 ExecuteDisable : 1;     /* 63    */
    } Bits;
    UINT64 BitAddress;
} PDPTE_LARGE;

typedef union _PD_ENTRY_LARGE {
    struct {
        UINT64 Present : 1;            /* 0     */
        UINT64 ReadWrite : 1;          /* 1     */
        UINT64 UserSupervisor : 1;     /* 2     */
        UINT64 PageWriteThrough : 1;   /* 3     */
        UINT64 PageCacheDisable : 1;   /* 4     */
        UINT64 Accessed : 1;           /* 5     */
        UINT64 Dirty : 1;              /* 6     */
        UINT64 PageSize : 1;           /* 7     */
        UINT64 Global : 1;             /* 8     */
        UINT64 _Ignored0 : 3;          /* 11:9  */
        UINT64 PageAttributeTalbe : 1; /* 12    */
        UINT64 _Reserved0 : 8;         /* 20:13 */
        UINT64 PhysicalAddress : 29;   /* 49:21 */
        UINT64 _Reserved1 : 2;         /* 51:50 */
        UINT64 _Ignored1 : 7;          /* 58:52 */
        UINT64 ProtectionKey : 4;      /* 62:59 */
        UINT64 ExecuteDisable : 1;     /* 63    */
    } Bits;
    UINT64 BitAddress;
} PDE_LARGE;

// typedef struct _KAPC_STATE
//{
//     LIST_ENTRY ApcListHead[ MaximumMode ];
//     struct _KPROCESS* Process;
//     union {
//         UCHAR InProgressFlags;
//         struct
//         {
//             BOOLEAN KernelApcInProgress : 1;
//             BOOLEAN SpecialApcInProgress : 1;
//         };
//     };
//
//     BOOLEAN KernelApcPending;
//     union {
//         BOOLEAN UserApcPendingAll;
//         struct
//         {
//             BOOLEAN SpecialUserApcPending : 1;
//             BOOLEAN UserApcPending : 1;
//         };
//     };
// } KAPC_STATE, * PKAPC_STATE, * PRKAPC_STATE;

typedef struct _RAW_SMBIOS_DATA {
    BYTE   Used20CallingMethod;
    BYTE   SMBIOSMajorVersion;
    BYTE   SMBIOSMinorVersion;
    BYTE   DmiRevision;
    UINT32 Length;
    BYTE   SMBIOSTableData[1];
} RAW_SMBIOS_DATA, *PRAW_SMBIOS_DATA;

typedef struct _SMBIOS_TABLE_HEADER {
    UCHAR  Type;
    UCHAR  Length;
    USHORT Handle;
    PCHAR  TableData;

} SMBIOS_TABLE_HEADER, *PSMBIOS_TABLE_HEADER;

typedef struct _RAW_SMBIOS_TABLE_01 {
    UCHAR  Type;
    UCHAR  Length;
    USHORT Handle;
    UCHAR  Manufacturer;
    UCHAR  ProductName;
    UCHAR  Version;
    UCHAR  SerialNumber;
    UCHAR  UUID[16];
    UCHAR  WakeUpType;
    UCHAR  SKUNumber;
    UCHAR  Family;

} RAW_SMBIOS_TABLE_01, *PRAW_SMBIOS_TABLE_01;

typedef struct _RAW_SMBIOS_TABLE_02 {
    UCHAR  Type;
    UCHAR  Length;
    USHORT Handle;
    BYTE   Manufacturer;
    BYTE   Product;
    BYTE   Version;
    BYTE   SerialNumber;
    BYTE   AssetTag;
    BYTE   FeatureFlags;
    BYTE   LocationInChassis;
    UINT16 ChassisHandle;
    BYTE   BoardType;
    BYTE   NumberOfContainedObjectHandles;
    BYTE   ContainedObjectHandles[256];

} RAW_SMBIOS_TABLE_02, *PRAW_SMBIOS_TABLE_02;

typedef struct _RTL_RELATIVE_NAME {
    UNICODE_STRING RelativeName;
    HANDLE         ContainingDirectory;
    void*          CurDirRef;
} RTL_RELATIVE_NAME, *PRTL_RELATIVE_NAME;

typedef struct _STORAGE_DESCRIPTOR_HEADER {
    ULONG Version;
    ULONG Size;
} STORAGE_DESCRIPTOR_HEADER, *PSTORAGE_DESCRIPTOR_HEADER;

typedef enum _STORAGE_BUS_TYPE {
    BusTypeUnknown = 0x00,
    BusTypeScsi,
    BusTypeAtapi,
    BusTypeAta,
    BusType1394,
    BusTypeSsa,
    BusTypeFibre,
    BusTypeUsb,
    BusTypeRAID,
    BusTypeMaxReserved = 0x7F
} STORAGE_BUS_TYPE,
    *PSTORAGE_BUS_TYPE;

typedef enum _STORAGE_SET_TYPE {
    PropertyStandardSet = 0, // Sets the descriptor
    PropertyExistsSet,       // Used to test whether the descriptor is supported
    PropertySetMaxDefined    // use to validate the value
} STORAGE_SET_TYPE,
    *PSTORAGE_SET_TYPE;

//
// define some initial property id's
//

typedef enum _STORAGE_QUERY_TYPE {
    PropertyStandardQuery = 0, // Retrieves the descriptor
    PropertyExistsQuery, // Used to test whether the descriptor is supported
    PropertyMaskQuery,   // Used to retrieve a mask of writeable fields in the
                         // descriptor
    PropertyQueryMaxDefined // use to validate the value
} STORAGE_QUERY_TYPE,
    *PSTORAGE_QUERY_TYPE;

typedef enum _STORAGE_PROPERTY_ID {
    StorageDeviceProperty = 0,
    StorageAdapterProperty,
    StorageDeviceIdProperty,
    StorageDeviceUniqueIdProperty, // See storduid.h for details
    StorageDeviceWriteCacheProperty,
    StorageMiniportProperty,
    StorageAccessAlignmentProperty,
    StorageDeviceSeekPenaltyProperty,
    StorageDeviceTrimProperty,
    StorageDeviceWriteAggregationProperty,
    StorageDeviceDeviceTelemetryProperty,
    StorageDeviceLBProvisioningProperty,
    StorageDevicePowerProperty,
    StorageDeviceCopyOffloadProperty,
    StorageDeviceResiliencyProperty,
    StorageDeviceMediumProductType,
    StorageAdapterRpmbProperty,
    StorageAdapterCryptoProperty,
    StorageDeviceIoCapabilityProperty = 48,
    StorageAdapterProtocolSpecificProperty,
    StorageDeviceProtocolSpecificProperty,
    StorageAdapterTemperatureProperty,
    StorageDeviceTemperatureProperty,
    StorageAdapterPhysicalTopologyProperty,
    StorageDevicePhysicalTopologyProperty,
    StorageDeviceAttributesProperty,
    StorageDeviceManagementStatus,
    StorageAdapterSerialNumberProperty,
    StorageDeviceLocationProperty,
    StorageDeviceNumaProperty,
    StorageDeviceZonedDeviceProperty,
    StorageDeviceUnsafeShutdownCount,
    StorageDeviceEnduranceProperty,
    StorageDeviceLedStateProperty,
    StorageDeviceSelfEncryptionProperty = 64,
    StorageFruIdProperty,
} STORAGE_PROPERTY_ID,
    *PSTORAGE_PROPERTY_ID;

typedef struct _STORAGE_PROPERTY_QUERY {
    STORAGE_PROPERTY_ID PropertyId;
    STORAGE_QUERY_TYPE  QueryType;
    UCHAR               AdditionalParameters[1];
} STORAGE_PROPERTY_QUERY, *PSTORAGE_PROPERTY_QUERY;

typedef struct _STORAGE_DEVICE_DESCRIPTOR {
    ULONG            Version;
    ULONG            Size;
    UCHAR            DeviceType;
    UCHAR            DeviceTypeModifier;
    BOOLEAN          RemovableMedia;
    BOOLEAN          CommandQueueing;
    ULONG            VendorIdOffset;
    ULONG            ProductIdOffset;
    ULONG            ProductRevisionOffset;
    ULONG            SerialNumberOffset;
    STORAGE_BUS_TYPE BusType;
    ULONG            RawPropertiesLength;
    UCHAR            RawDeviceProperties[1];
} STORAGE_DEVICE_DESCRIPTOR, *PSTORAGE_DEVICE_DESCRIPTOR;

NTKERNELAPI
BOOLEAN
ExEnumHandleTable(__in PHANDLE_TABLE               HandleTable,
                  __in EX_ENUMERATE_HANDLE_ROUTINE EnumHandleProcedure,
                  __in PVOID                       EnumParameter,
                  __out_opt PHANDLE                Handle);

NTKERNELAPI
POBJECT_TYPE
NTAPI
ObGetObjectType(_In_ PVOID Object);

typedef struct _EX_PUSH_LOCK_WAIT_BLOCK* PEX_PUSH_LOCK_WAIT_BLOCK;

NTKERNELAPI
VOID FASTCALL
ExfUnblockPushLock(_Inout_ PEX_PUSH_LOCK                PushLock,
                   _Inout_opt_ PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock);

LPCSTR
NTSYSAPI
NTAPI
PsGetProcessImageFileName(PEPROCESS Process);

EXTERN_C
VOID
KeInitializeAffinityEx(PKAFFINITY_EX affinity);

EXTERN_C
VOID
KeAddProcessorAffinityEx(PKAFFINITY_EX affinity, INT num);

EXTERN_C
VOID
HalSendNMI(PKAFFINITY_EX affinity);

NTSTATUS
RtlQueryModuleInformation(ULONG* InformationLength,
                          ULONG  SizePerModule,
                          PVOID  InformationBuffer);

NTSTATUS
NTAPI
NtSetInformationProcess(_In_ HANDLE           ProcessHandle,
                        _In_ PROCESSINFOCLASS ProcessInformationClass,
                        _In_ PVOID            ProcessInformation,
                        _In_ ULONG            ProcessInformationLength);

NTSYSAPI
ULONG
NTAPI
KeCapturePersistentThreadState(__in PCONTEXT     Context,
                               __in_opt PKTHREAD Thread,
                               __in ULONG        BugCheckCode,
                               __in ULONG_PTR    BugCheckParameter1,
                               __in ULONG_PTR    BugCheckParameter2,
                               __in ULONG_PTR    BugCheckParameter3,
                               __in ULONG_PTR    BugCheckParameter4,
                               __in PDUMP_HEADER DumpHeader);

BOOLEAN NTAPI
RtlDosPathNameToRelativeNtPathName_U(_In_ PCWSTR                  DosFileName,
                                     _Out_ PUNICODE_STRING        NtFileName,
                                     _Out_opt_ PWSTR*             FilePath,
                                     _Out_opt_ PRTL_RELATIVE_NAME RelativeName);

typedef _Function_class_(KNORMAL_ROUTINE) _IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
VOID NTAPI
                         KNORMAL_ROUTINE(_In_opt_ PVOID NormalContext,
                                         _In_opt_ PVOID SystemArgument1,
                                         _In_opt_ PVOID SystemArgument2);
typedef KNORMAL_ROUTINE* PKNORMAL_ROUTINE;

typedef _Function_class_(KRUNDOWN_ROUTINE) _IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
VOID NTAPI
                          KRUNDOWN_ROUTINE(_In_ PRKAPC Apc);
typedef KRUNDOWN_ROUTINE* PKRUNDOWN_ROUTINE;

typedef _Function_class_(KKERNEL_ROUTINE) _IRQL_requires_(APC_LEVEL)
_IRQL_requires_same_
VOID NTAPI
                         KKERNEL_ROUTINE(_In_ PRKAPC                                     Apc,
                                         _Inout_ _Deref_pre_maybenull_ PKNORMAL_ROUTINE* NormalRoutine,
                                         _Inout_ _Deref_pre_maybenull_ PVOID*            NormalContext,
                                         _Inout_ _Deref_pre_maybenull_ PVOID*            SystemArgument1,
                                         _Inout_ _Deref_pre_maybenull_ PVOID* SystemArgument2);
typedef KKERNEL_ROUTINE* PKKERNEL_ROUTINE;

typedef enum _KAPC_ENVIRONMENT {
    OriginalApcEnvironment,
    AttachedApcEnvironment,
    CurrentApcEnvironment,
    InsertApcEnvironment
} KAPC_ENVIRONMENT,
    *PKAPC_ENVIRONMENT;

NTKERNELAPI
VOID NTAPI
KeInitializeApc(_Out_ PRKAPC               Apc,
                _In_ PRKTHREAD             Thread,
                _In_ KAPC_ENVIRONMENT      Environment,
                _In_ PKKERNEL_ROUTINE      KernelRoutine,
                _In_opt_ PKRUNDOWN_ROUTINE RundownRoutine,
                _In_opt_ PKNORMAL_ROUTINE  NormalRoutine,
                _In_ KPROCESSOR_MODE       Mode,
                _In_opt_ PVOID             NormalContext);

NTSTATUS
NTAPI
MmCopyVirtualMemory(PEPROCESS       SourceProcess,
                    PVOID           SourceAddress,
                    PEPROCESS       TargetProcess,
                    PVOID           TargetAddress,
                    SIZE_T          BufferSize,
                    KPROCESSOR_MODE PreviousMode,
                    PSIZE_T         ReturnSize);

NTKERNELAPI
BOOLEAN
NTAPI
KeInsertQueueApc(_Inout_ PRKAPC Apc,
                 _In_opt_ PVOID SystemArgument1,
                 _In_opt_ PVOID SystemArgument2,
                 _In_ KPRIORITY Increment);

C_ASSERT(FIELD_OFFSET(DUMP_HEADER, Signature) == 0);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, ValidDump) == 4);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MajorVersion) == 8);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MinorVersion) == 0xc);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, DirectoryTableBase) == 0x10);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PfnDataBase) == 0x18);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PsLoadedModuleList) == 0x20);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PsActiveProcessHead) == 0x28);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MachineImageType) == 0x30);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, NumberProcessors) == 0x34);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckCode) == 0x38);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter1) == 0x40);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter2) == 0x48);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter3) == 0x50);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter4) == 0x58);
C_ASSERT(FIELD_OFFSET(DUMP_HEADER, KdDebuggerDataBlock) == 0x80);

#ifndef _WIN64
#    define KDDEBUGGER_DATA_OFFSET 0x1068
#else
#    define KDDEBUGGER_DATA_OFFSET 0x2080
#endif

#ifndef _WIN64
#    define DUMP_BLOCK_SIZE 0x20000
#else
#    define DUMP_BLOCK_SIZE 0x40000
#endif

#define IA32_GS_BASE                 0xc0000101
#define KPCR_TSS_BASE_OFFSET         0x008
#define TSS_IST_OFFSET               0x01c
#define WINDOWS_USERMODE_MAX_ADDRESS 0x00007FFFFFFFFFFF

typedef struct _MACHINE_FRAME {
    UINT64 rip;
    UINT64 cs;
    UINT64 eflags;
    UINT64 rsp;
    UINT64 ss;

} MACHINE_FRAME, *PMACHINE_FRAME;

NTKERNELAPI
_IRQL_requires_max_(APC_LEVEL)
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_same_
VOID
KeGenericCallDpc(_In_ PKDEFERRED_ROUTINE Routine, _In_opt_ PVOID Context);

NTKERNELAPI
_IRQL_requires_(DISPATCH_LEVEL)
_IRQL_requires_same_
VOID
KeSignalCallDpcDone(_In_ PVOID SystemArgument1);

PEPROCESS
NTAPI
PsGetNextProcess(IN PEPROCESS OldProcess OPTIONAL);

PETHREAD
NTAPI
PsGetNextProcessThread(IN PEPROCESS Process, IN PETHREAD Thread OPTIONAL);

#define ABSOLUTE(wait) (wait)

#define RELATIVE(wait) (-(wait))

#define NANOSECONDS(nanos) (((signed __int64)(nanos)) / 100L)

#define MICROSECONDS(micros) (((signed __int64)(micros)) * NANOSECONDS(1000L))

#define MILLISECONDS(milli) (((signed __int64)(milli)) * MICROSECONDS(1000L))

#define SECONDS(seconds) (((signed __int64)(seconds)) * MILLISECONDS(1000L))

// https://learn.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights
#define PROCESS_CREATE_PROCESS            0x0080
#define PROCESS_TERMINATE                 0x0001
#define PROCESS_CREATE_THREAD             0x0002
#define PROCESS_QUERY_INFORMATION         0x0400
#define PROCESS_QUERY_LIMITED_INFORMATION 0x1000
#define PROCESS_SET_INFORMATION           0x0200
#define PROCESS_SET_QUOTA                 0x0100
#define PROCESS_SUSPEND_RESUME            0x0800
#define PROCESS_VM_OPERATION              0x0008
#define PROCESS_VM_READ                   0x0010
#define PROCESS_VM_WRITE                  0x0020

#endif

```

`driver/cpp.hint`:

```hint
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define _Inout_ _SAL2_Source_(_Inout_, (), _Prepost_valid_)
#define _Inout_
#define _In_ _SAL2_Source_(_In_, (), _Pre1_impl_(__notnull_impl_notref) _Pre_valid_impl_ _Deref_pre1_impl_(__readaccess_impl_notref))
#define _In_
#define STATIC
#define VOID
#define INLINE

```

`driver/crypt.c`:

```c
#include "crypt.h"

#include <immintrin.h>
#include "imports.h"

#include <bcrypt.h>

#define XOR_KEY_1 0x1122334455667788
#define XOR_KEY_2 0x0011223344556677
#define XOR_KEY_3 0x5566778899AABBCC
#define XOR_KEY_4 0x66778899AABBCCDD

STATIC
__m256i
CryptGenerateSseXorKey()
{
    return _mm256_set_epi64x(XOR_KEY_1, XOR_KEY_2, XOR_KEY_3, XOR_KEY_4);
}

VOID
CryptEncryptImportsArray(_In_ PUINT64 Array, _In_ UINT32 Entries)
{
    UINT32 block_size  = sizeof(__m256i) / sizeof(UINT64);
    UINT32 block_count = Entries / block_size;

    /*
     * Here we break down the import array into blocks of 32 bytes. Each
     * block is loaded into an SSE register, xored with the key, and then
     * copied back into the array.
     */
    for (UINT32 block_index = 0; block_index < block_count; block_index++) {
        __m256i current_block = {0};
        __m256i load_block    = {0};
        __m256i xored_block   = {0};

        RtlCopyMemory(
            &current_block, &Array[block_index * block_size], sizeof(__m256i));

        load_block  = _mm256_loadu_si256(&current_block);
        xored_block = _mm256_xor_si256(load_block, CryptGenerateSseXorKey());

        RtlCopyMemory(
            &Array[block_index * block_size], &xored_block, sizeof(__m256i));
    }
}

STATIC
INLINE
__m256i
CryptDecryptImportBlock(_In_ PUINT64 Array, _In_ UINT32 BlockIndex)
{
    __m256i load_block = {0};
    UINT32  block_size = sizeof(__m256i) / sizeof(UINT64);

    RtlCopyMemory(
        &load_block, &Array[BlockIndex * block_size], sizeof(__m256i));

    return _mm256_xor_si256(load_block, CryptGenerateSseXorKey());
}

STATIC
INLINE
VOID
CryptFindContainingBlockForArrayIndex(_In_ UINT32   EntryIndex,
                                      _In_ UINT32   BlockSize,
                                      _Out_ PUINT32 ContainingBlockIndex,
                                      _Out_ PUINT32 BlockSubIndex)
{
    UINT32 containing_block = EntryIndex;
    UINT32 block_index      = 0;

    if (EntryIndex < BlockSize) {
        *ContainingBlockIndex = 0;
        *BlockSubIndex        = EntryIndex;
        return;
    }

    if (EntryIndex == BlockSize) {
        *ContainingBlockIndex = 1;
        *BlockSubIndex        = 0;
        return;
    }

    while (containing_block % BlockSize != 0) {
        containing_block--;
        block_index++;
    }

    *ContainingBlockIndex = containing_block / BlockSize;
    *BlockSubIndex        = block_index;
}

UINT64
CryptDecryptImportsArrayEntry(_In_ PUINT64 Array,
                              _In_ UINT32  Entries,
                              _In_ UINT32  EntryIndex)
{
    __m256i original_block         = {0};
    __m128i original_half          = {0};
    UINT32  block_size             = sizeof(__m256i) / sizeof(UINT64);
    UINT32  containing_block_index = 0;
    UINT32  block_sub_index        = 0;
    UINT64  pointer                = 0;

    CryptFindContainingBlockForArrayIndex(
        EntryIndex, block_size, &containing_block_index, &block_sub_index);

    original_block = CryptDecryptImportBlock(Array, containing_block_index);

    if (block_sub_index < 2) {
        original_half = _mm256_extracti128_si256(original_block, 0);

        if (block_sub_index < 1)
            pointer = _mm_extract_epi64(original_half, 0);
        else
            pointer = _mm_extract_epi64(original_half, 1);
    }
    else {
        original_half = _mm256_extracti128_si256(original_block, 1);

        if (block_sub_index == 2)
            pointer = _mm_extract_epi64(original_half, 0);
        else
            pointer = _mm_extract_epi64(original_half, 1);
    }

    return pointer;
}

/*
 * simple for now.. just to get it working
 */
VOID
CryptDecryptBufferWithCookie(_In_ PVOID  Buffer,
                             _In_ UINT32 BufferSize,
                             _In_ UINT32 Cookie)
{
    PCHAR buffer = (PCHAR)Buffer;
    for (UINT32 index = 0; index < BufferSize; index++) {
        buffer[index] ^= Cookie;
    }
}

```

`driver/crypt.h`:

```h
#ifndef CRYPT_H
#define CRYPT_H

#include "common.h"

VOID
CryptEncryptImportsArray(_In_ PUINT64 Array, _In_ UINT32 Entries);

UINT64
CryptDecryptImportsArrayEntry(_In_ PUINT64 Array,
                              _In_ UINT32  Entries,
                              _In_ UINT32  EntryIndex);

VOID
CryptDecryptBufferWithCookie(_In_ PVOID  Buffer,
                             _In_ UINT32 BufferSize,
                             _In_ UINT32 Cookie);

#endif
```

`driver/driver.c`:

```c
#include "driver.h"

#include "common.h"
#include "io.h"
#include "callbacks.h"

#include "hv.h"
#include "pool.h"
#include "thread.h"
#include "modules.h"
#include "integrity.h"
#include "imports.h"
#include "apc.h"
#include "crypt.h"
#include "session.h"
#include "hw.h"

STATIC
VOID
DriverUnload(_In_ PDRIVER_OBJECT DriverObject);

_Function_class_(DRIVER_INITIALIZE) _IRQL_requires_same_
NTSTATUS
DriverEntry(_In_ PDRIVER_OBJECT  DriverObject,
            _In_ PUNICODE_STRING RegistryPath);

STATIC
NTSTATUS
RegistryPathQueryCallbackRoutine(IN PWSTR ValueName,
                                 IN ULONG ValueType,
                                 IN PVOID ValueData,
                                 IN ULONG ValueLength,
                                 IN PVOID Context,
                                 IN PVOID EntryContext);

STATIC
VOID
DrvUnloadUnregisterObCallbacks();

STATIC
VOID
DrvUnloadFreeConfigStrings();

STATIC
VOID
DrvUnloadFreeThreadList();

STATIC
VOID
DrvUnloadFreeProcessList();

STATIC
NTSTATUS
DrvLoadEnableNotifyRoutines();

STATIC
NTSTATUS
DrvLoadInitialiseDriverConfig(_In_ PDRIVER_OBJECT  DriverObject,
                              _In_ PUNICODE_STRING RegistryPath);

#ifdef ALLOC_PRAGMA
#    pragma alloc_text(INIT, DriverEntry)
#    pragma alloc_text(PAGE, GetDriverName)
#    pragma alloc_text(PAGE, GetDriverPath)
#    pragma alloc_text(PAGE, GetDriverRegistryPath)
#    pragma alloc_text(PAGE, GetDriverDeviceName)
#    pragma alloc_text(PAGE, GetDriverSymbolicLink)
#    pragma alloc_text(PAGE, GetDriverConfigSystemInformation)
#    pragma alloc_text(PAGE, RegistryPathQueryCallbackRoutine)
#    pragma alloc_text(PAGE, DrvUnloadUnregisterObCallbacks)
#    pragma alloc_text(PAGE, DrvUnloadFreeConfigStrings)
#    pragma alloc_text(PAGE, DrvUnloadFreeThreadList)
#    pragma alloc_text(PAGE, DrvLoadEnableNotifyRoutines)
#    pragma alloc_text(PAGE, DrvLoadEnableNotifyRoutines)
#    pragma alloc_text(PAGE, DrvLoadInitialiseDriverConfig)
#endif

typedef struct _DRIVER_CONFIG {
    volatile LONG          nmi_status;
    UNICODE_STRING         unicode_driver_name;
    ANSI_STRING            ansi_driver_name;
    PUNICODE_STRING        device_name;
    PUNICODE_STRING        device_symbolic_link;
    UNICODE_STRING         driver_path;
    UNICODE_STRING         registry_path;
    SYSTEM_INFORMATION     system_information;
    PVOID                  apc_contexts[MAXIMUM_APC_CONTEXTS];
    PDRIVER_OBJECT         driver_object;
    PDEVICE_OBJECT         device_object;
    volatile BOOLEAN       unload_in_progress;
    KGUARDED_MUTEX         lock;
    SYS_MODULE_VAL_CONTEXT sys_val_context;
    IRP_QUEUE_HEAD         irp_queue;
    TIMER_OBJECT           timer;
    ACTIVE_SESSION         active_session;
    THREAD_LIST_HEAD       thread_list;
    DRIVER_LIST_HEAD       driver_list;
    PROCESS_LIST_HEAD      process_list;
    SHARED_MAPPING         mapping;
    BOOLEAN                has_driver_loaded;

} DRIVER_CONFIG, *PDRIVER_CONFIG;

UNICODE_STRING g_DeviceName         = RTL_CONSTANT_STRING(L"\\Device\\DonnaAC");
UNICODE_STRING g_DeviceSymbolicLink = RTL_CONSTANT_STRING(L"\\??\\DonnaAC");

/*
 * Rather then getting the driver state from the device object passed to our
 * IOCTL handlers, store a pointer to the device extension here and abstract it
 * with getters which can be accessed globally. The reason for this is because
 * there isnt a way for us to pass a context structure to some of notify
 * routines so I think it's better to do it this way.
 *
 * Note that the device extension pointer should be encrypted
 */
PDRIVER_CONFIG g_DriverConfig = NULL;

#define POOL_TAG_CONFIG 'conf'

BOOLEAN
HasDriverLoaded()
{
    return g_DriverConfig->has_driver_loaded;
}

VOID
UnsetNmiInProgressFlag()
{
    InterlockedDecrement(&g_DriverConfig->nmi_status);
}

BOOLEAN
IsNmiInProgress()
{
    /* if the initial value is true, we dont own the lock hence return false
     */
    return InterlockedCompareExchange(
               &g_DriverConfig->nmi_status, TRUE, FALSE) == 0
               ? FALSE
               : TRUE;
}

PSHARED_MAPPING
GetSharedMappingConfig()
{
    return &g_DriverConfig->mapping;
}

VOID
AcquireDriverConfigLock()
{
    ImpKeAcquireGuardedMutex(&g_DriverConfig->lock);
}

VOID
ReleaseDriverConfigLock()
{
    ImpKeReleaseGuardedMutex(&g_DriverConfig->lock);
}

PUINT64
GetApcContextArray()
{
    return (PUINT64)g_DriverConfig->apc_contexts;
}

BOOLEAN
IsDriverUnloading()
{
    return InterlockedExchange(&g_DriverConfig->unload_in_progress,
                               g_DriverConfig->unload_in_progress);
}

PACTIVE_SESSION
GetActiveSession()
{
    return &g_DriverConfig->active_session;
}

LPCSTR
GetDriverName()
{
    PAGED_CODE();
    return g_DriverConfig->ansi_driver_name.Buffer;
}

PDEVICE_OBJECT
GetDriverDeviceObject()
{
    PAGED_CODE();
    return g_DriverConfig->device_object;
}

PDRIVER_OBJECT
GetDriverObject()
{
    PAGED_CODE();
    return g_DriverConfig->driver_object;
}

PIRP_QUEUE_HEAD
GetIrpQueueHead()
{
    return &g_DriverConfig->irp_queue;
}

PSYS_MODULE_VAL_CONTEXT
GetSystemModuleValidationContext()
{
    PAGED_CODE();
    return &g_DriverConfig->sys_val_context;
}

PUNICODE_STRING
GetDriverPath()
{
    PAGED_CODE();
    return &g_DriverConfig->driver_path;
}

PUNICODE_STRING
GetDriverRegistryPath()
{
    PAGED_CODE();
    return &g_DriverConfig->registry_path;
}

PUNICODE_STRING
GetDriverDeviceName()
{
    PAGED_CODE();
    return &g_DriverConfig->device_name;
}

PUNICODE_STRING
GetDriverSymbolicLink()
{
    PAGED_CODE();
    return &g_DriverConfig->device_symbolic_link;
}

PSYSTEM_INFORMATION
GetDriverConfigSystemInformation()
{
    PAGED_CODE();
    return &g_DriverConfig->system_information;
}

PTHREAD_LIST_HEAD
GetThreadList()
{
    PAGED_CODE();
    return &g_DriverConfig->thread_list;
}

PDRIVER_LIST_HEAD
GetDriverList()
{
    PAGED_CODE();
    return &g_DriverConfig->driver_list;
}

PPROCESS_LIST_HEAD
GetProcessList()
{
    PAGED_CODE();
    return &g_DriverConfig->process_list;
}

/*
 * The question is, What happens if we attempt to register our callbacks after
 * we unregister them but before we free the pool? Hm.. No Good.
 *
 * Okay to solve this well acquire the driver lock aswell, we could also just
 * store the structure in the .data section but i ceebs atm.
 *
 * This definitely doesn't seem optimal, but it works ...
 */
STATIC
VOID
DrvUnloadUnregisterObCallbacks()
{
    PAGED_CODE();
    UnregisterProcessObCallbacks();
}

STATIC
VOID
DrvUnloadFreeConfigStrings()
{
    PAGED_CODE();

    if (g_DriverConfig->unicode_driver_name.Buffer)
        ImpExFreePoolWithTag(g_DriverConfig->unicode_driver_name.Buffer,
                             POOL_TAG_STRINGS);

    if (g_DriverConfig->driver_path.Buffer)
        ImpExFreePoolWithTag(g_DriverConfig->driver_path.Buffer,
                             POOL_TAG_STRINGS);

    if (g_DriverConfig->ansi_driver_name.Buffer)
        ImpRtlFreeAnsiString(&g_DriverConfig->ansi_driver_name);
}

STATIC
VOID
DrvUnloadDeleteSymbolicLink()
{
    if (g_DriverConfig->device_symbolic_link)
        ImpIoDeleteSymbolicLink(g_DriverConfig->device_symbolic_link);
}

STATIC
VOID
DrvUnloadFreeThreadList()
{
    PAGED_CODE();
    CleanupThreadListOnDriverUnload();
}

STATIC
VOID
DrvUnloadFreeDriverList()
{
    PAGED_CODE();
    CleanupDriverListOnDriverUnload();
}

STATIC
VOID
DrvUnloadFreeTimerObject()
{
    PAGED_CODE();
    CleanupDriverTimerObjects(&g_DriverConfig->timer);
}

STATIC
VOID
DrvUnloadFreeProcessList()
{
    PAGED_CODE();
    CleanupProcessListOnDriverUnload();
}

STATIC
VOID
DrvUnloadFreeModuleValidationContext()
{
    PAGED_CODE();
    CleanupValidationContextOnUnload(&g_DriverConfig->sys_val_context);
}

STATIC
VOID
DriverUnload(_In_ PDRIVER_OBJECT DriverObject)
{
    DEBUG_VERBOSE("Unloading...");

    InterlockedExchange(&g_DriverConfig->unload_in_progress, TRUE);

    /*
     * This blocks the thread dispatching the unload routine, which I don't
     * think is ideal. This is the issue with using APCs, we have very
     * little safe control over when they complete and thus when we can free
     * them.. For now, thisl do.
     */
    while (DrvUnloadFreeAllApcContextStructures() == FALSE)
        YieldProcessor();

    DrvUnloadFreeTimerObject();
    DrvUnloadFreeModuleValidationContext();
    DrvUnloadUnregisterObCallbacks();

    UnregisterThreadCreateNotifyRoutine();
    UnregisterProcessCreateNotifyRoutine();
    UnregisterImageLoadNotifyRoutine();

    DrvUnloadFreeThreadList();
    DrvUnloadFreeProcessList();
    DrvUnloadFreeDriverList();

    DrvUnloadFreeConfigStrings();
    DrvUnloadDeleteSymbolicLink();
    ImpIoDeleteDevice(DriverObject->DeviceObject);

    DEBUG_INFO("Driver successfully unloaded.");
}

STATIC
NTSTATUS
DrvLoadEnableNotifyRoutines()
{
    PAGED_CODE();

    NTSTATUS status = STATUS_UNSUCCESSFUL;

    DEBUG_VERBOSE("Enabling driver wide notify routines.");

    status = PsSetLoadImageNotifyRoutine(ImageLoadNotifyRoutineCallback);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("PsSetLoadImageNotifyRoutine failed with status %x",
                    status);
        return status;
    }

    status = ImpPsSetCreateThreadNotifyRoutine(ThreadCreateNotifyRoutine);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("PsSetCreateThreadNotifyRoutine failed with status %x",
                    status);
        PsRemoveLoadImageNotifyRoutine(ImageLoadNotifyRoutineCallback);
        return status;
    }

    status =
        ImpPsSetCreateProcessNotifyRoutine(ProcessCreateNotifyRoutine, FALSE);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("PsSetCreateProcessNotifyRoutine failed with status %x",
                    status);
        ImpPsRemoveCreateThreadNotifyRoutine(ThreadCreateNotifyRoutine);
        PsRemoveLoadImageNotifyRoutine(ImageLoadNotifyRoutineCallback);
        return status;
    }

    DEBUG_VERBOSE("Successfully enabled driver wide notify routines.");
    return status;
}

STATIC
NTSTATUS
DrvLoadSetupDriverLists()
{
    PAGED_CODE();

    NTSTATUS status = STATUS_UNSUCCESSFUL;

    status = InitialiseDriverList();

    if (!NT_SUCCESS(status)) {
        UnregisterProcessCreateNotifyRoutine();
        UnregisterThreadCreateNotifyRoutine();
        UnregisterImageLoadNotifyRoutine();
        DEBUG_ERROR("InitialiseDriverList failed with status %x", status);
        return status;
    }

    status = InitialiseThreadList();

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("InitialiseThreadList failed with status %x", status);
        UnregisterProcessCreateNotifyRoutine();
        UnregisterThreadCreateNotifyRoutine();
        UnregisterImageLoadNotifyRoutine();
        CleanupDriverListOnDriverUnload();
        return status;
    }

    status = InitialiseProcessList();

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("InitialiseProcessList failed with status %x", status);
        UnregisterProcessCreateNotifyRoutine();
        UnregisterThreadCreateNotifyRoutine();
        UnregisterImageLoadNotifyRoutine();
        CleanupDriverListOnDriverUnload();
        CleanupThreadListOnDriverUnload();
        return status;
    }

    return status;
}

/*
 * Regular routines
 */

STATIC
NTSTATUS
RegistryPathQueryCallbackRoutine(IN PWSTR ValueName,
                                 IN ULONG ValueType,
                                 IN PVOID ValueData,
                                 IN ULONG ValueLength,
                                 IN PVOID Context,
                                 IN PVOID EntryContext)
{
    PAGED_CODE();

    UNICODE_STRING value_name   = {0};
    UNICODE_STRING image_path   = RTL_CONSTANT_STRING(L"ImagePath");
    UNICODE_STRING display_name = RTL_CONSTANT_STRING(L"DisplayName");
    UNICODE_STRING value        = {0};
    PVOID          temp_buffer  = NULL;

    ImpRtlInitUnicodeString(&value_name, ValueName);

    if (ImpRtlCompareUnicodeString(&value_name, &image_path, FALSE) == FALSE) {
        temp_buffer =
            ImpExAllocatePool2(POOL_FLAG_PAGED, ValueLength, POOL_TAG_STRINGS);

        if (!temp_buffer)
            return STATUS_MEMORY_NOT_ALLOCATED;

        RtlCopyMemory(temp_buffer, ValueData, ValueLength);

        g_DriverConfig->driver_path.Buffer        = (PWCH)temp_buffer;
        g_DriverConfig->driver_path.Length        = ValueLength;
        g_DriverConfig->driver_path.MaximumLength = ValueLength;
    }

    if (ImpRtlCompareUnicodeString(&value_name, &display_name, FALSE) ==
        FALSE) {
        temp_buffer = ImpExAllocatePool2(
            POOL_FLAG_PAGED, ValueLength + 20, POOL_TAG_STRINGS);

        if (!temp_buffer)
            return STATUS_MEMORY_NOT_ALLOCATED;

        /*
         * The registry path driver name does not contain the .sys
         * extension which is required for us since when we enumerate
         * the system modules we are comparing the entire path including
         * the .sys extension. Hence we add it to the end of the buffer
         * here.
         */
        RtlCopyMemory(temp_buffer, ValueData, ValueLength);
        wcscpy((UINT64)temp_buffer + ValueLength - 2, L".sys");

        g_DriverConfig->unicode_driver_name.Buffer        = (PWCH)temp_buffer;
        g_DriverConfig->unicode_driver_name.Length        = ValueLength + 20;
        g_DriverConfig->unicode_driver_name.MaximumLength = ValueLength + 20;
    }

    return STATUS_SUCCESS;
}

/*
 * Values returned from CPUID that are equval to the vendor string
 */
#define CPUID_AUTHENTIC_AMD_EBX 0x68747541
#define CPUID_AUTHENTIC_AMD_EDX 0x69746e65
#define CPUID_AUTHENTIC_AMD_ECX 0x444d4163

#define CPUID_GENUINE_INTEL_EBX 0x756e6547
#define CPUID_GENUINE_INTEL_EDX 0x49656e69
#define CPUID_GENUINE_INTEL_ECX 0x6c65746e

#define EBX_REGISTER 1
#define ECX_REGISTER 2
#define EDX_REGISTER 3

STATIC
NTSTATUS
GetSystemProcessorType()
{
    UINT32 cpuid[4] = {0};

    __cpuid(cpuid, 0);

    DEBUG_VERBOSE(
        "Cpuid: EBX: %lx, ECX: %lx, EDX: %lx", cpuid[1], cpuid[2], cpuid[3]);

    if (cpuid[EBX_REGISTER] == CPUID_AUTHENTIC_AMD_EBX &&
        cpuid[ECX_REGISTER] == CPUID_AUTHENTIC_AMD_ECX &&
        cpuid[EDX_REGISTER] == CPUID_AUTHENTIC_AMD_EDX) {
        g_DriverConfig->system_information.processor = GenuineIntel;
        return STATUS_SUCCESS;
    }
    else if (cpuid[EBX_REGISTER] == CPUID_GENUINE_INTEL_EBX &&
             cpuid[ECX_REGISTER] == CPUID_GENUINE_INTEL_ECX &&
             cpuid[EDX_REGISTER] == CPUID_GENUINE_INTEL_EDX) {
        g_DriverConfig->system_information.processor = AuthenticAmd;
        return STATUS_SUCCESS;
    }
    else {
        g_DriverConfig->system_information.processor = Unknown;
        return STATUS_UNSUCCESSFUL;
    }
}

/*
 * Even though we are technically not meant to be operating when running under a
 * virtualized system, it is still useful to test the attainment of system
 * information under a virtualized system for testing purposes.
 */
STATIC
NTSTATUS
ParseSmbiosForGivenSystemEnvironment()
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    status = ParseSMBIOSTable(&g_DriverConfig->system_information.vendor,
                              VENDOR_STRING_MAX_LENGTH,
                              SmbiosInformation,
                              SMBIOS_VENDOR_STRING_SUB_INDEX);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ParseSMBIOSTable failed with status %x", status);
        return status;
    }

    if (strstr(&g_DriverConfig->system_information.vendor, "VMware, Inc"))
        g_DriverConfig->system_information.environment = Vmware;
    else if (strstr(&g_DriverConfig->system_information.vendor, "innotek GmbH"))
        g_DriverConfig->system_information.environment = VirtualBox;
    else
        g_DriverConfig->system_information.environment = NativeWindows;

    switch (g_DriverConfig->system_information.environment) {
    case NativeWindows: {
        /*
         * TODO: double check that amd indexes are the same should be,
         * but should check just in case
         */
        status = ParseSMBIOSTable(
            &g_DriverConfig->system_information.motherboard_serial,
            MOTHERBOARD_SERIAL_CODE_LENGTH,
            VendorSpecificInformation,
            SMBIOS_NATIVE_SERIAL_NUMBER_SUB_INDEX);

        break;
    }
    case Vmware: {
        status = ParseSMBIOSTable(
            &g_DriverConfig->system_information.motherboard_serial,
            MOTHERBOARD_SERIAL_CODE_LENGTH,
            SystemInformation,
            SMBIOS_VMWARE_SERIAL_NUMBER_SUB_INDEX);

        break;
    }
    case VirtualBox:
    default:
        DEBUG_WARNING("Environment type not supported.");
        return STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ParseSMBIOSTable 2 failed with status %x", status);
        return status;
    }

    return status;
}

STATIC
NTSTATUS
DrvLoadGatherSystemEnvironmentSettings()
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    /*
     * On Vmware, the APERF_MSR is not emulated hence this will return TRUE.
     */
    if (APERFMsrTimingCheck())
        g_DriverConfig->system_information.virtualised_environment = TRUE;

    status = GetOsVersionInformation(
        &g_DriverConfig->system_information.os_information);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetOsVersionInformation failed with status %x", status);
        return status;
    }

    status = GetSystemProcessorType();

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetSystemProcessorType failed with status %x", status);
        return status;
    }

    status = ParseSmbiosForGivenSystemEnvironment();

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR(
            "ParseSmbiosForGivenSystemEnvironment failed with status %x",
            status);
        return status;
    }

    status = GetHardDiskDriveSerialNumber(
        &g_DriverConfig->system_information.drive_0_serial,
        sizeof(g_DriverConfig->system_information.drive_0_serial));

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetHardDiskDriverSerialNumber failed with status %x",
                    status);
        return status;
    }

    DEBUG_VERBOSE(
        "OS Major Version: %lx, Minor Version: %lx, Build Number: %lx",
        g_DriverConfig->system_information.os_information.dwMajorVersion,
        g_DriverConfig->system_information.os_information.dwMinorVersion,
        g_DriverConfig->system_information.os_information.dwBuildNumber);
    DEBUG_VERBOSE("Environment type: %lx",
                  g_DriverConfig->system_information.environment);
    DEBUG_VERBOSE("Processor type: %lx",
                  g_DriverConfig->system_information.processor);
    DEBUG_VERBOSE("Motherboard serial: %s",
                  g_DriverConfig->system_information.motherboard_serial);
    DEBUG_VERBOSE("Drive 0 serial: %s",
                  g_DriverConfig->system_information.drive_0_serial);

    return status;
}

STATIC
NTSTATUS
DrvLoadRetrieveDriverNameFromRegistry(_In_ PUNICODE_STRING RegistryPath)
{
    NTSTATUS                 status         = STATUS_UNSUCCESSFUL;
    RTL_QUERY_REGISTRY_TABLE query_table[3] = {0};

    query_table[0].Flags         = RTL_QUERY_REGISTRY_NOEXPAND;
    query_table[0].Name          = L"ImagePath";
    query_table[0].DefaultType   = REG_MULTI_SZ;
    query_table[0].DefaultLength = 0;
    query_table[0].DefaultData   = NULL;
    query_table[0].EntryContext  = NULL;
    query_table[0].QueryRoutine  = RegistryPathQueryCallbackRoutine;

    query_table[1].Flags         = RTL_QUERY_REGISTRY_NOEXPAND;
    query_table[1].Name          = L"DisplayName";
    query_table[1].DefaultType   = REG_SZ;
    query_table[1].DefaultLength = 0;
    query_table[1].DefaultData   = NULL;
    query_table[1].EntryContext  = NULL;
    query_table[1].QueryRoutine  = RegistryPathQueryCallbackRoutine;

    status = RtlxQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE, RegistryPath->Buffer, &query_table, NULL, NULL);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("RtlxQueryRegistryValues failed with status %x", status);
        return status;
    }

    /*
     * The registry path contains the name of the driver i.e Driver, but
     * does not contain the .sys extension. Lets add it to our stored driver
     * name since we need the .sys extension when querying the system
     * modules for our driver.
     */

    status =
        ImpRtlUnicodeStringToAnsiString(&g_DriverConfig->ansi_driver_name,
                                        &g_DriverConfig->unicode_driver_name,
                                        TRUE);

    if (!NT_SUCCESS(status))
        DEBUG_ERROR("RtlUnicodeStringToAnsiString failed with status %x",
                    status);

    return status;
}

STATIC
NTSTATUS
DrvLoadInitialiseDriverConfig(_In_ PDRIVER_OBJECT  DriverObject,
                              _In_ PUNICODE_STRING RegistryPath)
{
    PAGED_CODE();
    DEBUG_VERBOSE("Initialising driver configuration");

    NTSTATUS status = STATUS_UNSUCCESSFUL;

    ImpKeInitializeGuardedMutex(&g_DriverConfig->lock);

    IrpQueueInitialise();
    SessionInitialiseCallbackConfiguration();

    g_DriverConfig->unload_in_progress                         = FALSE;
    g_DriverConfig->system_information.virtualised_environment = FALSE;
    g_DriverConfig->sys_val_context.active                     = FALSE;

    status = DrvLoadRetrieveDriverNameFromRegistry(RegistryPath);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR(
            "DrvLoadRetrieveDriverNameFromRegistry failed with status %x",
            status);
        return status;
    }

    /* when this function failed, we bugcheck in freeconfigstrings todo: fix
     */
    status = DrvLoadGatherSystemEnvironmentSettings();

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GatherSystemEnvironmentSettings failed with status %x",
                    status);
        return status;
    }

    status = InitialiseTimerObject(&g_DriverConfig->timer);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("InitialiseTimerObject failed with status %x", status);
        return status;
    }

    status = IrpQueueInitialise();

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("IrpQueueInitialise failed with status %x", status);
        return status;
    }

    DEBUG_VERBOSE("driver name: %s", g_DriverConfig->ansi_driver_name.Buffer);
    return status;
}

NTSTATUS
DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
    BOOLEAN  flag   = FALSE;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = DeviceCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = DeviceClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceControl;
    DriverObject->DriverUnload                         = DriverUnload;

    status = ImpResolveDynamicImports(DriverObject);

    if (!NT_SUCCESS(status))
        return STATUS_FAILED_DRIVER_ENTRY;

    DEBUG_VERBOSE("Beginning driver entry routine...");

    status = ImpIoCreateDevice(DriverObject,
                               sizeof(DRIVER_CONFIG),
                               &g_DeviceName,
                               FILE_DEVICE_UNKNOWN,
                               FILE_DEVICE_SECURE_OPEN,
                               FALSE,
                               &DriverObject->DeviceObject);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("IoCreateDevice failed with status %x", status);
        return status;
    }

    g_DriverConfig                = DriverObject->DeviceObject->DeviceExtension;
    g_DriverConfig->device_object = DriverObject->DeviceObject;
    g_DriverConfig->driver_object = DriverObject;
    g_DriverConfig->device_name   = &g_DeviceName;
    g_DriverConfig->device_symbolic_link = &g_DeviceSymbolicLink;

    status = DrvLoadInitialiseDriverConfig(DriverObject, RegistryPath);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("InitialiseDriverConfigOnDriverEntry failed with status %x",
                    status);
        DrvUnloadFreeConfigStrings();
        ImpIoDeleteDevice(DriverObject->DeviceObject);
        return status;
    }

    SessionInitialiseStructure();

    status = IoCreateSymbolicLink(g_DriverConfig->device_symbolic_link,
                                  g_DriverConfig->device_name);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("IoCreateSymbolicLink failed with status %x", status);
        DrvUnloadFreeConfigStrings();
        DrvUnloadFreeTimerObject();
        ImpIoDeleteDevice(DriverObject->DeviceObject);
        return status;
    }

    status = DrvLoadEnableNotifyRoutines();

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("EnablenotifyRoutines failed with status %x", status);
        DrvUnloadFreeConfigStrings();
        DrvUnloadFreeTimerObject();
        DrvUnloadDeleteSymbolicLink();
        ImpIoDeleteDevice(DriverObject->DeviceObject);
        return status;
    }

    status = DrvLoadSetupDriverLists();

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("DrvLoadSetupDriverLists failed with status %x", status);
        DrvUnloadFreeConfigStrings();
        DrvUnloadFreeTimerObject();
        DrvUnloadDeleteSymbolicLink();
        ImpIoDeleteDevice(DriverObject->DeviceObject);
        return status;
    }

    g_DriverConfig->has_driver_loaded = TRUE;

    DEBUG_INFO("Driver Entry Complete.");
    return STATUS_SUCCESS;
}

```

`driver/driver.h`:

```h
#ifndef DRIVER_H
#define DRIVER_H

#include "common.h"

#include <wdf.h>

#include "queue.h"
#include "modules.h"
#include "integrity.h"
#include "callbacks.h"

NTSTATUS
QueryActiveApcContextsForCompletion();

LPCSTR
GetDriverName();

PDEVICE_OBJECT
GetDriverDeviceObject();

PDRIVER_OBJECT
GetDriverObject();

PIRP_QUEUE_HEAD
GetIrpQueueHead();

PSYS_MODULE_VAL_CONTEXT
GetSystemModuleValidationContext();

PUNICODE_STRING
GetDriverPath();

PUNICODE_STRING
GetDriverRegistryPath();

PUNICODE_STRING
GetDriverDeviceName();

PUNICODE_STRING
GetDriverSymbolicLink();

PSYSTEM_INFORMATION
GetDriverConfigSystemInformation();

PTHREAD_LIST_HEAD
GetThreadList();

PDRIVER_LIST_HEAD
GetDriverList();

PPROCESS_LIST_HEAD
GetProcessList();

PUINT64
GetApcContextArray();

VOID
AcquireDriverConfigLock();

VOID
ReleaseDriverConfigLock();

BOOLEAN
IsDriverUnloading();

PACTIVE_SESSION
GetActiveSession();

PSHARED_MAPPING
GetSharedMappingConfig();

VOID
UnsetNmiInProgressFlag();

BOOLEAN
IsNmiInProgress();

BOOLEAN
HasDriverLoaded();

#endif
```

`driver/driver.inf`:

```inf
;
; driver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System ; TODO: specify appropriate Class
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider=%ManufacturerName%
CatalogFile=driver.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 12
driver_Device_CoInstaller_CopyFiles = 11

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
driver.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%driver.DeviceDesc%=driver_Device, Root\driver ; TODO: edit hw-id

[driver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
driver.sys

;-------------- Service installation
[driver_Device.NT.Services]
AddService = driver,%SPSVCINST_ASSOCSERVICE%, driver_Service_Inst

; -------------- driver driver install sections
[driver_Service_Inst]
DisplayName    = %driver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\driver.sys

;
;--- driver_Device Coinstaller installation ------
;

[driver_Device.NT.CoInstallers]
AddReg=driver_Device_CoInstaller_AddReg
CopyFiles=driver_Device_CoInstaller_CopyFiles

[driver_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[driver_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[driver_Device.NT.Wdf]
KmdfService =  driver, driver_wdfsect
[driver_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "driver Installation Disk"
driver.DeviceDesc = "driver Device"
driver.SVCDESC = "driver Service"

```

`driver/driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release - Win10|ARM64">
      <Configuration>Release - Win10</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release - Win10|x64">
      <Configuration>Release - Win10</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release - Win11|ARM64">
      <Configuration>Release - Win11</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release - Win11|x64">
      <Configuration>Release - Win11</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0AE83EC6-DDEA-4EDE-B1B2-1B2AB1E8BB54}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>driver</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - Win11|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - Win10|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <NTDDI_VERSION>NTDDI_WIN10_VB</NTDDI_VERSION>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <_NT_TARGET_VERSION>0xA00000C</_NT_TARGET_VERSION>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - Win11|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - Win10|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <EnableClangTidyCodeAnalysis>false</EnableClangTidyCodeAnalysis>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - Win11|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <EnableClangTidyCodeAnalysis>false</EnableClangTidyCodeAnalysis>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - Win10|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <EnableClangTidyCodeAnalysis>false</EnableClangTidyCodeAnalysis>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - Win11|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - Win10|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link />
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>Cng.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <EnablePREfast>true</EnablePREfast>
    </ClCompile>
    <Link />
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>Cng.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release - Win11|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <EnablePREfast>true</EnablePREfast>
    </ClCompile>
    <Link />
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>Cng.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release - Win10|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <EnablePREfast>true</EnablePREfast>
    </ClCompile>
    <Link />
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>Cng.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release - Win11|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release - Win10|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="driver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="apc.c" />
    <ClCompile Include="callbacks.c" />
    <ClCompile Include="crypt.c" />
    <ClCompile Include="driver.c" />
    <ClCompile Include="hv.c" />
    <ClCompile Include="imports.c" />
    <ClCompile Include="integrity.c" />
    <ClCompile Include="io.c" />
    <ClCompile Include="list.c" />
    <ClCompile Include="modules.c" />
    <ClCompile Include="hw.c" />
    <ClCompile Include="pool.c" />
    <ClCompile Include="queue.c" />
    <ClCompile Include="session.c" />
    <ClCompile Include="thread.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="apc.h" />
    <ClInclude Include="callbacks.h" />
    <ClInclude Include="common.h" />
    <ClInclude Include="crypt.h" />
    <ClInclude Include="driver.h" />
    <ClInclude Include="hv.h" />
    <ClInclude Include="hw.h" />
    <ClInclude Include="ia32.h" />
    <ClInclude Include="imports.h" />
    <ClInclude Include="integrity.h" />
    <ClInclude Include="io.h" />
    <ClInclude Include="list.h" />
    <ClInclude Include="modules.h" />
    <ClInclude Include="pool.h" />
    <ClInclude Include="queue.h" />
    <ClInclude Include="session.h" />
    <ClInclude Include="thread.h" />
    <ClInclude Include="types\types.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="arch.asm" />
  </ItemGroup>
  <ItemGroup>
    <None Include="cpp.hint" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`driver/driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="driver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="modules.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="callbacks.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="queue.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hv.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="integrity.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pool.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="thread.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="imports.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="apc.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="list.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="io.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="crypt.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="session.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hw.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="modules.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="callbacks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="queue.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hv.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="integrity.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pool.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="thread.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ia32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="imports.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="apc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="list.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="io.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="types\types.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="crypt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="session.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hw.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="arch.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <None Include="cpp.hint" />
  </ItemGroup>
</Project>
```

`driver/hv.c`:

```c
#include "hv.h"

#include <intrin.h>
#include "imports.h"
#include "common.h"
#include "io.h"

#ifdef ALLOC_PRAGMA
#    pragma alloc_text(PAGE, PerformVirtualizationDetection)
#endif

#define TOTAL_ITERATION_COUNT 20

/*
 * TODO: Perform the test in a loop and average the delta out, then compare it
 * to an instruction such as FYL2XP1 (source: secret.club) which has an average
 * execution time slightly higher then the CPUID instruction then compare the
 * two. If the average time for the CPUID instruction is higher then the average
 * time for the FYL2XP1 instruction it is a dead giveaway we are running on a
 * virtualized system.
 *
 * reference: https://secret.club/2020/01/12/battleye-hypervisor-detection.html
 */

BOOLEAN
APERFMsrTimingCheck()
{
    KAFFINITY new_affinity = {0};
    KAFFINITY old_affinity = {0};
    UINT64    old_irql     = 0;
    INT       cpuid_result[4];

    /*
     * First thing we do is we lock the current thread to the logical
     * processor its executing on.
     */
    new_affinity = (KAFFINITY)(1ull << KeGetCurrentProcessorNumber());
    old_affinity = ImpKeSetSystemAffinityThreadEx(new_affinity);

    /*
     * Once we've locked our thread to the current core, we save the old
     * irql and raise to HIGH_LEVEL to ensure the chance our thread is
     * preempted by a thread with a higher IRQL is extremely low.
     */
    old_irql = __readcr8();
    __writecr8(HIGH_LEVEL);

    /*
     * Then we also disable interrupts, once again making sure our thread
     * is not preempted.
     */
    _disable();

    /*
     * Once our thread is ready for the test, we read the APERF from the
     * MSR register and store it. We then execute a CPUID instruction
     * which we don't really care about and immediately after read the APERF
     * counter once again and store it in a seperate variable.
     */
    UINT64 aperf_before = __readmsr(IA32_APERF_MSR) << 32;
    __cpuid(cpuid_result, 1);
    UINT64 aperf_after = __readmsr(IA32_APERF_MSR) << 32;

    /*
     * Once we have performed our test, we want to make sure we are not
     * hogging the cpu time from other threads, so we reverse the initial
     * preparation process. i.e we first enable interrupts, lower our irql
     * to the threads previous irql before it was raised and then restore
     * the threads affinity back to its original affinity.
     */
    _enable();
    __writecr8(old_irql);
    ImpKeRevertToUserAffinityThreadEx(old_affinity);

    /*
     * Now the only thing left to do is calculate the change. Now, on some
     * VMs such as VMWARE the aperf value will be 0, meaning the change will
     * be 0. This is a dead giveaway we are executing in a VM.
     */
    UINT64 aperf_delta = aperf_after - aperf_before;

    return aperf_delta == 0 ? TRUE : FALSE;
}

NTSTATUS
PerformVirtualizationDetection(_Inout_ PIRP Irp)
{
    PAGED_CODE();

    NTSTATUS status =
        ValidateIrpOutputBuffer(Irp, sizeof(HYPERVISOR_DETECTION_REPORT));

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ValidateIrpOutputBuffer failed with status %x", status);
        return status;
    }

    HYPERVISOR_DETECTION_REPORT report = {0};
    report.aperf_msr_timing_check      = APERFMsrTimingCheck();
    report.invd_emulation_check        = TestINVDEmulation();

    Irp->IoStatus.Information = sizeof(HYPERVISOR_DETECTION_REPORT);

    RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer,
                  &report,
                  sizeof(HYPERVISOR_DETECTION_REPORT));

    return STATUS_SUCCESS;
}
```

`driver/hv.h`:

```h
#ifndef HV_H
#define HV_H

#include <ntifs.h>
#include "common.h"

NTSTATUS
PerformVirtualizationDetection(_Inout_ PIRP Irp);

BOOLEAN
APERFMsrTimingCheck();

extern INT
TestINVDEmulation();

#endif
```

`driver/hw.c`:

```c
#include "hw.h"

#include "modules.h"

#define PCI_VENDOR_ID_OFFSET 0x00
#define PCI_DEVICE_ID_OFFSET 0x02

#define FLAGGED_DEVICE_ID_COUNT 2

USHORT FLAGGED_DEVICE_IDS[FLAGGED_DEVICE_ID_COUNT] = {
    0x0666, // default PCIe Squirrel DeviceID (used by PCI Leech)
    0xffff};

typedef NTSTATUS (*PCI_DEVICE_CALLBACK)(_In_ PDEVICE_OBJECT DeviceObject,
                                        _In_opt_ PVOID      Context);

/*
 * Every PCI device has a set of registers commonly referred to as the PCI
 * configuration space. In modern PCI-e devices an extended configuration space
 * was implemented. These configuration spaces are mapped into main memory and
 * this allows us to read/write to the registers.
 *
 * The configuration space consists of a standard header, containing information
 * such as the DeviceID, VendorID, Status and so on. Below is the header schema
 * including offsets.
 *
 *  | Offset 0x00: Header Type
 *  | Offset 0x01: Multi-Function Device Indicator
 *  | Offset 0x02: Device ID (Low Byte)
 *  | Offset 0x03: Device ID (High Byte)
 *  | Offset 0x04: Status Register (16 bits)
 *  | Offset 0x06: Command Register (16 bits)
 *  | Offset 0x08: Class Code
 *  | Offset 0x09: Subclass Code
 *  | Offset 0x0A: Prog IF (Programming Interface)
 *  | Offset 0x0B: Revision ID
 *  | Offset 0x0C: BIST (Built-in Self-Test)
 *  | Offset 0x0D: Header Type (Secondary)
 *  | Offset 0x0E: Latency Timer
 *  | Offset 0x0F: Cache Line Size
 *  | Offset 0x10: Base Address Register 0 (BAR0) - 32 bits
 *  | Offset 0x14: Base Address Register 1 (BAR1) - 32 bits
 *  | Offset 0x18: Base Address Register 2 (BAR2) - 32 bits
 *  | Offset 0x1C: Base Address Register 3 (BAR3) - 32 bits
 *  | Offset 0x20: Base Address Register 4 (BAR4) - 32 bits
 *  | Offset 0x24: Base Address Register 5 (BAR5) - 32 bits
 *  | Offset 0x28: Cardbus CIS Pointer (for Cardbus bridges)
 *  | Offset 0x2C: Subsystem Vendor ID
 *  | Offset 0x2E: Subsystem ID
 *  | Offset 0x30: Expansion ROM Base Address
 *  | Offset 0x34: Reserved
 *  | Offset 0x38: Reserved
 *  | Offset 0x3C: Max_Lat (Maximum Latency)
 *  | Offset 0x3D: Min_Gnt (Minimum Grant)
 *  | Offset 0x3E: Interrupt Pin
 *  | Offset 0x3F: Interrupt Line
 *
 * We can use this to then query important information from PCI devices within
 * the device tree. To keep up with modern windows kernel programming, we can
 * make use of the IRP_MN_READ_CONFIG code, which as the name suggests, reads
 * from a PCI devices configuration space.
 */
STATIC
NTSTATUS
QueryPciDeviceConfigurationSpace(_In_ PDEVICE_OBJECT DeviceObject,
                                 _In_ UINT32         Offset,
                                 _Out_ PVOID         Buffer,
                                 _In_ UINT32         BufferLength)
{
    NTSTATUS           status            = STATUS_UNSUCCESSFUL;
    KEVENT             event             = {0};
    IO_STATUS_BLOCK    io                = {0};
    PIRP               irp               = NULL;
    PIO_STACK_LOCATION io_stack_location = NULL;

    if (BufferLength == 0)
        return STATUS_BUFFER_TOO_SMALL;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    /*
     * we dont need to free this IRP as the IO manager will free it when the
     * request is completed
     */
    irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP, DeviceObject, NULL, 0, NULL, &event, &io);

    if (!irp) {
        DEBUG_ERROR("IoBuildSynchronousFsdRequest failed with no status.");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    io_stack_location                = IoGetNextIrpStackLocation(irp);
    io_stack_location->MinorFunction = IRP_MN_READ_CONFIG;
    io_stack_location->Parameters.ReadWriteConfig.WhichSpace =
        PCI_WHICHSPACE_CONFIG;
    io_stack_location->Parameters.ReadWriteConfig.Offset = Offset;
    io_stack_location->Parameters.ReadWriteConfig.Buffer = Buffer;
    io_stack_location->Parameters.ReadWriteConfig.Length = BufferLength;

    status = IoCallDriver(DeviceObject, irp);

    if (status = STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = io.Status;
    }

    if (!NT_SUCCESS(status))
        DEBUG_ERROR("Failed to read configuration space with status %x",
                    status);

    return status;
}

/*
 * NOTE: Caller is responsible for freeing the array.
 */
STATIC
NTSTATUS
EnumerateDriverObjectDeviceObjects(_In_ PDRIVER_OBJECT    DriverObject,
                                   _Out_ PDEVICE_OBJECT** DeviceObjectArray,
                                   _Out_ PUINT32          ArrayEntries)
{
    NTSTATUS        status       = STATUS_UNSUCCESSFUL;
    UINT32          object_count = 0;
    PDEVICE_OBJECT* buffer       = NULL;
    UINT32          buffer_size  = 0;

    *DeviceObjectArray = NULL;

    status = IoEnumerateDeviceObjectList(DriverObject, NULL, 0, &object_count);

    if (status != STATUS_BUFFER_TOO_SMALL) {
        DEBUG_ERROR("IoEnumerateDeviceObjectList failed with status %x",
                    status);
        return status;
    }

    buffer_size = object_count * sizeof(UINT64);
    buffer = ExAllocatePool2(POOL_FLAG_NON_PAGED, buffer_size, POOL_TAG_HW);

    if (!buffer)
        return STATUS_INSUFFICIENT_RESOURCES;

    status = IoEnumerateDeviceObjectList(
        DriverObject, buffer, buffer_size, &object_count);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("IoEnumerateDeviceObjectList failed with status %x",
                    status);
        ExFreePoolWithTag(buffer, POOL_TAG_HW);
        return status;
    }

    DEBUG_VERBOSE("EnumerateDriverObjectDeviceObjects: Object Count: %lx",
                  object_count);

    *DeviceObjectArray = buffer;
    *ArrayEntries      = object_count;

    return status;
}

/*
 * While this isnt a perfect check to determine whether a DEVICE_OBJECT is
 * indeed a PDO or FDO, this is Peters preferred method... hence it is now my
 * preferred method... :smiling_imp:
 */
STATIC
BOOLEAN
IsDeviceObjectValidPdo(_In_ PDEVICE_OBJECT DeviceObject)
{
    return DeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE ? TRUE : FALSE;
}

/*
 * Windows splits DEVICE_OBJECTS up into 2 categories:
 *
 * Physical Device Object (PDO)
 * Functional Device Object (FDO)
 *
 * A PDO represents each device that is connected to a physical bus. Each PDO
 * has an associated DEVICE_NODE. An FDO represents the functionality of the
 * device. Its how the system interacts with the device objects.
 *
 * More information can be found here:
 * https://learn.microsoft.com/en-gb/windows-hardware/drivers/gettingstarted/device-nodes-and-device-stacks
 *
 * A device stack can have multiple PDO's, but can only have one FDO. This means
 * to access each PCI device on the system, we can enumerate all device objects
 * given the PCI FDO which is called pci.sys.
 */
NTSTATUS
EnumeratePciDeviceObjects(_In_ PCI_DEVICE_CALLBACK CallbackRoutine,
                          _In_opt_ PVOID           Context)
{
    NTSTATUS        status             = STATUS_UNSUCCESSFUL;
    UNICODE_STRING  pci                = RTL_CONSTANT_STRING(L"\\Driver\\pci");
    PDRIVER_OBJECT  pci_driver_object  = NULL;
    PDEVICE_OBJECT* pci_device_objects = NULL;
    PDEVICE_OBJECT  current_device     = NULL;
    UINT32          pci_device_objects_count = 0;
    USHORT          vendor_id                = 0;

    status = GetDriverObjectByDriverName(&pci, &pci_driver_object);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetDriverObjectByDriverName failed with status %x",
                    status);
        return status;
    }

    status = EnumerateDriverObjectDeviceObjects(
        pci_driver_object, &pci_device_objects, &pci_device_objects_count);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("EnumerateDriverObjectDeviceObjects failed with status %x",
                    status);
        return status;
    }

    for (UINT32 index = 0; index < pci_device_objects_count; index++) {
        current_device = pci_device_objects[index];

        /* make sure we have a valid PDO */
        if (!IsDeviceObjectValidPdo(current_device)) {
            ObDereferenceObject(current_device);
            continue;
        }

        status = CallbackRoutine(current_device, Context);

        if (!NT_SUCCESS(status))
            DEBUG_ERROR(
                "EnumeratePciDeviceObjects CallbackRoutine failed with status %x",
                status);

        ObDereferenceObject(current_device);
    }

end:
    if (pci_device_objects)
        ExFreePoolWithTag(pci_device_objects, POOL_TAG_HW);

    return status;
}

BOOLEAN
IsPciConfigurationSpaceFlagged(_In_ PPCI_COMMON_HEADER Configuration)
{
    for (UINT32 index = 0; index < FLAGGED_DEVICE_ID_COUNT; index++) {
        if (Configuration->DeviceID == FLAGGED_DEVICE_IDS[index])
            return TRUE;
    }

    return FALSE;
}

STATIC
NTSTATUS
PciDeviceQueryCallback(_In_ PDEVICE_OBJECT DeviceObject, _In_opt_ PVOID Context)
{
    NTSTATUS          status = STATUS_UNSUCCESSFUL;
    PCI_COMMON_HEADER header = {0};

    status = QueryPciDeviceConfigurationSpace(
        DeviceObject, PCI_VENDOR_ID_OFFSET, &header, sizeof(PCI_COMMON_HEADER));

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("QueryPciDeviceConfigurationSpace failed with status %x",
                    status);
        return status;
    }

    if (IsPciConfigurationSpaceFlagged(&header)) {
        DEBUG_VERBOSE("Flagged DeviceID found. Device: %llx, DeviceId: %lx",
                      (UINT64)DeviceObject,
                      header.DeviceID);
    }
    else {
        DEBUG_VERBOSE("Device: %llx, DeviceID: %lx, VendorID: %lx",
                      DeviceObject,
                      header.DeviceID,
                      header.VendorID);
    }

    return status;
}

NTSTATUS
ValidatePciDevices()
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    status = EnumeratePciDeviceObjects(PciDeviceQueryCallback, NULL);

    if (!NT_SUCCESS(status))
        DEBUG_ERROR("EnumeratePciDeviceObjects failed with status %x", status);

    return status;
}
```

`driver/hw.h`:

```h
#ifndef HW_H
#define HW_H

#include "common.h"

NTSTATUS
ValidatePciDevices();

#endif
```

`driver/ia32.h`:

```h
/** @file */
#pragma once
typedef unsigned char      UINT8;
typedef unsigned short     UINT16;
typedef unsigned int       UINT32;
typedef unsigned long long UINT64;

#if defined(_MSC_EXTENSIONS)
#        pragma warning(push)
#        pragma warning(disable : 4201)
#endif

/**
 * @defgroup INTEL_MANUAL \
 *           Intel Manual
 *
 * @remarks All references are based on <b>Intel(R) 64 and IA-32 architectures software developer's
 * manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4</b> (June 2021) and <b>Intel(R)
 * Virtualization Technology for Directed I/O</b> (April 2021)
 * @{
 */
/**
 * @defgroup CONTROL_REGISTERS \
 *           Control registers
 *
 * Control registers (CR0, CR1, CR2, CR3, and CR4) determine operating mode of the processor and the
 * characteristics of the currently executing task. These registers are 32 bits in all 32-bit modes
 * and compatibility mode. In 64-bit mode, control registers are expanded to 64 bits. The MOV CRn
 * instructions are used to manipulate the register bits. Operand-size prefixes for these
 * instructions are ignored. The following is also true:
 * - The control registers can be read and loaded (or modified) using the
 * move-to-or-from-control-registers forms of the MOV instruction. In protected mode, the MOV
 * instructions allow the control registers to be read or loaded (at privilege level 0 only). This
 * restriction means that application programs or operating-system procedures (running at privilege
 * levels 1, 2, or 3) are prevented from reading or loading the control registers.
 * - Bits 63:32 of CR0 and CR4 are reserved and must be written with zeros. Writing a nonzero value
 * to any of the upper 32 bits results in a general-protection exception, \#GP(0).
 * - All 64 bits of CR2 are writable by software.
 * - Bits 51:40 of CR3 are reserved and must be 0.
 * - The MOV CRn instructions do not check that addresses written to CR2 and CR3 are within the
 * linear-address or physical-address limitations of the implementation.
 * - Register CR8 is available in 64-bit mode only. The control registers are summarized below, and
 * each architecturally defined control field in these control registers is described individually.
 * - CR0 - Contains system control flags that control operating mode and states of the processor.
 * - CR1 - Reserved.
 * - CR2 - Contains the page-fault linear address (the linear address that caused a page fault).
 * - CR3 - Contains the physical address of the base of the paging-structure hierarchy and two flags
 * (PCD and PWT). Only the most-significant bits (less the lower 12 bits) of the base address are
 * specified; the lower 12 bits of the address are assumed to be 0. The first paging structure must
 * thus be aligned to a page (4-KByte) boundary. The PCD and PWT flags control caching of that
 * paging structure in the processor's internal data caches (they do not control TLB caching of
 * page-directory information). When using the physical address extension, the CR3 register contains
 * the base address of the page-directorypointer table. In IA-32e mode, the CR3 register contains
 * the base address of the PML4 table.
 * - CR4 - Contains a group of flags that enable several architectural extensions, and indicate
 * operating system or executive support for specific processor capabilities.
 * - CR8 - Provides read and write access to the Task Priority Register (TPR). It specifies the
 * priority threshold value that operating systems use to control the priority class of external
 * interrupts allowed to interrupt the processor. This register is available only in 64-bit mode.
 * However, interrupt filtering continues to apply in compatibility mode.
 *
 * @see Vol3A[2.5(CONTROL REGISTERS)] (reference)
 * @{
 */
typedef union
{
        struct
        {
                /**
                 * @brief Protection Enable
                 *
                 * [Bit 0] Enables protected mode when set; enables real-address mode when clear.
                 * This flag does not enable paging directly. It only enables segment-level
                 * protection. To enable paging, both the PE and PG flags must be set.
                 *
                 * @see Vol3A[9.9(Mode Switching)]
                 */
                UINT64 ProtectionEnable : 1;
#define CR0_PROTECTION_ENABLE_BIT  0
#define CR0_PROTECTION_ENABLE_FLAG 0x01
#define CR0_PROTECTION_ENABLE_MASK 0x01
#define CR0_PROTECTION_ENABLE(_)   (((_) >> 0) & 0x01)

                /**
                 * @brief Monitor Coprocessor
                 *
                 * [Bit 1] Controls the interaction of the WAIT (or FWAIT) instruction with the TS
                 * flag (bit 3 of CR0). If the MP flag is set, a WAIT instruction generates a
                 * device-not-available exception (\#NM) if the TS flag is also set. If the MP flag
                 * is clear, the WAIT instruction ignores the setting of the TS flag.
                 */
                UINT64 MonitorCoprocessor : 1;
#define CR0_MONITOR_COPROCESSOR_BIT  1
#define CR0_MONITOR_COPROCESSOR_FLAG 0x02
#define CR0_MONITOR_COPROCESSOR_MASK 0x01
#define CR0_MONITOR_COPROCESSOR(_)   (((_) >> 1) & 0x01)

                /**
                 * @brief FPU Emulation
                 *
                 * [Bit 2] Indicates that the processor does not have an internal or external x87
                 * FPU when set; indicates an x87 FPU is present when clear. This flag also affects
                 * the execution of MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions. When the EM flag is
                 * set, execution of an x87 FPU instruction generates a device-not-available
                 * exception (\#NM). This flag must be set when the processor does not have an
                 * internal x87 FPU or is not connected to an external math coprocessor. Setting
                 * this flag forces all floating-point instructions to be handled by software
                 * emulation. Also, when the EM flag is set, execution of an MMX instruction causes
                 * an invalid-opcode exception (\#UD) to be generated. Thus, if an IA-32 or Intel 64
                 * processor incorporates MMX technology, the EM flag must be set to 0 to enable
                 * execution of MMX instructions. Similarly for SSE/SSE2/SSE3/SSSE3/SSE4 extensions,
                 * when the EM flag is set, execution of most SSE/SSE2/SSE3/SSSE3/SSE4 instructions
                 * causes an invalid opcode exception (\#UD) to be generated. If an IA-32 or Intel
                 * 64 processor incorporates the SSE/SSE2/SSE3/SSSE3/SSE4 extensions, the EM flag
                 * must be set to 0 to enable execution of these extensions.
                 * SSE/SSE2/SSE3/SSSE3/SSE4 instructions not affected by the EM flag include: PAUSE,
                 * PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
                 */
                UINT64 EmulateFpu : 1;
#define CR0_EMULATE_FPU_BIT  2
#define CR0_EMULATE_FPU_FLAG 0x04
#define CR0_EMULATE_FPU_MASK 0x01
#define CR0_EMULATE_FPU(_)   (((_) >> 2) & 0x01)

                /**
                 * @brief Task Switched
                 *
                 * [Bit 3] Allows the saving of the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context on
                 * a task switch to be delayed until an x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4
                 * instruction is actually executed by the new task. The processor sets this flag on
                 * every task switch and tests it when executing x87
                 * FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions.
                 * - If the TS flag is set and the EM flag (bit 2 of CR0) is clear, a
                 * device-not-available exception (\#NM) is raised prior to the execution of any x87
                 * FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction; with the exception of PAUSE,
                 * PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
                 * - If the TS flag is set and the MP flag (bit 1 of CR0) and EM flag are clear, an
                 * \#NM exception is not raised prior to the execution of an x87 FPU WAIT/FWAIT
                 * instruction.
                 * - If the EM flag is set, the setting of the TS flag has no effect on the
                 * execution of x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instructions. The processor
                 * does not automatically save the context of the x87 FPU, XMM, and MXCSR registers
                 * on a task switch. Instead, it sets the TS flag, which causes the processor to
                 * raise an \#NM exception whenever it encounters an x87
                 *   FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction in the instruction stream for the
                 * new task (with the exception of the instructions listed above). The fault handler
                 * for the \#NM exception can then be used to clear the TS flag (with the CLTS
                 * instruction) and save the context of the x87 FPU, XMM, and MXCSR registers. If
                 * the task never encounters an x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 instruction,
                 * the x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4 context is never saved.
                 */
                UINT64 TaskSwitched : 1;
#define CR0_TASK_SWITCHED_BIT  3
#define CR0_TASK_SWITCHED_FLAG 0x08
#define CR0_TASK_SWITCHED_MASK 0x01
#define CR0_TASK_SWITCHED(_)   (((_) >> 3) & 0x01)

                /**
                 * @brief Extension Type
                 *
                 * [Bit 4] Reserved in the Pentium 4, Intel Xeon, P6 family, and Pentium processors.
                 * In the Pentium 4, Intel Xeon, and P6 family processors, this flag is hardcoded
                 * to 1. In the Intel386 and Intel486 processors, this flag indicates support of
                 * Intel 387 DX math coprocessor instructions when set.
                 */
                UINT64 ExtensionType : 1;
#define CR0_EXTENSION_TYPE_BIT  4
#define CR0_EXTENSION_TYPE_FLAG 0x10
#define CR0_EXTENSION_TYPE_MASK 0x01
#define CR0_EXTENSION_TYPE(_)   (((_) >> 4) & 0x01)

                /**
                 * @brief Numeric Error
                 *
                 * [Bit 5] Enables the native (internal) mechanism for reporting x87 FPU errors when
                 * set; enables the PC-style x87 FPU error reporting mechanism when clear. When the
                 * NE flag is clear and the IGNNE\# input is asserted, x87 FPU errors are ignored.
                 * When the NE flag is clear and the IGNNE\# input is deasserted, an unmasked x87
                 * FPU error causes the processor to assert the FERR\# pin to generate an external
                 * interrupt and to stop instruction execution immediately before executing the next
                 * waiting floating-point instruction or WAIT/FWAIT instruction. The FERR\# pin is
                 * intended to drive an input to an external interrupt controller (the FERR\# pin
                 * emulates the ERROR\# pin of the Intel 287 and Intel 387 DX math coprocessors).
                 * The NE flag, IGNNE\# pin, and FERR\# pin are used with external logic to
                 * implement PC-style error reporting. Using FERR\# and IGNNE\# to handle
                 * floating-point exceptions is deprecated by modern operating systems; this
                 * non-native approach also limits newer processors to operate with one logical
                 * processor active.
                 *
                 * @see Vol1[8.7(Handling x87 FPU Exceptions in Software)]
                 * @see Vol1[A.1(APPENDIX A | EFLAGS Cross-Reference)]
                 */
                UINT64 NumericError : 1;
#define CR0_NUMERIC_ERROR_BIT  5
#define CR0_NUMERIC_ERROR_FLAG 0x20
#define CR0_NUMERIC_ERROR_MASK 0x01
#define CR0_NUMERIC_ERROR(_)   (((_) >> 5) & 0x01)
                UINT64 Reserved1 : 10;

                /**
                 * @brief Write Protect
                 *
                 * [Bit 16] When set, inhibits supervisor-level procedures from writing into
                 * readonly pages; when clear, allows supervisor-level procedures to write into
                 * read-only pages (regardless of the U/S bit setting). This flag facilitates
                 * implementation of the copy-onwrite method of creating a new process (forking)
                 * used by operating systems such as UNIX.
                 *
                 * @see Vol3A[4.1.3(Paging-Mode Modifiers)]
                 * @see Vol3A[4.6(ACCESS RIGHTS)]
                 */
                UINT64 WriteProtect : 1;
#define CR0_WRITE_PROTECT_BIT  16
#define CR0_WRITE_PROTECT_FLAG 0x10000
#define CR0_WRITE_PROTECT_MASK 0x01
#define CR0_WRITE_PROTECT(_)   (((_) >> 16) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * @brief Alignment Mask
                 *
                 * [Bit 18] Enables automatic alignment checking when set; disables alignment
                 * checking when clear. Alignment checking is performed only when the AM flag is
                 * set, the AC flag in the EFLAGS register is set, CPL is 3, and the processor is
                 * operating in either protected or virtual-8086 mode.
                 */
                UINT64 AlignmentMask : 1;
#define CR0_ALIGNMENT_MASK_BIT  18
#define CR0_ALIGNMENT_MASK_FLAG 0x40000
#define CR0_ALIGNMENT_MASK_MASK 0x01
#define CR0_ALIGNMENT_MASK(_)   (((_) >> 18) & 0x01)
                UINT64 Reserved3 : 10;

                /**
                 * @brief Not Write-through
                 *
                 * [Bit 29] When the NW and CD flags are clear, write-back (for Pentium 4, Intel
                 * Xeon, P6 family, and Pentium processors) or write-through (for Intel486
                 * processors) is enabled for writes that hit the cache and invalidation cycles are
                 * enabled.
                 */
                UINT64 NotWriteThrough : 1;
#define CR0_NOT_WRITE_THROUGH_BIT  29
#define CR0_NOT_WRITE_THROUGH_FLAG 0x20000000
#define CR0_NOT_WRITE_THROUGH_MASK 0x01
#define CR0_NOT_WRITE_THROUGH(_)   (((_) >> 29) & 0x01)

                /**
                 * @brief Cache Disable
                 *
                 * [Bit 30] When the CD and NW flags are clear, caching of memory locations for the
                 * whole of physical memory in the processor's internal (and external) caches is
                 * enabled. When the CD flag is set, caching is restricted. To prevent the processor
                 * from accessing and updating its caches, the CD flag must be set and the caches
                 * must be invalidated so that no cache hits can occur.
                 *
                 * @see Vol3A[11.5.3(Preventing Caching)]
                 * @see Vol3A[11.5(CACHE CONTROL)]
                 */
                UINT64 CacheDisable : 1;
#define CR0_CACHE_DISABLE_BIT  30
#define CR0_CACHE_DISABLE_FLAG 0x40000000
#define CR0_CACHE_DISABLE_MASK 0x01
#define CR0_CACHE_DISABLE(_)   (((_) >> 30) & 0x01)

                /**
                 * @brief Paging Enable
                 *
                 * [Bit 31] Enables paging when set; disables paging when clear. When paging is
                 * disabled, all linear addresses are treated as physical addresses. The PG flag has
                 * no effect if the PE flag (bit 0 of register CR0) is not also set; setting the PG
                 * flag when the PE flag is clear causes a general-protection exception (\#GP).
                 * On Intel 64 processors, enabling and disabling IA-32e mode operation also
                 * requires modifying CR0.PG.
                 *
                 * @see Vol3A[4(PAGING)]
                 */
                UINT64 PagingEnable : 1;
#define CR0_PAGING_ENABLE_BIT  31
#define CR0_PAGING_ENABLE_FLAG 0x80000000
#define CR0_PAGING_ENABLE_MASK 0x01
#define CR0_PAGING_ENABLE(_)   (((_) >> 31) & 0x01)
                UINT64 Reserved4 : 32;
        } Fields;

        UINT64 AsUInt;
} CR0;

typedef union
{
        struct
        {
                UINT64 Reserved1 : 3;

                /**
                 * @brief Page-level Write-Through
                 *
                 * [Bit 3] Controls the memory type used to access the first paging structure of the
                 * current paging-structure hierarchy. This bit is not used if paging is disabled,
                 * with PAE paging, or with 4-level paging if CR4.PCIDE=1.
                 *
                 * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
                 */
                UINT64 PageLevelWriteThrough : 1;
#define CR3_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define CR3_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define CR3_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define CR3_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)

                /**
                 * @brief Page-level Cache Disable
                 *
                 * [Bit 4] Controls the memory type used to access the first paging structure of the
                 * current paging-structure hierarchy. This bit is not used if paging is disabled,
                 * with PAE paging, or with 4-level paging2 if CR4.PCIDE=1.
                 *
                 * @see Vol3A[4.9(PAGING AND MEMORY TYPING)]
                 */
                UINT64 PageLevelCacheDisable : 1;
#define CR3_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define CR3_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define CR3_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define CR3_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)
                UINT64 Reserved2 : 7;

                /**
                 * @brief Address of page directory
                 *
                 * [Bits 47:12] Physical address of the 4-KByte aligned page directory (32-bit
                 * paging) or PML4 table (64-bit paging) used for linear-address translation.
                 *
                 * @see Vol3A[4.3(32-BIT PAGING)]
                 * @see Vol3A[4.5(4-LEVEL PAGING)]
                 */
                UINT64 AddressOfPageDirectory : 36;
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_BIT  12
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_FLAG 0xFFFFFFFFF000
#define CR3_ADDRESS_OF_PAGE_DIRECTORY_MASK 0xFFFFFFFFF
#define CR3_ADDRESS_OF_PAGE_DIRECTORY(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved3 : 16;
        };

        UINT64 AsUInt;
} CR3;

// typedef union
//{
//	struct
//	{
//		/**
//		 * @brief Virtual-8086 Mode Extensions
//		 *
//		 * [Bit 0] Enables interrupt- and exception-handling extensions in virtual-8086 mode
//when set; disables the extensions when
//		 * clear. Use of the virtual mode extensions can improve the performance of
//virtual-8086 applications by eliminating the
//		 * overhead of calling the virtual- 8086 monitor to handle interrupts and exceptions
//that occur while executing an 8086
//		 * program and, instead, redirecting the interrupts and exceptions back to the 8086
//program's handlers. It also provides
//		 * hardware support for a virtual interrupt flag (VIF) to improve reliability of
//running 8086 programs in multitasking and
//		 * multiple-processor environments.
//		 *
//		 * @see Vol3B[20.3(INTERRUPT AND EXCEPTION HANDLING IN VIRTUAL-8086 MODE)]
//		 */
//		UINT64 VirtualModeExtensions : 1;
// #define CR4_VIRTUAL_MODE_EXTENSIONS_BIT                              0
// #define CR4_VIRTUAL_MODE_EXTENSIONS_FLAG                             0x01
// #define CR4_VIRTUAL_MODE_EXTENSIONS_MASK                             0x01
// #define CR4_VIRTUAL_MODE_EXTENSIONS(_)                               (((_) >> 0) & 0x01)
//
//		/**
//		 * @brief Protected-Mode Virtual Interrupts
//		 *
//		 * [Bit 1] Enables hardware support for a virtual interrupt flag (VIF) in protected
//mode when set; disables the VIF flag in
//		 * protected mode when clear.
//		 *
//		 * @see Vol3B[20.4(PROTECTED-MODE VIRTUAL INTERRUPTS)]
//		 */
//		UINT64 ProtectedModeVirtualInterrupts : 1;
// #define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_BIT                    1
// #define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_FLAG                   0x02
// #define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS_MASK                   0x01
// #define CR4_PROTECTED_MODE_VIRTUAL_INTERRUPTS(_)                     (((_) >> 1) & 0x01)
//
//		/**
//		 * @brief Time Stamp Disable
//		 *
//		 * [Bit 2] Restricts the execution of the RDTSC instruction to procedures running at
//privilege level 0 when set; allows
//		 * RDTSC instruction to be executed at any privilege level when clear. This bit also
//applies to the RDTSCP instruction if
//		 * supported (if CPUID.80000001H:EDX[27] = 1).
//		 */
//		UINT64 TimestampDisable : 1;
// #define CR4_TIMESTAMP_DISABLE_BIT                                    2
// #define CR4_TIMESTAMP_DISABLE_FLAG                                   0x04
// #define CR4_TIMESTAMP_DISABLE_MASK                                   0x01
// #define CR4_TIMESTAMP_DISABLE(_)                                     (((_) >> 2) & 0x01)
//
//		/**
//		 * @brief Debugging Extensions
//		 *
//		 * [Bit 3] References to debug registers DR4 and DR5 cause an undefined opcode (\#UD)
//exception to be generated when set;
//		 * when clear, processor aliases references to registers DR4 and DR5 for compatibility
//with software written to run on
//		 * earlier IA-32 processors.
//		 *
//		 * @see Vol3B[17.2.2(Debug Registers DR4 and DR5)]
//		 */
//		UINT64 DebuggingExtensions : 1;
// #define CR4_DEBUGGING_EXTENSIONS_BIT                                 3
// #define CR4_DEBUGGING_EXTENSIONS_FLAG                                0x08
// #define CR4_DEBUGGING_EXTENSIONS_MASK                                0x01
// #define CR4_DEBUGGING_EXTENSIONS(_)                                  (((_) >> 3) & 0x01)
//
//		/**
//		 * @brief Page Size Extensions
//		 *
//		 * [Bit 4] Enables 4-MByte pages with 32-bit paging when set; restricts 32-bit paging
//to pages of 4 KBytes when clear.
//		 *
//		 * @see Vol3A[4.3(32-BIT PAGING)]
//		 */
//		UINT64 PageSizeExtensions : 1;
// #define CR4_PAGE_SIZE_EXTENSIONS_BIT                                 4
// #define CR4_PAGE_SIZE_EXTENSIONS_FLAG                                0x10
// #define CR4_PAGE_SIZE_EXTENSIONS_MASK                                0x01
// #define CR4_PAGE_SIZE_EXTENSIONS(_)                                  (((_) >> 4) & 0x01)
//
//		/**
//		 * @brief Physical Address Extension
//		 *
//		 * [Bit 5] When set, enables paging to produce physical addresses with more than 32
//bits. When clear, restricts physical
//		 * addresses to 32 bits. PAE must be set before entering IA-32e mode.
//		 *
//		 * @see Vol3A[4(PAGING)]
//		 */
//		UINT64 PhysicalAddressExtension : 1;
// #define CR4_PHYSICAL_ADDRESS_EXTENSION_BIT                           5
// #define CR4_PHYSICAL_ADDRESS_EXTENSION_FLAG                          0x20
// #define CR4_PHYSICAL_ADDRESS_EXTENSION_MASK                          0x01
// #define CR4_PHYSICAL_ADDRESS_EXTENSION(_)                            (((_) >> 5) & 0x01)
//
//		/**
//		 * @brief Machine-Check Enable
//		 *
//		 * [Bit 6] Enables the machine-check exception when set; disables the machine-check
//exception when clear.
//		 *
//		 * @see Vol3B[15(MACHINE-CHECK ARCHITECTURE)]
//		 */
//		UINT64 MachineCheckEnable : 1;
// #define CR4_MACHINE_CHECK_ENABLE_BIT                                 6
// #define CR4_MACHINE_CHECK_ENABLE_FLAG                                0x40
// #define CR4_MACHINE_CHECK_ENABLE_MASK                                0x01
// #define CR4_MACHINE_CHECK_ENABLE(_)                                  (((_) >> 6) & 0x01)
//
//		/**
//		 * @brief Page Global Enable
//		 *
//		 * [Bit 7] (Introduced in the P6 family processors.) Enables the global page feature
//when set; disables the global page
//		 * feature when clear. The global page feature allows frequently used or shared pages
//to be marked as global to all users
//		 * (done with the global flag, bit 8, in a page-directory or page-table entry). Global
//pages are not flushed from the
//		 * translation-lookaside buffer (TLB) on a task switch or a write to register CR3.
//When enabling the global page feature,
//		 * paging must be enabled (by setting the PG flag in control register CR0) before the
//PGE flag is set. Reversing this
//		 * sequence may affect program correctness, and processor performance will be
//impacted.
//		 *
//		 * @see Vol3A[4.10(CACHING TRANSLATION INFORMATION)]
//		 */
//		UINT64 PageGlobalEnable : 1;
// #define CR4_PAGE_GLOBAL_ENABLE_BIT                                   7
// #define CR4_PAGE_GLOBAL_ENABLE_FLAG                                  0x80
// #define CR4_PAGE_GLOBAL_ENABLE_MASK                                  0x01
// #define CR4_PAGE_GLOBAL_ENABLE(_)                                    (((_) >> 7) & 0x01)
//
//		/**
//		 * @brief Performance-Monitoring Counter Enable
//		 *
//		 * [Bit 8] Enables execution of the RDPMC instruction for programs or procedures
//running at any protection level when set;
//		 * RDPMC instruction can be executed only at protection level 0 when clear.
//		 */
//		UINT64 PerformanceMonitoringCounterEnable : 1;
// #define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_BIT                8
// #define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_FLAG               0x100
// #define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE_MASK               0x01
// #define CR4_PERFORMANCE_MONITORING_COUNTER_ENABLE(_)                 (((_) >> 8) & 0x01)
//
//		/**
//		 * @brief Operating System Support for FXSAVE and FXRSTOR instructions
//		 *
//		 * [Bit 9] When set, this flag:
//		 * -# indicates to software that the operating system supports the use of the FXSAVE
//and FXRSTOR instructions,
//		 * -# enables the FXSAVE and FXRSTOR instructions to save and restore the contents of
//the XMM and MXCSR registers along
//		 * with the contents of the x87 FPU and MMX registers, and
//		 * -# enables the processor to execute SSE/SSE2/SSE3/SSSE3/SSE4 instructions, with the
//exception of the PAUSE, PREFETCHh,
//		 * SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
//		 * If this flag is clear, the FXSAVE and FXRSTOR instructions will save and restore
//the contents of the x87 FPU and MMX
//		 * registers, but they may not save and restore the contents of the XMM and MXCSR
//registers. Also, the processor will
//		 * generate an invalid opcode exception (\#UD) if it attempts to execute any
//SSE/SSE2/SSE3 instruction, with the exception
//		 * of PAUSE, PREFETCHh, SFENCE, LFENCE, MFENCE, MOVNTI, CLFLUSH, CRC32, and POPCNT.
//The operating system or executive must
//		 * explicitly set this flag.
//		 *
//		 * @remarks CPUID feature flag FXSR indicates availability of the FXSAVE/FXRSTOR
//instructions. The OSFXSR bit provides
//		 *          operating system software with a means of enabling FXSAVE/FXRSTOR to
//save/restore the contents of the X87 FPU, XMM and
//		 *          MXCSR registers. Consequently OSFXSR bit indicates that the operating
//system provides context switch support for
//		 *          SSE/SSE2/SSE3/SSSE3/SSE4.
//		 */
//		UINT64 OsFxsaveFxrstorSupport : 1;
// #define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_BIT                            9
// #define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_FLAG                           0x200
// #define CR4_OS_FXSAVE_FXRSTOR_SUPPORT_MASK                           0x01
// #define CR4_OS_FXSAVE_FXRSTOR_SUPPORT(_)                             (((_) >> 9) & 0x01)
//
//		/**
//		 * @brief Operating System Support for Unmasked SIMD Floating-Point Exceptions
//		 *
//		 * [Bit 10] Operating System Support for Unmasked SIMD Floating-Point Exceptions -
//When set, indicates that the operating
//		 * system supports the handling of unmasked SIMD floating-point exceptions through an
//exception handler that is invoked
//		 * when a SIMD floating-point exception (\#XM) is generated. SIMD floating-point
//exceptions are only generated by
//		 * SSE/SSE2/SSE3/SSE4.1 SIMD floating-point instructions.
//		 * The operating system or executive must explicitly set this flag. If this flag is
//not set, the processor will generate an
//		 * invalid opcode exception (\#UD) whenever it detects an unmasked SIMD floating-point
//exception.
//		 */
//		UINT64 OsXmmExceptionSupport : 1;
// #define CR4_OS_XMM_EXCEPTION_SUPPORT_BIT                             10
// #define CR4_OS_XMM_EXCEPTION_SUPPORT_FLAG                            0x400
// #define CR4_OS_XMM_EXCEPTION_SUPPORT_MASK                            0x01
// #define CR4_OS_XMM_EXCEPTION_SUPPORT(_)                              (((_) >> 10) & 0x01)
//
//		/**
//		 * @brief User-Mode Instruction Prevention
//		 *
//		 * [Bit 11] When set, the following instructions cannot be executed if CPL > 0: SGDT,
//SIDT, SLDT, SMSW, and STR. An attempt
//		 * at such execution causes a general-protection exception (\#GP).
//		 */
//		UINT64 UsermodeInstructionPrevention : 1;
// #define CR4_USERMODE_INSTRUCTION_PREVENTION_BIT                      11
// #define CR4_USERMODE_INSTRUCTION_PREVENTION_FLAG                     0x800
// #define CR4_USERMODE_INSTRUCTION_PREVENTION_MASK                     0x01
// #define CR4_USERMODE_INSTRUCTION_PREVENTION(_)                       (((_) >> 11) & 0x01)
//
//		/**
//		 * @brief 57-bit Linear Addresses
//		 *
//		 * [Bit 12] When set in IA-32e mode, the processor uses 5-level paging to translate
//57-bit linear addresses. When clear in
//		 * IA-32e mode, the processor uses 4-level paging to translate 48-bit linear
//addresses. This bit cannot be modified in
//		 * IA-32e mode.
//		 *
//		 * @see Vol3C[4(PAGING)]
//		 */
//		UINT64 LinearAddresses57Bit : 1;
// #define CR4_LINEAR_ADDRESSES_57_BIT_BIT                              12
// #define CR4_LINEAR_ADDRESSES_57_BIT_FLAG                             0x1000
// #define CR4_LINEAR_ADDRESSES_57_BIT_MASK                             0x01
// #define CR4_LINEAR_ADDRESSES_57_BIT(_)                               (((_) >> 12) & 0x01)
//
//		/**
//		 * @brief VMX-Enable
//		 *
//		 * [Bit 13] Enables VMX operation when set.
//		 *
//		 * @see Vol3C[23(INTRODUCTION TO VIRTUAL MACHINE EXTENSIONS)]
//		 */
//		UINT64 VmxEnable : 1;
// #define CR4_VMX_ENABLE_BIT                                           13
// #define CR4_VMX_ENABLE_FLAG                                          0x2000
// #define CR4_VMX_ENABLE_MASK                                          0x01
// #define CR4_VMX_ENABLE(_)                                            (((_) >> 13) & 0x01)
//
//		/**
//		 * @brief SMX-Enable
//		 *
//		 * [Bit 14] Enables SMX operation when set.
//		 *
//		 * @see Vol2[6(SAFER MODE EXTENSIONS REFERENCE)]
//		 */
//		UINT64 SmxEnable : 1;
// #define CR4_SMX_ENABLE_BIT                                           14
// #define CR4_SMX_ENABLE_FLAG                                          0x4000
// #define CR4_SMX_ENABLE_MASK                                          0x01
// #define CR4_SMX_ENABLE(_)                                            (((_) >> 14) & 0x01)
//		UINT64 Reserved1 : 1;
//
//		/**
//		 * @brief FSGSBASE-Enable
//		 *
//		 * [Bit 16] Enables the instructions RDFSBASE, RDGSBASE, WRFSBASE, and WRGSBASE.
//		 */
//		UINT64 FsgsbaseEnable : 1;
// #define CR4_FSGSBASE_ENABLE_BIT                                      16
// #define CR4_FSGSBASE_ENABLE_FLAG                                     0x10000
// #define CR4_FSGSBASE_ENABLE_MASK                                     0x01
// #define CR4_FSGSBASE_ENABLE(_)                                       (((_) >> 16) & 0x01)
//
//		/**
//		 * @brief PCID-Enable
//		 *
//		 * [Bit 17] Enables process-context identifiers (PCIDs) when set. Can be set only in
//IA-32e mode (if IA32_EFER.LMA = 1).
//		 *
//		 * @see Vol3A[4.10.1(Process-Context Identifiers (PCIDs))]
//		 */
//		UINT64 PcidEnable : 1;
// #define CR4_PCID_ENABLE_BIT                                          17
// #define CR4_PCID_ENABLE_FLAG                                         0x20000
// #define CR4_PCID_ENABLE_MASK                                         0x01
// #define CR4_PCID_ENABLE(_)                                           (((_) >> 17) & 0x01)
//
//		/**
//		 * @brief XSAVE and Processor Extended States-Enable
//		 *
//		 * [Bit 18] When set, this flag:
//		 * -# indicates (via CPUID.01H:ECX.OSXSAVE[bit 27]) that the operating system supports
//the use of the XGETBV, XSAVE and
//		 * XRSTOR instructions by general software;
//		 * -# enables the XSAVE and XRSTOR instructions to save and restore the x87 FPU state
//(including MMX registers), the SSE
//		 * state (XMM registers and MXCSR), along with other processor extended states enabled
//in XCR0;
//		 * -# enables the processor to execute XGETBV and XSETBV instructions in order to read
//and write XCR0.
//		 *
//		 * @see Vol3A[2.6(EXTENDED CONTROL REGISTERS (INCLUDING XCR0))]
//		 * @see Vol3A[13(SYSTEM PROGRAMMING FOR INSTRUCTION SET EXTENSIONS AND PROCESSOR
//EXTENDED)]
//		 */
//		UINT64 OsXsave : 1;
// #define CR4_OS_XSAVE_BIT                                             18
// #define CR4_OS_XSAVE_FLAG                                            0x40000
// #define CR4_OS_XSAVE_MASK                                            0x01
// #define CR4_OS_XSAVE(_)                                              (((_) >> 18) & 0x01)
//
//		/**
//		 * @brief Key-Locker-Enable
//		 *
//		 * [Bit 19] When set, the LOADIWKEY instruction is enabled; in addition, if support
//for the AES Key Locker instructions has
//		 * been activated by system firmware, CPUID.19H:EBX.AESKLE[bit 0] is enumerated as 1
//and the AES Key Locker instructions
//		 * are enabled. When clear, CPUID.19H:EBX.AESKLE[bit 0] is enumerated as 0 and
//execution of any Key Locker instruction
//		 * causes an invalid-opcode exception (\#UD).
//		 */
//		UINT64 KeyLockerEnable : 1;
// #define CR4_KEY_LOCKER_ENABLE_BIT                                    19
// #define CR4_KEY_LOCKER_ENABLE_FLAG                                   0x80000
// #define CR4_KEY_LOCKER_ENABLE_MASK                                   0x01
// #define CR4_KEY_LOCKER_ENABLE(_)                                     (((_) >> 19) & 0x01)
//
//		/**
//		 * @brief SMEP-Enable
//		 *
//		 * [Bit 20] Enables supervisor-mode execution prevention (SMEP) when set.
//		 *
//		 * @see Vol3A[4.6(ACCESS RIGHTS)]
//		 */
//		UINT64 SmepEnable : 1;
// #define CR4_SMEP_ENABLE_BIT                                          20
// #define CR4_SMEP_ENABLE_FLAG                                         0x100000
// #define CR4_SMEP_ENABLE_MASK                                         0x01
// #define CR4_SMEP_ENABLE(_)                                           (((_) >> 20) & 0x01)
//
//		/**
//		 * @brief SMAP-Enable
//		 *
//		 * [Bit 21] Enables supervisor-mode access prevention (SMAP) when set.
//		 *
//		 * @see Vol3A[4.6(ACCESS RIGHTS)]
//		 */
//		UINT64 SmapEnable : 1;
// #define CR4_SMAP_ENABLE_BIT                                          21
// #define CR4_SMAP_ENABLE_FLAG                                         0x200000
// #define CR4_SMAP_ENABLE_MASK                                         0x01
// #define CR4_SMAP_ENABLE(_)                                           (((_) >> 21) & 0x01)
//
//		/**
//		 * @brief Protection-Key-Enable
//		 *
//		 * [Bit 22] Enables 4-level paging to associate each linear address with a protection
//key. The PKRU register specifies, for
//		 * each protection key, whether user-mode linear addresses with that protection key
//can be read or written. This bit also
//		 * enables access to the PKRU register using the RDPKRU and WRPKRU instructions.
//		 */
//		UINT64 ProtectionKeyEnable : 1;
// #define CR4_PROTECTION_KEY_ENABLE_BIT                                22
// #define CR4_PROTECTION_KEY_ENABLE_FLAG                               0x400000
// #define CR4_PROTECTION_KEY_ENABLE_MASK                               0x01
// #define CR4_PROTECTION_KEY_ENABLE(_)                                 (((_) >> 22) & 0x01)
//
//		/**
//		 * @brief Control-flow Enforcement Technology
//		 *
//		 * [Bit 23] Enables control-flow enforcement technology when set. This flag can be set
//only if CR0.WP is set, and it must
//		 * be clear before CR0.WP can be cleared.
//		 *
//		 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
//		 */
//		UINT64 ControlFlowEnforcementEnable : 1;
// #define CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE_BIT                      23
// #define CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE_FLAG                     0x800000
// #define CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE_MASK                     0x01
// #define CR4_CONTROL_FLOW_ENFORCEMENT_ENABLE(_)                       (((_) >> 23) & 0x01)
//
//		/**
//		 * @brief Enable protection keys for supervisor-mode pages
//		 *
//		 * [Bit 24] 4-level paging and 5-level paging associate each supervisor-mode linear
//address with a protection key. When
//		 * set, this flag allows use of the IA32_PKRS MSR to specify, for each protection key,
//whether supervisor-mode linear
//		 * addresses with that protection key can be read or written.
//		 */
//		UINT64 ProtectionKeyForSupervisorModeEnable : 1;
// #define CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE_BIT            24
// #define CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE_FLAG           0x1000000
// #define CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE_MASK           0x01
// #define CR4_PROTECTION_KEY_FOR_SUPERVISOR_MODE_ENABLE(_)             (((_) >> 24) & 0x01)
//		UINT64 Reserved2 : 39;
//	};
//
//	UINT64 AsUInt;
// } CR4;

typedef union
{
        struct
        {
                /**
                 * @brief Task Priority Level
                 *
                 * [Bits 3:0] This sets the threshold value corresponding to the highestpriority
                 * interrupt to be blocked. A value of 0 means all interrupts are enabled. This
                 * field is available in 64- bit mode. A value of 15 means all interrupts will be
                 * disabled.
                 */
                UINT64 TaskPriorityLevel : 4;
#define CR8_TASK_PRIORITY_LEVEL_BIT  0
#define CR8_TASK_PRIORITY_LEVEL_FLAG 0x0F
#define CR8_TASK_PRIORITY_LEVEL_MASK 0x0F
#define CR8_TASK_PRIORITY_LEVEL(_)   (((_) >> 0) & 0x0F)

                /**
                 * @brief Reserved
                 *
                 * [Bits 63:4] Reserved and must be written with zeros. Failure to do this causes a
                 * general-protection exception.
                 */
                UINT64 Reserved : 60;
#define CR8_RESERVED_BIT  4
#define CR8_RESERVED_FLAG 0xFFFFFFFFFFFFFFF0
#define CR8_RESERVED_MASK 0xFFFFFFFFFFFFFFF
#define CR8_RESERVED(_)   (((_) >> 4) & 0xFFFFFFFFFFFFFFF)
        };

        UINT64 AsUInt;
} CR8;

/**
 * @}
 */

/**
 * @defgroup DEBUG_REGISTERS \
 *           Debug registers
 *
 * Eight debug registers control the debug operation of the processor. These registers can be
 * written to and read using the move to/from debug register form of the MOV instruction. A debug
 * register may be the source or destination operand for one of these instructions. Debug registers
 * are privileged resources; a MOV instruction that accesses these registers can only be executed in
 * real-address mode, in SMM or in protected mode at a CPL of 0. An attempt to read or write the
 * debug registers from any other privilege level generates a general-protection exception (\#GP).
 * The primary function of the debug registers is to set up and monitor from 1 to 4 breakpoints,
 * numbered 0 though 3. For each breakpoint, the following information can be specified:
 * - The linear address where the breakpoint is to occur.
 * - The length of the breakpoint location: 1, 2, 4, or 8 bytes.
 * - The operation that must be performed at the address for a debug exception to be generated.
 * - Whether the breakpoint is enabled.
 * - Whether the breakpoint condition was present when the debug exception was generated.
 *
 * @see Vol3B[17.2.4(Debug Control Register (DR7))]
 * @see Vol3B[17.2(DEBUG REGISTERS)] (reference)
 * @{
 */
typedef union
{
        struct
        {
                /**
                 * @brief B0 through B3 (breakpoint condition detected) flags
                 *
                 * [Bits 3:0] Indicates (when set) that its associated breakpoint condition was met
                 * when a debug exception was generated. These flags are set if the condition
                 * described for each breakpoint by the LENn, and R/Wn flags in debug control
                 * register DR7 is true. They may or may not be set if the breakpoint is not enabled
                 * by the Ln or the Gn flags in register DR7. Therefore on a \#DB, a debug handler
                 * should check only those B0-B3 bits which correspond to an enabled breakpoint.
                 */
                UINT64 BreakpointCondition : 4;
#define DR6_BREAKPOINT_CONDITION_BIT  0
#define DR6_BREAKPOINT_CONDITION_FLAG 0x0F
#define DR6_BREAKPOINT_CONDITION_MASK 0x0F
#define DR6_BREAKPOINT_CONDITION(_)   (((_) >> 0) & 0x0F)
                UINT64 Reserved1 : 9;

                /**
                 * @brief BD (debug register access detected) flag
                 *
                 * [Bit 13] Indicates that the next instruction in the instruction stream accesses
                 * one of the debug registers (DR0 through DR7). This flag is enabled when the GD
                 * (general detect) flag in debug control register DR7 is set.
                 *
                 * @see Vol3B[17.2.4(Debug Control Register (DR7))]
                 */
                UINT64 DebugRegisterAccessDetected : 1;
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_BIT  13
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_FLAG 0x2000
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED_MASK 0x01
#define DR6_DEBUG_REGISTER_ACCESS_DETECTED(_)   (((_) >> 13) & 0x01)

                /**
                 * @brief BS (single step) flag
                 *
                 * [Bit 14] Indicates (when set) that the debug exception was triggered by the
                 * singlestep execution mode (enabled with the TF flag in the EFLAGS register). The
                 * single-step mode is the highestpriority debug exception. When the BS flag is set,
                 * any of the other debug status bits also may be set.
                 */
                UINT64 SingleInstruction : 1;
#define DR6_SINGLE_INSTRUCTION_BIT  14
#define DR6_SINGLE_INSTRUCTION_FLAG 0x4000
#define DR6_SINGLE_INSTRUCTION_MASK 0x01
#define DR6_SINGLE_INSTRUCTION(_)   (((_) >> 14) & 0x01)

                /**
                 * @brief BT (task switch) flag
                 *
                 * [Bit 15] Indicates (when set) that the debug exception was triggered by the
                 * singlestep execution mode (enabled with the TF flag in the EFLAGS register). The
                 * single-step mode is the highestpriority debug exception. When the BS flag is set,
                 * any of the other debug status bits also may be set.
                 */
                UINT64 TaskSwitch : 1;
#define DR6_TASK_SWITCH_BIT  15
#define DR6_TASK_SWITCH_FLAG 0x8000
#define DR6_TASK_SWITCH_MASK 0x01
#define DR6_TASK_SWITCH(_)   (((_) >> 15) & 0x01)

                /**
                 * @brief RTM (restricted transactional memory) flag
                 *
                 * [Bit 16] Indicates (when clear) that a debug exception (\#DB) or breakpoint
                 * exception (\#BP) occurred inside an RTM region while advanced debugging of RTM
                 * transactional regions was enabled. This bit is set for any other debug exception
                 * (including all those that occur when advanced debugging of RTM transactional
                 * regions is not enabled). This bit is always 1 if the processor does not support
                 * RTM.
                 *
                 * @see Vol3B[17.3.3(Debug Exceptions, Breakpoint Exceptions, and Restricted
                 * Transactional Memory (RTM))]
                 */
                UINT64 RestrictedTransactionalMemory : 1;
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_BIT  16
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG 0x10000
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY_MASK 0x01
#define DR6_RESTRICTED_TRANSACTIONAL_MEMORY(_)   (((_) >> 16) & 0x01)
                UINT64 Reserved2 : 47;
        };

        UINT64 AsUInt;
} DR6;

typedef union
{
        struct
        {
                /**
                 * @brief L0 through L3 (local breakpoint enable) flags (bits 0, 2, 4, and 6)
                 *
                 * [Bit 0] Enables (when set) the breakpoint condition for the associated breakpoint
                 * for the current task. When a breakpoint condition is detected and its associated
                 * Ln flag is set, a debug exception is generated. The processor automatically
                 * clears these flags on every task switch to avoid unwanted breakpoint conditions
                 * in the new task.
                 */
                UINT64 LocalBreakpoint0 : 1;
#define DR7_LOCAL_BREAKPOINT_0_BIT  0
#define DR7_LOCAL_BREAKPOINT_0_FLAG 0x01
#define DR7_LOCAL_BREAKPOINT_0_MASK 0x01
#define DR7_LOCAL_BREAKPOINT_0(_)   (((_) >> 0) & 0x01)

                /**
                 * @brief G0 through G3 (global breakpoint enable) flags (bits 1, 3, 5, and 7)
                 *
                 * [Bit 1] Enables (when set) the breakpoint condition for the associated breakpoint
                 * for all tasks. When a breakpoint condition is detected and its associated Gn flag
                 * is set, a debug exception is generated. The processor does not clear these flags
                 * on a task switch, allowing a breakpoint to be enabled for all tasks.
                 */
                UINT64 GlobalBreakpoint0 : 1;
#define DR7_GLOBAL_BREAKPOINT_0_BIT  1
#define DR7_GLOBAL_BREAKPOINT_0_FLAG 0x02
#define DR7_GLOBAL_BREAKPOINT_0_MASK 0x01
#define DR7_GLOBAL_BREAKPOINT_0(_)   (((_) >> 1) & 0x01)
                UINT64 LocalBreakpoint1 : 1;
#define DR7_LOCAL_BREAKPOINT_1_BIT  2
#define DR7_LOCAL_BREAKPOINT_1_FLAG 0x04
#define DR7_LOCAL_BREAKPOINT_1_MASK 0x01
#define DR7_LOCAL_BREAKPOINT_1(_)   (((_) >> 2) & 0x01)
                UINT64 GlobalBreakpoint1 : 1;
#define DR7_GLOBAL_BREAKPOINT_1_BIT  3
#define DR7_GLOBAL_BREAKPOINT_1_FLAG 0x08
#define DR7_GLOBAL_BREAKPOINT_1_MASK 0x01
#define DR7_GLOBAL_BREAKPOINT_1(_)   (((_) >> 3) & 0x01)
                UINT64 LocalBreakpoint2 : 1;
#define DR7_LOCAL_BREAKPOINT_2_BIT  4
#define DR7_LOCAL_BREAKPOINT_2_FLAG 0x10
#define DR7_LOCAL_BREAKPOINT_2_MASK 0x01
#define DR7_LOCAL_BREAKPOINT_2(_)   (((_) >> 4) & 0x01)
                UINT64 GlobalBreakpoint2 : 1;
#define DR7_GLOBAL_BREAKPOINT_2_BIT  5
#define DR7_GLOBAL_BREAKPOINT_2_FLAG 0x20
#define DR7_GLOBAL_BREAKPOINT_2_MASK 0x01
#define DR7_GLOBAL_BREAKPOINT_2(_)   (((_) >> 5) & 0x01)
                UINT64 LocalBreakpoint3 : 1;
#define DR7_LOCAL_BREAKPOINT_3_BIT  6
#define DR7_LOCAL_BREAKPOINT_3_FLAG 0x40
#define DR7_LOCAL_BREAKPOINT_3_MASK 0x01
#define DR7_LOCAL_BREAKPOINT_3(_)   (((_) >> 6) & 0x01)
                UINT64 GlobalBreakpoint3 : 1;
#define DR7_GLOBAL_BREAKPOINT_3_BIT  7
#define DR7_GLOBAL_BREAKPOINT_3_FLAG 0x80
#define DR7_GLOBAL_BREAKPOINT_3_MASK 0x01
#define DR7_GLOBAL_BREAKPOINT_3(_)   (((_) >> 7) & 0x01)

                /**
                 * @brief LE (local exact breakpoint enable)
                 *
                 * [Bit 8] This feature is not supported in the P6 family processors, later IA-32
                 * processors, and Intel 64 processors. When set, these flags cause the processor to
                 * detect the exact instruction that caused a data breakpoint condition. For
                 * backward and forward compatibility with other Intel processors, we recommend that
                 * the LE and GE flags be set to 1 if exact breakpoints are required.
                 */
                UINT64 LocalExactBreakpoint : 1;
#define DR7_LOCAL_EXACT_BREAKPOINT_BIT  8
#define DR7_LOCAL_EXACT_BREAKPOINT_FLAG 0x100
#define DR7_LOCAL_EXACT_BREAKPOINT_MASK 0x01
#define DR7_LOCAL_EXACT_BREAKPOINT(_)   (((_) >> 8) & 0x01)
                UINT64 GlobalExactBreakpoint : 1;
#define DR7_GLOBAL_EXACT_BREAKPOINT_BIT  9
#define DR7_GLOBAL_EXACT_BREAKPOINT_FLAG 0x200
#define DR7_GLOBAL_EXACT_BREAKPOINT_MASK 0x01
#define DR7_GLOBAL_EXACT_BREAKPOINT(_)   (((_) >> 9) & 0x01)
                UINT64 Reserved1 : 1;

                /**
                 * @brief RTM (restricted transactional memory) flag
                 *
                 * [Bit 11] Enables (when set) advanced debugging of RTM transactional regions. This
                 * advanced debugging is enabled only if IA32_DEBUGCTL.RTM is also set.
                 *
                 * @see Vol3B[17.3.3(Debug Exceptions, Breakpoint Exceptions, and Restricted
                 * Transactional Memory (RTM))]
                 */
                UINT64 RestrictedTransactionalMemory : 1;
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_BIT  11
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_FLAG 0x800
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY_MASK 0x01
#define DR7_RESTRICTED_TRANSACTIONAL_MEMORY(_)   (((_) >> 11) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * @brief GD (general detect enable) flag
                 *
                 * [Bit 13] Enables (when set) debug-register protection, which causes a debug
                 * exception to be generated prior to any MOV instruction that accesses a debug
                 * register. When such a condition is detected, the BD flag in debug status register
                 * DR6 is set prior to generating the exception. This condition is provided to
                 * support in-circuit emulators. When the emulator needs to access the debug
                 * registers, emulator software can set the GD flag to prevent interference from the
                 * program currently executing on the processor. The processor clears the GD flag
                 * upon entering to the debug exception handler, to allow the handler access to the
                 * debug registers.
                 */
                UINT64 GeneralDetect : 1;
#define DR7_GENERAL_DETECT_BIT  13
#define DR7_GENERAL_DETECT_FLAG 0x2000
#define DR7_GENERAL_DETECT_MASK 0x01
#define DR7_GENERAL_DETECT(_)   (((_) >> 13) & 0x01)
                UINT64 Reserved3 : 2;

                /**
                 * @brief R/W0 through R/W3 (read/write) fields (bits 16, 17, 20, 21, 24, 25, 28,
                 * and 29)
                 *
                 * [Bits 17:16] Specifies the breakpoint condition for the corresponding breakpoint.
                 * The DE (debug extensions) flag in control register CR4 determines how the bits in
                 * the R/Wn fields are interpreted. When the DE flag is set, the processor
                 * interprets bits as follows:
                 * - 00 - Break on instruction execution only.
                 * - 01 - Break on data writes only.
                 * - 10 - Break on I/O reads or writes.
                 * - 11 - Break on data reads or writes but not instruction fetches.
                 * When the DE flag is clear, the processor interprets the R/Wn bits the same as for
                 * the Intel386(TM) and Intel486(TM) processors, which is as follows:
                 * - 00 - Break on instruction execution only.
                 * - 01 - Break on data writes only.
                 * - 10 - Undefined.
                 * - 11 - Break on data reads or writes but not instruction fetches.
                 */
                UINT64 ReadWrite0 : 2;
#define DR7_READ_WRITE_0_BIT  16
#define DR7_READ_WRITE_0_FLAG 0x30000
#define DR7_READ_WRITE_0_MASK 0x03
#define DR7_READ_WRITE_0(_)   (((_) >> 16) & 0x03)

                /**
                 * @brief LEN0 through LEN3 (Length) fields (bits 18, 19, 22, 23, 26, 27, 30, and
                 * 31)
                 *
                 * [Bits 19:18] Specify the size of the memory location at the address specified in
                 * the corresponding breakpoint address register (DR0 through DR3). These fields are
                 * interpreted as follows:
                 * - 00 - 1-byte length.
                 * - 01 - 2-byte length.
                 * - 10 - Undefined (or 8 byte length, see note below).
                 * - 11 - 4-byte length.
                 * If the corresponding RWn field in register DR7 is 00 (instruction execution),
                 * then the LENn field should also be 00. The effect of using other lengths is
                 * undefined.
                 *
                 * @see Vol3B[17.2.5(Breakpoint Field Recognition)]
                 */
                UINT64 Length0 : 2;
#define DR7_LENGTH_0_BIT  18
#define DR7_LENGTH_0_FLAG 0xC0000
#define DR7_LENGTH_0_MASK 0x03
#define DR7_LENGTH_0(_)   (((_) >> 18) & 0x03)
                UINT64 ReadWrite1 : 2;
#define DR7_READ_WRITE_1_BIT  20
#define DR7_READ_WRITE_1_FLAG 0x300000
#define DR7_READ_WRITE_1_MASK 0x03
#define DR7_READ_WRITE_1(_)   (((_) >> 20) & 0x03)
                UINT64 Length1 : 2;
#define DR7_LENGTH_1_BIT  22
#define DR7_LENGTH_1_FLAG 0xC00000
#define DR7_LENGTH_1_MASK 0x03
#define DR7_LENGTH_1(_)   (((_) >> 22) & 0x03)
                UINT64 ReadWrite2 : 2;
#define DR7_READ_WRITE_2_BIT  24
#define DR7_READ_WRITE_2_FLAG 0x3000000
#define DR7_READ_WRITE_2_MASK 0x03
#define DR7_READ_WRITE_2(_)   (((_) >> 24) & 0x03)
                UINT64 Length2 : 2;
#define DR7_LENGTH_2_BIT  26
#define DR7_LENGTH_2_FLAG 0xC000000
#define DR7_LENGTH_2_MASK 0x03
#define DR7_LENGTH_2(_)   (((_) >> 26) & 0x03)
                UINT64 ReadWrite3 : 2;
#define DR7_READ_WRITE_3_BIT  28
#define DR7_READ_WRITE_3_FLAG 0x30000000
#define DR7_READ_WRITE_3_MASK 0x03
#define DR7_READ_WRITE_3(_)   (((_) >> 28) & 0x03)
                UINT64 Length3 : 2;
#define DR7_LENGTH_3_BIT  30
#define DR7_LENGTH_3_FLAG 0xC0000000
#define DR7_LENGTH_3_MASK 0x03
#define DR7_LENGTH_3(_)   (((_) >> 30) & 0x03)
                UINT64 Reserved4 : 32;
        };

        UINT64 AsUInt;
} DR7;

/**
 * @}
 */

/**
 * @defgroup CPUID \
 *           CPUID
 *
 * @see Vol2A[3.2(CPUID)] (reference)
 * @{
 */
/**
 * @brief Returns CPUID's Highest Value for Basic Processor Information and the Vendor
 * Identification String
 *
 * When CPUID executes with EAX set to 0, the processor returns the highest value the CPUID
 * recognizes for returning basic processor information. The value is returned in the EAX register
 * and is processor specific. A vendor identification string is also returned in EBX, EDX, and ECX.
 * For Intel processors, the string is "GenuineIntel" and is expressed:
 * - EBX <- 756e6547h (* "Genu", with G in the low eight bits of BL *)
 * - EDX <- 49656e69h (* "ineI", with i in the low eight bits of DL *)
 * - ECX <- 6c65746eh (* "ntel", with n in the low eight bits of CL *)
 */
#define CPUID_SIGNATURE 0x00000000
typedef struct
{
        /**
         * @brief EAX
         *
         * Maximum Input Value for Basic CPUID Information.
         */
        UINT32 MaxCpuidInputValue;

        /**
         * @brief EBX
         *
         * "Genu"
         */
        UINT32 EbxValueGenu;

        /**
         * @brief ECX
         *
         * "ntel"
         */
        UINT32 EcxValueNtel;

        /**
         * @brief EDX
         *
         * "ineI"
         */
        UINT32 EdxValueInei;
} CPUID_EAX_00;

/**
 * @brief Returns Model, Family, Stepping Information, Additional Information and Feature
 * Information
 *
 * Returns:
 *   * Model, Family, Stepping Information in EAX
 *   * Additional Information in EBX
 *   * Feature Information in ECX and EDX
 */
#define CPUID_VERSION_INFORMATION 0x00000001
typedef struct
{
        /**
         * @brief When CPUID executes with EAX set to 01H, version information is returned in EAX
         */
        union
        {
                struct
                {
                        UINT32 SteppingId : 4;
#define CPUID_VERSION_INFORMATION_STEPPING_ID_BIT  0
#define CPUID_VERSION_INFORMATION_STEPPING_ID_FLAG 0x0F
#define CPUID_VERSION_INFORMATION_STEPPING_ID_MASK 0x0F
#define CPUID_VERSION_INFORMATION_STEPPING_ID(_)   (((_) >> 0) & 0x0F)
                        UINT32 Model : 4;
#define CPUID_VERSION_INFORMATION_MODEL_BIT  4
#define CPUID_VERSION_INFORMATION_MODEL_FLAG 0xF0
#define CPUID_VERSION_INFORMATION_MODEL_MASK 0x0F
#define CPUID_VERSION_INFORMATION_MODEL(_)   (((_) >> 4) & 0x0F)
                        UINT32 FamilyId : 4;
#define CPUID_VERSION_INFORMATION_FAMILY_ID_BIT  8
#define CPUID_VERSION_INFORMATION_FAMILY_ID_FLAG 0xF00
#define CPUID_VERSION_INFORMATION_FAMILY_ID_MASK 0x0F
#define CPUID_VERSION_INFORMATION_FAMILY_ID(_)   (((_) >> 8) & 0x0F)

                        /**
                         * [Bits 13:12] - 0 - Original OEM Processor
                         * - 1 - Intel OverDrive(R) Processor
                         * - 2 - Dual processor (not applicable to Intel486 processors)
                         * - 3 - Intel reserved
                         */
                        UINT32 ProcessorType : 2;
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_BIT  12
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_FLAG 0x3000
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE_MASK 0x03
#define CPUID_VERSION_INFORMATION_PROCESSOR_TYPE(_)   (((_) >> 12) & 0x03)
                        UINT32 Reserved1 : 2;

                        /**
                         * [Bits 19:16] The Extended Model ID needs to be examined only when the
                         * Family ID is 06H or 0FH.
                         */
                        UINT32 ExtendedModelId : 4;
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_BIT  16
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_FLAG 0xF0000
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID_MASK 0x0F
#define CPUID_VERSION_INFORMATION_EXTENDED_MODEL_ID(_)   (((_) >> 16) & 0x0F)

                        /**
                         * [Bits 27:20] The Extended Family ID needs to be examined only when the
                         * Family ID is 0FH.
                         */
                        UINT32 ExtendedFamilyId : 8;
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_BIT  20
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_FLAG 0xFF00000
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID_MASK 0xFF
#define CPUID_VERSION_INFORMATION_EXTENDED_FAMILY_ID(_)   (((_) >> 20) & 0xFF)
                        UINT32 Reserved2 : 4;
                };

                UINT32 AsUInt;
        } CpuidVersionInformation;

        /**
         * @brief When CPUID executes with EAX set to 01H, additional information is returned to the
         * EBX register
         */
        union
        {
                struct
                {
                        /**
                         * [Bits 7:0] This number provides an entry into a brand string table that
                         * contains brand strings for IA-32 processors. More information about this
                         * field is provided later in this section.
                         */
                        UINT32 BrandIndex : 8;
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_BIT  0
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_FLAG 0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX_MASK 0xFF
#define CPUID_ADDITIONAL_INFORMATION_BRAND_INDEX(_)   (((_) >> 0) & 0xFF)

                        /**
                         * @brief Value * 8 = cache line size in bytes; used also by CLFLUSHOPT
                         *
                         * [Bits 15:8] This number indicates the size of the cache line flushed by
                         * the CLFLUSH and CLFLUSHOPT instructions in 8-byte increments. This field
                         * was introduced in the Pentium 4 processor.
                         */
                        UINT32 ClflushLineSize : 8;
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_BIT  8
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_FLAG 0xFF00
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE_MASK 0xFF
#define CPUID_ADDITIONAL_INFORMATION_CLFLUSH_LINE_SIZE(_)   (((_) >> 8) & 0xFF)

                        /**
                         * [Bits 23:16] Maximum number of addressable IDs for logical processors in
                         * this physical package.
                         *
                         * @remarks The nearest power-of-2 integer that is not smaller than
                         * EBX[23:16] is the number of unique initial APIC IDs reserved for
                         * addressing different logical processors in a physical package. This field
                         * is only valid if CPUID.1.EDX.HTT[bit 28] = 1.
                         */
                        UINT32 MaxAddressableIds : 8;
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_BIT  16
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_FLAG 0xFF0000
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS_MASK 0xFF
#define CPUID_ADDITIONAL_INFORMATION_MAX_ADDRESSABLE_IDS(_)   (((_) >> 16) & 0xFF)

                        /**
                         * [Bits 31:24] This number is the 8-bit ID that is assigned to the local
                         * APIC on the processor during power up. This field was introduced in the
                         * Pentium 4 processor.
                         */
                        UINT32 InitialApicId : 8;
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_BIT  24
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_FLAG 0xFF000000
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID_MASK 0xFF
#define CPUID_ADDITIONAL_INFORMATION_INITIAL_APIC_ID(_)   (((_) >> 24) & 0xFF)
                };

                UINT32 AsUInt;
        } CpuidAdditionalInformation;

        /**
         * @brief When CPUID executes with EAX set to 01H, feature information is returned in ECX
         * and EDX
         */
        union
        {
                struct
                {
                        /**
                         * @brief Streaming SIMD Extensions 3 (SSE3)
                         *
                         * [Bit 0] A value of 1 indicates the processor supports this technology.
                         */
                        UINT32 StreamingSimdExtensions3 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_BIT  0
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_STREAMING_SIMD_EXTENSIONS_3(_)   (((_) >> 0) & 0x01)

                        /**
                         * @brief PCLMULQDQ instruction
                         *
                         * [Bit 1] A value of 1 indicates the processor supports the PCLMULQDQ
                         * instruction.
                         */
                        UINT32 PclmulqdqInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_BIT  1
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_FLAG 0x02
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PCLMULQDQ_INSTRUCTION(_)   (((_) >> 1) & 0x01)

                        /**
                         * @brief 64-bit DS Area
                         *
                         * [Bit 2] A value of 1 indicates the processor supports DS area using
                         * 64-bit layout.
                         */
                        UINT32 DsArea64BitLayout : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_BIT  2
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_FLAG 0x04
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_DS_AREA_64BIT_LAYOUT(_)   (((_) >> 2) & 0x01)

                        /**
                         * @brief MONITOR/MWAIT instruction
                         *
                         * [Bit 3] A value of 1 indicates the processor supports this feature.
                         */
                        UINT32 MonitorMwaitInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_BIT  3
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_FLAG 0x08
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_MONITOR_MWAIT_INSTRUCTION(_)   (((_) >> 3) & 0x01)

                        /**
                         * @brief CPL Qualified Debug Store
                         *
                         * [Bit 4] A value of 1 indicates the processor supports the extensions to
                         * the Debug Store feature to allow for branch message storage qualified by
                         * CPL.
                         */
                        UINT32 CplQualifiedDebugStore : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_BIT  4
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_FLAG 0x10
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_CPL_QUALIFIED_DEBUG_STORE(_)   (((_) >> 4) & 0x01)

                        /**
                         * @brief Virtual Machine Extensions
                         *
                         * [Bit 5] A value of 1 indicates that the processor supports this
                         * technology.
                         */
                        UINT32 VirtualMachineExtensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_BIT  5
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_FLAG 0x20
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_VIRTUAL_MACHINE_EXTENSIONS(_)   (((_) >> 5) & 0x01)

                        /**
                         * @brief Safer Mode Extensions
                         *
                         * [Bit 6] A value of 1 indicates that the processor supports this
                         * technology.
                         *
                         * @see Vol2[6(SAFER MODE EXTENSIONS REFERENCE)]
                         */
                        UINT32 SaferModeExtensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_BIT  6
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_FLAG 0x40
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SAFER_MODE_EXTENSIONS(_)   (((_) >> 6) & 0x01)

                        /**
                         * @brief Enhanced Intel SpeedStep(R) technology
                         *
                         * [Bit 7] A value of 1 indicates that the processor supports this
                         * technology.
                         */
                        UINT32 EnhancedIntelSpeedstepTechnology : 1;
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_BIT  7
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_FLAG 0x80
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY(_)   (((_) >> 7) & 0x01)

                        /**
                         * @brief Thermal Monitor 2
                         *
                         * [Bit 8] A value of 1 indicates whether the processor supports this
                         * technology.
                         */
                        UINT32 ThermalMonitor2 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_BIT  8
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_FLAG 0x100
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_THERMAL_MONITOR_2(_)   (((_) >> 8) & 0x01)

                        /**
                         * @brief Supplemental Streaming SIMD Extensions 3 (SSSE3)
                         *
                         * [Bit 9] A value of 1 indicates the presence of the Supplemental Streaming
                         * SIMD Extensions 3 (SSSE3). A value of 0 indicates the instruction
                         * extensions are not present in the processor.
                         */
                        UINT32 SupplementalStreamingSimdExtensions3 : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_BIT  9
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_FLAG 0x200
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SUPPLEMENTAL_STREAMING_SIMD_EXTENSIONS_3(_) \
        (((_) >> 9) & 0x01)

                        /**
                         * @brief L1 Context ID
                         *
                         * [Bit 10] A value of 1 indicates the L1 data cache mode can be set to
                         * either adaptive mode or shared mode. A value of 0 indicates this feature
                         * is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1
                         * Data Cache Context Mode) for details.
                         */
                        UINT32 L1ContextId : 1;
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_BIT  10
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_FLAG 0x400
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_L1_CONTEXT_ID(_)   (((_) >> 10) & 0x01)

                        /**
                         * @brief IA32_DEBUG_INTERFACE MSR for silicon debug
                         *
                         * [Bit 11] A value of 1 indicates the processor supports
                         * IA32_DEBUG_INTERFACE MSR for silicon debug.
                         */
                        UINT32 SiliconDebug : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_BIT  11
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_FLAG 0x800
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SILICON_DEBUG(_)   (((_) >> 11) & 0x01)

                        /**
                         * @brief FMA extensions using YMM state
                         *
                         * [Bit 12] A value of 1 indicates the processor supports FMA (Fused
                         * Multiple Add) extensions using YMM state.
                         */
                        UINT32 FmaExtensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_BIT  12
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_FLAG 0x1000
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_FMA_EXTENSIONS(_)   (((_) >> 12) & 0x01)

                        /**
                         * @brief CMPXCHG16B instruction
                         *
                         * [Bit 13] A value of 1 indicates that the feature is available.
                         */
                        UINT32 Cmpxchg16BInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_BIT  13
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_FLAG 0x2000
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_CMPXCHG16B_INSTRUCTION(_)   (((_) >> 13) & 0x01)

                        /**
                         * @brief xTPR Update Control
                         *
                         * [Bit 14] A value of 1 indicates that the processor supports changing
                         * IA32_MISC_ENABLE[bit 23].
                         */
                        UINT32 XtprUpdateControl : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_BIT  14
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_FLAG 0x4000
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_XTPR_UPDATE_CONTROL(_)   (((_) >> 14) & 0x01)

                        /**
                         * @brief Perfmon and Debug Capability
                         *
                         * [Bit 15] A value of 1 indicates the processor supports the performance
                         * and debug feature indication MSR IA32_PERF_CAPABILITIES.
                         */
                        UINT32 PerfmonAndDebugCapability : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_BIT  15
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PERFMON_AND_DEBUG_CAPABILITY(_)   (((_) >> 15) & 0x01)
                        UINT32 Reserved1 : 1;

                        /**
                         * @brief Process-context identifiers
                         *
                         * [Bit 17] A value of 1 indicates that the processor supports PCIDs and
                         * that software may set CR4.PCIDE to 1.
                         */
                        UINT32 ProcessContextIdentifiers : 1;
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_BIT  17
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_PROCESS_CONTEXT_IDENTIFIERS(_)   (((_) >> 17) & 0x01)

                        /**
                         * @brief Direct Cache Access
                         *
                         * [Bit 18] A value of 1 indicates the processor supports the ability to
                         * prefetch data from a memory mapped device (Direct Cache Access).
                         */
                        UINT32 DirectCacheAccess : 1;
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_BIT  18
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_FLAG 0x40000
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_DIRECT_CACHE_ACCESS(_)   (((_) >> 18) & 0x01)

                        /**
                         * @brief SSE4.1 support
                         *
                         * [Bit 19] A value of 1 indicates that the processor supports SSE4.1.
                         */
                        UINT32 Sse41Support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_BIT  19
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_FLAG 0x80000
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE41_SUPPORT(_)   (((_) >> 19) & 0x01)

                        /**
                         * @brief SSE4.2 support
                         *
                         * [Bit 20] A value of 1 indicates that the processor supports SSE4.2.
                         */
                        UINT32 Sse42Support : 1;
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_BIT  20
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_FLAG 0x100000
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_SSE42_SUPPORT(_)   (((_) >> 20) & 0x01)

                        /**
                         * @brief x2APIC support
                         *
                         * [Bit 21] A value of 1 indicates that the processor supports x2APIC
                         * feature.
                         */
                        UINT32 X2ApicSupport : 1;
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_BIT  21
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_FLAG 0x200000
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_X2APIC_SUPPORT(_)   (((_) >> 21) & 0x01)

                        /**
                         * @brief MOVBE instruction
                         *
                         * [Bit 22] A value of 1 indicates that the processor supports MOVBE
                         * instruction.
                         */
                        UINT32 MovbeInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_BIT  22
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_FLAG 0x400000
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_MOVBE_INSTRUCTION(_)   (((_) >> 22) & 0x01)

                        /**
                         * @brief POPCNT instruction
                         *
                         * [Bit 23] A value of 1 indicates that the processor supports the POPCNT
                         * instruction.
                         */
                        UINT32 PopcntInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_BIT  23
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_FLAG 0x800000
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_POPCNT_INSTRUCTION(_)   (((_) >> 23) & 0x01)

                        /**
                         * @brief TSC Deadline
                         *
                         * [Bit 24] A value of 1 indicates that the processor's local APIC timer
                         * supports one-shot operation using a TSC deadline value.
                         */
                        UINT32 TscDeadline : 1;
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_BIT  24
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_FLAG 0x1000000
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_TSC_DEADLINE(_)   (((_) >> 24) & 0x01)

                        /**
                         * @brief AESNI instruction extensions
                         *
                         * [Bit 25] A value of 1 indicates that the processor supports the AESNI
                         * instruction extensions.
                         */
                        UINT32 AesniInstructionExtensions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_BIT  25
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_FLAG 0x2000000
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_AESNI_INSTRUCTION_EXTENSIONS(_)   (((_) >> 25) & 0x01)

                        /**
                         * @brief XSAVE/XRSTOR instruction extensions
                         *
                         * [Bit 26] A value of 1 indicates that the processor supports the
                         * XSAVE/XRSTOR processor extended states feature, the XSETBV/XGETBV
                         * instructions, and XCR0.
                         */
                        UINT32 XsaveXrstorInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_BIT  26
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_FLAG 0x4000000
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_XSAVE_XRSTOR_INSTRUCTION(_)   (((_) >> 26) & 0x01)

                        /**
                         * @brief CR4.OSXSAVE[bit 18] set
                         *
                         * [Bit 27] A value of 1 indicates that the OS has set CR4.OSXSAVE[bit 18]
                         * to enable XSETBV/XGETBV instructions to access XCR0 and to support
                         * processor extended state management using XSAVE/XRSTOR.
                         */
                        UINT32 OsxSave : 1;
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_BIT  27
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_FLAG 0x8000000
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_OSX_SAVE(_)   (((_) >> 27) & 0x01)

                        /**
                         * @brief AVX instruction extensions support
                         *
                         * [Bit 28] A value of 1 indicates the processor supports the AVX
                         * instruction extensions.
                         */
                        UINT32 AvxSupport : 1;
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_BIT  28
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_FLAG 0x10000000
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_AVX_SUPPORT(_)   (((_) >> 28) & 0x01)

                        /**
                         * @brief 16-bit floating-point conversion instructions support
                         *
                         * [Bit 29] A value of 1 indicates that processor supports 16-bit
                         * floating-point conversion instructions.
                         */
                        UINT32 HalfPrecisionConversionInstructions : 1;
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_BIT  29
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_FLAG 0x20000000
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_HALF_PRECISION_CONVERSION_INSTRUCTIONS(_)   (((_) >> 29) & 0x01)

                        /**
                         * @brief RDRAND instruction support
                         *
                         * [Bit 30] A value of 1 indicates that processor supports RDRAND
                         * instruction.
                         */
                        UINT32 RdrandInstruction : 1;
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_BIT  30
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_FLAG 0x40000000
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_ECX_RDRAND_INSTRUCTION(_)   (((_) >> 30) & 0x01)
                        UINT32 Reserved2 : 1;
                };

                UINT32 AsUInt;
        } CpuidFeatureInformationEcx;

        /**
         * @brief When CPUID executes with EAX set to 01H, feature information is returned in ECX
         * and EDX
         */
        union
        {
                struct
                {
                        /**
                         * @brief Floating Point Unit On-Chip
                         *
                         * [Bit 0] The processor contains an x87 FPU.
                         */
                        UINT32 FloatingPointUnitOnChip : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_BIT  0
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_FLAG 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FLOATING_POINT_UNIT_ON_CHIP(_)   (((_) >> 0) & 0x01)

                        /**
                         * @brief Virtual 8086 Mode Enhancements
                         *
                         * [Bit 1] Virtual 8086 mode enhancements, including CR4.VME for controlling
                         * the feature, CR4.PVI for protected mode virtual interrupts, software
                         * interrupt indirection, expansion of the TSS with the software indirection
                         * bitmap, and EFLAGS.VIF and EFLAGS.VIP flags.
                         */
                        UINT32 Virtual8086ModeEnhancements : 1;
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_BIT  1
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_FLAG 0x02
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_VIRTUAL_8086_MODE_ENHANCEMENTS(_)   (((_) >> 1) & 0x01)

                        /**
                         * @brief Debugging Extensions
                         *
                         * [Bit 2] Support for I/O breakpoints, including CR4.DE for controlling the
                         * feature, and optional trapping of accesses to DR4 and DR5.
                         */
                        UINT32 DebuggingExtensions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_BIT  2
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_FLAG 0x04
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUGGING_EXTENSIONS(_)   (((_) >> 2) & 0x01)

                        /**
                         * @brief Page Size Extension
                         *
                         * [Bit 3] Large pages of size 4 MByte are supported, including CR4.PSE for
                         * controlling the feature, the defined dirty bit in PDE (Page Directory
                         * Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.
                         */
                        UINT32 PageSizeExtension : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_BIT  3
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_FLAG 0x08
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION(_)   (((_) >> 3) & 0x01)

                        /**
                         * @brief Time Stamp Counter
                         *
                         * [Bit 4] The RDTSC instruction is supported, including CR4.TSD for
                         * controlling privilege.
                         */
                        UINT32 TimestampCounter : 1;
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_BIT  4
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_FLAG 0x10
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_TIMESTAMP_COUNTER(_)   (((_) >> 4) & 0x01)

                        /**
                         * @brief Model Specific Registers RDMSR and WRMSR Instructions
                         *
                         * [Bit 5] The RDMSR and WRMSR instructions are supported. Some of the MSRs
                         * are implementation dependent.
                         */
                        UINT32 RdmsrWrmsrInstructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_BIT  5
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_FLAG 0x20
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_RDMSR_WRMSR_INSTRUCTIONS(_)   (((_) >> 5) & 0x01)

                        /**
                         * @brief Physical Address Extension
                         *
                         * [Bit 6] Physical addresses greater than 32 bits are supported: extended
                         * page table entry formats, an extra level in the page translation tables
                         * is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE
                         * bit is 1.
                         */
                        UINT32 PhysicalAddressExtension : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_BIT  6
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_FLAG 0x40
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PHYSICAL_ADDRESS_EXTENSION(_)   (((_) >> 6) & 0x01)

                        /**
                         * @brief Machine Check Exception
                         *
                         * [Bit 7] Exception 18 is defined for Machine Checks, including CR4.MCE for
                         * controlling the feature. This feature does not define the model-specific
                         * implementations of machine-check error logging, reporting, and processor
                         * shutdowns. Machine Check exception handlers may have to depend on
                         * processor version to do model specific processing of the exception, or
                         * test for the presence of the Machine Check feature.
                         */
                        UINT32 MachineCheckException : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_BIT  7
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_FLAG 0x80
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_EXCEPTION(_)   (((_) >> 7) & 0x01)

                        /**
                         * @brief CMPXCHG8B Instruction
                         *
                         * [Bit 8] The compare-and-exchange 8 bytes (64 bits) instruction is
                         * supported (implicitly locked and atomic).
                         */
                        UINT32 Cmpxchg8B : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_BIT  8
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_FLAG 0x100
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CMPXCHG8B(_)   (((_) >> 8) & 0x01)

                        /**
                         * @brief APIC On-Chip
                         *
                         * [Bit 9] The processor contains an Advanced Programmable Interrupt
                         * Controller (APIC), responding to memory mapped commands in the physical
                         * address range FFFE0000H to FFFE0FFFH (by default - some processors permit
                         * the APIC to be relocated).
                         */
                        UINT32 ApicOnChip : 1;
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_BIT  9
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_FLAG 0x200
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_APIC_ON_CHIP(_)   (((_) >> 9) & 0x01)
                        UINT32 Reserved1 : 1;

                        /**
                         * @brief SYSENTER and SYSEXIT Instructions
                         *
                         * [Bit 11] The SYSENTER and SYSEXIT and associated MSRs are supported.
                         */
                        UINT32 SysenterSysexitInstructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_BIT  11
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_FLAG 0x800
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SYSENTER_SYSEXIT_INSTRUCTIONS(_)   (((_) >> 11) & 0x01)

                        /**
                         * @brief Memory Type Range Registers
                         *
                         * [Bit 12] MTRRs are supported. The MTRRcap MSR contains feature bits that
                         * describe what memory types are supported, how many variable MTRRs are
                         * supported, and whether fixed MTRRs are supported.
                         */
                        UINT32 MemoryTypeRangeRegisters : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_BIT  12
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_FLAG 0x1000
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MEMORY_TYPE_RANGE_REGISTERS(_)   (((_) >> 12) & 0x01)

                        /**
                         * @brief Page Global Bit
                         *
                         * [Bit 13] The global bit is supported in paging-structure entries that map
                         * a page, indicating TLB entries that are common to different processes and
                         * need not be flushed. The CR4.PGE bit controls this feature.
                         */
                        UINT32 PageGlobalBit : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_BIT  13
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_FLAG 0x2000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_GLOBAL_BIT(_)   (((_) >> 13) & 0x01)

                        /**
                         * @brief Machine Check Architecture
                         *
                         * [Bit 14] A value of 1 indicates the Machine Check Architecture of
                         * reporting machine errors is supported. The MCG_CAP MSR contains feature
                         * bits describing how many banks of error reporting MSRs are supported.
                         */
                        UINT32 MachineCheckArchitecture : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_BIT  14
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_FLAG 0x4000
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MACHINE_CHECK_ARCHITECTURE(_)   (((_) >> 14) & 0x01)

                        /**
                         * @brief Conditional Move Instructions
                         *
                         * [Bit 15] The conditional move instruction CMOV is supported. In addition,
                         * if x87 FPU is present as indicated by the CPUID.FPU feature bit, then the
                         * FCOMI and FCMOV instructions are supported
                         */
                        UINT32 ConditionalMoveInstructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_BIT  15
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_FLAG 0x8000
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CONDITIONAL_MOVE_INSTRUCTIONS(_)   (((_) >> 15) & 0x01)

                        /**
                         * @brief Page Attribute Table
                         *
                         * [Bit 16] Page Attribute Table is supported. This feature augments the
                         * Memory Type Range Registers (MTRRs), allowing an operating system to
                         * specify attributes of memory accessed through a linear address on a 4KB
                         * granularity.
                         */
                        UINT32 PageAttributeTable : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_BIT  16
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_FLAG 0x10000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_ATTRIBUTE_TABLE(_)   (((_) >> 16) & 0x01)

                        /**
                         * @brief 36-Bit Page Size Extension
                         *
                         * [Bit 17] 4-MByte pages addressing physical memory beyond 4 GBytes are
                         * supported with 32-bit paging. This feature indicates that upper bits of
                         * the physical address of a 4-MByte page are encoded in bits 20:13 of the
                         * page-directory entry. Such physical addresses are limited by MAXPHYADDR
                         * and may be up to 40 bits in size.
                         */
                        UINT32 PageSizeExtension36Bit : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_BIT  17
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_FLAG 0x20000
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PAGE_SIZE_EXTENSION_36BIT(_)   (((_) >> 17) & 0x01)

                        /**
                         * @brief Processor Serial Number
                         *
                         * [Bit 18] The processor supports the 96-bit processor identification
                         * number feature and the feature is enabled.
                         */
                        UINT32 ProcessorSerialNumber : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_BIT  18
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_FLAG 0x40000
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PROCESSOR_SERIAL_NUMBER(_)   (((_) >> 18) & 0x01)

                        /**
                         * @brief CLFLUSH Instruction
                         *
                         * [Bit 19] CLFLUSH Instruction is supported.
                         */
                        UINT32 Clflush : 1;
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_BIT  19
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_FLAG 0x80000
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_CLFLUSH(_)   (((_) >> 19) & 0x01)
                        UINT32 Reserved2 : 1;

                        /**
                         * @brief Debug Store
                         *
                         * [Bit 21] The processor supports the ability to write debug information
                         * into a memory resident buffer. This feature is used by the branch trace
                         * store (BTS) and processor event-based sampling (PEBS) facilities.
                         *
                         * @see Vol3C[23(INTRODUCTION TO VIRTUAL MACHINE EXTENSIONS)]
                         */
                        UINT32 DebugStore : 1;
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_BIT  21
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_FLAG 0x200000
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_DEBUG_STORE(_)   (((_) >> 21) & 0x01)

                        /**
                         * @brief Thermal Monitor and Software Controlled Clock Facilities
                         *
                         * [Bit 22] The processor implements internal MSRs that allow processor
                         * temperature to be monitored and processor performance to be modulated in
                         * predefined duty cycles under software control.
                         */
                        UINT32 ThermalControlMsrsForAcpi : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_BIT  22
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_FLAG 0x400000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_CONTROL_MSRS_FOR_ACPI(_)   (((_) >> 22) & 0x01)

                        /**
                         * @brief Intel MMX Technology
                         *
                         * [Bit 23] The processor supports the Intel MMX technology.
                         */
                        UINT32 MmxSupport : 1;
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_BIT  23
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_FLAG 0x800000
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_MMX_SUPPORT(_)   (((_) >> 23) & 0x01)

                        /**
                         * @brief FXSAVE and FXRSTOR Instructions
                         *
                         * [Bit 24] The FXSAVE and FXRSTOR instructions are supported for fast save
                         * and restore of the floating point context. Presence of this bit also
                         * indicates that CR4.OSFXSR is available for an operating system to
                         * indicate that it supports the FXSAVE and FXRSTOR instructions.
                         */
                        UINT32 FxsaveFxrstorInstructions : 1;
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_BIT  24
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_FLAG 0x1000000
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_FXSAVE_FXRSTOR_INSTRUCTIONS(_)   (((_) >> 24) & 0x01)

                        /**
                         * @brief SSE extensions support
                         *
                         * [Bit 25] The processor supports the SSE extensions.
                         */
                        UINT32 SseSupport : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_BIT  25
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_FLAG 0x2000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE_SUPPORT(_)   (((_) >> 25) & 0x01)

                        /**
                         * @brief SSE2 extensions support
                         *
                         * [Bit 26] The processor supports the SSE2 extensions.
                         */
                        UINT32 Sse2Support : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_BIT  26
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_FLAG 0x4000000
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SSE2_SUPPORT(_)   (((_) >> 26) & 0x01)

                        /**
                         * @brief Self Snoop
                         *
                         * [Bit 27] The processor supports the management of conflicting memory
                         * types by performing a snoop of its own cache structure for transactions
                         * issued to the bus.
                         */
                        UINT32 SelfSnoop : 1;
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_BIT  27
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_FLAG 0x8000000
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_SELF_SNOOP(_)   (((_) >> 27) & 0x01)

                        /**
                         * @brief Max APIC IDs reserved field is Valid
                         *
                         * [Bit 28] A value of 0 for HTT indicates there is only a single logical
                         * processor in the package and software should assume only a single APIC ID
                         * is reserved. A value of 1 for HTT indicates the value in
                         * CPUID.1.EBX[23:16] (the Maximum number of addressable IDs for logical
                         * processors in this package) is valid for the package.
                         */
                        UINT32 HyperThreadingTechnology : 1;
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_BIT  28
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_FLAG 0x10000000
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_HYPER_THREADING_TECHNOLOGY(_)   (((_) >> 28) & 0x01)

                        /**
                         * @brief Thermal Monitor
                         *
                         * [Bit 29] The processor implements the thermal monitor automatic thermal
                         * control circuitry (TCC).
                         */
                        UINT32 ThermalMonitor : 1;
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_BIT  29
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_FLAG 0x20000000
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_THERMAL_MONITOR(_)   (((_) >> 29) & 0x01)
                        UINT32 Reserved3 : 1;

                        /**
                         * @brief Pending Break Enable
                         *
                         * [Bit 31] The processor supports the use of the FERR\#/PBE\# pin when the
                         * processor is in the stop-clock state (STPCLK\# is asserted) to signal the
                         * processor that an interrupt is pending and that the processor should
                         * return to normal operation to handle the interrupt. Bit 10 (PBE enable)
                         * in the IA32_MISC_ENABLE MSR enables this capability.
                         */
                        UINT32 PendingBreakEnable : 1;
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_BIT  31
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_FLAG 0x80000000
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE_MASK 0x01
#define CPUID_FEATURE_INFORMATION_EDX_PENDING_BREAK_ENABLE(_)   (((_) >> 31) & 0x01)
                };

                UINT32 AsUInt;
        } CpuidFeatureInformationEdx;

} CPUID_EAX_01;

/**
 * @brief Deterministic Cache Parameters Leaf
 *
 * When CPUID executes with EAX set to 04H and ECX contains an index value, the processor returns
 * encoded data that describe a set of deterministic cache parameters (for the cache level
 * associated with the input in ECX). Valid index values start from 0. Software can enumerate the
 * deterministic cache parameters for each level of the cache hierarchy starting with an index value
 * of 0, until the parameters report the value associated with the cache type field is 0. The
 * architecturally defined fields reported by deterministic cache parameters are documented in Table
 * 3-8. This Cache Size in Bytes
 * - = (Ways + 1) * (Partitions + 1) * (Line_Size + 1) * (Sets + 1)
 * - = (EBX[31:22] + 1) * (EBX[21:12] + 1) * (EBX[11:0] + 1) * (ECX + 1)
 * The CPUID leaf 04H also reports data that can be used to derive the topology of processor cores
 * in a physical package. This information is constant for all valid index values. Software can
 * query the raw data reported by executing CPUID with EAX=04H and ECX=0 and use it as part of the
 * topology enumeration algorithm.
 *
 * @see Vol3A[8(Multiple-Processor Management)]
 */
#define CPUID_CACHE_PARAMETERS 0x00000004
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 4:0] - 0 = Null - No more caches.
                         * - 1 = Data Cache.
                         * - 2 = Instruction Cache.
                         * - 3 = Unified Cache.
                         * - 4-31 = Reserved.
                         */
                        UINT32 CacheTypeField : 5;
#define CPUID_EAX_CACHE_TYPE_FIELD_BIT  0
#define CPUID_EAX_CACHE_TYPE_FIELD_FLAG 0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD_MASK 0x1F
#define CPUID_EAX_CACHE_TYPE_FIELD(_)   (((_) >> 0) & 0x1F)

                        /**
                         * [Bits 7:5] Cache Level (starts at 1).
                         */
                        UINT32 CacheLevel : 3;
#define CPUID_EAX_CACHE_LEVEL_BIT  5
#define CPUID_EAX_CACHE_LEVEL_FLAG 0xE0
#define CPUID_EAX_CACHE_LEVEL_MASK 0x07
#define CPUID_EAX_CACHE_LEVEL(_)   (((_) >> 5) & 0x07)

                        /**
                         * [Bit 8] Self Initializing cache level (does not need SW initialization).
                         */
                        UINT32 SelfInitializingCacheLevel : 1;
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_BIT  8
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_FLAG 0x100
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL_MASK 0x01
#define CPUID_EAX_SELF_INITIALIZING_CACHE_LEVEL(_)   (((_) >> 8) & 0x01)

                        /**
                         * [Bit 9] Fully Associative cache.
                         */
                        UINT32 FullyAssociativeCache : 1;
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_BIT  9
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_FLAG 0x200
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE_MASK 0x01
#define CPUID_EAX_FULLY_ASSOCIATIVE_CACHE(_)   (((_) >> 9) & 0x01)
                        UINT32 Reserved1 : 4;

                        /**
                         * [Bits 25:14] Maximum number of addressable IDs for logical processors
                         * sharing this cache.
                         *
                         * @note Add one to the return value to get the result.
                         *       The nearest power-of-2 integer that is not smaller than (1 +
                         * EAX[25:14]) is the number of unique initial APIC IDs reserved for
                         * addressing different logical processors sharing this cache.
                         */
                        UINT32 MaxAddressableIdsForLogicalProcessorsSharingThisCache : 12;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_BIT  14
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_FLAG 0x3FFC000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE_MASK 0xFFF
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_SHARING_THIS_CACHE(_) \
        (((_) >> 14) & 0xFFF)

                        /**
                         * [Bits 31:26] Maximum number of addressable IDs for processor cores in the
                         * physical package.
                         *
                         * @note Add one to the return value to get the result.
                         *       The nearest power-of-2 integer that is not smaller than (1 +
                         * EAX[31:26]) is the number of unique Core_IDs reserved for addressing
                         * different processor cores in a physical package. Core ID is a subset of
                         * bits of the initial APIC ID. The returned value is constant for valid
                         * initial values in ECX. Valid ECX values start from 0.
                         */
                        UINT32 MaxAddressableIdsForProcessorCoresInPhysicalPackage : 6;
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_BIT  26
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_FLAG 0xFC000000
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE_MASK 0x3F
#define CPUID_EAX_MAX_ADDRESSABLE_IDS_FOR_PROCESSOR_CORES_IN_PHYSICAL_PACKAGE(_) \
        (((_) >> 26) & 0x3F)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 11:0] System Coherency Line Size.
                         *
                         * @note Add one to the return value to get the result.
                         */
                        UINT32 SystemCoherencyLineSize : 12;
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_BIT  0
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_FLAG 0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE_MASK 0xFFF
#define CPUID_EBX_SYSTEM_COHERENCY_LINE_SIZE(_)   (((_) >> 0) & 0xFFF)

                        /**
                         * [Bits 21:12] Physical Line partitions.
                         *
                         * @note Add one to the return value to get the result.
                         */
                        UINT32 PhysicalLinePartitions : 10;
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_BIT  12
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_FLAG 0x3FF000
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS_MASK 0x3FF
#define CPUID_EBX_PHYSICAL_LINE_PARTITIONS(_)   (((_) >> 12) & 0x3FF)

                        /**
                         * [Bits 31:22] Ways of associativity.
                         *
                         * @note Add one to the return value to get the result.
                         */
                        UINT32 WaysOfAssociativity : 10;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_BIT  22
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_FLAG 0xFFC00000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_MASK 0x3FF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY(_)   (((_) >> 22) & 0x3FF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Number of Sets.
                         *
                         * @note Add one to the return value to get the result.
                         */
                        UINT32 NumberOfSets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT  0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG 0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK 0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * @brief Write-Back Invalidate/Invalidate
                         *
                         * [Bit 0] - 0 = WBINVD/INVD from threads sharing this cache acts upon lower
                         * level caches for threads sharing this cache.
                         * - 1 = WBINVD/INVD is not guaranteed to act upon lower level caches of
                         * non-originating threads sharing this cache.
                         */
                        UINT32 WriteBackInvalidate : 1;
#define CPUID_EDX_WRITE_BACK_INVALIDATE_BIT  0
#define CPUID_EDX_WRITE_BACK_INVALIDATE_FLAG 0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE_MASK 0x01
#define CPUID_EDX_WRITE_BACK_INVALIDATE(_)   (((_) >> 0) & 0x01)

                        /**
                         * @brief Cache Inclusiveness
                         *
                         * [Bit 1] - 0 = Cache is not inclusive of lower cache levels.
                         * - 1 = Cache is inclusive of lower cache levels.
                         */
                        UINT32 CacheInclusiveness : 1;
#define CPUID_EDX_CACHE_INCLUSIVENESS_BIT  1
#define CPUID_EDX_CACHE_INCLUSIVENESS_FLAG 0x02
#define CPUID_EDX_CACHE_INCLUSIVENESS_MASK 0x01
#define CPUID_EDX_CACHE_INCLUSIVENESS(_)   (((_) >> 1) & 0x01)

                        /**
                         * @brief Complex Cache Indexing
                         *
                         * [Bit 2] - 0 = Direct mapped cache.
                         * - 1 = A complex function is used to index the cache, potentially using
                         * all address bits.
                         */
                        UINT32 ComplexCacheIndexing : 1;
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_BIT  2
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_FLAG 0x04
#define CPUID_EDX_COMPLEX_CACHE_INDEXING_MASK 0x01
#define CPUID_EDX_COMPLEX_CACHE_INDEXING(_)   (((_) >> 2) & 0x01)
                        UINT32 Reserved1 : 29;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_04;

/**
 * @brief MONITOR/MWAIT Leaf
 *
 * When CPUID executes with EAX set to 05H, the processor returns information about features
 * available to MONITOR/MWAIT instructions. The MONITOR instruction is used for address-range
 * monitoring in conjunction with MWAIT instruction. The MWAIT instruction optionally provides
 * additional extensions for advanced power management.
 */
#define CPUID_MONITOR_MWAIT 0x00000005
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 15:0] Smallest monitor-line size in bytes (default is processor's
                         * monitor granularity).
                         */
                        UINT32 SmallestMonitorLineSize : 16;
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_BIT  0
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_FLAG 0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE_MASK 0xFFFF
#define CPUID_EAX_SMALLEST_MONITOR_LINE_SIZE(_)   (((_) >> 0) & 0xFFFF)
                        UINT32 Reserved1 : 16;
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 15:0] Largest monitor-line size in bytes (default is processor's
                         * monitor granularity).
                         */
                        UINT32 LargestMonitorLineSize : 16;
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_BIT  0
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_FLAG 0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE_MASK 0xFFFF
#define CPUID_EBX_LARGEST_MONITOR_LINE_SIZE(_)   (((_) >> 0) & 0xFFFF)
                        UINT32 Reserved1 : 16;
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bit 0] Enumeration of Monitor-Mwait extensions (beyond EAX and EBX
                         * registers) supported.
                         */
                        UINT32 EnumerationOfMonitorMwaitExtensions : 1;
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_BIT  0
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_FLAG 0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS_MASK 0x01
#define CPUID_ECX_ENUMERATION_OF_MONITOR_MWAIT_EXTENSIONS(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] Supports treating interrupts as break-event for MWAIT, even when
                         * interrupts disabled.
                         */
                        UINT32 SupportsTreatingInterruptsAsBreakEventForMwait : 1;
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_BIT  1
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_FLAG 0x02
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT_MASK 0x01
#define CPUID_ECX_SUPPORTS_TREATING_INTERRUPTS_AS_BREAK_EVENT_FOR_MWAIT(_)   (((_) >> 1) & 0x01)
                        UINT32 Reserved1 : 30;
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 3:0] Number of C0 sub C-states supported using MWAIT.
                         */
                        UINT32 NumberOfC0SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_BIT  0
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_FLAG 0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C0_SUB_C_STATES(_)   (((_) >> 0) & 0x0F)

                        /**
                         * [Bits 7:4] Number of C1 sub C-states supported using MWAIT.
                         */
                        UINT32 NumberOfC1SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_BIT  4
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_FLAG 0xF0
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C1_SUB_C_STATES(_)   (((_) >> 4) & 0x0F)

                        /**
                         * [Bits 11:8] Number of C2 sub C-states supported using MWAIT.
                         */
                        UINT32 NumberOfC2SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_BIT  8
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_FLAG 0xF00
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C2_SUB_C_STATES(_)   (((_) >> 8) & 0x0F)

                        /**
                         * [Bits 15:12] Number of C3 sub C-states supported using MWAIT.
                         */
                        UINT32 NumberOfC3SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_BIT  12
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_FLAG 0xF000
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C3_SUB_C_STATES(_)   (((_) >> 12) & 0x0F)

                        /**
                         * [Bits 19:16] Number of C4 sub C-states supported using MWAIT.
                         */
                        UINT32 NumberOfC4SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_BIT  16
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_FLAG 0xF0000
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C4_SUB_C_STATES(_)   (((_) >> 16) & 0x0F)

                        /**
                         * [Bits 23:20] Number of C5 sub C-states supported using MWAIT.
                         */
                        UINT32 NumberOfC5SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_BIT  20
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_FLAG 0xF00000
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C5_SUB_C_STATES(_)   (((_) >> 20) & 0x0F)

                        /**
                         * [Bits 27:24] Number of C6 sub C-states supported using MWAIT.
                         */
                        UINT32 NumberOfC6SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_BIT  24
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_FLAG 0xF000000
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C6_SUB_C_STATES(_)   (((_) >> 24) & 0x0F)

                        /**
                         * [Bits 31:28] Number of C7 sub C-states supported using MWAIT.
                         */
                        UINT32 NumberOfC7SubCStates : 4;
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_BIT  28
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_FLAG 0xF0000000
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES_MASK 0x0F
#define CPUID_EDX_NUMBER_OF_C7_SUB_C_STATES(_)   (((_) >> 28) & 0x0F)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_05;

/**
 * @brief Thermal and Power Management Leaf
 *
 * When CPUID executes with EAX set to 06H, the processor returns information about thermal and
 * power management features.
 */
#define CPUID_THERMAL_AND_POWER_MANAGEMENT 0x00000006
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bit 0] Digital temperature sensor is supported if set.
                         */
                        UINT32 TemperatureSensorSupported : 1;
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_BIT  0
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_FLAG 0x01
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED_MASK 0x01
#define CPUID_EAX_TEMPERATURE_SENSOR_SUPPORTED(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] Intel Turbo Boost Technology available (see description of
                         * IA32_MISC_ENABLE[38]).
                         */
                        UINT32 IntelTurboBoostTechnologyAvailable : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_BIT  1
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_FLAG 0x02
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE_MASK 0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_TECHNOLOGY_AVAILABLE(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bit 2] ARAT. APIC-Timer-always-running feature is supported if set.
                         */
                        UINT32 ApicTimerAlwaysRunning : 1;
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_BIT  2
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_FLAG 0x04
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING_MASK 0x01
#define CPUID_EAX_APIC_TIMER_ALWAYS_RUNNING(_)   (((_) >> 2) & 0x01)
                        UINT32 Reserved1 : 1;

                        /**
                         * [Bit 4] PLN. Power limit notification controls are supported if set.
                         */
                        UINT32 PowerLimitNotification : 1;
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_BIT  4
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_FLAG 0x10
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION_MASK 0x01
#define CPUID_EAX_POWER_LIMIT_NOTIFICATION(_)   (((_) >> 4) & 0x01)

                        /**
                         * [Bit 5] ECMD. Clock modulation duty cycle extension is supported if set.
                         */
                        UINT32 ClockModulationDuty : 1;
#define CPUID_EAX_CLOCK_MODULATION_DUTY_BIT  5
#define CPUID_EAX_CLOCK_MODULATION_DUTY_FLAG 0x20
#define CPUID_EAX_CLOCK_MODULATION_DUTY_MASK 0x01
#define CPUID_EAX_CLOCK_MODULATION_DUTY(_)   (((_) >> 5) & 0x01)

                        /**
                         * [Bit 6] PTM. Package thermal management is supported if set.
                         */
                        UINT32 PackageThermalManagement : 1;
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_BIT  6
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_FLAG 0x40
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT_MASK 0x01
#define CPUID_EAX_PACKAGE_THERMAL_MANAGEMENT(_)   (((_) >> 6) & 0x01)

                        /**
                         * [Bit 7] HWP. HWP base registers (IA32_PM_ENABLE[bit 0],
                         * IA32_HWP_CAPABILITIES, IA32_HWP_REQUEST, IA32_HWP_STATUS) are supported
                         * if set.
                         */
                        UINT32 HwpBaseRegisters : 1;
#define CPUID_EAX_HWP_BASE_REGISTERS_BIT  7
#define CPUID_EAX_HWP_BASE_REGISTERS_FLAG 0x80
#define CPUID_EAX_HWP_BASE_REGISTERS_MASK 0x01
#define CPUID_EAX_HWP_BASE_REGISTERS(_)   (((_) >> 7) & 0x01)

                        /**
                         * [Bit 8] HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set.
                         */
                        UINT32 HwpNotification : 1;
#define CPUID_EAX_HWP_NOTIFICATION_BIT  8
#define CPUID_EAX_HWP_NOTIFICATION_FLAG 0x100
#define CPUID_EAX_HWP_NOTIFICATION_MASK 0x01
#define CPUID_EAX_HWP_NOTIFICATION(_)   (((_) >> 8) & 0x01)

                        /**
                         * [Bit 9] HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if
                         * set.
                         */
                        UINT32 HwpActivityWindow : 1;
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_BIT  9
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_FLAG 0x200
#define CPUID_EAX_HWP_ACTIVITY_WINDOW_MASK 0x01
#define CPUID_EAX_HWP_ACTIVITY_WINDOW(_)   (((_) >> 9) & 0x01)

                        /**
                         * [Bit 10] HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24]
                         * is supported if set.
                         */
                        UINT32 HwpEnergyPerformancePreference : 1;
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_BIT  10
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_FLAG 0x400
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE_MASK 0x01
#define CPUID_EAX_HWP_ENERGY_PERFORMANCE_PREFERENCE(_)   (((_) >> 10) & 0x01)

                        /**
                         * [Bit 11] HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported
                         * if set.
                         */
                        UINT32 HwpPackageLevelRequest : 1;
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_BIT  11
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_FLAG 0x800
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST_MASK 0x01
#define CPUID_EAX_HWP_PACKAGE_LEVEL_REQUEST(_)   (((_) >> 11) & 0x01)
                        UINT32 Reserved2 : 1;

                        /**
                         * [Bit 13] HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1,
                         * IA32_THREAD_STALL MSRs are supported if set.
                         */
                        UINT32 Hdc : 1;
#define CPUID_EAX_HDC_BIT  13
#define CPUID_EAX_HDC_FLAG 0x2000
#define CPUID_EAX_HDC_MASK 0x01
#define CPUID_EAX_HDC(_)   (((_) >> 13) & 0x01)

                        /**
                         * [Bit 14] Intel(R) Turbo Boost Max Technology 3.0 available.
                         */
                        UINT32 IntelTurboBoostMaxTechnology3Available : 1;
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_BIT  14
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_FLAG 0x4000
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE_MASK 0x01
#define CPUID_EAX_INTEL_TURBO_BOOST_MAX_TECHNOLOGY_3_AVAILABLE(_)   (((_) >> 14) & 0x01)

                        /**
                         * [Bit 15] HWP Capabilities. Highest Performance change is supported if
                         * set.
                         */
                        UINT32 HwpCapabilities : 1;
#define CPUID_EAX_HWP_CAPABILITIES_BIT  15
#define CPUID_EAX_HWP_CAPABILITIES_FLAG 0x8000
#define CPUID_EAX_HWP_CAPABILITIES_MASK 0x01
#define CPUID_EAX_HWP_CAPABILITIES(_)   (((_) >> 15) & 0x01)

                        /**
                         * [Bit 16] HWP PECI override is supported if set.
                         */
                        UINT32 HwpPeciOverride : 1;
#define CPUID_EAX_HWP_PECI_OVERRIDE_BIT  16
#define CPUID_EAX_HWP_PECI_OVERRIDE_FLAG 0x10000
#define CPUID_EAX_HWP_PECI_OVERRIDE_MASK 0x01
#define CPUID_EAX_HWP_PECI_OVERRIDE(_)   (((_) >> 16) & 0x01)

                        /**
                         * [Bit 17] Flexible HWP is supported if set.
                         */
                        UINT32 FlexibleHwp : 1;
#define CPUID_EAX_FLEXIBLE_HWP_BIT  17
#define CPUID_EAX_FLEXIBLE_HWP_FLAG 0x20000
#define CPUID_EAX_FLEXIBLE_HWP_MASK 0x01
#define CPUID_EAX_FLEXIBLE_HWP(_)   (((_) >> 17) & 0x01)

                        /**
                         * [Bit 18] Fast access mode for the IA32_HWP_REQUEST MSR is supported if
                         * set.
                         */
                        UINT32 FastAccessModeForHwpRequestMsr : 1;
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_BIT  18
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_FLAG 0x40000
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR_MASK 0x01
#define CPUID_EAX_FAST_ACCESS_MODE_FOR_HWP_REQUEST_MSR(_)   (((_) >> 18) & 0x01)
                        UINT32 Reserved3 : 1;

                        /**
                         * [Bit 20] Ignoring Idle Logical Processor HWP request is supported if set.
                         */
                        UINT32 IgnoringIdleLogicalProcessorHwpRequest : 1;
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_BIT  20
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_FLAG 0x100000
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST_MASK 0x01
#define CPUID_EAX_IGNORING_IDLE_LOGICAL_PROCESSOR_HWP_REQUEST(_)   (((_) >> 20) & 0x01)
                        UINT32 Reserved4 : 2;

                        /**
                         * [Bit 23] Intel Thread Director supported if set. IA32_HW_FEEDBACK_CHAR
                         * and IA32_HW_FEEDBACK_THREAD_CONFIG MSRs are supported if set.
                         */
                        UINT32 IntelThreadDirector : 1;
#define CPUID_EAX_INTEL_THREAD_DIRECTOR_BIT  23
#define CPUID_EAX_INTEL_THREAD_DIRECTOR_FLAG 0x800000
#define CPUID_EAX_INTEL_THREAD_DIRECTOR_MASK 0x01
#define CPUID_EAX_INTEL_THREAD_DIRECTOR(_)   (((_) >> 23) & 0x01)
                        UINT32 Reserved5 : 8;
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 3:0] Number of Interrupt Thresholds in Digital Thermal Sensor.
                         */
                        UINT32 NumberOfInterruptThresholdsInThermalSensor : 4;
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_BIT  0
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_FLAG 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR_MASK 0x0F
#define CPUID_EBX_NUMBER_OF_INTERRUPT_THRESHOLDS_IN_THERMAL_SENSOR(_)   (((_) >> 0) & 0x0F)
                        UINT32 Reserved1 : 28;
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bit 0] Hardware Coordination Feedback Capability (Presence of IA32_MPERF
                         * and IA32_APERF). The capability to provide a measure of delivered
                         * processor performance (since last reset of the counters), as a percentage
                         * of the expected processor performance when running at the TSC frequency.
                         */
                        UINT32 HardwareCoordinationFeedbackCapability : 1;
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_BIT  0
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_FLAG 0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY_MASK 0x01
#define CPUID_ECX_HARDWARE_COORDINATION_FEEDBACK_CAPABILITY(_)   (((_) >> 0) & 0x01)
                        UINT32 Reserved1 : 2;

                        /**
                         * [Bit 3] Number of Intel Thread Director classes supported by the
                         * processor. Information for that many classes is written into the Intel
                         * Thread Director Table by the hardware.
                         */
                        UINT32 NumberOfIntelThreadDirectorClasses : 1;
#define CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES_BIT  3
#define CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES_FLAG 0x08
#define CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES_MASK 0x01
#define CPUID_ECX_NUMBER_OF_INTEL_THREAD_DIRECTOR_CLASSES(_)   (((_) >> 3) & 0x01)
                        UINT32 Reserved2 : 4;

                        /**
                         * [Bits 15:8] The processor supports performance-energy bias preference if
                         * CPUID.06H:ECX.SETBH[bit 3] is set and it also implies the presence of a
                         * new architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H).
                         */
                        UINT32 PerformanceEnergyBiasPreference : 8;
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_BIT  8
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_FLAG 0xFF00
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE_MASK 0xFF
#define CPUID_ECX_PERFORMANCE_ENERGY_BIAS_PREFERENCE(_)   (((_) >> 8) & 0xFF)
                        UINT32 Reserved3 : 16;
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EDX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_06;

/**
 * @brief Structured Extended Feature Flags Enumeration Leaf (Output depends on ECX input value)
 *
 * When CPUID executes with EAX set to 07H and ECX = 0, the processor returns information about the
 * maximum input value for sub-leaves that contain extended feature flags. When CPUID executes with
 * EAX set to 07H and the input value of ECX is invalid (see leaf 07H entry in Table 3-8), the
 * processor returns 0 in EAX/EBX/ECX/EDX. In subleaf 0, EAX returns the maximum input value of the
 * highest leaf 7 sub-leaf, and EBX, ECX & EDX contain information of extended feature flags.
 */
#define CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS 0x00000007
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reports the maximum input value for supported leaf 7
                         * sub-leaves.
                         */
                        UINT32 NumberOfSubLeaves : 32;
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_BIT  0
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_FLAG 0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES_MASK 0xFFFFFFFF
#define CPUID_EAX_NUMBER_OF_SUB_LEAVES(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bit 0] Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1.
                         */
                        UINT32 Fsgsbase : 1;
#define CPUID_EBX_FSGSBASE_BIT  0
#define CPUID_EBX_FSGSBASE_FLAG 0x01
#define CPUID_EBX_FSGSBASE_MASK 0x01
#define CPUID_EBX_FSGSBASE(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] IA32_TSC_ADJUST MSR is supported if 1.
                         */
                        UINT32 Ia32TscAdjustMsr : 1;
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_BIT  1
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_FLAG 0x02
#define CPUID_EBX_IA32_TSC_ADJUST_MSR_MASK 0x01
#define CPUID_EBX_IA32_TSC_ADJUST_MSR(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bit 2] Supports Intel(R) Software Guard Extensions (Intel(R) SGX
                         * Extensions) if 1.
                         */
                        UINT32 Sgx : 1;
#define CPUID_EBX_SGX_BIT  2
#define CPUID_EBX_SGX_FLAG 0x04
#define CPUID_EBX_SGX_MASK 0x01
#define CPUID_EBX_SGX(_)   (((_) >> 2) & 0x01)

                        /**
                         * [Bit 3] BMI1.
                         */
                        UINT32 Bmi1 : 1;
#define CPUID_EBX_BMI1_BIT  3
#define CPUID_EBX_BMI1_FLAG 0x08
#define CPUID_EBX_BMI1_MASK 0x01
#define CPUID_EBX_BMI1(_)   (((_) >> 3) & 0x01)

                        /**
                         * [Bit 4] HLE.
                         */
                        UINT32 Hle : 1;
#define CPUID_EBX_HLE_BIT  4
#define CPUID_EBX_HLE_FLAG 0x10
#define CPUID_EBX_HLE_MASK 0x01
#define CPUID_EBX_HLE(_)   (((_) >> 4) & 0x01)

                        /**
                         * [Bit 5] AVX2.
                         */
                        UINT32 Avx2 : 1;
#define CPUID_EBX_AVX2_BIT  5
#define CPUID_EBX_AVX2_FLAG 0x20
#define CPUID_EBX_AVX2_MASK 0x01
#define CPUID_EBX_AVX2(_)   (((_) >> 5) & 0x01)

                        /**
                         * [Bit 6] x87 FPU Data Pointer updated only on x87 exceptions if 1.
                         */
                        UINT32 FdpExcptnOnly : 1;
#define CPUID_EBX_FDP_EXCPTN_ONLY_BIT  6
#define CPUID_EBX_FDP_EXCPTN_ONLY_FLAG 0x40
#define CPUID_EBX_FDP_EXCPTN_ONLY_MASK 0x01
#define CPUID_EBX_FDP_EXCPTN_ONLY(_)   (((_) >> 6) & 0x01)

                        /**
                         * [Bit 7] Supports Supervisor-Mode Execution Prevention if 1.
                         */
                        UINT32 Smep : 1;
#define CPUID_EBX_SMEP_BIT  7
#define CPUID_EBX_SMEP_FLAG 0x80
#define CPUID_EBX_SMEP_MASK 0x01
#define CPUID_EBX_SMEP(_)   (((_) >> 7) & 0x01)

                        /**
                         * [Bit 8] BMI2.
                         */
                        UINT32 Bmi2 : 1;
#define CPUID_EBX_BMI2_BIT  8
#define CPUID_EBX_BMI2_FLAG 0x100
#define CPUID_EBX_BMI2_MASK 0x01
#define CPUID_EBX_BMI2(_)   (((_) >> 8) & 0x01)

                        /**
                         * [Bit 9] Supports Enhanced REP MOVSB/STOSB if 1.
                         */
                        UINT32 EnhancedRepMovsbStosb : 1;
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_BIT  9
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_FLAG 0x200
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB_MASK 0x01
#define CPUID_EBX_ENHANCED_REP_MOVSB_STOSB(_)   (((_) >> 9) & 0x01)

                        /**
                         * [Bit 10] If 1, supports INVPCID instruction for system software that
                         * manages process-context identifiers.
                         */
                        UINT32 Invpcid : 1;
#define CPUID_EBX_INVPCID_BIT  10
#define CPUID_EBX_INVPCID_FLAG 0x400
#define CPUID_EBX_INVPCID_MASK 0x01
#define CPUID_EBX_INVPCID(_)   (((_) >> 10) & 0x01)

                        /**
                         * [Bit 11] RTM.
                         */
                        UINT32 Rtm : 1;
#define CPUID_EBX_RTM_BIT  11
#define CPUID_EBX_RTM_FLAG 0x800
#define CPUID_EBX_RTM_MASK 0x01
#define CPUID_EBX_RTM(_)   (((_) >> 11) & 0x01)

                        /**
                         * [Bit 12] Supports Intel(R) Resource Director Technology (Intel(R) RDT)
                         * Monitoring capability if 1.
                         */
                        UINT32 RdtM : 1;
#define CPUID_EBX_RDT_M_BIT  12
#define CPUID_EBX_RDT_M_FLAG 0x1000
#define CPUID_EBX_RDT_M_MASK 0x01
#define CPUID_EBX_RDT_M(_)   (((_) >> 12) & 0x01)

                        /**
                         * [Bit 13] Deprecates FPU CS and FPU DS values if 1.
                         */
                        UINT32 Deprecates : 1;
#define CPUID_EBX_DEPRECATES_BIT  13
#define CPUID_EBX_DEPRECATES_FLAG 0x2000
#define CPUID_EBX_DEPRECATES_MASK 0x01
#define CPUID_EBX_DEPRECATES(_)   (((_) >> 13) & 0x01)

                        /**
                         * [Bit 14] Supports Intel(R) Memory Protection Extensions if 1.
                         */
                        UINT32 Mpx : 1;
#define CPUID_EBX_MPX_BIT  14
#define CPUID_EBX_MPX_FLAG 0x4000
#define CPUID_EBX_MPX_MASK 0x01
#define CPUID_EBX_MPX(_)   (((_) >> 14) & 0x01)

                        /**
                         * [Bit 15] Supports Intel(R) Resource Director Technology (Intel(R) RDT)
                         * Allocation capability if 1.
                         */
                        UINT32 Rdt : 1;
#define CPUID_EBX_RDT_BIT  15
#define CPUID_EBX_RDT_FLAG 0x8000
#define CPUID_EBX_RDT_MASK 0x01
#define CPUID_EBX_RDT(_)   (((_) >> 15) & 0x01)

                        /**
                         * [Bit 16] AVX512F.
                         */
                        UINT32 Avx512F : 1;
#define CPUID_EBX_AVX512F_BIT  16
#define CPUID_EBX_AVX512F_FLAG 0x10000
#define CPUID_EBX_AVX512F_MASK 0x01
#define CPUID_EBX_AVX512F(_)   (((_) >> 16) & 0x01)

                        /**
                         * [Bit 17] AVX512DQ.
                         */
                        UINT32 Avx512Dq : 1;
#define CPUID_EBX_AVX512DQ_BIT  17
#define CPUID_EBX_AVX512DQ_FLAG 0x20000
#define CPUID_EBX_AVX512DQ_MASK 0x01
#define CPUID_EBX_AVX512DQ(_)   (((_) >> 17) & 0x01)

                        /**
                         * [Bit 18] RDSEED.
                         */
                        UINT32 Rdseed : 1;
#define CPUID_EBX_RDSEED_BIT  18
#define CPUID_EBX_RDSEED_FLAG 0x40000
#define CPUID_EBX_RDSEED_MASK 0x01
#define CPUID_EBX_RDSEED(_)   (((_) >> 18) & 0x01)

                        /**
                         * [Bit 19] ADX.
                         */
                        UINT32 Adx : 1;
#define CPUID_EBX_ADX_BIT  19
#define CPUID_EBX_ADX_FLAG 0x80000
#define CPUID_EBX_ADX_MASK 0x01
#define CPUID_EBX_ADX(_)   (((_) >> 19) & 0x01)

                        /**
                         * [Bit 20] Supports Supervisor-Mode Access Prevention (and the CLAC/STAC
                         * instructions) if 1.
                         */
                        UINT32 Smap : 1;
#define CPUID_EBX_SMAP_BIT  20
#define CPUID_EBX_SMAP_FLAG 0x100000
#define CPUID_EBX_SMAP_MASK 0x01
#define CPUID_EBX_SMAP(_)   (((_) >> 20) & 0x01)

                        /**
                         * [Bit 21] AVX512_IFMA.
                         */
                        UINT32 Avx512Ifma : 1;
#define CPUID_EBX_AVX512_IFMA_BIT  21
#define CPUID_EBX_AVX512_IFMA_FLAG 0x200000
#define CPUID_EBX_AVX512_IFMA_MASK 0x01
#define CPUID_EBX_AVX512_IFMA(_)   (((_) >> 21) & 0x01)
                        UINT32 Reserved1 : 1;

                        /**
                         * [Bit 23] CLFLUSHOPT.
                         */
                        UINT32 Clflushopt : 1;
#define CPUID_EBX_CLFLUSHOPT_BIT  23
#define CPUID_EBX_CLFLUSHOPT_FLAG 0x800000
#define CPUID_EBX_CLFLUSHOPT_MASK 0x01
#define CPUID_EBX_CLFLUSHOPT(_)   (((_) >> 23) & 0x01)

                        /**
                         * [Bit 24] CLWB.
                         */
                        UINT32 Clwb : 1;
#define CPUID_EBX_CLWB_BIT  24
#define CPUID_EBX_CLWB_FLAG 0x1000000
#define CPUID_EBX_CLWB_MASK 0x01
#define CPUID_EBX_CLWB(_)   (((_) >> 24) & 0x01)

                        /**
                         * [Bit 25] Intel Processor Trace.
                         */
                        UINT32 Intel : 1;
#define CPUID_EBX_INTEL_BIT  25
#define CPUID_EBX_INTEL_FLAG 0x2000000
#define CPUID_EBX_INTEL_MASK 0x01
#define CPUID_EBX_INTEL(_)   (((_) >> 25) & 0x01)

                        /**
                         * [Bit 26] (Intel(R) Xeon Phi(TM) only).
                         */
                        UINT32 Avx512Pf : 1;
#define CPUID_EBX_AVX512PF_BIT  26
#define CPUID_EBX_AVX512PF_FLAG 0x4000000
#define CPUID_EBX_AVX512PF_MASK 0x01
#define CPUID_EBX_AVX512PF(_)   (((_) >> 26) & 0x01)

                        /**
                         * [Bit 27] (Intel(R) Xeon Phi(TM) only).
                         */
                        UINT32 Avx512Er : 1;
#define CPUID_EBX_AVX512ER_BIT  27
#define CPUID_EBX_AVX512ER_FLAG 0x8000000
#define CPUID_EBX_AVX512ER_MASK 0x01
#define CPUID_EBX_AVX512ER(_)   (((_) >> 27) & 0x01)

                        /**
                         * [Bit 28] AVX512CD.
                         */
                        UINT32 Avx512Cd : 1;
#define CPUID_EBX_AVX512CD_BIT  28
#define CPUID_EBX_AVX512CD_FLAG 0x10000000
#define CPUID_EBX_AVX512CD_MASK 0x01
#define CPUID_EBX_AVX512CD(_)   (((_) >> 28) & 0x01)

                        /**
                         * [Bit 29] Supports Intel(R) Secure Hash Algorithm Extensions (Intel(R) SHA
                         * Extensions) if 1.
                         */
                        UINT32 Sha : 1;
#define CPUID_EBX_SHA_BIT  29
#define CPUID_EBX_SHA_FLAG 0x20000000
#define CPUID_EBX_SHA_MASK 0x01
#define CPUID_EBX_SHA(_)   (((_) >> 29) & 0x01)

                        /**
                         * [Bit 30] AVX512BW.
                         */
                        UINT32 Avx512Bw : 1;
#define CPUID_EBX_AVX512BW_BIT  30
#define CPUID_EBX_AVX512BW_FLAG 0x40000000
#define CPUID_EBX_AVX512BW_MASK 0x01
#define CPUID_EBX_AVX512BW(_)   (((_) >> 30) & 0x01)

                        /**
                         * [Bit 31] AVX512VL.
                         */
                        UINT32 Avx512Vl : 1;
#define CPUID_EBX_AVX512VL_BIT  31
#define CPUID_EBX_AVX512VL_FLAG 0x80000000
#define CPUID_EBX_AVX512VL_MASK 0x01
#define CPUID_EBX_AVX512VL(_)   (((_) >> 31) & 0x01)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bit 0] (Intel(R) Xeon Phi(TM) only).
                         */
                        UINT32 Prefetchwt1 : 1;
#define CPUID_ECX_PREFETCHWT1_BIT  0
#define CPUID_ECX_PREFETCHWT1_FLAG 0x01
#define CPUID_ECX_PREFETCHWT1_MASK 0x01
#define CPUID_ECX_PREFETCHWT1(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] AVX512_VBMI.
                         */
                        UINT32 Avx512Vbmi : 1;
#define CPUID_ECX_AVX512_VBMI_BIT  1
#define CPUID_ECX_AVX512_VBMI_FLAG 0x02
#define CPUID_ECX_AVX512_VBMI_MASK 0x01
#define CPUID_ECX_AVX512_VBMI(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bit 2] Supports user-mode instruction prevention if 1.
                         */
                        UINT32 Umip : 1;
#define CPUID_ECX_UMIP_BIT  2
#define CPUID_ECX_UMIP_FLAG 0x04
#define CPUID_ECX_UMIP_MASK 0x01
#define CPUID_ECX_UMIP(_)   (((_) >> 2) & 0x01)

                        /**
                         * [Bit 3] Supports protection keys for user-mode pages if 1.
                         */
                        UINT32 Pku : 1;
#define CPUID_ECX_PKU_BIT  3
#define CPUID_ECX_PKU_FLAG 0x08
#define CPUID_ECX_PKU_MASK 0x01
#define CPUID_ECX_PKU(_)   (((_) >> 3) & 0x01)

                        /**
                         * [Bit 4] If 1, OS has set CR4.PKE to enable protection keys (and the
                         * RDPKRU/WRPKRU instructions).
                         */
                        UINT32 Ospke : 1;
#define CPUID_ECX_OSPKE_BIT  4
#define CPUID_ECX_OSPKE_FLAG 0x10
#define CPUID_ECX_OSPKE_MASK 0x01
#define CPUID_ECX_OSPKE(_)   (((_) >> 4) & 0x01)

                        /**
                         * [Bit 5] WAITPKG.
                         */
                        UINT32 Waitpkg : 1;
#define CPUID_ECX_WAITPKG_BIT  5
#define CPUID_ECX_WAITPKG_FLAG 0x20
#define CPUID_ECX_WAITPKG_MASK 0x01
#define CPUID_ECX_WAITPKG(_)   (((_) >> 5) & 0x01)

                        /**
                         * [Bit 6] AVX512_VBMI2.
                         */
                        UINT32 Avx512Vbmi2 : 1;
#define CPUID_ECX_AVX512_VBMI2_BIT  6
#define CPUID_ECX_AVX512_VBMI2_FLAG 0x40
#define CPUID_ECX_AVX512_VBMI2_MASK 0x01
#define CPUID_ECX_AVX512_VBMI2(_)   (((_) >> 6) & 0x01)

                        /**
                         * [Bit 7] Supports CET shadow stack features if 1. Processors that set this
                         * bit define bits 1:0 of the IA32_U_CET and IA32_S_CET MSRs. Enumerates
                         * support for the following MSRs: IA32_INTERRUPT_SPP_TABLE_ADDR,
                         * IA32_PL3_SSP, IA32_PL2_SSP, IA32_PL1_SSP, and IA32_PL0_SSP.
                         */
                        UINT32 CetSs : 1;
#define CPUID_ECX_CET_SS_BIT  7
#define CPUID_ECX_CET_SS_FLAG 0x80
#define CPUID_ECX_CET_SS_MASK 0x01
#define CPUID_ECX_CET_SS(_)   (((_) >> 7) & 0x01)

                        /**
                         * [Bit 8] GFNI.
                         */
                        UINT32 Gfni : 1;
#define CPUID_ECX_GFNI_BIT  8
#define CPUID_ECX_GFNI_FLAG 0x100
#define CPUID_ECX_GFNI_MASK 0x01
#define CPUID_ECX_GFNI(_)   (((_) >> 8) & 0x01)

                        /**
                         * [Bit 9] VAES.
                         */
                        UINT32 Vaes : 1;
#define CPUID_ECX_VAES_BIT  9
#define CPUID_ECX_VAES_FLAG 0x200
#define CPUID_ECX_VAES_MASK 0x01
#define CPUID_ECX_VAES(_)   (((_) >> 9) & 0x01)

                        /**
                         * [Bit 10] VPCLMULQDQ.
                         */
                        UINT32 Vpclmulqdq : 1;
#define CPUID_ECX_VPCLMULQDQ_BIT  10
#define CPUID_ECX_VPCLMULQDQ_FLAG 0x400
#define CPUID_ECX_VPCLMULQDQ_MASK 0x01
#define CPUID_ECX_VPCLMULQDQ(_)   (((_) >> 10) & 0x01)

                        /**
                         * [Bit 11] AVX512_VNNI.
                         */
                        UINT32 Avx512Vnni : 1;
#define CPUID_ECX_AVX512_VNNI_BIT  11
#define CPUID_ECX_AVX512_VNNI_FLAG 0x800
#define CPUID_ECX_AVX512_VNNI_MASK 0x01
#define CPUID_ECX_AVX512_VNNI(_)   (((_) >> 11) & 0x01)

                        /**
                         * [Bit 12] AVX512_BITALG.
                         */
                        UINT32 Avx512Bitalg : 1;
#define CPUID_ECX_AVX512_BITALG_BIT  12
#define CPUID_ECX_AVX512_BITALG_FLAG 0x1000
#define CPUID_ECX_AVX512_BITALG_MASK 0x01
#define CPUID_ECX_AVX512_BITALG(_)   (((_) >> 12) & 0x01)

                        /**
                         * [Bit 13] If 1, the following MSRs are supported: IA32_TME_CAPABILITY,
                         * IA32_TME_ACTIVATE, IA32_TME_EXCLUDE_MASK, and IA32_TME_EXCLUDE_BASE.
                         */
                        UINT32 TmeEn : 1;
#define CPUID_ECX_TME_EN_BIT  13
#define CPUID_ECX_TME_EN_FLAG 0x2000
#define CPUID_ECX_TME_EN_MASK 0x01
#define CPUID_ECX_TME_EN(_)   (((_) >> 13) & 0x01)

                        /**
                         * [Bit 14] AVX512_VPOPCNTDQ.
                         */
                        UINT32 Avx512Vpopcntdq : 1;
#define CPUID_ECX_AVX512_VPOPCNTDQ_BIT  14
#define CPUID_ECX_AVX512_VPOPCNTDQ_FLAG 0x4000
#define CPUID_ECX_AVX512_VPOPCNTDQ_MASK 0x01
#define CPUID_ECX_AVX512_VPOPCNTDQ(_)   (((_) >> 14) & 0x01)
                        UINT32 Reserved1 : 1;

                        /**
                         * [Bit 16] Supports 57-bit linear addresses and five-level paging if 1.
                         */
                        UINT32 La57 : 1;
#define CPUID_ECX_LA57_BIT  16
#define CPUID_ECX_LA57_FLAG 0x10000
#define CPUID_ECX_LA57_MASK 0x01
#define CPUID_ECX_LA57(_)   (((_) >> 16) & 0x01)

                        /**
                         * [Bits 21:17] The value of MAWAU used by the BNDLDX and BNDSTX
                         * instructions in 64-bit mode.
                         */
                        UINT32 Mawau : 5;
#define CPUID_ECX_MAWAU_BIT  17
#define CPUID_ECX_MAWAU_FLAG 0x3E0000
#define CPUID_ECX_MAWAU_MASK 0x1F
#define CPUID_ECX_MAWAU(_)   (((_) >> 17) & 0x1F)

                        /**
                         * [Bit 22] RDPID and IA32_TSC_AUX are available if 1.
                         */
                        UINT32 Rdpid : 1;
#define CPUID_ECX_RDPID_BIT  22
#define CPUID_ECX_RDPID_FLAG 0x400000
#define CPUID_ECX_RDPID_MASK 0x01
#define CPUID_ECX_RDPID(_)   (((_) >> 22) & 0x01)

                        /**
                         * [Bit 23] KL. Supports Key Locker if 1.
                         */
                        UINT32 Kl : 1;
#define CPUID_ECX_KL_BIT  23
#define CPUID_ECX_KL_FLAG 0x800000
#define CPUID_ECX_KL_MASK 0x01
#define CPUID_ECX_KL(_)   (((_) >> 23) & 0x01)
                        UINT32 Reserved2 : 1;

                        /**
                         * [Bit 25] Supports cache line demote if 1.
                         */
                        UINT32 Cldemote : 1;
#define CPUID_ECX_CLDEMOTE_BIT  25
#define CPUID_ECX_CLDEMOTE_FLAG 0x2000000
#define CPUID_ECX_CLDEMOTE_MASK 0x01
#define CPUID_ECX_CLDEMOTE(_)   (((_) >> 25) & 0x01)
                        UINT32 Reserved3 : 1;

                        /**
                         * [Bit 27] Supports MOVDIRI if 1.
                         */
                        UINT32 Movdiri : 1;
#define CPUID_ECX_MOVDIRI_BIT  27
#define CPUID_ECX_MOVDIRI_FLAG 0x8000000
#define CPUID_ECX_MOVDIRI_MASK 0x01
#define CPUID_ECX_MOVDIRI(_)   (((_) >> 27) & 0x01)

                        /**
                         * [Bit 28] Supports MOVDIR64B if 1.
                         */
                        UINT32 Movdir64B : 1;
#define CPUID_ECX_MOVDIR64B_BIT  28
#define CPUID_ECX_MOVDIR64B_FLAG 0x10000000
#define CPUID_ECX_MOVDIR64B_MASK 0x01
#define CPUID_ECX_MOVDIR64B(_)   (((_) >> 28) & 0x01)
                        UINT32 Reserved4 : 1;

                        /**
                         * [Bit 30] Supports SGX Launch Configuration if 1.
                         */
                        UINT32 SgxLc : 1;
#define CPUID_ECX_SGX_LC_BIT  30
#define CPUID_ECX_SGX_LC_FLAG 0x40000000
#define CPUID_ECX_SGX_LC_MASK 0x01
#define CPUID_ECX_SGX_LC(_)   (((_) >> 30) & 0x01)

                        /**
                         * [Bit 31] Supports protection keys for supervisor-mode pages if 1.
                         */
                        UINT32 Pks : 1;
#define CPUID_ECX_PKS_BIT  31
#define CPUID_ECX_PKS_FLAG 0x80000000
#define CPUID_ECX_PKS_MASK 0x01
#define CPUID_ECX_PKS(_)   (((_) >> 31) & 0x01)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        UINT32 Reserved1 : 2;

                        /**
                         * [Bit 2] (Intel(R) Xeon Phi(TM) only.)
                         */
                        UINT32 Avx5124Vnniw : 1;
#define CPUID_EDX_AVX512_4VNNIW_BIT  2
#define CPUID_EDX_AVX512_4VNNIW_FLAG 0x04
#define CPUID_EDX_AVX512_4VNNIW_MASK 0x01
#define CPUID_EDX_AVX512_4VNNIW(_)   (((_) >> 2) & 0x01)

                        /**
                         * [Bit 3] (Intel(R) Xeon Phi(TM) only.)
                         */
                        UINT32 Avx5124Fmaps : 1;
#define CPUID_EDX_AVX512_4FMAPS_BIT  3
#define CPUID_EDX_AVX512_4FMAPS_FLAG 0x08
#define CPUID_EDX_AVX512_4FMAPS_MASK 0x01
#define CPUID_EDX_AVX512_4FMAPS(_)   (((_) >> 3) & 0x01)

                        /**
                         * [Bit 4] Fast Short REP MOV.
                         */
                        UINT32 FastShortRepMov : 1;
#define CPUID_EDX_FAST_SHORT_REP_MOV_BIT  4
#define CPUID_EDX_FAST_SHORT_REP_MOV_FLAG 0x10
#define CPUID_EDX_FAST_SHORT_REP_MOV_MASK 0x01
#define CPUID_EDX_FAST_SHORT_REP_MOV(_)   (((_) >> 4) & 0x01)
                        UINT32 Reserved2 : 3;

                        /**
                         * [Bit 8] AVX512_VP2INTERSECT.
                         */
                        UINT32 Avx512Vp2Intersect : 1;
#define CPUID_EDX_AVX512_VP2INTERSECT_BIT  8
#define CPUID_EDX_AVX512_VP2INTERSECT_FLAG 0x100
#define CPUID_EDX_AVX512_VP2INTERSECT_MASK 0x01
#define CPUID_EDX_AVX512_VP2INTERSECT(_)   (((_) >> 8) & 0x01)
                        UINT32 Reserved3 : 1;

                        /**
                         * [Bit 10] MD_CLEAR supported.
                         */
                        UINT32 MdClear : 1;
#define CPUID_EDX_MD_CLEAR_BIT  10
#define CPUID_EDX_MD_CLEAR_FLAG 0x400
#define CPUID_EDX_MD_CLEAR_MASK 0x01
#define CPUID_EDX_MD_CLEAR(_)   (((_) >> 10) & 0x01)
                        UINT32 Reserved4 : 3;

                        /**
                         * [Bit 14] SERIALIZE supported.
                         */
                        UINT32 Serialize : 1;
#define CPUID_EDX_SERIALIZE_BIT  14
#define CPUID_EDX_SERIALIZE_FLAG 0x4000
#define CPUID_EDX_SERIALIZE_MASK 0x01
#define CPUID_EDX_SERIALIZE(_)   (((_) >> 14) & 0x01)

                        /**
                         * [Bit 15] If 1, the processor is identified as a hybrid part.
                         */
                        UINT32 Hybrid : 1;
#define CPUID_EDX_HYBRID_BIT  15
#define CPUID_EDX_HYBRID_FLAG 0x8000
#define CPUID_EDX_HYBRID_MASK 0x01
#define CPUID_EDX_HYBRID(_)   (((_) >> 15) & 0x01)
                        UINT32 Reserved5 : 2;

                        /**
                         * [Bit 18] Supports PCONFIG if 1.
                         */
                        UINT32 Pconfig : 1;
#define CPUID_EDX_PCONFIG_BIT  18
#define CPUID_EDX_PCONFIG_FLAG 0x40000
#define CPUID_EDX_PCONFIG_MASK 0x01
#define CPUID_EDX_PCONFIG(_)   (((_) >> 18) & 0x01)
                        UINT32 Reserved6 : 1;

                        /**
                         * [Bit 20] Supports CET indirect branch tracking features if 1. Processors
                         * that set this bit define bits 5:2 and bits 63:10 of the IA32_U_CET and
                         * IA32_S_CET MSRs.
                         */
                        UINT32 CetIbt : 1;
#define CPUID_EDX_CET_IBT_BIT  20
#define CPUID_EDX_CET_IBT_FLAG 0x100000
#define CPUID_EDX_CET_IBT_MASK 0x01
#define CPUID_EDX_CET_IBT(_)   (((_) >> 20) & 0x01)
                        UINT32 Reserved7 : 5;

                        /**
                         * [Bit 26] Enumerates support for indirect branch restricted speculation
                         * (IBRS) and the indirect branch predictor barrier (IBPB). Processors that
                         * set this bit support the IA32_SPEC_CTRL MSR and the IA32_PRED_CMD MSR.
                         * They allow software to set IA32_SPEC_CTRL[0] (IBRS) and IA32_PRED_CMD[0]
                         * (IBPB).
                         */
                        UINT32 IbrsIbpb : 1;
#define CPUID_EDX_IBRS_IBPB_BIT  26
#define CPUID_EDX_IBRS_IBPB_FLAG 0x4000000
#define CPUID_EDX_IBRS_IBPB_MASK 0x01
#define CPUID_EDX_IBRS_IBPB(_)   (((_) >> 26) & 0x01)

                        /**
                         * [Bit 27] Enumerates support for single thread indirect branch predictors
                         * (STIBP). Processors that set this bit support the IA32_SPEC_CTRL MSR.
                         * They allow software to set IA32_SPEC_CTRL[1] (STIBP).
                         */
                        UINT32 Stibp : 1;
#define CPUID_EDX_STIBP_BIT  27
#define CPUID_EDX_STIBP_FLAG 0x8000000
#define CPUID_EDX_STIBP_MASK 0x01
#define CPUID_EDX_STIBP(_)   (((_) >> 27) & 0x01)

                        /**
                         * [Bit 28] Enumerates support for L1D_FLUSH. Processors that set this bit
                         * support the IA32_FLUSH_CMD MSR. They allow software to set
                         * IA32_FLUSH_CMD[0] (L1D_FLUSH).
                         */
                        UINT32 L1DFlush : 1;
#define CPUID_EDX_L1D_FLUSH_BIT  28
#define CPUID_EDX_L1D_FLUSH_FLAG 0x10000000
#define CPUID_EDX_L1D_FLUSH_MASK 0x01
#define CPUID_EDX_L1D_FLUSH(_)   (((_) >> 28) & 0x01)

                        /**
                         * [Bit 29] Enumerates support for the IA32_ARCH_CAPABILITIES MSR.
                         */
                        UINT32 Ia32ArchCapabilities : 1;
#define CPUID_EDX_IA32_ARCH_CAPABILITIES_BIT  29
#define CPUID_EDX_IA32_ARCH_CAPABILITIES_FLAG 0x20000000
#define CPUID_EDX_IA32_ARCH_CAPABILITIES_MASK 0x01
#define CPUID_EDX_IA32_ARCH_CAPABILITIES(_)   (((_) >> 29) & 0x01)

                        /**
                         * [Bit 30] Enumerates support for the IA32_CORE_CAPABILITIES MSR.
                         */
                        UINT32 Ia32CoreCapabilities : 1;
#define CPUID_EDX_IA32_CORE_CAPABILITIES_BIT  30
#define CPUID_EDX_IA32_CORE_CAPABILITIES_FLAG 0x40000000
#define CPUID_EDX_IA32_CORE_CAPABILITIES_MASK 0x01
#define CPUID_EDX_IA32_CORE_CAPABILITIES(_)   (((_) >> 30) & 0x01)

                        /**
                         * [Bit 31] Enumerates support for Speculative Store Bypass Disable (SSBD).
                         * Processors that set this bit support the IA32_SPEC_CTRL MSR. They allow
                         * software to set IA32_SPEC_CTRL[2] (SSBD).
                         */
                        UINT32 Ssbd : 1;
#define CPUID_EDX_SSBD_BIT  31
#define CPUID_EDX_SSBD_FLAG 0x80000000
#define CPUID_EDX_SSBD_MASK 0x01
#define CPUID_EDX_SSBD(_)   (((_) >> 31) & 0x01)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_07;

/**
 * @brief Direct Cache Access Information Leaf
 *
 * When CPUID executes with EAX set to 09H, the processor returns information about Direct Cache
 * Access capabilities.
 */
#define CPUID_DIRECT_CACHE_ACCESS_INFORMATION 0x00000009
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address
                         * 1F8H).
                         */
                        UINT32 Ia32PlatformDcaCap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT  0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG 0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK 0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EBX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT  0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] ECX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT  0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EDX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_09;

/**
 * @brief Architectural Performance Monitoring Leaf
 *
 * When CPUID executes with EAX set to 0AH, the processor returns information about support for
 * architectural performance monitoring capabilities. Architectural performance monitoring is
 * supported if the version ID is greater than Pn 0. For each version of architectural performance
 * monitoring capability, software must enumerate this leaf to discover the programming facilities
 * and the architectural performance events available in the processor.
 *
 * @see Vol3C[23(Introduction to Virtual-Machine Extensions)]
 */
#define CPUID_ARCHITECTURAL_PERFORMANCE_MONITORING 0x0000000A
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 7:0] Version ID of architectural performance monitoring.
                         */
                        UINT32 VersionIdOfArchitecturalPerformanceMonitoring : 8;
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_BIT  0
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_FLAG 0xFF
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING_MASK 0xFF
#define CPUID_EAX_VERSION_ID_OF_ARCHITECTURAL_PERFORMANCE_MONITORING(_)   (((_) >> 0) & 0xFF)

                        /**
                         * [Bits 15:8] Number of general-purpose performance monitoring counter per
                         * logical processor.
                         */
                        UINT32 NumberOfPerformanceMonitoringCounterPerLogicalProcessor : 8;
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_BIT  8
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_FLAG 0xFF00
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR_MASK 0xFF
#define CPUID_EAX_NUMBER_OF_PERFORMANCE_MONITORING_COUNTER_PER_LOGICAL_PROCESSOR(_) \
        (((_) >> 8) & 0xFF)

                        /**
                         * [Bits 23:16] Bit width of general-purpose, performance monitoring
                         * counter.
                         */
                        UINT32 BitWidthOfPerformanceMonitoringCounter : 8;
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_BIT  16
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_FLAG 0xFF0000
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER_MASK 0xFF
#define CPUID_EAX_BIT_WIDTH_OF_PERFORMANCE_MONITORING_COUNTER(_)   (((_) >> 16) & 0xFF)

                        /**
                         * [Bits 31:24] Length of EBX bit vector to enumerate architectural
                         * performance monitoring events.
                         */
                        UINT32 EbxBitVectorLength : 8;
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_BIT  24
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_FLAG 0xFF000000
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH_MASK 0xFF
#define CPUID_EAX_EBX_BIT_VECTOR_LENGTH(_)   (((_) >> 24) & 0xFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bit 0] Core cycle event not available if 1.
                         */
                        UINT32 CoreCycleEventNotAvailable : 1;
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_BIT  0
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_FLAG 0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_CORE_CYCLE_EVENT_NOT_AVAILABLE(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] Instruction retired event not available if 1.
                         */
                        UINT32 InstructionRetiredEventNotAvailable : 1;
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT  1
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x02
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bit 2] Reference cycles event not available if 1.
                         */
                        UINT32 ReferenceCyclesEventNotAvailable : 1;
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_BIT  2
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_FLAG 0x04
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_REFERENCE_CYCLES_EVENT_NOT_AVAILABLE(_)   (((_) >> 2) & 0x01)

                        /**
                         * [Bit 3] Last-level cache reference event not available if 1.
                         */
                        UINT32 LastLevelCacheReferenceEventNotAvailable : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_BIT  3
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_FLAG 0x08
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_REFERENCE_EVENT_NOT_AVAILABLE(_)   (((_) >> 3) & 0x01)

                        /**
                         * [Bit 4] Last-level cache misses event not available if 1.
                         */
                        UINT32 LastLevelCacheMissesEventNotAvailable : 1;
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_BIT  4
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_FLAG 0x10
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_LAST_LEVEL_CACHE_MISSES_EVENT_NOT_AVAILABLE(_)   (((_) >> 4) & 0x01)

                        /**
                         * [Bit 5] Branch instruction retired event not available if 1.
                         */
                        UINT32 BranchInstructionRetiredEventNotAvailable : 1;
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_BIT  5
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x20
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_INSTRUCTION_RETIRED_EVENT_NOT_AVAILABLE(_)   (((_) >> 5) & 0x01)

                        /**
                         * [Bit 6] Branch mispredict retired event not available if 1.
                         */
                        UINT32 BranchMispredictRetiredEventNotAvailable : 1;
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_BIT  6
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_FLAG 0x40
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE_MASK 0x01
#define CPUID_EBX_BRANCH_MISPREDICT_RETIRED_EVENT_NOT_AVAILABLE(_)   (((_) >> 6) & 0x01)
                        UINT32 Reserved1 : 25;
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] ECX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT  0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 4:0] Number of fixed-function performance counters (if Version ID >
                         * 1).
                         */
                        UINT32 NumberOfFixedFunctionPerformanceCounters : 5;
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT  0
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0x1F
#define CPUID_EDX_NUMBER_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_)   (((_) >> 0) & 0x1F)

                        /**
                         * [Bits 12:5] Bit width of fixed-function performance counters (if Version
                         * ID > 1).
                         */
                        UINT32 BitWidthOfFixedFunctionPerformanceCounters : 8;
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_BIT  5
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_FLAG 0x1FE0
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS_MASK 0xFF
#define CPUID_EDX_BIT_WIDTH_OF_FIXED_FUNCTION_PERFORMANCE_COUNTERS(_)   (((_) >> 5) & 0xFF)
                        UINT32 Reserved1 : 2;

                        /**
                         * [Bit 15] AnyThread deprecation.
                         */
                        UINT32 AnyThreadDeprecation : 1;
#define CPUID_EDX_ANY_THREAD_DEPRECATION_BIT  15
#define CPUID_EDX_ANY_THREAD_DEPRECATION_FLAG 0x8000
#define CPUID_EDX_ANY_THREAD_DEPRECATION_MASK 0x01
#define CPUID_EDX_ANY_THREAD_DEPRECATION(_)   (((_) >> 15) & 0x01)
                        UINT32 Reserved2 : 16;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_0A;

/**
 * @brief Extended Topology Enumeration Leaf
 *
 * When CPUID executes with EAX set to 0BH, the processor returns information about extended
 * topology enumeration data. Software must detect the presence of CPUID leaf 0BH by verifying
 * - the highest leaf index supported by CPUID is >= 0BH, and
 * - CPUID.0BH:EBX[15:0] reports a non-zero value.
 *
 * @note Most of Leaf 0BH output depends on the initial value in ECX. The EDX output of leaf 0BH is
 * always valid and does not vary with input value in ECX. Output value in ECX[7:0] always equals
 * input value in ECX[7:0]. Sub-leaf index 0 enumerates SMT level. Each subsequent higher sub-leaf
 * index enumerates a higherlevel topological entity in hierarchical order. For sub-leaves that
 * return an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0. If an input value n in
 * ECX returns the invalid level-type of 0 in ECX[15:8], other input values with ECX > n also return
 * 0 in ECX[15:8].
 */
#define CPUID_EXTENDED_TOPOLOGY 0x0000000B
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 4:0] Number of bits to shift right on x2APIC ID to get a unique
                         * topology ID of the next level type. All logical processors with the same
                         * next level ID share current level.
                         *
                         * @note Software should use this field (EAX[4:0]) to enumerate processor
                         * topology of the system.
                         */
                        UINT32 X2ApicIdToUniqueTopologyIdShift : 5;
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_BIT  0
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_FLAG 0x1F
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT_MASK 0x1F
#define CPUID_EAX_X2APIC_ID_TO_UNIQUE_TOPOLOGY_ID_SHIFT(_)   (((_) >> 0) & 0x1F)
                        UINT32 Reserved1 : 27;
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 15:0] Number of logical processors at this level type. The number
                         * reflects configuration as shipped by Intel.
                         *
                         * @note Software must not use EBX[15:0] to enumerate processor topology of
                         * the system. This value in this field (EBX[15:0]) is only intended for
                         * display/diagnostic purposes. The actual number of logical processors
                         * available to BIOS/OS/Applications may be different from the value of
                         * EBX[15:0], depending on software and platform hardware configurations.
                         */
                        UINT32 NumberOfLogicalProcessorsAtThisLevelType : 16;
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_BIT  0
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_FLAG 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE_MASK 0xFFFF
#define CPUID_EBX_NUMBER_OF_LOGICAL_PROCESSORS_AT_THIS_LEVEL_TYPE(_)   (((_) >> 0) & 0xFFFF)
                        UINT32 Reserved1 : 16;
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 7:0] Level number. Same value in ECX input.
                         */
                        UINT32 LevelNumber : 8;
#define CPUID_ECX_LEVEL_NUMBER_BIT  0
#define CPUID_ECX_LEVEL_NUMBER_FLAG 0xFF
#define CPUID_ECX_LEVEL_NUMBER_MASK 0xFF
#define CPUID_ECX_LEVEL_NUMBER(_)   (((_) >> 0) & 0xFF)

                        /**
                         * [Bits 15:8] Level type.
                         *
                         * @note The value of the "level type" field is not related to level numbers
                         * in any way, higher "level type" values do not mean higher levels. Level
                         * type field has the following encoding:
                         *       - 0: Invalid.
                         *       - 1: SMT.
                         *       - 2: Core.
                         *       - 3-255: Reserved.
                         */
                        UINT32 LevelType : 8;
#define CPUID_ECX_LEVEL_TYPE_BIT  8
#define CPUID_ECX_LEVEL_TYPE_FLAG 0xFF00
#define CPUID_ECX_LEVEL_TYPE_MASK 0xFF
#define CPUID_ECX_LEVEL_TYPE(_)   (((_) >> 8) & 0xFF)
                        UINT32 Reserved1 : 16;
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] x2APIC ID the current logical processor.
                         */
                        UINT32 X2ApicId : 32;
#define CPUID_EDX_X2APIC_ID_BIT  0
#define CPUID_EDX_X2APIC_ID_FLAG 0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID_MASK 0xFFFFFFFF
#define CPUID_EDX_X2APIC_ID(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_0B;

/**
 * @defgroup CPUID_EAX_0D \
 *           EAX = 0x0D
 *
 * When CPUID executes with EAX set to 0DH and ECX = 0, the processor returns information about the
 * bit-vector representation of all processor state extensions that are supported in the processor
 * and storage size requirements of the XSAVE/XRSTOR area. When CPUID executes with EAX set to 0DH
 * and ECX = n (n > 1, and is a valid sub-leaf index), the processor returns information about the
 * size and offset of each processor extended state save area within the XSAVE/XRSTOR area. Software
 * can use the forward-extendable technique depicted below to query the valid sub-leaves and obtain
 * size and offset information for each processor extended state save area: <pre> For i = 2 to 62 //
 * sub-leaf 1 is reserved IF (CPUID.(EAX=0DH, ECX=0):VECTOR[i] = 1) // VECTOR is the 64-bit value of
 * EDX:EAX Execute CPUID.(EAX=0DH, ECX = i) to examine size and offset for sub-leaf i; FI; </pre>
 * @{
 */
#define CPUID_EXTENDED_STATE_INFORMATION 0x0000000D
/**
 * @brief Processor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)
 */
typedef struct
{
        /**
         * @brief Reports the supported bits of the lower 32 bits of XCR0. XCR0[n] can be set to 1
         * only if EAX[n] is 1
         */
        union
        {
                struct
                {
                        /**
                         * [Bit 0] x87 state.
                         */
                        UINT32 X87State : 1;
#define CPUID_EAX_X87_STATE_BIT  0
#define CPUID_EAX_X87_STATE_FLAG 0x01
#define CPUID_EAX_X87_STATE_MASK 0x01
#define CPUID_EAX_X87_STATE(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] SSE state.
                         */
                        UINT32 SseState : 1;
#define CPUID_EAX_SSE_STATE_BIT  1
#define CPUID_EAX_SSE_STATE_FLAG 0x02
#define CPUID_EAX_SSE_STATE_MASK 0x01
#define CPUID_EAX_SSE_STATE(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bit 2] AVX state.
                         */
                        UINT32 AvxState : 1;
#define CPUID_EAX_AVX_STATE_BIT  2
#define CPUID_EAX_AVX_STATE_FLAG 0x04
#define CPUID_EAX_AVX_STATE_MASK 0x01
#define CPUID_EAX_AVX_STATE(_)   (((_) >> 2) & 0x01)

                        /**
                         * [Bits 4:3] MPX state.
                         */
                        UINT32 MpxState : 2;
#define CPUID_EAX_MPX_STATE_BIT  3
#define CPUID_EAX_MPX_STATE_FLAG 0x18
#define CPUID_EAX_MPX_STATE_MASK 0x03
#define CPUID_EAX_MPX_STATE(_)   (((_) >> 3) & 0x03)

                        /**
                         * [Bits 7:5] AVX-512 state.
                         */
                        UINT32 Avx512State : 3;
#define CPUID_EAX_AVX_512_STATE_BIT  5
#define CPUID_EAX_AVX_512_STATE_FLAG 0xE0
#define CPUID_EAX_AVX_512_STATE_MASK 0x07
#define CPUID_EAX_AVX_512_STATE(_)   (((_) >> 5) & 0x07)

                        /**
                         * [Bit 8] Used for IA32_XSS.
                         */
                        UINT32 UsedForIa32Xss1 : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_1_BIT  8
#define CPUID_EAX_USED_FOR_IA32_XSS_1_FLAG 0x100
#define CPUID_EAX_USED_FOR_IA32_XSS_1_MASK 0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_1(_)   (((_) >> 8) & 0x01)

                        /**
                         * [Bit 9] PKRU state.
                         */
                        UINT32 PkruState : 1;
#define CPUID_EAX_PKRU_STATE_BIT  9
#define CPUID_EAX_PKRU_STATE_FLAG 0x200
#define CPUID_EAX_PKRU_STATE_MASK 0x01
#define CPUID_EAX_PKRU_STATE(_)   (((_) >> 9) & 0x01)
                        UINT32 Reserved1 : 3;

                        /**
                         * [Bit 13] Used for IA32_XSS.
                         */
                        UINT32 UsedForIa32Xss2 : 1;
#define CPUID_EAX_USED_FOR_IA32_XSS_2_BIT  13
#define CPUID_EAX_USED_FOR_IA32_XSS_2_FLAG 0x2000
#define CPUID_EAX_USED_FOR_IA32_XSS_2_MASK 0x01
#define CPUID_EAX_USED_FOR_IA32_XSS_2(_)   (((_) >> 13) & 0x01)
                        UINT32 Reserved2 : 18;
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR
                         * save area) required by enabled features in XCR0. May be different than
                         * ECX if some features at the end of the XSAVE save area are not enabled.
                         */
                        UINT32 MaxSizeRequiredByEnabledFeaturesInXcr0 : 32;
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_BIT  0
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_FLAG 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0_MASK 0xFFFFFFFF
#define CPUID_EBX_MAX_SIZE_REQUIRED_BY_ENABLED_FEATURES_IN_XCR0(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Maximum size (bytes, from the beginning of the XSAVE/XRSTOR
                         * save area) of the XSAVE/XRSTOR save area required by all supported
                         * features in the processor, i.e., all the valid bit fields in XCR0.
                         */
                        UINT32 MaxSizeOfXsaveXrstorSaveArea : 32;
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_BIT  0
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_FLAG 0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA_MASK 0xFFFFFFFF
#define CPUID_ECX_MAX_SIZE_OF_XSAVE_XRSTOR_SAVE_AREA(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reports the supported bits of the upper 32 bits of XCR0.
                         * XCR0[n+32] can be set to 1 only if EDX[n] is 1.
                         */
                        UINT32 Xcr0SupportedBits : 32;
#define CPUID_EDX_XCR0_SUPPORTED_BITS_BIT  0
#define CPUID_EDX_XCR0_SUPPORTED_BITS_FLAG 0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS_MASK 0xFFFFFFFF
#define CPUID_EDX_XCR0_SUPPORTED_BITS(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_0D_ECX_00;

/**
 * @brief Direct Cache Access Information Leaf
 */
typedef struct
{
        union
        {
                struct
                {
                        UINT32 Reserved1 : 1;

                        /**
                         * [Bit 1] Supports XSAVEC and the compacted form of XRSTOR if set.
                         */
                        UINT32 SupportsXsavecAndCompactedXrstor : 1;
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_BIT  1
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_FLAG 0x02
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR_MASK 0x01
#define CPUID_EAX_SUPPORTS_XSAVEC_AND_COMPACTED_XRSTOR(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bit 2] Supports XGETBV with ECX = 1 if set.
                         */
                        UINT32 SupportsXgetbvWithEcx1 : 1;
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_BIT  2
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_FLAG 0x04
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1_MASK 0x01
#define CPUID_EAX_SUPPORTS_XGETBV_WITH_ECX_1(_)   (((_) >> 2) & 0x01)

                        /**
                         * [Bit 3] Supports XSAVES/XRSTORS and IA32_XSS if set.
                         */
                        UINT32 SupportsXsaveXrstorAndIa32Xss : 1;
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_BIT  3
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_FLAG 0x08
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS_MASK 0x01
#define CPUID_EAX_SUPPORTS_XSAVE_XRSTOR_AND_IA32_XSS(_)   (((_) >> 3) & 0x01)
                        UINT32 Reserved2 : 28;
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] The size in bytes of the XSAVE area containing all states
                         * enabled by XCRO | IA32_XSS.
                         */
                        UINT32 SizeOfXsaveAread : 32;
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_BIT  0
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_FLAG 0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD_MASK 0xFFFFFFFF
#define CPUID_EBX_SIZE_OF_XSAVE_AREAD(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 7:0] Used for XCR0.
                         */
                        UINT32 UsedForXcr01 : 8;
#define CPUID_ECX_USED_FOR_XCR0_1_BIT  0
#define CPUID_ECX_USED_FOR_XCR0_1_FLAG 0xFF
#define CPUID_ECX_USED_FOR_XCR0_1_MASK 0xFF
#define CPUID_ECX_USED_FOR_XCR0_1(_)   (((_) >> 0) & 0xFF)

                        /**
                         * [Bit 8] PT state.
                         */
                        UINT32 PtState : 1;
#define CPUID_ECX_PT_STATE_BIT  8
#define CPUID_ECX_PT_STATE_FLAG 0x100
#define CPUID_ECX_PT_STATE_MASK 0x01
#define CPUID_ECX_PT_STATE(_)   (((_) >> 8) & 0x01)

                        /**
                         * [Bit 9] Used for XCR0.
                         */
                        UINT32 UsedForXcr02 : 1;
#define CPUID_ECX_USED_FOR_XCR0_2_BIT  9
#define CPUID_ECX_USED_FOR_XCR0_2_FLAG 0x200
#define CPUID_ECX_USED_FOR_XCR0_2_MASK 0x01
#define CPUID_ECX_USED_FOR_XCR0_2(_)   (((_) >> 9) & 0x01)
                        UINT32 Reserved1 : 1;

                        /**
                         * [Bit 11] CET user state.
                         */
                        UINT32 CetUserState : 1;
#define CPUID_ECX_CET_USER_STATE_BIT  11
#define CPUID_ECX_CET_USER_STATE_FLAG 0x800
#define CPUID_ECX_CET_USER_STATE_MASK 0x01
#define CPUID_ECX_CET_USER_STATE(_)   (((_) >> 11) & 0x01)

                        /**
                         * [Bit 12] CET supervisor state.
                         */
                        UINT32 CetSupervisorState : 1;
#define CPUID_ECX_CET_SUPERVISOR_STATE_BIT  12
#define CPUID_ECX_CET_SUPERVISOR_STATE_FLAG 0x1000
#define CPUID_ECX_CET_SUPERVISOR_STATE_MASK 0x01
#define CPUID_ECX_CET_SUPERVISOR_STATE(_)   (((_) >> 12) & 0x01)

                        /**
                         * [Bit 13] HDC state.
                         */
                        UINT32 HdcState : 1;
#define CPUID_ECX_HDC_STATE_BIT  13
#define CPUID_ECX_HDC_STATE_FLAG 0x2000
#define CPUID_ECX_HDC_STATE_MASK 0x01
#define CPUID_ECX_HDC_STATE(_)   (((_) >> 13) & 0x01)
                        UINT32 Reserved2 : 1;

                        /**
                         * [Bit 15] LBR state.
                         */
                        UINT32 LbrState : 1;
#define CPUID_ECX_LBR_STATE_BIT  15
#define CPUID_ECX_LBR_STATE_FLAG 0x8000
#define CPUID_ECX_LBR_STATE_MASK 0x01
#define CPUID_ECX_LBR_STATE(_)   (((_) >> 15) & 0x01)

                        /**
                         * [Bit 16] HWP state.
                         */
                        UINT32 HwpState : 1;
#define CPUID_ECX_HWP_STATE_BIT  16
#define CPUID_ECX_HWP_STATE_FLAG 0x10000
#define CPUID_ECX_HWP_STATE_MASK 0x01
#define CPUID_ECX_HWP_STATE(_)   (((_) >> 16) & 0x01)
                        UINT32 Reserved3 : 15;
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reports the supported bits of the upper 32 bits of the
                         * IA32_XSS MSR. IA32_XSS[n+32] can be set to 1 only if EDX[n] is 1
                         */
                        UINT32 SupportedUpperIa32XssBits : 32;
#define CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS_BIT  0
#define CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS_FLAG 0xFFFFFFFF
#define CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS_MASK 0xFFFFFFFF
#define CPUID_EDX_SUPPORTED_UPPER_IA32_XSS_BITS(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_0D_ECX_01;

/**
 * @brief Processor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n > 1)
 *
 * @note Leaf 0DH output depends on the initial value in ECX. Each sub-leaf index (starting at
 * position 2) is supported if it corresponds to a supported bit in either the XCR0 register or the
 * IA32_XSS MSR. If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0
 * <= n <= 31) is invalid if sub-leaf 0 returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n].
 * Sub-leaf n (32 <= n <= 63) is invalid if sub-leaf 0 returns 0 in EDX[n-32] and sub-leaf 1 returns
 * 0 in EDX[n-32].
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] The size in bytes (from the offset specified in EBX) of the
                         * save area for an extended state feature associated with a valid sub-leaf
                         * index, n.
                         */
                        UINT32 Ia32PlatformDcaCap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT  0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG 0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK 0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] The offset in bytes of this extended state component's save
                         * area from the beginning of the XSAVE/XRSTOR area. This field reports 0 if
                         * the sub-leaf index, n, does not map to a valid bit in the XCR0 register.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT  0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bit 0] Is set if the bit n (corresponding to the sub-leaf index) is
                         * supported in the IA32_XSS MSR; it is clear if bit n is instead supported
                         * in XCR0.
                         */
                        UINT32 Ecx2 : 1;
#define CPUID_ECX_ECX_2_BIT  0
#define CPUID_ECX_ECX_2_FLAG 0x01
#define CPUID_ECX_ECX_2_MASK 0x01
#define CPUID_ECX_ECX_2(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] Is set if, when the compacted format of an XSAVE area is used,
                         * this extended state component located on the next 64-byte boundary
                         * following the preceding state component (otherwise, it is located
                         * immediately following the preceding state component).
                         */
                        UINT32 Ecx1 : 1;
#define CPUID_ECX_ECX_1_BIT  1
#define CPUID_ECX_ECX_1_FLAG 0x02
#define CPUID_ECX_ECX_1_MASK 0x01
#define CPUID_ECX_ECX_1(_)   (((_) >> 1) & 0x01)
                        UINT32 Reserved1 : 30;
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] This field reports 0 if the sub-leaf index, n, is invalid;
                         * otherwise it is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_0D_ECX_N;

/**
 * @}
 */

/**
 * @defgroup CPUID_EAX_0F \
 *           EAX = 0x0F
 *
 * When CPUID executes with EAX set to 0FH and ECX = 0, the processor returns information about the
 * bit-vector representation of QoS monitoring resource types that are supported in the processor
 * and maximum range of RMID values the processor can use to monitor of any supported resource
 * types. Each bit, starting from bit 1, corresponds to a specific resource type if the bit is set.
 * The bit position corresponds to the sub-leaf index (or ResID) that software must use to query QoS
 * monitoring capability available for that type. See Table 3-8. When CPUID executes with EAX set to
 * 0FH and ECX = n (n >= 1, and is a valid ResID), the processor returns information software can
 * use to program IA32_PQR_ASSOC, IA32_QM_EVTSEL MSRs before reading QoS data from the IA32_QM_CTR
 * MSR.
 * @{
 */
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_MONITORING_INFORMATION 0x0000000F
/**
 * @brief Intel Resource Director Technology (Intel RDT) Monitoring Enumeration Sub-leaf (EAX = 0FH,
 * ECX = 0)
 *
 * @note Leaf 0FH output depends on the initial value in ECX. Sub-leaf index 0 reports valid
 * resource type starting at bit position 1 of EDX.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EAX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT  0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Maximum range (zero-based) of RMID within this physical
                         * processor of all types.
                         */
                        UINT32 RmidMaxRange : 32;
#define CPUID_EBX_RMID_MAX_RANGE_BIT  0
#define CPUID_EBX_RMID_MAX_RANGE_FLAG 0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE_MASK 0xFFFFFFFF
#define CPUID_EBX_RMID_MAX_RANGE(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] ECX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT  0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        UINT32 Reserved1 : 1;

                        /**
                         * [Bit 1] Supports L3 Cache Intel RDT Monitoring if 1.
                         */
                        UINT32 SupportsL3CacheIntelRdtMonitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_BIT  1
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_FLAG 0x02
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING_MASK 0x01
#define CPUID_EDX_SUPPORTS_L3_CACHE_INTEL_RDT_MONITORING(_)   (((_) >> 1) & 0x01)
                        UINT32 Reserved2 : 30;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_0F_ECX_00;

/**
 * @brief L3 Cache Intel RDT Monitoring Capability Enumeration Sub-leaf (EAX = 0FH, ECX = 1)
 *
 * @note Leaf 0FH output depends on the initial value in ECX.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EAX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT  0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Conversion factor from reported IA32_QM_CTR value to
                         * occupancy metric (bytes).
                         */
                        UINT32 ConversionFactor : 32;
#define CPUID_EBX_CONVERSION_FACTOR_BIT  0
#define CPUID_EBX_CONVERSION_FACTOR_FLAG 0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR_MASK 0xFFFFFFFF
#define CPUID_EBX_CONVERSION_FACTOR(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Maximum range (zero-based) of RMID within this physical
                         * processor of all types.
                         */
                        UINT32 RmidMaxRange : 32;
#define CPUID_ECX_RMID_MAX_RANGE_BIT  0
#define CPUID_ECX_RMID_MAX_RANGE_FLAG 0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE_MASK 0xFFFFFFFF
#define CPUID_ECX_RMID_MAX_RANGE(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bit 0] Supports L3 occupancy monitoring if 1.
                         */
                        UINT32 SupportsL3OccupancyMonitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_BIT  0
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_FLAG 0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING_MASK 0x01
#define CPUID_EDX_SUPPORTS_L3_OCCUPANCY_MONITORING(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] Supports L3 Total Bandwidth monitoring if 1.
                         */
                        UINT32 SupportsL3TotalBandwidthMonitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_BIT  1
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_FLAG 0x02
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING_MASK 0x01
#define CPUID_EDX_SUPPORTS_L3_TOTAL_BANDWIDTH_MONITORING(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bit 2] Supports L3 Local Bandwidth monitoring if 1.
                         */
                        UINT32 SupportsL3LocalBandwidthMonitoring : 1;
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_BIT  2
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_FLAG 0x04
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING_MASK 0x01
#define CPUID_EDX_SUPPORTS_L3_LOCAL_BANDWIDTH_MONITORING(_)   (((_) >> 2) & 0x01)
                        UINT32 Reserved1 : 29;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_0F_ECX_01;

/**
 * @}
 */

/**
 * @defgroup CPUID_EAX_10 \
 *           EAX = 0x10
 *
 * When CPUID executes with EAX set to 10H and ECX = 0, the processor returns information about the
 * bit-vector representation of QoS Enforcement resource types that are supported in the processor.
 * Each bit, starting from bit 1, corresponds to a specific resource type if the bit is set. The bit
 * position corresponds to the sub-leaf index (or ResID) that software must use to query QoS
 * enforcement capability available for that type. When CPUID executes with EAX set to 10H and ECX =
 * n (n >= 1, and is a valid ResID), the processor returns information about available classes of
 * service and range of QoS mask MSRs that software can use to configure each class of services
 * using capability bit masks in the QoS Mask registers, IA32_resourceType_Mask_n.
 * @{
 */
#define CPUID_INTEL_RESOURCE_DIRECTOR_TECHNOLOGY_ALLOCATION_INFORMATION 0x00000010
/**
 * @brief Intel Resource Director Technology (Intel RDT) Allocation Enumeration Sub-leaf (EAX = 10H,
 * ECX = 0)
 *
 * @note Leaf 10H output depends on the initial value in ECX. Sub-leaf index 0 reports valid
 * resource identification (ResID) starting at bit position 1 of EBX.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address
                         * 1F8H).
                         */
                        UINT32 Ia32PlatformDcaCap : 32;
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_BIT  0
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_FLAG 0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP_MASK 0xFFFFFFFF
#define CPUID_EAX_IA32_PLATFORM_DCA_CAP(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        UINT32 Reserved1 : 1;

                        /**
                         * [Bit 1] Supports L3 Cache Allocation Technology if 1.
                         */
                        UINT32 SupportsL3CacheAllocationTechnology : 1;
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_BIT  1
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_FLAG 0x02
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY_MASK 0x01
#define CPUID_EBX_SUPPORTS_L3_CACHE_ALLOCATION_TECHNOLOGY(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bit 2] Supports L2 Cache Allocation Technology if 1.
                         */
                        UINT32 SupportsL2CacheAllocationTechnology : 1;
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_BIT  2
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_FLAG 0x04
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY_MASK 0x01
#define CPUID_EBX_SUPPORTS_L2_CACHE_ALLOCATION_TECHNOLOGY(_)   (((_) >> 2) & 0x01)

                        /**
                         * [Bit 3] Supports Memory Bandwidth Allocation if 1.
                         */
                        UINT32 SupportsMemoryBandwidthAllocation : 1;
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_BIT  3
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_FLAG 0x08
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION_MASK 0x01
#define CPUID_EBX_SUPPORTS_MEMORY_BANDWIDTH_ALLOCATION(_)   (((_) >> 3) & 0x01)
                        UINT32 Reserved2 : 28;
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] ECX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT  0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EDX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_10_ECX_00;

/**
 * @brief L3 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 1)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID
                         * using minus-one notation.
                         */
                        UINT32 LengthOfCapacityBitMask : 5;
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT  0
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG 0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK 0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)   (((_) >> 0) & 0x1F)
                        UINT32 Reserved1 : 27;
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
                         */
                        UINT32 Ebx0 : 32;
#define CPUID_EBX_EBX_0_BIT  0
#define CPUID_EBX_EBX_0_FLAG 0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK 0xFFFFFFFF
#define CPUID_EBX_EBX_0(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        UINT32 Reserved1 : 2;

                        /**
                         * [Bit 2] Code and Data Prioritization Technology supported if 1.
                         */
                        UINT32 CodeAndDataPriorizationTechnologySupported : 1;
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_BIT  2
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_FLAG 0x04
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED_MASK 0x01
#define CPUID_ECX_CODE_AND_DATA_PRIORIZATION_TECHNOLOGY_SUPPORTED(_)   (((_) >> 2) & 0x01)
                        UINT32 Reserved2 : 29;
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 15:0] Highest COS number supported for this ResID.
                         */
                        UINT32 HighestCosNumberSupported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT  0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG 0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK 0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)   (((_) >> 0) & 0xFFFF)
                        UINT32 Reserved1 : 16;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_10_ECX_01;

/**
 * @brief L2 Cache Allocation Technology Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 2)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 4:0] Length of the capacity bit mask for the corresponding ResID
                         * using minus-one notation.
                         */
                        UINT32 LengthOfCapacityBitMask : 5;
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_BIT  0
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_FLAG 0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK_MASK 0x1F
#define CPUID_EAX_LENGTH_OF_CAPACITY_BIT_MASK(_)   (((_) >> 0) & 0x1F)
                        UINT32 Reserved1 : 27;
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Bit-granular map of isolation/contention of allocation units.
                         */
                        UINT32 Ebx0 : 32;
#define CPUID_EBX_EBX_0_BIT  0
#define CPUID_EBX_EBX_0_FLAG 0xFFFFFFFF
#define CPUID_EBX_EBX_0_MASK 0xFFFFFFFF
#define CPUID_EBX_EBX_0(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] ECX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT  0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 15:0] Highest COS number supported for this ResID.
                         */
                        UINT32 HighestCosNumberSupported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT  0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG 0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK 0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)   (((_) >> 0) & 0xFFFF)
                        UINT32 Reserved1 : 16;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_10_ECX_02;

/**
 * @brief Memory Bandwidth Allocation Enumeration Sub-leaf (EAX = 10H, ECX = ResID = 3)
 *
 * @note Leaf 10H output depends on the initial value in ECX.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 11:0] Reports the maximum MBA throttling value supported for the
                         * corresponding ResID using minus-one notation.
                         */
                        UINT32 MaxMbaThrottlingValue : 12;
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_BIT  0
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_FLAG 0xFFF
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE_MASK 0xFFF
#define CPUID_EAX_MAX_MBA_THROTTLING_VALUE(_)   (((_) >> 0) & 0xFFF)
                        UINT32 Reserved1 : 20;
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EBX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT  0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        UINT32 Reserved1 : 2;

                        /**
                         * [Bit 2] Reports whether the response of the delay values is linear.
                         */
                        UINT32 ResponseOfDelayIsLinear : 1;
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_BIT  2
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_FLAG 0x04
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR_MASK 0x01
#define CPUID_ECX_RESPONSE_OF_DELAY_IS_LINEAR(_)   (((_) >> 2) & 0x01)
                        UINT32 Reserved2 : 29;
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 15:0] Highest COS number supported for this ResID.
                         */
                        UINT32 HighestCosNumberSupported : 16;
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_BIT  0
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_FLAG 0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED_MASK 0xFFFF
#define CPUID_EDX_HIGHEST_COS_NUMBER_SUPPORTED(_)   (((_) >> 0) & 0xFFFF)
                        UINT32 Reserved1 : 16;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_10_ECX_03;

/**
 * @}
 */

/**
 * @defgroup CPUID_EAX_12 \
 *           EAX = 0x12
 *
 * When CPUID executes with EAX set to 12H and ECX = 0H, the processor returns information about
 * Intel SGX capabilities. When CPUID executes with EAX set to 12H and ECX = 1H, the processor
 * returns information about Intel SGX attributes. When CPUID executes with EAX set to 12H and ECX =
 * n (n > 1), the processor returns information about Intel SGX Enclave Page Cache.
 * @{
 */
#define CPUID_INTEL_SGX 0x00000012
/**
 * @brief Intel SGX Capability Enumeration Leaf, sub-leaf 0 (EAX = 12H, ECX = 0)
 *
 * @note Leaf 12H sub-leaf 0 (ECX = 0) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bit 0] If 1, Indicates Intel SGX supports the collection of SGX1 leaf
                         * functions.
                         */
                        UINT32 Sgx1 : 1;
#define CPUID_EAX_SGX1_BIT  0
#define CPUID_EAX_SGX1_FLAG 0x01
#define CPUID_EAX_SGX1_MASK 0x01
#define CPUID_EAX_SGX1(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] If 1, Indicates Intel SGX supports the collection of SGX2 leaf
                         * functions.
                         */
                        UINT32 Sgx2 : 1;
#define CPUID_EAX_SGX2_BIT  1
#define CPUID_EAX_SGX2_FLAG 0x02
#define CPUID_EAX_SGX2_MASK 0x01
#define CPUID_EAX_SGX2(_)   (((_) >> 1) & 0x01)
                        UINT32 Reserved1 : 3;

                        /**
                         * [Bit 5] If 1, indicates Intel SGX supports ENCLV instruction leaves
                         * EINCVIRTCHILD, EDECVIRTCHILD, and ESETCONTEXT.
                         */
                        UINT32 SgxEnclvAdvanced : 1;
#define CPUID_EAX_SGX_ENCLV_ADVANCED_BIT  5
#define CPUID_EAX_SGX_ENCLV_ADVANCED_FLAG 0x20
#define CPUID_EAX_SGX_ENCLV_ADVANCED_MASK 0x01
#define CPUID_EAX_SGX_ENCLV_ADVANCED(_)   (((_) >> 5) & 0x01)

                        /**
                         * [Bit 6] If 1, indicates Intel SGX supports ENCLS instruction leaves
                         * ETRACKC, ERDINFO, ELDBC, and ELDUC.
                         */
                        UINT32 SgxEnclsAdvanced : 1;
#define CPUID_EAX_SGX_ENCLS_ADVANCED_BIT  6
#define CPUID_EAX_SGX_ENCLS_ADVANCED_FLAG 0x40
#define CPUID_EAX_SGX_ENCLS_ADVANCED_MASK 0x01
#define CPUID_EAX_SGX_ENCLS_ADVANCED(_)   (((_) >> 6) & 0x01)
                        UINT32 Reserved2 : 25;
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Bit vector of supported extended SGX features.
                         */
                        UINT32 Miscselect : 32;
#define CPUID_EBX_MISCSELECT_BIT  0
#define CPUID_EBX_MISCSELECT_FLAG 0xFFFFFFFF
#define CPUID_EBX_MISCSELECT_MASK 0xFFFFFFFF
#define CPUID_EBX_MISCSELECT(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] ECX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT  0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 7:0] The maximum supported enclave size in non-64-bit mode is
                         * 2^(EDX[7:0]).
                         */
                        UINT32 MaxEnclaveSizeNot64 : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_BIT  0
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_FLAG 0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64_MASK 0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_NOT64(_)   (((_) >> 0) & 0xFF)

                        /**
                         * [Bits 15:8] The maximum supported enclave size in 64-bit mode is
                         * 2^(EDX[15:8]).
                         */
                        UINT32 MaxEnclaveSize64 : 8;
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_BIT  8
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_FLAG 0xFF00
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64_MASK 0xFF
#define CPUID_EDX_MAX_ENCLAVE_SIZE_64(_)   (((_) >> 8) & 0xFF)
                        UINT32 Reserved1 : 16;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_12_ECX_00;

/**
 * @brief Intel SGX Attributes Enumeration Leaf, sub-leaf 1 (EAX = 12H, ECX = 1)
 *
 * @note Leaf 12H sub-leaf 1 (ECX = 1) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX] = 1.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[31:0] that software
                         * can set with ECREATE.
                         */
                        UINT32 ValidSecsAttributes0 : 32;
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_BIT  0
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_FLAG 0xFFFFFFFF
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0_MASK 0xFFFFFFFF
#define CPUID_EAX_VALID_SECS_ATTRIBUTES_0(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[63:32] that
                         * software can set with ECREATE.
                         */
                        UINT32 ValidSecsAttributes1 : 32;
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_BIT  0
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_FLAG 0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1_MASK 0xFFFFFFFF
#define CPUID_EBX_VALID_SECS_ATTRIBUTES_1(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[95:64] that
                         * software can set with ECREATE.
                         */
                        UINT32 ValidSecsAttributes2 : 32;
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_BIT  0
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_FLAG 0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2_MASK 0xFFFFFFFF
#define CPUID_ECX_VALID_SECS_ATTRIBUTES_2(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reports the valid bits of SECS.ATTRIBUTES[127:96] that
                         * software can set with ECREATE.
                         */
                        UINT32 ValidSecsAttributes3 : 32;
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_BIT  0
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_FLAG 0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3_MASK 0xFFFFFFFF
#define CPUID_EDX_VALID_SECS_ATTRIBUTES_3(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_12_ECX_01;

/**
 * @brief Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
 *
 * @note Leaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX]
 * = 1. This structure describes sub-leaf type 0.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 3:0] Sub-leaf Type 0. Indicates this sub-leaf is invalid.
                         */
                        UINT32 SubLeafType : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT  0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_)   (((_) >> 0) & 0x0F)
                        UINT32 Reserved1 : 28;
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EBX is zero.
                         */
                        UINT32 Zero : 32;
#define CPUID_EBX_ZERO_BIT  0
#define CPUID_EBX_ZERO_FLAG 0xFFFFFFFF
#define CPUID_EBX_ZERO_MASK 0xFFFFFFFF
#define CPUID_EBX_ZERO(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] ECX is zero.
                         */
                        UINT32 Zero : 32;
#define CPUID_ECX_ZERO_BIT  0
#define CPUID_ECX_ZERO_FLAG 0xFFFFFFFF
#define CPUID_ECX_ZERO_MASK 0xFFFFFFFF
#define CPUID_ECX_ZERO(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EDX is zero.
                         */
                        UINT32 Zero : 32;
#define CPUID_EDX_ZERO_BIT  0
#define CPUID_EDX_ZERO_FLAG 0xFFFFFFFF
#define CPUID_EDX_ZERO_MASK 0xFFFFFFFF
#define CPUID_EDX_ZERO(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_12_ECX_02P_SLT_0;

/**
 * @brief Intel SGX EPC Enumeration Leaf, sub-leaves (EAX = 12H, ECX = 2 or higher)
 *
 * @note Leaf 12H sub-leaf 2 or higher (ECX >= 2) is supported if CPUID.(EAX=07H, ECX=0H):EBX[SGX]
 * = 1. This structure describes sub-leaf type 1.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 3:0] Sub-leaf Type 1. This sub-leaf enumerates an EPC section.
                         * EBX:EAX and EDX:ECX provide information on the Enclave Page Cache (EPC)
                         * section.
                         */
                        UINT32 SubLeafType : 4;
#define CPUID_EAX_SUB_LEAF_TYPE_BIT  0
#define CPUID_EAX_SUB_LEAF_TYPE_FLAG 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE_MASK 0x0F
#define CPUID_EAX_SUB_LEAF_TYPE(_)   (((_) >> 0) & 0x0F)
                        UINT32 Reserved1 : 8;

                        /**
                         * [Bits 31:12] Bits 31:12 of the physical address of the base of the EPC
                         * section.
                         */
                        UINT32 EpcBasePhysicalAddress1 : 20;
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_BIT  12
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_FLAG 0xFFFFF000
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1_MASK 0xFFFFF
#define CPUID_EAX_EPC_BASE_PHYSICAL_ADDRESS_1(_)   (((_) >> 12) & 0xFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 19:0] Bits 51:32 of the physical address of the base of the EPC
                         * section.
                         */
                        UINT32 EpcBasePhysicalAddress2 : 20;
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_BIT  0
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_FLAG 0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2_MASK 0xFFFFF
#define CPUID_EBX_EPC_BASE_PHYSICAL_ADDRESS_2(_)   (((_) >> 0) & 0xFFFFF)
                        UINT32 Reserved1 : 12;
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 3:0] EPC section property encoding defined as follows:
                         * - If EAX[3:0] 0000b, then all bits of the EDX:ECX pair are enumerated as
                         * 0.
                         * - If EAX[3:0] 0001b, then this section has confidentiality and integrity
                         * protection. All other encodings are reserved.
                         */
                        UINT32 EpcSectionProperty : 4;
#define CPUID_ECX_EPC_SECTION_PROPERTY_BIT  0
#define CPUID_ECX_EPC_SECTION_PROPERTY_FLAG 0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY_MASK 0x0F
#define CPUID_ECX_EPC_SECTION_PROPERTY(_)   (((_) >> 0) & 0x0F)
                        UINT32 Reserved1 : 8;

                        /**
                         * [Bits 31:12] Bits 31:12 of the size of the corresponding EPC section
                         * within the Processor Reserved Memory.
                         */
                        UINT32 EpcSize1 : 20;
#define CPUID_ECX_EPC_SIZE_1_BIT  12
#define CPUID_ECX_EPC_SIZE_1_FLAG 0xFFFFF000
#define CPUID_ECX_EPC_SIZE_1_MASK 0xFFFFF
#define CPUID_ECX_EPC_SIZE_1(_)   (((_) >> 12) & 0xFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 19:0] Bits 51:32 of the size of the corresponding EPC section
                         * within the Processor Reserved Memory.
                         */
                        UINT32 EpcSize2 : 20;
#define CPUID_EDX_EPC_SIZE_2_BIT  0
#define CPUID_EDX_EPC_SIZE_2_FLAG 0xFFFFF
#define CPUID_EDX_EPC_SIZE_2_MASK 0xFFFFF
#define CPUID_EDX_EPC_SIZE_2(_)   (((_) >> 0) & 0xFFFFF)
                        UINT32 Reserved1 : 12;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_12_ECX_02P_SLT_1;

/**
 * @}
 */

/**
 * @defgroup CPUID_EAX_14 \
 *           EAX = 0x14
 *
 * When CPUID executes with EAX set to 14H and ECX = 0H, the processor returns information about
 * Intel Processor Trace extensions. When CPUID executes with EAX set to 14H and ECX = n (n > 0 and
 * less than the number of non-zero bits in CPUID.(EAX=14H, ECX= 0H).EAX), the processor returns
 * information about packet generation in Intel Processor Trace.
 * @{
 */
#define CPUID_INTEL_PROCESSOR_TRACE_INFORMATION 0x00000014
/**
 * @brief Intel Processor Trace Enumeration Main Leaf (EAX = 14H, ECX = 0)
 *
 * @note Leaf 14H main leaf (ECX = 0).
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reports the maximum sub-leaf supported in leaf 14H.
                         */
                        UINT32 MaxSubLeaf : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT  0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG 0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK 0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bit 0] If 1, indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and
                         * that IA32_RTIT_CR3_MATCH MSR can be accessed.
                         */
                        UINT32 Flag0 : 1;
#define CPUID_EBX_FLAG0_BIT  0
#define CPUID_EBX_FLAG0_FLAG 0x01
#define CPUID_EBX_FLAG0_MASK 0x01
#define CPUID_EBX_FLAG0(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] If 1, indicates support of Configurable PSB and Cycle-Accurate
                         * Mode.
                         */
                        UINT32 Flag1 : 1;
#define CPUID_EBX_FLAG1_BIT  1
#define CPUID_EBX_FLAG1_FLAG 0x02
#define CPUID_EBX_FLAG1_MASK 0x01
#define CPUID_EBX_FLAG1(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bit 2] If 1, indicates support of IP Filtering, TraceStop filtering, and
                         * preservation of Intel PT MSRs across warm reset.
                         */
                        UINT32 Flag2 : 1;
#define CPUID_EBX_FLAG2_BIT  2
#define CPUID_EBX_FLAG2_FLAG 0x04
#define CPUID_EBX_FLAG2_MASK 0x01
#define CPUID_EBX_FLAG2(_)   (((_) >> 2) & 0x01)

                        /**
                         * [Bit 3] If 1, indicates support of MTC timing packet and suppression of
                         * COFI-based packets.
                         */
                        UINT32 Flag3 : 1;
#define CPUID_EBX_FLAG3_BIT  3
#define CPUID_EBX_FLAG3_FLAG 0x08
#define CPUID_EBX_FLAG3_MASK 0x01
#define CPUID_EBX_FLAG3(_)   (((_) >> 3) & 0x01)

                        /**
                         * [Bit 4] If 1, indicates support of PTWRITE. Writes can set
                         * IA32_RTIT_CTL[12] (PTWEn) and IA32_RTIT_CTL[5] (FUPonPTW), and PTWRITE
                         * can generate packets.
                         */
                        UINT32 Flag4 : 1;
#define CPUID_EBX_FLAG4_BIT  4
#define CPUID_EBX_FLAG4_FLAG 0x10
#define CPUID_EBX_FLAG4_MASK 0x01
#define CPUID_EBX_FLAG4(_)   (((_) >> 4) & 0x01)

                        /**
                         * [Bit 5] If 1, indicates support of Power Event Trace. Writes can set
                         * IA32_RTIT_CTL[4] (PwrEvtEn), enabling Power Event Trace packet
                         * generation.
                         */
                        UINT32 Flag5 : 1;
#define CPUID_EBX_FLAG5_BIT  5
#define CPUID_EBX_FLAG5_FLAG 0x20
#define CPUID_EBX_FLAG5_MASK 0x01
#define CPUID_EBX_FLAG5(_)   (((_) >> 5) & 0x01)

                        /**
                         * [Bit 6] If 1, indicates support for PSB and PH preservation. Writes can
                         * set IA32_RTIT CTL[56] (InjectPsb-PmiOnEnable), enabling the processor to
                         * setIA32_12TIT STATUS[7] (PendTopaPMI) and/or IA32_RTIT_STATUS[6]
                         * (PendPSB) in order to preserve ToPA PMIs and/or PSBs otherwise lost due
                         * to Intel PT disable. Writes can also set PendToPAPMI and PendPSB.
                         */
                        UINT32 Flag6 : 1;
#define CPUID_EBX_FLAG6_BIT  6
#define CPUID_EBX_FLAG6_FLAG 0x40
#define CPUID_EBX_FLAG6_MASK 0x01
#define CPUID_EBX_FLAG6(_)   (((_) >> 6) & 0x01)

                        /**
                         * [Bit 7] If 1, writes can set IA32_RTIT_CTL[31] (EventEn), enabling Event
                         * Trace packet generation.
                         */
                        UINT32 Flag7 : 1;
#define CPUID_EBX_FLAG7_BIT  7
#define CPUID_EBX_FLAG7_FLAG 0x80
#define CPUID_EBX_FLAG7_MASK 0x01
#define CPUID_EBX_FLAG7(_)   (((_) >> 7) & 0x01)

                        /**
                         * [Bit 8] If 1, writes can set IA32_RTIT_CTL[55] (DisTNT), disabling TNT
                         * packet generation.
                         */
                        UINT32 Flag8 : 1;
#define CPUID_EBX_FLAG8_BIT  8
#define CPUID_EBX_FLAG8_FLAG 0x100
#define CPUID_EBX_FLAG8_MASK 0x01
#define CPUID_EBX_FLAG8(_)   (((_) >> 8) & 0x01)
                        UINT32 Reserved1 : 23;
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bit 0] If 1, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence
                         * utilizing the ToPA output scheme; IA32_RTIT_OUTPUT_BASE and
                         * IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed.
                         */
                        UINT32 Flag0 : 1;
#define CPUID_ECX_FLAG0_BIT  0
#define CPUID_ECX_FLAG0_FLAG 0x01
#define CPUID_ECX_FLAG0_MASK 0x01
#define CPUID_ECX_FLAG0(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] If 1, ToPA tables can hold any number of output entries, up to
                         * the maximum allowed by the MaskOrTableOffset field of
                         * IA32_RTIT_OUTPUT_MASK_PTRS.
                         */
                        UINT32 Flag1 : 1;
#define CPUID_ECX_FLAG1_BIT  1
#define CPUID_ECX_FLAG1_FLAG 0x02
#define CPUID_ECX_FLAG1_MASK 0x01
#define CPUID_ECX_FLAG1(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bit 2] If 1, indicates support of Single-Range Output scheme.
                         */
                        UINT32 Flag2 : 1;
#define CPUID_ECX_FLAG2_BIT  2
#define CPUID_ECX_FLAG2_FLAG 0x04
#define CPUID_ECX_FLAG2_MASK 0x01
#define CPUID_ECX_FLAG2(_)   (((_) >> 2) & 0x01)

                        /**
                         * [Bit 3] If 1, indicates support of output to Trace Transport subsystem.
                         */
                        UINT32 Flag3 : 1;
#define CPUID_ECX_FLAG3_BIT  3
#define CPUID_ECX_FLAG3_FLAG 0x08
#define CPUID_ECX_FLAG3_MASK 0x01
#define CPUID_ECX_FLAG3(_)   (((_) >> 3) & 0x01)
                        UINT32 Reserved1 : 27;

                        /**
                         * [Bit 31] If 1, generated packets which contain IP payloads have LIP
                         * values, which include the CS base component.
                         */
                        UINT32 Flag31 : 1;
#define CPUID_ECX_FLAG31_BIT  31
#define CPUID_ECX_FLAG31_FLAG 0x80000000
#define CPUID_ECX_FLAG31_MASK 0x01
#define CPUID_ECX_FLAG31(_)   (((_) >> 31) & 0x01)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EDX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_14_ECX_00;

/**
 * @brief Intel Processor Trace Enumeration Sub-leaf (EAX = 14H, ECX = 1)
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 2:0] Number of configurable Address Ranges for filtering.
                         */
                        UINT32 NumberOfConfigurableAddressRangesForFiltering : 3;
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_BIT  0
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_FLAG 0x07
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING_MASK 0x07
#define CPUID_EAX_NUMBER_OF_CONFIGURABLE_ADDRESS_RANGES_FOR_FILTERING(_)   (((_) >> 0) & 0x07)
                        UINT32 Reserved1 : 13;

                        /**
                         * [Bits 31:16] Bitmap of supported MTC period encodings.
                         */
                        UINT32 BitmapOfSupportedMtcPeriodEncodings : 16;
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_BIT  16
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_FLAG 0xFFFF0000
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS_MASK 0xFFFF
#define CPUID_EAX_BITMAP_OF_SUPPORTED_MTC_PERIOD_ENCODINGS(_)   (((_) >> 16) & 0xFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 15:0] Bitmap of supported Cycle Threshold value encodings.
                         */
                        UINT32 BitmapOfSupportedCycleThresholdValueEncodings : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_BIT  0
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_FLAG 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CYCLE_THRESHOLD_VALUE_ENCODINGS(_)   (((_) >> 0) & 0xFFFF)

                        /**
                         * [Bits 31:16] Bitmap of supported Configurable PSB frequency encodings.
                         */
                        UINT32 BitmapOfSupportedConfigurablePsbFrequencyEncodings : 16;
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_BIT  16
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_FLAG 0xFFFF0000
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS_MASK 0xFFFF
#define CPUID_EBX_BITMAP_OF_SUPPORTED_CONFIGURABLE_PSB_FREQUENCY_ENCODINGS(_)   (((_) >> 16) & 0xFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] ECX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT  0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EDX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_14_ECX_01;

/**
 * @}
 */

/**
 * @brief Stamp Counter and Nominal Core Crystal Clock Information Leaf
 *
 * When CPUID executes with EAX set to 15H and ECX = 0H, the processor returns information about
 * Time Stamp Counter and Core Crystal Clock.
 *
 * @note If EBX[31:0] is 0, the TSC/"core crystal clock" ratio is not enumerated.
 * EBX[31:0]/EAX[31:0] indicates the ratio of the TSC frequency and the core crystal clock
 * frequency. If ECX is 0, the nominal core crystal clock frequency is not enumerated. "TSC
 * frequency" = "core crystal clock frequency" * EBX/EAX.
 */
#define CPUID_TIME_STAMP_COUNTER_INFORMATION 0x00000015
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] An unsigned integer which is the denominator of the TSC/"core
                         * crystal clock" ratio.
                         */
                        UINT32 Denominator : 32;
#define CPUID_EAX_DENOMINATOR_BIT  0
#define CPUID_EAX_DENOMINATOR_FLAG 0xFFFFFFFF
#define CPUID_EAX_DENOMINATOR_MASK 0xFFFFFFFF
#define CPUID_EAX_DENOMINATOR(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] An unsigned integer which is the numerator of the TSC/"core
                         * crystal clock" ratio.
                         */
                        UINT32 Numerator : 32;
#define CPUID_EBX_NUMERATOR_BIT  0
#define CPUID_EBX_NUMERATOR_FLAG 0xFFFFFFFF
#define CPUID_EBX_NUMERATOR_MASK 0xFFFFFFFF
#define CPUID_EBX_NUMERATOR(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] An unsigned integer which is the nominal frequency of the
                         * core crystal clock in Hz.
                         */
                        UINT32 NominalFrequency : 32;
#define CPUID_ECX_NOMINAL_FREQUENCY_BIT  0
#define CPUID_ECX_NOMINAL_FREQUENCY_FLAG 0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY_MASK 0xFFFFFFFF
#define CPUID_ECX_NOMINAL_FREQUENCY(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EDX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_15;

/**
 * @brief Processor Frequency Information Leaf
 *
 * When CPUID executes with EAX set to 16H, the processor returns information about Processor
 * Frequency Information.
 *
 * @note Data is returned from this interface in accordance with the processor's specification and
 * does not reflect actual values. Suitable use of this data includes the display of processor
 * information in like manner to the processor brand string and for determining the appropriate
 * range to use when displaying processor information e.g. frequency history graphs. The returned
 * information should not be used for any other purpose as the returned information does not
 *       accurately correlate to information / counters returned by other processor interfaces.
 *       While a processor may support the Processor Frequency Information leaf, fields that return
 * a value of zero are not supported.
 */
#define CPUID_PROCESSOR_FREQUENCY_INFORMATION 0x00000016
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 15:0] Processor Base Frequency (in MHz).
                         */
                        UINT32 ProcesorBaseFrequencyMhz : 16;
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_BIT  0
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_FLAG 0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ_MASK 0xFFFF
#define CPUID_EAX_PROCESOR_BASE_FREQUENCY_MHZ(_)   (((_) >> 0) & 0xFFFF)
                        UINT32 Reserved1 : 16;
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 15:0] Maximum Frequency (in MHz).
                         */
                        UINT32 ProcessorMaximumFrequencyMhz : 16;
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_BIT  0
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_FLAG 0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ_MASK 0xFFFF
#define CPUID_EBX_PROCESSOR_MAXIMUM_FREQUENCY_MHZ(_)   (((_) >> 0) & 0xFFFF)
                        UINT32 Reserved1 : 16;
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 15:0] Bus (Reference) Frequency (in MHz).
                         */
                        UINT32 BusFrequencyMhz : 16;
#define CPUID_ECX_BUS_FREQUENCY_MHZ_BIT  0
#define CPUID_ECX_BUS_FREQUENCY_MHZ_FLAG 0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ_MASK 0xFFFF
#define CPUID_ECX_BUS_FREQUENCY_MHZ(_)   (((_) >> 0) & 0xFFFF)
                        UINT32 Reserved1 : 16;
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EDX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_16;

/**
 * @defgroup CPUID_EAX_17 \
 *           EAX = 0x17
 *
 * When CPUID executes with EAX set to 17H, the processor returns information about the
 * System-On-Chip Vendor Attribute Enumeration.
 * @{
 */
#define CPUID_SOC_VENDOR_INFORMATION 0x00000017
/**
 * @brief System-On-Chip Vendor Attribute Enumeration Main Leaf (EAX = 17H, ECX = 0)
 *
 * @note Leaf 17H main leaf (ECX = 0). Leaf 17H output depends on the initial value in ECX. Leaf 17H
 * sub-leaves 1 through 3 reports SOC Vendor Brand String. Leaf 17H is valid if MaxSOCID_Index >= 3.
 * Leaf 17H sub-leaves 4 and above are reserved.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf
                         * 17H.
                         */
                        UINT32 MaxSocIdIndex : 32;
#define CPUID_EAX_MAX_SOC_ID_INDEX_BIT  0
#define CPUID_EAX_MAX_SOC_ID_INDEX_FLAG 0xFFFFFFFF
#define CPUID_EAX_MAX_SOC_ID_INDEX_MASK 0xFFFFFFFF
#define CPUID_EAX_MAX_SOC_ID_INDEX(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 15:0] SOC Vendor ID.
                         */
                        UINT32 SocVendorId : 16;
#define CPUID_EBX_SOC_VENDOR_ID_BIT  0
#define CPUID_EBX_SOC_VENDOR_ID_FLAG 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID_MASK 0xFFFF
#define CPUID_EBX_SOC_VENDOR_ID(_)   (((_) >> 0) & 0xFFFF)

                        /**
                         * [Bit 16] If 1, the SOC Vendor ID field is assigned via an industry
                         * standard enumeration scheme. Otherwise, the SOC Vendor ID field is
                         * assigned by Intel.
                         */
                        UINT32 IsVendorScheme : 1;
#define CPUID_EBX_IS_VENDOR_SCHEME_BIT  16
#define CPUID_EBX_IS_VENDOR_SCHEME_FLAG 0x10000
#define CPUID_EBX_IS_VENDOR_SCHEME_MASK 0x01
#define CPUID_EBX_IS_VENDOR_SCHEME(_)   (((_) >> 16) & 0x01)
                        UINT32 Reserved1 : 15;
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] A unique number an SOC vendor assigns to its SOC projects.
                         */
                        UINT32 ProjectId : 32;
#define CPUID_ECX_PROJECT_ID_BIT  0
#define CPUID_ECX_PROJECT_ID_FLAG 0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID_MASK 0xFFFFFFFF
#define CPUID_ECX_PROJECT_ID(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] A unique number within an SOC project that an SOC vendor
                         * assigns.
                         */
                        UINT32 SteppingId : 32;
#define CPUID_EDX_STEPPING_ID_BIT  0
#define CPUID_EDX_STEPPING_ID_FLAG 0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID_MASK 0xFFFFFFFF
#define CPUID_EDX_STEPPING_ID(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_17_ECX_00;

/**
 * @brief System-On-Chip Vendor Attribute Enumeration Sub-leaf (EAX = 17H, ECX = 1..3)
 *
 * @note Leaf 17H output depends on the initial value in ECX. SOC Vendor Brand String is a UTF-8
 * encoded string padded with trailing bytes of 00H. The complete SOC Vendor Brand String is
 * constructed by concatenating in ascending order of EAX:EBX:ECX:EDX and from the sub-leaf 1
 * fragment towards sub-leaf 3.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
                         */
                        UINT32 SocVendorBrandString : 32;
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_BIT  0
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_FLAG 0xFFFFFFFF
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING_MASK 0xFFFFFFFF
#define CPUID_EAX_SOC_VENDOR_BRAND_STRING(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
                         */
                        UINT32 SocVendorBrandString : 32;
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_BIT  0
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_FLAG 0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING_MASK 0xFFFFFFFF
#define CPUID_EBX_SOC_VENDOR_BRAND_STRING(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
                         */
                        UINT32 SocVendorBrandString : 32;
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_BIT  0
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_FLAG 0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING_MASK 0xFFFFFFFF
#define CPUID_ECX_SOC_VENDOR_BRAND_STRING(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] SOC Vendor Brand String. UTF-8 encoded string.
                         */
                        UINT32 SocVendorBrandString : 32;
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_BIT  0
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_FLAG 0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING_MASK 0xFFFFFFFF
#define CPUID_EDX_SOC_VENDOR_BRAND_STRING(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_17_ECX_01_03;

/**
 * @brief System-On-Chip Vendor Attribute Enumeration Sub-leaves (EAX = 17H, ECX > MaxSOCID_Index)
 *
 * @note Leaf 17H output depends on the initial value in ECX.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reserved = 0.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT  0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reserved = 0.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT  0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reserved = 0.
                         */
                        UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT  0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reserved = 0.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_17_ECX_N;

/**
 * @}
 */

/**
 * @defgroup CPUID_EAX_18 \
 *           EAX = 0x18
 *
 * When CPUID executes with EAX set to 18H, the processor returns information about the
 * Deterministic Address Translation Parameters.
 * @{
 */
#define CPUID_DETERMINISTIC_ADDRESS_TRANSLATION_PARAMETERS 0x00000018
/**
 * @brief Deterministic Address Translation Parameters Main Leaf (EAX = 18H, ECX = 0)
 *
 * @note Each sub-leaf enumerates a different address translation structure.
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is
 * invalid if n exceeds the value that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid
 * if EDX[4:0] returns 0. Valid sub-leaves do not need to be contiguous or in any particular order.
 * A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf or than a valid
 * sub-leaf of a higher or lower-level structure.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Reports the maximum input value of supported sub-leaf in leaf
                         * 18H.
                         */
                        UINT32 MaxSubLeaf : 32;
#define CPUID_EAX_MAX_SUB_LEAF_BIT  0
#define CPUID_EAX_MAX_SUB_LEAF_FLAG 0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF_MASK 0xFFFFFFFF
#define CPUID_EAX_MAX_SUB_LEAF(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bit 0] 4K page size entries supported by this structure.
                         */
                        UINT32 PageEntries4KbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT  0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG 0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] 2MB page size entries supported by this structure.
                         */
                        UINT32 PageEntries2MbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT  1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG 0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bit 2] 4MB page size entries supported by this structure.
                         */
                        UINT32 PageEntries4MbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT  2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG 0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_)   (((_) >> 2) & 0x01)

                        /**
                         * [Bit 3] 1 GB page size entries supported by this structure.
                         */
                        UINT32 PageEntries1GbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT  3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG 0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_)   (((_) >> 3) & 0x01)
                        UINT32 Reserved1 : 4;

                        /**
                         * [Bits 10:8] Partitioning (0: Soft partitioning between the logical
                         * processors sharing this structure).
                         */
                        UINT32 Partitioning : 3;
#define CPUID_EBX_PARTITIONING_BIT  8
#define CPUID_EBX_PARTITIONING_FLAG 0x700
#define CPUID_EBX_PARTITIONING_MASK 0x07
#define CPUID_EBX_PARTITIONING(_)   (((_) >> 8) & 0x07)
                        UINT32 Reserved2 : 5;

                        /**
                         * [Bits 31:16] W = Ways of associativity.
                         */
                        UINT32 WaysOfAssociativity00 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_BIT  16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_FLAG 0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00_MASK 0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_00(_)   (((_) >> 16) & 0xFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Number of Sets.
                         */
                        UINT32 NumberOfSets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT  0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG 0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK 0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 4:0] Translation cache type field.
                         * - 00000b: Null (indicates this sub-leaf is not valid).
                         * - 00001b: Data TLB.
                         * - 00010b: Instruction TLB.
                         * - 00011b: Unified TLB.
                         * All other encodings are reserved.
                         *
                         * @note Some unified TLBs will allow a single TLB entry to satisfy data
                         * read/write and instruction fetches. Others will require separate entries
                         * (e.g., one loaded on data read/write and another loaded on an instruction
                         * fetch) . Please see the Intel(R) 64 and IA-32 Architectures Optimization
                         * Reference Manual for details of a particular product.
                         */
                        UINT32 TranslationCacheTypeField : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT  0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG 0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK 0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_)   (((_) >> 0) & 0x1F)

                        /**
                         * [Bits 7:5] Translation cache level (starts at 1).
                         */
                        UINT32 TranslationCacheLevel : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT  5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG 0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK 0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_)   (((_) >> 5) & 0x07)

                        /**
                         * [Bit 8] Fully associative structure.
                         */
                        UINT32 FullyAssociativeStructure : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT  8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG 0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK 0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_)   (((_) >> 8) & 0x01)
                        UINT32 Reserved1 : 5;

                        /**
                         * [Bits 25:14] Maximum number of addressable IDs for logical processors
                         * sharing this translation cache.
                         *
                         * @note Add one to the return value to get the result.
                         */
                        UINT32 MaxAddressableIdsForLogicalProcessors : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT  14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG 0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK 0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_)   (((_) >> 14) & 0xFFF)
                        UINT32 Reserved2 : 6;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_18_ECX_00;

/**
 * @brief Deterministic Address Translation Parameters Sub-leaf (EAX = 18H, ECX >= 1)
 *
 * @note Each sub-leaf enumerates a different address translation structure.
 *       If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is
 * invalid if n exceeds the value that sub-leaf 0 returns in EAX. A sub-leaf index is also invalid
 * if EDX[4:0] returns 0. Valid sub-leaves do not need to be contiguous or in any particular order.
 * A valid sub-leaf may be in a higher input ECX value than an invalid sub-leaf or than a valid
 * sub-leaf of a higher or lower-level structure.
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EAX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT  0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bit 0] 4K page size entries supported by this structure.
                         */
                        UINT32 PageEntries4KbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_BIT  0
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_FLAG 0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_4KB_SUPPORTED(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] 2MB page size entries supported by this structure.
                         */
                        UINT32 PageEntries2MbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_BIT  1
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_FLAG 0x02
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_2MB_SUPPORTED(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bit 2] 4MB page size entries supported by this structure.
                         */
                        UINT32 PageEntries4MbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_BIT  2
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_FLAG 0x04
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_4MB_SUPPORTED(_)   (((_) >> 2) & 0x01)

                        /**
                         * [Bit 3] 1 GB page size entries supported by this structure.
                         */
                        UINT32 PageEntries1GbSupported : 1;
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_BIT  3
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_FLAG 0x08
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED_MASK 0x01
#define CPUID_EBX_PAGE_ENTRIES_1GB_SUPPORTED(_)   (((_) >> 3) & 0x01)
                        UINT32 Reserved1 : 4;

                        /**
                         * [Bits 10:8] Partitioning (0: Soft partitioning between the logical
                         * processors sharing this structure).
                         */
                        UINT32 Partitioning : 3;
#define CPUID_EBX_PARTITIONING_BIT  8
#define CPUID_EBX_PARTITIONING_FLAG 0x700
#define CPUID_EBX_PARTITIONING_MASK 0x07
#define CPUID_EBX_PARTITIONING(_)   (((_) >> 8) & 0x07)
                        UINT32 Reserved2 : 5;

                        /**
                         * [Bits 31:16] W = Ways of associativity.
                         */
                        UINT32 WaysOfAssociativity01 : 16;
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_BIT  16
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_FLAG 0xFFFF0000
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01_MASK 0xFFFF
#define CPUID_EBX_WAYS_OF_ASSOCIATIVITY_01(_)   (((_) >> 16) & 0xFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Number of Sets.
                         */
                        UINT32 NumberOfSets : 32;
#define CPUID_ECX_NUMBER_OF_SETS_BIT  0
#define CPUID_ECX_NUMBER_OF_SETS_FLAG 0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS_MASK 0xFFFFFFFF
#define CPUID_ECX_NUMBER_OF_SETS(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 4:0] Translation cache type field.
                         * - 00000b: Null (indicates this sub-leaf is not valid).
                         * - 00001b: Data TLB.
                         * - 00010b: Instruction TLB.
                         * - 00011b: Unified TLB.
                         * All other encodings are reserved.
                         *
                         * @note Some unified TLBs will allow a single TLB entry to satisfy data
                         * read/write and instruction fetches. Others will require separate entries
                         * (e.g., one loaded on data read/write and another loaded on an instruction
                         * fetch) . Please see the Intel(R) 64 and IA-32 Architectures Optimization
                         * Reference Manual for details of a particular product.
                         */
                        UINT32 TranslationCacheTypeField : 5;
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_BIT  0
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_FLAG 0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD_MASK 0x1F
#define CPUID_EDX_TRANSLATION_CACHE_TYPE_FIELD(_)   (((_) >> 0) & 0x1F)

                        /**
                         * [Bits 7:5] Translation cache level (starts at 1).
                         */
                        UINT32 TranslationCacheLevel : 3;
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_BIT  5
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_FLAG 0xE0
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL_MASK 0x07
#define CPUID_EDX_TRANSLATION_CACHE_LEVEL(_)   (((_) >> 5) & 0x07)

                        /**
                         * [Bit 8] Fully associative structure.
                         */
                        UINT32 FullyAssociativeStructure : 1;
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_BIT  8
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_FLAG 0x100
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE_MASK 0x01
#define CPUID_EDX_FULLY_ASSOCIATIVE_STRUCTURE(_)   (((_) >> 8) & 0x01)
                        UINT32 Reserved1 : 5;

                        /**
                         * [Bits 25:14] Maximum number of addressable IDs for logical processors
                         * sharing this translation cache.
                         *
                         * @note Add one to the return value to get the result.
                         */
                        UINT32 MaxAddressableIdsForLogicalProcessors : 12;
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_BIT  14
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_FLAG 0x3FFC000
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS_MASK 0xFFF
#define CPUID_EDX_MAX_ADDRESSABLE_IDS_FOR_LOGICAL_PROCESSORS(_)   (((_) >> 14) & 0xFFF)
                        UINT32 Reserved2 : 6;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_18_ECX_01P;

/**
 * @}
 */

/**
 * @brief Extended Function CPUID Information
 *
 * When CPUID executes with EAX set to 80000000H, the processor returns the highest value the
 * processor recognizes for returning extended processor information. The value is returned in the
 * EAX register and is processor specific.
 */
#define CPUID_EXTENDED_FUNCTION_INFORMATION 0x80000000
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Maximum Input Value for Extended Function CPUID Information.
                         */
                        UINT32 MaxExtendedFunctions : 32;
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_BIT  0
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_FLAG 0xFFFFFFFF
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS_MASK 0xFFFFFFFF
#define CPUID_EAX_MAX_EXTENDED_FUNCTIONS(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EBX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT  0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] ECX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT  0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EDX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_80000000;

/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_CPU_SIGNATURE 0x80000001
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EAX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT  0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EBX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT  0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bit 0] LAHF/SAHF available in 64-bit mode.
                         */
                        UINT32 LahfSahfAvailableIn64BitMode : 1;
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_BIT  0
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_FLAG 0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE_MASK 0x01
#define CPUID_ECX_LAHF_SAHF_AVAILABLE_IN_64_BIT_MODE(_)   (((_) >> 0) & 0x01)
                        UINT32 Reserved1 : 4;

                        /**
                         * [Bit 5] LZCNT.
                         */
                        UINT32 Lzcnt : 1;
#define CPUID_ECX_LZCNT_BIT  5
#define CPUID_ECX_LZCNT_FLAG 0x20
#define CPUID_ECX_LZCNT_MASK 0x01
#define CPUID_ECX_LZCNT(_)   (((_) >> 5) & 0x01)
                        UINT32 Reserved2 : 2;

                        /**
                         * [Bit 8] PREFETCHW.
                         */
                        UINT32 Prefetchw : 1;
#define CPUID_ECX_PREFETCHW_BIT  8
#define CPUID_ECX_PREFETCHW_FLAG 0x100
#define CPUID_ECX_PREFETCHW_MASK 0x01
#define CPUID_ECX_PREFETCHW(_)   (((_) >> 8) & 0x01)
                        UINT32 Reserved3 : 23;
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        UINT32 Reserved1 : 11;

                        /**
                         * [Bit 11] SYSCALL/SYSRET available in 64-bit mode.
                         */
                        UINT32 SyscallSysretAvailableIn64BitMode : 1;
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_BIT  11
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_FLAG 0x800
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE_MASK 0x01
#define CPUID_EDX_SYSCALL_SYSRET_AVAILABLE_IN_64_BIT_MODE(_)   (((_) >> 11) & 0x01)
                        UINT32 Reserved2 : 8;

                        /**
                         * [Bit 20] Execute Disable Bit available.
                         */
                        UINT32 ExecuteDisableBitAvailable : 1;
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_BIT  20
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_FLAG 0x100000
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE_MASK 0x01
#define CPUID_EDX_EXECUTE_DISABLE_BIT_AVAILABLE(_)   (((_) >> 20) & 0x01)
                        UINT32 Reserved3 : 5;

                        /**
                         * [Bit 26] 1-GByte pages are available if 1.
                         */
                        UINT32 Pages1GbAvailable : 1;
#define CPUID_EDX_PAGES_1GB_AVAILABLE_BIT  26
#define CPUID_EDX_PAGES_1GB_AVAILABLE_FLAG 0x4000000
#define CPUID_EDX_PAGES_1GB_AVAILABLE_MASK 0x01
#define CPUID_EDX_PAGES_1GB_AVAILABLE(_)   (((_) >> 26) & 0x01)

                        /**
                         * [Bit 27] RDTSCP and IA32_TSC_AUX are available if 1.
                         */
                        UINT32 RdtscpAvailable : 1;
#define CPUID_EDX_RDTSCP_AVAILABLE_BIT  27
#define CPUID_EDX_RDTSCP_AVAILABLE_FLAG 0x8000000
#define CPUID_EDX_RDTSCP_AVAILABLE_MASK 0x01
#define CPUID_EDX_RDTSCP_AVAILABLE(_)   (((_) >> 27) & 0x01)
                        UINT32 Reserved4 : 1;

                        /**
                         * [Bit 29] Intel(R) 64 Architecture available if 1.
                         */
                        UINT32 Ia64Available : 1;
#define CPUID_EDX_IA64_AVAILABLE_BIT  29
#define CPUID_EDX_IA64_AVAILABLE_FLAG 0x20000000
#define CPUID_EDX_IA64_AVAILABLE_MASK 0x01
#define CPUID_EDX_IA64_AVAILABLE(_)   (((_) >> 29) & 0x01)
                        UINT32 Reserved5 : 2;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_80000001;

/**
 * Extended Function CPUID Information.
 */
#define CPUID_BRAND_STRING1 0x80000002

/**
 * Extended Function CPUID Information.
 */
#define CPUID_BRAND_STRING2 0x80000003

/**
 * Extended Function CPUID Information.
 */
#define CPUID_BRAND_STRING3 0x80000004
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Processor Brand String.
                         */
                        UINT32 ProcessorBrandString1 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_BIT  0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_FLAG 0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1_MASK 0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_1(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Processor Brand String Continued.
                         */
                        UINT32 ProcessorBrandString2 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_BIT  0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_FLAG 0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2_MASK 0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_2(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Processor Brand String Continued.
                         */
                        UINT32 ProcessorBrandString3 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_BIT  0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_FLAG 0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3_MASK 0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_3(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Processor Brand String Continued.
                         */
                        UINT32 ProcessorBrandString4 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_BIT  0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_FLAG 0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4_MASK 0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_4(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_80000002;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Processor Brand String Continued.
                         */
                        UINT32 ProcessorBrandString5 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_BIT  0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_FLAG 0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5_MASK 0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_5(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Processor Brand String Continued.
                         */
                        UINT32 ProcessorBrandString6 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_BIT  0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_FLAG 0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6_MASK 0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_6(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Processor Brand String Continued.
                         */
                        UINT32 ProcessorBrandString7 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_BIT  0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_FLAG 0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7_MASK 0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_7(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Processor Brand String Continued.
                         */
                        UINT32 ProcessorBrandString8 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_BIT  0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_FLAG 0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8_MASK 0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_8(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_80000003;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Processor Brand String Continued.
                         */
                        UINT32 ProcessorBrandString9 : 32;
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_BIT  0
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_FLAG 0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9_MASK 0xFFFFFFFF
#define CPUID_EAX_PROCESSOR_BRAND_STRING_9(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Processor Brand String Continued.
                         */
                        UINT32 ProcessorBrandString10 : 32;
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_BIT  0
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_FLAG 0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10_MASK 0xFFFFFFFF
#define CPUID_EBX_PROCESSOR_BRAND_STRING_10(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Processor Brand String Continued.
                         */
                        UINT32 ProcessorBrandString11 : 32;
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_BIT  0
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_FLAG 0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11_MASK 0xFFFFFFFF
#define CPUID_ECX_PROCESSOR_BRAND_STRING_11(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] Processor Brand String Continued.
                         */
                        UINT32 ProcessorBrandString12 : 32;
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_BIT  0
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_FLAG 0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12_MASK 0xFFFFFFFF
#define CPUID_EDX_PROCESSOR_BRAND_STRING_12(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_80000004;

/**
 * @brief Extended Function CPUID Information
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EAX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT  0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EBX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT  0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] ECX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT  0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EDX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_80000005;

/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_CACHE_INFO 0x80000006
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EAX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT  0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EBX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT  0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 7:0] Cache Line size in bytes.
                         */
                        UINT32 CacheLineSizeInBytes : 8;
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_BIT  0
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_FLAG 0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES_MASK 0xFF
#define CPUID_ECX_CACHE_LINE_SIZE_IN_BYTES(_)   (((_) >> 0) & 0xFF)
                        UINT32 Reserved1 : 4;

                        /**
                         * [Bits 15:12] L2 Associativity field.
                         * L2 associativity field encodings:
                         * - 00H - Disabled.
                         * - 01H - Direct mapped.
                         * - 02H - 2-way.
                         * - 04H - 4-way.
                         * - 06H - 8-way.
                         * - 08H - 16-way.
                         * - 0FH - Fully associative.
                         */
                        UINT32 L2AssociativityField : 4;
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_BIT  12
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_FLAG 0xF000
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD_MASK 0x0F
#define CPUID_ECX_L2_ASSOCIATIVITY_FIELD(_)   (((_) >> 12) & 0x0F)

                        /**
                         * [Bits 31:16] Cache size in 1K units.
                         */
                        UINT32 CacheSizeIn1KUnits : 16;
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_BIT  16
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_FLAG 0xFFFF0000
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS_MASK 0xFFFF
#define CPUID_ECX_CACHE_SIZE_IN_1K_UNITS(_)   (((_) >> 16) & 0xFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EDX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_80000006;

/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_TIME_STAMP_COUNTER 0x80000007
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EAX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EAX_RESERVED_BIT  0
#define CPUID_EAX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EAX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EAX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EBX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT  0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] ECX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT  0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        UINT32 Reserved1 : 8;

                        /**
                         * [Bit 8] Invariant TSC available if 1.
                         */
                        UINT32 InvariantTscAvailable : 1;
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_BIT  8
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_FLAG 0x100
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE_MASK 0x01
#define CPUID_EDX_INVARIANT_TSC_AVAILABLE(_)   (((_) >> 8) & 0x01)
                        UINT32 Reserved2 : 23;
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_80000007;

/**
 * Extended Function CPUID Information.
 */
#define CPUID_EXTENDED_VIRTUAL_PHYSICAL_ADDRESS_SIZE 0x80000008
typedef struct
{
        /**
         * @brief Linear/Physical Address size
         */
        union
        {
                struct
                {
                        /**
                         * [Bits 7:0] Number of Physical Address Bits.
                         */
                        UINT32 NumberOfPhysicalAddressBits : 8;
#define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS_BIT  0
#define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS_FLAG 0xFF
#define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS_MASK 0xFF
#define CPUID_EAX_NUMBER_OF_PHYSICAL_ADDRESS_BITS(_)   (((_) >> 0) & 0xFF)

                        /**
                         * [Bits 15:8] Number of Linear Address Bits.
                         */
                        UINT32 NumberOfLinearAddressBits : 8;
#define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_BIT  8
#define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_FLAG 0xFF00
#define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS_MASK 0xFF
#define CPUID_EAX_NUMBER_OF_LINEAR_ADDRESS_BITS(_)   (((_) >> 8) & 0xFF)
                        UINT32 Reserved1 : 16;
                };

                UINT32 AsUInt;
        } Eax;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EBX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EBX_RESERVED_BIT  0
#define CPUID_EBX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EBX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EBX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ebx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] ECX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_ECX_RESERVED_BIT  0
#define CPUID_ECX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_ECX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_ECX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Ecx;

        union
        {
                struct
                {
                        /**
                         * [Bits 31:0] EDX is reserved.
                         */
                        UINT32 Reserved : 32;
#define CPUID_EDX_RESERVED_BIT  0
#define CPUID_EDX_RESERVED_FLAG 0xFFFFFFFF
#define CPUID_EDX_RESERVED_MASK 0xFFFFFFFF
#define CPUID_EDX_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)
                };

                UINT32 AsUInt;
        } Edx;

} CPUID_EAX_80000008;

/**
 * @}
 */

/**
 * @defgroup MODEL_SPECIFIC_REGISTERS \
 *           Model Specific Registers
 *
 * @see Vol2A[3.2(CPUID)] (reference)
 * @{
 */
/**
 * @defgroup IA32_P5_MC \
 *           IA32_P5_MC_(x)
 *
 * When machine-check exceptions are enabled for the Pentium processor (MCE flag is set in control
 * register CR4), the machine-check exception handler uses the RDMSR instruction to read the error
 * type from the P5_MC_TYPE register and the machine check address from the P5_MC_ADDR register. The
 * handler then normally reports these register values to the system console before aborting
 * execution.
 *
 * @see Vol3B[15.10.2(Pentium Processor Machine-Check Exception Handling)] (reference)
 * @{
 */
/**
 * Machine-check exception address.
 *
 * @remarks 05_01H
 * @see Vol4[2.22(MSRS IN PENTIUM PROCESSORS)]
 */
#define IA32_P5_MC_ADDR 0x00000000

/**
 * Machine-check exception type.
 *
 * @remarks 05_01H
 * @see Vol4[2.22(MSRS IN PENTIUM PROCESSORS)]
 */
#define IA32_P5_MC_TYPE 0x00000001
/**
 * @}
 */

/**
 * System coherence line size.
 *
 * @remarks 0F_03H
 * @see Vol3A[8.10.5(Monitor/Mwait Address Range Determination)]
 * @see Vol3A[8.10.5(Monitor/Mwait Address Range Determination)] (reference)
 */
#define IA32_MONITOR_FILTER_LINE_SIZE 0x00000006

/**
 * Value as returned by instruction RDTSC.
 *
 * @remarks 05_01H
 * @see Vol3B[17.17(TIME-STAMP COUNTER)]
 */
#define IA32_TIME_STAMP_COUNTER 0x00000010

/**
 * The operating system can use this MSR to determine "slot" information for the processor and the
 * proper microcode update to load.
 *
 * @remarks 06_01H
 */
#define IA32_PLATFORM_ID 0x00000017
typedef union
{
        struct
        {
                UINT64 Reserved1 : 50;

                /**
                 * @brief Platform Id <b>(RO)</b>
                 *
                 * [Bits 52:50] Contains information concerning the intended platform for the
                 * processor.
                 *
                 *
                 * 52 | 51 | 50 | _
                 * --:|:--:|:---|-----------------
                 * 0  | 0  | 0  | Processor Flag 0
                 * 0  | 0  | 1  | Processor Flag 1
                 * 0  | 1  | 0  | Processor Flag 2
                 * 0  | 1  | 1  | Processor Flag 3
                 * 1  | 0  | 0  | Processor Flag 4
                 * 1  | 0  | 1  | Processor Flag 5
                 * 1  | 1  | 0  | Processor Flag 6
                 * 1  | 1  | 1  | Processor Flag 7
                 */
                UINT64 PlatformId : 3;
#define IA32_PLATFORM_ID_PLATFORM_ID_BIT  50
#define IA32_PLATFORM_ID_PLATFORM_ID_FLAG 0x1C000000000000
#define IA32_PLATFORM_ID_PLATFORM_ID_MASK 0x07
#define IA32_PLATFORM_ID_PLATFORM_ID(_)   (((_) >> 50) & 0x07)
                UINT64 Reserved2 : 11;
        };

        UINT64 AsUInt;
} IA32_PLATFORM_ID_REGISTER;

/**
 * This register holds the APIC base address, permitting the relocation of the APIC memory map.
 *
 * @remarks 06_01H
 * @see Vol3A[10.4.4(Local APIC Status and Location)]
 * @see Vol3A[10.4.5(Relocating the Local APIC Registers)]
 */
#define IA32_APIC_BASE 0x0000001B
typedef union
{
        struct
        {
                UINT64 Reserved1 : 8;

                /**
                 * [Bit 8] BSP flag.
                 */
                UINT64 BspFlag : 1;
#define IA32_APIC_BASE_BSP_FLAG_BIT  8
#define IA32_APIC_BASE_BSP_FLAG_FLAG 0x100
#define IA32_APIC_BASE_BSP_FLAG_MASK 0x01
#define IA32_APIC_BASE_BSP_FLAG(_)   (((_) >> 8) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * [Bit 10] Enable x2APIC mode.
                 */
                UINT64 EnableX2ApicMode : 1;
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_BIT  10
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_FLAG 0x400
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE_MASK 0x01
#define IA32_APIC_BASE_ENABLE_X2APIC_MODE(_)   (((_) >> 10) & 0x01)

                /**
                 * [Bit 11] APIC Global Enable.
                 */
                UINT64 ApicGlobalEnable : 1;
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_BIT  11
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_FLAG 0x800
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE_MASK 0x01
#define IA32_APIC_BASE_APIC_GLOBAL_ENABLE(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bits 47:12] APIC Base.
                 */
                UINT64 ApicBase : 36;
#define IA32_APIC_BASE_APIC_BASE_BIT  12
#define IA32_APIC_BASE_APIC_BASE_FLAG 0xFFFFFFFFF000
#define IA32_APIC_BASE_APIC_BASE_MASK 0xFFFFFFFFF
#define IA32_APIC_BASE_APIC_BASE(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved3 : 16;
        };

        UINT64 AsUInt;
} IA32_APIC_BASE_REGISTER;

/**
 * Control Features in Intel 64 Processor.
 *
 * @remarks If any one enumeration condition for defined bit field holds.
 */
#define IA32_FEATURE_CONTROL 0x0000003A
typedef union
{
        struct
        {
                /**
                 * @brief Lock bit <b>(R/WO)</b>
                 *
                 * [Bit 0] When set, locks this MSR from being written; writes to this bit will
                 * result in GP(0).
                 *
                 * @note Once the Lock bit is set, the contents of this register cannot be modified.
                 * Therefore the lock bit must be set after configuring support for Intel
                 * Virtualization Technology and prior to transferring control to an option ROM or
                 * the OS. Hence, once the Lock bit is set, the entire IA32_FEATURE_CONTROL contents
                 * are preserved across RESET when PWRGOOD is not deasserted.
                 * @remarks If any one enumeration condition for defined bit field position greater
                 * than bit 0 holds.
                 */
                UINT64 LockBit : 1;
#define IA32_FEATURE_CONTROL_LOCK_BIT_BIT  0
#define IA32_FEATURE_CONTROL_LOCK_BIT_FLAG 0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT_MASK 0x01
#define IA32_FEATURE_CONTROL_LOCK_BIT(_)   (((_) >> 0) & 0x01)

                /**
                 * @brief Enable VMX inside SMX operation <b>(R/WL)</b>
                 *
                 * [Bit 1] This bit enables a system executive to use VMX in conjunction with SMX to
                 * support Intel(R) Trusted Execution Technology. BIOS must set this bit only when
                 * the CPUID function 1 returns VMX feature flag and SMX feature flag set (ECX bits
                 * 5 and 6 respectively).
                 *
                 * @remarks If CPUID.01H:ECX[5] = 1 && CPUID.01H:ECX[6] = 1
                 */
                UINT64 EnableVmxInsideSmx : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_BIT  1
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_FLAG 0x02
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX_MASK 0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_INSIDE_SMX(_)   (((_) >> 1) & 0x01)

                /**
                 * @brief Enable VMX outside SMX operation <b>(R/WL)</b>
                 *
                 * [Bit 2] This bit enables VMX for a system executive that does not require SMX.
                 * BIOS must set this bit only when the CPUID function 1 returns the VMX feature
                 * flag set (ECX bit 5).
                 *
                 * @remarks If CPUID.01H:ECX[5] = 1
                 */
                UINT64 EnableVmxOutsideSmx : 1;
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_BIT  2
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_FLAG 0x04
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX_MASK 0x01
#define IA32_FEATURE_CONTROL_ENABLE_VMX_OUTSIDE_SMX(_)   (((_) >> 2) & 0x01)
                UINT64 Reserved1 : 5;

                /**
                 * @brief SENTER Local Function Enable <b>(R/WL)</b>
                 *
                 * [Bits 14:8] When set, each bit in the field represents an enable control for a
                 * corresponding SENTER function. This field is supported only if CPUID.1:ECX.[bit
                 * 6] is set.
                 *
                 * @remarks If CPUID.01H:ECX[6] = 1
                 */
                UINT64 SenterLocalFunctionEnables : 7;
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_BIT  8
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_FLAG 0x7F00
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES_MASK 0x7F
#define IA32_FEATURE_CONTROL_SENTER_LOCAL_FUNCTION_ENABLES(_)   (((_) >> 8) & 0x7F)

                /**
                 * @brief SENTER Global Enable <b>(R/WL)</b>
                 *
                 * [Bit 15] This bit must be set to enable SENTER leaf functions. This bit is
                 * supported only if CPUID.1:ECX.[bit 6] is set.
                 *
                 * @remarks If CPUID.01H:ECX[6] = 1
                 */
                UINT64 SenterGlobalEnable : 1;
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_BIT  15
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_FLAG 0x8000
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE_MASK 0x01
#define IA32_FEATURE_CONTROL_SENTER_GLOBAL_ENABLE(_)   (((_) >> 15) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * @brief SGX Launch Control Enable <b>(R/WL)</b>
                 *
                 * [Bit 17] This bit must be set to enable runtime reconfiguration of SGX Launch
                 * Control via the IA32_SGXLEPUBKEYHASHn MSR.
                 *
                 * @remarks If CPUID.(EAX=07H, ECX=0H): ECX[30] = 1
                 */
                UINT64 SgxLaunchControlEnable : 1;
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_BIT  17
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_FLAG 0x20000
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE_MASK 0x01
#define IA32_FEATURE_CONTROL_SGX_LAUNCH_CONTROL_ENABLE(_)   (((_) >> 17) & 0x01)

                /**
                 * @brief SGX Global Enable <b>(R/WL)</b>
                 *
                 * [Bit 18] This bit must be set to enable SGX leaf functions.
                 *
                 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[2] = 1
                 */
                UINT64 SgxGlobalEnable : 1;
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_BIT  18
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_FLAG 0x40000
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE_MASK 0x01
#define IA32_FEATURE_CONTROL_SGX_GLOBAL_ENABLE(_)   (((_) >> 18) & 0x01)
                UINT64 Reserved3 : 1;

                /**
                 * @brief LMCE On <b>(R/WL)</b>
                 *
                 * [Bit 20] When set, system software can program the MSRs associated with LMCE to
                 * configure delivery of some machine check exceptions to a single logical
                 * processor.
                 *
                 * @remarks If IA32_MCG_CAP[27] = 1
                 */
                UINT64 LmceOn : 1;
#define IA32_FEATURE_CONTROL_LMCE_ON_BIT  20
#define IA32_FEATURE_CONTROL_LMCE_ON_FLAG 0x100000
#define IA32_FEATURE_CONTROL_LMCE_ON_MASK 0x01
#define IA32_FEATURE_CONTROL_LMCE_ON(_)   (((_) >> 20) & 0x01)
                UINT64 Reserved4 : 43;
        };

        UINT64 AsUInt;
} IA32_FEATURE_CONTROL_REGISTER;

/**
 * Per Logical Processor TSC Adjust.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[1] = 1
 */
#define IA32_TSC_ADJUST 0x0000003B
typedef struct
{
        /**
         * Local offset value of the IA32_TSC for a logical processor. Reset value is zero. A write
         * to IA32_TSC will modify the local offset in IA32_TSC_ADJUST and the content of IA32_TSC,
         * but does not affect the internal invariant TSC hardware.
         */
        UINT64 ThreadAdjust;
} IA32_TSC_ADJUST_REGISTER;

/**
 * Speculation Control. The MSR bits are defined as logical processor scope. On some core
 * implementations, the bits may impact sibling logical processors on the same core. This MSR has a
 * value of 0 after reset and is unaffected by INIT\# or SIPI\#.
 *
 * @remarks If any one of the enumeration conditions for defined bit field positions holds.
 */
#define IA32_SPEC_CTRL 0x00000048
typedef union
{
        struct
        {
                /**
                 * [Bit 0] IBRS: Indirect Branch Restricted Speculation (IBRS). Restricts
                 * speculation of indirect branch.
                 *
                 * @remarks If CPUID.(EAX=07H,ECX=0):EDX[26]=1
                 */
                UINT64 Ibrs : 1;
#define IA32_SPEC_CTRL_IBRS_BIT  0
#define IA32_SPEC_CTRL_IBRS_FLAG 0x01
#define IA32_SPEC_CTRL_IBRS_MASK 0x01
#define IA32_SPEC_CTRL_IBRS(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] STIBP: Single Thread Indirect Branch Predictors (STIBP). Prevents
                 * indirect branch predictions on all logical processors on the core from being
                 * controlled by any sibling logical processor in the same core.
                 *
                 * @remarks If CPUID.(EAX=07H,ECX=0):EDX[27]=1
                 */
                UINT64 Stibp : 1;
#define IA32_SPEC_CTRL_STIBP_BIT  1
#define IA32_SPEC_CTRL_STIBP_FLAG 0x02
#define IA32_SPEC_CTRL_STIBP_MASK 0x01
#define IA32_SPEC_CTRL_STIBP(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] SSBD: Speculative Store Bypass Disable (SSBD). Delays speculative
                 * execution of a load until the addresses for all older stores are known.
                 *
                 * @remarks If CPUID.(EAX=07H,ECX=0):EDX[31]=1
                 */
                UINT64 Ssbd : 1;
#define IA32_SPEC_CTRL_SSBD_BIT  2
#define IA32_SPEC_CTRL_SSBD_FLAG 0x04
#define IA32_SPEC_CTRL_SSBD_MASK 0x01
#define IA32_SPEC_CTRL_SSBD(_)   (((_) >> 2) & 0x01)
                UINT64 Reserved1 : 61;
        };

        UINT64 AsUInt;
} IA32_SPEC_CTRL_REGISTER;

/**
 * Prediction Command. Gives software a way to issue commands that affect the state of predictors.
 *
 * @remarks If any one of the enumeration conditions for defined bit field positions holds.
 */
#define IA32_PRED_CMD 0x00000049
typedef union
{
        struct
        {
                /**
                 * [Bit 0] IBPB: Indirect Branch Prediction Barrier (IBPB).
                 *
                 * @remarks If CPUID.(EAX=07H,ECX=0):EDX[26]=1
                 */
                UINT64 Ibpb : 1;
#define IA32_PRED_CMD_IBPB_BIT  0
#define IA32_PRED_CMD_IBPB_FLAG 0x01
#define IA32_PRED_CMD_IBPB_MASK 0x01
#define IA32_PRED_CMD_IBPB(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 63;
        };

        UINT64 AsUInt;
} IA32_PRED_CMD_REGISTER;

/**
 * @brief BIOS Update Trigger <b>(W)</b>
 *
 * Executing a WRMSR instruction to this MSR causes a microcode update to be loaded into the
 * processor. A processor may prevent writing to this MSR when loading guest states on VM entries or
 * saving guest states on VM exits.
 *
 * @remarks 06_01H
 * @see Vol3A[9.11.6(Microcode Update Loader)]
 */
#define IA32_BIOS_UPDATE_TRIGGER 0x00000079

/**
 * @brief BIOS Update Signature <b>(RO)</b>
 *
 * Returns the microcode update signature following the execution of CPUID.01H. A processor may
 * prevent writing to this MSR when loading guest states on VM entries or saving guest states on VM
 * exits.
 *
 * @remarks 06_01H
 */
#define IA32_BIOS_UPDATE_SIGNATURE 0x0000008B
typedef union
{
        struct
        {
                /**
                 * [Bits 31:0] Reserved.
                 */
                UINT64 Reserved : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_BIT  0
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_FLAG 0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED_MASK 0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFF)

                /**
                 * @brief Microcode update signature
                 *
                 * [Bits 63:32] This field contains the signature of the currently loaded microcode
                 * update when read following the execution of the CPUID instruction, function 1. It
                 * is required that this register field be pre-loaded with zero prior to executing
                 * the CPUID, function 1. If the field remains equal to zero, then there is no
                 * microcode update loaded. Another nonzero value will be the signature.
                 *
                 * @see Vol3A[9.11.7.1(Determining the Signature)] (reference)
                 */
                UINT64 MicrocodeUpdateSignature : 32;
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_BIT  32
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_FLAG 0xFFFFFFFF00000000
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE_MASK 0xFFFFFFFF
#define IA32_BIOS_UPDATE_SIGNATURE_MICROCODE_UPDATE_SIGNATURE(_)   (((_) >> 32) & 0xFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_BIOS_UPDATE_SIGNATURE_REGISTER;

/**
 * @defgroup IA32_SGXLEPUBKEYHASH \
 *           IA32_SGXLEPUBKEYHASH[(64*n+63):(64*n)]
 *
 * Bits (64*n+63):(64*n) of the SHA256 digest of the SIGSTRUCT.MODULUS for SGX Launch Enclave. On
 * reset, the default value is the digest of Intel's signing key.
 *
 * @remarks Read permitted If CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && CPUID.(EAX=07H,ECX=0H):ECX[30]=1.
 * Write permitted if CPUID.(EAX=12H,ECX=0H): EAX[0]=1 && IA32_FEATURE_CONTROL[17] = 1 &&
 * IA32_FEATURE_CONTROL[0] = 1.
 * @{
 */
#define IA32_SGXLEPUBKEYHASH0 0x0000008C
#define IA32_SGXLEPUBKEYHASH1 0x0000008D
#define IA32_SGXLEPUBKEYHASH2 0x0000008E
#define IA32_SGXLEPUBKEYHASH3 0x0000008F
/**
 * @}
 */

/**
 * SMM Monitor Configuration.
 *
 * @remarks If CPUID.01H: ECX[5]=1 || CPUID.01H: ECX[6] = 1
 */
#define IA32_SMM_MONITOR_CTL 0x0000009B
typedef union
{
        struct
        {
                /**
                 * @brief Valid <b>(R/W)</b>
                 *
                 * [Bit 0] The STM may be invoked using VMCALL only if this bit is 1. Because VMCALL
                 * is used to activate the dual-monitor treatment, the dual-monitor treatment cannot
                 * be activated if the bit is 0. This bit is cleared when the logical processor is
                 * reset.
                 *
                 * @see Vol3C[34.15.6(Activating the Dual-Monitor Treatment)]
                 * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
                 */
                UINT64 Valid : 1;
#define IA32_SMM_MONITOR_CTL_VALID_BIT  0
#define IA32_SMM_MONITOR_CTL_VALID_FLAG 0x01
#define IA32_SMM_MONITOR_CTL_VALID_MASK 0x01
#define IA32_SMM_MONITOR_CTL_VALID(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 1;

                /**
                 * @brief Controls SMI unblocking by VMXOFF
                 *
                 * [Bit 2] Determines whether executions of VMXOFF unblock SMIs under the default
                 * treatment of SMIs and SMM. Executions of VMXOFF unblock SMIs unless bit 2 is 1
                 * (the value of bit 0 is irrelevant).
                 *
                 * @remarks If IA32_VMX_MISC[28]
                 * @see Vol3C[34.14.4(VMXOFF and SMI Unblocking)]
                 * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
                 */
                UINT64 SmiUnblockingByVmxoff : 1;
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_BIT  2
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_FLAG 0x04
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF_MASK 0x01
#define IA32_SMM_MONITOR_CTL_SMI_UNBLOCKING_BY_VMXOFF(_)   (((_) >> 2) & 0x01)
                UINT64 Reserved2 : 9;

                /**
                 * @brief MSEG Base <b>(R/W)</b>
                 *
                 * [Bits 31:12] Value that, when shifted left 12 bits, is the physical address of
                 * MSEG (the MSEG base address).
                 *
                 * @see Vol3C[34.15.5(Enabling the Dual-Monitor Treatment)] (reference)
                 */
                UINT64 MsegBase : 20;
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_BIT  12
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_FLAG 0xFFFFF000
#define IA32_SMM_MONITOR_CTL_MSEG_BASE_MASK 0xFFFFF
#define IA32_SMM_MONITOR_CTL_MSEG_BASE(_)   (((_) >> 12) & 0xFFFFF)
                UINT64 Reserved3 : 32;
        };

        UINT64 AsUInt;
} IA32_SMM_MONITOR_CTL_REGISTER;

typedef struct
{
        /**
         * @brief MSEG revision identifier
         *
         * Different processors may use different MSEG revision identifiers. These identifiers
         * enable software to avoid using an MSEG header formatted for one processor on a processor
         * that uses a different format. Software can discover the MSEG revision identifier that a
         * processor uses by reading the VMX capability MSR IA32_VMX_MISC.
         *
         * @see Vol3D[A.6(MISCELLANEOUS DATA)]
         */
        UINT32 MsegHeaderRevision;

        /**
         * @brief SMM-transfer monitor features field
         *
         * Bits 31:1 of this field are reserved and must be zero. Bit 0 of the field is the IA-32e
         * mode SMM feature bit. It indicates whether the logical processor will be in IA-32e mode
         * after the STM is activated.
         *
         * @see Vol3C[34.15.6(Activating the Dual-Monitor Treatment)]
         */
        UINT32 MonitorFeatures;

        /**
         * Define values for the MonitorFeatures field of MSEG_HEADER.
         */
#define IA32_STM_FEATURES_IA32E 0x00000001

        /**
         * Fields that determine how processor state is loaded when the STM is activated. SMM code
         * should establish these fields so that activating of the STM invokes the STM's
         * initialization code.
         *
         * @see Vol3C[34.15.6.5(Loading Host State)]
         */
        UINT32 GdtrLimit;
        UINT32 GdtrBaseOffset;
        UINT32 CsSelector;
        UINT32 EipOffset;
        UINT32 EspOffset;
        UINT32 Cr3Offset;
} IA32_MSEG_HEADER;

/**
 * Base address of the logical processor's SMRAM image.
 *
 * @remarks If IA32_VMX_MISC[15]
 */
#define IA32_SMBASE 0x0000009E
/**
 * @defgroup IA32_PMC \
 *           IA32_PMC(n)
 *
 * General Performance Counters.
 *
 * @remarks If CPUID.0AH: EAX[15:8] > n
 * @{
 */
#define IA32_PMC0 0x000000C1
#define IA32_PMC1 0x000000C2
#define IA32_PMC2 0x000000C3
#define IA32_PMC3 0x000000C4
#define IA32_PMC4 0x000000C5
#define IA32_PMC5 0x000000C6
#define IA32_PMC6 0x000000C7
#define IA32_PMC7 0x000000C8
/**
 * @}
 */

/**
 * TSC Frequency Clock Counter.
 *
 * @remarks If CPUID.06H: ECX[0] = 1
 */
#define IA32_MPERF 0x000000E7
typedef struct
{
        /**
         * @brief C0 TSC Frequency Clock Count
         *
         * Increments at fixed interval (relative to TSC freq.) when the logical processor is in C0.
         * Cleared upon overflow / wrap-around of IA32_APERF.
         */
        UINT64 C0Mcnt;
} IA32_MPERF_REGISTER;

/**
 * Actual Performance Clock Counter
 *
 * @remarks If CPUID.06H: ECX[0] = 1
 */
#define IA32_APERF 0x000000E8
typedef struct
{
        /**
         * @brief C0 Actual Frequency Clock Count
         *
         * Accumulates core clock counts at the coordinated clock frequency, when the logical
         * processor is in C0. Cleared upon overflow / wrap-around of IA32_MPERF.
         */
        UINT64 C0Acnt;
} IA32_APERF_REGISTER;

/**
 * MTRR Capability.
 *
 * @see Vol3A[11.11.2.1(IA32_MTRR_DEF_TYPE MSR)]
 * @see Vol3A[11.11.1(MTRR Feature Identification)] (reference)
 */
#define IA32_MTRR_CAPABILITIES 0x000000FE
typedef union
{
        struct
        {
                /**
                 * @brief VCNT (variable range registers count) field
                 *
                 * [Bits 7:0] Indicates the number of variable ranges implemented on the processor.
                 */
                UINT64 VariableRangeCount : 8;
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_BIT  0
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_FLAG 0xFF
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT_MASK 0xFF
#define IA32_MTRR_CAPABILITIES_VARIABLE_RANGE_COUNT(_)   (((_) >> 0) & 0xFF)

                /**
                 * @brief FIX (fixed range registers supported) flag
                 *
                 * [Bit 8] Fixed range MTRRs (IA32_MTRR_FIX64K_00000 through IA32_MTRR_FIX4K_0F8000)
                 * are supported when set; no fixed range registers are supported when clear.
                 */
                UINT64 FixedRangeSupported : 1;
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_BIT  8
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_FLAG 0x100
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED_MASK 0x01
#define IA32_MTRR_CAPABILITIES_FIXED_RANGE_SUPPORTED(_)   (((_) >> 8) & 0x01)
                UINT64 Reserved1 : 1;

                /**
                 * @brief WC (write combining) flag
                 *
                 * [Bit 10] The write-combining (WC) memory type is supported when set; the WC type
                 * is not supported when clear.
                 */
                UINT64 WcSupported : 1;
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_BIT  10
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_FLAG 0x400
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED_MASK 0x01
#define IA32_MTRR_CAPABILITIES_WC_SUPPORTED(_)   (((_) >> 10) & 0x01)

                /**
                 * @brief SMRR (System-Management Range Register) flag
                 *
                 * [Bit 11] The system-management range register (SMRR) interface is supported when
                 * bit 11 is set; the SMRR interface is not supported when clear.
                 */
                UINT64 SmrrSupported : 1;
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_BIT  11
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_FLAG 0x800
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED_MASK 0x01
#define IA32_MTRR_CAPABILITIES_SMRR_SUPPORTED(_)   (((_) >> 11) & 0x01)
                UINT64 Reserved2 : 52;
        };

        UINT64 AsUInt;
} IA32_MTRR_CAPABILITIES_REGISTER;

/**
 * Enumeration of Architectural Features.
 *
 * @remarks If CPUID.(EAX=07H,ECX=0):EDX[29]=1
 */
#define IA32_ARCH_CAPABILITIES 0x0000010A
typedef union
{
        struct
        {
                /**
                 * [Bit 0] RDCL_NO: The processor is not susceptible to Rogue Data Cache Load
                 * (RDCL).
                 */
                UINT64 RdclNo : 1;
#define IA32_ARCH_CAPABILITIES_RDCL_NO_BIT  0
#define IA32_ARCH_CAPABILITIES_RDCL_NO_FLAG 0x01
#define IA32_ARCH_CAPABILITIES_RDCL_NO_MASK 0x01
#define IA32_ARCH_CAPABILITIES_RDCL_NO(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] IBRS_ALL: The processor supports enhanced IBRS.
                 */
                UINT64 IbrsAll : 1;
#define IA32_ARCH_CAPABILITIES_IBRS_ALL_BIT  1
#define IA32_ARCH_CAPABILITIES_IBRS_ALL_FLAG 0x02
#define IA32_ARCH_CAPABILITIES_IBRS_ALL_MASK 0x01
#define IA32_ARCH_CAPABILITIES_IBRS_ALL(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] RSBA: The processor supports RSB Alternate. Alternative branch predictors
                 * may be used by RET instructions when the RSB is empty. SW using retpoline may be
                 * affected by this behavior.
                 */
                UINT64 Rsba : 1;
#define IA32_ARCH_CAPABILITIES_RSBA_BIT  2
#define IA32_ARCH_CAPABILITIES_RSBA_FLAG 0x04
#define IA32_ARCH_CAPABILITIES_RSBA_MASK 0x01
#define IA32_ARCH_CAPABILITIES_RSBA(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] SKIP_L1DFL_VMENTRY: A value of 1 indicates the hypervisor need not flush
                 * the L1D on VM entry.
                 */
                UINT64 SkipL1DflVmentry : 1;
#define IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY_BIT  3
#define IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY_FLAG 0x08
#define IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY_MASK 0x01
#define IA32_ARCH_CAPABILITIES_SKIP_L1DFL_VMENTRY(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] SSB_NO: Processor is not susceptible to Speculative Store Bypass.
                 */
                UINT64 SsbNo : 1;
#define IA32_ARCH_CAPABILITIES_SSB_NO_BIT  4
#define IA32_ARCH_CAPABILITIES_SSB_NO_FLAG 0x10
#define IA32_ARCH_CAPABILITIES_SSB_NO_MASK 0x01
#define IA32_ARCH_CAPABILITIES_SSB_NO(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] MDS_NO: Processor is not susceptible to Microarchitectural Data Sampling
                 * (MDS).
                 */
                UINT64 MdsNo : 1;
#define IA32_ARCH_CAPABILITIES_MDS_NO_BIT  5
#define IA32_ARCH_CAPABILITIES_MDS_NO_FLAG 0x20
#define IA32_ARCH_CAPABILITIES_MDS_NO_MASK 0x01
#define IA32_ARCH_CAPABILITIES_MDS_NO(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] IF_PSCHANGE_MC_NO: The processor is not susceptible to a machine check
                 * error due to modifying the size of a code page without TLB invalidation.
                 */
                UINT64 IfPschangeMcNo : 1;
#define IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO_BIT  6
#define IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO_FLAG 0x40
#define IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO_MASK 0x01
#define IA32_ARCH_CAPABILITIES_IF_PSCHANGE_MC_NO(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] TSX_CTRL: If 1, indicates presence of IA32_TSX_CTRL MSR.
                 */
                UINT64 TsxCtrl : 1;
#define IA32_ARCH_CAPABILITIES_TSX_CTRL_BIT  7
#define IA32_ARCH_CAPABILITIES_TSX_CTRL_FLAG 0x80
#define IA32_ARCH_CAPABILITIES_TSX_CTRL_MASK 0x01
#define IA32_ARCH_CAPABILITIES_TSX_CTRL(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] TAA_NO: If 1, processor is not affected by TAA.
                 */
                UINT64 TaaNo : 1;
#define IA32_ARCH_CAPABILITIES_TAA_NO_BIT  8
#define IA32_ARCH_CAPABILITIES_TAA_NO_FLAG 0x100
#define IA32_ARCH_CAPABILITIES_TAA_NO_MASK 0x01
#define IA32_ARCH_CAPABILITIES_TAA_NO(_)   (((_) >> 8) & 0x01)
                UINT64 Reserved1 : 55;
        };

        UINT64 AsUInt;
} IA32_ARCH_CAPABILITIES_REGISTER;

/**
 * Flush Command. Gives software a way to invalidate structures with finer granularity than other
 * architectural methods.
 *
 * @remarks If any one of the enumeration conditions for defined bit field positions holds.
 */
#define IA32_FLUSH_CMD 0x0000010B
typedef union
{
        struct
        {
                /**
                 * [Bit 0] L1D_FLUSH: Writeback and invalidate the L1 data cache.
                 *
                 * @remarks If CPUID.(EAX=07H,ECX=0):EDX[28]=1
                 */
                UINT64 L1DFlush : 1;
#define IA32_FLUSH_CMD_L1D_FLUSH_BIT  0
#define IA32_FLUSH_CMD_L1D_FLUSH_FLAG 0x01
#define IA32_FLUSH_CMD_L1D_FLUSH_MASK 0x01
#define IA32_FLUSH_CMD_L1D_FLUSH(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 63;
        };

        UINT64 AsUInt;
} IA32_FLUSH_CMD_REGISTER;

/**
 * Flush Command. Gives software a way to invalidate structures with finer granularity than other
 * architectural methods.
 *
 * @remarks Thread scope. Not architecturally serializing.
 *          Available when CPUID.ARCH_CAP(EAX=7H,ECX = 0):EDX[29] = 1 and IA32_ARCH_CAPABILITIES.bit
 * 7 = 1.
 */
#define IA32_TSX_CTRL 0x00000122
typedef union
{
        struct
        {
                /**
                 * [Bit 0] RTM_DISABLE: When set to 1, XBEGIN will always abort with EAX code 0.
                 */
                UINT64 RtmDisable : 1;
#define IA32_TSX_CTRL_RTM_DISABLE_BIT  0
#define IA32_TSX_CTRL_RTM_DISABLE_FLAG 0x01
#define IA32_TSX_CTRL_RTM_DISABLE_MASK 0x01
#define IA32_TSX_CTRL_RTM_DISABLE(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] TSX_CPUID_CLEAR: When set to 1, CPUID.07H.EBX.RTM [bit 11] and
                 * CPUID.07H.EBX.HLE [bit 4] report 0. When set to 0 and the SKU supports TSX, these
                 * bits will return 1.
                 */
                UINT64 TsxCpuidClear : 1;
#define IA32_TSX_CTRL_TSX_CPUID_CLEAR_BIT  1
#define IA32_TSX_CTRL_TSX_CPUID_CLEAR_FLAG 0x02
#define IA32_TSX_CTRL_TSX_CPUID_CLEAR_MASK 0x01
#define IA32_TSX_CTRL_TSX_CPUID_CLEAR(_)   (((_) >> 1) & 0x01)
                UINT64 Reserved1 : 62;
        };

        UINT64 AsUInt;
} IA32_TSX_CTRL_REGISTER;

/**
 * @brief SYSENTER_CS_MSR <b>(R/W)</b>
 *
 * The lower 16 bits of this MSR are the segment selector for the privilege level 0 code segment.
 * This value is also used to determine the segment selector of the privilege level 0 stack segment.
 * This value cannot indicate a null selector.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_CS 0x00000174
typedef union
{
        struct
        {
                /**
                 * [Bits 15:0] CS Selector.
                 */
                UINT64 CsSelector : 16;
#define IA32_SYSENTER_CS_CS_SELECTOR_BIT  0
#define IA32_SYSENTER_CS_CS_SELECTOR_FLAG 0xFFFF
#define IA32_SYSENTER_CS_CS_SELECTOR_MASK 0xFFFF
#define IA32_SYSENTER_CS_CS_SELECTOR(_)   (((_) >> 0) & 0xFFFF)

                /**
                 * [Bits 31:16] Not used.
                 *
                 * @remarks Can be read and written.
                 */
                UINT64 NotUsed1 : 16;
#define IA32_SYSENTER_CS_NOT_USED_1_BIT  16
#define IA32_SYSENTER_CS_NOT_USED_1_FLAG 0xFFFF0000
#define IA32_SYSENTER_CS_NOT_USED_1_MASK 0xFFFF
#define IA32_SYSENTER_CS_NOT_USED_1(_)   (((_) >> 16) & 0xFFFF)

                /**
                 * [Bits 63:32] Not used.
                 *
                 * @remarks Writes ignored; reads return zero.
                 */
                UINT64 NotUsed2 : 32;
#define IA32_SYSENTER_CS_NOT_USED_2_BIT  32
#define IA32_SYSENTER_CS_NOT_USED_2_FLAG 0xFFFFFFFF00000000
#define IA32_SYSENTER_CS_NOT_USED_2_MASK 0xFFFFFFFF
#define IA32_SYSENTER_CS_NOT_USED_2(_)   (((_) >> 32) & 0xFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_SYSENTER_CS_REGISTER;

/**
 * @brief SYSENTER_ESP_MSR <b>(R/W)</b>
 *
 * The value of this MSR is loaded into RSP (thus, this value contains the stack pointer for the
 * privilege level 0 stack). This value cannot represent a non-canonical address. In protected mode,
 * only bits 31:0 are loaded.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_ESP 0x00000175

/**
 * @brief SYSENTER_EIP_MSR <b>(R/W)</b>
 *
 * The value of this MSR is loaded into RIP (thus, this value references the first instruction of
 * the selected operating procedure or routine). In protected mode, only bits 31:0 are loaded.
 *
 * @remarks 06_01H
 * @see Vol2B[4.3(Instructions (M-U) | SYSCALL - Fast System Call)] (reference)
 */
#define IA32_SYSENTER_EIP 0x00000176

/**
 * Global Machine Check Capability.
 *
 * @remarks 06_01H
 */
#define IA32_MCG_CAP 0x00000179
typedef union
{
        struct
        {
                /**
                 * [Bits 7:0] Number of reporting banks.
                 */
                UINT64 Count : 8;
#define IA32_MCG_CAP_COUNT_BIT  0
#define IA32_MCG_CAP_COUNT_FLAG 0xFF
#define IA32_MCG_CAP_COUNT_MASK 0xFF
#define IA32_MCG_CAP_COUNT(_)   (((_) >> 0) & 0xFF)

                /**
                 * [Bit 8] IA32_MCG_CTL is present if this bit is set.
                 */
                UINT64 McgCtlP : 1;
#define IA32_MCG_CAP_MCG_CTL_P_BIT  8
#define IA32_MCG_CAP_MCG_CTL_P_FLAG 0x100
#define IA32_MCG_CAP_MCG_CTL_P_MASK 0x01
#define IA32_MCG_CAP_MCG_CTL_P(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bit 9] Extended machine check state registers are present if this bit is set.
                 */
                UINT64 McgExtP : 1;
#define IA32_MCG_CAP_MCG_EXT_P_BIT  9
#define IA32_MCG_CAP_MCG_EXT_P_FLAG 0x200
#define IA32_MCG_CAP_MCG_EXT_P_MASK 0x01
#define IA32_MCG_CAP_MCG_EXT_P(_)   (((_) >> 9) & 0x01)

                /**
                 * [Bit 10] Support for corrected MC error event is present.
                 *
                 * @remarks 06_01H
                 */
                UINT64 McpCmciP : 1;
#define IA32_MCG_CAP_MCP_CMCI_P_BIT  10
#define IA32_MCG_CAP_MCP_CMCI_P_FLAG 0x400
#define IA32_MCG_CAP_MCP_CMCI_P_MASK 0x01
#define IA32_MCG_CAP_MCP_CMCI_P(_)   (((_) >> 10) & 0x01)

                /**
                 * [Bit 11] Threshold-based error status register are present if this bit is set.
                 */
                UINT64 McgTesP : 1;
#define IA32_MCG_CAP_MCG_TES_P_BIT  11
#define IA32_MCG_CAP_MCG_TES_P_FLAG 0x800
#define IA32_MCG_CAP_MCG_TES_P_MASK 0x01
#define IA32_MCG_CAP_MCG_TES_P(_)   (((_) >> 11) & 0x01)
                UINT64 Reserved1 : 4;

                /**
                 * [Bits 23:16] Number of extended machine check state registers present.
                 */
                UINT64 McgExtCnt : 8;
#define IA32_MCG_CAP_MCG_EXT_CNT_BIT  16
#define IA32_MCG_CAP_MCG_EXT_CNT_FLAG 0xFF0000
#define IA32_MCG_CAP_MCG_EXT_CNT_MASK 0xFF
#define IA32_MCG_CAP_MCG_EXT_CNT(_)   (((_) >> 16) & 0xFF)

                /**
                 * [Bit 24] The processor supports software error recovery if this bit is set.
                 */
                UINT64 McgSerP : 1;
#define IA32_MCG_CAP_MCG_SER_P_BIT  24
#define IA32_MCG_CAP_MCG_SER_P_FLAG 0x1000000
#define IA32_MCG_CAP_MCG_SER_P_MASK 0x01
#define IA32_MCG_CAP_MCG_SER_P(_)   (((_) >> 24) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * [Bit 26] Indicates that the processor allows platform firmware to be invoked when
                 * an error is detected so that it may provide additional platform specific
                 * information in an ACPI format "Generic Error Data Entry" that augments the data
                 * included in machine check bank registers.
                 *
                 * @remarks 06_3EH
                 */
                UINT64 McgElogP : 1;
#define IA32_MCG_CAP_MCG_ELOG_P_BIT  26
#define IA32_MCG_CAP_MCG_ELOG_P_FLAG 0x4000000
#define IA32_MCG_CAP_MCG_ELOG_P_MASK 0x01
#define IA32_MCG_CAP_MCG_ELOG_P(_)   (((_) >> 26) & 0x01)

                /**
                 * [Bit 27] Indicates that the processor supports extended state in IA32_MCG_STATUS
                 * and associated MSR necessary to configure Local Machine Check Exception (LMCE).
                 *
                 * @remarks 06_3EH
                 */
                UINT64 McgLmceP : 1;
#define IA32_MCG_CAP_MCG_LMCE_P_BIT  27
#define IA32_MCG_CAP_MCG_LMCE_P_FLAG 0x8000000
#define IA32_MCG_CAP_MCG_LMCE_P_MASK 0x01
#define IA32_MCG_CAP_MCG_LMCE_P(_)   (((_) >> 27) & 0x01)
                UINT64 Reserved3 : 36;
        };

        UINT64 AsUInt;
} IA32_MCG_CAP_REGISTER;

/**
 * Global Machine Check Status.
 *
 * @remarks 06_01H
 */
#define IA32_MCG_STATUS 0x0000017A
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Restart IP valid.
                 *
                 * @remarks 06_01H
                 */
                UINT64 Ripv : 1;
#define IA32_MCG_STATUS_RIPV_BIT  0
#define IA32_MCG_STATUS_RIPV_FLAG 0x01
#define IA32_MCG_STATUS_RIPV_MASK 0x01
#define IA32_MCG_STATUS_RIPV(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Error IP valid.
                 *
                 * @remarks 06_01H
                 */
                UINT64 Eipv : 1;
#define IA32_MCG_STATUS_EIPV_BIT  1
#define IA32_MCG_STATUS_EIPV_FLAG 0x02
#define IA32_MCG_STATUS_EIPV_MASK 0x01
#define IA32_MCG_STATUS_EIPV(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] Machine check in progress.
                 *
                 * @remarks 06_01H
                 */
                UINT64 Mcip : 1;
#define IA32_MCG_STATUS_MCIP_BIT  2
#define IA32_MCG_STATUS_MCIP_FLAG 0x04
#define IA32_MCG_STATUS_MCIP_MASK 0x01
#define IA32_MCG_STATUS_MCIP(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] If IA32_MCG_CAP.LMCE_P[27] = 1.
                 */
                UINT64 LmceS : 1;
#define IA32_MCG_STATUS_LMCE_S_BIT  3
#define IA32_MCG_STATUS_LMCE_S_FLAG 0x08
#define IA32_MCG_STATUS_LMCE_S_MASK 0x01
#define IA32_MCG_STATUS_LMCE_S(_)   (((_) >> 3) & 0x01)
                UINT64 Reserved1 : 60;
        };

        UINT64 AsUInt;
} IA32_MCG_STATUS_REGISTER;

/**
 * Global Machine Check Control.
 *
 * @remarks If IA32_MCG_CAP.CTL_P[8] = 1
 */
#define IA32_MCG_CTL 0x0000017B
/**
 * @defgroup IA32_PERFEVTSEL \
 *           IA32_PERFEVTSEL(n)
 *
 * Performance Event Select Register n.
 *
 * @remarks If CPUID.0AH: EAX[15:8] > n
 * @{
 */
#define IA32_PERFEVTSEL0 0x00000186
#define IA32_PERFEVTSEL1 0x00000187
#define IA32_PERFEVTSEL2 0x00000188
#define IA32_PERFEVTSEL3 0x00000189
typedef union
{
        struct
        {
                /**
                 * [Bits 7:0] Selects a performance event logic unit.
                 */
                UINT64 EventSelect : 8;
#define IA32_PERFEVTSEL_EVENT_SELECT_BIT  0
#define IA32_PERFEVTSEL_EVENT_SELECT_FLAG 0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT_MASK 0xFF
#define IA32_PERFEVTSEL_EVENT_SELECT(_)   (((_) >> 0) & 0xFF)

                /**
                 * [Bits 15:8] Qualifies the microarchitectural condition to detect on the selected
                 * event logic.
                 */
                UINT64 UMask : 8;
#define IA32_PERFEVTSEL_U_MASK_BIT  8
#define IA32_PERFEVTSEL_U_MASK_FLAG 0xFF00
#define IA32_PERFEVTSEL_U_MASK_MASK 0xFF
#define IA32_PERFEVTSEL_U_MASK(_)   (((_) >> 8) & 0xFF)

                /**
                 * [Bit 16] Counts while in privilege level is not ring 0.
                 */
                UINT64 Usr : 1;
#define IA32_PERFEVTSEL_USR_BIT  16
#define IA32_PERFEVTSEL_USR_FLAG 0x10000
#define IA32_PERFEVTSEL_USR_MASK 0x01
#define IA32_PERFEVTSEL_USR(_)   (((_) >> 16) & 0x01)

                /**
                 * [Bit 17] Counts while in privilege level is ring 0.
                 */
                UINT64 Os : 1;
#define IA32_PERFEVTSEL_OS_BIT  17
#define IA32_PERFEVTSEL_OS_FLAG 0x20000
#define IA32_PERFEVTSEL_OS_MASK 0x01
#define IA32_PERFEVTSEL_OS(_)   (((_) >> 17) & 0x01)

                /**
                 * [Bit 18] Enables edge detection if set.
                 */
                UINT64 Edge : 1;
#define IA32_PERFEVTSEL_EDGE_BIT  18
#define IA32_PERFEVTSEL_EDGE_FLAG 0x40000
#define IA32_PERFEVTSEL_EDGE_MASK 0x01
#define IA32_PERFEVTSEL_EDGE(_)   (((_) >> 18) & 0x01)

                /**
                 * [Bit 19] Enables pin control.
                 */
                UINT64 Pc : 1;
#define IA32_PERFEVTSEL_PC_BIT  19
#define IA32_PERFEVTSEL_PC_FLAG 0x80000
#define IA32_PERFEVTSEL_PC_MASK 0x01
#define IA32_PERFEVTSEL_PC(_)   (((_) >> 19) & 0x01)

                /**
                 * [Bit 20] Enables interrupt on counter overflow.
                 */
                UINT64 Intr : 1;
#define IA32_PERFEVTSEL_INTR_BIT  20
#define IA32_PERFEVTSEL_INTR_FLAG 0x100000
#define IA32_PERFEVTSEL_INTR_MASK 0x01
#define IA32_PERFEVTSEL_INTR(_)   (((_) >> 20) & 0x01)

                /**
                 * [Bit 21] When set to 1, it enables counting the associated event conditions
                 * occurring across all logical processors sharing a processor core. When set to 0,
                 * the counter only increments the associated event conditions occurring in the
                 * logical processor which programmed the MSR.
                 */
                UINT64 AnyThread : 1;
#define IA32_PERFEVTSEL_ANY_THREAD_BIT  21
#define IA32_PERFEVTSEL_ANY_THREAD_FLAG 0x200000
#define IA32_PERFEVTSEL_ANY_THREAD_MASK 0x01
#define IA32_PERFEVTSEL_ANY_THREAD(_)   (((_) >> 21) & 0x01)

                /**
                 * [Bit 22] Enables the corresponding performance counter to commence counting when
                 * this bit is set.
                 */
                UINT64 En : 1;
#define IA32_PERFEVTSEL_EN_BIT  22
#define IA32_PERFEVTSEL_EN_FLAG 0x400000
#define IA32_PERFEVTSEL_EN_MASK 0x01
#define IA32_PERFEVTSEL_EN(_)   (((_) >> 22) & 0x01)

                /**
                 * [Bit 23] Invert the CMASK.
                 */
                UINT64 Inv : 1;
#define IA32_PERFEVTSEL_INV_BIT  23
#define IA32_PERFEVTSEL_INV_FLAG 0x800000
#define IA32_PERFEVTSEL_INV_MASK 0x01
#define IA32_PERFEVTSEL_INV(_)   (((_) >> 23) & 0x01)

                /**
                 * [Bits 31:24] When CMASK is not zero, the corresponding performance counter
                 * increments each cycle if the event count is greater than or equal to the CMASK.
                 */
                UINT64 Cmask : 8;
#define IA32_PERFEVTSEL_CMASK_BIT  24
#define IA32_PERFEVTSEL_CMASK_FLAG 0xFF000000
#define IA32_PERFEVTSEL_CMASK_MASK 0xFF
#define IA32_PERFEVTSEL_CMASK(_)   (((_) >> 24) & 0xFF)
                UINT64 Reserved1 : 32;
        };

        UINT64 AsUInt;
} IA32_PERFEVTSEL_REGISTER;

/**
 * @}
 */

/**
 * Current Performance Status.
 *
 * @remarks 0F_03H
 * @see Vol3B[14.1.1(Software Interface For Initiating Performance State Transitions)]
 */
#define IA32_PERF_STATUS 0x00000198
typedef union
{
        struct
        {
                /**
                 * [Bits 15:0] Current performance State Value.
                 */
                UINT64 StateValue : 16;
#define IA32_PERF_STATUS_STATE_VALUE_BIT  0
#define IA32_PERF_STATUS_STATE_VALUE_FLAG 0xFFFF
#define IA32_PERF_STATUS_STATE_VALUE_MASK 0xFFFF
#define IA32_PERF_STATUS_STATE_VALUE(_)   (((_) >> 0) & 0xFFFF)
                UINT64 Reserved1 : 48;
        };

        UINT64 AsUInt;
} IA32_PERF_STATUS_REGISTER;

/**
 * @brief Performance Control <b>(R/W)</b>
 *
 * Performance Control. Software makes a request for a new Performance state (P-State) by writing
 * this MSR.
 *
 * @remarks 0F_03H
 * @see Vol3B[14.1.1(Software Interface For Initiating Performance State Transitions)]
 */
#define IA32_PERF_CTL 0x00000199
typedef union
{
        struct
        {
                /**
                 * [Bits 15:0] Target performance State Value.
                 */
                UINT64 TargetStateValue : 16;
#define IA32_PERF_CTL_TARGET_STATE_VALUE_BIT  0
#define IA32_PERF_CTL_TARGET_STATE_VALUE_FLAG 0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE_MASK 0xFFFF
#define IA32_PERF_CTL_TARGET_STATE_VALUE(_)   (((_) >> 0) & 0xFFFF)
                UINT64 Reserved1 : 16;

                /**
                 * [Bit 32] IDA Engage.
                 *
                 * @remarks 06_0FH (Mobile only)
                 */
                UINT64 IdaEngage : 1;
#define IA32_PERF_CTL_IDA_ENGAGE_BIT  32
#define IA32_PERF_CTL_IDA_ENGAGE_FLAG 0x100000000
#define IA32_PERF_CTL_IDA_ENGAGE_MASK 0x01
#define IA32_PERF_CTL_IDA_ENGAGE(_)   (((_) >> 32) & 0x01)
                UINT64 Reserved2 : 31;
        };

        UINT64 AsUInt;
} IA32_PERF_CTL_REGISTER;

/**
 * Clock Modulation Control.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.3(Software Controlled Clock Modulation)]
 */
#define IA32_CLOCK_MODULATION 0x0000019A
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Extended On-Demand Clock Modulation Duty Cycle.
                 *
                 * @remarks If CPUID.06H:EAX[5] = 1
                 */
                UINT64 ExtendedOnDemandClockModulationDutyCycle : 1;
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT  0
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x01
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x01
#define IA32_CLOCK_MODULATION_EXTENDED_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_)   (((_) >> 0) & 0x01)

                /**
                 * @brief On-Demand Clock Modulation Duty Cycle
                 *
                 * [Bits 3:1] On-Demand Clock Modulation Duty Cycle: Specific encoded values for
                 * target duty cycle modulation.
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 OnDemandClockModulationDutyCycle : 3;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_BIT  1
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_FLAG 0x0E
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE_MASK 0x07
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_DUTY_CYCLE(_)   (((_) >> 1) & 0x07)

                /**
                 * @brief On-Demand Clock Modulation Enable
                 *
                 * [Bit 4] On-Demand Clock Modulation Enable: Set 1 to enable modulation.
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 OnDemandClockModulationEnable : 1;
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_BIT  4
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_FLAG 0x10
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE_MASK 0x01
#define IA32_CLOCK_MODULATION_ON_DEMAND_CLOCK_MODULATION_ENABLE(_)   (((_) >> 4) & 0x01)
                UINT64 Reserved1 : 59;
        };

        UINT64 AsUInt;
} IA32_CLOCK_MODULATION_REGISTER;

/**
 * @brief Thermal Interrupt Control <b>(R/W)</b>
 *
 * Thermal Interrupt Control. Enables and disables the generation of an interrupt on temperature
 * transitions detected with the processor's thermal sensors and thermal monitor.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.2(Thermal Monitor)]
 */
#define IA32_THERM_INTERRUPT 0x0000019B
typedef union
{
        struct
        {
                /**
                 * [Bit 0] High-Temperature Interrupt Enable.
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 HighTemperatureInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT  0
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x01
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Low-Temperature Interrupt Enable.
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 LowTemperatureInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT  1
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x02
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] PROCHOT\# Interrupt Enable.
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 ProchotInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT  2
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG 0x04
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] FORCEPR\# Interrupt Enable.
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 ForceprInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_BIT  3
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_FLAG 0x08
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_FORCEPR_INTERRUPT_ENABLE(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Critical Temperature Interrupt Enable.
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 CriticalTemperatureInterruptEnable : 1;
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_BIT  4
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x10
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_CRITICAL_TEMPERATURE_INTERRUPT_ENABLE(_)   (((_) >> 4) & 0x01)
                UINT64 Reserved1 : 3;

                /**
                 * [Bits 14:8] Threshold \#1 Value
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 Threshold1Value : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT  8
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG 0x7F00
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK 0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD1_VALUE(_)   (((_) >> 8) & 0x7F)

                /**
                 * [Bit 15] Threshold \#1 Interrupt Enable.
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 Threshold1InterruptEnable : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT  15
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG 0x8000
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_)   (((_) >> 15) & 0x01)

                /**
                 * [Bits 22:16] Threshold \#2 Value.
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 Threshold2Value : 7;
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT  16
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG 0x7F0000
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK 0x7F
#define IA32_THERM_INTERRUPT_THRESHOLD2_VALUE(_)   (((_) >> 16) & 0x7F)

                /**
                 * [Bit 23] Threshold \#2 Interrupt Enable.
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 Threshold2InterruptEnable : 1;
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT  23
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG 0x800000
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_)   (((_) >> 23) & 0x01)

                /**
                 * [Bit 24] Power Limit Notification Enable.
                 *
                 * @remarks If CPUID.06H:EAX[4] = 1
                 */
                UINT64 PowerLimitNotificationEnable : 1;
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT  24
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG 0x1000000
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK 0x01
#define IA32_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_)   (((_) >> 24) & 0x01)
                UINT64 Reserved2 : 39;
        };

        UINT64 AsUInt;
} IA32_THERM_INTERRUPT_REGISTER;

/**
 * @brief Thermal Status Information <b>(RO)</b>
 *
 * Thermal Status Information. Contains status information about the processor's thermal sensor and
 * automatic thermal monitoring facilities.
 *
 * @remarks If CPUID.01H:EDX[22] = 1
 * @see Vol3B[14.7.2(Thermal Monitor)]
 */
#define IA32_THERM_STATUS 0x0000019C
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Thermal Status
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 ThermalStatus : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_BIT  0
#define IA32_THERM_STATUS_THERMAL_STATUS_FLAG 0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_MASK 0x01
#define IA32_THERM_STATUS_THERMAL_STATUS(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Thermal Status Log
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 ThermalStatusLog : 1;
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_BIT  1
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_FLAG 0x02
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG_MASK 0x01
#define IA32_THERM_STATUS_THERMAL_STATUS_LOG(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] PROCHOT \# or FORCEPR\# event
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 ProchotForceprEvent : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_BIT  2
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_FLAG 0x04
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT_MASK 0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_EVENT(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] PROCHOT \# or FORCEPR\# log
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 ProchotForceprLog : 1;
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_BIT  3
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_FLAG 0x08
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG_MASK 0x01
#define IA32_THERM_STATUS_PROCHOT_FORCEPR_LOG(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Critical Temperature Status
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 CriticalTemperatureStatus : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT  4
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG 0x10
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK 0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] Critical Temperature Status log
                 *
                 * @remarks If CPUID.01H:EDX[22] = 1
                 */
                UINT64 CriticalTemperatureStatusLog : 1;
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT  5
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG 0x20
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK 0x01
#define IA32_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] Thermal Threshold \#1 Status
                 *
                 * @remarks If CPUID.01H:ECX[8] = 1
                 */
                UINT64 ThermalThreshold1Status : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT  6
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG 0x40
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK 0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] Thermal Threshold \#1 log
                 *
                 * @remarks If CPUID.01H:ECX[8] = 1
                 */
                UINT64 ThermalThreshold1Log : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT  7
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG 0x80
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK 0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] Thermal Threshold \#2 Status
                 *
                 * @remarks If CPUID.01H:ECX[8] = 1
                 */
                UINT64 ThermalThreshold2Status : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT  8
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG 0x100
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK 0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bit 9] Thermal Threshold \#2 log
                 *
                 * @remarks If CPUID.01H:ECX[8] = 1
                 */
                UINT64 ThermalThreshold2Log : 1;
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT  9
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG 0x200
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK 0x01
#define IA32_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_)   (((_) >> 9) & 0x01)

                /**
                 * [Bit 10] Power Limitation Status
                 *
                 * @remarks If CPUID.06H:EAX[4] = 1
                 */
                UINT64 PowerLimitationStatus : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_BIT  10
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG 0x400
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS_MASK 0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_STATUS(_)   (((_) >> 10) & 0x01)

                /**
                 * [Bit 11] Power Limitation log
                 *
                 * @remarks If CPUID.06H:EAX[4] = 1
                 */
                UINT64 PowerLimitationLog : 1;
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_BIT  11
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_FLAG 0x800
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG_MASK 0x01
#define IA32_THERM_STATUS_POWER_LIMITATION_LOG(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bit 12] Current Limit Status
                 *
                 * @remarks If CPUID.06H:EAX[7] = 1
                 */
                UINT64 CurrentLimitStatus : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_BIT  12
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_FLAG 0x1000
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS_MASK 0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_STATUS(_)   (((_) >> 12) & 0x01)

                /**
                 * [Bit 13] Current Limit log
                 *
                 * @remarks If CPUID.06H:EAX[7] = 1
                 */
                UINT64 CurrentLimitLog : 1;
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_BIT  13
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_FLAG 0x2000
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG_MASK 0x01
#define IA32_THERM_STATUS_CURRENT_LIMIT_LOG(_)   (((_) >> 13) & 0x01)

                /**
                 * [Bit 14] Cross Domain Limit Status
                 *
                 * @remarks If CPUID.06H:EAX[7] = 1
                 */
                UINT64 CrossDomainLimitStatus : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_BIT  14
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_FLAG 0x4000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS_MASK 0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_STATUS(_)   (((_) >> 14) & 0x01)

                /**
                 * [Bit 15] Cross Domain Limit log
                 *
                 * @remarks If CPUID.06H:EAX[7] = 1
                 */
                UINT64 CrossDomainLimitLog : 1;
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_BIT  15
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_FLAG 0x8000
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG_MASK 0x01
#define IA32_THERM_STATUS_CROSS_DOMAIN_LIMIT_LOG(_)   (((_) >> 15) & 0x01)

                /**
                 * [Bits 22:16] Digital Readout
                 *
                 * @remarks If CPUID.06H:EAX[0] = 1
                 */
                UINT64 DigitalReadout : 7;
#define IA32_THERM_STATUS_DIGITAL_READOUT_BIT  16
#define IA32_THERM_STATUS_DIGITAL_READOUT_FLAG 0x7F0000
#define IA32_THERM_STATUS_DIGITAL_READOUT_MASK 0x7F
#define IA32_THERM_STATUS_DIGITAL_READOUT(_)   (((_) >> 16) & 0x7F)
                UINT64 Reserved1 : 4;

                /**
                 * [Bits 30:27] Resolution in Degrees Celsius
                 *
                 * @remarks If CPUID.06H:EAX[0] = 1
                 */
                UINT64 ResolutionInDegreesCelsius : 4;
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_BIT  27
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_FLAG 0x78000000
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS_MASK 0x0F
#define IA32_THERM_STATUS_RESOLUTION_IN_DEGREES_CELSIUS(_)   (((_) >> 27) & 0x0F)

                /**
                 * [Bit 31] Reading Valid
                 *
                 * @remarks If CPUID.06H:EAX[0] = 1
                 */
                UINT64 ReadingValid : 1;
#define IA32_THERM_STATUS_READING_VALID_BIT  31
#define IA32_THERM_STATUS_READING_VALID_FLAG 0x80000000
#define IA32_THERM_STATUS_READING_VALID_MASK 0x01
#define IA32_THERM_STATUS_READING_VALID(_)   (((_) >> 31) & 0x01)
                UINT64 Reserved2 : 32;
        };

        UINT64 AsUInt;
} IA32_THERM_STATUS_REGISTER;

/**
 * @brief Enable Misc. Processor Features <b>(R/W)</b>
 *
 * Allows a variety of processor functions to be enabled and disabled.
 */
#define IA32_MISC_ENABLE 0x000001A0
typedef union
{
        struct
        {
                /**
                 * @brief Fast-Strings Enable
                 *
                 * [Bit 0] When set, the fast-strings feature (for REP MOVS and REP STORS) is
                 * enabled (default). When clear, fast-strings are disabled.
                 *
                 * @remarks 0F_0H
                 */
                UINT64 FastStringsEnable : 1;
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_BIT  0
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_FLAG 0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_FAST_STRINGS_ENABLE(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 2;

                /**
                 * @brief Automatic Thermal Control Circuit Enable <b>(R/W)</b>
                 *
                 * [Bit 3] - 1 = Setting this bit enables the thermal control circuit (TCC) portion
                 * of the Intel Thermal Monitor feature. This allows the processor to automatically
                 * reduce power consumption in response to TCC activation.
                 * - 0 = Disabled.
                 *
                 * @note In some products clearing this bit might be ignored in critical thermal
                 * conditions, and TM1, TM2 and adaptive thermal throttling will still be activated.
                 * The default value of this field varies with product.
                 * @remarks 0F_0H
                 */
                UINT64 AutomaticThermalControlCircuitEnable : 1;
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_BIT  3
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_FLAG 0x08
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_AUTOMATIC_THERMAL_CONTROL_CIRCUIT_ENABLE(_)   (((_) >> 3) & 0x01)
                UINT64 Reserved2 : 3;

                /**
                 * @brief Performance Monitoring Available <b>(R)</b>
                 *
                 * [Bit 7] - 1 = Performance monitoring enabled.
                 * - 0 = Performance monitoring disabled.
                 *
                 * @remarks 0F_0H
                 */
                UINT64 PerformanceMonitoringAvailable : 1;
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_BIT  7
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_FLAG 0x80
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE_MASK 0x01
#define IA32_MISC_ENABLE_PERFORMANCE_MONITORING_AVAILABLE(_)   (((_) >> 7) & 0x01)
                UINT64 Reserved3 : 3;

                /**
                 * @brief Branch Trace Storage Unavailable <b>(RO)</b>
                 *
                 * [Bit 11] - 1 = Processor doesn't support branch trace storage (BTS).
                 * - 0 = BTS is supported.
                 *
                 * @remarks 0F_0H
                 */
                UINT64 BranchTraceStorageUnavailable : 1;
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_BIT  11
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_FLAG 0x800
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE_MASK 0x01
#define IA32_MISC_ENABLE_BRANCH_TRACE_STORAGE_UNAVAILABLE(_)   (((_) >> 11) & 0x01)

                /**
                 * @brief Processor Event Based Sampling (PEBS) Unavailable <b>(RO)</b>
                 *
                 * [Bit 12] - 1 = PEBS is not supported.
                 * - 0 = PEBS is supported.
                 *
                 * @remarks 06_0FH
                 */
                UINT64 ProcessorEventBasedSamplingUnavailable : 1;
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_BIT  12
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_FLAG 0x1000
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE_MASK 0x01
#define IA32_MISC_ENABLE_PROCESSOR_EVENT_BASED_SAMPLING_UNAVAILABLE(_)   (((_) >> 12) & 0x01)
                UINT64 Reserved4 : 3;

                /**
                 * @brief Enhanced Intel SpeedStep Technology Enable <b>(R/W)</b>
                 *
                 * [Bit 16] - 0 = Enhanced Intel SpeedStep Technology disabled.
                 * - 1 = Enhanced Intel SpeedStep Technology enabled.
                 *
                 * @remarks If CPUID.01H: ECX[7] = 1
                 */
                UINT64 EnhancedIntelSpeedstepTechnologyEnable : 1;
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_BIT  16
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_FLAG 0x10000
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE_MASK 0x01
#define IA32_MISC_ENABLE_ENHANCED_INTEL_SPEEDSTEP_TECHNOLOGY_ENABLE(_)   (((_) >> 16) & 0x01)
                UINT64 Reserved5 : 1;

                /**
                 * @brief ENABLE MONITOR FSM <b>(R/W)</b>
                 *
                 * [Bit 18] When this bit is set to 0, the MONITOR feature flag is not set
                 * (CPUID.01H:ECX[bit3] = 0). This indicates that MONITOR/MWAIT are not supported.
                 * Software attempts to execute MONITOR/MWAIT will cause \#UD when this bit is 0.
                 * When this bit is set to 1 (default), MONITOR/MWAIT are supported
                 * (CPUID.01H:ECX[bit 3] = 1). If the SSE3 feature flag ECX[0] is not set
                 * (CPUID.01H:ECX[bit 0] = 0), the OS must not attempt to alter this bit. BIOS must
                 * leave it in the default state. Writing this bit when the SSE3 feature flag is set
                 * to 0 may generate a \#GP exception.
                 *
                 * @remarks 0F_03H
                 */
                UINT64 EnableMonitorFsm : 1;
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_BIT  18
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_FLAG 0x40000
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM_MASK 0x01
#define IA32_MISC_ENABLE_ENABLE_MONITOR_FSM(_)   (((_) >> 18) & 0x01)
                UINT64 Reserved6 : 3;

                /**
                 * @brief Limit CPUID Maxval <b>(R/W)</b>
                 *
                 * [Bit 22] When this bit is set to 1, CPUID.00H returns a maximum value in EAX[7:0]
                 * of 2. BIOS should contain a setup question that allows users to specify when the
                 * installed OS does not support CPUID functions greater than 2. Before setting this
                 * bit, BIOS must execute the CPUID.0H and examine the maximum value returned in
                 * EAX[7:0]. If the maximum value is greater than 2, this bit is supported.
                 * Otherwise, this bit is not supported. Setting this bit when the maximum value is
                 * not greater than 2 may generate a \#GP exception. Setting this bit may cause
                 * unexpected behavior in software that depends on the availability of CPUID leaves
                 * greater than 2.
                 *
                 * @remarks 0F_03H
                 */
                UINT64 LimitCpuidMaxval : 1;
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_BIT  22
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_FLAG 0x400000
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL_MASK 0x01
#define IA32_MISC_ENABLE_LIMIT_CPUID_MAXVAL(_)   (((_) >> 22) & 0x01)

                /**
                 * @brief xTPR Message Disable <b>(R/W)</b>
                 *
                 * [Bit 23] When set to 1, xTPR messages are disabled. xTPR messages are optional
                 * messages that allow the processor to inform the chipset of its priority.
                 *
                 * @remarks If CPUID.01H:ECX[14] = 1
                 */
                UINT64 XtprMessageDisable : 1;
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_BIT  23
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_FLAG 0x800000
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE_MASK 0x01
#define IA32_MISC_ENABLE_XTPR_MESSAGE_DISABLE(_)   (((_) >> 23) & 0x01)
                UINT64 Reserved7 : 10;

                /**
                 * @brief XD Bit Disable <b>(R/W)</b>
                 *
                 * [Bit 34] When set to 1, the Execute Disable Bit feature (XD Bit) is disabled and
                 * the XD Bit extended feature flag will be clear (CPUID.80000001H: EDX[20]=0). When
                 * set to a 0 (default), the Execute Disable Bit feature (if available) allows the
                 * OS to enable PAE paging and take advantage of data only pages. BIOS must not
                 * alter the contents of this bit location, if XD bit is not supported. Writing this
                 * bit to 1 when the XD Bit extended feature flag is set to 0 may generate a \#GP
                 * exception.
                 *
                 * @remarks If CPUID.80000001H:EDX[20] = 1
                 */
                UINT64 XdBitDisable : 1;
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_BIT  34
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_FLAG 0x400000000
#define IA32_MISC_ENABLE_XD_BIT_DISABLE_MASK 0x01
#define IA32_MISC_ENABLE_XD_BIT_DISABLE(_)   (((_) >> 34) & 0x01)
                UINT64 Reserved8 : 29;
        };

        UINT64 AsUInt;
} IA32_MISC_ENABLE_REGISTER;

/**
 * Performance Energy Bias Hint.
 *
 * @remarks If CPUID.6H:ECX[3] = 1
 */
#define IA32_ENERGY_PERF_BIAS 0x000001B0
typedef union
{
        struct
        {
                /**
                 * @brief Power Policy Preference
                 *
                 * [Bits 3:0] - 0 indicates preference to highest performance.
                 * - 15 indicates preference to maximize energy saving.
                 */
                UINT64 PowerPolicyPreference : 4;
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_BIT  0
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_FLAG 0x0F
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE_MASK 0x0F
#define IA32_ENERGY_PERF_BIAS_POWER_POLICY_PREFERENCE(_)   (((_) >> 0) & 0x0F)
                UINT64 Reserved1 : 60;
        };

        UINT64 AsUInt;
} IA32_ENERGY_PERF_BIAS_REGISTER;

/**
 * @brief Package Thermal Status Information <b>(RO)</b>
 *
 * Package Thermal Status Information. Contains status information about the package's thermal
 * sensor.
 *
 * @remarks If CPUID.06H: EAX[6] = 1
 * @see Vol3B[14.8(PACKAGE LEVEL THERMAL MANAGEMENT)]
 */
#define IA32_PACKAGE_THERM_STATUS 0x000001B1
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Pkg Thermal Status
                 */
                UINT64 ThermalStatus : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_BIT  0
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_FLAG 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Pkg Thermal Status Log
                 */
                UINT64 ThermalStatusLog : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_BIT  1
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_FLAG 0x02
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_STATUS_LOG(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] Pkg PROCHOT \# event
                 */
                UINT64 ProchotEvent : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_BIT  2
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_FLAG 0x04
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_EVENT(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Pkg PROCHOT \# log
                 */
                UINT64 ProchotLog : 1;
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_BIT  3
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_FLAG 0x08
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_PROCHOT_LOG(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Pkg Critical Temperature Status
                 */
                UINT64 CriticalTemperatureStatus : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_BIT  4
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_FLAG 0x10
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] Pkg Critical Temperature Status Log
                 */
                UINT64 CriticalTemperatureStatusLog : 1;
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_BIT  5
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_FLAG 0x20
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_CRITICAL_TEMPERATURE_STATUS_LOG(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] Pkg Thermal Threshold \#1 Status
                 */
                UINT64 ThermalThreshold1Status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_BIT  6
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_FLAG 0x40
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_STATUS(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] Pkg Thermal Threshold \#1 log
                 */
                UINT64 ThermalThreshold1Log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_BIT  7
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_FLAG 0x80
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD1_LOG(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] Pkg Thermal Threshold \#2 Status
                 */
                UINT64 ThermalThreshold2Status : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_BIT  8
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_FLAG 0x100
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_STATUS(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bit 9] Pkg Thermal Threshold \#2 log
                 */
                UINT64 ThermalThreshold2Log : 1;
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_BIT  9
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_FLAG 0x200
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_THERMAL_THRESHOLD2_LOG(_)   (((_) >> 9) & 0x01)

                /**
                 * [Bit 10] Pkg Power Limitation Status
                 */
                UINT64 PowerLimitationStatus : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_BIT  10
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_FLAG 0x400
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_STATUS(_)   (((_) >> 10) & 0x01)

                /**
                 * [Bit 11] Pkg Power Limitation log
                 */
                UINT64 PowerLimitationLog : 1;
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_BIT  11
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_FLAG 0x800
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG_MASK 0x01
#define IA32_PACKAGE_THERM_STATUS_POWER_LIMITATION_LOG(_)   (((_) >> 11) & 0x01)
                UINT64 Reserved1 : 4;

                /**
                 * [Bits 22:16] Pkg Digital Readout
                 */
                UINT64 DigitalReadout : 7;
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_BIT  16
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_FLAG 0x7F0000
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT_MASK 0x7F
#define IA32_PACKAGE_THERM_STATUS_DIGITAL_READOUT(_)   (((_) >> 16) & 0x7F)
                UINT64 Reserved2 : 41;
        };

        UINT64 AsUInt;
} IA32_PACKAGE_THERM_STATUS_REGISTER;

/**
 * @brief Package Thermal Interrupt Control <b>(RO)</b>
 *
 * Enables and disables the generation of an interrupt on temperature transitions detected with the
 * package's thermal sensor.
 *
 * @remarks If CPUID.06H: EAX[6] = 1
 * @see Vol3B[14.8(PACKAGE LEVEL THERMAL MANAGEMENT)]
 */
#define IA32_PACKAGE_THERM_INTERRUPT 0x000001B2
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Pkg High-Temperature Interrupt Enable.
                 */
                UINT64 HighTemperatureInterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_BIT  0
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_HIGH_TEMPERATURE_INTERRUPT_ENABLE(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Pkg Low-Temperature Interrupt Enable.
                 */
                UINT64 LowTemperatureInterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_BIT  1
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_FLAG 0x02
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_LOW_TEMPERATURE_INTERRUPT_ENABLE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] Pkg PROCHOT\# Interrupt Enable.
                 */
                UINT64 ProchotInterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_BIT  2
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_FLAG 0x04
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_PROCHOT_INTERRUPT_ENABLE(_)   (((_) >> 2) & 0x01)
                UINT64 Reserved1 : 1;

                /**
                 * [Bit 4] Pkg Overheat Interrupt Enable.
                 */
                UINT64 OverheatInterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_BIT  4
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_FLAG 0x10
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_OVERHEAT_INTERRUPT_ENABLE(_)   (((_) >> 4) & 0x01)
                UINT64 Reserved2 : 3;

                /**
                 * [Bits 14:8] Pkg Threshold \#1 Value
                 */
                UINT64 Threshold1Value : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_BIT  8
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_FLAG 0x7F00
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE_MASK 0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_VALUE(_)   (((_) >> 8) & 0x7F)

                /**
                 * [Bit 15] Pkg Threshold \#1 Interrupt Enable.
                 */
                UINT64 Threshold1InterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_BIT  15
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_FLAG 0x8000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD1_INTERRUPT_ENABLE(_)   (((_) >> 15) & 0x01)

                /**
                 * [Bits 22:16] Pkg Threshold \#2 Value.
                 */
                UINT64 Threshold2Value : 7;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_BIT  16
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_FLAG 0x7F0000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE_MASK 0x7F
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_VALUE(_)   (((_) >> 16) & 0x7F)

                /**
                 * [Bit 23] Pkg Threshold \#2 Interrupt Enable.
                 */
                UINT64 Threshold2InterruptEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_BIT  23
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_FLAG 0x800000
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_THRESHOLD2_INTERRUPT_ENABLE(_)   (((_) >> 23) & 0x01)

                /**
                 * [Bit 24] Pkg Power Limit Notification Enable.
                 */
                UINT64 PowerLimitNotificationEnable : 1;
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_BIT  24
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_FLAG 0x1000000
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE_MASK 0x01
#define IA32_PACKAGE_THERM_INTERRUPT_POWER_LIMIT_NOTIFICATION_ENABLE(_)   (((_) >> 24) & 0x01)
                UINT64 Reserved3 : 39;
        };

        UINT64 AsUInt;
} IA32_PACKAGE_THERM_INTERRUPT_REGISTER;

/**
 * Trace/Profile Resource Control.
 *
 * @remarks 06_0EH
 */
#define IA32_DEBUGCTL 0x000001D9
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Setting this bit to 1 enables the processor to record a running trace of
                 * the most recent branches taken by the processor in the LBR stack.
                 *
                 * @remarks 06_01H
                 */
                UINT64 Lbr : 1;
#define IA32_DEBUGCTL_LBR_BIT  0
#define IA32_DEBUGCTL_LBR_FLAG 0x01
#define IA32_DEBUGCTL_LBR_MASK 0x01
#define IA32_DEBUGCTL_LBR(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Setting this bit to 1 enables the processor to treat EFLAGS.TF as
                 * single-step on branches instead of single-step on instructions.
                 *
                 * @remarks 06_01H
                 */
                UINT64 Btf : 1;
#define IA32_DEBUGCTL_BTF_BIT  1
#define IA32_DEBUGCTL_BTF_FLAG 0x02
#define IA32_DEBUGCTL_BTF_MASK 0x01
#define IA32_DEBUGCTL_BTF(_)   (((_) >> 1) & 0x01)
                UINT64 Reserved1 : 4;

                /**
                 * [Bit 6] Setting this bit to 1 enables branch trace messages to be sent.
                 *
                 * @remarks 06_0EH
                 */
                UINT64 Tr : 1;
#define IA32_DEBUGCTL_TR_BIT  6
#define IA32_DEBUGCTL_TR_FLAG 0x40
#define IA32_DEBUGCTL_TR_MASK 0x01
#define IA32_DEBUGCTL_TR(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] Setting this bit enables branch trace messages (BTMs) to be logged in a
                 * BTS buffer.
                 *
                 * @remarks 06_0EH
                 */
                UINT64 Bts : 1;
#define IA32_DEBUGCTL_BTS_BIT  7
#define IA32_DEBUGCTL_BTS_FLAG 0x80
#define IA32_DEBUGCTL_BTS_MASK 0x01
#define IA32_DEBUGCTL_BTS(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] When clear, BTMs are logged in a BTS buffer in circular fashion. When
                 * this bit is set, an interrupt is generated by the BTS facility when the BTS
                 * buffer is full.
                 *
                 * @remarks 06_0EH
                 */
                UINT64 Btint : 1;
#define IA32_DEBUGCTL_BTINT_BIT  8
#define IA32_DEBUGCTL_BTINT_FLAG 0x100
#define IA32_DEBUGCTL_BTINT_MASK 0x01
#define IA32_DEBUGCTL_BTINT(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bit 9] When set, BTS or BTM is skipped if CPL = 0.
                 *
                 * @remarks 06_0FH
                 */
                UINT64 BtsOffOs : 1;
#define IA32_DEBUGCTL_BTS_OFF_OS_BIT  9
#define IA32_DEBUGCTL_BTS_OFF_OS_FLAG 0x200
#define IA32_DEBUGCTL_BTS_OFF_OS_MASK 0x01
#define IA32_DEBUGCTL_BTS_OFF_OS(_)   (((_) >> 9) & 0x01)

                /**
                 * [Bit 10] When set, BTS or BTM is skipped if CPL > 0.
                 *
                 * @remarks 06_0FH
                 */
                UINT64 BtsOffUsr : 1;
#define IA32_DEBUGCTL_BTS_OFF_USR_BIT  10
#define IA32_DEBUGCTL_BTS_OFF_USR_FLAG 0x400
#define IA32_DEBUGCTL_BTS_OFF_USR_MASK 0x01
#define IA32_DEBUGCTL_BTS_OFF_USR(_)   (((_) >> 10) & 0x01)

                /**
                 * [Bit 11] When set, the LBR stack is frozen on a PMI request.
                 *
                 * @remarks If CPUID.01H: ECX[15] = 1 && CPUID.0AH: EAX[7:0] > 1
                 */
                UINT64 FreezeLbrsOnPmi : 1;
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_BIT  11
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_FLAG 0x800
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI_MASK 0x01
#define IA32_DEBUGCTL_FREEZE_LBRS_ON_PMI(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bit 12] When set, each ENABLE bit of the global counter control MSR are frozen
                 * (address 38FH) on a PMI request.
                 *
                 * @remarks If CPUID.01H: ECX[15] = 1 && CPUID.0AH: EAX[7:0] > 1
                 */
                UINT64 FreezePerfmonOnPmi : 1;
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_BIT  12
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_FLAG 0x1000
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI_MASK 0x01
#define IA32_DEBUGCTL_FREEZE_PERFMON_ON_PMI(_)   (((_) >> 12) & 0x01)

                /**
                 * [Bit 13] When set, enables the logical processor to receive and generate PMI on
                 * behalf of the uncore.
                 *
                 * @remarks 06_1AH
                 */
                UINT64 EnableUncorePmi : 1;
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_BIT  13
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_FLAG 0x2000
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI_MASK 0x01
#define IA32_DEBUGCTL_ENABLE_UNCORE_PMI(_)   (((_) >> 13) & 0x01)

                /**
                 * [Bit 14] When set, freezes perfmon and trace messages while in SMM.
                 *
                 * @remarks If IA32_PERF_CAPABILITIES[12] = 1
                 */
                UINT64 FreezeWhileSmm : 1;
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_BIT  14
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_FLAG 0x4000
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM_MASK 0x01
#define IA32_DEBUGCTL_FREEZE_WHILE_SMM(_)   (((_) >> 14) & 0x01)

                /**
                 * [Bit 15] When set, enables DR7 debug bit on XBEGIN.
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[11] = 1)
                 */
                UINT64 RtmDebug : 1;
#define IA32_DEBUGCTL_RTM_DEBUG_BIT  15
#define IA32_DEBUGCTL_RTM_DEBUG_FLAG 0x8000
#define IA32_DEBUGCTL_RTM_DEBUG_MASK 0x01
#define IA32_DEBUGCTL_RTM_DEBUG(_)   (((_) >> 15) & 0x01)
                UINT64 Reserved2 : 48;
        };

        UINT64 AsUInt;
} IA32_DEBUGCTL_REGISTER;

/**
 * @brief SMRR Base Address <b>(Writeable only in SMM)</b>
 *
 * SMRR Base Address. Base address of SMM memory range.
 *
 * @remarks If IA32_MTRRCAP.SMRR[11] = 1
 */
#define IA32_SMRR_PHYSBASE 0x000001F2
typedef union
{
        struct
        {
                /**
                 * @brief Type
                 *
                 * [Bits 7:0] Type. Specifies memory type of the range.
                 */
                UINT64 Type : 8;
#define IA32_SMRR_PHYSBASE_TYPE_BIT  0
#define IA32_SMRR_PHYSBASE_TYPE_FLAG 0xFF
#define IA32_SMRR_PHYSBASE_TYPE_MASK 0xFF
#define IA32_SMRR_PHYSBASE_TYPE(_)   (((_) >> 0) & 0xFF)
                UINT64 Reserved1 : 4;

                /**
                 * [Bits 31:12] SMRR physical Base Address.
                 */
                UINT64 SmrrPhysicalBaseAddress : 20;
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_BIT  12
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_FLAG 0xFFFFF000
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS_MASK 0xFFFFF
#define IA32_SMRR_PHYSBASE_SMRR_PHYSICAL_BASE_ADDRESS(_)   (((_) >> 12) & 0xFFFFF)
                UINT64 Reserved2 : 32;
        };

        UINT64 AsUInt;
} IA32_SMRR_PHYSBASE_REGISTER;

/**
 * @brief SMRR Range Mask <b>(Writeable only in SMM)</b>
 *
 * Range Mask of SMM memory range.
 *
 * @remarks If IA32_MTRRCAP[SMRR] = 1
 */
#define IA32_SMRR_PHYSMASK 0x000001F3
typedef union
{
        struct
        {
                UINT64 Reserved1 : 11;

                /**
                 * [Bit 11] Enable range mask.
                 */
                UINT64 EnableRangeMask : 1;
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_BIT  11
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_FLAG 0x800
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK_MASK 0x01
#define IA32_SMRR_PHYSMASK_ENABLE_RANGE_MASK(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bits 31:12] SMRR address range mask.
                 */
                UINT64 SmrrAddressRangeMask : 20;
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_BIT  12
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_FLAG 0xFFFFF000
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK_MASK 0xFFFFF
#define IA32_SMRR_PHYSMASK_SMRR_ADDRESS_RANGE_MASK(_)   (((_) >> 12) & 0xFFFFF)
                UINT64 Reserved2 : 32;
        };

        UINT64 AsUInt;
} IA32_SMRR_PHYSMASK_REGISTER;

/**
 * DCA Capability.
 *
 * @remarks If CPUID.01H: ECX[18] = 1
 */
#define IA32_PLATFORM_DCA_CAP 0x000001F8

/**
 * If set, CPU supports Prefetch-Hint type.
 *
 * @remarks If CPUID.01H: ECX[18] = 1
 */
#define IA32_CPU_DCA_CAP 0x000001F9

/**
 * DCA type 0 Status and Control register.
 *
 * @remarks If CPUID.01H: ECX[18] = 1
 */
#define IA32_DCA_0_CAP 0x000001FA
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Set by HW when DCA is fuseenabled and no defeatures are set.
                 */
                UINT64 DcaActive : 1;
#define IA32_DCA_0_CAP_DCA_ACTIVE_BIT  0
#define IA32_DCA_0_CAP_DCA_ACTIVE_FLAG 0x01
#define IA32_DCA_0_CAP_DCA_ACTIVE_MASK 0x01
#define IA32_DCA_0_CAP_DCA_ACTIVE(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bits 2:1] TRANSACTION.
                 */
                UINT64 Transaction : 2;
#define IA32_DCA_0_CAP_TRANSACTION_BIT  1
#define IA32_DCA_0_CAP_TRANSACTION_FLAG 0x06
#define IA32_DCA_0_CAP_TRANSACTION_MASK 0x03
#define IA32_DCA_0_CAP_TRANSACTION(_)   (((_) >> 1) & 0x03)

                /**
                 * [Bits 6:3] DCA_TYPE.
                 */
                UINT64 DcaType : 4;
#define IA32_DCA_0_CAP_DCA_TYPE_BIT  3
#define IA32_DCA_0_CAP_DCA_TYPE_FLAG 0x78
#define IA32_DCA_0_CAP_DCA_TYPE_MASK 0x0F
#define IA32_DCA_0_CAP_DCA_TYPE(_)   (((_) >> 3) & 0x0F)

                /**
                 * [Bits 10:7] DCA_QUEUE_SIZE.
                 */
                UINT64 DcaQueueSize : 4;
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_BIT  7
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_FLAG 0x780
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE_MASK 0x0F
#define IA32_DCA_0_CAP_DCA_QUEUE_SIZE(_)   (((_) >> 7) & 0x0F)
                UINT64 Reserved1 : 2;

                /**
                 * [Bits 16:13] Writes will update the register but have no HW side-effect.
                 */
                UINT64 DcaDelay : 4;
#define IA32_DCA_0_CAP_DCA_DELAY_BIT  13
#define IA32_DCA_0_CAP_DCA_DELAY_FLAG 0x1E000
#define IA32_DCA_0_CAP_DCA_DELAY_MASK 0x0F
#define IA32_DCA_0_CAP_DCA_DELAY(_)   (((_) >> 13) & 0x0F)
                UINT64 Reserved2 : 7;

                /**
                 * [Bit 24] SW can request DCA block by setting this bit.
                 */
                UINT64 SwBlock : 1;
#define IA32_DCA_0_CAP_SW_BLOCK_BIT  24
#define IA32_DCA_0_CAP_SW_BLOCK_FLAG 0x1000000
#define IA32_DCA_0_CAP_SW_BLOCK_MASK 0x01
#define IA32_DCA_0_CAP_SW_BLOCK(_)   (((_) >> 24) & 0x01)
                UINT64 Reserved3 : 1;

                /**
                 * [Bit 26] Set when DCA is blocked by HW (e.g. CR0.CD = 1).
                 */
                UINT64 HwBlock : 1;
#define IA32_DCA_0_CAP_HW_BLOCK_BIT  26
#define IA32_DCA_0_CAP_HW_BLOCK_FLAG 0x4000000
#define IA32_DCA_0_CAP_HW_BLOCK_MASK 0x01
#define IA32_DCA_0_CAP_HW_BLOCK(_)   (((_) >> 26) & 0x01)
                UINT64 Reserved4 : 37;
        };

        UINT64 AsUInt;
} IA32_DCA_0_CAP_REGISTER;

/**
 * @defgroup IA32_MTRR_PHYSBASE \
 *           IA32_MTRR_PHYSBASE(n)
 *
 * IA32_MTRR_PHYSBASE(0-9).
 *
 * @remarks If CPUID.01H: EDX.MTRR[12] = 1
 * @see Vol3A[11.11.2.3(Variable Range MTRRs)]
 * @{
 */
typedef union
{
        struct
        {
                /**
                 * [Bits 7:0] Specifies the memory type for the range.
                 */
                UINT64 Type : 8;
#define IA32_MTRR_PHYSBASE_TYPE_BIT  0
#define IA32_MTRR_PHYSBASE_TYPE_FLAG 0xFF
#define IA32_MTRR_PHYSBASE_TYPE_MASK 0xFF
#define IA32_MTRR_PHYSBASE_TYPE(_)   (((_) >> 0) & 0xFF)
                UINT64 Reserved1 : 4;

                /**
                 * [Bits 47:12] Specifies the base address of the address range. This 24-bit value,
                 * in the case where MAXPHYADDR is 36 bits, is extended by 12 bits at the low end to
                 * form the base address (this automatically aligns the address on a 4-KByte
                 * boundary).
                 */
                UINT64 PageFrameNumber : 36;
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_BIT  12
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define IA32_MTRR_PHYSBASE_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved2 : 16;
        };

        UINT64 AsUInt;
} IA32_MTRR_PHYSBASE_REGISTER;

#define IA32_MTRR_PHYSBASE0 0x00000200
#define IA32_MTRR_PHYSBASE1 0x00000202
#define IA32_MTRR_PHYSBASE2 0x00000204
#define IA32_MTRR_PHYSBASE3 0x00000206
#define IA32_MTRR_PHYSBASE4 0x00000208
#define IA32_MTRR_PHYSBASE5 0x0000020A
#define IA32_MTRR_PHYSBASE6 0x0000020C
#define IA32_MTRR_PHYSBASE7 0x0000020E
#define IA32_MTRR_PHYSBASE8 0x00000210
#define IA32_MTRR_PHYSBASE9 0x00000212
/**
 * @}
 */

/**
 * @defgroup IA32_MTRR_PHYSMASK \
 *           IA32_MTRR_PHYSMASK(n)
 *
 * IA32_MTRR_PHYSMASK(0-9).
 *
 * @remarks If CPUID.01H: EDX.MTRR[12] = 1
 * @see Vol3A[11.11.2.3(Variable Range MTRRs)]
 * @{
 */
typedef union
{
        struct
        {
                UINT64 Reserved1 : 11;

                /**
                 * [Bit 11] Enables the register pair when set; disables register pair when clear.
                 */
                UINT64 Valid : 1;
#define IA32_MTRR_PHYSMASK_VALID_BIT  11
#define IA32_MTRR_PHYSMASK_VALID_FLAG 0x800
#define IA32_MTRR_PHYSMASK_VALID_MASK 0x01
#define IA32_MTRR_PHYSMASK_VALID(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bits 47:12] Specifies a mask (24 bits if the maximum physical address size is 36
                 * bits, 28 bits if the maximum physical address size is 40 bits). The mask
                 * determines the range of the region being mapped, according to the following
                 * relationships:
                 * - Address_Within_Range AND PhysMask = PhysBase AND PhysMask
                 * - This value is extended by 12 bits at the low end to form the mask value.
                 * - The width of the PhysMask field depends on the maximum physical address size
                 * supported by the processor. CPUID.80000008H reports the maximum physical address
                 * size supported by the processor. If CPUID.80000008H is not available, software
                 * may assume that the processor supports a 36-bit physical address size.
                 *
                 * @see Vol3A[11.11.3(Example Base and Mask Calculations)]
                 */
                UINT64 PageFrameNumber : 36;
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_BIT  12
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define IA32_MTRR_PHYSMASK_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved2 : 16;
        };

        UINT64 AsUInt;
} IA32_MTRR_PHYSMASK_REGISTER;

#define IA32_MTRR_PHYSMASK0 0x00000201
#define IA32_MTRR_PHYSMASK1 0x00000203
#define IA32_MTRR_PHYSMASK2 0x00000205
#define IA32_MTRR_PHYSMASK3 0x00000207
#define IA32_MTRR_PHYSMASK4 0x00000209
#define IA32_MTRR_PHYSMASK5 0x0000020B
#define IA32_MTRR_PHYSMASK6 0x0000020D
#define IA32_MTRR_PHYSMASK7 0x0000020F
#define IA32_MTRR_PHYSMASK8 0x00000211
#define IA32_MTRR_PHYSMASK9 0x00000213
/**
 * @}
 */

/**
 * @defgroup IA32_MTRR_FIX \
 *           IA32_MTRR_FIX(x)
 *
 * IA32_MTRR_FIX(x).
 *
 * @remarks If CPUID.01H: EDX.MTRR[12] = 1
 * @see Vol3A[11.11.2.2(Fixed Range MTRRs)]
 * @{
 */
/**
 * @defgroup IA32_MTRR_FIX64K \
 *           IA32_MTRR_FIX64K(x)
 *
 * IA32_MTRR_FIX64K(x).
 * @{
 */
#define IA32_MTRR_FIX64K_BASE  0x00000000
#define IA32_MTRR_FIX64K_SIZE  0x00010000
#define IA32_MTRR_FIX64K_00000 0x00000250
/**
 * @}
 */

/**
 * @defgroup IA32_MTRR_FIX16K \
 *           IA32_MTRR_FIX16K(x)
 *
 * IA32_MTRR_FIX16K(x).
 * @{
 */
#define IA32_MTRR_FIX16K_BASE  0x00080000
#define IA32_MTRR_FIX16K_SIZE  0x00004000
#define IA32_MTRR_FIX16K_80000 0x00000258
#define IA32_MTRR_FIX16K_A0000 0x00000259
/**
 * @}
 */

/**
 * @defgroup IA32_MTRR_FIX4K \
 *           IA32_MTRR_FIX4K(x)
 *
 * IA32_MTRR_FIX4K(x).
 * @{
 */
#define IA32_MTRR_FIX4K_BASE  0x000C0000
#define IA32_MTRR_FIX4K_SIZE  0x00001000
#define IA32_MTRR_FIX4K_C0000 0x00000268
#define IA32_MTRR_FIX4K_C8000 0x00000269
#define IA32_MTRR_FIX4K_D0000 0x0000026A
#define IA32_MTRR_FIX4K_D8000 0x0000026B
#define IA32_MTRR_FIX4K_E0000 0x0000026C
#define IA32_MTRR_FIX4K_E8000 0x0000026D
#define IA32_MTRR_FIX4K_F0000 0x0000026E
#define IA32_MTRR_FIX4K_F8000 0x0000026F
/**
 * @}
 */

/**
 * Architecture defined number of fixed range MTRRs (1 for 64k, 2 for 16k, 8 for 4k).
 */
#define IA32_MTRR_FIX_COUNT ((1 + 2 + 8) * 8)

/**
 * Architecture defined number of variable range MTRRs. See: Table 2-2. IA-32 Architectural MSRs
 *
 * @see Vol3A[2.1(ARCHITECTURAL MSRS)]
 */
#define IA32_MTRR_VARIABLE_COUNT 0x0000000A

/**
 * A size of array to store all possible MTRRs.
 */
#define IA32_MTRR_COUNT (IA32_MTRR_FIX_COUNT + IA32_MTRR_VARIABLE_COUNT)
/**
 * @}
 */

/**
 * IA32_PAT.
 *
 * @remarks If CPUID.01H: EDX.MTRR[16] = 1
 */
#define IA32_PAT 0x00000277
typedef union
{
        struct
        {
                /**
                 * [Bits 2:0] PA0.
                 */
                UINT64 Pa0 : 3;
#define IA32_PAT_PA0_BIT  0
#define IA32_PAT_PA0_FLAG 0x07
#define IA32_PAT_PA0_MASK 0x07
#define IA32_PAT_PA0(_)   (((_) >> 0) & 0x07)
                UINT64 Reserved1 : 5;

                /**
                 * [Bits 10:8] PA1.
                 */
                UINT64 Pa1 : 3;
#define IA32_PAT_PA1_BIT  8
#define IA32_PAT_PA1_FLAG 0x700
#define IA32_PAT_PA1_MASK 0x07
#define IA32_PAT_PA1(_)   (((_) >> 8) & 0x07)
                UINT64 Reserved2 : 5;

                /**
                 * [Bits 18:16] PA2.
                 */
                UINT64 Pa2 : 3;
#define IA32_PAT_PA2_BIT  16
#define IA32_PAT_PA2_FLAG 0x70000
#define IA32_PAT_PA2_MASK 0x07
#define IA32_PAT_PA2(_)   (((_) >> 16) & 0x07)
                UINT64 Reserved3 : 5;

                /**
                 * [Bits 26:24] PA3.
                 */
                UINT64 Pa3 : 3;
#define IA32_PAT_PA3_BIT  24
#define IA32_PAT_PA3_FLAG 0x7000000
#define IA32_PAT_PA3_MASK 0x07
#define IA32_PAT_PA3(_)   (((_) >> 24) & 0x07)
                UINT64 Reserved4 : 5;

                /**
                 * [Bits 34:32] PA4.
                 */
                UINT64 Pa4 : 3;
#define IA32_PAT_PA4_BIT  32
#define IA32_PAT_PA4_FLAG 0x700000000
#define IA32_PAT_PA4_MASK 0x07
#define IA32_PAT_PA4(_)   (((_) >> 32) & 0x07)
                UINT64 Reserved5 : 5;

                /**
                 * [Bits 42:40] PA5.
                 */
                UINT64 Pa5 : 3;
#define IA32_PAT_PA5_BIT  40
#define IA32_PAT_PA5_FLAG 0x70000000000
#define IA32_PAT_PA5_MASK 0x07
#define IA32_PAT_PA5(_)   (((_) >> 40) & 0x07)
                UINT64 Reserved6 : 5;

                /**
                 * [Bits 50:48] PA6.
                 */
                UINT64 Pa6 : 3;
#define IA32_PAT_PA6_BIT  48
#define IA32_PAT_PA6_FLAG 0x7000000000000
#define IA32_PAT_PA6_MASK 0x07
#define IA32_PAT_PA6(_)   (((_) >> 48) & 0x07)
                UINT64 Reserved7 : 5;

                /**
                 * [Bits 58:56] PA7.
                 */
                UINT64 Pa7 : 3;
#define IA32_PAT_PA7_BIT  56
#define IA32_PAT_PA7_FLAG 0x700000000000000
#define IA32_PAT_PA7_MASK 0x07
#define IA32_PAT_PA7(_)   (((_) >> 56) & 0x07)
                UINT64 Reserved8 : 5;
        };

        UINT64 AsUInt;
} IA32_PAT_REGISTER;

/**
 * @defgroup IA32_MC_CTL2 \
 *           IA32_MC(i)_CTL2
 *
 * MSR to enable/disable CMCI capability for bank n.
 *
 * @remarks If IA32_MCG_CAP[10] = 1 && IA32_MCG_CAP[7:0] > n
 * @see Vol3B[15.3.2.5(IA32_MCi_CTL2 MSRs)]
 * @{
 */
#define IA32_MC0_CTL2  0x00000280
#define IA32_MC1_CTL2  0x00000281
#define IA32_MC2_CTL2  0x00000282
#define IA32_MC3_CTL2  0x00000283
#define IA32_MC4_CTL2  0x00000284
#define IA32_MC5_CTL2  0x00000285
#define IA32_MC6_CTL2  0x00000286
#define IA32_MC7_CTL2  0x00000287
#define IA32_MC8_CTL2  0x00000288
#define IA32_MC9_CTL2  0x00000289
#define IA32_MC10_CTL2 0x0000028A
#define IA32_MC11_CTL2 0x0000028B
#define IA32_MC12_CTL2 0x0000028C
#define IA32_MC13_CTL2 0x0000028D
#define IA32_MC14_CTL2 0x0000028E
#define IA32_MC15_CTL2 0x0000028F
#define IA32_MC16_CTL2 0x00000290
#define IA32_MC17_CTL2 0x00000291
#define IA32_MC18_CTL2 0x00000292
#define IA32_MC19_CTL2 0x00000293
#define IA32_MC20_CTL2 0x00000294
#define IA32_MC21_CTL2 0x00000295
#define IA32_MC22_CTL2 0x00000296
#define IA32_MC23_CTL2 0x00000297
#define IA32_MC24_CTL2 0x00000298
#define IA32_MC25_CTL2 0x00000299
#define IA32_MC26_CTL2 0x0000029A
#define IA32_MC27_CTL2 0x0000029B
#define IA32_MC28_CTL2 0x0000029C
#define IA32_MC29_CTL2 0x0000029D
#define IA32_MC30_CTL2 0x0000029E
#define IA32_MC31_CTL2 0x0000029F
typedef union
{
        struct
        {
                /**
                 * [Bits 14:0] Corrected error count threshold.
                 */
                UINT64 CorrectedErrorCountThreshold : 15;
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_BIT  0
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_FLAG 0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD_MASK 0x7FFF
#define IA32_MC_CTL2_CORRECTED_ERROR_COUNT_THRESHOLD(_)   (((_) >> 0) & 0x7FFF)
                UINT64 Reserved1 : 15;

                /**
                 * [Bit 30] CMCI_EN.
                 */
                UINT64 CmciEn : 1;
#define IA32_MC_CTL2_CMCI_EN_BIT  30
#define IA32_MC_CTL2_CMCI_EN_FLAG 0x40000000
#define IA32_MC_CTL2_CMCI_EN_MASK 0x01
#define IA32_MC_CTL2_CMCI_EN(_)   (((_) >> 30) & 0x01)
                UINT64 Reserved2 : 33;
        };

        UINT64 AsUInt;
} IA32_MC_CTL2_REGISTER;

/**
 * @}
 */

/**
 * IA32_MTRR_DEF_TYPE.
 *
 * @remarks If CPUID.01H: EDX.MTRR[12] = 1
 */
#define IA32_MTRR_DEF_TYPE 0x000002FF
typedef union
{
        struct
        {
                /**
                 * [Bits 2:0] Default Memory Type.
                 */
                UINT64 DefaultMemoryType : 3;
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_BIT  0
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_FLAG 0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_MASK 0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE(_)   (((_) >> 0) & 0x07)
                UINT64 Reserved1 : 7;

                /**
                 * [Bit 10] Fixed Range MTRR Enable.
                 */
                UINT64 FixedRangeMtrrEnable : 1;
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_BIT  10
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_FLAG 0x400
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_MASK 0x01
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE(_)   (((_) >> 10) & 0x01)

                /**
                 * [Bit 11] MTRR Enable.
                 */
                UINT64 MtrrEnable : 1;
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_BIT  11
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_FLAG 0x800
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_MASK 0x01
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE(_)   (((_) >> 11) & 0x01)
                UINT64 Reserved2 : 52;
        };

        UINT64 AsUInt;
} IA32_MTRR_DEF_TYPE_REGISTER;

/**
 * @defgroup IA32_FIXED_CTR \
 *           IA32_FIXED_CTR(n)
 *
 * Fixed-Function Performance Counter n.
 *
 * @remarks If CPUID.0AH: EDX[4:0] > n
 * @{
 */
/**
 * Counts Instr_Retired.Any.
 */
#define IA32_FIXED_CTR0 0x00000309

/**
 * Counts CPU_CLK_Unhalted.Core
 */
#define IA32_FIXED_CTR1 0x0000030A

/**
 * Counts CPU_CLK_Unhalted.Ref
 */
#define IA32_FIXED_CTR2 0x0000030B
/**
 * @}
 */

/**
 * Read Only MSR that enumerates the existence of performance monitoring features.
 *
 * @remarks If CPUID.01H: ECX[15] = 1
 */
#define IA32_PERF_CAPABILITIES 0x00000345
typedef union
{
        struct
        {
                /**
                 * [Bits 5:0] LBR format.
                 */
                UINT64 LbrFormat : 6;
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_BIT  0
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_FLAG 0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT_MASK 0x3F
#define IA32_PERF_CAPABILITIES_LBR_FORMAT(_)   (((_) >> 0) & 0x3F)

                /**
                 * [Bit 6] PEBS Trap.
                 */
                UINT64 PebsTrap : 1;
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_BIT  6
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_FLAG 0x40
#define IA32_PERF_CAPABILITIES_PEBS_TRAP_MASK 0x01
#define IA32_PERF_CAPABILITIES_PEBS_TRAP(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] PEBSSaveArchRegs.
                 */
                UINT64 PebsSaveArchRegs : 1;
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_BIT  7
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_FLAG 0x80
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS_MASK 0x01
#define IA32_PERF_CAPABILITIES_PEBS_SAVE_ARCH_REGS(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bits 11:8] PEBS Record Format.
                 */
                UINT64 PebsRecordFormat : 4;
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_BIT  8
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_FLAG 0xF00
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT_MASK 0x0F
#define IA32_PERF_CAPABILITIES_PEBS_RECORD_FORMAT(_)   (((_) >> 8) & 0x0F)

                /**
                 * [Bit 12] Freeze while SMM is supported.
                 */
                UINT64 FreezeWhileSmmIsSupported : 1;
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_BIT  12
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_FLAG 0x1000
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED_MASK 0x01
#define IA32_PERF_CAPABILITIES_FREEZE_WHILE_SMM_IS_SUPPORTED(_)   (((_) >> 12) & 0x01)

                /**
                 * [Bit 13] Full width of counter writable via IA32_A_PMCx.
                 */
                UINT64 FullWidthCounterWrite : 1;
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_BIT  13
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_FLAG 0x2000
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE_MASK 0x01
#define IA32_PERF_CAPABILITIES_FULL_WIDTH_COUNTER_WRITE(_)   (((_) >> 13) & 0x01)
                UINT64 Reserved1 : 50;
        };

        UINT64 AsUInt;
} IA32_PERF_CAPABILITIES_REGISTER;

/**
 * @brief Fixed-Function Performance Counter Control <b>(R/W)</b>
 *
 * Fixed-Function Performance Counter Control. Counter increments while the results of ANDing
 * respective enable bit in IA32_PERF_GLOBAL_CTRL with the corresponding OS or USR bits in this MSR
 * is true.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 1
 */
#define IA32_FIXED_CTR_CTRL 0x0000038D
typedef union
{
        struct
        {
                /**
                 * [Bit 0] EN0_OS: Enable Fixed Counter 0 to count while CPL = 0.
                 */
                UINT64 En0Os : 1;
#define IA32_FIXED_CTR_CTRL_EN0_OS_BIT  0
#define IA32_FIXED_CTR_CTRL_EN0_OS_FLAG 0x01
#define IA32_FIXED_CTR_CTRL_EN0_OS_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN0_OS(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] EN0_Usr: Enable Fixed Counter 0 to count while CPL > 0.
                 */
                UINT64 En0Usr : 1;
#define IA32_FIXED_CTR_CTRL_EN0_USR_BIT  1
#define IA32_FIXED_CTR_CTRL_EN0_USR_FLAG 0x02
#define IA32_FIXED_CTR_CTRL_EN0_USR_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN0_USR(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] AnyThread: When set to 1, it enables counting the associated event
                 * conditions occurring across all logical processors sharing a processor core. When
                 * set to 0, the counter only increments the associated event conditions occurring
                 * in the logical processor which programmed the MSR.
                 */
                UINT64 AnyThread0 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_BIT  2
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_FLAG 0x04
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0_MASK 0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD0(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] EN0_PMI: Enable PMI when fixed counter 0 overflows.
                 */
                UINT64 En0Pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN0_PMI_BIT  3
#define IA32_FIXED_CTR_CTRL_EN0_PMI_FLAG 0x08
#define IA32_FIXED_CTR_CTRL_EN0_PMI_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN0_PMI(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] EN1_OS: Enable Fixed Counter 1 to count while CPL = 0.
                 */
                UINT64 En1Os : 1;
#define IA32_FIXED_CTR_CTRL_EN1_OS_BIT  4
#define IA32_FIXED_CTR_CTRL_EN1_OS_FLAG 0x10
#define IA32_FIXED_CTR_CTRL_EN1_OS_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN1_OS(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] EN1_Usr: Enable Fixed Counter 1 to count while CPL > 0.
                 */
                UINT64 En1Usr : 1;
#define IA32_FIXED_CTR_CTRL_EN1_USR_BIT  5
#define IA32_FIXED_CTR_CTRL_EN1_USR_FLAG 0x20
#define IA32_FIXED_CTR_CTRL_EN1_USR_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN1_USR(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] AnyThread: When set to 1, it enables counting the associated event
                 * conditions occurring across all logical processors sharing a processor core. When
                 * set to 0, the counter only increments the associated event conditions occurring
                 * in the logical processor which programmed the MSR.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 2
                 */
                UINT64 AnyThread1 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_BIT  6
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_FLAG 0x40
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1_MASK 0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD1(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] EN1_PMI: Enable PMI when fixed counter 1 overflows.
                 */
                UINT64 En1Pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN1_PMI_BIT  7
#define IA32_FIXED_CTR_CTRL_EN1_PMI_FLAG 0x80
#define IA32_FIXED_CTR_CTRL_EN1_PMI_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN1_PMI(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] EN2_OS: Enable Fixed Counter 2 to count while CPL = 0.
                 */
                UINT64 En2Os : 1;
#define IA32_FIXED_CTR_CTRL_EN2_OS_BIT  8
#define IA32_FIXED_CTR_CTRL_EN2_OS_FLAG 0x100
#define IA32_FIXED_CTR_CTRL_EN2_OS_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN2_OS(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bit 9] EN2_Usr: Enable Fixed Counter 2 to count while CPL > 0.
                 */
                UINT64 En2Usr : 1;
#define IA32_FIXED_CTR_CTRL_EN2_USR_BIT  9
#define IA32_FIXED_CTR_CTRL_EN2_USR_FLAG 0x200
#define IA32_FIXED_CTR_CTRL_EN2_USR_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN2_USR(_)   (((_) >> 9) & 0x01)

                /**
                 * [Bit 10] AnyThread: When set to 1, it enables counting the associated event
                 * conditions occurring across all logical processors sharing a processor core. When
                 * set to 0, the counter only increments the associated event conditions occurring
                 * in the logical processor which programmed the MSR.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 2
                 */
                UINT64 AnyThread2 : 1;
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_BIT  10
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_FLAG 0x400
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2_MASK 0x01
#define IA32_FIXED_CTR_CTRL_ANY_THREAD2(_)   (((_) >> 10) & 0x01)

                /**
                 * [Bit 11] EN2_PMI: Enable PMI when fixed counter 2 overflows.
                 */
                UINT64 En2Pmi : 1;
#define IA32_FIXED_CTR_CTRL_EN2_PMI_BIT  11
#define IA32_FIXED_CTR_CTRL_EN2_PMI_FLAG 0x800
#define IA32_FIXED_CTR_CTRL_EN2_PMI_MASK 0x01
#define IA32_FIXED_CTR_CTRL_EN2_PMI(_)   (((_) >> 11) & 0x01)
                UINT64 Reserved1 : 52;
        };

        UINT64 AsUInt;
} IA32_FIXED_CTR_CTRL_REGISTER;

/**
 * Global Performance Counter Status.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 0
 */
#define IA32_PERF_GLOBAL_STATUS 0x0000038E
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Ovf_PMC0: Overflow status of IA32_PMC0.
                 *
                 * @remarks If CPUID.0AH: EAX[15:8] > 0
                 */
                UINT64 OvfPmc0 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_BIT  0
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_FLAG 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC0(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Ovf_PMC1: Overflow status of IA32_PMC1.
                 *
                 * @remarks If CPUID.0AH: EAX[15:8] > 1
                 */
                UINT64 OvfPmc1 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_BIT  1
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_FLAG 0x02
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC1(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] Ovf_PMC2: Overflow status of IA32_PMC2.
                 *
                 * @remarks If CPUID.0AH: EAX[15:8] > 2
                 */
                UINT64 OvfPmc2 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_BIT  2
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_FLAG 0x04
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC2(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Ovf_PMC3: Overflow status of IA32_PMC3.
                 *
                 * @remarks If CPUID.0AH: EAX[15:8] > 3
                 */
                UINT64 OvfPmc3 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_BIT  3
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_FLAG 0x08
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_PMC3(_)   (((_) >> 3) & 0x01)
                UINT64 Reserved1 : 28;

                /**
                 * [Bit 32] Ovf_FixedCtr0: Overflow status of IA32_FIXED_CTR0.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 1
                 */
                UINT64 OvfFixedctr0 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_BIT  32
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_FLAG 0x100000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR0(_)   (((_) >> 32) & 0x01)

                /**
                 * [Bit 33] Ovf_FixedCtr1: Overflow status of IA32_FIXED_CTR1.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 1
                 */
                UINT64 OvfFixedctr1 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_BIT  33
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_FLAG 0x200000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR1(_)   (((_) >> 33) & 0x01)

                /**
                 * [Bit 34] Ovf_FixedCtr2: Overflow status of IA32_FIXED_CTR2.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 1
                 */
                UINT64 OvfFixedctr2 : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_BIT  34
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_FLAG 0x400000000
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_FIXEDCTR2(_)   (((_) >> 34) & 0x01)
                UINT64 Reserved2 : 20;

                /**
                 * [Bit 55] Trace_ToPA_PMI: A PMI occurred due to a ToPA entry memory buffer that
                 * was completely filled.
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && IA32_RTIT_CTL.ToPA = 1
                 */
                UINT64 TraceTopaPmi : 1;
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_BIT  55
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_FLAG 0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_TRACE_TOPA_PMI(_)   (((_) >> 55) & 0x01)
                UINT64 Reserved3 : 2;

                /**
                 * [Bit 58] LBR_Frz. LBRs are frozen due to:
                 * * IA32_DEBUGCTL.FREEZE_LBR_ON_PMI=1.
                 * * The LBR stack overflowed.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 3
                 */
                UINT64 LbrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_BIT  58
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_FLAG 0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_LBR_FRZ(_)   (((_) >> 58) & 0x01)

                /**
                 * [Bit 59] CTR_Frz. Performance counters in the core PMU are frozen due to:
                 * * IA32_DEBUGCTL.FREEZE_PERFMON_ON_PMI=1.
                 * * One or more core PMU counters overflowed.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 3
                 */
                UINT64 CtrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_BIT  59
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_FLAG 0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_CTR_FRZ(_)   (((_) >> 59) & 0x01)

                /**
                 * [Bit 60] ASCI: Data in the performance counters in the core PMU may include
                 * contributions from the direct or indirect operation Intel SGX to protect an
                 * enclave.
                 *
                 * @remarks If CPUID.(EAX=07H, ECX=0):EBX[2] = 1
                 */
                UINT64 Asci : 1;
#define IA32_PERF_GLOBAL_STATUS_ASCI_BIT  60
#define IA32_PERF_GLOBAL_STATUS_ASCI_FLAG 0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_ASCI_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_ASCI(_)   (((_) >> 60) & 0x01)

                /**
                 * [Bit 61] Uncore counter overflow status.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 2
                 */
                UINT64 OvfUncore : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_BIT  61
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_FLAG 0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_UNCORE(_)   (((_) >> 61) & 0x01)

                /**
                 * [Bit 62] OvfBuf: DS SAVE area Buffer overflow status.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 0
                 */
                UINT64 OvfBuf : 1;
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_BIT  62
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_FLAG 0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_OVF_BUF(_)   (((_) >> 62) & 0x01)

                /**
                 * [Bit 63] CondChgd: Status bits of this register have changed.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 0
                 */
                UINT64 CondChgd : 1;
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_BIT  63
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_FLAG 0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_COND_CHGD(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} IA32_PERF_GLOBAL_STATUS_REGISTER;

/**
 * @brief Global Performance Counter Control <b>(R/W)</b>
 *
 * Global Performance Counter Control. Counter increments while the result of ANDing the respective
 * enable bit in this MSR with the corresponding OS or USR bits in the general-purpose or fixed
 * counter control MSR is true.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 0
 */
#define IA32_PERF_GLOBAL_CTRL 0x0000038F
typedef union
{
        struct
        {
                /**
                 * [Bits 31:0] EN_PMC(n). Enable bitmask. Only the first n-1 bits are valid. Bits
                 * 31:n are reserved.
                 *
                 * @remarks If CPUID.0AH: EAX[15:8] > n
                 */
                UINT64 EnPmcn : 32;
#define IA32_PERF_GLOBAL_CTRL_EN_PMCN_BIT  0
#define IA32_PERF_GLOBAL_CTRL_EN_PMCN_FLAG 0xFFFFFFFF
#define IA32_PERF_GLOBAL_CTRL_EN_PMCN_MASK 0xFFFFFFFF
#define IA32_PERF_GLOBAL_CTRL_EN_PMCN(_)   (((_) >> 0) & 0xFFFFFFFF)

                /**
                 * [Bits 63:32] EN_FIXED_CTR(n). Enable bitmask. Only the first n-1 bits are valid.
                 * Bits 31:n are reserved.
                 *
                 * @remarks If CPUID.0AH: EDX[4:0] > n
                 */
                UINT64 EnFixedCtrn : 32;
#define IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN_BIT  32
#define IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN_FLAG 0xFFFFFFFF00000000
#define IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN_MASK 0xFFFFFFFF
#define IA32_PERF_GLOBAL_CTRL_EN_FIXED_CTRN(_)   (((_) >> 32) & 0xFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_PERF_GLOBAL_CTRL_REGISTER;

/**
 * Global Performance Counter Overflow Reset Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_STATUS_RESET 0x00000390
typedef union
{
        struct
        {
                /**
                 * [Bits 31:0] Set 1 to clear Ovf_PMC(n) bit. Clear bitmask. Only the first n-1 bits
                 * are valid. Bits 31:n are reserved.
                 *
                 * @remarks If CPUID.0AH: EAX[15:8] > n
                 */
                UINT64 ClearOvfPmcn : 32;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_BIT  0
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_FLAG 0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN_MASK 0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_PMCN(_)   (((_) >> 0) & 0xFFFFFFFF)

                /**
                 * [Bits 34:32] Set 1 to clear Ovf_FIXED_CTR(n) bit. Clear bitmask. Only the first
                 * n-1 bits are valid. Bits 31:n are reserved.
                 *
                 * @remarks If CPUID.0AH: EDX[4:0] > n
                 */
                UINT64 ClearOvfFixedCtrn : 3;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_BIT  32
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_FLAG 0x700000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN_MASK 0x07
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_FIXED_CTRN(_)   (((_) >> 32) & 0x07)
                UINT64 Reserved1 : 20;

                /**
                 * [Bit 55] Set 1 to clear Trace_ToPA_PMI bit.
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && IA32_RTIT_CTL.ToPA = 1
                 */
                UINT64 ClearTraceTopaPmi : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_BIT  55
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_FLAG 0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_TRACE_TOPA_PMI(_)   (((_) >> 55) & 0x01)
                UINT64 Reserved2 : 2;

                /**
                 * [Bit 58] Set 1 to clear LBR_Frz bit.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 3
                 */
                UINT64 ClearLbrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_BIT  58
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_FLAG 0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_LBR_FRZ(_)   (((_) >> 58) & 0x01)

                /**
                 * [Bit 59] Set 1 to clear CTR_Frz bit.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 3
                 */
                UINT64 ClearCtrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_BIT  59
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_FLAG 0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_CTR_FRZ(_)   (((_) >> 59) & 0x01)

                /**
                 * [Bit 60] Set 1 to clear ASCI bit.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 3
                 */
                UINT64 ClearAsci : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_BIT  60
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_FLAG 0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_ASCI(_)   (((_) >> 60) & 0x01)

                /**
                 * [Bit 61] Set 1 to clear Ovf_Uncore bit.
                 *
                 * @remarks 06_2EH
                 */
                UINT64 ClearOvfUncore : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_BIT  61
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_FLAG 0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_UNCORE(_)   (((_) >> 61) & 0x01)

                /**
                 * [Bit 62] Set 1 to clear OvfBuf bit.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 0
                 */
                UINT64 ClearOvfBuf : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_BIT  62
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_FLAG 0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_OVF_BUF(_)   (((_) >> 62) & 0x01)

                /**
                 * [Bit 63] Set 1 to clear CondChgd bit.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 0
                 */
                UINT64 ClearCondChgd : 1;
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_BIT  63
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_FLAG 0x8000000000000000
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_RESET_CLEAR_COND_CHGD(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} IA32_PERF_GLOBAL_STATUS_RESET_REGISTER;

/**
 * Global Performance Counter Overflow Set Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_STATUS_SET 0x00000391
typedef union
{
        struct
        {
                /**
                 * [Bits 31:0] Set 1 to cause Ovf_PMC(n) = 1. Set bitmask. Only the first n-1 bits
                 * are valid. Bits 31:n are reserved.
                 *
                 * @remarks If CPUID.0AH: EAX[15:8] > n
                 */
                UINT64 OvfPmcn : 32;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_BIT  0
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_FLAG 0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN_MASK 0xFFFFFFFF
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_PMCN(_)   (((_) >> 0) & 0xFFFFFFFF)

                /**
                 * [Bits 34:32] Set 1 to cause Ovf_FIXED_CTR(n) = 1. Set bitmask. Only the first n-1
                 * bits are valid. Bits 31:n are reserved.
                 *
                 * @remarks If CPUID.0AH: EDX[4:0] > n
                 */
                UINT64 OvfFixedCtrn : 3;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_BIT  32
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_FLAG 0x700000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN_MASK 0x07
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_FIXED_CTRN(_)   (((_) >> 32) & 0x07)
                UINT64 Reserved1 : 20;

                /**
                 * [Bit 55] Set 1 to cause Trace_ToPA_PMI = 1.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 3
                 */
                UINT64 TraceTopaPmi : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_BIT  55
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_FLAG 0x80000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_SET_TRACE_TOPA_PMI(_)   (((_) >> 55) & 0x01)
                UINT64 Reserved2 : 2;

                /**
                 * [Bit 58] Set 1 to cause LBR_Frz = 1.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 3
                 */
                UINT64 LbrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_BIT  58
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_FLAG 0x400000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_SET_LBR_FRZ(_)   (((_) >> 58) & 0x01)

                /**
                 * [Bit 59] Set 1 to cause CTR_Frz = 1.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 3
                 */
                UINT64 CtrFrz : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_BIT  59
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_FLAG 0x800000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_SET_CTR_FRZ(_)   (((_) >> 59) & 0x01)

                /**
                 * [Bit 60] Set 1 to cause ASCI = 1.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 3
                 */
                UINT64 Asci : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_BIT  60
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_FLAG 0x1000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_SET_ASCI(_)   (((_) >> 60) & 0x01)

                /**
                 * [Bit 61] Set 1 to cause Ovf_Uncore = 1.
                 *
                 * @remarks 06_2EH
                 */
                UINT64 OvfUncore : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_BIT  61
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_FLAG 0x2000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_UNCORE(_)   (((_) >> 61) & 0x01)

                /**
                 * [Bit 62] Set 1 to cause OvfBuf = 1.
                 *
                 * @remarks If CPUID.0AH: EAX[7:0] > 3
                 */
                UINT64 OvfBuf : 1;
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_BIT  62
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_FLAG 0x4000000000000000
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF_MASK 0x01
#define IA32_PERF_GLOBAL_STATUS_SET_OVF_BUF(_)   (((_) >> 62) & 0x01)
                UINT64 Reserved3 : 1;
        };

        UINT64 AsUInt;
} IA32_PERF_GLOBAL_STATUS_SET_REGISTER;

/**
 * Indicator that core perfmon interface is in use.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PERF_GLOBAL_INUSE 0x00000392
typedef union
{
        struct
        {
                /**
                 * [Bits 31:0] IA32_PERFEVTSEL(n) in use. Status bitmask. Only the first n-1 bits
                 * are valid. Bits 31:n are reserved.
                 *
                 * @remarks If CPUID.0AH: EAX[15:8] > n
                 */
                UINT64 Ia32PerfevtselnInUse : 32;
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_BIT  0
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_FLAG 0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE_MASK 0xFFFFFFFF
#define IA32_PERF_GLOBAL_INUSE_IA32_PERFEVTSELN_IN_USE(_)   (((_) >> 0) & 0xFFFFFFFF)

                /**
                 * [Bits 34:32] IA32_FIXED_CTR(n) in use. Status bitmask. Only the first n-1 bits
                 * are valid. Bits 31:n are reserved.
                 */
                UINT64 Ia32FixedCtrnInUse : 3;
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_BIT  32
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_FLAG 0x700000000
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE_MASK 0x07
#define IA32_PERF_GLOBAL_INUSE_IA32_FIXED_CTRN_IN_USE(_)   (((_) >> 32) & 0x07)
                UINT64 Reserved1 : 28;

                /**
                 * [Bit 63] PMI in use.
                 */
                UINT64 PmiInUse : 1;
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_BIT  63
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_FLAG 0x8000000000000000
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE_MASK 0x01
#define IA32_PERF_GLOBAL_INUSE_PMI_IN_USE(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} IA32_PERF_GLOBAL_INUSE_REGISTER;

/**
 * PEBS Control.
 *
 * @remarks If CPUID.0AH: EAX[7:0] > 3
 */
#define IA32_PEBS_ENABLE 0x000003F1
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Enable PEBS on IA32_PMC0.
                 *
                 * @remarks 06_0FH
                 */
                UINT64 EnablePebs : 1;
#define IA32_PEBS_ENABLE_ENABLE_PEBS_BIT  0
#define IA32_PEBS_ENABLE_ENABLE_PEBS_FLAG 0x01
#define IA32_PEBS_ENABLE_ENABLE_PEBS_MASK 0x01
#define IA32_PEBS_ENABLE_ENABLE_PEBS(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bits 3:1] Reserved or model specific.
                 */
                UINT64 Reservedormodelspecific1 : 3;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_BIT  1
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_FLAG 0x0E
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1_MASK 0x07
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC1(_)   (((_) >> 1) & 0x07)
                UINT64 Reserved1 : 28;

                /**
                 * [Bits 35:32] Reserved or model specific.
                 */
                UINT64 Reservedormodelspecific2 : 4;
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_BIT  32
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_FLAG 0xF00000000
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2_MASK 0x0F
#define IA32_PEBS_ENABLE_RESERVEDORMODELSPECIFIC2(_)   (((_) >> 32) & 0x0F)
                UINT64 Reserved2 : 28;
        };

        UINT64 AsUInt;
} IA32_PEBS_ENABLE_REGISTER;

/**
 * @defgroup IA32_MC_CTL \
 *           IA32_MC(i)_CTL
 *
 * IA32_MC(0-28)_CTL.
 *
 * @remarks If IA32_MCG_CAP.CNT > n
 * @{
 */
#define IA32_MC0_CTL  0x00000400
#define IA32_MC1_CTL  0x00000404
#define IA32_MC2_CTL  0x00000408
#define IA32_MC3_CTL  0x0000040C
#define IA32_MC4_CTL  0x00000410
#define IA32_MC5_CTL  0x00000414
#define IA32_MC6_CTL  0x00000418
#define IA32_MC7_CTL  0x0000041C
#define IA32_MC8_CTL  0x00000420
#define IA32_MC9_CTL  0x00000424
#define IA32_MC10_CTL 0x00000428
#define IA32_MC11_CTL 0x0000042C
#define IA32_MC12_CTL 0x00000430
#define IA32_MC13_CTL 0x00000434
#define IA32_MC14_CTL 0x00000438
#define IA32_MC15_CTL 0x0000043C
#define IA32_MC16_CTL 0x00000440
#define IA32_MC17_CTL 0x00000444
#define IA32_MC18_CTL 0x00000448
#define IA32_MC19_CTL 0x0000044C
#define IA32_MC20_CTL 0x00000450
#define IA32_MC21_CTL 0x00000454
#define IA32_MC22_CTL 0x00000458
#define IA32_MC23_CTL 0x0000045C
#define IA32_MC24_CTL 0x00000460
#define IA32_MC25_CTL 0x00000464
#define IA32_MC26_CTL 0x00000468
#define IA32_MC27_CTL 0x0000046C
#define IA32_MC28_CTL 0x00000470
/**
 * @}
 */

/**
 * @defgroup IA32_MC_STATUS \
 *           IA32_MC(i)_STATUS
 *
 * IA32_MC(0-28)_STATUS.
 *
 * @remarks If IA32_MCG_CAP.CNT > n
 * @{
 */
#define IA32_MC0_STATUS  0x00000401
#define IA32_MC1_STATUS  0x00000405
#define IA32_MC2_STATUS  0x00000409
#define IA32_MC3_STATUS  0x0000040D
#define IA32_MC4_STATUS  0x00000411
#define IA32_MC5_STATUS  0x00000415
#define IA32_MC6_STATUS  0x00000419
#define IA32_MC7_STATUS  0x0000041D
#define IA32_MC8_STATUS  0x00000421
#define IA32_MC9_STATUS  0x00000425
#define IA32_MC10_STATUS 0x00000429
#define IA32_MC11_STATUS 0x0000042D
#define IA32_MC12_STATUS 0x00000431
#define IA32_MC13_STATUS 0x00000435
#define IA32_MC14_STATUS 0x00000439
#define IA32_MC15_STATUS 0x0000043D
#define IA32_MC16_STATUS 0x00000441
#define IA32_MC17_STATUS 0x00000445
#define IA32_MC18_STATUS 0x00000449
#define IA32_MC19_STATUS 0x0000044D
#define IA32_MC20_STATUS 0x00000451
#define IA32_MC21_STATUS 0x00000455
#define IA32_MC22_STATUS 0x00000459
#define IA32_MC23_STATUS 0x0000045D
#define IA32_MC24_STATUS 0x00000461
#define IA32_MC25_STATUS 0x00000465
#define IA32_MC26_STATUS 0x00000469
#define IA32_MC27_STATUS 0x0000046D
#define IA32_MC28_STATUS 0x00000471
/**
 * @}
 */

/**
 * @defgroup IA32_MC_ADDR \
 *           IA32_MC(i)_ADDR
 *
 * IA32_MC(0-28)_ADDR.
 *
 * @remarks If IA32_MCG_CAP.CNT > n
 * @{
 */
#define IA32_MC0_ADDR  0x00000402
#define IA32_MC1_ADDR  0x00000406
#define IA32_MC2_ADDR  0x0000040A
#define IA32_MC3_ADDR  0x0000040E
#define IA32_MC4_ADDR  0x00000412
#define IA32_MC5_ADDR  0x00000416
#define IA32_MC6_ADDR  0x0000041A
#define IA32_MC7_ADDR  0x0000041E
#define IA32_MC8_ADDR  0x00000422
#define IA32_MC9_ADDR  0x00000426
#define IA32_MC10_ADDR 0x0000042A
#define IA32_MC11_ADDR 0x0000042E
#define IA32_MC12_ADDR 0x00000432
#define IA32_MC13_ADDR 0x00000436
#define IA32_MC14_ADDR 0x0000043A
#define IA32_MC15_ADDR 0x0000043E
#define IA32_MC16_ADDR 0x00000442
#define IA32_MC17_ADDR 0x00000446
#define IA32_MC18_ADDR 0x0000044A
#define IA32_MC19_ADDR 0x0000044E
#define IA32_MC20_ADDR 0x00000452
#define IA32_MC21_ADDR 0x00000456
#define IA32_MC22_ADDR 0x0000045A
#define IA32_MC23_ADDR 0x0000045E
#define IA32_MC24_ADDR 0x00000462
#define IA32_MC25_ADDR 0x00000466
#define IA32_MC26_ADDR 0x0000046A
#define IA32_MC27_ADDR 0x0000046E
#define IA32_MC28_ADDR 0x00000472
/**
 * @}
 */

/**
 * @defgroup IA32_MC_MISC \
 *           IA32_MC(i)_MISC
 *
 * IA32_MC(0-28)_MISC.
 *
 * @remarks If IA32_MCG_CAP.CNT > n
 * @{
 */
#define IA32_MC0_MISC  0x00000403
#define IA32_MC1_MISC  0x00000407
#define IA32_MC2_MISC  0x0000040B
#define IA32_MC3_MISC  0x0000040F
#define IA32_MC4_MISC  0x00000413
#define IA32_MC5_MISC  0x00000417
#define IA32_MC6_MISC  0x0000041B
#define IA32_MC7_MISC  0x0000041F
#define IA32_MC8_MISC  0x00000423
#define IA32_MC9_MISC  0x00000427
#define IA32_MC10_MISC 0x0000042B
#define IA32_MC11_MISC 0x0000042F
#define IA32_MC12_MISC 0x00000433
#define IA32_MC13_MISC 0x00000437
#define IA32_MC14_MISC 0x0000043B
#define IA32_MC15_MISC 0x0000043F
#define IA32_MC16_MISC 0x00000443
#define IA32_MC17_MISC 0x00000447
#define IA32_MC18_MISC 0x0000044B
#define IA32_MC19_MISC 0x0000044F
#define IA32_MC20_MISC 0x00000453
#define IA32_MC21_MISC 0x00000457
#define IA32_MC22_MISC 0x0000045B
#define IA32_MC23_MISC 0x0000045F
#define IA32_MC24_MISC 0x00000463
#define IA32_MC25_MISC 0x00000467
#define IA32_MC26_MISC 0x0000046B
#define IA32_MC27_MISC 0x0000046F
#define IA32_MC28_MISC 0x00000473
/**
 * @}
 */

/**
 * Reporting Register of Basic VMX Capabilities.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.1(BASIC VMX INFORMATION)]
 * @see Vol3D[A.1(Basic VMX Information)] (reference)
 */
#define IA32_VMX_BASIC 0x00000480
typedef union
{
        struct
        {
                /**
                 * @brief VMCS revision identifier used by the processor
                 *
                 * [Bits 30:0] 31-bit VMCS revision identifier used by the processor. Processors
                 * that use the same VMCS revision identifier use the same size for VMCS regions.
                 */
                UINT64 VmcsRevisionId : 31;
#define IA32_VMX_BASIC_VMCS_REVISION_ID_BIT  0
#define IA32_VMX_BASIC_VMCS_REVISION_ID_FLAG 0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID_MASK 0x7FFFFFFF
#define IA32_VMX_BASIC_VMCS_REVISION_ID(_)   (((_) >> 0) & 0x7FFFFFFF)

                /**
                 * [Bit 31] Bit 31 is always 0.
                 */
                UINT64 MustBeZero : 1;
#define IA32_VMX_BASIC_MUST_BE_ZERO_BIT  31
#define IA32_VMX_BASIC_MUST_BE_ZERO_FLAG 0x80000000
#define IA32_VMX_BASIC_MUST_BE_ZERO_MASK 0x01
#define IA32_VMX_BASIC_MUST_BE_ZERO(_)   (((_) >> 31) & 0x01)

                /**
                 * @brief Size of the VMCS
                 *
                 * [Bits 44:32] Report the number of bytes that software should allocate for the
                 * VMXON region and any VMCS region. It is a value greater than 0 and at most 4096
                 * (bit 44 is set if and only if bits 43:32 are clear).
                 */
                UINT64 VmcsSizeInBytes : 13;
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_BIT  32
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_FLAG 0x1FFF00000000
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES_MASK 0x1FFF
#define IA32_VMX_BASIC_VMCS_SIZE_IN_BYTES(_)   (((_) >> 32) & 0x1FFF)
                UINT64 Reserved1 : 3;

                /**
                 * @brief Width of physical address used for the VMCS
                 *        - 0 -> limited to the available amount of physical RAM
                 *        - 1 -> within the first 4 GB
                 *
                 * [Bit 48] Indicates the width of the physical addresses that may be used for the
                 * VMXON region, each VMCS, and data structures referenced by pointers in a VMCS
                 * (I/O bitmaps, virtual-APIC page, MSR areas for VMX transitions). If the bit is 0,
                 * these addresses are limited to the processor's physical-address width.2 If the
                 * bit is 1, these addresses are limited to 32 bits. This bit is always 0 for
                 * processors that support Intel 64 architecture.
                 */
                UINT64 VmcsPhysicalAddressWidth : 1;
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_BIT  48
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_FLAG 0x1000000000000
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH_MASK 0x01
#define IA32_VMX_BASIC_VMCS_PHYSICAL_ADDRESS_WIDTH(_)   (((_) >> 48) & 0x01)

                /**
                 * @brief Whether the processor supports the dual-monitor treatment of
                 * system-management interrupts and system-management code (always 1)
                 *
                 * [Bit 49] Read as 1, the logical processor supports the dual-monitor treatment of
                 * system-management interrupts and system-management mode.
                 *
                 * @see Vol3C[34.15(DUAL-MONITOR TREATMENT OF SMIs AND SMM)]
                 */
                UINT64 DualMonitorSupport : 1;
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_BIT  49
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_FLAG 0x2000000000000
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT_MASK 0x01
#define IA32_VMX_BASIC_DUAL_MONITOR_SUPPORT(_)   (((_) >> 49) & 0x01)

                /**
                 * @brief Memory type that must be used for the VMCS
                 *
                 * [Bits 53:50] Report the memory type that should be used for the VMCS, for data
                 * structures referenced by pointers in the VMCS (I/O bitmaps, virtual-APIC page,
                 * MSR areas for VMX transitions), and for the MSEG header. If software needs to
                 * access these data structures (e.g., to modify the contents of the MSR bitmaps),
                 * it can configure the paging structures to map them into the linear-address space.
                 * If it does so, it should establish mappings that use the memory type reported
                 * bits 53:50 in this MSR.
                 * As of this writing, all processors that support VMX operation indicate the
                 * write-back type.
                 */
                UINT64 MemoryType : 4;
#define IA32_VMX_BASIC_MEMORY_TYPE_BIT  50
#define IA32_VMX_BASIC_MEMORY_TYPE_FLAG 0x3C000000000000
#define IA32_VMX_BASIC_MEMORY_TYPE_MASK 0x0F
#define IA32_VMX_BASIC_MEMORY_TYPE(_)   (((_) >> 50) & 0x0F)

                /**
                 * @brief Whether the processor provides additional information for exits due to
                 * INS/OUTS
                 *
                 * [Bit 54] When set to 1, the processor reports information in the VM-exit
                 * instruction-information field on VM exits due to execution of the INS and OUTS
                 * instructions. This reporting is done only if this bit is read as 1.
                 *
                 * @see Vol3C[27.2.4(Information for VM Exits Due to Instruction Execution)]
                 */
                UINT64 InsOutsReporting : 1;
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_BIT  54
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_FLAG 0x40000000000000
#define IA32_VMX_BASIC_INS_OUTS_REPORTING_MASK 0x01
#define IA32_VMX_BASIC_INS_OUTS_REPORTING(_)   (((_) >> 54) & 0x01)

                /**
                 * @brief Whether default 1 bits in control MSRs (pin/proc/exit/entry) may be
                 * cleared to 0 and that 'true' control MSRs are supported
                 *
                 * [Bit 55] Is read as 1 if any VMX controls that default to 1 may be cleared to 0.
                 * It also reports support for the VMX capability MSRs IA32_VMX_TRUE_PINBASED_CTLS,
                 * IA32_VMX_TRUE_PROCBASED_CTLS, IA32_VMX_TRUE_EXIT_CTLS, and
                 * IA32_VMX_TRUE_ENTRY_CTLS.
                 *
                 * @see Vol3D[A.2(RESERVED CONTROLS AND DEFAULT SETTINGS)]
                 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
                 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
                 * @see Vol3D[A.4(VM-EXIT CONTROLS)]
                 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
                 */
                UINT64 VmxControls : 1;
#define IA32_VMX_BASIC_VMX_CONTROLS_BIT  55
#define IA32_VMX_BASIC_VMX_CONTROLS_FLAG 0x80000000000000
#define IA32_VMX_BASIC_VMX_CONTROLS_MASK 0x01
#define IA32_VMX_BASIC_VMX_CONTROLS(_)   (((_) >> 55) & 0x01)
                UINT64 Reserved2 : 8;
        };

        UINT64 AsUInt;
} IA32_VMX_BASIC_REGISTER;

/**
 * Capability Reporting Register of Pin-Based VM-Execution Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
 * @see Vol3C[24.6.1(Pin-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PINBASED_CTLS 0x00000481
typedef union
{
        struct
        {
                /**
                 * @brief External interrupts cause VM-exits if set; otherwise dispatched through
                 * the guest's IDT
                 *
                 * [Bit 0] If this control is 1, external interrupts cause VM exits. Otherwise, they
                 * are delivered normally through the guest interrupt-descriptor table (IDT). If
                 * this control is 1, the value of RFLAGS.IF does not affect interrupt blocking.
                 */
                UINT64 ExternalInterruptExiting : 1;
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_BIT  0
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_FLAG 0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING_MASK 0x01
#define IA32_VMX_PINBASED_CTLS_EXTERNAL_INTERRUPT_EXITING(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 2;

                /**
                 * @brief Non-maskable interrupts cause VM-exits if set; otherwise dispatched
                 * through the guest's IDT
                 *
                 * [Bit 3] If this control is 1, non-maskable interrupts (NMIs) cause VM exits.
                 * Otherwise, they are delivered normally using descriptor 2 of the IDT. This
                 * control also determines interactions between IRET and blocking by NMI.
                 *
                 * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
                 */
                UINT64 NmiExiting : 1;
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_BIT  3
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_FLAG 0x08
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING_MASK 0x01
#define IA32_VMX_PINBASED_CTLS_NMI_EXITING(_)   (((_) >> 3) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * @brief Virtual NMIs
                 *
                 * [Bit 5] If this control is 1, NMIs are never blocked and the "blocking by NMI"
                 * bit (bit 3) in the interruptibility-state field indicates "virtual-NMI blocking".
                 * This control also interacts with the "NMI-window exiting" VM-execution control.
                 *
                 * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)]
                 */
                UINT64 VirtualNmi : 1;
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_BIT  5
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_FLAG 0x20
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI_MASK 0x01
#define IA32_VMX_PINBASED_CTLS_VIRTUAL_NMI(_)   (((_) >> 5) & 0x01)

                /**
                 * @brief Activate VMX preemption timer
                 *
                 * [Bit 6] If this control is 1, the VMX-preemption timer counts down in VMX
                 * non-root operation. A VM exit occurs when the timer counts down to zero.
                 *
                 * @see Vol3C[25.5.1(VMX-Preemption Timer)]
                 * @see Vol3C[25.2(OTHER CAUSES OF VM EXITS)]
                 */
                UINT64 ActivateVmxPreemptionTimer : 1;
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_BIT  6
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_FLAG 0x40
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER_MASK 0x01
#define IA32_VMX_PINBASED_CTLS_ACTIVATE_VMX_PREEMPTION_TIMER(_)   (((_) >> 6) & 0x01)

                /**
                 * @brief Process interrupts with the posted-interrupt notification vector
                 *
                 * [Bit 7] If this control is 1, the processor treats interrupts with the
                 * posted-interrupt notification vector specially, updating the virtual-APIC page
                 * with posted-interrupt requests.
                 *
                 * @see Vol3C[24.6.8(Controls for APIC Virtualization)]
                 * @see Vol3C[29.6(POSTED-INTERRUPT PROCESSING)]
                 */
                UINT64 ProcessPostedInterrupts : 1;
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_BIT  7
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_FLAG 0x80
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS_MASK 0x01
#define IA32_VMX_PINBASED_CTLS_PROCESS_POSTED_INTERRUPTS(_)   (((_) >> 7) & 0x01)
                UINT64 Reserved3 : 56;
        };

        UINT64 AsUInt;
} IA32_VMX_PINBASED_CTLS_REGISTER;

/**
 * Capability Reporting Register of Primary Processor-Based VM-Execution Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
 * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS 0x00000482
typedef union
{
        struct
        {
                UINT64 Reserved1 : 2;

                /**
                 * @brief VM-exit as soon as RFLAGS.IF=1 and no blocking is active
                 *
                 * [Bit 2] If this control is 1, a VM exit occurs at the beginning of any
                 * instruction if RFLAGS.IF = 1 and there are no other blocking of interrupts.
                 *
                 * @see Vol3C[24.4.2(Guest Non-Register State)]
                 */
                UINT64 InterruptWindowExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_BIT  2
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_FLAG 0x04
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_INTERRUPT_WINDOW_EXITING(_)   (((_) >> 2) & 0x01)

                /**
                 * @brief Use timestamp counter offset
                 *
                 * [Bit 3] This control determines whether executions of RDTSC, executions of
                 * RDTSCP, and executions of RDMSR that read from the IA32_TIME_STAMP_COUNTER MSR
                 * return a value modified by the TSC offset field.
                 *
                 * @see Vol3C[24.6.5(Time-Stamp Counter Offset and Multiplier)]
                 * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
                 */
                UINT64 UseTscOffsetting : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_BIT  3
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_FLAG 0x08
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TSC_OFFSETTING(_)   (((_) >> 3) & 0x01)
                UINT64 Reserved2 : 3;

                /**
                 * @brief VM-exit when executing the HLT instruction
                 *
                 * [Bit 7] This control determines whether executions of HLT cause VM exits.
                 */
                UINT64 HltExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_BIT  7
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_FLAG 0x80
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_HLT_EXITING(_)   (((_) >> 7) & 0x01)
                UINT64 Reserved3 : 1;

                /**
                 * @brief VM-exit when executing the INVLPG instruction
                 *
                 * [Bit 9] This control determines whether executions of INVLPG cause VM exits.
                 */
                UINT64 InvlpgExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_BIT  9
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_FLAG 0x200
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_INVLPG_EXITING(_)   (((_) >> 9) & 0x01)

                /**
                 * @brief VM-exit when executing the MWAIT instruction
                 *
                 * [Bit 10] This control determines whether executions of MWAIT cause VM exits.
                 */
                UINT64 MwaitExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_BIT  10
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_FLAG 0x400
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_MWAIT_EXITING(_)   (((_) >> 10) & 0x01)

                /**
                 * @brief VM-exit when executing the RDPMC instruction
                 *
                 * [Bit 11] This control determines whether executions of RDPMC cause VM exits.
                 */
                UINT64 RdpmcExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_BIT  11
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_FLAG 0x800
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_RDPMC_EXITING(_)   (((_) >> 11) & 0x01)

                /**
                 * @brief VM-exit when executing the RDTSC/RDTSCP instruction
                 *
                 * [Bit 12] This control determines whether executions of RDTSC and RDTSCP cause VM
                 * exits.
                 */
                UINT64 RdtscExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_BIT  12
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_FLAG 0x1000
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_RDTSC_EXITING(_)   (((_) >> 12) & 0x01)
                UINT64 Reserved4 : 2;

                /**
                 * @brief VM-exit when executing the MOV to CR3 instruction (forced to 1 on the
                 * 'first' VT-x capable CPUs; this actually includes the newest Nehalem CPUs)
                 *
                 * [Bit 15] In conjunction with the CR3-target controls, this control determines
                 * whether executions of MOV to CR3 cause VM exits. The first processors to support
                 * the virtual-machine extensions supported only the 1-setting of this control.
                 *
                 * @see Vol3C[24.6.7(CR3-Target Controls)]
                 * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
                 */
                UINT64 Cr3LoadExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_BIT  15
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_FLAG 0x8000
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_LOAD_EXITING(_)   (((_) >> 15) & 0x01)

                /**
                 * @brief VM-exit when executing the MOV from CR3 instruction (forced to 1 on the
                 * 'first' VT-x capable CPUs; this actually includes the newest Nehalem CPUs)
                 *
                 * [Bit 16] This control determines whether executions of MOV from CR3 cause VM
                 * exits. The first processors to support the virtual-machine extensions supported
                 * only the 1-setting of this control.
                 */
                UINT64 Cr3StoreExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_BIT  16
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_FLAG 0x10000
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_CR3_STORE_EXITING(_)   (((_) >> 16) & 0x01)

                /**
                 * @brief Determines whether the tertiary processor based VM-execution controls are
                 * used
                 *
                 * [Bit 17] This control determines whether the tertiary processor-based
                 * VM-execution controls are used. If this control is 0, the logical processor
                 * operates as if all the tertiary processor-based VM-execution controls were also
                 * 0.
                 */
                UINT64 ActivateTertiaryControls : 1;
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS_BIT  17
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS_FLAG 0x20000
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_TERTIARY_CONTROLS(_)   (((_) >> 17) & 0x01)
                UINT64 Reserved5 : 1;

                /**
                 * @brief VM-exit on CR8 loads
                 *
                 * [Bit 19] This control determines whether executions of MOV to CR8 cause VM exits.
                 */
                UINT64 Cr8LoadExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_BIT  19
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_FLAG 0x80000
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_LOAD_EXITING(_)   (((_) >> 19) & 0x01)

                /**
                 * @brief VM-exit on CR8 stores
                 *
                 * [Bit 20] This control determines whether executions of MOV from CR8 cause VM
                 * exits.
                 */
                UINT64 Cr8StoreExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_BIT  20
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_FLAG 0x100000
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_CR8_STORE_EXITING(_)   (((_) >> 20) & 0x01)

                /**
                 * @brief Use TPR shadow
                 *
                 * [Bit 21] Setting this control to 1 enables TPR virtualization and other
                 * APIC-virtualization features.
                 *
                 * @see Vol3C[29(APIC VIRTUALIZATION AND VIRTUAL INTERRUPTS)]
                 */
                UINT64 UseTprShadow : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_BIT  21
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_FLAG 0x200000
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_TPR_SHADOW(_)   (((_) >> 21) & 0x01)

                /**
                 * @brief VM-exit when virtual NMI blocking is disabled
                 *
                 * [Bit 22] If this control is 1, a VM exit occurs at the beginning of any
                 * instruction if there is no virtual-NMI blocking.
                 *
                 * @see Vol3C[24.4.2(Guest Non-Register State)]
                 */
                UINT64 NmiWindowExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_BIT  22
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_FLAG 0x400000
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_NMI_WINDOW_EXITING(_)   (((_) >> 22) & 0x01)

                /**
                 * @brief VM-exit when executing a MOV DRx instruction
                 *
                 * [Bit 23] This control determines whether executions of MOV DR cause VM exits.
                 */
                UINT64 MovDrExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_BIT  23
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_FLAG 0x800000
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_MOV_DR_EXITING(_)   (((_) >> 23) & 0x01)

                /**
                 * @brief VM-exit when executing IO instructions
                 *
                 * [Bit 24] This control determines whether executions of I/O instructions (IN,
                 * INS/INSB/INSW/INSD, OUT, and OUTS/OUTSB/OUTSW/OUTSD) cause VM exits.
                 */
                UINT64 UnconditionalIoExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_BIT  24
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_FLAG 0x1000000
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_UNCONDITIONAL_IO_EXITING(_)   (((_) >> 24) & 0x01)

                /**
                 * @brief Use IO bitmaps
                 *
                 * [Bit 25] This control determines whether I/O bitmaps are used to restrict
                 * executions of I/O instructions For this control, "0" means "do not use I/O
                 * bitmaps" and "1" means "use I/O bitmaps." If the I/O bitmaps are used, the
                 * setting of the "unconditional I/O exiting" control is ignored.
                 *
                 * @see Vol3C[24.6.4(I/O-Bitmap Addresses)]
                 * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
                 */
                UINT64 UseIoBitmaps : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_BIT  25
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_FLAG 0x2000000
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_IO_BITMAPS(_)   (((_) >> 25) & 0x01)
                UINT64 Reserved6 : 1;

                /**
                 * @brief Monitor trap flag
                 *
                 * [Bit 27] If this control is 1, the monitor trap flag debugging feature is
                 * enabled.
                 *
                 * @see Vol3C[25.5.2(Monitor Trap Flag)]
                 */
                UINT64 MonitorTrapFlag : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_BIT  27
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_FLAG 0x8000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_TRAP_FLAG(_)   (((_) >> 27) & 0x01)

                /**
                 * @brief Use MSR bitmaps
                 *
                 * [Bit 28] This control determines whether MSR bitmaps are used to control
                 * execution of the RDMSR and WRMSR instructions. For this control, "0" means "do
                 * not use MSR bitmaps" and "1" means "use MSR bitmaps." If the MSR bitmaps are not
                 * used, all executions of the RDMSR and WRMSR instructions cause VM exits.
                 *
                 * @see Vol3C[24.6.9(MSR-Bitmap Address)]
                 * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
                 */
                UINT64 UseMsrBitmaps : 1;
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_BIT  28
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_FLAG 0x10000000
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_USE_MSR_BITMAPS(_)   (((_) >> 28) & 0x01)

                /**
                 * @brief VM-exit when executing the MONITOR instruction
                 *
                 * [Bit 29] This control determines whether executions of MONITOR cause VM exits.
                 */
                UINT64 MonitorExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_BIT  29
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_FLAG 0x20000000
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_MONITOR_EXITING(_)   (((_) >> 29) & 0x01)

                /**
                 * @brief VM-exit when executing the PAUSE instruction
                 *
                 * [Bit 30] This control determines whether executions of PAUSE cause VM exits.
                 */
                UINT64 PauseExiting : 1;
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_BIT  30
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_FLAG 0x40000000
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_PAUSE_EXITING(_)   (((_) >> 30) & 0x01)

                /**
                 * @brief Determines whether the secondary processor based VM-execution controls are
                 * used
                 *
                 * [Bit 31] This control determines whether the secondary processor-based
                 * VM-execution controls are used. If this control is 0, the logical processor
                 * operates as if all the secondary processor-based VM-execution controls were also
                 * 0.
                 */
                UINT64 ActivateSecondaryControls : 1;
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_BIT  31
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_FLAG 0x80000000
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS_ACTIVATE_SECONDARY_CONTROLS(_)   (((_) >> 31) & 0x01)
                UINT64 Reserved7 : 32;
        };

        UINT64 AsUInt;
} IA32_VMX_PROCBASED_CTLS_REGISTER;

/**
 * Capability Reporting Register of Primaryr VM-Exit Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.4.1(Primaryr VM-Exit Controls)]
 * @see Vol3C[24.7.1(VM-Exit Controls)] (reference)
 */
#define IA32_VMX_EXIT_CTLS 0x00000483
typedef union
{
        struct
        {
                UINT64 Reserved1 : 2;

                /**
                 * @brief Save guest debug controls (dr7 & IA32_DEBUGCTL_MSR) (forced to 1 on the
                 * 'first' VT-x capable CPUs; this actually includes the newest Nehalem CPUs)
                 *
                 * [Bit 2] This control determines whether DR7 and the IA32_DEBUGCTL MSR are saved
                 * on VM exit. The first processors to support the virtual-machine extensions
                 * supported only the 1-setting of this control.
                 */
                UINT64 SaveDebugControls : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_BIT  2
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_FLAG 0x04
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS_MASK 0x01
#define IA32_VMX_EXIT_CTLS_SAVE_DEBUG_CONTROLS(_)   (((_) >> 2) & 0x01)
                UINT64 Reserved2 : 6;

                /**
                 * @brief Return to long mode after a VM-exit
                 *
                 * [Bit 9] On processors that support Intel 64 architecture, this control determines
                 * whether a logical processor is in 64-bit mode after the next VM exit. Its value
                 * is loaded into CS.L, IA32_EFER.LME, and IA32_EFER.LMA on every VM exit.1 This
                 * control must be 0 on processors that do not support Intel 64 architecture.
                 */
                UINT64 HostAddressSpaceSize : 1;
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_BIT  9
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_FLAG 0x200
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE_MASK 0x01
#define IA32_VMX_EXIT_CTLS_HOST_ADDRESS_SPACE_SIZE(_)   (((_) >> 9) & 0x01)
                UINT64 Reserved3 : 2;

                /**
                 * @brief Whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM-exit
                 *
                 * [Bit 12] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded
                 * on VM exit.
                 */
                UINT64 LoadIa32PerfGlobalCtrl : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT  12
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG 0x1000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK 0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_)   (((_) >> 12) & 0x01)
                UINT64 Reserved4 : 2;

                /**
                 * @brief Acknowledge external interrupts with the irq controller if one caused a
                 * VM-exit
                 *
                 * [Bit 15] This control affects VM exits due to external interrupts:
                 * - If such a VM exit occurs and this control is 1, the logical processor
                 * acknowledges the interrupt controller, acquiring the interrupt's vector. The
                 * vector is stored in the VM-exit interruption-information field, which is marked
                 * valid.
                 * - If such a VM exit occurs and this control is 0, the interrupt is not
                 * acknowledged and the VM-exit interruption-information field is marked invalid.
                 */
                UINT64 AcknowledgeInterruptOnExit : 1;
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_BIT  15
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_FLAG 0x8000
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT_MASK 0x01
#define IA32_VMX_EXIT_CTLS_ACKNOWLEDGE_INTERRUPT_ON_EXIT(_)   (((_) >> 15) & 0x01)
                UINT64 Reserved5 : 2;

                /**
                 * @brief Whether the guest IA32_PAT MSR is saved on VM-exit
                 *
                 * [Bit 18] This control determines whether the IA32_PAT MSR is saved on VM exit.
                 */
                UINT64 SaveIa32Pat : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_BIT  18
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_FLAG 0x40000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT_MASK 0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_PAT(_)   (((_) >> 18) & 0x01)

                /**
                 * @brief Whether the host IA32_PAT MSR is loaded on VM-exit
                 *
                 * [Bit 19] This control determines whether the IA32_PAT MSR is loaded on VM exit.
                 */
                UINT64 LoadIa32Pat : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_BIT  19
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_FLAG 0x80000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT_MASK 0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PAT(_)   (((_) >> 19) & 0x01)

                /**
                 * @brief Whether the guest IA32_EFER MSR is saved on VM-exit
                 *
                 * [Bit 20] This control determines whether the IA32_EFER MSR is saved on VM exit.
                 */
                UINT64 SaveIa32Efer : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_BIT  20
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_FLAG 0x100000
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER_MASK 0x01
#define IA32_VMX_EXIT_CTLS_SAVE_IA32_EFER(_)   (((_) >> 20) & 0x01)

                /**
                 * @brief Whether the host IA32_EFER MSR is loaded on VM-exit
                 *
                 * [Bit 21] This control determines whether the IA32_EFER MSR is loaded on VM exit.
                 */
                UINT64 LoadIa32Efer : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_BIT  21
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_FLAG 0x200000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER_MASK 0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_EFER(_)   (((_) >> 21) & 0x01)

                /**
                 * @brief Whether the value of the VMX preemption timer is saved on every VM-exit
                 *
                 * [Bit 22] This control determines whether the value of the VMX-preemption timer is
                 * saved on VM exit.
                 */
                UINT64 SaveVmxPreemptionTimerValue : 1;
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_BIT  22
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_FLAG 0x400000
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE_MASK 0x01
#define IA32_VMX_EXIT_CTLS_SAVE_VMX_PREEMPTION_TIMER_VALUE(_)   (((_) >> 22) & 0x01)

                /**
                 * [Bit 23] This control determines whether the IA32_BNDCFGS MSR is cleared on VM
                 * exit.
                 */
                UINT64 ClearIa32Bndcfgs : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_BIT  23
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_FLAG 0x800000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS_MASK 0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_BNDCFGS(_)   (((_) >> 23) & 0x01)

                /**
                 * [Bit 24] If this control is 1, Intel Processor Trace does not produce a paging
                 * information packet (PIP) on a VM exit or a VMCS packet on an SMM VM exit.
                 *
                 * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
                 */
                UINT64 ConcealVmxFromPt : 1;
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_BIT  24
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_FLAG 0x1000000
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT_MASK 0x01
#define IA32_VMX_EXIT_CTLS_CONCEAL_VMX_FROM_PT(_)   (((_) >> 24) & 0x01)

                /**
                 * [Bit 25] This control determines whether the IA32_RTIT_CTL MSR is cleared on VM
                 * exit.
                 *
                 * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
                 */
                UINT64 ClearIa32RtitCtl : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL_BIT  25
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL_FLAG 0x2000000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL_MASK 0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_RTIT_CTL(_)   (((_) >> 25) & 0x01)

                /**
                 * [Bit 26] This control determines whether the IA32_LBR_CTL MSR is cleared on VM
                 * exit.
                 */
                UINT64 ClearIa32LbrCtl : 1;
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL_BIT  26
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL_FLAG 0x4000000
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL_MASK 0x01
#define IA32_VMX_EXIT_CTLS_CLEAR_IA32_LBR_CTL(_)   (((_) >> 26) & 0x01)
                UINT64 Reserved6 : 1;

                /**
                 * [Bit 28] This control determines whether CET-related MSRs and SPP are loaded on
                 * VM exit.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 LoadIa32CetState : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE_BIT  28
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE_FLAG 0x10000000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE_MASK 0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_CET_STATE(_)   (((_) >> 28) & 0x01)

                /**
                 * [Bit 29] This control determines whether the IA32_PKRS MSR is loaded on VM exit.
                 */
                UINT64 LoadIa32Pkrs : 1;
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS_BIT  29
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS_FLAG 0x20000000
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS_MASK 0x01
#define IA32_VMX_EXIT_CTLS_LOAD_IA32_PKRS(_)   (((_) >> 29) & 0x01)
                UINT64 Reserved7 : 1;

                /**
                 * [Bit 31] This control determines whether the secondary VM-exit controls are used.
                 * If this control is 0, the logical processor operates as if all the secondary
                 * VM-exit controls were also 0.
                 */
                UINT64 ActivateSecondaryControls : 1;
#define IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS_BIT  31
#define IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS_FLAG 0x80000000
#define IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS_MASK 0x01
#define IA32_VMX_EXIT_CTLS_ACTIVATE_SECONDARY_CONTROLS(_)   (((_) >> 31) & 0x01)
                UINT64 Reserved8 : 32;
        };

        UINT64 AsUInt;
} IA32_VMX_EXIT_CTLS_REGISTER;

/**
 * Capability Reporting Register of VM-Entry Controls.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
 * @see Vol3D[24.8.1(VM-Entry Controls)] (reference)
 */
#define IA32_VMX_ENTRY_CTLS 0x00000484
typedef union
{
        struct
        {
                UINT64 Reserved1 : 2;

                /**
                 * @brief Load guest debug controls (dr7 & IA32_DEBUGCTL_MSR) (forced to 1 on the
                 * 'first' VT-x capable CPUs; this actually includes the newest Nehalem CPUs)
                 *
                 * [Bit 2] This control determines whether DR7 and the IA32_DEBUGCTL MSR are loaded
                 * on VM entry. The first processors to support the virtual-machine extensions
                 * supported only the 1-setting of this control.
                 */
                UINT64 LoadDebugControls : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_BIT  2
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_FLAG 0x04
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_DEBUG_CONTROLS(_)   (((_) >> 2) & 0x01)
                UINT64 Reserved2 : 6;

                /**
                 * @brief 64 bits guest mode. Must be 0 for CPUs that don't support AMD64
                 *
                 * [Bit 9] On processors that support Intel 64 architecture, this control determines
                 * whether the logical processor is in IA-32e mode after VM entry. Its value is
                 * loaded into IA32_EFER.LMA as part of VM entry. This control must be 0 on
                 * processors that do not support Intel 64 architecture.
                 */
                UINT64 Ia32EModeGuest : 1;
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_BIT  9
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_FLAG 0x200
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_IA32E_MODE_GUEST(_)   (((_) >> 9) & 0x01)

                /**
                 * @brief In SMM mode after VM-entry
                 *
                 * [Bit 10] This control determines whether the logical processor is in
                 * system-management mode (SMM) after VM entry. This control must be 0 for any VM
                 * entry from outside SMM.
                 */
                UINT64 EntryToSmm : 1;
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_BIT  10
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_FLAG 0x400
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_ENTRY_TO_SMM(_)   (((_) >> 10) & 0x01)

                /**
                 * @brief Disable dual treatment of SMI and SMM; must be zero for VM-entry outside
                 * of SMM
                 *
                 * [Bit 11] If set to 1, the default treatment of SMIs and SMM is in effect after
                 * the VM entry. This control must be 0 for any VM entry from outside SMM
                 *
                 * @see Vol3C[34.15.7(Deactivating the Dual-Monitor Treatment)]
                 */
                UINT64 DeactivateDualMonitorTreatment : 1;
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_BIT  11
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_FLAG 0x800
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_DEACTIVATE_DUAL_MONITOR_TREATMENT(_)   (((_) >> 11) & 0x01)
                UINT64 Reserved3 : 1;

                /**
                 * @brief Whether the guest IA32_PERF_GLOBAL_CTRL MSR is loaded on VM-entry
                 *
                 * [Bit 13] This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded
                 * on VM entry.
                 */
                UINT64 LoadIa32PerfGlobalCtrl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_BIT  13
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_FLAG 0x2000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PERF_GLOBAL_CTRL(_)   (((_) >> 13) & 0x01)

                /**
                 * @brief Whether the guest IA32_PAT MSR is loaded on VM-entry
                 *
                 * [Bit 14] This control determines whether the IA32_PAT MSR is loaded on VM entry.
                 */
                UINT64 LoadIa32Pat : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_BIT  14
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_FLAG 0x4000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PAT(_)   (((_) >> 14) & 0x01)

                /**
                 * @brief Whether the guest IA32_EFER MSR is loaded on VM-entry
                 *
                 * [Bit 15] This control determines whether the IA32_EFER MSR is loaded on VM entry.
                 */
                UINT64 LoadIa32Efer : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_BIT  15
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_FLAG 0x8000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_EFER(_)   (((_) >> 15) & 0x01)

                /**
                 * [Bit 16] This control determines whether the IA32_BNDCFGS MSR is loaded on VM
                 * entry.
                 */
                UINT64 LoadIa32Bndcfgs : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_BIT  16
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_FLAG 0x10000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_BNDCFGS(_)   (((_) >> 16) & 0x01)

                /**
                 * [Bit 17] If this control is 1, Intel Processor Trace does not produce a paging
                 * information packet (PIP) on a VM entry or a VMCS packet on a VM entry that
                 * returns from SMM.
                 *
                 * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
                 */
                UINT64 ConcealVmxFromPt : 1;
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_BIT  17
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_FLAG 0x20000
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_CONCEAL_VMX_FROM_PT(_)   (((_) >> 17) & 0x01)

                /**
                 * [Bit 18] This control determines whether the IA32_RTIT_CTL MSR is loaded on VM
                 * entry.
                 */
                UINT64 LoadIa32RtitCtl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_BIT  18
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_FLAG 0x40000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_RTIT_CTL(_)   (((_) >> 18) & 0x01)
                UINT64 Reserved4 : 1;

                /**
                 * [Bit 20] This control determines whether CET-related MSRs and SPP are loaded on
                 * VM entry.
                 */
                UINT64 LoadCetState : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_BIT  20
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_FLAG 0x100000
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_CET_STATE(_)   (((_) >> 20) & 0x01)

                /**
                 * [Bit 21] This control determines whether the IA32_LBR_CTL MSR is loaded on VM
                 * entry.
                 */
                UINT64 LoadIa32LbrCtl : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL_BIT  21
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL_FLAG 0x200000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_LBR_CTL(_)   (((_) >> 21) & 0x01)

                /**
                 * [Bit 22] This control determines whether the IA32_PKRS MSR is loaded on VM entry.
                 */
                UINT64 LoadIa32Pkrs : 1;
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS_BIT  22
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS_FLAG 0x400000
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS_MASK 0x01
#define IA32_VMX_ENTRY_CTLS_LOAD_IA32_PKRS(_)   (((_) >> 22) & 0x01)
                UINT64 Reserved5 : 41;
        };

        UINT64 AsUInt;
} IA32_VMX_ENTRY_CTLS_REGISTER;

/**
 * Reporting Register of Miscellaneous VMX Capabilities.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.6(MISCELLANEOUS DATA)]
 * @see Vol3D[A.6(Miscellaneous Data)] (reference)
 */
#define IA32_VMX_MISC 0x00000485
typedef union
{
        struct
        {
                /**
                 * @brief Relationship between the preemption timer and tsc; count down every time
                 * bit x of the tsc changes
                 *
                 * [Bits 4:0] Report a value X that specifies the relationship between the rate of
                 * the VMX-preemption timer and that of the timestamp counter (TSC). Specifically,
                 * the VMX-preemption timer (if it is active) counts down by 1 every time bit X in
                 * the TSC changes due to a TSC increment.
                 */
                UINT64 PreemptionTimerTscRelationship : 5;
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_BIT  0
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_FLAG 0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP_MASK 0x1F
#define IA32_VMX_MISC_PREEMPTION_TIMER_TSC_RELATIONSHIP(_)   (((_) >> 0) & 0x1F)

                /**
                 * @brief Whether VM-exit stores EFER.LMA into the "IA32e mode guest" field
                 *
                 * [Bit 5] When set to 1, VM exits store the value of IA32_EFER.LMA into the "IA-32e
                 * mode guest" VM-entry control. This bit is read as 1 on any logical processor that
                 * supports the 1-setting of the "unrestricted guest" VM-execution control.
                 *
                 * @see Vol3C[27.2(RECORDING VM-EXIT INFORMATION AND UPDATING VM-ENTRY CONTROL
                 * FIELDS)]
                 */
                UINT64 StoreEferLmaOnVmexit : 1;
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_BIT  5
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_FLAG 0x20
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT_MASK 0x01
#define IA32_VMX_MISC_STORE_EFER_LMA_ON_VMEXIT(_)   (((_) >> 5) & 0x01)

                /**
                 * @brief Activity states supported by the implementation
                 *
                 * [Bits 8:6] Report, as a bitmap, the activity states supported by the
                 * implementation:
                 * - Bit 6 reports (if set) the support for activity state 1 (HLT).
                 * - Bit 7 reports (if set) the support for activity state 2 (shutdown).
                 * - Bit 8 reports (if set) the support for activity state 3 (wait-for-SIPI).
                 * If an activity state is not supported, the implementation causes a VM entry to
                 * fail if it attempts to establish that activity state. All implementations support
                 * VM entry to activity state 0 (active).
                 */
                UINT64 ActivityStates : 3;
#define IA32_VMX_MISC_ACTIVITY_STATES_BIT  6
#define IA32_VMX_MISC_ACTIVITY_STATES_FLAG 0x1C0
#define IA32_VMX_MISC_ACTIVITY_STATES_MASK 0x07
#define IA32_VMX_MISC_ACTIVITY_STATES(_)   (((_) >> 6) & 0x07)
                UINT64 Reserved1 : 5;

                /**
                 * @brief Intel Processor Trace (Intel PT) can be used in VMX operation
                 *
                 * [Bit 14] When set to 1, Intel(R) Processor Trace (Intel PT) can be used in VMX
                 * operation. If the processor supports Intel PT but does not allow it to be used in
                 * VMX operation, execution of VMXON clears IA32_RTIT_CTL.TraceEn; any attempt to
                 * write IA32_RTIT_CTL while in VMX operation (including VMX root operation) causes
                 * a general-protection exception.
                 *
                 * @see Vol3C[30.3(VMX INSTRUCTIONS | VMXON-Enter VMX Operation)]
                 */
                UINT64 IntelPtAvailableInVmx : 1;
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_BIT  14
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_FLAG 0x4000
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX_MASK 0x01
#define IA32_VMX_MISC_INTEL_PT_AVAILABLE_IN_VMX(_)   (((_) >> 14) & 0x01)

                /**
                 * @brief Whether RDMSR can be used to read IA32_SMBASE_MSR in SMM
                 *
                 * [Bit 15] When set to 1, the RDMSR instruction can be used in system-management
                 * mode (SMM) to read the IA32_SMBASE MSR (MSR address 9EH).
                 *
                 * @see Vol3C[34.15.6.3(Saving Guest State)]
                 */
                UINT64 RdmsrCanReadIa32SmbaseMsrInSmm : 1;
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_BIT  15
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_FLAG 0x8000
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM_MASK 0x01
#define IA32_VMX_MISC_RDMSR_CAN_READ_IA32_SMBASE_MSR_IN_SMM(_)   (((_) >> 15) & 0x01)

                /**
                 * @brief Number of CR3 target values supported by the processor (0-256)
                 *
                 * [Bits 24:16] Indicate the number of CR3-target values supported by the processor.
                 * This number is a value between 0 and 256, inclusive (bit 24 is set if and only if
                 * bits 23:16 are clear).
                 */
                UINT64 Cr3TargetCount : 9;
#define IA32_VMX_MISC_CR3_TARGET_COUNT_BIT  16
#define IA32_VMX_MISC_CR3_TARGET_COUNT_FLAG 0x1FF0000
#define IA32_VMX_MISC_CR3_TARGET_COUNT_MASK 0x1FF
#define IA32_VMX_MISC_CR3_TARGET_COUNT(_)   (((_) >> 16) & 0x1FF)

                /**
                 * @brief Maximum number of MSRs in the VMCS. (N+1)*512
                 *
                 * [Bits 27:25] Used to compute the recommended maximum number of MSRs that should
                 * appear in the VM-exit MSR-store list, the VM-exit MSR-load list, or the VM-entry
                 * MSR-load list. Specifically, if the value bits 27:25 of IA32_VMX_MISC is N, then
                 * 512 * (N + 1) is the recommended maximum number of MSRs to be included in each
                 * list. If the limit is exceeded, undefined processor behavior may result
                 * (including a machine check during the VMX transition).
                 */
                UINT64 MaxNumberOfMsr : 3;
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_BIT  25
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_FLAG 0xE000000
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR_MASK 0x07
#define IA32_VMX_MISC_MAX_NUMBER_OF_MSR(_)   (((_) >> 25) & 0x07)

                /**
                 * @brief Whether bit 2 of IA32_SMM_MONITOR_CTL can be set to 1
                 *
                 * [Bit 28] When set to 1, bit 2 of the IA32_SMM_MONITOR_CTL can be set to 1. VMXOFF
                 * unblocks SMIs unless IA32_SMM_MONITOR_CTL[bit 2] is 1.
                 *
                 * @see Vol3C[34.14.4(VMXOFF and SMI Unblocking)]
                 */
                UINT64 SmmMonitorCtlB2 : 1;
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_BIT  28
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_FLAG 0x10000000
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2_MASK 0x01
#define IA32_VMX_MISC_SMM_MONITOR_CTL_B2(_)   (((_) >> 28) & 0x01)

                /**
                 * @brief Whether VMWRITE can be used to write VM-exit information fields
                 *
                 * [Bit 29] When set to 1, software can use VMWRITE to write to any supported field
                 * in the VMCS; otherwise, VMWRITE cannot be used to modify VM-exit information
                 * fields.
                 */
                UINT64 VmwriteVmexitInfo : 1;
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_BIT  29
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_FLAG 0x20000000
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO_MASK 0x01
#define IA32_VMX_MISC_VMWRITE_VMEXIT_INFO(_)   (((_) >> 29) & 0x01)

                /**
                 * [Bit 30] When set to 1, VM entry allows injection of a software interrupt,
                 * software exception, or privileged software exception with an instruction length
                 * of 0.
                 */
                UINT64 ZeroLengthInstructionVmentryInjection : 1;
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_BIT  30
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_FLAG 0x40000000
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION_MASK 0x01
#define IA32_VMX_MISC_ZERO_LENGTH_INSTRUCTION_VMENTRY_INJECTION(_)   (((_) >> 30) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * @brief MSEG revision identifier used by the processor
                 *
                 * [Bits 63:32] Report the 32-bit MSEG revision identifier used by the processor.
                 */
                UINT64 MsegId : 32;
#define IA32_VMX_MISC_MSEG_ID_BIT  32
#define IA32_VMX_MISC_MSEG_ID_FLAG 0xFFFFFFFF00000000
#define IA32_VMX_MISC_MSEG_ID_MASK 0xFFFFFFFF
#define IA32_VMX_MISC_MSEG_ID(_)   (((_) >> 32) & 0xFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_VMX_MISC_REGISTER;

/**
 * Capability Reporting Register of CR0 Bits Fixed to 0.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.7(VMX-FIXED BITS IN CR0)]
 * @see Vol3D[A.7(VMX-Fixed Bits in CR0)] (reference)
 */
#define IA32_VMX_CR0_FIXED0 0x00000486

/**
 * Capability Reporting Register of CR0 Bits Fixed to 1.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.7(VMX-FIXED BITS IN CR0)]
 * @see Vol3D[A.7(VMX-Fixed Bits in CR0)] (reference)
 */
#define IA32_VMX_CR0_FIXED1 0x00000487

/**
 * Capability Reporting Register of CR4 Bits Fixed to 0.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.8(VMX-FIXED BITS IN CR4)]
 * @see Vol3D[A.8(VMX-Fixed Bits in CR4)] (reference)
 */
#define IA32_VMX_CR4_FIXED0 0x00000488

/**
 * Capability Reporting Register of CR4 Bits Fixed to 1.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.8(VMX-FIXED BITS IN CR4)]
 * @see Vol3D[A.8(VMX-Fixed Bits in CR4)] (reference)
 */
#define IA32_VMX_CR4_FIXED1 0x00000489

/**
 * Capability Reporting Register of VMCS Field Enumeration.
 *
 * @remarks If CPUID.01H:ECX.[5] = 1
 * @see Vol3D[A.9(VMCS ENUMERATION)]
 * @see Vol3D[A.9(VMCS Enumeration)] (reference)
 */
#define IA32_VMX_VMCS_ENUM 0x0000048A
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Indicates access type.
                 */
                UINT64 AccessType : 1;
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_BIT  0
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_FLAG 0x01
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE_MASK 0x01
#define IA32_VMX_VMCS_ENUM_ACCESS_TYPE(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bits 9:1] Highest index value used for any VMCS encoding.
                 */
                UINT64 HighestIndexValue : 9;
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_BIT  1
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_FLAG 0x3FE
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE_MASK 0x1FF
#define IA32_VMX_VMCS_ENUM_HIGHEST_INDEX_VALUE(_)   (((_) >> 1) & 0x1FF)

                /**
                 * [Bits 11:10] Indicate the field's type.
                 */
                UINT64 FieldType : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_BIT  10
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_FLAG 0xC00
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE_MASK 0x03
#define IA32_VMX_VMCS_ENUM_FIELD_TYPE(_)   (((_) >> 10) & 0x03)
                UINT64 Reserved1 : 1;

                /**
                 * [Bits 14:13] Indicate the field's width.
                 */
                UINT64 FieldWidth : 2;
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_BIT  13
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_FLAG 0x6000
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH_MASK 0x03
#define IA32_VMX_VMCS_ENUM_FIELD_WIDTH(_)   (((_) >> 13) & 0x03)
                UINT64 Reserved2 : 49;
        };

        UINT64 AsUInt;
} IA32_VMX_VMCS_ENUM_REGISTER;

/**
 * Capability Reporting Register of Secondary Processor-Based VM-Execution Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[63] )
 * @see Vol3D[A.3.3(Secondary Processor-Based VM-Execution Controls)]
 * @see Vol3D[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS2 0x0000048B
typedef union
{
        struct
        {
                /**
                 * @brief Virtualize APIC access
                 *
                 * [Bit 0] If this control is 1, the logical processor treats specially accesses to
                 * the page with the APICaccess address.
                 *
                 * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
                 */
                UINT64 VirtualizeApicAccesses : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_BIT  0
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_FLAG 0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_APIC_ACCESSES(_)   (((_) >> 0) & 0x01)

                /**
                 * @brief EPT supported/enabled
                 *
                 * [Bit 1] If this control is 1, extended page tables (EPT) are enabled.
                 *
                 * @see Vol3C[28.2(THE EXTENDED PAGE TABLE MECHANISM (EPT))]
                 */
                UINT64 EnableEpt : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_BIT  1
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_FLAG 0x02
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_EPT(_)   (((_) >> 1) & 0x01)

                /**
                 * @brief Descriptor table instructions cause VM-exits
                 *
                 * [Bit 2] This control determines whether executions of LGDT, LIDT, LLDT, LTR,
                 * SGDT, SIDT, SLDT, and STR cause VM exits.
                 */
                UINT64 DescriptorTableExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_BIT  2
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_FLAG 0x04
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_DESCRIPTOR_TABLE_EXITING(_)   (((_) >> 2) & 0x01)

                /**
                 * @brief RDTSCP supported/enabled
                 *
                 * [Bit 3] If this control is 0, any execution of RDTSCP causes an invalid-opcode
                 * exception (\#UD).
                 */
                UINT64 EnableRdtscp : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_BIT  3
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_FLAG 0x08
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_RDTSCP(_)   (((_) >> 3) & 0x01)

                /**
                 * @brief Virtualize x2APIC mode
                 *
                 * [Bit 4] If this control is 1, the logical processor treats specially RDMSR and
                 * WRMSR to APIC MSRs (in the range 800H-8FFH).
                 *
                 * @see Vol3C[29.5(VIRTUALIZING MSR-BASED APIC ACCESSES)]
                 */
                UINT64 VirtualizeX2ApicMode : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_BIT  4
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_FLAG 0x10
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUALIZE_X2APIC_MODE(_)   (((_) >> 4) & 0x01)

                /**
                 * @brief VPID supported/enabled
                 *
                 * [Bit 5] If this control is 1, cached translations of linear addresses are
                 * associated with a virtualprocessor identifier (VPID).
                 *
                 * @see Vol3C[28.1(VIRTUAL PROCESSOR IDENTIFIERS (VPIDS))]
                 */
                UINT64 EnableVpid : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_BIT  5
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_FLAG 0x20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VPID(_)   (((_) >> 5) & 0x01)

                /**
                 * @brief VM-exit when executing the WBINVD instruction
                 *
                 * [Bit 6] This control determines whether executions of WBINVD cause VM exits.
                 */
                UINT64 WbinvdExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_BIT  6
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_FLAG 0x40
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_WBINVD_EXITING(_)   (((_) >> 6) & 0x01)

                /**
                 * @brief Unrestricted guest execution
                 *
                 * [Bit 7] This control determines whether guest software may run in unpaged
                 * protected mode or in realaddress mode.
                 */
                UINT64 UnrestrictedGuest : 1;
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_BIT  7
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_FLAG 0x80
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_UNRESTRICTED_GUEST(_)   (((_) >> 7) & 0x01)

                /**
                 * @brief APIC register virtualization
                 *
                 * [Bit 8] If this control is 1, the logical processor virtualizes certain APIC
                 * accesses.
                 *
                 * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
                 * @see Vol3C[29.5(VIRTUALIZING MSR-BASED APIC ACCESSES)]
                 */
                UINT64 ApicRegisterVirtualization : 1;
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_BIT  8
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_FLAG 0x100
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_APIC_REGISTER_VIRTUALIZATION(_)   (((_) >> 8) & 0x01)

                /**
                 * @brief Virtual-interrupt delivery
                 *
                 * [Bit 9] This controls enables the evaluation and delivery of pending virtual
                 * interrupts as well as the emulation of writes to the APIC registers that control
                 * interrupt prioritization.
                 */
                UINT64 VirtualInterruptDelivery : 1;
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_BIT  9
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_FLAG 0x200
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_VIRTUAL_INTERRUPT_DELIVERY(_)   (((_) >> 9) & 0x01)

                /**
                 * @brief A specified number of pause loops cause a VM-exit
                 *
                 * [Bit 10] This control determines whether a series of executions of PAUSE can
                 * cause a VM exit.
                 *
                 * @see Vol3C[24.6.13(Controls for PAUSE-Loop Exiting)]
                 * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
                 */
                UINT64 PauseLoopExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_BIT  10
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_FLAG 0x400
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_PAUSE_LOOP_EXITING(_)   (((_) >> 10) & 0x01)

                /**
                 * @brief VM-exit when executing RDRAND instructions
                 *
                 * [Bit 11] This control determines whether executions of RDRAND cause VM exits.
                 */
                UINT64 RdrandExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_BIT  11
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_FLAG 0x800
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDRAND_EXITING(_)   (((_) >> 11) & 0x01)

                /**
                 * @brief Enables INVPCID instructions
                 *
                 * [Bit 12] If this control is 0, any execution of INVPCID causes a \#UD.
                 */
                UINT64 EnableInvpcid : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_BIT  12
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_FLAG 0x1000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_INVPCID(_)   (((_) >> 12) & 0x01)

                /**
                 * @brief Enables VMFUNC instructions
                 *
                 * [Bit 13] Setting this control to 1 enables use of the VMFUNC instruction in VMX
                 * non-root operation.
                 *
                 * @see Vol3C[25.5.5(VM Functions)]
                 */
                UINT64 EnableVmFunctions : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_BIT  13
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_FLAG 0x2000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_VM_FUNCTIONS(_)   (((_) >> 13) & 0x01)

                /**
                 * @brief Enables VMCS shadowing
                 *
                 * [Bit 14] If this control is 1, executions of VMREAD and VMWRITE in VMX non-root
                 * operation may access a shadow VMCS (instead of causing VM exits).
                 *
                 * @see {'Vol3C[24.10(VMCS TYPES': 'ORDINARY AND SHADOW)]'}
                 * @see Vol3C[30.3(VMX INSTRUCTIONS)]
                 */
                UINT64 VmcsShadowing : 1;
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_BIT  14
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_FLAG 0x4000
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_VMCS_SHADOWING(_)   (((_) >> 14) & 0x01)

                /**
                 * @brief Enables ENCLS VM-exits
                 *
                 * [Bit 15] If this control is 1, executions of ENCLS consult the ENCLS-exiting
                 * bitmap to determine whether the instruction causes a VM exit.
                 *
                 * @see Vol3C[24.6.16(ENCLS-Exiting Bitmap)]
                 * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
                 */
                UINT64 EnableEnclsExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_BIT  15
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_FLAG 0x8000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLS_EXITING(_)   (((_) >> 15) & 0x01)

                /**
                 * @brief VM-exit when executing RDSEED
                 *
                 * [Bit 16] This control determines whether executions of RDSEED cause VM exits.
                 */
                UINT64 RdseedExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_BIT  16
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_FLAG 0x10000
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_RDSEED_EXITING(_)   (((_) >> 16) & 0x01)

                /**
                 * @brief Enables page-modification logging
                 *
                 * [Bit 17] If this control is 1, an access to a guest-physical address that sets an
                 * EPT dirty bit first adds an entry to the page-modification log.
                 *
                 * @see Vol3C[28.2.5(Page-Modification Logging)]
                 */
                UINT64 EnablePml : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_BIT  17
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_FLAG 0x20000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_PML(_)   (((_) >> 17) & 0x01)

                /**
                 * @brief Controls whether EPT-violations may cause
                 *
                 * [Bit 18] If this control is 1, EPT violations may cause virtualization exceptions
                 * (\#VE) instead of VM exits.
                 *
                 * @see Vol3C[25.5.6(Virtualization Exceptions)]
                 */
                UINT64 EptViolation : 1;
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_BIT  18
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_FLAG 0x40000
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_EPT_VIOLATION(_)   (((_) >> 18) & 0x01)

                /**
                 * @brief Conceal VMX non-root operation from Intel processor trace (PT)
                 *
                 * [Bit 19] If this control is 1, Intel Processor Trace suppresses from PIPs an
                 * indication that the processor was in VMX non-root operation and omits a VMCS
                 * packet from any PSB+ produced in VMX nonroot operation.
                 *
                 * @see Vol3C[35(INTEL(R) PROCESSOR TRACE)]
                 */
                UINT64 ConcealVmxFromPt : 1;
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_BIT  19
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_FLAG 0x80000
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_CONCEAL_VMX_FROM_PT(_)   (((_) >> 19) & 0x01)

                /**
                 * @brief Enables XSAVES/XRSTORS instructions
                 *
                 * [Bit 20] If this control is 0, any execution of XSAVES or XRSTORS causes a \#UD.
                 */
                UINT64 EnableXsaves : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_BIT  20
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_FLAG 0x100000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_XSAVES(_)   (((_) >> 20) & 0x01)
                UINT64 Reserved1 : 1;

                /**
                 * [Bit 22] If this control is 1, EPT execute permissions are based on whether the
                 * linear address being accessed is supervisor mode or user mode.
                 *
                 * @see Vol3C[28(VMX SUPPORT FOR ADDRESS TRANSLATION)]
                 */
                UINT64 ModeBasedExecuteControlForEpt : 1;
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_BIT  22
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_FLAG 0x400000
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_MODE_BASED_EXECUTE_CONTROL_FOR_EPT(_)   (((_) >> 22) & 0x01)

                /**
                 * [Bit 23] If this control is 1, EPT write permissions may be specified at the
                 * granularity of 128 bytes.
                 *
                 * @see Vol3C[28.2.4(Sub-Page Write Permissions)]
                 */
                UINT64 SubPageWritePermissionsForEpt : 1;
#define IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT_BIT  23
#define IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT_FLAG 0x800000
#define IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_SUB_PAGE_WRITE_PERMISSIONS_FOR_EPT(_)   (((_) >> 23) & 0x01)

                /**
                 * [Bit 24] If this control is 1, all output addresses used by Intel Processor Trace
                 * are treated as guestphysical addresses and translated using EPT.
                 *
                 * @see Vol3C[25.5.3(Translation of Guest-Physical Addresses Using EPT)]
                 */
                UINT64 PtUsesGuestPhysicalAddresses : 1;
#define IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES_BIT  24
#define IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES_FLAG 0x1000000
#define IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_PT_USES_GUEST_PHYSICAL_ADDRESSES(_)   (((_) >> 24) & 0x01)

                /**
                 * @brief Use TSC scaling
                 *
                 * [Bit 25] This control determines whether executions of RDTSC, executions of
                 * RDTSCP, and executions of RDMSR that read from the IA32_TIME_STAMP_COUNTER MSR
                 * return a value modified by the TSC multiplier field.
                 *
                 * @see Vol3C[24.6.5(Time-Stamp Counter Offset and Multiplier)]
                 * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
                 */
                UINT64 UseTscScaling : 1;
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_BIT  25
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_FLAG 0x2000000
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_USE_TSC_SCALING(_)   (((_) >> 25) & 0x01)

                /**
                 * @brief Enables TPAUSE/UMONITOR/UMWAIT instructions
                 *
                 * [Bit 26] If this control is 0, any execution of TPAUSE, UMONITOR, or UMWAIT
                 * causes a \#UD.
                 */
                UINT64 EnableUserWaitPause : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE_BIT  26
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE_FLAG 0x4000000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_USER_WAIT_PAUSE(_)   (((_) >> 26) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * @brief Enables ENCLV VM-exits
                 *
                 * [Bit 28] If this control is 1, executions of ENCLV consult the ENCLV-exiting
                 * bitmap to determine whether the instruction causes a VM exit.
                 *
                 * @see Vol3C[24.6.17(ENCLV-Exiting Bitmap)]
                 * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
                 */
                UINT64 EnableEnclvExiting : 1;
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING_BIT  28
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING_FLAG 0x10000000
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS2_ENABLE_ENCLV_EXITING(_)   (((_) >> 28) & 0x01)
                UINT64 Reserved3 : 35;
        };

        UINT64 AsUInt;
} IA32_VMX_PROCBASED_CTLS2_REGISTER;

/**
 * Capability Reporting Register of EPT and VPID.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[63] && (IA32_VMX_PROCBASED_CTLS2[33]
 * || IA32_VMX_PROCBASED_CTLS2[37]) )
 * @see Vol3D[A.10(VPID AND EPT CAPABILITIES)]
 * @see Vol3D[A.10(VPID and EPT Capabilities)] (reference)
 */
#define IA32_VMX_EPT_VPID_CAP 0x0000048C
typedef union
{
        struct
        {
                /**
                 * [Bit 0] When set to 1, the processor supports execute-only translations by EPT.
                 * This support allows software to configure EPT paging-structure entries in which
                 * bits 1:0 are clear (indicating that data accesses are not allowed) and bit 2 is
                 * set (indicating that instruction fetches are allowed).
                 */
                UINT64 ExecuteOnlyPages : 1;
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_BIT  0
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_FLAG 0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_EXECUTE_ONLY_PAGES(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 5;

                /**
                 * [Bit 6] Indicates support for a page-walk length of 4.
                 */
                UINT64 PageWalkLength4 : 1;
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_BIT  6
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_FLAG 0x40
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_PAGE_WALK_LENGTH_4(_)   (((_) >> 6) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * [Bit 8] When set to 1, the logical processor allows software to configure the EPT
                 * paging-structure memory type to be uncacheable (UC).
                 *
                 * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP))]
                 */
                UINT64 MemoryTypeUncacheable : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_BIT  8
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_FLAG 0x100
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_UNCACHEABLE(_)   (((_) >> 8) & 0x01)
                UINT64 Reserved3 : 5;

                /**
                 * [Bit 14] When set to 1, the logical processor allows software to configure the
                 * EPT paging-structure memory type to be write-back (WB).
                 */
                UINT64 MemoryTypeWriteBack : 1;
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_BIT  14
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_FLAG 0x4000
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_MEMORY_TYPE_WRITE_BACK(_)   (((_) >> 14) & 0x01)
                UINT64 Reserved4 : 1;

                /**
                 * [Bit 16] When set to 1, the logical processor allows software to configure a EPT
                 * PDE to map a 2-Mbyte page (by setting bit 7 in the EPT PDE).
                 */
                UINT64 Pde2MbPages : 1;
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_BIT  16
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_FLAG 0x10000
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_PDE_2MB_PAGES(_)   (((_) >> 16) & 0x01)

                /**
                 * [Bit 17] When set to 1, the logical processor allows software to configure a EPT
                 * PDPTE to map a 1-Gbyte page (by setting bit 7 in the EPT PDPTE).
                 */
                UINT64 Pdpte1GbPages : 1;
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_BIT  17
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_FLAG 0x20000
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_PDPTE_1GB_PAGES(_)   (((_) >> 17) & 0x01)
                UINT64 Reserved5 : 2;

                /**
                 * [Bit 20] If bit 20 is read as 1, the INVEPT instruction is supported.
                 *
                 * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
                 * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
                 */
                UINT64 Invept : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_BIT  20
#define IA32_VMX_EPT_VPID_CAP_INVEPT_FLAG 0x100000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT(_)   (((_) >> 20) & 0x01)

                /**
                 * [Bit 21] When set to 1, accessed and dirty flags for EPT are supported.
                 *
                 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
                 */
                UINT64 EptAccessedAndDirtyFlags : 1;
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_BIT  21
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_FLAG 0x200000
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_EPT_ACCESSED_AND_DIRTY_FLAGS(_)   (((_) >> 21) & 0x01)

                /**
                 * [Bit 22] When set to 1, the processor reports advanced VM-exit information for
                 * EPT violations. This reporting is done only if this bit is read as 1.
                 *
                 * @see Vol3C[27.2.1(Basic VM-Exit Information)]
                 */
                UINT64 AdvancedVmexitEptViolationsInformation : 1;
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_BIT  22
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_FLAG 0x400000
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_ADVANCED_VMEXIT_EPT_VIOLATIONS_INFORMATION(_)   (((_) >> 22) & 0x01)

                /**
                 * [Bit 23] If bit 23 is read as 1, supervisor shadow-stack control is supported.
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 SupervisorShadowStack : 1;
#define IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK_BIT  23
#define IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK_FLAG 0x800000
#define IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_SUPERVISOR_SHADOW_STACK(_)   (((_) >> 23) & 0x01)
                UINT64 Reserved6 : 1;

                /**
                 * [Bit 25] When set to 1, the single-context INVEPT type is supported.
                 *
                 * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
                 * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
                 */
                UINT64 InveptSingleContext : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_BIT  25
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_FLAG 0x2000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_SINGLE_CONTEXT(_)   (((_) >> 25) & 0x01)

                /**
                 * [Bit 26] When set to 1, the all-context INVEPT type is supported.
                 *
                 * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
                 * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
                 */
                UINT64 InveptAllContexts : 1;
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_BIT  26
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_FLAG 0x4000000
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVEPT_ALL_CONTEXTS(_)   (((_) >> 26) & 0x01)
                UINT64 Reserved7 : 5;

                /**
                 * [Bit 32] When set to 1, the INVVPID instruction is supported.
                 */
                UINT64 Invvpid : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_BIT  32
#define IA32_VMX_EPT_VPID_CAP_INVVPID_FLAG 0x100000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID(_)   (((_) >> 32) & 0x01)
                UINT64 Reserved8 : 7;

                /**
                 * [Bit 40] When set to 1, the individual-address INVVPID type is supported.
                 */
                UINT64 InvvpidIndividualAddress : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_BIT  40
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_FLAG 0x10000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_INDIVIDUAL_ADDRESS(_)   (((_) >> 40) & 0x01)

                /**
                 * [Bit 41] When set to 1, the single-context INVVPID type is supported.
                 */
                UINT64 InvvpidSingleContext : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_BIT  41
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_FLAG 0x20000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT(_)   (((_) >> 41) & 0x01)

                /**
                 * [Bit 42] When set to 1, the all-context INVVPID type is supported.
                 */
                UINT64 InvvpidAllContexts : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_BIT  42
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_FLAG 0x40000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_ALL_CONTEXTS(_)   (((_) >> 42) & 0x01)

                /**
                 * [Bit 43] When set to 1, the single-context-retaining-globals INVVPID type is
                 * supported.
                 */
                UINT64 InvvpidSingleContextRetainGlobals : 1;
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_BIT  43
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_FLAG 0x80000000000
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS_MASK 0x01
#define IA32_VMX_EPT_VPID_CAP_INVVPID_SINGLE_CONTEXT_RETAIN_GLOBALS(_)   (((_) >> 43) & 0x01)
                UINT64 Reserved9 : 4;

                /**
                 * [Bits 53:48] Enumerate the maximum HLAT prefix size. It is expected that any
                 * processor that supports the 1-setting of the "enable HLAT" VM-execution control
                 * will enumerate this value as 1.
                 *
                 * @see Vol3A[4.5.1(Ordinary Paging and HLAT Paging)]
                 */
                UINT64 MaxHlatPrefixSize : 6;
#define IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE_BIT  48
#define IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE_FLAG 0x3F000000000000
#define IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE_MASK 0x3F
#define IA32_VMX_EPT_VPID_CAP_MAX_HLAT_PREFIX_SIZE(_)   (((_) >> 48) & 0x3F)
                UINT64 Reserved10 : 10;
        };

        UINT64 AsUInt;
} IA32_VMX_EPT_VPID_CAP_REGISTER;

/**
 * @defgroup IA32_VMX_TRUE_CTLS \
 *           IA32_VMX_TRUE_(x)_CTLS
 *
 * Capability Reporting Register of Pin-Based VM-Execution Flex Controls, Primary Processor-Based
 * VM-Execution Flex Controls, VM-Exit Flex Controls and VM-Entry Flex Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] = 1 && IA32_VMX_BASIC[55] )
 * @see Vol3D[A.3.1(Pin-Based VM-Execution Controls)]
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)]
 * @see Vol3D[A.4(VM-EXIT CONTROLS)]
 * @see Vol3D[A.5(VM-ENTRY CONTROLS)]
 * @see Vol3D[A.3.1(Pin-Based VMExecution Controls)] (reference)
 * @see Vol3D[A.3.2(Primary Processor-Based VM-Execution Controls)] (reference)
 * @see Vol3D[A.4(VM-Exit Controls)] (reference)
 * @see Vol3D[A.5(VM-Entry Controls)] (reference)
 * @{
 */
#define IA32_VMX_TRUE_PINBASED_CTLS  0x0000048D
#define IA32_VMX_TRUE_PROCBASED_CTLS 0x0000048E
#define IA32_VMX_TRUE_EXIT_CTLS      0x0000048F
#define IA32_VMX_TRUE_ENTRY_CTLS     0x00000490
typedef union
{
        struct
        {
                /**
                 * [Bits 31:0] Indicate the allowed 0-settings of these controls. VM entry allows
                 * control X to be 0 if bit X in the MSR is cleared to 0; if bit X in the MSR is set
                 * to 1, VM entry fails if control X is 0.
                 */
                UINT64 Allowed0Settings : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_BIT  0
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_FLAG 0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS_MASK 0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_0_SETTINGS(_)   (((_) >> 0) & 0xFFFFFFFF)

                /**
                 * [Bits 63:32] Indicate the allowed 1-settings of these controls. VM entry allows
                 * control X to be 1 if bit 32+X in the MSR is set to 1; if bit 32+X in the MSR is
                 * cleared to 0, VM entry fails if control X is 1.
                 */
                UINT64 Allowed1Settings : 32;
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_BIT  32
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_FLAG 0xFFFFFFFF00000000
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS_MASK 0xFFFFFFFF
#define IA32_VMX_TRUE_CTLS_ALLOWED_1_SETTINGS(_)   (((_) >> 32) & 0xFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_VMX_TRUE_CTLS_REGISTER;

/**
 * @}
 */

/**
 * Capability Reporting Register of VMFunction Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] = 1 && IA32_VMX_BASIC[55] )
 * @see Vol3D[A.11(VM FUNCTIONS)]
 * @see Vol3D[24.6.14(VM-Function Controls)] (reference)
 */
#define IA32_VMX_VMFUNC 0x00000491
typedef union
{
        struct
        {
                /**
                 * [Bit 0] The EPTP-switching VM function changes the EPT pointer to a value chosen
                 * from the EPTP list.
                 *
                 * @see Vol3C[25.5.5.3(EPTP Switching)]
                 */
                UINT64 EptpSwitching : 1;
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_BIT  0
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_FLAG 0x01
#define IA32_VMX_VMFUNC_EPTP_SWITCHING_MASK 0x01
#define IA32_VMX_VMFUNC_EPTP_SWITCHING(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 63;
        };

        UINT64 AsUInt;
} IA32_VMX_VMFUNC_REGISTER;

/**
 * Capability Reporting Register of Tertiary Processor-Based VM-Execution Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_PROCBASED_CTLS[49] )
 * @see Vol3D[A.3.4(Tertiary Processor-Based VM-Execution Controls)]
 * @see Vol3D[24.6.2(Processor-Based VM-Execution Controls)] (reference)
 */
#define IA32_VMX_PROCBASED_CTLS3 0x00000492
typedef union
{
        struct
        {
                /**
                 * @brief Executions of LOADIWKEY cause VM exits
                 *
                 * [Bit 0] This control determines whether executions of LOADIWKEY cause VM exits.
                 */
                UINT64 LoadiwkeyExiting : 1;
#define IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING_BIT  0
#define IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING_FLAG 0x01
#define IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS3_LOADIWKEY_EXITING(_)   (((_) >> 0) & 0x01)

                /**
                 * @brief Enables hypervisor-managed linear-address translation
                 *
                 * [Bit 1] This control enables hypervisor-managed linear-address translation.
                 *
                 * @see Vol3A[4.5.1(Ordinary Paging and HLAT Paging)]
                 */
                UINT64 EnableHlat : 1;
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT_BIT  1
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT_FLAG 0x02
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS3_ENABLE_HLAT(_)   (((_) >> 1) & 0x01)

                /**
                 * @brief If this control is 1, EPT permissions can be specified to allow writes
                 * only for paging-related control updates
                 *
                 * [Bit 2] If this control is 1, EPT permissions can be specified to allow writes
                 * only for paging-related control updates.
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 EptPagingWrite : 1;
#define IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE_BIT  2
#define IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE_FLAG 0x04
#define IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS3_EPT_PAGING_WRITE(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] If this control is 1, EPT permissions can be specified to prevent
                 * accesses using linear addresses verification whose translation has certain
                 * properties.
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 GuestPaging : 1;
#define IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING_BIT  3
#define IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING_FLAG 0x08
#define IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING_MASK 0x01
#define IA32_VMX_PROCBASED_CTLS3_GUEST_PAGING(_)   (((_) >> 3) & 0x01)
                UINT64 Reserved1 : 60;
        };

        UINT64 AsUInt;
} IA32_VMX_PROCBASED_CTLS3_REGISTER;

/**
 * Capability Reporting Register of Secondary VM-Exit Controls.
 *
 * @remarks If ( CPUID.01H:ECX.[5] && IA32_VMX_EXIT_CTLS[63] )
 * @see Vol3D[A.4.2(Secondary VM-Exit Controls)]
 * @see Vol3C[24.7.1(VM-Exit Controls)] (reference)
 */
#define IA32_VMX_EXIT_CTLS2 0x00000493
typedef union
{
        struct
        {
                UINT64 Reserved : 64;
#define IA32_VMX_EXIT_CTLS2_RESERVED_BIT  0
#define IA32_VMX_EXIT_CTLS2_RESERVED_FLAG 0xFFFFFFFFFFFFFFFF
#define IA32_VMX_EXIT_CTLS2_RESERVED_MASK 0xFFFFFFFFFFFFFFFF
#define IA32_VMX_EXIT_CTLS2_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFFFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_VMX_EXIT_CTLS2_REGISTER;

/**
 * @defgroup IA32_A_PMC \
 *           IA32_A_PMC(n)
 *
 * Full Width Writable IA32_PMC(n) Alias.
 *
 * @remarks (If CPUID.0AH: EAX[15:8] > 0) && IA32_PERF_CAPABILITIES[13] = 1
 * @{
 */
#define IA32_A_PMC0 0x000004C1
#define IA32_A_PMC1 0x000004C2
#define IA32_A_PMC2 0x000004C3
#define IA32_A_PMC3 0x000004C4
#define IA32_A_PMC4 0x000004C5
#define IA32_A_PMC5 0x000004C6
#define IA32_A_PMC6 0x000004C7
#define IA32_A_PMC7 0x000004C8
/**
 * @}
 */

/**
 * Allows software to signal some MCEs to only a single logical processor in the system.
 *
 * @remarks If IA32_MCG_CAP.LMCE_P = 1
 * @see Vol3B[15.3.1.4(IA32_MCG_EXT_CTL MSR)]
 */
#define IA32_MCG_EXT_CTL 0x000004D0
typedef union
{
        struct
        {
                UINT64 LmceEn : 1;
#define IA32_MCG_EXT_CTL_LMCE_EN_BIT  0
#define IA32_MCG_EXT_CTL_LMCE_EN_FLAG 0x01
#define IA32_MCG_EXT_CTL_LMCE_EN_MASK 0x01
#define IA32_MCG_EXT_CTL_LMCE_EN(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 63;
        };

        UINT64 AsUInt;
} IA32_MCG_EXT_CTL_REGISTER;

/**
 * @brief Status and SVN Threshold of SGX Support for ACM <b>(RO)</b>
 *
 * Intel SGX only allows launching ACMs with an Intel SGX SVN that is at the same level or higher
 * than the expected Intel SGX SVN. The expected Intel SGX SVN is specified by BIOS and locked down
 * by the processor on the first successful execution of an Intel SGX instruction that doesn't
 * return an error code. Intel SGX provides interfaces for system software to discover whether a non
 * faulting Intel SGX instruction has been executed, and evaluate the suitability of the Intel SGX
 * SVN value of any ACM that is expected to be launched by the OS or the VMM.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H): EBX[2] = 1
 * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))] (reference)
 */
#define IA32_SGX_SVN_STATUS 0x00000500
typedef union
{
        struct
        {
                /**
                 * [Bit 0] - If 1, indicates that a non-faulting Intel SGX instruction has been
                 * executed, consequently, launching a properly signed ACM but with Intel SGX SVN
                 * value less than the BIOS specified Intel SGX SVN threshold would lead to an TXT
                 * shutdown.
                 * - If 0, indicates that the processor will allow a properly signed ACM to launch
                 * irrespective of the Intel SGX SVN value of the ACM.
                 *
                 * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))]
                 */
                UINT64 Lock : 1;
#define IA32_SGX_SVN_STATUS_LOCK_BIT  0
#define IA32_SGX_SVN_STATUS_LOCK_FLAG 0x01
#define IA32_SGX_SVN_STATUS_LOCK_MASK 0x01
#define IA32_SGX_SVN_STATUS_LOCK(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 15;

                /**
                 * @brief Reflects the expected threshold of Intel SGX SVN for the SINIT ACM
                 *
                 * [Bits 23:16] - If CPUID.01H:ECX.SMX = 1, this field reflects the expected
                 * threshold of Intel SGX SVN for the SINIT ACM.
                 * - If CPUID.01H:ECX.SMX = 0, this field is reserved (0).
                 *
                 * @see Vol3D[41.11.3(Interactions with Authenticated Code Modules (ACMs))]
                 */
                UINT64 SgxSvnSinit : 8;
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_BIT  16
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_FLAG 0xFF0000
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT_MASK 0xFF
#define IA32_SGX_SVN_STATUS_SGX_SVN_SINIT(_)   (((_) >> 16) & 0xFF)
                UINT64 Reserved2 : 40;
        };

        UINT64 AsUInt;
} IA32_SGX_SVN_STATUS_REGISTER;

/**
 * Trace Output Base Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && ( (CPUID.(EAX=14H,ECX=0): ECX[0] = 1) ||
 *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
 * @see Vol3C[35.2.7.7(IA32_RTIT_OUTPUT_BASE MSR)] (reference)
 */
#define IA32_RTIT_OUTPUT_BASE 0x00000560
typedef union
{
        struct
        {
                UINT64 Reserved1 : 7;

                /**
                 * @brief Base physical address
                 *
                 * [Bits 47:7] The base physical address. How this address is used depends on the
                 * value of IA32_RTIT_CTL.ToPA:
                 * - 0: This is the base physical address of a single, contiguous physical output
                 * region. This could be mapped to DRAM or to MMIO, depending on the value. The base
                 * address should be aligned with the size of the region, such that none of the 1s
                 * in the mask value overlap with 1s in the base address. If the base is not
                 * aligned, an operational error will result.
                 * - 1: The base physical address of the current ToPA table. The address must be 4K
                 * aligned. Writing an address in which bits 11:7 are non-zero will not cause a
                 * \#GP, but an operational error will be signaled once TraceEn is set.
                 *
                 * @see Vol3C[35.2.7.8(IA32_RTIT_OUTPUT_MASK_PTRS MSR)]
                 * @see Vol3C[35.3.9(Operational Errors)]
                 * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA))]
                 */
                UINT64 BasePhysicalAddress : 41;
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_BIT  7
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_FLAG 0xFFFFFFFFFF80
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS_MASK 0x1FFFFFFFFFF
#define IA32_RTIT_OUTPUT_BASE_BASE_PHYSICAL_ADDRESS(_)   (((_) >> 7) & 0x1FFFFFFFFFF)
                UINT64 Reserved2 : 16;
        };

        UINT64 AsUInt;
} IA32_RTIT_OUTPUT_BASE_REGISTER;

/**
 * Trace Output Mask Pointers Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[25] = 1) && ( (CPUID.(EAX=14H,ECX=0):ECX[0] = 1) ||
 *          (CPUID.(EAX=14H,ECX=0):ECX[2] = 1) ) )
 * @see Vol3C[35.2.7.8(IA32_RTIT_OUTPUT_MASK_PTRS MSR)] (reference)
 */
#define IA32_RTIT_OUTPUT_MASK_PTRS 0x00000561
typedef union
{
        struct
        {
                /**
                 * [Bits 6:0] Forced to 1, writes are ignored.
                 */
                UINT64 LowerMask : 7;
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_BIT  0
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_FLAG 0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK_MASK 0x7F
#define IA32_RTIT_OUTPUT_MASK_PTRS_LOWER_MASK(_)   (((_) >> 0) & 0x7F)

                /**
                 * @brief MaskOrTableOffset
                 *
                 * [Bits 31:7] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
                 * - 0: This field holds bits 31:7 of the mask value for the single, contiguous
                 * physical output region. The size of this field indicates that regions can be of
                 * size 128B up to 4GB. This value (combined with the lower 7 bits, which are
                 * reserved to 1) will be ANDed with the OutputOffset field to determine the next
                 * write address. All 1s in this field should be consecutive and starting at bit 7,
                 * otherwise the region will not be contiguous, and an operational error will be
                 * signaled when TraceEn is set.
                 * - 1: This field holds bits 27:3 of the offset pointer into the current ToPA
                 * table. This value can be added to the IA32_RTIT_OUTPUT_BASE value to produce a
                 * pointer to the current ToPA table entry, which itself is a pointer to the current
                 * output region. In this scenario, the lower 7 reserved bits are ignored. This
                 * field supports tables up to 256 MBytes in size.
                 *
                 * @see Vol3C[35.3.9(Operational Errors)]
                 */
                UINT64 MaskOrTableOffset : 25;
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_BIT  7
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_FLAG 0xFFFFFF80
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET_MASK 0x1FFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_MASK_OR_TABLE_OFFSET(_)   (((_) >> 7) & 0x1FFFFFF)

                /**
                 * @brief Output Offset
                 *
                 * [Bits 63:32] The use of this field depends on the value of IA32_RTIT_CTL.ToPA:
                 * - 0: This is bits 31:0 of the offset pointer into the single, contiguous physical
                 * output region. This value will be added to the IA32_RTIT_OUTPUT_BASE value to
                 * form the physical address at which the next byte of packet output data will be
                 * written. This value must be less than or equal to the MaskOrTableOffset field,
                 * otherwise an operational error will be signaled when TraceEn is set.
                 * - 1: This field holds bits 31:0 of the offset pointer into the current ToPA
                 * output region. This value will be added to the output region base field, found in
                 * the current ToPA table entry, to form the physical address at which the next byte
                 * of trace output data will be written. This value must be less than the ToPA entry
                 * size, otherwise an operational error will be signaled when TraceEn is set.
                 *
                 * @see Vol3C[35.3.9(Operational Errors)]
                 */
                UINT64 OutputOffset : 32;
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_BIT  32
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_FLAG 0xFFFFFFFF00000000
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET_MASK 0xFFFFFFFF
#define IA32_RTIT_OUTPUT_MASK_PTRS_OUTPUT_OFFSET(_)   (((_) >> 32) & 0xFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_RTIT_OUTPUT_MASK_PTRS_REGISTER;

/**
 * Trace Control Register.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 * @see Vol3C[35.2.7.2(IA32_RTIT_CTL MSR)] (reference)
 */
#define IA32_RTIT_CTL 0x00000570
typedef union
{
        struct
        {
                /**
                 * @brief TraceEn
                 *
                 * [Bit 0] If 1, enables tracing; else tracing is disabled.
                 * When this bit transitions from 1 to 0, all buffered packets are flushed out of
                 * internal buffers. A further store, fence, or architecturally serializing
                 * instruction may be required to ensure that packet data can be observed at the
                 * trace endpoint. Note that the processor will clear this bit on \#SMI (Section)
                 * and warm reset. Other MSR bits of IA32_RTIT_CTL (and other trace configuration
                 * MSRs) are not impacted by these events.
                 *
                 * @see Vol3C[35.2.7.3(Enabling and Disabling Packet Generation with TraceEn)]
                 */
                UINT64 TraceEnabled : 1;
#define IA32_RTIT_CTL_TRACE_ENABLED_BIT  0
#define IA32_RTIT_CTL_TRACE_ENABLED_FLAG 0x01
#define IA32_RTIT_CTL_TRACE_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_TRACE_ENABLED(_)   (((_) >> 0) & 0x01)

                /**
                 * @brief CYCEn
                 *
                 * [Bit 1] - 0: Disables CYC Packet.
                 * - 1: Enables CYC Packet.
                 *
                 * @remarks If CPUID.(EAX=14H, ECX=0):EBX.CPSB_CAM[bit 1] = 0
                 * @see Vol3C[35.4.2.14(Cycle Count (CYC) Packet)]
                 */
                UINT64 CycEnabled : 1;
#define IA32_RTIT_CTL_CYC_ENABLED_BIT  1
#define IA32_RTIT_CTL_CYC_ENABLED_FLAG 0x02
#define IA32_RTIT_CTL_CYC_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_CYC_ENABLED(_)   (((_) >> 1) & 0x01)

                /**
                 * @brief OS
                 *
                 * [Bit 2] - 0: Packet generation is disabled when CPL = 0.
                 * - 1: Packet generation may be enabled when CPL = 0.
                 */
                UINT64 Os : 1;
#define IA32_RTIT_CTL_OS_BIT  2
#define IA32_RTIT_CTL_OS_FLAG 0x04
#define IA32_RTIT_CTL_OS_MASK 0x01
#define IA32_RTIT_CTL_OS(_)   (((_) >> 2) & 0x01)

                /**
                 * @brief User
                 *
                 * [Bit 3] - 0: Packet generation is disabled when CPL > 0.
                 * - 1: Packet generation may be enabled when CPL > 0.
                 */
                UINT64 User : 1;
#define IA32_RTIT_CTL_USER_BIT  3
#define IA32_RTIT_CTL_USER_FLAG 0x08
#define IA32_RTIT_CTL_USER_MASK 0x01
#define IA32_RTIT_CTL_USER(_)   (((_) >> 3) & 0x01)

                /**
                 * @brief PwrEvtEn
                 *
                 * [Bit 4] - 0: Power Event Trace packets are disabled.
                 * - 1: Power Event Trace packets are enabled.
                 *
                 * @see Vol3C[35.2.3(Power Event Tracing)]
                 */
                UINT64 PowerEventTraceEnabled : 1;
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_BIT  4
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_FLAG 0x10
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_POWER_EVENT_TRACE_ENABLED(_)   (((_) >> 4) & 0x01)

                /**
                 * @brief FUPonPTW
                 *
                 * [Bit 5] - 0: PTW packets are not followed by FUPs.
                 * - 1: PTW packets are followed by FUPs.
                 */
                UINT64 FupOnPtw : 1;
#define IA32_RTIT_CTL_FUP_ON_PTW_BIT  5
#define IA32_RTIT_CTL_FUP_ON_PTW_FLAG 0x20
#define IA32_RTIT_CTL_FUP_ON_PTW_MASK 0x01
#define IA32_RTIT_CTL_FUP_ON_PTW(_)   (((_) >> 5) & 0x01)

                /**
                 * @brief FabricEn
                 *
                 * [Bit 6] - 0: Trace output is directed to the memory subsystem, mechanism depends
                 * on IA32_RTIT_CTL.ToPA.
                 * - 1: Trace output is directed to the trace transport subsystem,
                 * IA32_RTIT_CTL.ToPA is ignored.
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=0):ECX[3] = 1) Reserved if CPUID.(EAX=14H,
                 * ECX=0):ECX[bit 3] = 0
                 */
                UINT64 FabricEnabled : 1;
#define IA32_RTIT_CTL_FABRIC_ENABLED_BIT  6
#define IA32_RTIT_CTL_FABRIC_ENABLED_FLAG 0x40
#define IA32_RTIT_CTL_FABRIC_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_FABRIC_ENABLED(_)   (((_) >> 6) & 0x01)

                /**
                 * @brief CR3 filter
                 *
                 * [Bit 7] - 0: Disables CR3 filtering.
                 * - 1: Enables CR3 filtering.
                 */
                UINT64 Cr3Filter : 1;
#define IA32_RTIT_CTL_CR3_FILTER_BIT  7
#define IA32_RTIT_CTL_CR3_FILTER_FLAG 0x80
#define IA32_RTIT_CTL_CR3_FILTER_MASK 0x01
#define IA32_RTIT_CTL_CR3_FILTER(_)   (((_) >> 7) & 0x01)

                /**
                 * @brief ToPA
                 *
                 * [Bit 8] - 0: Single-range output scheme enabled.
                 * - 1: ToPA output scheme enabled.
                 *
                 * @remarks 0: If CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 1 and
                 * IA32_RTIT_CTL.FabricEn=0 1: If CPUID.(EAX=14H, ECX=0):ECX.TOPA[bit 0] = 1, and
                 * IA32_RTIT_CTL.FabricEn=0 WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this
                 * bit and FabricEn would cause \#GP: If CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit
                 * 2] = 0 WRMSR to IA32_RTIT_CTL that sets this bit causes \#GP: If CPUID.(EAX=14H,
                 *          ECX=0):ECX.TOPA[bit 0] = 0
                 * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA))]
                 */
                UINT64 Topa : 1;
#define IA32_RTIT_CTL_TOPA_BIT  8
#define IA32_RTIT_CTL_TOPA_FLAG 0x100
#define IA32_RTIT_CTL_TOPA_MASK 0x01
#define IA32_RTIT_CTL_TOPA(_)   (((_) >> 8) & 0x01)

                /**
                 * @brief MTCEn
                 *
                 * [Bit 9] - 0: Disables MTC Packet.
                 * - 1: Enables MTC Packet.
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[3] = 1) Reserved if CPUID.(EAX=14H,
                 * ECX=0):EBX.MTC[bit 3] = 0
                 * @see Vol3C[35.4.2.16(Overflow (OVF) Packet)]
                 */
                UINT64 MtcEnabled : 1;
#define IA32_RTIT_CTL_MTC_ENABLED_BIT  9
#define IA32_RTIT_CTL_MTC_ENABLED_FLAG 0x200
#define IA32_RTIT_CTL_MTC_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_MTC_ENABLED(_)   (((_) >> 9) & 0x01)

                /**
                 * @brief TSCEn
                 *
                 * [Bit 10] - 0: Disable TSC packets.
                 * - 1: Enable TSC packets.
                 *
                 * @see Vol3C[35.4.2.11(Timestamp Counter (TSC) Packet)]
                 */
                UINT64 TscEnabled : 1;
#define IA32_RTIT_CTL_TSC_ENABLED_BIT  10
#define IA32_RTIT_CTL_TSC_ENABLED_FLAG 0x400
#define IA32_RTIT_CTL_TSC_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_TSC_ENABLED(_)   (((_) >> 10) & 0x01)

                /**
                 * @brief DisRETC
                 *
                 * [Bit 11] - 0: Enable RET compression.
                 * - 1: Disable RET compression.
                 *
                 * @see Vol3C[35.2.1.2(Indirect Transfer COFI)]
                 */
                UINT64 RetCompressionDisabled : 1;
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_BIT  11
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_FLAG 0x800
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED_MASK 0x01
#define IA32_RTIT_CTL_RET_COMPRESSION_DISABLED(_)   (((_) >> 11) & 0x01)

                /**
                 * @brief PTWEn
                 *
                 * [Bit 12] - 0: PTWRITE packet generation disabled.
                 * - 1: PTWRITE packet generation enabled.
                 */
                UINT64 PtwEnabled : 1;
#define IA32_RTIT_CTL_PTW_ENABLED_BIT  12
#define IA32_RTIT_CTL_PTW_ENABLED_FLAG 0x1000
#define IA32_RTIT_CTL_PTW_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_PTW_ENABLED(_)   (((_) >> 12) & 0x01)

                /**
                 * @brief BranchEn
                 *
                 * [Bit 13] - 0: Disable COFI-based packets.
                 * - 1: Enable COFI-based packets: FUP, TIP, TIP.PGE, TIP.PGD, TNT, MODE.Exec,
                 * MODE.TSX.
                 *
                 * @see Vol3C[35.2.5.4(Branch Enable (BranchEn))]
                 */
                UINT64 BranchEnabled : 1;
#define IA32_RTIT_CTL_BRANCH_ENABLED_BIT  13
#define IA32_RTIT_CTL_BRANCH_ENABLED_FLAG 0x2000
#define IA32_RTIT_CTL_BRANCH_ENABLED_MASK 0x01
#define IA32_RTIT_CTL_BRANCH_ENABLED(_)   (((_) >> 13) & 0x01)

                /**
                 * @brief MTCFreq
                 *
                 * [Bits 17:14] Defines MTC packet Frequency, which is based on the core crystal
                 * clock, or Always Running Timer (ART). MTC will be sent each time the selected ART
                 * bit toggles. The following Encodings are defined: 0: ART(0), 1: ART(1), 2:
                 * ART(2), 3: ART(3), 4: ART(4), 5: ART(5), 6: ART(6), 7: ART(7), 8: ART(8), 9:
                 * ART(9), 10: ART(10), 11: ART(11), 12: ART(12), 13: ART(13), 14: ART(14), 15:
                 * ART(15)
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[3] = 1) Reserved if CPUID.(EAX=14H,
                 * ECX=0):EBX.MTC[bit 3] = 0
                 * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
                 */
                UINT64 MtcFrequency : 4;
#define IA32_RTIT_CTL_MTC_FREQUENCY_BIT  14
#define IA32_RTIT_CTL_MTC_FREQUENCY_FLAG 0x3C000
#define IA32_RTIT_CTL_MTC_FREQUENCY_MASK 0x0F
#define IA32_RTIT_CTL_MTC_FREQUENCY(_)   (((_) >> 14) & 0x0F)
                UINT64 Reserved1 : 1;

                /**
                 * @brief CYCThresh
                 *
                 * [Bits 22:19] CYC packet threshold. CYC packets will be sent with the first
                 * eligible packet after N cycles have passed since the last CYC packet. If
                 * CycThresh is 0 then N=0, otherwise N is defined as 2(CycThresh-1). The following
                 * Encodings are defined: 0: 0, 1: 1, 2: 2, 3: 4, 4: 8, 5: 16, 6: 32, 7: 64, 8: 128,
                 * 9: 256, 10: 512, 11: 1024, 12: 2048, 13: 4096, 14: 8192, 15: 16384
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] = 1) Reserved if CPUID.(EAX=14H,
                 * ECX=0):EBX.CPSB_CAM[bit 1] = 0
                 * @see Vol3C[35.3.6(Cycle-Accurate Mode)]
                 * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
                 */
                UINT64 CycThreshold : 4;
#define IA32_RTIT_CTL_CYC_THRESHOLD_BIT  19
#define IA32_RTIT_CTL_CYC_THRESHOLD_FLAG 0x780000
#define IA32_RTIT_CTL_CYC_THRESHOLD_MASK 0x0F
#define IA32_RTIT_CTL_CYC_THRESHOLD(_)   (((_) >> 19) & 0x0F)
                UINT64 Reserved2 : 1;

                /**
                 * @brief PSBFreq
                 *
                 * [Bits 27:24] Indicates the frequency of PSB packets. PSB packet frequency is
                 * based on the number of Intel PT packet bytes output, so this field allows the
                 * user to determine the increment of IA32_IA32_RTIT_STATUS.PacketByteCnt that
                 * should cause a PSB to be generated. Note that PSB insertion is not precise, but
                 * the average output bytes per PSB should approximate the SW selected period. The
                 * following Encodings are defined: 0: 2K, 1: 4K, 2: 8K, 3: 16K, 4: 32K, 5: 64K, 6:
                 * 128K, 7: 256K, 8: 512K, 9: 1M, 10: 2M, 11: 4M, 12: 8M, 13: 16M, 14: 32M, 15: 64M
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] = 1) Reserved if CPUID.(EAX=14H,
                 * ECX=0):EBX.CPSB_CAM[bit 1] = 0
                 * @see Vol3C[35.3.1(Detection of Intel Processor Trace and Capability Enumeration)]
                 */
                UINT64 PsbFrequency : 4;
#define IA32_RTIT_CTL_PSB_FREQUENCY_BIT  24
#define IA32_RTIT_CTL_PSB_FREQUENCY_FLAG 0xF000000
#define IA32_RTIT_CTL_PSB_FREQUENCY_MASK 0x0F
#define IA32_RTIT_CTL_PSB_FREQUENCY(_)   (((_) >> 24) & 0x0F)
                UINT64 Reserved3 : 4;

                /**
                 * @brief ADDR0_CFG
                 *
                 * [Bits 35:32] Configures the base/limit register pair IA32_RTIT_ADDR0_A/B based on
                 * the following encodings:
                 * - 0: ADDR0 range unused.
                 * - 1: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a FilterEn range.
                 * FilterEn will only be set when the IP is within this range, though other FilterEn
                 * ranges can additionally be used.
                 * - 2: The [IA32_RTIT_ADDR0_A..IA32_RTIT_ADDR0_B] range defines a TraceStop range.
                 * TraceStop will be asserted if code branches into this range.
                 * - 3..15: Reserved (\#GP).
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 0) Reserved if CPUID.(EAX=14H,
                 * ECX=1):EBX.RANGECNT[2:0] >= 0
                 * @see Vol3C[35.2.4.3(Filtering by IP)]
                 * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
                 */
                UINT64 Addr0Cfg : 4;
#define IA32_RTIT_CTL_ADDR0_CFG_BIT  32
#define IA32_RTIT_CTL_ADDR0_CFG_FLAG 0xF00000000
#define IA32_RTIT_CTL_ADDR0_CFG_MASK 0x0F
#define IA32_RTIT_CTL_ADDR0_CFG(_)   (((_) >> 32) & 0x0F)

                /**
                 * @brief ADDR1_CFG
                 *
                 * [Bits 39:36] Configures the base/limit register pair IA32_RTIT_ADDR1_A/B based on
                 * the following encodings:
                 * - 0: ADDR1 range unused.
                 * - 1: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a FilterEn range.
                 * FilterEn will only be set when the IP is within this range, though other FilterEn
                 * ranges can additionally be used.
                 * - 2: The [IA32_RTIT_ADDR1_A..IA32_RTIT_ADDR1_B] range defines a TraceStop range.
                 * TraceStop will be asserted if code branches into this range.
                 * - 3..15: Reserved (\#GP).
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 1) Reserved if CPUID.(EAX=14H,
                 * ECX=1):EBX.RANGECNT[2:0] < 2
                 * @see Vol3C[35.2.4.3(Filtering by IP)]
                 * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
                 */
                UINT64 Addr1Cfg : 4;
#define IA32_RTIT_CTL_ADDR1_CFG_BIT  36
#define IA32_RTIT_CTL_ADDR1_CFG_FLAG 0xF000000000
#define IA32_RTIT_CTL_ADDR1_CFG_MASK 0x0F
#define IA32_RTIT_CTL_ADDR1_CFG(_)   (((_) >> 36) & 0x0F)

                /**
                 * @brief ADDR2_CFG
                 *
                 * [Bits 43:40] Configures the base/limit register pair IA32_RTIT_ADDR2_A/B based on
                 * the following encodings:
                 * - 0: ADDR2 range unused.
                 * - 1: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a FilterEn range.
                 * FilterEn will only be set when the IP is within this range, though other FilterEn
                 * ranges can additionally be used.
                 * - 2: The [IA32_RTIT_ADDR2_A..IA32_RTIT_ADDR2_B] range defines a TraceStop range.
                 * TraceStop will be asserted if code branches into this range.
                 * - 3..15: Reserved (\#GP).
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 2) Reserved if CPUID.(EAX=14H,
                 * ECX=1):EBX.RANGECNT[2:0] < 3
                 * @see Vol3C[35.2.4.3(Filtering by IP)]
                 * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
                 */
                UINT64 Addr2Cfg : 4;
#define IA32_RTIT_CTL_ADDR2_CFG_BIT  40
#define IA32_RTIT_CTL_ADDR2_CFG_FLAG 0xF0000000000
#define IA32_RTIT_CTL_ADDR2_CFG_MASK 0x0F
#define IA32_RTIT_CTL_ADDR2_CFG(_)   (((_) >> 40) & 0x0F)

                /**
                 * @brief ADDR3_CFG
                 *
                 * [Bits 47:44] Configures the base/limit register pair IA32_RTIT_ADDR3_A/B based on
                 * the following encodings:
                 * - 0: ADDR3 range unused.
                 * - 1: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a FilterEn range.
                 * FilterEn will only be set when the IP is within this range, though other FilterEn
                 * ranges can additionally be used.
                 * - 2: The [IA32_RTIT_ADDR3_A..IA32_RTIT_ADDR3_B] range defines a TraceStop range.
                 * TraceStop will be asserted if code branches into this range.
                 * - 3..15: Reserved (\#GP).
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > 3) Reserved if CPUID.(EAX=14H,
                 * ECX=1):EBX.RANGECNT[2:0] < 4
                 * @see Vol3C[35.2.4.3(Filtering by IP)]
                 * @see Vol3C[35.4.2.10(Core:Bus Ratio (CBR) Packet)]
                 */
                UINT64 Addr3Cfg : 4;
#define IA32_RTIT_CTL_ADDR3_CFG_BIT  44
#define IA32_RTIT_CTL_ADDR3_CFG_FLAG 0xF00000000000
#define IA32_RTIT_CTL_ADDR3_CFG_MASK 0x0F
#define IA32_RTIT_CTL_ADDR3_CFG(_)   (((_) >> 44) & 0x0F)
                UINT64 Reserved4 : 8;

                /**
                 * @brief InjectPsbPmiOnEnable
                 *
                 * [Bit 56] - 1: Enables use of IA32_RTIT_STATUS bits PendPSB[6] and PendTopaPMI[7].
                 * - 0: IA32_RTIT_STATUS bits 6 and 7 are ignored.
                 *
                 * @remarks Reserved if CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 0
                 * @see Vol3C[35.2.7.4(IA32_RTIT_STATUS MSR)]
                 */
                UINT64 InjectPsbPmiOnEnable : 1;
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_BIT  56
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_FLAG 0x100000000000000
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE_MASK 0x01
#define IA32_RTIT_CTL_INJECT_PSB_PMI_ON_ENABLE(_)   (((_) >> 56) & 0x01)
                UINT64 Reserved5 : 7;
        };

        UINT64 AsUInt;
} IA32_RTIT_CTL_REGISTER;

/**
 * Tracing Status Register.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 */
#define IA32_RTIT_STATUS 0x00000571
typedef union
{
        struct
        {
                /**
                 * @brief FilterEn (writes ignored)
                 *
                 * [Bit 0] This bit is written by the processor, and indicates that tracing is
                 * allowed for the current IP. Writes are ignored.
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[2] = 1)
                 * @see Vol3C[35.2.5.5(Filter Enable (FilterEn))]
                 */
                UINT64 FilterEnabled : 1;
#define IA32_RTIT_STATUS_FILTER_ENABLED_BIT  0
#define IA32_RTIT_STATUS_FILTER_ENABLED_FLAG 0x01
#define IA32_RTIT_STATUS_FILTER_ENABLED_MASK 0x01
#define IA32_RTIT_STATUS_FILTER_ENABLED(_)   (((_) >> 0) & 0x01)

                /**
                 * @brief ContexEn (writes ignored)
                 *
                 * [Bit 1] The processor sets this bit to indicate that tracing is allowed for the
                 * current context. Writes are ignored.
                 *
                 * @see Vol3C[35.2.5.3(Context Enable (ContextEn))]
                 */
                UINT64 ContextEnabled : 1;
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_BIT  1
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_FLAG 0x02
#define IA32_RTIT_STATUS_CONTEXT_ENABLED_MASK 0x01
#define IA32_RTIT_STATUS_CONTEXT_ENABLED(_)   (((_) >> 1) & 0x01)

                /**
                 * @brief TriggerEn (writes ignored)
                 *
                 * [Bit 2] The processor sets this bit to indicate that tracing is enabled. Writes
                 * are ignored.
                 *
                 * @see Vol3C[35.2.5.2(Trigger Enable (TriggerEn))]
                 */
                UINT64 TriggerEnabled : 1;
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_BIT  2
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_FLAG 0x04
#define IA32_RTIT_STATUS_TRIGGER_ENABLED_MASK 0x01
#define IA32_RTIT_STATUS_TRIGGER_ENABLED(_)   (((_) >> 2) & 0x01)
                UINT64 Reserved1 : 1;

                /**
                 * @brief Error
                 *
                 * [Bit 4] The processor sets this bit to indicate that an operational error has
                 * been encountered. When this bit is set, TriggerEn is cleared to 0 and packet
                 * generation is disabled. When TraceEn is cleared, software can write this bit.
                 * Once it is set, only software can clear it. It is not recommended that software
                 * ever set this bit, except in cases where it is restoring a prior saved state.
                 *
                 * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA Errors)]
                 */
                UINT64 Error : 1;
#define IA32_RTIT_STATUS_ERROR_BIT  4
#define IA32_RTIT_STATUS_ERROR_FLAG 0x10
#define IA32_RTIT_STATUS_ERROR_MASK 0x01
#define IA32_RTIT_STATUS_ERROR(_)   (((_) >> 4) & 0x01)

                /**
                 * @brief Stopped
                 *
                 * [Bit 5] The processor sets this bit to indicate that a ToPA Stop condition has
                 * been encountered. When this bit is set, TriggerEn is cleared to 0 and packet
                 * generation is disabled. When TraceEn is cleared, software can write this bit.
                 * Once it is set, only software can clear it. It is not recommended that software
                 * ever set this bit, except in cases where it is restoring a prior saved state.
                 *
                 * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA STOP)]
                 */
                UINT64 Stopped : 1;
#define IA32_RTIT_STATUS_STOPPED_BIT  5
#define IA32_RTIT_STATUS_STOPPED_FLAG 0x20
#define IA32_RTIT_STATUS_STOPPED_MASK 0x01
#define IA32_RTIT_STATUS_STOPPED(_)   (((_) >> 5) & 0x01)

                /**
                 * @brief Pend PSB
                 *
                 * [Bit 6] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this
                 * bit when the threshold for a PSB+ to be inserted has been reached. The processor
                 * will clear this bit when the PSB+ has been inserted into the trace. If PendPSB =
                 * 1 and InjectPsbPmiOnEnable = 1 when IA32_RTIT_CTL.TraceEn[0] transitions from 0
                 * to 1, a PSB+ will be inserted into the trace.
                 *
                 * @remarks If CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 1
                 */
                UINT64 PendPsb : 1;
#define IA32_RTIT_STATUS_PEND_PSB_BIT  6
#define IA32_RTIT_STATUS_PEND_PSB_FLAG 0x40
#define IA32_RTIT_STATUS_PEND_PSB_MASK 0x01
#define IA32_RTIT_STATUS_PEND_PSB(_)   (((_) >> 6) & 0x01)

                /**
                 * @brief Pend ToPA PMI
                 *
                 * [Bit 7] If IA32_RTIT_CTL.InjectPsbPmiOnEnable[56] = 1, the processor sets this
                 * bit when the threshold for a ToPA PMI to be inserted has been reached. Software
                 * should clear this bit once the ToPA PMI has been handled. If PendTopaPMI = 1 and
                 * InjectPsbPmiOnEnable = 1 when IA32_RTIT_CTL.TraceEn[0] transitions from 0 to 1, a
                 * PMI will be pended.
                 *
                 * @remarks If CPUID.(EAX=14H, ECX=0):EBX.INJECTPSBPMI[6] = 1
                 * @see Vol3C[35.2.6.2(Table of Physical Addresses (ToPA) | ToPA PMI)]
                 */
                UINT64 PendTopaPmi : 1;
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_BIT  7
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_FLAG 0x80
#define IA32_RTIT_STATUS_PEND_TOPA_PMI_MASK 0x01
#define IA32_RTIT_STATUS_PEND_TOPA_PMI(_)   (((_) >> 7) & 0x01)
                UINT64 Reserved2 : 24;

                /**
                 * @brief PacketByteCnt
                 *
                 * [Bits 48:32] This field is written by the processor, and holds a count of packet
                 * bytes that have been sent out. The processor also uses this field to determine
                 * when the next PSB packet should be inserted. Note that the processor may clear or
                 * modify this field at any time while IA32_RTIT_CTL.TraceEn=1. It will have a
                 * stable value when IA32_RTIT_CTL.TraceEn=0.
                 *
                 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[1] > 3)
                 * @see Vol3C[35.4.2.17(Packet Stream Boundary (PSB) Packet)]
                 */
                UINT64 PacketByteCount : 17;
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_BIT  32
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_FLAG 0x1FFFF00000000
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT_MASK 0x1FFFF
#define IA32_RTIT_STATUS_PACKET_BYTE_COUNT(_)   (((_) >> 32) & 0x1FFFF)
                UINT64 Reserved3 : 15;
        };

        UINT64 AsUInt;
} IA32_RTIT_STATUS_REGISTER;

/**
 * @brief Trace Filter CR3 Match Register <b>(R/W)</b>
 *
 * The IA32_RTIT_CR3_MATCH register is compared against CR3 when IA32_RTIT_CTL.CR3Filter is 1. Bits
 * 63:5 hold the CR3 address value to match, bits 4:0 are reserved to 0.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0):EBX[25] = 1)
 * @see Vol3C[35.2.4.2(Filtering by CR3)]
 * @see Vol3C[35.2.7.6(IA32_RTIT_CR3_MATCH MSR)] (reference)
 */
#define IA32_RTIT_CR3_MATCH 0x00000572
typedef union
{
        struct
        {
                UINT64 Reserved1 : 5;

                /**
                 * [Bits 63:5] CR3[63:5] value to match.
                 */
                UINT64 Cr3ValueToMatch : 59;
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_BIT  5
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_FLAG 0xFFFFFFFFFFFFFFE0
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH_MASK 0x7FFFFFFFFFFFFFF
#define IA32_RTIT_CR3_MATCH_CR3_VALUE_TO_MATCH(_)   (((_) >> 5) & 0x7FFFFFFFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_RTIT_CR3_MATCH_REGISTER;

/**
 * @defgroup IA32_RTIT_ADDR \
 *           IA32_RTIT_ADDR(x)
 *
 * The role of the IA32_RTIT_ADDRn_A/B register pairs, for each n, is determined by the
 * corresponding ADDRn_CFG fields in IA32_RTIT_CTL. The number of these register pairs is enumerated
 * by CPUID.(EAX=14H, ECX=1):EAX.RANGECNT[2:0].
 *
 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
 * @see Vol3C[35.2.7.2(IA32_RTIT_CTL MSR)]
 * @see Vol3C[35.2.7.5(IA32_RTIT_ADDRn_A and IA32_RTIT_ADDRn_B MSRs)] (reference)
 * @{
 */
/**
 * @defgroup IA32_RTIT_ADDR_A \
 *           IA32_RTIT_ADDR(n)_A
 *
 * Region n Start Address.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
 * @{
 */
#define IA32_RTIT_ADDR0_A 0x00000580
#define IA32_RTIT_ADDR1_A 0x00000582
#define IA32_RTIT_ADDR2_A 0x00000584
#define IA32_RTIT_ADDR3_A 0x00000586
/**
 * @}
 */

/**
 * @defgroup IA32_RTIT_ADDR_B \
 *           IA32_RTIT_ADDR(n)_B
 *
 * Region n End Address.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=1):EAX[2:0] > n)
 * @{
 */
#define IA32_RTIT_ADDR0_B 0x00000581
#define IA32_RTIT_ADDR1_B 0x00000583
#define IA32_RTIT_ADDR2_B 0x00000585
#define IA32_RTIT_ADDR3_B 0x00000587
/**
 * @}
 */

typedef union
{
        struct
        {
                /**
                 * [Bits 47:0] Virtual Address.
                 */
                UINT64 VirtualAddress : 48;
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_BIT  0
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_FLAG 0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS_MASK 0xFFFFFFFFFFFF
#define IA32_RTIT_ADDR_VIRTUAL_ADDRESS(_)   (((_) >> 0) & 0xFFFFFFFFFFFF)

                /**
                 * [Bits 63:48] SignExt_VA.
                 */
                UINT64 SignExtVa : 16;
#define IA32_RTIT_ADDR_SIGN_EXT_VA_BIT  48
#define IA32_RTIT_ADDR_SIGN_EXT_VA_FLAG 0xFFFF000000000000
#define IA32_RTIT_ADDR_SIGN_EXT_VA_MASK 0xFFFF
#define IA32_RTIT_ADDR_SIGN_EXT_VA(_)   (((_) >> 48) & 0xFFFF)
        };

        UINT64 AsUInt;
} IA32_RTIT_ADDR_REGISTER;

/**
 * @}
 */

/**
 * DS Save Area. Points to the linear address of the first byte of the DS buffer management area,
 * which is used to manage the BTS and PEBS buffers. Returns:
 * - [63:0] The linear address of the first byte of the DS buffer management area, if IA-32e mode is
 * active.
 * - [31:0] The linear address of the first byte of the DS buffer management area, if not in IA-32e
 * mode.
 * - [63:32] Reserved if not in IA-32e mode.
 *
 * @remarks If CPUID.01H:EDX.DS[21] = 1
 * @see Vol3B[18.6.3.4(Debug Store (DS) Mechanism)]
 */
#define IA32_DS_AREA 0x00000600

/**
 * Configure User Mode CET
 *
 * @remarks - Bits 1:0 are defined if CPUID.(EAX=07H,ECX=0H):ECX.CET_SS[07] = 1. - Bits 5:2 and bits
 * 63:10 are defined if CPUID.(EAX=07H,ECX=0H):EDX.CET_IBT[20] = 1.
 */
#define IA32_U_CET 0x000006A0
typedef union
{
        struct
        {
                /**
                 * [Bit 0] When set to 1, enable shadow stacks at CPL3.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 ShStkEn : 1;
#define IA32_U_CET_SH_STK_EN_BIT  0
#define IA32_U_CET_SH_STK_EN_FLAG 0x01
#define IA32_U_CET_SH_STK_EN_MASK 0x01
#define IA32_U_CET_SH_STK_EN(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] When set to 1, enables the WRSSD/WRSSQ instructions.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 WrShstkEn : 1;
#define IA32_U_CET_WR_SHSTK_EN_BIT  1
#define IA32_U_CET_WR_SHSTK_EN_FLAG 0x02
#define IA32_U_CET_WR_SHSTK_EN_MASK 0x01
#define IA32_U_CET_WR_SHSTK_EN(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] When set to 1, enables indirect branch tracking
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 EndbrEn : 1;
#define IA32_U_CET_ENDBR_EN_BIT  2
#define IA32_U_CET_ENDBR_EN_FLAG 0x04
#define IA32_U_CET_ENDBR_EN_MASK 0x01
#define IA32_U_CET_ENDBR_EN(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Enable legacy compatibility treatment for indirect branch tracking.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 LegIwEn : 1;
#define IA32_U_CET_LEG_IW_EN_BIT  3
#define IA32_U_CET_LEG_IW_EN_FLAG 0x08
#define IA32_U_CET_LEG_IW_EN_MASK 0x01
#define IA32_U_CET_LEG_IW_EN(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] When set to 1, enables use of no-track prefix for indirect branch
                 * tracking.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 NoTrackEn : 1;
#define IA32_U_CET_NO_TRACK_EN_BIT  4
#define IA32_U_CET_NO_TRACK_EN_FLAG 0x10
#define IA32_U_CET_NO_TRACK_EN_MASK 0x01
#define IA32_U_CET_NO_TRACK_EN(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] When set to 1, disables suppression of CET indirect branch tracking on
                 * legacy compatibility.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 SuppressDis : 1;
#define IA32_U_CET_SUPPRESS_DIS_BIT  5
#define IA32_U_CET_SUPPRESS_DIS_FLAG 0x20
#define IA32_U_CET_SUPPRESS_DIS_MASK 0x01
#define IA32_U_CET_SUPPRESS_DIS(_)   (((_) >> 5) & 0x01)
                UINT64 Reserved1 : 4;

                /**
                 * [Bit 10] When set to 1, indirect branch tracking is suppressed. This bit can be
                 * written to 1 only if TRACKER is written as IDLE.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 Suppress : 1;
#define IA32_U_CET_SUPPRESS_BIT  10
#define IA32_U_CET_SUPPRESS_FLAG 0x400
#define IA32_U_CET_SUPPRESS_MASK 0x01
#define IA32_U_CET_SUPPRESS(_)   (((_) >> 10) & 0x01)

                /**
                 * [Bit 11] Value of the indirect branch tracking state machine. Values: IDLE (0),
                 * WAIT_FOR_ENDBRANCH(1).
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 Tracker : 1;
#define IA32_U_CET_TRACKER_BIT  11
#define IA32_U_CET_TRACKER_FLAG 0x800
#define IA32_U_CET_TRACKER_MASK 0x01
#define IA32_U_CET_TRACKER(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bits 63:12] Linear address bits 63:12 of a legacy code page bitmap used for
                 * legacy compatibility when indirect branch tracking is enabled. If the processor
                 * does not support Intel 64 architecture, these fields have only 32 bits; bits
                 * 63:32 of the MSRs are reserved. On processors that support Intel 64 architecture
                 * this value cannot represent a non-canonical address. In protected mode, only 31:0
                 * are loaded. The linear address written must be aligned to 8 bytes and bits 2:0
                 * must be 0 (hardware requires bits 1:0 to be 0).
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 EbLegBitmapBase : 52;
#define IA32_U_CET_EB_LEG_BITMAP_BASE_BIT  12
#define IA32_U_CET_EB_LEG_BITMAP_BASE_FLAG 0xFFFFFFFFFFFFF000
#define IA32_U_CET_EB_LEG_BITMAP_BASE_MASK 0xFFFFFFFFFFFFF
#define IA32_U_CET_EB_LEG_BITMAP_BASE(_)   (((_) >> 12) & 0xFFFFFFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_U_CET_REGISTER;

/**
 * Configure Supervisor Mode CET
 *
 * @remarks - Bits 1:0 are defined if CPUID.(EAX=07H,ECX=0H):ECX.CET_SS[07] = 1. - Bits 5:2 and bits
 * 63:10 are defined if CPUID.(EAX=07H,ECX=0H):EDX.CET_IBT[20] = 1.
 */
#define IA32_S_CET 0x000006A2
typedef union
{
        struct
        {
                /**
                 * [Bit 0] When set to 1, enable shadow stacks at CPL0.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 ShStkEn : 1;
#define IA32_S_CET_SH_STK_EN_BIT  0
#define IA32_S_CET_SH_STK_EN_FLAG 0x01
#define IA32_S_CET_SH_STK_EN_MASK 0x01
#define IA32_S_CET_SH_STK_EN(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] When set to 1, enables the WRSSD/WRSSQ instructions.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 WrShstkEn : 1;
#define IA32_S_CET_WR_SHSTK_EN_BIT  1
#define IA32_S_CET_WR_SHSTK_EN_FLAG 0x02
#define IA32_S_CET_WR_SHSTK_EN_MASK 0x01
#define IA32_S_CET_WR_SHSTK_EN(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] When set to 1, enables indirect branch tracking
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 EndbrEn : 1;
#define IA32_S_CET_ENDBR_EN_BIT  2
#define IA32_S_CET_ENDBR_EN_FLAG 0x04
#define IA32_S_CET_ENDBR_EN_MASK 0x01
#define IA32_S_CET_ENDBR_EN(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Enable legacy compatibility treatment for indirect branch tracking.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 LegIwEn : 1;
#define IA32_S_CET_LEG_IW_EN_BIT  3
#define IA32_S_CET_LEG_IW_EN_FLAG 0x08
#define IA32_S_CET_LEG_IW_EN_MASK 0x01
#define IA32_S_CET_LEG_IW_EN(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] When set to 1, enables use of no-track prefix for indirect branch
                 * tracking.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 NoTrackEn : 1;
#define IA32_S_CET_NO_TRACK_EN_BIT  4
#define IA32_S_CET_NO_TRACK_EN_FLAG 0x10
#define IA32_S_CET_NO_TRACK_EN_MASK 0x01
#define IA32_S_CET_NO_TRACK_EN(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] When set to 1, disables suppression of CET indirect branch tracking on
                 * legacy compatibility.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 SuppressDis : 1;
#define IA32_S_CET_SUPPRESS_DIS_BIT  5
#define IA32_S_CET_SUPPRESS_DIS_FLAG 0x20
#define IA32_S_CET_SUPPRESS_DIS_MASK 0x01
#define IA32_S_CET_SUPPRESS_DIS(_)   (((_) >> 5) & 0x01)
                UINT64 Reserved1 : 4;

                /**
                 * [Bit 10] When set to 1, indirect branch tracking is suppressed. This bit can be
                 * written to 1 only if TRACKER is written as IDLE.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 Suppress : 1;
#define IA32_S_CET_SUPPRESS_BIT  10
#define IA32_S_CET_SUPPRESS_FLAG 0x400
#define IA32_S_CET_SUPPRESS_MASK 0x01
#define IA32_S_CET_SUPPRESS(_)   (((_) >> 10) & 0x01)

                /**
                 * [Bit 11] Value of the indirect branch tracking state machine. Values: IDLE (0),
                 * WAIT_FOR_ENDBRANCH(1).
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 Tracker : 1;
#define IA32_S_CET_TRACKER_BIT  11
#define IA32_S_CET_TRACKER_FLAG 0x800
#define IA32_S_CET_TRACKER_MASK 0x01
#define IA32_S_CET_TRACKER(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bits 63:12] Linear address bits 63:12 of a legacy code page bitmap used for
                 * legacy compatibility when indirect branch tracking is enabled. If the processor
                 * does not support Intel 64 architecture, these fields have only 32 bits; bits
                 * 63:32 of the MSRs are reserved. On processors that support Intel 64 architecture
                 * this value cannot represent a non-canonical address. In protected mode, only 31:0
                 * are loaded. The linear address written must be aligned to 8 bytes and bits 2:0
                 * must be 0 (hardware requires bits 1:0 to be 0).
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT64 EbLegBitmapBase : 52;
#define IA32_S_CET_EB_LEG_BITMAP_BASE_BIT  12
#define IA32_S_CET_EB_LEG_BITMAP_BASE_FLAG 0xFFFFFFFFFFFFF000
#define IA32_S_CET_EB_LEG_BITMAP_BASE_MASK 0xFFFFFFFFFFFFF
#define IA32_S_CET_EB_LEG_BITMAP_BASE(_)   (((_) >> 12) & 0xFFFFFFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_S_CET_REGISTER;

/**
 * Linear address to be loaded into SSP on transition to privilege level 0.
 * If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits
 * 63:32 of the MSRs are reserved. On processors that support Intel 64 architecture this value
 * cannot represent a non-canonical address. In protected mode, only 31:0 are loaded. The linear
 * address written must be aligned to 8 bytes and bits 2:0 must be 0 (hardware requires bits 1:0 to
 * be 0).
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H):ECX.CET_SS[07] = 1
 */
#define IA32_PL0_SSP 0x000006A4

/**
 * Linear address to be loaded into SSP on transition to privilege level 1.
 * If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits
 * 63:32 of the MSRs are reserved. On processors that support Intel 64 architecture this value
 * cannot represent a non-canonical address. In protected mode, only 31:0 are loaded. The linear
 * address written must be aligned to 8 bytes and bits 2:0 must be 0 (hardware requires bits 1:0 to
 * be 0).
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H):ECX.CET_SS[07] = 1
 */
#define IA32_PL1_SSP 0x000006A5

/**
 * Linear address to be loaded into SSP on transition to privilege level 2.
 * If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits
 * 63:32 of the MSRs are reserved. On processors that support Intel 64 architecture this value
 * cannot represent a non-canonical address. In protected mode, only 31:0 are loaded. The linear
 * address written must be aligned to 8 bytes and bits 2:0 must be 0 (hardware requires bits 1:0 to
 * be 0).
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H):ECX.CET_SS[07] = 1
 */
#define IA32_PL2_SSP 0x000006A6

/**
 * Linear address to be loaded into SSP on transition to privilege level 3.
 * If the processor does not support Intel 64 architecture, these fields have only 32 bits; bits
 * 63:32 of the MSRs are reserved. On processors that support Intel 64 architecture this value
 * cannot represent a non-canonical address. In protected mode, only 31:0 are loaded. The linear
 * address written must be aligned to 8 bytes and bits 2:0 must be 0 (hardware requires bits 1:0 to
 * be 0).
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H):ECX.CET_SS[07] = 1
 */
#define IA32_PL3_SSP 0x000006A7

/**
 * Linear address of a table of seven shadow stack pointers that are selected in IA-32e mode using
 * the IST index (when not 0) from the interrupt gate descriptor. This MSR is not present on
 * processors that do not support Intel 64 architecture. This field cannot represent a non-canonical
 * address.
 *
 * @remarks If CPUID.(EAX=07H, ECX=0H):ECX.CET_SS[07] = 1
 */
#define IA32_INTERRUPT_SSP_TABLE_ADDR 0x000006A8

/**
 * TSC Target of Local APIC's TSC Deadline Mode.
 *
 * @remarks If CPUID.01H:ECX.[24] = 1
 */
#define IA32_TSC_DEADLINE 0x000006E0

/**
 * Enable/disable HWP.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_PM_ENABLE 0x00000770
typedef union
{
        struct
        {
                /**
                 * [Bit 0] HWP_ENABLE.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1
                 * @see Vol3B[14.4.2(Enabling HWP)]
                 */
                UINT64 HwpEnable : 1;
#define IA32_PM_ENABLE_HWP_ENABLE_BIT  0
#define IA32_PM_ENABLE_HWP_ENABLE_FLAG 0x01
#define IA32_PM_ENABLE_HWP_ENABLE_MASK 0x01
#define IA32_PM_ENABLE_HWP_ENABLE(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 63;
        };

        UINT64 AsUInt;
} IA32_PM_ENABLE_REGISTER;

/**
 * HWP Performance Range Enumeration.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_CAPABILITIES 0x00000771
typedef union
{
        struct
        {
                /**
                 * [Bits 7:0] Highest_Performance.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1
                 * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
                 */
                UINT64 HighestPerformance : 8;
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_BIT  0
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_FLAG 0xFF
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE_MASK 0xFF
#define IA32_HWP_CAPABILITIES_HIGHEST_PERFORMANCE(_)   (((_) >> 0) & 0xFF)

                /**
                 * [Bits 15:8] Guaranteed_Performance.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1
                 * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
                 */
                UINT64 GuaranteedPerformance : 8;
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_BIT  8
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_FLAG 0xFF00
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE_MASK 0xFF
#define IA32_HWP_CAPABILITIES_GUARANTEED_PERFORMANCE(_)   (((_) >> 8) & 0xFF)

                /**
                 * [Bits 23:16] Most_Efficient_Performance.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1
                 * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
                 */
                UINT64 MostEfficientPerformance : 8;
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_BIT  16
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_FLAG 0xFF0000
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE_MASK 0xFF
#define IA32_HWP_CAPABILITIES_MOST_EFFICIENT_PERFORMANCE(_)   (((_) >> 16) & 0xFF)

                /**
                 * [Bits 31:24] Lowest_Performance.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1
                 * @see Vol3B[14.4.3(HWP Performance Range and Dynamic Capabilities)]
                 */
                UINT64 LowestPerformance : 8;
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_BIT  24
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_FLAG 0xFF000000
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE_MASK 0xFF
#define IA32_HWP_CAPABILITIES_LOWEST_PERFORMANCE(_)   (((_) >> 24) & 0xFF)
                UINT64 Reserved1 : 32;
        };

        UINT64 AsUInt;
} IA32_HWP_CAPABILITIES_REGISTER;

/**
 * Power Management Control Hints for All Logical Processors in a Package.
 *
 * @remarks If CPUID.06H:EAX.[11] = 1
 */
#define IA32_HWP_REQUEST_PKG 0x00000772
typedef union
{
        struct
        {
                /**
                 * [Bits 7:0] Minimum_Performance.
                 *
                 * @remarks If CPUID.06H:EAX.[11] = 1
                 * @see Vol3B[14.4.4(Managing HWP)]
                 */
                UINT64 MinimumPerformance : 8;
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_BIT  0
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_FLAG 0xFF
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE_MASK 0xFF
#define IA32_HWP_REQUEST_PKG_MINIMUM_PERFORMANCE(_)   (((_) >> 0) & 0xFF)

                /**
                 * [Bits 15:8] Maximum_Performance.
                 *
                 * @remarks If CPUID.06H:EAX.[11] = 1
                 * @see Vol3B[14.4.4(Managing HWP)]
                 */
                UINT64 MaximumPerformance : 8;
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_BIT  8
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_FLAG 0xFF00
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE_MASK 0xFF
#define IA32_HWP_REQUEST_PKG_MAXIMUM_PERFORMANCE(_)   (((_) >> 8) & 0xFF)

                /**
                 * [Bits 23:16] Desired_Performance.
                 *
                 * @remarks If CPUID.06H:EAX.[11] = 1
                 * @see Vol3B[14.4.4(Managing HWP)]
                 */
                UINT64 DesiredPerformance : 8;
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_BIT  16
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_FLAG 0xFF0000
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE_MASK 0xFF
#define IA32_HWP_REQUEST_PKG_DESIRED_PERFORMANCE(_)   (((_) >> 16) & 0xFF)

                /**
                 * [Bits 31:24] Energy_Performance_Preference.
                 *
                 * @remarks If CPUID.06H:EAX.[11] = 1 && CPUID.06H:EAX.[10] = 1
                 * @see Vol3B[14.4.4(Managing HWP)]
                 */
                UINT64 EnergyPerformancePreference : 8;
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_BIT  24
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_FLAG 0xFF000000
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE_MASK 0xFF
#define IA32_HWP_REQUEST_PKG_ENERGY_PERFORMANCE_PREFERENCE(_)   (((_) >> 24) & 0xFF)

                /**
                 * [Bits 41:32] Activity_Window.
                 *
                 * @remarks If CPUID.06H:EAX.[11] = 1 && CPUID.06H:EAX.[9] = 1
                 * @see Vol3B[14.4.4(Managing HWP)]
                 */
                UINT64 ActivityWindow : 10;
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_BIT  32
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_FLAG 0x3FF00000000
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW_MASK 0x3FF
#define IA32_HWP_REQUEST_PKG_ACTIVITY_WINDOW(_)   (((_) >> 32) & 0x3FF)
                UINT64 Reserved1 : 22;
        };

        UINT64 AsUInt;
} IA32_HWP_REQUEST_PKG_REGISTER;

/**
 * Control HWP Native Interrupts.
 *
 * @remarks If CPUID.06H:EAX.[8] = 1
 */
#define IA32_HWP_INTERRUPT 0x00000773
typedef union
{
        struct
        {
                /**
                 * [Bit 0] EN_Guaranteed_Performance_Change.
                 *
                 * @remarks If CPUID.06H:EAX.[8] = 1
                 * @see Vol3B[14.4.6(HWP Notifications)]
                 */
                UINT64 EnGuaranteedPerformanceChange : 1;
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_BIT  0
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_FLAG 0x01
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE_MASK 0x01
#define IA32_HWP_INTERRUPT_EN_GUARANTEED_PERFORMANCE_CHANGE(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] EN_Excursion_Minimum.
                 *
                 * @remarks If CPUID.06H:EAX.[8] = 1
                 * @see Vol3B[14.4.6(HWP Notifications)]
                 */
                UINT64 EnExcursionMinimum : 1;
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_BIT  1
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_FLAG 0x02
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM_MASK 0x01
#define IA32_HWP_INTERRUPT_EN_EXCURSION_MINIMUM(_)   (((_) >> 1) & 0x01)
                UINT64 Reserved1 : 62;
        };

        UINT64 AsUInt;
} IA32_HWP_INTERRUPT_REGISTER;

/**
 * Power Management Control Hints to a Logical Processor.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_REQUEST 0x00000774
typedef union
{
        struct
        {
                /**
                 * [Bits 7:0] Minimum_Performance.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1
                 * @see Vol3B[14.4.4(Managing HWP)]
                 */
                UINT64 MinimumPerformance : 8;
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_BIT  0
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_FLAG 0xFF
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE_MASK 0xFF
#define IA32_HWP_REQUEST_MINIMUM_PERFORMANCE(_)   (((_) >> 0) & 0xFF)

                /**
                 * [Bits 15:8] Maximum_Performance.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1
                 * @see Vol3B[14.4.4(Managing HWP)]
                 */
                UINT64 MaximumPerformance : 8;
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_BIT  8
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_FLAG 0xFF00
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE_MASK 0xFF
#define IA32_HWP_REQUEST_MAXIMUM_PERFORMANCE(_)   (((_) >> 8) & 0xFF)

                /**
                 * [Bits 23:16] Desired_Performance.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1
                 * @see Vol3B[14.4.4(Managing HWP)]
                 */
                UINT64 DesiredPerformance : 8;
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_BIT  16
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_FLAG 0xFF0000
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE_MASK 0xFF
#define IA32_HWP_REQUEST_DESIRED_PERFORMANCE(_)   (((_) >> 16) & 0xFF)

                /**
                 * [Bits 31:24] Energy_Performance_Preference.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[10] = 1
                 * @see Vol3B[14.4.4(Managing HWP)]
                 */
                UINT64 EnergyPerformancePreference : 8;
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_BIT  24
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_FLAG 0xFF000000
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE_MASK 0xFF
#define IA32_HWP_REQUEST_ENERGY_PERFORMANCE_PREFERENCE(_)   (((_) >> 24) & 0xFF)

                /**
                 * [Bits 41:32] Activity_Window.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[9] = 1
                 * @see Vol3B[14.4.4(Managing HWP)]
                 */
                UINT64 ActivityWindow : 10;
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_BIT  32
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_FLAG 0x3FF00000000
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW_MASK 0x3FF
#define IA32_HWP_REQUEST_ACTIVITY_WINDOW(_)   (((_) >> 32) & 0x3FF)

                /**
                 * [Bit 42] Package_Control.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1 && CPUID.06H:EAX.[11] = 1
                 * @see Vol3B[14.4.4(Managing HWP)]
                 */
                UINT64 PackageControl : 1;
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_BIT  42
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_FLAG 0x40000000000
#define IA32_HWP_REQUEST_PACKAGE_CONTROL_MASK 0x01
#define IA32_HWP_REQUEST_PACKAGE_CONTROL(_)   (((_) >> 42) & 0x01)
                UINT64 Reserved1 : 21;
        };

        UINT64 AsUInt;
} IA32_HWP_REQUEST_REGISTER;

/**
 * Log bits indicating changes to Guaranteed & excursions to Minimum.
 *
 * @remarks If CPUID.06H:EAX.[7] = 1
 */
#define IA32_HWP_STATUS 0x00000777
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Guaranteed_Performance_Change.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1
                 * @see Vol3B[14.4.5(HWP Feedback)]
                 */
                UINT64 GuaranteedPerformanceChange : 1;
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_BIT  0
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_FLAG 0x01
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE_MASK 0x01
#define IA32_HWP_STATUS_GUARANTEED_PERFORMANCE_CHANGE(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 1;

                /**
                 * [Bit 2] Excursion_To_Minimum.
                 *
                 * @remarks If CPUID.06H:EAX.[7] = 1
                 * @see Vol3B[14.4.5(HWP Feedback)]
                 */
                UINT64 ExcursionToMinimum : 1;
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_BIT  2
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_FLAG 0x04
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM_MASK 0x01
#define IA32_HWP_STATUS_EXCURSION_TO_MINIMUM(_)   (((_) >> 2) & 0x01)
                UINT64 Reserved2 : 61;
        };

        UINT64 AsUInt;
} IA32_HWP_STATUS_REGISTER;

/**
 * x2APIC ID Register.
 *
 * @remarks If CPUID.01H:ECX[21] = 1 && IA32_APIC_BASE.[10] = 1
 * @see Vol3A[10.12(EXTENDED XAPIC (X2APIC))]
 */
#define IA32_X2APIC_APICID 0x00000802

/**
 * x2APIC Version Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_VERSION 0x00000803

/**
 * x2APIC Task Priority Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_TPR 0x00000808

/**
 * x2APIC Processor Priority Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_PPR 0x0000080A

/**
 * x2APIC EOI Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_EOI 0x0000080B

/**
 * x2APIC Logical Destination Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LDR 0x0000080D

/**
 * x2APIC Spurious Interrupt Vector Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_SIVR 0x0000080F
/**
 * @defgroup IA32_X2APIC_ISR \
 *           IA32_X2APIC_ISR(n)
 *
 * x2APIC In-Service Register Bits (n * 32 + 31):(n * 32).
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 * @{
 */
#define IA32_X2APIC_ISR0 0x00000810
#define IA32_X2APIC_ISR1 0x00000811
#define IA32_X2APIC_ISR2 0x00000812
#define IA32_X2APIC_ISR3 0x00000813
#define IA32_X2APIC_ISR4 0x00000814
#define IA32_X2APIC_ISR5 0x00000815
#define IA32_X2APIC_ISR6 0x00000816
#define IA32_X2APIC_ISR7 0x00000817
/**
 * @}
 */

/**
 * @defgroup IA32_X2APIC_TMR \
 *           IA32_X2APIC_TMR(n)
 *
 * x2APIC Trigger Mode Register Bits (n * 32 + 31):(n * 32).
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 * @{
 */
#define IA32_X2APIC_TMR0 0x00000818
#define IA32_X2APIC_TMR1 0x00000819
#define IA32_X2APIC_TMR2 0x0000081A
#define IA32_X2APIC_TMR3 0x0000081B
#define IA32_X2APIC_TMR4 0x0000081C
#define IA32_X2APIC_TMR5 0x0000081D
#define IA32_X2APIC_TMR6 0x0000081E
#define IA32_X2APIC_TMR7 0x0000081F
/**
 * @}
 */

/**
 * @defgroup IA32_X2APIC_IRR \
 *           IA32_X2APIC_IRR(n)
 *
 * x2APIC Interrupt Request Register Bits (n * 32 + 31):(n * 32).
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 * @{
 */
#define IA32_X2APIC_IRR0 0x00000820
#define IA32_X2APIC_IRR1 0x00000821
#define IA32_X2APIC_IRR2 0x00000822
#define IA32_X2APIC_IRR3 0x00000823
#define IA32_X2APIC_IRR4 0x00000824
#define IA32_X2APIC_IRR5 0x00000825
#define IA32_X2APIC_IRR6 0x00000826
#define IA32_X2APIC_IRR7 0x00000827
/**
 * @}
 */

/**
 * x2APIC Error Status Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_ESR 0x00000828

/**
 * x2APIC LVT Corrected Machine Check Interrupt Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_CMCI 0x0000082F

/**
 * x2APIC Interrupt Command Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_ICR 0x00000830

/**
 * x2APIC LVT Timer Interrupt Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_TIMER 0x00000832

/**
 * x2APIC LVT Thermal Sensor Interrupt Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_THERMAL 0x00000833

/**
 * x2APIC LVT Performance Monitor Interrupt Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_PMI 0x00000834

/**
 * x2APIC LVT LINT0 Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_LINT0 0x00000835

/**
 * x2APIC LVT LINT1 Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_LINT1 0x00000836

/**
 * x2APIC LVT Error Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_LVT_ERROR 0x00000837

/**
 * x2APIC Initial Count Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_INIT_COUNT 0x00000838

/**
 * x2APIC Current Count Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_CUR_COUNT 0x00000839

/**
 * x2APIC Divide Configuration Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_DIV_CONF 0x0000083E

/**
 * x2APIC Self IPI Register.
 *
 * @remarks If CPUID.01H:ECX.[21] = 1 && IA32_APIC_BASE.[10] = 1
 */
#define IA32_X2APIC_SELF_IPI 0x0000083F

/**
 * Silicon Debug Feature Control.
 *
 * @remarks If CPUID.01H:ECX.[11] = 1
 */
#define IA32_DEBUG_INTERFACE 0x00000C80
typedef union
{
        struct
        {
                /**
                 * @brief Enable <b>(R/W)</b>
                 *
                 * [Bit 0] BIOS set 1 to enable Silicon debug features. Default is 0.
                 *
                 * @remarks If CPUID.01H:ECX.[11] = 1
                 */
                UINT64 Enable : 1;
#define IA32_DEBUG_INTERFACE_ENABLE_BIT  0
#define IA32_DEBUG_INTERFACE_ENABLE_FLAG 0x01
#define IA32_DEBUG_INTERFACE_ENABLE_MASK 0x01
#define IA32_DEBUG_INTERFACE_ENABLE(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 29;

                /**
                 * @brief Lock <b>(R/W)</b>
                 *
                 * [Bit 30] If 1, locks any further change to the MSR. The lock bit is set
                 * automatically on the first SMI assertion even if not explicitly set by BIOS.
                 * Default is 0.
                 *
                 * @remarks If CPUID.01H:ECX.[11] = 1
                 */
                UINT64 Lock : 1;
#define IA32_DEBUG_INTERFACE_LOCK_BIT  30
#define IA32_DEBUG_INTERFACE_LOCK_FLAG 0x40000000
#define IA32_DEBUG_INTERFACE_LOCK_MASK 0x01
#define IA32_DEBUG_INTERFACE_LOCK(_)   (((_) >> 30) & 0x01)

                /**
                 * @brief Debug Occurred <b>(R/O)</b>
                 *
                 * [Bit 31] This "sticky bit" is set by hardware to indicate the status of bit 0.
                 * Default is 0.
                 *
                 * @remarks If CPUID.01H:ECX.[11] = 1
                 */
                UINT64 DebugOccurred : 1;
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_BIT  31
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_FLAG 0x80000000
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED_MASK 0x01
#define IA32_DEBUG_INTERFACE_DEBUG_OCCURRED(_)   (((_) >> 31) & 0x01)
                UINT64 Reserved2 : 32;
        };

        UINT64 AsUInt;
} IA32_DEBUG_INTERFACE_REGISTER;

/**
 * L3 QOS Configuration.
 *
 * @remarks If ( CPUID.(EAX=10H, ECX=1):ECX.[2] = 1 )
 */
#define IA32_L3_QOS_CFG 0x00000C81
typedef union
{
        struct
        {
                /**
                 * @brief Enable <b>(R/W)</b>
                 *
                 * [Bit 0] Set 1 to enable L3 CAT masks and COS to operate in Code and Data
                 * Prioritization (CDP) mode.
                 */
                UINT64 Enable : 1;
#define IA32_L3_QOS_CFG_ENABLE_BIT  0
#define IA32_L3_QOS_CFG_ENABLE_FLAG 0x01
#define IA32_L3_QOS_CFG_ENABLE_MASK 0x01
#define IA32_L3_QOS_CFG_ENABLE(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 63;
        };

        UINT64 AsUInt;
} IA32_L3_QOS_CFG_REGISTER;

/**
 * L2 QOS Configuration.
 *
 * @remarks If ( CPUID.(EAX=10H, ECX=2):ECX.[2] = 1 )
 */
#define IA32_L2_QOS_CFG 0x00000C82
typedef union
{
        struct
        {
                /**
                 * @brief Enable <b>(R/W)</b>
                 *
                 * [Bit 0] Set 1 to enable L2 CAT masks and COS to operate in Code and Data
                 * Prioritization (CDP) mode.
                 */
                UINT64 Enable : 1;
#define IA32_L2_QOS_CFG_ENABLE_BIT  0
#define IA32_L2_QOS_CFG_ENABLE_FLAG 0x01
#define IA32_L2_QOS_CFG_ENABLE_MASK 0x01
#define IA32_L2_QOS_CFG_ENABLE(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 63;
        };

        UINT64 AsUInt;
} IA32_L2_QOS_CFG_REGISTER;

/**
 * Monitoring Event Select Register.
 *
 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[12] = 1 )
 */
#define IA32_QM_EVTSEL 0x00000C8D
typedef union
{
        struct
        {
                /**
                 * @brief Event ID
                 *
                 * [Bits 7:0] ID of a supported monitoring event to report via IA32_QM_CTR.
                 */
                UINT64 EventId : 8;
#define IA32_QM_EVTSEL_EVENT_ID_BIT  0
#define IA32_QM_EVTSEL_EVENT_ID_FLAG 0xFF
#define IA32_QM_EVTSEL_EVENT_ID_MASK 0xFF
#define IA32_QM_EVTSEL_EVENT_ID(_)   (((_) >> 0) & 0xFF)
                UINT64 Reserved1 : 24;

                /**
                 * @brief Resource Monitoring ID
                 *
                 * [Bits 63:32] ID for monitoring hardware to report monitored data via IA32_QM_CTR.
                 *
                 * @remarks Bits [N+31:32] N = Ceil (Log2 (CPUID.(EAX= 0FH,ECX=0H).EBX[31:0] + 1))
                 */
                UINT64 ResourceMonitoringId : 32;
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_BIT  32
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_FLAG 0xFFFFFFFF00000000
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID_MASK 0xFFFFFFFF
#define IA32_QM_EVTSEL_RESOURCE_MONITORING_ID(_)   (((_) >> 32) & 0xFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_QM_EVTSEL_REGISTER;

/**
 * Monitoring Counter Register.
 *
 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[12] = 1 )
 */
#define IA32_QM_CTR 0x00000C8E
typedef union
{
        struct
        {
                /**
                 * [Bits 61:0] Resource Monitored Data.
                 */
                UINT64 ResourceMonitoredData : 62;
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_BIT  0
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_FLAG 0x3FFFFFFFFFFFFFFF
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA_MASK 0x3FFFFFFFFFFFFFFF
#define IA32_QM_CTR_RESOURCE_MONITORED_DATA(_)   (((_) >> 0) & 0x3FFFFFFFFFFFFFFF)

                /**
                 * @brief Unavailable
                 *
                 * [Bit 62] If 1, indicates data for this RMID is not available or not monitored for
                 * this resource or RMID.
                 */
                UINT64 Unavailable : 1;
#define IA32_QM_CTR_UNAVAILABLE_BIT  62
#define IA32_QM_CTR_UNAVAILABLE_FLAG 0x4000000000000000
#define IA32_QM_CTR_UNAVAILABLE_MASK 0x01
#define IA32_QM_CTR_UNAVAILABLE(_)   (((_) >> 62) & 0x01)

                /**
                 * @brief Error
                 *
                 * [Bit 63] If 1, indicates an unsupported RMID or event type was written to
                 * IA32_PQR_QM_EVTSEL.
                 */
                UINT64 Error : 1;
#define IA32_QM_CTR_ERROR_BIT  63
#define IA32_QM_CTR_ERROR_FLAG 0x8000000000000000
#define IA32_QM_CTR_ERROR_MASK 0x01
#define IA32_QM_CTR_ERROR(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} IA32_QM_CTR_REGISTER;

/**
 * Resource Association Register.
 *
 * @remarks If ( (CPUID.(EAX=07H, ECX=0):EBX[12] = 1) or (CPUID.(EAX=07H, ECX=0):EBX[15] = 1 ) )
 */
#define IA32_PQR_ASSOC 0x00000C8F
typedef union
{
        struct
        {
                /**
                 * @brief Resource Monitoring ID <b>(R/W)</b>
                 *
                 * [Bits 31:0] ID for monitoring hardware to track internal operation, e.g., memory
                 * access.
                 *
                 * @remarks Bits [N-1:0] N = Ceil (Log2 (CPUID.(EAX= 0FH, ECX=0H).EBX[31:0] +1))
                 * 31:N Reserved
                 */
                UINT64 ResourceMonitoringId : 32;
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_BIT  0
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_FLAG 0xFFFFFFFF
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID_MASK 0xFFFFFFFF
#define IA32_PQR_ASSOC_RESOURCE_MONITORING_ID(_)   (((_) >> 0) & 0xFFFFFFFF)

                /**
                 * @brief COS <b>(R/W)</b>
                 *
                 * [Bits 63:32] The class of service (COS) to enforce (on writes); returns the
                 * current COS when read.
                 *
                 * @remarks If ( CPUID.(EAX=07H, ECX=0):EBX.[15] = 1 )
                 */
                UINT64 Cos : 32;
#define IA32_PQR_ASSOC_COS_BIT  32
#define IA32_PQR_ASSOC_COS_FLAG 0xFFFFFFFF00000000
#define IA32_PQR_ASSOC_COS_MASK 0xFFFFFFFF
#define IA32_PQR_ASSOC_COS(_)   (((_) >> 32) & 0xFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_PQR_ASSOC_REGISTER;

/**
 * Supervisor State of MPX Configuration.
 *
 * @remarks If (CPUID.(EAX=07H, ECX=0H):EBX[14] = 1)
 */
#define IA32_BNDCFGS 0x00000D90
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Enable Intel MPX in supervisor mode.
                 */
                UINT64 Enable : 1;
#define IA32_BNDCFGS_ENABLE_BIT  0
#define IA32_BNDCFGS_ENABLE_FLAG 0x01
#define IA32_BNDCFGS_ENABLE_MASK 0x01
#define IA32_BNDCFGS_ENABLE(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Preserve the bounds registers for near branch instructions in the absence
                 * of the BND prefix.
                 */
                UINT64 BndPreserve : 1;
#define IA32_BNDCFGS_BND_PRESERVE_BIT  1
#define IA32_BNDCFGS_BND_PRESERVE_FLAG 0x02
#define IA32_BNDCFGS_BND_PRESERVE_MASK 0x01
#define IA32_BNDCFGS_BND_PRESERVE(_)   (((_) >> 1) & 0x01)
                UINT64 Reserved1 : 10;

                /**
                 * [Bits 63:12] Base Address of Bound Directory.
                 */
                UINT64 BoundDirectoryBaseAddress : 52;
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_BIT  12
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_FLAG 0xFFFFFFFFFFFFF000
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS_MASK 0xFFFFFFFFFFFFF
#define IA32_BNDCFGS_BOUND_DIRECTORY_BASE_ADDRESS(_)   (((_) >> 12) & 0xFFFFFFFFFFFFF)
        };

        UINT64 AsUInt;
} IA32_BNDCFGS_REGISTER;

/**
 * Extended Supervisor State Mask.
 *
 * @remarks If ( CPUID.(0DH, 1):EAX.[3] = 1
 */
#define IA32_XSS 0x00000DA0
typedef union
{
        struct
        {
                UINT64 Reserved1 : 8;

                /**
                 * [Bit 8] Trace Packet Configuration State.
                 */
                UINT64 TracePacketConfigurationState : 1;
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_BIT  8
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_FLAG 0x100
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE_MASK 0x01
#define IA32_XSS_TRACE_PACKET_CONFIGURATION_STATE(_)   (((_) >> 8) & 0x01)
                UINT64 Reserved2 : 55;
        };

        UINT64 AsUInt;
} IA32_XSS_REGISTER;

/**
 * Package Level Enable/disable HDC.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_PKG_HDC_CTL 0x00000DB0
typedef union
{
        struct
        {
                /**
                 * @brief HDC_Pkg_Enable <b>(R/W)</b>
                 *
                 * [Bit 0] Force HDC idling or wake up HDC-idled logical processors in the package.
                 *
                 * @remarks If CPUID.06H:EAX.[13] = 1
                 * @see Vol3B[14.5.2(Package level Enabling HDC)]
                 */
                UINT64 HdcPkgEnable : 1;
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_BIT  0
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_FLAG 0x01
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE_MASK 0x01
#define IA32_PKG_HDC_CTL_HDC_PKG_ENABLE(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 63;
        };

        UINT64 AsUInt;
} IA32_PKG_HDC_CTL_REGISTER;

/**
 * Enable/disable HWP.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_PM_CTL1 0x00000DB1
typedef union
{
        struct
        {
                /**
                 * @brief HDC_Allow_Block <b>(R/W)</b>
                 *
                 * [Bit 0] Allow/Block this logical processor for package level HDC control.
                 *
                 * @remarks If CPUID.06H:EAX.[13] = 1
                 * @see Vol3B[14.5.3(Logical-Processor Level HDC Control)]
                 */
                UINT64 HdcAllowBlock : 1;
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_BIT  0
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_FLAG 0x01
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK_MASK 0x01
#define IA32_PM_CTL1_HDC_ALLOW_BLOCK(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 63;
        };

        UINT64 AsUInt;
} IA32_PM_CTL1_REGISTER;

/**
 * Per-Logical_Processor HDC Idle Residency.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_THREAD_STALL 0x00000DB2
typedef struct
{
        /**
         * @brief Stall_Cycle_Cnt <b>(R/W)</b>
         *
         * Stalled cycles due to HDC forced idle on this logical processor.
         *
         * @remarks If CPUID.06H:EAX.[13] = 1
         * @see Vol3B[14.5.4.1(IA32_THREAD_STALL)]
         */
        UINT64 StallCycleCount;
} IA32_THREAD_STALL_REGISTER;

/**
 * Extended Feature Enables.
 *
 * @remarks If CPUID.06H:EAX.[13] = 1
 */
#define IA32_EFER 0xC0000080
typedef union
{
        struct
        {
                /**
                 * @brief SYSCALL Enable <b>(R/W)</b>
                 *
                 * [Bit 0] Enables SYSCALL/SYSRET instructions in 64-bit mode.
                 */
                UINT64 SyscallEnable : 1;
#define IA32_EFER_SYSCALL_ENABLE_BIT  0
#define IA32_EFER_SYSCALL_ENABLE_FLAG 0x01
#define IA32_EFER_SYSCALL_ENABLE_MASK 0x01
#define IA32_EFER_SYSCALL_ENABLE(_)   (((_) >> 0) & 0x01)
                UINT64 Reserved1 : 7;

                /**
                 * @brief IA-32e Mode Enable <b>(R/W)</b>
                 *
                 * [Bit 8] Enables IA-32e mode operation.
                 */
                UINT64 Ia32EModeEnable : 1;
#define IA32_EFER_IA32E_MODE_ENABLE_BIT  8
#define IA32_EFER_IA32E_MODE_ENABLE_FLAG 0x100
#define IA32_EFER_IA32E_MODE_ENABLE_MASK 0x01
#define IA32_EFER_IA32E_MODE_ENABLE(_)   (((_) >> 8) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * @brief IA-32e Mode Active <b>(R)</b>
                 *
                 * [Bit 10] Indicates IA-32e mode is active when set.
                 */
                UINT64 Ia32EModeActive : 1;
#define IA32_EFER_IA32E_MODE_ACTIVE_BIT  10
#define IA32_EFER_IA32E_MODE_ACTIVE_FLAG 0x400
#define IA32_EFER_IA32E_MODE_ACTIVE_MASK 0x01
#define IA32_EFER_IA32E_MODE_ACTIVE(_)   (((_) >> 10) & 0x01)

                /**
                 * [Bit 11] Execute Disable Bit Enable.
                 */
                UINT64 ExecuteDisableBitEnable : 1;
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_BIT  11
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_FLAG 0x800
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE_MASK 0x01
#define IA32_EFER_EXECUTE_DISABLE_BIT_ENABLE(_)   (((_) >> 11) & 0x01)
                UINT64 Reserved3 : 52;
        };

        UINT64 AsUInt;
} IA32_EFER_REGISTER;

/**
 * System Call Target Address.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_STAR 0xC0000081

/**
 * @brief IA-32e Mode System Call Target Address <b>(R/W)</b>
 *
 * Target RIP for the called procedure when SYSCALL is executed in 64-bit mode.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_LSTAR 0xC0000082

/**
 * @brief IA-32e Mode System Call Target Address <b>(R/W)</b>
 *
 * Not used, as the SYSCALL instruction is not recognized in compatibility mode.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_CSTAR 0xC0000083

/**
 * System Call Flag Mask.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_FMASK 0xC0000084

/**
 * Map of BASE Address of FS.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_FS_BASE 0xC0000100

/**
 * Map of BASE Address of GS.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_GS_BASE 0xC0000101

/**
 * Swap Target of BASE Address of GS.
 *
 * @remarks If CPUID.80000001:EDX.[29] = 1
 */
#define IA32_KERNEL_GS_BASE 0xC0000102

/**
 * Auxiliary TSC.
 *
 * @remarks If CPUID.80000001H: EDX[27] = 1 or CPUID.(EAX=7,ECX=0):ECX[bit 22] = 1
 */
#define IA32_TSC_AUX 0xC0000103
typedef union
{
        struct
        {
                /**
                 * [Bits 31:0] AUX. Auxiliary signature of TSC.
                 */
                UINT64 TscAuxiliarySignature : 32;
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_BIT  0
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_FLAG 0xFFFFFFFF
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE_MASK 0xFFFFFFFF
#define IA32_TSC_AUX_TSC_AUXILIARY_SIGNATURE(_)   (((_) >> 0) & 0xFFFFFFFF)
                UINT64 Reserved1 : 32;
        };

        UINT64 AsUInt;
} IA32_TSC_AUX_REGISTER;

/**
 * @}
 */

/**
 * @defgroup PAGING \
 *           Paging
 * @{
 */
/**
 * @defgroup PAGING_32 \
 *           32-Bit Paging
 *
 * A logical processor uses 32-bit paging if CR0.PG = 1 and CR4.PAE = 0. 32-bit paging translates
 * 32-bit linear addresses to 40-bit physical addresses. Although 40 bits corresponds to 1 TByte,
 * linear addresses are limited to 32 bits; at most 4 GBytes of linear-address space may be accessed
 * at any given time. 32-bit paging uses a hierarchy of paging structures to produce a translation
 * for a linear address. CR3 is used to locate the first paging-structure, the page directory.
 * 32-bit paging may map linear addresses to either 4-KByte pages or 4-MByte pages.
 *
 * @see Vol3A[4.5(4-LEVEL PAGING)] (reference)
 * @{
 */
/**
 * @brief Format of a 32-Bit Page-Directory Entry that Maps a 4-MByte Page
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Present; must be 1 to map a 4-MByte page.
                 */
                UINT32 Present : 1;
#define PDE_4MB_32_PRESENT_BIT  0
#define PDE_4MB_32_PRESENT_FLAG 0x01
#define PDE_4MB_32_PRESENT_MASK 0x01
#define PDE_4MB_32_PRESENT(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT32 Write : 1;
#define PDE_4MB_32_WRITE_BIT  1
#define PDE_4MB_32_WRITE_FLAG 0x02
#define PDE_4MB_32_WRITE_MASK 0x01
#define PDE_4MB_32_WRITE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte
                 * page referenced by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT32 Supervisor : 1;
#define PDE_4MB_32_SUPERVISOR_BIT  2
#define PDE_4MB_32_SUPERVISOR_FLAG 0x04
#define PDE_4MB_32_SUPERVISOR_MASK 0x01
#define PDE_4MB_32_SUPERVISOR(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Page-level write-through; indirectly determines the memory type used to
                 * access the 4-MByte page referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT32 PageLevelWriteThrough : 1;
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PDE_4MB_32_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Page-level cache disable; indirectly determines the memory type used to
                 * access the 4-MByte page referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT32 PageLevelCacheDisable : 1;
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PDE_4MB_32_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] Accessed; indicates whether software has accessed the 4-MByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT32 Accessed : 1;
#define PDE_4MB_32_ACCESSED_BIT  5
#define PDE_4MB_32_ACCESSED_FLAG 0x20
#define PDE_4MB_32_ACCESSED_MASK 0x01
#define PDE_4MB_32_ACCESSED(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] Dirty; indicates whether software has written to the 4-MByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT32 Dirty : 1;
#define PDE_4MB_32_DIRTY_BIT  6
#define PDE_4MB_32_DIRTY_FLAG 0x40
#define PDE_4MB_32_DIRTY_MASK 0x01
#define PDE_4MB_32_DIRTY(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] Page size; must be 1 (otherwise, this entry references a page table).
                 */
                UINT32 LargePage : 1;
#define PDE_4MB_32_LARGE_PAGE_BIT  7
#define PDE_4MB_32_LARGE_PAGE_FLAG 0x80
#define PDE_4MB_32_LARGE_PAGE_MASK 0x01
#define PDE_4MB_32_LARGE_PAGE(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global;
                 * ignored otherwise.
                 *
                 * @see Vol3A[4.10(Caching Translation Information)]
                 */
                UINT32 Global : 1;
#define PDE_4MB_32_GLOBAL_BIT  8
#define PDE_4MB_32_GLOBAL_FLAG 0x100
#define PDE_4MB_32_GLOBAL_MASK 0x01
#define PDE_4MB_32_GLOBAL(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bits 11:9] Ignored.
                 */
                UINT32 Ignored1 : 3;
#define PDE_4MB_32_IGNORED_1_BIT  9
#define PDE_4MB_32_IGNORED_1_FLAG 0xE00
#define PDE_4MB_32_IGNORED_1_MASK 0x07
#define PDE_4MB_32_IGNORED_1(_)   (((_) >> 9) & 0x07)

                /**
                 * [Bit 12] Indirectly determines the memory type used to access the 4-MByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT32 Pat : 1;
#define PDE_4MB_32_PAT_BIT  12
#define PDE_4MB_32_PAT_FLAG 0x1000
#define PDE_4MB_32_PAT_MASK 0x01
#define PDE_4MB_32_PAT(_)   (((_) >> 12) & 0x01)

                /**
                 * [Bits 20:13] Bits (M-1):32 of physical address of the 4-MByte page referenced by
                 * this entry.
                 */
                UINT32 PageFrameNumberLow : 8;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_BIT  13
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_FLAG 0x1FE000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW_MASK 0xFF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_LOW(_)   (((_) >> 13) & 0xFF)
                UINT32 Reserved1 : 1;

                /**
                 * [Bits 31:22] Bits 31:22 of physical address of the 4-MByte page referenced by
                 * this entry.
                 */
                UINT32 PageFrameNumberHigh : 10;
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_BIT  22
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_FLAG 0xFFC00000
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH_MASK 0x3FF
#define PDE_4MB_32_PAGE_FRAME_NUMBER_HIGH(_)   (((_) >> 22) & 0x3FF)
        };

        UINT32 AsUInt;
} PDE_4MB_32;

/**
 * @brief Format of a 32-Bit Page-Directory Entry that References a Page Table
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Present; must be 1 to reference a page table.
                 */
                UINT32 Present : 1;
#define PDE_32_PRESENT_BIT  0
#define PDE_32_PRESENT_FLAG 0x01
#define PDE_32_PRESENT_MASK 0x01
#define PDE_32_PRESENT(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-MByte region
                 * controlled by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT32 Write : 1;
#define PDE_32_WRITE_BIT  1
#define PDE_32_WRITE_FLAG 0x02
#define PDE_32_WRITE_MASK 0x01
#define PDE_32_WRITE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-MByte
                 * region controlled by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT32 Supervisor : 1;
#define PDE_32_SUPERVISOR_BIT  2
#define PDE_32_SUPERVISOR_FLAG 0x04
#define PDE_32_SUPERVISOR_MASK 0x01
#define PDE_32_SUPERVISOR(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Page-level write-through; indirectly determines the memory type used to
                 * access the page table referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT32 PageLevelWriteThrough : 1;
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PDE_32_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Page-level cache disable; indirectly determines the memory type used to
                 * access the page table referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT32 PageLevelCacheDisable : 1;
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PDE_32_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] Accessed; indicates whether this entry has been used for linear-address
                 * translation.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT32 Accessed : 1;
#define PDE_32_ACCESSED_BIT  5
#define PDE_32_ACCESSED_FLAG 0x20
#define PDE_32_ACCESSED_MASK 0x01
#define PDE_32_ACCESSED(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] Ignored.
                 */
                UINT32 Ignored1 : 1;
#define PDE_32_IGNORED_1_BIT  6
#define PDE_32_IGNORED_1_FLAG 0x40
#define PDE_32_IGNORED_1_MASK 0x01
#define PDE_32_IGNORED_1(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] If CR4.PSE = 1, must be 0 (otherwise, this entry maps a 4-MByte page);
                 * otherwise, ignored.
                 */
                UINT32 LargePage : 1;
#define PDE_32_LARGE_PAGE_BIT  7
#define PDE_32_LARGE_PAGE_FLAG 0x80
#define PDE_32_LARGE_PAGE_MASK 0x01
#define PDE_32_LARGE_PAGE(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bits 11:8] Ignored.
                 */
                UINT32 Ignored2 : 4;
#define PDE_32_IGNORED_2_BIT  8
#define PDE_32_IGNORED_2_FLAG 0xF00
#define PDE_32_IGNORED_2_MASK 0x0F
#define PDE_32_IGNORED_2(_)   (((_) >> 8) & 0x0F)

                /**
                 * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this
                 * entry.
                 */
                UINT32 PageFrameNumber : 20;
#define PDE_32_PAGE_FRAME_NUMBER_BIT  12
#define PDE_32_PAGE_FRAME_NUMBER_FLAG 0xFFFFF000
#define PDE_32_PAGE_FRAME_NUMBER_MASK 0xFFFFF
#define PDE_32_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFF)
        };

        UINT32 AsUInt;
} PDE_32;

/**
 * @brief Format of a 32-Bit Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Present; must be 1 to map a 4-KByte page.
                 */
                UINT32 Present : 1;
#define PTE_32_PRESENT_BIT  0
#define PTE_32_PRESENT_FLAG 0x01
#define PTE_32_PRESENT_MASK 0x01
#define PTE_32_PRESENT(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT32 Write : 1;
#define PTE_32_WRITE_BIT  1
#define PTE_32_WRITE_FLAG 0x02
#define PTE_32_WRITE_MASK 0x01
#define PTE_32_WRITE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte
                 * page referenced by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT32 Supervisor : 1;
#define PTE_32_SUPERVISOR_BIT  2
#define PTE_32_SUPERVISOR_FLAG 0x04
#define PTE_32_SUPERVISOR_MASK 0x01
#define PTE_32_SUPERVISOR(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Page-level write-through; indirectly determines the memory type used to
                 * access the 4-KByte page referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT32 PageLevelWriteThrough : 1;
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PTE_32_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Page-level cache disable; indirectly determines the memory type used to
                 * access the 4-KByte page referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT32 PageLevelCacheDisable : 1;
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PTE_32_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT32 Accessed : 1;
#define PTE_32_ACCESSED_BIT  5
#define PTE_32_ACCESSED_FLAG 0x20
#define PTE_32_ACCESSED_MASK 0x01
#define PTE_32_ACCESSED(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT32 Dirty : 1;
#define PTE_32_DIRTY_BIT  6
#define PTE_32_DIRTY_FLAG 0x40
#define PTE_32_DIRTY_MASK 0x01
#define PTE_32_DIRTY(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT32 Pat : 1;
#define PTE_32_PAT_BIT  7
#define PTE_32_PAT_FLAG 0x80
#define PTE_32_PAT_MASK 0x01
#define PTE_32_PAT(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global;
                 * ignored otherwise.
                 *
                 * @see Vol3A[4.10(Caching Translation Information)]
                 */
                UINT32 Global : 1;
#define PTE_32_GLOBAL_BIT  8
#define PTE_32_GLOBAL_FLAG 0x100
#define PTE_32_GLOBAL_MASK 0x01
#define PTE_32_GLOBAL(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bits 11:9] Ignored.
                 */
                UINT32 Ignored1 : 3;
#define PTE_32_IGNORED_1_BIT  9
#define PTE_32_IGNORED_1_FLAG 0xE00
#define PTE_32_IGNORED_1_MASK 0x07
#define PTE_32_IGNORED_1(_)   (((_) >> 9) & 0x07)

                /**
                 * [Bits 31:12] Physical address of 4-KByte aligned page table referenced by this
                 * entry.
                 */
                UINT32 PageFrameNumber : 20;
#define PTE_32_PAGE_FRAME_NUMBER_BIT  12
#define PTE_32_PAGE_FRAME_NUMBER_FLAG 0xFFFFF000
#define PTE_32_PAGE_FRAME_NUMBER_MASK 0xFFFFF
#define PTE_32_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFF)
        };

        UINT32 AsUInt;
} PTE_32;

/**
 * @brief Format of a common Page-Table Entry
 */
typedef union
{
        struct
        {
                UINT32 Present : 1;
#define PT_ENTRY_32_PRESENT_BIT  0
#define PT_ENTRY_32_PRESENT_FLAG 0x01
#define PT_ENTRY_32_PRESENT_MASK 0x01
#define PT_ENTRY_32_PRESENT(_)   (((_) >> 0) & 0x01)
                UINT32 Write : 1;
#define PT_ENTRY_32_WRITE_BIT  1
#define PT_ENTRY_32_WRITE_FLAG 0x02
#define PT_ENTRY_32_WRITE_MASK 0x01
#define PT_ENTRY_32_WRITE(_)   (((_) >> 1) & 0x01)
                UINT32 Supervisor : 1;
#define PT_ENTRY_32_SUPERVISOR_BIT  2
#define PT_ENTRY_32_SUPERVISOR_FLAG 0x04
#define PT_ENTRY_32_SUPERVISOR_MASK 0x01
#define PT_ENTRY_32_SUPERVISOR(_)   (((_) >> 2) & 0x01)
                UINT32 PageLevelWriteThrough : 1;
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PT_ENTRY_32_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)
                UINT32 PageLevelCacheDisable : 1;
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PT_ENTRY_32_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)
                UINT32 Accessed : 1;
#define PT_ENTRY_32_ACCESSED_BIT  5
#define PT_ENTRY_32_ACCESSED_FLAG 0x20
#define PT_ENTRY_32_ACCESSED_MASK 0x01
#define PT_ENTRY_32_ACCESSED(_)   (((_) >> 5) & 0x01)
                UINT32 Dirty : 1;
#define PT_ENTRY_32_DIRTY_BIT  6
#define PT_ENTRY_32_DIRTY_FLAG 0x40
#define PT_ENTRY_32_DIRTY_MASK 0x01
#define PT_ENTRY_32_DIRTY(_)   (((_) >> 6) & 0x01)
                UINT32 LargePage : 1;
#define PT_ENTRY_32_LARGE_PAGE_BIT  7
#define PT_ENTRY_32_LARGE_PAGE_FLAG 0x80
#define PT_ENTRY_32_LARGE_PAGE_MASK 0x01
#define PT_ENTRY_32_LARGE_PAGE(_)   (((_) >> 7) & 0x01)
                UINT32 Global : 1;
#define PT_ENTRY_32_GLOBAL_BIT  8
#define PT_ENTRY_32_GLOBAL_FLAG 0x100
#define PT_ENTRY_32_GLOBAL_MASK 0x01
#define PT_ENTRY_32_GLOBAL(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bits 11:9] Ignored.
                 */
                UINT32 Ignored1 : 3;
#define PT_ENTRY_32_IGNORED_1_BIT  9
#define PT_ENTRY_32_IGNORED_1_FLAG 0xE00
#define PT_ENTRY_32_IGNORED_1_MASK 0x07
#define PT_ENTRY_32_IGNORED_1(_)   (((_) >> 9) & 0x07)

                /**
                 * [Bits 31:12] Physical address of the 4-KByte page referenced by this entry.
                 */
                UINT32 PageFrameNumber : 20;
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_BIT  12
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_FLAG 0xFFFFF000
#define PT_ENTRY_32_PAGE_FRAME_NUMBER_MASK 0xFFFFF
#define PT_ENTRY_32_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFF)
        };

        UINT32 AsUInt;
} PT_ENTRY_32;

/**
 * @defgroup PAGING_STRUCTURES_ENTRY_COUNT_32 \
 *           Paging structures entry counts
 *
 * Paging structures entry counts.
 * @{
 */
#define PDE_ENTRY_COUNT_32 0x00000400
#define PTE_ENTRY_COUNT_32 0x00000400
/**
 * @}
 */

/**
 * @}
 */

/**
 * @defgroup PAGING_64 \
 *           64-Bit (4-Level) Paging
 *
 * A logical processor uses 4-level paging if CR0.PG = 1, CR4.PAE = 1, and IA32_EFER.LME = 1. With
 * 4-level paging, linear address are translated using a hierarchy of in-memory paging structures
 * located using the contents of CR3. 4-level paging translates 48-bit linear addresses to 52-bit
 * physical addresses. Although 52 bits corresponds to 4 PBytes, linear addresses are limited to 48
 * bits; at most 256 TBytes of linear-address space may be accessed at any given time. 4-level
 * paging uses a hierarchy of paging structures to produce a translation for a linear address. CR3
 * is used to locate the first paging-structure, the PML4 table. Use of CR3 with 4-level paging
 * depends on whether processcontext identifiers (PCIDs) have been enabled by setting CR4.PCIDE.
 *
 * @see Vol3A[4.5(4-LEVEL PAGING)] (reference)
 * @{
 */
/**
 * @brief Format of a 4-Level PML4 Entry (PML4E) that References a Page-Directory-Pointer Table
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Present; must be 1 to reference a page-directory-pointer table.
                 */
                UINT64 Present : 1;
#define PML4E_64_PRESENT_BIT  0
#define PML4E_64_PRESENT_FLAG 0x01
#define PML4E_64_PRESENT_MASK 0x01
#define PML4E_64_PRESENT(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Read/write; if 0, writes may not be allowed to the 512-GByte region
                 * controlled by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 Write : 1;
#define PML4E_64_WRITE_BIT  1
#define PML4E_64_WRITE_FLAG 0x02
#define PML4E_64_WRITE_MASK 0x01
#define PML4E_64_WRITE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the
                 * 512-GByte region controlled by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 Supervisor : 1;
#define PML4E_64_SUPERVISOR_BIT  2
#define PML4E_64_SUPERVISOR_FLAG 0x04
#define PML4E_64_SUPERVISOR_MASK 0x01
#define PML4E_64_SUPERVISOR(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Page-level write-through; indirectly determines the memory type used to
                 * access the page-directory-pointer table referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 PageLevelWriteThrough : 1;
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PML4E_64_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Page-level cache disable; indirectly determines the memory type used to
                 * access the page-directory-pointer table referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 PageLevelCacheDisable : 1;
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PML4E_64_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] Accessed; indicates whether this entry has been used for linear-address
                 * translation.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT64 Accessed : 1;
#define PML4E_64_ACCESSED_BIT  5
#define PML4E_64_ACCESSED_FLAG 0x20
#define PML4E_64_ACCESSED_MASK 0x01
#define PML4E_64_ACCESSED(_)   (((_) >> 5) & 0x01)
                UINT64 Reserved1 : 1;

                /**
                 * [Bit 7] Reserved (must be 0).
                 */
                UINT64 MustBeZero : 1;
#define PML4E_64_MUST_BE_ZERO_BIT  7
#define PML4E_64_MUST_BE_ZERO_FLAG 0x80
#define PML4E_64_MUST_BE_ZERO_MASK 0x01
#define PML4E_64_MUST_BE_ZERO(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bits 10:8] Ignored.
                 */
                UINT64 Ignored1 : 3;
#define PML4E_64_IGNORED_1_BIT  8
#define PML4E_64_IGNORED_1_FLAG 0x700
#define PML4E_64_IGNORED_1_MASK 0x07
#define PML4E_64_IGNORED_1(_)   (((_) >> 8) & 0x07)

                /**
                 * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1,
                 * linear-address translation is restarted with ordinary paging)
                 *
                 * @see Vol3A[4.5.5(Restart of HLAT Paging)]
                 */
                UINT64 Restart : 1;
#define PML4E_64_RESTART_BIT  11
#define PML4E_64_RESTART_FLAG 0x800
#define PML4E_64_RESTART_MASK 0x01
#define PML4E_64_RESTART(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bits 47:12] Physical address of 4-KByte aligned page-directory-pointer table
                 * referenced by this entry.
                 */
                UINT64 PageFrameNumber : 36;
#define PML4E_64_PAGE_FRAME_NUMBER_BIT  12
#define PML4E_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define PML4E_64_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define PML4E_64_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved2 : 4;

                /**
                 * [Bits 62:52] Ignored.
                 */
                UINT64 Ignored2 : 11;
#define PML4E_64_IGNORED_2_BIT  52
#define PML4E_64_IGNORED_2_FLAG 0x7FF0000000000000
#define PML4E_64_IGNORED_2_MASK 0x7FF
#define PML4E_64_IGNORED_2(_)   (((_) >> 52) & 0x7FF)

                /**
                 * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not
                 * allowed from the 512-GByte region controlled by this entry); otherwise, reserved
                 * (must be 0).
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 ExecuteDisable : 1;
#define PML4E_64_EXECUTE_DISABLE_BIT  63
#define PML4E_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PML4E_64_EXECUTE_DISABLE_MASK 0x01
#define PML4E_64_EXECUTE_DISABLE(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} PML4E_64;

/**
 * @brief Format of a 4-Level Page-Directory-Pointer-Table Entry (PDPTE) that Maps a 1-GByte Page
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Present; must be 1 to map a 1-GByte page.
                 */
                UINT64 Present : 1;
#define PDPTE_1GB_64_PRESENT_BIT  0
#define PDPTE_1GB_64_PRESENT_FLAG 0x01
#define PDPTE_1GB_64_PRESENT_MASK 0x01
#define PDPTE_1GB_64_PRESENT(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 Write : 1;
#define PDPTE_1GB_64_WRITE_BIT  1
#define PDPTE_1GB_64_WRITE_FLAG 0x02
#define PDPTE_1GB_64_WRITE_MASK 0x01
#define PDPTE_1GB_64_WRITE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte
                 * page referenced by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 Supervisor : 1;
#define PDPTE_1GB_64_SUPERVISOR_BIT  2
#define PDPTE_1GB_64_SUPERVISOR_FLAG 0x04
#define PDPTE_1GB_64_SUPERVISOR_MASK 0x01
#define PDPTE_1GB_64_SUPERVISOR(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Page-level write-through; indirectly determines the memory type used to
                 * access the 1-GByte page referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 PageLevelWriteThrough : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PDPTE_1GB_64_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Page-level cache disable; indirectly determines the memory type used to
                 * access the 1-GByte page referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 PageLevelCacheDisable : 1;
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PDPTE_1GB_64_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] Accessed; indicates whether software has accessed the 1-GByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT64 Accessed : 1;
#define PDPTE_1GB_64_ACCESSED_BIT  5
#define PDPTE_1GB_64_ACCESSED_FLAG 0x20
#define PDPTE_1GB_64_ACCESSED_MASK 0x01
#define PDPTE_1GB_64_ACCESSED(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] Dirty; indicates whether software has written to the 1-GByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT64 Dirty : 1;
#define PDPTE_1GB_64_DIRTY_BIT  6
#define PDPTE_1GB_64_DIRTY_FLAG 0x40
#define PDPTE_1GB_64_DIRTY_MASK 0x01
#define PDPTE_1GB_64_DIRTY(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
                 */
                UINT64 LargePage : 1;
#define PDPTE_1GB_64_LARGE_PAGE_BIT  7
#define PDPTE_1GB_64_LARGE_PAGE_FLAG 0x80
#define PDPTE_1GB_64_LARGE_PAGE_MASK 0x01
#define PDPTE_1GB_64_LARGE_PAGE(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global;
                 * ignored otherwise.
                 *
                 * @see Vol3A[4.10(Caching Translation Information)]
                 */
                UINT64 Global : 1;
#define PDPTE_1GB_64_GLOBAL_BIT  8
#define PDPTE_1GB_64_GLOBAL_FLAG 0x100
#define PDPTE_1GB_64_GLOBAL_MASK 0x01
#define PDPTE_1GB_64_GLOBAL(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bits 10:9] Ignored.
                 */
                UINT64 Ignored1 : 2;
#define PDPTE_1GB_64_IGNORED_1_BIT  9
#define PDPTE_1GB_64_IGNORED_1_FLAG 0x600
#define PDPTE_1GB_64_IGNORED_1_MASK 0x03
#define PDPTE_1GB_64_IGNORED_1(_)   (((_) >> 9) & 0x03)

                /**
                 * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1,
                 * linear-address translation is restarted with ordinary paging)
                 *
                 * @see Vol3A[4.5.5(Restart of HLAT Paging)]
                 */
                UINT64 Restart : 1;
#define PDPTE_1GB_64_RESTART_BIT  11
#define PDPTE_1GB_64_RESTART_FLAG 0x800
#define PDPTE_1GB_64_RESTART_MASK 0x01
#define PDPTE_1GB_64_RESTART(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bit 12] Indirectly determines the memory type used to access the 1-GByte page
                 * referenced by this entry.
                 *
                 * @note The PAT is supported on all processors that support 4-level paging.
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 Pat : 1;
#define PDPTE_1GB_64_PAT_BIT  12
#define PDPTE_1GB_64_PAT_FLAG 0x1000
#define PDPTE_1GB_64_PAT_MASK 0x01
#define PDPTE_1GB_64_PAT(_)   (((_) >> 12) & 0x01)
                UINT64 Reserved1 : 17;

                /**
                 * [Bits 47:30] Physical address of the 1-GByte page referenced by this entry.
                 */
                UINT64 PageFrameNumber : 18;
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_BIT  30
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFC0000000
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER_MASK 0x3FFFF
#define PDPTE_1GB_64_PAGE_FRAME_NUMBER(_)   (((_) >> 30) & 0x3FFFF)
                UINT64 Reserved2 : 4;

                /**
                 * [Bits 58:52] Ignored.
                 */
                UINT64 Ignored2 : 7;
#define PDPTE_1GB_64_IGNORED_2_BIT  52
#define PDPTE_1GB_64_IGNORED_2_FLAG 0x7F0000000000000
#define PDPTE_1GB_64_IGNORED_2_MASK 0x7F
#define PDPTE_1GB_64_IGNORED_2(_)   (((_) >> 52) & 0x7F)

                /**
                 * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the
                 * page; ignored otherwise.
                 *
                 * @see Vol3A[4.6.2(Protection Keys)]
                 */
                UINT64 ProtectionKey : 4;
#define PDPTE_1GB_64_PROTECTION_KEY_BIT  59
#define PDPTE_1GB_64_PROTECTION_KEY_FLAG 0x7800000000000000
#define PDPTE_1GB_64_PROTECTION_KEY_MASK 0x0F
#define PDPTE_1GB_64_PROTECTION_KEY(_)   (((_) >> 59) & 0x0F)

                /**
                 * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not
                 * allowed from the 1-GByte page controlled by this entry); otherwise, reserved
                 * (must be 0).
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 ExecuteDisable : 1;
#define PDPTE_1GB_64_EXECUTE_DISABLE_BIT  63
#define PDPTE_1GB_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PDPTE_1GB_64_EXECUTE_DISABLE_MASK 0x01
#define PDPTE_1GB_64_EXECUTE_DISABLE(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} PDPTE_1GB_64;

/**
 * @brief Format of a 4-Level Page-Directory-Pointer-Table Entry (PDPTE) that References a Page
 * Directory
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Present; must be 1 to reference a page directory.
                 */
                UINT64 Present : 1;
#define PDPTE_64_PRESENT_BIT  0
#define PDPTE_64_PRESENT_FLAG 0x01
#define PDPTE_64_PRESENT_MASK 0x01
#define PDPTE_64_PRESENT(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Read/write; if 0, writes may not be allowed to the 1-GByte region
                 * controlled by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 Write : 1;
#define PDPTE_64_WRITE_BIT  1
#define PDPTE_64_WRITE_FLAG 0x02
#define PDPTE_64_WRITE_MASK 0x01
#define PDPTE_64_WRITE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 1-GByte
                 * region controlled by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 Supervisor : 1;
#define PDPTE_64_SUPERVISOR_BIT  2
#define PDPTE_64_SUPERVISOR_FLAG 0x04
#define PDPTE_64_SUPERVISOR_MASK 0x01
#define PDPTE_64_SUPERVISOR(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Page-level write-through; indirectly determines the memory type used to
                 * access the page directory referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 PageLevelWriteThrough : 1;
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PDPTE_64_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Page-level cache disable; indirectly determines the memory type used to
                 * access the page directory referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 PageLevelCacheDisable : 1;
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PDPTE_64_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] Accessed; indicates whether this entry has been used for linear-address
                 * translation.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT64 Accessed : 1;
#define PDPTE_64_ACCESSED_BIT  5
#define PDPTE_64_ACCESSED_FLAG 0x20
#define PDPTE_64_ACCESSED_MASK 0x01
#define PDPTE_64_ACCESSED(_)   (((_) >> 5) & 0x01)
                UINT64 Reserved1 : 1;

                /**
                 * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 1-GByte page).
                 */
                UINT64 LargePage : 1;
#define PDPTE_64_LARGE_PAGE_BIT  7
#define PDPTE_64_LARGE_PAGE_FLAG 0x80
#define PDPTE_64_LARGE_PAGE_MASK 0x01
#define PDPTE_64_LARGE_PAGE(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bits 10:8] Ignored.
                 */
                UINT64 Ignored1 : 3;
#define PDPTE_64_IGNORED_1_BIT  8
#define PDPTE_64_IGNORED_1_FLAG 0x700
#define PDPTE_64_IGNORED_1_MASK 0x07
#define PDPTE_64_IGNORED_1(_)   (((_) >> 8) & 0x07)

                /**
                 * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1,
                 * linear-address translation is restarted with ordinary paging)
                 *
                 * @see Vol3A[4.5.5(Restart of HLAT Paging)]
                 */
                UINT64 Restart : 1;
#define PDPTE_64_RESTART_BIT  11
#define PDPTE_64_RESTART_FLAG 0x800
#define PDPTE_64_RESTART_MASK 0x01
#define PDPTE_64_RESTART(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bits 47:12] Physical address of 4-KByte aligned page directory referenced by
                 * this entry.
                 */
                UINT64 PageFrameNumber : 36;
#define PDPTE_64_PAGE_FRAME_NUMBER_BIT  12
#define PDPTE_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define PDPTE_64_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define PDPTE_64_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved2 : 4;

                /**
                 * [Bits 62:52] Ignored.
                 */
                UINT64 Ignored2 : 11;
#define PDPTE_64_IGNORED_2_BIT  52
#define PDPTE_64_IGNORED_2_FLAG 0x7FF0000000000000
#define PDPTE_64_IGNORED_2_MASK 0x7FF
#define PDPTE_64_IGNORED_2(_)   (((_) >> 52) & 0x7FF)

                /**
                 * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not
                 * allowed from the 1-GByte region controlled by this entry); otherwise, reserved
                 * (must be 0).
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 ExecuteDisable : 1;
#define PDPTE_64_EXECUTE_DISABLE_BIT  63
#define PDPTE_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PDPTE_64_EXECUTE_DISABLE_MASK 0x01
#define PDPTE_64_EXECUTE_DISABLE(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} PDPTE_64;

/**
 * @brief Format of a 4-Level Page-Directory Entry that Maps a 2-MByte Page
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Present; must be 1 to map a 2-MByte page.
                 */
                UINT64 Present : 1;
#define PDE_2MB_64_PRESENT_BIT  0
#define PDE_2MB_64_PRESENT_FLAG 0x01
#define PDE_2MB_64_PRESENT_MASK 0x01
#define PDE_2MB_64_PRESENT(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 Write : 1;
#define PDE_2MB_64_WRITE_BIT  1
#define PDE_2MB_64_WRITE_FLAG 0x02
#define PDE_2MB_64_WRITE_MASK 0x01
#define PDE_2MB_64_WRITE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte
                 * page referenced by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 Supervisor : 1;
#define PDE_2MB_64_SUPERVISOR_BIT  2
#define PDE_2MB_64_SUPERVISOR_FLAG 0x04
#define PDE_2MB_64_SUPERVISOR_MASK 0x01
#define PDE_2MB_64_SUPERVISOR(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Page-level write-through; indirectly determines the memory type used to
                 * access the 2-MByte page referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 PageLevelWriteThrough : 1;
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PDE_2MB_64_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Page-level cache disable; indirectly determines the memory type used to
                 * access the 2-MByte page referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 PageLevelCacheDisable : 1;
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PDE_2MB_64_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] Accessed; indicates whether software has accessed the 2-MByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT64 Accessed : 1;
#define PDE_2MB_64_ACCESSED_BIT  5
#define PDE_2MB_64_ACCESSED_FLAG 0x20
#define PDE_2MB_64_ACCESSED_MASK 0x01
#define PDE_2MB_64_ACCESSED(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] Dirty; indicates whether software has written to the 2-MByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT64 Dirty : 1;
#define PDE_2MB_64_DIRTY_BIT  6
#define PDE_2MB_64_DIRTY_FLAG 0x40
#define PDE_2MB_64_DIRTY_MASK 0x01
#define PDE_2MB_64_DIRTY(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] Page size; must be 1 (otherwise, this entry references a page directory).
                 */
                UINT64 LargePage : 1;
#define PDE_2MB_64_LARGE_PAGE_BIT  7
#define PDE_2MB_64_LARGE_PAGE_FLAG 0x80
#define PDE_2MB_64_LARGE_PAGE_MASK 0x01
#define PDE_2MB_64_LARGE_PAGE(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global;
                 * ignored otherwise.
                 *
                 * @see Vol3A[4.10(Caching Translation Information)]
                 */
                UINT64 Global : 1;
#define PDE_2MB_64_GLOBAL_BIT  8
#define PDE_2MB_64_GLOBAL_FLAG 0x100
#define PDE_2MB_64_GLOBAL_MASK 0x01
#define PDE_2MB_64_GLOBAL(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bits 10:9] Ignored.
                 */
                UINT64 Ignored1 : 2;
#define PDE_2MB_64_IGNORED_1_BIT  9
#define PDE_2MB_64_IGNORED_1_FLAG 0x600
#define PDE_2MB_64_IGNORED_1_MASK 0x03
#define PDE_2MB_64_IGNORED_1(_)   (((_) >> 9) & 0x03)

                /**
                 * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1,
                 * linear-address translation is restarted with ordinary paging)
                 *
                 * @see Vol3A[4.5.5(Restart of HLAT Paging)]
                 */
                UINT64 Restart : 1;
#define PDE_2MB_64_RESTART_BIT  11
#define PDE_2MB_64_RESTART_FLAG 0x800
#define PDE_2MB_64_RESTART_MASK 0x01
#define PDE_2MB_64_RESTART(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bit 12] Indirectly determines the memory type used to access the 2-MByte page
                 * referenced by this entry.
                 *
                 * @note The PAT is supported on all processors that support 4-level paging.
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 Pat : 1;
#define PDE_2MB_64_PAT_BIT  12
#define PDE_2MB_64_PAT_FLAG 0x1000
#define PDE_2MB_64_PAT_MASK 0x01
#define PDE_2MB_64_PAT(_)   (((_) >> 12) & 0x01)
                UINT64 Reserved1 : 8;

                /**
                 * [Bits 47:21] Physical address of the 2-MByte page referenced by this entry.
                 */
                UINT64 PageFrameNumber : 27;
#define PDE_2MB_64_PAGE_FRAME_NUMBER_BIT  21
#define PDE_2MB_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFE00000
#define PDE_2MB_64_PAGE_FRAME_NUMBER_MASK 0x7FFFFFF
#define PDE_2MB_64_PAGE_FRAME_NUMBER(_)   (((_) >> 21) & 0x7FFFFFF)
                UINT64 Reserved2 : 4;

                /**
                 * [Bits 58:52] Ignored.
                 */
                UINT64 Ignored2 : 7;
#define PDE_2MB_64_IGNORED_2_BIT  52
#define PDE_2MB_64_IGNORED_2_FLAG 0x7F0000000000000
#define PDE_2MB_64_IGNORED_2_MASK 0x7F
#define PDE_2MB_64_IGNORED_2(_)   (((_) >> 52) & 0x7F)

                /**
                 * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the
                 * page; ignored otherwise.
                 *
                 * @see Vol3A[4.6.2(Protection Keys)]
                 */
                UINT64 ProtectionKey : 4;
#define PDE_2MB_64_PROTECTION_KEY_BIT  59
#define PDE_2MB_64_PROTECTION_KEY_FLAG 0x7800000000000000
#define PDE_2MB_64_PROTECTION_KEY_MASK 0x0F
#define PDE_2MB_64_PROTECTION_KEY(_)   (((_) >> 59) & 0x0F)

                /**
                 * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not
                 * allowed from the 2-MByte page controlled by this entry); otherwise, reserved
                 * (must be 0).
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 ExecuteDisable : 1;
#define PDE_2MB_64_EXECUTE_DISABLE_BIT  63
#define PDE_2MB_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PDE_2MB_64_EXECUTE_DISABLE_MASK 0x01
#define PDE_2MB_64_EXECUTE_DISABLE(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} PDE_2MB_64;

/**
 * @brief Format of a 4-Level Page-Directory Entry that References a Page Table
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Present; must be 1 to reference a page table.
                 */
                UINT64 Present : 1;
#define PDE_64_PRESENT_BIT  0
#define PDE_64_PRESENT_FLAG 0x01
#define PDE_64_PRESENT_MASK 0x01
#define PDE_64_PRESENT(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Read/write; if 0, writes may not be allowed to the 2-MByte region
                 * controlled by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 Write : 1;
#define PDE_64_WRITE_BIT  1
#define PDE_64_WRITE_FLAG 0x02
#define PDE_64_WRITE_MASK 0x01
#define PDE_64_WRITE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 2-MByte
                 * region controlled by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 Supervisor : 1;
#define PDE_64_SUPERVISOR_BIT  2
#define PDE_64_SUPERVISOR_FLAG 0x04
#define PDE_64_SUPERVISOR_MASK 0x01
#define PDE_64_SUPERVISOR(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Page-level write-through; indirectly determines the memory type used to
                 * access the page table referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 PageLevelWriteThrough : 1;
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PDE_64_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Page-level cache disable; indirectly determines the memory type used to
                 * access the page table referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 PageLevelCacheDisable : 1;
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PDE_64_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] Accessed; indicates whether this entry has been used for linear-address
                 * translation.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT64 Accessed : 1;
#define PDE_64_ACCESSED_BIT  5
#define PDE_64_ACCESSED_FLAG 0x20
#define PDE_64_ACCESSED_MASK 0x01
#define PDE_64_ACCESSED(_)   (((_) >> 5) & 0x01)
                UINT64 Reserved1 : 1;

                /**
                 * [Bit 7] Page size; must be 0 (otherwise, this entry maps a 2-MByte page).
                 */
                UINT64 LargePage : 1;
#define PDE_64_LARGE_PAGE_BIT  7
#define PDE_64_LARGE_PAGE_FLAG 0x80
#define PDE_64_LARGE_PAGE_MASK 0x01
#define PDE_64_LARGE_PAGE(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bits 10:8] Ignored.
                 */
                UINT64 Ignored1 : 3;
#define PDE_64_IGNORED_1_BIT  8
#define PDE_64_IGNORED_1_FLAG 0x700
#define PDE_64_IGNORED_1_MASK 0x07
#define PDE_64_IGNORED_1(_)   (((_) >> 8) & 0x07)

                /**
                 * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1,
                 * linear-address translation is restarted with ordinary paging)
                 *
                 * @see Vol3A[4.5.5(Restart of HLAT Paging)]
                 */
                UINT64 Restart : 1;
#define PDE_64_RESTART_BIT  11
#define PDE_64_RESTART_FLAG 0x800
#define PDE_64_RESTART_MASK 0x01
#define PDE_64_RESTART(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bits 47:12] Physical address of 4-KByte aligned page table referenced by this
                 * entry.
                 */
                UINT64 PageFrameNumber : 36;
#define PDE_64_PAGE_FRAME_NUMBER_BIT  12
#define PDE_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define PDE_64_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define PDE_64_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved2 : 4;

                /**
                 * [Bits 62:52] Ignored.
                 */
                UINT64 Ignored2 : 11;
#define PDE_64_IGNORED_2_BIT  52
#define PDE_64_IGNORED_2_FLAG 0x7FF0000000000000
#define PDE_64_IGNORED_2_MASK 0x7FF
#define PDE_64_IGNORED_2(_)   (((_) >> 52) & 0x7FF)

                /**
                 * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not
                 * allowed from the 2-MByte region controlled by this entry); otherwise, reserved
                 * (must be 0).
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 ExecuteDisable : 1;
#define PDE_64_EXECUTE_DISABLE_BIT  63
#define PDE_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PDE_64_EXECUTE_DISABLE_MASK 0x01
#define PDE_64_EXECUTE_DISABLE(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} PDE_64;

/**
 * @brief Format of a 4-Level Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Present; must be 1 to map a 4-KByte page.
                 */
                UINT64 Present : 1;
#define PTE_64_PRESENT_BIT  0
#define PTE_64_PRESENT_FLAG 0x01
#define PTE_64_PRESENT_MASK 0x01
#define PTE_64_PRESENT(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Read/write; if 0, writes may not be allowed to the 4-KByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 Write : 1;
#define PTE_64_WRITE_BIT  1
#define PTE_64_WRITE_FLAG 0x02
#define PTE_64_WRITE_MASK 0x01
#define PTE_64_WRITE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte
                 * page referenced by this entry.
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 Supervisor : 1;
#define PTE_64_SUPERVISOR_BIT  2
#define PTE_64_SUPERVISOR_FLAG 0x04
#define PTE_64_SUPERVISOR_MASK 0x01
#define PTE_64_SUPERVISOR(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Page-level write-through; indirectly determines the memory type used to
                 * access the 4-KByte page referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 PageLevelWriteThrough : 1;
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PTE_64_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Page-level cache disable; indirectly determines the memory type used to
                 * access the 4-KByte page referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 PageLevelCacheDisable : 1;
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PTE_64_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] Accessed; indicates whether software has accessed the 4-KByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT64 Accessed : 1;
#define PTE_64_ACCESSED_BIT  5
#define PTE_64_ACCESSED_FLAG 0x20
#define PTE_64_ACCESSED_MASK 0x01
#define PTE_64_ACCESSED(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] Dirty; indicates whether software has written to the 4-KByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.8(Accessed and Dirty Flags)]
                 */
                UINT64 Dirty : 1;
#define PTE_64_DIRTY_BIT  6
#define PTE_64_DIRTY_FLAG 0x40
#define PTE_64_DIRTY_MASK 0x01
#define PTE_64_DIRTY(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] Indirectly determines the memory type used to access the 4-KByte page
                 * referenced by this entry.
                 *
                 * @see Vol3A[4.9.2(Paging and Memory Typing When the PAT is Supported (Pentium III
                 * and More Recent Processor Families))]
                 */
                UINT64 Pat : 1;
#define PTE_64_PAT_BIT  7
#define PTE_64_PAT_FLAG 0x80
#define PTE_64_PAT_MASK 0x01
#define PTE_64_PAT(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] Global; if CR4.PGE = 1, determines whether the translation is global;
                 * ignored otherwise.
                 *
                 * @see Vol3A[4.10(Caching Translation Information)]
                 */
                UINT64 Global : 1;
#define PTE_64_GLOBAL_BIT  8
#define PTE_64_GLOBAL_FLAG 0x100
#define PTE_64_GLOBAL_MASK 0x01
#define PTE_64_GLOBAL(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bits 10:9] Ignored.
                 */
                UINT64 Ignored1 : 2;
#define PTE_64_IGNORED_1_BIT  9
#define PTE_64_IGNORED_1_FLAG 0x600
#define PTE_64_IGNORED_1_MASK 0x03
#define PTE_64_IGNORED_1(_)   (((_) >> 9) & 0x03)

                /**
                 * [Bit 11] For ordinary paging, ignored; for HLAT paging, restart (if 1,
                 * linear-address translation is restarted with ordinary paging)
                 *
                 * @see Vol3A[4.5.5(Restart of HLAT Paging)]
                 */
                UINT64 Restart : 1;
#define PTE_64_RESTART_BIT  11
#define PTE_64_RESTART_FLAG 0x800
#define PTE_64_RESTART_MASK 0x01
#define PTE_64_RESTART(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
                 */
                UINT64 PageFrameNumber : 36;
#define PTE_64_PAGE_FRAME_NUMBER_BIT  12
#define PTE_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define PTE_64_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define PTE_64_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved1 : 4;

                /**
                 * [Bits 58:52] Ignored.
                 */
                UINT64 Ignored2 : 7;
#define PTE_64_IGNORED_2_BIT  52
#define PTE_64_IGNORED_2_FLAG 0x7F0000000000000
#define PTE_64_IGNORED_2_MASK 0x7F
#define PTE_64_IGNORED_2(_)   (((_) >> 52) & 0x7F)

                /**
                 * [Bits 62:59] Protection key; if CR4.PKE = 1, determines the protection key of the
                 * page; ignored otherwise.
                 *
                 * @see Vol3A[4.6.2(Protection Keys)]
                 */
                UINT64 ProtectionKey : 4;
#define PTE_64_PROTECTION_KEY_BIT  59
#define PTE_64_PROTECTION_KEY_FLAG 0x7800000000000000
#define PTE_64_PROTECTION_KEY_MASK 0x0F
#define PTE_64_PROTECTION_KEY(_)   (((_) >> 59) & 0x0F)

                /**
                 * [Bit 63] If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not
                 * allowed from the 1-GByte page controlled by this entry); otherwise, reserved
                 * (must be 0).
                 *
                 * @see Vol3A[4.6(Access Rights)]
                 */
                UINT64 ExecuteDisable : 1;
#define PTE_64_EXECUTE_DISABLE_BIT  63
#define PTE_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PTE_64_EXECUTE_DISABLE_MASK 0x01
#define PTE_64_EXECUTE_DISABLE(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} PTE_64;

/**
 * @brief Format of a common Page-Table Entry
 */
typedef union
{
        struct
        {
                UINT64 Present : 1;
#define PT_ENTRY_64_PRESENT_BIT  0
#define PT_ENTRY_64_PRESENT_FLAG 0x01
#define PT_ENTRY_64_PRESENT_MASK 0x01
#define PT_ENTRY_64_PRESENT(_)   (((_) >> 0) & 0x01)
                UINT64 Write : 1;
#define PT_ENTRY_64_WRITE_BIT  1
#define PT_ENTRY_64_WRITE_FLAG 0x02
#define PT_ENTRY_64_WRITE_MASK 0x01
#define PT_ENTRY_64_WRITE(_)   (((_) >> 1) & 0x01)
                UINT64 Supervisor : 1;
#define PT_ENTRY_64_SUPERVISOR_BIT  2
#define PT_ENTRY_64_SUPERVISOR_FLAG 0x04
#define PT_ENTRY_64_SUPERVISOR_MASK 0x01
#define PT_ENTRY_64_SUPERVISOR(_)   (((_) >> 2) & 0x01)
                UINT64 PageLevelWriteThrough : 1;
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define PT_ENTRY_64_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)
                UINT64 PageLevelCacheDisable : 1;
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define PT_ENTRY_64_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)
                UINT64 Accessed : 1;
#define PT_ENTRY_64_ACCESSED_BIT  5
#define PT_ENTRY_64_ACCESSED_FLAG 0x20
#define PT_ENTRY_64_ACCESSED_MASK 0x01
#define PT_ENTRY_64_ACCESSED(_)   (((_) >> 5) & 0x01)
                UINT64 Dirty : 1;
#define PT_ENTRY_64_DIRTY_BIT  6
#define PT_ENTRY_64_DIRTY_FLAG 0x40
#define PT_ENTRY_64_DIRTY_MASK 0x01
#define PT_ENTRY_64_DIRTY(_)   (((_) >> 6) & 0x01)
                UINT64 LargePage : 1;
#define PT_ENTRY_64_LARGE_PAGE_BIT  7
#define PT_ENTRY_64_LARGE_PAGE_FLAG 0x80
#define PT_ENTRY_64_LARGE_PAGE_MASK 0x01
#define PT_ENTRY_64_LARGE_PAGE(_)   (((_) >> 7) & 0x01)
                UINT64 Global : 1;
#define PT_ENTRY_64_GLOBAL_BIT  8
#define PT_ENTRY_64_GLOBAL_FLAG 0x100
#define PT_ENTRY_64_GLOBAL_MASK 0x01
#define PT_ENTRY_64_GLOBAL(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bits 10:9] Ignored.
                 */
                UINT64 Ignored1 : 2;
#define PT_ENTRY_64_IGNORED_1_BIT  9
#define PT_ENTRY_64_IGNORED_1_FLAG 0x600
#define PT_ENTRY_64_IGNORED_1_MASK 0x03
#define PT_ENTRY_64_IGNORED_1(_)   (((_) >> 9) & 0x03)
                UINT64 Restart : 1;
#define PT_ENTRY_64_RESTART_BIT  11
#define PT_ENTRY_64_RESTART_FLAG 0x800
#define PT_ENTRY_64_RESTART_MASK 0x01
#define PT_ENTRY_64_RESTART(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
                 */
                UINT64 PageFrameNumber : 36;
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_BIT  12
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define PT_ENTRY_64_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define PT_ENTRY_64_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved1 : 4;

                /**
                 * [Bits 58:52] Ignored.
                 */
                UINT64 Ignored2 : 7;
#define PT_ENTRY_64_IGNORED_2_BIT  52
#define PT_ENTRY_64_IGNORED_2_FLAG 0x7F0000000000000
#define PT_ENTRY_64_IGNORED_2_MASK 0x7F
#define PT_ENTRY_64_IGNORED_2(_)   (((_) >> 52) & 0x7F)
                UINT64 ProtectionKey : 4;
#define PT_ENTRY_64_PROTECTION_KEY_BIT  59
#define PT_ENTRY_64_PROTECTION_KEY_FLAG 0x7800000000000000
#define PT_ENTRY_64_PROTECTION_KEY_MASK 0x0F
#define PT_ENTRY_64_PROTECTION_KEY(_)   (((_) >> 59) & 0x0F)
                UINT64 ExecuteDisable : 1;
#define PT_ENTRY_64_EXECUTE_DISABLE_BIT  63
#define PT_ENTRY_64_EXECUTE_DISABLE_FLAG 0x8000000000000000
#define PT_ENTRY_64_EXECUTE_DISABLE_MASK 0x01
#define PT_ENTRY_64_EXECUTE_DISABLE(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} PT_ENTRY_64;

/**
 * @defgroup PAGING_STRUCTURES_ENTRY_COUNT_64 \
 *           Paging structures entry counts
 *
 * Paging structures entry counts.
 * @{
 */
#define PML4E_ENTRY_COUNT_64 0x00000200
#define PDPTE_ENTRY_COUNT_64 0x00000200
#define PDE_ENTRY_COUNT_64   0x00000200
#define PTE_ENTRY_COUNT_64   0x00000200
/**
 * @}
 */

/**
 * @}
 */

/**
 * @}
 */

typedef enum
{
        /**
         * If the INVPCID type is 0, the logical processor invalidates mappings-except global
         * translations-associated with the PCID specified in the INVPCID descriptor and that would
         * be used to translate the linear address specified in the INVPCID descriptor.2 (The
         * instruction may also invalidate global translations, as well as mappings associated with
         * other PCIDs and for other linear addresses.)
         */
        InvpcidIndividualAddress = 0x00000000,

        /**
         * If the INVPCID type is 1, the logical processor invalidates all mappings-except global
         * translations-associated with the PCID specified in the INVPCID descriptor. (The
         * instruction may also invalidate global translations, as well as mappings associated with
         * other PCIDs.)
         */
        InvpcidSingleContext = 0x00000001,

        /**
         * If the INVPCID type is 2, the logical processor invalidates mappings-including global
         * translations-associated with all PCIDs.
         */
        InvpcidAllContextWithGlobals = 0x00000002,

        /**
         * If the INVPCID type is 3, the logical processor invalidates mappings-except global
         * translations- associated with all PCIDs. (The instruction may also invalidate global
         * translations.)
         */
        InvpcidAllContext = 0x00000003,
} INVPCID_TYPE;

typedef union
{
        struct
        {
                UINT64 Pcid : 12;
#define INVPCID_DESCRIPTOR_PCID_BIT  0
#define INVPCID_DESCRIPTOR_PCID_FLAG 0xFFF
#define INVPCID_DESCRIPTOR_PCID_MASK 0xFFF
#define INVPCID_DESCRIPTOR_PCID(_)   (((_) >> 0) & 0xFFF)

                /**
                 * [Bits 63:12] Must be zero.
                 */
                UINT64 Reserved1 : 52;
#define INVPCID_DESCRIPTOR_RESERVED1_BIT  12
#define INVPCID_DESCRIPTOR_RESERVED1_FLAG 0xFFFFFFFFFFFFF000
#define INVPCID_DESCRIPTOR_RESERVED1_MASK 0xFFFFFFFFFFFFF
#define INVPCID_DESCRIPTOR_RESERVED1(_)   (((_) >> 12) & 0xFFFFFFFFFFFFF)
                UINT64 LinearAddress : 64;
#define INVPCID_DESCRIPTOR_LINEAR_ADDRESS_BIT  64
#define INVPCID_DESCRIPTOR_LINEAR_ADDRESS_FLAG 0xFFFFFFFFFFFFFFFF0000000000000000
#define INVPCID_DESCRIPTOR_LINEAR_ADDRESS_MASK 0xFFFFFFFFFFFFFFFF
#define INVPCID_DESCRIPTOR_LINEAR_ADDRESS(_)   (((_) >> 64) & 0xFFFFFFFFFFFFFFFF)
        };

        UINT64 AsUInt;
} INVPCID_DESCRIPTOR;

/**
 * @defgroup SEGMENT_DESCRIPTORS \
 *           Segment descriptors
 * @{
 */
/**
 * @brief Pseudo-Descriptor Format (32-bit)
 *
 * @see Vol3A[3.5.1(Segment Descriptor Tables)] (reference)
 */
#pragma pack(push, 1)
typedef struct
{
        /**
         * Limit.
         */
        UINT16 Limit;

        /**
         * Base Address.
         */
        UINT32 BaseAddress;
} SEGMENT_DESCRIPTOR_REGISTER_32;
#pragma pack(pop)

/**
 * @brief Pseudo-Descriptor Format (64-bit)
 *
 * @see Vol3A[3.5.1(Segment Descriptor Tables)] (reference)
 */
#pragma pack(push, 1)
typedef struct
{
        /**
         * Limit.
         */
        UINT16 Limit;

        /**
         * Base Address.
         */
        UINT64 BaseAddress;
} SEGMENT_DESCRIPTOR_REGISTER_64;
#pragma pack(pop)

/**
 * @brief Segment access rights
 *
 * @see Vol2A[3.2(Instructions (A-L) | LAR-Load Access Rights Byte)] (reference)
 */
typedef union
{
        struct
        {
                UINT32 Reserved1 : 8;

                /**
                 * @brief Type field
                 *
                 * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of access
                 * that can be made to the segment and the direction of growth. The interpretation
                 * of this field depends on whether the descriptor type flag specifies an
                 * application (code or data) descriptor or a system descriptor. The encoding of the
                 * type field is different for code, data, and system descriptors.
                 *
                 * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
                 */
                UINT32 Type : 4;
#define SEGMENT_ACCESS_RIGHTS_TYPE_BIT  8
#define SEGMENT_ACCESS_RIGHTS_TYPE_FLAG 0xF00
#define SEGMENT_ACCESS_RIGHTS_TYPE_MASK 0x0F
#define SEGMENT_ACCESS_RIGHTS_TYPE(_)   (((_) >> 8) & 0x0F)

                /**
                 * @brief S (descriptor type) flag
                 *
                 * [Bit 12] Specifies whether the segment descriptor is for a system segment (S flag
                 * is clear) or a code or data segment (S flag is set).
                 */
                UINT32 DescriptorType : 1;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT  12
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG 0x1000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK 0x01
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_)   (((_) >> 12) & 0x01)

                /**
                 * @brief DPL (descriptor privilege level) field
                 *
                 * [Bits 14:13] Specifies the privilege level of the segment. The privilege level
                 * can range from 0 to 3, with 0 being the most privileged level. The DPL is used to
                 * control access to the segment. See Section 5.5, "Privilege Levels", for a
                 * description of the relationship of the DPL to the CPL of the executing code
                 * segment and the RPL of a segment selector.
                 */
                UINT32 DescriptorPrivilegeLevel : 2;
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT  13
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG 0x6000
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK 0x03
#define SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_)   (((_) >> 13) & 0x03)

                /**
                 * @brief P (segment-present) flag
                 *
                 * [Bit 15] Indicates whether the segment is present in memory (set) or not present
                 * (clear). If this flag is clear, the processor generates a segment-not-present
                 * exception (\#NP) when a segment selector that points to the segment descriptor is
                 * loaded into a segment register. Memory management software can use this flag to
                 * control which segments are actually loaded into physical memory at a given time.
                 * It offers a control in addition to paging for managing virtual memory.
                 */
                UINT32 Present : 1;
#define SEGMENT_ACCESS_RIGHTS_PRESENT_BIT  15
#define SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG 0x8000
#define SEGMENT_ACCESS_RIGHTS_PRESENT_MASK 0x01
#define SEGMENT_ACCESS_RIGHTS_PRESENT(_)   (((_) >> 15) & 0x01)
                UINT32 Reserved2 : 4;

                /**
                 * @brief Available bit
                 *
                 * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is available
                 * for use by system software.
                 */
                UINT32 System : 1;
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_BIT  20
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_FLAG 0x100000
#define SEGMENT_ACCESS_RIGHTS_SYSTEM_MASK 0x01
#define SEGMENT_ACCESS_RIGHTS_SYSTEM(_)   (((_) >> 20) & 0x01)

                /**
                 * @brief L (64-bit code segment) flag
                 *
                 * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment
                 * descriptor indicates whether a code segment contains native 64-bit code. A value
                 * of 1 indicates instructions in this code segment are executed in 64-bit mode. A
                 * value of 0 indicates the instructions in this code segment are executed in
                 * compatibility mode. If L-bit is set, then D-bit must be cleared. When not in
                 * IA-32e mode or for non-code segments, bit 21 is reserved and should always be set
                 * to 0.
                 */
                UINT32 LongMode : 1;
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT  21
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG 0x200000
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK 0x01
#define SEGMENT_ACCESS_RIGHTS_LONG_MODE(_)   (((_) >> 21) & 0x01)

                /**
                 * @brief D/B (default operation size/default stack pointer size and/or upper bound)
                 * flag
                 *
                 * [Bit 22] Performs different functions depending on whether the segment descriptor
                 * is an executable code segment, an expand-down data segment, or a stack segment.
                 * (This flag should always be set to 1 for 32-bit code and data segments and to 0
                 * for 16-bit code and data segments.)
                 * - Executable code segment. The flag is called the D flag and it indicates the
                 * default length for effective addresses and operands referenced by instructions in
                 * the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands
                 * are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are
                 * assumed. The instruction prefix 66H can be used to select an operand size other
                 * than the default, and the prefix 67H can be used select an address size other
                 * than the default.
                 * - Stack segment (data segment pointed to by the SS register). The flag is called
                 * the B (big) flag and it specifies the size of the stack pointer used for implicit
                 * stack operations (such as pushes, pops, and calls). If the flag is set, a 32-bit
                 * stack pointer is used, which is stored in the 32-bit ESP register; if the flag is
                 * clear, a 16-bit stack pointer is used, which is stored in the 16- bit SP
                 * register. If the stack segment is set up to be an expand-down data segment
                 * (described in the next paragraph), the B flag also specifies the upper bound of
                 * the stack segment.
                 * - Expand-down data segment. The flag is called the B flag and it specifies the
                 * upper bound of the segment. If the flag is set, the upper bound is FFFFFFFFH (4
                 * GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).
                 */
                UINT32 DefaultBig : 1;
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT  22
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG 0x400000
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK 0x01
#define SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_)   (((_) >> 22) & 0x01)

                /**
                 * @brief G (granularity) flag
                 *
                 * [Bit 23] Determines the scaling of the segment limit field. When the granularity
                 * flag is clear, the segment limit is interpreted in byte units; when flag is set,
                 * the segment limit is interpreted in 4-KByte units. (This flag does not affect the
                 * granularity of the base address; it is always byte granular.) When the
                 * granularity flag is set, the twelve least significant bits of an offset are not
                 * tested when checking the offset against the segment limit. For example, when the
                 * granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095.
                 */
                UINT32 Granularity : 1;
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT  23
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG 0x800000
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK 0x01
#define SEGMENT_ACCESS_RIGHTS_GRANULARITY(_)   (((_) >> 23) & 0x01)
                UINT32 Reserved3 : 8;
        };

        UINT32 AsUInt;
} SEGMENT_ACCESS_RIGHTS;

/**
 * @brief General Segment Descriptor (32-bit)
 *
 * A segment descriptor is a data structure in a GDT or LDT that provides the processor with the
 * size and location of a segment, as well as access control and status information. Segment
 * descriptors are typically created by compilers, linkers, loaders, or the operating system or
 * executive, but not application programs.
 *
 * @see Vol3A[5.2(FIELDS AND FLAGS USED FOR SEGMENT-LEVEL AND PAGE-LEVEL PROTECTION)]
 * @see Vol3A[5.2.1(Code-Segment Descriptor in 64-bit Mode)]
 * @see Vol3A[5.8.3(Call Gates)]
 * @see Vol3A[6.11(IDT DESCRIPTORS)]
 * @see Vol3A[6.14.1(64-Bit Mode IDT)]
 * @see Vol3A[7.2.2(TSS Descriptor)]
 * @see Vol3A[7.2.3(TSS Descriptor in 64-bit mode)]
 * @see Vol3A[7.2.5(Task-Gate Descriptor)]
 * @see Vol3A[3.4.5(Segment Descriptors)] (reference)
 */
typedef struct
{
        /**
         * @brief Segment limit field (15:00)
         *
         * Specifies the size of the segment. The processor puts together the two segment limit
         * fields to form a 20-bit value. The processor interprets the segment limit in one of two
         * ways, depending on the setting of the G (granularity) flag:
         * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in
         * byte increments.
         * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes,
         * in 4-KByte increments. The processor uses the segment limit in two different ways,
         * depending on whether the segment is an expand-up or an expand-down segment. For expand-up
         * segments, the offset in a logical address can range from 0 to the segment limit. Offsets
         * greater than the segment limit generate general-protection exceptions (\#GP, for all
         * segments other than SS) or stack-fault exceptions (\#SS for the SS segment). For
         * expand-down segments, the segment limit has the reverse function; the offset can range
         * from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B
         * flag. Offsets less than or equal to the segment limit generate general-protection
         * exceptions or stack-fault exceptions. Decreasing the value in the segment limit field for
         * an expanddown segment allocates new memory at the bottom of the segment's address space,
         * rather than at the top. IA-32 architecture stacks always grow downwards, making this
         * mechanism convenient for expandable stacks.
         *
         * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
         */
        UINT16 SegmentLimitLow;

        /**
         * @brief Base address field (15:00)
         *
         * Defines the location of byte 0 of the segment within the 4-GByte linear address space.
         * The processor puts together the three base address fields to form a single 32-bit value.
         * Segment base addresses should be aligned to 16-byte boundaries. Although 16-byte
         * alignment is not required, this alignment allows programs to maximize performance by
         * aligning code and data on 16-byte boundaries.
         */
        UINT16 BaseAddressLow;
        /**
         * @brief Segment descriptor fields
         */
        union
        {
                struct
                {
                        /**
                         * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for
                         * more details.
                         */
                        UINT32 BaseAddressMiddle : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT  0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG 0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK 0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_)   (((_) >> 0) & 0xFF)

                        /**
                         * @brief Type field
                         *
                         * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of
                         * access that can be made to the segment and the direction of growth. The
                         * interpretation of this field depends on whether the descriptor type flag
                         * specifies an application (code or data) descriptor or a system
                         * descriptor. The encoding of the type field is different for code, data,
                         * and system descriptors.
                         *
                         * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
                         */
                        UINT32 Type : 4;
#define SEGMENT__TYPE_BIT  8
#define SEGMENT__TYPE_FLAG 0xF00
#define SEGMENT__TYPE_MASK 0x0F
#define SEGMENT__TYPE(_)   (((_) >> 8) & 0x0F)

                        /**
                         * @brief S (descriptor type) flag
                         *
                         * [Bit 12] Specifies whether the segment descriptor is for a system segment
                         * (S flag is clear) or a code or data segment (S flag is set).
                         */
                        UINT32 DescriptorType : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT  12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG 0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK 0x01
#define SEGMENT__DESCRIPTOR_TYPE(_)   (((_) >> 12) & 0x01)

                        /**
                         * @brief DPL (descriptor privilege level) field
                         *
                         * [Bits 14:13] Specifies the privilege level of the segment. The privilege
                         * level can range from 0 to 3, with 0 being the most privileged level. The
                         * DPL is used to control access to the segment. See Section 5.5, "Privilege
                         * Levels", for a description of the relationship of the DPL to the CPL of
                         * the executing code segment and the RPL of a segment selector.
                         */
                        UINT32 DescriptorPrivilegeLevel : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT  13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG 0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK 0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)   (((_) >> 13) & 0x03)

                        /**
                         * @brief P (segment-present) flag
                         *
                         * [Bit 15] Indicates whether the segment is present in memory (set) or not
                         * present (clear). If this flag is clear, the processor generates a
                         * segment-not-present exception (\#NP) when a segment selector that points
                         * to the segment descriptor is loaded into a segment register. Memory
                         * management software can use this flag to control which segments are
                         * actually loaded into physical memory at a given time. It offers a control
                         * in addition to paging for managing virtual memory.
                         */
                        UINT32 Present : 1;
#define SEGMENT__PRESENT_BIT  15
#define SEGMENT__PRESENT_FLAG 0x8000
#define SEGMENT__PRESENT_MASK 0x01
#define SEGMENT__PRESENT(_)   (((_) >> 15) & 0x01)

                        /**
                         * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW
                         * for more details.
                         */
                        UINT32 SegmentLimitHigh : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT  16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG 0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK 0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_)   (((_) >> 16) & 0x0F)

                        /**
                         * @brief Available bit
                         *
                         * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is
                         * available for use by system software.
                         */
                        UINT32 System : 1;
#define SEGMENT__SYSTEM_BIT  20
#define SEGMENT__SYSTEM_FLAG 0x100000
#define SEGMENT__SYSTEM_MASK 0x01
#define SEGMENT__SYSTEM(_)   (((_) >> 20) & 0x01)

                        /**
                         * @brief L (64-bit code segment) flag
                         *
                         * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment
                         * descriptor indicates whether a code segment contains native 64-bit code.
                         * A value of 1 indicates instructions in this code segment are executed in
                         * 64-bit mode. A value of 0 indicates the instructions in this code segment
                         * are executed in compatibility mode. If L-bit is set, then D-bit must be
                         * cleared. When not in IA-32e mode or for non-code segments, bit 21 is
                         * reserved and should always be set to 0.
                         */
                        UINT32 LongMode : 1;
#define SEGMENT__LONG_MODE_BIT  21
#define SEGMENT__LONG_MODE_FLAG 0x200000
#define SEGMENT__LONG_MODE_MASK 0x01
#define SEGMENT__LONG_MODE(_)   (((_) >> 21) & 0x01)

                        /**
                         * @brief D/B (default operation size/default stack pointer size and/or
                         * upper bound) flag
                         *
                         * [Bit 22] Performs different functions depending on whether the segment
                         * descriptor is an executable code segment, an expand-down data segment, or
                         * a stack segment. (This flag should always be set to 1 for 32-bit code and
                         * data segments and to 0 for 16-bit code and data segments.)
                         * - Executable code segment. The flag is called the D flag and it indicates
                         * the default length for effective addresses and operands referenced by
                         * instructions in the segment. If the flag is set, 32-bit addresses and
                         * 32-bit or 8-bit operands are assumed; if it is clear, 16-bit addresses
                         * and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
                         * be used to select an operand size other than the default, and the prefix
                         * 67H can be used select an address size other than the default.
                         * - Stack segment (data segment pointed to by the SS register). The flag is
                         * called the B (big) flag and it specifies the size of the stack pointer
                         * used for implicit stack operations (such as pushes, pops, and calls). If
                         * the flag is set, a 32-bit stack pointer is used, which is stored in the
                         * 32-bit ESP register; if the flag is clear, a 16-bit stack pointer is
                         * used, which is stored in the 16- bit SP register. If the stack segment is
                         * set up to be an expand-down data segment (described in the next
                         * paragraph), the B flag also specifies the upper bound of the stack
                         * segment.
                         * - Expand-down data segment. The flag is called the B flag and it
                         * specifies the upper bound of the segment. If the flag is set, the upper
                         * bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is
                         * FFFFH (64 KBytes).
                         */
                        UINT32 DefaultBig : 1;
#define SEGMENT__DEFAULT_BIG_BIT  22
#define SEGMENT__DEFAULT_BIG_FLAG 0x400000
#define SEGMENT__DEFAULT_BIG_MASK 0x01
#define SEGMENT__DEFAULT_BIG(_)   (((_) >> 22) & 0x01)

                        /**
                         * @brief G (granularity) flag
                         *
                         * [Bit 23] Determines the scaling of the segment limit field. When the
                         * granularity flag is clear, the segment limit is interpreted in byte
                         * units; when flag is set, the segment limit is interpreted in 4-KByte
                         * units. (This flag does not affect the granularity of the base address; it
                         * is always byte granular.) When the granularity flag is set, the twelve
                         * least significant bits of an offset are not tested when checking the
                         * offset against the segment limit. For example, when the granularity flag
                         * is set, a limit of 0 results in valid offsets from 0 to 4095.
                         */
                        UINT32 Granularity : 1;
#define SEGMENT__GRANULARITY_BIT  23
#define SEGMENT__GRANULARITY_FLAG 0x800000
#define SEGMENT__GRANULARITY_MASK 0x01
#define SEGMENT__GRANULARITY(_)   (((_) >> 23) & 0x01)

                        /**
                         * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for
                         * more details.
                         */
                        UINT32 BaseAddressHigh : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT  24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG 0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK 0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_)   (((_) >> 24) & 0xFF)
                };

                UINT32 AsUInt;
        };

} SEGMENT_DESCRIPTOR_32;

/**
 * @brief General Segment Descriptor (64-bit)
 *
 * A segment descriptor is a data structure in a GDT or LDT that provides the processor with the
 * size and location of a segment, as well as access control and status information. Segment
 * descriptors are typically created by compilers, linkers, loaders, or the operating system or
 * executive, but not application programs.
 *
 * @see Vol3A[3.4.5(Segment Descriptors)] (reference)
 */
typedef struct
{
        /**
         * @brief Segment limit field (15:00)
         *
         * Specifies the size of the segment. The processor puts together the two segment limit
         * fields to form a 20-bit value. The processor interprets the segment limit in one of two
         * ways, depending on the setting of the G (granularity) flag:
         * - If the granularity flag is clear, the segment size can range from 1 byte to 1 MByte, in
         * byte increments.
         * - If the granularity flag is set, the segment size can range from 4 KBytes to 4 GBytes,
         * in 4-KByte increments. The processor uses the segment limit in two different ways,
         * depending on whether the segment is an expand-up or an expand-down segment. For expand-up
         * segments, the offset in a logical address can range from 0 to the segment limit. Offsets
         * greater than the segment limit generate general-protection exceptions (\#GP, for all
         * segments other than SS) or stack-fault exceptions (\#SS for the SS segment). For
         * expand-down segments, the segment limit has the reverse function; the offset can range
         * from the segment limit plus 1 to FFFFFFFFH or FFFFH, depending on the setting of the B
         * flag. Offsets less than or equal to the segment limit generate general-protection
         * exceptions or stack-fault exceptions. Decreasing the value in the segment limit field for
         * an expanddown segment allocates new memory at the bottom of the segment's address space,
         * rather than at the top. IA-32 architecture stacks always grow downwards, making this
         * mechanism convenient for expandable stacks.
         *
         * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
         */
        UINT16 SegmentLimitLow;

        /**
         * @brief Base address field (15:00)
         *
         * Defines the location of byte 0 of the segment within the 4-GByte linear address space.
         * The processor puts together the three base address fields to form a single 32-bit value.
         * Segment base addresses should be aligned to 16-byte boundaries. Although 16-byte
         * alignment is not required, this alignment allows programs to maximize performance by
         * aligning code and data on 16-byte boundaries.
         */
        UINT16 BaseAddressLow;
        /**
         * @brief Segment descriptor fields
         */
        union
        {
                struct
                {
                        /**
                         * [Bits 7:0] Base address field (23:16); see description of $BASE_LOW for
                         * more details.
                         */
                        UINT32 BaseAddressMiddle : 8;
#define SEGMENT__BASE_ADDRESS_MIDDLE_BIT  0
#define SEGMENT__BASE_ADDRESS_MIDDLE_FLAG 0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE_MASK 0xFF
#define SEGMENT__BASE_ADDRESS_MIDDLE(_)   (((_) >> 0) & 0xFF)

                        /**
                         * @brief Type field
                         *
                         * [Bits 11:8] Indicates the segment or gate type and specifies the kinds of
                         * access that can be made to the segment and the direction of growth. The
                         * interpretation of this field depends on whether the descriptor type flag
                         * specifies an application (code or data) descriptor or a system
                         * descriptor. The encoding of the type field is different for code, data,
                         * and system descriptors.
                         *
                         * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)]
                         */
                        UINT32 Type : 4;
#define SEGMENT__TYPE_BIT  8
#define SEGMENT__TYPE_FLAG 0xF00
#define SEGMENT__TYPE_MASK 0x0F
#define SEGMENT__TYPE(_)   (((_) >> 8) & 0x0F)

                        /**
                         * @brief S (descriptor type) flag
                         *
                         * [Bit 12] Specifies whether the segment descriptor is for a system segment
                         * (S flag is clear) or a code or data segment (S flag is set).
                         */
                        UINT32 DescriptorType : 1;
#define SEGMENT__DESCRIPTOR_TYPE_BIT  12
#define SEGMENT__DESCRIPTOR_TYPE_FLAG 0x1000
#define SEGMENT__DESCRIPTOR_TYPE_MASK 0x01
#define SEGMENT__DESCRIPTOR_TYPE(_)   (((_) >> 12) & 0x01)

                        /**
                         * @brief DPL (descriptor privilege level) field
                         *
                         * [Bits 14:13] Specifies the privilege level of the segment. The privilege
                         * level can range from 0 to 3, with 0 being the most privileged level. The
                         * DPL is used to control access to the segment. See Section 5.5, "Privilege
                         * Levels", for a description of the relationship of the DPL to the CPL of
                         * the executing code segment and the RPL of a segment selector.
                         */
                        UINT32 DescriptorPrivilegeLevel : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT  13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG 0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK 0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)   (((_) >> 13) & 0x03)

                        /**
                         * @brief P (segment-present) flag
                         *
                         * [Bit 15] Indicates whether the segment is present in memory (set) or not
                         * present (clear). If this flag is clear, the processor generates a
                         * segment-not-present exception (\#NP) when a segment selector that points
                         * to the segment descriptor is loaded into a segment register. Memory
                         * management software can use this flag to control which segments are
                         * actually loaded into physical memory at a given time. It offers a control
                         * in addition to paging for managing virtual memory.
                         */
                        UINT32 Present : 1;
#define SEGMENT__PRESENT_BIT  15
#define SEGMENT__PRESENT_FLAG 0x8000
#define SEGMENT__PRESENT_MASK 0x01
#define SEGMENT__PRESENT(_)   (((_) >> 15) & 0x01)

                        /**
                         * [Bits 19:16] Segment limit field (19:16); see description of $LIMIT_LOW
                         * for more details.
                         */
                        UINT32 SegmentLimitHigh : 4;
#define SEGMENT__SEGMENT_LIMIT_HIGH_BIT  16
#define SEGMENT__SEGMENT_LIMIT_HIGH_FLAG 0xF0000
#define SEGMENT__SEGMENT_LIMIT_HIGH_MASK 0x0F
#define SEGMENT__SEGMENT_LIMIT_HIGH(_)   (((_) >> 16) & 0x0F)

                        /**
                         * @brief Available bit
                         *
                         * [Bit 20] Bit 20 of the second doubleword of the segment descriptor is
                         * available for use by system software.
                         */
                        UINT32 System : 1;
#define SEGMENT__SYSTEM_BIT  20
#define SEGMENT__SYSTEM_FLAG 0x100000
#define SEGMENT__SYSTEM_MASK 0x01
#define SEGMENT__SYSTEM(_)   (((_) >> 20) & 0x01)

                        /**
                         * @brief L (64-bit code segment) flag
                         *
                         * [Bit 21] In IA-32e mode, bit 21 of the second doubleword of the segment
                         * descriptor indicates whether a code segment contains native 64-bit code.
                         * A value of 1 indicates instructions in this code segment are executed in
                         * 64-bit mode. A value of 0 indicates the instructions in this code segment
                         * are executed in compatibility mode. If L-bit is set, then D-bit must be
                         * cleared. When not in IA-32e mode or for non-code segments, bit 21 is
                         * reserved and should always be set to 0.
                         */
                        UINT32 LongMode : 1;
#define SEGMENT__LONG_MODE_BIT  21
#define SEGMENT__LONG_MODE_FLAG 0x200000
#define SEGMENT__LONG_MODE_MASK 0x01
#define SEGMENT__LONG_MODE(_)   (((_) >> 21) & 0x01)

                        /**
                         * @brief D/B (default operation size/default stack pointer size and/or
                         * upper bound) flag
                         *
                         * [Bit 22] Performs different functions depending on whether the segment
                         * descriptor is an executable code segment, an expand-down data segment, or
                         * a stack segment. (This flag should always be set to 1 for 32-bit code and
                         * data segments and to 0 for 16-bit code and data segments.)
                         * - Executable code segment. The flag is called the D flag and it indicates
                         * the default length for effective addresses and operands referenced by
                         * instructions in the segment. If the flag is set, 32-bit addresses and
                         * 32-bit or 8-bit operands are assumed; if it is clear, 16-bit addresses
                         * and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can
                         * be used to select an operand size other than the default, and the prefix
                         * 67H can be used select an address size other than the default.
                         * - Stack segment (data segment pointed to by the SS register). The flag is
                         * called the B (big) flag and it specifies the size of the stack pointer
                         * used for implicit stack operations (such as pushes, pops, and calls). If
                         * the flag is set, a 32-bit stack pointer is used, which is stored in the
                         * 32-bit ESP register; if the flag is clear, a 16-bit stack pointer is
                         * used, which is stored in the 16- bit SP register. If the stack segment is
                         * set up to be an expand-down data segment (described in the next
                         * paragraph), the B flag also specifies the upper bound of the stack
                         * segment.
                         * - Expand-down data segment. The flag is called the B flag and it
                         * specifies the upper bound of the segment. If the flag is set, the upper
                         * bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is
                         * FFFFH (64 KBytes).
                         */
                        UINT32 DefaultBig : 1;
#define SEGMENT__DEFAULT_BIG_BIT  22
#define SEGMENT__DEFAULT_BIG_FLAG 0x400000
#define SEGMENT__DEFAULT_BIG_MASK 0x01
#define SEGMENT__DEFAULT_BIG(_)   (((_) >> 22) & 0x01)

                        /**
                         * @brief G (granularity) flag
                         *
                         * [Bit 23] Determines the scaling of the segment limit field. When the
                         * granularity flag is clear, the segment limit is interpreted in byte
                         * units; when flag is set, the segment limit is interpreted in 4-KByte
                         * units. (This flag does not affect the granularity of the base address; it
                         * is always byte granular.) When the granularity flag is set, the twelve
                         * least significant bits of an offset are not tested when checking the
                         * offset against the segment limit. For example, when the granularity flag
                         * is set, a limit of 0 results in valid offsets from 0 to 4095.
                         */
                        UINT32 Granularity : 1;
#define SEGMENT__GRANULARITY_BIT  23
#define SEGMENT__GRANULARITY_FLAG 0x800000
#define SEGMENT__GRANULARITY_MASK 0x01
#define SEGMENT__GRANULARITY(_)   (((_) >> 23) & 0x01)

                        /**
                         * [Bits 31:24] Base address field (31:24); see description of $BASE_LOW for
                         * more details.
                         */
                        UINT32 BaseAddressHigh : 8;
#define SEGMENT__BASE_ADDRESS_HIGH_BIT  24
#define SEGMENT__BASE_ADDRESS_HIGH_FLAG 0xFF000000
#define SEGMENT__BASE_ADDRESS_HIGH_MASK 0xFF
#define SEGMENT__BASE_ADDRESS_HIGH(_)   (((_) >> 24) & 0xFF)
                };

                UINT32 AsUInt;
        };

        /**
         * Base address field (32:63); see description of $BASE_LOW for more details.
         */
        UINT32 BaseAddressUpper;

        /**
         * This field must be set to zero.
         */
        UINT32 MustBeZero;
} SEGMENT_DESCRIPTOR_64;

/**
 * @brief Interrupt Gate Descriptor (64-bit)
 *
 * @see Vol3A[6.14.1(64-Bit Mode IDT)] (reference)
 */
typedef struct
{
        /**
         * Offset to procedure entry point (15:00).
         */
        UINT16 OffsetLow;

        /**
         * Segment selector for destination code segment.
         */
        UINT16 SegmentSelector;
        union
        {
                struct
                {
                        /**
                         * [Bits 2:0] Index into the TSS Interrupt Stack Table.
                         */
                        UINT32 InterruptStackTable : 3;
#define SEGMENT__INTERRUPT_STACK_TABLE_BIT  0
#define SEGMENT__INTERRUPT_STACK_TABLE_FLAG 0x07
#define SEGMENT__INTERRUPT_STACK_TABLE_MASK 0x07
#define SEGMENT__INTERRUPT_STACK_TABLE(_)   (((_) >> 0) & 0x07)

                        /**
                         * [Bits 7:3] This field must be set to zero.
                         */
                        UINT32 MustBeZero0 : 5;
#define SEGMENT__MUST_BE_ZERO_0_BIT  3
#define SEGMENT__MUST_BE_ZERO_0_FLAG 0xF8
#define SEGMENT__MUST_BE_ZERO_0_MASK 0x1F
#define SEGMENT__MUST_BE_ZERO_0(_)   (((_) >> 3) & 0x1F)

                        /**
                         * [Bits 11:8] Indicates the segment or gate type.
                         */
                        UINT32 Type : 4;
#define SEGMENT__TYPE_BIT  8
#define SEGMENT__TYPE_FLAG 0xF00
#define SEGMENT__TYPE_MASK 0x0F
#define SEGMENT__TYPE(_)   (((_) >> 8) & 0x0F)

                        /**
                         * [Bit 12] This field must be set to zero.
                         */
                        UINT32 MustBeZero1 : 1;
#define SEGMENT__MUST_BE_ZERO_1_BIT  12
#define SEGMENT__MUST_BE_ZERO_1_FLAG 0x1000
#define SEGMENT__MUST_BE_ZERO_1_MASK 0x01
#define SEGMENT__MUST_BE_ZERO_1(_)   (((_) >> 12) & 0x01)

                        /**
                         * [Bits 14:13] Specifies the segment privilege level.
                         */
                        UINT32 DescriptorPrivilegeLevel : 2;
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_BIT  13
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_FLAG 0x6000
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL_MASK 0x03
#define SEGMENT__DESCRIPTOR_PRIVILEGE_LEVEL(_)   (((_) >> 13) & 0x03)

                        /**
                         * [Bit 15] Indicates whether the segment is present in memory (set) or not
                         * present (clear).
                         */
                        UINT32 Present : 1;
#define SEGMENT__PRESENT_BIT  15
#define SEGMENT__PRESENT_FLAG 0x8000
#define SEGMENT__PRESENT_MASK 0x01
#define SEGMENT__PRESENT(_)   (((_) >> 15) & 0x01)

                        /**
                         * [Bits 31:16] Offset to procedure entry point (31:16).
                         */
                        UINT32 OffsetMiddle : 16;
#define SEGMENT__OFFSET_MIDDLE_BIT  16
#define SEGMENT__OFFSET_MIDDLE_FLAG 0xFFFF0000
#define SEGMENT__OFFSET_MIDDLE_MASK 0xFFFF
#define SEGMENT__OFFSET_MIDDLE(_)   (((_) >> 16) & 0xFFFF)
                };

                UINT32 AsUInt;
        };

        /**
         * Offset to procedure entry point (63:32).
         */
        UINT32 OffsetHigh;
        UINT32 Reserved;
} SEGMENT_DESCRIPTOR_INTERRUPT_GATE_64;

#define SEGMENT_DESCRIPTOR_TYPE_SYSTEM       0x00000000
#define SEGMENT_DESCRIPTOR_TYPE_CODE_OR_DATA 0x00000001
/**
 * @defgroup SEGMENT_DESCRIPTOR_CODE_AND_DATA_TYPE \
 *           Code- and Data-Segment Descriptor Types
 *
 * When the S (descriptor type) flag in a segment descriptor is set, the descriptor is for either a
 * code or a data segment. The highest order bit of the type field (bit 11 of the second double word
 * of the segment descriptor) then determines whether the descriptor is for a data segment (clear)
 * or a code segment (set). For data segments, the three low-order bits of the type field (bits 8,
 * 9, and 10) are interpreted as accessed (A), write-enable (W), and expansion-direction (E). See
 * Table 3-1 for a description of the encoding of the bits in the type field for code and data
 * segments. Data segments can be read-only or read/write segments, depending on the setting of the
 * write-enable bit.
 *
 * @see Vol3A[3.4.5.1(Code- and Data-Segment Descriptor Types)] (reference)
 * @{
 */
/**
 * Read-Only.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY 0x00000000

/**
 * Data Read-Only, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_ACCESSED 0x00000001

/**
 * Data Read/Write.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE 0x00000002

/**
 * Data Read/Write, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_ACCESSED 0x00000003

/**
 * Data Read-Only, expand-down.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN 0x00000004

/**
 * Data Read-Only, expand-down, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_ONLY_EXPAND_DOWN_ACCESSED 0x00000005

/**
 * Data Read/Write, expand-down.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN 0x00000006

/**
 * Data Read/Write, expand-down, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_DATA_READ_WRITE_EXPAND_DOWN_ACCESSED 0x00000007

/**
 * Code Execute-Only.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY 0x00000008

/**
 * Code Execute-Only, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_ACCESSED 0x00000009

/**
 * Code Execute/Read.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ 0x0000000A

/**
 * Code Execute/Read, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_ACCESSED 0x0000000B

/**
 * Code Execute-Only, conforming.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING 0x0000000C

/**
 * Code Execute-Only, conforming, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_ONLY_CONFORMING_ACCESSED 0x0000000D

/**
 * Code Execute/Read, conforming.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING 0x0000000E

/**
 * Code Execute/Read, conforming, accessed.
 */
#define SEGMENT_DESCRIPTOR_TYPE_CODE_EXECUTE_READ_CONFORMING_ACCESSED 0x0000000F
/**
 * @}
 */

/**
 * @defgroup SEGMENT_DESCRIPTOR_SYSTEM_TYPE \
 *           System Descriptor Types
 *
 * When the S (descriptor type) flag in a segment descriptor is clear, the descriptor type is a
 * system descriptor. The processor recognizes the following types of system descriptors:
 * - Local descriptor-table (LDT) segment descriptor.
 * - Task-state segment (TSS) descriptor.
 * - Call-gate descriptor.
 * - Interrupt-gate descriptor.
 * - Trap-gate descriptor.
 * - Task-gate descriptor.
 * These descriptor types fall into two categories: system-segment descriptors and gate descriptors.
 * Systemsegment descriptors point to system segments (LDT and TSS segments). Gate descriptors are
 * in themselves "gates," which hold pointers to procedure entry points in code segments (call,
 * interrupt, and trap gates) or which hold segment selectors for TSS's (task gates).
 *
 * @see Vol3A[3.5(SYSTEM DESCRIPTOR TYPES)] (reference)
 * @{
 */
/**
 * - 32-Bit Mode: Reserved
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_1 0x00000000

/**
 * - 32-Bit Mode: 16-bit TSS (Available)
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_AVAILABLE 0x00000001

/**
 * - 32-Bit Mode: LDT
 * - IA-32e Mode: LDT
 */
#define SEGMENT_DESCRIPTOR_TYPE_LDT 0x00000002

/**
 * - 32-Bit Mode: 16-bit TSS (Busy)
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_16_BUSY 0x00000003

/**
 * - 32-Bit Mode: 16-bit Call Gate
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE_16 0x00000004

/**
 * - 32-Bit Mode: Task Gate
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_TASK_GATE 0x00000005

/**
 * - 32-Bit Mode: 16-bit Interrupt Gate
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE_16 0x00000006

/**
 * - 32-Bit Mode: 16-bit Trap Gate
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE_16 0x00000007

/**
 * - 32-Bit Mode: Reserved
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_2 0x00000008

/**
 * - 32-Bit Mode: 32-bit TSS (Available)
 * - IA-32e Mode: 64-bit TSS (Available)
 */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_AVAILABLE 0x00000009

/**
 * - 32-Bit Mode: Reserved
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_3 0x0000000A

/**
 * - 32-Bit Mode: 32-bit TSS (Busy)
 * - IA-32e Mode: 64-bit TSS (Busy)
 */
#define SEGMENT_DESCRIPTOR_TYPE_TSS_BUSY 0x0000000B

/**
 * - 32-Bit Mode: 32-bit Call Gate
 * - IA-32e Mode: 64-bit Call Gate
 */
#define SEGMENT_DESCRIPTOR_TYPE_CALL_GATE 0x0000000C

/**
 * - 32-Bit Mode: Reserved
 * - IA-32e Mode: Reserved
 */
#define SEGMENT_DESCRIPTOR_TYPE_RESERVED_4 0x0000000D

/**
 * - 32-Bit Mode: 32-bit Interrupt Gate
 * - IA-32e Mode: 64-bit Interrupt Gate
 */
#define SEGMENT_DESCRIPTOR_TYPE_INTERRUPT_GATE 0x0000000E

/**
 * - 32-Bit Mode: 32-bit Trap Gate
 * - IA-32e Mode: 64-bit Trap Gate
 */
#define SEGMENT_DESCRIPTOR_TYPE_TRAP_GATE 0x0000000F
/**
 * @}
 */

/**
 * @brief A segment selector is a 16-bit identifier for a segment. It does not point directly to the
 * segment, but instead points to the segment descriptor that defines the segment
 *
 * @see Vol3A[3.4.2(Segment Selectors)] (reference)
 */
typedef union
{
        struct
        {
                /**
                 * [Bits 1:0] Specifies the privilege level of the selector. The privilege level can
                 * range from 0 to 3, with 0 being the most privileged level.
                 *
                 * @see Vol3A[5.5(Privilege Levels)]
                 */
                UINT16 RequestPrivilegeLevel : 2;
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_BIT  0
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_FLAG 0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL_MASK 0x03
#define SEGMENT_SELECTOR_REQUEST_PRIVILEGE_LEVEL(_)   (((_) >> 0) & 0x03)

                /**
                 * [Bit 2] Specifies the descriptor table to use: clearing this flag selects the
                 * GDT; setting this flag selects the current LDT.
                 */
                UINT16 Table : 1;
#define SEGMENT_SELECTOR_TABLE_BIT  2
#define SEGMENT_SELECTOR_TABLE_FLAG 0x04
#define SEGMENT_SELECTOR_TABLE_MASK 0x01
#define SEGMENT_SELECTOR_TABLE(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bits 15:3] Selects one of 8192 descriptors in the GDT or LDT. The processor
                 * multiplies the index value by 8 (the number of bytes in a segment descriptor) and
                 * adds the result to the base address of the GDT or LDT (from the GDTR or LDTR
                 * register, respectively).
                 */
                UINT16 Index : 13;
#define SEGMENT_SELECTOR_INDEX_BIT  3
#define SEGMENT_SELECTOR_INDEX_FLAG 0xFFF8
#define SEGMENT_SELECTOR_INDEX_MASK 0x1FFF
#define SEGMENT_SELECTOR_INDEX(_)   (((_) >> 3) & 0x1FFF)
        };

        UINT16 AsUInt;
} SEGMENT_SELECTOR;

/**
 * @}
 */

/**
 * @brief Task State Segment (64-bit)
 *
 * @see Vol3C[7.7(Task Management in 64-bit Mode)] (reference)
 */
#pragma pack(push, 1)
typedef struct
{
        /**
         * Reserved bits. Set to 0.
         */
        UINT32 Reserved0;

        /**
         * Stack pointer for privilege level 0.
         */
        UINT64 Rsp0;

        /**
         * Stack pointer for privilege level 1.
         */
        UINT64 Rsp1;

        /**
         * Stack pointer for privilege level 2.
         */
        UINT64 Rsp2;

        /**
         * Reserved bits. Set to 0.
         */
        UINT64 Reserved1;

        /**
         * Interrupt stack table pointer (1).
         */
        UINT64 Ist1;

        /**
         * Interrupt stack table pointer (2).
         */
        UINT64 Ist2;

        /**
         * Interrupt stack table pointer (3).
         */
        UINT64 Ist3;

        /**
         * Interrupt stack table pointer (4).
         */
        UINT64 Ist4;

        /**
         * Interrupt stack table pointer (5).
         */
        UINT64 Ist5;

        /**
         * Interrupt stack table pointer (6).
         */
        UINT64 Ist6;

        /**
         * Interrupt stack table pointer (7).
         */
        UINT64 Ist7;

        /**
         * Reserved bits. Set to 0.
         */
        UINT64 Reserved2;

        /**
         * Reserved bits. Set to 0.
         */
        UINT16 Reserved3;

        /**
         * The 16-bit offset to the I/O permission bit map from the 64-bit TSS base.
         */
        UINT16 IoMapBase;
} TASK_STATE_SEGMENT_64;
#pragma pack(pop)

/**
 * @defgroup VMX \
 *           VMX
 * @{
 */
/**
 * @{
 */
/**
 * @defgroup VMX_BASIC_EXIT_REASONS \
 *           VMX Basic Exit Reasons
 *
 * VMX Basic Exit Reasons.
 *
 * @see Vol3D[C(VMX BASIC EXIT REASONS)] (reference)
 * @{
 */
/**
 * @brief Exception or non-maskable interrupt (NMI)
 *
 * Either:
 * -# Guest software caused an exception and the bit in the exception bitmap associated with
 * exception's vector was 1. This case includes executions of BOUND that cause \#BR, executions of
 * INT1 (they cause \#DB), executions of INT3 (they cause
 * \#BP), executions of INTO that cause \#OF, and executions of UD0, UD1, and UD2 (they cause \#UD).
 * -# An NMI was delivered to the logical processor and the "NMI exiting" VM-execution control
 * was 1.
 */
#define VMX_EXIT_REASON_EXCEPTION_OR_NMI 0x00000000

/**
 * @brief External interrupt
 *
 * An external interrupt arrived and the "external-interrupt exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXTERNAL_INTERRUPT 0x00000001

/**
 * @brief Triple fault
 *
 * The logical processor encountered an exception while attempting to call the double-fault handler
 * and that exception did not itself cause a VM exit due to the exception bitmap.
 */
#define VMX_EXIT_REASON_TRIPLE_FAULT 0x00000002

/**
 * @brief INIT signal
 *
 * An INIT signal arrived.
 */
#define VMX_EXIT_REASON_INIT_SIGNAL 0x00000003

/**
 * @brief Start-up IPI (SIPI)
 *
 * A SIPI arrived while the logical processor was in the "wait-for-SIPI" state.
 */
#define VMX_EXIT_REASON_STARTUP_IPI 0x00000004

/**
 * @brief I/O system-management interrupt (SMI)
 *
 * An SMI arrived immediately after retirement of an I/O instruction and caused an SMM VM exit.
 *
 * @see Vol3C[34.15.2(SMM VM Exits)]
 */
#define VMX_EXIT_REASON_IO_SMI 0x00000005

/**
 * @brief Other SMI
 *
 * An SMI arrived and caused an SMM VM exit but not immediately after retirement of an I/O
 * instruction.
 *
 * @see Vol3C[34.15.2(SMM VM Exits)]
 */
#define VMX_EXIT_REASON_SMI 0x00000006

/**
 * @brief Interrupt window exiting
 *
 * At the beginning of an instruction, RFLAGS.IF was 1; events were not blocked by STI or by MOV SS;
 * and the "interrupt-window exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_INTERRUPT_WINDOW 0x00000007

/**
 * @brief NMI window exiting
 *
 * At the beginning of an instruction, there was no virtual-NMI blocking; events were not blocked by
 * MOV SS; and the "NMI-window exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_NMI_WINDOW 0x00000008

/**
 * @brief Task switch
 *
 * Guest software attempted a task switch.
 */
#define VMX_EXIT_REASON_TASK_SWITCH 0x00000009

/**
 * @brief CPUID
 *
 * Guest software attempted to execute CPUID.
 */
#define VMX_EXIT_REASON_EXECUTE_CPUID 0x0000000A

/**
 * @brief GETSEC
 *
 * Guest software attempted to execute GETSEC.
 */
#define VMX_EXIT_REASON_EXECUTE_GETSEC 0x0000000B

/**
 * @brief HLT
 *
 * Guest software attempted to execute HLT and the "HLT exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_HLT 0x0000000C

/**
 * @brief INVD
 *
 * Guest software attempted to execute INVD.
 */
#define VMX_EXIT_REASON_EXECUTE_INVD 0x0000000D

/**
 * @brief INVLPG
 *
 * Guest software attempted to execute INVLPG and the "INVLPG exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_INVLPG 0x0000000E

/**
 * @brief RDPMC
 *
 * Guest software attempted to execute RDPMC and the "RDPMC exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_RDPMC 0x0000000F

/**
 * @brief RDTSC
 *
 * Guest software attempted to execute RDTSC and the "RDTSC exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_RDTSC 0x00000010

/**
 * @brief RSM in SMM
 *
 * Guest software attempted to execute RSM in SMM.
 */
#define VMX_EXIT_REASON_EXECUTE_RSM_IN_SMM 0x00000011

/**
 * @brief VMCALL
 *
 * VMCALL was executed either by guest software (causing an ordinary VM exit) or by the executive
 * monitor (causing an SMM VM exit).
 *
 * @see Vol3C[34.15.2(SMM VM Exits)]
 */
#define VMX_EXIT_REASON_EXECUTE_VMCALL 0x00000012

/**
 * @brief VMCLEAR
 *
 * Guest software attempted to execute VMCLEAR.
 */
#define VMX_EXIT_REASON_EXECUTE_VMCLEAR 0x00000013

/**
 * @brief VMLAUNCH
 *
 * Guest software attempted to execute VMLAUNCH.
 */
#define VMX_EXIT_REASON_EXECUTE_VMLAUNCH 0x00000014

/**
 * @brief VMPTRLD
 *
 * Guest software attempted to execute VMPTRLD.
 */
#define VMX_EXIT_REASON_EXECUTE_VMPTRLD 0x00000015

/**
 * @brief VMPTRST
 *
 * Guest software attempted to execute VMPTRST.
 */
#define VMX_EXIT_REASON_EXECUTE_VMPTRST 0x00000016

/**
 * @brief VMREAD
 *
 * Guest software attempted to execute VMREAD.
 */
#define VMX_EXIT_REASON_EXECUTE_VMREAD 0x00000017

/**
 * @brief VMRESUME
 *
 * Guest software attempted to execute VMRESUME.
 */
#define VMX_EXIT_REASON_EXECUTE_VMRESUME 0x00000018

/**
 * @brief VMWRITE
 *
 * Guest software attempted to execute VMWRITE.
 */
#define VMX_EXIT_REASON_EXECUTE_VMWRITE 0x00000019

/**
 * @brief VMXOFF
 *
 * Guest software attempted to execute VMXOFF.
 */
#define VMX_EXIT_REASON_EXECUTE_VMXOFF 0x0000001A

/**
 * @brief VMXON
 *
 * Guest software attempted to execute VMXON.
 */
#define VMX_EXIT_REASON_EXECUTE_VMXON 0x0000001B

/**
 * @brief Control-register accesses
 *
 * Guest software attempted to access CR0, CR3, CR4, or CR8 using CLTS, LMSW, or MOV CR and the
 * VM-execution control fields indicate that a VM exit should occur. This basic exit reason is not
 * used for trap-like VM exits following executions of the MOV to CR8 instruction when the "use TPR
 * shadow" VM-execution control is 1. Such VM exits instead use basic exit reason 43.
 *
 * @see Vol3C[25.1(INSTRUCTIONS THAT CAUSE VM EXITS)]
 */
#define VMX_EXIT_REASON_MOV_CR 0x0000001C

/**
 * @brief Debug-register accesses
 *
 * Guest software attempted a MOV to or from a debug register and the "MOV-DR exiting" VM-execution
 * control was 1.
 */
#define VMX_EXIT_REASON_MOV_DR 0x0000001D

/**
 * @brief I/O instruction
 *
 * Guest software attempted to execute an I/O instruction and either:
 * -# The "use I/O bitmaps" VM-execution control was 0 and the "unconditional I/O exiting"
 * VM-execution control was 1.
 * -# The "use I/O bitmaps" VM-execution control was 1 and a bit in the I/O bitmap associated with
 * one of the ports accessed by the I/O instruction was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_IO_INSTRUCTION 0x0000001E

/**
 * @brief RDMSR
 *
 * Guest software attempted to execute RDMSR and either:
 * -# The "use MSR bitmaps" VM-execution control was 0.
 * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H -
 * C0001FFFH.
 * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in read bitmap for low
 * MSRs is 1, where n was the value of RCX.
 * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in read bitmap for high
 * MSRs is 1, where n is the value of RCX & 00001FFFH.
 */
#define VMX_EXIT_REASON_EXECUTE_RDMSR 0x0000001F

/**
 * @brief WRMSR
 *
 * Guest software attempted to execute WRMSR and either:
 * -# The "use MSR bitmaps" VM-execution control was 0.
 * -# The value of RCX is neither in the range 00000000H - 00001FFFH nor in the range C0000000H -
 * C0001FFFH.
 * -# The value of RCX was in the range 00000000H - 00001FFFH and the nth bit in write bitmap for
 * low MSRs is 1, where n was the value of RCX.
 * -# The value of RCX is in the range C0000000H - C0001FFFH and the nth bit in write bitmap for
 * high MSRs is 1, where n is the value of RCX & 00001FFFH.
 */
#define VMX_EXIT_REASON_EXECUTE_WRMSR 0x00000020

/**
 * @brief VM-entry failure due to invalid guest state
 *
 * A VM entry failed one of the checks identified in Section 26.3.1.
 */
#define VMX_EXIT_REASON_ERROR_INVALID_GUEST_STATE 0x00000021

/**
 * @brief VM-entry failure due to MSR loading
 *
 * A VM entry failed in an attempt to load MSRs. See Section 26.4.
 */
#define VMX_EXIT_REASON_ERROR_MSR_LOAD 0x00000022

/**
 * @brief Guest software executed MWAIT
 *
 * Guest software attempted to execute MWAIT and the "MWAIT exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_MWAIT 0x00000024

/**
 * @brief VM-exit due to monitor trap flag
 *
 * A VM entry occurred due to the 1-setting of the "monitor trap flag" VM-execution control and
 * injection of an MTF VM exit as part of VM entry.
 *
 * @see Vol3C[25.5.2(Monitor Trap Flag)]
 */
#define VMX_EXIT_REASON_MONITOR_TRAP_FLAG 0x00000025

/**
 * @brief Guest software attempted to execute MONITOR
 *
 * Guest software attempted to execute MONITOR and the "MONITOR exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_MONITOR 0x00000027

/**
 * @brief Guest software attempted to execute PAUSE
 *
 * Either guest software attempted to execute PAUSE and the "PAUSE exiting" VM-execution control was
 * 1 or the "PAUSE-loop exiting" VM-execution control was 1 and guest software executed a PAUSE loop
 * with execution time exceeding PLE_Window.
 *
 * @see Vol3C[25.1.3(Instructions That Cause VM Exits Conditionally)]
 */
#define VMX_EXIT_REASON_EXECUTE_PAUSE 0x00000028

/**
 * @brief VM-entry failure due to machine-check
 *
 * A machine-check event occurred during VM entry.
 *
 * @see Vol3C[26.8(MACHINE-CHECK EVENTS DURING VM ENTRY)]
 */
#define VMX_EXIT_REASON_ERROR_MACHINE_CHECK 0x00000029

/**
 * @brief TPR below threshold
 *
 * The logical processor determined that the value of bits 7:4 of the byte at offset 080H on the
 * virtual-APIC page was below that of the TPR threshold VM-execution control field while the "use
 * TPR shadow" VMexecution control was 1 either as part of TPR virtualization or VM entry.
 *
 * @see Vol3C[29.1.2(TPR Virtualization)]
 * @see Vol3C[26.6.7(VM Exits Induced by the TPR Threshold)]
 */
#define VMX_EXIT_REASON_TPR_BELOW_THRESHOLD 0x0000002B

/**
 * @brief APIC access
 *
 * Guest software attempted to access memory at a physical address on the APIC-access page and the
 * "virtualize APIC accesses" VM-execution control was 1.
 *
 * @see Vol3C[29.4(VIRTUALIZING MEMORY-MAPPED APIC ACCESSES)]
 */
#define VMX_EXIT_REASON_APIC_ACCESS 0x0000002C

/**
 * @brief Virtualized EOI
 *
 * EOI virtualization was performed for a virtual interrupt whose vector indexed a bit set in the
 * EOIexit bitmap.
 */
#define VMX_EXIT_REASON_VIRTUALIZED_EOI 0x0000002D

/**
 * @brief Access to GDTR or IDTR
 *
 * Guest software attempted to execute LGDT, LIDT, SGDT, or SIDT and the "descriptor-table exiting"
 * VM-execution control was 1.
 */
#define VMX_EXIT_REASON_GDTR_IDTR_ACCESS 0x0000002E

/**
 * @brief Access to LDTR or TR
 *
 * Guest software attempted to execute LLDT, LTR, SLDT, or STR and the "descriptor-table exiting"
 * VM-execution control was 1.
 */
#define VMX_EXIT_REASON_LDTR_TR_ACCESS 0x0000002F

/**
 * @brief EPT violation
 *
 * An attempt to access memory with a guest-physical address was disallowed by the configuration of
 * the EPT paging structures.
 */
#define VMX_EXIT_REASON_EPT_VIOLATION 0x00000030

/**
 * @brief EPT misconfiguration
 *
 * An attempt to access memory with a guest-physical address encountered a misconfigured EPT
 * paging-structure entry.
 */
#define VMX_EXIT_REASON_EPT_MISCONFIGURATION 0x00000031

/**
 * @brief INVEPT
 *
 * Guest software attempted to execute INVEPT.
 */
#define VMX_EXIT_REASON_EXECUTE_INVEPT 0x00000032

/**
 * @brief RDTSCP
 *
 * Guest software attempted to execute RDTSCP and the "enable RDTSCP" and "RDTSC exiting"
 * VM-execution controls were both 1.
 */
#define VMX_EXIT_REASON_EXECUTE_RDTSCP 0x00000033

/**
 * @brief VMX-preemption timer expired
 *
 * The preemption timer counted down to zero.
 */
#define VMX_EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED 0x00000034

/**
 * @brief INVVPID
 *
 * Guest software attempted to execute INVVPID.
 */
#define VMX_EXIT_REASON_EXECUTE_INVVPID 0x00000035

/**
 * @brief WBINVD
 *
 * Guest software attempted to execute WBINVD and the "WBINVD exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_WBINVD 0x00000036

/**
 * @brief XSETBV - Guest software attempted to execute XSETBV
 *
 * Guest software attempted to execute XSETBV.
 */
#define VMX_EXIT_REASON_EXECUTE_XSETBV 0x00000037

/**
 * @brief APIC write
 *
 * Guest software completed a write to the virtual-APIC page that must be virtualized by VMM
 * software.
 *
 * @see Vol3C[29.4.3.3(APIC-Write VM Exits)]
 */
#define VMX_EXIT_REASON_APIC_WRITE 0x00000038

/**
 * @brief RDRAND
 *
 * Guest software attempted to execute RDRAND and the "RDRAND exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_RDRAND 0x00000039

/**
 * @brief INVPCID
 *
 * Guest software attempted to execute INVPCID and the "enable INVPCID" and "INVLPG exiting"
 * VM-execution controls were both 1.
 */
#define VMX_EXIT_REASON_EXECUTE_INVPCID 0x0000003A

/**
 * @brief VMFUNC
 *
 * Guest software invoked a VM function with the VMFUNC instruction and the VM function either was
 * not enabled or generated a function-specific condition causing a VM exit.
 */
#define VMX_EXIT_REASON_EXECUTE_VMFUNC 0x0000003B

/**
 * @brief ENCLS
 *
 * Guest software attempted to execute ENCLS and "enable ENCLS exiting" VM-execution control was 1
 * and either:
 * -# EAX < 63 and the corresponding bit in the ENCLS-exiting bitmap is 1; or
 * -# EAX >= 63 and bit 63 in the ENCLS-exiting bitmap is 1.
 */
#define VMX_EXIT_REASON_EXECUTE_ENCLS 0x0000003C

/**
 * @brief RDSEED
 *
 * Guest software attempted to execute RDSEED and the "RDSEED exiting" VM-execution control was 1.
 */
#define VMX_EXIT_REASON_EXECUTE_RDSEED 0x0000003D

/**
 * @brief Page-modification log full
 *
 * The processor attempted to create a page-modification log entry and the value of the PML index
 * was not in the range 0-511.
 */
#define VMX_EXIT_REASON_PAGE_MODIFICATION_LOG_FULL 0x0000003E

/**
 * @brief XSAVES
 *
 * Guest software attempted to execute XSAVES, the "enable XSAVES/XRSTORS" was 1, and a bit was set
 * in the logical-AND of the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting
 * bitmap.
 */
#define VMX_EXIT_REASON_EXECUTE_XSAVES 0x0000003F

/**
 * @brief XRSTORS
 *
 * Guest software attempted to execute XRSTORS, the "enable XSAVES/XRSTORS" was 1, and a bit was set
 * in the logical-AND of the following three values: EDX:EAX, the IA32_XSS MSR, and the XSS-exiting
 * bitmap.
 */
#define VMX_EXIT_REASON_EXECUTE_XRSTORS 0x00000040
/**
 * @}
 */

/**
 * @defgroup VMX_INSTRUCTION_ERROR_NUMBERS \
 *           VM-Instruction Error Numbers
 *
 * VM-Instruction Error Numbers.
 *
 * @see Vol3C[30.4(VM INSTRUCTION ERROR NUMBERS)] (reference)
 * @{
 */
/**
 * VMCALL executed in VMX root operation.
 */
#define VMX_ERROR_VMCALL_IN_VMX_ROOT_OPERATION 0x00000001

/**
 * VMCLEAR with invalid physical address.
 */
#define VMX_ERROR_VMCLEAR_INVALID_PHYSICAL_ADDRESS 0x00000002

/**
 * VMCLEAR with VMXON pointer.
 */
#define VMX_ERROR_VMCLEAR_INVALID_VMXON_POINTER 0x00000003

/**
 * VMLAUNCH with non-clear VMCS.
 */
#define VMX_ERROR_VMLAUCH_NON_CLEAR_VMCS 0x00000004

/**
 * VMRESUME with non-launched VMCS.
 */
#define VMX_ERROR_VMRESUME_NON_LAUNCHED_VMCS 0x00000005

/**
 * VMRESUME after VMXOFF (VMXOFF and VMXON between VMLAUNCH and VMRESUME).
 */
#define VMX_ERROR_VMRESUME_AFTER_VMXOFF 0x00000006

/**
 * VM entry with invalid control field(s).
 */
#define VMX_ERROR_VMENTRY_INVALID_CONTROL_FIELDS 0x00000007

/**
 * VM entry with invalid host-state field(s).
 */
#define VMX_ERROR_VMENTRY_INVALID_HOST_STATE 0x00000008

/**
 * VMPTRLD with invalid physical address.
 */
#define VMX_ERROR_VMPTRLD_INVALID_PHYSICAL_ADDRESS 0x00000009

/**
 * VMPTRLD with VMXON pointer.
 */
#define VMX_ERROR_VMPTRLD_VMXON_POINTER 0x0000000A

/**
 * VMPTRLD with incorrect VMCS revision identifier.
 */
#define VMX_ERROR_VMPTRLD_INCORRECT_VMCS_REVISION_ID 0x0000000B

/**
 * VMREAD/VMWRITE from/to unsupported VMCS component.
 */
#define VMX_ERROR_VMREAD_VMWRITE_INVALID_COMPONENT 0x0000000C

/**
 * VMWRITE to read-only VMCS component.
 */
#define VMX_ERROR_VMWRITE_READONLY_COMPONENT 0x0000000D

/**
 * VMXON executed in VMX root operation.
 */
#define VMX_ERROR_VMXON_IN_VMX_ROOT_OP 0x0000000F

/**
 * VM entry with invalid executive-VMCS pointer.
 */
#define VMX_ERROR_VMENTRY_INVALID_VMCS_EXECUTIVE_POINTER 0x00000010

/**
 * VM entry with non-launched executive VMCS.
 */
#define VMX_ERROR_VMENTRY_NON_LAUNCHED_EXECUTIVE_VMCS 0x00000011

/**
 * VM entry with executive-VMCS pointer not VMXON pointer (when attempting to deactivate the
 * dual-monitor treatment of SMIs and SMM).
 */
#define VMX_ERROR_VMENTRY_EXECUTIVE_VMCS_PTR 0x00000012

/**
 * VMCALL with non-clear VMCS (when attempting to activate the dual-monitor treatment of SMIs and
 * SMM).
 */
#define VMX_ERROR_VMCALL_NON_CLEAR_VMCS 0x00000013

/**
 * VMCALL with invalid VM-exit control fields.
 */
#define VMX_ERROR_VMCALL_INVALID_VMEXIT_FIELDS 0x00000014

/**
 * VMCALL with incorrect MSEG revision identifier (when attempting to activate the dual-monitor
 * treatment of SMIs and SMM).
 */
#define VMX_ERROR_VMCALL_INVALID_MSEG_REVISION_ID 0x00000016

/**
 * VMXOFF under dual-monitor treatment of SMIs and SMM.
 */
#define VMX_ERROR_VMXOFF_DUAL_MONITOR 0x00000017

/**
 * VMCALL with invalid SMM-monitor features (when attempting to activate the dual-monitor treatment
 * of SMIs and SMM).
 */
#define VMX_ERROR_VMCALL_INVALID_SMM_MONITOR 0x00000018

/**
 * VM entry with invalid VM-execution control fields in executive VMCS (when attempting to return
 * from SMM).
 */
#define VMX_ERROR_VMENTRY_INVALID_VM_EXECUTION_CONTROL 0x00000019

/**
 * VM entry with events blocked by MOV SS.
 */
#define VMX_ERROR_VMENTRY_MOV_SS 0x0000001A

/**
 * Invalid operand to INVEPT/INVVPID.
 */
#define VMX_ERROR_INVEPT_INVVPID_INVALID_OPERAND 0x0000001C
/**
 * @}
 */

/**
 * @defgroup VMX_EXCEPTIONS \
 *           Virtualization Exceptions
 *
 * Virtualization Exceptions.
 *
 * @see Vol3C[25.5.6(Virtualization Exceptions)] (reference)
 * @{
 */
typedef struct
{
        /**
         * The 32-bit value that would have been saved into the VMCS as an exit reason had a VM exit
         * occurred instead of the virtualization exception. For EPT violations, this value is 48
         * (00000030H).
         */
        UINT32 Reason;

        /**
         * FFFFFFFFH
         */
        UINT32 ExceptionMask;

        /**
         * The 64-bit value that would have been saved into the VMCS as an exit qualification had a
         * VM exit occurred instead of the virtualization exception.
         */
        UINT64 Exit;

        /**
         * The 64-bit value that would have been saved into the VMCS as a guest-linear address had a
         * VM exit occurred instead of the virtualization exception.
         */
        UINT64 GuestLinearAddress;

        /**
         * The 64-bit value that would have been saved into the VMCS as a guest-physical address had
         * a VM exit occurred instead of the virtualization exception.
         */
        UINT64 GuestPhysicalAddress;

        /**
         * The current 16-bit value of the EPTP index VM-execution control.
         *
         * @see Vol3C[24.6.18(Controls for Virtualization Exceptions)]
         * @see Vol3C[25.5.5.3(EPTP Switching)]
         */
        UINT16 CurrentEptpIndex;
} VMX_VIRTUALIZATION_EXCEPTION_INFORMATION;

/**
 * @}
 */

/**
 * @defgroup VMX_BASIC_EXIT_INFORMATION \
 *           Basic VM-Exit Information
 *
 * Basic VM-Exit Information.
 *
 * @see Vol3C[27.2.1(Basic VM-Exit Information)] (reference)
 * @{
 */
/**
 * @brief Exit Qualification for Debug Exceptions
 */
typedef union
{
        struct
        {
                /**
                 * @brief B0 - B3
                 *
                 * [Bits 3:0] When set, each of these bits indicates that the corresponding
                 * breakpoint condition was met. Any of these bits may be set even if its
                 * corresponding enabling bit in DR7 is not set.
                 */
                UINT64 BreakpointCondition : 4;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_BIT  0
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_FLAG 0x0F
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_BREAKPOINT_CONDITION(_)   (((_) >> 0) & 0x0F)
                UINT64 Reserved1 : 9;

                /**
                 * @brief BD
                 *
                 * [Bit 13] When set, this bit indicates that the cause of the debug exception is
                 * "debug register access detected."
                 */
                UINT64 DebugRegisterAccessDetected : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_BIT  13
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_FLAG 0x2000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_DEBUG_REGISTER_ACCESS_DETECTED(_) \
        (((_) >> 13) & 0x01)

                /**
                 * @brief BS
                 *
                 * [Bit 14] When set, this bit indicates that the cause of the debug exception is
                 * either the execution of a single instruction (if RFLAGS.TF = 1 and
                 * IA32_DEBUGCTL.BTF = 0) or a taken branch (if RFLAGS.TF = DEBUGCTL.BTF = 1).
                 */
                UINT64 SingleInstruction : 1;
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_BIT  14
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_FLAG 0x4000
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION_SINGLE_INSTRUCTION(_)   (((_) >> 14) & 0x01)
                UINT64 Reserved2 : 49;
        };

        UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_DEBUG_EXCEPTION;

/**
 * @brief Exit Qualification for Task Switch
 */
typedef union
{
        struct
        {
                /**
                 * [Bits 15:0] Selector of task-state segment (TSS) to which the guest attempted to
                 * switch.
                 */
                UINT64 Selector : 16;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_BIT  0
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_FLAG 0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR_MASK 0xFFFF
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SELECTOR(_)   (((_) >> 0) & 0xFFFF)
                UINT64 Reserved1 : 14;

                /**
                 * [Bits 31:30] Source of task switch initiation.
                 */
                UINT64 Source : 2;
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_BIT  30
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_FLAG 0xC0000000
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE_MASK 0x03
#define VMX_EXIT_QUALIFICATION_TASK_SWITCH_SOURCE(_)   (((_) >> 30) & 0x03)
#define VMX_EXIT_QUALIFICATION_TYPE_CALL_INSTRUCTION   0x00000000
#define VMX_EXIT_QUALIFICATION_TYPE_IRET_INSTRUCTION   0x00000001
#define VMX_EXIT_QUALIFICATION_TYPE_JMP_INSTRUCTION    0x00000002
#define VMX_EXIT_QUALIFICATION_TYPE_TASK_GATE_IN_IDT   0x00000003
                UINT64 Reserved2 : 32;
        };

        UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_TASK_SWITCH;

/**
 * @brief Exit Qualification for Control-Register Accesses
 */
typedef union
{
        struct
        {
                /**
                 * [Bits 3:0] Number of control register (0 for CLTS and LMSW). Bit 3 is always 0 on
                 * processors that do not support Intel 64 architecture as they do not support CR8.
                 */
                UINT64 ControlRegister : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_BIT  0
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_FLAG 0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_CONTROL_REGISTER(_)   (((_) >> 0) & 0x0F)
#define VMX_EXIT_QUALIFICATION_REGISTER_CR0                 0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_CR2                 0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_CR3                 0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_CR4                 0x00000004
#define VMX_EXIT_QUALIFICATION_REGISTER_CR8                 0x00000008

                /**
                 * [Bits 5:4] Access type.
                 */
                UINT64 AccessType : 2;
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_BIT  4
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_FLAG 0x30
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE_MASK 0x03
#define VMX_EXIT_QUALIFICATION_MOV_CR_ACCESS_TYPE(_)   (((_) >> 4) & 0x03)
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_TO_CR        0x00000000
#define VMX_EXIT_QUALIFICATION_ACCESS_MOV_FROM_CR      0x00000001
#define VMX_EXIT_QUALIFICATION_ACCESS_CLTS             0x00000002
#define VMX_EXIT_QUALIFICATION_ACCESS_LMSW             0x00000003

                /**
                 * [Bit 6] LMSW operand type. For CLTS and MOV CR, cleared to 0.
                 */
                UINT64 LmswOperandType : 1;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_BIT  6
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_FLAG 0x40
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_OPERAND_TYPE(_)   (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_LMSW_OP_REGISTER              0x00000000
#define VMX_EXIT_QUALIFICATION_LMSW_OP_MEMORY                0x00000001
                UINT64 Reserved1 : 1;

                /**
                 * [Bits 11:8] For MOV CR, the general-purpose register.
                 */
                UINT64 GeneralPurposeRegister : 4;
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_BIT  8
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_FLAG 0xF00
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_MOV_CR_GENERAL_PURPOSE_REGISTER(_)   (((_) >> 8) & 0x0F)
#define VMX_EXIT_QUALIFICATION_GENREG_RAX                           0x00000000
#define VMX_EXIT_QUALIFICATION_GENREG_RCX                           0x00000001
#define VMX_EXIT_QUALIFICATION_GENREG_RDX                           0x00000002
#define VMX_EXIT_QUALIFICATION_GENREG_RBX                           0x00000003
#define VMX_EXIT_QUALIFICATION_GENREG_RSP                           0x00000004
#define VMX_EXIT_QUALIFICATION_GENREG_RBP                           0x00000005
#define VMX_EXIT_QUALIFICATION_GENREG_RSI                           0x00000006
#define VMX_EXIT_QUALIFICATION_GENREG_RDI                           0x00000007
#define VMX_EXIT_QUALIFICATION_GENREG_R8                            0x00000008
#define VMX_EXIT_QUALIFICATION_GENREG_R9                            0x00000009
#define VMX_EXIT_QUALIFICATION_GENREG_R10                           0x0000000A
#define VMX_EXIT_QUALIFICATION_GENREG_R11                           0x0000000B
#define VMX_EXIT_QUALIFICATION_GENREG_R12                           0x0000000C
#define VMX_EXIT_QUALIFICATION_GENREG_R13                           0x0000000D
#define VMX_EXIT_QUALIFICATION_GENREG_R14                           0x0000000E
#define VMX_EXIT_QUALIFICATION_GENREG_R15                           0x0000000F
                UINT64 Reserved2 : 4;

                /**
                 * [Bits 31:16] For LMSW, the LMSW source data. For CLTS and MOV CR, cleared to 0.
                 */
                UINT64 LmswSourceData : 16;
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_BIT  16
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_FLAG 0xFFFF0000
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA_MASK 0xFFFF
#define VMX_EXIT_QUALIFICATION_MOV_CR_LMSW_SOURCE_DATA(_)   (((_) >> 16) & 0xFFFF)
                UINT64 Reserved3 : 32;
        };

        UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_MOV_CR;

/**
 * @brief Exit Qualification for MOV DR
 */
typedef union
{
        struct
        {
                /**
                 * [Bits 2:0] Number of debug register.
                 */
                UINT64 DebugRegister : 3;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_BIT  0
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_FLAG 0x07
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER_MASK 0x07
#define VMX_EXIT_QUALIFICATION_MOV_DR_DEBUG_REGISTER(_)   (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_REGISTER_DR0               0x00000000
#define VMX_EXIT_QUALIFICATION_REGISTER_DR1               0x00000001
#define VMX_EXIT_QUALIFICATION_REGISTER_DR2               0x00000002
#define VMX_EXIT_QUALIFICATION_REGISTER_DR3               0x00000003
#define VMX_EXIT_QUALIFICATION_REGISTER_DR6               0x00000006
#define VMX_EXIT_QUALIFICATION_REGISTER_DR7               0x00000007
                UINT64 Reserved1 : 1;

                /**
                 * [Bit 4] Direction of access (0 = MOV to DR; 1 = MOV from DR).
                 */
                UINT64 DirectionOfAccess : 1;
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_BIT  4
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_FLAG 0x10
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_MOV_DR_DIRECTION_OF_ACCESS(_)   (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_TO_DR             0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_MOV_FROM_DR           0x00000001
                UINT64 Reserved2 : 3;

                /**
                 * [Bits 11:8] General-purpose register.
                 */
                UINT64 GeneralPurposeRegister : 4;
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_BIT  8
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_FLAG 0xF00
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_MOV_DR_GENERAL_PURPOSE_REGISTER(_)   (((_) >> 8) & 0x0F)
                UINT64 Reserved3 : 52;
        };

        UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_MOV_DR;

/**
 * @brief Exit Qualification for I/O Instructions
 */
typedef union
{
        struct
        {
                /**
                 * [Bits 2:0] Size of access.
                 */
                UINT64 SizeOfAccess : 3;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_BIT  0
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_FLAG 0x07
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS_MASK 0x07
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_SIZE_OF_ACCESS(_)   (((_) >> 0) & 0x07)
#define VMX_EXIT_QUALIFICATION_WIDTH_1_BYTE                       0x00000000
#define VMX_EXIT_QUALIFICATION_WIDTH_2_BYTE                       0x00000001
#define VMX_EXIT_QUALIFICATION_WIDTH_4_BYTE                       0x00000003

                /**
                 * [Bit 3] Direction of the attempted access (0 = OUT, 1 = IN).
                 */
                UINT64 DirectionOfAccess : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_BIT  3
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_FLAG 0x08
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_DIRECTION_OF_ACCESS(_)   (((_) >> 3) & 0x01)
#define VMX_EXIT_QUALIFICATION_DIRECTION_OUT                           0x00000000
#define VMX_EXIT_QUALIFICATION_DIRECTION_IN                            0x00000001

                /**
                 * [Bit 4] String instruction (0 = not string; 1 = string).
                 */
                UINT64 StringInstruction : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_BIT  4
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_FLAG 0x10
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_STRING_INSTRUCTION(_)   (((_) >> 4) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_STRING_NOT_STRING                   0x00000000
#define VMX_EXIT_QUALIFICATION_IS_STRING_STRING                       0x00000001

                /**
                 * [Bit 5] REP prefixed (0 = not REP; 1 = REP).
                 */
                UINT64 RepPrefixed : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_BIT  5
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_FLAG 0x20
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_REP_PREFIXED(_)   (((_) >> 5) & 0x01)
#define VMX_EXIT_QUALIFICATION_IS_REP_NOT_REP                   0x00000000
#define VMX_EXIT_QUALIFICATION_IS_REP_REP                       0x00000001

                /**
                 * [Bit 6] Operand encoding (0 = DX, 1 = immediate).
                 */
                UINT64 OperandEncoding : 1;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_BIT  6
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_FLAG 0x40
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING_MASK 0x01
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_OPERAND_ENCODING(_)   (((_) >> 6) & 0x01)
#define VMX_EXIT_QUALIFICATION_ENCODING_DX                          0x00000000
#define VMX_EXIT_QUALIFICATION_ENCODING_IMMEDIATE                   0x00000001
                UINT64 Reserved1 : 9;

                /**
                 * [Bits 31:16] Port number (as specified in DX or in an immediate operand).
                 */
                UINT64 PortNumber : 16;
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_BIT  16
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_FLAG 0xFFFF0000
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER_MASK 0xFFFF
#define VMX_EXIT_QUALIFICATION_IO_INSTRUCTION_PORT_NUMBER(_)   (((_) >> 16) & 0xFFFF)
                UINT64 Reserved2 : 32;
        };

        UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_IO_INSTRUCTION;

/**
 * @brief Exit Qualification for APIC-Access VM Exits from Linear Accesses and Guest-Physical
 * Accesses
 */
typedef union
{
        struct
        {
                /**
                 * [Bits 11:0] - If the APIC-access VM exit is due to a linear access, the offset of
                 * access within the APIC page.
                 * - Undefined if the APIC-access VM exit is due a guest-physical access.
                 */
                UINT64 PageOffset : 12;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_BIT  0
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_FLAG 0xFFF
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET_MASK 0xFFF
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_PAGE_OFFSET(_)   (((_) >> 0) & 0xFFF)

                /**
                 * [Bits 15:12] Access type.
                 */
                UINT64 AccessType : 4;
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_BIT  12
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_FLAG 0xF000
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE_MASK 0x0F
#define VMX_EXIT_QUALIFICATION_APIC_ACCESS_ACCESS_TYPE(_)   (((_) >> 12) & 0x0F)
                /**
                 * Linear access for a data read during instruction execution.
                 */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_READ 0x00000000

                /**
                 * Linear access for a data write during instruction execution.
                 */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_WRITE 0x00000001

                /**
                 * Linear access for an instruction fetch.
                 */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_INSTRUCTION_FETCH 0x00000002

                /**
                 * Linear access (read or write) during event delivery.
                 */
#define VMX_EXIT_QUALIFICATION_TYPE_LINEAR_EVENT_DELIVERY 0x00000003

                /**
                 * Guest-physical access during event delivery.
                 */
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_EVENT_DELIVERY 0x0000000A

                /**
                 * Guest-physical access for an instruction fetch or during instruction execution.
                 */
#define VMX_EXIT_QUALIFICATION_TYPE_PHYSICAL_INSTRUCTION_FETCH 0x0000000F
                UINT64 Reserved1 : 48;
        };

        UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_APIC_ACCESS;

/**
 * @brief Exit Qualification for EPT Violations
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Set if the access causing the EPT violation was a data read.
                 */
                UINT64 ReadAccess : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_BIT  0
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_FLAG 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READ_ACCESS(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Set if the access causing the EPT violation was a data write.
                 */
                UINT64 WriteAccess : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_BIT  1
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_FLAG 0x02
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_WRITE_ACCESS(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] Set if the access causing the EPT violation was an instruction fetch.
                 */
                UINT64 ExecuteAccess : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_BIT  2
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_FLAG 0x04
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_ACCESS(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] The logical-AND of bit 0 in the EPT paging-structure entries used to
                 * translate the guest-physical address of the access causing the EPT violation
                 * (indicates whether the guest-physical address was readable).
                 */
                UINT64 EptReadable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_BIT  3
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_FLAG 0x08
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_READABLE(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] The logical-AND of bit 1 in the EPT paging-structure entries used to
                 * translate the guest-physical address of the access causing the EPT violation
                 * (indicates whether the guest-physical address was writeable).
                 */
                UINT64 EptWriteable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_BIT  4
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_FLAG 0x10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_WRITEABLE(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] The logical-AND of bit 2 in the EPT paging-structure entries used to
                 * translate the guest-physical address of the access causing the EPT violation. If
                 * the "mode-based execute control for EPT" VM-execution control is 0, this
                 * indicates whether the guest-physical address was executable. If that control is
                 * 1, this indicates whether the guest-physical address was executable for
                 * supervisor-mode linear addresses.
                 */
                UINT64 EptExecutable : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_BIT  5
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FLAG 0x20
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] If the "mode-based execute control" VM-execution control is 0, the value
                 * of this bit is undefined. If that control is 1, this bit is the logical-AND of
                 * bit 10 in the EPT paging-structures entries used to translate the guest-physical
                 * address of the access causing the EPT violation. In this case, it indicates
                 * whether the guest-physical address was executable for user-mode linear addresses.
                 */
                UINT64 EptExecutableForUserMode : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_BIT  6
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_FLAG 0x40
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EPT_EXECUTABLE_FOR_USER_MODE(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] Set if the guest linear-address field is valid. The guest linear-address
                 * field is valid for all EPT violations except those resulting from an attempt to
                 * load the guest PDPTEs as part of the execution of the MOV CR instruction.
                 */
                UINT64 ValidGuestLinearAddress : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_BIT  7
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_FLAG 0x80
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_VALID_GUEST_LINEAR_ADDRESS(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] If bit 7 is 1:
                 * - Set if the access causing the EPT violation is to a guest-physical address that
                 * is the translation of a linear address.
                 * - Clear if the access causing the EPT violation is to a paging-structure entry as
                 * part of a page walk or the update of an accessed or dirty bit. Reserved if bit 7
                 * is 0 (cleared to 0).
                 */
                UINT64 CausedByTranslation : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_BIT  8
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_FLAG 0x100
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_CAUSED_BY_TRANSLATION(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bit 9] This bit is 0 if the linear address is a supervisor-mode linear address
                 * and 1 if it is a user-mode linear address. Otherwise, this bit is undefined.
                 *
                 * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit
                 * information for EPT violations. (If CR0.PG = 0, the translation of every linear
                 * address is a user-mode linear address and thus this bit will be 1.)
                 */
                UINT64 UserModeLinearAddress : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_BIT  9
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_FLAG 0x200
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_USER_MODE_LINEAR_ADDRESS(_)   (((_) >> 9) & 0x01)

                /**
                 * [Bit 10] This bit is 0 if paging translates the linear address to a read-only
                 * page and 1 if it translates to a read/write page. Otherwise, this bit is
                 * undefined
                 *
                 * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit
                 * information for EPT violations. (If CR0.PG = 0, every linear address is
                 * read/write and thus this bit will be 1.)
                 */
                UINT64 ReadableWritablePage : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_BIT  10
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_FLAG 0x400
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_READABLE_WRITABLE_PAGE(_)   (((_) >> 10) & 0x01)

                /**
                 * [Bit 11] This bit is 0 if paging translates the linear address to an executable
                 * page and 1 if it translates to an execute-disable page. Otherwise, this bit is
                 * undefined.
                 *
                 * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit
                 * information for EPT violations. (If CR0.PG = 0, CR4.PAE = 0, or IA32_EFER.NXE =
                 * 0, every linear address is executable and thus this bit will be 0.)
                 */
                UINT64 ExecuteDisablePage : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_BIT  11
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_FLAG 0x800
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_EXECUTE_DISABLE_PAGE(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bit 12] NMI unblocking due to IRET.
                 */
                UINT64 NmiUnblocking : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_BIT  12
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_FLAG 0x1000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_NMI_UNBLOCKING(_)   (((_) >> 12) & 0x01)

                /**
                 * [Bit 13] Set if the access causing the EPT violation was a shadow-stack access.
                 */
                UINT64 ShadowStackAccess : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS_BIT  13
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS_FLAG 0x2000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SHADOW_STACK_ACCESS(_)   (((_) >> 13) & 0x01)

                /**
                 * [Bit 14] If supervisor shadow-stack control is enabled (by setting bit 7 of
                 * EPTP), this bit is the same as bit 60 in the EPT paging-structure entry that maps
                 * the page of the guest-physical address of the access causing the EPT violation.
                 * Otherwise (or if translation of the guest-physical address terminates before
                 * reaching an EPT paging-structure entry that maps a page), this bit is undefined.
                 */
                UINT64 SupervisorShadowStack : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK_BIT  14
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK_FLAG 0x4000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_SUPERVISOR_SHADOW_STACK(_)   (((_) >> 14) & 0x01)

                /**
                 * [Bit 15] This bit is set if the EPT violation was caused as a result of
                 * guest-paging verification.
                 */
                UINT64 GuestPagingVerification : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION_BIT  15
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION_FLAG 0x8000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_GUEST_PAGING_VERIFICATION(_)   (((_) >> 15) & 0x01)

                /**
                 * [Bit 16] This bit is set if the access was asynchronous to instruction execution
                 * not the result of event delivery. (The bit is set if the access is related to
                 * trace output by Intel PT; see Section 25.5.4.) Otherwise, this bit is cleared.
                 */
                UINT64 AsynchronousToInstruction : 1;
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION_BIT  16
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION_FLAG 0x10000
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION_MASK 0x01
#define VMX_EXIT_QUALIFICATION_EPT_VIOLATION_ASYNCHRONOUS_TO_INSTRUCTION(_)   (((_) >> 16) & 0x01)
                UINT64 Reserved1 : 47;
        };

        UINT64 AsUInt;
} VMX_EXIT_QUALIFICATION_EPT_VIOLATION;

/**
 * @}
 */

/**
 * @defgroup VMX_VMEXIT_INSTRUCTION_INFORMATION \
 *           Information for VM Exits Due to Instruction Execution
 *
 * Information for VM Exits Due to Instruction Execution.
 *
 * @see Vol3C[27.2.4(Information for VM Exits Due to Instruction Execution)] (reference)
 * @{
 */
/**
 * @brief VM-Exit Instruction-Information Field as Used for INS and OUTS
 */
typedef union
{
        struct
        {
                UINT64 Reserved1 : 7;

                /**
                 * @brief Address size
                 *
                 * [Bits 9:7] 0: 16-bit
                 * 1: 32-bit
                 * 2: 64-bit (used only on processors that support Intel 64 architecture)
                 * Other values not used.
                 */
                UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)
                UINT64 Reserved2 : 5;

                /**
                 * @brief Segment register
                 *
                 * [Bits 17:15] 0: ES
                 * 1: CS
                 * 2: SS
                 * 3: DS
                 * 4: FS
                 * 5: GS
                 * Other values not used. Undefined for VM exits due to execution of INS.
                 */
                UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_BIT  15
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS_SEGMENT_REGISTER(_)   (((_) >> 15) & 0x07)
                UINT64 Reserved3 : 46;
        };

        UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_INS_OUTS;

/**
 * @brief VM-Exit Instruction-Information Field as Used for INVEPT, INVPCID, and INVVPID
 */
typedef union
{
        struct
        {
                /**
                 * @brief Scaling
                 *
                 * [Bits 1:0] 0: no scaling
                 * 1: scale by 2
                 * 2: scale by 4
                 * 3: scale by 8 (used only on processors that support Intel 64 architecture)
                 * Undefined for instructions with no index register (bit 22 is set).
                 */
                UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_BIT  0
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_FLAG 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SCALING(_)   (((_) >> 0) & 0x03)
                UINT64 Reserved1 : 5;

                /**
                 * @brief Address size
                 *
                 * [Bits 9:7] 0: 16-bit
                 * 1: 32-bit
                 * 2: 64-bit (used only on processors that support Intel 64 architecture)
                 * Other values not used.
                 */
                UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)
                UINT64 Reserved2 : 5;

                /**
                 * @brief Segment register
                 *
                 * [Bits 17:15] 0: ES
                 * 1: CS
                 * 2: SS
                 * 3: DS
                 * 4: FS
                 * 5: GS
                 * Other values not used. Undefined for VM exits due to execution of INS.
                 */
                UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_BIT  15
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_SEGMENT_REGISTER(_)   (((_) >> 15) & 0x07)

                /**
                 * [Bits 21:18] General-purpose register. Undefined for instructions with no index
                 * register (bit 22 is set).
                 */
                UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_BIT  18
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER(_)   (((_) >> 18) & 0x0F)

                /**
                 * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
                 */
                UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_BIT  22
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_GENERAL_PURPOSE_REGISTER_INVALID(_) \
        (((_) >> 22) & 0x01)

                /**
                 * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory
                 * instructions with no base register (bit 27 is set).
                 */
                UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_BIT  23
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER(_)   (((_) >> 23) & 0x0F)

                /**
                 * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
                 */
                UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_BIT  27
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_BASE_REGISTER_INVALID(_)   (((_) >> 27) & 0x01)

                /**
                 * [Bits 31:28] Reg2 (same encoding as IndexReg above).
                 */
                UINT64 Register2 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_BIT  28
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_FLAG 0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE_REGISTER_2(_)   (((_) >> 28) & 0x0F)
                UINT64 Reserved3 : 32;
        };

        UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_INVALIDATE;

/**
 * @brief VM-Exit Instruction-Information Field as Used for LIDT, LGDT, SIDT, or SGDT
 */
typedef union
{
        struct
        {
                /**
                 * @brief Scaling
                 *
                 * [Bits 1:0] 0: no scaling
                 * 1: scale by 2
                 * 2: scale by 4
                 * 3: scale by 8 (used only on processors that support Intel 64 architecture)
                 * Undefined for instructions with no index register (bit 22 is set).
                 */
                UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_BIT  0
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_FLAG 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SCALING(_)   (((_) >> 0) & 0x03)
                UINT64 Reserved1 : 5;

                /**
                 * @brief Address size
                 *
                 * [Bits 9:7] 0: 16-bit
                 * 1: 32-bit
                 * 2: 64-bit (used only on processors that support Intel 64 architecture)
                 * Other values not used.
                 */
                UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)
                UINT64 Reserved2 : 1;

                /**
                 * @brief Operand size
                 *
                 * [Bit 11] 0: 16-bit
                 * 1: 32-bit
                 * Undefined for VM exits from 64-bit mode.
                 */
                UINT64 OperandSize : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_BIT  11
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_FLAG 0x800
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_OPERAND_SIZE(_)   (((_) >> 11) & 0x01)
                UINT64 Reserved3 : 3;

                /**
                 * @brief Segment register
                 *
                 * [Bits 17:15] 0: ES
                 * 1: CS
                 * 2: SS
                 * 3: DS
                 * 4: FS
                 * 5: GS
                 * Other values not used.
                 */
                UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_BIT  15
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_SEGMENT_REGISTER(_)   (((_) >> 15) & 0x07)

                /**
                 * [Bits 21:18] General-purpose register. Undefined for instructions with no index
                 * register (bit 22 is set).
                 */
                UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT  18
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER(_) \
        (((_) >> 18) & 0x0F)

                /**
                 * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
                 */
                UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT  22
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) \
        (((_) >> 22) & 0x01)

                /**
                 * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory
                 * instructions with no base register (bit 27 is set).
                 */
                UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_BIT  23
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER(_)   (((_) >> 23) & 0x0F)

                /**
                 * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
                 */
                UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_BIT  27
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_BASE_REGISTER_INVALID(_)   (((_) >> 27) & 0x01)

                /**
                 * @brief Instruction identity
                 *
                 * [Bits 29:28] 0: SGDT
                 * 1: SIDT
                 * 2: LGDT
                 * 3: LIDT
                 */
                UINT64 Instruction : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_BIT  28
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_FLAG 0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS_INSTRUCTION(_)   (((_) >> 28) & 0x03)
                UINT64 Reserved4 : 34;
        };

        UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_GDTR_IDTR_ACCESS;

/**
 * @brief VM-Exit Instruction-Information Field as Used for LLDT, LTR, SLDT, and STR
 */
typedef union
{
        struct
        {
                /**
                 * @brief Scaling
                 *
                 * [Bits 1:0] 0: no scaling
                 * 1: scale by 2
                 * 2: scale by 4
                 * 3: scale by 8 (used only on processors that support Intel 64 architecture)
                 * Undefined for instructions with no index register (bit 22 is set).
                 */
                UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_BIT  0
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_FLAG 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SCALING(_)   (((_) >> 0) & 0x03)
                UINT64 Reserved1 : 1;

                /**
                 * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
                 */
                UINT64 Reg1 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_BIT  3
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_FLAG 0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_REG_1(_)   (((_) >> 3) & 0x0F)

                /**
                 * @brief Address size
                 *
                 * [Bits 9:7] 0: 16-bit
                 * 1: 32-bit
                 * 2: 64-bit (used only on processors that support Intel 64 architecture)
                 * Other values not used. Undefined for register instructions (bit 10 is set).
                 */
                UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)

                /**
                 * [Bit 10] Mem/Reg (0 = memory; 1 = register).
                 */
                UINT64 MemoryRegister : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_BIT  10
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_MEMORY_REGISTER(_)   (((_) >> 10) & 0x01)
                UINT64 Reserved2 : 4;

                /**
                 * @brief Segment register
                 *
                 * [Bits 17:15] 0: ES
                 * 1: CS
                 * 2: SS
                 * 3: DS
                 * 4: FS
                 * 5: GS
                 * Other values not used. Undefined for register instructions (bit 10 is set).
                 */
                UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_BIT  15
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_SEGMENT_REGISTER(_)   (((_) >> 15) & 0x07)

                /**
                 * [Bits 21:18] General-purpose register. Undefined for register instructions (bit
                 * 10 is set) and for memory instructions with no index register (bit 10 is clear
                 * and bit 22 is set).
                 */
                UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_BIT  18
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER(_)   (((_) >> 18) & 0x0F)

                /**
                 * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register
                 * instructions (bit 10 is set).
                 */
                UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_BIT  22
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_GENERAL_PURPOSE_REGISTER_INVALID(_) \
        (((_) >> 22) & 0x01)

                /**
                 * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for register
                 * instructions (bit 10 is set) and for memory instructions with no base register
                 * (bit 10 is clear and bit 27 is set).
                 */
                UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_BIT  23
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER(_)   (((_) >> 23) & 0x0F)

                /**
                 * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid). Undefined for register
                 * instructions (bit 10 is set).
                 */
                UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_BIT  27
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_BASE_REGISTER_INVALID(_)   (((_) >> 27) & 0x01)

                /**
                 * @brief Instruction identity
                 *
                 * [Bits 29:28] 0: SLDT
                 * 1: STR
                 * 2: LLDT
                 * 3: LTR
                 */
                UINT64 Instruction : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_BIT  28
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_FLAG 0x30000000
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS_INSTRUCTION(_)   (((_) >> 28) & 0x03)
                UINT64 Reserved3 : 34;
        };

        UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_LDTR_TR_ACCESS;

/**
 * @brief VM-Exit Instruction-Information Field as Used for RDRAND and RDSEED
 */
typedef union
{
        struct
        {
                UINT64 Reserved1 : 3;

                /**
                 * [Bits 6:3] Destination register.
                 */
                UINT64 DestinationRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_BIT  3
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_FLAG 0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_DESTINATION_REGISTER(_)   (((_) >> 3) & 0x0F)
                UINT64 Reserved2 : 4;

                /**
                 * @brief Operand size
                 *
                 * [Bits 12:11] 0: 16-bit
                 * 1: 32-bit
                 * 2: 64-bit
                 * The value 3 is not used.
                 */
                UINT64 OperandSize : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_BIT  11
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_FLAG 0x1800
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED_OPERAND_SIZE(_)   (((_) >> 11) & 0x03)
                UINT64 Reserved3 : 51;
        };

        UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_RDRAND_RDSEED;

/**
 * @brief VM-Exit Instruction-Information Field as Used for VMCLEAR, VMPTRLD, VMPTRST, VMXON,
 * XRSTORS, and XSAVES
 */
typedef union
{
        struct
        {
                /**
                 * @brief Scaling
                 *
                 * [Bits 1:0] 0: no scaling
                 * 1: scale by 2
                 * 2: scale by 4
                 * 3: scale by 8 (used only on processors that support Intel 64 architecture)
                 * Undefined for instructions with no index register (bit 22 is set).
                 */
                UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_BIT  0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_FLAG 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SCALING(_)   (((_) >> 0) & 0x03)
                UINT64 Reserved1 : 5;

                /**
                 * @brief Address size
                 *
                 * [Bits 9:7] 0: 16-bit
                 * 1: 32-bit
                 * 2: 64-bit (used only on processors that support Intel 64 architecture)
                 * Other values not used.
                 */
                UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)
                UINT64 Reserved2 : 5;

                /**
                 * @brief Segment register
                 *
                 * [Bits 17:15] 0: ES
                 * 1: CS
                 * 2: SS
                 * 3: DS
                 * 4: FS
                 * 5: GS
                 * Other values not used.
                 */
                UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_BIT  15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_SEGMENT_REGISTER(_)   (((_) >> 15) & 0x07)

                /**
                 * [Bits 21:18] General-purpose register. Undefined for instructions with no index
                 * register (bit 22 is set).
                 */
                UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_BIT  18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER(_)   (((_) >> 18) & 0x0F)

                /**
                 * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid).
                 */
                UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_BIT  22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_GENERAL_PURPOSE_REGISTER_INVALID(_) \
        (((_) >> 22) & 0x01)

                /**
                 * [Bits 26:23] BaseReg (encoded as IndexReg above). Undefined for memory
                 * instructions with no base register (bit 27 is set).
                 */
                UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_BIT  23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER(_)   (((_) >> 23) & 0x0F)

                /**
                 * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
                 */
                UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_BIT  27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES_BASE_REGISTER_INVALID(_)   (((_) >> 27) & 0x01)
                UINT64 Reserved3 : 36;
        };

        UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_VMX_AND_XSAVES;

/**
 * @brief VM-Exit Instruction-Information Field as Used for VMREAD and VMWRITE
 */
typedef union
{
        struct
        {
                /**
                 * @brief Scaling
                 *
                 * [Bits 1:0] 0: no scaling
                 * 1: scale by 2
                 * 2: scale by 4
                 * 3: scale by 8 (used only on processors that support Intel 64 architecture)
                 * Undefined for register instructions (bit 10 is set) and for memory instructions
                 * with no index register (bit 10 is clear and bit 22 is set).
                 */
                UINT64 Scaling : 2;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_BIT  0
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_FLAG 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING_MASK 0x03
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SCALING(_)   (((_) >> 0) & 0x03)
                UINT64 Reserved1 : 1;

                /**
                 * [Bits 6:3] Reg1. Undefined for memory instructions (bit 10 is clear).
                 */
                UINT64 Register1 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_BIT  3
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_FLAG 0x78
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_1(_)   (((_) >> 3) & 0x0F)

                /**
                 * @brief Address size
                 *
                 * [Bits 9:7] 0: 16-bit
                 * 1: 32-bit
                 * 2: 64-bit (used only on processors that support Intel 64 architecture)
                 * Other values not used. Undefined for register instructions (bit 10 is set).
                 */
                UINT64 AddressSize : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_BIT  7
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_FLAG 0x380
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_ADDRESS_SIZE(_)   (((_) >> 7) & 0x07)

                /**
                 * [Bit 10] Mem/Reg (0 = memory; 1 = register).
                 */
                UINT64 MemoryRegister : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_BIT  10
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_FLAG 0x400
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_MEMORY_REGISTER(_)   (((_) >> 10) & 0x01)
                UINT64 Reserved2 : 4;

                /**
                 * @brief Segment register
                 *
                 * [Bits 17:15] 0: ES
                 * 1: CS
                 * 2: SS
                 * 3: DS
                 * 4: FS
                 * 5: GS
                 * Other values not used. Undefined for register instructions (bit 10 is set).
                 */
                UINT64 SegmentRegister : 3;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_BIT  15
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_FLAG 0x38000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER_MASK 0x07
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_SEGMENT_REGISTER(_)   (((_) >> 15) & 0x07)

                /**
                 * [Bits 21:18] General-purpose register. Undefined for register instructions (bit
                 * 10 is set) and for memory instructions with no index register (bit 10 is clear
                 * and bit 22 is set).
                 */
                UINT64 GeneralPurposeRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_BIT  18
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_FLAG 0x3C0000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER(_)   (((_) >> 18) & 0x0F)

                /**
                 * [Bit 22] IndexReg invalid (0 = valid; 1 = invalid). Undefined for register
                 * instructions (bit 10 is set).
                 */
                UINT64 GeneralPurposeRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_BIT  22
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_FLAG 0x400000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_GENERAL_PURPOSE_REGISTER_INVALID(_) \
        (((_) >> 22) & 0x01)

                /**
                 * [Bits 26:23] BaseReg (encoded as Reg1 above). Undefined for register instructions
                 * (bit 10 is set) and for memory instructions with no base register (bit 10 is
                 * clear and bit 27 is set).
                 */
                UINT64 BaseRegister : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_BIT  23
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_FLAG 0x7800000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER(_)   (((_) >> 23) & 0x0F)

                /**
                 * [Bit 27] BaseReg invalid (0 = valid; 1 = invalid).
                 */
                UINT64 BaseRegisterInvalid : 1;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_BIT  27
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_FLAG 0x8000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID_MASK 0x01
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_BASE_REGISTER_INVALID(_)   (((_) >> 27) & 0x01)

                /**
                 * [Bits 31:28] Reg2 (same encoding as IndexReg above).
                 */
                UINT64 Register2 : 4;
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_BIT  28
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_FLAG 0xF0000000
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2_MASK 0x0F
#define VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE_REGISTER_2(_)   (((_) >> 28) & 0x0F)
                UINT64 Reserved3 : 32;
        };

        UINT64 AsUInt;
} VMX_VMEXIT_INSTRUCTION_INFO_VMREAD_VMWRITE;

/**
 * @}
 */

/**
 * @brief - The low 16 bits correspond to bits 23:8 of the upper 32 bits of a 64-bit segment
 * descriptor. While bits 19:16 of code-segment and data-segment descriptors correspond to the upper
 * 4 bits of the segment limit, the corresponding bits (bits 11:8) are reserved in this VMCS field.
 *        - Bit 16 indicates an unusable segment. Attempts to use such a segment fault except in
 * 64-bit mode. In general, a segment register is unusable if it has been loaded with a null
 * selector.
 *        - Bits 31:17 are reserved
 *
 * @note There are a few exceptions to this statement. For example, a segment with a non-null
 * selector may be unusable following a task switch that fails after its commit point. In contrast,
 * the TR register is usable after processor reset despite having a null selector
 * @see SEGMENT_DESCRIPTOR_32
 * @see SEGMENT_DESCRIPTOR_64
 * @see XXX_ACCESS_RIGHTS fields of 32_BIT_GUEST_STATE_FIELDS
 * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
 */
typedef union
{
        struct
        {
                /**
                 * [Bits 3:0] Segment type.
                 */
                UINT32 Type : 4;
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_BIT  0
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_FLAG 0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE_MASK 0x0F
#define VMX_SEGMENT_ACCESS_RIGHTS_TYPE(_)   (((_) >> 0) & 0x0F)

                /**
                 * [Bit 4] S - Descriptor type (0 = system; 1 = code or data).
                 */
                UINT32 DescriptorType : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_BIT  4
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_FLAG 0x10
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_TYPE(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bits 6:5] DPL - Descriptor privilege level.
                 */
                UINT32 DescriptorPrivilegeLevel : 2;
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_BIT  5
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_FLAG 0x60
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL_MASK 0x03
#define VMX_SEGMENT_ACCESS_RIGHTS_DESCRIPTOR_PRIVILEGE_LEVEL(_)   (((_) >> 5) & 0x03)

                /**
                 * [Bit 7] P - Segment present.
                 */
                UINT32 Present : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_BIT  7
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_FLAG 0x80
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_PRESENT(_)   (((_) >> 7) & 0x01)
                UINT32 Reserved1 : 4;

                /**
                 * [Bit 12] AVL - Available for use by system software.
                 */
                UINT32 AvailableBit : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_BIT  12
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_FLAG 0x1000
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_AVAILABLE_BIT(_)   (((_) >> 12) & 0x01)

                /**
                 * [Bit 13] Reserved (except for CS). L - 64-bit mode active (for CS only).
                 */
                UINT32 LongMode : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_BIT  13
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_FLAG 0x2000
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_LONG_MODE(_)   (((_) >> 13) & 0x01)

                /**
                 * [Bit 14] D/B - Default operation size (0 = 16-bit segment; 1 = 32-bit segment).
                 */
                UINT32 DefaultBig : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_BIT  14
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_FLAG 0x4000
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_DEFAULT_BIG(_)   (((_) >> 14) & 0x01)

                /**
                 * [Bit 15] G - Granularity.
                 */
                UINT32 Granularity : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_BIT  15
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_FLAG 0x8000
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_GRANULARITY(_)   (((_) >> 15) & 0x01)

                /**
                 * [Bit 16] Segment unusable (0 = usable; 1 = unusable).
                 */
                UINT32 Unusable : 1;
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_BIT  16
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_FLAG 0x10000
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE_MASK 0x01
#define VMX_SEGMENT_ACCESS_RIGHTS_UNUSABLE(_)   (((_) >> 16) & 0x01)
                UINT32 Reserved2 : 15;
        };

        UINT32 AsUInt;
} VMX_SEGMENT_ACCESS_RIGHTS;

/**
 * @brief The IA-32 architecture includes features that permit certain events to be blocked for a
 * period of time. This field contains information about such blocking
 *
 * @see INTERRUPTIBILITY_STATE of 32_BIT_GUEST_STATE_FIELDS
 * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Execution of STI with RFLAGS.IF = 0 blocks maskable interrupts on the
                 * instruction boundary following its execution.1 Setting this bit indicates that
                 * this blocking is in effect.
                 *
                 * @see Vol2B[4(STI-Set Interrupt Flag)]
                 */
                UINT32 BlockingBySti : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_BIT  0
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_FLAG 0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI_MASK 0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_STI(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Execution of a MOV to SS or a POP to SS blocks or suppresses certain
                 * debug exceptions as well as interrupts (maskable and nonmaskable) on the
                 * instruction boundary following its execution. Setting this bit indicates that
                 * this blocking is in effect. This document uses the term "blocking by MOV SS," but
                 * it applies equally to POP SS.
                 *
                 * @see Vol3A[6.8.3(Masking Exceptions and Interrupts When Switching Stacks)]
                 */
                UINT32 BlockingByMovSs : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_BIT  1
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_FLAG 0x02
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS_MASK 0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_MOV_SS(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] System-management interrupts (SMIs) are disabled while the processor is
                 * in system-management mode (SMM). Setting this bit indicates that blocking of SMIs
                 * is in effect.
                 *
                 * @see Vol3C[34.2(System Management Interrupt (SMI))]
                 */
                UINT32 BlockingBySmi : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_BIT  2
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_FLAG 0x04
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI_MASK 0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_SMI(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] Delivery of a non-maskable interrupt (NMI) or a system-management
                 * interrupt (SMI) blocks subsequent NMIs until the next execution of IRET. Setting
                 * this bit indicates that blocking of NMIs is in effect. Clearing this bit does not
                 * imply that NMIs are not (temporarily) blocked for other reasons. If the "virtual
                 * NMIs" VM-execution control is 1, this bit does not control the blocking of NMIs.
                 * Instead, it refers to "virtual-NMI blocking" (the fact that guest software is not
                 * ready for an NMI).
                 *
                 * @see Vol3C[6.7.1(Handling Multiple NMIs)]
                 * @see Vol3C[25.3(CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION)]
                 * @see Vol3C[24.6.1(Pin-Based VM-Execution Controls)]
                 */
                UINT32 BlockingByNmi : 1;
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_BIT  3
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_FLAG 0x08
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI_MASK 0x01
#define VMX_INTERRUPTIBILITY_STATE_BLOCKING_BY_NMI(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] A VM exit saves this bit as 1 to indicate that the VM exit was incident
                 * to enclave mode.
                 */
                UINT32 EnclaveInterruption : 1;
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_BIT  4
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_FLAG 0x10
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION_MASK 0x01
#define VMX_INTERRUPTIBILITY_STATE_ENCLAVE_INTERRUPTION(_)   (((_) >> 4) & 0x01)
                UINT32 Reserved1 : 27;
        };

        UINT32 AsUInt;
} VMX_INTERRUPTIBILITY_STATE;

typedef enum
{
        /**
         * The logical processor is executing instructions normally.
         */
        VmxActive = 0x00000000,

        /**
         * The logical processor is inactive because it executed the HLT instruction.
         */
        VmxHlt = 0x00000001,

        /**
         * The logical processor is inactive because it incurred a triple fault1 or some other
         * serious error.
         */
        VmxShutdown = 0x00000002,

        /**
         * The logical processor is inactive because it is waiting for a startup-IPI (SIPI).
         */
        VmxWaitForSipi = 0x00000003,
} VMX_GUEST_ACTIVITY_STATE;

/**
 * @brief IA-32 processors may recognize one or more debug exceptions without immediately delivering
 * them. This field contains information about such exceptions
 *
 * @see Vol3C[24.4.2(Guest Non-Register State)] (reference)
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] When set, indicates that the corresponding breakpoint condition was met.
                 * May be set even if the corresponding enabling bit in DR7 is not set.
                 */
                UINT64 B0 : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_B0_BIT  0
#define VMX_PENDING_DEBUG_EXCEPTIONS_B0_FLAG 0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B0_MASK 0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B0(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] When set, indicates that the corresponding breakpoint condition was met.
                 * May be set even if the corresponding enabling bit in DR7 is not set.
                 */
                UINT64 B1 : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_B1_BIT  1
#define VMX_PENDING_DEBUG_EXCEPTIONS_B1_FLAG 0x02
#define VMX_PENDING_DEBUG_EXCEPTIONS_B1_MASK 0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B1(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] When set, indicates that the corresponding breakpoint condition was met.
                 * May be set even if the corresponding enabling bit in DR7 is not set.
                 */
                UINT64 B2 : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_B2_BIT  2
#define VMX_PENDING_DEBUG_EXCEPTIONS_B2_FLAG 0x04
#define VMX_PENDING_DEBUG_EXCEPTIONS_B2_MASK 0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B2(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] When set, indicates that the corresponding breakpoint condition was met.
                 * May be set even if the corresponding enabling bit in DR7 is not set.
                 */
                UINT64 B3 : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_B3_BIT  3
#define VMX_PENDING_DEBUG_EXCEPTIONS_B3_FLAG 0x08
#define VMX_PENDING_DEBUG_EXCEPTIONS_B3_MASK 0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_B3(_)   (((_) >> 3) & 0x01)
                UINT64 Reserved1 : 8;

                /**
                 * [Bit 12] When set, this bit indicates that at least one data or I/O breakpoint
                 * was met and was enabled in DR7.
                 */
                UINT64 EnabledBreakpoint : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT_BIT  12
#define VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT_FLAG 0x1000
#define VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT_MASK 0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_ENABLED_BREAKPOINT(_)   (((_) >> 12) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * [Bit 14] When set, this bit indicates that a debug exception would have been
                 * triggered by single-step execution mode.
                 */
                UINT64 Bs : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_BS_BIT  14
#define VMX_PENDING_DEBUG_EXCEPTIONS_BS_FLAG 0x4000
#define VMX_PENDING_DEBUG_EXCEPTIONS_BS_MASK 0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_BS(_)   (((_) >> 14) & 0x01)
                UINT64 Reserved3 : 1;

                /**
                 * [Bit 16] When set, this bit indicates that a debug exception (\#DB) or a
                 * breakpoint exception (\#BP) occurred inside an RTM region while advanced
                 * debugging of RTM transactional regions was enabled.
                 */
                UINT64 Rtm : 1;
#define VMX_PENDING_DEBUG_EXCEPTIONS_RTM_BIT  16
#define VMX_PENDING_DEBUG_EXCEPTIONS_RTM_FLAG 0x10000
#define VMX_PENDING_DEBUG_EXCEPTIONS_RTM_MASK 0x01
#define VMX_PENDING_DEBUG_EXCEPTIONS_RTM(_)   (((_) >> 16) & 0x01)
                UINT64 Reserved4 : 47;
        };

        UINT64 AsUInt;
} VMX_PENDING_DEBUG_EXCEPTIONS;

/**
 * @}
 */

/**
 * @brief Format of Exit Reason
 *
 * Exit reason (32 bits). This field encodes the reason for the VM exit and has the structure.
 *
 * @see Vol3C[24.9.1(Basic VM-Exit Information)] (reference)
 */
typedef union
{
        struct
        {
                /**
                 * [Bits 15:0] Provides basic information about the cause of the VM exit (if bit 31
                 * is clear) or of the VM-entry failure (if bit 31 is set).
                 */
                UINT32 BasicExitReason : 16;
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_BIT  0
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_FLAG 0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON_MASK 0xFFFF
#define VMX_VMEXIT_REASON_BASIC_EXIT_REASON(_)   (((_) >> 0) & 0xFFFF)

                /**
                 * [Bit 16] Always cleared to 0.
                 */
                UINT32 Always0 : 1;
#define VMX_VMEXIT_REASON_ALWAYS0_BIT  16
#define VMX_VMEXIT_REASON_ALWAYS0_FLAG 0x10000
#define VMX_VMEXIT_REASON_ALWAYS0_MASK 0x01
#define VMX_VMEXIT_REASON_ALWAYS0(_)   (((_) >> 16) & 0x01)
                UINT32 Reserved1 : 10;
#define VMX_VMEXIT_REASON_RESERVED1_BIT  17
#define VMX_VMEXIT_REASON_RESERVED1_FLAG 0x7FE0000
#define VMX_VMEXIT_REASON_RESERVED1_MASK 0x3FF
#define VMX_VMEXIT_REASON_RESERVED1(_)   (((_) >> 17) & 0x3FF)

                /**
                 * [Bit 27] A VM exit saves this bit as 1 to indicate that the VM exit was incident
                 * to enclave mode.
                 */
                UINT32 EnclaveMode : 1;
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_BIT  27
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_FLAG 0x8000000
#define VMX_VMEXIT_REASON_ENCLAVE_MODE_MASK 0x01
#define VMX_VMEXIT_REASON_ENCLAVE_MODE(_)   (((_) >> 27) & 0x01)

                /**
                 * [Bit 28] Pending MTF VM exit.
                 */
                UINT32 PendingMtfVmExit : 1;
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_BIT  28
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_FLAG 0x10000000
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT_MASK 0x01
#define VMX_VMEXIT_REASON_PENDING_MTF_VM_EXIT(_)   (((_) >> 28) & 0x01)

                /**
                 * [Bit 29] VM exit from VMX root operation.
                 */
                UINT32 VmExitFromVmxRoot : 1;
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT_BIT  29
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT_FLAG 0x20000000
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT_MASK 0x01
#define VMX_VMEXIT_REASON_VM_EXIT_FROM_VMX_ROOT(_)   (((_) >> 29) & 0x01)
                UINT32 Reserved2 : 1;
#define VMX_VMEXIT_REASON_RESERVED2_BIT  30
#define VMX_VMEXIT_REASON_RESERVED2_FLAG 0x40000000
#define VMX_VMEXIT_REASON_RESERVED2_MASK 0x01
#define VMX_VMEXIT_REASON_RESERVED2(_)   (((_) >> 30) & 0x01)

                /**
                 * [Bit 31] VM-entry failure:
                 *   - 0 = true VM exit
                 *   - 1 = VM-entry failure
                 */
                UINT32 VmEntryFailure : 1;
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_BIT  31
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_FLAG 0x80000000
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE_MASK 0x01
#define VMX_VMEXIT_REASON_VM_ENTRY_FAILURE(_)   (((_) >> 31) & 0x01)
        };

        UINT32 AsUInt;
} VMX_VMEXIT_REASON;

typedef struct
{
#define IO_BITMAP_A_MIN 0x00000000
#define IO_BITMAP_A_MAX 0x00007FFF
#define IO_BITMAP_B_MIN 0x00008000
#define IO_BITMAP_B_MAX 0x0000FFFF
        UINT8 IoA[4096];
        UINT8 IoB[4096];
} VMX_IO_BITMAP;

typedef struct
{
#define MSR_ID_LOW_MIN  0x00000000
#define MSR_ID_LOW_MAX  0x00001FFF
#define MSR_ID_HIGH_MIN 0xC0000000
#define MSR_ID_HIGH_MAX 0xC0001FFF
        UINT8 RdmsrLow[1024];
        UINT8 RdmsrHigh[1024];
        UINT8 WrmsrLow[1024];
        UINT8 WrmsrHigh[1024];
} VMX_MSR_BITMAP;

/**
 * @defgroup EPT \
 *           The extended page-table mechanism
 *
 * The extended page-table mechanism (EPT) is a feature that can be used to support the
 * virtualization of physical memory. When EPT is in use, certain addresses that would normally be
 * treated as physical addresses (and used to access memory) are instead treated as guest-physical
 * addresses. Guest-physical addresses are translated by traversing a set of EPT paging structures
 * to produce physical addresses that are used to access memory.
 *
 * @see Vol3C[28.2(THE EXTENDED PAGE TABLE MECHANISM (EPT))] (reference)
 * @{
 */
/**
 * @brief Extended-Page-Table Pointer (EPTP)
 *
 * The extended-page-table pointer (EPTP) contains the address of the base of EPT PML4 table, as
 * well as other EPT configuration information.
 *
 * @see Vol3C[28.2.2(EPT Translation Mechanism]
 * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP)] (reference)
 */
typedef union
{
        struct
        {
                /**
                 * [Bits 2:0] EPT paging-structure memory type:
                 * - 0 = Uncacheable (UC)
                 * - 6 = Write-back (WB)
                 * Other values are reserved.
                 *
                 * @see Vol3C[28.2.6(EPT and memory Typing)]
                 */
                UINT64 MemoryType : 3;
#define EPT_POINTER_MEMORY_TYPE_BIT  0
#define EPT_POINTER_MEMORY_TYPE_FLAG 0x07
#define EPT_POINTER_MEMORY_TYPE_MASK 0x07
#define EPT_POINTER_MEMORY_TYPE(_)   (((_) >> 0) & 0x07)

                /**
                 * [Bits 5:3] This value is 1 less than the EPT page-walk length.
                 *
                 * @see Vol3C[28.2.6(EPT and memory Typing)]
                 */
                UINT64 PageWalkLength : 3;
#define EPT_POINTER_PAGE_WALK_LENGTH_BIT  3
#define EPT_POINTER_PAGE_WALK_LENGTH_FLAG 0x38
#define EPT_POINTER_PAGE_WALK_LENGTH_MASK 0x07
#define EPT_POINTER_PAGE_WALK_LENGTH(_)   (((_) >> 3) & 0x07)
#define EPT_PAGE_WALK_LENGTH_4            0x00000003

                /**
                 * [Bit 6] Setting this control to 1 enables accessed and dirty flags for EPT.
                 *
                 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
                 */
                UINT64 EnableAccessAndDirtyFlags : 1;
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_BIT  6
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_FLAG 0x40
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS_MASK 0x01
#define EPT_POINTER_ENABLE_ACCESS_AND_DIRTY_FLAGS(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] Setting this control to 1 enables enforcement of access rights for
                 * supervisor shadow-stack pages.
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 EnableSupervisorShadowStackPages : 1;
#define EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES_BIT  7
#define EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES_FLAG 0x80
#define EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES_MASK 0x01
#define EPT_POINTER_ENABLE_SUPERVISOR_SHADOW_STACK_PAGES(_)   (((_) >> 7) & 0x01)
                UINT64 Reserved1 : 4;

                /**
                 * [Bits 47:12] Bits N-1:12 of the physical address of the 4-KByte aligned EPT PML4
                 * table.
                 */
                UINT64 PageFrameNumber : 36;
#define EPT_POINTER_PAGE_FRAME_NUMBER_BIT  12
#define EPT_POINTER_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define EPT_POINTER_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define EPT_POINTER_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved2 : 16;
        } Fields;

        UINT64 AsUInt;
} EPT_POINTER;

/**
 * @brief Format of an EPT PML4 Entry (PML4E) that References an EPT Page-Directory-Pointer Table
 *
 * A 4-KByte naturally aligned EPT PML4 table is located at the physical address specified in bits
 * 51:12 of the extended-page-table pointer (EPTP), a VM-execution control field. An EPT PML4 table
 * comprises 512 64-bit entries (EPT PML4Es). An EPT PML4E is selected using the physical address
 * defined as follows:
 * - Bits 63:52 are all 0.
 * - Bits 51:12 are from the EPTP.
 * - Bits 11:3 are bits 47:39 of the guest-physical address.
 * - Bits 2:0 are all 0.
 * Because an EPT PML4E is identified using bits 47:39 of the guest-physical address, it controls
 * access to a 512- GByte region of the guest-physical-address space.
 *
 * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP)]
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Read access; indicates whether reads are allowed from the 512-GByte
                 * region controlled by this entry.
                 */
                UINT64 ReadAccess : 1;
#define EPT_PML4E_READ_ACCESS_BIT  0
#define EPT_PML4E_READ_ACCESS_FLAG 0x01
#define EPT_PML4E_READ_ACCESS_MASK 0x01
#define EPT_PML4E_READ_ACCESS(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Write access; indicates whether writes are allowed from the 512-GByte
                 * region controlled by this entry.
                 */
                UINT64 WriteAccess : 1;
#define EPT_PML4E_WRITE_ACCESS_BIT  1
#define EPT_PML4E_WRITE_ACCESS_FLAG 0x02
#define EPT_PML4E_WRITE_ACCESS_MASK 0x01
#define EPT_PML4E_WRITE_ACCESS(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0,
                 * execute access; indicates whether instruction fetches are allowed from the
                 * 512-GByte region controlled by this entry. If that control is 1, execute access
                 * for supervisor-mode linear addresses; indicates whether instruction fetches are
                 * allowed from supervisor-mode linear addresses in the 512-GByte region controlled
                 * by this entry.
                 */
                UINT64 ExecuteAccess : 1;
#define EPT_PML4E_EXECUTE_ACCESS_BIT  2
#define EPT_PML4E_EXECUTE_ACCESS_FLAG 0x04
#define EPT_PML4E_EXECUTE_ACCESS_MASK 0x01
#define EPT_PML4E_EXECUTE_ACCESS(_)   (((_) >> 2) & 0x01)
                UINT64 Reserved1 : 5;

                /**
                 * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software
                 * has accessed the 512-GByte region controlled by this entry. Ignored if bit 6 of
                 * EPTP is 0.
                 *
                 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
                 */
                UINT64 Accessed : 1;
#define EPT_PML4E_ACCESSED_BIT  8
#define EPT_PML4E_ACCESSED_FLAG 0x100
#define EPT_PML4E_ACCESSED_MASK 0x01
#define EPT_PML4E_ACCESSED(_)   (((_) >> 8) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based
                 * execute control for EPT" VM-execution control is 1, indicates whether instruction
                 * fetches are allowed from user-mode linear addresses in the 512-GByte region
                 * controlled by this entry. If that control is 0, this bit is ignored.
                 */
                UINT64 UserModeExecute : 1;
#define EPT_PML4E_USER_MODE_EXECUTE_BIT  10
#define EPT_PML4E_USER_MODE_EXECUTE_FLAG 0x400
#define EPT_PML4E_USER_MODE_EXECUTE_MASK 0x01
#define EPT_PML4E_USER_MODE_EXECUTE(_)   (((_) >> 10) & 0x01)
                UINT64 Reserved3 : 1;

                /**
                 * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table
                 * referenced by this entry.
                 */
                UINT64 PageFrameNumber : 36;
#define EPT_PML4E_PAGE_FRAME_NUMBER_BIT  12
#define EPT_PML4E_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define EPT_PML4E_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define EPT_PML4E_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved4 : 16;
        } Fields;

        UINT64 AsUInt;
} EPT_PML4E;

/**
 * @brief Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE) that Maps a 1-GByte Page
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte page
                 * referenced by this entry.
                 */
                UINT64 ReadAccess : 1;
#define EPT_PDPTE_1GB_READ_ACCESS_BIT  0
#define EPT_PDPTE_1GB_READ_ACCESS_FLAG 0x01
#define EPT_PDPTE_1GB_READ_ACCESS_MASK 0x01
#define EPT_PDPTE_1GB_READ_ACCESS(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte page
                 * referenced by this entry.
                 */
                UINT64 WriteAccess : 1;
#define EPT_PDPTE_1GB_WRITE_ACCESS_BIT  1
#define EPT_PDPTE_1GB_WRITE_ACCESS_FLAG 0x02
#define EPT_PDPTE_1GB_WRITE_ACCESS_MASK 0x01
#define EPT_PDPTE_1GB_WRITE_ACCESS(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0,
                 * execute access; indicates whether instruction fetches are allowed from the
                 * 1-GByte page controlled by this entry. If that control is 1, execute access for
                 * supervisor-mode linear addresses; indicates whether instruction fetches are
                 * allowed from supervisor-mode linear addresses in the 1-GByte page controlled by
                 * this entry.
                 */
                UINT64 ExecuteAccess : 1;
#define EPT_PDPTE_1GB_EXECUTE_ACCESS_BIT  2
#define EPT_PDPTE_1GB_EXECUTE_ACCESS_FLAG 0x04
#define EPT_PDPTE_1GB_EXECUTE_ACCESS_MASK 0x01
#define EPT_PDPTE_1GB_EXECUTE_ACCESS(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bits 5:3] EPT memory type for this 1-GByte page.
                 *
                 * @see Vol3C[28.2.6(EPT and memory Typing)]
                 */
                UINT64 MemoryType : 3;
#define EPT_PDPTE_1GB_MEMORY_TYPE_BIT  3
#define EPT_PDPTE_1GB_MEMORY_TYPE_FLAG 0x38
#define EPT_PDPTE_1GB_MEMORY_TYPE_MASK 0x07
#define EPT_PDPTE_1GB_MEMORY_TYPE(_)   (((_) >> 3) & 0x07)

                /**
                 * [Bit 6] Ignore PAT memory type for this 1-GByte page.
                 *
                 * @see Vol3C[28.2.6(EPT and memory Typing)]
                 */
                UINT64 IgnorePat : 1;
#define EPT_PDPTE_1GB_IGNORE_PAT_BIT  6
#define EPT_PDPTE_1GB_IGNORE_PAT_FLAG 0x40
#define EPT_PDPTE_1GB_IGNORE_PAT_MASK 0x01
#define EPT_PDPTE_1GB_IGNORE_PAT(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] Must be 1 (otherwise, this entry references an EPT page directory).
                 */
                UINT64 LargePage : 1;
#define EPT_PDPTE_1GB_LARGE_PAGE_BIT  7
#define EPT_PDPTE_1GB_LARGE_PAGE_FLAG 0x80
#define EPT_PDPTE_1GB_LARGE_PAGE_MASK 0x01
#define EPT_PDPTE_1GB_LARGE_PAGE(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software
                 * has accessed the 1-GByte page referenced by this entry. Ignored if bit 6 of EPTP
                 * is 0.
                 *
                 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
                 */
                UINT64 Accessed : 1;
#define EPT_PDPTE_1GB_ACCESSED_BIT  8
#define EPT_PDPTE_1GB_ACCESSED_FLAG 0x100
#define EPT_PDPTE_1GB_ACCESSED_MASK 0x01
#define EPT_PDPTE_1GB_ACCESSED(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has
                 * written to the 1-GByte page referenced by this entry. Ignored if bit 6 of EPTP is
                 * 0.
                 *
                 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
                 */
                UINT64 Dirty : 1;
#define EPT_PDPTE_1GB_DIRTY_BIT  9
#define EPT_PDPTE_1GB_DIRTY_FLAG 0x200
#define EPT_PDPTE_1GB_DIRTY_MASK 0x01
#define EPT_PDPTE_1GB_DIRTY(_)   (((_) >> 9) & 0x01)

                /**
                 * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based
                 * execute control for EPT" VM-execution control is 1, indicates whether instruction
                 * fetches are allowed from user-mode linear addresses in the 1-GByte page
                 * controlled by this entry. If that control is 0, this bit is ignored.
                 */
                UINT64 UserModeExecute : 1;
#define EPT_PDPTE_1GB_USER_MODE_EXECUTE_BIT  10
#define EPT_PDPTE_1GB_USER_MODE_EXECUTE_FLAG 0x400
#define EPT_PDPTE_1GB_USER_MODE_EXECUTE_MASK 0x01
#define EPT_PDPTE_1GB_USER_MODE_EXECUTE(_)   (((_) >> 10) & 0x01)
                UINT64 Reserved1 : 19;

                /**
                 * [Bits 47:30] Physical address of 4-KByte aligned EPT page-directory-pointer table
                 * referenced by this entry.
                 */
                UINT64 PageFrameNumber : 18;
#define EPT_PDPTE_1GB_PAGE_FRAME_NUMBER_BIT  30
#define EPT_PDPTE_1GB_PAGE_FRAME_NUMBER_FLAG 0xFFFFC0000000
#define EPT_PDPTE_1GB_PAGE_FRAME_NUMBER_MASK 0x3FFFF
#define EPT_PDPTE_1GB_PAGE_FRAME_NUMBER(_)   (((_) >> 30) & 0x3FFFF)
                UINT64 Reserved2 : 9;

                /**
                 * [Bit 57] Verify guest paging. If the "guest-paging verification" VM-execution
                 * control is 1, indicates limits on the guest paging structures used to access the
                 * 1-GByte page controlled by this entry (see Section 28.3.3.2). If that control is
                 * 0, this bit is ignored.
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 VerifyGuestPaging : 1;
#define EPT_PDPTE_1GB_VERIFY_GUEST_PAGING_BIT  57
#define EPT_PDPTE_1GB_VERIFY_GUEST_PAGING_FLAG 0x200000000000000
#define EPT_PDPTE_1GB_VERIFY_GUEST_PAGING_MASK 0x01
#define EPT_PDPTE_1GB_VERIFY_GUEST_PAGING(_)   (((_) >> 57) & 0x01)

                /**
                 * [Bit 58] Paging-write access. If the "EPT paging-write control" VM-execution
                 * control is 1, indicates that guest paging may update the 1-GByte page controlled
                 * by this entry (see Section 28.3.3.2). If that control is 0, this bit is ignored
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 PagingWriteAccess : 1;
#define EPT_PDPTE_1GB_PAGING_WRITE_ACCESS_BIT  58
#define EPT_PDPTE_1GB_PAGING_WRITE_ACCESS_FLAG 0x400000000000000
#define EPT_PDPTE_1GB_PAGING_WRITE_ACCESS_MASK 0x01
#define EPT_PDPTE_1GB_PAGING_WRITE_ACCESS(_)   (((_) >> 58) & 0x01)
                UINT64 Reserved3 : 1;

                /**
                 * [Bit 60] Supervisor shadow stack. If bit 7 of EPTP is 1, indicates whether
                 * supervisor shadow stack accesses are allowed to guest-physical addresses in the
                 * 1-GByte page mapped by this entry (see Section 28.3.3.2)
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 SupervisorShadowStack : 1;
#define EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK_BIT  60
#define EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK_FLAG 0x1000000000000000
#define EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK_MASK 0x01
#define EPT_PDPTE_1GB_SUPERVISOR_SHADOW_STACK(_)   (((_) >> 60) & 0x01)
                UINT64 Reserved4 : 2;

                /**
                 * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1,
                 * EPT violations caused by accesses to this page are convertible to virtualization
                 * exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
                 * 0, this bit is ignored.
                 *
                 * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
                 */
                UINT64 SuppressVe : 1;
#define EPT_PDPTE_1GB_SUPPRESS_VE_BIT  63
#define EPT_PDPTE_1GB_SUPPRESS_VE_FLAG 0x8000000000000000
#define EPT_PDPTE_1GB_SUPPRESS_VE_MASK 0x01
#define EPT_PDPTE_1GB_SUPPRESS_VE(_)   (((_) >> 63) & 0x01)
        } Fields;

        UINT64 AsUInt;
} EPT_PDPTE_1GB;

/**
 * @brief Format of an EPT Page-Directory-Pointer-Table Entry (PDPTE) that References an EPT Page
 * Directory
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte region
                 * controlled by this entry.
                 */
                UINT64 ReadAccess : 1;
#define EPT_PDPTE_READ_ACCESS_BIT  0
#define EPT_PDPTE_READ_ACCESS_FLAG 0x01
#define EPT_PDPTE_READ_ACCESS_MASK 0x01
#define EPT_PDPTE_READ_ACCESS(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte
                 * region controlled by this entry.
                 */
                UINT64 WriteAccess : 1;
#define EPT_PDPTE_WRITE_ACCESS_BIT  1
#define EPT_PDPTE_WRITE_ACCESS_FLAG 0x02
#define EPT_PDPTE_WRITE_ACCESS_MASK 0x01
#define EPT_PDPTE_WRITE_ACCESS(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0,
                 * execute access; indicates whether instruction fetches are allowed from the
                 * 1-GByte region controlled by this entry. If that control is 1, execute access for
                 * supervisor-mode linear addresses; indicates whether instruction fetches are
                 * allowed from supervisor-mode linear addresses in the 1-GByte region controlled by
                 * this entry.
                 */
                UINT64 ExecuteAccess : 1;
#define EPT_PDPTE_EXECUTE_ACCESS_BIT  2
#define EPT_PDPTE_EXECUTE_ACCESS_FLAG 0x04
#define EPT_PDPTE_EXECUTE_ACCESS_MASK 0x01
#define EPT_PDPTE_EXECUTE_ACCESS(_)   (((_) >> 2) & 0x01)
                UINT64 Reserved1 : 5;

                /**
                 * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software
                 * has accessed the 1-GByte region controlled by this entry. Ignored if bit 6 of
                 * EPTP is 0.
                 *
                 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
                 */
                UINT64 Accessed : 1;
#define EPT_PDPTE_ACCESSED_BIT  8
#define EPT_PDPTE_ACCESSED_FLAG 0x100
#define EPT_PDPTE_ACCESSED_MASK 0x01
#define EPT_PDPTE_ACCESSED(_)   (((_) >> 8) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based
                 * execute control for EPT" VM-execution control is 1, indicates whether instruction
                 * fetches are allowed from user-mode linear addresses in the 1-GByte region
                 * controlled by this entry. If that control is 0, this bit is ignored.
                 */
                UINT64 UserModeExecute : 1;
#define EPT_PDPTE_USER_MODE_EXECUTE_BIT  10
#define EPT_PDPTE_USER_MODE_EXECUTE_FLAG 0x400
#define EPT_PDPTE_USER_MODE_EXECUTE_MASK 0x01
#define EPT_PDPTE_USER_MODE_EXECUTE(_)   (((_) >> 10) & 0x01)
                UINT64 Reserved3 : 1;

                /**
                 * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table
                 * referenced by this entry.
                 */
                UINT64 PageFrameNumber : 36;
#define EPT_PDPTE_PAGE_FRAME_NUMBER_BIT  12
#define EPT_PDPTE_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define EPT_PDPTE_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define EPT_PDPTE_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved4 : 16;
        } Fields;

        UINT64 AsUInt;
} EPT_PDPTE;

/**
 * @brief Format of an EPT Page-Directory Entry (PDE) that Maps a 2-MByte Page
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte page
                 * referenced by this entry.
                 */
                UINT64 ReadAccess : 1;
#define EPT_PDE_2MB_READ_ACCESS_BIT  0
#define EPT_PDE_2MB_READ_ACCESS_FLAG 0x01
#define EPT_PDE_2MB_READ_ACCESS_MASK 0x01
#define EPT_PDE_2MB_READ_ACCESS(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte page
                 * referenced by this entry.
                 */
                UINT64 WriteAccess : 1;
#define EPT_PDE_2MB_WRITE_ACCESS_BIT  1
#define EPT_PDE_2MB_WRITE_ACCESS_FLAG 0x02
#define EPT_PDE_2MB_WRITE_ACCESS_MASK 0x01
#define EPT_PDE_2MB_WRITE_ACCESS(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0,
                 * execute access; indicates whether instruction fetches are allowed from the
                 * 2-MByte page controlled by this entry. If that control is 1, execute access for
                 * supervisor-mode linear addresses; indicates whether instruction fetches are
                 * allowed from supervisor-mode linear addresses in the 2-MByte page controlled by
                 * this entry.
                 */
                UINT64 ExecuteAccess : 1;
#define EPT_PDE_2MB_EXECUTE_ACCESS_BIT  2
#define EPT_PDE_2MB_EXECUTE_ACCESS_FLAG 0x04
#define EPT_PDE_2MB_EXECUTE_ACCESS_MASK 0x01
#define EPT_PDE_2MB_EXECUTE_ACCESS(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bits 5:3] EPT memory type for this 2-MByte page.
                 *
                 * @see Vol3C[28.2.6(EPT and memory Typing)]
                 */
                UINT64 MemoryType : 3;
#define EPT_PDE_2MB_MEMORY_TYPE_BIT  3
#define EPT_PDE_2MB_MEMORY_TYPE_FLAG 0x38
#define EPT_PDE_2MB_MEMORY_TYPE_MASK 0x07
#define EPT_PDE_2MB_MEMORY_TYPE(_)   (((_) >> 3) & 0x07)

                /**
                 * [Bit 6] Ignore PAT memory type for this 2-MByte page.
                 *
                 * @see Vol3C[28.2.6(EPT and memory Typing)]
                 */
                UINT64 IgnorePat : 1;
#define EPT_PDE_2MB_IGNORE_PAT_BIT  6
#define EPT_PDE_2MB_IGNORE_PAT_FLAG 0x40
#define EPT_PDE_2MB_IGNORE_PAT_MASK 0x01
#define EPT_PDE_2MB_IGNORE_PAT(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] Must be 1 (otherwise, this entry references an EPT page table).
                 */
                UINT64 LargePage : 1;
#define EPT_PDE_2MB_LARGE_PAGE_BIT  7
#define EPT_PDE_2MB_LARGE_PAGE_FLAG 0x80
#define EPT_PDE_2MB_LARGE_PAGE_MASK 0x01
#define EPT_PDE_2MB_LARGE_PAGE(_)   (((_) >> 7) & 0x01)

                /**
                 * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software
                 * has accessed the 2-MByte page referenced by this entry. Ignored if bit 6 of EPTP
                 * is 0.
                 *
                 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
                 */
                UINT64 Accessed : 1;
#define EPT_PDE_2MB_ACCESSED_BIT  8
#define EPT_PDE_2MB_ACCESSED_FLAG 0x100
#define EPT_PDE_2MB_ACCESSED_MASK 0x01
#define EPT_PDE_2MB_ACCESSED(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has
                 * written to the 2-MByte page referenced by this entry. Ignored if bit 6 of EPTP is
                 * 0.
                 *
                 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
                 */
                UINT64 Dirty : 1;
#define EPT_PDE_2MB_DIRTY_BIT  9
#define EPT_PDE_2MB_DIRTY_FLAG 0x200
#define EPT_PDE_2MB_DIRTY_MASK 0x01
#define EPT_PDE_2MB_DIRTY(_)   (((_) >> 9) & 0x01)

                /**
                 * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based
                 * execute control for EPT" VM-execution control is 1, indicates whether instruction
                 * fetches are allowed from user-mode linear addresses in the 2-MByte page
                 * controlled by this entry. If that control is 0, this bit is ignored.
                 */
                UINT64 UserModeExecute : 1;
#define EPT_PDE_2MB_USER_MODE_EXECUTE_BIT  10
#define EPT_PDE_2MB_USER_MODE_EXECUTE_FLAG 0x400
#define EPT_PDE_2MB_USER_MODE_EXECUTE_MASK 0x01
#define EPT_PDE_2MB_USER_MODE_EXECUTE(_)   (((_) >> 10) & 0x01)
                UINT64 Reserved1 : 10;

                /**
                 * [Bits 47:21] Physical address of 4-KByte aligned EPT page-directory-pointer table
                 * referenced by this entry.
                 */
                UINT64 PageFrameNumber : 27;
#define EPT_PDE_2MB_PAGE_FRAME_NUMBER_BIT  21
#define EPT_PDE_2MB_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFE00000
#define EPT_PDE_2MB_PAGE_FRAME_NUMBER_MASK 0x7FFFFFF
#define EPT_PDE_2MB_PAGE_FRAME_NUMBER(_)   (((_) >> 21) & 0x7FFFFFF)
                UINT64 Reserved2 : 9;

                /**
                 * [Bit 57] Verify guest paging. If the "guest-paging verification" VM-execution
                 * control is 1, indicates limits on the guest paging structures used to access the
                 * 2-MByte page controlled by this entry (see Section 28.3.3.2). If that control is
                 * 0, this bit is ignored.
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 VerifyGuestPaging : 1;
#define EPT_PDE_2MB_VERIFY_GUEST_PAGING_BIT  57
#define EPT_PDE_2MB_VERIFY_GUEST_PAGING_FLAG 0x200000000000000
#define EPT_PDE_2MB_VERIFY_GUEST_PAGING_MASK 0x01
#define EPT_PDE_2MB_VERIFY_GUEST_PAGING(_)   (((_) >> 57) & 0x01)

                /**
                 * [Bit 58] Paging-write access. If the "EPT paging-write control" VM-execution
                 * control is 1, indicates that guest paging may update the 2-MByte page controlled
                 * by this entry (see Section 28.3.3.2). If that control is 0, this bit is ignored
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 PagingWriteAccess : 1;
#define EPT_PDE_2MB_PAGING_WRITE_ACCESS_BIT  58
#define EPT_PDE_2MB_PAGING_WRITE_ACCESS_FLAG 0x400000000000000
#define EPT_PDE_2MB_PAGING_WRITE_ACCESS_MASK 0x01
#define EPT_PDE_2MB_PAGING_WRITE_ACCESS(_)   (((_) >> 58) & 0x01)
                UINT64 Reserved3 : 1;

                /**
                 * [Bit 60] Supervisor shadow stack. If bit 7 of EPTP is 1, indicates whether
                 * supervisor shadow stack accesses are allowed to guest-physical addresses in the
                 * 2-MByte page mapped by this entry (see Section 28.3.3.2)
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 SupervisorShadowStack : 1;
#define EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK_BIT  60
#define EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK_FLAG 0x1000000000000000
#define EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK_MASK 0x01
#define EPT_PDE_2MB_SUPERVISOR_SHADOW_STACK(_)   (((_) >> 60) & 0x01)
                UINT64 Reserved4 : 2;

                /**
                 * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1,
                 * EPT violations caused by accesses to this page are convertible to virtualization
                 * exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
                 * 0, this bit is ignored.
                 *
                 * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
                 */
                UINT64 SuppressVe : 1;
#define EPT_PDE_2MB_SUPPRESS_VE_BIT  63
#define EPT_PDE_2MB_SUPPRESS_VE_FLAG 0x8000000000000000
#define EPT_PDE_2MB_SUPPRESS_VE_MASK 0x01
#define EPT_PDE_2MB_SUPPRESS_VE(_)   (((_) >> 63) & 0x01)
        } Fields;

        UINT64 AsUInt;
} EPT_PDE_2MB;

/**
 * @brief Format of an EPT Page-Directory Entry (PDE) that References an EPT Page Table
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte region
                 * controlled by this entry.
                 */
                UINT64 ReadAccess : 1;
#define EPT_PDE_READ_ACCESS_BIT  0
#define EPT_PDE_READ_ACCESS_FLAG 0x01
#define EPT_PDE_READ_ACCESS_MASK 0x01
#define EPT_PDE_READ_ACCESS(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte
                 * region controlled by this entry.
                 */
                UINT64 WriteAccess : 1;
#define EPT_PDE_WRITE_ACCESS_BIT  1
#define EPT_PDE_WRITE_ACCESS_FLAG 0x02
#define EPT_PDE_WRITE_ACCESS_MASK 0x01
#define EPT_PDE_WRITE_ACCESS(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0,
                 * execute access; indicates whether instruction fetches are allowed from the
                 * 2-MByte region controlled by this entry. If that control is 1, execute access for
                 * supervisor-mode linear addresses; indicates whether instruction fetches are
                 * allowed from supervisor-mode linear addresses in the 2-MByte region controlled by
                 * this entry.
                 */
                UINT64 ExecuteAccess : 1;
#define EPT_PDE_EXECUTE_ACCESS_BIT  2
#define EPT_PDE_EXECUTE_ACCESS_FLAG 0x04
#define EPT_PDE_EXECUTE_ACCESS_MASK 0x01
#define EPT_PDE_EXECUTE_ACCESS(_)   (((_) >> 2) & 0x01)
                UINT64 Reserved1 : 5;

                /**
                 * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software
                 * has accessed the 2-MByte region controlled by this entry. Ignored if bit 6 of
                 * EPTP is 0.
                 *
                 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
                 */
                UINT64 Accessed : 1;
#define EPT_PDE_ACCESSED_BIT  8
#define EPT_PDE_ACCESSED_FLAG 0x100
#define EPT_PDE_ACCESSED_MASK 0x01
#define EPT_PDE_ACCESSED(_)   (((_) >> 8) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based
                 * execute control for EPT" VM-execution control is 1, indicates whether instruction
                 * fetches are allowed from user-mode linear addresses in the 2-MByte region
                 * controlled by this entry. If that control is 0, this bit is ignored.
                 */
                UINT64 UserModeExecute : 1;
#define EPT_PDE_USER_MODE_EXECUTE_BIT  10
#define EPT_PDE_USER_MODE_EXECUTE_FLAG 0x400
#define EPT_PDE_USER_MODE_EXECUTE_MASK 0x01
#define EPT_PDE_USER_MODE_EXECUTE(_)   (((_) >> 10) & 0x01)
                UINT64 Reserved3 : 1;

                /**
                 * [Bits 47:12] Physical address of 4-KByte aligned EPT page table referenced by
                 * this entry.
                 */
                UINT64 PageFrameNumber : 36;
#define EPT_PDE_PAGE_FRAME_NUMBER_BIT  12
#define EPT_PDE_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define EPT_PDE_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define EPT_PDE_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved4 : 16;
        } Fields;

        UINT64 AsUInt;
} EPT_PDE;

/**
 * @brief Format of an EPT Page-Table Entry that Maps a 4-KByte Page
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Read access; indicates whether reads are allowed from the 4-KByte page
                 * referenced by this entry.
                 */
                UINT64 ReadAccess : 1;
#define EPT_PTE_READ_ACCESS_BIT  0
#define EPT_PTE_READ_ACCESS_FLAG 0x01
#define EPT_PTE_READ_ACCESS_MASK 0x01
#define EPT_PTE_READ_ACCESS(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Write access; indicates whether writes are allowed from the 4-KByte page
                 * referenced by this entry.
                 */
                UINT64 WriteAccess : 1;
#define EPT_PTE_WRITE_ACCESS_BIT  1
#define EPT_PTE_WRITE_ACCESS_FLAG 0x02
#define EPT_PTE_WRITE_ACCESS_MASK 0x01
#define EPT_PTE_WRITE_ACCESS(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0,
                 * execute access; indicates whether instruction fetches are allowed from the
                 * 4-KByte page controlled by this entry. If that control is 1, execute access for
                 * supervisor-mode linear addresses; indicates whether instruction fetches are
                 * allowed from supervisor-mode linear addresses in the 4-KByte page controlled by
                 * this entry.
                 */
                UINT64 ExecuteAccess : 1;
#define EPT_PTE_EXECUTE_ACCESS_BIT  2
#define EPT_PTE_EXECUTE_ACCESS_FLAG 0x04
#define EPT_PTE_EXECUTE_ACCESS_MASK 0x01
#define EPT_PTE_EXECUTE_ACCESS(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bits 5:3] EPT memory type for this 4-KByte page.
                 *
                 * @see Vol3C[28.2.6(EPT and memory Typing)]
                 */
                UINT64 MemoryType : 3;
#define EPT_PTE_MEMORY_TYPE_BIT  3
#define EPT_PTE_MEMORY_TYPE_FLAG 0x38
#define EPT_PTE_MEMORY_TYPE_MASK 0x07
#define EPT_PTE_MEMORY_TYPE(_)   (((_) >> 3) & 0x07)

                /**
                 * [Bit 6] Ignore PAT memory type for this 4-KByte page.
                 *
                 * @see Vol3C[28.2.6(EPT and memory Typing)]
                 */
                UINT64 IgnorePat : 1;
#define EPT_PTE_IGNORE_PAT_BIT  6
#define EPT_PTE_IGNORE_PAT_FLAG 0x40
#define EPT_PTE_IGNORE_PAT_MASK 0x01
#define EPT_PTE_IGNORE_PAT(_)   (((_) >> 6) & 0x01)
                UINT64 Reserved1 : 1;

                /**
                 * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software
                 * has accessed the 4-KByte page referenced by this entry. Ignored if bit 6 of EPTP
                 * is 0.
                 *
                 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
                 */
                UINT64 Accessed : 1;
#define EPT_PTE_ACCESSED_BIT  8
#define EPT_PTE_ACCESSED_FLAG 0x100
#define EPT_PTE_ACCESSED_MASK 0x01
#define EPT_PTE_ACCESSED(_)   (((_) >> 8) & 0x01)

                /**
                 * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has
                 * written to the 4-KByte page referenced by this entry. Ignored if bit 6 of EPTP is
                 * 0.
                 *
                 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
                 */
                UINT64 Dirty : 1;
#define EPT_PTE_DIRTY_BIT  9
#define EPT_PTE_DIRTY_FLAG 0x200
#define EPT_PTE_DIRTY_MASK 0x01
#define EPT_PTE_DIRTY(_)   (((_) >> 9) & 0x01)

                /**
                 * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based
                 * execute control for EPT" VM-execution control is 1, indicates whether instruction
                 * fetches are allowed from user-mode linear addresses in the 4-KByte page
                 * controlled by this entry. If that control is 0, this bit is ignored.
                 */
                UINT64 UserModeExecute : 1;
#define EPT_PTE_USER_MODE_EXECUTE_BIT  10
#define EPT_PTE_USER_MODE_EXECUTE_FLAG 0x400
#define EPT_PTE_USER_MODE_EXECUTE_MASK 0x01
#define EPT_PTE_USER_MODE_EXECUTE(_)   (((_) >> 10) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
                 */
                UINT64 PageFrameNumber : 36;
#define EPT_PTE_PAGE_FRAME_NUMBER_BIT  12
#define EPT_PTE_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define EPT_PTE_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define EPT_PTE_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved3 : 9;

                /**
                 * [Bit 57] Verify guest paging. If the "guest-paging verification" VM-execution
                 * control is 1, indicates limits on the guest paging structures used to access the
                 * 4-KByte page controlled by this entry (see Section 28.3.3.2). If that control is
                 * 0, this bit is ignored.
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 VerifyGuestPaging : 1;
#define EPT_PTE_VERIFY_GUEST_PAGING_BIT  57
#define EPT_PTE_VERIFY_GUEST_PAGING_FLAG 0x200000000000000
#define EPT_PTE_VERIFY_GUEST_PAGING_MASK 0x01
#define EPT_PTE_VERIFY_GUEST_PAGING(_)   (((_) >> 57) & 0x01)

                /**
                 * [Bit 58] Paging-write access. If the "EPT paging-write control" VM-execution
                 * control is 1, indicates that guest paging may update the 4-KByte page controlled
                 * by this entry (see Section 28.3.3.2). If that control is 0, this bit is ignored
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 PagingWriteAccess : 1;
#define EPT_PTE_PAGING_WRITE_ACCESS_BIT  58
#define EPT_PTE_PAGING_WRITE_ACCESS_FLAG 0x400000000000000
#define EPT_PTE_PAGING_WRITE_ACCESS_MASK 0x01
#define EPT_PTE_PAGING_WRITE_ACCESS(_)   (((_) >> 58) & 0x01)
                UINT64 Reserved4 : 1;

                /**
                 * [Bit 60] Supervisor shadow stack. If bit 7 of EPTP is 1, indicates whether
                 * supervisor shadow stack accesses are allowed to guest-physical addresses in the
                 * 4-KByte page mapped by this entry (see Section 28.3.3.2)
                 *
                 * @see Vol3C[28.3.3.2(EPT Violations)]
                 */
                UINT64 SupervisorShadowStack : 1;
#define EPT_PTE_SUPERVISOR_SHADOW_STACK_BIT  60
#define EPT_PTE_SUPERVISOR_SHADOW_STACK_FLAG 0x1000000000000000
#define EPT_PTE_SUPERVISOR_SHADOW_STACK_MASK 0x01
#define EPT_PTE_SUPERVISOR_SHADOW_STACK(_)   (((_) >> 60) & 0x01)

                /**
                 * [Bit 61] Sub-page write permissions. If the "sub-page write permissions for EPT"
                 * VM-execution control is 1, writes to individual 128-byte regions of the 4-KByte
                 * page referenced by this entry may be allowed even if the page would normally not
                 * be writable (see Section 28.3.4). If "sub-page write permissions for EPT"
                 * VM-execution control is 0, this bit is ignored.
                 *
                 * @see Vol3C[28.3.4(Sub-Page Write Permissions)]
                 */
                UINT64 SubPageWritePermissions : 1;
#define EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS_BIT  61
#define EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS_FLAG 0x2000000000000000
#define EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS_MASK 0x01
#define EPT_PTE_SUB_PAGE_WRITE_PERMISSIONS(_)   (((_) >> 61) & 0x01)
                UINT64 Reserved5 : 1;

                /**
                 * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1,
                 * EPT violations caused by accesses to this page are convertible to virtualization
                 * exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
                 * 0, this bit is ignored.
                 *
                 * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
                 */
                UINT64 SuppressVe : 1;
#define EPT_PTE_SUPPRESS_VE_BIT  63
#define EPT_PTE_SUPPRESS_VE_FLAG 0x8000000000000000
#define EPT_PTE_SUPPRESS_VE_MASK 0x01
#define EPT_PTE_SUPPRESS_VE(_)   (((_) >> 63) & 0x01)
        } Fields;

        UINT64 AsUInt;
} EPT_PTE;

/**
 * @brief Format of a common EPT Entry
 */
typedef union
{
        struct
        {
                UINT64 ReadAccess : 1;
#define EPT_ENTRY_READ_ACCESS_BIT  0
#define EPT_ENTRY_READ_ACCESS_FLAG 0x01
#define EPT_ENTRY_READ_ACCESS_MASK 0x01
#define EPT_ENTRY_READ_ACCESS(_)   (((_) >> 0) & 0x01)
                UINT64 WriteAccess : 1;
#define EPT_ENTRY_WRITE_ACCESS_BIT  1
#define EPT_ENTRY_WRITE_ACCESS_FLAG 0x02
#define EPT_ENTRY_WRITE_ACCESS_MASK 0x01
#define EPT_ENTRY_WRITE_ACCESS(_)   (((_) >> 1) & 0x01)
                UINT64 ExecuteAccess : 1;
#define EPT_ENTRY_EXECUTE_ACCESS_BIT  2
#define EPT_ENTRY_EXECUTE_ACCESS_FLAG 0x04
#define EPT_ENTRY_EXECUTE_ACCESS_MASK 0x01
#define EPT_ENTRY_EXECUTE_ACCESS(_)   (((_) >> 2) & 0x01)
                UINT64 MemoryType : 3;
#define EPT_ENTRY_MEMORY_TYPE_BIT  3
#define EPT_ENTRY_MEMORY_TYPE_FLAG 0x38
#define EPT_ENTRY_MEMORY_TYPE_MASK 0x07
#define EPT_ENTRY_MEMORY_TYPE(_)   (((_) >> 3) & 0x07)
                UINT64 IgnorePat : 1;
#define EPT_ENTRY_IGNORE_PAT_BIT  6
#define EPT_ENTRY_IGNORE_PAT_FLAG 0x40
#define EPT_ENTRY_IGNORE_PAT_MASK 0x01
#define EPT_ENTRY_IGNORE_PAT(_)   (((_) >> 6) & 0x01)
                UINT64 LargePage : 1;
#define EPT_ENTRY_LARGE_PAGE_BIT  7
#define EPT_ENTRY_LARGE_PAGE_FLAG 0x80
#define EPT_ENTRY_LARGE_PAGE_MASK 0x01
#define EPT_ENTRY_LARGE_PAGE(_)   (((_) >> 7) & 0x01)
                UINT64 Accessed : 1;
#define EPT_ENTRY_ACCESSED_BIT  8
#define EPT_ENTRY_ACCESSED_FLAG 0x100
#define EPT_ENTRY_ACCESSED_MASK 0x01
#define EPT_ENTRY_ACCESSED(_)   (((_) >> 8) & 0x01)
                UINT64 Dirty : 1;
#define EPT_ENTRY_DIRTY_BIT  9
#define EPT_ENTRY_DIRTY_FLAG 0x200
#define EPT_ENTRY_DIRTY_MASK 0x01
#define EPT_ENTRY_DIRTY(_)   (((_) >> 9) & 0x01)
                UINT64 UserModeExecute : 1;
#define EPT_ENTRY_USER_MODE_EXECUTE_BIT  10
#define EPT_ENTRY_USER_MODE_EXECUTE_FLAG 0x400
#define EPT_ENTRY_USER_MODE_EXECUTE_MASK 0x01
#define EPT_ENTRY_USER_MODE_EXECUTE(_)   (((_) >> 10) & 0x01)
                UINT64 Reserved1 : 1;
                UINT64 PageFrameNumber : 36;
#define EPT_ENTRY_PAGE_FRAME_NUMBER_BIT  12
#define EPT_ENTRY_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define EPT_ENTRY_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define EPT_ENTRY_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved2 : 15;
                UINT64 SuppressVe : 1;
#define EPT_ENTRY_SUPPRESS_VE_BIT  63
#define EPT_ENTRY_SUPPRESS_VE_FLAG 0x8000000000000000
#define EPT_ENTRY_SUPPRESS_VE_MASK 0x01
#define EPT_ENTRY_SUPPRESS_VE(_)   (((_) >> 63) & 0x01)
        } Fields;

        UINT64 AsUInt;
} EPT_ENTRY;

/**
 * @defgroup EPT_TABLE_LEVEL \
 *           EPT Table level numbers
 *
 * EPT Table level numbers.
 * @{
 */
#define EPT_LEVEL_PML4E 0x00000003
#define EPT_LEVEL_PDPTE 0x00000002
#define EPT_LEVEL_PDE   0x00000001
#define EPT_LEVEL_PTE   0x00000000
/**
 * @}
 */

/**
 * @defgroup EPT_ENTRY_COUNT \
 *           EPT Entry counts
 *
 * EPT Entry counts.
 * @{
 */
#define EPT_PML4E_ENTRY_COUNT 0x00000200
#define EPT_PDPTE_ENTRY_COUNT 0x00000200
#define EPT_PDE_ENTRY_COUNT   0x00000200
#define EPT_PTE_ENTRY_COUNT   0x00000200
/**
 * @}
 */

/**
 * @}
 */

typedef enum
{
        /**
         * If the INVEPT type is 1, the logical processor invalidates all guest-physical mappings
         * and combined mappings associated with the EP4TA specified in the INVEPT descriptor.
         * Combined mappings for that EP4TA are invalidated for all VPIDs and all PCIDs. (The
         * instruction may invalidate mappings associated with other EP4TAs.)
         */
        InveptSingleContext = 0x00000001,

        /**
         * If the INVEPT type is 2, the logical processor invalidates guest-physical mappings and
         * combined mappings associated with all EP4TAs (and, for combined mappings, for all VPIDs
         * and PCIDs).
         */
        InveptAllContext = 0x00000002,
} INVEPT_TYPE;

typedef enum
{
        /**
         * If the INVVPID type is 0, the logical processor invalidates linear mappings and combined
         * mappings associated with the VPID specified in the INVVPID descriptor and that would be
         * used to translate the linear address specified in of the INVVPID descriptor. Linear
         * mappings and combined mappings for that VPID and linear address are invalidated for all
         * PCIDs and, for combined mappings, all EP4TAs. (The instruction may also invalidate
         * mappings associated with other VPIDs and for other linear addresses).
         */
        InvvpidIndividualAddress = 0x00000000,

        /**
         * If the INVVPID type is 1, the logical processor invalidates all linear mappings and
         * combined mappings associated with the VPID specified in the INVVPID descriptor. Linear
         * mappings and combined mappings for that VPID are invalidated for all PCIDs and, for
         * combined mappings, all EP4TAs. (The instruction may also invalidate mappings associated
         * with other VPIDs).
         */
        InvvpidSingleContext = 0x00000001,

        /**
         * If the INVVPID type is 2, the logical processor invalidates linear mappings and combined
         * mappings associated with all VPIDs except VPID 0000H and with all PCIDs. (The instruction
         * may also invalidate linear mappings with VPID 0000H.) Combined mappings are invalidated
         * for all EP4TAs.
         */
        InvvpidAllContext = 0x00000002,

        /**
         * If the INVVPID type is 3, the logical processor invalidates linear mappings and combined
         * mappings associated with the VPID specified in the INVVPID descriptor. Linear mappings
         * and combined mappings for that VPID are invalidated for all PCIDs and, for combined
         * mappings, all EP4TAs. The logical processor is not required to invalidate information
         * that was used for global translations (although it may do so). (The instruction may also
         * invalidate mappings associated with other VPIDs).
         *
         * @see Vol3C[4.10(Caching Translation Information)]
         */
        InvvpidSingleContextRetainingGlobals = 0x00000003,
} INVVPID_TYPE;

typedef struct
{
        UINT64 EptPointer;

        /**
         * Must be zero.
         */
        UINT64 Reserved;
} INVEPT_DESCRIPTOR;

typedef struct
{
        UINT16 Vpid;

        /**
         * Must be zero.
         */
        UINT16 Reserved1;

        /**
         * Must be zero.
         */
        UINT32 Reserved2;
        UINT64 LinearAddress;
} INVVPID_DESCRIPTOR;

/**
 * @brief Hypervisor-Managed linear-Address Translation Pointer (HLATP)
 *
 * The hypervisor-managed linear-address translation pointer (HLAT pointer or HLATP) is used by HLAT
 * paging to locate and access the first paging structure used for linear-address translation.
 *
 * @see Vol3A[4.5(4-LEVEL PAGING AND 5-LEVEL PAGING)]
 */
typedef union
{
        struct
        {
                UINT64 Reserved1 : 3;

                /**
                 * [Bit 3] Page-level write-through; indirectly determines the memory type used to
                 * access the first HLAT paging structure during linear-address translation.
                 */
                UINT64 PageLevelWriteThrough : 1;
#define HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH_BIT  3
#define HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH_FLAG 0x08
#define HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH_MASK 0x01
#define HLAT_POINTER_PAGE_LEVEL_WRITE_THROUGH(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] Page-level cache disable; indirectly determines the memory type used to
                 * access the first HLAT paging structure during linear-address translation.
                 */
                UINT64 PageLevelCacheDisable : 1;
#define HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE_BIT  4
#define HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE_FLAG 0x10
#define HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE_MASK 0x01
#define HLAT_POINTER_PAGE_LEVEL_CACHE_DISABLE(_)   (((_) >> 4) & 0x01)
                UINT64 Reserved2 : 7;

                /**
                 * [Bits 47:12] Guest-physical address (4KB-aligned) of the first HLAT paging
                 * structure during linear-address translation)
                 */
                UINT64 PageFrameNumber : 36;
#define HLAT_POINTER_PAGE_FRAME_NUMBER_BIT  12
#define HLAT_POINTER_PAGE_FRAME_NUMBER_FLAG 0xFFFFFFFFF000
#define HLAT_POINTER_PAGE_FRAME_NUMBER_MASK 0xFFFFFFFFF
#define HLAT_POINTER_PAGE_FRAME_NUMBER(_)   (((_) >> 12) & 0xFFFFFFFFF)
                UINT64 Reserved3 : 16;
        };

        UINT64 AsUInt;
} HLAT_POINTER;

/**
 * @brief Format of the VMCS Region
 *
 * A logical processor uses virtual-machine control data structures (VMCSs) while it is in VMX
 * operation. These manage transitions into and out of VMX non-root operation (VM entries and VM
 * exits) as well as processor behavior in VMX non-root operation. This structure is manipulated by
 * the new instructions VMCLEAR, VMPTRLD, VMREAD, and VMWRITE. A VMCS region comprises up to
 * 4-KBytes. The exact size is implementation specific and can be determined by consulting the VMX
 * capability MSR IA32_VMX_BASIC.
 *
 * @see Vol3C[24.2(FORMAT OF THE VMCS REGION)] (reference)
 */
typedef struct
{
        struct
        {
                /**
                 * @brief VMCS revision identifier
                 *
                 * [Bits 30:0] Processors that maintain VMCS data in different formats (see below)
                 * use different VMCS revision identifiers. These identifiers enable software to
                 * avoid using a VMCS region formatted for one processor on a processor that uses a
                 * different format.
                 * Software should write the VMCS revision identifier to the VMCS region before
                 * using that region for a VMCS. The VMCS revision identifier is never written by
                 * the processor; VMPTRLD fails if its operand references a VMCS region whose VMCS
                 * revision identifier differs from that used by the processor.
                 * Software can discover the VMCS revision identifier that a processor uses by
                 * reading the VMX capability MSR IA32_VMX_BASIC.
                 *
                 * @see Vol3C[24.6.2(Processor-Based VM-Execution Controls)]
                 * @see Vol3D[A.1(BASIC VMX INFORMATION)]
                 */
                UINT32 RevisionId : 31;

                /**
                 * @brief Shadow-VMCS indicator
                 *
                 * [Bit 31] Software should clear or set the shadow-VMCS indicator depending on
                 * whether the VMCS is to be an ordinary VMCS or a shadow VMCS. VMPTRLD fails if the
                 * shadow-VMCS indicator is set and the processor does not support the 1-setting of
                 * the "VMCS shadowing" VM-execution control. Software can discover support for this
                 * setting by reading the VMX capability MSR IA32_VMX_PROCBASED_CTLS2.
                 *
                 * @see Vol3C[24.10(VMCS TYPES ORDINARY AND SHADOW)]
                 */
                UINT32 ShadowVmcsIndicator : 1;
        };

        /**
         * @brief VMX-abort indicator
         *
         * The contents of these bits do not control processor operation in any way. A logical
         * processor writes a non-zero value into these bits if a VMX abort occurs. Software may
         * also write into this field.
         *
         * @see Vol3D[27.7(VMX Aborts)]
         */
        UINT32 AbortIndicator;

        /**
         * @brief VMCS data (implementation-specific format)
         *
         * These parts of the VMCS control VMX non-root operation and the VMX transitions.
         * The format of these data is implementation-specific. To ensure proper behavior in VMX
         * operation, software should maintain the VMCS region and related structures in writeback
         * cacheable memory. Future implementations may allow or require a different memory type.
         * Software should consult the VMX capability MSR IA32_VMX_BASIC.
         *
         * @see Vol3C[24.11.4(Software Access to Related Structures)]
         * @see Vol3D[A.1(BASIC VMX INFORMATION)]
         */
        UINT8 Data[4088];
} VMCS;

/**
 * @brief Format of the VMXON Region
 *
 * Before executing VMXON, software allocates a region of memory that the logical processor uses to
 * support VMX operation. This region is called the VMXON region. A VMXON region comprises up to
 * 4-KBytes. The exact size is implementation specific and can be determined by consulting the VMX
 * capability MSR IA32_VMX_BASIC.
 *
 * @see Vol3C[24.11.5(VMXON Region)] (reference)
 */
typedef struct
{
        struct
        {
                /**
                 * @brief VMCS revision identifier
                 *
                 * [Bits 30:0] Before executing VMXON, software should write the VMCS revision
                 * identifier to the VMXON region. (Specifically, it should write the 31-bit VMCS
                 * revision identifier to bits 30:0 of the first 4 bytes of the VMXON region; bit 31
                 * should be cleared to 0.)
                 *
                 * @see VMCS
                 * @see Vol3C[24.2(FORMAT OF THE VMCS REGION)]
                 * @see Vol3C[24.11.5(VMXON Region)]
                 */
                UINT32 RevisionId : 31;

                /**
                 * [Bit 31] Bit 31 is always 0.
                 */
                UINT32 MustBeZero : 1;
        };

        /**
         * @brief VMXON data (implementation-specific format)
         *
         * The format of these data is implementation-specific. To ensure proper behavior in VMX
         * operation, software should not access or modify the VMXON region of a logical processor
         * between execution of VMXON and VMXOFF on that logical processor. Doing otherwise may lead
         * to unpredictable behavior.
         *
         * @see Vol3C[24.11.4(Software Access to Related Structures)]
         * @see Vol3D[A.1(BASIC VMX INFORMATION)]
         */
        UINT8 Data[4092];
} VMXON;

/**
 * @defgroup VMCS_FIELDS \
 *           VMCS (VM Control Structure)
 *
 * Every component of the VMCS is encoded by a 32-bit field that can be used by VMREAD and VMWRITE.
 * This enumerates all fields in the VMCS and their encodings. Fields are grouped by width (16-bit,
 * 32-bit, etc.) and type (guest-state, host-state, etc.).
 *
 * @see Vol3D[B(APPENDIX B FIELD ENCODING IN VMCS)] (reference)
 * @{
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] Access type (0 = full; 1 = high); must be full for 16-bit, 32-bit, and
                 * natural-width fields.
                 */
                UINT16 AccessType : 1;
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_BIT  0
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_FLAG 0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE_MASK 0x01
#define VMCS_COMPONENT_ENCODING_ACCESS_TYPE(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bits 9:1] Index.
                 */
                UINT16 Index : 9;
#define VMCS_COMPONENT_ENCODING_INDEX_BIT  1
#define VMCS_COMPONENT_ENCODING_INDEX_FLAG 0x3FE
#define VMCS_COMPONENT_ENCODING_INDEX_MASK 0x1FF
#define VMCS_COMPONENT_ENCODING_INDEX(_)   (((_) >> 1) & 0x1FF)

                /**
                 * [Bits 11:10] Type:
                 * 0: control
                 * 1: VM-exit information
                 * 2: guest state
                 * 3: host state
                 */
                UINT16 Type : 2;
#define VMCS_COMPONENT_ENCODING_TYPE_BIT  10
#define VMCS_COMPONENT_ENCODING_TYPE_FLAG 0xC00
#define VMCS_COMPONENT_ENCODING_TYPE_MASK 0x03
#define VMCS_COMPONENT_ENCODING_TYPE(_)   (((_) >> 10) & 0x03)

                /**
                 * [Bit 12] Reserved (must be 0).
                 */
                UINT16 MustBeZero : 1;
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_BIT  12
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_FLAG 0x1000
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO_MASK 0x01
#define VMCS_COMPONENT_ENCODING_MUST_BE_ZERO(_)   (((_) >> 12) & 0x01)

                /**
                 * [Bits 14:13] Width:
                 * 0: 16-bit
                 * 1: 64-bit
                 * 2: 32-bit
                 * 3: natural-width
                 */
                UINT16 Width : 2;
#define VMCS_COMPONENT_ENCODING_WIDTH_BIT  13
#define VMCS_COMPONENT_ENCODING_WIDTH_FLAG 0x6000
#define VMCS_COMPONENT_ENCODING_WIDTH_MASK 0x03
#define VMCS_COMPONENT_ENCODING_WIDTH(_)   (((_) >> 13) & 0x03)
                UINT16 Reserved1 : 1;
        };

        UINT16 AsUInt;
} VMCS_COMPONENT_ENCODING;

/**
 * @defgroup VMCS_16_BIT \
 *           16-Bit Fields
 *
 * 16-Bit Fields.
 *
 * @see Vol3D[B.1(16-BIT FIELDS)] (reference)
 * @{
 */
/**
 * @defgroup VMCS_16_BIT_CONTROL_FIELDS \
 *           16-Bit Control Fields
 *
 * 16-Bit Control Fields.
 * @{
 */
/**
 * Virtual-processor identifier (VPID).
 *
 * @remarks This field exists only on processors that support the 1-setting of the "enable VPID"
 * VM-execution control.
 */
#define VMCS_CTRL_VIRTUAL_PROCESSOR_IDENTIFIER 0x00000000

/**
 * Posted-interrupt notification vector.
 *
 * @remarks This field exists only on processors that support the 1-setting of the "process posted
 * interrupts" VM-execution control.
 */
#define VMCS_CTRL_POSTED_INTERRUPT_NOTIFICATION_VECTOR 0x00000002

/**
 * EPTP index.
 *
 * @remarks This field exists only on processors that support the 1-setting of the "EPT-violation
 * \#VE" VM-execution control.
 */
#define VMCS_CTRL_EPTP_INDEX 0x00000004

/**
 * HLAT prefix size.
 *
 * @remarks This field exists only on processors that support the 1-setting of the "enable HLAT"
 * VM-execution control.
 */
#define VMCS_CTRL_HLAT_PREFIX_SIZE 0x00000006
/**
 * @}
 */

/**
 * @defgroup VMCS_16_BIT_GUEST_STATE_FIELDS \
 *           16-Bit Guest-State Fields
 *
 * 16-Bit Guest-State Fields.
 * @{
 */
/**
 * Guest ES selector.
 */
#define VMCS_GUEST_ES_SELECTOR 0x00000800

/**
 * Guest CS selector.
 */
#define VMCS_GUEST_CS_SELECTOR 0x00000802

/**
 * Guest SS selector.
 */
#define VMCS_GUEST_SS_SELECTOR 0x00000804

/**
 * Guest DS selector.
 */
#define VMCS_GUEST_DS_SELECTOR 0x00000806

/**
 * Guest FS selector.
 */
#define VMCS_GUEST_FS_SELECTOR 0x00000808

/**
 * Guest GS selector.
 */
#define VMCS_GUEST_GS_SELECTOR 0x0000080A

/**
 * Guest LDTR selector.
 */
#define VMCS_GUEST_LDTR_SELECTOR 0x0000080C

/**
 * Guest TR selector.
 */
#define VMCS_GUEST_TR_SELECTOR 0x0000080E

/**
 * Guest interrupt status.
 *
 * @remarks This field exists only on processors that support the 1-setting of the
 * "virtual-interrupt delivery" VM-execution control.
 */
#define VMCS_GUEST_INTERRUPT_STATUS 0x00000810

/**
 * PML index.
 *
 * @remarks This field exists only on processors that support the 1-setting of the "enable PML"
 * VM-execution control.
 */
#define VMCS_GUEST_PML_INDEX 0x00000812
/**
 * @}
 */

/**
 * @defgroup VMCS_16_BIT_HOST_STATE_FIELDS \
 *           16-Bit Host-State Fields
 *
 * 16-Bit Host-State Fields.
 * @{
 */
/**
 * Host ES selector.
 */
#define VMCS_HOST_ES_SELECTOR 0x00000C00

/**
 * Host CS selector.
 */
#define VMCS_HOST_CS_SELECTOR 0x00000C02

/**
 * Host SS selector.
 */
#define VMCS_HOST_SS_SELECTOR 0x00000C04

/**
 * Host DS selector.
 */
#define VMCS_HOST_DS_SELECTOR 0x00000C06

/**
 * Host FS selector.
 */
#define VMCS_HOST_FS_SELECTOR 0x00000C08

/**
 * Host GS selector.
 */
#define VMCS_HOST_GS_SELECTOR 0x00000C0A

/**
 * Host TR selector.
 */
#define VMCS_HOST_TR_SELECTOR 0x00000C0C
/**
 * @}
 */

/**
 * @}
 */

/**
 * @defgroup VMCS_64_BIT \
 *           64-Bit Fields
 *
 * 64-Bit Fields.
 *
 * @see Vol3D[B.2(64-BIT FIELDS)] (reference)
 * @{
 */
/**
 * @defgroup VMCS_64_BIT_CONTROL_FIELDS \
 *           64-Bit Control Fields
 *
 * 64-Bit Control Fields.
 * @{
 */
/**
 * Address of I/O bitmap A.
 */
#define VMCS_CTRL_IO_BITMAP_A_ADDRESS 0x00002000

/**
 * Address of I/O bitmap B.
 */
#define VMCS_CTRL_IO_BITMAP_B_ADDRESS 0x00002002

/**
 * Address of MSR bitmaps.
 */
#define VMCS_CTRL_MSR_BITMAP_ADDRESS 0x00002004

/**
 * VM-exit MSR-store address.
 */
#define VMCS_CTRL_VMEXIT_MSR_STORE_ADDRESS 0x00002006

/**
 * VM-exit MSR-load address.
 */
#define VMCS_CTRL_VMEXIT_MSR_LOAD_ADDRESS 0x00002008

/**
 * VM-entry MSR-load address.
 */
#define VMCS_CTRL_VMENTRY_MSR_LOAD_ADDRESS 0x0000200A

/**
 * Executive-VMCS pointer.
 */
#define VMCS_CTRL_EXECUTIVE_VMCS_POINTER 0x0000200C

/**
 * PML address.
 */
#define VMCS_CTRL_PML_ADDRESS 0x0000200E

/**
 * TSC offset.
 */
#define VMCS_CTRL_TSC_OFFSET 0x00002010

/**
 * Virtual-APIC address.
 */
#define VMCS_CTRL_VIRTUAL_APIC_ADDRESS 0x00002012

/**
 * APIC-access address.
 */
#define VMCS_CTRL_APIC_ACCESS_ADDRESS 0x00002014

/**
 * Posted-interrupt descriptor address
 */
#define VMCS_CTRL_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS 0x00002016

/**
 * VM-function controls.
 */
#define VMCS_CTRL_VMFUNC_CONTROLS 0x00002018

/**
 * EPT pointer.
 */
#define VMCS_CTRL_EPT_POINTER 0x0000201A

/**
 * EOI-exit bitmap 0.
 */
#define VMCS_CTRL_EOI_EXIT_BITMAP_0 0x0000201C

/**
 * EOI-exit bitmap 1.
 */
#define VMCS_CTRL_EOI_EXIT_BITMAP_1 0x0000201E

/**
 * EOI-exit bitmap 2.
 */
#define VMCS_CTRL_EOI_EXIT_BITMAP_2 0x00002020

/**
 * EOI-exit bitmap 3.
 */
#define VMCS_CTRL_EOI_EXIT_BITMAP_3 0x00002022

/**
 * EPTP-list address.
 */
#define VMCS_CTRL_EPT_POINTER_LIST_ADDRESS 0x00002024

/**
 * VMREAD-bitmap address.
 */
#define VMCS_CTRL_VMREAD_BITMAP_ADDRESS 0x00002026

/**
 * VMWRITE-bitmap address.
 */
#define VMCS_CTRL_VMWRITE_BITMAP_ADDRESS 0x00002028

/**
 * Virtualization-exception information address.
 */
#define VMCS_CTRL_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS 0x0000202A

/**
 * XSS-exiting bitmap.
 */
#define VMCS_CTRL_XSS_EXITING_BITMAP 0x0000202C

/**
 * ENCLS-exiting bitmap.
 */
#define VMCS_CTRL_ENCLS_EXITING_BITMAP 0x0000202E

/**
 * Sub-page-permission-table pointer.
 */
#define VMCS_CTRL_SUB_PAGE_PERMISSION_TABLE_POINTER 0x00002030

/**
 * TSC multiplier.
 */
#define VMCS_CTRL_TSC_MULTIPLIER 0x00002032

/**
 * Tertiary processor-based VM-execution controls.
 */
#define VMCS_CTRL_TERTIARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS 0x00002034

/**
 * ENCLV-exiting bitmap.
 */
#define VMCS_CTRL_ENCLV_EXITING_BITMAP 0x00002036

/**
 * Hypervisor-managed linear-address translation pointer.
 */
#define VMCS_CTRL_HLAT_POINTER 0x00002040

/**
 * Secondary VM-exit controls.
 */
#define VMCS_CTRL_SECONDARY_VMEXIT_CONTROLS 0x00002044
/**
 * @}
 */

/**
 * @defgroup VMCS_64_BIT_READ_ONLY_DATA_FIELDS \
 *           64-Bit Read-Only Data Field
 *
 * 64-Bit Read-Only Data Field.
 * @{
 */
/**
 * Guest-physical address.
 */
#define VMCS_GUEST_PHYSICAL_ADDRESS 0x00002400
/**
 * @}
 */

/**
 * @defgroup VMCS_64_BIT_GUEST_STATE_FIELDS \
 *           64-Bit Guest-State Fields
 *
 * 64-Bit Guest-State Fields.
 * @{
 */
/**
 * VMCS link pointer.
 */
#define VMCS_GUEST_VMCS_LINK_POINTER 0x00002800

/**
 * Guest IA32_DEBUGCTL.
 */
#define VMCS_GUEST_DEBUGCTL 0x00002802

/**
 * Guest IA32_PAT.
 */
#define VMCS_GUEST_PAT 0x00002804

/**
 * Guest IA32_EFER.
 */
#define VMCS_GUEST_EFER 0x00002806

/**
 * Guest IA32_PERF_GLOBAL_CTRL.
 */
#define VMCS_GUEST_PERF_GLOBAL_CTRL 0x00002808

/**
 * Guest PDPTE0.
 */
#define VMCS_GUEST_PDPTE0 0x0000280A

/**
 * Guest PDPTE1.
 */
#define VMCS_GUEST_PDPTE1 0x0000280C

/**
 * Guest PDPTE2.
 */
#define VMCS_GUEST_PDPTE2 0x0000280E

/**
 * Guest PDPTE3.
 */
#define VMCS_GUEST_PDPTE3 0x00002810

/**
 * Guest IA32_BNDCFGS.
 */
#define VMCS_GUEST_BNDCFGS 0x00002812

/**
 * Guest IA32_RTIT_CTL.
 */
#define VMCS_GUEST_RTIT_CTL 0x00002814

/**
 * Guest IA32_LBR_CTL.
 */
#define VMCS_GUEST_LBR_CTL 0x00002816

/**
 * Guest IA32_PKRS
 */
#define VMCS_GUEST_PKRS 0x00002818
/**
 * @}
 */

/**
 * @defgroup VMCS_64_BIT_HOST_STATE_FIELDS \
 *           64-Bit Host-State Fields
 *
 * 64-Bit Host-State Fields.
 * @{
 */
/**
 * Host IA32_PAT.
 */
#define VMCS_HOST_PAT 0x00002C00

/**
 * Host IA32_EFER.
 */
#define VMCS_HOST_EFER 0x00002C02

/**
 * Host IA32_PERF_GLOBAL_CTRL.
 */
#define VMCS_HOST_PERF_GLOBAL_CTRL 0x00002C04

/**
 * Host IA32_PKRS
 */
#define VMCS_HOST_PKRS 0x00002C06
/**
 * @}
 */

/**
 * @}
 */

/**
 * @defgroup VMCS_32_BIT \
 *           32-Bit Fields
 *
 * 32-Bit Fields.
 *
 * @see Vol3D[B.3(32-BIT FIELDS)] (reference)
 * @{
 */
/**
 * @defgroup VMCS_32_BIT_CONTROL_FIELDS \
 *           32-Bit Control Fields
 *
 * 32-Bit Control Fields.
 * @{
 */
/**
 * Pin-based VM-execution controls.
 */
#define VMCS_CTRL_PIN_BASED_VM_EXECUTION_CONTROLS 0x00004000

/**
 * Primary processor-based VM-execution controls.
 */
#define VMCS_CTRL_PROCESSOR_BASED_VM_EXECUTION_CONTROLS 0x00004002

/**
 * Exception bitmap.
 */
#define VMCS_CTRL_EXCEPTION_BITMAP 0x00004004

/**
 * Page-fault error-code mask.
 */
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MASK 0x00004006

/**
 * Page-fault error-code match.
 */
#define VMCS_CTRL_PAGEFAULT_ERROR_CODE_MATCH 0x00004008

/**
 * CR3-target count.
 */
#define VMCS_CTRL_CR3_TARGET_COUNT 0x0000400A

/**
 * Primary VM-exit controls.
 */
#define VMCS_CTRL_PRIMARY_VMEXIT_CONTROLS 0x0000400C

/**
 * VM-exit MSR-store count.
 */
#define VMCS_CTRL_VMEXIT_MSR_STORE_COUNT 0x0000400E

/**
 * VM-exit MSR-load count.
 */
#define VMCS_CTRL_VMEXIT_MSR_LOAD_COUNT 0x00004010

/**
 * VM-entry controls.
 */
#define VMCS_CTRL_VMENTRY_CONTROLS 0x00004012

/**
 * VM-entry MSR-load count.
 */
#define VMCS_CTRL_VMENTRY_MSR_LOAD_COUNT 0x00004014

/**
 * VM-entry interruption-information field.
 */
#define VMCS_CTRL_VMENTRY_INTERRUPTION_INFORMATION_FIELD 0x00004016

/**
 * VM-entry exception error code.
 */
#define VMCS_CTRL_VMENTRY_EXCEPTION_ERROR_CODE 0x00004018

/**
 * VM-entry instruction length.
 */
#define VMCS_CTRL_VMENTRY_INSTRUCTION_LENGTH 0x0000401A

/**
 * TPR threshold.
 */
#define VMCS_CTRL_TPR_THRESHOLD 0x0000401C

/**
 * Secondary processor-based VM-execution controls.
 */
#define VMCS_CTRL_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS 0x0000401E

/**
 * PLE_Gap.
 */
#define VMCS_CTRL_PLE_GAP 0x00004020

/**
 * PLE_Window.
 */
#define VMCS_CTRL_PLE_WINDOW 0x00004022
/**
 * @}
 */

/**
 * @defgroup VMCS_32_BIT_READ_ONLY_DATA_FIELDS \
 *           32-Bit Read-Only Data Fields
 *
 * 32-Bit Read-Only Data Fields.
 * @{
 */
/**
 * VM-instruction error.
 */
#define VMCS_VM_INSTRUCTION_ERROR 0x00004400

/**
 * Exit reason.
 */
#define VMCS_EXIT_REASON 0x00004402

/**
 * VM-exit interruption information.
 */
#define VMCS_VMEXIT_INTERRUPTION_INFORMATION 0x00004404

/**
 * VM-exit interruption error code.
 */
#define VMCS_VMEXIT_INTERRUPTION_ERROR_CODE 0x00004406

/**
 * IDT-vectoring information field.
 */
#define VMCS_IDT_VECTORING_INFORMATION 0x00004408

/**
 * IDT-vectoring error code.
 */
#define VMCS_IDT_VECTORING_ERROR_CODE 0x0000440A

/**
 * VM-exit instruction length.
 */
#define VMCS_VMEXIT_INSTRUCTION_LENGTH 0x0000440C

/**
 * VM-exit instruction information.
 */
#define VMCS_VMEXIT_INSTRUCTION_INFO 0x0000440E
/**
 * @}
 */

/**
 * @defgroup VMCS_32_BIT_GUEST_STATE_FIELDS \
 *           32-Bit Guest-State Fields
 *
 * 32-Bit Guest-State Fields.
 * @{
 */
/**
 * Guest ES limit.
 */
#define VMCS_GUEST_ES_LIMIT 0x00004800

/**
 * Guest CS limit.
 */
#define VMCS_GUEST_CS_LIMIT 0x00004802

/**
 * Guest SS limit.
 */
#define VMCS_GUEST_SS_LIMIT 0x00004804

/**
 * Guest DS limit.
 */
#define VMCS_GUEST_DS_LIMIT 0x00004806

/**
 * Guest FS limit.
 */
#define VMCS_GUEST_FS_LIMIT 0x00004808

/**
 * Guest GS limit.
 */
#define VMCS_GUEST_GS_LIMIT 0x0000480A

/**
 * Guest LDTR limit.
 */
#define VMCS_GUEST_LDTR_LIMIT 0x0000480C

/**
 * Guest TR limit.
 */
#define VMCS_GUEST_TR_LIMIT 0x0000480E

/**
 * Guest GDTR limit.
 */
#define VMCS_GUEST_GDTR_LIMIT 0x00004810

/**
 * Guest IDTR limit.
 */
#define VMCS_GUEST_IDTR_LIMIT 0x00004812

/**
 * Guest ES access rights.
 */
#define VMCS_GUEST_ES_ACCESS_RIGHTS 0x00004814

/**
 * Guest CS access rights.
 */
#define VMCS_GUEST_CS_ACCESS_RIGHTS 0x00004816

/**
 * Guest SS access rights.
 */
#define VMCS_GUEST_SS_ACCESS_RIGHTS 0x00004818

/**
 * Guest DS access rights.
 */
#define VMCS_GUEST_DS_ACCESS_RIGHTS 0x0000481A

/**
 * Guest FS access rights.
 */
#define VMCS_GUEST_FS_ACCESS_RIGHTS 0x0000481C

/**
 * Guest GS access rights.
 */
#define VMCS_GUEST_GS_ACCESS_RIGHTS 0x0000481E

/**
 * Guest LDTR access rights.
 */
#define VMCS_GUEST_LDTR_ACCESS_RIGHTS 0x00004820

/**
 * Guest TR access rights.
 */
#define VMCS_GUEST_TR_ACCESS_RIGHTS 0x00004822

/**
 * Guest interruptibility state.
 */
#define VMCS_GUEST_INTERRUPTIBILITY_STATE 0x00004824

/**
 * Guest activity state.
 */
#define VMCS_GUEST_ACTIVITY_STATE 0x00004826

/**
 * Guest SMBASE.
 */
#define VMCS_GUEST_SMBASE 0x00004828

/**
 * Guest IA32_SYSENTER_CS.
 */
#define VMCS_GUEST_SYSENTER_CS 0x0000482A

/**
 * VMX-preemption timer value.
 */
#define VMCS_GUEST_VMX_PREEMPTION_TIMER_VALUE 0x0000482E
/**
 * @}
 */

/**
 * @defgroup VMCS_32_BIT_HOST_STATE_FIELDS \
 *           32-Bit Host-State Field
 *
 * 32-Bit Host-State Field.
 * @{
 */
/**
 * Host IA32_SYSENTER_CS.
 */
#define VMCS_HOST_SYSENTER_CS 0x00004C00
/**
 * @}
 */

/**
 * @}
 */

/**
 * @defgroup VMCS_NATURAL_WIDTH \
 *           Natural-Width Fields
 *
 * Natural-Width Fields.
 *
 * @see Vol3D[B.4(NATURAL-WIDTH FIELDS)] (reference)
 * @{
 */
/**
 * @defgroup VMCS_NATURAL_WIDTH_CONTROL_FIELDS \
 *           Natural-Width Control Fields
 *
 * Natural-Width Control Fields
 * @{
 */
/**
 * CR0 guest/host mask.
 */
#define VMCS_CTRL_CR0_GUEST_HOST_MASK 0x00006000

/**
 * CR4 guest/host mask.
 */
#define VMCS_CTRL_CR4_GUEST_HOST_MASK 0x00006002

/**
 * CR0 read shadow.
 */
#define VMCS_CTRL_CR0_READ_SHADOW 0x00006004

/**
 * CR4 read shadow.
 */
#define VMCS_CTRL_CR4_READ_SHADOW 0x00006006

/**
 * CR3-target value 0.
 */
#define VMCS_CTRL_CR3_TARGET_VALUE_0 0x00006008

/**
 * CR3-target value 1.
 */
#define VMCS_CTRL_CR3_TARGET_VALUE_1 0x0000600A

/**
 * CR3-target value 2.
 */
#define VMCS_CTRL_CR3_TARGET_VALUE_2 0x0000600C

/**
 * CR3-target value 3.
 */
#define VMCS_CTRL_CR3_TARGET_VALUE_3 0x0000600E
/**
 * @}
 */

/**
 * @defgroup VMCS_NATURAL_WIDTH_READ_ONLY_DATA_FIELDS \
 *           Natural-Width Read-Only Data Fields
 *
 * Natural-Width Read-Only Data Fields.
 * @{
 */
/**
 * Exit qualification.
 */
#define VMCS_EXIT_QUALIFICATION 0x00006400

/**
 * I/O RCX.
 */
#define VMCS_IO_RCX 0x00006402

/**
 * I/O RSI.
 */
#define VMCS_IO_RSI 0x00006404

/**
 * I/O RDI.
 */
#define VMCS_IO_RDI 0x00006406

/**
 * I/O RIP.
 */
#define VMCS_IO_RIP 0x00006408

/**
 * Guest-linear address.
 */
#define VMCS_EXIT_GUEST_LINEAR_ADDRESS 0x0000640A
/**
 * @}
 */

/**
 * @defgroup VMCS_NATURAL_WIDTH_GUEST_STATE_FIELDS \
 *           Natural-Width Guest-State Fields
 *
 * Natural-Width Guest-State Fields.
 * @{
 */
/**
 * Guest CR0.
 */
#define VMCS_GUEST_CR0 0x00006800

/**
 * Guest CR3.
 */
#define VMCS_GUEST_CR3 0x00006802

/**
 * Guest CR4.
 */
#define VMCS_GUEST_CR4 0x00006804

/**
 * Guest ES base.
 */
#define VMCS_GUEST_ES_BASE 0x00006806

/**
 * Guest CS base.
 */
#define VMCS_GUEST_CS_BASE 0x00006808

/**
 * Guest SS base.
 */
#define VMCS_GUEST_SS_BASE 0x0000680A

/**
 * Guest DS base.
 */
#define VMCS_GUEST_DS_BASE 0x0000680C

/**
 * Guest FS base.
 */
#define VMCS_GUEST_FS_BASE 0x0000680E

/**
 * Guest GS base.
 */
#define VMCS_GUEST_GS_BASE 0x00006810

/**
 * Guest LDTR base.
 */
#define VMCS_GUEST_LDTR_BASE 0x00006812

/**
 * Guest TR base.
 */
#define VMCS_GUEST_TR_BASE 0x00006814

/**
 * Guest GDTR base.
 */
#define VMCS_GUEST_GDTR_BASE 0x00006816

/**
 * Guest IDTR base.
 */
#define VMCS_GUEST_IDTR_BASE 0x00006818

/**
 * Guest DR7.
 */
#define VMCS_GUEST_DR7 0x0000681A

/**
 * Guest RSP.
 */
#define VMCS_GUEST_RSP 0x0000681C

/**
 * Guest RIP.
 */
#define VMCS_GUEST_RIP 0x0000681E

/**
 * Guest RFLAGS.
 */
#define VMCS_GUEST_RFLAGS 0x00006820

/**
 * Guest pending debug exceptions.
 */
#define VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS 0x00006822

/**
 * Guest IA32_SYSENTER_ESP.
 */
#define VMCS_GUEST_SYSENTER_ESP 0x00006824

/**
 * Guest IA32_SYSENTER_EIP.
 */
#define VMCS_GUEST_SYSENTER_EIP 0x00006826

/**
 * Guest IA32_S_CET.
 */
#define VMCS_GUEST_S_CET 0x00006C28

/**
 * Guest SSP.
 */
#define VMCS_GUEST_SSP 0x00006C2A

/**
 * Guest IA32_INTERRUPT_SSP_TABLE_ADDR.
 */
#define VMCS_GUEST_INTERRUPT_SSP_TABLE_ADDR 0x00006C2C
/**
 * @}
 */

/**
 * @defgroup VMCS_NATURAL_WIDTH_HOST_STATE_FIELDS \
 *           Natural-Width Host-State Fields
 *
 * Natural-Width Host-State Fields.
 * @{
 */
/**
 * Host CR0.
 */
#define VMCS_HOST_CR0 0x00006C00

/**
 * Host CR3.
 */
#define VMCS_HOST_CR3 0x00006C02

/**
 * Host CR4.
 */
#define VMCS_HOST_CR4 0x00006C04

/**
 * Host FS base.
 */
#define VMCS_HOST_FS_BASE 0x00006C06

/**
 * Host GS base.
 */
#define VMCS_HOST_GS_BASE 0x00006C08

/**
 * Host TR base.
 */
#define VMCS_HOST_TR_BASE 0x00006C0A

/**
 * Host GDTR base.
 */
#define VMCS_HOST_GDTR_BASE 0x00006C0C

/**
 * Host IDTR base.
 */
#define VMCS_HOST_IDTR_BASE 0x00006C0E

/**
 * Host IA32_SYSENTER_ESP.
 */
#define VMCS_HOST_SYSENTER_ESP 0x00006C10

/**
 * Host IA32_SYSENTER_EIP.
 */
#define VMCS_HOST_SYSENTER_EIP 0x00006C12

/**
 * Host RSP.
 */
#define VMCS_HOST_RSP 0x00006C14

/**
 * Host RIP.
 */
#define VMCS_HOST_RIP 0x00006C16

/**
 * Host IA32_S_CET.
 */
#define VMCS_HOST_S_CET 0x00006C18

/**
 * Host SSP.
 */
#define VMCS_HOST_SSP 0x00006C1A

/**
 * Host IA32_INTERRUPT_SSP_TABLE_ADDR.
 */
#define VMCS_HOST_INTERRUPT_SSP_TABLE_ADDR 0x00006C1C
/**
 * @}
 */

/**
 * @}
 */

/**
 * @}
 */

/**
 * @brief Valid interruption types
 */
typedef enum
{
        /**
         * External interrupt.
         */
        ExternalInterrupt = 0x00000000,

        /**
         * Non-maskable interrupt (NMI).
         */
        NonMaskableInterrupt = 0x00000002,

        /**
         * Hardware exception (e.g,. \#PF).
         */
        HardwareException = 0x00000003,

        /**
         * Software interrupt (INT n).
         */
        SoftwareInterrupt = 0x00000004,

        /**
         * Privileged software exception (INT1).
         */
        PrivilegedSoftwareException = 0x00000005,

        /**
         * Software exception (INT3 or INTO).
         */
        SoftwareException = 0x00000006,

        /**
         * Other event. This type is used for injection of events that are not delivered through the
         * IDT.
         */
        OtherEvent = 0x00000007,
} INTERRUPTION_TYPE;

/**
 * @brief VM entry can be configured to conclude by delivering an event through the IDT (after all
 * guest state and MSRs have been loaded). This process is called event injection and is controlled
 * by these VM-entry control fields
 *
 * @see Vol3A[24.8.3(VM-Entry Controls for Event Injection)] (reference)
 */
typedef union
{
        struct
        {
                /**
                 * @brief Vector of interrupt or exception
                 *
                 * [Bits 7:0] Determines which entry in the IDT is used or which other event is
                 * injected.
                 */
                UINT32 Vector : 8;
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_BIT  0
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_FLAG 0xFF
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR_MASK 0xFF
#define VMENTRY_INTERRUPT_INFORMATION_VECTOR(_)   (((_) >> 0) & 0xFF)

                /**
                 * @brief Interruption type
                 *
                 * [Bits 10:8] Determines details of how the injection is performed.
                 */
                UINT32 InterruptionType : 3;
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT  8
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG 0x700
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK 0x07
#define VMENTRY_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_)   (((_) >> 8) & 0x07)

                /**
                 * @brief Deliver error code (0 = do not deliver; 1 = deliver)
                 *
                 * [Bit 11] Determines whether delivery pushes an error code on the guest stack.
                 */
                UINT32 DeliverErrorCode : 1;
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_BIT  11
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_FLAG 0x800
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE_MASK 0x01
#define VMENTRY_INTERRUPT_INFORMATION_DELIVER_ERROR_CODE(_)   (((_) >> 11) & 0x01)
                UINT32 Reserved1 : 19;

                /**
                 * @brief Valid
                 *
                 * [Bit 31] VM entry injects an event if and only if the valid bit is 1. The valid
                 * bit in this field is cleared on every VM exit.
                 */
                UINT32 Valid : 1;
#define VMENTRY_INTERRUPT_INFORMATION_VALID_BIT  31
#define VMENTRY_INTERRUPT_INFORMATION_VALID_FLAG 0x80000000
#define VMENTRY_INTERRUPT_INFORMATION_VALID_MASK 0x01
#define VMENTRY_INTERRUPT_INFORMATION_VALID(_)   (((_) >> 31) & 0x01)
        };

        UINT32 AsUInt;
} VMENTRY_INTERRUPT_INFORMATION;

/**
 * @brief VM entry can be configured to conclude by delivering an event through the IDT (after all
 * guest state and MSRs have been loaded). This process is called event injection and is controlled
 * by these VM-entry control fields
 *
 * @see Vol3A[24.9.2(Information for VM Exits Due to Vectored Events)] (reference)
 */
typedef union
{
        struct
        {
                /**
                 * [Bits 7:0] Vector of interrupt or exception.
                 */
                UINT32 Vector : 8;
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_BIT  0
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_FLAG 0xFF
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR_MASK 0xFF
#define VMEXIT_INTERRUPT_INFORMATION_VECTOR(_)   (((_) >> 0) & 0xFF)

                /**
                 * [Bits 10:8] Interruption type.
                 */
                UINT32 InterruptionType : 3;
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_BIT  8
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_FLAG 0x700
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE_MASK 0x07
#define VMEXIT_INTERRUPT_INFORMATION_INTERRUPTION_TYPE(_)   (((_) >> 8) & 0x07)

                /**
                 * [Bit 11] Deliver error code (0 = do not deliver; 1 = deliver).
                 */
                UINT32 ErrorCodeValid : 1;
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_BIT  11
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_FLAG 0x800
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID_MASK 0x01
#define VMEXIT_INTERRUPT_INFORMATION_ERROR_CODE_VALID(_)   (((_) >> 11) & 0x01)

                /**
                 * [Bit 12] NMI unblocking due to IRET.
                 */
                UINT32 NmiUnblocking : 1;
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_BIT  12
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_FLAG 0x1000
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING_MASK 0x01
#define VMEXIT_INTERRUPT_INFORMATION_NMI_UNBLOCKING(_)   (((_) >> 12) & 0x01)
                UINT32 Reserved1 : 18;

                /**
                 * [Bit 31] Valid.
                 */
                UINT32 Valid : 1;
#define VMEXIT_INTERRUPT_INFORMATION_VALID_BIT  31
#define VMEXIT_INTERRUPT_INFORMATION_VALID_FLAG 0x80000000
#define VMEXIT_INTERRUPT_INFORMATION_VALID_MASK 0x01
#define VMEXIT_INTERRUPT_INFORMATION_VALID(_)   (((_) >> 31) & 0x01)
        };

        UINT32 AsUInt;
} VMEXIT_INTERRUPT_INFORMATION;

/**
 * @}
 */

/**
 * @defgroup APIC \
 *           Advanced Programmable Interrupt Controller (APIC)
 *
 * Software interacts with the local APIC by reading and writing its registers. APIC registers are
 * memory-mapped to a 4-KByte region of the processor's physical address space with an initial
 * starting address of FEE00000H. For correct APIC operation, this address space must be mapped to
 * an area of memory that has been designated as strong uncacheable (UC).
 *
 * @remarks Registers are 32 bits, 64 bits, or 256 bits in width; all are aligned on 128-bit
 * boundaries. All 32-bit registers should be accessed using 128-bit aligned 32-bit loads or stores.
 * Some processors may support loads and stores of less than 32 bits to some of the APIC registers.
 * This is model specific behavior and is not guaranteed to work on all processors. Any FP/MMX/SSE
 * access to an APIC register, or any access that touches bytes 4 through 15 of an APIC register may
 * cause undefined behavior and must not be executed. This undefined behavior could include hangs,
 * incorrect results or unexpected exceptions, including machine checks, and may vary between
 * implementations. Wider registers (64-bit or 256-bit) must be accessed using multiple 32-bit loads
 * or stores, with all accesses being 128-bit aligned.
 * @see Vol3A[10.4.1(The Local APIC Block Diagram)] (reference)
 * @{
 */
/**
 * Local APIC Base Address.
 *
 * @remarks Reserved.
 */
#define APIC_BASE_ADDRESS 0xFEE00000

/**
 * Local APIC ID Register.
 */
#define APIC_ID 0x00000020

/**
 * Local APIC Version Register.
 */
#define APIC_VERSION 0x00000030

/**
 * Task Priority Register (TPR).
 */
#define APIC_TASK_PRIORITY 0x00000080

/**
 * Arbitration Priority Register (APR).
 */
#define APIC_ARBITRATION_PRIORITY 0x00000090

/**
 * Processor Priority Register (PPR).
 */
#define APIC_PROCESSOR_PRIORITY 0x000000A0

/**
 * EOI Register.
 */
#define APIC_EOI 0x000000B0

/**
 * Remote Read Register (RRD).
 */
#define APIC_REMOTE_READ 0x000000C0

/**
 * Logical Destination Register.
 */
#define APIC_LOGICAL_DESTINATION 0x000000D0

/**
 * Destination Format Register.
 *
 * @see Vol3A[10.6.2.2(Logical Destination Mode)]
 */
#define APIC_DESTINATION_FORMAT 0x000000E0

/**
 * Spurious Interrupt Vector Register.
 *
 * @see Vol3A[10.9(SPURIOUS INTERRUPT)]
 */
#define APIC_SPURIOUS_INTERRUPT_VECTOR 0x000000F0

/**
 * In-Service Register (ISR); bits 31:0.
 */
#define APIC_IN_SERVICE_BITS_31_0 0x00000100

/**
 * In-Service Register (ISR); bits 63:32.
 */
#define APIC_IN_SERVICE_BITS_63_32 0x00000110

/**
 * In-Service Register (ISR); bits 95:64.
 */
#define APIC_IN_SERVICE_BITS_95_64 0x00000120

/**
 * In-Service Register (ISR); bits 127:96.
 */
#define APIC_IN_SERVICE_BITS_127_96 0x00000130

/**
 * In-Service Register (ISR); bits 159:128.
 */
#define APIC_IN_SERVICE_BITS_159_128 0x00000140

/**
 * In-Service Register (ISR); bits 191:160.
 */
#define APIC_IN_SERVICE_BITS_191_160 0x00000150

/**
 * In-Service Register (ISR); bits 223:192.
 */
#define APIC_IN_SERVICE_BITS_223_192 0x00000160

/**
 * In-Service Register (ISR); bits 255:224.
 */
#define APIC_IN_SERVICE_BITS_255_224 0x00000170

/**
 * Trigger Mode Register (TMR); bits 31:0.
 */
#define APIC_TRIGGER_MODE_BITS_31_0 0x00000180

/**
 * Trigger Mode Register (TMR); bits 63:32.
 */
#define APIC_TRIGGER_MODE_BITS_63_32 0x00000190

/**
 * Trigger Mode Register (TMR); bits 95:64.
 */
#define APIC_TRIGGER_MODE_BITS_95_64 0x000001A0

/**
 * Trigger Mode Register (TMR); bits 127:96.
 */
#define APIC_TRIGGER_MODE_BITS_127_96 0x000001B0

/**
 * Trigger Mode Register (TMR); bits 159:128.
 */
#define APIC_TRIGGER_MODE_BITS_159_128 0x000001C0

/**
 * Trigger Mode Register (TMR); bits 191:160.
 */
#define APIC_TRIGGER_MODE_BITS_191_160 0x000001D0

/**
 * Trigger Mode Register (TMR); bits 223:192.
 */
#define APIC_TRIGGER_MODE_BITS_223_192 0x000001E0

/**
 * Trigger Mode Register (TMR); bits 255:224.
 */
#define APIC_TRIGGER_MODE_BITS_255_224 0x000001F0

/**
 * Interrupt Request Register (IRR); bits 31:0.
 */
#define APIC_INTERRUPT_REQUEST_BITS_31_0 0x00000200

/**
 * Interrupt Request Register (IRR); bits 63:32.
 */
#define APIC_INTERRUPT_REQUEST_BITS_63_32 0x00000210

/**
 * Interrupt Request Register (IRR); bits 95:64.
 */
#define APIC_INTERRUPT_REQUEST_BITS_95_64 0x00000220

/**
 * Interrupt Request Register (IRR); bits 127:96.
 */
#define APIC_INTERRUPT_REQUEST_BITS_127_96 0x00000230

/**
 * Interrupt Request Register (IRR); bits 159:128.
 */
#define APIC_INTERRUPT_REQUEST_BITS_159_128 0x00000240

/**
 * Interrupt Request Register (IRR); bits 191:160.
 */
#define APIC_INTERRUPT_REQUEST_BITS_191_160 0x00000250

/**
 * Interrupt Request Register (IRR); bits 223:192.
 */
#define APIC_INTERRUPT_REQUEST_BITS_223_192 0x00000260

/**
 * Interrupt Request Register (IRR); bits 255:224.
 */
#define APIC_INTERRUPT_REQUEST_BITS_255_224 0x00000270

/**
 * Error Status Register.
 */
#define APIC_ERROR_STATUS 0x00000280

/**
 * LVT Corrected Machine Check Interrupt (CMCI) Register.
 */
#define APIC_LVT_CORRECTED_MACHINE_CHECK_INTERRUPT 0x000002F0

/**
 * Interrupt Command Register (ICR); bits 0-31.
 */
#define APIC_INTERRUPT_COMMAND_BITS_0_31 0x00000300

/**
 * Interrupt Command Register (ICR); bits 32-63.
 */
#define APIC_INTERRUPT_COMMAND_BITS_32_63 0x00000310

/**
 * LVT Timer Register.
 */
#define APIC_LVT_TIMER 0x00000320

/**
 * LVT Thermal Sensor Register.
 */
#define APIC_LVT_THERMAL_SENSOR 0x00000330

/**
 * LVT Performance Monitoring Counters Register.
 */
#define APIC_LVT_PERFORMANCE_MONITORING_COUNTERS 0x00000340

/**
 * LVT LINT0 Register.
 */
#define APIC_LVT_LINT0 0x00000350

/**
 * LVT LINT1 Register.
 */
#define APIC_LVT_LINT1 0x00000360

/**
 * LVT Error Register.
 */
#define APIC_LVT_ERROR 0x00000370

/**
 * Initial Count Register (for Timer).
 */
#define APIC_INITIAL_COUNT 0x00000380

/**
 * Current Count Register (for Timer).
 */
#define APIC_CURRENT_COUNT 0x00000390

/**
 * Divide Configuration Register (for Timer).
 */
#define APIC_DIVIDE_CONFIGURATION 0x000003E0
/**
 * @}
 */

/**
 * The 32-bit EFLAGS register contains a group of status flags, a control flag, and a group of
 * system flags. The status flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the
 * results of arithmetic instructions, such as the ADD, SUB, MUL, and DIV instructions. The system
 * flags and IOPL field in the EFLAGS register control operating-system or executive operations.
 *
 * @see Vol1[3.4.3(EFLAGS)] (reference)
 */
typedef union
{
        struct
        {
                /**
                 * @brief Carry flag
                 *
                 * [Bit 0] Set if an arithmetic operation generates a carry or a borrow out of the
                 * mostsignificant bit of the result; cleared otherwise. This flag indicates an
                 * overflow condition for unsigned-integer arithmetic. It is also used in
                 * multiple-precision arithmetic.
                 */
                UINT32 CarryFlag : 1;
#define EFLAGS_CARRY_FLAG_BIT  0
#define EFLAGS_CARRY_FLAG_FLAG 0x01
#define EFLAGS_CARRY_FLAG_MASK 0x01
#define EFLAGS_CARRY_FLAG(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] Reserved - always 1
                 */
                UINT32 ReadAs1 : 1;
#define EFLAGS_READ_AS_1_BIT  1
#define EFLAGS_READ_AS_1_FLAG 0x02
#define EFLAGS_READ_AS_1_MASK 0x01
#define EFLAGS_READ_AS_1(_)   (((_) >> 1) & 0x01)

                /**
                 * @brief Parity flag
                 *
                 * [Bit 2] Set if the least-significant byte of the result contains an even number
                 * of 1 bits; cleared otherwise.
                 */
                UINT32 ParityFlag : 1;
#define EFLAGS_PARITY_FLAG_BIT  2
#define EFLAGS_PARITY_FLAG_FLAG 0x04
#define EFLAGS_PARITY_FLAG_MASK 0x01
#define EFLAGS_PARITY_FLAG(_)   (((_) >> 2) & 0x01)
                UINT32 Reserved1 : 1;

                /**
                 * @brief Auxiliary Carry flag
                 *
                 * [Bit 4] Set if an arithmetic operation generates a carry or a borrow out of bit 3
                 * of the result; cleared otherwise. This flag is used in binary-coded decimal (BCD)
                 * arithmetic.
                 */
                UINT32 AuxiliaryCarryFlag : 1;
#define EFLAGS_AUXILIARY_CARRY_FLAG_BIT  4
#define EFLAGS_AUXILIARY_CARRY_FLAG_FLAG 0x10
#define EFLAGS_AUXILIARY_CARRY_FLAG_MASK 0x01
#define EFLAGS_AUXILIARY_CARRY_FLAG(_)   (((_) >> 4) & 0x01)
                UINT32 Reserved2 : 1;

                /**
                 * @brief Zero flag
                 *
                 * [Bit 6] Set if the result is zero; cleared otherwise.
                 */
                UINT32 ZeroFlag : 1;
#define EFLAGS_ZERO_FLAG_BIT  6
#define EFLAGS_ZERO_FLAG_FLAG 0x40
#define EFLAGS_ZERO_FLAG_MASK 0x01
#define EFLAGS_ZERO_FLAG(_)   (((_) >> 6) & 0x01)

                /**
                 * @brief Sign flag
                 *
                 * [Bit 7] Set equal to the most-significant bit of the result, which is the sign
                 * bit of a signed integer. (0 indicates a positive value and 1 indicates a negative
                 * value.)
                 */
                UINT32 SignFlag : 1;
#define EFLAGS_SIGN_FLAG_BIT  7
#define EFLAGS_SIGN_FLAG_FLAG 0x80
#define EFLAGS_SIGN_FLAG_MASK 0x01
#define EFLAGS_SIGN_FLAG(_)   (((_) >> 7) & 0x01)

                /**
                 * @brief Trap flag
                 *
                 * [Bit 8] Set to enable single-step mode for debugging; clear to disable
                 * single-step mode.
                 */
                UINT32 TrapFlag : 1;
#define EFLAGS_TRAP_FLAG_BIT  8
#define EFLAGS_TRAP_FLAG_FLAG 0x100
#define EFLAGS_TRAP_FLAG_MASK 0x01
#define EFLAGS_TRAP_FLAG(_)   (((_) >> 8) & 0x01)

                /**
                 * @brief Interrupt enable flag
                 *
                 * [Bit 9] Controls the response of the processor to maskable interrupt requests.
                 * Set to respond to maskable interrupts; cleared to inhibit maskable interrupts.
                 */
                UINT32 InterruptEnableFlag : 1;
#define EFLAGS_INTERRUPT_ENABLE_FLAG_BIT  9
#define EFLAGS_INTERRUPT_ENABLE_FLAG_FLAG 0x200
#define EFLAGS_INTERRUPT_ENABLE_FLAG_MASK 0x01
#define EFLAGS_INTERRUPT_ENABLE_FLAG(_)   (((_) >> 9) & 0x01)

                /**
                 * @brief Direction flag
                 *
                 * [Bit 10] Controls string instructions (MOVS, CMPS, SCAS, LODS, and STOS). Setting
                 * the DF flag causes the string instructions to auto-decrement (to process strings
                 * from high addresses to low addresses). Clearing the DF flag causes the string
                 * instructions to auto-increment (process strings from low addresses to high
                 * addresses).
                 */
                UINT32 DirectionFlag : 1;
#define EFLAGS_DIRECTION_FLAG_BIT  10
#define EFLAGS_DIRECTION_FLAG_FLAG 0x400
#define EFLAGS_DIRECTION_FLAG_MASK 0x01
#define EFLAGS_DIRECTION_FLAG(_)   (((_) >> 10) & 0x01)

                /**
                 * @brief Overflow flag
                 *
                 * [Bit 11] Set if the integer result is too large a positive number or too small a
                 * negative number (excluding the sign-bit) to fit in the destination operand;
                 * cleared otherwise. This flag indicates an overflow condition for signed-integer
                 * (two's complement) arithmetic.
                 */
                UINT32 OverflowFlag : 1;
#define EFLAGS_OVERFLOW_FLAG_BIT  11
#define EFLAGS_OVERFLOW_FLAG_FLAG 0x800
#define EFLAGS_OVERFLOW_FLAG_MASK 0x01
#define EFLAGS_OVERFLOW_FLAG(_)   (((_) >> 11) & 0x01)

                /**
                 * @brief I/O privilege level field
                 *
                 * [Bits 13:12] Indicates the I/O privilege level of the currently running program
                 * or task. The current privilege level (CPL) of the currently running program or
                 * task must be less than or equal to the I/O privilege level to access the I/O
                 * address space. The POPF and IRET instructions can modify this field only when
                 * operating at a CPL of 0.
                 */
                UINT32 IoPrivilegeLevel : 2;
#define EFLAGS_IO_PRIVILEGE_LEVEL_BIT  12
#define EFLAGS_IO_PRIVILEGE_LEVEL_FLAG 0x3000
#define EFLAGS_IO_PRIVILEGE_LEVEL_MASK 0x03
#define EFLAGS_IO_PRIVILEGE_LEVEL(_)   (((_) >> 12) & 0x03)

                /**
                 * @brief Nested task flag
                 *
                 * [Bit 14] Controls the chaining of interrupted and called tasks. Set when the
                 * current task is linked to the previously executed task; cleared when the current
                 * task is not linked to another task.
                 */
                UINT32 NestedTaskFlag : 1;
#define EFLAGS_NESTED_TASK_FLAG_BIT  14
#define EFLAGS_NESTED_TASK_FLAG_FLAG 0x4000
#define EFLAGS_NESTED_TASK_FLAG_MASK 0x01
#define EFLAGS_NESTED_TASK_FLAG(_)   (((_) >> 14) & 0x01)
                UINT32 Reserved3 : 1;

                /**
                 * @brief Resume flag
                 *
                 * [Bit 16] Controls the processor's response to debug exceptions.
                 */
                UINT32 ResumeFlag : 1;
#define EFLAGS_RESUME_FLAG_BIT  16
#define EFLAGS_RESUME_FLAG_FLAG 0x10000
#define EFLAGS_RESUME_FLAG_MASK 0x01
#define EFLAGS_RESUME_FLAG(_)   (((_) >> 16) & 0x01)

                /**
                 * @brief Virtual-8086 mode flag
                 *
                 * [Bit 17] Set to enable virtual-8086 mode; clear to return to protected mode
                 * without virtual-8086 mode semantics.
                 */
                UINT32 Virtual8086ModeFlag : 1;
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_BIT  17
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG 0x20000
#define EFLAGS_VIRTUAL_8086_MODE_FLAG_MASK 0x01
#define EFLAGS_VIRTUAL_8086_MODE_FLAG(_)   (((_) >> 17) & 0x01)

                /**
                 * @brief Alignment check (or access control) flag
                 *
                 * [Bit 18] If the AM bit is set in the CR0 register, alignment checking of
                 * user-mode data accesses is enabled if and only if this flag is 1. If the SMAP bit
                 * is set in the CR4 register, explicit supervisor-mode data accesses to user-mode
                 * pages are allowed if and only if this bit is 1.
                 *
                 * @see Vol3A[4.6(ACCESS RIGHTS)]
                 */
                UINT32 AlignmentCheckFlag : 1;
#define EFLAGS_ALIGNMENT_CHECK_FLAG_BIT  18
#define EFLAGS_ALIGNMENT_CHECK_FLAG_FLAG 0x40000
#define EFLAGS_ALIGNMENT_CHECK_FLAG_MASK 0x01
#define EFLAGS_ALIGNMENT_CHECK_FLAG(_)   (((_) >> 18) & 0x01)

                /**
                 * @brief Virtual interrupt flag
                 *
                 * [Bit 19] Virtual image of the IF flag. Used in conjunction with the VIP flag. (To
                 * use this flag and the VIP flag the virtual mode extensions are enabled by setting
                 * the VME flag in control register CR4.)
                 */
                UINT32 VirtualInterruptFlag : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT  19
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG 0x80000
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK 0x01
#define EFLAGS_VIRTUAL_INTERRUPT_FLAG(_)   (((_) >> 19) & 0x01)

                /**
                 * @brief Virtual interrupt pending flag
                 *
                 * [Bit 20] Set to indicate that an interrupt is pending; clear when no interrupt is
                 * pending. (Software sets and clears this flag; the processor only reads it.) Used
                 * in conjunction with the VIF flag.
                 */
                UINT32 VirtualInterruptPendingFlag : 1;
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT  20
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG 0x100000
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK 0x01
#define EFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_)   (((_) >> 20) & 0x01)

                /**
                 * @brief Identification flag
                 *
                 * [Bit 21] The ability of a program to set or clear this flag indicates support for
                 * the CPUID instruction.
                 */
                UINT32 IdentificationFlag : 1;
#define EFLAGS_IDENTIFICATION_FLAG_BIT  21
#define EFLAGS_IDENTIFICATION_FLAG_FLAG 0x200000
#define EFLAGS_IDENTIFICATION_FLAG_MASK 0x01
#define EFLAGS_IDENTIFICATION_FLAG(_)   (((_) >> 21) & 0x01)
                UINT32 Reserved4 : 10;
        };

        UINT32 AsUInt;
} EFLAGS;

/**
 * The 64-bit RFLAGS register contains a group of status flags, a control flag, and a group of
 * system flags in 64-bit mode. The upper 32 bits of RFLAGS register is reserved. The lower 32 bits
 * of RFLAGS is the same as EFLAGS.
 *
 * @see EFLAGS
 * @see Vol1[3.4.3.4(RFLAGS Register in 64-Bit Mode)] (reference)
 */
// typedef union
//{
//	struct
//	{
//		/**
//		 * @brief Carry flag
//		 *
//		 * [Bit 0] See the description in EFLAGS.
//		 */
//		UINT64 CarryFlag : 1;
// #define RFLAGS_CARRY_FLAG_BIT                                        0
// #define RFLAGS_CARRY_FLAG_FLAG                                       0x01
// #define RFLAGS_CARRY_FLAG_MASK                                       0x01
// #define RFLAGS_CARRY_FLAG(_)                                         (((_) >> 0) & 0x01)
//
//		/**
//		 * [Bit 1] Reserved - always 1
//		 */
//		UINT64 ReadAs1 : 1;
// #define RFLAGS_READ_AS_1_BIT                                         1
// #define RFLAGS_READ_AS_1_FLAG                                        0x02
// #define RFLAGS_READ_AS_1_MASK                                        0x01
// #define RFLAGS_READ_AS_1(_)                                          (((_) >> 1) & 0x01)
//
//		/**
//		 * @brief Parity flag
//		 *
//		 * [Bit 2] See the description in EFLAGS.
//		 */
//		UINT64 ParityFlag : 1;
// #define RFLAGS_PARITY_FLAG_BIT                                       2
// #define RFLAGS_PARITY_FLAG_FLAG                                      0x04
// #define RFLAGS_PARITY_FLAG_MASK                                      0x01
// #define RFLAGS_PARITY_FLAG(_)                                        (((_) >> 2) & 0x01)
//		UINT64 Reserved1 : 1;
//
//		/**
//		 * @brief Auxiliary Carry flag
//		 *
//		 * [Bit 4] See the description in EFLAGS.
//		 */
//		UINT64 AuxiliaryCarryFlag : 1;
// #define RFLAGS_AUXILIARY_CARRY_FLAG_BIT                              4
// #define RFLAGS_AUXILIARY_CARRY_FLAG_FLAG                             0x10
// #define RFLAGS_AUXILIARY_CARRY_FLAG_MASK                             0x01
// #define RFLAGS_AUXILIARY_CARRY_FLAG(_)                               (((_) >> 4) & 0x01)
//		UINT64 Reserved2 : 1;
//
//		/**
//		 * @brief Zero flag
//		 *
//		 * [Bit 6] See the description in EFLAGS.
//		 */
//		UINT64 ZeroFlag : 1;
// #define RFLAGS_ZERO_FLAG_BIT                                         6
// #define RFLAGS_ZERO_FLAG_FLAG                                        0x40
// #define RFLAGS_ZERO_FLAG_MASK                                        0x01
// #define RFLAGS_ZERO_FLAG(_)                                          (((_) >> 6) & 0x01)
//
//		/**
//		 * @brief Sign flag
//		 *
//		 * [Bit 7] See the description in EFLAGS.
//		 */
//		UINT64 SignFlag : 1;
// #define RFLAGS_SIGN_FLAG_BIT                                         7
// #define RFLAGS_SIGN_FLAG_FLAG                                        0x80
// #define RFLAGS_SIGN_FLAG_MASK                                        0x01
// #define RFLAGS_SIGN_FLAG(_)                                          (((_) >> 7) & 0x01)
//
//		/**
//		 * @brief Trap flag
//		 *
//		 * [Bit 8] See the description in EFLAGS.
//		 */
//		UINT64 TrapFlag : 1;
// #define RFLAGS_TRAP_FLAG_BIT                                         8
// #define RFLAGS_TRAP_FLAG_FLAG                                        0x100
// #define RFLAGS_TRAP_FLAG_MASK                                        0x01
// #define RFLAGS_TRAP_FLAG(_)                                          (((_) >> 8) & 0x01)
//
//		/**
//		 * @brief Interrupt enable flag
//		 *
//		 * [Bit 9] See the description in EFLAGS.
//		 */
//		UINT64 InterruptEnableFlag : 1;
// #define RFLAGS_INTERRUPT_ENABLE_FLAG_BIT                             9
// #define RFLAGS_INTERRUPT_ENABLE_FLAG_FLAG                            0x200
// #define RFLAGS_INTERRUPT_ENABLE_FLAG_MASK                            0x01
// #define RFLAGS_INTERRUPT_ENABLE_FLAG(_)                              (((_) >> 9) & 0x01)
//
//		/**
//		 * @brief Direction flag
//		 *
//		 * [Bit 10] See the description in EFLAGS.
//		 */
//		UINT64 DirectionFlag : 1;
// #define RFLAGS_DIRECTION_FLAG_BIT                                    10
// #define RFLAGS_DIRECTION_FLAG_FLAG                                   0x400
// #define RFLAGS_DIRECTION_FLAG_MASK                                   0x01
// #define RFLAGS_DIRECTION_FLAG(_)                                     (((_) >> 10) & 0x01)
//
//		/**
//		 * @brief Overflow flag
//		 *
//		 * [Bit 11] See the description in EFLAGS.
//		 */
//		UINT64 OverflowFlag : 1;
// #define RFLAGS_OVERFLOW_FLAG_BIT                                     11
// #define RFLAGS_OVERFLOW_FLAG_FLAG                                    0x800
// #define RFLAGS_OVERFLOW_FLAG_MASK                                    0x01
// #define RFLAGS_OVERFLOW_FLAG(_)                                      (((_) >> 11) & 0x01)
//
//		/**
//		 * @brief I/O privilege level field
//		 *
//		 * [Bits 13:12] See the description in EFLAGS.
//		 */
//		UINT64 IoPrivilegeLevel : 2;
// #define RFLAGS_IO_PRIVILEGE_LEVEL_BIT                                12
// #define RFLAGS_IO_PRIVILEGE_LEVEL_FLAG                               0x3000
// #define RFLAGS_IO_PRIVILEGE_LEVEL_MASK                               0x03
// #define RFLAGS_IO_PRIVILEGE_LEVEL(_)                                 (((_) >> 12) & 0x03)
//
//		/**
//		 * @brief Nested task flag
//		 *
//		 * [Bit 14] See the description in EFLAGS.
//		 */
//		UINT64 NestedTaskFlag : 1;
// #define RFLAGS_NESTED_TASK_FLAG_BIT                                  14
// #define RFLAGS_NESTED_TASK_FLAG_FLAG                                 0x4000
// #define RFLAGS_NESTED_TASK_FLAG_MASK                                 0x01
// #define RFLAGS_NESTED_TASK_FLAG(_)                                   (((_) >> 14) & 0x01)
//		UINT64 Reserved3 : 1;
//
//		/**
//		 * @brief Resume flag
//		 *
//		 * [Bit 16] See the description in EFLAGS.
//		 */
//		UINT64 ResumeFlag : 1;
// #define RFLAGS_RESUME_FLAG_BIT                                       16
// #define RFLAGS_RESUME_FLAG_FLAG                                      0x10000
// #define RFLAGS_RESUME_FLAG_MASK                                      0x01
// #define RFLAGS_RESUME_FLAG(_)                                        (((_) >> 16) & 0x01)
//
//		/**
//		 * @brief Virtual-8086 mode flag
//		 *
//		 * [Bit 17] See the description in EFLAGS.
//		 */
//		UINT64 Virtual8086ModeFlag : 1;
// #define RFLAGS_VIRTUAL_8086_MODE_FLAG_BIT                            17
// #define RFLAGS_VIRTUAL_8086_MODE_FLAG_FLAG                           0x20000
// #define RFLAGS_VIRTUAL_8086_MODE_FLAG_MASK                           0x01
// #define RFLAGS_VIRTUAL_8086_MODE_FLAG(_)                             (((_) >> 17) & 0x01)
//
//		/**
//		 * @brief Alignment check (or access control) flag
//		 *
//		 * [Bit 18] See the description in EFLAGS.
//		 *
//		 * @see Vol3A[4.6(ACCESS RIGHTS)]
//		 */
//		UINT64 AlignmentCheckFlag : 1;
// #define RFLAGS_ALIGNMENT_CHECK_FLAG_BIT                              18
// #define RFLAGS_ALIGNMENT_CHECK_FLAG_FLAG                             0x40000
// #define RFLAGS_ALIGNMENT_CHECK_FLAG_MASK                             0x01
// #define RFLAGS_ALIGNMENT_CHECK_FLAG(_)                               (((_) >> 18) & 0x01)
//
//		/**
//		 * @brief Virtual interrupt flag
//		 *
//		 * [Bit 19] See the description in EFLAGS.
//		 */
//		UINT64 VirtualInterruptFlag : 1;
// #define RFLAGS_VIRTUAL_INTERRUPT_FLAG_BIT                            19
// #define RFLAGS_VIRTUAL_INTERRUPT_FLAG_FLAG                           0x80000
// #define RFLAGS_VIRTUAL_INTERRUPT_FLAG_MASK                           0x01
// #define RFLAGS_VIRTUAL_INTERRUPT_FLAG(_)                             (((_) >> 19) & 0x01)
//
//		/**
//		 * @brief Virtual interrupt pending flag
//		 *
//		 * [Bit 20] See the description in EFLAGS.
//		 */
//		UINT64 VirtualInterruptPendingFlag : 1;
// #define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_BIT                    20
// #define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_FLAG                   0x100000
// #define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG_MASK                   0x01
// #define RFLAGS_VIRTUAL_INTERRUPT_PENDING_FLAG(_)                     (((_) >> 20) & 0x01)
//
//		/**
//		 * @brief Identification flag
//		 *
//		 * [Bit 21] See the description in EFLAGS.
//		 */
//		UINT64 IdentificationFlag : 1;
// #define RFLAGS_IDENTIFICATION_FLAG_BIT                               21
// #define RFLAGS_IDENTIFICATION_FLAG_FLAG                              0x200000
// #define RFLAGS_IDENTIFICATION_FLAG_MASK                              0x01
// #define RFLAGS_IDENTIFICATION_FLAG(_)                                (((_) >> 21) & 0x01)
//		UINT64 Reserved4 : 42;
//	};
//
//	UINT64 AsUInt;
// } RFLAGS;

/**
 * @defgroup EXCEPTIONS \
 *           Exceptions
 * @{
 */
/**
 * @brief Control Protection Exception
 *
 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))] (reference)
 */
typedef union
{
        struct
        {
                /**
                 * [Bits 14:0] One of the following values:
                 * 1 - NEAR-RET: Indicates the \#CP was caused by a near RET instruction.
                 * 2 - FAR-RET/IRET: Indicates the \#CP was caused by a FAR RET or IRET instruction.
                 * 3 - ENDBRANCH: indicates the \#CP was due to missing ENDBRANCH at target of an
                 * indirect call or jump instruction. 4 - RSTORSSP: Indicates the \#CP was caused by
                 * a shadow-stack-restore token check failure in the RSTORSSP instruction. 5 -
                 * SETSSBSY: Indicates \#CP was caused by a supervisor shadow stack token check
                 * failure in the SETSSBSY instruction.
                 */
                UINT32 Cpec : 15;
#define CONTROL_PROTECTION_EXCEPTION_CPEC_BIT  0
#define CONTROL_PROTECTION_EXCEPTION_CPEC_FLAG 0x7FFF
#define CONTROL_PROTECTION_EXCEPTION_CPEC_MASK 0x7FFF
#define CONTROL_PROTECTION_EXCEPTION_CPEC(_)   (((_) >> 0) & 0x7FFF)

                /**
                 * [Bit 15] If set to 1, indicates the \#CP occurred during enclave execution.
                 */
                UINT32 Encl : 1;
#define CONTROL_PROTECTION_EXCEPTION_ENCL_BIT  15
#define CONTROL_PROTECTION_EXCEPTION_ENCL_FLAG 0x8000
#define CONTROL_PROTECTION_EXCEPTION_ENCL_MASK 0x01
#define CONTROL_PROTECTION_EXCEPTION_ENCL(_)   (((_) >> 15) & 0x01)
                UINT32 Reserved1 : 16;
        };

        UINT32 AsUInt;
} CONTROL_PROTECTION_EXCEPTION;

/**
 * @brief Exceptions that can occur when the instruction is executed in protected mode.
 *        Each exception is given a mnemonic that consists of a pound sign (\#) followed by two
 * letters and an optional error code in parentheses. For example, \#GP(0) denotes a general
 * protection exception with an error code of 0
 *
 * @see Vol2A[3.1.1.13(Protected Mode Exceptions Section)] (reference)
 * @see Vol3A[6.3.1(External Interrupts)] (reference)
 */
typedef enum
{
        /**
         * #DE - Divide Error.
         * Source: DIV and IDIV instructions.
         * Error Code: No.
         */
        DivideError = 0x00000000,

        /**
         * #DB - Debug.
         * Source: Any code or data reference.
         * Error Code: No.
         */
        Debug = 0x00000001,

        /**
         * Nonmaskable Interrupt.
         * Source: Generated externally by asserting the processor's NMI pin or
         *         through an NMI request set by the I/O APIC to the local APIC.
         * Error Code: No.
         */
        Nmi = 0x00000002,

        /**
         * #BP - Breakpoint.
         * Source: INT3 instruction.
         * Error Code: No.
         */
        Breakpoint = 0x00000003,

        /**
         * #OF - Overflow.
         * Source: INTO instruction.
         * Error Code: No.
         */
        Overflow = 0x00000004,

        /**
         * #BR - BOUND Range Exceeded.
         * Source: BOUND instruction.
         * Error Code: No.
         */
        BoundRangeExceeded = 0x00000005,

        /**
         * #UD - Invalid Opcode (Undefined Opcode).
         * Source: UD instruction or reserved opcode.
         * Error Code: No.
         */
        InvalidOpcode = 0x00000006,

        /**
         * #NM - Device Not Available (No Math Coprocessor).
         * Source: Floating-point or WAIT/FWAIT instruction.
         * Error Code: No.
         */
        DeviceNotAvailable = 0x00000007,

        /**
         * #DF - Double Fault.
         * Source: Any instruction that can generate an exception, an NMI, or an INTR.
         * Error Code: Yes (zero).
         */
        DoubleFault = 0x00000008,

        /**
         * #\## - Coprocessor Segment Overrun (reserved).
         * Source: Floating-point instruction.
         * Error Code: No.
         *
         * @note Processors after the Intel386 processor do not generate this exception.
         */
        CoprocessorSegmentOverrun = 0x00000009,

        /**
         * #TS - Invalid TSS.
         * Source: Task switch or TSS access.
         * Error Code: Yes.
         */
        InvalidTss = 0x0000000A,

        /**
         * #NP - Segment Not Present.
         * Source: Loading segment registers or accessing system segments.
         * Error Code: Yes.
         */
        SegmentNotPresent = 0x0000000B,

        /**
         * #SS - Stack Segment Fault.
         * Source: Stack operations and SS register loads.
         * Error Code: Yes.
         */
        StackSegmentFault = 0x0000000C,

        /**
         * #GP - General Protection.
         * Source: Any memory reference and other protection checks.
         * Error Code: Yes.
         */
        GeneralProtection = 0x0000000D,

        /**
         * #PF - Page Fault.
         * Source: Any memory reference.
         * Error Code: Yes.
         */
        PageFault = 0x0000000E,

        /**
         * #MF - Floating-Point Error (Math Fault).
         * Source: Floating-point or WAIT/FWAIT instruction.
         * Error Code: No.
         */
        X87FloatingPointError = 0x00000010,

        /**
         * #AC - Alignment Check.
         * Source: Any data reference in memory.
         * Error Code: Yes.
         */
        AlignmentCheck = 0x00000011,

        /**
         * #MC - Machine Check.
         * Source: Model dependent machine check errors.
         * Error Code: No.
         */
        MachineCheck = 0x00000012,

        /**
         * #XM - SIMD Floating-Point Numeric Error.
         * Source: SSE/SSE2/SSE3 floating-point instructions.
         * Error Code: No.
         */
        SimdFloatingPointError = 0x00000013,

        /**
         * #VE - Virtualization Exception.
         * Source: EPT violations.
         * Error Code: No.
         */
        VirtualizationException = 0x00000014,

        /**
         * #CP - Control Protection Exception.
         * Source: Control flow transfer attempt violated the control flow enforcement technology
         * constraints. Error Code: Yes.
         */
        ControlProtection = 0x00000015,
} EXCEPTION_VECTOR;

/**
 * @brief When an exception condition is related to a specific segment selector or IDT vector, the
 * processor pushes an error code onto the stack of the exception handler (whether it is a procedure
 * or task). The error code resembles a segment selector; however, instead of a TI flag and RPL
 * field, the error code contains 3 different flags
 *
 * @see Vol3A[6.13(ERROR CODE)] (reference)
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] When set, indicates that the exception occurred during delivery of an
                 * event external to the program, such as an interrupt or an earlier exception. The
                 * bit is cleared if the exception occurred during delivery of a software interrupt
                 * (INT n, INT3, or INTO).
                 */
                UINT32 ExternalEvent : 1;
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_BIT  0
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_FLAG 0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT_MASK 0x01
#define EXCEPTION_ERROR_CODE_EXTERNAL_EVENT(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] When set, indicates that the index portion of the error code refers to a
                 * gate descriptor in the IDT; when clear, indicates that the index refers to a
                 * descriptor in the GDT or the current LDT.
                 */
                UINT32 DescriptorLocation : 1;
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_BIT  1
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_FLAG 0x02
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION_MASK 0x01
#define EXCEPTION_ERROR_CODE_DESCRIPTOR_LOCATION(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] Only used when the IDT flag is clear. When set, the TI flag indicates
                 * that the index portion of the error code refers to a segment or gate descriptor
                 * in the LDT; when clear, it indicates that the index refers to a descriptor in the
                 * current GDT.
                 */
                UINT32 GdtLdt : 1;
#define EXCEPTION_ERROR_CODE_GDT_LDT_BIT  2
#define EXCEPTION_ERROR_CODE_GDT_LDT_FLAG 0x04
#define EXCEPTION_ERROR_CODE_GDT_LDT_MASK 0x01
#define EXCEPTION_ERROR_CODE_GDT_LDT(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bits 15:3] The segment selector index field provides an index into the IDT, GDT,
                 * or current LDT to the segment or gate selector being referenced by the error
                 * code. In some cases the error code is null (all bits are clear except possibly
                 * EXT). A null error code indicates that the error was not caused by a reference to
                 * a specific segment or that a null segment selector was referenced in an
                 * operation.
                 *
                 * @note The format of the error code is different for page-fault exceptions (#PF).
                 */
                UINT32 Index : 13;
#define EXCEPTION_ERROR_CODE_INDEX_BIT  3
#define EXCEPTION_ERROR_CODE_INDEX_FLAG 0xFFF8
#define EXCEPTION_ERROR_CODE_INDEX_MASK 0x1FFF
#define EXCEPTION_ERROR_CODE_INDEX(_)   (((_) >> 3) & 0x1FFF)
                UINT32 Reserved1 : 16;
        };

        UINT32 AsUInt;
} EXCEPTION_ERROR_CODE;

/**
 * @brief Page fault exception
 *
 * @see Vol3A[4.7(PAGE-FAULT EXCEPTIONS)] (reference)
 */
typedef union
{
        struct
        {
                /**
                 * [Bit 0] This flag is 0 if there is no translation for the linear address because
                 * the P flag was 0 in one of the pagingstructure entries used to translate that
                 * address.
                 */
                UINT32 Present : 1;
#define PAGE_FAULT_EXCEPTION_PRESENT_BIT  0
#define PAGE_FAULT_EXCEPTION_PRESENT_FLAG 0x01
#define PAGE_FAULT_EXCEPTION_PRESENT_MASK 0x01
#define PAGE_FAULT_EXCEPTION_PRESENT(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] If the access causing the page-fault exception was a write, this flag is
                 * 1; otherwise, it is 0. This flag describes the access causing the page-fault
                 * exception, not the access rights specified by paging.
                 */
                UINT32 Write : 1;
#define PAGE_FAULT_EXCEPTION_WRITE_BIT  1
#define PAGE_FAULT_EXCEPTION_WRITE_FLAG 0x02
#define PAGE_FAULT_EXCEPTION_WRITE_MASK 0x01
#define PAGE_FAULT_EXCEPTION_WRITE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] If a user-mode access caused the page-fault exception, this flag is 1; it
                 * is 0 if a supervisor-mode access did so. This flag describes the access causing
                 * the page-fault exception, not the access rights specified by paging.
                 *
                 * @see Vol3A[4.6(ACCESS RIGHTS)]
                 */
                UINT32 UserModeAccess : 1;
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_BIT  2
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_FLAG 0x04
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS_MASK 0x01
#define PAGE_FAULT_EXCEPTION_USER_MODE_ACCESS(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] This flag is 1 if there is no translation for the linear address because
                 * a reserved bit was set in one of the pagingstructure entries used to translate
                 * that address. (Because reserved bits are not checked in a paging-structure entry
                 * whose P flag is 0, bit 3 of the error code can be set only if bit 0 is also set).
                 * Bits reserved in the paging-structure entries are reserved for future
                 * functionality. Software developers should be aware that such bits may be used in
                 * the future and that a paging-structure entry that causes a page-fault exception
                 * on one processor might not do so in the future.
                 */
                UINT32 ReservedBitViolation : 1;
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_BIT  3
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_FLAG 0x08
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION_MASK 0x01
#define PAGE_FAULT_EXCEPTION_RESERVED_BIT_VIOLATION(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] This flag is 1 if (1) the access causing the page-fault exception was an
                 * instruction fetch; and (2) either (a) CR4.SMEP = 1; or (b) both (i) CR4.PAE = 1
                 * (either PAE paging or 4-level paging is in use); and (ii) IA32_EFER.NXE = 1.
                 * Otherwise, the flag is 0. This flag describes the access causing the page-fault
                 * exception, not the access rights specified by paging.
                 */
                UINT32 Execute : 1;
#define PAGE_FAULT_EXCEPTION_EXECUTE_BIT  4
#define PAGE_FAULT_EXCEPTION_EXECUTE_FLAG 0x10
#define PAGE_FAULT_EXCEPTION_EXECUTE_MASK 0x01
#define PAGE_FAULT_EXCEPTION_EXECUTE(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] This flag is 1 if (1) IA32_EFER.LMA = CR4.PKE = 1; (2) the access causing
                 * the page-fault exception was a data access; (3) the linear address was a
                 * user-mode address with protection key i; and (5) the PKRU register is such that
                 * either (a) ADi = 1; or (b) the following all hold: (i) WDi = 1; (ii) the access
                 * is a write access; and (iii) either CR0.WP = 1 or the access causing the
                 * page-fault exception was a user-mode access.
                 *
                 * @see Vol3A[4.6.2(Protection Keys)]
                 */
                UINT32 ProtectionKeyViolation : 1;
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_BIT  5
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_FLAG 0x20
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION_MASK 0x01
#define PAGE_FAULT_EXCEPTION_PROTECTION_KEY_VIOLATION(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] If the access causing the page-fault exception was a shadow-stack access
                 * (including shadow-stack accesses in enclave mode), this flag is 1; otherwise, it
                 * is 0. This flag describes the access causing the page-fault exception, not the
                 * access rights specified by paging.
                 *
                 * @see Vol1[18(CONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET))]
                 */
                UINT32 ShadowStack : 1;
#define PAGE_FAULT_EXCEPTION_SHADOW_STACK_BIT  6
#define PAGE_FAULT_EXCEPTION_SHADOW_STACK_FLAG 0x40
#define PAGE_FAULT_EXCEPTION_SHADOW_STACK_MASK 0x01
#define PAGE_FAULT_EXCEPTION_SHADOW_STACK(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] This flag is 1 if there is no translation for the linear address using
                 * HLAT paging because, in one of the paging- structure entries used to translate
                 * that address, either the P flag was 0 or a reserved bit was set. An error code
                 * will set this flag only if it clears bit o or sets bit 3. This flag will not be
                 * set by a page fault resulting from a violation of access rights, nor for one
                 * encountered during ordinary paging, including the case in which there has been a
                 * restart of HLAT paging.
                 *
                 * @see Vol3A[4.5.1(Ordinary Paging and HLAT Paging)]
                 */
                UINT32 Hlat : 1;
#define PAGE_FAULT_EXCEPTION_HLAT_BIT  7
#define PAGE_FAULT_EXCEPTION_HLAT_FLAG 0x80
#define PAGE_FAULT_EXCEPTION_HLAT_MASK 0x01
#define PAGE_FAULT_EXCEPTION_HLAT(_)   (((_) >> 7) & 0x01)
                UINT32 Reserved1 : 7;

                /**
                 * [Bit 15] This flag is 1 if the exception is unrelated to paging and resulted from
                 * violation of SGX-specific access-control requirements. Because such a violation
                 * can occur only if there is no ordinary page fault, this flag is set only if the P
                 * flag (bit 0) is 1 and the RSVD flag (bit 3) and the PK flag (bit 5) are both 0.
                 */
                UINT32 Sgx : 1;
#define PAGE_FAULT_EXCEPTION_SGX_BIT  15
#define PAGE_FAULT_EXCEPTION_SGX_FLAG 0x8000
#define PAGE_FAULT_EXCEPTION_SGX_MASK 0x01
#define PAGE_FAULT_EXCEPTION_SGX(_)   (((_) >> 15) & 0x01)
                UINT32 Reserved2 : 16;
        };

        UINT32 AsUInt;
} PAGE_FAULT_EXCEPTION;

/**
 * @}
 */

/**
 * @defgroup MEMORY_TYPE \
 *           Memory caching type
 *
 * The processor allows any area of system memory to be cached in the L1, L2, and L3 caches. In
 * individual pages or regions of system memory, it allows the type of caching (also called memory
 * type) to be specified.
 *
 * @see Vol3A[11.11(MEMORY TYPE RANGE REGISTERS (MTRRS))]
 * @see Vol3A[11.5(CACHE CONTROL)]
 * @see Vol3A[11.3(METHODS OF CACHING AVAILABLE)] (reference)
 * @{
 */
/**
 * @brief Strong Uncacheable (UC)
 *
 * System memory locations are not cached. All reads and writes appear on the system bus and are
 * executed in program order without reordering. No speculative memory accesses, pagetable walks, or
 * prefetches of speculated branch targets are made. This type of cache-control is useful for
 * memory-mapped I/O devices. When used with normal RAM, it greatly reduces processor performance.
 */
#define MEMORY_TYPE_UNCACHEABLE 0x00000000

/**
 * @brief Write Combining (WC)
 *
 * System memory locations are not cached (as with uncacheable memory) and coherency is not enforced
 * by the processor's bus coherency protocol. Speculative reads are allowed. Writes may be delayed
 * and combined in the write combining buffer (WC buffer) to reduce memory accesses. If the WC
 * buffer is partially filled, the writes may be delayed until the next occurrence of a serializing
 * event; such as, an SFENCE or MFENCE instruction, CPUID execution, a read or write to uncached
 * memory, an interrupt occurrence, or a LOCK instruction execution. This type of cache-control is
 * appropriate for video frame buffers, where the order of writes is unimportant as long as the
 * writes update memory so they can be seen on the graphics display. This memory type is available
 * in the Pentium Pro and Pentium II processors by programming the MTRRs; or in processor families
 * starting from the Pentium III processors by programming the MTRRs or by selecting it through the
 * PAT.
 *
 * @see Vol3A[11.3.1(Buffering of Write Combining Memory Locations)]
 */
#define MEMORY_TYPE_WRITE_COMBINING 0x00000001

/**
 * @brief Write-through (WT)
 *
 * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits;
 * read misses cause cache fills. Speculative reads are allowed. All writes are written to a cache
 * line (when possible) and through to system memory. When writing through to memory, invalid cache
 * lines are never filled, and valid cache lines are either filled or invalidated. Write combining
 * is allowed. This type of cache-control is appropriate for frame buffers or when there are devices
 * on the system bus that access system memory, but do not perform snooping of memory accesses. It
 * enforces coherency between caches in the processors and system memory.
 */
#define MEMORY_TYPE_WRITE_THROUGH 0x00000004

/**
 * @brief Write protected (WP)
 *
 * Reads come from cache lines when possible, and read misses cause cache fills. Writes are
 * propagated to the system bus and cause corresponding cache lines on all processors on the bus to
 * be invalidated. Speculative reads are allowed. This memory type is available in processor
 * families starting from the P6 family processors by programming the MTRRs.
 */
#define MEMORY_TYPE_WRITE_PROTECTED 0x00000005

/**
 * @brief Write-back (WB)
 *
 * Writes and reads to and from system memory are cached. Reads come from cache lines on cache hits;
 * read misses cause cache fills. Speculative reads are allowed. Write misses cause cache line fills
 * (in processor families starting with the P6 family processors), and writes are performed entirely
 * in the cache, when possible. Write combining is allowed. The write-back memory type reduces bus
 * traffic by eliminating many unnecessary writes to system memory. Writes to a cache line are not
 * immediately forwarded to system memory; instead, they are accumulated in the cache. The modified
 * cache lines are written to system memory later, when a write-back operation is performed.
 * Write-back operations are triggered when cache lines need to be deallocated, such as when new
 * cache lines are being allocated in a cache that is already full. They also are triggered by the
 * mechanisms used to maintain cache consistency. This type of cache-control provides the best
 * performance, but it requires that all devices that access system memory on the system bus be able
 * to snoop memory accesses to insure system memory and cache coherency.
 */
#define MEMORY_TYPE_WRITE_BACK 0x00000006

/**
 * @brief Uncacheable (UC-)
 *
 * Has same characteristics as the strong uncacheable (UC) memory type, except that this memory type
 * can be overridden by programming the MTRRs for the WC memory type. This memory type is available
 * in processor families starting from the Pentium III processors and can only be selected through
 * the PAT.
 */
#define MEMORY_TYPE_UNCACHEABLE_MINUS 0x00000007
#define MEMORY_TYPE_INVALID           0x000000FF
/**
 * @}
 */

/**
 * @defgroup VTD \
 *           VTD
 * @{
 */
/**
 * @brief The Root Table Address Register points to a table of root-entries, when the Translation
 * Table Mode (TTM) field in the register is 00b
 *
 * @see VTd[9.1(Root Entry)]
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bit 0] This field indicates whether the root-entry is present.
                         * * 0: Indicates the root-entry is not present. All other fields are
                         * ignored by hardware.
                         * * 1: Indicates the root-entry is present.
                         */
                        UINT64 Present : 1;
#define VTD_Lower64_PRESENT_BIT  0
#define VTD_Lower64_PRESENT_FLAG 0x01
#define VTD_Lower64_PRESENT_MASK 0x01
#define VTD_Lower64_PRESENT(_)   (((_) >> 0) & 0x01)
                        UINT64 Reserved1 : 11;

                        /**
                         * [Bits 63:12] Pointer to Context-table for this bus. The Context-table is
                         * 4KB in size and size aligned. Hardware treats bits 63:HAW as reserved
                         * (0), where HAW is the host address width of the platform.
                         */
                        UINT64 ContextTablePointer : 52;
#define VTD_Lower64_CONTEXT_TABLE_POINTER_BIT  12
#define VTD_Lower64_CONTEXT_TABLE_POINTER_FLAG 0xFFFFFFFFFFFFF000
#define VTD_Lower64_CONTEXT_TABLE_POINTER_MASK 0xFFFFFFFFFFFFF
#define VTD_Lower64_CONTEXT_TABLE_POINTER(_)   (((_) >> 12) & 0xFFFFFFFFFFFFF)
                };

                UINT64 AsUInt;
        } Lower64;

        union
        {
                struct
                {
                        /**
                         * [Bits 63:0] Reserved. Must be 0.
                         */
                        UINT64 Reserved : 64;
#define VTD_Upper64_RESERVED_BIT  0
#define VTD_Upper64_RESERVED_FLAG 0xFFFFFFFFFFFFFFFF
#define VTD_Upper64_RESERVED_MASK 0xFFFFFFFFFFFFFFFF
#define VTD_Upper64_RESERVED(_)   (((_) >> 0) & 0xFFFFFFFFFFFFFFFF)
                };

                UINT64 AsUInt;
        } Upper64;

} VTD_ROOT_ENTRY;

/**
 * @brief Context-entries support translation of requests-without-PASID. Context-entries are
 * referenced through root-entries
 *
 * @see VTd[9.3(Context Entry)]
 */
typedef struct
{
        union
        {
                struct
                {
                        /**
                         * [Bit 0]
                         * * 0: Indicates the context-entry is not present. All other fields except
                         * Fault Processing Disable (FPD) field are ignored by hardware.
                         * * 1: Indicates the context-entry is present.
                         */
                        UINT64 Present : 1;
#define VTD_Lower64_PRESENT_BIT  0
#define VTD_Lower64_PRESENT_FLAG 0x01
#define VTD_Lower64_PRESENT_MASK 0x01
#define VTD_Lower64_PRESENT(_)   (((_) >> 0) & 0x01)

                        /**
                         * [Bit 1] Enables or disables recording/reporting of qualified
                         * non-recoverable faults.
                         * * 0: Qualified non-recoverable faults are recorded/reported for requests
                         * processed through this context-entry.
                         * * 1: Qualified non-recoverable faults are not recorded/reported for
                         * requests processed through this context-entry. This field is evaluated by
                         * hardware irrespective of the setting of the present (P) field.
                         */
                        UINT64 FaultProcessingDisable : 1;
#define VTD_Lower64_FAULT_PROCESSING_DISABLE_BIT  1
#define VTD_Lower64_FAULT_PROCESSING_DISABLE_FLAG 0x02
#define VTD_Lower64_FAULT_PROCESSING_DISABLE_MASK 0x01
#define VTD_Lower64_FAULT_PROCESSING_DISABLE(_)   (((_) >> 1) & 0x01)

                        /**
                         * [Bits 3:2] This field is applicable only for requests-without-PASID, as
                         * hardware blocks all requests-with- PASID in legacy mode before they can
                         * use context table.
                         * * 00b: Untranslated requests are translated using second-level paging
                         * structures referenced through SLPTPTR field. Translated requests and
                         * Translation Requests are blocked.
                         * * 01b: Untranslated, Translated and Translation Requests are supported.
                         * This encoding is treated as reserved by hardware implementations not
                         * supporting Device-TLBs (DT=0 in Extended Capability Register).
                         * * 10b: Untranslated requests are processed as pass-through. SLPTPTR field
                         * is ignored by hardware. Translated and Translation Requests are blocked.
                         * This encoding is treated by hardware as reserved for hardware
                         * implementations not supporting Pass Through (PT=0 in Extended Capability
                         * Register).
                         * * 11b: Reserved.
                         */
                        UINT64 TranslationType : 2;
#define VTD_Lower64_TRANSLATION_TYPE_BIT  2
#define VTD_Lower64_TRANSLATION_TYPE_FLAG 0x0C
#define VTD_Lower64_TRANSLATION_TYPE_MASK 0x03
#define VTD_Lower64_TRANSLATION_TYPE(_)   (((_) >> 2) & 0x03)
                        UINT64 Reserved1 : 8;

                        /**
                         * [Bits 63:12] When the Translation-Type (TT) field is 00b or 01b, this
                         * field points to the base of second level paging entries (described in
                         * Section 9.8). Hardware treats bits 63:HAW as reserved (0), where HAW is
                         * the host address width of the platform. This field is ignored by hardware
                         * when Translation-Type (TT) field is 10b (pass-through).
                         */
                        UINT64 SecondLevelPageTranslationPointer : 52;
#define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_BIT  12
#define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_FLAG 0xFFFFFFFFFFFFF000
#define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER_MASK 0xFFFFFFFFFFFFF
#define VTD_Lower64_SECOND_LEVEL_PAGE_TRANSLATION_POINTER(_)   (((_) >> 12) & 0xFFFFFFFFFFFFF)
                };

                UINT64 AsUInt;
        } Lower64;

        union
        {
                struct
                {
                        /**
                         * [Bits 2:0] When the Translation-type (TT) field is 00b or 01b, this field
                         * indicates the adjusted guest address- width (AGAW) to be used by hardware
                         * for the second-level page-table walk. The following encodings are defined
                         * for this field:
                         * * 000b: Reserved
                         * * 001b: 39-bit AGAW (3-level page table)
                         * * 010b: 48-bit AGAW (4-level page table)
                         * * 011b: 57-bit AGAW (5-level page table)
                         * * 100b-111b: Reserved
                         * The value specified in this field must match an AGAW value supported by
                         * hardware (as reported in the SAGAW field in the Capability Register).
                         * When the Translation-type (TT) field indicates pass-through processing
                         * (10b), this field must be programmed to indicate the largest AGAW value
                         * supported by hardware. Untranslated requests-without-PASID processed
                         * through this context-entry and accessing addresses above 2X-1 (where X is
                         * the AGAW value indicated by this field) are blocked and treated as
                         * translation faults.
                         */
                        UINT64 AddressWidth : 3;
#define VTD_Upper64_ADDRESS_WIDTH_BIT  0
#define VTD_Upper64_ADDRESS_WIDTH_FLAG 0x07
#define VTD_Upper64_ADDRESS_WIDTH_MASK 0x07
#define VTD_Upper64_ADDRESS_WIDTH(_)   (((_) >> 0) & 0x07)

                        /**
                         * [Bits 6:3] Hardware ignores the programming of this field.
                         */
                        UINT64 Ignored : 4;
#define VTD_Upper64_IGNORED_BIT  3
#define VTD_Upper64_IGNORED_FLAG 0x78
#define VTD_Upper64_IGNORED_MASK 0x0F
#define VTD_Upper64_IGNORED(_)   (((_) >> 3) & 0x0F)
                        UINT64 Reserved1 : 1;

                        /**
                         * [Bits 17:8] Identifier for the domain to which this context-entry maps.
                         * Hardware may use the domain identifier to tag its internal caches. The
                         * Capability Register reports the domain-id width supported by hardware.
                         * For implementations supporting less than 16-bit domain-ids, unused bits
                         * of this field are treated as reserved by hardware. For example, for
                         * implementation supporting 8-bit domain-ids, bits 87:80 of this field are
                         * treated as reserved. Context-entries programmed with the same domain
                         * identifier must always reference same address translation (SLPTPTR
                         * field). Context-entries referencing same address translation are
                         * recommended to be programmed with same domain id for hardware efficiency.
                         * When Caching Mode (CM) field in Capability Register is reported as Set,
                         * the domain-id value of zero is architecturally reserved. Software must
                         * not use domain-id value of zero when CM is Set.
                         */
                        UINT64 DomainIdentifier : 10;
#define VTD_Upper64_DOMAIN_IDENTIFIER_BIT  8
#define VTD_Upper64_DOMAIN_IDENTIFIER_FLAG 0x3FF00
#define VTD_Upper64_DOMAIN_IDENTIFIER_MASK 0x3FF
#define VTD_Upper64_DOMAIN_IDENTIFIER(_)   (((_) >> 8) & 0x3FF)
                        UINT64 Reserved2 : 46;
                };

                UINT64 AsUInt;
        } Upper64;

} VTD_CONTEXT_ENTRY;

/**
 * @defgroup VTD_ENTRY_COUNT \
 *           Table entry counts
 *
 * Table entry counts.
 * @{
 */
#define VTD_ROOT_ENTRY_COUNT    0x00000100
#define VTD_CONTEXT_ENTRY_COUNT 0x00000100
/**
 * @}
 */

/**
 * Register to report the implementation version. Backward compatibility for the architecture is
 * maintained with new revision numbers, allowing software to load remapping hardware drivers
 * written for prior versions.
 *
 * @remarks VER_REG
 * @see VTd[10.4.1(Version Register)]
 */
#define VTD_VERSION 0x00000000
typedef union
{
        struct
        {
                /**
                 * @brief Minor Version number <b>(RO)</b>
                 *
                 * [Bits 3:0] Indicates Minor Version of Implementation.
                 */
                UINT32 Minor : 4;
#define VTD_VERSION_MINOR_BIT  0
#define VTD_VERSION_MINOR_FLAG 0x0F
#define VTD_VERSION_MINOR_MASK 0x0F
#define VTD_VERSION_MINOR(_)   (((_) >> 0) & 0x0F)

                /**
                 * @brief Major Version number <b>(RO)</b>
                 *
                 * [Bits 7:4] Indicates Major Version of Implementation.
                 */
                UINT32 Major : 4;
#define VTD_VERSION_MAJOR_BIT  4
#define VTD_VERSION_MAJOR_FLAG 0xF0
#define VTD_VERSION_MAJOR_MASK 0x0F
#define VTD_VERSION_MAJOR(_)   (((_) >> 4) & 0x0F)
                UINT32 Reserved1 : 24;
        };

        UINT32 AsUInt;
} VTD_VERSION_REGISTER;

/**
 * Register to report general remapping hardware capabilities.
 *
 * @remarks CAP_REG
 * @see VTd[10.4.2(Capability Register)]
 */
#define VTD_CAPABILITY 0x00000008
typedef union
{
        struct
        {
                /**
                 * @brief Number of domains supported <b>(RO)</b>
                 *
                 * [Bits 2:0]
                 * * 000b: Hardware supports 4-bit domain-ids with support for up to 16 domains.
                 * * 001b: Hardware supports 6-bit domain-ids with support for up to 64 domains.
                 * * 010b: Hardware supports 8-bit domain-ids with support for up to 256 domains.
                 * * 011b: Hardware supports 10-bit domain-ids with support for up to 1024 domains.
                 * * 100b: Hardware supports 12-bit domain-ids with support for up to 4K domains.
                 * * 101b: Hardware supports 14-bit domain-ids with support for up to 16K domains.
                 * * 110b: Hardware supports 16-bit domain-ids with support for up to 64K domains.
                 * * 111b: Reserved.
                 */
                UINT64 NumberOfDomainsSupported : 3;
#define VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED_BIT  0
#define VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED_FLAG 0x07
#define VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED_MASK 0x07
#define VTD_CAPABILITY_NUMBER_OF_DOMAINS_SUPPORTED(_)   (((_) >> 0) & 0x07)

                /**
                 * @brief Advanced Fault Logging <b>(RO)</b>
                 *
                 * [Bit 3]
                 * * 0: Indicates advanced fault logging is not supported. Only primary fault
                 * logging is supported.
                 * * 1: Indicates advanced fault logging is supported.
                 */
                UINT64 AdvancedFaultLogging : 1;
#define VTD_CAPABILITY_ADVANCED_FAULT_LOGGING_BIT  3
#define VTD_CAPABILITY_ADVANCED_FAULT_LOGGING_FLAG 0x08
#define VTD_CAPABILITY_ADVANCED_FAULT_LOGGING_MASK 0x01
#define VTD_CAPABILITY_ADVANCED_FAULT_LOGGING(_)   (((_) >> 3) & 0x01)

                /**
                 * @brief Required Write-Buffer Flushing <b>(RO)</b>
                 *
                 * [Bit 4]
                 * * 0: Indicates no write-buffer flushing is needed to ensure changes to
                 * memory-resident structures are visible to hardware.
                 * * 1: Indicates software must explicitly flush the write buffers to ensure updates
                 * made to memory-resident remapping structures are visible to hardware.
                 */
                UINT64 RequiredWriteBufferFlushing : 1;
#define VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING_BIT  4
#define VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING_FLAG 0x10
#define VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING_MASK 0x01
#define VTD_CAPABILITY_REQUIRED_WRITE_BUFFER_FLUSHING(_)   (((_) >> 4) & 0x01)

                /**
                 * @brief Protected Low-Memory Region <b>(RO)</b>
                 *
                 * [Bit 5]
                 * * 0: Indicates protected low-memory region is not supported.
                 * * 1: Indicates protected low-memory region is supported.
                 */
                UINT64 ProtectedLowMemoryRegion : 1;
#define VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION_BIT  5
#define VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION_FLAG 0x20
#define VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION_MASK 0x01
#define VTD_CAPABILITY_PROTECTED_LOW_MEMORY_REGION(_)   (((_) >> 5) & 0x01)

                /**
                 * @brief Protected High-Memory Region <b>(RO)</b>
                 *
                 * [Bit 6]
                 * * 0: Indicates protected high-memory region is not supported.
                 * * 1: Indicates protected high-memory region is supported.
                 */
                UINT64 ProtectedHighMemoryRegion : 1;
#define VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION_BIT  6
#define VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION_FLAG 0x40
#define VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION_MASK 0x01
#define VTD_CAPABILITY_PROTECTED_HIGH_MEMORY_REGION(_)   (((_) >> 6) & 0x01)

                /**
                 * @brief Caching Mode <b>(RO)</b>
                 *
                 * [Bit 7] This field applies to all DMA and Interrupt remap tables except FLtables.
                 * Hardware will not cache faulting FL-only translations in IOTLB or
                 * FL-paging-structure caches.
                 * * 0: Not-present and erroneous entries are not cached in any of the remapping
                 * caches. Invalidations are not required for modifications to individual not
                 * present or invalid entries. However, any modifications that result in decreasing
                 * the effective permissions or partial permission increases require invalidations
                 * for them to be effective.
                 * * 1: Not-present and erroneous mappings may be cached in the remapping caches.
                 * Any software updates to the remapping structures (including updates to
                 * "not-present" or erroneous entries) require explicit invalidation.
                 */
                UINT64 CachingMode : 1;
#define VTD_CAPABILITY_CACHING_MODE_BIT  7
#define VTD_CAPABILITY_CACHING_MODE_FLAG 0x80
#define VTD_CAPABILITY_CACHING_MODE_MASK 0x01
#define VTD_CAPABILITY_CACHING_MODE(_)   (((_) >> 7) & 0x01)

                /**
                 * @brief Supported Adjusted Guest Address Widths <b>(RO)</b>
                 *
                 * [Bits 12:8] This 5-bit field indicates the supported adjusted guest address
                 * widths (which in turn represents the levels of page-table walks for the 4KB base
                 * page size) supported by the hardware implementation. A value of 1 in any of these
                 * bits indicates the corresponding adjusted guest address width is supported. The
                 * adjusted guest address widths corresponding to various bit positions within this
                 * field are:
                 * * 0: Reserved
                 * * 1: 39-bit AGAW (3-level page-table)
                 * * 2: 48-bit AGAW (4-level page-table)
                 * * 3: 57-bit AGAW (5-level page-table)
                 * * 4: Reserved
                 * Software must ensure that the adjusted guest address width used to set up the
                 * page tables is one of the supported guest address widths reported in this field.
                 * Hardware implementations reporting second-level translation support (SLTS) field
                 * as Clear also report this field as 0.
                 */
                UINT64 SupportedAdjustedGuestAddressWidths : 5;
#define VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS_BIT  8
#define VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS_FLAG 0x1F00
#define VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS_MASK 0x1F
#define VTD_CAPABILITY_SUPPORTED_ADJUSTED_GUEST_ADDRESS_WIDTHS(_)   (((_) >> 8) & 0x1F)
                UINT64 Reserved1 : 3;

                /**
                 * @brief Maximum Guest Address Width <b>(RO)</b>
                 *
                 * [Bits 21:16] This field indicates the maximum guest physical address width
                 * supported by second-level translation in remapping hardware. The Maximum Guest
                 * Address Width (MGAW) is computed as (N+1), where N is the valued reported in this
                 * field. For example, a hardware implementation supporting 48-bit MGAW reports a
                 * value of 47 (101111b) in this field. If the value in this field is X,
                 * untranslated DMA requests with addresses above 2(X+1)-1 that are subjected to
                 * second-level translation are blocked by hardware. Device-TLB translation requests
                 * to addresses above 2(X+1)-1 that are subjected to second-level translation from
                 * allowed devices return a null Translation-Completion Data with R=W=0. Guest
                 * addressability for a given DMA request is limited to the minimum of the value
                 * reported through this field and the adjusted guest address width of the
                 * corresponding page-table structure. (Adjusted guest address widths supported by
                 * hardware are reported through the SAGAW field).
                 * Implementations must support MGAW at least equal to the physical addressability
                 * (host address width) of the platform.
                 */
                UINT64 MaximumGuestAddressWidth : 6;
#define VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH_BIT  16
#define VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH_FLAG 0x3F0000
#define VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH_MASK 0x3F
#define VTD_CAPABILITY_MAXIMUM_GUEST_ADDRESS_WIDTH(_)   (((_) >> 16) & 0x3F)

                /**
                 * @brief Zero Length Read <b>(RO)</b>
                 *
                 * [Bit 22]
                 * * 0: Indicates the remapping hardware unit blocks (and treats as fault) zero
                 * length DMA read requests to write-only pages.
                 * * 1: Indicates the remapping hardware unit supports zero length DMA read requests
                 * to write-only pages. DMA remapping hardware implementations are recommended to
                 * report ZLR field as Set.
                 */
                UINT64 ZeroLengthRead : 1;
#define VTD_CAPABILITY_ZERO_LENGTH_READ_BIT  22
#define VTD_CAPABILITY_ZERO_LENGTH_READ_FLAG 0x400000
#define VTD_CAPABILITY_ZERO_LENGTH_READ_MASK 0x01
#define VTD_CAPABILITY_ZERO_LENGTH_READ(_)   (((_) >> 22) & 0x01)

                /**
                 * @brief Deprecated <b>(RO)</b>
                 *
                 * [Bit 23] This field must be reported as 0 to ensure backward compatibility with
                 * older software.
                 */
                UINT64 Deprecated : 1;
#define VTD_CAPABILITY_DEPRECATED_BIT  23
#define VTD_CAPABILITY_DEPRECATED_FLAG 0x800000
#define VTD_CAPABILITY_DEPRECATED_MASK 0x01
#define VTD_CAPABILITY_DEPRECATED(_)   (((_) >> 23) & 0x01)

                /**
                 * @brief Fault-recording Register offset <b>(RO)</b>
                 *
                 * [Bits 33:24] This field specifies the offset of the first fault recording
                 * register relative to the register base address of this remapping hardware unit.
                 * If the register base address is X, and the value reported in this field is Y, the
                 * address for the first fault recording register is calculated as X+(16*Y).
                 */
                UINT64 FaultRecordingRegisterOffset : 10;
#define VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET_BIT  24
#define VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET_FLAG 0x3FF000000
#define VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET_MASK 0x3FF
#define VTD_CAPABILITY_FAULT_RECORDING_REGISTER_OFFSET(_)   (((_) >> 24) & 0x3FF)

                /**
                 * @brief Second Level Large Page Support <b>(RO)</b>
                 *
                 * [Bits 37:34] This field indicates the large page sizes supported by hardware.
                 * A value of 1 in any of these bits indicates the corresponding large page size is
                 * supported. The large-page sizes corresponding to various bit positions within
                 * this field are:
                 * * 0: 21-bit offset to page frame (2MB)
                 * * 1: 30-bit offset to page frame (1GB)
                 * * 2: Reserved
                 * * 3: Reserved
                 * Hardware implementations supporting a specific large-page size must support all
                 * smaller large-page sizes. i.e., only valid values for this field are 0000b,
                 * 0001b, 0011b.
                 */
                UINT64 SecondLevelLargePageSupport : 4;
#define VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT_BIT  34
#define VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT_FLAG 0x3C00000000
#define VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT_MASK 0x0F
#define VTD_CAPABILITY_SECOND_LEVEL_LARGE_PAGE_SUPPORT(_)   (((_) >> 34) & 0x0F)
                UINT64 Reserved2 : 1;

                /**
                 * @brief Page Selective Invalidation <b>(RO)</b>
                 *
                 * [Bit 39]
                 * * 0: Hardware supports only global and domain-selective invalidates for IOTLB.
                 * * 1: Hardware supports page-selective, domain-selective, and global invalidates
                 * for IOTLB. Hardware implementations reporting this field as Set are recommended
                 * to support a Maximum Address Mask Value (MAMV) value of at least 9 (or 18 if
                 * supporting 1GB pages with second level translation). This field is applicable
                 * only for IOTLB invalidations for second-level translation. Irrespective of value
                 * reported in this field, implementations supporting SMTS must support page/address
                 * selective IOTLB invalidation for first-level translation.
                 */
                UINT64 PageSelectiveInvalidation : 1;
#define VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION_BIT  39
#define VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION_FLAG 0x8000000000
#define VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION_MASK 0x01
#define VTD_CAPABILITY_PAGE_SELECTIVE_INVALIDATION(_)   (((_) >> 39) & 0x01)

                /**
                 * @brief Number of Fault-recording Registers <b>(RO)</b>
                 *
                 * [Bits 47:40] Number of fault recording registers is computed as N+1, where N is
                 * the value reported in this field. Implementations must support at least one fault
                 * recording register (NFR = 0) for each remapping hardware unit in the platform.
                 * The maximum number of fault recording registers per remapping hardware unit is
                 * 256.
                 */
                UINT64 NumberOfFaultRecordingRegisters : 8;
#define VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS_BIT  40
#define VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS_FLAG 0xFF0000000000
#define VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS_MASK 0xFF
#define VTD_CAPABILITY_NUMBER_OF_FAULT_RECORDING_REGISTERS(_)   (((_) >> 40) & 0xFF)

                /**
                 * @brief Maximum Address Mask Value <b>(RO)</b>
                 *
                 * [Bits 53:48] The value in this field indicates the maximum supported value for
                 * the Address Mask (AM) field in the Invalidation Address register (IVA_REG), and
                 * IOTLB Invalidation Descriptor (iotlb_inv_dsc) used for invalidations of
                 * second-level translation.
                 * This field is valid when the PSI field in Capability register is reported as Set.
                 * Independent of value reported in this field, implementations supporting SMTS must
                 * support address-selective PASID-based IOTLB invalidations (p_iotlb_inv_dsc) with
                 * any defined address mask.
                 */
                UINT64 MaximumAddressMaskValue : 6;
#define VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE_BIT  48
#define VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE_FLAG 0x3F000000000000
#define VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE_MASK 0x3F
#define VTD_CAPABILITY_MAXIMUM_ADDRESS_MASK_VALUE(_)   (((_) >> 48) & 0x3F)

                /**
                 * @brief Write Draining <b>(RO)</b>
                 *
                 * [Bit 54]
                 * * 0: Hardware does not support draining of write requests on IOTLB Invalidation.
                 * * 1: Hardware supports draining of write requests on IOTLB Invalidation.
                 * Hardware implementation with Major Version 2 or higher (VER_REG), always performs
                 * required drain without software explicitly requesting a drain in IOTLB
                 * invalidation. This field is deprecated and hardware will always report it as 1 to
                 * maintain backward compatibility with software.
                 */
                UINT64 WriteDraining : 1;
#define VTD_CAPABILITY_WRITE_DRAINING_BIT  54
#define VTD_CAPABILITY_WRITE_DRAINING_FLAG 0x40000000000000
#define VTD_CAPABILITY_WRITE_DRAINING_MASK 0x01
#define VTD_CAPABILITY_WRITE_DRAINING(_)   (((_) >> 54) & 0x01)

                /**
                 * @brief Read Draining <b>(RO)</b>
                 *
                 * [Bit 55]
                 * * 0: Hardware does not support draining of read requests on IOTLB Invalidation.
                 * * 1: Hardware supports draining of read requests on IOTLB Invalidation.
                 * Hardware implementation with Major Version 2 or higher (VER_REG), always performs
                 * required drain without software explicitly requesting a drain in IOTLB
                 * invalidation. This field is deprecated and hardware will always report it as 1 to
                 * maintain backward compatibility with software.
                 */
                UINT64 ReadDraining : 1;
#define VTD_CAPABILITY_READ_DRAINING_BIT  55
#define VTD_CAPABILITY_READ_DRAINING_FLAG 0x80000000000000
#define VTD_CAPABILITY_READ_DRAINING_MASK 0x01
#define VTD_CAPABILITY_READ_DRAINING(_)   (((_) >> 55) & 0x01)

                /**
                 * @brief First Level 1-GByte Page Support <b>(RO)</b>
                 *
                 * [Bit 56] A value of 1 in this field indicates 1-GByte page size is supported for
                 * first-level translation. Hardware implementation reporting First-level
                 * Translation Support (FLTS) as Clear also report this field as Clear.
                 */
                UINT64 FirstLevel1GbytePageSupport : 1;
#define VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT_BIT  56
#define VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT_FLAG 0x100000000000000
#define VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT_MASK 0x01
#define VTD_CAPABILITY_FIRST_LEVEL_1GBYTE_PAGE_SUPPORT(_)   (((_) >> 56) & 0x01)
                UINT64 Reserved3 : 2;

                /**
                 * @brief Posted Interrupts Support <b>(RO)</b>
                 *
                 * [Bit 59]
                 * * 0: Hardware does not support Posting of Interrupts.
                 * * 1: Hardware supports Posting of Interrupts.
                 * Hardware implementation reporting Interrupt Remapping support (IR) field in
                 * Extended Capability Register as Clear also report this field as Clear.
                 */
                UINT64 PostedInterruptsSupport : 1;
#define VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT_BIT  59
#define VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT_FLAG 0x800000000000000
#define VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT_MASK 0x01
#define VTD_CAPABILITY_POSTED_INTERRUPTS_SUPPORT(_)   (((_) >> 59) & 0x01)

                /**
                 * @brief First Level 5-level Paging Support <b>(RO)</b>
                 *
                 * [Bit 60]
                 * * 0: Hardware does not support 5-level paging for first-level translation.
                 * * 1: Hardware supports 5-level paging for first-level translation.
                 * Hardware implementation reporting First-level Translation Support (FLTS) as Clear
                 * also report this field as Clear.
                 */
                UINT64 FirstLevel5LevelPagingSupport : 1;
#define VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT_BIT  60
#define VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT_FLAG 0x1000000000000000
#define VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT_MASK 0x01
#define VTD_CAPABILITY_FIRST_LEVEL_5LEVEL_PAGING_SUPPORT(_)   (((_) >> 60) & 0x01)
                UINT64 Reserved4 : 1;

                /**
                 * @brief Enhanced Set Interrupt Remap Table Pointer Support <b>(RO)</b>
                 *
                 * [Bit 62]
                 * * 0: Hardware does not invalidate all Interrupt remapping hardware translation
                 * caches as part of SIRTP flow.
                 * * 1: Hardware invalidates all Interrupt remapping hardware translation caches as
                 * part of SIRTP flow.
                 */
                UINT64 EnhancedSetInterruptRemapTablePointerSupport : 1;
#define VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT_BIT  62
#define VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT_FLAG 0x4000000000000000
#define VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT_MASK 0x01
#define VTD_CAPABILITY_ENHANCED_SET_INTERRUPT_REMAP_TABLE_POINTER_SUPPORT(_)   (((_) >> 62) & 0x01)

                /**
                 * @brief Enhanced Set Root Table Pointer Support <b>(RO)</b>
                 *
                 * [Bit 63]
                 * * 0: Hardware does not invalidate all DMA remapping hardware translation caches
                 * as part of SRTP flow.
                 * * 1: Hardware invalidates all DMA remapping hardware translation caches as part
                 * of SRTP flow.
                 */
                UINT64 EnhancedSetRootTablePointerSupport : 1;
#define VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT_BIT  63
#define VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT_FLAG 0x8000000000000000
#define VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT_MASK 0x01
#define VTD_CAPABILITY_ENHANCED_SET_ROOT_TABLE_POINTER_SUPPORT(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} VTD_CAPABILITY_REGISTER;

/**
 * Register to report remapping hardware extended capabilities
 *
 * @remarks ECAP_REG
 * @see VTd[10.4.3(Extended Capability Register)]
 */
#define VTD_EXTENDED_CAPABILITY 0x00000010
typedef union
{
        struct
        {
                /**
                 * @brief Page-walk Coherency <b>(RO)</b>
                 *
                 * [Bit 0] This field indicates if hardware access to the root, scalable-mode root,
                 * context, scalable-mode-context, scalable-mode PASIDdirectory, scalable-mode
                 * PASID-table, and interrupt-remap tables, and legacy-mode second-level paging
                 * structures are coherent (snooped) or not.
                 * * 0:Indicates hardware accesses to remapping structures are non-coherent.
                 * * 1:Indicates hardware accesses to remapping structures are coherent.
                 * Hardware access to advanced fault log, invalidation queue, invalidation
                 * semaphore, page-request queue are always snooped.
                 */
                UINT64 PageWalkCoherency : 1;
#define VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY_BIT  0
#define VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY_FLAG 0x01
#define VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_PAGE_WALK_COHERENCY(_)   (((_) >> 0) & 0x01)

                /**
                 * @brief Queued Invalidation support <b>(RO)</b>
                 *
                 * [Bit 1]
                 * * 0: Hardware does not support queued invalidations.
                 * * 1: Hardware supports queued invalidations.
                 */
                UINT64 QueuedInvalidationSupport : 1;
#define VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT_BIT  1
#define VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT_FLAG 0x02
#define VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_QUEUED_INVALIDATION_SUPPORT(_)   (((_) >> 1) & 0x01)

                /**
                 * @brief Device-TLB support <b>(RO)</b>
                 *
                 * [Bit 2]
                 * * 0: Hardware does not support Device-TLBs.
                 * * 1: Hardware supports Device-TLBs.
                 * Hardware implementation reporting Queued Invalidation support (QI) field as Clear
                 * also report this field as Clear.
                 */
                UINT64 DeviceTlbSupport : 1;
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT_BIT  2
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT_FLAG 0x04
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_SUPPORT(_)   (((_) >> 2) & 0x01)

                /**
                 * @brief Interrupt Remapping support <b>(RO)</b>
                 *
                 * [Bit 3]
                 * * 0: Hardware does not support interrupt remapping.
                 * * 1: Hardware supports interrupt remapping.
                 * Hardware implementation reporting Queued Invalidation support (QI) field as Clear
                 * also report this field as Clear.
                 */
                UINT64 InterruptRemappingSupport : 1;
#define VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT_BIT  3
#define VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT_FLAG 0x08
#define VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_INTERRUPT_REMAPPING_SUPPORT(_)   (((_) >> 3) & 0x01)

                /**
                 * @brief Extended Interrupt Mode <b>(RO)</b>
                 *
                 * [Bit 4]
                 * * 0: On Intel(R) 64 platforms, hardware supports only 8-bit APIC-IDs (xAPIC
                 * Mode).
                 * * 1: On Intel(R) 64 platforms, hardware supports 32-bit APICIDs (x2APIC mode).
                 * Hardware implementation reporting Interrupt Remapping support (IR) field as Clear
                 * also report this field as Clear.
                 */
                UINT64 ExtendedInterruptMode : 1;
#define VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE_BIT  4
#define VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE_FLAG 0x10
#define VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_EXTENDED_INTERRUPT_MODE(_)   (((_) >> 4) & 0x01)

                /**
                 * @brief Deprecated1 <b>(RO)</b>
                 *
                 * [Bit 5] This field must be reported as 0 to ensure backward compatibility with
                 * older software.
                 */
                UINT64 Deprecated1 : 1;
#define VTD_EXTENDED_CAPABILITY_DEPRECATED1_BIT  5
#define VTD_EXTENDED_CAPABILITY_DEPRECATED1_FLAG 0x20
#define VTD_EXTENDED_CAPABILITY_DEPRECATED1_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_DEPRECATED1(_)   (((_) >> 5) & 0x01)

                /**
                 * @brief Pass Through <b>(RO)</b>
                 *
                 * [Bit 6]
                 * * 0: Hardware does not support pass-through translation type in context-entries
                 * and scalable-mode-pasid-table-entries.
                 * * 1: Hardware supports pass-through translation type in context and
                 * scalable-mode-pasid-table-entries.
                 */
                UINT64 PassThrough : 1;
#define VTD_EXTENDED_CAPABILITY_PASS_THROUGH_BIT  6
#define VTD_EXTENDED_CAPABILITY_PASS_THROUGH_FLAG 0x40
#define VTD_EXTENDED_CAPABILITY_PASS_THROUGH_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_PASS_THROUGH(_)   (((_) >> 6) & 0x01)

                /**
                 * @brief Snoop Control <b>(RO)</b>
                 *
                 * [Bit 7]
                 * * 0: Hardware does not support 1-setting of the SNP field in the page-table
                 * entries.
                 * * 1: Hardware supports the 1-setting of the SNP field in the page-table entries.
                 * Implementations are recommended to support Snoop Control to support software
                 * usages that require Snoop Control for assignment of devices behind a remapping
                 * hardware unit.
                 */
                UINT64 SnoopControl : 1;
#define VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL_BIT  7
#define VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL_FLAG 0x80
#define VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SNOOP_CONTROL(_)   (((_) >> 7) & 0x01)

                /**
                 * @brief IOTLB Register Offset <b>(RO)</b>
                 *
                 * [Bits 17:8] This field specifies the offset to the IOTLB registers relative to
                 * the register base address of this remapping hardware unit. If the register base
                 * address is X, and the value reported in this field is Y, the address for the
                 * IOTLB registers is calculated as X+(16*Y).
                 */
                UINT64 IotlbRegisterOffset : 10;
#define VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET_BIT  8
#define VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET_FLAG 0x3FF00
#define VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET_MASK 0x3FF
#define VTD_EXTENDED_CAPABILITY_IOTLB_REGISTER_OFFSET(_)   (((_) >> 8) & 0x3FF)
                UINT64 Reserved1 : 2;

                /**
                 * @brief Maximum Handle Mask Value <b>(RO)</b>
                 *
                 * [Bits 23:20] The value in this field indicates the maximum supported value for
                 * the Interrupt Mask (IM) field in the Interrupt Entry Cache Invalidation
                 * Descriptor (iec_inv_dsc). This field is unused and is reported as 0 if Interrupt
                 * Remapping support (IR) field is Clear.
                 */
                UINT64 MaximumHandleMaskValue : 4;
#define VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE_BIT  20
#define VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE_FLAG 0xF00000
#define VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE_MASK 0x0F
#define VTD_EXTENDED_CAPABILITY_MAXIMUM_HANDLE_MASK_VALUE(_)   (((_) >> 20) & 0x0F)

                /**
                 * @brief Deprecated2 <b>(RO)</b>
                 *
                 * [Bit 24] In prior versions of this specification this bit was used to enumerate
                 * "Extended mode address translation" which is now deprecated. This field must be
                 * reported as 0 to ensure backward compatibility with any software that enables
                 * extended mode address translation.
                 */
                UINT64 Deprecated2 : 1;
#define VTD_EXTENDED_CAPABILITY_DEPRECATED2_BIT  24
#define VTD_EXTENDED_CAPABILITY_DEPRECATED2_FLAG 0x1000000
#define VTD_EXTENDED_CAPABILITY_DEPRECATED2_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_DEPRECATED2(_)   (((_) >> 24) & 0x01)

                /**
                 * @brief Memory Type Support <b>(RO)</b>
                 *
                 * [Bit 25]
                 * * 0: Hardware does not support Memory Type in first-level translation and
                 * Extended Memory type in second-level translation.
                 * * 1: Hardware supports Memory Type in first-level translation and Extended Memory
                 * type in second-level translation. Hardware implementations reporting Scalable
                 * Mode Translation Support (SMTS) field as Clear also report this field as Clear.
                 * Remapping hardware units with, one or more devices that operate in processor
                 * coherency domain, under its scope must report this field as Set.
                 */
                UINT64 MemoryTypeSupport : 1;
#define VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT_BIT  25
#define VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT_FLAG 0x2000000
#define VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_MEMORY_TYPE_SUPPORT(_)   (((_) >> 25) & 0x01)

                /**
                 * @brief Nested Translation Support <b>(RO)</b>
                 *
                 * [Bit 26]
                 * * 0: Hardware does not support nested translations.
                 * * 1: Hardware supports nested translations.
                 * Hardware implementations reporting Scalable Mode Translation Support (SMTS) field
                 * as Clear or First-level Translation Support (FLTS) field as Clear or Second-level
                 * Translation Support (SLTS) field as Clear also report this field as Clear.
                 */
                UINT64 NestedTranslationSupport : 1;
#define VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT_BIT  26
#define VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT_FLAG 0x4000000
#define VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_NESTED_TRANSLATION_SUPPORT(_)   (((_) >> 26) & 0x01)
                UINT64 Reserved2 : 1;

                /**
                 * @brief Deprecated3 <b>(RO)</b>
                 *
                 * [Bit 28] This field must be reported as 0 to ensure backward compatibility with
                 * older software.
                 */
                UINT64 Deprecated3 : 1;
#define VTD_EXTENDED_CAPABILITY_DEPRECATED3_BIT  28
#define VTD_EXTENDED_CAPABILITY_DEPRECATED3_FLAG 0x10000000
#define VTD_EXTENDED_CAPABILITY_DEPRECATED3_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_DEPRECATED3(_)   (((_) >> 28) & 0x01)

                /**
                 * @brief Page Request Support <b>(RO)</b>
                 *
                 * [Bit 29]
                 * * 0: Hardware does not support page requests.
                 * * 1: Hardware supports page requests.
                 * Hardware implementation reporting Device-TLB support (DT) field as Clear or
                 * Scalable Mode Translation Support (SMTS) field as Clear also report this field as
                 * Clear.
                 */
                UINT64 PageRequestSupport : 1;
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT_BIT  29
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT_FLAG 0x20000000
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_SUPPORT(_)   (((_) >> 29) & 0x01)

                /**
                 * @brief Execute Request Support <b>(RO)</b>
                 *
                 * [Bit 30]
                 * * 0: Hardware does not support requests-with-PASID seeking execute permission.
                 * * 1: Hardware supports requests-with-PASID seeking execute permission.
                 * Hardware implementations reporting Process Address Space ID support (PASID) field
                 * as Clear must report this field as Clear.
                 */
                UINT64 ExecuteRequestSupport : 1;
#define VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT_BIT  30
#define VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT_FLAG 0x40000000
#define VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_EXECUTE_REQUEST_SUPPORT(_)   (((_) >> 30) & 0x01)
                UINT64 Reserved3 : 2;

                /**
                 * @brief No Write Flag Support <b>(RO)</b>
                 *
                 * [Bit 33]
                 * * 0: Hardware ignores the 'No Write' (NW) flag in Device-TLB
                 * translation-requests, and behaves as if NW is always 0.
                 * * 1: Hardware supports the 'No Write' (NW) flag in Device-TLB
                 * translation-requests. Hardware implementations reporting Device-TLB support (DT)
                 * field as Clear also report this field as Clear.
                 */
                UINT64 NoWriteFlagSupport : 1;
#define VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT_BIT  33
#define VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT_FLAG 0x200000000
#define VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_NO_WRITE_FLAG_SUPPORT(_)   (((_) >> 33) & 0x01)

                /**
                 * @brief Extended Accessed Flag Support <b>(RO)</b>
                 *
                 * [Bit 34]
                 * * 0: Hardware does not support the extended-accessed (EA) bit in first-level
                 * paging-structure entries.
                 * * 1: Hardware supports the extended-accessed (EA) bit in first-level
                 * paging-structure entries. Hardware implementations reporting Scalable-Mode
                 * Page-walk Coherency Support (SWPWCS) as Clear also report this field as Clear.
                 */
                UINT64 ExtendedAccessedFlagSupport : 1;
#define VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT_BIT  34
#define VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT_FLAG 0x400000000
#define VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_EXTENDED_ACCESSED_FLAG_SUPPORT(_)   (((_) >> 34) & 0x01)

                /**
                 * @brief PASID Size Supported <b>(RO)</b>
                 *
                 * [Bits 39:35] This field reports the PASID size supported by the remapping
                 * hardware for requests-with-PASID. A value of N in this field indicates hardware
                 * supports PASID field of N+1 bits (For example, value of 7 in this field,
                 * indicates 8-bit PASIDs are supported). Requests-with-PASID with PASID value
                 * beyond the limit specified by this field are treated as error by the remapping
                 * hardware. This field is unused and reported as 0 if Scalable Mode Translation
                 * Support (SMTS) field is Clear.
                 */
                UINT64 PasidSizeSupported : 5;
#define VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED_BIT  35
#define VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED_FLAG 0xF800000000
#define VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED_MASK 0x1F
#define VTD_EXTENDED_CAPABILITY_PASID_SIZE_SUPPORTED(_)   (((_) >> 35) & 0x1F)

                /**
                 * @brief Process Address Space ID Support <b>(RO)</b>
                 *
                 * [Bit 40]
                 * * 0: Hardware does not support requests tagged with Process Address Space IDs.
                 * * 1: Hardware supports requests tagged with Process Address Space IDs.
                 * Hardware implementations reporting Scalable Mode Translation Support (SMTS) field
                 * as Clear also report this field as Clear.
                 */
                UINT64 ProcessAddressSpaceIdSupport : 1;
#define VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT_BIT  40
#define VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT_FLAG 0x10000000000
#define VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_PROCESS_ADDRESS_SPACE_ID_SUPPORT(_)   (((_) >> 40) & 0x01)

                /**
                 * @brief Device-TLB Invalidation Throttle <b>(RO)</b>
                 *
                 * [Bit 41]
                 * * 0: Hardware does not support Device-TLB Invalidation Throttling.
                 * * 1: Hardware supports Device-TLB Invalidation Throttling.
                 * Hardware implementations reporting Device-TLB support (DT) as Clear also report
                 * this field as Clear.
                 */
                UINT64 DeviceTlbInvalidationThrottle : 1;
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE_BIT  41
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE_FLAG 0x20000000000
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_DEVICE_TLB_INVALIDATION_THROTTLE(_)   (((_) >> 41) & 0x01)

                /**
                 * @brief Page-request Drain Support <b>(RO)</b>
                 *
                 * [Bit 42]
                 * * 0: Hardware does not support Page-request Drain (PD) flag in inv_wait_dsc.
                 * * 1: Hardware supports Page-request Drain (PD) flag in inv_wait_dsc.
                 * Hardware implementations reporting Device-TLB support (DT) as Clear also report
                 * this field as Clear.
                 */
                UINT64 PageRequestDrainSupport : 1;
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT_BIT  42
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT_FLAG 0x40000000000
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_PAGE_REQUEST_DRAIN_SUPPORT(_)   (((_) >> 42) & 0x01)

                /**
                 * @brief Scalable Mode Translation Support <b>(RO)</b>
                 *
                 * [Bit 43]
                 * * 0: Hardware does not support Scalable Mode DMA Remapping.
                 * * 1: Hardware supports Scalable Mode DMA Remapping through scalable-mode
                 * context-table and PASID-table structures. Hardware implementation reporting
                 * Queued Invalidation (QI) field as Clear also report this field as Clear. Hardware
                 * implementation reporting First-Level Translation Support (FLTS), Second-level
                 * Translation Support (SLTS) and Pass-through Support (PT) as Clear also report
                 * this field as Clear.
                 */
                UINT64 ScalableModeTranslationSupport : 1;
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT_BIT  43
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT_FLAG 0x80000000000
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_TRANSLATION_SUPPORT(_)   (((_) >> 43) & 0x01)

                /**
                 * @brief Virtual Command Support <b>(RO)</b>
                 *
                 * [Bit 44]
                 * * 0: Hardware does not support command submission to virtual-DMA Remapping
                 * hardware.
                 * * 1: Hardware does support command submission to virtual- DMA Remapping hardware.
                 * Hardware implementations of this architecture report a value of 0 in this field.
                 * Software implementations (emulation) of this architecture may report VCS=1.
                 * Software managing remapping hardware should be written to handle both values of
                 * VCS.
                 */
                UINT64 VirtualCommandSupport : 1;
#define VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT_BIT  44
#define VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT_FLAG 0x100000000000
#define VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_VIRTUAL_COMMAND_SUPPORT(_)   (((_) >> 44) & 0x01)

                /**
                 * @brief Second-Level Accessed/Dirty Support <b>(RO)</b>
                 *
                 * [Bit 45]
                 * * 0: Hardware does not support Accessed/Dirty bits in Second- Level translation.
                 * * 1: Hardware supports Accessed/Dirty bits in Second-Level translation.
                 * Hardware implementations reporting Scalable-Mode Page-walk Coherency Support
                 * (SMPWCS) as Clear also report this field as Clear.
                 */
                UINT64 SecondLevelAccessedDirtySupport : 1;
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT_BIT  45
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT_FLAG 0x200000000000
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_ACCESSED_DIRTY_SUPPORT(_)   (((_) >> 45) & 0x01)

                /**
                 * @brief Second-level Translation Support <b>(RO)</b>
                 *
                 * [Bit 46]
                 * * 0: Hardware does not support PASID Granular Translation Type of second-level
                 * (PGTT=010b) in scalable-mode PASIDTable entry.
                 * * 1: Hardware supports PASID Granular Translation Type of second-level
                 * (PGTT=010b) in scalable-mode PASID-Table entry.
                 */
                UINT64 SecondLevelTranslationSupport : 1;
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT_BIT  46
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT_FLAG 0x400000000000
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SECOND_LEVEL_TRANSLATION_SUPPORT(_)   (((_) >> 46) & 0x01)

                /**
                 * @brief First-level Translation Support <b>(RO)</b>
                 *
                 * [Bit 47]
                 * * 0: Hardware does not support PASID Granular Translation Type of first-level
                 * (PGTT=001b) in scalable-mode PASIDTable entry.
                 * * 1: Hardware supports PASID Granular Translation Type of first-level (PGTT=001b)
                 * in scalable-mode PASID-Table entry. Hardware implementations reporting Scalable
                 * Mode Translation Support (SMTS) as Clear also report this field as Clear
                 */
                UINT64 FirstLevelTranslationSupport : 1;
#define VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT_BIT  47
#define VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT_FLAG 0x800000000000
#define VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_FIRST_LEVEL_TRANSLATION_SUPPORT(_)   (((_) >> 47) & 0x01)

                /**
                 * @brief Scalable-Mode Page-walk Coherency <b>(RO)</b>
                 *
                 * [Bit 48]
                 * * 0: Hardware access to paging structures accessed through PASID-table entry are
                 * not snooped.
                 * * 1: Hardware access to paging structures accessed through PASID-table entry are
                 * snooped if PWSNP field in PASID-table entry is Set. Paging-structures accessed
                 * through PASID-table entry are not snooped if PWSNP field in PASID-table entry is
                 * Clear. Hardware implementations reporting Scalable Mode Translation Support
                 * (SMTS) as Clear also report this field as Clear.
                 */
                UINT64 ScalableModePageWalkCoherency : 1;
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY_BIT  48
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY_FLAG 0x1000000000000
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_SCALABLE_MODE_PAGE_WALK_COHERENCY(_)   (((_) >> 48) & 0x01)

                /**
                 * @brief RID-PASID Support <b>(RO)</b>
                 *
                 * [Bit 49]
                 * * 0: Hardware does not support RID_PASID field in scalable mode context-entry. It
                 * uses the value of 0 for RID_PASID.
                 * * 1: Hardware supports the RID_PASID field in scalable-mode context-entry.
                 * Hardware implementations reporting Scalable Mode Translation Support (SMTS) as
                 * Clear also report this field as Clear.
                 */
                UINT64 RidPasidSupport : 1;
#define VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT_BIT  49
#define VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT_FLAG 0x2000000000000
#define VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_RID_PASID_SUPPORT(_)   (((_) >> 49) & 0x01)
                UINT64 Reserved4 : 2;

                /**
                 * @brief Abort DMA Mode Support <b>(RO)</b>
                 *
                 * [Bit 52]
                 * * 0: Hardware does not support Abort DMA Mode.
                 * * 1: Hardware supports Abort DMA Mode.
                 */
                UINT64 AbortDmaModeSupport : 1;
#define VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT_BIT  52
#define VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT_FLAG 0x10000000000000
#define VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_ABORT_DMA_MODE_SUPPORT(_)   (((_) >> 52) & 0x01)

                /**
                 * @brief RID_PRIV Support <b>(RO)</b>
                 *
                 * [Bit 53]
                 * * 0: Hardware does not support the RID_PRIV field in the scalable-mode
                 * context-entry. It uses the value of 0 for RID_PRIV.
                 * * 1: Hardware supports the RID_PRIV field in the scalable mode context-entry.
                 * Hardware implementations reporting Supervisor Request Support (SRS) as Clear also
                 * report this field as Clear.
                 */
                UINT64 RidPrivSupport : 1;
#define VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT_BIT  53
#define VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT_FLAG 0x20000000000000
#define VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT_MASK 0x01
#define VTD_EXTENDED_CAPABILITY_RID_PRIV_SUPPORT(_)   (((_) >> 53) & 0x01)
                UINT64 Reserved5 : 10;
        };

        UINT64 AsUInt;
} VTD_EXTENDED_CAPABILITY_REGISTER;

/**
 * Register to control remapping hardware. If multiple control fields in this register need to be
 * modified, software must serialize the modifications through multiple writes to this register. For
 * example, to update a bit field in this register at offset X with value of Y, software must follow
 * below steps:
 * 1. Tmp = Read GSTS_REG
 * 2. Status = (Tmp & 96FFFFFFh) // Reset the one-shot bits
 * 3. if (Y) {Command = (Status | (1 << X))} else {Command = (Status & ~(1 << X))}
 * 4. Write Command to GCMD_REG
 * 5. Wait until GSTS_REG[X] indicates command is serviced.
 *
 * @remarks GCMD_REG
 * @see VTd[10.4.4(Global Command Register)]
 */
#define VTD_GLOBAL_COMMAND 0x00000018
typedef union
{
        struct
        {
                UINT32 Reserved1 : 23;

                /**
                 * @brief Compatibility Format Interrupt <b>(WO)</b>
                 *
                 * [Bit 23] This field is valid only for Intel(R) 64 implementations supporting
                 * interrupt remapping. Software writes to this field to enable or disable
                 * Compatibility Format interrupts on Intel(R) 64 platforms. The value in this field
                 * is effective only when interrupt-remapping is enabled and Extended Interrupt Mode
                 * (x2APIC mode) is not enabled.
                 * * 0: Block Compatibility format interrupts.
                 * * 1: Process Compatibility format interrupts as pass-through (bypass interrupt
                 * remapping). Hardware reports the status of updating this field through the CFIS
                 * field in the Global Status register. The value returned on a read of this field
                 * is undefined.
                 */
                UINT32 CompatibilityFormatInterrupt : 1;
#define VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT_BIT  23
#define VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT_FLAG 0x800000
#define VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT_MASK 0x01
#define VTD_GLOBAL_COMMAND_COMPATIBILITY_FORMAT_INTERRUPT(_)   (((_) >> 23) & 0x01)

                /**
                 * @brief Set Interrupt Remap Table Pointer <b>(WO)</b>
                 *
                 * [Bit 24] This field is valid only for implementations supporting interrupt
                 * remapping. Software sets this field to set/update the interrupt remapping table
                 * pointer used by hardware. The interrupt remapping table pointer is specified
                 * through the Interrupt Remapping Table Address (IRTA_REG) register. Hardware
                 * reports the status of the 'Set Interrupt Remap Table Pointer' operation through
                 * the IRTPS field in the Global Status register. The 'Set Interrupt Remap Table
                 * Pointer' operation must be performed before enabling or re-enabling (after
                 * disabling) interrupt-remapping hardware through the IRE field. Clearing this bit
                 * has no effect. The value returned on a read of this field is undefined.
                 */
                UINT32 SetInterruptRemapTablePointer : 1;
#define VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER_BIT  24
#define VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER_FLAG 0x1000000
#define VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER_MASK 0x01
#define VTD_GLOBAL_COMMAND_SET_INTERRUPT_REMAP_TABLE_POINTER(_)   (((_) >> 24) & 0x01)

                /**
                 * @brief Interrupt Remapping Enable <b>(WO)</b>
                 *
                 * [Bit 25] This field is valid only for implementations supporting interrupt
                 * remapping.
                 * * 0: Disable interrupt-remapping hardware
                 * * 1: Enable interrupt-remapping hardware
                 * Hardware reports the status of the interrupt remapping enable operation through
                 * the IRES field in the Global Status register. There may be active interrupt
                 * requests in the platform when software updates this field. Hardware must enable
                 * or disable interrupt-remapping logic only at deterministic transaction
                 * boundaries, so that any in-flight interrupts are either subject to remapping or
                 * not at all. For implementations reporting the Enhanced Set Interrupt Remap Table
                 * Pointer Support (ESIRTPS) field as Set, hardware performs global invalidation on
                 * all Interrupt remapping caches as part of Interrupt Remapping Disable operation.
                 * Hardware implementations must drain any in-flight interrupts requests queued in
                 * the Root-Complex before completing the interrupt-remapping enable command and
                 * reflecting the status of the command through the IRES field in the Global Status
                 * register.
                 * The value returned on a read of this field is undefined.
                 */
                UINT32 InterruptRemappingEnable : 1;
#define VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE_BIT  25
#define VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE_FLAG 0x2000000
#define VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE_MASK 0x01
#define VTD_GLOBAL_COMMAND_INTERRUPT_REMAPPING_ENABLE(_)   (((_) >> 25) & 0x01)

                /**
                 * @brief Queued Invalidation Enable <b>(WO)</b>
                 *
                 * [Bit 26] This field is valid only for implementations supporting queued
                 * invalidations. Software writes to this field to enable or disable queued
                 * invalidations.
                 * * 0: Disable queued invalidations.
                 * * 1: Enable use of queued invalidations.
                 * Hardware reports the status of queued invalidation enable operation through QIES
                 * field in the Global Status register. The value returned on a read of this field
                 * is undefined.
                 */
                UINT32 QueuedInvalidationEnable : 1;
#define VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE_BIT  26
#define VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE_FLAG 0x4000000
#define VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE_MASK 0x01
#define VTD_GLOBAL_COMMAND_QUEUED_INVALIDATION_ENABLE(_)   (((_) >> 26) & 0x01)

                /**
                 * @brief Write Buffer Flush <b>(WO)</b>
                 *
                 * [Bit 27] This bit is valid only for implementations requiring write buffer
                 * flushing. Software sets this field to request that hardware flush the
                 * Root-Complex internal write buffers. This is done to ensure any updates to the
                 * memory resident remapping structures are not held in any internal write posting
                 * buffers. Hardware reports the status of the write buffer flushing operation
                 * through the WBFS field in the Global Status register. Clearing this bit has no
                 * effect. The value returned on a read of this field is undefined.
                 */
                UINT32 WriteBufferFlush : 1;
#define VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH_BIT  27
#define VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH_FLAG 0x8000000
#define VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH_MASK 0x01
#define VTD_GLOBAL_COMMAND_WRITE_BUFFER_FLUSH(_)   (((_) >> 27) & 0x01)

                /**
                 * @brief Enable Advanced Fault Logging <b>(WO)</b>
                 *
                 * [Bit 28] This field is valid only for implementations supporting advanced fault
                 * logging. Software writes to this field to request hardware to enable or disable
                 * advanced fault logging:
                 * * 0: Disable advanced fault logging. In this case, translation faults are
                 * reported through the Fault Recording registers.
                 * * 1: Enable use of memory-resident fault log. When enabled, translation faults
                 * are recorded in the memory-resident log. The fault log pointer must be set in
                 * hardware (through the SFL field) before enabling advanced fault logging. Hardware
                 * reports the status of the advanced fault logging enable operation through the
                 * AFLS field in the Global Status register. The value returned on read of this
                 * field is undefined.
                 */
                UINT32 EnableAdvancedFaultLogging : 1;
#define VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING_BIT  28
#define VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING_FLAG 0x10000000
#define VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING_MASK 0x01
#define VTD_GLOBAL_COMMAND_ENABLE_ADVANCED_FAULT_LOGGING(_)   (((_) >> 28) & 0x01)

                /**
                 * @brief Set Fault Log <b>(WO)</b>
                 *
                 * [Bit 29] This field is valid only for implementations supporting advanced fault
                 * logging. Software sets this field to request hardware to set/update the fault-log
                 * pointer used by hardware. The fault-log pointer is specified through Advanced
                 * Fault Log register. Hardware reports the status of the 'Set Fault Log' operation
                 * through the FLS field in the Global Status register. The fault log pointer must
                 * be set before enabling advanced fault logging (through EAFL field). Once advanced
                 * fault logging is enabled, the fault log pointer may be updated through this field
                 * while DMA remapping is active. Clearing this bit has no effect. The value
                 * returned on read of this field is undefined.
                 */
                UINT32 SetFaultLog : 1;
#define VTD_GLOBAL_COMMAND_SET_FAULT_LOG_BIT  29
#define VTD_GLOBAL_COMMAND_SET_FAULT_LOG_FLAG 0x20000000
#define VTD_GLOBAL_COMMAND_SET_FAULT_LOG_MASK 0x01
#define VTD_GLOBAL_COMMAND_SET_FAULT_LOG(_)   (((_) >> 29) & 0x01)

                /**
                 * @brief Set Root Table Pointer <b>(WO)</b>
                 *
                 * [Bit 30] Software sets this field to set/update the root-table pointer (and
                 * translation table mode) used by hardware. The root-table pointer (and translation
                 * table mode) is specified through the Root Table Address (RTADDR_REG) register.
                 * Hardware reports the status of the 'Set Root Table Pointer' operation through the
                 * RTPS field in the Global Status register. The 'Set Root Table Pointer' operation
                 * must be performed before enabling or re-enabling (after disabling) DMA remapping
                 * through the TE field. For details on invalidation that software may have to
                 * perform after the Clearing this bit has no effect. The value returned on a read
                 * of this field is undefined.
                 */
                UINT32 SetRootTablePointer : 1;
#define VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_BIT  30
#define VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_FLAG 0x40000000
#define VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_MASK 0x01
#define VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER(_)   (((_) >> 30) & 0x01)

                /**
                 * @brief Translation Enable <b>(WO)</b>
                 *
                 * [Bit 31] Software writes to this field to request hardware to enable/disable DMA
                 * remapping:
                 * * 0: Disable DMA remapping
                 * * 1: Enable DMA remapping
                 * Hardware reports the status of the translation enable operation through the TES
                 * field in the Global Status register. There may be active DMA requests in the
                 * platform when software updates this field. Hardware must enable or disable
                 * remapping logic only at deterministic transaction boundaries, so that any
                 * in-flight transaction is either subject to remapping or not at all. Hardware
                 * implementations supporting DMA draining must drain any inflight DMA read/write
                 * requests queued within the Root-Complex before completing the translation enable
                 * command and reflecting the status of the command through the TES field in the
                 * Global Status register. For implementations reporting Scalable Mode Translation
                 * Support (SMTS) field as Set, hardware performs global invalidation on all DMA
                 * remapping translation caches as part of Translation Disable operation. The value
                 * returned on a read of this field is undefined.
                 */
                UINT32 TranslationEnable : 1;
#define VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_BIT  31
#define VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_FLAG 0x80000000
#define VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_MASK 0x01
#define VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE(_)   (((_) >> 31) & 0x01)
        };

        UINT32 AsUInt;
} VTD_GLOBAL_COMMAND_REGISTER;

/**
 * Register to report general remapping hardware status.
 *
 * @remarks GSTS_REG
 * @see VTd[10.4.5(Global Status Register)]
 */
#define VTD_GLOBAL_STATUS 0x0000001C
typedef union
{
        struct
        {
                UINT32 Reserved1 : 23;

                /**
                 * @brief Compatibility Format Interrupt Status <b>(RO)</b>
                 *
                 * [Bit 23] This field indicates the status of Compatibility format interrupts on
                 * Intel(R) 64 implementations supporting interrupt-remapping. The value reported in
                 * this field is applicable only when interrupt-remapping is enabled and extended
                 * interrupt mode (x2APIC mode) is not enabled.
                 * * 0: Compatibility format interrupts are blocked.
                 * * 1: Compatibility format interrupts are processed as pass-through (bypassing
                 * interrupt remapping).
                 */
                UINT32 CompatibilityFormatInterruptStatus : 1;
#define VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS_BIT  23
#define VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS_FLAG 0x800000
#define VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_COMPATIBILITY_FORMAT_INTERRUPT_STATUS(_)   (((_) >> 23) & 0x01)

                /**
                 * @brief Interrupt Remapping Table Pointer Status <b>(RO)</b>
                 *
                 * [Bit 24] This field indicates the status of the interrupt remapping table pointer
                 * in hardware. This field is cleared by hardware when software sets the SIRTP field
                 * in the Global Command register. This field is Set by hardware when hardware
                 * completes the 'Set Interrupt Remap Table Pointer' operation using the value
                 * provided in the Interrupt Remapping Table Address register.
                 */
                UINT32 InterruptRemappingTablePointerStatus : 1;
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS_BIT  24
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS_FLAG 0x1000000
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_TABLE_POINTER_STATUS(_)   (((_) >> 24) & 0x01)

                /**
                 * @brief Interrupt Remapping Enable Status <b>(RO)</b>
                 *
                 * [Bit 25] This field indicates the status of Interrupt-remapping hardware.
                 * * 0: Interrupt-remapping hardware is not enabled
                 * * 1: Interrupt-remapping hardware is enabled
                 */
                UINT32 InterruptRemappingEnableStatus : 1;
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS_BIT  25
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS_FLAG 0x2000000
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_INTERRUPT_REMAPPING_ENABLE_STATUS(_)   (((_) >> 25) & 0x01)

                /**
                 * @brief Queued Invalidation Enable Status <b>(RO)</b>
                 *
                 * [Bit 26] This field indicates queued invalidation enable status.
                 * * 0: queued invalidation is not enabled
                 * * 1: queued invalidation is enabled
                 */
                UINT32 QueuedInvalidationEnableStatus : 1;
#define VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS_BIT  26
#define VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS_FLAG 0x4000000
#define VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_QUEUED_INVALIDATION_ENABLE_STATUS(_)   (((_) >> 26) & 0x01)

                /**
                 * @brief Write Buffer Flush Status <b>(RO)</b>
                 *
                 * [Bit 27] This field is valid only for implementations requiring write buffer
                 * flushing. This field indicates the status of the write buffer flush command. It
                 * is
                 * * Set by hardware when software sets the WBF field in the Global Command
                 * register.
                 * * Cleared by hardware when hardware completes the write buffer flushing
                 * operation.
                 */
                UINT32 WriteBufferFlushStatus : 1;
#define VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS_BIT  27
#define VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS_FLAG 0x8000000
#define VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_WRITE_BUFFER_FLUSH_STATUS(_)   (((_) >> 27) & 0x01)

                /**
                 * @brief Advanced Fault Logging Status <b>(RO)</b>
                 *
                 * [Bit 28] This field is valid only for implementations supporting advanced fault
                 * logging. It indicates the advanced fault logging status:
                 * * 0: Advanced Fault Logging is not enabled
                 * * 1: Advanced Fault Logging is enabled
                 */
                UINT32 AdvancedFaultLoggingStatus : 1;
#define VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS_BIT  28
#define VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS_FLAG 0x10000000
#define VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_ADVANCED_FAULT_LOGGING_STATUS(_)   (((_) >> 28) & 0x01)

                /**
                 * @brief Fault Log Status <b>(RO)</b>
                 *
                 * [Bit 29] This field:
                 * * Is cleared by hardware when software Sets the SFL field in the Global Command
                 * register.
                 * * Is Set by hardware when hardware completes the 'Set Fault Log Pointer'
                 * operation using the value provided in the Advanced Fault Log register.
                 */
                UINT32 FaultLogStatus : 1;
#define VTD_GLOBAL_STATUS_FAULT_LOG_STATUS_BIT  29
#define VTD_GLOBAL_STATUS_FAULT_LOG_STATUS_FLAG 0x20000000
#define VTD_GLOBAL_STATUS_FAULT_LOG_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_FAULT_LOG_STATUS(_)   (((_) >> 29) & 0x01)

                /**
                 * @brief Root Table Pointer Status <b>(RO)</b>
                 *
                 * [Bit 30] This field indicates the status of the root-table pointer in hardware.
                 * This field is cleared by hardware when software sets the SRTP field in the Global
                 * Command register. This field is set by hardware when hardware completes the 'Set
                 * Root Table Pointer' operation using the value provided in the Root Table Address
                 * register.
                 */
                UINT32 RootTablePointerStatus : 1;
#define VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_BIT  30
#define VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_FLAG 0x40000000
#define VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS(_)   (((_) >> 30) & 0x01)

                /**
                 * @brief Translation Enable Status <b>(RO)</b>
                 *
                 * [Bit 31] This field indicates the status of DMA-remapping hardware.
                 * * 0: DMA remapping is not enabled
                 * * 1: DMA remapping is enabled
                 */
                UINT32 TranslationEnableStatus : 1;
#define VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_BIT  31
#define VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_FLAG 0x80000000
#define VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_MASK 0x01
#define VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS(_)   (((_) >> 31) & 0x01)
        };

        UINT32 AsUInt;
} VTD_GLOBAL_STATUS_REGISTER;

/**
 * Register providing the base address of root-table and the translation table mode. Software
 * programs the desired values in this register but these values take effect only after software
 * executes Set Root Table Pointer command through the SRTP field in the Global Command Register
 * (GCMD_REG).
 *
 * @remarks RTADDR_REG
 * @see VTd[10.4.6(Root Table Address Register)]
 */
#define VTD_ROOT_TABLE_ADDRESS 0x00000020
typedef union
{
        struct
        {
                UINT64 Reserved1 : 10;

                /**
                 * @brief Translation Table Mode <b>(RW)</b>
                 *
                 * [Bits 11:10] This field specifies the translation mode used for DMA remapping.
                 * * 00: legacy mode - uses root tables and context tables.
                 * * 01: scalable mode - uses scalable-mode root tables and scalable mode context
                 * tables.
                 * * 10: reserved - in prior version of this specification, this encoding was used
                 * to enable extended mode which is no longer supported.
                 * * 11: abort-dma mode.
                 * For implementations reporting Enhanced SRTP Support (ESRTPS) field as Clear in
                 * the Capability register, software must not modify this field while DMA remapping
                 * is active (TES=1 in Global Status register). The value of this field takes effect
                 * only after software executes Set Root Table Pointer command.
                 */
                UINT64 TranslationTableMode : 2;
#define VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE_BIT  10
#define VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE_FLAG 0xC00
#define VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE_MASK 0x03
#define VTD_ROOT_TABLE_ADDRESS_TRANSLATION_TABLE_MODE(_)   (((_) >> 10) & 0x03)

                /**
                 * @brief Root Table Address <b>(RW)</b>
                 *
                 * [Bits 63:12] This field points to the base of the page-aligned, 4KB-sized
                 * root-table in system memory. Hardware may ignore and not implement bits 63:HAW,
                 * where HAW is the host address width. The value of this field takes effect only
                 * after software executes Set Root Table Pointer command.
                 */
                UINT64 RootTableAddress : 52;
#define VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS_BIT  12
#define VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS_FLAG 0xFFFFFFFFFFFFF000
#define VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS_MASK 0xFFFFFFFFFFFFF
#define VTD_ROOT_TABLE_ADDRESS_ROOT_TABLE_ADDRESS(_)   (((_) >> 12) & 0xFFFFFFFFFFFFF)
        };

        UINT64 AsUInt;
} VTD_ROOT_TABLE_ADDRESS_REGISTER;

/**
 * Register to manage context-cache.The act of writing the uppermost byte of the CCMD_REG with the
 * ICC field Set causes the hardware to perform the context-cache invalidation.
 *
 * @remarks CCMD_RE
 * @see VTd[10.4.7(Context Command Register)]
 */
#define VTD_CONTEXT_COMMAND 0x00000028
typedef union
{
        struct
        {
                /**
                 * @brief Domain-ID <b>(RW)</b>
                 *
                 * [Bits 15:0] Indicates the id of the domain whose context-entries need to be
                 * selectively invalidated. This field must be programmed by software for both
                 * domain selective and device-selective invalidation requests. The Capability
                 * register reports the domain-id width supported by hardware. Software must ensure
                 * that the value written to this field is within this limit. Hardware ignores (and
                 * may not implement) bits 15:N, where N is the supported domain-id width reported
                 * in the Capability register.
                 */
                UINT64 DomainId : 16;
#define VTD_CONTEXT_COMMAND_DOMAIN_ID_BIT  0
#define VTD_CONTEXT_COMMAND_DOMAIN_ID_FLAG 0xFFFF
#define VTD_CONTEXT_COMMAND_DOMAIN_ID_MASK 0xFFFF
#define VTD_CONTEXT_COMMAND_DOMAIN_ID(_)   (((_) >> 0) & 0xFFFF)

                /**
                 * @brief Source-ID <b>(WO)</b>
                 *
                 * [Bits 31:16] Indicates the source-id of the device whose corresponding
                 * context-entry needs to be selectively invalidated.This field along with the FM
                 * field must be programmed by software for device-selective invalidation requests.
                 * The value returned on a read of this field is undefined.
                 */
                UINT64 SourceId : 16;
#define VTD_CONTEXT_COMMAND_SOURCE_ID_BIT  16
#define VTD_CONTEXT_COMMAND_SOURCE_ID_FLAG 0xFFFF0000
#define VTD_CONTEXT_COMMAND_SOURCE_ID_MASK 0xFFFF
#define VTD_CONTEXT_COMMAND_SOURCE_ID(_)   (((_) >> 16) & 0xFFFF)

                /**
                 * @brief Function Mask <b>(WO)</b>
                 *
                 * [Bits 33:32] Software may use the Function Mask to perform device-selective
                 * invalidations on behalf of devices supporting PCI Express Phantom Functions. This
                 * field specifies which bits of the function number portion (least significant
                 * three bits) of the SID field to mask when performing device selective
                 * invalidations.The following encodings are defined for this field:
                 * * 00: No bits in the SID field masked
                 * * 01: Mask bit 2 in the SID field
                 * * 10: Mask bits 2:1 in the SID field
                 * * 11: Mask bits 2:0 in the SID field
                 * The context-entries corresponding to the source-ids specified through the SID and
                 * FM fields must have the domain-id specified in the DID field. The value returned
                 * on a read of this field is undefined.
                 */
                UINT64 FunctionMask : 2;
#define VTD_CONTEXT_COMMAND_FUNCTION_MASK_BIT  32
#define VTD_CONTEXT_COMMAND_FUNCTION_MASK_FLAG 0x300000000
#define VTD_CONTEXT_COMMAND_FUNCTION_MASK_MASK 0x03
#define VTD_CONTEXT_COMMAND_FUNCTION_MASK(_)   (((_) >> 32) & 0x03)
                UINT64 Reserved1 : 25;

                /**
                 * @brief Context Actual Invalidation Granularity <b>(RO)</b>
                 *
                 * [Bits 60:59] Hardware reports the granularity at which an invalidation request
                 * was processed through the CAIG field at the time of reporting invalidation
                 * completion (by clearing the ICC field). The following are the encodings for this
                 * field:
                 * * 00: Error. This indicates hardware detected an incorrect invalidation request
                 * and ignored the request, e.g., register based invalidation when Translation Table
                 * Mode (TTM) in Root Table Address Register is not programmed to legacy mode
                 * (RTADDR_REG.TTM!=00b).
                 * On hardware implementations with Major Version 6 or higher (VER_REG), all
                 * invalidation requests through this register are treated as incorrect invalidation
                 * requests. Software should use the Queued Invalidation interface to perform
                 * context-cache invalidations for such hardware implementations. Refer to
                 * Section 6.5 for more details.
                 * * 01: Global Invalidation performed. This could be in response to a global,
                 * domain-selective, or device-selective invalidation request.
                 * * 10: Domain-selective invalidation performed using the domain-id specified by
                 * software in the DID field. This could be in response to a domain-selective or
                 * device-selective invalidation request.
                 * * 11: Device-selective invalidation performed using the source-id and domain-id
                 * specified by software in the SID and FM fields. This can only be in response to a
                 * device-selective invalidation request.
                 */
                UINT64 ContextActualInvalidationGranularity : 2;
#define VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY_BIT  59
#define VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY_FLAG 0x1800000000000000
#define VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY_MASK 0x03
#define VTD_CONTEXT_COMMAND_CONTEXT_ACTUAL_INVALIDATION_GRANULARITY(_)   (((_) >> 59) & 0x03)

                /**
                 * @brief Context Invalidation Request Granularity <b>(RW)</b>
                 *
                 * [Bits 62:61] Software provides the requested invalidation granularity through
                 * this field when setting the ICC field:
                 * * 00: Reserved.
                 * * 01: Global Invalidation request.
                 * * 10: Domain-selective invalidation request. The target domain-id must be
                 * specified in the DID field.
                 * * 11: Device-selective invalidation request. The target source-id(s) must be
                 * specified through the SID and FM fields, and the domain-id [that was programmed
                 * in the context-entry for these device(s)] must be provided in the DID field.
                 * Hardware implementations may process an invalidation request by performing
                 * invalidation at a coarser granularity than requested. Hardware indicates
                 * completion of the invalidation request by clearing the ICC field. At this time,
                 * hardware also indicates the granularity at which the actual invalidation was
                 * performed through the CAIG field.
                 */
                UINT64 ContextInvalidationRequestGranularity : 2;
#define VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY_BIT  61
#define VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY_FLAG 0x6000000000000000
#define VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY_MASK 0x03
#define VTD_CONTEXT_COMMAND_CONTEXT_INVALIDATION_REQUEST_GRANULARITY(_)   (((_) >> 61) & 0x03)

                /**
                 * @brief Invalidate Context-Cache <b>(RW)</b>
                 *
                 * [Bit 63] Software requests invalidation of context-cache by setting this field.
                 * Software must also set the requested invalidation granularity by programming the
                 * CIRG field. Software must read back and check the ICC field is Clear to confirm
                 * the invalidation is complete. Software must not update this register when this
                 * field is Set. Hardware clears the ICC field to indicate the invalidation request
                 * is complete.Hardware also indicates the granularity at which the invalidation
                 * operation was performed through the CAIG field. Software must submit a
                 * context-cache invalidation request through this field only when there are no
                 * invalidation requests pending at this remapping hardware unit. Since information
                 * from the context-cache may be used by hardware to tag IOTLB entries, software
                 * must perform domain-selective (or global) invalidation of IOTLB after the
                 * context-cache invalidation has completed. Hardware implementations reporting a
                 * write-buffer flushing requirement (RWBF=1 in the Capability register) must
                 * implicitly perform a write buffer flush before invalidating the context-cache.
                 * When Translation Table Mode field in Root Table Address register is not setup as
                 * legacy mode (RTADDR_REG.TTM!=00b), hardware will ignore the value provided by
                 * software in this register, treat it as an incorrect invalidation request, and
                 * report a value of 00b in CAIG field.
                 */
                UINT64 InvalidateContextCache : 1;
#define VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE_BIT  63
#define VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE_FLAG 0x8000000000000000
#define VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE_MASK 0x01
#define VTD_CONTEXT_COMMAND_INVALIDATE_CONTEXT_CACHE(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} VTD_CONTEXT_COMMAND_REGISTER;

/**
 * Register to provide the DMA address whose corresponding IOTLB entry needs to be invalidated
 * through the corresponding IOTLB Invalidate register. This register is a write-only register. A
 * value returned on a read of this register is undefined.
 *
 * @remarks IVA_REG
 * @see VTd[10.4.8.2(Invalidate Address Register)]
 */
#define VTD_INVALIDATE_ADDRESS 0x00000000
typedef union
{
        struct
        {
                /**
                 * @brief Address Mask <b>(WO)</b>
                 *
                 * [Bits 5:0] The value in this field specifies the number of low order bits of the
                 * ADDR field that must be masked for the invalidation operation. This field enables
                 * software to request invalidation of contiguous mappings for size-aligned regions.
                 * When invalidating mappings for large-pages, software must specify the appropriate
                 * mask value. For example, when invalidating mapping for a 2MB page, software must
                 * specify an address mask value of at least 9. Hardware implementations report the
                 * maximum supported address mask value through the Capability register. A value
                 * returned on a read of this field is undefined.
                 */
                UINT64 AddressMask : 6;
#define VTD_INVALIDATE_ADDRESS_ADDRESS_MASK_BIT  0
#define VTD_INVALIDATE_ADDRESS_ADDRESS_MASK_FLAG 0x3F
#define VTD_INVALIDATE_ADDRESS_ADDRESS_MASK_MASK 0x3F
#define VTD_INVALIDATE_ADDRESS_ADDRESS_MASK(_)   (((_) >> 0) & 0x3F)

                /**
                 * @brief Invalidation Hint <b>(WO)</b>
                 *
                 * [Bit 6] The field provides hints to hardware about preserving or flushing the
                 * nonleaf (context-entry) entries that may be cached in hardware:
                 * * 0: Software may have modified both leaf and non-leaf second-level
                 * paging-structure entries corresponding to mappings specified in the ADDR and AM
                 * fields. On a page-selective-within-domain invalidation request, hardware must
                 * invalidate the cached entries associated with the mappings specified by DID, ADDR
                 * and AM fields, in both IOTLB and paging-structure caches.
                 * * 1: Software has not modified any second-level non-leaf paging entries
                 * associated with the mappings specified by the ADDR and AM fields. On a
                 * page-selective-within-domain invalidation request, hardware may preserve the
                 * cached second-level mappings in paging-structurecaches. A value returned on a
                 * read of this field is undefined.
                 */
                UINT64 InvalidationHint : 1;
#define VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT_BIT  6
#define VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT_FLAG 0x40
#define VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT_MASK 0x01
#define VTD_INVALIDATE_ADDRESS_INVALIDATION_HINT(_)   (((_) >> 6) & 0x01)
                UINT64 Reserved1 : 5;

                /**
                 * @brief Address <b>(WO)</b>
                 *
                 * [Bits 63:12] Software provides the second-level-input-address that needs to be
                 * page selectively invalidated. To make a page-selective-within-domain invalidation
                 * request to hardware, software must first write the appropriate fields in this
                 * register, and then issue the page-selective-within-domain invalidate command
                 * through the IOTLB_REG. Hardware ignores bits 63:N, where N is the maximum guest
                 * address width (MGAW) supported. A value returned on a read of this field is
                 * undefined.
                 */
                UINT64 PageAddress : 52;
#define VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS_BIT  12
#define VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS_FLAG 0xFFFFFFFFFFFFF000
#define VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS_MASK 0xFFFFFFFFFFFFF
#define VTD_INVALIDATE_ADDRESS_PAGE_ADDRESS(_)   (((_) >> 12) & 0xFFFFFFFFFFFFF)
        };

        UINT64 AsUInt;
} VTD_INVALIDATE_ADDRESS_REGISTER;

/**
 * Register to invalidate IOTLB. The act of writing the upper byte of the IOTLB_REG with the IVT
 * field Set causes the hardware to perform the IOTLB invalidation.
 *
 * @remarks IOTLB_REG
 * @see VTd[10.4.8.1(IOTLB Invalidate Register)]
 */
#define VTD_IOTLB_INVALIDATE 0x00000008
typedef union
{
        struct
        {
                UINT64 Reserved1 : 32;

                /**
                 * @brief Domain-ID <b>(RW)</b>
                 *
                 * [Bits 47:32] Indicates the ID of the domain whose IOTLB entries need to be
                 * selectively invalidated. This field must be programmed by software for
                 * domainselective and page-selective invalidation requests. The Capability register
                 * reports the domain-id width supported by hardware. Software must ensure that the
                 * value written to this field is within this limit. Hardware may ignore and not
                 * implement bits 47:(32+N), where N is the supported domain-id width reported in
                 * the Capability register.
                 */
                UINT64 DomainId : 16;
#define VTD_IOTLB_INVALIDATE_DOMAIN_ID_BIT  32
#define VTD_IOTLB_INVALIDATE_DOMAIN_ID_FLAG 0xFFFF00000000
#define VTD_IOTLB_INVALIDATE_DOMAIN_ID_MASK 0xFFFF
#define VTD_IOTLB_INVALIDATE_DOMAIN_ID(_)   (((_) >> 32) & 0xFFFF)

                /**
                 * @brief Drain Writes <b>(RW)</b>
                 *
                 * [Bit 48] This field is ignored by hardware if the DWD field is reported as Clear
                 * in the Capability register. When the DWD field is reported as Set in the
                 * Capability register, the following encodings are supported for this field:
                 * * 0: Hardware may complete the IOTLB invalidation without draining DMA write
                 * requests.
                 * * 1: Hardware must drain relevant translated DMA write requests.
                 */
                UINT64 DrainWrites : 1;
#define VTD_IOTLB_INVALIDATE_DRAIN_WRITES_BIT  48
#define VTD_IOTLB_INVALIDATE_DRAIN_WRITES_FLAG 0x1000000000000
#define VTD_IOTLB_INVALIDATE_DRAIN_WRITES_MASK 0x01
#define VTD_IOTLB_INVALIDATE_DRAIN_WRITES(_)   (((_) >> 48) & 0x01)

                /**
                 * @brief Drain Reads <b>(RW)</b>
                 *
                 * [Bit 49] This field is ignored by hardware if the DRD field is reported as Clear
                 * in the Capability register. When the DRD field is reported as Set in the
                 * Capability register, the following encodings are supported for this field:
                 * * 0: Hardware may complete the IOTLB invalidation without draining DMA read
                 * requests.
                 * * 1: Hardware must drain DMA read requests.
                 */
                UINT64 DrainReads : 1;
#define VTD_IOTLB_INVALIDATE_DRAIN_READS_BIT  49
#define VTD_IOTLB_INVALIDATE_DRAIN_READS_FLAG 0x2000000000000
#define VTD_IOTLB_INVALIDATE_DRAIN_READS_MASK 0x01
#define VTD_IOTLB_INVALIDATE_DRAIN_READS(_)   (((_) >> 49) & 0x01)
                UINT64 Reserved2 : 7;

                /**
                 * @brief IOTLB Actual Invalidation Granularity <b>(RO)</b>
                 *
                 * [Bits 58:57] Hardware reports the granularity at which an invalidation request
                 * was processed through this field when reporting invalidation completion (by
                 * clearing the IVT field). The following are the encodings for this field.
                 * * 00: Error. This indicates hardware detected an incorrect invalidation request
                 * and ignored the request, e.g., register based invalidation when Translation Table
                 * Mode (TTM) in Root Table Address Register is not programmed to legacy mode
                 * (RTADDR_REG.TTM!=00b), detected an unsupported address mask value in Invalidate
                 * Address register for page-selective invalidation requests. On hardware
                 * implementations with Major Version 6 or higher (VER_REG), all invalidation
                 * requests through this register are treated as incorrect invalidation requests.
                 * Software should use the Queued Invalidation interface to perform IOTLB
                 * invalidations for such hardware implementations. Refer to Section 6.5 for more
                 * details.
                 * * 01: Global Invalidation performed. This could be in response to a global,
                 * domain-selective, or page-selective invalidation request.
                 * * 10: Domain-selective invalidation performed using the domain-id specified by
                 * software in the DID field. This could be in response to a domain-selective or a
                 * page-selective invalidation request.
                 * * 11: Page-selective-within-domain invalidation performed using the address, mask
                 * and hint specified by software in the Invalidate Address register and domain-id
                 * specified in DID field. This can be in response to a page-selective-within-domain
                 * invalidation request.
                 */
                UINT64 IotlbActualInvalidationGranularity : 2;
#define VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY_BIT  57
#define VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY_FLAG 0x600000000000000
#define VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY_MASK 0x03
#define VTD_IOTLB_INVALIDATE_IOTLB_ACTUAL_INVALIDATION_GRANULARITY(_)   (((_) >> 57) & 0x03)
                UINT64 Reserved3 : 1;

                /**
                 * @brief IOTLB Invalidation Request Granularity <b>(RW)</b>
                 *
                 * [Bits 61:60] When requesting hardware to invalidate the IOTLB (by setting the IVT
                 * field), software writes the requested invalidation granularity through this
                 * field. The following are the encodings for the field.
                 * * 00: Reserved.
                 * * 01: Global invalidation request.
                 * * 10: Domain-selective invalidation request. The target domain-id must be
                 * specified in the DID field.
                 * * 11: Page-selective-within-domain invalidation request. The target address,
                 * mask, and invalidation hint must be specified in the Invalidate Address register,
                 * and the domain-id must be provided in the DID field. Hardware implementations may
                 * process an invalidation request by performing invalidation at a coarser
                 * granularity than requested. Hardware indicates completion of the invalidation
                 * request by clearing the IVT field. At that time, the granularity at which actual
                 * invalidation was performed is reported through the IAIG field.
                 */
                UINT64 IotlbInvalidationRequestGranularity : 2;
#define VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY_BIT  60
#define VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY_FLAG 0x3000000000000000
#define VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY_MASK 0x03
#define VTD_IOTLB_INVALIDATE_IOTLB_INVALIDATION_REQUEST_GRANULARITY(_)   (((_) >> 60) & 0x03)
                UINT64 Reserved4 : 1;

                /**
                 * @brief Invalidate IOTLB <b>(RW)</b>
                 *
                 * [Bit 63] Software requests IOTLB invalidation by setting this field. Software
                 * must also set the requested invalidation granularity by programming the IIRG
                 * field. Hardware clears the IVT field to indicate the invalidation request is
                 * complete. Hardware also indicates the granularity at which the invalidation
                 * operation was performed through the IAIG field. Software must not submit another
                 * invalidation request through this register while the IVT field is Set, nor update
                 * the associated Invalidate Address register. Software must not submit IOTLB
                 * invalidation requests when there is a context-cache invalidation request pending
                 * at this remapping hardware unit. Hardware implementations reporting a
                 * write-buffer flushing requirement (RWBF=1 in Capability register) must implicitly
                 * perform a write buffer flushing before invalidating the IOTLB. Refer to
                 * Section 6.8 for write buffer flushing requirements. When Translation Table Mode
                 * field in Root Table Address registers is not setup as legacy mode
                 * (RTADDR_REG.TTM!=00b), hardware will ignore the value provided by software in
                 * this register, treat it as an incorrect invalidation request, and report a value
                 * of 00b in IAIG field.
                 */
                UINT64 InvalidateIotlb : 1;
#define VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB_BIT  63
#define VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB_FLAG 0x8000000000000000
#define VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB_MASK 0x01
#define VTD_IOTLB_INVALIDATE_INVALIDATE_IOTLB(_)   (((_) >> 63) & 0x01)
        };

        UINT64 AsUInt;
} VTD_IOTLB_INVALIDATE_REGISTER;

/**
 * @}
 */

typedef union
{
        struct
        {
                /**
                 * [Bit 0] This bit 0 must be 1. An attempt to write 0 to this bit causes a
                 * general-protection exception.
                 */
                UINT64 X87 : 1;
#define XCR0_X87_BIT  0
#define XCR0_X87_FLAG 0x01
#define XCR0_X87_MASK 0x01
#define XCR0_X87(_)   (((_) >> 0) & 0x01)

                /**
                 * [Bit 1] If 1, the XSAVE feature set can be used to manage MXCSR and the XMM
                 * registers (XMM0-XMM15 in 64-bit mode; otherwise XMM0-XMM7).
                 */
                UINT64 Sse : 1;
#define XCR0_SSE_BIT  1
#define XCR0_SSE_FLAG 0x02
#define XCR0_SSE_MASK 0x01
#define XCR0_SSE(_)   (((_) >> 1) & 0x01)

                /**
                 * [Bit 2] If 1, AVX instructions can be executed and the XSAVE feature set can be
                 * used to manage the upper halves of the YMM registers (YMM0-YMM15 in 64-bit mode;
                 * otherwise YMM0-YMM7).
                 */
                UINT64 Avx : 1;
#define XCR0_AVX_BIT  2
#define XCR0_AVX_FLAG 0x04
#define XCR0_AVX_MASK 0x01
#define XCR0_AVX(_)   (((_) >> 2) & 0x01)

                /**
                 * [Bit 3] If 1, MPX instructions can be executed and the XSAVE feature set can be
                 * used to manage the bounds registers BND0-BND3.
                 */
                UINT64 Bndreg : 1;
#define XCR0_BNDREG_BIT  3
#define XCR0_BNDREG_FLAG 0x08
#define XCR0_BNDREG_MASK 0x01
#define XCR0_BNDREG(_)   (((_) >> 3) & 0x01)

                /**
                 * [Bit 4] If 1, MPX instructions can be executed and the XSAVE feature set can be
                 * used to manage the BNDCFGU and BNDSTATUS registers.
                 */
                UINT64 Bndcsr : 1;
#define XCR0_BNDCSR_BIT  4
#define XCR0_BNDCSR_FLAG 0x10
#define XCR0_BNDCSR_MASK 0x01
#define XCR0_BNDCSR(_)   (((_) >> 4) & 0x01)

                /**
                 * [Bit 5] If 1, AVX-512 instructions can be executed and the XSAVE feature set can
                 * be used to manage the opmask registers k0-k7.
                 */
                UINT64 Opmask : 1;
#define XCR0_OPMASK_BIT  5
#define XCR0_OPMASK_FLAG 0x20
#define XCR0_OPMASK_MASK 0x01
#define XCR0_OPMASK(_)   (((_) >> 5) & 0x01)

                /**
                 * [Bit 6] If 1, AVX-512 instructions can be executed and the XSAVE feature set can
                 * be used to manage the upper halves of the lower ZMM registers (ZMM0-ZMM15 in
                 * 64-bit mode; otherwise ZMM0-ZMM7).
                 */
                UINT64 ZmmHi256 : 1;
#define XCR0_ZMM_HI256_BIT  6
#define XCR0_ZMM_HI256_FLAG 0x40
#define XCR0_ZMM_HI256_MASK 0x01
#define XCR0_ZMM_HI256(_)   (((_) >> 6) & 0x01)

                /**
                 * [Bit 7] If 1, AVX-512 instructions can be executed and the XSAVE feature set can
                 * be used to manage the upper ZMM registers (ZMM16-ZMM31, oonly in 64-bit mode).
                 */
                UINT64 ZmmHi16 : 1;
#define XCR0_ZMM_HI16_BIT  7
#define XCR0_ZMM_HI16_FLAG 0x80
#define XCR0_ZMM_HI16_MASK 0x01
#define XCR0_ZMM_HI16(_)   (((_) >> 7) & 0x01)
                UINT64 Reserved1 : 1;

                /**
                 * [Bit 9] If 1, the XSAVE feature set can be used to manage the PKRU register.
                 */
                UINT64 Pkru : 1;
#define XCR0_PKRU_BIT  9
#define XCR0_PKRU_FLAG 0x200
#define XCR0_PKRU_MASK 0x01
#define XCR0_PKRU(_)   (((_) >> 9) & 0x01)
                UINT64 Reserved2 : 54;
        };

        UINT64 AsUInt;
} XCR0;

/**
 * @}
 */

#if defined(_MSC_EXTENSIONS)
#        pragma warning(pop)
#endif

```

`driver/imports.c`:

```c
#include "imports.h"

#include "common.h"
#include "driver.h"
#include "crypt.h"
#include <stdarg.h>

PVOID
FindDriverBaseNoApi(_In_ PDRIVER_OBJECT DriverObject, _In_ PWCH Name)
{
    PKLDR_DATA_TABLE_ENTRY first =
        (PKLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;

    /* first entry contains invalid data, 2nd entry is the kernel */
    PKLDR_DATA_TABLE_ENTRY entry =
        ((PKLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection)
            ->InLoadOrderLinks.Flink->Flink;

    while (entry->InLoadOrderLinks.Flink != first) {
        /* todo: write our own unicode string comparison function, since
         * the entire point of this is to find exports with no exports.
         */
        if (!wcscmp(entry->BaseDllName.Buffer, Name)) {
            return entry->DllBase;
        }

        entry = entry->InLoadOrderLinks.Flink;
    }

    return NULL;
}

PVOID
ImpResolveNtImport(PDRIVER_OBJECT DriverObject, PCZPSTR ExportName)
{
    PVOID                    image_base           = NULL;
    PIMAGE_DOS_HEADER        dos_header           = NULL;
    PLOCAL_NT_HEADER         nt_header            = NULL;
    PIMAGE_OPTIONAL_HEADER64 optional_header      = NULL;
    PIMAGE_DATA_DIRECTORY    data_dir             = NULL;
    PIMAGE_EXPORT_DIRECTORY  export_dir           = NULL;
    PUINT32                  export_name_table    = NULL;
    PCHAR                    name                 = NULL;
    PUINT16                  ordinals_table       = NULL;
    PUINT32                  export_addr_table    = NULL;
    UINT32                   ordinal              = 0;
    PVOID                    target_function_addr = 0;
    UINT32                   export_offset        = 0;

    image_base = FindDriverBaseNoApi(DriverObject, L"ntoskrnl.exe");

    if (!image_base) {
        DEBUG_ERROR("FindDriverBaseNoApi failed with no status");
        return NULL;
    }

    /*
     * todo: add comment explaining this shit also this ugly af
     */
    dos_header      = (PIMAGE_DOS_HEADER)image_base;
    nt_header       = (struct _IMAGE_NT_HEADERS64*)((UINT64)image_base +
                                              dos_header->e_lfanew);
    optional_header = (PIMAGE_OPTIONAL_HEADER64)&nt_header->OptionalHeader;

    data_dir = (PIMAGE_DATA_DIRECTORY) &
               (optional_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
    export_dir = (PIMAGE_EXPORT_DIRECTORY)((UINT64)image_base +
                                           data_dir->VirtualAddress);

    export_name_table =
        (PUINT32)((UINT64)image_base + export_dir->AddressOfNames);
    ordinals_table =
        (PUINT16)((UINT64)image_base + export_dir->AddressOfNameOrdinals);
    export_addr_table =
        (PUINT32)((UINT64)image_base + export_dir->AddressOfFunctions);

    for (INT index = 0; index < export_dir->NumberOfNames; index++) {
        name = (PCHAR)((UINT64)image_base + export_name_table[index]);

        if (strcmp(name, ExportName))
            continue;

        ordinal              = ordinals_table[index];
        export_offset        = export_addr_table[ordinal];
        target_function_addr = (PVOID)((UINT64)image_base + export_offset);
        return target_function_addr;
    }

    return NULL;
}

/*
 * The strings in this array need to be hashed at compile time, then we can use
 * the same hash function to compare when we walk the export table.
 */
#define NT_IMPORT_MAX_LENGTH 128
#define NT_IMPORT_COUNT      79

CHAR NT_IMPORTS[NT_IMPORT_COUNT][NT_IMPORT_MAX_LENGTH] = {
    "ObDereferenceObject",
    "PsLookupThreadByThreadId",
    "MmIsAddressValid",
    "PsSetCreateProcessNotifyRoutine",
    "PsRemoveCreateThreadNotifyRoutine",
    "PsGetCurrentThreadId",
    "PsGetProcessId",
    "PsLookupProcessByProcessId",
    "ExEnumHandleTable",
    "ObGetObjectType",
    "ExfUnblockPushLock",
    "PsGetProcessImageFileName",
    "strstr",
    "RtlInitUnicodeString",
    "RtlQueryRegistryValues",
    "MmGetSystemRoutineAddress",
    "RtlUnicodeStringToAnsiString",
    "RtlCopyUnicodeString",
    "RtlFreeAnsiString",
    "KeInitializeGuardedMutex",
    "IoCreateDevice",
    "IoCreateSymbolicLink",
    "IoDeleteDevice",
    "IoDeleteSymbolicLink",
    "ObRegisterCallbacks",
    "ObUnRegisterCallbacks",
    "PsSetCreateThreadNotifyRoutine",
    "KeRevertToUserAffinityThreadEx",
    "KeSetSystemAffinityThreadEx",
    "strnlen",
    "RtlInitAnsiString",
    "RtlAnsiStringToUnicodeString",
    "IoGetCurrentProcess",
    "RtlGetVersion",
    "RtlCompareMemory",
    "ExGetSystemFirmwareTable",
    "IoAllocateWorkItem",
    "IoFreeWorkItem",
    "IoQueueWorkItem",
    "ZwOpenFile",
    "ZwClose",
    "ZwCreateSection",
    "ZwMapViewOfSection",
    "ZwUnmapViewOfSection",
    "MmCopyMemory",
    "ZwDeviceIoControlFile",
    "KeStackAttachProcess",
    "KeUnstackDetachProcess",
    "KeWaitForSingleObject",
    "PsCreateSystemThread",
    "IofCompleteRequest",
    "ObReferenceObjectByHandle",
    "KeDelayExecutionThread",
    "KeRegisterNmiCallback",
    "KeDeregisterNmiCallback",
    "KeQueryActiveProcessorCount",
    "ExAcquirePushLockExclusiveEx",
    "ExReleasePushLockExclusiveEx",
    "PsGetThreadId",
    "RtlCaptureStackBackTrace",
    "ZwOpenDirectoryObject",
    "KeInitializeAffinityEx",
    "KeAddProcessorAffinityEx",
    "RtlQueryModuleInformation",
    "KeInitializeApc",
    "KeInsertQueueApc",
    "KeGenericCallDpc",
    "KeSignalCallDpcDone",
    "MmGetPhysicalMemoryRangesEx2",
    "MmGetVirtualForPhysical",
    "ObfReferenceObject",
    "ExFreePoolWithTag",
    "ExAllocatePool2",
    "KeReleaseGuardedMutex",
    "KeAcquireGuardedMutex",
    "DbgPrintEx",
    "RtlCompareUnicodeString",
    "RtlFreeUnicodeString",
    "PsGetProcessImageFileName"};

DRIVER_IMPORTS driver_imports = {0};

NTSTATUS
ImpResolveDynamicImports(_In_ PDRIVER_OBJECT DriverObject)
{
    PUINT64 imports_array = (PUINT64)&driver_imports;

    for (UINT32 index = 0; index < NT_IMPORT_COUNT; index++) {
        imports_array[index] =
            ImpResolveNtImport(DriverObject, NT_IMPORTS[index]);

        if (!imports_array[index])
            return STATUS_UNSUCCESSFUL;
    }

    CryptEncryptImportsArray(&driver_imports, IMPORTS_LENGTH);

    return STATUS_SUCCESS;
}

VOID
ImpObDereferenceObject(_In_ PVOID Object)
{
    pObDereferenceObject impObDereferenceObject =
        (pObDereferenceObject)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, OB_DEREFERENCE_OBJECT_INDEX);

    impObDereferenceObject(Object);
}

NTSTATUS
ImpPsLookupThreadByThreadId(_In_ HANDLE ThreadId, _Out_ PETHREAD* Thread)
{
    pPsLookupThreadByThreadId impPsLookupThreadByThreadId =
        (pPsLookupThreadByThreadId)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            PS_LOOKUP_THREAD_BY_THREAD_ID_INDEX);

    return impPsLookupThreadByThreadId(ThreadId, Thread);
}

BOOLEAN
ImpMmIsAddressValid(_In_ PVOID VirtualAddress)
{
    pMmIsAddressValid impMmIsAddressValid =
        (pMmIsAddressValid)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, MM_IS_ADDRESS_VALID_INDEX);

    return impMmIsAddressValid(VirtualAddress);
}

NTSTATUS
ImpPsSetCreateProcessNotifyRoutine(
    _In_ PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine, _In_ BOOLEAN Remove)
{
    pPsSetCreateProcessNotifyRoutine impPsSetCreateProcessNotifyRoutine =
        (pPsSetCreateProcessNotifyRoutine)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            PS_SET_CREATE_PROCESS_NOTIFY_ROUTINE_INDEX);

    return impPsSetCreateProcessNotifyRoutine(NotifyRoutine, Remove);
}

NTSTATUS
ImpPsRemoveCreateThreadNotifyRoutine(
    _In_ PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine)
{
    pPsRemoveCreateThreadNotifyRoutine impPsRemoveCreateThreadNotifyRoutine =
        (pPsRemoveCreateThreadNotifyRoutine)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            PS_REMOVE_CREATE_THREAD_NOTIFY_ROUTINE_INDEX);

    return impPsRemoveCreateThreadNotifyRoutine(NotifyRoutine);
}

HANDLE
ImpPsGetCurrentThreadId()
{
    pPsGetCurrentThreadId impPsGetCurrentThreadId =
        (pPsGetCurrentThreadId)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, PS_GET_CURRENT_THREAD_ID_INDEX);

    return impPsGetCurrentThreadId();
}

HANDLE
ImpPsGetProcessId(_In_ PEPROCESS Process)
{
    pPsGetProcessId impPsGetProcessId =
        (pPsGetProcessId)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, PS_GET_PROCESS_ID_INDEX);

    return impPsGetProcessId(Process);
}

NTSTATUS
ImpPsLookupProcessByProcessId(_In_ HANDLE ProcessId, _Out_ PEPROCESS* Process)
{
    pPsLookupProcessByProcessId impPsLookupProcessByProcessId =
        (pPsLookupProcessByProcessId)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            PS_LOOKUP_PROCESS_BY_PROCESS_ID_INDEX);

    return impPsLookupProcessByProcessId(ProcessId, Process);
}

PVOID
ImpExEnumHandleTable(_In_ PHANDLE_TABLE HandleTable,
                     _In_ PVOID         Callback,
                     _In_opt_ PVOID     Context,
                     _Out_opt_ PHANDLE  Handle)
{
    pExEnumHandleTable impExEnumHandleTable =
        (pExEnumHandleTable)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, EX_ENUM_HANDLE_TABLE_INDEX);

    return impExEnumHandleTable(HandleTable, Callback, Context, Handle);
}

POBJECT_TYPE
ImpObGetObjectType(_In_ PVOID Object)
{
    pObGetObjectType impObGetObjectType =
        (pObGetObjectType)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, OB_GET_OBJECT_TYPE_INDEX);

    return impObGetObjectType(Object);
}

VOID
ImpExfUnblockPushLock(_In_ PEX_PUSH_LOCK PushLock, _In_ PVOID WaitBlock)
{
    pExfUnblockPushLock impExfUnblockPushLock =
        (pExfUnblockPushLock)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, EXF_UNBLOCK_PUSH_LOCK_INDEX);

    impExfUnblockPushLock(PushLock, WaitBlock);
}

LPCSTR
ImpPsGetProcessImageFileName(_In_ PEPROCESS Process)
{
    pPsGetProcessImageFileName impPsGetProcessImageFileName =
        (pPsGetProcessImageFileName)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            PS_GET_PROCESS_IMAGE_FILE_NAME_INDEX);

    return impPsGetProcessImageFileName(Process);
}

INT
ImpStrStr(_In_ CHAR* haystack, _In_ CHAR* needle)
{
    pstrstr impStrStr = (pstrstr)CryptDecryptImportsArrayEntry(
        &driver_imports, IMPORTS_LENGTH, STRSTR_INDEX);

    return impStrStr(haystack, needle);
}

VOID
ImpRtlInitUnicodeString(_In_ PUNICODE_STRING DestinationString,
                        _In_ PCWSTR          SourceString)
{
    pRtlInitUnicodeString impRtlInitUnicodeString =
        (pRtlInitUnicodeString)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, RTL_INIT_UNICODE_STRING_INDEX);

    impRtlInitUnicodeString(DestinationString, SourceString);
}

NTSTATUS
ImpRtlQueryRegistryValues(_In_ ULONG                     RelativeTo,
                          _In_ PCWSTR                    Path,
                          _In_ PRTL_QUERY_REGISTRY_TABLE QueryTable,
                          _In_opt_ void*                 Context,
                          _In_ void*                     Environment)
{
    pRtlQueryRegistryValues impRtlQueryRegistryValues =
        (pRtlQueryRegistryValues)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, RTL_QUERY_REGISTRY_VALUES_INDEX);

    return impRtlQueryRegistryValues(
        RelativeTo, Path, QueryTable, Context, Environment);
}

PVOID
ImpMmGetSystemRoutineAddress(_In_ PUNICODE_STRING SystemRoutineName)
{
    pMmGetSystemRoutineAddress impMmGetSystemRoutineAddress =
        (pMmGetSystemRoutineAddress)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            MM_GET_SYSTEM_ROUTINE_ADDRESS_INDEX);

    return impMmGetSystemRoutineAddress(SystemRoutineName);
}

NTSTATUS
ImpRtlUnicodeStringToAnsiString(_In_ PANSI_STRING     DestinationString,
                                _In_ PCUNICODE_STRING SourceString,
                                _In_ BOOLEAN          AllocateDestinationString)
{
    pRtlUnicodeStringToAnsiString impRtlUnicodeStringToAnsiString =
        (pRtlUnicodeStringToAnsiString)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            RTL_UNICODE_STRING_TO_ANSI_STRING_INDEX);

    return impRtlUnicodeStringToAnsiString(
        DestinationString, SourceString, AllocateDestinationString);
}

VOID
ImpRtlCopyUnicodeString(_In_ PUNICODE_STRING  DestinationString,
                        _In_ PCUNICODE_STRING SourceString)
{
    pRtlCopyUnicodeString impRtlCopyUnicodeString =
        (pRtlCopyUnicodeString)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, RTL_COPY_UNICODE_STRING_INDEX);

    impRtlCopyUnicodeString(DestinationString, SourceString);
}

VOID
ImpRtlFreeAnsiString(_In_ PANSI_STRING AnsiString)
{
    pRtlFreeAnsiString impRtlFreeAnsiString =
        (pRtlFreeAnsiString)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, RTL_FREE_ANSI_STRING_INDEX);

    impRtlFreeAnsiString(AnsiString);
}

VOID
ImpKeInitializeGuardedMutex(_In_ PKGUARDED_MUTEX GuardedMutex)
{
    pKeInitializeGuardedMutex impKeInitializeGuardedMutex =
        (pKeInitializeGuardedMutex)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_INITIALIZE_GUARDED_MUTEX_INDEX);

    impKeInitializeGuardedMutex(GuardedMutex);
}

NTSTATUS
ImpIoCreateDevice(_In_ PDRIVER_OBJECT      DriverObject,
                  _In_ ULONG               DeviceExtensionSize,
                  _In_opt_ PUNICODE_STRING DeviceName,
                  _In_ DEVICE_TYPE         DeviceType,
                  _In_ ULONG               DeviceCharacteristics,
                  _In_ BOOLEAN             Exclusive,
                  _Out_ PDEVICE_OBJECT*    DeviceObject)
{
    pIoCreateDevice impIoCreateDevice =
        (pIoCreateDevice)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, IO_CREATE_DEVICE_INDEX);

    return impIoCreateDevice(DriverObject,
                             DeviceExtensionSize,
                             DeviceName,
                             DeviceType,
                             DeviceCharacteristics,
                             Exclusive,
                             DeviceObject);
}

NTSTATUS
ImpIoCreateSymbolicLink(_In_ PUNICODE_STRING SymbolicLinkName,
                        _In_ PUNICODE_STRING DeviceName)
{
    pIoCreateSymbolicLink impIoCreateSymbolicLink =
        (pIoCreateSymbolicLink)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, IO_CREATE_SYMBOLIC_LINK_INDEX);

    return impIoCreateSymbolicLink(SymbolicLinkName, DeviceName);
}

VOID
ImpIoDeleteDevice(_In_ PDEVICE_OBJECT DeviceObject)
{
    pIoDeleteDevice impIoDeleteDevice =
        (pIoDeleteDevice)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, IO_DELETE_DEVICE_INDEX);

    impIoDeleteDevice(DeviceObject);
}

VOID
ImpIoDeleteSymbolicLink(_In_ PUNICODE_STRING SymbolicLinkName)
{
    pIoDeleteSymbolicLink impIoDeleteSymbolicLink =
        (pIoDeleteSymbolicLink)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, IO_DELETE_SYMBOLIC_LINK_INDEX);

    impIoDeleteSymbolicLink(SymbolicLinkName);
}

NTSTATUS
ImpObRegisterCallbacks(_In_ POB_CALLBACK_REGISTRATION CallbackRegistration,
                       _Out_ PVOID*                   RegistrationHandle)
{
    pObRegisterCallbacks impObRegisterCallbacks =
        (pObRegisterCallbacks)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, OB_REGISTER_CALLBACKS_INDEX);

    return impObRegisterCallbacks(CallbackRegistration, RegistrationHandle);
}

VOID
ImpObUnRegisterCallbacks(_In_ PVOID RegistrationHandle)
{
    pObUnRegisterCallbacks impObUnRegisterCallbacks =
        (pObUnRegisterCallbacks)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, OB_UNREGISTER_CALLBACKS_INDEX);

    impObUnRegisterCallbacks(RegistrationHandle);
}

NTSTATUS
ImpPsSetCreateThreadNotifyRoutine(
    _In_ PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine)
{
    pPsSetCreateThreadNotifyRoutine impPsSetCreateThreadNotifyRoutine =
        (pPsSetCreateThreadNotifyRoutine)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            PS_SET_CREATE_THREAD_NOTIFY_ROUTINE_INDEX);

    return impPsSetCreateThreadNotifyRoutine(NotifyRoutine);
}

VOID
ImpKeRevertToUserAffinityThreadEx(_In_ KAFFINITY Affinity)
{
    pKeRevertToUserAffinityThreadEx impKeRevertToUserAffinityThreadEx =
        (pKeRevertToUserAffinityThreadEx)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            KE_REVERT_TO_USER_AFFINITY_THREAD_EX_INDEX);

    impKeRevertToUserAffinityThreadEx(Affinity);
}

KAFFINITY
ImpKeSetSystemAffinityThreadEx(_In_ KAFFINITY Affinity)
{
    pKeSetSystemAffinityThreadEx impKeSetSystemAffinityThreadEx =
        (pKeSetSystemAffinityThreadEx)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            KE_SET_SYSTEM_AFFINITY_THREAD_EX_INDEX);

    return impKeSetSystemAffinityThreadEx(Affinity);
}

SIZE_T
ImpStrnlen(_In_ CHAR* str, _In_ SIZE_T maxCount)
{
    pstrnlen impStrnlen = (pstrnlen)CryptDecryptImportsArrayEntry(
        &driver_imports, IMPORTS_LENGTH, STRNLEN_INDEX);

    return impStrnlen(str, maxCount);
}

VOID
ImpRtlInitAnsiString(_In_ PANSI_STRING DestinationString,
                     _In_ PCSZ         SourceString)
{
    pRtlInitAnsiString impRtlInitAnsiString =
        (pRtlInitAnsiString)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, RTL_INIT_ANSI_STRING_INDEX);

    impRtlInitAnsiString(DestinationString, SourceString);
}

NTSTATUS
ImpRtlAnsiStringToUnicodeString(_In_ PUNICODE_STRING DestinationString,
                                _In_ PCANSI_STRING   SourceString,
                                _In_ BOOLEAN         AllocateDestinationString)
{
    pRtlAnsiStringToUnicodeString impRtlAnsiStringToUnicodeString =
        (pRtlAnsiStringToUnicodeString)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            RTL_ANSI_STRING_TO_UNICODE_STRING_INDEX);

    return impRtlAnsiStringToUnicodeString(
        DestinationString, SourceString, AllocateDestinationString);
}

PEPROCESS
ImpIoGetCurrentProcess()
{
    pIoGetCurrentProcess impIoGetCurrentProcess =
        (pIoGetCurrentProcess)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, IO_GET_CURRENT_PROCESS_INDEX);

    return impIoGetCurrentProcess();
}

NTSTATUS
ImpRtlGetVersion(_Out_ PRTL_OSVERSIONINFOW lpVersionInformation)
{
    pRtlGetVersion impRtlGetVersion =
        (pRtlGetVersion)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, RTL_GET_VERSION_INDEX);

    return impRtlGetVersion(lpVersionInformation);
}

SIZE_T
ImpRtlCompareMemory(_In_ PVOID Source1, _In_ PVOID Source2, _In_ SIZE_T Length)
{
    pRtlCompareMemory impRtlCompareMemory =
        (pRtlCompareMemory)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, RTL_COMPARE_MEMORY_INDEX);

    return impRtlCompareMemory(Source1, Source2, Length);
}

NTSTATUS
ImpExGetSystemFirmwareTable(_In_ ULONG   FirmwareTableProviderSignature,
                            _In_ ULONG   FirmwareTableID,
                            _In_ PVOID   pFirmwareTableBuffer,
                            _In_ ULONG   BufferLength,
                            _Out_ PULONG ReturnLength)
{
    pExGetSystemFirmwareTable impExGetSystemFirmwareTable =
        (pExGetSystemFirmwareTable)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            EX_GET_SYSTEM_FIRMWARE_TABLE_INDEX);

    return impExGetSystemFirmwareTable(FirmwareTableProviderSignature,
                                       FirmwareTableID,
                                       pFirmwareTableBuffer,
                                       BufferLength,
                                       ReturnLength);
}

PIO_WORKITEM
ImpIoAllocateWorkItem(_In_ PDEVICE_OBJECT DeviceObject)
{
    pIoAllocateWorkItem impIoAllocateWorkItem =
        (pIoAllocateWorkItem)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, IO_ALLOCATE_WORK_ITEM_INDEX);

    return impIoAllocateWorkItem(DeviceObject);
}

VOID
ImpIoFreeWorkItem(_In_ PIO_WORKITEM WorkItem)
{
    pIoFreeWorkItem impIoFreeWorkItem =
        (pIoFreeWorkItem)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, IO_FREE_WORK_ITEM_INDEX);

    impIoFreeWorkItem(WorkItem);
}

VOID
ImpIoQueueWorkItem(_In_ PIO_WORKITEM         IoWorkItem,
                   _In_ PIO_WORKITEM_ROUTINE WorkerRoutine,
                   _In_ WORK_QUEUE_TYPE      QueueType,
                   _In_opt_ PVOID            Context)
{
    pIoQueueWorkItem impIoQueueWorkItem =
        (pIoQueueWorkItem)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, IO_QUEUE_WORK_ITEM_INDEX);

    impIoQueueWorkItem(IoWorkItem, WorkerRoutine, QueueType, Context);
}

NTSTATUS
ImpZwOpenFile(_Out_ PHANDLE           FileHandle,
              _In_ ACCESS_MASK        DesiredAccess,
              _In_ POBJECT_ATTRIBUTES ObjectAttributes,
              _Out_ PIO_STATUS_BLOCK  IoStatusBlock,
              _In_ ULONG              ShareAccess,
              _In_ ULONG              OpenOptions)
{
    pZwOpenFile impZwOpenFile = (pZwOpenFile)CryptDecryptImportsArrayEntry(
        &driver_imports, IMPORTS_LENGTH, ZW_OPEN_FILE_INDEX);

    return impZwOpenFile(FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         ShareAccess,
                         OpenOptions);
}

NTSTATUS
ImpZwClose(_In_ HANDLE Handle)
{
    pZwClose impZwClose = (pZwClose)CryptDecryptImportsArrayEntry(
        &driver_imports, IMPORTS_LENGTH, ZW_CLOSE_INDEX);

    return impZwClose(Handle);
}

NTSTATUS
ImpZwCreateSection(_Out_ PHANDLE               SectionHandle,
                   _In_ ACCESS_MASK            DesiredAccess,
                   _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
                   _In_opt_ PLARGE_INTEGER     MaximumSize,
                   _In_ ULONG                  SectionPageProtection,
                   _In_ ULONG                  AllocationAttributes,
                   _In_opt_ HANDLE             FileHandle)
{
    pZwCreateSection impZwCreateSection =
        (pZwCreateSection)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, ZW_CREATE_SECTION_INDEX);

    return impZwCreateSection(SectionHandle,
                              DesiredAccess,
                              ObjectAttributes,
                              MaximumSize,
                              SectionPageProtection,
                              AllocationAttributes,
                              FileHandle);
}

NTSTATUS
ImpZwMapViewOfSection(_In_ HANDLE                SectionHandle,
                      _In_ HANDLE                ProcessHandle,
                      _Inout_ PVOID*             BaseAddress,
                      _In_ ULONG_PTR             ZeroBits,
                      _In_ SIZE_T                CommitSize,
                      _Inout_opt_ PLARGE_INTEGER SectionOffset,
                      _Inout_ PSIZE_T            ViewSize,
                      _In_ SECTION_INHERIT       InheritDisposition,
                      _In_ ULONG                 AllocationType,
                      _In_ ULONG                 Win32Protect)
{
    pZwMapViewOfSection impZwMapViewOfSection =
        (pZwMapViewOfSection)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, ZW_MAP_VIEW_OF_SECTION_INDEX);

    return impZwMapViewOfSection(SectionHandle,
                                 ProcessHandle,
                                 BaseAddress,
                                 ZeroBits,
                                 CommitSize,
                                 SectionOffset,
                                 ViewSize,
                                 InheritDisposition,
                                 AllocationType,
                                 Win32Protect);
}

NTSTATUS
ImpZwUnmapViewOfSection(_In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress)
{
    pZwUnmapViewOfSection impZwUnmapViewOfSection =
        (pZwUnmapViewOfSection)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, ZW_UNMAP_VIEW_OF_SECTION_INDEX);

    return impZwUnmapViewOfSection(ProcessHandle, BaseAddress);
}

NTSTATUS
ImpMmCopyMemory(_In_ PVOID           TargetAddress,
                _In_ MM_COPY_ADDRESS SourceAddress,
                _In_ SIZE_T          NumberOfBytes,
                _In_ ULONG           Flags,
                _Out_ PSIZE_T        NumberOfBytesTransferred)
{
    pMmCopyMemory impMmCopyMemory =
        (pMmCopyMemory)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, MM_COPY_MEMORY_INDEX);

    return impMmCopyMemory(TargetAddress,
                           SourceAddress,
                           NumberOfBytes,
                           Flags,
                           NumberOfBytesTransferred);
}

NTSTATUS
ImpZwDeviceIoControlFile(_In_ HANDLE              FileHandle,
                         _In_opt_ HANDLE          Event,
                         _In_opt_ PIO_APC_ROUTINE ApcRoutine,
                         _In_opt_ PVOID           ApcContext,
                         _Out_ PIO_STATUS_BLOCK   IoStatusBlock,
                         _In_ ULONG               IoControlCode,
                         _In_opt_ PVOID           InputBuffer,
                         _In_ ULONG               InputBufferLength,
                         _Out_opt_ PVOID          OutputBuffer,
                         _In_ ULONG               OutputBufferLength)
{
    pZwDeviceIoControlFile impZwDeviceIoControlFile =
        (pZwDeviceIoControlFile)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, ZW_DEVICE_IO_CONTROL_FILE_INDEX);

    return impZwDeviceIoControlFile(FileHandle,
                                    Event,
                                    ApcRoutine,
                                    ApcContext,
                                    IoStatusBlock,
                                    IoControlCode,
                                    InputBuffer,
                                    InputBufferLength,
                                    OutputBuffer,
                                    OutputBufferLength);
}

VOID
ImpKeStackAttachProcess(_In_ PRKPROCESS Process, _Out_ PKAPC_STATE ApcState)
{
    pKeStackAttachProcess impKeStackAttachProcess =
        (pKeStackAttachProcess)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_STACK_ATTACH_PROCESS_INDEX);

    impKeStackAttachProcess(Process, ApcState);
}

VOID
ImpKeUnstackDetachProcess(_In_ PKAPC_STATE ApcState)
{
    pKeUnstackDetachProcess impKeUnstackDetachProcess =
        (pKeUnstackDetachProcess)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_UNSTACK_DETACH_PROCESS_INDEX);

    impKeUnstackDetachProcess(ApcState);
}

NTSTATUS
ImpKeWaitForSingleObject(_In_ PVOID           Object,
                         _In_ KWAIT_REASON    WaitReason,
                         _In_ KPROCESSOR_MODE WaitMode,
                         _In_ BOOLEAN         Alertable,
                         _In_ PLARGE_INTEGER  Timeout)
{
    pKeWaitForSingleObject impKeWaitForSingleObject =
        (pKeWaitForSingleObject)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_WAIT_FOR_SINGLE_OBJECT_INDEX);

    return impKeWaitForSingleObject(
        Object, WaitReason, WaitMode, Alertable, Timeout);
}

NTSTATUS
ImpPsCreateSystemThread(_Out_ PHANDLE               ThreadHandle,
                        _In_ ULONG                  DesiredAccess,
                        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
                        _In_opt_ HANDLE             ProcessHandle,
                        _Out_opt_ PCLIENT_ID        ClientId,
                        _In_ PKSTART_ROUTINE        StartRoutine,
                        _In_opt_ PVOID              StartContext)
{
    pPsCreateSystemThread impPsCreateSystemThread =
        (pPsCreateSystemThread)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, PS_CREATE_SYSTEM_THREAD_INDEX);

    return impPsCreateSystemThread(ThreadHandle,
                                   DesiredAccess,
                                   ObjectAttributes,
                                   ProcessHandle,
                                   ClientId,
                                   StartRoutine,
                                   StartContext);
}

VOID
ImpIofCompleteRequest(_In_ PIRP Irp, _In_ CCHAR PriorityBoost)
{
    pIofCompleteRequest impIofCompleteRequest =
        (pIofCompleteRequest)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, IOF_COMPLETE_REQUEST_INDEX);

    impIofCompleteRequest(Irp, PriorityBoost);
}

NTSTATUS
ImpObReferenceObjectByHandle(_In_ HANDLE           Handle,
                             _In_ ACCESS_MASK      DesiredAccess,
                             _In_opt_ POBJECT_TYPE ObjectType,
                             _In_ KPROCESSOR_MODE  AccessMode,
                             _Out_ PVOID*          Object,
                             _Out_opt_ POBJECT_HANDLE_INFORMATION
                                 HandleInformation)
{
    pObReferenceObjectByHandle impObReferenceObjectByHandle =
        (pObReferenceObjectByHandle)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            OB_REFERENCE_OBJECT_BY_HANDLE_INDEX);

    return impObReferenceObjectByHandle(Handle,
                                        DesiredAccess,
                                        ObjectType,
                                        AccessMode,
                                        Object,
                                        HandleInformation);
}

NTSTATUS
ImpKeDelayExecutionThread(_In_ KPROCESSOR_MODE WaitMode,
                          _In_ BOOLEAN         Alertable,
                          _In_ PLARGE_INTEGER  Interval)
{
    pKeDelayExecutionThread impKeDelayExecutionThread =
        (pKeDelayExecutionThread)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_DELAY_EXECUTION_THREAD_INDEX);

    return impKeDelayExecutionThread(WaitMode, Alertable, Interval);
}

PVOID
ImpKeRegisterNmiCallback(_In_ PVOID CallbackRoutine, _In_opt_ PVOID Context)
{
    pKeRegisterNmiCallback impKeRegisterNmiCallback =
        (pKeRegisterNmiCallback)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_REGISTER_NMI_CALLBACK_INDEX);

    return impKeRegisterNmiCallback(CallbackRoutine, Context);
}

NTSTATUS
ImpKeDeregisterNmiCallback(_In_ PVOID Handle)
{
    pKeDeregisterNmiCallback impKeDeregisterNmiCallback =
        (pKeDeregisterNmiCallback)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_DEREGISTER_NMI_CALLBACK_INDEX);

    return impKeDeregisterNmiCallback(Handle);
}

ULONG
ImpKeQueryActiveProcessorCount(_In_ PKAFFINITY ActiveProcessors)
{
    pKeQueryActiveProcessorCount impKeQueryActiveProcessorCount =
        (pKeQueryActiveProcessorCount)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            KE_QUERY_ACTIVE_PROCESSOR_COUNT_INDEX);

    return impKeQueryActiveProcessorCount(ActiveProcessors);
}

VOID
ImpExAcquirePushLockExclusiveEx(_Inout_ PEX_PUSH_LOCK PushLock,
                                _In_ ULONG            Flags)
{
    pExAcquirePushLockExclusiveEx impExAcquirePushLockExclusiveEx =
        (pExAcquirePushLockExclusiveEx)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            EX_ACQUIRE_PUSH_LOCK_EXCLUSIVE_EX_INDEX);

    impExAcquirePushLockExclusiveEx(PushLock, Flags);
}

VOID
ImpExReleasePushLockExclusiveEx(_Inout_ PEX_PUSH_LOCK PushLock,
                                _In_ ULONG            Flags)
{
    pExReleasePushLockExclusiveEx impExReleasePushLockExclusiveEx =
        (pExReleasePushLockExclusiveEx)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            EX_RELEASE_PUSH_LOCK_EXCLUSIVE_EX_INDEX);

    impExReleasePushLockExclusiveEx(PushLock, Flags);
}

HANDLE
ImpPsGetThreadId(_In_ PETHREAD Thread)
{
    pPsGetThreadId impPsGetThreadId =
        (pPsGetThreadId)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, PS_GET_THREAD_ID_INDEX);

    return impPsGetThreadId(Thread);
}

USHORT
ImpRtlCaptureStackBackTrace(_In_ ULONG       FramesToSkip,
                            _In_ ULONG       FramesToCapture,
                            _Out_ PVOID*     BackTrace,
                            _Out_opt_ PULONG BackTraceHash)
{
    pRtlCaptureStackBackTrace impRtlCaptureStackBackTrace =
        (pRtlCaptureStackBackTrace)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            RTL_CAPTURE_STACK_BACK_TRACE_INDEX);

    return impRtlCaptureStackBackTrace(
        FramesToSkip, FramesToCapture, BackTrace, BackTraceHash);
}

NTSTATUS
ImpZwOpenDirectoryObject(_Out_ PHANDLE           DirectoryHandle,
                         _In_ ACCESS_MASK        DesiredAccess,
                         _In_ POBJECT_ATTRIBUTES ObjectAttributes)
{
    pZwOpenDirectoryObject impZwOpenDirectoryObject =
        (pZwOpenDirectoryObject)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, ZW_OPEN_DIRECTORY_OBJECT_INDEX);

    return impZwOpenDirectoryObject(
        DirectoryHandle, DesiredAccess, ObjectAttributes);
}

VOID
ImpKeInitializeAffinityEx(_In_ PKAFFINITY_EX AffinityMask)
{
    pKeInitializeAffinityEx impKeInitializeAffinityEx =
        (pKeInitializeAffinityEx)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_INITIALIZE_AFFINITY_EX_INDEX);

    impKeInitializeAffinityEx(AffinityMask);
}

VOID
ImpKeAddProcessorAffinityEx(_In_ PKAFFINITY_EX Affinity, _In_ INT CoreNumber)
{
    pKeAddProcessorAffinityEx impKeAddProcessorAffinityEx =
        (pKeAddProcessorAffinityEx)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            KE_ADD_PROCESSOR_AFFINITY_EX_INDEX);

    impKeAddProcessorAffinityEx(Affinity, CoreNumber);
}

NTSTATUS
ImpRtlQueryModuleInformation(_Inout_ ULONG* InformationLength,
                             _In_ ULONG     SizePerModule,
                             _In_ PVOID     InformationBuffer)
{
    pRtlQueryModuleInformation impRtlQueryModuleInformation =
        (pRtlQueryModuleInformation)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            RTL_QUERY_MODULE_INFORMATION_INDEX);

    return impRtlQueryModuleInformation(
        InformationLength, SizePerModule, InformationBuffer);
}

VOID
ImpKeInitializeApc(_In_ PKAPC             Apc,
                   _In_ PKTHREAD          Thread,
                   _In_ KAPC_ENVIRONMENT  Environment,
                   _In_ PKKERNEL_ROUTINE  KernelRoutine,
                   _In_ PKRUNDOWN_ROUTINE RundownRoutine,
                   _In_ PKNORMAL_ROUTINE  NormalRoutine,
                   _In_ KPROCESSOR_MODE   ApcMode,
                   _In_ PVOID             NormalContext)
{
    pKeInitializeApc impKeInitializeApc =
        (pKeInitializeApc)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_INITIALIZE_APC_INDEX);

    impKeInitializeApc(Apc,
                       Thread,
                       Environment,
                       KernelRoutine,
                       RundownRoutine,
                       NormalRoutine,
                       ApcMode,
                       NormalContext);
}

BOOLEAN
ImpKeInsertQueueApc(_In_ PKAPC     Apc,
                    _In_ PVOID     SystemArgument1,
                    _In_ PVOID     SystemArgument2,
                    _In_ KPRIORITY Increment)
{
    pKeInsertQueueApc impKeInsertQueueApc =
        (pKeInsertQueueApc)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_INSERT_QUEUE_APC_INDEX);

    return impKeInsertQueueApc(
        Apc, SystemArgument1, SystemArgument2, Increment);
}

VOID
ImpKeGenericCallDpc(_In_ PKDEFERRED_ROUTINE DpcRoutine, _In_ PVOID Context)
{
    pKeGenericCallDpc impKeGenericCallDpc =
        (pKeGenericCallDpc)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_GENERIC_CALL_DPC_INDEX);

    impKeGenericCallDpc(DpcRoutine, Context);
}

VOID
ImpKeSignalCallDpcDone(_In_ PVOID SystemArgument1)
{
    pKeSignalCallDpcDone impKeSignalCallDpcDone =
        (pKeSignalCallDpcDone)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_SIGNAL_CALL_DPC_DONE_INDEX);

    impKeSignalCallDpcDone(SystemArgument1);
}

PPHYSICAL_MEMORY_RANGE
ImpMmGetPhysicalMemoryRangesEx2(_In_ PVOID PartitionObject, _In_ ULONG Flags)
{
    pMmGetPhysicalMemoryRangesEx2 impMmGetPhysicalMemoryRangesEx2 =
        (pMmGetPhysicalMemoryRangesEx2)CryptDecryptImportsArrayEntry(
            &driver_imports,
            IMPORTS_LENGTH,
            MM_GET_PHYSICAL_MEMORY_RANGES_EX2_INDEX);

    return impMmGetPhysicalMemoryRangesEx2(PartitionObject, Flags);
}

PVOID
ImpMmGetVirtualForPhysical(_In_ PHYSICAL_ADDRESS PhysicalAddress)
{
    pMmGetVirtualForPhysical impMmGetVirtualForPhysical =
        (pMmGetVirtualForPhysical)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, MM_GET_VIRTUAL_FOR_PHYSICAL_INDEX);

    return impMmGetVirtualForPhysical(PhysicalAddress);
}

LONG_PTR
ImpObfReferenceObject(_In_ PVOID Object)
{
    pObfReferenceObject impObfReferenceObject =
        (pObfReferenceObject)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, OBF_REFERENCE_OBJECT_INDEX);

    return impObfReferenceObject(Object);
}

VOID
ImpExFreePoolWithTag(_In_ PVOID P, _In_ ULONG Tag)
{
    pExFreePoolWithTag impExFreePoolWithTag =
        (pExFreePoolWithTag)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, EX_FREE_POOL_WITH_TAG_INDEX);

    impExFreePoolWithTag(P, Tag);
}

PVOID
ImpExAllocatePool2(_In_ POOL_FLAGS Flags,
                   _In_ SIZE_T     NumberOfBytes,
                   _In_ ULONG      Tag)
{
    pExAllocatePool2 impExAllocatePool2 =
        (pExAllocatePool2)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, EX_ALLOCATE_POOL2_INDEX);

    return impExAllocatePool2(Flags, NumberOfBytes, Tag);
}

VOID
ImpKeReleaseGuardedMutex(_In_ PKGUARDED_MUTEX GuardedMutex)
{
    pKeReleaseGuardedMutex impKeReleaseGuardedMutex =
        (pKeReleaseGuardedMutex)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_RELEASE_GUARDED_MUTEX_INDEX);

    impKeReleaseGuardedMutex(GuardedMutex);
}

VOID
ImpKeAcquireGuardedMutex(_In_ PKGUARDED_MUTEX GuardedMutex)
{
    pKeAcquireGuardedMutex impKeAcquireGuardedMutex =
        (pKeAcquireGuardedMutex)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, KE_ACQUIRE_GUARDED_MUTEX_INDEX);

    impKeAcquireGuardedMutex(GuardedMutex);
}

ULONG
ImpDbgPrintEx(_In_ ULONG ComponentId, _In_ ULONG Level, _In_ PCSTR Format, ...)
{
    pDbgPrintEx impDbgPrintEx = (pDbgPrintEx)CryptDecryptImportsArrayEntry(
        &driver_imports, IMPORTS_LENGTH, DBG_PRINT_EX_INDEX);

    va_list args;
    va_start(args, Format);
    ULONG result = impDbgPrintEx(ComponentId, Level, Format, args);
    va_end(args);

    return result;
}

LONG
ImpRtlCompareUnicodeString(_In_ PCUNICODE_STRING String1,
                           _In_ PCUNICODE_STRING String2,
                           _In_ BOOLEAN          CaseInSensitive)
{
    pRtlCompareUnicodeString impRtlCompareUnicodeString =
        (pRtlCompareUnicodeString)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, RTL_COMPARE_UNICODE_STRING_INDEX);

    return impRtlCompareUnicodeString(String1, String2, CaseInSensitive);
}

VOID
ImpRtlFreeUnicodeString(_In_ PUNICODE_STRING UnicodeString)
{
    pRtlFreeUnicodeString impRtlFreeUnicodeString =
        (pRtlFreeUnicodeString)CryptDecryptImportsArrayEntry(
            &driver_imports, IMPORTS_LENGTH, RTL_FREE_UNICODE_STRING_INDEX);

    impRtlFreeUnicodeString(UnicodeString);
}
```

`driver/imports.h`:

```h
#ifndef IMPORTS_H
#define IMPORTS_H

#include "common.h"

PVOID
ImpResolveNtImport(PDRIVER_OBJECT DriverObject, PCZPSTR ExportName);

NTSTATUS
ImpResolveDynamicImports(_In_ PDRIVER_OBJECT DriverObject);

#define IMPORT_FUNCTION_MAX_LENGTH 128
#define IMPORT_FUNCTION_COUNT      256

// clang-format off

typedef 
void* (*pObDereferenceObject)(
        void* Object
        );

typedef 
void* (*pObReferenceObject)(
        void* Object
        );

typedef 
NTSTATUS (*pPsLookupThreadByThreadId)(
        HANDLE ThreadId, 
        PETHREAD* Thread
        );

typedef 
BOOLEAN (*pMmIsAddressValid)(
        void* VirtualAddress
        );

typedef 
NTSTATUS (*pPsSetCreateProcessNotifyRoutine)(
        PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,
        BOOLEAN Remove
        );

typedef 
NTSTATUS (*pPsRemoveCreateThreadNotifyRoutine)(
        PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
        );

typedef 
HANDLE (*pPsGetCurrentThreadId)(
        void
        );

typedef 
HANDLE (*pPsGetProcessId)(
        PEPROCESS Process
        );

typedef 
NTSTATUS (*pPsLookupProcessByProcessId)(
        HANDLE ProcessId,
        PEPROCESS* Process
        );

typedef 
void* (*pExEnumHandleTable)(
        PHANDLE_TABLE HandleTable,
        void*     Callback,
        void*     Context,
        PHANDLE   Handle);

typedef 
POBJECT_TYPE (*pObGetObjectType)(
        void* Object
        );

typedef 
void (*pExfUnblockPushLock)(
        PEX_PUSH_LOCK PushLock, 
        void* WaitBlock
        );

typedef 
LPCSTR (*pPsGetProcessImageFileName)(
        PEPROCESS Process
        );

typedef 
INT (*pstrcmp)(
        const CHAR* str1, 
        const CHAR* str2
        );

typedef 
PCHAR (*pstrstr)(
        const CHAR* haystack, 
        const CHAR* needle
        );

typedef 
void (*pRtlInitUnicodeString)(
        PUNICODE_STRING DestinationString, 
        PCWSTR SourceString
        );

typedef 
NTSTATUS (*pRtlQueryRegistryValues)(
        ULONG                     RelativeTo,
        PCWSTR                    Path,
        PRTL_QUERY_REGISTRY_TABLE QueryTable,
        void*                     Context,
        void*                     Environment
        );

typedef 
void* (*pMmGetSystemRoutineAddress)(
        PUNICODE_STRING SystemRoutineName
        );

typedef 
NTSTATUS (*pRtlUnicodeStringToAnsiString)(
        PANSI_STRING     DestinationString,
        PCUNICODE_STRING SourceString,
        BOOLEAN          AllocateDestinationString
        );

typedef 
void (*pRtlCopyUnicodeString)(
        PUNICODE_STRING  DestinationString,
        PCUNICODE_STRING SourceString
        );

typedef 
void (*pRtlFreeAnsiString)(
        PANSI_STRING AnsiString
        );

typedef 
void (*pKeInitializeGuardedMutex)(
        PKGUARDED_MUTEX GuardedMutex
        );

typedef 
NTSTATUS (*pIoCreateDevice)(
        PDRIVER_OBJECT  DriverObject,
        ULONG           DeviceExtensionSize,
        PUNICODE_STRING DeviceName,
        DEVICE_TYPE     DeviceType,
        ULONG           DeviceCharacteristics,
        BOOLEAN         Exclusive,
        PDEVICE_OBJECT  *DeviceObject
        );

typedef 
NTSTATUS (*pIoCreateSymbolicLink)(
        PUNICODE_STRING SymbolicLinkName,
        PUNICODE_STRING DeviceName
        );

typedef 
void (*pIoDeleteDevice)(
        PDEVICE_OBJECT DeviceObject
        );

typedef 
void (*pIoDeleteSymbolicLink)(
        PUNICODE_STRING SymbolicLinkName
        );

typedef 
NTSTATUS (*pObRegisterCallbacks)(
        POB_CALLBACK_REGISTRATION CallbackRegistration,
        void**                    RegistrationHandle
        );

typedef 
void (*pObUnRegisterCallbacks)(
        void* RegistrationHandle
        );

typedef 
NTSTATUS (*pPsSetCreateThreadNotifyRoutine)(
        PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
        );

typedef 
void (*pKeRevertToUserAffinityThreadEx)(
        KAFFINITY Affinity
        );

typedef 
KAFFINITY (*pKeSetSystemAffinityThreadEx)(
        KAFFINITY Affinity
        );

typedef 
SIZE_T (*pstrnlen)(
        const CHAR* str, 
        SIZE_T maxCount
        );

typedef 
void (*pRtlInitAnsiString)(
        PANSI_STRING DestinationString, 
        PCSZ SourceString
        );

typedef 
NTSTATUS (*pRtlAnsiStringToUnicodeString)(
        PUNICODE_STRING DestinationString,
        PCANSI_STRING   SourceString,
        BOOLEAN         AllocateDestinationString
        );

typedef 
PEPROCESS (*pIoGetCurrentProcess)(
        void
        );

typedef 
NTSTATUS (*pRtlGetVersion)(
        PRTL_OSVERSIONINFOW lpVersionInformation
        );

typedef 
SIZE_T (*pRtlCompareMemory)(
        const void* Source1, 
        const void* Source2, 
        SIZE_T Length
        );

typedef 
NTSTATUS (*pExGetSystemFirmwareTable)(
        ULONG FirmwareTableProviderSignature,
        ULONG FirmwareTableID,
        void* pFirmwareTableBuffer,
        ULONG BufferLength,
        PULONG ReturnLength
        );

typedef 
PIO_WORKITEM (*pIoAllocateWorkItem)(
        PDEVICE_OBJECT DeviceObject
        );

typedef 
void (*pIoFreeWorkItem)(
        PIO_WORKITEM WorkItem
        );

typedef 
void (*pIoQueueWorkItem)(
        PIO_WORKITEM         IoWorkItem,
        PIO_WORKITEM_ROUTINE WorkerRoutine,
        WORK_QUEUE_TYPE      QueueType,
        void* Context
        );

typedef 
NTSTATUS (*pZwOpenFile)(
        PHANDLE            FileHandle,
        ACCESS_MASK        DesiredAccess,
        POBJECT_ATTRIBUTES ObjectAttributes,
        PIO_STATUS_BLOCK   IoStatusBlock,
        ULONG              ShareAccess,
        ULONG              OpenOptions
        );

typedef 
NTSTATUS (*pZwClose)(
        HANDLE Handle
        );

typedef 
NTSTATUS (*pZwCreateSection)(
        PHANDLE            SectionHandle,
        ACCESS_MASK        DesiredAccess,
        POBJECT_ATTRIBUTES ObjectAttributes,
        PLARGE_INTEGER     MaximumSize,
        ULONG              SectionPageProtection,
        ULONG              AllocationAttributes,
        HANDLE             FileHandle
        );

typedef 
NTSTATUS (*pZwMapViewOfSection)(
        HANDLE          SectionHandle,
        HANDLE          ProcessHandle,
        void**          BaseAddress,
        ULONG_PTR       ZeroBits,
        SIZE_T          CommitSize,
        PLARGE_INTEGER  SectionOffset,
        PSIZE_T         ViewSize,
        SECTION_INHERIT InheritDisposition,
        ULONG           AllocationType,
        ULONG           Win32Protect
        );

typedef 
NTSTATUS (*pZwUnmapViewOfSection)(
        HANDLE ProcessHandle, 
        void* BaseAddress
        );

typedef 
NTSTATUS (*pMmCopyMemory)(
        PVOID           TargetAddress,
        MM_COPY_ADDRESS SourceAddress,
        SIZE_T          NumberOfBytes,
        ULONG           Flags,
        PSIZE_T         NumberOfBytesTransferred
        );

typedef 
NTSTATUS (*pZwDeviceIoControlFile)(
        HANDLE           FileHandle,
        HANDLE           Event,
        PIO_APC_ROUTINE  ApcRoutine,
        void*            ApcContext,
        PIO_STATUS_BLOCK IoStatusBlock,
        ULONG            IoControlCode,
        void*            InputBuffer,
        ULONG            InputBufferLength,
        void*            OutputBuffer,
        ULONG            OutputBufferLength
        );

typedef 
void (*pKeStackAttachProcess)(
        PRKPROCESS Process, 
        PKAPC_STATE ApcState
        );

typedef 
void (*pKeUnstackDetachProcess)(
        PKAPC_STATE ApcState
        );

typedef 
NTSTATUS (*pKeWaitForSingleObject)(
        void*           Object,
        KWAIT_REASON    WaitReason,
        KPROCESSOR_MODE WaitMode,
        BOOLEAN         Alertable,
        PLARGE_INTEGER  Timeout
        );

typedef 
NTSTATUS (*pPsCreateSystemThread)(
        PHANDLE            ThreadHandle,
        ULONG              DesiredAccess,
        POBJECT_ATTRIBUTES ObjectAttributes,
        HANDLE             ProcessHandle,
        PCLIENT_ID         ClientId,
        PKSTART_ROUTINE    StartRoutine,
        void*              StartContext
        );

typedef 
void (*pIofCompleteRequest)(
        PIRP Irp, 
        CCHAR PriorityBoost
        );

typedef 
NTSTATUS (*pObReferenceObjectByHandle)(
        HANDLE                     Handle,
        ACCESS_MASK                DesiredAccess,
        POBJECT_TYPE               ObjectType,
        KPROCESSOR_MODE            AccessMode,
        void**                     Object,
        POBJECT_HANDLE_INFORMATION HandleInformation
        );

typedef 
NTSTATUS (*pKeDelayExecutionThread)(
        KPROCESSOR_MODE WaitMode,
        BOOLEAN         Alertable,
        PLARGE_INTEGER  Interval
        );

typedef 
void* (*pKeRegisterNmiCallback)(
        void* CallbackRoutine, 
        void* Context
        );

typedef 
NTSTATUS (*pKeDeregisterNmiCallback)(
        void* Handle
        );

typedef 
ULONG (*pKeQueryActiveProcessorCount)(
        PKAFFINITY ActiveProcessors
        );

typedef 
void (*pExAcquirePushLockExclusiveEx)(
        PEX_PUSH_LOCK PushLock, 
        ULONG Flags
        );

typedef 
void (*pExReleasePushLockExclusiveEx)(
        PEX_PUSH_LOCK PushLock, 
        ULONG Flags
        );

typedef 
HANDLE (*pPsGetThreadId)(
        PETHREAD Thread
        );

typedef 
USHORT (*pRtlCaptureStackBackTrace)(
        ULONG  FramesToSkip,
        ULONG  FramesToCapture,
        void** BackTrace,
        PULONG BackTraceHash
        );

typedef 
NTSTATUS (*pZwOpenDirectoryObject)(
        PHANDLE            DirectoryHandle,
        ACCESS_MASK        DesiredAccess,
        POBJECT_ATTRIBUTES ObjectAttributes
        );

typedef 
void (*pKeInitializeAffinityEx)(
        PKAFFINITY_EX AffinityMask
        );

typedef 
void (*pKeAddProcessorAffinityEx)(
        PKAFFINITY_EX Affinity, 
        INT CoreNumber
        );

typedef 
NTSTATUS (*pRtlQueryModuleInformation)(
        ULONG* InformationLength,
        ULONG  SizePerModule,
        PVOID  InformationBuffer
        );

typedef 
void (*pKeInitializeApc)(
        PKAPC             Apc,
        PKTHREAD          Thread,
        KAPC_ENVIRONMENT  Environment,
        PKKERNEL_ROUTINE  KernelRoutine,
        PKRUNDOWN_ROUTINE RundownRoutine,
        PKNORMAL_ROUTINE  NormalRoutine,
        KPROCESSOR_MODE   ApcMode,
        void*             NormalContext
        );

typedef 
BOOLEAN (*pKeInsertQueueApc)(
        PKAPC     Apc,
        void*     SystemArgument1,
        void*     SystemArgument2,
        KPRIORITY Increment
        );

typedef 
void (*pKeGenericCallDpc)(
        PKDEFERRED_ROUTINE DpcRoutine, 
        void* Context
        );

typedef 
void (*pKeSignalCallDpcDone)(
        void* SystemArgument1
        );

typedef 
PPHYSICAL_MEMORY_RANGE (*pMmGetPhysicalMemoryRangesEx2)(
        PVOID PartitionObject, 
        ULONG Flags
        );

typedef 
void* (*pMmGetVirtualForPhysical)(
        PHYSICAL_ADDRESS PhysicalAddress
        );

typedef 
LONG_PTR (*pObfReferenceObject)(
        void* Object
        );

typedef 
void (*pExFreePoolWithTag)(
        void* P, 
        ULONG Tag
        );

typedef 
void* (*pExAllocatePool2)(
        POOL_FLAGS Flags, 
        SIZE_T NumberOfBytes, 
        ULONG Tag
        );

typedef 
void (*pKeReleaseGuardedMutex)(
        PKGUARDED_MUTEX GuardedMutex
        );

typedef 
void (*pKeAcquireGuardedMutex)(
        PKGUARDED_MUTEX GuardedMutex
        );

typedef 
ULONG (*pDbgPrintEx)(
        ULONG ComponentId, 
        ULONG Level, 
        PCSTR Format, 
        ...
        );

typedef 
LONG (*pRtlCompareUnicodeString)(
        PCUNICODE_STRING String1,
        PCUNICODE_STRING String2,
        BOOLEAN          CaseInSensitive
        );

typedef 
PIO_STACK_LOCATION (*pIoGetCurrentIrpStackLocation)(
        PIRP Irp
        );

typedef 
void (*pRtlFreeUnicodeString)(
        PUNICODE_STRING UnicodeString
        );

// clang-format on

#define OB_DEREFERENCE_OBJECT_INDEX                0
#define PS_LOOKUP_THREAD_BY_THREAD_ID_INDEX        1
#define MM_IS_ADDRESS_VALID_INDEX                  2
#define PS_SET_CREATE_PROCESS_NOTIFY_ROUTINE_INDEX 3

#define PS_REMOVE_CREATE_THREAD_NOTIFY_ROUTINE_INDEX 4
#define PS_GET_CURRENT_THREAD_ID_INDEX               5
#define PS_GET_PROCESS_ID_INDEX                      6
#define PS_LOOKUP_PROCESS_BY_PROCESS_ID_INDEX        7

#define EX_ENUM_HANDLE_TABLE_INDEX           8
#define OB_GET_OBJECT_TYPE_INDEX             9
#define EXF_UNBLOCK_PUSH_LOCK_INDEX          10
#define PS_GET_PROCESS_IMAGE_FILE_NAME_INDEX 11

#define STRSTR_INDEX                        12
#define RTL_INIT_UNICODE_STRING_INDEX       13
#define RTL_QUERY_REGISTRY_VALUES_INDEX     14
#define MM_GET_SYSTEM_ROUTINE_ADDRESS_INDEX 15

#define RTL_UNICODE_STRING_TO_ANSI_STRING_INDEX 16
#define RTL_COPY_UNICODE_STRING_INDEX           17
#define RTL_FREE_ANSI_STRING_INDEX              18
#define KE_INITIALIZE_GUARDED_MUTEX_INDEX       19

#define IO_CREATE_DEVICE_INDEX        20
#define IO_CREATE_SYMBOLIC_LINK_INDEX 21
#define IO_DELETE_DEVICE_INDEX        22
#define IO_DELETE_SYMBOLIC_LINK_INDEX 23

#define OB_REGISTER_CALLBACKS_INDEX                24
#define OB_UNREGISTER_CALLBACKS_INDEX              25
#define PS_SET_CREATE_THREAD_NOTIFY_ROUTINE_INDEX  26
#define KE_REVERT_TO_USER_AFFINITY_THREAD_EX_INDEX 27

#define KE_SET_SYSTEM_AFFINITY_THREAD_EX_INDEX  28
#define STRNLEN_INDEX                           29
#define RTL_INIT_ANSI_STRING_INDEX              30
#define RTL_ANSI_STRING_TO_UNICODE_STRING_INDEX 31

#define IO_GET_CURRENT_PROCESS_INDEX       32
#define RTL_GET_VERSION_INDEX              33
#define RTL_COMPARE_MEMORY_INDEX           34
#define EX_GET_SYSTEM_FIRMWARE_TABLE_INDEX 35

#define IO_ALLOCATE_WORK_ITEM_INDEX 36
#define IO_FREE_WORK_ITEM_INDEX     37
#define IO_QUEUE_WORK_ITEM_INDEX    38
#define ZW_OPEN_FILE_INDEX          39

#define ZW_CLOSE_INDEX                 40
#define ZW_CREATE_SECTION_INDEX        41
#define ZW_MAP_VIEW_OF_SECTION_INDEX   42
#define ZW_UNMAP_VIEW_OF_SECTION_INDEX 43

#define MM_COPY_MEMORY_INDEX            44
#define ZW_DEVICE_IO_CONTROL_FILE_INDEX 45
#define KE_STACK_ATTACH_PROCESS_INDEX   46
#define KE_UNSTACK_DETACH_PROCESS_INDEX 47

#define KE_WAIT_FOR_SINGLE_OBJECT_INDEX     48
#define PS_CREATE_SYSTEM_THREAD_INDEX       49
#define IOF_COMPLETE_REQUEST_INDEX          50
#define OB_REFERENCE_OBJECT_BY_HANDLE_INDEX 51

#define KE_DELAY_EXECUTION_THREAD_INDEX       52
#define KE_REGISTER_NMI_CALLBACK_INDEX        53
#define KE_DEREGISTER_NMI_CALLBACK_INDEX      54
#define KE_QUERY_ACTIVE_PROCESSOR_COUNT_INDEX 55

#define EX_ACQUIRE_PUSH_LOCK_EXCLUSIVE_EX_INDEX 56
#define EX_RELEASE_PUSH_LOCK_EXCLUSIVE_EX_INDEX 57
#define PS_GET_THREAD_ID_INDEX                  58
#define RTL_CAPTURE_STACK_BACK_TRACE_INDEX      59

#define ZW_OPEN_DIRECTORY_OBJECT_INDEX     60
#define KE_INITIALIZE_AFFINITY_EX_INDEX    61
#define KE_ADD_PROCESSOR_AFFINITY_EX_INDEX 62
#define RTL_QUERY_MODULE_INFORMATION_INDEX 63

#define KE_INITIALIZE_APC_INDEX       64
#define KE_INSERT_QUEUE_APC_INDEX     65
#define KE_GENERIC_CALL_DPC_INDEX     66
#define KE_SIGNAL_CALL_DPC_DONE_INDEX 67

#define MM_GET_PHYSICAL_MEMORY_RANGES_EX2_INDEX 68
#define MM_GET_VIRTUAL_FOR_PHYSICAL_INDEX       69
#define OBF_REFERENCE_OBJECT_INDEX              70
#define EX_FREE_POOL_WITH_TAG_INDEX             71

#define EX_ALLOCATE_POOL2_INDEX        72
#define KE_RELEASE_GUARDED_MUTEX_INDEX 73
#define KE_ACQUIRE_GUARDED_MUTEX_INDEX 74
#define DBG_PRINT_EX_INDEX             75

#define RTL_COMPARE_UNICODE_STRING_INDEX     76
#define RTL_FREE_UNICODE_STRING_INDEX        77
#define PS_GET_PROCESS_IMAGE_FILE_NAME_INDEX 78

typedef struct _DRIVER_IMPORTS
{
        pObDereferenceObject             DrvImpObDereferenceObject;
        pPsLookupThreadByThreadId        DrvImpPsLookupThreadByThreadId;
        pMmIsAddressValid                DrvImpMmIsAddressValid;
        pPsSetCreateProcessNotifyRoutine DrvImpPsSetCreateProcessNotifyRoutine;

        pPsRemoveCreateThreadNotifyRoutine DrvImpPsRemoveCreateThreadNotifyRoutine;
        pPsGetCurrentThreadId              DrvImpPsGetCurrentThreadId;
        pPsGetProcessId                    DrvImpPsGetProcessId;
        pPsLookupProcessByProcessId        DrvImpPsLookupProcessByProcessId;

        pExEnumHandleTable         DrvImpExEnumHandleTable;
        pObGetObjectType           DrvImpObGetObjectType;
        pExfUnblockPushLock        DrvImpExfUnblockPushLock;
        pPsGetProcessImageFileName DrvImpPsGetProcessImage;

        pstrstr                    DrvImpstrstr;
        pRtlInitUnicodeString      DrvImpRtlInitUnicodeString;
        pRtlQueryRegistryValues    DrvImpRtlQueryRegistryValues;
        pMmGetSystemRoutineAddress DrvImpMmGetSystemRoutineAddress;

        pRtlUnicodeStringToAnsiString DrvImpRtlUnicodeStringToAnsiString;
        pRtlCopyUnicodeString         DrvImpRtlCopyUnicodeString;
        pRtlFreeAnsiString            DrvImpRtlFreeAnsiString;
        pKeInitializeGuardedMutex     DrvImpKeInitializeGuardedMutex;

        pIoCreateDevice       DrvImpIoCreateDevice;
        pIoCreateSymbolicLink DrvImpIoCreateSymbolicLink;
        pIoDeleteDevice       DrvImpIoDeleteDevice;
        pIoDeleteSymbolicLink DrvImpIoDeleteSymbolicLink;

        pObRegisterCallbacks            DrvImpObRegisterCallbacks;
        pObUnRegisterCallbacks          DrvImpObUnRegisterCallbacks;
        pPsSetCreateThreadNotifyRoutine DrvImpPsSetCreateThreadNotifyRoutine;
        pKeRevertToUserAffinityThreadEx DrvImpKeRevertToUserAffinityThreadEx;

        pKeSetSystemAffinityThreadEx  DrvImpKeSetSystemAffinityThreadEx;
        pstrnlen                      DrvImpstrnlen;
        pRtlInitAnsiString            DrvImpRtlInitAnsiString;
        pRtlAnsiStringToUnicodeString DrvImpRtlAnsiStringToUnicodeString;

        pIoGetCurrentProcess      DrvImpIoGetCurrentProcess;
        pRtlGetVersion            DrvImpRtlGetVersion;
        pRtlCompareMemory         DrvImpRtlCompareMemory;
        pExGetSystemFirmwareTable DrvImpExGetSystemFirmwareTable;

        pIoAllocateWorkItem DrvImpIoAllocateWorkItem;
        pIoFreeWorkItem     DrvImpIoFreeWorkItem;
        pIoQueueWorkItem    DrvImpIoQueueWorkItem;
        pZwOpenFile         DrvImpZwOpenFile;

        pZwClose              DrvImpZwClose;
        pZwCreateSection      DrvImpZwCreateSection;
        pZwMapViewOfSection   DrvImpZwMapViewOfSection;
        pZwUnmapViewOfSection DrvImpZwUnmapViewOfSection;

        pMmCopyMemory           DrvImpMmCopyMemory;
        pZwDeviceIoControlFile  DrvImpZwDeviceIoControlFile;
        pKeStackAttachProcess   DrvImpKeStackAttachProcess;
        pKeUnstackDetachProcess DrvImpKeUnstackDetachProcess;

        pKeWaitForSingleObject     DrvImpKeWaitForSingleObject;
        pPsCreateSystemThread      DrvImpPsCreateSystemThread;
        pIofCompleteRequest        DrvImpIofCompleteRequest;
        pObReferenceObjectByHandle DrvImpObReferenceObjectByHandle;

        pKeDelayExecutionThread      DrvImpKeDelayExecutionThread;
        pKeRegisterNmiCallback       DrvImpKeRegisterNmiCallback;
        pKeDeregisterNmiCallback     DrvImpKeDeregisterNmiCallback;
        pKeQueryActiveProcessorCount DrvImpKeQueryActiveProcessorCount;

        pExAcquirePushLockExclusiveEx DrvImpExAcquirePushLockExclusiveEx;
        pExReleasePushLockExclusiveEx DrvImpExReleasePushLockExclusiveEx;
        pPsGetThreadId                DrvImpPsGetThreadId;
        pRtlCaptureStackBackTrace     DrvImpRtlCaptureStackBackTrace;

        pZwOpenDirectoryObject     DrvImpZwOpenDirectoryObject;
        pKeInitializeAffinityEx    DrvImpKeInitializeAffinityEx;
        pKeAddProcessorAffinityEx  DrvImpKeAddProcessorAffinityEx;
        pRtlQueryModuleInformation DrvImpRtlQueryModuleInformation;

        pKeInitializeApc     DrvImpKeInitializeApc;
        pKeInsertQueueApc    DrvImpKeInsertQueueApc;
        pKeGenericCallDpc    DrvImpKeGenericCallDpc;
        pKeSignalCallDpcDone DrvImpKeSignalCallDpcDone;

        pMmGetPhysicalMemoryRangesEx2 DrvImpMmGetPhysicalMemoryRangesEx2;
        pMmGetVirtualForPhysical      DrvImpMmGetVirtualForPhysical;
        pObfReferenceObject           DrvImpObfReferenceObject;
        pExFreePoolWithTag            DrvImpExFreePoolWithTag;

        pExAllocatePool2       DrvImpExAllocatePool2;
        pKeReleaseGuardedMutex DrvImpKeReleaseGuardedMutex;
        pKeAcquireGuardedMutex DrvImpKeAcquireGuardedMutex;
        pDbgPrintEx            DrvImpDbgPrintEx;

        pRtlCompareUnicodeString   DrvImpRtlCompareUnicodeString;
        pRtlFreeUnicodeString      DrvImpRtlFreeUnicodeString;
        pPsGetProcessImageFileName DrvImpPsGetProcessImageFileName;
        UINT64                     dummy;

} DRIVER_IMPORTS, *PDRIVER_IMPORTS;

#define IMPORTS_LENGTH sizeof(DRIVER_IMPORTS) / sizeof(UINT64)

VOID
ImpObDereferenceObject(_In_ PVOID Object);

NTSTATUS
ImpPsLookupThreadByThreadId(HANDLE ThreadId, PETHREAD* Thread);

BOOLEAN
ImpMmIsAddressValid(_In_ PVOID VirtualAddress);

NTSTATUS
ImpPsSetCreateProcessNotifyRoutine(PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine, BOOLEAN Remove);

NTSTATUS
ImpPsRemoveCreateThreadNotifyRoutine(PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine);

HANDLE
ImpPsGetCurrentThreadId();

HANDLE
ImpPsGetProcessId(PEPROCESS Process);

NTSTATUS
ImpPsLookupProcessByProcessId(HANDLE ProcessId, PEPROCESS* Process);

PVOID
ImpExEnumHandleTable(_In_ PHANDLE_TABLE HandleTable,
                     _In_ PVOID         Callback,
                     _In_opt_ PVOID     Context,
                     _Out_opt_ PHANDLE  Handle);

POBJECT_TYPE
ImpObGetObjectType(_In_ PVOID Object);

VOID
ImpExfUnblockPushLock(_In_ PEX_PUSH_LOCK PushLock, _In_ PVOID WaitBlock);

LPCSTR
ImpPsGetProcessImageFileName(PEPROCESS Process);

INT
ImpStrStr(_In_ CHAR* haystack, _In_ CHAR* needle);

void
ImpRtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);

NTSTATUS
ImpRtlQueryRegistryValues(ULONG                     RelativeTo,
                          PCWSTR                    Path,
                          PRTL_QUERY_REGISTRY_TABLE QueryTable,
                          void*                     Context,
                          void*                     Environment);

void*
ImpMmGetSystemRoutineAddress(PUNICODE_STRING SystemRoutineName);

NTSTATUS
ImpRtlUnicodeStringToAnsiString(PANSI_STRING     DestinationString,
                                PCUNICODE_STRING SourceString,
                                BOOLEAN          AllocateDestinationString);

void
ImpRtlCopyUnicodeString(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString);

void
ImpRtlFreeAnsiString(PANSI_STRING AnsiString);

void
ImpKeInitializeGuardedMutex(PKGUARDED_MUTEX GuardedMutex);

NTSTATUS
ImpIoCreateDevice(PDRIVER_OBJECT  DriverObject,
                  ULONG           DeviceExtensionSize,
                  PUNICODE_STRING DeviceName,
                  DEVICE_TYPE     DeviceType,
                  ULONG           DeviceCharacteristics,
                  BOOLEAN         Exclusive,
                  PDEVICE_OBJECT* DeviceObject);

NTSTATUS
ImpIoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName, PUNICODE_STRING DeviceName);

void
ImpIoDeleteDevice(PDEVICE_OBJECT DeviceObject);

void
ImpIoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName);

NTSTATUS
ImpObRegisterCallbacks(_In_ POB_CALLBACK_REGISTRATION CallbackRegistration,
                       _Out_ PVOID*                   RegistrationHandle);

VOID
ImpObUnRegisterCallbacks(_In_ PVOID RegistrationHandle);

NTSTATUS
ImpPsSetCreateThreadNotifyRoutine(PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine);

void
ImpKeRevertToUserAffinityThreadEx(KAFFINITY Affinity);

KAFFINITY
ImpKeSetSystemAffinityThreadEx(KAFFINITY Affinity);

SIZE_T
ImpStrnlen(_In_ CHAR* str, _In_ SIZE_T maxCount);

void
ImpRtlInitAnsiString(PANSI_STRING DestinationString, PCSZ SourceString);

NTSTATUS
ImpRtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString,
                                PCANSI_STRING   SourceString,
                                BOOLEAN         AllocateDestinationString);

PEPROCESS
ImpIoGetCurrentProcess(void);

NTSTATUS
ImpRtlGetVersion(PRTL_OSVERSIONINFOW lpVersionInformation);

SIZE_T
ImpRtlCompareMemory(_In_ PVOID Source1, _In_ PVOID Source2, _In_ SIZE_T Length);

NTSTATUS
ImpExGetSystemFirmwareTable(_In_ ULONG   FirmwareTableProviderSignature,
                            _In_ ULONG   FirmwareTableID,
                            _In_ PVOID   pFirmwareTableBuffer,
                            _In_ ULONG   BufferLength,
                            _Out_ PULONG ReturnLength);

PIO_WORKITEM
ImpIoAllocateWorkItem(PDEVICE_OBJECT DeviceObject);

void
ImpIoFreeWorkItem(PIO_WORKITEM WorkItem);

VOID
ImpIoQueueWorkItem(_In_ PIO_WORKITEM         IoWorkItem,
                   _In_ PIO_WORKITEM_ROUTINE WorkerRoutine,
                   _In_ WORK_QUEUE_TYPE      QueueType,
                   _In_opt_ PVOID            Context);

NTSTATUS
ImpZwOpenFile(PHANDLE            FileHandle,
              ACCESS_MASK        DesiredAccess,
              POBJECT_ATTRIBUTES ObjectAttributes,
              PIO_STATUS_BLOCK   IoStatusBlock,
              ULONG              ShareAccess,
              ULONG              OpenOptions);

NTSTATUS
ImpZwClose(HANDLE Handle);

NTSTATUS
ImpZwCreateSection(PHANDLE            SectionHandle,
                   ACCESS_MASK        DesiredAccess,
                   POBJECT_ATTRIBUTES ObjectAttributes,
                   PLARGE_INTEGER     MaximumSize,
                   ULONG              SectionPageProtection,
                   ULONG              AllocationAttributes,
                   HANDLE             FileHandle);

NTSTATUS
ImpZwMapViewOfSection(_In_ HANDLE                SectionHandle,
                      _In_ HANDLE                ProcessHandle,
                      _Inout_ PVOID*             BaseAddress,
                      _In_ ULONG_PTR             ZeroBits,
                      _In_ SIZE_T                CommitSize,
                      _Inout_opt_ PLARGE_INTEGER SectionOffset,
                      _Inout_ PSIZE_T            ViewSize,
                      _In_ SECTION_INHERIT       InheritDisposition,
                      _In_ ULONG                 AllocationType,
                      _In_ ULONG                 Win32Protect);

NTSTATUS
ImpZwUnmapViewOfSection(_In_ HANDLE ProcessHandle, _In_ PVOID BaseAddress);

NTSTATUS
ImpMmCopyMemory(PVOID           TargetAddress,
                MM_COPY_ADDRESS SourceAddress,
                SIZE_T          NumberOfBytes,
                ULONG           Flags,
                PSIZE_T         NumberOfBytesTransferred);

NTSTATUS
ImpZwDeviceIoControlFile(_In_ HANDLE              FileHandle,
                         _In_opt_ HANDLE          Event,
                         _In_opt_ PIO_APC_ROUTINE ApcRoutine,
                         _In_opt_ PVOID           ApcContext,
                         _Out_ PIO_STATUS_BLOCK   IoStatusBlock,
                         _In_ ULONG               IoControlCode,
                         _In_opt_ PVOID           InputBuffer,
                         _In_ ULONG               InputBufferLength,
                         _Out_opt_ PVOID          OutputBuffer,
                         _In_ ULONG               OutputBufferLength);

void
ImpKeStackAttachProcess(PRKPROCESS Process, PKAPC_STATE ApcState);

void
ImpKeUnstackDetachProcess(PKAPC_STATE ApcState);

NTSTATUS
ImpKeWaitForSingleObject(_In_ PVOID           Object,
                         _In_ KWAIT_REASON    WaitReason,
                         _In_ KPROCESSOR_MODE WaitMode,
                         _In_ BOOLEAN         Alertable,
                         _In_ PLARGE_INTEGER  Timeout);

NTSTATUS
ImpPsCreateSystemThread(_Out_ PHANDLE               ThreadHandle,
                        _In_ ULONG                  DesiredAccess,
                        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
                        _In_opt_ HANDLE             ProcessHandle,
                        _Out_opt_ PCLIENT_ID        ClientId,
                        _In_ PKSTART_ROUTINE        StartRoutine,
                        _In_opt_ PVOID              StartContext);

void
ImpIofCompleteRequest(PIRP Irp, CCHAR PriorityBoost);

NTSTATUS
ImpObReferenceObjectByHandle(_In_ HANDLE                          Handle,
                             _In_ ACCESS_MASK                     DesiredAccess,
                             _In_opt_ POBJECT_TYPE                ObjectType,
                             _In_ KPROCESSOR_MODE                 AccessMode,
                             _Out_ PVOID*                         Object,
                             _Out_opt_ POBJECT_HANDLE_INFORMATION HandleInformation);

NTSTATUS
ImpKeDelayExecutionThread(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Interval);

PVOID
ImpKeRegisterNmiCallback(_In_ PVOID CallbackRoutine, _In_opt_ PVOID Context);

NTSTATUS
ImpKeDeregisterNmiCallback(_In_ PVOID Handle);

ULONG
ImpKeQueryActiveProcessorCount(PKAFFINITY ActiveProcessors);

void
ImpExAcquirePushLockExclusiveEx(PEX_PUSH_LOCK PushLock, ULONG Flags);

void
ImpExReleasePushLockExclusiveEx(PEX_PUSH_LOCK PushLock, ULONG Flags);

HANDLE
ImpPsGetThreadId(PETHREAD Thread);

USHORT
ImpRtlCaptureStackBackTrace(_In_ ULONG       FramesToSkip,
                            _In_ ULONG       FramesToCapture,
                            _Out_ PVOID*     BackTrace,
                            _Out_opt_ PULONG BackTraceHash);

NTSTATUS
ImpZwOpenDirectoryObject(PHANDLE            DirectoryHandle,
                         ACCESS_MASK        DesiredAccess,
                         POBJECT_ATTRIBUTES ObjectAttributes);

void
ImpKeInitializeAffinityEx(PKAFFINITY_EX AffinityMask);

VOID
ImpKeAddProcessorAffinityEx(_In_ PKAFFINITY_EX affinity, _In_ INT num);

NTSTATUS
ImpRtlQueryModuleInformation(_Inout_ ULONG* InformationLength,
                             _In_ ULONG     SizePerModule,
                             _In_ PVOID     InformationBuffer);

VOID
ImpKeInitializeApc(_In_ PKAPC             Apc,
                   _In_ PKTHREAD          Thread,
                   _In_ KAPC_ENVIRONMENT  Environment,
                   _In_ PKKERNEL_ROUTINE  KernelRoutine,
                   _In_ PKRUNDOWN_ROUTINE RundownRoutine,
                   _In_ PKNORMAL_ROUTINE  NormalRoutine,
                   _In_ KPROCESSOR_MODE   ApcMode,
                   _In_ PVOID             NormalContext);

BOOLEAN
ImpKeInsertQueueApc(_In_ PKAPC     Apc,
                    _In_ PVOID     SystemArgument1,
                    _In_ PVOID     SystemArgument2,
                    _In_ KPRIORITY Increment);

VOID
ImpKeGenericCallDpc(_In_ PKDEFERRED_ROUTINE DpcRoutine, _In_ PVOID Context);

VOID
ImpKeSignalCallDpcDone(_In_ PVOID SystemArgument1);

PPHYSICAL_MEMORY_RANGE
ImpMmGetPhysicalMemoryRangesEx2(_In_ PVOID PartitionObject, _In_ ULONG Flags);

void*
ImpMmGetVirtualForPhysical(_In_ PHYSICAL_ADDRESS PhysicalAddress);

LONG_PTR
ImpObfReferenceObject(_In_ PVOID Object);

VOID
ImpExFreePoolWithTag(_In_ PVOID P, _In_ ULONG Tag);

void*
ImpExAllocatePool2(_In_ POOL_FLAGS Flags, _In_ SIZE_T NumberOfBytes, _In_ ULONG Tag);

VOID
ImpKeReleaseGuardedMutex(_In_ PKGUARDED_MUTEX GuardedMutex);

VOID
ImpKeAcquireGuardedMutex(_In_ PKGUARDED_MUTEX GuardedMutex);

ULONG
ImpDbgPrintEx(_In_ ULONG ComponentId, _In_ ULONG Level, _In_ PCSTR Format, ...);

LONG
ImpRtlCompareUnicodeString(_In_ PCUNICODE_STRING String1,
                           _In_ PCUNICODE_STRING String2,
                           _In_ BOOLEAN          CaseInSensitive);

VOID
ImpRtlFreeUnicodeString(_In_ PUNICODE_STRING UnicodeString);

#endif
```

`driver/integrity.c`:

```c
#include "integrity.h"

#include "common.h"
#include "driver.h"
#include "modules.h"
#include "callbacks.h"
#include "io.h"
#include "imports.h"
#include "session.h"

#include <bcrypt.h>
#include <initguid.h>
#include <devpkey.h>

typedef struct _INTEGRITY_CHECK_HEADER {
    INT  executable_section_count;
    LONG total_packet_size;

} INTEGRITY_CHECK_HEADER, *PINTEGRITY_CHECK_HEADER;

typedef struct _PROCESS_MODULE_INFORMATION {
    PVOID  module_base;
    SIZE_T module_size;
    WCHAR  module_path[MAX_MODULE_PATH];

} PROCESS_MODULE_INFORMATION, *PPROCESS_MODULE_INFORMATION;

typedef struct _PROCESS_MODULE_VALIDATION_RESULT {
    INT is_module_valid;

} PROCESS_MODULE_VALIDATION_RESULT, *PPROCESS_MODULE_VALIDATION_RESULT;

STATIC
NTSTATUS
InitiateEptFunctionAddressArrays();

STATIC
NTSTATUS
GetModuleInformationByName(_Out_ PRTL_MODULE_EXTENDED_INFO ModuleInfo,
                           _In_ LPCSTR                     ModuleName);

STATIC
NTSTATUS
StoreModuleExecutableRegionsInBuffer(_Outptr_result_bytebuffer_(*BytesWritten)
                                         PVOID*   Buffer,
                                     _In_ PVOID   ModuleBase,
                                     _In_ SIZE_T  ModuleSize,
                                     _Out_        _Deref_out_range_(>, 0)
                                         PSIZE_T  BytesWritten,
                                     _In_ BOOLEAN IsModulex86);

STATIC
NTSTATUS
MapDiskImageIntoVirtualAddressSpace(_Inout_ PHANDLE SectionHandle,
                                    _Outptr_result_bytebuffer_(*Size)
                                        PVOID*           Section,
                                    _In_ PUNICODE_STRING Path,
                                    _Out_ _Deref_out_range_(>, 0) PSIZE_T Size);

STATIC
NTSTATUS
ComputeHashOfBuffer(_In_ PVOID Buffer,
                    _In_ ULONG BufferSize,
                    _Outptr_result_bytebuffer_(*HashResultSize)
                        PVOID* HashResult,
                    _Out_ _Deref_out_range_(>, 0) PULONG HashResultSize);

STATIC
VOID
GetNextSMBIOSStructureInTable(_Inout_ PSMBIOS_TABLE_HEADER* CurrentStructure);

STATIC
NTSTATUS
GetStringAtIndexFromSMBIOSTable(_In_ PSMBIOS_TABLE_HEADER Table,
                                _In_ INT                  Index,
                                _In_ PVOID                Buffer,
                                _In_ SIZE_T               BufferSize);

STATIC
NTSTATUS
GetAverageReadTimeAtRoutine(_In_ PVOID    RoutineAddress,
                            _Out_ PUINT64 AverageTime);

#ifdef ALLOC_PRAGMA
#    pragma alloc_text(PAGE, GetDriverImageSize)
#    pragma alloc_text(PAGE, GetModuleInformationByName)
#    pragma alloc_text(PAGE, StoreModuleExecutableRegionsInBuffer)
#    pragma alloc_text(PAGE, MapDiskImageIntoVirtualAddressSpace)
#    pragma alloc_text(PAGE, ComputeHashOfBuffer)
// #        pragma alloc_text(PAGE, VerifyInMemoryImageVsDiskImage)
#    pragma alloc_text(PAGE, RetrieveInMemoryModuleExecutableSections)
#    pragma alloc_text(PAGE, GetNextSMBIOSStructureInTable)
#    pragma alloc_text(PAGE, GetStringAtIndexFromSMBIOSTable)
#    pragma alloc_text(PAGE, ParseSMBIOSTable)
#    pragma alloc_text(PAGE, ValidateProcessLoadedModule)
#    pragma alloc_text(PAGE, GetHardDiskDriveSerialNumber)
#    pragma alloc_text(PAGE, ScanForSignature)
#    pragma alloc_text(PAGE, InitiateEptFunctionAddressArrays)
#    pragma alloc_text(PAGE, DetectEptHooksInKeyFunctions)
// #pragma alloc_text(PAGE, DetermineIfTestSigningIsEnabled)
#endif

/*
 * note: this can be put into its own function wihtout an IRP as argument then
 * it can be used in both the get driver image ioctl handler and the
 * CopyDriverExecvutableRegions func
 */
NTSTATUS
GetDriverImageSize(_Inout_ PIRP Irp)
{
    PAGED_CODE();

    NTSTATUS                  status      = STATUS_UNSUCCESSFUL;
    LPCSTR                    driver_name = GetDriverName();
    SYSTEM_MODULES            modules     = {0};
    PRTL_MODULE_EXTENDED_INFO driver_info = NULL;

    status = GetSystemModuleInformation(&modules);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetSystemModuleInformation failed with status %x", status);
        return status;
    }

    driver_info = FindSystemModuleByName(driver_name, &modules);

    if (!driver_info) {
        DEBUG_ERROR("FindSystemModuleByName failed with no status code");
        ImpExFreePoolWithTag(modules.address, SYSTEM_MODULES_POOL);
        return STATUS_NOT_FOUND;
    }

    status = ValidateIrpOutputBuffer(Irp, sizeof(ULONG));

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ValidateIrpOutputBuffer failed with status %x", status);
        goto end;
    }

    Irp->IoStatus.Information = sizeof(ULONG);
    RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer,
                  &driver_info->ImageSize,
                  sizeof(ULONG));

end:

    if (modules.address)
        ImpExFreePoolWithTag(modules.address, SYSTEM_MODULES_POOL);

    return status;
}

STATIC
NTSTATUS
GetModuleInformationByName(_Out_ PRTL_MODULE_EXTENDED_INFO ModuleInfo,
                           _In_ LPCSTR                     ModuleName)
{
    PAGED_CODE();

    NTSTATUS                  status      = STATUS_UNSUCCESSFUL;
    LPCSTR                    driver_name = GetDriverName();
    SYSTEM_MODULES            modules     = {0};
    PRTL_MODULE_EXTENDED_INFO driver_info = NULL;

    status = GetSystemModuleInformation(&modules);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetSystemModuleInformation failed with status %x", status);
        return status;
    }

    driver_info = FindSystemModuleByName(driver_name, &modules);

    if (!driver_info) {
        DEBUG_ERROR("FindSystemModuleByName failed with no status");
        ImpExFreePoolWithTag(modules.address, SYSTEM_MODULES_POOL);
        return STATUS_NOT_FOUND;
    }

    ModuleInfo->FileNameOffset = driver_info->FileNameOffset;
    ModuleInfo->ImageBase      = driver_info->ImageBase;
    ModuleInfo->ImageSize      = driver_info->ImageSize;

    RtlCopyMemory(ModuleInfo->FullPathName,
                  driver_info->FullPathName,
                  sizeof(ModuleInfo->FullPathName));

    if (modules.address)
        ImpExFreePoolWithTag(modules.address, SYSTEM_MODULES_POOL);

    return status;
}

#define PE_TYPE_32_BIT 0x10b

STATIC
NTSTATUS
StoreModuleExecutableRegionsInBuffer(_Outptr_result_bytebuffer_(*BytesWritten)
                                         PVOID*   Buffer,
                                     _In_ PVOID   ModuleBase,
                                     _In_ SIZE_T  ModuleSize,
                                     _Out_        _Deref_out_range_(>, 0)
                                         PSIZE_T  BytesWritten,
                                     _In_ BOOLEAN IsModulex86)
{
    PAGED_CODE();

    NTSTATUS              status                  = STATUS_UNSUCCESSFUL;
    PIMAGE_DOS_HEADER     dos_header              = NULL;
    PLOCAL_NT_HEADER      nt_header               = NULL;
    PIMAGE_SECTION_HEADER section                 = NULL;
    ULONG                 total_packet_size       = 0;
    ULONG                 num_sections            = 0;
    ULONG                 num_executable_sections = 0;
    UINT64                buffer_base             = 0;
    ULONG                 bytes_returned          = 0;
    MM_COPY_ADDRESS       address                 = {0};
    ULONG                 buffer_size             = 0;

    if (!ModuleBase || !ModuleSize)
        return STATUS_INVALID_PARAMETER;

    /*
     * The reason we allocate a buffer to temporarily hold the section data
     * is that we don't know the total size until after we iterate over the
     * sections meaning we cant set Irp->IoStatus.Information to the size of
     * our reponse until we enumerate and count all executable sections for
     * the file.
     */
    buffer_size = ModuleSize + sizeof(INTEGRITY_CHECK_HEADER);

    *BytesWritten = 0;
    *Buffer       = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, buffer_size, POOL_TAG_INTEGRITY);

    if (*Buffer == NULL)
        return STATUS_MEMORY_NOT_ALLOCATED;

    /*
     * Note: Verifier doesn't like it when we map the module so rather then
     * mapping it to our address space we will simply use MmCopyMemory on
     * the module to avoid upsetting verifier
     * :)
     */
    dos_header = (PIMAGE_DOS_HEADER)ModuleBase;

    if (!MmIsAddressValid(dos_header) && !IsModulex86) {
        ImpExFreePoolWithTag(*Buffer, POOL_TAG_INTEGRITY);
        *Buffer = NULL;
        return STATUS_INVALID_ADDRESS;
    }

    /*
     * The IMAGE_DOS_HEADER.e_lfanew stores the offset of the
     * IMAGE_NT_HEADER from the base of the image.
     */
    nt_header = (struct _IMAGE_NT_HEADERS64*)((UINT64)ModuleBase +
                                              dos_header->e_lfanew);

    num_sections = nt_header->FileHeader.NumberOfSections;

    /*
     * The IMAGE_FIRST_SECTION macro takes in an IMAGE_NT_HEADER and returns
     * the address of the first section of the PE file.
     */
    section     = IMAGE_FIRST_SECTION(nt_header);
    buffer_base = (UINT64)*Buffer + sizeof(INTEGRITY_CHECK_HEADER);

    for (ULONG index = 0; index < num_sections - 1; index++) {
        if (!(section->Characteristics & IMAGE_SCN_MEM_EXECUTE)) {
            section++;
            continue;
        }

        address.VirtualAddress = section;

        status = ImpMmCopyMemory((UINT64)buffer_base + total_packet_size,
                                 address,
                                 sizeof(IMAGE_SECTION_HEADER),
                                 MM_COPY_MEMORY_VIRTUAL,
                                 &bytes_returned);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("MmCopyMemory failed with status %x", status);
            ImpExFreePoolWithTag(*Buffer, POOL_TAG_INTEGRITY);
            *Buffer = NULL;
            return status;
        }

        address.VirtualAddress = (UINT64)ModuleBase + section->PointerToRawData;

        status = ImpMmCopyMemory((UINT64)buffer_base + total_packet_size +
                                     sizeof(IMAGE_SECTION_HEADER),
                                 address,
                                 section->SizeOfRawData,
                                 MM_COPY_MEMORY_VIRTUAL,
                                 &bytes_returned);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("MmCopyMemory failed with status %x", status);
            ImpExFreePoolWithTag(*Buffer, POOL_TAG_INTEGRITY);
            *Buffer = NULL;
            return status;
        }

        total_packet_size +=
            section->SizeOfRawData + sizeof(IMAGE_SECTION_HEADER);
        num_executable_sections += 1;
        section++;
    }

    INTEGRITY_CHECK_HEADER header   = {0};
    header.executable_section_count = num_executable_sections;
    header.total_packet_size =
        total_packet_size + sizeof(INTEGRITY_CHECK_HEADER);

    RtlCopyMemory(*Buffer, &header, sizeof(INTEGRITY_CHECK_HEADER));
    *BytesWritten = total_packet_size + sizeof(INTEGRITY_CHECK_HEADER);
    return status;
}

STATIC
NTSTATUS
MapDiskImageIntoVirtualAddressSpace(_Inout_ PHANDLE SectionHandle,
                                    _Outptr_result_bytebuffer_(*Size)
                                        PVOID*           Section,
                                    _In_ PUNICODE_STRING Path,
                                    _Out_ _Deref_out_range_(>, 0) PSIZE_T Size)
{
    PAGED_CODE();

    NTSTATUS          status            = STATUS_UNSUCCESSFUL;
    HANDLE            file_handle       = NULL;
    OBJECT_ATTRIBUTES object_attributes = {0};
    PIO_STATUS_BLOCK  pio_block         = NULL;
    UNICODE_STRING    path              = {0};

    *Section = NULL;
    *Size    = 0;

    ImpRtlInitUnicodeString(&path, Path->Buffer);

    InitializeObjectAttributes(
        &object_attributes, &path, OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ImpZwOpenFile(
        &file_handle, GENERIC_READ, &object_attributes, &pio_block, NULL, NULL);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ZwOpenFile failed with status %x", status);
        return status;
    }

    object_attributes.ObjectName = NULL;

    /*
     * Its important that we set the SEC_IMAGE flag with the PAGE_READONLY
     * flag as we are mapping an executable image.
     */
    status = ImpZwCreateSection(SectionHandle,
                                SECTION_ALL_ACCESS,
                                &object_attributes,
                                NULL,
                                PAGE_READONLY,
                                SEC_IMAGE,
                                file_handle);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ZwCreateSection failed with status %x", status);
        ImpZwClose(file_handle);
        *SectionHandle = NULL;
        return status;
    }

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ObReferenceObjectByHandle failed with status %x", status);
        return status;
    }
    /*
     * Mapping a section with the flag SEC_IMAGE (see function above) tells
     * the os we are mapping an executable image. This then allows the OS to
     * take care of parsing the PE header and dealing with all relocations
     * for us, meaning the mapped image will be identical to the in memory
     * image.
     */
    status = ImpZwMapViewOfSection(*SectionHandle,
                                   ZwCurrentProcess(),
                                   Section,
                                   NULL,
                                   NULL,
                                   NULL,
                                   Size,
                                   ViewUnmap,
                                   MEM_TOP_DOWN,
                                   PAGE_READONLY);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ZwMapViewOfSection failed with status %x", status);
        ImpZwClose(file_handle);
        ImpZwClose(*SectionHandle);
        *SectionHandle = NULL;
        return status;
    }

    ImpZwClose(file_handle);
    return status;
}

STATIC
NTSTATUS
ComputeHashOfBuffer(_In_ PVOID Buffer,
                    _In_ ULONG BufferSize,
                    _Outptr_result_bytebuffer_(*HashResultSize)
                        PVOID* HashResult,
                    _Out_ _Deref_out_range_(>, 0) PULONG HashResultSize)
{
    PAGED_CODE();

    NTSTATUS           status              = STATUS_UNSUCCESSFUL;
    BCRYPT_ALG_HANDLE  algo_handle         = NULL;
    BCRYPT_HASH_HANDLE hash_handle         = NULL;
    ULONG              bytes_copied        = 0;
    ULONG              resulting_hash_size = 0;
    ULONG              hash_object_size    = 0;
    PCHAR              hash_object         = NULL;
    PCHAR              resulting_hash      = NULL;

    *HashResult     = NULL;
    *HashResultSize = 0;

    status = BCryptOpenAlgorithmProvider(
        &algo_handle, BCRYPT_SHA256_ALGORITHM, NULL, BCRYPT_PROV_DISPATCH);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("BCryptOpenAlogrithmProvider failed with status %x",
                    status);
        goto end;
    }

    /*
     * Request the size of the hash object buffer, this is different then
     * the buffer that will store the resulting hash, instead this will be
     * used to store the hash object used to create the hash.
     */
    status = BCryptGetProperty(algo_handle,
                               BCRYPT_OBJECT_LENGTH,
                               (PCHAR)&hash_object_size,
                               sizeof(ULONG),
                               &bytes_copied,
                               NULL);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("BCryptGetProperty failed with status %x", status);
        goto end;
    }

    hash_object = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, hash_object_size, POOL_TAG_INTEGRITY);

    if (!hash_object) {
        status = STATUS_MEMORY_NOT_ALLOCATED;
        goto end;
    }

    /*
     * This call gets the size of the resulting hash, which we will use to
     * allocate the resulting hash buffer.
     */
    status = BCryptGetProperty(algo_handle,
                               BCRYPT_HASH_LENGTH,
                               (PCHAR)&resulting_hash_size,
                               sizeof(ULONG),
                               &bytes_copied,
                               NULL);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("BCryptGetProperty failed with status %x", status);
        goto end;
    }

    resulting_hash = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, resulting_hash_size, POOL_TAG_INTEGRITY);

    if (!resulting_hash) {
        status = STATUS_MEMORY_NOT_ALLOCATED;
        goto end;
    }

    /*
     * Here we create our hash object and store it in the hash_object
     * buffer.
     */
    status = BCryptCreateHash(algo_handle,
                              &hash_handle,
                              hash_object,
                              hash_object_size,
                              NULL,
                              NULL,
                              NULL);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("BCryptCreateHash failed with status %x", status);
        goto end;
    }

    /*
     * This function hashes the buffer, but does NOT store it in our
     * resulting buffer yet, we need to call BCryptFinishHash to retrieve
     * the final hash.
     */
    status = BCryptHashData(hash_handle, Buffer, BufferSize, NULL);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("BCryptHashData failed with status %x", status);
        goto end;
    }

    /*
     * As said in the previous comment, this is where we retrieve the final
     * hash and store it in our output buffer.
     */
    status = BCryptFinishHash(
        hash_handle, resulting_hash, resulting_hash_size, NULL);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("BCryptFinishHash failed with status %x", status);
        goto end;
    }

    *HashResult     = resulting_hash;
    *HashResultSize = resulting_hash_size;

end:

    if (algo_handle)
        BCryptCloseAlgorithmProvider(algo_handle, NULL);

    if (hash_handle)
        BCryptDestroyHash(hash_handle);

    if (hash_object)
        ImpExFreePoolWithTag(hash_object, POOL_TAG_INTEGRITY);

    return status;
}

NTSTATUS
RetrieveInMemoryModuleExecutableSections(_Inout_ PIRP Irp)
{
    PAGED_CODE();

    NTSTATUS                 status        = STATUS_UNSUCCESSFUL;
    SIZE_T                   bytes_written = NULL;
    PVOID                    buffer        = NULL;
    RTL_MODULE_EXTENDED_INFO module_info   = {0};
    LPCSTR                   driver_name   = GetDriverName();

    status = GetModuleInformationByName(&module_info, driver_name);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetModuleInformationByName failed with status %x", status);
        return status;
    }

    status = StoreModuleExecutableRegionsInBuffer(&buffer,
                                                  module_info.ImageBase,
                                                  module_info.ImageSize,
                                                  &bytes_written,
                                                  FALSE);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("StoreModuleExecutableRegionsInBuffe failed with status %x",
                    status);
        return status;
    }

    status = ValidateIrpOutputBuffer(Irp, bytes_written);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ValidateIrpOutputBuffer failed with status %x", status);
        goto end;
    }

    Irp->IoStatus.Information = bytes_written;
    RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer, buffer, bytes_written);

end:
    if (buffer)
        ImpExFreePoolWithTag(buffer, POOL_TAG_INTEGRITY);

    return status;
}
#define SMBIOS_TABLE    'RSMB'
#define NULL_TERMINATOR '\0'
/*
 * From line 727 in the SMBIOS Specification:
 *
 *    727 • Each structure shall be terminated by a double-null (0000h), either
 * directly following the 728   formatted area (if no strings are present) or
 * directly following the last string. This includes 729   system- and
 * OEM-specific structures and allows upper-level software to easily traverse
 * the 730   structure table. (See structure-termination examples later in this
 * clause.)
 *
 * TLDR is that if the first two characters proceeding the structure are null
 * terminators, then there are no strings, otherwise to find the end of the
 * string section simply iterate until there is a double null terminator.
 *
 * source:
 * https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_2.7.1.pdf
 */
STATIC
VOID
GetNextSMBIOSStructureInTable(_Inout_ PSMBIOS_TABLE_HEADER* CurrentStructure)
{
    PAGED_CODE();

    PCHAR string_section_start =
        (PCHAR)((UINT64)*CurrentStructure + (*CurrentStructure)->Length);

    PCHAR current_char_in_strings = string_section_start;
    PCHAR next_char_in_strings    = string_section_start + 1;

    for (;;) {
        if (*current_char_in_strings == NULL_TERMINATOR &&
            *next_char_in_strings == NULL_TERMINATOR) {
            *CurrentStructure =
                (PSMBIOS_TABLE_HEADER)(next_char_in_strings + 1);
            return;
        }

        current_char_in_strings++;
        next_char_in_strings++;
    }
}

/*
 * Remember that the string index does not start from the beginning of the
 * struct. For example, lets take RAW_SMBIOS_TABLE_02: the first string is NOT
 * "Type" at index 0, the first string is Manufacturer. So if we want to find
 * the SerialNumber, the string index would be 4, as the previous 3 values
 * (after the header) are all strings. So remember, the index is into the number
 * of strings that exist for the given table, NOT the size of the structure or a
 * values index into the struct.
 *
 * Here we count the number of strings by incrementing the string_count each
 * time we pass a null terminator so we know when we're at the beginning of the
 * target string.
 */
STATIC
NTSTATUS
GetStringAtIndexFromSMBIOSTable(_In_ PSMBIOS_TABLE_HEADER Table,
                                _In_ INT                  Index,
                                _In_ PVOID                Buffer,
                                _In_ SIZE_T               BufferSize)
{
    PAGED_CODE();

    INT   current_string_char_index = 0;
    INT   string_count              = 0;
    PCHAR current_string_char       = (PCHAR)((UINT64)Table + Table->Length);
    PCHAR next_string_char          = current_string_char + 1;

    for (;;) {
        if (*current_string_char == NULL_TERMINATOR &&
            *next_string_char == NULL_TERMINATOR)
            return STATUS_NOT_FOUND;

        if (current_string_char_index >= BufferSize)
            return STATUS_BUFFER_TOO_SMALL;

        if (string_count + 1 == Index) {
            if (*current_string_char == NULL_TERMINATOR)
                return STATUS_SUCCESS;

            UINT64 dest = (UINT64)Buffer + current_string_char_index;

            RtlCopyMemory(dest, current_string_char, sizeof(CHAR));
            current_string_char_index++;
            goto increment;
        }

        if (*current_string_char == NULL_TERMINATOR) {
            current_string_char_index = 0;
            string_count++;
        }

    increment:
        current_string_char++;
        next_string_char++;
    }

    return STATUS_NOT_FOUND;
}

/* for generic intel */
// #define SMBIOS_SYSTEM_INFORMATION_TYPE_2_TABLE 2
// #define MOTHERBOARD_SERIAL_CODE_TABLE_INDEX    4

/* for testing purposes in vmware */
// #define VMWARE_SMBIOS_TABLE       1
// #define VMWARE_SMBIOS_TABLE_INDEX 3

NTSTATUS
ParseSMBIOSTable(_Out_ PVOID             Buffer,
                 _In_ SIZE_T             BufferSize,
                 _In_ SMBIOS_TABLE_INDEX TableIndex,
                 _In_ ULONG              TableSubIndex)
{
    PAGED_CODE();

    NTSTATUS             status                       = STATUS_UNSUCCESSFUL;
    PVOID                firmware_table_buffer        = NULL;
    ULONG                firmware_table_buffer_size   = 0;
    ULONG                bytes_returned               = 0;
    PRAW_SMBIOS_DATA     smbios_data                  = NULL;
    PSMBIOS_TABLE_HEADER smbios_table_header          = NULL;
    PRAW_SMBIOS_TABLE_01 smbios_baseboard_information = NULL;

    status = ImpExGetSystemFirmwareTable(
        SMBIOS_TABLE, 0, NULL, 0, &firmware_table_buffer_size);

    /*
     * Because we pass a null buffer here, the NTSTATUS result will be a
     * BUFFER_TOO_SMALL error, so to validate this function call we check
     * the return bytes returned (which indicate required buffer size) is
     * above 0.
     */
    if (firmware_table_buffer_size == NULL) {
        DEBUG_ERROR(
            "ExGetSystemFirmwareTable call 1 failed to get required buffer size.");
        return STATUS_BUFFER_TOO_SMALL;
    }

    firmware_table_buffer = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, firmware_table_buffer_size, POOL_TAG_INTEGRITY);

    if (!firmware_table_buffer)
        return STATUS_MEMORY_NOT_ALLOCATED;

    status = ImpExGetSystemFirmwareTable(SMBIOS_TABLE,
                                         NULL,
                                         firmware_table_buffer,
                                         firmware_table_buffer_size,
                                         &bytes_returned);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ExGetSystemFirmwareTable call 2 failed with status %x",
                    status);
        goto end;
    }

    smbios_data = (PRAW_SMBIOS_DATA)firmware_table_buffer;
    smbios_table_header =
        (PSMBIOS_TABLE_HEADER)(&smbios_data->SMBIOSTableData[0]);

    /*
     * The System Information table is equal to Type == 2 and contains the
     * serial number of the motherboard in the computer among various other
     * things.
     *
     * source:
     * https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_2.7.1.pdf
     * line 823
     */
    while (smbios_table_header->Type != TableIndex)
        GetNextSMBIOSStructureInTable(&smbios_table_header);

    status = GetStringAtIndexFromSMBIOSTable(
        smbios_table_header, TableSubIndex, Buffer, BufferSize);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetStringAtIndexFromSMBIOSTable failed with status %x",
                    status);
        goto end;
    }

end:

    if (firmware_table_buffer)
        ImpExFreePoolWithTag(firmware_table_buffer, POOL_TAG_INTEGRITY);

    return status;
}

STATIC
NTSTATUS
ComputeHashOfSections(_In_ PIMAGE_SECTION_HEADER DiskSection,
                      _In_ PIMAGE_SECTION_HEADER MemorySection,
                      _Out_ PVOID*               DiskHash,
                      _Out_ PULONG               DiskHashSize,
                      _Out_ PVOID*               MemoryHash,
                      _Out_ PULONG               MemoryHashSize)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    if (DiskSection->SizeOfRawData != MemorySection->SizeOfRawData) {
        DEBUG_WARNING("Executable section sizes differ between images.");
        return STATUS_INVALID_BUFFER_SIZE;
    }

    status =
        ComputeHashOfBuffer((UINT64)DiskSection + sizeof(IMAGE_SECTION_HEADER),
                            DiskSection->SizeOfRawData,
                            DiskHash,
                            DiskHashSize);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ComputeHashOfBuffer failed with status %x", status);
        return status;
    }

    status = ComputeHashOfBuffer((UINT64)MemorySection +
                                     sizeof(IMAGE_SECTION_HEADER),
                                 MemorySection->SizeOfRawData,
                                 MemoryHash,
                                 MemoryHashSize);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ComputeHashOfBuffer 2 failed with status %x", status);
        return status;
    }

    return status;
}

STATIC
BOOLEAN
CompareHashes(_In_ PVOID Hash1, _In_ PVOID Hash2, _In_ UINT32 Length)
{
    if (RtlCompareMemory(Hash1, Hash2, Length) == Length)
        return TRUE;
    else
        return FALSE;
}

typedef struct _VAL_INTEGRITY_HEADER {
    INTEGRITY_CHECK_HEADER integrity_check_header;
    IMAGE_SECTION_HEADER   section_header;
    CHAR                   section_base[];

} VAL_INTEGRITY_HEADER, *PVAL_INTEGRITY_HEADER;

STATIC
VOID
ReportInvalidProcessModule(_In_ PPROCESS_MODULE_INFORMATION Module)
{
    PPROCESS_MODULE_VALIDATION_REPORT report =
        ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                           sizeof(PROCESS_MODULE_VALIDATION_REPORT),
                           REPORT_POOL_TAG);

    if (!report)
        return;

    report->report_code = REPORT_INVALID_PROCESS_MODULE;
    report->image_base  = Module->module_base;
    report->image_size  = Module->module_size;
    RtlCopyMemory(
        report->module_path, Module->module_path, sizeof(report->module_path));

    IrpQueueCompleteIrp(report, sizeof(PROCESS_MODULE_VALIDATION_REPORT));
}

/*
 * Because the infrastructure has already been setup to validate modules in the
 * driver, that is how I will validate the usermode modules as well. Another
 * reason is that the win32 api makes it very easy to take a snapshot of the
 * modules and enumerate them with easy to use functions and macros.
 *
 * 1. Take a snapshot of the modules in the process from our dll
 * 2. pass the image base, image size and the image path to our driver via an
 * IRP
 * 3. from our driver, to first verify the in memory module, attach to our
 * protected process and using the base + size simply use
 * StoreModuleExecutableRegionsInBuffer()
 * 4. Next we use the path to map the image on disk into memory, and pass the
 * image to StoreModuleExecutableRegionsInBuffer() just as we did before.
 * 5. With the 2 buffers that contain both images executable regions, we hash
 * them and compare for anomalies.
 *
 * note: Its important to realise that since these are user mode modules, they
 * are often hooked by various legitimate programs - such as discord, nvidia
 * etc. So this needs to be rethinked.
 */
NTSTATUS
ValidateProcessLoadedModule(_Inout_ PIRP Irp)
{
    PAGED_CODE();

    NTSTATUS                         status            = STATUS_UNSUCCESSFUL;
    PROCESS_MODULE_VALIDATION_RESULT validation_result = {0};
    PPROCESS_MODULE_INFORMATION      module_info       = NULL;
    PKPROCESS                        process           = NULL;
    KAPC_STATE                       apc_state         = {0};
    PVAL_INTEGRITY_HEADER            memory_buffer     = NULL;
    PVAL_INTEGRITY_HEADER            disk_buffer       = NULL;
    PVOID                            memory_hash       = NULL;
    PVOID                            disk_hash         = NULL;
    ULONG                            memory_hash_size  = 0;
    ULONG                            disk_hash_size    = 0;
    SIZE_T                           bytes_written     = 0;
    UNICODE_STRING                   module_path       = {0};
    HANDLE                           section_handle    = NULL;
    PVOID                            section           = NULL;
    ULONG                            section_size      = 0;

    status = ValidateIrpInputBuffer(Irp, sizeof(PROCESS_MODULE_INFORMATION));

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ValidateIrpInputBuffer failed with status %x", status);
        return status;
    }

    module_info = (PPROCESS_MODULE_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

    SessionGetProcess(&process);
    ImpRtlInitUnicodeString(&module_path, &module_info->module_path);

    /*
     * Attach because the offsets given are from the process' context.
     */
    ImpKeStackAttachProcess(process, &apc_state);

    status = StoreModuleExecutableRegionsInBuffer(&memory_buffer,
                                                  module_info->module_base,
                                                  module_info->module_size,
                                                  &bytes_written,
                                                  FALSE);

    ImpKeUnstackDetachProcess(&apc_state);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR(
            "StoreModuleExecutableRegionsInBuffer failed with status %x",
            status);
        goto end;
    }

    status = MapDiskImageIntoVirtualAddressSpace(
        &section_handle, &section, &module_path, &section_size, 0);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("MapDiskImageIntoVirtualAddressSpace failed with status %x",
                    status);
        goto end;
    }

    status = StoreModuleExecutableRegionsInBuffer(
        &disk_buffer, section, section_size, &bytes_written, FALSE);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR(
            "StoreModuleExecutableRegionsInbuffer 2 failed with status %x",
            status);
        goto end;
    }

    status = ComputeHashOfSections(&memory_buffer->section_header,
                                   &disk_buffer->section_header,
                                   &disk_hash,
                                   &disk_hash_size,
                                   &memory_hash,
                                   &memory_hash_size);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ComputeHashOfSections failed with status %x", status);
        goto end;
    }

    if (!CompareHashes(disk_hash, memory_hash, memory_hash_size))
        ReportInvalidProcessModule(module_info);

end:

    if (section_handle)
        ImpZwClose(section_handle);

    if (section)
        ImpZwUnmapViewOfSection(ZwCurrentProcess(), section);

    if (memory_buffer)
        ImpExFreePoolWithTag(memory_buffer, POOL_TAG_INTEGRITY);

    if (memory_hash)
        ImpExFreePoolWithTag(memory_hash, POOL_TAG_INTEGRITY);

    if (disk_buffer)
        ImpExFreePoolWithTag(disk_buffer, POOL_TAG_INTEGRITY);

    if (disk_hash)
        ImpExFreePoolWithTag(disk_hash, POOL_TAG_INTEGRITY);

    return status;
}

/*
 * TODO: Query PhysicalDrive%n to get the serial numbers for all harddrives, can
 * use the command "wmic diskdrive" check in console.
 */
NTSTATUS
GetHardDiskDriveSerialNumber(_Inout_ PVOID ConfigDrive0Serial,
                             _In_ SIZE_T   ConfigDrive0MaxSize)
{
    PAGED_CODE();

    NTSTATUS                   status                    = STATUS_UNSUCCESSFUL;
    HANDLE                     handle                    = NULL;
    OBJECT_ATTRIBUTES          attributes                = {0};
    IO_STATUS_BLOCK            status_block              = {0};
    STORAGE_PROPERTY_QUERY     storage_property          = {0};
    STORAGE_DESCRIPTOR_HEADER  storage_descriptor_header = {0};
    PSTORAGE_DEVICE_DESCRIPTOR device_descriptor         = NULL;
    UNICODE_STRING             physical_drive_path       = {0};
    PCHAR                      serial_number             = NULL;
    SIZE_T                     serial_length             = 0;

    ImpRtlInitUnicodeString(&physical_drive_path,
                            L"\\DosDevices\\PhysicalDrive0");

    /*
     * No need to use the flag OBJ_FORCE_ACCESS_CHECK since we arent passing
     * a handle given to us from usermode.
     */
    InitializeObjectAttributes(&attributes,
                               &physical_drive_path,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    status = ImpZwOpenFile(
        &handle, GENERIC_READ, &attributes, &status_block, NULL, NULL);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ZwOpenFile on PhysicalDrive0 failed with status %x",
                    status);
        goto end;
    }

    storage_property.PropertyId = StorageDeviceProperty;
    storage_property.QueryType  = PropertyStandardQuery;

    status = ImpZwDeviceIoControlFile(handle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &status_block,
                                      IOCTL_STORAGE_QUERY_PROPERTY,
                                      &storage_property,
                                      sizeof(STORAGE_PROPERTY_QUERY),
                                      &storage_descriptor_header,
                                      sizeof(STORAGE_DESCRIPTOR_HEADER));

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ZwDeviceIoControlFile first call failed with status %x",
                    status);
        goto end;
    }

    device_descriptor = ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                                           storage_descriptor_header.Size,
                                           POOL_TAG_INTEGRITY);

    if (!device_descriptor) {
        status = STATUS_MEMORY_NOT_ALLOCATED;
        goto end;
    }

    status = ImpZwDeviceIoControlFile(handle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &status_block,
                                      IOCTL_STORAGE_QUERY_PROPERTY,
                                      &storage_property,
                                      sizeof(STORAGE_PROPERTY_QUERY),
                                      device_descriptor,
                                      storage_descriptor_header.Size);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ZwDeviceIoControlFile second call failed with status %x",
                    status);
        goto end;
    }

    if (!device_descriptor->SerialNumberOffset)
        goto end;

    serial_number = (PCHAR)((UINT64)device_descriptor +
                            device_descriptor->SerialNumberOffset);
    serial_length =
        strnlen_s(serial_number, DEVICE_DRIVE_0_SERIAL_CODE_LENGTH) + 1;

    if (serial_length > ConfigDrive0MaxSize) {
        status = STATUS_BUFFER_TOO_SMALL;
        goto end;
    }

    RtlCopyMemory(ConfigDrive0Serial, serial_number, serial_length);
end:

    if (handle)
        ImpZwClose(handle);

    if (device_descriptor)
        ImpExFreePoolWithTag(device_descriptor, POOL_TAG_INTEGRITY);

    return status;
}
PVOID
ScanForSignature(_In_ PVOID  BaseAddress,
                 _In_ SIZE_T MaxLength,
                 _In_ LPCSTR Signature,
                 _In_ SIZE_T SignatureLength)
{
    PAGED_CODE();

    CHAR current_char     = 0;
    CHAR current_sig_char = 0;

    for (INT index = 0; index < MaxLength; index++) {
        for (INT sig = 0; sig < SignatureLength + 1; sig++) {
            current_char     = *(PCHAR)((UINT64)BaseAddress + index + sig);
            current_sig_char = Signature[sig];

            if (sig == SignatureLength)
                return (PVOID)((UINT64)BaseAddress + index);

            if (current_char != current_sig_char)
                break;
        }
    }

    return NULL;
}

/*
 * Lets ensure to the compiler doens't optimise out our useless instructions...
 */
#pragma optimize("", off)

STATIC
UINT64
MeasureInstructionRead(_In_ PVOID InstructionAddress)
{
    CONST UINT64 start = __readmsr(IA32_APERF_MSR) << 32;
    CHAR         value = *(PCHAR)InstructionAddress;
    return (__readmsr(IA32_APERF_MSR) << 32) - start;
}

#pragma optimize("", on)

STATIC
UINT64
MeasureReads(_In_ PVOID Address, _In_ ULONG Count)
{
    UINT64 read_average = 0;
    UINT64 old_irql     = 0;

    MeasureInstructionRead(Address);

    old_irql = __readcr8();
    __writecr8(HIGH_LEVEL);

    _disable();

    for (ULONG iteration = 0; iteration < Count; iteration++)
        read_average += MeasureInstructionRead(Address);

    _enable();
    __writecr8(old_irql);

    DEBUG_VERBOSE("EPT Detection - Read Average: %llx", read_average);

    return read_average / Count;
}

#define EPT_CHECK_NUM_ITERATIONS      30
#define EPT_CONTROL_FUNCTIONS_COUNT   4
#define EPT_PROTECTED_FUNCTIONS_COUNT 2
#define EPT_MAX_FUNCTION_NAME_LENGTH  128
#define EPT_EXECUTION_TIME_MULTIPLIER 10

/*
 * Even though we test for the presence of a hypervisor, we should still test
 * for the presence of EPT hooks on key functions as this is a primary method
 * for reversing AC's.
 *
 * Credits to momo5502 for the idea: https://momo5502.com/blog/?p=255
 *
 * [+] EPT: Read average: 14991c28f5c2
 * [+] no EPT: Read average: 28828f5c28
 *
 * On average a read when HyperDbg's !epthook is active is around ~125x longer.
 * Will need to continue testing with other HV's, however it is a good start.
 */
STATIC
NTSTATUS
GetAverageReadTimeAtRoutine(_In_ PVOID    RoutineAddress,
                            _Out_ PUINT64 AverageTime)
{
    if (!RoutineAddress || !AverageTime)
        return STATUS_UNSUCCESSFUL;

    *AverageTime = MeasureReads(RoutineAddress, EPT_CHECK_NUM_ITERATIONS);

    return *AverageTime == 0 ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS;
}

/*
 * todo: encrypt both arrays
 *
 * The goal with the control functions is to find a reference time for an
 * average read on a function that is not EPT hooked. To accomplish this I've
 * selected some arbitrary, rarely used functions that shouldn't really ever
 * have an EPT hook active on them. This will give us a baseline that we can
 * then average out to find a relatively accurate average read time.
 *
 * From here, we have an array of protected functions which are commonly hooked
 * via EPT to reverse anti cheats. We then check the read times of these
 * functions and compare them to the average of the read times for the control
 * functions. If the read threshold exceeds a multiple of 10, we can be fairly
 * certain an EPT hook is active.
 *
 * Each time we measure the read we perform 30 iterations to ensure we get a
 * consistent result aswell as disabling interrupts + raising IRQL to ensure the
 * test is as accurate as possible.
 *
 * The following open source Intel VT-X hv's w/ EPT functionality have been
 * tested and detected in a non vm environment:
 *
 * HyperDbg !epthook (https://github.com/HyperDbg/HyperDbg):  detected
 * DdiMon (https://github.com/tandasat/DdiMon):               detected
 */
WCHAR CONTROL_FUNCTIONS[EPT_CONTROL_FUNCTIONS_COUNT]
                       [EPT_MAX_FUNCTION_NAME_LENGTH] = {
                           L"RtlAssert",
                           L"PsAcquireSiloHardReference",
                           L"PsDereferencePrimaryToken",
                           L"ZwCommitEnlistment"};

WCHAR PROTECTED_FUNCTIONS[EPT_PROTECTED_FUNCTIONS_COUNT]
                         [EPT_MAX_FUNCTION_NAME_LENGTH] = {
                             L"ExAllocatePoolWithTag", L"MmCopyMemory"};

/*
 * For whatever reason MmGetSystemRoutineAddress only works once, then every
 * call thereafter fails. So will be storing the routine addresses in arrays
 * since they dont change once the kernel is loaded.
 */
UINT64 CONTROL_FUNCTION_ADDRESSES[EPT_CONTROL_FUNCTIONS_COUNT]     = {0};
UINT64 PROTECTED_FUNCTION_ADDRESSES[EPT_PROTECTED_FUNCTIONS_COUNT] = {0};

STATIC
NTSTATUS
InitiateEptFunctionAddressArrays()
{
    PAGED_CODE();

    UNICODE_STRING current_function;

    for (INT index = 0; index < EPT_CONTROL_FUNCTIONS_COUNT; index++) {
        ImpRtlInitUnicodeString(&current_function, CONTROL_FUNCTIONS[index]);
        CONTROL_FUNCTION_ADDRESSES[index] =
            ImpMmGetSystemRoutineAddress(&current_function);

        if (!CONTROL_FUNCTION_ADDRESSES[index])
            return STATUS_UNSUCCESSFUL;
    }

    for (INT index = 0; index < EPT_PROTECTED_FUNCTIONS_COUNT; index++) {
        ImpRtlInitUnicodeString(&current_function, PROTECTED_FUNCTIONS[index]);
        PROTECTED_FUNCTION_ADDRESSES[index] =
            ImpMmGetSystemRoutineAddress(&current_function);

        if (!PROTECTED_FUNCTION_ADDRESSES[index])
            return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
DetectEptHooksInKeyFunctions()
{
    PAGED_CODE();

    NTSTATUS status           = STATUS_UNSUCCESSFUL;
    UINT32   control_fails    = 0;
    UINT64   instruction_time = 0;
    UINT64   control_time_sum = 0;
    UINT64   control_average  = 0;

    /* todo: once we call this, we need to set a flag to skip this,
     * otherwise we just return early */
    status = InitiateEptFunctionAddressArrays();

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("InitiateEptFunctionAddressArrays failed with status %x",
                    status);
        return status;
    }

    for (INT index = 0; index < EPT_CONTROL_FUNCTIONS_COUNT; index++) {
        status = GetAverageReadTimeAtRoutine(CONTROL_FUNCTION_ADDRESSES[index],
                                             &instruction_time);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("DetectEptPresentOnFunction failed with status %x",
                        status);
            control_fails += 1;
            continue;
        }

        control_time_sum += instruction_time;
    }

    if (control_time_sum == 0)
        return STATUS_UNSUCCESSFUL;

    control_average =
        control_time_sum / (EPT_CONTROL_FUNCTIONS_COUNT - control_fails);

    if (control_average == 0)
        return STATUS_UNSUCCESSFUL;

    for (INT index = 0; index < EPT_PROTECTED_FUNCTIONS_COUNT; index++) {
        status = GetAverageReadTimeAtRoutine(
            PROTECTED_FUNCTION_ADDRESSES[index], &instruction_time);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("DetectEptPresentOnFunction failed with status %x",
                        status);
            continue;
        }

        /* [+] EPT hook detected at function: ExAllocatePoolWithTag with
         * execution time of: 149b7777777 */
        if (control_average * EPT_EXECUTION_TIME_MULTIPLIER <
            instruction_time) {
            DEBUG_WARNING(
                "EPT hook detected at function: %llx with execution time of: %llx",
                PROTECTED_FUNCTION_ADDRESSES[index],
                instruction_time);

            /* close game etc. */
        }
    }

    return status;
}

STATIC
VOID
FindWinLogonProcess(_In_ PPROCESS_LIST_ENTRY Entry, _In_opt_ PVOID Context)
{
    LPCSTR     process_name = NULL;
    PEPROCESS* process      = (PEPROCESS*)Context;

    if (!Context)
        return;

    process_name = ImpPsGetProcessImageFileName(Entry->process);

    if (!strcmp(process_name, "winlogon.exe"))
        *process = Entry->process;
}

STATIC
NTSTATUS
StoreModuleExecutableRegionsx86(_In_ PRTL_MODULE_EXTENDED_INFO Module,
                                _In_ PVOID*                    Buffer,
                                _In_ PULONG                    BufferSize)
{
    NTSTATUS   status    = STATUS_UNSUCCESSFUL;
    PEPROCESS  process   = NULL;
    KAPC_STATE apc_state = {0};

    EnumerateProcessListWithCallbackRoutine(FindWinLogonProcess, &process);

    if (!process)
        return STATUS_NOT_FOUND;

    ImpKeStackAttachProcess(process, &apc_state);

    status = StoreModuleExecutableRegionsInBuffer(
        Buffer, Module->ImageBase, Module->ImageSize, BufferSize, TRUE);

    ImpKeUnstackDetachProcess(&apc_state);

    if (!NT_SUCCESS(status))
        DEBUG_ERROR(
            "StoreModuleExecutableRegionsInBuffer-x86 failed with status %x",
            status);

    return status;
}

VOID
DeferredModuleHashingCallback()
{
    NTSTATUS                 status        = STATUS_UNSUCCESSFUL;
    RTL_MODULE_EXTENDED_INFO module        = {0};
    PDRIVER_LIST_HEAD        driver_list   = GetDriverList();
    PLIST_ENTRY              deferred_head = &GetDriverList()->deferred_list;
    PLIST_ENTRY              list_entry    = NULL;
    PDRIVER_LIST_ENTRY       entry         = NULL;

    list_entry = RemoveHeadList(deferred_head);

    if (list_entry == deferred_head)
        goto end;

    while (list_entry != deferred_head) {
        entry =
            CONTAINING_RECORD(list_entry, DRIVER_LIST_ENTRY, deferred_entry);

        DriverListEntryToExtendedModuleInfo(entry, &module);

        DEBUG_VERBOSE("Hashing Deferred Module: %s", module.FullPathName);

        status = HashModule(&module, &entry->text_hash);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("HashModule-x86 failed with status %x", status);
            entry->hashed = FALSE;
            list_entry    = RemoveHeadList(deferred_head);
            continue;
        }

        entry->hashed = TRUE;
        list_entry    = RemoveHeadList(deferred_head);
    }

end:
    DEBUG_VERBOSE("All deferred modules hashed.");
    ImpIoFreeWorkItem(driver_list->deferred_work_item);
}

NTSTATUS
HashModule(_In_ PRTL_MODULE_EXTENDED_INFO Module, _Out_ PVOID Hash)
{
    NTSTATUS              status             = STATUS_UNSUCCESSFUL;
    ANSI_STRING           ansi_string        = {0};
    UNICODE_STRING        path               = {0};
    ULONG                 memory_text_size   = 0;
    PVOID                 memory_hash        = NULL;
    ULONG                 memory_hash_size   = 0;
    PVAL_INTEGRITY_HEADER memory_buffer      = NULL;
    ULONG                 memory_buffer_size = 0;
    PDRIVER_LIST_HEAD     list               = GetDriverList();

    ImpRtlInitAnsiString(&ansi_string, Module->FullPathName);

    if (!ansi_string.Buffer) {
        DEBUG_ERROR("RtlInitAnsiString failed with status %x", status);
        return;
    }

    status = ImpRtlAnsiStringToUnicodeString(&path, &ansi_string, TRUE);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("RtlAnsiStringToUnicodeString failed with status %x",
                    status);
        goto end;
    }

    /*
     * For win32k and related modules, because they are 32bit for us to read
     * the memory we need to attach to a 32 bit process. A simple check is
     * that the 32 bit image base wont be a valid address, while this is
     * hacky it works. Then we simply attach to a 32 bit address space, in
     * our case winlogon, which will allow us to perform the copy.
     *
     * Since the driver loads at system startup, our driver is loaded before
     * the WinLogon process has started, so to combat this return return
     * early with a status code. This will mark the module as not hashed and
     * x86. We will then queue a work item to hash these modules later once
     * WinLogon has started.
     */
    if (!ImpMmIsAddressValid(Module->ImageBase) && !list->can_hash_x86) {
        status = STATUS_INVALID_IMAGE_WIN_32;
        goto end;
    }
    else if (!ImpMmIsAddressValid(Module->ImageBase) && list->can_hash_x86) {
        /*
         * Once the WinLogon process has started, we can then hash new
         * x86 modules.
         */
        status = StoreModuleExecutableRegionsx86(
            Module, (PVOID)&memory_buffer, &memory_buffer_size);
    }
    else {
        status = StoreModuleExecutableRegionsInBuffer((PVOID)&memory_buffer,
                                                      Module->ImageBase,
                                                      Module->ImageSize,
                                                      &memory_buffer_size,
                                                      FALSE);
    }

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR(
            "StoreModuleExecutableRegionsInbuffer 2 failed with status %x",
            status);
        goto end;
    }

    status = ComputeHashOfBuffer(memory_buffer->section_base,
                                 memory_buffer->section_header.SizeOfRawData,
                                 &memory_hash,
                                 &memory_hash_size);

    if (!NT_SUCCESS(status)) {
        DEBUG_VERBOSE("ComputeHashOfSections failed with status %x", status);
        goto end;
    }

    RtlCopyMemory(Hash, memory_hash, memory_hash_size);

end:

    if (memory_buffer)
        ImpExFreePoolWithTag(memory_buffer, POOL_TAG_INTEGRITY);

    if (memory_hash)
        ImpExFreePoolWithTag(memory_hash, POOL_TAG_INTEGRITY);

    if (path.Buffer)
        ImpRtlFreeUnicodeString(&path);

    return status;
}

VOID
ValidateSystemModule(_In_ PRTL_MODULE_EXTENDED_INFO Module)
{
    NTSTATUS           status = STATUS_UNSUCCESSFUL;
    PDRIVER_LIST_ENTRY entry  = NULL;
    PVOID              hash   = NULL;

    hash = ExAllocatePool2(
        POOL_FLAG_NON_PAGED, SHA_256_HASH_LENGTH, POOL_TAG_INTEGRITY);

    if (!hash)
        return;

    FindDriverEntryByBaseAddress(Module->ImageBase, &entry);

    if (!entry) {
        DEBUG_ERROR("FindDriverEntryByBaseAddress failed with no status");
        goto end;
    }

    status = HashModule(Module, hash);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("HashModule failed with status %x", status);
        goto end;
    }

    if (CompareHashes(hash, entry->text_hash, SHA_256_HASH_LENGTH))
        DEBUG_VERBOSE("Module: %s text regions are valid.",
                      Module->FullPathName);
    else
        DEBUG_WARNING("**!!** Module: %s text regions are NOT valid **!!**",
                      Module->FullPathName);

end:
    if (hash)
        ExFreePoolWithTag(hash, POOL_TAG_INTEGRITY);
}

NTSTATUS
ValidateOurDriverImage()
{
    NTSTATUS                  status           = STATUS_UNSUCCESSFUL;
    SYSTEM_MODULES            modules          = {0};
    PRTL_MODULE_EXTENDED_INFO module_info      = NULL;
    PVOID                     memory_hash      = NULL;
    ULONG                     memory_hash_size = 0;
    PDRIVER_LIST_ENTRY        entry            = NULL;
    LPCSTR                    driver_name      = GetDriverName();
    PUNICODE_STRING           path             = GetDriverPath();

    status = GetSystemModuleInformation(&modules);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetSystemModuleInformation failed with status %x", status);
        return status;
    }

    module_info = FindSystemModuleByName(driver_name, &modules);

    if (!module_info) {
        DEBUG_ERROR("FindSystemModuleByName failed with no status.");
        goto end;
    }

    memory_hash = ExAllocatePool2(
        POOL_FLAG_NON_PAGED, SHA_256_HASH_LENGTH, POOL_TAG_INTEGRITY);

    if (!memory_hash)
        goto end;

    FindDriverEntryByBaseAddress(module_info->ImageBase, &entry);

    if (!entry) {
        DEBUG_ERROR("FindDriverEntryByBaseAddress failed with no status.");
        goto end;
    }

    if (entry->hashed == FALSE) {
        DEBUG_WARNING("Our module has not been hashed, returning.");
        status = STATUS_HASH_NOT_PRESENT;
        goto end;
    }

    status = HashModule(module_info, memory_hash);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("HashModule failed with status %x", status);
        goto end;
    }

    /*
     * Since we don't pass a return value, I think we would raise an invalid
     * module error and stop the users game session ? since module .text
     * section error would be a large red flag
     */
    if (CompareHashes(memory_hash, entry->text_hash, SHA_256_HASH_LENGTH))
        DEBUG_VERBOSE("Driver image is valid. Integrity check complete");
    else
        DEBUG_WARNING("**!!** Driver image is NOT valid. **!!**");

end:

    if (memory_hash)
        ExFreePoolWithTag(memory_hash, POOL_TAG_INTEGRITY);

    if (modules.address)
        ExFreePoolWithTag(modules.address, SYSTEM_MODULES_POOL);

    return status;
}

STATIC
VOID
SystemModuleVerificationDispatchFunction(_In_ PDEVICE_OBJECT DeviceObject,
                                         _In_ PSYS_MODULE_VAL_CONTEXT Context)
{
    InterlockedIncrement(&Context->active_thread_count);

    LONG count =
        InterlockedExchange(&Context->current_count, Context->current_count);
    LONG max = count + Context->block_size;

    for (; count < max && count < Context->total_count; count++) {
        if (!InterlockedCompareExchange(
                &Context->dispatcher_info[count].validated, TRUE, FALSE)) {
            ValidateSystemModule(&Context->module_info[count]);
        }
    }

    if (count == Context->total_count)
        InterlockedExchange(&Context->complete, TRUE);

    InterlockedExchange(&Context->current_count, count);
    InterlockedDecrement(&Context->active_thread_count);
}

#define VALIDATION_BLOCK_SIZE 25

/*
 * Multithreaded delayed priority work items improve 1% lows by 25% and reduces
 * average PC latency by 10% compared to traditional multithreading. This is
 * important as having high average fps but low 1% lows just leads to stuttery
 * gameplay which in competitive multiplayer games is simply not alright.
 * Overall still room for improvement but from a statistical and feel standpoint
 * which the gameplay is much smoother (tested in cs2).
 *
 * A potential idea for further improvement is finding the cores with the least
 * cpu usages and setting the worker threads affinity accordingly.
 */
STATIC
NTSTATUS
InitialiseSystemModuleVerificationContext(PSYS_MODULE_VAL_CONTEXT Context)
{
    NTSTATUS                  status           = STATUS_UNSUCCESSFUL;
    SYSTEM_MODULES            modules          = {0};
    PMODULE_DISPATCHER_HEADER dispatcher_array = NULL;

    status = GetSystemModuleInformation(&modules);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetSystemModuleInformation failed with status %x", status);
        return status;
    }

    DEBUG_VERBOSE("driver count: %lx", modules.module_count);

    dispatcher_array = ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                                          modules.module_count *
                                              sizeof(MODULE_DISPATCHER_HEADER),
                                          POOL_TAG_INTEGRITY);

    if (!dispatcher_array) {
        ImpExFreePoolWithTag(modules.address, SYSTEM_MODULES_POOL);
        return STATUS_MEMORY_NOT_ALLOCATED;
    }

    Context->active_thread_count = 0;
    Context->active              = TRUE;
    Context->complete            = FALSE;
    Context->dispatcher_info     = dispatcher_array;
    Context->module_info         = modules.address;
    Context->total_count         = modules.module_count;
    Context->block_size          = VALIDATION_BLOCK_SIZE;

    /* skip hal.dll and ntosrnl.exe  */
    Context->current_count = 2;

    return status;
}

VOID
FreeWorkItems(_In_ PSYS_MODULE_VAL_CONTEXT Context)
{
    for (INT index = 0; index < VERIFICATION_THREAD_COUNT; index++) {
        if (Context->work_items[index]) {
            ImpIoFreeWorkItem(Context->work_items[index]);
            Context->work_items[index] = NULL;
        }
    }
}

STATIC
VOID
FreeModuleVerificationItems(_In_ PSYS_MODULE_VAL_CONTEXT Context)
{
    /* if a thread hasnt completed by this point, something catastrophic has
     * gone wrong and maybe its better not to yield..*/
    while (Context->active_thread_count)
        YieldProcessor();

    if (Context->module_info) {
        ImpExFreePoolWithTag(Context->module_info, SYSTEM_MODULES_POOL);
        Context->module_info = NULL;
    }

    if (Context->dispatcher_info) {
        ImpExFreePoolWithTag(Context->dispatcher_info, POOL_TAG_INTEGRITY);
        Context->dispatcher_info = NULL;
    }
}

VOID
CleanupValidationContextOnUnload(_In_ PSYS_MODULE_VAL_CONTEXT Context)
{
    Context->active   = FALSE;
    Context->complete = TRUE;
    FreeWorkItems(Context);
    FreeModuleVerificationItems(Context);
}

NTSTATUS
SystemModuleVerificationDispatcher()
{
    NTSTATUS                status    = STATUS_UNSUCCESSFUL;
    PIO_WORKITEM            work_item = NULL;
    PSYS_MODULE_VAL_CONTEXT context   = GetSystemModuleValidationContext();

    if (context->complete) {
        DEBUG_VERBOSE(
            "System modules integrity check complete. Freeing items.");
        context->active   = FALSE;
        context->complete = FALSE;
        FreeModuleVerificationItems(context);
        FreeWorkItems(context);
        return STATUS_SUCCESS;
    }

    if (!context->active) {
        DEBUG_VERBOSE("Context not active, generating new one");

        status = InitialiseSystemModuleVerificationContext(context);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR(
                "InitialiseSystemModuleVerificationContext failed with status %x",
                status);
            return status;
        }
    }
    else {
        FreeWorkItems(context);
    }

    for (INT index = 0; index < VERIFICATION_THREAD_COUNT; index++) {
        work_item = ImpIoAllocateWorkItem(GetDriverDeviceObject());

        if (!work_item)
            continue;

        ImpIoQueueWorkItem(work_item,
                           SystemModuleVerificationDispatchFunction,
                           DelayedWorkQueue,
                           context);

        context->work_items[index] = work_item;
    }

    DEBUG_VERBOSE(
        "All worker threads dispatched for system module validation.");

    return STATUS_SUCCESS;
}

NTSTATUS
GetOsVersionInformation(_Out_ PRTL_OSVERSIONINFOW VersionInfo)
{
    NTSTATUS           status = STATUS_ABANDONED;
    RTL_OSVERSIONINFOW info   = {0};

    if (!VersionInfo)
        return STATUS_INVALID_PARAMETER;

    status = ImpRtlGetVersion(&info);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("RtlGetVersion failed with status %x", status);
        return status;
    }

    VersionInfo->dwBuildNumber       = info.dwBuildNumber;
    VersionInfo->dwMajorVersion      = info.dwMajorVersion;
    VersionInfo->dwMinorVersion      = info.dwMinorVersion;
    VersionInfo->dwOSVersionInfoSize = info.dwOSVersionInfoSize;
    VersionInfo->dwPlatformId        = info.dwPlatformId;

    RtlCopyMemory(VersionInfo->szCSDVersion,
                  info.szCSDVersion,
                  sizeof(VersionInfo->szCSDVersion));

    return status;
}

#define KPCR_KPRCB_OFFSET        0x180
#define KPCRB_IDLE_THREAD_OFFSET 0x018
#define KTHREAD_IDLE_TIME_OFFSET 0x28c
#define KPCRB_KERNEL_TIME_OFFSET 0x7e84
#define KPCRB_USER_TIME_OFFSET   0x7e88

UINT32
CalculateCpuCoreUsage(_In_ UINT32 Core)
{
    PVOID  kpcr        = NULL;
    PVOID  kpcrb       = NULL;
    PVOID  idle_thread = NULL;
    UINT32 idle_time   = 0;
    UINT32 kernel_time = 0;
    UINT32 user_time   = 0;

    KeSetSystemAffinityThread(1ull << Core);

    while (Core != KeGetCurrentProcessorNumber())
        YieldProcessor();

    kpcr        = __readmsr(IA32_GS_BASE);
    kpcrb       = (UINT64)kpcr + KPCR_KPRCB_OFFSET;
    idle_thread = *(UINT64*)((UINT64)kpcrb + KPCRB_IDLE_THREAD_OFFSET);

    idle_time   = *(UINT32*)((UINT64)idle_thread + KTHREAD_IDLE_TIME_OFFSET);
    kernel_time = *(UINT32*)((UINT64)kpcrb + KPCRB_KERNEL_TIME_OFFSET);
    user_time   = *(UINT32*)((UINT64)kpcrb + KPCRB_USER_TIME_OFFSET);

    return (100 - (UINT32)(UInt32x32To64(idle_time, 100) /
                           (UINT64)(kernel_time + user_time)));
}

BOOLEAN
ValidateOurDriversDispatchRoutines()
{
    PDRIVER_OBJECT driver = GetDriverObject();

    if (driver->MajorFunction[IRP_MJ_CREATE] != DeviceCreate ||
        driver->MajorFunction[IRP_MJ_CLOSE] != DeviceClose ||
        driver->MajorFunction[IRP_MJ_DEVICE_CONTROL] != DeviceControl) {
        DEBUG_WARNING(
            "**!!** Drivers dispatch routine has been tampered with. **!!**");
        return FALSE;
    }

    return TRUE;
}

```

`driver/integrity.h`:

```h
#ifndef INTEGRITY_H
#define INTEGRITY_H

#include <ntifs.h>

#include "common.h"

typedef struct _MODULE_DISPATCHER_HEADER {
    volatile UINT32 validated; // if this is > 0, a thread is already using it
    UINT8           result;

} MODULE_DISPATCHER_HEADER, *PMODULE_DISPATCHER_HEADER;

typedef struct _SYSTEM_MODULE_INFORMATION {
    MODULE_DISPATCHER_HEADER dispatcher_header;
    RTL_MODULE_EXTENDED_INFO module_information;

} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

#define VERIFICATION_THREAD_COUNT 4

typedef struct _SYS_MODULE_VAL_CONTEXT {
    /* Stores the number of actively executing worker threads */
    volatile LONG active_thread_count;

    /* determines whether a validation is in progress */
    volatile LONG active;

    /* determines whether a validation is complete */
    volatile LONG complete;

    /* current count of validated modules */
    volatile LONG current_count;

    /* total count of modules */
    UINT32 total_count;

    /* number of modules to validate in a single sweep */
    UINT32 block_size;

    /* pointer to the buffer containing the system module information */
    PRTL_MODULE_EXTENDED_INFO module_info;

    /* pointer to the array of dispatcher info used to synchonize threads */
    PMODULE_DISPATCHER_HEADER dispatcher_info;

    /* array of pointers to work items, used to free work items when
     * complete */
    PIO_WORKITEM work_items[VERIFICATION_THREAD_COUNT];

} SYS_MODULE_VAL_CONTEXT, *PSYS_MODULE_VAL_CONTEXT;

typedef enum _SMBIOS_TABLE_INDEX {
    SmbiosInformation = 0,
    SystemInformation,
    VendorSpecificInformation,
    ChassisInformation

} SMBIOS_TABLE_INDEX;

#define SMBIOS_VMWARE_SERIAL_NUMBER_SUB_INDEX 3
#define SMBIOS_NATIVE_SERIAL_NUMBER_SUB_INDEX 4
#define SMBIOS_VENDOR_STRING_SUB_INDEX        1

NTSTATUS
GetDriverImageSize(_Inout_ PIRP Irp);

NTSTATUS
RetrieveInMemoryModuleExecutableSections(_Inout_ PIRP Irp);

NTSTATUS
ValidateProcessLoadedModule(_Inout_ PIRP Irp);

NTSTATUS
GetHardDiskDriveSerialNumber(_Inout_ PVOID ConfigDrive0Serial,
                             _In_ SIZE_T   ConfigDrive0MaxSize);

NTSTATUS
ParseSMBIOSTable(_Out_ PVOID Buffer,
                 _In_ SIZE_T BufferSize,
                 _In_ ULONG  TableIndex,
                 _In_ ULONG  TableSubIndex);

NTSTATUS
DetectEptHooksInKeyFunctions();

PVOID
ScanForSignature(_In_ PVOID  BaseAddress,
                 _In_ SIZE_T MaxLength,
                 _In_ LPCSTR Signature,
                 _In_ SIZE_T SignatureLength);

NTSTATUS
ValidateNtoskrnl();

NTSTATUS
GetOsVersionInformation(_Out_ PRTL_OSVERSIONINFOW VersionInfo);

NTSTATUS
SystemModuleVerificationDispatcher();

NTSTATUS
ValidateOurDriverImage();

VOID
CleanupValidationContextOnUnload(_In_ PSYS_MODULE_VAL_CONTEXT Context);

UINT32
CalculateCpuCoreUsage(_In_ UINT32 Core);

NTSTATUS
HashModule(_In_ PRTL_MODULE_EXTENDED_INFO Module, _Out_ PVOID Hash);

VOID
ValidateSystemModule(_In_ PRTL_MODULE_EXTENDED_INFO Module);

BOOLEAN
ValidateOurDriversDispatchRoutines();

VOID
DeferredModuleHashingCallback();

#endif

```

`driver/io.c`:

```c
#include "io.h"

#include "modules.h"
#include "driver.h"
#include "callbacks.h"
#include "pool.h"
#include "integrity.h"
#include "thread.h"
#include "queue.h"
#include "hv.h"
#include "imports.h"
#include "list.h"
#include "session.h"
#include "hw.h"

STATIC
NTSTATUS
DispatchApcOperation(_In_ PAPC_OPERATION_ID Operation);

#ifdef ALLOC_PRAGMA
#    pragma alloc_text(PAGE, DispatchApcOperation)
#    pragma alloc_text(PAGE, DeviceControl)
#    pragma alloc_text(PAGE, DeviceClose)
#    pragma alloc_text(PAGE, DeviceCreate)
#endif

#define IOCTL_RUN_NMI_CALLBACKS \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20001, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VALIDATE_DRIVER_OBJECTS \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20002, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_NOTIFY_DRIVER_ON_PROCESS_LAUNCH \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20004, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_HANDLE_REPORTS_IN_CALLBACK_QUEUE \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20005, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PERFORM_VIRTUALIZATION_CHECK \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20006, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_ENUMERATE_HANDLE_TABLES \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20007, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_RETRIEVE_MODULE_EXECUTABLE_REGIONS \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20008, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_REQUEST_TOTAL_MODULE_SIZE \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20009, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_NOTIFY_DRIVER_ON_PROCESS_TERMINATION \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20010, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCAN_FOR_UNLINKED_PROCESS \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20011, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PERFORM_INTEGRITY_CHECK \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20013, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DETECT_ATTACHED_THREADS \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20014, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VALIDATE_PROCESS_LOADED_MODULE \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20015, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_REQUEST_HARDWARE_INFORMATION \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20016, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INITIATE_APC_OPERATION \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20017, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CHECK_FOR_EPT_HOOK \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20018, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LAUNCH_DPC_STACKWALK \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20019, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VALIDATE_SYSTEM_MODULES \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20020, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INSERT_IRP_INTO_QUEUE \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20021, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_QUERY_DEFERRED_REPORTS \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20022, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INITIATE_SHARED_MAPPING \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20023, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VALIDATE_PCI_DEVICES \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20024, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define APC_OPERATION_STACKWALK 0x1

/*
 * Basic cancel-safe IRP queue implementation. Stores pending IRPs in a list,
 * allowing us to dequeue entries to send data back to user mode without being
 * invoked by the user mode module via an io completion port.
 *
 * user mode program will automatically queue another irp when an irp completes,
 * ensuring queue has a sufficient supply.
 *
 * note: maybe we should use a spinlock here? Dont really want competing threads
 * sleeping. I think spinlock should be used here.
 */
VOID
IrpQueueAcquireLock(_In_ PIO_CSQ Csq, _Out_ PKIRQL Irql)
{
    KeAcquireSpinLock(&GetIrpQueueHead()->lock, Irql);
}

VOID
IrpQueueReleaseLock(_In_ PIO_CSQ Csq, _In_ KIRQL Irql)
{
    KeReleaseSpinLock(&GetIrpQueueHead()->lock, Irql);
}

PIRP
IrpQueuePeekNextEntry(_In_ PIO_CSQ Csq, _In_ PIRP Irp, _In_ PVOID Context)
{
    UNREFERENCED_PARAMETER(Context);
    PIRP_QUEUE_HEAD queue = GetIrpQueueHead();

    if (queue->count == 0)
        return NULL;

    return CONTAINING_RECORD(queue->queue.Flink, IRP, Tail.Overlay.ListEntry);
}

VOID
IrpQueueRemove(_In_ PIO_CSQ Csq, _In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(Csq);
    GetIrpQueueHead()->count--;
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
}

BOOLEAN
IrpQueueIsThereDeferredReport(_In_ PIRP_QUEUE_HEAD Queue)
{
    return Queue->deferred_reports.count > 0 ? TRUE : FALSE;
}

PDEFERRED_REPORT
IrpQueueRemoveDeferredReport(_In_ PIRP_QUEUE_HEAD Queue)
{
    return RemoveHeadList(&Queue->deferred_reports.head);
}

STATIC
VOID
IrpQueueFreeDeferredReport(_In_ PDEFERRED_REPORT Report)
{
    ImpExFreePoolWithTag(Report->buffer, REPORT_POOL_TAG);
    ImpExFreePoolWithTag(Report, REPORT_POOL_TAG);
}

NTSTATUS
IrpQueueCompleteDeferredReport(_In_ PDEFERRED_REPORT Report, _In_ PIRP Irp)
{
    NTSTATUS status = ValidateIrpOutputBuffer(Irp, Report->buffer_size);

    if (!NT_SUCCESS(status))
        return status;

    RtlCopyMemory(
        Irp->AssociatedIrp.SystemBuffer, Report->buffer, Report->buffer_size);

    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = Report->buffer_size;
    IofCompleteRequest(Irp, IO_NO_INCREMENT);
    IrpQueueFreeDeferredReport(Report);
    return STATUS_SUCCESS;
}

NTSTATUS
IrpQueueQueryPendingReports(_In_ PIRP Irp)
{
    PIRP_QUEUE_HEAD  queue  = GetIrpQueueHead();
    PDEFERRED_REPORT report = NULL;
    NTSTATUS         status = STATUS_UNSUCCESSFUL;
    KIRQL            irql   = 0;

    /*
     * Important we hold the lock before we call IsThereDeferredReport to
     * prevent the race condition where in the period between when we get a
     * TRUE result and another thread removes the last entry from the list.
     * We then request a deferred report and will receive a null value
     * leading to a bugcheck in the subsequent call to
     * CompleteDeferredReport.
     */
    KeAcquireSpinLock(&GetIrpQueueHead()->deferred_reports.lock, &irql);

    if (IrpQueueIsThereDeferredReport(queue)) {
        report = IrpQueueRemoveDeferredReport(queue);
        status = IrpQueueCompleteDeferredReport(report, Irp);

        if (!NT_SUCCESS(status)) {
            IrpQueueFreeDeferredReport(report);
            goto end;
        }

        queue->deferred_reports.count--;
        goto end;
    }

end:
    KeReleaseSpinLock(&GetIrpQueueHead()->deferred_reports.lock, irql);
    return status;
}

VOID
IrpQueueInsert(_In_ PIO_CSQ Csq, _In_ PIRP Irp)
{
    PIRP_QUEUE_HEAD queue = GetIrpQueueHead();
    InsertTailList(&queue->queue, &Irp->Tail.Overlay.ListEntry);
    queue->count++;
}

VOID
IrpQueueCompleteCancelledIrp(_In_ PIO_CSQ Csq, _In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(Csq);
    Irp->IoStatus.Status      = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    ImpIofCompleteRequest(Irp, IO_NO_INCREMENT);
}

PDEFERRED_REPORT
IrpQueueAllocateDeferredReport(_In_ PVOID Buffer, _In_ UINT32 BufferSize)
{
    PDEFERRED_REPORT report = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, sizeof(DEFERRED_REPORT), REPORT_POOL_TAG);

    if (!report)
        return NULL;

    report->buffer      = Buffer;
    report->buffer_size = BufferSize;
    return report;
}

#define MAX_DEFERRED_REPORTS_COUNT 100

VOID
IrpQueueDeferReport(_In_ PIRP_QUEUE_HEAD Queue,
                    _In_ PVOID           Buffer,
                    _In_ UINT32          BufferSize)
{
    PDEFERRED_REPORT report = NULL;
    KIRQL            irql   = {0};
    /*
     * arbitrary number, if we ever do have 100 deferred reports, theres
     * probably a catastrophic error somewhere else
     */
    if (Queue->deferred_reports.count > MAX_DEFERRED_REPORTS_COUNT) {
        ImpExFreePoolWithTag(Buffer, REPORT_POOL_TAG);
        return;
    }

    report = IrpQueueAllocateDeferredReport(Buffer, BufferSize);

    if (!report)
        return;

    KeAcquireSpinLock(&GetIrpQueueHead()->deferred_reports.lock, &irql);
    InsertTailList(&Queue->deferred_reports.head, &report->list_entry);
    Queue->deferred_reports.count++;
    KeReleaseSpinLock(&GetIrpQueueHead()->deferred_reports.lock, irql);
}

/*
 * takes ownership of the buffer, and regardless of the outcome will free it.
 *
 * IMPORTANT: All report buffers must be allocated in non paged memory.
 */
NTSTATUS
IrpQueueCompleteIrp(_In_ PVOID Buffer, _In_ ULONG BufferSize)
{
    NTSTATUS        status = STATUS_UNSUCCESSFUL;
    PIRP_QUEUE_HEAD queue  = GetIrpQueueHead();

    PIRP irp = IoCsqRemoveNextIrp(&queue->csq, NULL);

    /*
     * If no irps are available in our queue, lets store it in a deferred
     * reports list which should be checked each time we insert a new irp
     * into the queue.
     */
    if (!irp) {
        IrpQueueDeferReport(queue, Buffer, BufferSize);
        return STATUS_SUCCESS;
    }

    status = ValidateIrpOutputBuffer(irp, BufferSize);

    /*
     * Not sure how we should handle this, for now lets just free the buffer
     * and return a status.
     */
    if (!NT_SUCCESS(status)) {
        ImpExFreePoolWithTag(Buffer, REPORT_POOL_TAG);
        irp->IoStatus.Status      = STATUS_INSUFFICIENT_RESOURCES;
        irp->IoStatus.Information = 0;
        ImpIofCompleteRequest(irp, IO_NO_INCREMENT);
        return status;
    }

    irp->IoStatus.Status      = STATUS_SUCCESS;
    irp->IoStatus.Information = BufferSize;
    RtlCopyMemory(irp->AssociatedIrp.SystemBuffer, Buffer, BufferSize);
    ImpExFreePoolWithTag(Buffer, REPORT_POOL_TAG);
    ImpIofCompleteRequest(irp, IO_NO_INCREMENT);
    return status;
}

VOID
IrpQueueFreeDeferredReports()
{
    PIRP_QUEUE_HEAD  queue  = GetIrpQueueHead();
    PDEFERRED_REPORT report = NULL;
    KIRQL            irql   = 0;

    /* just in case... */
    KeAcquireSpinLock(&GetIrpQueueHead()->deferred_reports.lock, &irql);

    while (IrpQueueIsThereDeferredReport(queue)) {
        report = IrpQueueRemoveDeferredReport(queue);
        IrpQueueFreeDeferredReport(report);
    }

    KeReleaseSpinLock(&GetIrpQueueHead()->deferred_reports.lock, irql);
}

NTSTATUS
IrpQueueInitialise()
{
    NTSTATUS        status = STATUS_UNSUCCESSFUL;
    PIRP_QUEUE_HEAD queue  = GetIrpQueueHead();

    KeInitializeSpinLock(&queue->lock);
    KeInitializeSpinLock(&queue->deferred_reports.lock);
    InitializeListHead(&queue->queue);
    InitializeListHead(&queue->deferred_reports.head);

    status = IoCsqInitialize(&queue->csq,
                             IrpQueueInsert,
                             IrpQueueRemove,
                             IrpQueuePeekNextEntry,
                             IrpQueueAcquireLock,
                             IrpQueueReleaseLock,
                             IrpQueueCompleteCancelledIrp);

    if (!NT_SUCCESS(status))
        DEBUG_ERROR("IoCsqInitialize failed with status %x", status);

    return status;
}

VOID
SharedMappingWorkRoutine(_In_ PDEVICE_OBJECT DeviceObject,
                         _In_opt_ PVOID      Context)
{
    NTSTATUS        status = STATUS_UNSUCCESSFUL;
    HANDLE          handle = NULL;
    PSHARED_MAPPING state  = (PSHARED_MAPPING)Context;

    InterlockedIncrement(&state->work_item_status);

    DEBUG_VERBOSE("SharedMapping work routine called. OperationId: %lx",
                  state->kernel_buffer->operation_id);

    switch (state->kernel_buffer->operation_id) {
    case ssRunNmiCallbacks:

        DEBUG_INFO("SHARED_STATE_OPERATION_ID: RunNmiCallbacks Received.");

        status = HandleNmiIOCTL();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("RunNmiCallbacks failed with status %lx", status);

        break;

    case ssValidateDriverObjects:

        DEBUG_INFO(
            "SHARED_STATE_OPERATION_ID: ValidateDriverObjects Received.");

        status = ImpPsCreateSystemThread(&handle,
                                         PROCESS_ALL_ACCESS,
                                         NULL,
                                         NULL,
                                         NULL,
                                         HandleValidateDriversIOCTL,
                                         NULL);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("PsCreateSystemThread failed with status %x", status);
            goto end;
        }

        ImpZwClose(handle);
        break;

    case ssEnumerateHandleTables:

        DEBUG_INFO("SHARED_STATE_OPERATION_ID: EnumerateHandleTables Received");

        /* can maybe implement this better so we can extract a status
         * value */
        EnumerateProcessListWithCallbackRoutine(EnumerateProcessHandles, NULL);

        break;

    case ssScanForUnlinkedProcesses:

        DEBUG_INFO(
            "SHARED_STATE_OPERATION_ID: ScanForUnlinkedProcesses Received");

        status = FindUnlinkedProcesses();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("FindUnlinkedProcesses failed with status %x", status);

        break;

    case ssPerformModuleIntegrityCheck:

        DEBUG_INFO("SHARED_STATE_OPERATION_ID: PerformIntegrityCheck Received");

        status = ValidateOurDriverImage();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("VerifyInMemoryImageVsDiskImage failed with status %x",
                        status);

        break;

    case ssScanForAttachedThreads:

        DEBUG_INFO(
            "SHARED_STATE_OPERATION_ID: ScanForAttachedThreads Received");

        DetectThreadsAttachedToProtectedProcess();

        break;

    case ssScanForEptHooks:

        DEBUG_INFO("SHARED_STATE_OPERATION_ID: ScanForEptHooks Received");

        status = DetectEptHooksInKeyFunctions();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("DetectEpthooksInKeyFunctions failed with status %x",
                        status);

        break;

    case ssInitiateDpcStackwalk:

        DEBUG_INFO("SHARED_STATE_OPERATION_ID Received");

        status = DispatchStackwalkToEachCpuViaDpc();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR(
                "DispatchStackwalkToEachCpuViaDpc failed with status %x",
                status);

        break;

    case ssValidateSystemModules:

        DEBUG_INFO("SHARED_STATE_OPERATION_ID: ValidateSystemModules Received");

        status = SystemModuleVerificationDispatcher();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("ValidateSystemModules failed with status %x", status);

        break;

    default: DEBUG_ERROR("Invalid SHARED_STATE_OPERATION_ID Received");
    }

end:
    InterlockedDecrement(&state->work_item_status);
}

/* again, we want to run our routine at apc level not dispatch level */
VOID
SharedMappingDpcRoutine(_In_ PKDPC     Dpc,
                        _In_opt_ PVOID DeferredContext,
                        _In_opt_ PVOID SystemArgument1,
                        _In_opt_ PVOID SystemArgument2)
{
    PSHARED_MAPPING mapping = (PSHARED_MAPPING)DeferredContext;

    if (!mapping->active || mapping->work_item_status)
        return;

    IoQueueWorkItem(
        mapping->work_item, SharedMappingWorkRoutine, NormalWorkQueue, mapping);
}

#define REPEAT_TIME_15_SEC 30000

VOID
SharedMappingTerminate()
{
    PSHARED_MAPPING mapping = GetSharedMappingConfig();

    if (!mapping->active)
        return;

    while (mapping->work_item_status)
        YieldProcessor();

    mapping->active      = FALSE;
    mapping->user_buffer = NULL;
    mapping->size        = 0;

    KeCancelTimer(&mapping->timer);
    IoFreeWorkItem(mapping->work_item);
    IoFreeMdl(mapping->mdl);
    ExFreePoolWithTag(mapping->kernel_buffer, POOL_TAG_INTEGRITY);

    RtlZeroMemory(mapping, sizeof(SHARED_MAPPING));
}

STATIC
NTSTATUS
SharedMappingInitialiseTimer(_In_ PSHARED_MAPPING Mapping)
{
    LARGE_INTEGER due_time = {0};
    LONG          period   = 0;

    due_time.QuadPart = ABSOLUTE(SECONDS(30));

    Mapping->work_item = IoAllocateWorkItem(GetDriverDeviceObject());

    if (!Mapping->work_item) {
        DEBUG_ERROR("IoAllocateWorkItem failed with no status.");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeDpc(&Mapping->timer_dpc, SharedMappingDpcRoutine, Mapping);
    KeInitializeTimer(&Mapping->timer);
    KeSetTimerEx(
        &Mapping->timer, due_time, REPEAT_TIME_15_SEC, &Mapping->timer_dpc);

    DEBUG_VERBOSE("Initialised shared mapping event timer.");
    return STATUS_SUCCESS;
}

STATIC
NTSTATUS
SharedMappingInitialise(_In_ PIRP Irp)
{
    NTSTATUS             status       = STATUS_UNSUCCESSFUL;
    PMDL                 mdl          = NULL;
    PSHARED_MAPPING      mapping      = NULL;
    PSHARED_MAPPING_INIT mapping_init = NULL;
    PEPROCESS            process      = NULL;
    PVOID                buffer       = NULL;
    PVOID                user_buffer  = NULL;

    mapping = GetSharedMappingConfig();

    /* TODO: need to copy these out */
    status = ValidateIrpOutputBuffer(Irp, sizeof(SHARED_MAPPING_INIT));

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ValidateIrpOutputBuffer failed with status %x", status);
        return status;
    }

    /*
     * remember that ExAllocatePool2 zeroes the allocation, so no need to
     * zero
     */
    buffer =
        ExAllocatePool2(POOL_FLAG_NON_PAGED, PAGE_SIZE, POOL_TAG_INTEGRITY);

    if (!buffer)
        return STATUS_INSUFFICIENT_RESOURCES;

    mdl = IoAllocateMdl(buffer, PAGE_SIZE, FALSE, FALSE, NULL);

    if (!mdl) {
        DEBUG_ERROR("IoAllocateMdl failed with no status");
        ExFreePoolWithTag(buffer, POOL_TAG_INTEGRITY);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MmBuildMdlForNonPagedPool(mdl);

    __try {
        user_buffer = MmMapLockedPagesSpecifyCache(mdl,
                                                   UserMode,
                                                   MmCached,
                                                   NULL,
                                                   FALSE,
                                                   NormalPagePriority |
                                                       MdlMappingNoExecute);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        DEBUG_ERROR("MmMapLockedPagesSpecifyCache failed with status %x",
                    status);
        IoFreeMdl(mdl);
        ExFreePoolWithTag(buffer, POOL_TAG_INTEGRITY);
        return status;
    }

    mapping->kernel_buffer    = (PSHARED_STATE)buffer;
    mapping->user_buffer      = user_buffer;
    mapping->mdl              = mdl;
    mapping->size             = PAGE_SIZE;
    mapping->active           = TRUE;
    mapping->work_item_status = FALSE;

    SharedMappingInitialiseTimer(mapping);

    mapping_init = (PSHARED_MAPPING_INIT)Irp->AssociatedIrp.SystemBuffer;
    mapping_init->buffer = user_buffer;
    mapping_init->size   = PAGE_SIZE;

    return status;
}

STATIC
NTSTATUS
DispatchApcOperation(_In_ PAPC_OPERATION_ID Operation)
{
    PAGED_CODE();

    NTSTATUS status = STATUS_UNSUCCESSFUL;

    DEBUG_VERBOSE("Dispatching APC Operation...");

    switch (Operation->operation_id) {
    case APC_OPERATION_STACKWALK:

        DEBUG_INFO("Initiating APC stackwalk operation with operation id %i",
                   Operation->operation_id);

        status = ValidateThreadsViaKernelApc();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("ValidateThreadsViaKernelApc failed with status %x",
                        status);

        return status;

    default:
        DEBUG_WARNING("Invalid operation ID passed");
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

/*
 * Obviously, its important we check that the input and output buffer sizes for
 * each IRP is big enough to hold the incoming and outgoing information.
 *
 * Another important thing to note is that the windows IO manager will only zero
 * out the size of the input buffer. Given that we use METHOD_BUFFERED for all
 * communication, the input and output buffer are the same, with the size used
 * being that of the greatest buffer passed to DeviceIoControl. The IO manager
 * will then zero our the buffer to the size of the input buffer, so if the
 * output buffer is larger then the input buffer there will be uninitialised
 * memory in the buffer so we must zero out the buffer to the length of the
 * output buffer.
 *
 * We then set the IoStatus.Information field to the size of the buffer we are
 * passing back. If we don't do this and we allocate an output buffer of size
 * 0x1000, yet only use 0x100 bytes, the user mode apps output buffer will
 * receive 0x100 bytes + 0x900 bytes of uninitialised memory which is an
 * information leak.
 */
NTSTATUS
ValidateIrpOutputBuffer(_In_ PIRP Irp, _In_ ULONG RequiredSize)
{
    if (!Irp || !RequiredSize)
        return STATUS_INVALID_PARAMETER;

    PIO_STACK_LOCATION io = IoGetCurrentIrpStackLocation(Irp);

    if (!io)
        return STATUS_UNSUCCESSFUL;

    if (io->Parameters.DeviceIoControl.OutputBufferLength < RequiredSize)
        return STATUS_BUFFER_TOO_SMALL;

    RtlSecureZeroMemory(Irp->AssociatedIrp.SystemBuffer, RequiredSize);

    Irp->IoStatus.Information = RequiredSize;

    return STATUS_SUCCESS;
}

/*
 * Here we just check that the input buffers size matches the expected size..
 * It isnt a very secure check but we can work on that later...
 */
NTSTATUS
ValidateIrpInputBuffer(_In_ PIRP Irp, _In_ ULONG RequiredSize)
{
    if (!Irp || !RequiredSize)
        return STATUS_INVALID_PARAMETER;

    PIO_STACK_LOCATION io = IoGetCurrentIrpStackLocation(Irp);

    if (!io)
        return STATUS_UNSUCCESSFUL;

    if (io->Parameters.DeviceIoControl.InputBufferLength != RequiredSize)
        return STATUS_INVALID_BUFFER_SIZE;

    return STATUS_SUCCESS;
}

NTSTATUS
DeviceControl(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp)
{
    PAGED_CODE();

    NTSTATUS           status         = STATUS_SUCCESS;
    PIO_STACK_LOCATION stack_location = IoGetCurrentIrpStackLocation(Irp);
    HANDLE             handle         = NULL;
    PKTHREAD           thread         = NULL;
    BOOLEAN            security_flag  = FALSE;

    /*
     * LMAO
     */
    SessionIsActive(&security_flag);

    if (security_flag == FALSE &&
        stack_location->Parameters.DeviceIoControl.IoControlCode !=
            IOCTL_NOTIFY_DRIVER_ON_PROCESS_LAUNCH) {
        status = STATUS_ACCESS_DENIED;
        goto end;
    }

    switch (stack_location->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_RUN_NMI_CALLBACKS:

        DEBUG_INFO("IOCTL_RUN_NMI_CALLBACKS Received.");

        status = HandleNmiIOCTL(Irp);

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("RunNmiCallbacks failed with status %lx", status);

        break;

    case IOCTL_VALIDATE_DRIVER_OBJECTS:

        DEBUG_INFO("IOCTL_VALIDATE_DRIVER_OBJECTS Received.");

        /*
         * The reason this function is run in a new thread and not the
         * thread issuing the IOCTL is because ZwOpenDirectoryObject
         * issues a user mode handle if called on the user mode thread
         * calling DeviceIoControl. This is a problem because when we
         * pass said handle to ObReferenceObjectByHandle it will issue a
         * bug check under windows driver verifier.
         */

        status = ImpPsCreateSystemThread(&handle,
                                         PROCESS_ALL_ACCESS,
                                         NULL,
                                         NULL,
                                         NULL,
                                         HandleValidateDriversIOCTL,
                                         NULL);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("PsCreateSystemThread failed with status %x", status);
            goto end;
        }

        ImpZwClose(handle);
        break;

    case IOCTL_NOTIFY_DRIVER_ON_PROCESS_LAUNCH:;

        DEBUG_INFO("IOCTL_NOTIFY_DRIVER_ON_PROCESS_LAUNCH Received");

        status = SessionInitialise(Irp);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("InitialiseSession failed with status %x", status);
            goto end;
        }

        status = RegisterProcessObCallbacks();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("EnableObCallbacks failed with status %x", status);

        break;

    case IOCTL_HANDLE_REPORTS_IN_CALLBACK_QUEUE:

        DEBUG_INFO("IOCTL_HANDLE_REPORTS_IN_CALLBACK_QUEUE Received");

        status = QueryActiveApcContextsForCompletion();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR(
                "QueryActiveApcContextsForCompletion failed with status %x",
                status);

        break;

    case IOCTL_PERFORM_VIRTUALIZATION_CHECK:

        DEBUG_INFO("IOCTL_PERFORM_VIRTUALIZATION_CHECK Received");

        status = PerformVirtualizationDetection(Irp);

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("PerformVirtualizationDetection failed with status %x",
                        status);

        break;

    case IOCTL_ENUMERATE_HANDLE_TABLES:

        DEBUG_INFO("IOCTL_ENUMERATE_HANDLE_TABLES Received");

        /* can maybe implement this better so we can extract a status
         * value */
        EnumerateProcessListWithCallbackRoutine(EnumerateProcessHandles, NULL);

        break;

    case IOCTL_RETRIEVE_MODULE_EXECUTABLE_REGIONS:

        DEBUG_VERBOSE("IOCTL_RETRIEVE_MODULE_EXECUTABLE_REGIONS Received");

        status =
            ImpPsCreateSystemThread(&handle,
                                    PROCESS_ALL_ACCESS,
                                    NULL,
                                    NULL,
                                    NULL,
                                    RetrieveInMemoryModuleExecutableSections,
                                    Irp);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("PsCreateSystemThread failed with status %x", status);
            goto end;
        }

        status = ImpObReferenceObjectByHandle(handle,
                                              THREAD_ALL_ACCESS,
                                              *PsThreadType,
                                              KernelMode,
                                              &thread,
                                              NULL);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("ObReferenceObjectbyhandle failed with status %lx",
                        status);
            ImpZwClose(handle);
            goto end;
        }

        ImpKeWaitForSingleObject(thread, Executive, KernelMode, FALSE, NULL);

        ImpZwClose(handle);
        ImpObDereferenceObject(thread);

        break;

    case IOCTL_REQUEST_TOTAL_MODULE_SIZE:

        DEBUG_INFO("IOCTL_REQUEST_TOTAL_MODULE_SIZE Received");

        status = GetDriverImageSize(Irp);

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("GetDriverImageSize failed with status %x", status);

        break;

    case IOCTL_NOTIFY_DRIVER_ON_PROCESS_TERMINATION:

        DEBUG_INFO("IOCTL_NOTIFY_DRIVER_ON_PROCESS_TERMINATION Received");

        SessionTerminate();
        UnregisterProcessObCallbacks();

        break;

    case IOCTL_SCAN_FOR_UNLINKED_PROCESS:

        DEBUG_INFO("IOCTL_SCAN_FOR_UNLINKED_PROCESS Received");

        status = FindUnlinkedProcesses();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("FindUnlinkedProcesses failed with status %x", status);

        break;

    case IOCTL_PERFORM_INTEGRITY_CHECK:

        DEBUG_INFO("IOCTL_PERFORM_INTEGRITY_CHECK Received");

        status = ValidateOurDriverImage();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("VerifyInMemoryImageVsDiskImage failed with status %x",
                        status);

        break;

    case IOCTL_DETECT_ATTACHED_THREADS:

        DEBUG_INFO("IOCTL_DETECT_ATTACHED_THREADS Received");

        DetectThreadsAttachedToProtectedProcess();

        break;

    case IOCTL_VALIDATE_PROCESS_LOADED_MODULE:

        DEBUG_INFO("IOCTL_VALIDATE_PROCESS_LOADED_MODULE Received");

        status = ValidateProcessLoadedModule(Irp);

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("ValidateProcessLoadedModule failed with status %x",
                        status);

        break;

    case IOCTL_REQUEST_HARDWARE_INFORMATION:;

        DEBUG_INFO("IOCTL_REQUEST_HARDWARE_INFORMATION Received");

        PSYSTEM_INFORMATION system_information =
            GetDriverConfigSystemInformation();

        status = ValidateIrpOutputBuffer(Irp, sizeof(SYSTEM_INFORMATION));

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("ValidateIrpOutputBuffer failed with status %x",
                        status);
            goto end;
        }

        Irp->IoStatus.Information = sizeof(SYSTEM_INFORMATION);

        RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer,
                      system_information,
                      sizeof(SYSTEM_INFORMATION));

        break;

    case IOCTL_INITIATE_APC_OPERATION:;

        DEBUG_INFO("IOCTL_INITIATE_APC_OPERATION Received");

        PAPC_OPERATION_ID operation =
            (PAPC_OPERATION_ID)Irp->AssociatedIrp.SystemBuffer;

        status = DispatchApcOperation(operation);

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("DispatchApcOperation failed with status %x", status);

        break;

    case IOCTL_CHECK_FOR_EPT_HOOK:

        DEBUG_INFO("IOCTL_CHECK_FOR_EPT_HOOK Received");

        status = DetectEptHooksInKeyFunctions();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("DetectEpthooksInKeyFunctions failed with status %x",
                        status);

        break;

    case IOCTL_VALIDATE_SYSTEM_MODULES:

        DEBUG_INFO("IOCTL_VALIDATE_SYSTEM_MODULES Received");

        status = SystemModuleVerificationDispatcher();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("ValidateSystemModules failed with status %x", status);

        break;

    case IOCTL_LAUNCH_DPC_STACKWALK:

        DEBUG_INFO("IOCTL_LAUNCH_DPC_STACKWALK Received");

        status = DispatchStackwalkToEachCpuViaDpc();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR(
                "DispatchStackwalkToEachCpuViaDpc failed with status %x",
                status);

        break;

    case IOCTL_INSERT_IRP_INTO_QUEUE:;

        // DEBUG_INFO("IOCTL_INSERT_IRP_INTO_QUEUE Received");

        PIRP_QUEUE_HEAD queue = GetIrpQueueHead();

        /*
         * Given the nature of the Windows IO subsystem and the
         * cancel-safe queue implementation we use, we need to query for
         * deferred reports before insert an irp into the queue. The
         * reason for this is the cancel-safe queue will automically
         * mark the irp as pending, so if we then use that irp to return
         * a deferred report and return success here verifier has a lil
         * cry.
         */

        /* before we queue our IRP, check if we can complete a deferred
         * report */
        status = IrpQueueQueryPendingReports(Irp);

        /* if we return success, weve completed the irp, we can return
         * success */
        if (!NT_SUCCESS(status)) {
            /* if there are no deferred reports, store the irp in
             * the queue */
            IoCsqInsertIrp(&queue->csq, Irp, NULL);

            /* we dont want to complete the request */
            return STATUS_PENDING;
        }

        return STATUS_SUCCESS;

    case IOCTL_INITIATE_SHARED_MAPPING:

        DEBUG_INFO("IOCTL_INITIATE_SHARED_MAPPING Received");

        status = SharedMappingInitialise(Irp);

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("SharedMappingInitialise failed with status %x",
                        status);

        break;

    case IOCTL_VALIDATE_PCI_DEVICES:

        DEBUG_INFO("IOCTL_VALIDATE_PCI_DEVICES Received");

        status = ValidatePciDevices();

        if (!NT_SUCCESS(status))
            DEBUG_ERROR("ValidatePciDevices failed with status %x", status);

        break;

    default:
        DEBUG_WARNING("Invalid IOCTL passed to driver: %lx",
                      stack_location->Parameters.DeviceIoControl.IoControlCode);

        status = STATUS_INVALID_PARAMETER;
        break;
    }

end:
    DEBUG_VERBOSE("Completing IRP with status %x", status);
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
DeviceClose(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp)
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DeviceObject);
    DEBUG_INFO("Handle to driver closed.");

    SessionTerminate();
    UnregisterProcessObCallbacks();
    SharedMappingTerminate();

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}

NTSTATUS
DeviceCreate(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp)
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DeviceObject);
    DEBUG_INFO("Handle to driver opened.");

    NTSTATUS status = ValidatePciDevices();

    if (!NT_SUCCESS(status))
        DEBUG_ERROR("ValidatePciDevices failed with status %x", status);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Irp->IoStatus.Status;
}
```

`driver/io.h`:

```h
#ifndef IO_H
#define IO_H

#include <ntifs.h>
#include <wdftypes.h>
#include <wdf.h>
#include "common.h"

typedef struct _SHARED_MAPPING_INIT {
    PVOID  buffer;
    SIZE_T size;

} SHARED_MAPPING_INIT, *PSHARED_MAPPING_INIT;

typedef enum _SHARED_STATE_OPERATION_ID {
    ssRunNmiCallbacks = 0,
    ssValidateDriverObjects,
    ssEnumerateHandleTables,
    ssScanForUnlinkedProcesses,
    ssPerformModuleIntegrityCheck,
    ssScanForAttachedThreads,
    ssScanForEptHooks,
    ssInitiateDpcStackwalk,
    ssValidateSystemModules,

} SHARED_STATE_OPERATION_ID;

typedef struct _SHARED_STATE {
    volatile UINT32 status;
    volatile UINT16 operation_id;

} SHARED_STATE, *PSHARED_STATE;

typedef struct _SHARED_MAPPING {
    volatile LONG    work_item_status;
    PVOID            user_buffer;
    PSHARED_STATE    kernel_buffer;
    PMDL             mdl;
    SIZE_T           size;
    volatile BOOLEAN active;
    KTIMER           timer;
    KDPC             timer_dpc;
    PIO_WORKITEM     work_item;

} SHARED_MAPPING, *PSHARED_MAPPING;

NTSTATUS
DeviceControl(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp);

NTSTATUS
DeviceClose(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp);

NTSTATUS
DeviceCreate(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp);

NTSTATUS
ValidateIrpOutputBuffer(_In_ PIRP Irp, _In_ ULONG RequiredSize);

NTSTATUS
ValidateIrpInputBuffer(_In_ PIRP Irp, _In_ ULONG RequiredSize);

NTSTATUS
IrpQueueInitialise();

NTSTATUS
IrpQueueCompleteIrp(_In_ PVOID Buffer, _In_ ULONG BufferSize);

#endif
```

`driver/list.c`:

```c
#include "list.h"

#include "imports.h"
#include "driver.h"

/*
 * Simple thread safe linked list implementation. All structures should begin
 * with a SINGLE_LIST_ENTRY structure provided by the windows API. for example:
 *
 *	typedef struct _LIST_ENTRY_STRUCTURE
 *	{
 *		SINGLE_LIST_ENTRY list;
 *		PVOID address;
 *		UINT32 data;
 *		...
 *	};
 *
 * This common structure layout allows us to pass in a callback routine when
 *freeing allowing immense flexibility to ensure we can free and/or deference
 *any objects that are referenced in said object.
 *
 * I've opted to use a mutex rather then a spinlock since there are many times
 *we enumerate the list for extended periods aswell as queue up many insertions
 *at once.
 */

#define LIST_POOL_TAG 'list'

VOID
ListInit(_Inout_ PSINGLE_LIST_ENTRY Head, _Inout_ PKGUARDED_MUTEX Lock)
{
    ImpKeInitializeGuardedMutex(Lock);
    Head->Next = NULL;
}

VOID
ListInsert(_Inout_ PSINGLE_LIST_ENTRY Head,
           _Inout_ PSINGLE_LIST_ENTRY NewEntry,
           _In_ PKGUARDED_MUTEX       Lock)
{
    ImpKeAcquireGuardedMutex(Lock);

    PSINGLE_LIST_ENTRY old_entry = Head->Next;

    Head->Next     = NewEntry;
    NewEntry->Next = old_entry;

    ImpKeReleaseGuardedMutex(Lock);
}

/*
 * Assuming the SINGLE_LIST_ENTRY is the first item in the structure, we
 * can pass a callback routine to be called before the free occurs. This
 * allows us to dereference/free structure specific items whilst still allowing
 * the list to remain flexible.
 */
BOOLEAN
ListFreeFirstEntry(_Inout_ PSINGLE_LIST_ENTRY       Head,
                   _In_ PKGUARDED_MUTEX             Lock,
                   _In_opt_ FREE_LIST_ITEM_CALLBACK CallbackRoutine)
{
    BOOLEAN result = FALSE;
    ImpKeAcquireGuardedMutex(Lock);

    if (Head->Next) {
        PSINGLE_LIST_ENTRY entry = Head->Next;

        if (CallbackRoutine)
            CallbackRoutine(entry);

        Head->Next = Head->Next->Next;
        ImpExFreePoolWithTag(entry, POOL_TAG_THREAD_LIST);
        result = TRUE;
    }

    ImpKeReleaseGuardedMutex(Lock);
    return result;
}

/*
 * If we are removing a specific entry, its assumed we have freed and/or
 * dereferenced any fields in the structure.
 */
VOID
ListRemoveEntry(_Inout_ PSINGLE_LIST_ENTRY Head,
                _Inout_ PSINGLE_LIST_ENTRY Entry,
                _In_ PKGUARDED_MUTEX       Lock)
{
    ImpKeAcquireGuardedMutex(Lock);

    PSINGLE_LIST_ENTRY entry = Head->Next;

    if (!entry)
        goto unlock;

    if (entry == Entry) {
        Head->Next = entry->Next;
        ImpExFreePoolWithTag(Entry, POOL_TAG_THREAD_LIST);
        goto unlock;
    }

    while (entry->Next) {
        if (entry->Next == Entry) {
            entry->Next = Entry->Next;
            ImpExFreePoolWithTag(Entry, POOL_TAG_THREAD_LIST);
            goto unlock;
        }

        entry = entry->Next;
    }

unlock:
    ImpKeReleaseGuardedMutex(Lock);
}

VOID
LookasideListRemoveEntry(_Inout_ PSINGLE_LIST_ENTRY Head,
                         _Inout_ PSINGLE_LIST_ENTRY Entry,
                         _In_ PKGUARDED_MUTEX       Lock)
{
    ImpKeAcquireGuardedMutex(Lock);

    PTHREAD_LIST_HEAD  head  = GetThreadList();
    PSINGLE_LIST_ENTRY entry = Head->Next;

    if (!entry)
        goto unlock;

    if (entry == Entry) {
        Head->Next = entry->Next;
        ExFreeToLookasideListEx(&head->lookaside_list, Entry);
        goto unlock;
    }

    while (entry->Next) {
        if (entry->Next == Entry) {
            entry->Next = Entry->Next;
            ExFreeToLookasideListEx(&head->lookaside_list, Entry);
            goto unlock;
        }

        entry = entry->Next;
    }

unlock:
    ImpKeReleaseGuardedMutex(Lock);
}

BOOLEAN
LookasideListFreeFirstEntry(_Inout_ PSINGLE_LIST_ENTRY       Head,
                            _In_ PKGUARDED_MUTEX             Lock,
                            _In_opt_ FREE_LIST_ITEM_CALLBACK CallbackRoutine)
{
    ImpKeAcquireGuardedMutex(Lock);

    PTHREAD_LIST_HEAD head   = GetThreadList();
    BOOLEAN           result = FALSE;

    if (Head->Next) {
        PSINGLE_LIST_ENTRY entry = Head->Next;

        if (CallbackRoutine)
            CallbackRoutine(entry);

        Head->Next = Head->Next->Next;
        ExFreeToLookasideListEx(&head->lookaside_list, entry);
        result = TRUE;
    }

    ImpKeReleaseGuardedMutex(Lock);
    return result;
}
```

`driver/list.h`:

```h
#ifndef LIST_H
#define LIST_H

#include "common.h"

typedef void (*FREE_LIST_ITEM_CALLBACK)(_In_ PVOID Entry);

VOID
LookasideListRemoveEntry(_Inout_ PSINGLE_LIST_ENTRY Head,
                         _Inout_ PSINGLE_LIST_ENTRY Entry,
                         _In_ PKGUARDED_MUTEX       Lock);

BOOLEAN
LookasideListFreeFirstEntry(_Inout_ PSINGLE_LIST_ENTRY       Head,
                            _In_ PKGUARDED_MUTEX             Lock,
                            _In_opt_ FREE_LIST_ITEM_CALLBACK CallbackRoutine);

VOID
ListInit(_Inout_ PSINGLE_LIST_ENTRY Head, _Inout_ PKGUARDED_MUTEX Lock);

VOID
ListInsert(_Inout_ PSINGLE_LIST_ENTRY Head,
           _Inout_ PSINGLE_LIST_ENTRY NewEntry,
           _In_ PKGUARDED_MUTEX       Lock);

BOOLEAN
ListFreeFirstEntry(_Inout_ PSINGLE_LIST_ENTRY       Head,
                   _In_ PKGUARDED_MUTEX             Lock,
                   _In_opt_ FREE_LIST_ITEM_CALLBACK CallbackRoutine);

VOID
ListRemoveEntry(_Inout_ PSINGLE_LIST_ENTRY Head,
                _Inout_ PSINGLE_LIST_ENTRY Entry,
                _In_ PKGUARDED_MUTEX       Lock);

#endif
```

`driver/modules.c`:

```c
#include "modules.h"

#include "callbacks.h"
#include "driver.h"
#include "io.h"
#include "ia32.h"
#include "imports.h"
#include "apc.h"
#include "thread.h"

#define WHITELISTED_MODULE_TAG 'whte'

#define NMI_DELAY 200 * 10000

#define WHITELISTED_MODULE_COUNT 11
#define MODULE_MAX_STRING_SIZE   256

#define NTOSKRNL 0
#define CLASSPNP 1
#define WDF01000 2

/*
 * The modules seen in the array below have been seen to commonly hook other
 * drivers' IOCTL dispatch routines. Its possible to see this by using
 * WinObjEx64 and checking which module each individual dispatch routine lies
 * in. These modules are then addded to the list (in addition to either the
 * driver itself or ntoskrnl) which is seen as a valid region for a drivers
 * dispatch routine to lie within.
 */
CHAR WHITELISTED_MODULES[WHITELISTED_MODULE_COUNT][MODULE_MAX_STRING_SIZE] = {
    "ntoskrnl.exe",
    "CLASSPNP.SYS",
    "Wdf01000.sys",
    "HIDCLASS.SYS",
    "storport.sys",
    "dxgkrnl.sys",
    "ndis.sys",
    "ks.sys",
    "portcls.sys",
    "rdbss.sys",
    "LXCORE.SYS"};

#define MODULE_REPORT_DRIVER_NAME_BUFFER_SIZE 128

#define REASON_NO_BACKING_MODULE      1
#define REASON_INVALID_IOCTL_DISPATCH 2

#define SYSTEM_IDLE_PROCESS_ID 0
#define SYSTEM_PROCESS_ID      4
#define SVCHOST_PROCESS_ID     8

typedef struct _WHITELISTED_REGIONS {
    UINT64 base;
    UINT64 end;

} WHITELISTED_REGIONS, *PWHITELISTED_REGIONS;

typedef struct _NMI_POOLS {
    PVOID thread_data_pool;
    PVOID stack_frames;
    PVOID nmi_context;

} NMI_POOLS, *PNMI_POOLS;

typedef struct _MODULE_VALIDATION_FAILURE_HEADER {
    INT module_count;

} MODULE_VALIDATION_FAILURE_HEADER, *PMODULE_VALIDATION_FAILURE_HEADER;

typedef struct _NMI_CONTEXT {
    UINT64  interrupted_rip;
    UINT64  interrupted_rsp;
    UINT64  kthread;
    UINT32  callback_count;
    BOOLEAN user_thread;

} NMI_CONTEXT, *PNMI_CONTEXT;

typedef struct _INVALID_DRIVER {
    struct _INVALID_DRIVER* next;
    INT                     reason;
    PDRIVER_OBJECT          driver;

} INVALID_DRIVER, *PINVALID_DRIVER;

typedef struct _INVALID_DRIVERS_HEAD {
    PINVALID_DRIVER first_entry;
    INT             count;

} INVALID_DRIVERS_HEAD, *PINVALID_DRIVERS_HEAD;

STATIC
NTSTATUS
PopulateWhitelistedModuleBuffer(_Inout_ PVOID        Buffer,
                                _In_ PSYSTEM_MODULES SystemModules);

STATIC
NTSTATUS
ValidateDriverIOCTLDispatchRegion(_In_ PDRIVER_OBJECT       Driver,
                                  _In_ PSYSTEM_MODULES      Modules,
                                  _In_ PWHITELISTED_REGIONS WhitelistedRegions,
                                  _Out_ PBOOLEAN            Flag);

STATIC
VOID
InitDriverList(_Inout_ PINVALID_DRIVERS_HEAD ListHead);

STATIC
NTSTATUS
AddDriverToList(_Inout_ PINVALID_DRIVERS_HEAD InvalidDriversHead,
                _In_ PDRIVER_OBJECT           Driver,
                _In_ INT                      Reason);

STATIC
VOID
RemoveInvalidDriverFromList(_Inout_ PINVALID_DRIVERS_HEAD InvalidDriversHead);

STATIC
VOID
EnumerateInvalidDrivers(_In_ PINVALID_DRIVERS_HEAD InvalidDriversHead);

STATIC
NTSTATUS
ValidateDriverObjectHasBackingModule(_In_ PSYSTEM_MODULES ModuleInformation,
                                     _In_ PDRIVER_OBJECT  DriverObject,
                                     _Out_ PBOOLEAN       Result);

STATIC
NTSTATUS
ValidateDriverObjectsWrapper(_In_ PSYSTEM_MODULES SystemModules,
                             _Inout_ PINVALID_DRIVERS_HEAD
                                 InvalidDriverListHead);

STATIC
NTSTATUS
AnalyseNmiData(_In_ PNMI_CONTEXT    NmiContext,
               _In_ PSYSTEM_MODULES SystemModules);

STATIC
NTSTATUS
LaunchNonMaskableInterrupt();

STATIC
VOID
ApcRundownRoutine(_In_ PRKAPC Apc);

STATIC
VOID
ApcKernelRoutine(_In_ PRKAPC                                     Apc,
                 _Inout_ _Deref_pre_maybenull_ PKNORMAL_ROUTINE* NormalRoutine,
                 _Inout_ _Deref_pre_maybenull_ PVOID*            NormalContext,
                 _Inout_ _Deref_pre_maybenull_ PVOID* SystemArgument1,
                 _Inout_ _Deref_pre_maybenull_ PVOID* SystemArgument2);

STATIC
VOID
ApcNormalRoutine(_In_opt_ PVOID NormalContext,
                 _In_opt_ PVOID SystemArgument1,
                 _In_opt_ PVOID SystemArgument2);

STATIC
VOID
ValidateThreadViaKernelApcCallback(_In_ PTHREAD_LIST_ENTRY ThreadListEntry,
                                   _Inout_opt_ PVOID       Context);

#ifdef ALLOC_PRAGMA
#    pragma alloc_text(PAGE, FindSystemModuleByName)
#    pragma alloc_text(PAGE, PopulateWhitelistedModuleBuffer)
#    pragma alloc_text(PAGE, ValidateDriverIOCTLDispatchRegion)
#    pragma alloc_text(PAGE, InitDriverList)
#    pragma alloc_text(PAGE, AddDriverToList)
#    pragma alloc_text(PAGE, RemoveInvalidDriverFromList)
#    pragma alloc_text(PAGE, EnumerateInvalidDrivers)
#    pragma alloc_text(PAGE, ValidateDriverObjectHasBackingModule)
#    pragma alloc_text(PAGE, GetSystemModuleInformation)
#    pragma alloc_text(PAGE, ValidateDriverObjectsWrapper)
#    pragma alloc_text(PAGE, HandleValidateDriversIOCTL)
#    pragma alloc_text(PAGE, IsInstructionPointerInInvalidRegion)
#    pragma alloc_text(PAGE, AnalyseNmiData)
#    pragma alloc_text(PAGE, LaunchNonMaskableInterrupt)
#    pragma alloc_text(PAGE, HandleNmiIOCTL)
#    pragma alloc_text(PAGE, ApcRundownRoutine)
#    pragma alloc_text(PAGE, ApcKernelRoutine)
#    pragma alloc_text(PAGE, ApcNormalRoutine)
#    pragma alloc_text(PAGE, FlipKThreadMiscFlagsFlag)
#    pragma alloc_text(PAGE, ValidateThreadsViaKernelApc)
#    pragma alloc_text(PAGE, ValidateThreadViaKernelApcCallback)
#endif

/*
 * This returns a reference to an entry in the system modules array retrieved
 * via GetSystemModuleInformation. It's important to remember we don't free the
 * modules once we retrieve this reference, and instead only free them when we
 * are done using it.
 */
PRTL_MODULE_EXTENDED_INFO
FindSystemModuleByName(_In_ LPCSTR          ModuleName,
                       _In_ PSYSTEM_MODULES SystemModules)
{
    PAGED_CODE();

    if (!ModuleName || !SystemModules)
        return NULL;

    PRTL_MODULE_EXTENDED_INFO modules =
        (PRTL_MODULE_EXTENDED_INFO)SystemModules->address;

    for (INT index = 0; index < SystemModules->module_count; index++) {
        if (strstr(modules[index].FullPathName, ModuleName)) {
            return &modules[index];
        }
    }

    return NULL;
}

STATIC
NTSTATUS
PopulateWhitelistedModuleBuffer(_Inout_ PVOID        Buffer,
                                _In_ PSYSTEM_MODULES SystemModules)
{
    PAGED_CODE();

    if (!Buffer || !SystemModules)
        return STATUS_INVALID_PARAMETER;

    for (INT index = 0; index < WHITELISTED_MODULE_COUNT; index++) {
        LPCSTR name = WHITELISTED_MODULES[index];

        PRTL_MODULE_EXTENDED_INFO module =
            FindSystemModuleByName(name, SystemModules);

        /* not everyone will contain all whitelisted modules */
        if (!module)
            continue;

        WHITELISTED_REGIONS region = {0};
        region.base                = (UINT64)module->ImageBase;
        region.end                 = region.base + module->ImageSize;

        UINT64 destination =
            (UINT64)Buffer + index * sizeof(WHITELISTED_REGIONS);
        RtlCopyMemory(destination, &region, sizeof(WHITELISTED_REGIONS));
    }

    return STATUS_SUCCESS;
}

STATIC
NTSTATUS
ValidateDriverIOCTLDispatchRegion(_In_ PDRIVER_OBJECT       Driver,
                                  _In_ PSYSTEM_MODULES      Modules,
                                  _In_ PWHITELISTED_REGIONS WhitelistedRegions,
                                  _Out_ PBOOLEAN            Flag)
{
    PAGED_CODE();

    if (!Modules || !Driver || !Flag || !WhitelistedRegions)
        return STATUS_INVALID_PARAMETER;

    UINT64 dispatch_function = 0;
    UINT64 module_base       = 0;
    UINT64 module_end        = 0;

    *Flag = TRUE;

    dispatch_function = Driver->MajorFunction[IRP_MJ_DEVICE_CONTROL];

    if (dispatch_function == NULL)
        return STATUS_SUCCESS;

    PRTL_MODULE_EXTENDED_INFO module =
        (PRTL_MODULE_EXTENDED_INFO)Modules->address;

    for (INT index = 0; index < Modules->module_count; index++) {
        if (module[index].ImageBase != Driver->DriverStart)
            continue;

        /* make sure our driver has a device object which is required
         * for IOCTL */
        if (Driver->DeviceObject == NULL)
            return STATUS_SUCCESS;

        module_base = (UINT64)module[index].ImageBase;
        module_end  = module_base + module[index].ImageSize;

        /* firstly, check if its inside its own module */
        if (dispatch_function >= module_base && dispatch_function <= module_end)
            return STATUS_SUCCESS;

        /*
         * The WDF framework and other low level drivers often hook the
         * dispatch routines when initiating the respective config of
         * their framework or system. With a bit of digging you can view
         * the drivers reponsible for the hooks. What this means is that
         * there will be legit drivers with dispatch routines that point
         * outside of ntoskrnl and their own memory region. So, I have
         * formed a list which contains the drivers that perform these
         * hooks and we iteratively check if the dispatch routine is
         * contained within one of these whitelisted regions. A note on
         * how to imrpove this is the fact that a code cave can be used
         * inside a whitelisted region which then jumps to an invalid
         * region such as a manually mapped driver. So in the future we
         * should implement a function which checks for standard hook
         * implementations like mov rax jmp rax etc.
         */
        for (INT index = 0; index < WHITELISTED_MODULE_COUNT; index++) {
            if (dispatch_function >= WhitelistedRegions[index].base &&
                dispatch_function <= WhitelistedRegions[index].end)
                return STATUS_SUCCESS;
        }

        DEBUG_WARNING("Driver with invalid dispatch routine found: %s",
                      module[index].FullPathName);

        *Flag = FALSE;
        return STATUS_SUCCESS;
    }

    return STATUS_SUCCESS;
}

STATIC
VOID
InitDriverList(_Inout_ PINVALID_DRIVERS_HEAD ListHead)
{
    PAGED_CODE();

    ListHead->count       = 0;
    ListHead->first_entry = NULL;
}

STATIC
NTSTATUS
AddDriverToList(_Inout_ PINVALID_DRIVERS_HEAD InvalidDriversHead,
                _In_ PDRIVER_OBJECT           Driver,
                _In_ INT                      Reason)
{
    PAGED_CODE();

    PINVALID_DRIVER new_entry =
        ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                           sizeof(INVALID_DRIVER),
                           INVALID_DRIVER_LIST_ENTRY_POOL);

    if (!new_entry)
        return STATUS_MEMORY_NOT_ALLOCATED;

    new_entry->driver               = Driver;
    new_entry->reason               = Reason;
    new_entry->next                 = InvalidDriversHead->first_entry;
    InvalidDriversHead->first_entry = new_entry;

    return STATUS_SUCCESS;
}

STATIC
VOID
RemoveInvalidDriverFromList(_Inout_ PINVALID_DRIVERS_HEAD InvalidDriversHead)
{
    PAGED_CODE();

    if (InvalidDriversHead->first_entry) {
        PINVALID_DRIVER entry           = InvalidDriversHead->first_entry;
        InvalidDriversHead->first_entry = InvalidDriversHead->first_entry->next;
        ImpExFreePoolWithTag(entry, INVALID_DRIVER_LIST_ENTRY_POOL);
    }
}

STATIC
VOID
EnumerateInvalidDrivers(_In_ PINVALID_DRIVERS_HEAD InvalidDriversHead)
{
    PAGED_CODE();

    PINVALID_DRIVER entry = InvalidDriversHead->first_entry;

    while (entry != NULL) {
        DEBUG_VERBOSE("Invalid Driver: %wZ", entry->driver->DriverName);
        entry = entry->next;
    }
}

STATIC
NTSTATUS
ValidateDriverObjectHasBackingModule(_In_ PSYSTEM_MODULES ModuleInformation,
                                     _In_ PDRIVER_OBJECT  DriverObject,
                                     _Out_ PBOOLEAN       Result)
{
    PAGED_CODE();

    if (!ModuleInformation || !DriverObject || !Result)
        return STATUS_INVALID_PARAMETER;

    PRTL_MODULE_EXTENDED_INFO module =
        (PRTL_MODULE_EXTENDED_INFO)ModuleInformation->address;

    for (INT index = 0; index < ModuleInformation->module_count; index++) {
        if (module[index].ImageSize == 0 || module[index].ImageBase == 0)
            return STATUS_INVALID_MEMBER;

        if (module[index].ImageBase == DriverObject->DriverStart) {
            *Result = TRUE;
            return STATUS_SUCCESS;
        }
    }

    DEBUG_WARNING("Driver found with no backing system image at address: %llx",
                  (UINT64)DriverObject->DriverStart);

    *Result = FALSE;
    return STATUS_SUCCESS;
}

// https://imphash.medium.com/windows-process-internals-a-few-concepts-to-know-before-jumping-on-memory-forensics-part-3-4a0e195d947b
NTSTATUS
GetSystemModuleInformation(_Out_ PSYSTEM_MODULES ModuleInformation)
{
    PAGED_CODE();

    if (!ModuleInformation)
        return STATUS_INVALID_PARAMETER;

    ULONG    size   = 0;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    status = RtlQueryModuleInformation(
        &size, sizeof(RTL_MODULE_EXTENDED_INFO), NULL);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("RtlQueryModuleInformation failed with status %x", status);
        return status;
    }

    PRTL_MODULE_EXTENDED_INFO driver_information =
        ExAllocatePool2(POOL_FLAG_NON_PAGED, size, SYSTEM_MODULES_POOL);

    if (!driver_information) {
        DEBUG_ERROR("Failed to allocate pool LOL");
        return STATUS_MEMORY_NOT_ALLOCATED;
    }

    status = RtlQueryModuleInformation(
        &size, sizeof(RTL_MODULE_EXTENDED_INFO), driver_information);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("RtlQueryModuleInformation 2 failed with status %x",
                    status);
        ExFreePoolWithTag(driver_information, SYSTEM_MODULES_POOL);
        return STATUS_ABANDONED;
    }

    ModuleInformation->address      = driver_information;
    ModuleInformation->module_count = size / sizeof(RTL_MODULE_EXTENDED_INFO);

    return status;
}

STATIC
VOID
ValidateDriverObjects(_In_ PSYSTEM_MODULES          SystemModules,
                      _In_ POBJECT_DIRECTORY_ENTRY  Entry,
                      _Inout_ PINVALID_DRIVERS_HEAD Head,
                      _In_ PVOID                    Whitelist)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    if (!Entry)
        return;

    POBJECT_DIRECTORY_ENTRY sub_entry = Entry;

    while (sub_entry) {
        BOOLEAN        flag           = FALSE;
        PDRIVER_OBJECT current_driver = sub_entry->Object;

        status = ValidateDriverObjectHasBackingModule(
            SystemModules, current_driver, &flag);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR(
                "ValidateDriverObjectHasBackingModule failed with status %x",
                status);
            return;
        }

        if (!flag) {
            status =
                AddDriverToList(Head, current_driver, REASON_NO_BACKING_MODULE);

            if (NT_SUCCESS(status))
                Head->count += 1;
        }

        status = ValidateDriverIOCTLDispatchRegion(
            current_driver, SystemModules, Whitelist, &flag);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR(
                "ValidateDriverIOCTLDispatchRegion failed with status %x",
                status);
            return;
        }

        if (!flag) {
            status = AddDriverToList(
                Head, current_driver, REASON_INVALID_IOCTL_DISPATCH);
            if (NT_SUCCESS(status))
                Head->count += 1;
        }

        sub_entry = sub_entry->ChainLink;
    }
}

/* TODO: this function needs to be rewritten. Infact, this entire file needs to
 * be rewritten.
 * god this is so bad.
 */
STATIC
NTSTATUS
ValidateDriverObjectsWrapper(_In_ PSYSTEM_MODULES          SystemModules,
                             _Inout_ PINVALID_DRIVERS_HEAD Head)
{
    PAGED_CODE();

    if (!SystemModules || !Head)
        return STATUS_INVALID_PARAMETER;

    HANDLE            handle                     = NULL;
    OBJECT_ATTRIBUTES attributes                 = {0};
    PVOID             directory                  = {0};
    UNICODE_STRING    directory_name             = {0};
    PVOID             whitelisted_regions_buffer = NULL;
    NTSTATUS          status                     = STATUS_UNSUCCESSFUL;
    POBJECT_DIRECTORY directory_object           = NULL;

    ImpRtlInitUnicodeString(&directory_name, L"\\Driver");

    InitializeObjectAttributes(
        &attributes, &directory_name, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status =
        ImpZwOpenDirectoryObject(&handle, DIRECTORY_ALL_ACCESS, &attributes);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ZwOpenDirectoryObject failed with status %x", status);
        return status;
    }

    status = ImpObReferenceObjectByHandle(
        handle, DIRECTORY_ALL_ACCESS, NULL, KernelMode, &directory, NULL);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ObReferenceObjectByHandle failed with status %x", status);
        ImpZwClose(handle);
        return status;
    }

    /*
     * Windows organises its drivers in object directories (not the same as
     * files directories). For the driver directory, there are 37 entries,
     * each driver is hashed and indexed. If there is a driver with a
     * duplicate index, it is inserted into same index in a linked list
     * using the _OBJECT_DIRECTORY_ENTRY struct. So to enumerate all drivers
     * we visit each entry in the hashmap, enumerate all objects in the
     * linked list at entry j then we increment the hashmap index i. The
     * motivation behind this is that when a driver is accessed, it is
     * brought to the first index in the linked list, so drivers that are
     * accessed the most can be accessed quickly
     */

    directory_object = (POBJECT_DIRECTORY)directory;

    ImpExAcquirePushLockExclusiveEx(&directory_object->Lock, NULL);

    whitelisted_regions_buffer =
        ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                           WHITELISTED_MODULE_COUNT * MODULE_MAX_STRING_SIZE,
                           WHITELISTED_MODULE_TAG);

    if (!whitelisted_regions_buffer)
        goto end;

    status = PopulateWhitelistedModuleBuffer(whitelisted_regions_buffer,
                                             SystemModules);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("PopulateWhitelistedModuleBuffer failed with status %x",
                    status);
        goto end;
    }

    for (INT index = 0; index < NUMBER_HASH_BUCKETS; index++) {
        POBJECT_DIRECTORY_ENTRY entry = directory_object->HashBuckets[index];
        ValidateDriverObjects(
            SystemModules, entry, Head, whitelisted_regions_buffer);
    }

end:
    if (whitelisted_regions_buffer)
        ImpExFreePoolWithTag(whitelisted_regions_buffer,
                             WHITELISTED_MODULE_TAG);

    ImpExReleasePushLockExclusiveEx(&directory_object->Lock, 0);
    ImpObDereferenceObject(directory);
    ImpZwClose(handle);

    return STATUS_SUCCESS;
}

NTSTATUS
HandleValidateDriversIOCTL()
{
    PAGED_CODE();

    NTSTATUS                         status         = STATUS_UNSUCCESSFUL;
    ULONG                            buffer_size    = 0;
    SYSTEM_MODULES                   system_modules = {0};
    MODULE_VALIDATION_FAILURE_HEADER header         = {0};
    PINVALID_DRIVERS_HEAD            head           = NULL;

    /* Fix annoying visual studio linting error */
    RtlZeroMemory(&system_modules, sizeof(SYSTEM_MODULES));

    status = GetSystemModuleInformation(&system_modules);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetSystemModuleInformation failed with status %x", status);
        return status;
    }

    head = ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                              sizeof(INVALID_DRIVERS_HEAD),
                              INVALID_DRIVER_LIST_HEAD_POOL);

    if (!head) {
        ImpExFreePoolWithTag(system_modules.address, SYSTEM_MODULES_POOL);
        return STATUS_MEMORY_NOT_ALLOCATED;
    }

    /*
     * Use a linked list here so that so we have easy access to the invalid
     * drivers which we can then use to copy the drivers logic for further
     * analysis in identifying drivers specifically used for the purpose of
     * cheating
     */

    InitDriverList(head);

    status = ValidateDriverObjectsWrapper(&system_modules, head);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ValidateDriverObjects failed with status %x", status);
        goto end;
    }

    header.module_count =
        head->count >= MODULE_VALIDATION_FAILURE_MAX_REPORT_COUNT
            ? MODULE_VALIDATION_FAILURE_MAX_REPORT_COUNT
            : head->count;

    if (head->count == 0) {
        DEBUG_INFO("Found no invalid drivers on the system.");
        goto end;
    }

    DEBUG_VERBOSE("System has an invalid driver count of: %i", head->count);

    for (INT index = 0; index < head->count; index++) {
        /* make sure we free any non reported modules */
        if (index >= MODULE_VALIDATION_FAILURE_MAX_REPORT_COUNT) {
            RemoveInvalidDriverFromList(head);
            continue;
        }

        PMODULE_VALIDATION_FAILURE report =
            ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                               sizeof(MODULE_VALIDATION_FAILURE),
                               POOL_TAG_INTEGRITY);

        if (!report)
            continue;

        report->report_code         = REPORT_MODULE_VALIDATION_FAILURE;
        report->report_type         = head->first_entry->reason;
        report->driver_base_address = head->first_entry->driver->DriverStart;
        report->driver_size         = head->first_entry->driver->DriverSize;

        ANSI_STRING string   = {0};
        string.Length        = 0;
        string.MaximumLength = MODULE_REPORT_DRIVER_NAME_BUFFER_SIZE;
        string.Buffer        = &report->driver_name;

        status = ImpRtlUnicodeStringToAnsiString(
            &string, &head->first_entry->driver->DriverName, FALSE);

        /* still continue if we fail to get the driver name */
        if (!NT_SUCCESS(status))
            DEBUG_ERROR("RtlUnicodeStringToAnsiString failed with status %x",
                        status);

        status = IrpQueueCompleteIrp(report, sizeof(MODULE_VALIDATION_FAILURE));

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR("IrpQueueCompleteIrp failed with status %x", status);
            continue;
        }

        RemoveInvalidDriverFromList(head);
    }
end:
    ImpExFreePoolWithTag(head, INVALID_DRIVER_LIST_HEAD_POOL);
    ImpExFreePoolWithTag(system_modules.address, SYSTEM_MODULES_POOL);

    return status;
}

/*
 * TODO: this probably doesnt need to return an NTSTATUS, we can just return a
 * boolean and remove the out variable.
 */
NTSTATUS
IsInstructionPointerInInvalidRegion(_In_ UINT64          RIP,
                                    _In_ PSYSTEM_MODULES SystemModules,
                                    _Out_ PBOOLEAN       Result)
{
    PAGED_CODE();

    if (!RIP || !SystemModules || !Result)
        return STATUS_INVALID_PARAMETER;

    PRTL_MODULE_EXTENDED_INFO modules =
        (PRTL_MODULE_EXTENDED_INFO)SystemModules->address;

    /* Note that this does not check for HAL or PatchGuard Execution */
    for (INT index = 0; index < SystemModules->module_count; index++) {
        UINT64 base = (UINT64)modules[index].ImageBase;
        UINT64 end  = base + modules[index].ImageSize;

        if (RIP >= base && RIP <= end) {
            *Result = TRUE;
            return STATUS_SUCCESS;
        }
    }

    *Result = FALSE;
    return STATUS_SUCCESS;
}

NTSTATUS
IsInstructionPointerInsideModule(_In_ UINT64                    Rip,
                                 _In_ PRTL_MODULE_EXTENDED_INFO Module,
                                 _Out_ PBOOLEAN                 Result)
{
    UINT64 base = (UINT64)Module->ImageBase;
    UINT64 end  = base + Module->ImageSize;

    if (Rip >= base && Rip <= end) {
        *Result = TRUE;
        return STATUS_SUCCESS;
    }

    *Result = FALSE;
    return STATUS_SUCCESS;
}

STATIC
VOID
ReportNmiBlocking()
{
    PNMI_CALLBACK_FAILURE report = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, sizeof(NMI_CALLBACK_FAILURE), REPORT_POOL_TAG);

    if (!report)
        return STATUS_INSUFFICIENT_RESOURCES;

    report->report_code        = REPORT_NMI_CALLBACK_FAILURE;
    report->kthread_address    = NULL;
    report->invalid_rip        = NULL;
    report->were_nmis_disabled = TRUE;

    IrpQueueCompleteIrp(report, sizeof(NMI_CALLBACK_FAILURE));
}

STATIC
VOID
ReportMissingCidTableEntry(_In_ PNMI_CONTEXT Context)
{
    DEBUG_WARNING("Thread: %llx was not found in the pspcid table.",
                  Context->kthread);

    PHIDDEN_SYSTEM_THREAD_REPORT report =
        ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                           sizeof(HIDDEN_SYSTEM_THREAD_REPORT),
                           REPORT_POOL_TAG);

    if (!report)
        return;

    report->report_code          = REPORT_HIDDEN_SYSTEM_THREAD;
    report->found_in_kthreadlist = FALSE; // wip
    report->found_in_pspcidtable = FALSE;
    report->thread_id            = ImpPsGetThreadId(Context->kthread);
    report->thread_address       = Context->kthread;

    RtlCopyMemory(report->thread, Context->kthread, sizeof(report->thread));
    IrpQueueCompleteIrp(report, sizeof(HIDDEN_SYSTEM_THREAD_REPORT));
}

STATIC
VOID
ReportInvalidRipFoundDuringNmi(_In_ PNMI_CONTEXT Context)
{
    PNMI_CALLBACK_FAILURE report =
        ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                           sizeof(HIDDEN_SYSTEM_THREAD_REPORT),
                           REPORT_POOL_TAG);

    report->report_code        = REPORT_NMI_CALLBACK_FAILURE;
    report->kthread_address    = Context->kthread;
    report->invalid_rip        = Context->interrupted_rip;
    report->were_nmis_disabled = FALSE;

    IrpQueueCompleteIrp(report, sizeof(HIDDEN_SYSTEM_THREAD_REPORT));
}

/*
 * todo: i think we should split this function up into each analysis i.e one for
 * the interrupted rip, one for the cid etc.
 */
STATIC
NTSTATUS
AnalyseNmiData(_In_ PNMI_CONTEXT NmiContext, _In_ PSYSTEM_MODULES SystemModules)
{
    PAGED_CODE();

    NTSTATUS status = STATUS_UNSUCCESSFUL;
    BOOLEAN  flag   = FALSE;

    if (!NmiContext || !SystemModules)
        return STATUS_INVALID_PARAMETER;

    for (INT core = 0; core < ImpKeQueryActiveProcessorCount(0); core++) {
        /* Make sure our NMIs were run  */
        if (!NmiContext[core].callback_count) {
            ReportNmiBlocking();
            return STATUS_SUCCESS;
        }

        DEBUG_VERBOSE(
            "Analysing Nmi Data for: cpu number: %i callback count: %lx",
            core,
            NmiContext[core].callback_count);

        /*
         * Our NMI callback allows us to interrupt every running thread
         * on each core. Now it is common practice for malicious
         * programs to either unlink their thread from the KTHREAD
         * linked list or remove their threads entry from the
         * PspCidTable or both. Now the reason an unlinked thread can
         * still be scheduled is because the scheduler keeps a seperate
         * list that it uses to schedule threads. It then places these
         * threads in the KPRCB in either the CurrentThread, IdleThread
         * or NextThread.
         *
         * Since you can't just set a threads affinity to enumerate over
         * all cores and read the KPCRB->CurrentThread (since it will
         * just show your thread) we have to interrupt the thread. So
         * below we are validating that the thread is indeed in our own
         * threads list using our callback routine and then using
         * PsGetThreadId
         *
         * I also want to integrate a way to SAFELY determine whether a
         * thread has been removed from the KTHREADs linked list, maybe
         * PsGetNextProcess ?
         */

        if (!ValidateThreadsPspCidTableEntry(NmiContext[core].kthread)) {
            ReportMissingCidTableEntry(&NmiContext[core]);
        }

        if (NmiContext[core].user_thread)
            continue;

        status = IsInstructionPointerInInvalidRegion(
            NmiContext[core].interrupted_rip, SystemModules, &flag);

        if (!NT_SUCCESS(status)) {
            continue;
        }

        if (!flag) {
            ReportInvalidRipFoundDuringNmi(&NmiContext[core]);
            return STATUS_SUCCESS;
        }
    }

    return STATUS_SUCCESS;
}

STATIC
BOOLEAN
NmiCallback(_Inout_opt_ PVOID Context, _In_ BOOLEAN Handled)
{
    UNREFERENCED_PARAMETER(Handled);

    PNMI_CONTEXT           context       = (PNMI_CONTEXT)Context;
    ULONG                  core          = KeGetCurrentProcessorNumber();
    UINT64                 kpcr          = 0;
    TASK_STATE_SEGMENT_64* tss           = NULL;
    PMACHINE_FRAME         machine_frame = NULL;

    /*
     * To find the IRETQ frame (MACHINE_FRAME) we need to find the top of
     * the NMI ISR stack. This is stored at TSS->Ist[3]. To find the TSS, we
     * can read it from KPCR->TSS_BASE. Once we have our TSS, we can read
     * the value at TSS->Ist[3] which points to the top of the ISR stack,
     * and subtract the size of the MACHINE_FRAME struct. Allowing us read
     * the interrupted RIP.
     *
     * The reason this is needed is because RtlCaptureStackBackTrace is not
     * safe to run at IRQL = HIGH_LEVEL, hence we need to manually unwind
     * the ISR stack to find the interrupted rip.
     */
    kpcr          = __readmsr(IA32_GS_BASE);
    tss           = *(TASK_STATE_SEGMENT_64**)(kpcr + KPCR_TSS_BASE_OFFSET);
    machine_frame = tss->Ist3 - sizeof(MACHINE_FRAME);

    if (machine_frame->rip <= WINDOWS_USERMODE_MAX_ADDRESS)
        context[core].user_thread = TRUE;

    context[core].interrupted_rip = machine_frame->rip;
    context[core].interrupted_rsp = machine_frame->rsp;
    context[core].kthread         = PsGetCurrentThread();
    context[core].callback_count++;

    DEBUG_VERBOSE(
        "[NMI CALLBACK]: Core Number: %lx, Interrupted RIP: %llx, Interrupted RSP: %llx",
        core,
        machine_frame->rip,
        machine_frame->rsp);

    return TRUE;
}

#define NMI_DELAY_TIME 200 * 10000

STATIC
NTSTATUS
LaunchNonMaskableInterrupt()
{
    PAGED_CODE();

    PKAFFINITY_EX ProcAffinityPool = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, sizeof(KAFFINITY_EX), PROC_AFFINITY_POOL);

    if (!ProcAffinityPool)
        return STATUS_MEMORY_NOT_ALLOCATED;

    LARGE_INTEGER delay = {0};
    delay.QuadPart -= NMI_DELAY_TIME;

    for (ULONG core = 0; core < ImpKeQueryActiveProcessorCount(0); core++) {
        ImpKeInitializeAffinityEx(ProcAffinityPool);
        ImpKeAddProcessorAffinityEx(ProcAffinityPool, core);

        HalSendNMI(ProcAffinityPool);

        /*
         * Only a single NMI can be active at any given time, so
         * arbitrarily delay execution  to allow time for the NMI to be
         * processed
         */
        ImpKeDelayExecutionThread(KernelMode, FALSE, &delay);
    }

    ImpExFreePoolWithTag(ProcAffinityPool, PROC_AFFINITY_POOL);
    return STATUS_SUCCESS;
}

NTSTATUS
HandleNmiIOCTL()
{
    PAGED_CODE();

    NTSTATUS       status          = STATUS_UNSUCCESSFUL;
    PVOID          callback_handle = NULL;
    SYSTEM_MODULES system_modules  = {0};
    PNMI_CONTEXT   nmi_context     = NULL;

    UINT32 size = ImpKeQueryActiveProcessorCount(0) * sizeof(NMI_CONTEXT);

    if (IsNmiInProgress())
        return STATUS_ALREADY_COMMITTED;

    status = ValidateHalDispatchTables();

    /* do we continue ? probably. */
    if (!NT_SUCCESS(status))
        DEBUG_ERROR("ValidateHalDispatchTables failed with status %x", status);

    nmi_context =
        ImpExAllocatePool2(POOL_FLAG_NON_PAGED, size, NMI_CONTEXT_POOL);

    if (!nmi_context) {
        UnsetNmiInProgressFlag();
        return STATUS_MEMORY_NOT_ALLOCATED;
    }

    /*
     * We want to register and unregister our callback each time so it
     * becomes harder for people to hook our callback and get up to some
     * funny business
     */
    callback_handle = ImpKeRegisterNmiCallback(NmiCallback, nmi_context);

    if (!callback_handle) {
        DEBUG_ERROR("KeRegisterNmiCallback failed with no status.");
        ImpExFreePoolWithTag(nmi_context, NMI_CONTEXT_POOL);
        UnsetNmiInProgressFlag();
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * We query the system modules each time since they can potentially
     * change at any time
     */
    status = GetSystemModuleInformation(&system_modules);

    if (!NT_SUCCESS(status)) {
        ImpKeDeregisterNmiCallback(callback_handle);
        ImpExFreePoolWithTag(nmi_context, NMI_CONTEXT_POOL);
        DEBUG_ERROR("Error retriving system module information");
        UnsetNmiInProgressFlag();
        return status;
    }

    status = LaunchNonMaskableInterrupt();

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("Error running NMI callbacks");
        ImpKeDeregisterNmiCallback(callback_handle);
        ImpExFreePoolWithTag(system_modules.address, SYSTEM_MODULES_POOL);
        ImpExFreePoolWithTag(nmi_context, NMI_CONTEXT_POOL);
        UnsetNmiInProgressFlag();
        return status;
    }

    status = AnalyseNmiData(nmi_context, &system_modules);

    if (!NT_SUCCESS(status))
        DEBUG_ERROR("Error analysing nmi data");

    ImpExFreePoolWithTag(system_modules.address, SYSTEM_MODULES_POOL);
    ImpExFreePoolWithTag(nmi_context, NMI_CONTEXT_POOL);
    ImpKeDeregisterNmiCallback(callback_handle);
    UnsetNmiInProgressFlag();
    return status;
}

/*
 * The RundownRoutine is executed if the thread terminates before the APC was
 * delivered to user mode.
 */
STATIC
VOID
ApcRundownRoutine(_In_ PRKAPC Apc)
{
    PAGED_CODE();
    FreeApcAndDecrementApcCount(Apc, APC_CONTEXT_ID_STACKWALK);
}

STATIC
VOID
ReportApcStackwalkViolation(_In_ UINT64 Rip)
{
    PAPC_STACKWALK_REPORT report = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, sizeof(APC_STACKWALK_REPORT), REPORT_POOL_TAG);

    if (!report)
        return;

    report->report_code     = REPORT_APC_STACKWALK;
    report->kthread_address = (UINT64)KeGetCurrentThread();
    report->invalid_rip     = Rip;

    IrpQueueCompleteIrp(report, sizeof(APC_STACKWALK_REPORT));
}

/*
 * The KernelRoutine is executed in kernel mode at APC_LEVEL before the APC is
 * delivered. This is also where we want to free our APC object.
 */
STATIC
VOID
ApcKernelRoutine(_In_ PRKAPC                                     Apc,
                 _Inout_ _Deref_pre_maybenull_ PKNORMAL_ROUTINE* NormalRoutine,
                 _Inout_ _Deref_pre_maybenull_ PVOID*            NormalContext,
                 _Inout_ _Deref_pre_maybenull_ PVOID* SystemArgument1,
                 _Inout_ _Deref_pre_maybenull_ PVOID* SystemArgument2)
{
    PAGED_CODE();

    NTSTATUS               status            = STATUS_UNSUCCESSFUL;
    PVOID                  buffer            = NULL;
    INT                    frames_captured   = 0;
    PUINT64                frames            = 0;
    BOOLEAN                flag              = FALSE;
    PAPC_STACKWALK_CONTEXT context           = NULL;
    PTHREAD_LIST_ENTRY     thread_list_entry = NULL;

    context = (PAPC_STACKWALK_CONTEXT)Apc->NormalContext;

    FindThreadListEntryByThreadAddress(KeGetCurrentThread(),
                                       &thread_list_entry);

    if (!thread_list_entry)
        return;

    buffer = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, STACK_FRAME_POOL_SIZE, POOL_TAG_APC);

    if (!buffer)
        goto free;

    frames_captured = ImpRtlCaptureStackBackTrace(
        NULL, STACK_FRAME_POOL_SIZE / sizeof(UINT64), buffer, NULL);

    if (!frames_captured)
        goto free;

    for (INT index = 0; index < frames_captured; index++) {
        frames = (PUINT64)buffer;

        /*
         * Apc->NormalContext holds the address of our context data
         * structure that we passed into KeInitializeApc as the last
         * argument.
         */
        status = IsInstructionPointerInInvalidRegion(
            frames[index], context->modules, &flag);

        if (!NT_SUCCESS(status)) {
            goto free;
        }

        if (!flag)
            ReportApcStackwalkViolation(frames[index]);
    }

free:

    if (buffer)
        ImpExFreePoolWithTag(buffer, POOL_TAG_APC);

    FreeApcAndDecrementApcCount(Apc, APC_CONTEXT_ID_STACKWALK);

    thread_list_entry->apc        = NULL;
    thread_list_entry->apc_queued = FALSE;
}

/*
 * The NormalRoutine is executed in user mode when the APC is delivered.
 */
STATIC
VOID
ApcNormalRoutine(_In_opt_ PVOID NormalContext,
                 _In_opt_ PVOID SystemArgument1,
                 _In_opt_ PVOID SystemArgument2)
{
    PAGED_CODE();
}

#define THREAD_STATE_TERMINATED 4
#define THREAD_STATE_WAIT       5
#define THREAD_STATE_INIT       0

STATIC
VOID
ValidateThreadViaKernelApcCallback(_In_ PTHREAD_LIST_ENTRY ThreadListEntry,
                                   _Inout_opt_ PVOID       Context)
{
    PAGED_CODE();

    PKAPC                  apc           = NULL;
    BOOLEAN                apc_status    = FALSE;
    PLONG                  flags         = NULL;
    PCHAR                  previous_mode = NULL;
    PUCHAR                 state         = NULL;
    BOOLEAN                apc_queueable = FALSE;
    LPCSTR                 process_name  = NULL;
    PAPC_STACKWALK_CONTEXT context       = (PAPC_STACKWALK_CONTEXT)Context;

    process_name =
        ImpPsGetProcessImageFileName(ThreadListEntry->owning_process);

    /*
     * Its possible to set the KThread->ApcQueueable flag to false ensuring
     * that no APCs can be queued to the thread, as KeInsertQueueApc will
     * check this flag before queueing an APC so lets make sure we flip this
     * before before queueing ours. Since we filter out any system threads
     * this should be fine... c:
     */
    flags =
        (PLONG)((UINT64)ThreadListEntry->thread + KTHREAD_MISC_FLAGS_OFFSET);
    previous_mode =
        (PCHAR)((UINT64)ThreadListEntry->thread + KTHREAD_PREVIOUS_MODE_OFFSET);
    state = (PUCHAR)((UINT64)ThreadListEntry->thread + KTHREAD_STATE_OFFSET);

    /*
     * For now, lets only check for system threads. However, we also want to
     * check for threads executing in kernel mode, i.e KTHREAD->PreviousMode
     * == UserMode.
     */
    if (ThreadListEntry->owning_process != PsInitialSystemProcess)
        return;

    if (ThreadListEntry->thread == KeGetCurrentThread() ||
        !ThreadListEntry->thread)
        return;

    DEBUG_VERBOSE(
        "Validating thread: %llx, process name: %s via kernel APC stackwalk.",
        ThreadListEntry->thread,
        process_name);

    SetFlag(*flags, KTHREAD_MISC_FLAGS_ALERTABLE);
    SetFlag(*flags, KTHREAD_MISC_FLAGS_APC_QUEUEABLE);

    apc = (PKAPC)ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, sizeof(KAPC), POOL_TAG_APC);

    if (!apc)
        return;

    ImpKeInitializeApc(apc,
                       ThreadListEntry->thread,
                       OriginalApcEnvironment,
                       ApcKernelRoutine,
                       ApcRundownRoutine,
                       ApcNormalRoutine,
                       KernelMode,
                       Context);

    apc_status = ImpKeInsertQueueApc(apc, NULL, NULL, IO_NO_INCREMENT);

    if (!apc_status) {
        DEBUG_ERROR("KeInsertQueueApc failed with no status.");
        ImpExFreePoolWithTag(apc, POOL_TAG_APC);
        return;
    }

    ThreadListEntry->apc        = apc;
    ThreadListEntry->apc_queued = TRUE;

    IncrementApcCount(APC_CONTEXT_ID_STACKWALK);
}

/*
 * Since NMIs are only executed on the thread that is running on each logical
 * core, it makes sense to make use of APCs that, while can be masked off,
 * provide us to easily issue a callback routine to threads we want a stack
 * trace of. Hence by utilising both APCs and NMIs we get excellent coverage of
 * the entire system.
 */
NTSTATUS
ValidateThreadsViaKernelApc()
{
    PAGED_CODE();

    NTSTATUS               status  = STATUS_UNSUCCESSFUL;
    PAPC_STACKWALK_CONTEXT context = NULL;

    /* First, ensure we dont already have an ongoing operation */
    GetApcContext(&context, APC_CONTEXT_ID_STACKWALK);

    if (context) {
        DEBUG_WARNING("Existing APC_STACKWALK operation already in progress.");
        return STATUS_SUCCESS;
    }

    context = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, sizeof(APC_STACKWALK_CONTEXT), POOL_TAG_APC);

    if (!context)
        return STATUS_MEMORY_NOT_ALLOCATED;

    context->header.context_id = APC_CONTEXT_ID_STACKWALK;
    context->modules           = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, sizeof(SYSTEM_MODULES), POOL_TAG_APC);

    if (!context->modules) {
        ImpExFreePoolWithTag(context, POOL_TAG_APC);
        return STATUS_MEMORY_NOT_ALLOCATED;
    }

    status = GetSystemModuleInformation(context->modules);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetSystemModuleInformation failed with status %x", status);
        ImpExFreePoolWithTag(context->modules, POOL_TAG_APC);
        ImpExFreePoolWithTag(context, POOL_TAG_APC);
        return STATUS_MEMORY_NOT_ALLOCATED;
    }

    InsertApcContext(context);

    context->header.allocation_in_progress = TRUE;
    EnumerateThreadListWithCallbackRoutine(ValidateThreadViaKernelApcCallback,
                                           context);
    context->header.allocation_in_progress = FALSE;

    return status;
}

VOID
FreeApcStackwalkApcContextInformation(_Inout_ PAPC_STACKWALK_CONTEXT Context)
{
    if (Context->modules->address)
        ImpExFreePoolWithTag(Context->modules->address, SYSTEM_MODULES_POOL);
    if (Context->modules)
        ImpExFreePoolWithTag(Context->modules, POOL_TAG_APC);
}

#define DPC_STACKWALK_STACKFRAME_COUNT 10

/* the first 3 frames are isr handlers which we dont care about */
#define DPC_STACKWALK_FRAMES_TO_SKIP 3

typedef struct _DPC_CONTEXT {
    UINT64           stack_frame[DPC_STACKWALK_STACKFRAME_COUNT];
    UINT16           frames_captured;
    volatile BOOLEAN executed;

} DPC_CONTEXT, *PDPC_CONTEXT;

VOID
DpcStackwalkCallbackRoutine(_In_ PKDPC     Dpc,
                            _In_opt_ PVOID DeferredContext,
                            _In_opt_ PVOID SystemArgument1,
                            _In_opt_ PVOID SystemArgument2)
{
    PDPC_CONTEXT context =
        &((PDPC_CONTEXT)DeferredContext)[KeGetCurrentProcessorNumber()];

    context->frames_captured =
        ImpRtlCaptureStackBackTrace(DPC_STACKWALK_FRAMES_TO_SKIP,
                                    DPC_STACKWALK_STACKFRAME_COUNT,
                                    &context->stack_frame,
                                    NULL);
    InterlockedExchange(&context->executed, TRUE);
    ImpKeSignalCallDpcDone(SystemArgument1);

    DEBUG_VERBOSE("Executed DPC on core: %lx, with %lx frames captured.",
                  KeGetCurrentProcessorNumber(),
                  context->frames_captured);
}

STATIC
BOOLEAN
CheckForDpcCompletion(_In_ PDPC_CONTEXT Context)
{
    for (UINT32 index = 0; index < ImpKeQueryActiveProcessorCount(0); index++) {
        if (!InterlockedExchange(&Context[index].executed,
                                 Context[index].executed))
            return FALSE;
    }

    return TRUE;
}

STATIC
VOID
ReportDpcStackwalkViolation(_In_ PDPC_CONTEXT Context, _In_ UINT64 Frame)
{
    PDPC_STACKWALK_REPORT report = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, sizeof(DPC_STACKWALK_REPORT), REPORT_POOL_TAG);

    if (!report)
        return;

    report->report_code     = REPORT_DPC_STACKWALK;
    report->kthread_address = PsGetCurrentThread();
    report->invalid_rip     = Frame;

    // RtlCopyMemory(report->driver,
    //               (UINT64)Context[core].stack_frame[frame]
    //               - 0x50,
    //               APC_STACKWALK_BUFFER_SIZE);

    IrpQueueCompleteIrp(report, sizeof(DPC_STACKWALK_REPORT));
}

STATIC
VOID
ValidateDpcStackFrame(_In_ PDPC_CONTEXT Context, _In_ PSYSTEM_MODULES Modules)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    BOOLEAN  flag   = FALSE;

    for (UINT32 frame = 0; frame < Context->frames_captured; frame++) {
        UINT64 rip = Context->stack_frame[frame];
        status     = IsInstructionPointerInInvalidRegion(rip, Modules, &flag);

        if (!NT_SUCCESS(status))
            return;

        if (!flag)
            ReportDpcStackwalkViolation(Context, rip);
    }
}

STATIC
VOID
ValidateDpcCapturedStack(_In_ PSYSTEM_MODULES Modules,
                         _In_ PDPC_CONTEXT    Context)
{
    BOOLEAN               flag   = FALSE;
    PDPC_STACKWALK_REPORT report = NULL;
    UINT32                count  = ImpKeQueryActiveProcessorCount(0);

    for (UINT32 core = 0; core < count; core++) {
        ValidateDpcStackFrame(&Context[core], Modules);
    }
}

/*
 * Lets use DPCs as another form of stackwalking rather then inter-process
 * interrupts because DPCs run at IRQL = DISPATCH_LEVEL, allowing us to use
 * functions such as RtlCaptureStackBackTrace whereas IPIs run at IRQL =
 * IPI_LEVEL. DPCs are also harder to mask compared to APCs which can be masked
 * with the flip of a bit in the KTHREAD structure.
 */
NTSTATUS
DispatchStackwalkToEachCpuViaDpc()
{
    NTSTATUS       status  = STATUS_UNSUCCESSFUL;
    PDPC_CONTEXT   context = NULL;
    SYSTEM_MODULES modules = {0};
    UINT32 size = ImpKeQueryActiveProcessorCount(0) * sizeof(DPC_CONTEXT);

    context = ImpExAllocatePool2(POOL_FLAG_NON_PAGED, size, POOL_TAG_DPC);

    if (!context)
        return STATUS_MEMORY_NOT_ALLOCATED;

    status = GetSystemModuleInformation(&modules);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetSystemModuleInformation failed with status %x", status);
        goto end;
    }

    /* KeGenericCallDpc will queue a DPC to each processor with importance =
     * HighImportance. This means our DPC will be inserted into the front of
     * the DPC queue and executed immediately.*/
    ImpKeGenericCallDpc(DpcStackwalkCallbackRoutine, context);

    while (!CheckForDpcCompletion(context))
        YieldProcessor();

    ValidateDpcCapturedStack(&modules, context);

    DEBUG_VERBOSE("Finished validating cores via dpc");
end:

    if (modules.address)
        ImpExFreePoolWithTag(modules.address, SYSTEM_MODULES_POOL);
    if (context)
        ImpExFreePoolWithTag(context, POOL_TAG_DPC);

    return status;
}

/* todo: walk the chain of pointers to prevent jmp chaining */
STATIC
NTSTATUS
ValidateTableDispatchRoutines(_In_ PVOID*          Base,
                              _In_ UINT32          Entries,
                              _In_ PSYSTEM_MODULES Modules,
                              _Out_ PVOID*         Routine)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    BOOLEAN  flag   = FALSE;

    for (UINT32 index = 0; index < Entries; index++) {
        if (!Base[index])
            continue;

        status =
            IsInstructionPointerInInvalidRegion(Base[index], Modules, &flag);

        if (!NT_SUCCESS(status)) {
            DEBUG_ERROR(
                "IsInstructionPointerInInvalidRegion failed with status %x",
                status);
            continue;
        }

        if (!flag)
            *Routine = Base[index];
    }

    return status;
}

/*
 * windows version info: https://www.techthoughts.info/windows-version-numbers/
 *
 * sizes:
 * https://www.vergiliusproject.com/kernels/x64/Windows%2011/22H2%20(2022%20Update)/HAL_PRIVATE_DISPATCH
 */
#define HAL_PRIVATE_DISPATCH_W11_22H2_SIZE 0x4f0
#define HAL_PRIVATE_DISPATCH_W10_22H2_SIZE 0x4b0

#define WINDOWS_10_MAX_BUILD_NUMBER 19045

STATIC
UINT32
GetHalPrivateDispatchTableRoutineCount(_In_ PRTL_OSVERSIONINFOW VersionInfo)
{
    if (VersionInfo->dwBuildNumber <= WINDOWS_10_MAX_BUILD_NUMBER)
        return (HAL_PRIVATE_DISPATCH_W10_22H2_SIZE / sizeof(UINT64)) - 1;
    else
        return (HAL_PRIVATE_DISPATCH_W11_22H2_SIZE / sizeof(UINT64)) - 1;
}

STATIC
NTSTATUS
ValidateHalPrivateDispatchTable(_Out_ PVOID*         Routine,
                                _In_ PSYSTEM_MODULES Modules)
{
    NTSTATUS           status = STATUS_UNSUCCESSFUL;
    PVOID              table  = NULL;
    UNICODE_STRING     string = RTL_CONSTANT_STRING(L"HalPrivateDispatchTable");
    PVOID*             base   = NULL;
    RTL_OSVERSIONINFOW os_info = {0};
    UINT32             count   = 0;

    DEBUG_VERBOSE("Validating HalPrivateDispatchTable.");

    table = ImpMmGetSystemRoutineAddress(&string);

    if (!table)
        return status;

    status = GetOsVersionInformation(&os_info);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetOsVersionInformation failed with status %x", status);
        return status;
    }

    base  = (UINT64)table + sizeof(UINT64);
    count = GetHalPrivateDispatchTableRoutineCount(&os_info);

    status = ValidateTableDispatchRoutines(base, count, Modules, Routine);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ValidateTableDispatchRoutines failed with status %x",
                    status);
        return status;
    }

    return status;
}

STATIC
NTSTATUS
ValidateHalDispatchTable(_Out_ PVOID* Routine, _In_ PSYSTEM_MODULES Modules)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    BOOLEAN  flag   = FALSE;

    *Routine = NULL;

    DEBUG_VERBOSE("Validating HalDispatchTable.");

    /*
     * Since windows exports all the function pointers inside the
     * HalDispatchTable, we may aswell make use of them and validate it this
     * way. While it definitely is ugly, it is the safest way to do it.
     *
     * What if there are 2 invalid routines? hmm.. tink.
     */
    status = IsInstructionPointerInInvalidRegion(
        HalQuerySystemInformation, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalQuerySystemInformation;
    else
        return status;

    status = IsInstructionPointerInInvalidRegion(
        HalSetSystemInformation, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalSetSystemInformation;
    else
        return status;

    status =
        IsInstructionPointerInInvalidRegion(HalQueryBusSlots, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalQueryBusSlots;
    else
        return status;

    status = IsInstructionPointerInInvalidRegion(
        HalReferenceHandlerForBus, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalReferenceHandlerForBus;
    else
        return status;

    status = IsInstructionPointerInInvalidRegion(
        HalReferenceBusHandler, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalReferenceBusHandler;
    else
        return status;

    status = IsInstructionPointerInInvalidRegion(
        HalDereferenceBusHandler, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalDereferenceBusHandler;
    else
        return status;

    status =
        IsInstructionPointerInInvalidRegion(HalInitPnpDriver, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalInitPnpDriver;
    else
        return status;

    status = IsInstructionPointerInInvalidRegion(
        HalInitPowerManagement, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalInitPowerManagement;
    else
        return status;

    status =
        IsInstructionPointerInInvalidRegion(HalGetDmaAdapter, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalGetDmaAdapter;
    else
        return status;

    status = IsInstructionPointerInInvalidRegion(
        HalGetInterruptTranslator, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalGetInterruptTranslator;
    else
        return status;

    status =
        IsInstructionPointerInInvalidRegion(HalStartMirroring, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalStartMirroring;
    else
        return status;

    status =
        IsInstructionPointerInInvalidRegion(HalEndMirroring, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalEndMirroring;
    else
        return status;

    status = IsInstructionPointerInInvalidRegion(
        HalMirrorPhysicalMemory, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalMirrorPhysicalMemory;
    else
        return status;

    status = IsInstructionPointerInInvalidRegion(HalEndOfBoot, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalEndOfBoot;
    else
        return status;

    status =
        IsInstructionPointerInInvalidRegion(HalMirrorVerify, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalMirrorVerify;
    else
        return status;

    status = IsInstructionPointerInInvalidRegion(
        HalGetCachedAcpiTable, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalGetCachedAcpiTable;
    else
        return status;

    status = IsInstructionPointerInInvalidRegion(
        HalSetPciErrorHandlerCallback, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalSetPciErrorHandlerCallback;
    else
        return status;

    status =
        IsInstructionPointerInInvalidRegion(HalGetPrmCache, Modules, &flag);

    if (!flag && NT_SUCCESS(status))
        *Routine = HalGetPrmCache;

    return status;
}

STATIC
VOID
ReportDataTableInvalidRoutine(_In_ TABLE_ID TableId, _In_ UINT64 Address)
{
    PDATA_TABLE_ROUTINE_REPORT report =
        ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                           sizeof(DATA_TABLE_ROUTINE_REPORT),
                           REPORT_POOL_TAG);

    if (!report)
        return;

    DEBUG_WARNING("Invalid data table routine found. Table: %lx, Address: %llx",
                  TableId,
                  Address);

    report->address = Address;
    report->id      = TableId;
    report->id      = REPORT_DATA_TABLE_ROUTINE;
    RtlCopyMemory(report->routine, Address, DATA_TABLE_ROUTINE_BUF_SIZE);

    if (!NT_SUCCESS(
            IrpQueueCompleteIrp(report, sizeof(DATA_TABLE_ROUTINE_REPORT))))
        DEBUG_ERROR("IrpQueueCompleteIrp failed with no status.");
}

NTSTATUS
ValidateHalDispatchTables()
{
    NTSTATUS       status   = STATUS_UNSUCCESSFUL;
    SYSTEM_MODULES modules  = {0};
    PVOID          routine1 = NULL;
    PVOID          routine2 = NULL;

    status = GetSystemModuleInformation(&modules);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("GetSystemModuleInformation failed with status %x", status);
        return status;
    }

    status = ValidateHalDispatchTable(&routine1, &modules);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ValidateHalDispatchTable failed with status %x", status);
        goto end;
    }

    if (routine1)
        ReportDataTableInvalidRoutine(HalDispatch, routine1);
    else
        DEBUG_VERBOSE("HalDispatch dispatch routines are valid.");

    status = ValidateHalPrivateDispatchTable(&routine2, &modules);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ValidateHalPrivateDispatchTable failed with status %x",
                    status);
        goto end;
    }

    if (routine2)
        ReportDataTableInvalidRoutine(HalPrivateDispatch, routine2);
    else
        DEBUG_VERBOSE("HalPrivateDispatch dispatch routines are valid.");

end:
    if (modules.address)
        ImpExFreePoolWithTag(modules.address, SYSTEM_MODULES_POOL);

    return status;
}

NTSTATUS
GetDriverObjectByDriverName(_In_ PUNICODE_STRING  DriverName,
                            _Out_ PDRIVER_OBJECT* DriverObject)
{
    HANDLE            handle           = NULL;
    OBJECT_ATTRIBUTES attributes       = {0};
    PVOID             directory        = {0};
    UNICODE_STRING    directory_name   = {0};
    NTSTATUS          status           = STATUS_UNSUCCESSFUL;
    POBJECT_DIRECTORY directory_object = NULL;

    *DriverObject = NULL;

    ImpRtlInitUnicodeString(&directory_name, L"\\Driver");

    InitializeObjectAttributes(
        &attributes, &directory_name, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status =
        ImpZwOpenDirectoryObject(&handle, DIRECTORY_ALL_ACCESS, &attributes);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ZwOpenDirectoryObject failed with status %x", status);
        return status;
    }

    status = ImpObReferenceObjectByHandle(
        handle, DIRECTORY_ALL_ACCESS, NULL, KernelMode, &directory, NULL);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ObReferenceObjectByHandle failed with status %x", status);
        ImpZwClose(handle);
        return status;
    }

    directory_object = (POBJECT_DIRECTORY)directory;

    ImpExAcquirePushLockExclusiveEx(&directory_object->Lock, NULL);

    for (INT index = 0; index < NUMBER_HASH_BUCKETS; index++) {
        POBJECT_DIRECTORY_ENTRY entry = directory_object->HashBuckets[index];

        if (!entry)
            continue;

        POBJECT_DIRECTORY_ENTRY sub_entry = entry;

        while (sub_entry) {
            PDRIVER_OBJECT current_driver = sub_entry->Object;

            if (!RtlCompareUnicodeString(
                    DriverName, &current_driver->DriverName, FALSE)) {
                *DriverObject = current_driver;
                goto end;
            }

            sub_entry = sub_entry->ChainLink;
        }
    }

end:
    ImpExReleasePushLockExclusiveEx(&directory_object->Lock, 0);
    ImpObDereferenceObject(directory);
    ImpZwClose(handle);
    return STATUS_SUCCESS;
}
```

`driver/modules.h`:

```h
#ifndef MODULES_H
#define MODULES_H

#include <ntifs.h>
#include <intrin.h>

#include "common.h"
#include "queue.h"

typedef struct _APC_OPERATION_ID {
    int operation_id;

} APC_OPERATION_ID, *PAPC_OPERATION_ID;

/* system modules information */

typedef struct _SYSTEM_MODULES {
    PVOID address;
    INT   module_count;

} SYSTEM_MODULES, *PSYSTEM_MODULES;

#define APC_CONTEXT_ID_STACKWALK 0x1

typedef struct _APC_CONTEXT_HEADER {
    LONG         context_id;
    volatile INT count;
    volatile INT allocation_in_progress;

} APC_CONTEXT_HEADER, *PAPC_CONTEXT_HEADER;

typedef struct _APC_STACKWALK_CONTEXT {
    APC_CONTEXT_HEADER header;
    PSYSTEM_MODULES    modules;

} APC_STACKWALK_CONTEXT, *PAPC_STACKWALK_CONTEXT;

NTSTATUS
GetSystemModuleInformation(_Out_ PSYSTEM_MODULES ModuleInformation);

NTSTATUS
HandleValidateDriversIOCTL();

PRTL_MODULE_EXTENDED_INFO
FindSystemModuleByName(_In_ LPCSTR          ModuleName,
                       _In_ PSYSTEM_MODULES SystemModules);

NTSTATUS
HandleNmiIOCTL();

BOOLEAN
FreeApcContextStructure(_Inout_ PAPC_CONTEXT_HEADER Context);

NTSTATUS
ValidateThreadsViaKernelApc();

VOID
FreeApcStackwalkApcContextInformation(_Inout_ PAPC_STACKWALK_CONTEXT Context);

NTSTATUS
IsInstructionPointerInInvalidRegion(_In_ UINT64          RIP,
                                    _In_ PSYSTEM_MODULES SystemModules,
                                    _Out_ PBOOLEAN       Result);

VOID
FlipKThreadMiscFlagsFlag(_In_ PKTHREAD Thread,
                         _In_ ULONG    FlagIndex,
                         _In_ BOOLEAN  NewValue);

NTSTATUS
DispatchStackwalkToEachCpuViaDpc();

NTSTATUS
ValidateHalDispatchTables();

PVOID
FindDriverBaseNoApi(_In_ PDRIVER_OBJECT DriverObject, _In_ PWCH Name);

NTSTATUS
GetDriverObjectByDriverName(_In_ PUNICODE_STRING  DriverName,
                            _Out_ PDRIVER_OBJECT* DriverObject);

#endif

```

`driver/pool.c`:

```c
#include "pool.h"

#include <intrin.h>

#include "callbacks.h"
#include "queue.h"
#include "ia32.h"
#include "imports.h"

#define PAGE_BASE_SIZE 0x1000
#define POOL_TAG_SIZE  0x004

#define PML4_ENTRY_COUNT 512
#define PDPT_ENTRY_COUNT 512
#define PD_ENTRY_COUNT   512
#define PT_ENTRY_COUNT   512

#define LARGE_PAGE_2MB_ENTRIES 512
#define LARGE_PAGE_1GB_ENTRIES 0x40000

#define CHUNK_SIZE 16

#define PROCESS_OBJECT_ALLOCATION_MARGIN 0x90

#define POOL_TAG_LENGTH        4
#define EXECUTIVE_OBJECT_COUNT 8

#define INDEX_PROCESS_POOL_TAG         0
#define INDEX_THREAD_POOL_TAG          1
#define INDEX_DESKTOP_POOL_TAG         2
#define INDEX_WINDOW_STATIONS_POOL_TAG 3
#define INDEX_MUTANTS_POOL_TAG         4
#define INDEX_FILE_OBJECTS_POOL_TAG    5
#define INDEX_DRIVERS_POOL_TAG         6
#define INDEX_SYMBOLIC_LINKS_POOL_TAG  7

CHAR EXECUTIVE_OBJECT_POOL_TAGS[EXECUTIVE_OBJECT_COUNT][POOL_TAG_LENGTH] = {
    "\x50\x72\x6f\x63", /* Process */
    "\x54\x68\x72\x64", /* Thread */
    "\x44\x65\x73\x6B", /* Desktop */
    "\x57\x69\x6E\x64", /* Windows Station */
    "\x4D\x75\x74\x65", /* Mutants i.e mutex etc. */
    "\x46\x69\x6C\x65", /* File objects */
    "\x44\x72\x69\x76", /* Drivers */
    "\x4C\x69\x6E\x6B"  /* Symbolic links */
};

typedef struct _PROCESS_SCAN_CONTEXT {
    ULONG process_count;
    PVOID process_buffer;

} PROCESS_SCAN_CONTEXT, *PPROCESS_SCAN_CONTEXT;

STATIC
BOOLEAN
ValidateIfAddressIsProcessStructure(_In_ PVOID        Address,
                                    _In_ PPOOL_HEADER PoolHeader);

STATIC
VOID
ScanPageForKernelObjectAllocation(_In_ UINT64                   PageBase,
                                  _In_ ULONG                    PageSize,
                                  _In_ ULONG                    ObjectIndex,
                                  _Inout_ PPROCESS_SCAN_CONTEXT Context);

STATIC
BOOLEAN
IsPhysicalAddressInPhysicalMemoryRange(_In_ UINT64 PhysicalAddress,
                                       _In_ PPHYSICAL_MEMORY_RANGE
                                           PhysicalMemoryRanges);

STATIC
VOID
EnumerateKernelLargePages(_In_ UINT64                PageBase,
                          _In_ ULONG                 PageSize,
                          _In_ PPROCESS_SCAN_CONTEXT Context,
                          _In_ ULONG                 ObjectIndex);

STATIC
VOID
WalkKernelPageTables(_In_ PPROCESS_SCAN_CONTEXT Context);

STATIC
VOID
IncrementProcessCounter(_In_ PPROCESS_LIST_ENTRY ProcessListEntry,
                        _Inout_opt_ PVOID        Context);

STATIC
VOID
CheckIfProcessAllocationIsInProcessList(
    _In_ PPROCESS_LIST_ENTRY ProcessListEntry, _Inout_opt_ PVOID Context);

#ifdef ALLOC_PRAGMA
#    pragma alloc_text(PAGE, GetGlobalDebuggerData)
#    pragma alloc_text(PAGE, GetPsActiveProcessHead)
#    pragma alloc_text(PAGE, IncrementProcessCounter)
#    pragma alloc_text(PAGE, CheckIfProcessAllocationIsInProcessList)
#    pragma alloc_text(PAGE, FindUnlinkedProcesses)
#endif

PKDDEBUGGER_DATA64
GetGlobalDebuggerData()
{
    PAGED_CODE();

    CONTEXT            context       = {0};
    PDUMP_HEADER       dump_header   = {0};
    UINT64             thread_state  = 0;
    PKDDEBUGGER_DATA64 debugger_data = NULL;

    context.ContextFlags = CONTEXT_FULL;

    RtlCaptureContext(&context);

    dump_header = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, DUMP_BLOCK_SIZE, POOL_DUMP_BLOCK_TAG);

    if (!dump_header)
        goto end;

    KeCapturePersistentThreadState(
        &context, NULL, NULL, NULL, NULL, NULL, NULL, dump_header);

    debugger_data = (PKDDEBUGGER_DATA64)ExAllocatePool2(
        POOL_FLAG_NON_PAGED, sizeof(KDDEBUGGER_DATA64), POOL_DEBUGGER_DATA_TAG);

    if (!debugger_data)
        goto end;

    RtlCopyMemory(debugger_data,
                  dump_header->KdDebuggerDataBlock,
                  sizeof(KDDEBUGGER_DATA64));

end:

    if (dump_header)
        ImpExFreePoolWithTag(dump_header, POOL_DUMP_BLOCK_TAG);

    return debugger_data;
}

VOID
GetPsActiveProcessHead(_Out_ PUINT64 Address)
{
    PAGED_CODE();

    *Address = NULL;

    PKDDEBUGGER_DATA64 debugger_data = GetGlobalDebuggerData();

    if (!debugger_data)
        return;

    *Address = *(UINT64*)(debugger_data->PsActiveProcessHead);
    ImpExFreePoolWithTag(debugger_data, POOL_DEBUGGER_DATA_TAG);
}

/*
 * Here we define a signature that can be used to find EPROCESS structures
 *consistently across major windows versions. The fields we test have proven to
 *be consistent in the following study:
 *
 * https://www.cise.ufl.edu/~traynor/papers/ccs09b.pdf
 *
 * Aswell as some of my own additional research and testing. The following
 *signature is used:
 *
 * PeakVirtualSize must be greater then 0 for any valid process:
 *	-> EPROCESS->PeakVirtualSize > 0
 *
 * The DirectoryTableBase must be 0x20 aligned:
 *	-> EPROCESS->DirectoryTableBase % 20 == 0
 *
 * The pool allocation size must be greater then the size of an EPROCESS
 *allocation and less then the size of a page. Allocation size can be found with
 *the following formula:
 *	-> AllocationSize = POOL_HEADER->BlockSize * CHUNK_SIZE -
 *sizeof(POOL_HEADER)
 *	-> AllocationSize > sizeof(EPROCESS)
 *	-> AllocationSize < PAGE_SIZE (4096)
 *
 * Pool type must be non-null:
 *	-> POOL_HEADER->PoolType != NULL
 *
 * The process PEB must be a usermode address and 0x1000 aligned:
 *	-> EPROCESS->Peb & 0x7ffd0000 == 0x7ffd0000 && EPROCESS->Peb % 0x1000 == 0
 *
 * The object table must have the following properties and be 0x8 aligned:
 *	-> EPROCESS->ObjectTable & 0xe0000000 == 0xe0000000 && EPROCESS->ObjectTable
 *% 0x8 == 0
 *
 * The allocation size, when AND'd with 0xfff0 must not equal 0xfff0:
 *	-> AllocationSize & 0xfff0 != 0xfff0
 *
 * This signature will allow us to consistently and accurately determine if a
 *given pool allocation is indeed an executive process allocation across major
 *versions of Windows.
 */
STATIC
BOOLEAN
ValidateIfAddressIsProcessStructure(_In_ PVOID        Address,
                                    _In_ PPOOL_HEADER PoolHeader)
{
    UINT64  peak_virtual_size    = 0;
    UINT64  dir_table_base       = 0;
    UINT64  allocation_size      = 0;
    UINT64  peb                  = 0;
    UINT64  object_table         = 0;
    BOOLEAN peb_test             = FALSE;
    BOOLEAN object_table_test    = FALSE;
    UINT64  allocation_size_test = 0;

    if (ImpMmIsAddressValid((UINT64)Address +
                            KPROCESS_DIRECTORY_TABLE_BASE_OFFSET))
        dir_table_base =
            *(UINT64*)((UINT64)Address + KPROCESS_DIRECTORY_TABLE_BASE_OFFSET);

    if (ImpMmIsAddressValid((UINT64)Address +
                            EPROCESS_PEAK_VIRTUAL_SIZE_OFFSET))
        peak_virtual_size =
            *(UINT64*)((UINT64)Address + EPROCESS_PEAK_VIRTUAL_SIZE_OFFSET);

    if (ImpMmIsAddressValid((UINT64)PoolHeader + POOL_HEADER_BLOCK_SIZE_OFFSET))
        allocation_size =
            PoolHeader->BlockSize * CHUNK_SIZE - sizeof(POOL_HEADER);

    if (ImpMmIsAddressValid((UINT64)Address + EPROCESS_PEB_OFFSET))
        peb = *(UINT64*)((UINT64)Address + EPROCESS_PEB_OFFSET);

    if (ImpMmIsAddressValid((UINT64)Address + EPROCESS_OBJECT_TABLE_OFFSET))
        object_table =
            *(UINT64*)((UINT64)Address + EPROCESS_OBJECT_TABLE_OFFSET);

    peb_test =
        peb == NULL || (peb & 0x7ffd0000 == 0x7ffd0000 && peb % 0x1000 == NULL);
    object_table_test =
        object_table == NULL ||
        (object_table & 0xe0000000 == 0xe0000000 && object_table % 0x8 == 0);
    allocation_size_test = allocation_size & 0xfff0;

    if (peak_virtual_size > 0 && (dir_table_base & 0x20) == 0 &&
        allocation_size >
            (EPROCESS_SIZE + OBJECT_HEADER_SIZE + sizeof(POOL_HEADER)) &&
        PoolHeader->PoolType != NULL && !(allocation_size_test == 0xfff0) &&
        !peb_test && !object_table_test) {
        return TRUE;
    }

    return FALSE;
}

/*
 * OBJECT_HEADER->InfoMask is a bit mask that tells us which optional
 * headers the object has. The bits are as follows:
 *
 * 0x1 = OBJECT_HEADER_CREATOR_INFO
 * 0x2 = OBJECT_HEADER_NAME_INFO
 * 0x4 = OBJECT_HEADER_HANDLE_INFO
 * 0x8 = OBJECT_HEADER_QUOTA_INFO
 * 0x10 = OBJECT_HEADER_PROCESS_INFO
 * 0x20 = OBJECT_HEADER_AUDIT_INFO
 * 0x40 = OBJECT_HEADER_HANDLE_REVOCATION_INFO
 */

/*
 * Idea: since we don't know the number of headers or the exact memory layout of
 * the object header section for these proc allocations, we can form an estimate
 * address of base + 0x70 and then iterate the loaded process list and if theres
 * an address within say 0x50 of it we can assume that the process is legitmate.
 * Then to find an unlinked process, it wouldn't exist in the loaded module
 * list, check that it hasnt been deallocated and then focus on scanning it for
 * name etc. Maybe scan for .exe extension?
 *
 * Also use the full name so we get the file extension and path not the 15 char
 * long one
 */
STATIC
VOID
ScanPageForKernelObjectAllocation(_In_ UINT64                   PageBase,
                                  _In_ ULONG                    PageSize,
                                  _In_ ULONG                    ObjectIndex,
                                  _Inout_ PPROCESS_SCAN_CONTEXT Context)
{
    INT          length           = 0;
    CHAR         current_char     = 0;
    CHAR         current_sig_byte = 0;
    PPOOL_HEADER pool_header      = NULL;
    PEPROCESS    process          = NULL;
    PEPROCESS    process_size_one = NULL;
    PEPROCESS    process_size_two = NULL;
    PEPROCESS    test_process     = NULL;
    LPCSTR       process_name     = NULL;
    PUINT64      address_list     = NULL;
    ULONG        allocation_size  = 0;
    ULONG        minimum_process_allocation_size =
        EPROCESS_SIZE - sizeof(POOL_HEADER) - OBJECT_HEADER_SIZE;

    if (!PageBase || !PageSize)
        return;

    for (INT offset = 0;
         offset <= PageSize - POOL_TAG_LENGTH - minimum_process_allocation_size;
         offset++) {
        for (INT sig_index = 0; sig_index < POOL_TAG_LENGTH + 1; sig_index++) {
            if (!ImpMmIsAddressValid(PageBase + offset + sig_index))
                break;

            current_char = *(PCHAR)(PageBase + offset + sig_index);
            current_sig_byte =
                EXECUTIVE_OBJECT_POOL_TAGS[ObjectIndex][sig_index];

            if (sig_index == POOL_TAG_LENGTH) {
                pool_header =
                    (UINT64)PageBase + offset - POOL_HEADER_TAG_OFFSET;

                if (!ImpMmIsAddressValid((PVOID)pool_header))
                    break;

                /*
                 * Since every executive allocation is required
                 * to have an _OBJECT_HEADER, we start iterating
                 * from the size of this object header, then
                 * jump up in blocks of 0x10 since every object
                 * header is divisible by 0x10. We iterate up to
                 * 0xb0 which is equal to the following:
                 *
                 * 0xb0 = sizeof(ALL_HEADER_OBJECTS) + 0x10
                 * where the 0x10 is 16 bytes of padding.
                 */
                for (ULONG header_size = OBJECT_HEADER_SIZE; header_size < 0xb0;
                     header_size += 0x10) {
                    test_process =
                        (PEPROCESS)((UINT64)pool_header + sizeof(POOL_HEADER) +
                                    header_size);

                    if (ValidateIfAddressIsProcessStructure(test_process,
                                                            pool_header)) {
                        process = test_process;
                        break;
                    }
                }

                if (!process)
                    break;

                DEBUG_VERBOSE("Found process via pt walk: %llx",
                              (UINT64)process);

                address_list = (PUINT64)Context->process_buffer;

                for (INT i = 0; i < Context->process_count; i++) {
                    if (address_list[i] == NULL) {
                        address_list[i] = (UINT64)process;
                        break;
                    }
                }

                break;
            }

            if (current_char != current_sig_byte)
                break;
        }
    }
}

/*
 * Using MmGetPhysicalMemoryRangesEx2(), we can get a block of structures that
 * describe the physical memory layout. With each physical page base we are
 * going to enumerate, we want to make sure it lies within an appropriate region
 * of physical memory, so this function is to check for exactly that.
 */
STATIC
BOOLEAN
IsPhysicalAddressInPhysicalMemoryRange(_In_ UINT64 PhysicalAddress,
                                       _In_ PPHYSICAL_MEMORY_RANGE
                                           PhysicalMemoryRanges)
{
    ULONG  page_index    = 0;
    UINT64 start_address = 0;
    UINT64 end_address   = 0;

    while (PhysicalMemoryRanges[page_index].NumberOfBytes.QuadPart != NULL) {
        start_address = PhysicalMemoryRanges[page_index].BaseAddress.QuadPart;
        end_address   = start_address +
                      PhysicalMemoryRanges[page_index].NumberOfBytes.QuadPart;

        if (PhysicalAddress >= start_address && PhysicalAddress <= end_address)
            return TRUE;

        page_index++;
    }

    return FALSE;
}

STATIC
VOID
EnumerateKernelLargePages(_In_ UINT64                PageBase,
                          _In_ ULONG                 PageSize,
                          _In_ PPROCESS_SCAN_CONTEXT Context,
                          _In_ ULONG                 ObjectIndex)
{
    /*
     * Split the large pages up into blocks of 0x1000 and scan each block
     */
    for (UINT64 page_index = 0; page_index < PageSize; page_index++) {
        UINT64 page_base = PageBase + (page_index * PAGE_SIZE);
        ScanPageForKernelObjectAllocation(
            page_base, PAGE_SIZE, ObjectIndex, Context);
    }
}

/*
 * This is your basic page table walk function. On intel systems, paging has 4
 * levels, each table holds 512 entries with a total size of 0x1000 (512 *
 * sizeof(QWORD)). Each entry in each table contains a value with a subset
 * bitfield containing the physical address of the base of the next table in the
 * structure. So for example, a PML4 entry contains a physical address that
 * points to the base of the PDPT table, it is the same for a PDPT entry -> PD
 * base and so on.
 *
 * However, as with all good things Windows has implemented security features
 * meaning we cannot use functions such as MmCopyMemory or MmMapIoSpace on
 * paging structures, so we must find another way to walk the pages. Luckily for
 * us, there exists MmGetVirtualForPhysical. This function is self explanatory
 * and returns the corresponding virtual address given a physical address. What
 * this means is that we can extract a page entry physical address, pass it to
 * MmGetVirtualForPhysical which returns us the virtual address of the base of
 * the next page structure. This is because page tables are still mapped by the
 * kernel and exist in virtual memory just like everything else and hence
 * reading the value at all 512 entries from the virtual base will give us the
 * equivalent value as directly reading the physical address.
 *
 * Using this, we essentially walk the page tables as any regular translation
 * would except instead of simply reading the physical we translate it to a
 * virtual address and extract the physical address from the value at each
 * virtual address page entry.
 *
 * TODO: rewrite this its kinda ugly
 */
STATIC
VOID
WalkKernelPageTables(_In_ PPROCESS_SCAN_CONTEXT Context)
{
    CR3                    cr3                    = {0};
    PML4E                  pml4_base              = {0};
    PML4E                  pml4_entry             = {0};
    UINT64                 pdpt_base              = 0;
    UINT64                 pd_base                = 0;
    UINT64                 pt_base                = 0;
    PDPTE                  pdpt_entry             = {0};
    PDPTE_LARGE            pdpt_large_entry       = {0};
    PDE                    pd_entry               = {0};
    PDE_LARGE              pd_large_entry         = {0};
    PTE                    pt_entry               = {0};
    UINT64                 base_physical_page     = 0;
    UINT64                 base_virtual_page      = 0;
    UINT64                 base_2mb_virtual_page  = 0;
    UINT64                 base_1gb_virtual_page  = 0;
    PHYSICAL_ADDRESS       physical               = {0};
    PPHYSICAL_MEMORY_RANGE physical_memory_ranges = NULL;
    KIRQL                  irql                   = {0};

    physical_memory_ranges = ImpMmGetPhysicalMemoryRangesEx2(NULL, NULL);

    if (!physical_memory_ranges) {
        DEBUG_ERROR("MmGetPhysicalMemoryRangesEx2 failed with no status.");
        return;
    }

    cr3.AsUInt = __readcr3();

    physical.QuadPart = cr3.AddressOfPageDirectory << PAGE_4KB_SHIFT;

    pml4_base.BitAddress = ImpMmGetVirtualForPhysical(physical);

    if (!ImpMmIsAddressValid(pml4_base.BitAddress) || !pml4_base.BitAddress)
        return;

    for (INT pml4_index = 0; pml4_index < PML4_ENTRY_COUNT; pml4_index++) {
        if (!ImpMmIsAddressValid(pml4_base.BitAddress +
                                 pml4_index * sizeof(UINT64)))
            continue;

        pml4_entry.BitAddress =
            *(UINT64*)(pml4_base.BitAddress + pml4_index * sizeof(UINT64));

        if (pml4_entry.Bits.Present == NULL)
            continue;

        physical.QuadPart = pml4_entry.Bits.PhysicalAddress << PAGE_4KB_SHIFT;

        pdpt_base = ImpMmGetVirtualForPhysical(physical);

        if (!pdpt_base || !ImpMmIsAddressValid(pdpt_base))
            continue;

        for (INT pdpt_index = 0; pdpt_index < PDPT_ENTRY_COUNT; pdpt_index++) {
            if (!ImpMmIsAddressValid(pdpt_base + pdpt_index * sizeof(UINT64)))
                continue;

            pdpt_entry.BitAddress =
                *(UINT64*)(pdpt_base + pdpt_index * sizeof(UINT64));

            if (pdpt_entry.Bits.Present == NULL)
                continue;

            if (IS_LARGE_PAGE(pdpt_entry.BitAddress)) {
                /* 1gb size page */
                pdpt_large_entry.BitAddress = pdpt_entry.BitAddress;

                physical.QuadPart = pdpt_large_entry.Bits.PhysicalAddress
                                    << PAGE_1GB_SHIFT;

                if (IsPhysicalAddressInPhysicalMemoryRange(
                        physical.QuadPart, physical_memory_ranges) == FALSE)
                    continue;

                base_1gb_virtual_page = ImpMmGetVirtualForPhysical(physical);

                if (!base_1gb_virtual_page ||
                    !ImpMmIsAddressValid(base_1gb_virtual_page))
                    continue;

                EnumerateKernelLargePages(base_1gb_virtual_page,
                                          LARGE_PAGE_1GB_ENTRIES,
                                          Context,
                                          INDEX_PROCESS_POOL_TAG);

                continue;
            }

            physical.QuadPart = pdpt_entry.Bits.PhysicalAddress
                                << PAGE_4KB_SHIFT;

            pd_base = ImpMmGetVirtualForPhysical(physical);

            if (!pd_base || !ImpMmIsAddressValid(pd_base))
                continue;

            for (INT pd_index = 0; pd_index < PD_ENTRY_COUNT; pd_index++) {
                if (!ImpMmIsAddressValid(pd_base + pd_index * sizeof(UINT64)))
                    continue;

                pd_entry.BitAddress =
                    *(UINT64*)(pd_base + pd_index * sizeof(UINT64));

                if (pd_entry.Bits.Present == NULL)
                    continue;

                if (IS_LARGE_PAGE(pd_entry.BitAddress)) {
                    /* 2MB size page */
                    pd_large_entry.BitAddress = pd_entry.BitAddress;

                    physical.QuadPart = pd_large_entry.Bits.PhysicalAddress
                                        << PAGE_2MB_SHIFT;

                    if (IsPhysicalAddressInPhysicalMemoryRange(
                            physical.QuadPart, physical_memory_ranges) == FALSE)
                        continue;

                    base_2mb_virtual_page =
                        ImpMmGetVirtualForPhysical(physical);

                    if (!base_2mb_virtual_page ||
                        !ImpMmIsAddressValid(base_2mb_virtual_page))
                        continue;

                    EnumerateKernelLargePages(base_2mb_virtual_page,
                                              LARGE_PAGE_2MB_ENTRIES,
                                              Context,
                                              INDEX_PROCESS_POOL_TAG);

                    continue;
                }

                physical.QuadPart = pd_entry.Bits.PhysicalAddress
                                    << PAGE_4KB_SHIFT;

                if (!ImpMmIsAddressValid(pd_base + pd_index * sizeof(UINT64)))
                    continue;

                pt_base = ImpMmGetVirtualForPhysical(physical);

                if (!pt_base || !ImpMmIsAddressValid(pt_base))
                    continue;

                for (INT pt_index = 0; pt_index < PT_ENTRY_COUNT; pt_index++) {
                    if (!ImpMmIsAddressValid(pt_base +
                                             pt_index * sizeof(UINT64)))
                        continue;

                    pt_entry.BitAddress =
                        *(UINT64*)(pt_base + pt_index * sizeof(UINT64));

                    if (pt_entry.Bits.Present == NULL)
                        continue;

                    physical.QuadPart = pt_entry.Bits.PhysicalAddress
                                        << PAGE_4KB_SHIFT;

                    /* if the page base isnt in a legit
                     * region, go next */
                    if (IsPhysicalAddressInPhysicalMemoryRange(
                            physical.QuadPart, physical_memory_ranges) == FALSE)
                        continue;

                    base_virtual_page = ImpMmGetVirtualForPhysical(physical);

                    /* stupid fucking intellisense error GO
                     * AWAY! */
                    if (base_virtual_page == NULL ||
                        !ImpMmIsAddressValid(base_virtual_page))
                        continue;

                    ScanPageForKernelObjectAllocation(base_virtual_page,
                                                      PAGE_BASE_SIZE,
                                                      INDEX_PROCESS_POOL_TAG,
                                                      Context);
                }
            }
        }
    }

    DEBUG_VERBOSE("Finished scanning memory for unlinked processes.");
}

STATIC
VOID
IncrementProcessCounter(_In_ PPROCESS_LIST_ENTRY ProcessListEntry,
                        _Inout_opt_ PVOID        Context)
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(ProcessListEntry);

    PPROCESS_SCAN_CONTEXT context = (PPROCESS_SCAN_CONTEXT)Context;

    if (!context)
        return;

    context->process_count++;
}

STATIC
VOID
CheckIfProcessAllocationIsInProcessList(
    _In_ PPROCESS_LIST_ENTRY ProcessListEntry, _Inout_opt_ PVOID Context)
{
    PAGED_CODE();

    PUINT64               allocation_address = NULL;
    PPROCESS_SCAN_CONTEXT context            = (PPROCESS_SCAN_CONTEXT)Context;

    if (!context)
        return;

    for (INT i = 0; i < context->process_count; i++) {
        allocation_address = (PUINT64)context->process_buffer;

        if ((UINT64)ProcessListEntry->process >=
                allocation_address[i] - PROCESS_OBJECT_ALLOCATION_MARGIN &&
            (UINT64)ProcessListEntry->process <=
                allocation_address[i] + PROCESS_OBJECT_ALLOCATION_MARGIN) {
            RtlZeroMemory((UINT64)context->process_buffer + i * sizeof(UINT64),
                          sizeof(UINT64));
        }
    }
}

/*
 * This is actually broken right now since changing to use our process list,
 * will need to fix at somepoint.
 */
NTSTATUS
FindUnlinkedProcesses()
{
    PAGED_CODE();

    PUINT64                            allocation_address = NULL;
    PROCESS_SCAN_CONTEXT               context            = {0};
    PINVALID_PROCESS_ALLOCATION_REPORT report_buffer      = NULL;

    EnumerateProcessListWithCallbackRoutine(IncrementProcessCounter, &context);

    if (context.process_count == 0) {
        DEBUG_ERROR("IncrementProcessCounter failed with no status.");
        return STATUS_ABANDONED;
    }

    context.process_buffer =
        ExAllocatePool2(POOL_FLAG_NON_PAGED,
                        context.process_count * 2 * sizeof(UINT64),
                        PROCESS_ADDRESS_LIST_TAG);

    if (!context.process_buffer)
        return STATUS_MEMORY_NOT_ALLOCATED;

    WalkKernelPageTables(&context);

    EnumerateProcessListWithCallbackRoutine(
        CheckIfProcessAllocationIsInProcessList, &context);

    allocation_address = (PUINT64)context.process_buffer;

    for (INT index = 0; index < context.process_count; index++) {
        if (allocation_address[index] == NULL)
            continue;

        UINT64 allocation =
            (UINT64)allocation_address[index] - OBJECT_HEADER_SIZE;

        /*
         * It's important to remember that at this point it is still not
         * guaranteed that we have found an unlinked process allocation.
         * It is better to have a few false positives that can be later
         * analysed rather then enforce a strict signature and
         * potentially miss a real unlinked process.
         */
        DEBUG_WARNING(
            "Potentially found an unlinked process allocation at address: %llx",
            allocation);

        report_buffer =
            ImpExAllocatePool2(POOL_FLAG_NON_PAGED,
                               sizeof(INVALID_PROCESS_ALLOCATION_REPORT),
                               REPORT_POOL_TAG);

        if (!report_buffer)
            continue;

        report_buffer->report_code = REPORT_INVALID_PROCESS_ALLOCATION;

        RtlCopyMemory(report_buffer->process,
                      allocation,
                      REPORT_INVALID_PROCESS_BUFFER_SIZE);

        if (!NT_SUCCESS(IrpQueueCompleteIrp(
                report_buffer, sizeof(INVALID_PROCESS_ALLOCATION_REPORT)))) {
            DEBUG_ERROR("IrpQueueCompleteIrp failed with no status.");
            continue;
        }
    }

end:

    if (context.process_buffer)
        ImpExFreePoolWithTag(context.process_buffer, PROCESS_ADDRESS_LIST_TAG);

    return STATUS_SUCCESS;
}

/*
 * Allocations greater then a page in size are stored in a linked list and are
 * called big pool allocations.
 */

NTSTATUS
EnumerateBigPoolAllocations()
{
    ULONG                       return_length    = 0;
    NTSTATUS                    status           = STATUS_UNSUCCESSFUL;
    PSYSTEM_BIGPOOL_ENTRY       entry            = NULL;
    SYSTEM_BIGPOOL_INFORMATION  pool_information = {0};
    PSYSTEM_BIGPOOL_INFORMATION pool_entries     = NULL;
    UNICODE_STRING routine = RTL_CONSTANT_STRING(L"ZwQuerySystemInformation");
    ZwQuerySystemInformation pZwQuerySystemInformation =
        ImpMmGetSystemRoutineAddress(&routine);

    if (!pZwQuerySystemInformation) {
        DEBUG_ERROR("MmGetSystemRoutineAddress failed with no status.");
        return status;
    }

    status = pZwQuerySystemInformation(SYSTEM_BIGPOOL_INFORMATION_ID,
                                       &pool_information,
                                       sizeof(pool_information),
                                       &return_length);

    if (status != STATUS_INFO_LENGTH_MISMATCH) {
        DEBUG_ERROR("ZwQuerySystemInformation failed with status %x", status);
        return status;
    }

    return_length += sizeof(SYSTEM_BIGPOOL_INFORMATION);

    pool_entries = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, return_length, POOL_TAG_INTEGRITY);

    if (!pool_entries)
        return STATUS_MEMORY_NOT_ALLOCATED;

    status = pZwQuerySystemInformation(SYSTEM_BIGPOOL_INFORMATION_ID,
                                       pool_entries,
                                       return_length,
                                       &return_length);

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ZwQuerySystemInformation 2 failed with status %x", status);
        goto end;
    }

    for (INT index = 0; index < pool_entries->Count; index++) {
        entry = &pool_entries->AllocatedInfo[index];
    }
    // MiGetPteAddress of va
    // check if page is executaable
end:

    if (pool_entries)
        ImpExFreePoolWithTag(pool_entries, POOL_TAG_INTEGRITY);

    return status;
}
```

`driver/pool.h`:

```h
#ifndef POOL_H
#define POOL_H

#include <ntifs.h>
#include "common.h"

NTSTATUS
FindUnlinkedProcesses();

VOID
GetPsActiveProcessHead(_Out_ PUINT64 Address);

PKDDEBUGGER_DATA64
GetGlobalDebuggerData();

NTSTATUS
EnumerateBigPoolAllocations();

#endif
```

`driver/queue.c`:

```c
#include "queue.h"

#include "callbacks.h"

#include "driver.h"

#include "queue.h"
#include "pool.h"
#include "thread.h"
#include "io.h"
#include "common.h"
#include "imports.h"

VOID
QueuePush(_Inout_ PQUEUE_HEAD Head, _In_ PVOID Data)
{
    ImpKeAcquireGuardedMutex(&Head->lock);

    PQUEUE_NODE temp = ExAllocatePool2(
        POOL_FLAG_NON_PAGED, sizeof(QUEUE_NODE), QUEUE_POOL_TAG);

    if (!temp)
        goto end;

    Head->entries += 1;

    temp->data = Data;

    if (Head->end != NULL)
        Head->end->next = temp;

    Head->end = temp;

    if (Head->start == NULL)
        Head->start = temp;

end:
    ImpKeReleaseGuardedMutex(&Head->lock);
}

PVOID
QueuePop(_Inout_ PQUEUE_HEAD Head)
{
    ImpKeAcquireGuardedMutex(&Head->lock);

    PVOID       data = NULL;
    PQUEUE_NODE temp = Head->start;

    if (temp == NULL)
        goto end;

    Head->entries = Head->entries - 1;

    data        = temp->data;
    Head->start = temp->next;

    if (Head->end == temp)
        Head->end = NULL;

    ImpExFreePoolWithTag(temp, QUEUE_POOL_TAG);

end:
    ImpKeReleaseGuardedMutex(&Head->lock);
    return data;
}
```

`driver/queue.h`:

```h
#ifndef QUEUE_H
#define QUEUE_H

#include <ntifs.h>
#include "common.h"

#define MAX_REPORTS_PER_IRP 20

typedef struct QUEUE_HEAD {
    struct _QUEUE_NODE* start;
    struct _QUEUE_NODE* end;
    KGUARDED_MUTEX      lock;
    INT                 entries;

} QUEUE_HEAD, *PQUEUE_HEAD;

/*
 * This mutex is to prevent a new item being pushed to the queue
 * while the HandlePeriodicCallbackReportQueue is iterating through
 * the objects. This can be an issue because the spinlock is released
 * after each report is placed in the IRP buffer which means a new report
 * can be pushed into the queue before the next iteration can take ownership
 * of the spinlock.
 */
typedef struct _REPORT_QUEUE_HEAD {
    QUEUE_HEAD       head;
    volatile BOOLEAN is_driver_unloading;
    KGUARDED_MUTEX   lock;

} REPORT_QUEUE_HEAD, *PREPORT_QUEUE_HEAD;

typedef struct _QUEUE_NODE {
    struct _QUEUE_NODE* next;
    PVOID               data;

} QUEUE_NODE, *PQUEUE_NODE;

typedef struct _GLOBAL_REPORT_QUEUE_HEADER {
    INT count;

} GLOBAL_REPORT_QUEUE_HEADER, *PGLOBAL_REPORT_QUEUE_HEADER;

typedef struct _REPORT_HEADER {
    INT report_id;

} REPORT_HEADER, *PREPORT_HEADER;

VOID
QueuePush(_Inout_ PQUEUE_HEAD Head, _In_ PVOID Data);

PVOID
QueuePop(_Inout_ PQUEUE_HEAD Head);

#endif
```

`driver/session.c`:

```c
#include "session.h"

#include "imports.h"

/* for now, lets just xor the aes key with our cookie */

typedef struct _SESSION_INITIATION_PACKET {
    UINT32 session_cookie;
    CHAR   session_aes_key[AES_128_KEY_SIZE];
    PVOID  protected_process_id;

} SESSION_INITIATION_PACKET, *PSESSION_INITIATION_PACKET;

VOID
SessionInitialiseStructure()
{
    PAGED_CODE();
    ImpKeInitializeGuardedMutex(&GetActiveSession()->lock);
}

VOID
SessionInitialiseCallbackConfiguration()
{
    PAGED_CODE();
    InitialiseObCallbacksConfiguration(GetActiveSession());
}

VOID
SessionIsActive(_Out_ PBOOLEAN Flag)
{
    PAGED_CODE();
    ImpKeAcquireGuardedMutex(&GetActiveSession()->lock);
    *Flag = GetActiveSession()->is_session_active;
    ImpKeReleaseGuardedMutex(&GetActiveSession()->lock);
}

VOID
SessionGetProcess(_Out_ PEPROCESS* Process)
{
    PAGED_CODE();
    ImpKeAcquireGuardedMutex(&GetActiveSession()->lock);
    *Process = GetActiveSession()->process;
    ImpKeReleaseGuardedMutex(&GetActiveSession()->lock);
}

VOID
SessionGetProcessId(_Out_ PLONG ProcessId)
{
    PAGED_CODE();
    ImpKeAcquireGuardedMutex(&GetActiveSession()->lock);
    *ProcessId = GetActiveSession()->km_handle;
    ImpKeReleaseGuardedMutex(&GetActiveSession()->lock);
}

VOID
SessionGetCallbackConfiguration(
    _Out_ POB_CALLBACKS_CONFIG* CallbackConfiguration)
{
    ImpKeAcquireGuardedMutex(&GetActiveSession()->lock);
    *CallbackConfiguration = &GetActiveSession()->callback_configuration;
    ImpKeReleaseGuardedMutex(&GetActiveSession()->lock);
}

VOID
SessionTerminate()
{
    PAGED_CODE();
    DEBUG_INFO("Termination active session.");

    PACTIVE_SESSION session = GetActiveSession();

    ImpKeAcquireGuardedMutex(&session->lock);
    session->km_handle         = NULL;
    session->um_handle         = NULL;
    session->process           = NULL;
    session->is_session_active = FALSE;
    ImpKeReleaseGuardedMutex(&session->lock);
}

NTSTATUS
SessionInitialise(_In_ PIRP Irp)
{
    PAGED_CODE();

    NTSTATUS                   status      = STATUS_UNSUCCESSFUL;
    PEPROCESS                  process     = NULL;
    PSESSION_INITIATION_PACKET information = NULL;
    PACTIVE_SESSION            session     = GetActiveSession();

    DEBUG_VERBOSE("Initialising new session.");

    status = ValidateIrpInputBuffer(Irp, sizeof(SESSION_INITIATION_PACKET));

    if (!NT_SUCCESS(status)) {
        DEBUG_ERROR("ValidateIrpInputBuffer failed with status %x", status);
        return status;
    }

    information = (PSESSION_INITIATION_PACKET)Irp->AssociatedIrp.SystemBuffer;

    ImpKeAcquireGuardedMutex(&session->lock);

    session->um_handle = information->protected_process_id;

    /* What if we pass an invalid handle here? not good. */
    status = ImpPsLookupProcessByProcessId(session->um_handle, &process);

    if (!NT_SUCCESS(status)) {
        status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    session->km_handle         = ImpPsGetProcessId(process);
    session->process           = process;
    session->is_session_active = TRUE;
    session->session_cookie    = information->session_cookie;

    RtlCopyMemory(session->session_aes_key,
                  information->session_aes_key,
                  AES_128_KEY_SIZE);

end:
    ImpKeReleaseGuardedMutex(&session->lock);
    return status;
}

VOID
SessionTerminateProcess()
{
    PAGED_CODE();

    NTSTATUS status     = STATUS_UNSUCCESSFUL;
    ULONG    process_id = 0;

    SessionGetProcessId(&process_id);

    if (!process_id) {
        DEBUG_ERROR("Failed to terminate process as process id is null");
        return;
    }

    /* Make sure we pass a km handle to ZwTerminateProcess and NOT a
     * usermode handle. */
    status = ZwTerminateProcess(process_id,
                                STATUS_SYSTEM_INTEGRITY_POLICY_VIOLATION);

    if (!NT_SUCCESS(status)) {
        /*
         * We don't want to clear the process config if
         * ZwTerminateProcess fails so we can try again.
         */
        DEBUG_ERROR("ZwTerminateProcess failed with status %x", status);
        return;
    }
    /* this wont be needed when procloadstuff is implemented */
    SessionTerminate();
}

VOID
SessionIncrementIrpsProcessedCount()
{
    ImpKeAcquireGuardedMutex(&GetActiveSession()->lock);
    GetActiveSession()->irps_processed++;
    ImpKeReleaseGuardedMutex(&GetActiveSession()->lock);
}

VOID
SessionIncrementReportCount()
{
    ImpKeAcquireGuardedMutex(&GetActiveSession()->lock);
    GetActiveSession()->report_count++;
    ImpKeReleaseGuardedMutex(&GetActiveSession()->lock);
}

VOID
SessionIncrementHeartbeatCount()
{
    ImpKeAcquireGuardedMutex(&GetActiveSession()->lock);
    GetActiveSession()->heartbeat_count++;
    ImpKeReleaseGuardedMutex(&GetActiveSession()->lock);
}
```

`driver/session.h`:

```h
#ifndef SESSION_H
#define SESSION_H

#include "common.h"

#include "driver.h"

VOID
SessionInitialiseStructure();

VOID
SessionInitialiseCallbackConfiguration();

VOID
SessionIsActive(_Out_ PBOOLEAN Flag);

VOID
SessionGetProcess(_Out_ PEPROCESS* Process);

VOID
SessionGetProcessId(_Out_ PLONG ProcessId);

VOID
SessionGetCallbackConfiguration(
    _Out_ POB_CALLBACKS_CONFIG* CallbackConfiguration);

VOID
SessionTerminate();

NTSTATUS
SessionInitialise(_In_ PIRP Irp);

VOID
SessionTerminateProcess();

VOID
SessionIncrementIrpsProcessedCount();

VOID
SessionIncrementReportCount();

VOID
SessionIncrementHeartbeatCount();

#endif
```

`driver/thread.c`:

```c
#include "thread.h"

#include <intrin.h>

#include "pool.h"
#include "callbacks.h"
#include "driver.h"
#include "queue.h"
#include "session.h"
#include "imports.h"

#ifdef ALLOC_PRAGMA
#    pragma alloc_text(PAGE, DetectThreadsAttachedToProtectedProcess)
#    pragma alloc_text(PAGE, ValidateThreadsPspCidTableEntry)
#endif

BOOLEAN
ValidateThreadsPspCidTableEntry(_In_ PETHREAD Thread)
{
    PAGED_CODE();

    NTSTATUS status    = STATUS_UNSUCCESSFUL;
    HANDLE   thread_id = NULL;
    PETHREAD thread    = NULL;

    /*
     * PsGetThreadId simply returns ETHREAD->Cid.UniqueThread
     */
    thread_id = ImpPsGetThreadId(Thread);

    /*
     * For each core on the processor, the first x threads equal to x cores
     * will be assigned a cid equal to its equivalent core. These threads
     * are generally executing the HLT instruction or some other boring
     * stuff while the processor is not busy. The reason this is important
     * is because passing in a handle value of 0 which, even though is a
     * valid cid, returns a non success status meaning we mark it an invalid
     * cid entry even though it is. To combat this we simply add a little
     * check here. The problem is this can be easily bypassed by simply
     * modifying the ETHREAD->Cid.UniqueThread identifier.. So while it isnt
     * a perfect detection method for now it's good enough.
     */
    if ((UINT64)thread_id < (UINT64)ImpKeQueryActiveProcessorCount(NULL))
        return TRUE;

    /*
     * PsLookupThreadByThreadId will use a threads id to find its cid entry,
     * and return the pointer contained in the HANDLE_TABLE entry pointing
     * to the thread object. Meaning if we pass a valid thread id which we
     * retrieved above and dont receive a STATUS_SUCCESS the cid entry could
     * potentially be removed or disrupted..
     */
    status = ImpPsLookupThreadByThreadId(thread_id, &thread);

    if (!NT_SUCCESS(status)) {
        DEBUG_WARNING(
            "Failed to lookup thread by id. PspCidTable entry potentially removed.");
        return FALSE;
    }

    return TRUE;
}

/*
 * I did not reverse this myself and previously had no idea how you would go
 * about detecting KiAttachProcess so credits to KANKOSHEV for the find:
 *
 * https://github.com/KANKOSHEV/Detect-KeAttachProcess/tree/main
 * https://doxygen.reactos.org/d0/dc9/procobj_8c.html#adec6dc539d4a5c0ee7d0f48e24ef0933
 *
 * To expand on his writeup a little, the offset that he provides is equivalent
 * to PKAPC_STATE->Process. This is where KiAttachProcess writes the process
 * that thread is attaching to when it's called. The APC_STATE structure holds
 * relevant information about the thread's APC state and is quite important
 * during context switch scenarios as it's how the thread determines if it has
 * any APC's queued.
 */
STATIC VOID
DetectAttachedThreadsProcessCallback(_In_ PTHREAD_LIST_ENTRY ThreadListEntry,
                                     _Inout_opt_ PVOID       Context)
{
    UNREFERENCED_PARAMETER(Context);

    PKAPC_STATE apc_state         = NULL;
    PEPROCESS   protected_process = NULL;

    SessionGetProcess(&protected_process);

    if (!protected_process)
        return;

    apc_state = (PKAPC_STATE)((UINT64)ThreadListEntry->thread +
                              KTHREAD_APC_STATE_OFFSET);

    /*
     * We don't care if a thread owned by our protected process is attached
     *
     * todo: this is filterless and will just report anything, need to have
     * a look into what processes actually attach to real games
     */
    if (!(apc_state->Process == protected_process &&
          ThreadListEntry->owning_process != protected_process)) {
        return;
    }

    DEBUG_WARNING("Thread is attached to our protected process: %llx",
                  (UINT64)ThreadListEntry->thread);

    PATTACH_PROCESS_REPORT report = ImpExAllocatePool2(
        POOL_FLAG_NON_PAGED, sizeof(ATTACH_PROCESS_REPORT), REPORT_POOL_TAG);

    if (!report)
        return;

    report->report_code    = REPORT_ILLEGAL_ATTACH_PROCESS;
    report->thread_id      = ImpPsGetThreadId(ThreadListEntry->thread);
    report->thread_address = ThreadListEntry->thread;

    if (!NT_SUCCESS(IrpQueueCompleteIrp(report, sizeof(ATTACH_PROCESS_REPORT))))
        DEBUG_ERROR("IrpQueueCompleteIrp failed with no status.");
}

VOID
DetectThreadsAttachedToProtectedProcess()
{
    PAGED_CODE();
    DEBUG_VERBOSE("Detecting threads attached to our process...");
    EnumerateThreadListWithCallbackRoutine(DetectAttachedThreadsProcessCallback,
                                           NULL);
}

```

`driver/thread.h`:

```h
#ifndef THREAD_H
#define THREAD_H

#include <ntifs.h>

#include "common.h"
#include "callbacks.h"

BOOLEAN
ValidateThreadsPspCidTableEntry(_In_ PETHREAD Thread);

VOID
DetectThreadsAttachedToProtectedProcess();

#endif
```

`driver/types/types.h`:

```h
#ifndef TYPES_H
#define TYPES_H

#include "../common.h"

#define REPORT_NMI_CALLBACK_FAILURE 50
#define REPORT_MODULE_VALIDATION_FAILURE 60
#define REPORT_ILLEGAL_HANDLE_OPERATION 70
#define REPORT_INVALID_PROCESS_ALLOCATION 80
#define REPORT_HIDDEN_SYSTEM_THREAD 90
#define REPORT_ILLEGAL_ATTACH_PROCESS 100
#define REPORT_APC_STACKWALK 110
#define REPORT_DPC_STACKWALK 120
#define REPORT_DATA_TABLE_ROUTINE 130
#define REPORT_INVALID_PROCESS_MODULE 140

typedef enum _TABLE_ID
{
        HalDispatch = 0,
        HalPrivateDispatch
} TABLE_ID;

typedef struct _HYPERVISOR_DETECTION_REPORT
{
        INT aperf_msr_timing_check;
        INT invd_emulation_check;

} HYPERVISOR_DETECTION_REPORT, *PHYPERVISOR_DETECTION_REPORT;

#define APC_STACKWALK_BUFFER_SIZE 500

typedef struct _APC_STACKWALK_REPORT
{
        INT    report_code;
        UINT64 kthread_address;
        UINT64 invalid_rip;
        CHAR   driver[APC_STACKWALK_BUFFER_SIZE];

} APC_STACKWALK_REPORT, *PAPC_STACKWALK_REPORT;

typedef struct _DPC_STACKWALK_REPORT
{
        UINT32 report_code;
        UINT64 kthread_address;
        UINT64 invalid_rip;
        CHAR   driver[APC_STACKWALK_BUFFER_SIZE];

} DPC_STACKWALK_REPORT, *PDPC_STACKWALK_REPORT;

typedef struct _MODULE_VALIDATION_FAILURE
{
        INT    report_code;
        INT    report_type;
        UINT64 driver_base_address;
        UINT64 driver_size;
        CHAR   driver_name[128];

} MODULE_VALIDATION_FAILURE, *PMODULE_VALIDATION_FAILURE;

#define DATA_TABLE_ROUTINE_BUF_SIZE 256

typedef struct _DATA_TABLE_ROUTINE_REPORT
{
        UINT32   report_code;
        TABLE_ID id;
        UINT64   address;
        CHAR     routine[DATA_TABLE_ROUTINE_BUF_SIZE];

} DATA_TABLE_ROUTINE_REPORT, *PDATA_TABLE_ROUTINE_REPORT;

typedef struct _NMI_CALLBACK_FAILURE
{
        INT    report_code;
        INT    were_nmis_disabled;
        UINT64 kthread_address;
        UINT64 invalid_rip;

} NMI_CALLBACK_FAILURE, *PNMI_CALLBACK_FAILURE;

#define REPORT_INVALID_PROCESS_BUFFER_SIZE 500

typedef struct _INVALID_PROCESS_ALLOCATION_REPORT
{
        INT  report_code;
        CHAR process[REPORT_INVALID_PROCESS_BUFFER_SIZE];

} INVALID_PROCESS_ALLOCATION_REPORT, *PINVALID_PROCESS_ALLOCATION_REPORT;

typedef struct _HIDDEN_SYSTEM_THREAD_REPORT
{
        INT    report_code;
        INT    found_in_kthreadlist;
        INT    found_in_pspcidtable;
        UINT64 thread_address;
        LONG   thread_id;
        CHAR   thread[500];

} HIDDEN_SYSTEM_THREAD_REPORT, *PHIDDEN_SYSTEM_THREAD_REPORT;

typedef struct _ATTACH_PROCESS_REPORT
{
        INT    report_code;
        UINT32 thread_id;
        UINT64 thread_address;

} ATTACH_PROCESS_REPORT, *PATTACH_PROCESS_REPORT;

typedef struct _KPRCB_THREAD_VALIDATION_CTX
{
        UINT64  thread;
        BOOLEAN thread_found_in_pspcidtable;
        // BOOLEAN thread_found_in_kthreadlist;
        BOOLEAN finished;

} KPRCB_THREAD_VALIDATION_CTX, *PKPRCB_THREAD_VALIDATION_CTX;

#define HANDLE_REPORT_PROCESS_NAME_MAX_LENGTH 64

typedef struct _OPEN_HANDLE_FAILURE_REPORT
{
        INT  report_code;
        INT  is_kernel_handle;
        LONG process_id;
        LONG thread_id;
        LONG access;
        CHAR process_name[HANDLE_REPORT_PROCESS_NAME_MAX_LENGTH];

} OPEN_HANDLE_FAILURE_REPORT, *POPEN_HANDLE_FAILURE_REPORT;

#define MODULE_PATH_LEN 256

typedef struct _PROCESS_MODULE_VALIDATION_REPORT
{
        INT    report_code;
        UINT64 image_base;
        UINT32 image_size;
        WCHAR  module_path[MODULE_PATH_LEN];

} PROCESS_MODULE_VALIDATION_REPORT, *PPROCESS_MODULE_VALIDATION_REPORT;

#endif
```

`module/client/message_queue.cpp`:

```cpp
#include "message_queue.h"

#include <Windows.h>

#define TEST_STEAM_64_ID 123456789;

client::message_queue::message_queue(LPTSTR PipeName) {
#if NO_SERVER
  LOG_INFO("No_Server build used. Not opening named pipe.");
#else
  this->pipe_interface = std::make_unique<client::pipe>(PipeName);
#endif
}

void client::message_queue::dequeue_message(void *Buffer, size_t Size) {
#if NO_SERVER
  return;
#else
  this->pipe_interface->read_pipe(Buffer, Size);
#endif
}

void client::message_queue::enqueue_message(void *Buffer, size_t Size) {
#if NO_SERVER
  return;
#else
  return;
#endif
}

```

`module/client/message_queue.h`:

```h
#ifndef REPORT_H
#define REPORT_H

#include <Windows.h>

#include "../dispatcher/threadpool.h"

#include "../common.h"

#include "pipe.h"

#define REPORT_BUFFER_SIZE 8192
#define SEND_BUFFER_SIZE 8192

#define MAX_SIGNATURE_SIZE 256

#define MESSAGE_TYPE_CLIENT_REPORT 1
#define MESSAGE_TYPE_CLIENT_SEND 2
#define MESSAGE_TYPE_CLIENT_REQUEST 3

namespace client {

class message_queue {
  struct MESSAGE_PACKET_HEADER {
    int message_type;
    int request_id;
    unsigned __int64 steam64_id;
  };

  std::unique_ptr<client::pipe> pipe_interface;
  std::mutex lock;

  byte report_buffer[REPORT_BUFFER_SIZE];

public:
  message_queue(LPTSTR PipeName);
  void enqueue_message(void *Buffer, size_t Size);
  void dequeue_message(void *Buffer, size_t Size);
};

} // namespace client

#endif

```

`module/client/pipe.cpp`:

```cpp
#include "pipe.h"

#include "../common.h"

#include <intrin.h>

client::pipe::pipe(LPTSTR PipeName) {
  this->pipe_name = PipeName;
  this->pipe_handle =
      CreateFile(this->pipe_name, GENERIC_READ | GENERIC_WRITE, 0, NULL,
                 OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);

  if (this->pipe_handle == INVALID_HANDLE_VALUE) {
    LOG_ERROR("CreateFile failed with status 0x%x", GetLastError());
    return;
  }
}

void client::pipe::write_pipe(PVOID Buffer, SIZE_T Size) {
  DWORD bytes_written = 0;

  WriteFile(this->pipe_handle, Buffer, Size, &bytes_written, NULL);

  if (bytes_written == 0) {
    LOG_ERROR("WriteFile failed with status code 0x%x", GetLastError());
    return;
  }
}

void client::pipe::read_pipe(PVOID Buffer, SIZE_T Size) {
  BOOL status = FALSE;
  DWORD bytes_read = 0;

  status = ReadFile(this->pipe_handle, Buffer, Size, &bytes_read, NULL);

  if (status == NULL) {
    LOG_ERROR("ReadFile failed with status code 0x%x", GetLastError());
    return;
  }
}

```

`module/client/pipe.h`:

```h
#pragma once

#include <Windows.h>

#define MESSAGE_TYPE_CLIENT_REPORT 1
#define MESSAGE_TYPE_CLIENT_SEND 2
#define MESSAGE_TYPE_CLIENT_REQUEST 3

#define MOTHERBOARD_SERIAL_CODE_LENGTH 64
#define DEVICE_DRIVE_0_SERIAL_CODE_LENGTH 64

namespace client {
class pipe {
  HANDLE pipe_handle;
  LPTSTR pipe_name;

public:
  pipe(LPTSTR PipeName);

  void write_pipe(PVOID Buffer, SIZE_T Size);
  void read_pipe(PVOID Buffer, SIZE_T Size);
};

namespace headers {
typedef enum _ENVIRONMENT_TYPE {
  NativeWindows = 0,
  Vmware,
  VirtualBox

} ENVIRONMENT_TYPE;

typedef enum _PROCESSOR_TYPE {
  Unknown = 0,
  GenuineIntel,
  AuthenticAmd

} PROCESSOR_TYPE;

#define VENDOR_STRING_MAX_LENGTH 256
struct SYSTEM_INFORMATION {
  CHAR motherboard_serial[MOTHERBOARD_SERIAL_CODE_LENGTH];
  CHAR drive_0_serial[DEVICE_DRIVE_0_SERIAL_CODE_LENGTH];
  CHAR vendor[VENDOR_STRING_MAX_LENGTH];
  BOOLEAN virtualised_environment;
  ENVIRONMENT_TYPE environment;
  PROCESSOR_TYPE processor;
  RTL_OSVERSIONINFOW os_information;
};

} // namespace headers
} // namespace client
```

`module/common.h`:

```h
#pragma once

#include <stdio.h>

#include <atomic>
#include <mutex>
#include <optional>
#include <vector>

#define LOG_INFO(fmt, ...) printf("[+] " fmt "\n", ##__VA_ARGS__)
#define LOG_ERROR(fmt, ...) printf("[-] " fmt "\n", ##__VA_ARGS__)

#define ABSOLUTE(wait) (wait)
#define RELATIVE(wait) (-(wait))

#define NANOSECONDS(nanos) (((signed __int64)(nanos)) / 100L)
#define MICROSECONDS(micros) (((signed __int64)(micros)) * NANOSECONDS(1000L))
#define MILLISECONDS(milli) (((signed __int64)(milli)) * MICROSECONDS(1000L))
#define SECONDS(seconds) (((signed __int64)(seconds)) * MILLISECONDS(1000L))
#define LOG_ERROR(fmt, ...) printf("[-] " fmt "\n", ##__VA_ARGS__)

```

`module/dispatcher/dispatcher.cpp`:

```cpp
#include "dispatcher.h"

#include "../client/message_queue.h"
#include "../helper.h"

#include <bcrypt.h>
#include <chrono>

dispatcher::dispatcher::dispatcher(LPCWSTR driver_name,
                                   client::message_queue &message_queue)
    : thread_pool(DISPATCHER_THREAD_COUNT),
      k_interface(driver_name, message_queue) {}

void dispatcher::dispatcher::request_session_pk() {
#ifdef NO_SERVER
  LOG_INFO("NO_SERVER Build used. Generating local session key pair.");
#else
  LOG_INFO("Requesting session key pair.");
#endif
}

void dispatcher::dispatcher::write_shared_mapping_operation() {
  int operation =
      helper::generate_rand_int(kernel_interface::SHARED_STATE_OPERATION_COUNT);
  LOG_INFO("Shared mapping operation callback received. operation: %lx",
           operation);
  this->k_interface.write_shared_mapping_operation(
      *reinterpret_cast<kernel_interface::shared_state_operation_id *>(
          &operation));
}

void dispatcher::dispatcher::init_timer_callbacks() {
  /* we want to offset when our driver routines are called */
  this->k_interface.initiate_shared_mapping();
  std::optional<HANDLE> result = this->timers.insert_callback(
      std::bind(&dispatcher::dispatcher::write_shared_mapping_operation, this),
      WRITE_SHARED_MAPPING_DUE_TIME, WRITE_SHARED_MAPPING_PERIOD);
  helper::sleep_thread(TIMER_CALLBACK_DELAY);
}

void dispatcher::dispatcher::run_timer_thread() {
  thread_pool.queue_job([this]() { this->timers.run_timer_thread(); });
}

void dispatcher::dispatcher::run_io_port_thread() {
  thread_pool.queue_job([this]() { k_interface.run_completion_port(); });
}

void dispatcher::dispatcher::run() {
  //helper::generate_rand_seed();
  std::srand(std::time(nullptr));
  this->init_timer_callbacks();
  this->run_timer_thread();
  this->run_io_port_thread();
  thread_pool.queue_job([this]() { k_interface.run_completion_port(); });
  while (true) {
    //this->issue_kernel_job();
          this->k_interface.initiate_apc_stackwalk();
    helper::sleep_thread(DISPATCH_LOOP_SLEEP_TIME);
  }
}

void dispatcher::dispatcher::issue_kernel_job() {
  switch (helper::generate_rand_int(KERNEL_DISPATCH_FUNCTION_COUNT)) {
  case 0:
    thread_pool.queue_job([this]() { k_interface.enumerate_handle_tables(); });
    break;
  case 1:
    thread_pool.queue_job([this]() { k_interface.perform_integrity_check(); });
    break;
  case 2:
    thread_pool.queue_job(
        [this]() { k_interface.scan_for_unlinked_processes(); });
    break;
  case 3:
    thread_pool.queue_job(
        [this]() { k_interface.verify_process_module_executable_regions(); });
    break;
  case 4:
    thread_pool.queue_job(
        [this]() { k_interface.validate_system_driver_objects(); });
    break;
  case 5:
    thread_pool.queue_job([this]() { k_interface.run_nmi_callbacks(); });
    break;
  case 6:
    thread_pool.queue_job(
        [this]() { k_interface.scan_for_attached_threads(); });
    break;
  case 7:
    thread_pool.queue_job([this]() { k_interface.initiate_apc_stackwalk(); });
    break;
  case 8:
    thread_pool.queue_job([this]() { k_interface.scan_for_ept_hooks(); });
    break;
  case 9:
    thread_pool.queue_job([this]() { k_interface.perform_dpc_stackwalk(); });
    break;
  case 10:
    thread_pool.queue_job([this]() { k_interface.validate_system_modules(); });
    break;
  case 11:
    thread_pool.queue_job([this]() { k_interface.validate_pci_devices(); });
    break;
  }
}
```

`module/dispatcher/dispatcher.h`:

```h
#pragma once

#include "threadpool.h"

#include "timer.h"
#include "../kernel_interface/kernel_interface.h"

namespace dispatcher {

constexpr int DISPATCH_LOOP_SLEEP_TIME = 30;
constexpr int KERNEL_DISPATCH_FUNCTION_COUNT = 12;
constexpr int DISPATCHER_THREAD_COUNT = 4;
constexpr int TIMER_CALLBACK_DELAY = 15;
constexpr int WRITE_SHARED_MAPPING_PERIOD = 30;
constexpr int WRITE_SHARED_MAPPING_DUE_TIME = 30;

class dispatcher {
  timer timers;
  thread_pool thread_pool;
  kernel_interface::kernel_interface k_interface;

  void issue_kernel_job();
  void write_shared_mapping_operation();
  void init_timer_callbacks();
  void run_timer_thread();
  void run_io_port_thread();
  void request_session_pk();

public:
  dispatcher(LPCWSTR driver_name, client::message_queue &queue);
  void run();
};
} // namespace dispatcher
```

`module/dispatcher/threadpool.cpp`:

```cpp
#include "threadpool.h"

/*
 * This is the idle loop each thread will be running until a job is ready
 * for execution
 */
void dispatcher::thread_pool::wait_for_task() {
  while (true) {
    std::function<void()> job;
    {
      std::unique_lock<std::mutex> lock(this->queue_mutex);

      /*
       * This is equivalent to :
       *
       *		while (!this->jobs.empty() || should_terminate)
       *			mutex_condition.wait(lock);
       *
       * we are essentially waiting for a job to be queued up or the terminate
       *flag to be set. Another piece of useful information is that the
       *predicate is checked under the lock as the precondition for .wait() is
       *that the calling thread owns the lock.
       *
       * Now, when .wait() is run, the lock is unlocked the the executing thread
       *is blocked and is added to a list of threads current waiting on the
       *predicate. In our case whether there are new jobs available for the
       *terminate flag is set. Once the condition variables are true i.e there
       *are new jobs or we are terminating, the lock is reacquired by the thread
       *and the thread is unblocked.
       */
      mutex_condition.wait(lock, [this] {
        return !this->jobs.empty() || this->should_terminate;
      });

      if (this->should_terminate)
        return;

      /* get the first job in the queue*/
      job = jobs.front();
      jobs.pop();
    }
    /* run the job */
    job();
  }
}

dispatcher::thread_pool::thread_pool(int thread_count) {
  this->thread_count = thread_count;
  this->should_terminate = false;

  /* Initiate our threads and store them in our threads vector */
  for (int i = 0; i < this->thread_count; i++) {
    this->threads.emplace_back(std::thread(&thread_pool::wait_for_task, this));
  }
}

void dispatcher::thread_pool::queue_job(const std::function<void()> &job) {
  /* push a job into our job queue safely by holding our queue lock */
  std::unique_lock<std::mutex> lock(this->queue_mutex);

  this->jobs.push(job);
  lock.unlock();

  mutex_condition.notify_one();
}

void dispatcher::thread_pool::terminate() {
  /* safely set our termination flag to true */
  std::unique_lock<std::mutex> lock(this->queue_mutex);
  should_terminate = true;
  lock.unlock();

  /* unlock all threads waiting on our condition */
  mutex_condition.notify_all();

  /* join the threads and clear our threads vector */
  for (std::thread &thread : threads) {
    thread.join();
  }
  threads.clear();
}

bool dispatcher::thread_pool::busy_wait() {
  /* allows us to wait for when the job queue is empty allowing us to safely
   * call the destructor */
  std::unique_lock<std::mutex> lock(this->queue_mutex);

  bool pool_busy = !jobs.empty();
  this->queue_mutex.unlock();

  return pool_busy;
}

```

`module/dispatcher/threadpool.h`:

```h
#pragma once

#include <functional>
#include <mutex>
#include <queue>
#include <vector>

namespace dispatcher {
/*
 * This ThreadPool class is a simple threadpool implementation that will allow
 * us to delegate jobs to a set number of threads without the constant need to
 * close and open new threads.
 */
class thread_pool {
  int thread_count;
  bool should_terminate;
  std::mutex queue_mutex;
  std::condition_variable mutex_condition;
  std::vector<std::thread> threads;
  std::queue<std::function<void()>> jobs;

  void wait_for_task();

public:
  thread_pool(int thread_count);
  void queue_job(const std::function<void()> &job);
  void terminate();
  bool busy_wait();
};
} // namespace dispatcher
```

`module/dispatcher/timer.cpp`:

```cpp
#include "timer.h"

#include "../common.h"
#include "../helper.h"

dispatcher::timer::timer() {
  this->active_callbacks = 0;
  for (auto &entry : handles) {
    entry = INVALID_HANDLE_VALUE;
  }
}

dispatcher::timer::~timer() {}

HANDLE dispatcher::timer::create_timer_object() {
  return CreateWaitableTimer(nullptr, false, nullptr);
}

bool dispatcher::timer::set_timer_object(HANDLE handle, LARGE_INTEGER *due_time,
                                         unsigned long period) {
  return SetWaitableTimer(handle, due_time, period, nullptr, nullptr, false) > 0
             ? true
             : false;
}

dispatcher::timer::callback::callback(std::function<void()> routine,
                                      int due_time_seconds,
                                      int period_seconds) {
  this->callback_routine = routine;
  this->due_time.QuadPart = helper::seconds_to_nanoseconds(due_time_seconds);
  this->period = helper::seconds_to_milliseconds(period_seconds);
}

std::optional<HANDLE>
dispatcher::timer::insert_callback(std::function<void()> routine,
                                   int due_time_seconds, int period_seconds) {
  std::lock_guard<std::mutex> lock(this->lock);
  std::optional<HANDLE *> handle = this->find_free_handle();
  if (!handle.has_value()) {
    LOG_ERROR("No free event handles available. Unable to create timer.");
    return {};
  }

  *handle.value() = create_timer_object();
  if (*handle.value() == NULL) {
    LOG_ERROR("CreateWaitableTimer failed with status %x", GetLastError());
    return {};
  }

  callback cb(routine, due_time_seconds, period_seconds);
  if (!set_timer_object(*handle.value(), &cb.due_time, cb.period)) {
    LOG_ERROR("SetWaitableTimer failed with status %x", GetLastError());
  }

  std::pair<HANDLE, callback> entry(*handle.value(), cb);
  this->callbacks.insert(entry);
  this->insert_handle(*handle.value());
  this->active_callbacks++;
  return *handle.value();
}

/* assumes lock is held by caller */
std::optional<HANDLE *> dispatcher::timer::find_free_handle() {
  for (int index = 0; index < MAXIMUM_WAIT_OBJECTS; index++) {
    if (handles[index] == INVALID_HANDLE_VALUE)
      return &handles[index];
  }
  return {};
}

/* assumes lock is held */
void dispatcher::timer::insert_handle(HANDLE handle) {
  for (HANDLE entry : this->handles) {
    if (entry == INVALID_HANDLE_VALUE) {
      entry = handle;
      return;
    }
  }
}

/* assumes lock is held */
void dispatcher::timer::close_handle_entry(HANDLE handle) {
  this->callbacks.erase(handle);
  for (int entry = 0; entry < MAXIMUM_WAIT_OBJECTS; entry++) {
    if (this->handles[entry] == handle) {
      CloseHandle(handle);
      this->handles[entry] = INVALID_HANDLE_VALUE;
      /* ordering doesnt matter, as long as the valid handles are at the front
       * of the array and are contiguous */
      std::sort(this->handles.begin(), this->handles.end());
      this->active_callbacks--;
      return;
    }
  }
}

void dispatcher::timer::dispatch_callback_for_index(unsigned long index) {
  std::unordered_map<HANDLE, callback>::const_iterator it =
      this->callbacks.find(handles[index]);
  if (it == this->callbacks.end())
    return;
  it->second.callback_routine();
}

/* assumes lock is held */
void dispatcher::timer::query_removal_queue() {
  if (callbacks_to_remove.empty())
    return;
  while (!callbacks_to_remove.empty()) {
    HANDLE entry = callbacks_to_remove.front();
    this->close_handle_entry(entry);
    this->callbacks_to_remove.pop();
    this->active_callbacks--;
  }
}

/* todo: maybe have an event object that we can wait on whilst no events are queued, then when we do insert an event alert the event object ? though this isnt urgent for our use case...*/
void dispatcher::timer::run_timer_thread() {
  if (this->active_callbacks == 0)
    return;
  while (true) {
    unsigned long index = WaitForMultipleObjects(
        this->active_callbacks, reinterpret_cast<HANDLE *>(&handles), false,
        INFINITE);
    {
      std::lock_guard<std::mutex> lock(this->lock);
      this->dispatch_callback_for_index(index);
      this->query_removal_queue();
      /* maybe we should have some default event ? */
      if (this->active_callbacks == 0)
        return;
    }
  }
}

/*
 * If we remove a callback whilst the main loop is sleeping, it means the
 * information passed to KeWaitForMultipleObjects will be wrong, hence we need
 * to wait until our thread is run by the scheduler, perform the operation for
 * the alerted handle and THEN remove any entries from the removal queue. Then
 * once we recall KeWaitForMultipleObjects the new handle array will be valid.
 */
void dispatcher::timer::remove_callback(HANDLE handle) {
  std::lock_guard<std::mutex> lock(this->lock);
  this->callbacks_to_remove.push(handle);
}
```

`module/dispatcher/timer.h`:

```h
#pragma once

#include <Windows.h>

#include <array>
#include <functional>
#include <mutex>
#include <optional>
#include <queue>
#include <unordered_map>
#include <vector>

/*
 * array of handles which we pass to WaitForMultipleEvents
 *
 * needa do this rather then use the dedicated apc routien pointer in set timer
 * cos u cant just take a pointer to a member function for some reason lol like
 * tf
 *
 * map maps a handle to a callback object, this object contains various
 * information bust most important the callback routine. When the event is
 * signaled, it returns a handle, use that handle to index the map and run the
 * callback routine. This has to be done as the handles needs to be in a
 * contiguous array, so we can use an array of callback objects.
 */
namespace dispatcher {

constexpr int HANDLE_AVAILABLE = 0;
constexpr int HANDLE_NOT_AVAILABLE = 1;

class timer {

  struct callback {
    bool in_use;
    std::function<void()> callback_routine;
    LARGE_INTEGER due_time;
    unsigned long period;

    callback(std::function<void()> routine, int due_time_seconds,
             int period_seconds);
  };

  std::optional<HANDLE *> find_free_handle();
  void close_handle_entry(HANDLE handle);
  void dispatch_callback_for_index(unsigned long index);
  HANDLE create_timer_object();
  bool set_timer_object(HANDLE handle, LARGE_INTEGER *due_time,
                        unsigned long period);
  void query_removal_queue();
  void insert_handle(HANDLE handle);

public:
  std::mutex lock;
  std::array<HANDLE, MAXIMUM_WAIT_OBJECTS> handles;
  std::unordered_map<HANDLE, callback> callbacks;
  std::queue<HANDLE> callbacks_to_remove;

  int active_callbacks;

  timer();
  ~timer();

  std::optional<HANDLE> insert_callback(std::function<void()> routine,
                                        int due_time_seconds,
                                        int period_seconds);
  void remove_callback(HANDLE handle);
  void run_timer_thread();
};
} // namespace dispatcher
```

`module/helper.cpp`:

```cpp
#include "helper.h"

#include <chrono>
#include <random>

void helper::generate_rand_seed() { srand(time(0)); }

int helper::generate_rand_int(int max) { return std::rand() % max; }

void helper::sleep_thread(int seconds) {
  std::this_thread::sleep_for(std::chrono::seconds(seconds));
}

int helper::get_report_id_from_buffer(void *buffer) {
  kernel_interface::report_header *header =
      reinterpret_cast<kernel_interface::report_header *>(buffer);
  return header->report_id;
}

kernel_interface::report_id helper::get_kernel_report_type(void *buffer) {
  switch (helper::get_report_id_from_buffer(buffer)) {
  case kernel_interface::report_id::report_nmi_callback_failure:
    return kernel_interface::report_id::report_nmi_callback_failure;

  case kernel_interface::report_id::report_module_validation_failure:
    return kernel_interface::report_id::report_module_validation_failure;

  case kernel_interface::report_id::report_illegal_handle_operation:
    return kernel_interface::report_id::report_illegal_handle_operation;

  case kernel_interface::report_id::report_invalid_process_allocation:
    return kernel_interface::report_id::report_invalid_process_allocation;

  case kernel_interface::report_id::report_hidden_system_thread:
    return kernel_interface::report_id::report_hidden_system_thread;

  case kernel_interface::report_id::report_illegal_attach_process:
    return kernel_interface::report_id::report_illegal_attach_process;

  case kernel_interface::report_id::report_apc_stackwalk:
    return kernel_interface::report_id::report_apc_stackwalk;

  case kernel_interface::report_id::report_dpc_stackwalk:
    return kernel_interface::report_id::report_dpc_stackwalk;

  case kernel_interface::report_id::report_data_table_routine:
    return kernel_interface::report_id::report_data_table_routine;
  }
}

void helper::print_kernel_report(void *buffer) {
  switch (get_kernel_report_type(buffer)) {
  case kernel_interface::report_id::report_nmi_callback_failure: {
    kernel_interface::nmi_callback_failure *r1 =
        reinterpret_cast<kernel_interface::nmi_callback_failure *>(buffer);
    LOG_INFO("report type: nmi_callback_failure");
    LOG_INFO("report code: %lx", r1->report_code);
    LOG_INFO("were_nmis_disabled: %lx", r1->were_nmis_disabled);
    LOG_INFO("kthread_address: %llx", r1->kthread_address);
    LOG_INFO("invalid_rip: %llx", r1->invalid_rip);
    LOG_INFO("********************************");
    break;
  }
  case kernel_interface::report_id::report_invalid_process_allocation: {
    kernel_interface::invalid_process_allocation_report *r2 =
        reinterpret_cast<kernel_interface::invalid_process_allocation_report *>(
            buffer);
    LOG_INFO("report type: invalid_process_allocation_report");
    LOG_INFO("report code: %d", r2->report_code);
    LOG_INFO("********************************");
    break;
  }
  case kernel_interface::report_id::report_hidden_system_thread: {
    kernel_interface::hidden_system_thread_report *r3 =
        reinterpret_cast<kernel_interface::hidden_system_thread_report *>(
            buffer);
    LOG_INFO("report type: hidden_system_thread_report");
    LOG_INFO("report code: %lx", r3->report_code);
    LOG_INFO("found_in_kthreadlist: %lx", r3->found_in_kthreadlist);
    LOG_INFO("found_in_pspcidtable: %lx", r3->found_in_pspcidtable);
    LOG_INFO("thread_address: %llx", r3->thread_address);
    LOG_INFO("thread_id: %lx", r3->thread_id);
    LOG_INFO("********************************");
    break;
  }
  case kernel_interface::report_id::report_illegal_attach_process: {
    kernel_interface::attach_process_report *r4 =
        reinterpret_cast<kernel_interface::attach_process_report *>(buffer);
    LOG_INFO("report type: attach_process_report");
    LOG_INFO("report code: %lx", r4->report_code);
    LOG_INFO("thread_id: %lx", r4->thread_id);
    LOG_INFO("thread_address: %llx", r4->thread_address);
    LOG_INFO("********************************");
    break;
  }
  case kernel_interface::report_id::report_illegal_handle_operation: {
    kernel_interface::open_handle_failure_report *r5 =
        reinterpret_cast<kernel_interface::open_handle_failure_report *>(
            buffer);
    LOG_INFO("report type: open_handle_failure_report");
    LOG_INFO("report code: %lx", r5->report_code);
    LOG_INFO("is_kernel_handle: %lx", r5->is_kernel_handle);
    LOG_INFO("process_id: %lx", r5->process_id);
    LOG_INFO("thread_id: %lx", r5->thread_id);
    LOG_INFO("access: %lx", r5->access);
    LOG_INFO("process_name: %s", r5->process_name);
    LOG_INFO("********************************");
    break;
  }
  case kernel_interface::report_id::report_invalid_process_module: {
    kernel_interface::process_module_validation_report *r6 =
        reinterpret_cast<kernel_interface::process_module_validation_report *>(
            buffer);
    LOG_INFO("report type: process_module_validation_report");
    LOG_INFO("report code: %d", r6->report_code);
    LOG_INFO("image_base: %llx", r6->image_base);
    LOG_INFO("image_size: %u", r6->image_size);
    LOG_INFO("module_path: %ls", r6->module_path);
    LOG_INFO("********************************");
    break;
  }
  case kernel_interface::report_id::report_apc_stackwalk: {
    kernel_interface::apc_stackwalk_report *r7 =
        reinterpret_cast<kernel_interface::apc_stackwalk_report *>(buffer);
    LOG_INFO("report type: apc_stackwalk_report");
    LOG_INFO("report code: %d", r7->report_code);
    LOG_INFO("kthread_address: %llx", r7->kthread_address);
    LOG_INFO("invalid_rip: %llx", r7->invalid_rip);
    LOG_INFO("********************************");
    break;
  }
  case kernel_interface::report_id::report_dpc_stackwalk: {
    kernel_interface::dpc_stackwalk_report *r8 =
        reinterpret_cast<kernel_interface::dpc_stackwalk_report *>(buffer);
    LOG_INFO("report type: dpc_stackwalk_report");
    LOG_INFO("report code: %d", r8->report_code);
    LOG_INFO("kthread_address: %llx", r8->kthread_address);
    LOG_INFO("invalid_rip: %llx", r8->invalid_rip);
    LOG_INFO("********************************");
    break;
  }
  case kernel_interface::report_id::report_data_table_routine: {
    kernel_interface::data_table_routine_report *r9 =
        reinterpret_cast<kernel_interface::data_table_routine_report *>(buffer);
    LOG_INFO("report type: data_table_routine_report");
    LOG_INFO("report code: %d", r9->report_code);
    LOG_INFO("id: %d", r9->id);
    LOG_INFO("address: %llx", r9->address);
    LOG_INFO("routine: %s", r9->routine);
    LOG_INFO("********************************");
    break;
  }
  case kernel_interface::report_id::report_module_validation_failure: {
    kernel_interface::module_validation_failure *r10 =
        reinterpret_cast<kernel_interface::module_validation_failure *>(buffer);
    LOG_INFO("report type: module_validation_failure");
    LOG_INFO("report code: %lx", r10->report_code);
    LOG_INFO("report type: %lx", r10->report_type);
    LOG_INFO("driver_base_address: %llx", r10->driver_base_address);
    LOG_INFO("driver_size: %llx", r10->driver_size);
    LOG_INFO("driver_name: %s", r10->driver_name);
    LOG_INFO("********************************");
    break;
  }
  default:
    LOG_INFO("Invalid report type.");
    break;
  }
}

unsigned __int64 helper::seconds_to_nanoseconds(int seconds) {
  return ABSOLUTE(SECONDS(seconds));
}

unsigned __int32 helper::seconds_to_milliseconds(int seconds) {
  return seconds * 1000;
}
```

`module/helper.h`:

```h
#pragma once

#include "kernel_interface/kernel_interface.h"

namespace helper {
void generate_rand_seed();
int generate_rand_int(int max);
void sleep_thread(int seconds);
kernel_interface::report_id get_kernel_report_type(void *buffer);
int get_report_id_from_buffer(void *buffer);
void print_kernel_report(void *buffer);
unsigned __int64 seconds_to_nanoseconds(int seconds);
unsigned __int32 seconds_to_milliseconds(int seconds);
} // namespace helper
```

`module/imports.cpp`:

```cpp
#include "imports.h"

bool imports::initialise_imports() { return false; }
```

`module/imports.h`:

```h
#pragma once

namespace imports
{
bool initialise_imports();


}
```

`module/kernel_interface/kernel_interface.cpp`:

```cpp
#include "kernel_interface.h"

#include <iostream>

#include "../common.h"
#include "../helper.h"

#include <TlHelp32.h>
#include <winternl.h>

typedef BOOLEAN(NTAPI *RtlDosPathNameToNtPathName_U)(PCWSTR DosPathName,
                                                     PUNICODE_STRING NtPathName,
                                                     PCWSTR *NtFileNamePart,
                                                     PVOID DirectoryInfo);

kernel_interface::event_dispatcher *
kernel_interface::kernel_interface::get_free_event_entry() {
  std::lock_guard<std::mutex> lock(this->lock);
  for (std::vector<event_dispatcher>::iterator it = events.begin();
       it != events.end(); it++) {
    if (it->in_use == false) {
      it->in_use = true;
      return &(*it);
    }
  }
  return nullptr;
}

void kernel_interface::kernel_interface::terminate_completion_port() {
  std::lock_guard<std::mutex> lock(this->lock);
  for (std::vector<event_dispatcher>::iterator it = events.begin();
       it != events.end(); it++) {
    free(it->buffer);
    CloseHandle(it->overlapped.hEvent);
  }
}

void kernel_interface::kernel_interface::run_completion_port() {
  DWORD bytes = 0;
  OVERLAPPED *io = nullptr;
  ULONG_PTR key = 0;
  while (true) {
    GetQueuedCompletionStatus(this->port, &bytes, &key, &io, INFINITE);
    if (io == nullptr)
      continue;
    void *buffer = get_buffer_from_event_object(io);
    helper::print_kernel_report(buffer);
    release_event_object(io);
    send_pending_irp();
  }
}

void kernel_interface::kernel_interface::initiate_completion_port() {
  for (int index = 0; index < EVENT_COUNT; index++) {
    void *buffer = malloc(MAXIMUM_REPORT_BUFFER_SIZE);
    this->events.push_back(
        event_dispatcher(buffer, MAXIMUM_REPORT_BUFFER_SIZE));
  }
  this->port = CreateIoCompletionPort(this->driver_handle, nullptr, 0, 0);
  if (!this->port) {
    LOG_ERROR("CreateIoCompletePort failed with status %x", GetLastError());
    return;
  }
  for (int index = 0; index < EVENT_COUNT; index++) {
    send_pending_irp();
  }
}

void kernel_interface::kernel_interface::release_event_object(
    OVERLAPPED *event) {
  std::lock_guard<std::mutex> lock(this->lock);
  for (std::vector<event_dispatcher>::iterator it = events.begin();
       it != events.end(); it++) {
    if (&it->overlapped == event) {
      /* simply zero our the buffer, no need to free and realloc */
      memset(it->buffer, 0, it->buffer_size);
      it->in_use = false;
      ResetEvent(it->overlapped.hEvent);
    }
  }
}

void *kernel_interface::kernel_interface::get_buffer_from_event_object(
    OVERLAPPED *event) {
  std::lock_guard<std::mutex> lock(this->lock);
  for (std::vector<event_dispatcher>::iterator it = events.begin();
       it != events.end(); it++) {
    if (&it->overlapped == event) {
      return it->buffer;
    }
  }
  return nullptr;
}

kernel_interface::kernel_interface::kernel_interface(
    LPCWSTR driver_name, client::message_queue &queue)
    : message_queue(queue) {
  this->driver_name = driver_name;
  this->port = INVALID_HANDLE_VALUE;
  this->driver_handle = CreateFileW(
      driver_name, GENERIC_WRITE | GENERIC_READ | GENERIC_EXECUTE, 0, 0,
      OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_OVERLAPPED, 0);
  if (this->driver_handle == INVALID_HANDLE_VALUE) {
    LOG_ERROR("Failed to open handle to driver with status 0x%x",
              GetLastError());
    return;
  }
  this->notify_driver_on_process_launch();
  this->initiate_completion_port();
}

kernel_interface::kernel_interface::~kernel_interface() {
  this->terminate_completion_port();
  this->notify_driver_on_process_termination();
}

unsigned int kernel_interface::kernel_interface::generic_driver_call_output(
    ioctl_code ioctl, void *output_buffer, size_t buffer_size,
    unsigned long *bytes_returned) {
  return DeviceIoControl(this->driver_handle, ioctl, nullptr, 0, output_buffer,
                         buffer_size, bytes_returned, nullptr);
}

void kernel_interface::kernel_interface::generic_driver_call_input(
    ioctl_code ioctl, void *input_buffer, size_t buffer_size,
    unsigned long *bytes_returned) {
  if (!DeviceIoControl(this->driver_handle, ioctl, input_buffer, buffer_size,
                       nullptr, 0, bytes_returned, nullptr))
    LOG_ERROR("DeviceIoControl failed with status %x", GetLastError());
}

void kernel_interface::kernel_interface::generic_driver_call_apc(
    apc_operation operation) {
  apc_operation_init init = {0};
  init.operation_id = operation;
  this->generic_driver_call_input(ioctl_code::InitiateApcStackwalkOperation,
                                  &init, sizeof(init), nullptr);
}

void kernel_interface::kernel_interface::notify_driver_on_process_launch() {
  unsigned long bytes_returned = 0;
  session_initiation_packet packet = {0};
  packet.protected_process_id = reinterpret_cast<void *>(GetCurrentProcessId());
  generic_driver_call_input(ioctl_code::NotifyDriverOnProcessLaunch, &packet,
                            sizeof(session_initiation_packet), &bytes_returned);
}

void kernel_interface::kernel_interface::detect_system_virtualization() {
  unsigned int status = 0;
  unsigned long bytes_returned = 0;
  hv_detection_packet packet = {0};
  status = generic_driver_call_output(ioctl_code::PerformVirtualisationCheck,
                                      &packet, sizeof(packet), &bytes_returned);
  if (!status) {
    LOG_ERROR("Failed virtualization detection with status %x", GetLastError());
    return;
  }
  if (packet.aperf_msr_timing_check == true ||
      packet.invd_emulation_check == true)
    LOG_INFO("HYPERVISOR DETECTED!!!");
}

void kernel_interface::kernel_interface::generic_driver_call(ioctl_code ioctl) {
  if (!DeviceIoControl(this->driver_handle, ioctl, nullptr, 0, nullptr, 0,
                       nullptr, nullptr))
    LOG_ERROR("DeviceIoControl failed with status %x", GetLastError());
}

void kernel_interface::kernel_interface::run_nmi_callbacks() {
  this->generic_driver_call(ioctl_code::RunNmiCallbacks);
}

void kernel_interface::kernel_interface::validate_pci_devices() {
  this->generic_driver_call(ioctl_code::ValidatePciDevices);
}

void kernel_interface::kernel_interface::validate_system_driver_objects() {
  this->generic_driver_call(ioctl_code::ValidateDriverObjects);
}

void kernel_interface::kernel_interface::enumerate_handle_tables() {
  this->generic_driver_call(ioctl_code::EnumerateHandleTables);
}

void kernel_interface::kernel_interface::scan_for_unlinked_processes() {
  this->generic_driver_call(ioctl_code::ScanForUnlinkedProcesses);
}

void kernel_interface::kernel_interface::perform_integrity_check() {
  this->generic_driver_call(ioctl_code::PerformModuleIntegrityCheck);
}

void kernel_interface::kernel_interface::
    notify_driver_on_process_termination() {
  this->generic_driver_call(ioctl_code::NotifyDriverOnProcessTermination);
}

void kernel_interface::kernel_interface::scan_for_attached_threads() {
  this->generic_driver_call(ioctl_code::ScanFroAttachedThreads);
}

void kernel_interface::kernel_interface::scan_for_ept_hooks() {
  this->generic_driver_call(ioctl_code::ScanForEptHooks);
}

void kernel_interface::kernel_interface::perform_dpc_stackwalk() {
  this->generic_driver_call(ioctl_code::InitiateDpcStackwalk);
}

void kernel_interface::kernel_interface::validate_system_modules() {
  this->generic_driver_call(ioctl_code::ValidateSystemModules);
}

void kernel_interface::kernel_interface::
    verify_process_module_executable_regions() {
//  HANDLE handle = INVALID_HANDLE_VALUE;
//  MODULEENTRY32 module_entry = {0};
//  BOOLEAN status = FALSE;
//  process_module module = {0};
//  unsigned long bytes_returned = 0;
//  RtlDosPathNameToNtPathName_U pRtlDosPathNameToNtPathName_U = NULL;
//  UNICODE_STRING nt_path_name = {0};
//  pRtlDosPathNameToNtPathName_U = (RtlDosPathNameToNtPathName_U)GetProcAddress(
//      GetModuleHandle("ntdll.dll"), "RtlDosPathNameToNtPathName_U");
//  handle = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32,
//                                    GetCurrentProcessId());
//  if (handle == INVALID_HANDLE_VALUE) {
//    LOG_ERROR("CreateToolHelp32Snapshot with TH32CS_SNAPMODULE failed with "
//              "status 0x%x",
//              GetLastError());
//    return;
//  }
//  module_entry.dwSize = sizeof(MODULEENTRY32);
//  if (!Module32First(handle, &module_entry)) {
//    LOG_ERROR("Module32First failed with status 0x%x", GetLastError());
//    return;
//  }
//  do {
//    module.module_base = module_entry.modBaseAddr;
//    module.module_size = module_entry.modBaseSize;
//    status = (*pRtlDosPathNameToNtPathName_U)(module_entry.szExePath,
//                                              &nt_path_name, NULL, NULL);
//    if (!status) {
//      LOG_ERROR("RtlDosPathNameToNtPathName_U failed with no status.");
//      continue;
//    }
//    memcpy(module.module_path, nt_path_name.Buffer, MAX_MODULE_PATH);
//    this->generic_driver_call_input(ioctl_code::ValidateProcessLoadedModule,
//                                    &module, sizeof(module), &bytes_returned);
//  } while (Module32Next(handle, &module_entry));
//end:
//  CloseHandle(handle);
}

void kernel_interface::kernel_interface::initiate_apc_stackwalk() {
  this->generic_driver_call_apc(apc_operation::operation_stackwalk);
}

void kernel_interface::kernel_interface::send_pending_irp() {
  DWORD status = 0;
  event_dispatcher *event = get_free_event_entry();
  if (!event) {
    LOG_ERROR("All event objects in use.");
    return;
  }
  status = DeviceIoControl(
      this->driver_handle, ioctl_code::InsertIrpIntoIrpQueue, NULL, NULL,
      event->buffer, event->buffer_size, NULL, &event->overlapped);
  /*
   * im not sure why this returns a status of ERROR_INVALID_FUNCTION when we use
   * the inserted irp to complete a deferred irp - even though that procedure
   * should return STATUS_SUCCESS? Weird.. Anyhow it works.
   */
  if (status == ERROR_IO_PENDING || status == ERROR_SUCCESS ||
      status == ERROR_INVALID_FUNCTION)
    return;
  LOG_ERROR("failed to insert irp into irp queue %x", status);
}

// void kernel_interface::kernel_interface::query_deferred_reports() {
//   unsigned long bytes_returned = 0;
//   void *buffer = malloc(MAXIMUM_REPORT_BUFFER_SIZE);
//   if (!buffer)
//     return;
//   for (int i = 0; i < QUERY_DEFERRED_REPORT_COUNT; i++) {
//     unsigned int status =
//         generic_driver_call_output(ioctl_code::QueryDeferredReports, buffer,
//                                    MAXIMUM_REPORT_BUFFER_SIZE,
//                                    &bytes_returned);
//     if (status && bytes_returned > 0)
//       helper::print_kernel_report(buffer);
//     memset(buffer, 0, MAXIMUM_REPORT_BUFFER_SIZE);
//   }
//   free(buffer);
// }

void kernel_interface::kernel_interface::write_shared_mapping_operation(
    shared_state_operation_id operation_id) {
  InterlockedExchange16(
      reinterpret_cast<SHORT *>(&this->mapping.buffer->operation_id),
      operation_id);
}

void kernel_interface::kernel_interface::initiate_shared_mapping() {
  LOG_INFO("Initialising shared memory buffer!");
  unsigned long bytes_returned = 0;
  unsigned long result = this->generic_driver_call_output(
      ioctl_code::InitiateSharedMapping, &this->mapping,
      sizeof(kernel_interface::shared_mapping), &bytes_returned);
  if (!result) {
    LOG_ERROR("DeviceIoControl failed with status %x", GetLastError());
    return;
  }
}
```

`module/kernel_interface/kernel_interface.h`:

```h
#pragma once

#include <Windows.h>

#include "../client/message_queue.h"

namespace kernel_interface {

static constexpr int EVENT_COUNT = 5;
static constexpr int MAX_MODULE_PATH = 256;
static constexpr int MAXIMUM_REPORT_BUFFER_SIZE = 1000;
static constexpr int QUERY_DEFERRED_REPORT_COUNT = 10;
static constexpr int AES_128_KEY_SIZE = 16;

enum report_id {
  report_nmi_callback_failure = 50,
  report_module_validation_failure = 60,
  report_illegal_handle_operation = 70,
  report_invalid_process_allocation = 80,
  report_hidden_system_thread = 90,
  report_illegal_attach_process = 100,
  report_apc_stackwalk = 110,
  report_dpc_stackwalk = 120,
  report_data_table_routine = 130,
  report_invalid_process_module = 140
};

struct report_header {
  int report_id;
};

constexpr int APC_STACKWALK_BUFFER_SIZE = 500;
constexpr int DATA_TABLE_ROUTINE_BUF_SIZE = 256;
constexpr int REPORT_INVALID_PROCESS_BUFFER_SIZE = 500;
constexpr int HANDLE_REPORT_PROCESS_NAME_MAX_LENGTH = 64;
constexpr int MODULE_PATH_LEN = 256;

struct apc_stackwalk_report {
  int report_code;
  uint64_t kthread_address;
  uint64_t invalid_rip;
  char driver[APC_STACKWALK_BUFFER_SIZE];
};

struct dpc_stackwalk_report {
  uint32_t report_code;
  uint64_t kthread_address;
  uint64_t invalid_rip;
  char driver[APC_STACKWALK_BUFFER_SIZE];
};

struct module_validation_failure {
  int report_code;
  int report_type;
  uint64_t driver_base_address;
  uint64_t driver_size;
  char driver_name[128];
};

enum table_id { hal_dispatch = 0, hal_private_dispatch };

struct data_table_routine_report {
  uint32_t report_code;
  table_id id;
  uint64_t address;
  char routine[DATA_TABLE_ROUTINE_BUF_SIZE];
};

struct nmi_callback_failure {
  int report_code;
  int were_nmis_disabled;
  uint64_t kthread_address;
  uint64_t invalid_rip;
};

struct invalid_process_allocation_report {
  int report_code;
  char process[REPORT_INVALID_PROCESS_BUFFER_SIZE];
};

struct hidden_system_thread_report {
  int report_code;
  int found_in_kthreadlist;
  int found_in_pspcidtable;
  uint64_t thread_address;
  long thread_id;
  char thread[500];
};

struct attach_process_report {
  int report_code;
  uint32_t thread_id;
  uint64_t thread_address;
};

struct kprcb_thread_validation_ctx {
  uint64_t thread;
  bool thread_found_in_pspcidtable;
  bool finished;
};

struct open_handle_failure_report {
  int report_code;
  int is_kernel_handle;
  long process_id;
  long thread_id;
  long access;
  char process_name[HANDLE_REPORT_PROCESS_NAME_MAX_LENGTH];
};

struct process_module_validation_report {
  int report_code;
  uint64_t image_base;
  uint32_t image_size;
  wchar_t module_path[MODULE_PATH_LEN];
};

enum apc_operation { operation_stackwalk = 0x1 };

// clang-format off
enum ioctl_code
{
        RunNmiCallbacks =                       CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20001, METHOD_BUFFERED, FILE_ANY_ACCESS),
        ValidateDriverObjects =                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20002, METHOD_BUFFERED, FILE_ANY_ACCESS),
        NotifyDriverOnProcessLaunch =           CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20004, METHOD_BUFFERED, FILE_ANY_ACCESS),
        QueryForApcCompletion =                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20005, METHOD_BUFFERED, FILE_ANY_ACCESS),
        PerformVirtualisationCheck =            CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20006, METHOD_BUFFERED, FILE_ANY_ACCESS),
        EnumerateHandleTables =                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20007, METHOD_BUFFERED, FILE_ANY_ACCESS),
        NotifyDriverOnProcessTermination =      CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20010, METHOD_BUFFERED, FILE_ANY_ACCESS),
        ScanForUnlinkedProcesses =              CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20011, METHOD_BUFFERED, FILE_ANY_ACCESS),
        PerformModuleIntegrityCheck =           CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20013, METHOD_BUFFERED, FILE_ANY_ACCESS),
        ScanFroAttachedThreads =                CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20014, METHOD_BUFFERED, FILE_ANY_ACCESS),
        ValidateProcessLoadedModule =           CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20015, METHOD_BUFFERED, FILE_ANY_ACCESS),
        RequestHardwareInformation =            CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20016, METHOD_BUFFERED, FILE_ANY_ACCESS),
        InitiateApcStackwalkOperation =         CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20017, METHOD_BUFFERED, FILE_ANY_ACCESS),
        ScanForEptHooks =                       CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20018, METHOD_BUFFERED, FILE_ANY_ACCESS),
        InitiateDpcStackwalk =                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20019, METHOD_BUFFERED, FILE_ANY_ACCESS),
        ValidateSystemModules =                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20020, METHOD_BUFFERED, FILE_ANY_ACCESS),
        InsertIrpIntoIrpQueue =                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20021, METHOD_BUFFERED, FILE_ANY_ACCESS),
        QueryDeferredReports =                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20022, METHOD_BUFFERED, FILE_ANY_ACCESS),
        InitiateSharedMapping =                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20023, METHOD_BUFFERED, FILE_ANY_ACCESS),
        ValidatePciDevices =                    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20024, METHOD_BUFFERED, FILE_ANY_ACCESS)
};

constexpr int SHARED_STATE_OPERATION_COUNT = 9;

enum shared_state_operation_id
{
        ssRunNmiCallbacks = 0,
        ssValidateDriverObjects,
        ssEnumerateHandleTables,
        ssScanForUnlinkedProcesses,
        ssPerformModuleIntegrityCheck,
        ssScanForAttachedThreads,
        ssScanForEptHooks,
        ssInitiateDpcStackwalk,
        ssValidateSystemModules,
};

// clang-format on

struct event_dispatcher {
  bool in_use;
  OVERLAPPED overlapped;
  void *buffer;
  unsigned long buffer_size;

  event_dispatcher(void *buffer, unsigned long buffer_size) {
    this->in_use = false;
    this->overlapped.hEvent = CreateEvent(nullptr, false, false, nullptr);
    this->buffer = buffer;
    this->buffer_size = buffer_size;
  }
};

class kernel_interface {
  struct session_initiation_packet {
    unsigned __int32 session_cookie;
    char session_aes_key[AES_128_KEY_SIZE];
    void *protected_process_id;
  };

  struct hv_detection_packet {
    unsigned long aperf_msr_timing_check;
    unsigned long invd_emulation_check;
  };

  struct process_module {
    void *module_base;
    size_t module_size;
    wchar_t module_path[MAX_MODULE_PATH];
  };

  struct apc_operation_init {
    int operation_id;
  };

  HANDLE driver_handle;
  LPCWSTR driver_name;
  client::message_queue &message_queue;
  HANDLE port;
  std::mutex lock;
  std::vector<event_dispatcher> events;

  struct shared_data {
    unsigned __int32 status;
    unsigned __int16 operation_id;
  };

  struct shared_mapping {
    shared_data *buffer;
    size_t size;
  };

  shared_mapping mapping;

  void initiate_completion_port();
  void terminate_completion_port();
  event_dispatcher *get_free_event_entry();
  void release_event_object(OVERLAPPED *event);
  void *get_buffer_from_event_object(OVERLAPPED *event);

  void notify_driver_on_process_launch();
  void notify_driver_on_process_termination();
  void generic_driver_call(ioctl_code ioctl);
  unsigned int generic_driver_call_output(ioctl_code ioctl, void *output_buffer,
                                          size_t buffer_size,
                                          unsigned long *bytes_returned);
  void generic_driver_call_input(ioctl_code ioctl, void *input_buffer,
                                 size_t buffer_size,
                                 unsigned long *bytes_returned);
  void generic_driver_call_apc(apc_operation operation);

public:
  kernel_interface(LPCWSTR driver_name, client::message_queue &queue);
  ~kernel_interface();

  void run_completion_port();
  void run_nmi_callbacks();
  void validate_pci_devices();
  void validate_system_driver_objects();
  void detect_system_virtualization();
  void enumerate_handle_tables();
  void scan_for_unlinked_processes();
  void perform_integrity_check();
  void scan_for_attached_threads();
  void scan_for_ept_hooks();
  void perform_dpc_stackwalk();
  void validate_system_modules();
  void verify_process_module_executable_regions();
  void initiate_apc_stackwalk();
  void send_pending_irp();
  void write_shared_mapping_operation(shared_state_operation_id operation_id);
  void initiate_shared_mapping();
};
} // namespace kernel_interface
```

`module/main.cpp`:

```cpp
#include <Windows.h>

#include "module.h"

DWORD WINAPI Init(HINSTANCE hinstDLL) {
  module::run(hinstDLL);
  return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call,
                      LPVOID lpReserved) {
  switch (ul_reason_for_call) {
  case DLL_PROCESS_ATTACH: {
    DisableThreadLibraryCalls(hModule);

    const auto thread =
        CreateThread(nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(Init),
                     hModule, 0, nullptr);

    if (thread)
      CloseHandle(thread);

    break;
  }

  case DLL_THREAD_ATTACH:
  case DLL_THREAD_DETACH:
  case DLL_PROCESS_DETACH:
    
  {
    LOG_INFO("process closing!");
    break;
  }
  }
  return TRUE;
}

```

`module/module.cpp`:

```cpp
#include "module.h"

#include <Windows.h>

#include "client/message_queue.h"
#include "dispatcher/dispatcher.h"

void
module::run(HINSTANCE hinstDLL)
{
#if DEBUG
        AllocConsole();
        FILE* file;
        freopen_s(&file, "CONOUT$", "w", stdout);
        freopen_s(&file, "CONIN$", "r", stdin);
#endif

        LPTSTR  pipe_name   = (LPTSTR)L"\\\\.\\pipe\\DonnaACPipe";
        LPCWSTR driver_name = L"\\\\.\\DonnaAC";

        client::message_queue  queue(pipe_name);
        dispatcher::dispatcher dispatch(driver_name, queue);
        dispatch.run();

#if DEBUG
        fclose(stdout);
        fclose(stdin);
        FreeConsole();
#endif

        FreeLibraryAndExitThread(hinstDLL, 0);
}

void
module::terminate()
{
}
```

`module/module.h`:

```h
#pragma once

#include "common.h"

#include <Windows.h>

namespace module {
void run(HINSTANCE hinstDLL);
void terminate();
} // namespace module
```

`module/module.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release - No Server|Win32">
      <Configuration>Release - No Server</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release - No Server|x64">
      <Configuration>Release - No Server</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="test|Win32">
      <Configuration>test</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="test|x64">
      <Configuration>test</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{3b18467a-4358-45ef-81b1-5c6f9b0b6728}</ProjectGuid>
    <RootNamespace>module</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='test|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='test|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release - No Server|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='test|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release - No Server|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='test|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;MODULE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;MODULE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='test|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;MODULE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>
      </PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NO_SERVER</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='test|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NO_SERVER</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dispatcher\timer.cpp" />
    <ClCompile Include="helper.cpp" />
    <ClCompile Include="imports.cpp" />
    <ClCompile Include="module.cpp" />
    <ClCompile Include="client\message_queue.cpp" />
    <ClCompile Include="client\pipe.cpp" />
    <ClCompile Include="dispatcher\dispatcher.cpp" />
    <ClCompile Include="dispatcher\threadpool.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="kernel_interface\kernel_interface.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="client\message_queue.h" />
    <ClInclude Include="client\pipe.h" />
    <ClInclude Include="dispatcher\dispatcher.h" />
    <ClInclude Include="dispatcher\threadpool.h" />
    <ClInclude Include="common.h" />
    <ClInclude Include="dispatcher\timer.h" />
    <ClInclude Include="helper.h" />
    <ClInclude Include="imports.h" />
    <ClInclude Include="kernel_interface\kernel_interface.h" />
    <ClInclude Include="module.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`module/module.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="dispatcher\timer.cpp" />
    <ClCompile Include="helper.cpp" />
    <ClCompile Include="imports.cpp" />
    <ClCompile Include="module.cpp" />
    <ClCompile Include="client\message_queue.cpp" />
    <ClCompile Include="client\pipe.cpp" />
    <ClCompile Include="dispatcher\dispatcher.cpp" />
    <ClCompile Include="dispatcher\threadpool.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="kernel_interface\kernel_interface.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="client\message_queue.h" />
    <ClInclude Include="client\pipe.h" />
    <ClInclude Include="dispatcher\dispatcher.h" />
    <ClInclude Include="dispatcher\threadpool.h" />
    <ClInclude Include="common.h" />
    <ClInclude Include="dispatcher\timer.h" />
    <ClInclude Include="helper.h" />
    <ClInclude Include="imports.h" />
    <ClInclude Include="kernel_interface\kernel_interface.h" />
    <ClInclude Include="module.h" />
  </ItemGroup>
</Project>
```

`server/Database/Entity/HardwareConfiguration.cs`:

```cs
using Serilog;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using server.Database.Model;
using System.Reflection.Metadata.Ecma335;
using Microsoft.EntityFrameworkCore;

namespace server.Database.Entity
{
    public class HardwareConfigurationEntity : HardwareConfiguration
    {
        private readonly ModelContext _modelContext;
        public UserEntity UserEntity { get; set; }

        public HardwareConfigurationEntity(ModelContext modelContext)
        {
            UserEntity = new UserEntity(modelContext);
            _modelContext = modelContext;
        }

        public bool CheckIfHardwareIsBanned()
        {
            return _modelContext.HardwareConfiguration.Any(
                        h => h.MotherboardSerial == MotherboardSerial &&
                             h.DeviceDrive0Serial == DeviceDrive0Serial &&
                             h.IsBanned);
        }

        public void InsertHardwareConfiguration()
        {
            _modelContext.HardwareConfiguration.Add(this);
        }
    }
}

```

`server/Database/Entity/Report/IReportEntity.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Entity.Report
{
    /// <summary>
    /// Implements the IReport interface
    /// </summary>
    public interface IReportEntity
    {   
        /// <summary>
        /// Inserts the report into the database.
        /// </summary>
        void InsertReport();
    }
}

```

`server/Database/Entity/Report/ReportEntity.cs`:

```cs
using server.Database.Model;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Entity.Report
{
    public class ReportEntity : Model.Report
    {
        private readonly ModelContext _modelContext;
        private UserEntity UserEntity { get; set; }

        public ReportEntity(ModelContext modelContext)
        {
            UserEntity = new UserEntity(modelContext);
            _modelContext = modelContext;
        }

        public void InsertReport()
        {
            _modelContext.Reports.Add(this);
        }
    }
}

```

`server/Database/Entity/Report/Types/AttachProcessEntity.cs`:

```cs
using server.Database.Model;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Entity.Report.Types
{
    public class AttachProcessEntity : ReportTypeAttachProcess, IReportEntity
    {
        private readonly ModelContext _modelContext;
        public ReportEntity ReportEntity { get; set; }

        public AttachProcessEntity(ModelContext modelContext)
        {
            ReportEntity = new ReportEntity(modelContext);
            _modelContext = modelContext;
        }

        public void InsertReport()
        {
            _modelContext.ReportTypeAttachProcess.Add(this);
        }
    }
}

```

`server/Database/Entity/Report/Types/HiddenSystemThreadEntity.cs`:

```cs
using server.Database.Model;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Entity.Report.Types
{
    public class HiddenSystemThreadEntity : ReportTypeHiddenSystemThread, IReportEntity
    {
        private readonly ModelContext _modelContext;
        public ReportEntity ReportEntity { get; set; }

        public HiddenSystemThreadEntity(ModelContext modelContext)
        {
            ReportEntity = new ReportEntity(modelContext);
            _modelContext = modelContext;
        }

        public void InsertReport()
        {
            _modelContext.ReportTypeHiddenSystemThread.Add(this);
        }
    }
}

```

`server/Database/Entity/Report/Types/IllegalHandleOperationEntity.cs`:

```cs
using server.Database.Model;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Entity.Report.Types
{
    public class ReportTypeIllegalHandleOperationEntity : ReportTypeIllegalHandleOperation, IReportEntity
    {
        private readonly ModelContext _modelContext;
        public ReportEntity ReportEntity { get; set; }

        public ReportTypeIllegalHandleOperationEntity(ModelContext modelContext)
        {
            ReportEntity = new ReportEntity(modelContext);
            _modelContext = modelContext;
        }
        public void InsertReport()
        {
            _modelContext.ReportTypeIllegalHandleOperation.Add(this);
        }
    }
}

```

`server/Database/Entity/Report/Types/InvalidProcessAllocationEntity.cs`:

```cs
using server.Database.Model;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Entity.Report.Types
{
    public class InvalidProcessAllocationEntity : ReportTypeInvalidProcessAllocation, IReportEntity
    {
        private readonly ModelContext _modelContext;
        public ReportEntity ReportEntity { get; set; }

        public InvalidProcessAllocationEntity(ModelContext modelContext)
        {
            ReportEntity = new ReportEntity(modelContext);
            _modelContext = modelContext;
        }

        public void InsertReport()
        {
            _modelContext.ReportTypeInvalidProcessAllocation.Add(this);
        }
    }
}

```

`server/Database/Entity/Report/Types/NmiCallbackEntity.cs`:

```cs
using server.Database.Model;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Entity.Report.Types
{
    public class NmiCallbackEntity : ReportTypeNmiCallback, IReportEntity
    {
        private readonly ModelContext _modelContext;
        public ReportEntity ReportEntity { get; set; }

        public NmiCallbackEntity(ModelContext modelContext)
        {
            ReportEntity = new ReportEntity(modelContext);
            _modelContext = modelContext;
        }

        public void InsertReport()
        {
            _modelContext.ReportTypeNmiCallback.Add(this);
        }
    }
}

```

`server/Database/Entity/Report/Types/PageProtectionEntity.cs`:

```cs
using server.Database.Model;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Entity.Report.Types
{
    public class PageProtectionEntity : ReportTypePageProtection, IReportEntity
    {
        private readonly ModelContext _modelContext;
        public ReportEntity ReportEntity { get; set; }

        public PageProtectionEntity(ModelContext modelContext)
        {
            ReportEntity = new ReportEntity(modelContext);
            _modelContext = modelContext;
        }

        public void InsertReport()
        {
            _modelContext.ReportTypePageProtection.Add(this);
        }
    }
}

```

`server/Database/Entity/Report/Types/PatternScanEntity.cs`:

```cs
using server.Database.Model;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Entity.Report.Types
{
    public class PatternScanEntity : ReportTypePatternScan, IReportEntity
    {
        private readonly ModelContext _modelContext;
        public ReportEntity ReportEntity { get; set; }

        public PatternScanEntity(ModelContext modelContext)
        {
            ReportEntity = new ReportEntity(modelContext);
            _modelContext = modelContext;
        }

        public void InsertReport()
        {
            _modelContext.ReportTypePatternScan.Add(this);
        }
    }
}

```

`server/Database/Entity/Report/Types/ProcessModuleIntegrityCheckEntity.cs`:

```cs
using server.Database.Model;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Entity.Report.Types
{
    public class ProcessModuleIntegrityCheckEntity : ReportTypeProcessModuleIntegrityCheck, IReportEntity
    {
        private readonly ModelContext _modelContext;

        public ReportEntity ReportEntity { get; set; }

        public ProcessModuleIntegrityCheckEntity(ModelContext modelContext)
        {
            ReportEntity = new ReportEntity(modelContext);
            _modelContext = modelContext;
        }

        public void InsertReport()
        {
            _modelContext.ReportTypeProcessModuleIntegrityCheck.Add(this);
        }
    }
}

```

`server/Database/Entity/Report/Types/StartAddressEntity.cs`:

```cs
using server.Database.Model;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Entity.Report.Types
{
    public class StartAddressEntity : ReportTypeStartAddress, IReportEntity
    {
        private readonly ModelContext _modelContext;
        public ReportEntity ReportEntity { get; set; }

        public StartAddressEntity(ModelContext modelContext)
        {
            ReportEntity = new ReportEntity(modelContext);
            _modelContext = modelContext;
        }

        public void InsertReport()
        {
            _modelContext.ReportTypeStartAddress.Add(this);
        }
    }
}

```

`server/Database/Entity/Report/Types/SystemModuleValidationEntity.cs`:

```cs
using server.Database.Model;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Entity.Report.Types
{
    public class SystemModuleValidationEntity : ReportTypeSystemModuleValidation, IReportEntity
    {
        private readonly ModelContext _modelContext;
        public ReportEntity ReportEntity { get; set; }

        public SystemModuleValidationEntity(ModelContext modelContext)
        {
            ReportEntity = new ReportEntity(modelContext);
            _modelContext = modelContext;
        }

        public void InsertReport()
        {
            _modelContext.ReportTypeSystemModuleValidation.Add(this);
        }
    }
}

```

`server/Database/Entity/User.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using server.Database.Model;
using Serilog;

namespace server.Database.Entity
{
    public class UserEntity : User
    {
        private readonly ModelContext _modelContext;

        public UserEntity(ModelContext modelContext)
        {
            _modelContext = modelContext;
        }

        public bool CheckIfUserExists()
        {
            return _modelContext.Users.Any(u => u.Steam64Id == Steam64Id);
        }

        public bool CheckIfUserIsBanned()
        {
            return _modelContext.Users.Any(u => u.Steam64Id == Steam64Id && u.IsBanned);
        }

        public User GetUserBySteamId(ulong steamId)
        {
            return _modelContext.Users.First(u => u.Steam64Id == steamId);
        }

        public bool CheckIfUsersHardwareExists()
        {
            List<HardwareConfiguration> hardwareConfigurations = _modelContext.HardwareConfiguration
                .Where(h => h.User.Steam64Id == Steam64Id).ToList();

            return hardwareConfigurations.Count > 0;
        }

        public void InsertUser()
        {
            _modelContext.Users.Add(this);
        }
    }
}

```

`server/Database/Model/Model.cs`:

```cs
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static Microsoft.EntityFrameworkCore.DbLoggerCategory;

namespace server.Database.Model
{
    public class User
    {
        public int UserId { get; set; }
        public ulong Steam64Id { get; set; }
        public bool IsBanned { get; set; }
        public virtual ICollection<HardwareConfiguration> HardwareConfigurations { get; set; }
        public virtual ICollection<Report> Reports { get; set; }
    }

    public class HardwareConfiguration
    {
        public int HardwareId { get; set; }
        public virtual User User { get; set; }
        public bool IsBanned { get; set; }
        public string DeviceDrive0Serial { get; set; }
        public string MotherboardSerial { get; set; }
    }

    public class Report
    {
        public int ReportId { get; set; }
        public virtual User User { get; set; }
        public int ReportCode { get; set; }
        public virtual ICollection<ReportTypeIllegalHandleOperation> ReportTypeIllegalHandleOperations { get; set; }
        public virtual ICollection<ReportTypeStartAddress> ReportTypeStartAddresses { get; set; }
        public virtual ICollection<ReportTypePageProtection> ReportTypePageProtections { get; set; }
        public virtual ICollection<ReportTypePatternScan> ReportTypePatternScans { get; set; }
        public virtual ICollection<ReportTypeNmiCallback> ReportTypeNmiCallbacks { get; set; }
        public virtual ICollection<ReportTypeSystemModuleValidation> ReportTypeSystemModuleValidations { get; set; }
        public virtual ICollection<ReportTypeHiddenSystemThread> ReportTypeHiddenSystemThreads { get; set; }
        public virtual ICollection<ReportTypeAttachProcess> ReportTypeAttachProcesses { get; set; }
        public virtual ICollection<ReportTypeInvalidProcessAllocation> ReportTypeInvalidProcessAllocations { get; set; }
        public virtual ICollection<ReportTypeProcessModuleIntegrityCheck> ReportTypeProcessModuleIntegrityChecks { get; set; }
    }

    public class ReportTypeIllegalHandleOperation
    {
        public int ReportNumber { get; set; }
        public virtual Report Report { get; set; }
        public int IsKernelHandle { get; set; }
        public uint ProcessId { get; set; }
        public uint ThreadId { get; set; }
        public uint DesiredAccess { get; set; }
        public string ProcessName { get; set; }
    }

    public class ReportTypeStartAddress
    {
        public int ReportNumber { get; set; }
        public virtual Report Report { get; set; }
        public int ThreadId { get; set; }
        public long ThreadStartAddress { get; set; }
    }

    public class ReportTypePageProtection
    {
        public virtual Report Report { get; set; }
        public int ReportNumber { get; set; }
        public ulong PageBaseAddress { get; set; }
        public long AllocationProtection { get; set; }
        public long AllocationState { get; set; }
        public long AllocationType { get; set; }
    }

    public class ReportTypePatternScan
    {
        public virtual Report Report { get; set; }
        public int ReportNumber { get; set; }
        public int SignatureId { get; set; }
        public ulong Address { get; set; }
    }

    public class ReportTypeNmiCallback
    {
        public virtual Report Report { get; set; }
        public int ReportNumber { get; set; }
        public int WereNmisDisabled { get; set; }
        public ulong KThreadAddress { get; set; }
        public ulong InvalidRip { get; set; }
    }

    public class ReportTypeSystemModuleValidation
    {
        public virtual Report Report { get; set; }
        public int ReportNumber { get; set; }
        public int ReportType { get; set; }
        public long DriverBaseAddress { get; set; }
        public long DriverSize { get; set; }
        public string ModuleName { get; set; }
    }

    public class ReportTypeHiddenSystemThread
    {
        public virtual Report Report { get; set; }
        public int ReportNumber { get; set; }
        public int FoundInKThreadList { get; set; }
        public int FoundInPspCidTable { get; set; }
        public long ThreadAddress { get; set; }
        public int ThreadId { get; set; }
        public byte[] ThreadStructure { get; set; }
    }

    public class ReportTypeAttachProcess
    {
        public virtual Report Report { get; set; }
        public int ReportNumber { get; set; }
        public int ThreadId { get; set; }
        public long ThreadAddress { get; set; }
    }

    public class ReportTypeInvalidProcessAllocation
    {
        public virtual Report Report { get; set; }
        public int ReportNumber { get; set; }
        public byte[] ProcessStructure { get; set; }
    }

    public class ReportTypeProcessModuleIntegrityCheck
    {
        public virtual Report Report { get; set; }
        public int ReportNumber { get; set; }
        public long ModuleBaseAddress { get; set; }
        public int ModuleSize { get; set; }
        public string ModuleName { get; set; }
    }
}
```

`server/Database/Model/ModelContext.cs`:

```cs
using Google.Protobuf.Reflection;
using Microsoft.EntityFrameworkCore;
using MySql.EntityFrameworkCore.Extensions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Emit;
using System.Text;
using System.Threading.Tasks;

namespace server.Database.Model
{
    public class ModelContext : DbContext
    {
        public DbSet<User> Users { get; set; }
        public DbSet<HardwareConfiguration> HardwareConfiguration { get; set; }
        public DbSet<Report> Reports { get; set; }
        public DbSet<ReportTypeIllegalHandleOperation> ReportTypeIllegalHandleOperation { get; set; }
        public DbSet<ReportTypeStartAddress> ReportTypeStartAddress { get; set; }
        public DbSet<ReportTypePageProtection> ReportTypePageProtection { get; set; }
        public DbSet<ReportTypePatternScan> ReportTypePatternScan { get; set; }
        public DbSet<ReportTypeNmiCallback> ReportTypeNmiCallback { get; set; }
        public DbSet<ReportTypeSystemModuleValidation> ReportTypeSystemModuleValidation { get; set; }
        public DbSet<ReportTypeHiddenSystemThread> ReportTypeHiddenSystemThread { get; set; }
        public DbSet<ReportTypeAttachProcess> ReportTypeAttachProcess { get; set; }
        public DbSet<ReportTypeInvalidProcessAllocation> ReportTypeInvalidProcessAllocation { get; set; }
        public DbSet<ReportTypeProcessModuleIntegrityCheck> ReportTypeProcessModuleIntegrityCheck { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseMySQL("server=localhost;userid=root;password=root;database=ac_db");
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<User>(entity =>
            {
                entity.HasKey(e => e.UserId);

                entity.Property(e => e.UserId)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.UserId).Metadata.Name);

                entity.Property(e => e.Steam64Id)
                    .IsRequired();

                entity.Property(e => e.IsBanned)
                    .HasDefaultValue(false);
            });

            modelBuilder.Entity<HardwareConfiguration>(entity =>
            {
                entity.HasKey(e => e.HardwareId);

                entity.Property(e => e.HardwareId)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.HardwareId).Metadata.Name);

                entity.Property(e => e.IsBanned)
                    .HasDefaultValue(false);

                entity.Property(e => e.MotherboardSerial)
                    .IsRequired();

                entity.Property(e => e.DeviceDrive0Serial)
                    .IsRequired();

                entity.HasOne(d => d.User)
                    .WithMany(f => f.HardwareConfigurations);
            });

            modelBuilder.Entity<Report>(entity =>
            {
                entity.HasKey(e => e.ReportId);

                entity.Property(e => e.ReportId)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.ReportId).Metadata.Name);

                entity.HasOne(d => d.User)
                    .WithMany(e => e.Reports);

                entity.Property(e => e.ReportCode)
                    .IsRequired();
            });

            modelBuilder.Entity<ReportTypeIllegalHandleOperation>(entity =>
            {
                entity.HasKey(e => e.ReportNumber);

                entity.Property(e => e.ReportNumber)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.ReportNumber).Metadata.Name);

                entity.Property(e => e.IsKernelHandle)
                    .IsRequired();

                entity.Property(e => e.ProcessId)
                    .IsRequired();

                entity.Property(e => e.ThreadId)
                    .IsRequired();

                entity.Property(e => e.DesiredAccess)
                    .IsRequired();

                entity.Property(e => e.ProcessName)
                    .IsRequired();

                entity.HasOne(d => d.Report)
                    .WithMany(f => f.ReportTypeIllegalHandleOperations);
            });

            modelBuilder.Entity<ReportTypeStartAddress>(entity =>
            {
                entity.HasKey(e => e.ReportNumber);

                entity.Property(e => e.ReportNumber)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.ReportNumber).Metadata.Name);

                entity.Property(e => e.ThreadId)
                    .IsRequired();

                entity.Property(e => e.ThreadStartAddress)
                    .IsRequired();

                entity.HasOne(d => d.Report)
                    .WithMany(f => f.ReportTypeStartAddresses);
            });

            modelBuilder.Entity<ReportTypePageProtection>(entity =>
            {
                entity.HasKey(e => e.ReportNumber);

                entity.Property(e => e.ReportNumber)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.ReportNumber).Metadata.Name);

                entity.Property(e => e.AllocationProtection)
                    .IsRequired();

                entity.Property(e => e.AllocationState)
                    .IsRequired();

                entity.Property(e => e.AllocationType)
                    .IsRequired();

                entity.HasOne(d => d.Report)
                    .WithMany(f => f.ReportTypePageProtections);
            });

            modelBuilder.Entity<ReportTypePatternScan>(entity =>
            {
                entity.HasKey(e => e.ReportNumber);

                entity.Property(e => e.ReportNumber)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.ReportNumber).Metadata.Name);

                entity.Property(e => e.SignatureId)
                    .IsRequired();

                entity.Property(e => e.Address)
                    .IsRequired();

                entity.HasOne(d => d.Report)
                    .WithMany(f => f.ReportTypePatternScans);
            });

            modelBuilder.Entity<ReportTypeNmiCallback>(entity =>
            {
                entity.HasKey(e => e.ReportNumber);

                entity.Property(e => e.ReportNumber)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.ReportNumber).Metadata.Name);

                entity.Property(e => e.WereNmisDisabled)
                    .IsRequired();

                entity.Property(e => e.KThreadAddress)
                    .IsRequired();

                entity.Property(e => e.InvalidRip)
                    .IsRequired();

                entity.HasOne(d => d.Report)
                    .WithMany(f => f.ReportTypeNmiCallbacks);
            });

            modelBuilder.Entity<ReportTypeSystemModuleValidation>(entity =>
            {
                entity.HasKey(e => e.ReportNumber);

                entity.Property(e => e.ReportNumber)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.ReportNumber).Metadata.Name);

                entity.Property(e => e.ReportType)
                    .IsRequired();

                entity.Property(e => e.DriverBaseAddress)
                    .IsRequired();

                entity.Property(e => e.DriverSize)
                    .IsRequired();

                entity.Property(e => e.ModuleName)
                    .IsRequired();

                entity.HasOne(d => d.Report)
                    .WithMany(f => f.ReportTypeSystemModuleValidations);
            });

            modelBuilder.Entity<ReportTypeHiddenSystemThread>(entity =>
            {
                entity.HasKey(e => e.ReportNumber);

                entity.Property(e => e.ReportNumber)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.ReportNumber).Metadata.Name);

                entity.Property(e => e.FoundInKThreadList)
                    .IsRequired();

                entity.Property(e => e.FoundInPspCidTable)
                    .IsRequired();

                entity.Property(e => e.ThreadAddress)
                    .IsRequired();

                entity.Property(e => e.ThreadId)
                    .IsRequired();

                entity.Property(e => e.ThreadStructure)
                    .IsRequired();

                entity.HasOne(d => d.Report)
                    .WithMany(f => f.ReportTypeHiddenSystemThreads);
            });

            modelBuilder.Entity<ReportTypeAttachProcess>(entity =>
            {
                entity.HasKey(e => e.ReportNumber);

                entity.Property(e => e.ReportNumber)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.ReportNumber).Metadata.Name);

                entity.Property(e => e.ThreadId)
                    .IsRequired();

                entity.Property(e => e.ThreadAddress)
                    .IsRequired();

                entity.Property(e => e.ThreadAddress)
                    .IsRequired();

                entity.HasOne(d => d.Report)
                    .WithMany(f => f.ReportTypeAttachProcesses);
            });

            modelBuilder.Entity<ReportTypeInvalidProcessAllocation>(entity =>
            {
                entity.HasKey(e => e.ReportNumber);

                entity.Property(e => e.ReportNumber)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.ReportNumber).Metadata.Name);

                entity.Property(e => e.ProcessStructure)
                    .IsRequired();

                entity.HasOne(d => d.Report)
                    .WithMany(f => f.ReportTypeInvalidProcessAllocations);
            });

            modelBuilder.Entity<ReportTypeProcessModuleIntegrityCheck>(entity =>
            {
                entity.HasKey(e => e.ReportNumber);

                entity.Property(e => e.ReportNumber)
                    .UseMySQLAutoIncrementColumn(entity.Property(e => e.ReportNumber).Metadata.Name);

                entity.Property(e => e.ModuleBaseAddress)
                    .IsRequired();

                entity.Property(e => e.ModuleSize)
                    .IsRequired();

                entity.Property(e => e.ModuleName)
                    .IsRequired();

                entity.HasOne(d => d.Report)
                    .WithMany(f => f.ReportTypeProcessModuleIntegrityChecks);
            });
        }
    }
}

```

`server/Helper.cs`:

```cs
using Microsoft.AspNetCore.Mvc.Infrastructure;
using Serilog;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

#pragma warning disable CS8600
#pragma warning disable CS8603

namespace server
{
    public class Helper
    {
        unsafe public static T BytesToStructure<T>(byte[] buffer, int offset)
        {
            int typeSize = Marshal.SizeOf(typeof(T));

            if (buffer.Length == 0)
                return default(T);

            IntPtr ptr = Marshal.AllocHGlobal(typeSize);

            try
            {
                Marshal.Copy(buffer, offset, ptr, typeSize);
                T result = (T)Marshal.PtrToStructure(ptr, typeof(T));
                Marshal.FreeHGlobal(ptr);
                return result;
            }
            catch(Exception ex)
            {
                Log.Information(ex.Message);
                return default(T);
            }
        }

        unsafe public static byte[] StructureToBytes<T>(ref T structure)
        {
            int typeSize = Marshal.SizeOf(typeof(T));
            byte[] buffer = new byte[typeSize];
            IntPtr ptr = Marshal.AllocHGlobal(typeSize);

            try
            {
                Marshal.StructureToPtr(structure, ptr, true);
                Marshal.Copy(ptr, buffer, 0, typeSize);
                Marshal.FreeHGlobal(ptr);
                return buffer;
            }
            catch (Exception ex)
            {
                Log.Information(ex.Message);
                return null;
            }
        }   

        unsafe public static string FixedUnsafeBufferToSafeString(ref byte[] buffer, int bufferSize, int offset, int stringSize)
        {
            if (stringSize > bufferSize)
                return null;

            char[] stringBuffer = new char[stringSize];

            for (int i = 0; i < stringSize; i++)
            {
                stringBuffer[i] = (char)buffer[offset + i];
            }

            return new string(stringBuffer);
        }
        
        unsafe public static void CopyMemory(ref byte[] source, ref byte[] destination, int size, int offset)
        {
            if (size > destination.Length)
                return;

            for (int i=0; i < size; i++)
            {
                destination[i] = source[i + offset];
            }
        }
    }
}

#pragma warning restore CS8600
#pragma warning restore CS8603
```

`server/Message/ClientReport.cs`:

```cs
using Serilog;
using server.Database.Entity;
using server.Database.Entity.Report;
using server.Database.Entity.Report.Types;
using server.Database.Model;
using server.Types.ClientReport;
using System;
using System.Collections.Generic;
using System.Drawing.Printing;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using static server.Message.MessageHandler;

namespace server.Message
{
    public class ClientReport : IClientMessage
    {
        private readonly ILogger _logger;
        private byte[] _buffer;
        private int _bufferSize;
        private int _bytesRead;
        private PACKET_HEADER _packetHeader;
        CLIENT_REPORT_PACKET_HEADER _currentReportHeader;
        private CLIENT_REPORT_PACKET_RESPONSE _responsePacket;

        private enum CLIENT_SEND_REPORT_ID
        {
            PROCESS_MODULE_VERIFICATION = 10,
            START_ADDRESS_VERIFICATION = 20,
            PAGE_PROTECTION_VERIFICATION = 30,
            PATTERN_SCAN_FAILURE = 40,
            NMI_CALLBACK_FAILURE = 50,
            MODULE_VALIDATION_FAILURE = 60,
            ILLEGAL_HANDLE_OPERATION = 70,
            INVALID_PROCESS_ALLOCATION = 80,
            HIDDEN_SYSTEM_THREAD = 90,
            ILLEGAL_ATTACH_PROCESS = 100
        }

        private struct CLIENT_REPORT_PACKET_HEADER
        {
            public int reportCode;
        }

        private struct CLIENT_REPORT_PACKET_RESPONSE
        {
            public int success;
        }

        public ClientReport(ILogger logger, byte[] buffer, int bufferSize, PACKET_HEADER packetHeader)
        {
            this._logger = logger;
            this._buffer = buffer;
            this._bufferSize = bufferSize;
            this._packetHeader = packetHeader;
            this._bytesRead = 0;
            this._responsePacket = new CLIENT_REPORT_PACKET_RESPONSE();
            this.GetPacketHeader();

            _logger.Information("buffer size: {0}", bufferSize);
        }

        unsafe public void GetPacketHeader()
        {
            this._currentReportHeader = 
                Helper.BytesToStructure<CLIENT_REPORT_PACKET_HEADER>(this._buffer, Marshal.SizeOf(typeof(PACKET_HEADER)) + this._bytesRead);
        }

        public byte[] GetResponsePacket()
        {
            return Helper.StructureToBytes<CLIENT_REPORT_PACKET_RESPONSE>(ref this._responsePacket);
        }

        private void SetResponsePacketData(int success)
        {
            this._responsePacket.success = success;
        }

        unsafe public bool HandleMessage()
        {
            if (this._currentReportHeader.reportCode == 0)
            {
                _logger.Error("Failed to get the report packet code");
                SetResponsePacketData(1);
                return false;
            }

            while (this._bytesRead < this._bufferSize)
            {
                this.GetPacketHeader();

                _logger.Information("Report code: {0}", this._currentReportHeader.reportCode);

                switch (this._currentReportHeader.reportCode)
                {
                    case (int)CLIENT_SEND_REPORT_ID.PROCESS_MODULE_VERIFICATION:
                        _logger.Information("REPORT CODE: MODULE_VERIFICATION");
                        break;
                    case (int)CLIENT_SEND_REPORT_ID.START_ADDRESS_VERIFICATION:

                        _logger.Information("REPORT CODE: START_ADDRESS_VERIFICATION");

                        HandleReportStartAddressVerification(this._bytesRead);

                        this._bytesRead += Marshal.SizeOf(typeof(PROCESS_THREAD_START_FAILURE)) +
                                           Marshal.SizeOf(typeof(PACKET_HEADER));

                        break;

                    case (int)CLIENT_SEND_REPORT_ID.PAGE_PROTECTION_VERIFICATION:

                        _logger.Information("REPORT CODE: PAGE_PROTECTION_VERIFICATION");

                        HandleReportPageProtection(this._bytesRead);

                        this._bytesRead += Marshal.SizeOf(typeof(PAGE_PROTECTION_FAILURE)) +
                                           Marshal.SizeOf(typeof(PACKET_HEADER));

                        break;

                    case (int)CLIENT_SEND_REPORT_ID.PATTERN_SCAN_FAILURE:

                        _logger.Information("REPORT_PATTERN_SCAN_FAILURE");

                        HandleReportPatternScan(this._bytesRead);

                        this._bytesRead += Marshal.SizeOf(typeof(PATTERN_SCAN_FAILURE)) +
                                           Marshal.SizeOf(typeof(PACKET_HEADER));


                        break;

                    case (int)CLIENT_SEND_REPORT_ID.NMI_CALLBACK_FAILURE:

                        _logger.Information("REPORT_NMI_CALLBACK_FAILURE");

                        HandleReportNmiCallback(this._bytesRead);

                        this._bytesRead += Marshal.SizeOf(typeof(NMI_CALLBACK_FAILURE)) + 
                                           Marshal.SizeOf(typeof(PACKET_HEADER));


                        break;

                    case (int)CLIENT_SEND_REPORT_ID.MODULE_VALIDATION_FAILURE:

                        _logger.Information("REPORT_MODULE_VALIDATION_FAILURE");

                        HandleReportSystemModuleValidation(this._bytesRead);

                        this._bytesRead += Marshal.SizeOf(typeof(MODULE_VALIDATION_FAILURE)) + 
                                           Marshal.SizeOf(typeof(PACKET_HEADER));

                        break;

                    case (int)CLIENT_SEND_REPORT_ID.ILLEGAL_HANDLE_OPERATION:

                        _logger.Information("REPORT_ILLEGAL_HANDLE_OPERATION");

                        HandleReportIllegalHandleOperation(this._bytesRead);

                        this._bytesRead += Marshal.SizeOf(typeof(OPEN_HANDLE_FAILURE)) +
                                           Marshal.SizeOf(typeof(PACKET_HEADER));

                        break;

                    case (int)CLIENT_SEND_REPORT_ID.INVALID_PROCESS_ALLOCATION:

                        _logger.Information("REPORT_INVALID_PROCESS_ALLOCATION");

                        HandleReportInvalidProcessAllocation(this._bytesRead);

                        this._bytesRead += Marshal.SizeOf(typeof(INVALID_PROCESS_ALLOCATION_FAILURE)) +
                                           Marshal.SizeOf(typeof(PACKET_HEADER));

                        break;

                    case (int)CLIENT_SEND_REPORT_ID.HIDDEN_SYSTEM_THREAD:

                        _logger.Information("REPORT_HIDDEN_SYSTEM_THREAD");

                        HandleReportHiddenSystemThread(this._bytesRead);

                        this._bytesRead += Marshal.SizeOf(typeof(HIDDEN_SYSTEM_THREAD_FAILURE)) + 
                                           Marshal.SizeOf(typeof(PACKET_HEADER));

                        break;

                    case (int)CLIENT_SEND_REPORT_ID.ILLEGAL_ATTACH_PROCESS:

                        _logger.Information("REPORT_ILLEGAL_ATTACH_PROCESS");

                        HandleReportAttachProcess(this._bytesRead);

                        this._bytesRead += Marshal.SizeOf(typeof(ATTACH_PROCESS_FAILURE)) +
                                           Marshal.SizeOf(typeof(PACKET_HEADER));


                        break;

                    default:
                        _logger.Information("Report code not handled yet");
                        SetResponsePacketData(0);
                        return false;
                }
            }

            SetResponsePacketData(1);
            return true;
        }

        unsafe public void HandleReportIllegalHandleOperation(int offset)
        {
            OPEN_HANDLE_FAILURE report = 
                Helper.BytesToStructure<OPEN_HANDLE_FAILURE>(_buffer, sizeof(PACKET_HEADER) + offset);

            if (report.IsKernelHandle == 0 &&
                report.ProcessId == 0 &&
                report.DesiredAccess == 0)
            {
                return;
            }
                
            _logger.Information("ProcessName: {0}, ProcessID: {1:x}, ThreadId: {2:x}, DesiredAccess{3:x}",
                report.ProcessName,
                report.ProcessId,
                report.ThreadId,
                report.DesiredAccess);

            using (var context = new ModelContext())
            {
                /*
                 * This doesn't seem to be the most optimal way to do this, but it works..
                 * Maybe look into it further at somepoint..
                 */
                UserEntity user = new UserEntity(context);

                var newReport = new ReportEntity(context)
                {
                    User = user.GetUserBySteamId(this._packetHeader.steam64_id),
                    ReportCode = (int)CLIENT_SEND_REPORT_ID.ILLEGAL_HANDLE_OPERATION
                };

                newReport.InsertReport();

                var reportTypeIllegalHandleOperation = new ReportTypeIllegalHandleOperationEntity(context)
                {
                    Report = newReport,
                    IsKernelHandle = report.IsKernelHandle,
                    ProcessId = report.ProcessId,
                    ThreadId = report.ThreadId,
                    DesiredAccess = report.DesiredAccess,
                    ProcessName = report.ProcessName
                };

                reportTypeIllegalHandleOperation.InsertReport();

                context.SaveChanges();
            }
        }

        unsafe public void HandleReportStartAddressVerification(int offset)
        {
            PROCESS_THREAD_START_FAILURE report = 
                Helper.BytesToStructure<PROCESS_THREAD_START_FAILURE>(_buffer, sizeof(PACKET_HEADER) + offset);

            if (report.ThreadId == 0 &&
                report.StartAddress == 0)
            { 
               return;
            }

            _logger.Information("ThreadId: {0}, ThreadStartAddress: {1:x}",
                report.ThreadId,
                report.StartAddress);

            using (var context = new ModelContext())
            {
                UserEntity user = new UserEntity(context);

                var newReport = new ReportEntity(context)
                {
                    User = user.GetUserBySteamId(this._packetHeader.steam64_id),
                    ReportCode = (int)CLIENT_SEND_REPORT_ID.START_ADDRESS_VERIFICATION
                };

                newReport.InsertReport();

                var reportTypeStartAddress = new StartAddressEntity(context)
                {
                    Report = newReport,
                    ThreadId = report.ThreadId,
                    ThreadStartAddress = report.StartAddress
                };

                reportTypeStartAddress.InsertReport();

                context.SaveChanges();
            }
        }

        unsafe public void HandleReportPageProtection(int offset)
        {
            PAGE_PROTECTION_FAILURE report =
                Helper.BytesToStructure<PAGE_PROTECTION_FAILURE>(_buffer, sizeof(PACKET_HEADER) + offset);

            if (report.AllocationProtection == 0 &&
                report.PageBaseAddress == 0 &&
                report.AllocationState == 0 &&
                report.AllocationType == 0 )
            {
                return;
            }

            _logger.Information("Page base address: {0:x}, allocation protection: {1:x}, allocation state: {2:x}, allocationtype: {3:x}",
                report.PageBaseAddress,
                report.AllocationProtection,
                report.AllocationState,
                report.AllocationType);

            using (var context = new ModelContext())
            {
                UserEntity user = new UserEntity(context);

                var newReport = new ReportEntity(context)
                {
                    User = user.GetUserBySteamId(this._packetHeader.steam64_id),
                    ReportCode = (int)CLIENT_SEND_REPORT_ID.PAGE_PROTECTION_VERIFICATION
                };

                newReport.InsertReport();

                var reportTypePageProtection = new PageProtectionEntity(context)
                {
                    Report = newReport,
                    PageBaseAddress = report.PageBaseAddress,
                    AllocationProtection = report.AllocationProtection,
                    AllocationState = report.AllocationState,
                    AllocationType = report.AllocationType
                };

                reportTypePageProtection.InsertReport();

                context.SaveChanges();
            }
        }

        unsafe public void HandleReportPatternScan(int offset)
        {
            PATTERN_SCAN_FAILURE report =
                Helper.BytesToStructure<PATTERN_SCAN_FAILURE>(_buffer, sizeof(PACKET_HEADER) + offset);

            if (report.Address == 0 &&
                report.SignatureId == 0)
            {
                return;
            }

            _logger.Information("signature id: {0}, address: {1:x}",
                report.SignatureId,
                report.Address);

            using (var context = new ModelContext())
            {
                UserEntity user = new UserEntity(context);

                var newReport = new ReportEntity(context)
                {
                    User = user.GetUserBySteamId(this._packetHeader.steam64_id),
                    ReportCode = (int)CLIENT_SEND_REPORT_ID.PATTERN_SCAN_FAILURE
                };

                newReport.InsertReport();

                var reportTypePatternScan = new PatternScanEntity(context)
                {
                    Report = newReport,
                    SignatureId = report.SignatureId,
                    Address = report.Address
                };

                reportTypePatternScan.InsertReport();

                context.SaveChanges();
            }
        }

        unsafe public void HandleReportNmiCallback(int offset)
        {
            NMI_CALLBACK_FAILURE report =
                Helper.BytesToStructure<NMI_CALLBACK_FAILURE>(_buffer, sizeof(PACKET_HEADER) + offset);

            if (report.InvalidRip == 0 &&
                report.WereNmisDisabled == 0 &&
                report.KThreadAddress == 0)
            {
                return;
            }

            _logger.Information("were nmis disabled: {0}, kthread: {1:x}, invalid rip: {2:x}",
                report.WereNmisDisabled,
                report.KThreadAddress,
                report.InvalidRip);

            using (var context = new ModelContext())
            {
                UserEntity user = new UserEntity(context);

                var newReport = new ReportEntity(context)
                {
                    User = user.GetUserBySteamId(this._packetHeader.steam64_id),
                    ReportCode = (int)CLIENT_SEND_REPORT_ID.NMI_CALLBACK_FAILURE
                };

                newReport.InsertReport();

                var reportTypeNmiCallback = new NmiCallbackEntity(context)
                {
                    Report = newReport,
                    WereNmisDisabled = report.WereNmisDisabled,
                    KThreadAddress = report.KThreadAddress,
                    InvalidRip = report.InvalidRip
                };

                reportTypeNmiCallback.InsertReport();

                context.SaveChanges();
            }
        }

        unsafe public void HandleReportSystemModuleValidation(int offset)
        {
            MODULE_VALIDATION_FAILURE report =
                Helper.BytesToStructure<MODULE_VALIDATION_FAILURE>(_buffer, sizeof(PACKET_HEADER) + offset);

            if (report.ReportType == 0 &&
                report.ReportCode == 0 &&
                report.DriverSize == 0 &&
                report.DriverBaseAddress == 0)
            {
                return;
            }

            _logger.Information("report type: {0}, driver base: {1:x}, size: {2}, module name: {3}",
                report.ReportType,
                report.DriverBaseAddress,
                report.DriverSize,
                report.ModuleName);

            using (var context = new ModelContext())
            {
                UserEntity user = new UserEntity(context);

                var newReport = new ReportEntity(context)
                {
                    User = user.GetUserBySteamId(this._packetHeader.steam64_id),
                    ReportCode = (int)CLIENT_SEND_REPORT_ID.MODULE_VALIDATION_FAILURE
                };

                newReport.InsertReport();

                var reportTypeSystemModuleValidation = new SystemModuleValidationEntity(context)
                {
                    Report = newReport,
                    ReportType = report.ReportType,
                    DriverBaseAddress = report.DriverBaseAddress,
                    DriverSize = report.DriverSize,
                    ModuleName = report.ModuleName
                };

                reportTypeSystemModuleValidation.InsertReport();

                context.SaveChanges();
            }
        }

        unsafe public void HandleReportHiddenSystemThread(int offset)
        {
            HIDDEN_SYSTEM_THREAD_FAILURE report =
                Helper.BytesToStructure<HIDDEN_SYSTEM_THREAD_FAILURE>(_buffer, sizeof(PACKET_HEADER) + offset);

            /* todo: some weird reference bug here */

            if (report.FoundInPspCidTable == 0 &&
                report.FoundInKThreadList == 0 &&
                report.ThreadId == 0 &&
                report.ThreadAddress == 0)
            {
                return;
            }

            _logger.Information("found in kthread list: {0}, found in pspcidtable: {1}, thread address: {2:x}, thread id: {3:x}",
                report.FoundInKThreadList,
                report.FoundInPspCidTable,
                report.ThreadAddress,
                report.ThreadId);

            using (var context = new ModelContext())
            {
                UserEntity user = new UserEntity(context);

                var newReport = new ReportEntity(context)
                {
                    User = user.GetUserBySteamId(this._packetHeader.steam64_id),
                    ReportCode = (int)CLIENT_SEND_REPORT_ID.HIDDEN_SYSTEM_THREAD
                };

                newReport.InsertReport();

                var reportTypeHiddenSystemThread = new HiddenSystemThreadEntity(context)
                {
                    Report = newReport,
                    FoundInKThreadList = report.FoundInKThreadList,
                    FoundInPspCidTable = report.FoundInPspCidTable,
                    ThreadAddress = report.ThreadAddress,
                    ThreadId = report.ThreadId,
                    ThreadStructure = report.ThreadStructure
                };

                reportTypeHiddenSystemThread.InsertReport();

                context.SaveChanges();
            }
        }

        unsafe public void HandleReportAttachProcess(int offset)
        {
            ATTACH_PROCESS_FAILURE report =
                Helper.BytesToStructure<ATTACH_PROCESS_FAILURE>(_buffer, sizeof(PACKET_HEADER) + offset);

            if (report.ThreadAddress == 0 &&
                report.ThreadId == 0)
            {
                return;
            }

            _logger.Information("thread id: {0:x}, thread address: {1:x}",
                report.ThreadId,
                report.ThreadAddress);

            using (var context = new ModelContext())
            {
                UserEntity user = new UserEntity(context);

                var newReport = new ReportEntity(context)
                {
                    User = user.GetUserBySteamId(this._packetHeader.steam64_id),
                    ReportCode = (int)CLIENT_SEND_REPORT_ID.ILLEGAL_ATTACH_PROCESS
                };

                newReport.InsertReport();

                var reportTypeAttachProcess = new AttachProcessEntity(context)
                {
                    Report = newReport,
                    ThreadId = report.ThreadId,
                    ThreadAddress = report.ThreadAddress,
                };

                reportTypeAttachProcess.InsertReport();

                context.SaveChanges();
            }
        }

        unsafe public void HandleReportInvalidProcessAllocation(int offset)
        {
            INVALID_PROCESS_ALLOCATION_FAILURE report =
                Helper.BytesToStructure<INVALID_PROCESS_ALLOCATION_FAILURE>(_buffer, sizeof(PACKET_HEADER) + offset);

            if (report.Equals(null)) { return; }

            if (report.ReportCode == 0 &&
                report.ProcessStructure.Length == 0)
            {
                return;
            }

            _logger.Information("received invalid process allocation structure");

            using (var context = new ModelContext())
            {
                UserEntity user = new UserEntity(context);

                var newReport = new ReportEntity(context)
                {
                    User = user.GetUserBySteamId(this._packetHeader.steam64_id),
                    ReportCode = (int)CLIENT_SEND_REPORT_ID.INVALID_PROCESS_ALLOCATION
                };

                newReport.InsertReport();

                var reportTypeInvalidProcessAllocation = new InvalidProcessAllocationEntity(context)
                {
                    Report = newReport,
                    ProcessStructure = report.ProcessStructure
                };

                reportTypeInvalidProcessAllocation.InsertReport();

                context.SaveChanges();
            }
        }
    }
}

```

`server/Message/ClientRequest.cs`:

```cs
using Serilog;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using static server.Message.MessageHandler;

namespace server.Message
{
    public class ClientRequest : IClientMessage
    {
        private readonly ILogger _logger;
        private byte[] _buffer;
        private int _bufferSize;
        private CLIENT_REQUEST_HEADER _header;

        private enum CLIENT_REQUEST_ID
        {
            BLACKLISTED_SIGNATURES = 10,
            WINDOWS_VERSION_STRUCTURE_OFFSETS = 20
        }

        private struct CLIENT_REQUEST_HEADER
        {
            public int RequestId;
        }

        public ClientRequest(ILogger logger, ref byte[] buffer, int bufferSize)
        {
            this._logger = logger;
            this._buffer = buffer;
            this._bufferSize = bufferSize;
        }

        public bool HandleMessage()
        {
            throw new NotImplementedException();
        }

        public unsafe void GetPacketHeader()
        {
            this._header =
                Helper.BytesToStructure<CLIENT_REQUEST_HEADER>(this._buffer, Marshal.SizeOf(typeof(PACKET_HEADER)));
        }

        public byte[] GetResponsePacket()
        {
            throw new NotImplementedException();
        }
    }
}

```

`server/Message/ClientSend.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.PortableExecutable;
using System.Text;
using System.Threading.Tasks;
using Serilog;
using server.Database.Entity;
using server.Database.Model;
using server.Types.ClientSend;
using static server.Message.MessageHandler;

namespace server.Message
{
    public class ClientSend : IClientMessage
    {
        private readonly ILogger _logger;
        private byte[] _buffer;
        private int _bufferSize;
        private int _sendId;
        private PACKET_HEADER _packetHeader;
        private CLIENT_SEND_PACKET_HEADER _clientSendPacketHeader;
        private CLIENT_SEND_PACKET_RESPONSE _responsePacket;

        private enum CLIENT_SEND_REQUEST_ID
        {
            SYSTEM_INFORMATION = 10
        }

        private struct CLIENT_SEND_PACKET_HEADER
        {
            public int RequestId;
            public int PacketSize;
        };

        private struct CLIENT_SEND_PACKET_RESPONSE
        {
            public int RequestId;
            public int CanUserProceed;
            public int reason;
        }

        public ClientSend(ILogger logger, ref byte[] buffer, int bufferSize, PACKET_HEADER packetHeader)
        {
            this._logger = logger;
            this._buffer = buffer;
            this._bufferSize = bufferSize;
            this._packetHeader = packetHeader;
            this._responsePacket = new CLIENT_SEND_PACKET_RESPONSE();
            this.GetPacketHeader();
        }

        unsafe public void GetPacketHeader()
        {
            this._clientSendPacketHeader = 
                Helper.BytesToStructure<CLIENT_SEND_PACKET_HEADER>(_buffer, sizeof(PACKET_HEADER));
        }

        public byte[] GetResponsePacket()
        {
            return Helper.StructureToBytes<CLIENT_SEND_PACKET_RESPONSE>(ref this._responsePacket);
        }

        public bool HandleMessage()
        {
            if (this._clientSendPacketHeader.RequestId == 0)
            {
                _logger.Error("Failed to get the client send report code");
                return false;
            }

            switch (this._clientSendPacketHeader.RequestId)
            {
                case (int)CLIENT_SEND_REQUEST_ID.SYSTEM_INFORMATION:
                    HandleClientSendHardwareInformation(this._clientSendPacketHeader);
                    break;
            }

            return true;
        }

        unsafe private void HandleClientSendHardwareInformation(CLIENT_SEND_PACKET_HEADER sendPacketHeader)
        {
            _logger.Information("Handling client send hardware information");

            PACKET_CLIENT_HARDWARE_INFORMATION info = 
                Helper.BytesToStructure<PACKET_CLIENT_HARDWARE_INFORMATION>(
                    _buffer, sizeof(PACKET_HEADER) + sizeof(CLIENT_SEND_PACKET_HEADER));

            _logger.Information("SteamId: {0}, Mobo Serial: {1}, drive serial: {2}", 
                this._packetHeader.steam64_id, 
                info.MotherboardSerialNumber, 
                info.DeviceDriver0Serial);

            using (var context = new ModelContext())
            {
                context.Database.EnsureCreated();

                var user = new UserEntity(context)
                {
                    Steam64Id = this._packetHeader.steam64_id
                };

                var hardwareConfiguration = new HardwareConfigurationEntity(context)
                {
                    DeviceDrive0Serial = info.DeviceDriver0Serial,
                    MotherboardSerial = info.MotherboardSerialNumber,
                };

                if (user.CheckIfUserExists())
                {
                    if (user.CheckIfUserIsBanned())
                    {
                        _logger.Information("User is banned, updating response packet to halt client.");
                        SetResponsePacketData(0, sendPacketHeader.RequestId, (int)USER_BAN_REASONS.USER_BAN);
                        return;
                    }

                    hardwareConfiguration.User = user.GetUserBySteamId(this._packetHeader.steam64_id);
                }
                else
                {
                    _logger.Information("User does not exist in database, creating new user.");
                    user.InsertUser();
                    hardwareConfiguration.User = user;
                }

                if (hardwareConfiguration.CheckIfHardwareIsBanned())
                {
                    _logger.Information("User is hardware banned, updating response packet to halt client.");
                    SetResponsePacketData(0, sendPacketHeader.RequestId, (int)USER_BAN_REASONS.HARDWARE_BAN);
                    return;
                }

                if (user.CheckIfUsersHardwareExists())
                {
                    _logger.Information("Users hardware already references the user.");
                    SetResponsePacketData(1, sendPacketHeader.RequestId, 0);
                    return;
                }

                _logger.Information("Users hardware does not existing, inserting hardware.");
                hardwareConfiguration.InsertHardwareConfiguration();
                SetResponsePacketData(1, sendPacketHeader.RequestId, 0);

                context.SaveChanges();
            }
        }

        private void SetResponsePacketData(int canUserProceed, int requestId, int reason)
        {
            this._responsePacket.CanUserProceed = canUserProceed;
            this._responsePacket.RequestId = requestId;
            this._responsePacket.reason = reason;
        }
    }
}

```

`server/Message/IClientMessage.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace server.Message
{
    public interface IClientMessage
    {
        /// <summary>
        /// Implements a function that returns the packet header for the type of client 
        /// message it is handling. Is an unsafe function because we are taking the
        /// size of struct which makes c# unhappy.
        /// </summary>
        unsafe void GetPacketHeader();
        /// <summary>
        /// Function which implements the core logic to handle a message received from 
        /// the client. Should take care of all major actions when handling the message.
        /// </summary>
        bool HandleMessage();
        /// <summary>
        /// Function that returns the response packet in the form of a byte array.
        /// </summary>
        byte[] GetResponsePacket();
        
    }
}

```

`server/Message/MessageHandler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Metadata.Ecma335;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using Serilog;
using System.Net;
using System.Net.Sockets;
using server.Types.ClientReport;
using server.Types.ClientSend;
using System.Runtime.InteropServices;
using server.Database.Model;
using server.Database.Entity;
using Org.BouncyCastle.Asn1.BC;
using Org.BouncyCastle.Asn1.Ocsp;

namespace server.Message
{
    public class MessageHandler
    {
        private byte[] _buffer;
        private int _bufferSize;
        private ILogger _logger;
        private PACKET_HEADER _header;
        private NetworkStream _networkStream;
        private TcpClient _tcpClient;

        private enum MESSAGE_TYPE
        {
            MESSAGE_TYPE_CLIENT_REPORT = 1,
            MESSAGE_TYPE_CLIENT_SEND = 2,
            MESSAGE_TYPE_CLIENT_REQUEST = 3
        }

        public struct PACKET_HEADER
        {
            public int message_type;
            public ulong steam64_id;
        };

        private struct PACKET_REQUEST_HEADER
        {
            public int RequestId;
        }

        public MessageHandler(TcpClient client, byte[] buffer, int bufferSize, ILogger logger)
        {
            _tcpClient = client;
            _networkStream = client.GetStream();
            _buffer = buffer;
            _bufferSize = bufferSize;
            _logger = logger;
            _header = GetMessageHeader();

            switch (_header.message_type)
            {
                case (int)MESSAGE_TYPE.MESSAGE_TYPE_CLIENT_REPORT:
                    HandleClientSendReport();
                    break;
                case (int)MESSAGE_TYPE.MESSAGE_TYPE_CLIENT_SEND:
                    HandleClientSendMessage();
                    break;
                default:
                    _logger.Information("This message type is not accepted at the moment.");
                    break;
            }
        }

        private void HandleClientSendReport()
        {
            ClientReport report = new ClientReport(_logger, _buffer, _bufferSize, _header);
           
            if (report.HandleMessage())
            {
                byte[] reponsePacket = report.GetResponsePacket();
                this.SendResponsePacketToClient(reponsePacket);
                return;
            }

            _logger.Warning("Failed to handle client sent report");
        }

        private void HandleClientSendMessage()
        {
            ClientSend send = new ClientSend(_logger, ref _buffer, _bufferSize, _header);

            if (send.HandleMessage())
            {
                byte[] responsePacket = send.GetResponsePacket();
                this.SendResponsePacketToClient(responsePacket);
                return;
            }

            _logger.Warning("Failed to handle client send message");
        }
        private PACKET_HEADER GetMessageHeader()
        {
            return Helper.BytesToStructure<PACKET_HEADER>(_buffer, 0);
        }

        private void SendResponsePacketToClient(byte[] responsePacket)
        {
            _networkStream.Write(responsePacket, 0, responsePacket.Length);
        }
    }
}

```

`server/Program.cs`:

```cs
using Serilog;
using server.Database;
using server.Database.Entity;
using server.Database.Model;
using System.Configuration;
using System.Net;
using System.Net.Sockets;
using System.Reflection.Metadata.Ecma335;
using System.Text;

namespace server
{
    public class Program
    {
        public static async Task Main(string[] args)
        {
            using var logger = new LoggerConfiguration()
                .WriteTo.Console()
                .CreateLogger();

            Server server = new Server(logger);
            await server.Listen();
        }
    }
}
```

`server/Server.cs`:

```cs
using System.IO;
using System;
using System.Net;
using System.Net.Sockets;
using System.Reflection.Metadata.Ecma335;
using System.Text;
using Serilog;
using server.Message;
using Microsoft.EntityFrameworkCore.Metadata.Conventions;
using K4os.Compression.LZ4.Streams.Adapters;

namespace server
{
    public class Server
    {
        private IPEndPoint _ipEndPoint;
        private TcpListener _tcpListener;
        private ILogger _logger;

        public Server(ILogger logger)
        {
            _ipEndPoint = new IPEndPoint(IPAddress.Any, 8888);
            _tcpListener = new TcpListener(_ipEndPoint);
            _logger = logger;
        }

        public async Task Listen()
        {
            _tcpListener.Start();

            _logger.Information("Listening for incoming connections...");

            while (true)
            {
                TcpClient client = await _tcpListener.AcceptTcpClientAsync();

                NetworkStream _stream = client.GetStream();
                TcpClient clientReference = client;

                byte[] buffer = new byte[2048];
                int bytesRead = 0;

                using (MemoryStream stream = new MemoryStream())
                {
                    while (_stream.DataAvailable)
                    {
                        bytesRead = _stream.Read(buffer, 0, buffer.Length);

                        _logger.Information("bytes read: {0}", bytesRead);

                        stream.Write(buffer, 0, bytesRead);
                    }

                    byte[] message = stream.ToArray();

                    if (message.Length == 0)
                    {
                        _logger.Error("Null message received at server");
                        continue;
                    }

                    ThreadPool.QueueUserWorkItem(state => DispatchMessage(state, clientReference, message, message.Length));
                }
            }
        }

        private void DispatchMessage(Object? stateInfo, TcpClient client, byte[] buffer, int bufferSize)
        {
            MessageHandler message = new MessageHandler(client, buffer, bufferSize, _logger);
        }
    }
}
```

`server/Types.cs`:

```cs
using Org.BouncyCastle.Utilities;
using Serilog;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace server
{
    namespace Types
    {
        namespace ClientSend
        {
            struct CLIENT_SEND_PACKET_HEADER
            {
                public int RequestId;
                public int PacketSize;
            };

            public enum USER_BAN_REASONS
            {
                HARDWARE_BAN = 10,
                USER_BAN = 20
            }

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public unsafe struct PACKET_CLIENT_HARDWARE_INFORMATION
            {
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
                public string MotherboardSerialNumber;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
                public string DeviceDriver0Serial;
            }
        }

        namespace ClientReport
        {
            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public unsafe struct PROCESS_MODULE_INTEGRITY_CHECK_FAILURE
            {
                public int ReportCode;
                public UInt64 ModuleBaseAddress;
                public int ModuleSize;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
                public string ModuleName;
            }

            public struct PROCESS_THREAD_START_FAILURE
            {
                public int ReportCode;
                public int ThreadId;
                public long StartAddress;
            }

            public struct PAGE_PROTECTION_FAILURE
            {
                public int ReportCode;
                public UInt64 PageBaseAddress;
                public long AllocationProtection;
                public long AllocationState;
                public long AllocationType;
            }

            public struct PATTERN_SCAN_FAILURE
            {
                public int ReportCode;
                public int SignatureId;
                public UInt64 Address;
            }

            public struct NMI_CALLBACK_FAILURE
            {
                public int ReportCode;
                public int WereNmisDisabled;
                public UInt64 KThreadAddress;
                public UInt64 InvalidRip;
            }

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public unsafe struct MODULE_VALIDATION_FAILURE
            {
                public int ReportCode;
                public int ReportType;
                public long DriverBaseAddress;
                public long DriverSize;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
                public string ModuleName;
            }

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public unsafe struct OPEN_HANDLE_FAILURE
            {
                public int ReportCode;
                public int IsKernelHandle;
                public uint ProcessId;
                public uint ThreadId;
                public uint DesiredAccess;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
                public string ProcessName;

            }

            [StructLayout(LayoutKind.Sequential)]
            public unsafe struct INVALID_PROCESS_ALLOCATION_FAILURE
            {
                public int ReportCode;
                [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4096)]
                public byte[] ProcessStructure;
            }

            [StructLayout(LayoutKind.Sequential)]
            public struct HIDDEN_SYSTEM_THREAD_FAILURE
            {
                public int ReportCode;
                public int FoundInKThreadList;
                public int FoundInPspCidTable;
                public long ThreadAddress;
                public int ThreadId;
                [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4096)]
                public byte[] ThreadStructure;
            }

            public struct ATTACH_PROCESS_FAILURE
            {
                public int ReportCode;
                public int ThreadId;
                public long ThreadAddress;
            }
        }
    }
}

```

`server/server.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net7.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
    <Configurations>Debug;Release;Release - No Server;Release - No Server - Win11</Configurations>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="7.0.10" />
    <PackageReference Include="MySql.Data" Version="8.1.0" />
    <PackageReference Include="MySql.EntityFrameworkCore" Version="7.0.5" />
    <PackageReference Include="Serilog" Version="3.0.1" />
    <PackageReference Include="Serilog.Sinks.Console" Version="4.1.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="5.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\service\service.csproj" />
  </ItemGroup>

</Project>

```

`service/Client.cs`:

```cs
using Microsoft.AspNetCore.Authentication.OAuth.Claims;
using System.Net;
using System.Net.Sockets;
using System.Text;
using Serilog;
using Microsoft.AspNetCore.Http;
using System.Linq.Expressions;

namespace service
{
    public class Client
    {
        private readonly Serilog.ILogger _logger;
        private IPEndPoint _ipEndPoint;
        private TcpClient _tcpClient;
        private NetworkStream _stream;
        private byte[] _buffer;
        private int _bufferSize;

        public Client(ref byte[] buffer, int bufferSize, Serilog.ILogger logger)
        {
            _logger = logger;
            _ipEndPoint = new IPEndPoint(IPAddress.Parse("127.0.0.1"), 8888);
            _tcpClient = new TcpClient();
            _tcpClient.Connect(_ipEndPoint);
            _stream = _tcpClient.GetStream();
            _buffer = buffer;
            _bufferSize = bufferSize;
        }

        public void SendMessageToServer()
        {
            try
            {
                _stream.Write(_buffer, 0, _bufferSize);
            }
            catch(Exception ex)
            {
                _logger.Error("{0}", ex.Message);
            }
        }

        public byte[]? GetResponseFromServer()
        {
            byte[] buffer = new byte[1024];

            try
            {
                using (MemoryStream memoryStream = new MemoryStream())
                {
                    int bytesRead = _stream.Read(buffer, 0, 1024);

                    memoryStream.Write(buffer, 0, bytesRead);

                    return memoryStream.ToArray();
                }
            }
            catch(Exception ex)
            {
                _logger.Error("{0}", ex.Message);
                return null;
            }
        }
    }
}
```

`service/Program.cs`:

```cs
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Serilog;

namespace service
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .UseWindowsService()
                .ConfigureServices((hostContext, services) =>
                {
                    services.AddHostedService<Worker>();
                })
                .UseSerilog((context, configuration) =>
                {
                    var config = context.Configuration;
                    configuration.ReadFrom.Configuration(config);
                });
    }
}
```

`service/Properties/launchSettings.json`:

```json
{
  "profiles": {
    "service": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "environmentVariables": {
        "DOTNET_ENVIRONMENT": "Development"
      }
    }
  }
}

```

`service/Worker.cs`:

```cs
using System.IO.Pipes;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System;
using System.Reflection.PortableExecutable;
using System.Net.Sockets;
using System.Net;
using System.Net.Http;
using Serilog;

#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously
#pragma warning disable CS8600
#pragma warning disable CS8603

namespace service
{
    public class Worker : BackgroundService
    {
        private readonly Serilog.ILogger _logger;
        private NamedPipeServerStream _pipeServer;
        private byte[] _buffer;
        private int _bufferSize;
        private static int MAX_BUFFER_SIZE = 8192;

        private static int OK_RESPONSE_SIZE = 4;

        public Worker(Serilog.ILogger logger)
        {
            _logger = logger;

            _pipeServer = new NamedPipeServerStream(
                "DonnaACPipe", 
                PipeDirection.InOut, 
                1, 
                0, 
                PipeOptions.Asynchronous, 
                MAX_BUFFER_SIZE, 
                MAX_BUFFER_SIZE);

            _bufferSize = MAX_BUFFER_SIZE;
            _buffer = new byte[_bufferSize];
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.Information("Windows service starting, waiting for client to connect");

            // to do: verify whos connecting 
            _pipeServer.WaitForConnection();

            _logger.Information("Client connected to the pipe server");

            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    int numBytesRead = _pipeServer.Read(_buffer, 0, _bufferSize);

                    if (numBytesRead > 0)
                    {
                        _logger.Information("Message received at pipe server with size: {0}", numBytesRead);

                        Client message = new Client(ref _buffer, numBytesRead, _logger);

                        message.SendMessageToServer();

                        ThreadPool.QueueUserWorkItem(state => RelayResponseMessage(ref message));
                    }
                }
                catch (Exception ex)
                {
                    _logger.Error("Reading buffer from pipe failed with message: {0}", ex.Message);
                }

                Array.Clear(_buffer, 0, _bufferSize);
            }
        }

        private void RelayResponseMessage(ref Client message)
        {
            byte[] responseMessage = message.GetResponseFromServer();

            if (responseMessage == null)
            {
                _logger.Warning("Response message is null");
                return;
            }

            _logger.Information("Sending response message to client with size: {0}", responseMessage.Length);

            _pipeServer.Write(responseMessage, 0, responseMessage.Length);
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        internal static extern bool GetNamedPipeClientProcessId(IntPtr Pipe, out uint ClientProcessId);
        public static uint GetNamedPipeClientProcId(NamedPipeServerStream PipeServer)
        {
            UInt32 procId;
            IntPtr pipeHandle = PipeServer.SafePipeHandle.DangerousGetHandle();

            if (GetNamedPipeClientProcessId(pipeHandle, out procId))
                return procId;

            return 0;
        }
    }
}
#pragma warning restore CS1998 // Async method lacks 'await' operators and will run synchronously
#pragma warning restore CS8600
#pragma warning restore CS8603
```

`service/appsettings.Development.json`:

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}

```

`service/appsettings.json`:

```json
{
  "AllowedHosts": "*",
  "Serilog": {
    "MinimumLevel": "Debug",
    "Override": {
      "Microsoft.AspNetCore": "Warning"
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "File",
        "Args": {
          "path": "bin/logs.txt",
          "rollingInterval": "Day"
        }
      }
    ]
  }
}
```

`service/helper.cs`:

```cs
using Serilog;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

#pragma warning disable CS8600
#pragma warning disable CS8603

namespace service
{
    public class Helper
    {
        unsafe public static T BytesToStructure<T>(byte[] buffer, int offset)
        {
            int typeSize = Marshal.SizeOf(typeof(T));

            if (buffer.Length == 0)
                return default(T);

            IntPtr ptr = Marshal.AllocHGlobal(typeSize);

            try
            {
                Marshal.Copy(buffer, offset, ptr, typeSize);
                T result = (T)Marshal.PtrToStructure(ptr, typeof(T));
                Marshal.FreeHGlobal(ptr);
                return result;
            }
            catch (Exception ex)
            {
                Log.Information(ex.Message);
                return default(T);
            }
        }
    }
}

#pragma warning restore CS8600
#pragma warning restore CS8603
```

`service/service.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UserSecretsId>dotnet-service-ab667d6f-8728-45a8-a87c-ae511852674a</UserSecretsId>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Configurations>Debug;Release;Release - No Server;Release - No Server - Win11</Configurations>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Hosting.Abstractions" Version="2.1.1" />
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="7.0.1" />
    <PackageReference Include="Microsoft.Extensions.Hosting.WindowsServices" Version="7.0.1" />
    <PackageReference Include="Serilog" Version="3.0.1" />
    <PackageReference Include="Serilog.AspNetCore" Version="7.0.0" />
    <PackageReference Include="Serilog.Extensions.Hosting" Version="7.0.0" />
    <PackageReference Include="Serilog.Settings.Configuration" Version="7.0.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="5.0.0" />
  </ItemGroup>
</Project>

```

`test/cli/driver.h`:

```h
#pragma once

#include <string>
#include <iostream>

#include <Windows.h>

class DriverInterface
{
	HANDLE driver_handle;

	bool validate_process_name()
	{

	}
	
public:
	DriverInterface(std::string& process_name)
	{
		this->driver_handle = CreateFileW(
			L"donna-ac-test",
			GENERIC_WRITE | GENERIC_READ | GENERIC_EXECUTE,
			0,
			0,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_OVERLAPPED,
			0
		);

		if (this->driver_handle == INVALID_HANDLE_VALUE)
		{
			std::cerr << "Failed to open handle to driver" << std::endl;
			return;
		}


	}
};
```

`test/cli/main.cpp`:

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <string_view>

#include <Windows.h>
#include <tlhelp32.h>

std::wstring cstr_to_wstr(std::string cstr)
{
        return std::wstring(cstr.begin(), cstr.end());
}

DWORD get_proc_id_by_name(const std::string& process_name)
{
        PROCESSENTRY32 entry = { 0 };
        entry.dwSize = sizeof(PROCESSENTRY32);

        HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

        while (Process32Next(snapshot, &entry))
        {
                if (entry.szExeFile == cstr_to_wstr(process_name))
                {
                        return entry.th32ProcessID;
                }
        }

        CloseHandle(snapshot);

        return 0;
}

int main(int argc, char* argv[])
{
        if (argc < 2)
        {
                std::cerr << "Please enter a valid Process Name";
                return EXIT_FAILURE;
        }

        const std::vector<std::string_view> args(argv + 1, argv + argc);

        std::string process_name = std::string(args[0].data());

        DWORD proc_id = get_proc_id_by_name(process_name);

        if (!proc_id)
        {
                std::cerr << "Process does not exist, please enter a valid running process name." << std::endl;
                return EXIT_FAILURE;
        }



        return EXIT_SUCCESS;
}
```

`test/cli/testcli.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release - No Server|Win32">
      <Configuration>Release - No Server</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release - No Server|x64">
      <Configuration>Release - No Server</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{bb9e4b6e-81e3-4d39-8928-0ba3f947c479}</ProjectGuid>
    <RootNamespace>testcli</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`test/cli/testcli.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`test/driver/common.hpp`:

```hpp
#include <ntifs.h>

#define STATIC static
#define VOID   void

typedef UINT32 uint32_t;
typedef UINT64 uint64_t;
typedef UINT16 uint16_t;

#define DEBUG_LOG(fmt, ...)   ImpDbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[+] " fmt "\n", ##__VA_ARGS__)
#define DEBUG_ERROR(fmt, ...) ImpDbgPrintEx(DPFLTR_IHVDRIVER_ID, 0, "[-] " fmt "\n", ##__VA_ARGS__)
```

`test/driver/driver.hpp`:

```hpp
#pragma once

#include "common.hpp"
```

`test/driver/framework.hpp`:

```hpp
#include "common.hpp"

namespace framework
{
	class state
	{

	};
}
```

`test/driver/main.cpp`:

```cpp
#include "driver.hpp"

UNICODE_STRING DRIVER_NAME = RTL_CONSTANT_STRING(L"donna-ac-test");
UNICODE_STRING DRIVER_LINK = RTL_CONSTANT_STRING(L"donna-ac-test-link");

#define IOCTL_RUN_NMI_CALLBACKS                                                \
  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x20001, METHOD_BUFFERED, FILE_ANY_ACCESS)

NTSTATUS
DeviceControl(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp) {
  UNREFERENCED_PARAMETER(DeviceObject);

  NTSTATUS status = STATUS_SUCCESS;
  PIO_STACK_LOCATION stack_location = IoGetCurrentIrpStackLocation(Irp);

  switch (stack_location->Parameters.DeviceIoControl.IoControlCode) {}
end:
  Irp->IoStatus.Status = status;
  IoCompleteRequest(Irp, IO_NO_INCREMENT);
  return status;
}

NTSTATUS
DeviceClose(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp) {
  UNREFERENCED_PARAMETER(DeviceObject);
  IoCompleteRequest(Irp, IO_NO_INCREMENT);
  return Irp->IoStatus.Status;
}

NTSTATUS
DeviceCreate(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp) {
  UNREFERENCED_PARAMETER(DeviceObject);
  IoCompleteRequest(Irp, IO_NO_INCREMENT);
  return Irp->IoStatus.Status;
}

STATIC
VOID DriverUnload(_In_ PDRIVER_OBJECT DriverObject) {
  IoDeleteDevice(DriverObject->DeviceObject);
}

extern "C" NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject,
                                _In_ PUNICODE_STRING RegistryPath) {
  NTSTATUS status;

  status = IoCreateDevice(DriverObject, NULL, &DRIVER_NAME, FILE_DEVICE_UNKNOWN,
                          FILE_DEVICE_SECURE_OPEN, FALSE,
                          &DriverObject->DeviceObject);

  if (!NT_SUCCESS(status)) {
    return STATUS_FAILED_DRIVER_ENTRY;
  }

  status = IoCreateSymbolicLink(&DRIVER_LINK, &DRIVER_NAME);

  if (!NT_SUCCESS(status)) {
    IoDeleteDevice(DriverObject->DeviceObject);
    return STATUS_FAILED_DRIVER_ENTRY;
  }

  DriverObject->MajorFunction[IRP_MJ_CREATE] = DeviceCreate;
  DriverObject->MajorFunction[IRP_MJ_CLOSE] = DeviceClose;
  DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceControl;
  DriverObject->DriverUnload = DriverUnload;

  return STATUS_SUCCESS;
}
```

`test/driver/patch.cpp`:

```cpp
#include "patch.hpp"

namespace framework {
patch::patch(char *image_name) {}

patch::~patch() {}
} // namespace framework
```

`test/driver/patch.hpp`:

```hpp
#include "common.hpp"

namespace framework {
class patch
{
    private:
        char*         image_name;
        void*         image_base;
        void*         patch_address;
        void*         original_bytes;
        unsigned long patch_size;

    public:
        patch(char* image_name);
        ~patch();
};
}
```

`test/driver/testdrv.inf`:

```inf
;
; testdrv.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System ; TODO: specify appropriate Class
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider=%ManufacturerName%
CatalogFile=testdrv.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 12
testdrv_Device_CoInstaller_CopyFiles = 11

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
testdrv.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%testdrv.DeviceDesc%=testdrv_Device, Root\testdrv ; TODO: edit hw-id

[testdrv_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
testdrv.sys

;-------------- Service installation
[testdrv_Device.NT.Services]
AddService = testdrv,%SPSVCINST_ASSOCSERVICE%, testdrv_Service_Inst

; -------------- testdrv driver install sections
[testdrv_Service_Inst]
DisplayName    = %testdrv.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\testdrv.sys

;
;--- testdrv_Device Coinstaller installation ------
;

[testdrv_Device.NT.CoInstallers]
AddReg=testdrv_Device_CoInstaller_AddReg
CopyFiles=testdrv_Device_CoInstaller_CopyFiles

[testdrv_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[testdrv_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[testdrv_Device.NT.Wdf]
KmdfService =  testdrv, testdrv_wdfsect
[testdrv_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "testdrv Installation Disk"
testdrv.DeviceDesc = "testdrv Device"
testdrv.SVCDESC = "testdrv Service"

```

`test/driver/testdrv.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release - No Server - Win11|ARM64">
      <Configuration>Release - No Server - Win11</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release - No Server - Win11|x64">
      <Configuration>Release - No Server - Win11</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release - No Server|ARM64">
      <Configuration>Release - No Server</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release - No Server|x64">
      <Configuration>Release - No Server</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3CE9C9B1-1FB1-4770-ABBB-EE4E6AA949B0}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>testdrv</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server - Win11|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server - Win11|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server - Win11|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server - Win11|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server - Win11|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release - No Server - Win11|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="testdrv.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="patch.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="common.hpp" />
    <ClInclude Include="driver.hpp" />
    <ClInclude Include="framework.hpp" />
    <ClInclude Include="patch.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`test/driver/testdrv.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="testdrv.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="patch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="framework.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="common.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="patch.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```