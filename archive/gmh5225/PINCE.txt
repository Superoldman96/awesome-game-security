Project Path: arc_gmh5225_PINCE_3iooopv2

Source Tree:

```txt
arc_gmh5225_PINCE_3iooopv2
├── AUTHORS
├── COPYING
├── COPYING.CC-BY
├── GUI
│   ├── AboutWidget.py
│   ├── AboutWidget.ui
│   ├── AddAddressManuallyDialog.py
│   ├── AddAddressManuallyDialog.ui
│   ├── BookmarkWidget.py
│   ├── BookmarkWidget.ui
│   ├── BreakpointInfoWidget.py
│   ├── BreakpointInfoWidget.ui
│   ├── ConsoleWidget.py
│   ├── ConsoleWidget.ui
│   ├── CustomAbstractTableModels
│   │   ├── AsciiModel.py
│   │   └── HexModel.py
│   ├── CustomLabels
│   │   ├── FlagRegisterLabel.py
│   │   └── RegisterLabel.py
│   ├── CustomTableViews
│   │   ├── AsciiView.py
│   │   └── HexView.py
│   ├── CustomValidators
│   │   └── HexValidator.py
│   ├── DissectCodeDialog.py
│   ├── DissectCodeDialog.ui
│   ├── EditTypeDialog.py
│   ├── EditTypeDialog.ui
│   ├── ExamineReferrersWidget.py
│   ├── ExamineReferrersWidget.ui
│   ├── FloatRegisterWidget.py
│   ├── FloatRegisterWidget.ui
│   ├── FunctionsInfoWidget.py
│   ├── FunctionsInfoWidget.ui
│   ├── HandleSignalsDialog.py
│   ├── HandleSignalsDialog.ui
│   ├── HexEditDialog.py
│   ├── HexEditDialog.ui
│   ├── InputDialog.py
│   ├── InputDialog.ui
│   ├── LibpinceReferenceWidget.py
│   ├── LibpinceReferenceWidget.ui
│   ├── LoadingDialog.py
│   ├── LoadingDialog.ui
│   ├── LogFileWidget.py
│   ├── LogFileWidget.ui
│   ├── MainWindow.py
│   ├── MainWindow.ui
│   ├── MemoryRegionsWidget.py
│   ├── MemoryRegionsWidget.ui
│   ├── MemoryViewerWindow.py
│   ├── MemoryViewerWindow.ui
│   ├── Notes.txt
│   ├── ReferencedCallsWidget.py
│   ├── ReferencedCallsWidget.ui
│   ├── ReferencedStringsWidget.py
│   ├── ReferencedStringsWidget.ui
│   ├── RestoreInstructionsWidget.py
│   ├── RestoreInstructionsWidget.ui
│   ├── SearchOpcodeWidget.py
│   ├── SearchOpcodeWidget.ui
│   ├── SelectProcess.py
│   ├── SelectProcess.ui
│   ├── SettingsDialog.py
│   ├── SettingsDialog.ui
│   ├── StackTraceInfoWidget.py
│   ├── StackTraceInfoWidget.ui
│   ├── TextEditDialog.py
│   ├── TextEditDialog.ui
│   ├── TraceInstructionsPromptDialog.py
│   ├── TraceInstructionsPromptDialog.ui
│   ├── TraceInstructionsWaitWidget.py
│   ├── TraceInstructionsWaitWidget.ui
│   ├── TraceInstructionsWindow.py
│   ├── TraceInstructionsWindow.ui
│   ├── TrackBreakpointWidget.py
│   ├── TrackBreakpointWidget.ui
│   ├── TrackWatchpointWidget.py
│   ├── TrackWatchpointWidget.ui
│   └── __init__.py
├── MainWindow.py
├── Notes.txt
├── PINCE.py
├── PINCE.sh
├── README.md
├── THANKS
├── __init__.py
├── install_gdb.sh
├── install_pince.sh
├── libpince
│   ├── GDB_Engine.py
│   ├── GuiUtils.py
│   ├── Injection
│   │   ├── Notes.txt
│   │   └── example.c
│   ├── Notes.txt
│   ├── PINCEBackend.py
│   ├── SysUtils.py
│   ├── __init__.py
│   ├── common_regexes.py
│   ├── gdb_python_scripts
│   │   ├── GDBCommandExtensions.py
│   │   ├── ScriptUtils.py
│   │   ├── __init__.py
│   │   └── tests
│   │       ├── Notes.txt
│   │       └── example.c
│   └── type_defs.py
├── media
│   ├── LoadingDialog
│   │   └── ajax-loader.gif
│   ├── TraceInstructionsWaitWidget
│   │   └── ajax-loader.gif
│   ├── icons
│   │   ├── accept.png
│   │   ├── add.png
│   │   ├── anchor.png
│   │   ├── application.png
│   │   ├── application_add.png
│   │   ├── application_cascade.png
│   │   ├── application_delete.png
│   │   ├── application_double.png
│   │   ├── application_edit.png
│   │   ├── application_error.png
│   │   ├── application_form.png
│   │   ├── application_form_add.png
│   │   ├── application_form_delete.png
│   │   ├── application_form_edit.png
│   │   ├── application_form_magnify.png
│   │   ├── application_get.png
│   │   ├── application_go.png
│   │   ├── application_home.png
│   │   ├── application_key.png
│   │   ├── application_lightning.png
│   │   ├── application_link.png
│   │   ├── application_osx.png
│   │   ├── application_osx_terminal.png
│   │   ├── application_put.png
│   │   ├── application_side_boxes.png
│   │   ├── application_side_contract.png
│   │   ├── application_side_expand.png
│   │   ├── application_side_list.png
│   │   ├── application_side_tree.png
│   │   ├── application_split.png
│   │   ├── application_tile_horizontal.png
│   │   ├── application_tile_vertical.png
│   │   ├── application_view_columns.png
│   │   ├── application_view_detail.png
│   │   ├── application_view_gallery.png
│   │   ├── application_view_icons.png
│   │   ├── application_view_list.png
│   │   ├── application_view_tile.png
│   │   ├── application_xp.png
│   │   ├── application_xp_terminal.png
│   │   ├── arrow_branch.png
│   │   ├── arrow_divide.png
│   │   ├── arrow_down.png
│   │   ├── arrow_in.png
│   │   ├── arrow_inout.png
│   │   ├── arrow_join.png
│   │   ├── arrow_left.png
│   │   ├── arrow_merge.png
│   │   ├── arrow_out.png
│   │   ├── arrow_redo.png
│   │   ├── arrow_refresh.png
│   │   ├── arrow_refresh_small.png
│   │   ├── arrow_right.png
│   │   ├── arrow_rotate_anticlockwise.png
│   │   ├── arrow_rotate_clockwise.png
│   │   ├── arrow_switch.png
│   │   ├── arrow_turn_left.png
│   │   ├── arrow_turn_right.png
│   │   ├── arrow_undo.png
│   │   ├── arrow_up.png
│   │   ├── asterisk_orange.png
│   │   ├── asterisk_yellow.png
│   │   ├── attach.png
│   │   ├── award_star_add.png
│   │   ├── award_star_bronze_1.png
│   │   ├── award_star_bronze_2.png
│   │   ├── award_star_bronze_3.png
│   │   ├── award_star_delete.png
│   │   ├── award_star_gold_1.png
│   │   ├── award_star_gold_2.png
│   │   ├── award_star_gold_3.png
│   │   ├── award_star_silver_1.png
│   │   ├── award_star_silver_2.png
│   │   ├── award_star_silver_3.png
│   │   ├── basket.png
│   │   ├── basket_add.png
│   │   ├── basket_delete.png
│   │   ├── basket_edit.png
│   │   ├── basket_error.png
│   │   ├── basket_go.png
│   │   ├── basket_put.png
│   │   ├── basket_remove.png
│   │   ├── bell.png
│   │   ├── bell_add.png
│   │   ├── bell_delete.png
│   │   ├── bell_error.png
│   │   ├── bell_go.png
│   │   ├── bell_link.png
│   │   ├── bin.png
│   │   ├── bin_closed.png
│   │   ├── bin_empty.png
│   │   ├── bomb.png
│   │   ├── book.png
│   │   ├── book_add.png
│   │   ├── book_addresses.png
│   │   ├── book_delete.png
│   │   ├── book_edit.png
│   │   ├── book_error.png
│   │   ├── book_go.png
│   │   ├── book_key.png
│   │   ├── book_link.png
│   │   ├── book_next.png
│   │   ├── book_open.png
│   │   ├── book_previous.png
│   │   ├── box.png
│   │   ├── brick.png
│   │   ├── brick_add.png
│   │   ├── brick_delete.png
│   │   ├── brick_edit.png
│   │   ├── brick_error.png
│   │   ├── brick_go.png
│   │   ├── brick_link.png
│   │   ├── bricks.png
│   │   ├── briefcase.png
│   │   ├── bug.png
│   │   ├── bug_add.png
│   │   ├── bug_delete.png
│   │   ├── bug_edit.png
│   │   ├── bug_error.png
│   │   ├── bug_go.png
│   │   ├── bug_link.png
│   │   ├── building.png
│   │   ├── building_add.png
│   │   ├── building_delete.png
│   │   ├── building_edit.png
│   │   ├── building_error.png
│   │   ├── building_go.png
│   │   ├── building_key.png
│   │   ├── building_link.png
│   │   ├── bullet_add.png
│   │   ├── bullet_arrow_bottom.png
│   │   ├── bullet_arrow_down.png
│   │   ├── bullet_arrow_top.png
│   │   ├── bullet_arrow_up.png
│   │   ├── bullet_black.png
│   │   ├── bullet_blue.png
│   │   ├── bullet_delete.png
│   │   ├── bullet_disk.png
│   │   ├── bullet_error.png
│   │   ├── bullet_feed.png
│   │   ├── bullet_go.png
│   │   ├── bullet_green.png
│   │   ├── bullet_key.png
│   │   ├── bullet_orange.png
│   │   ├── bullet_picture.png
│   │   ├── bullet_pink.png
│   │   ├── bullet_purple.png
│   │   ├── bullet_red.png
│   │   ├── bullet_star.png
│   │   ├── bullet_toggle_minus.png
│   │   ├── bullet_toggle_plus.png
│   │   ├── bullet_white.png
│   │   ├── bullet_wrench.png
│   │   ├── bullet_yellow.png
│   │   ├── cake.png
│   │   ├── calculator.png
│   │   ├── calculator_add.png
│   │   ├── calculator_delete.png
│   │   ├── calculator_edit.png
│   │   ├── calculator_error.png
│   │   ├── calculator_link.png
│   │   ├── calendar.png
│   │   ├── calendar_add.png
│   │   ├── calendar_delete.png
│   │   ├── calendar_edit.png
│   │   ├── calendar_link.png
│   │   ├── calendar_view_day.png
│   │   ├── calendar_view_month.png
│   │   ├── calendar_view_week.png
│   │   ├── camera.png
│   │   ├── camera_add.png
│   │   ├── camera_delete.png
│   │   ├── camera_edit.png
│   │   ├── camera_error.png
│   │   ├── camera_go.png
│   │   ├── camera_link.png
│   │   ├── camera_small.png
│   │   ├── cancel.png
│   │   ├── car.png
│   │   ├── car_add.png
│   │   ├── car_delete.png
│   │   ├── cart.png
│   │   ├── cart_add.png
│   │   ├── cart_delete.png
│   │   ├── cart_edit.png
│   │   ├── cart_error.png
│   │   ├── cart_go.png
│   │   ├── cart_put.png
│   │   ├── cart_remove.png
│   │   ├── cd.png
│   │   ├── cd_add.png
│   │   ├── cd_burn.png
│   │   ├── cd_delete.png
│   │   ├── cd_edit.png
│   │   ├── cd_eject.png
│   │   ├── cd_go.png
│   │   ├── chart_bar.png
│   │   ├── chart_bar_add.png
│   │   ├── chart_bar_delete.png
│   │   ├── chart_bar_edit.png
│   │   ├── chart_bar_error.png
│   │   ├── chart_bar_link.png
│   │   ├── chart_curve.png
│   │   ├── chart_curve_add.png
│   │   ├── chart_curve_delete.png
│   │   ├── chart_curve_edit.png
│   │   ├── chart_curve_error.png
│   │   ├── chart_curve_go.png
│   │   ├── chart_curve_link.png
│   │   ├── chart_line.png
│   │   ├── chart_line_add.png
│   │   ├── chart_line_delete.png
│   │   ├── chart_line_edit.png
│   │   ├── chart_line_error.png
│   │   ├── chart_line_link.png
│   │   ├── chart_organisation.png
│   │   ├── chart_organisation_add.png
│   │   ├── chart_organisation_delete.png
│   │   ├── chart_pie.png
│   │   ├── chart_pie_add.png
│   │   ├── chart_pie_delete.png
│   │   ├── chart_pie_edit.png
│   │   ├── chart_pie_error.png
│   │   ├── chart_pie_link.png
│   │   ├── clock.png
│   │   ├── clock_add.png
│   │   ├── clock_delete.png
│   │   ├── clock_edit.png
│   │   ├── clock_error.png
│   │   ├── clock_go.png
│   │   ├── clock_link.png
│   │   ├── clock_pause.png
│   │   ├── clock_play.png
│   │   ├── clock_red.png
│   │   ├── clock_stop.png
│   │   ├── cog.png
│   │   ├── cog_add.png
│   │   ├── cog_delete.png
│   │   ├── cog_edit.png
│   │   ├── cog_error.png
│   │   ├── cog_go.png
│   │   ├── coins.png
│   │   ├── coins_add.png
│   │   ├── coins_delete.png
│   │   ├── color_swatch.png
│   │   ├── color_wheel.png
│   │   ├── comment.png
│   │   ├── comment_add.png
│   │   ├── comment_delete.png
│   │   ├── comment_edit.png
│   │   ├── comments.png
│   │   ├── comments_add.png
│   │   ├── comments_delete.png
│   │   ├── compress.png
│   │   ├── computer.png
│   │   ├── computer_add.png
│   │   ├── computer_delete.png
│   │   ├── computer_edit.png
│   │   ├── computer_error.png
│   │   ├── computer_go.png
│   │   ├── computer_key.png
│   │   ├── computer_link.png
│   │   ├── connect.png
│   │   ├── contrast.png
│   │   ├── contrast_decrease.png
│   │   ├── contrast_high.png
│   │   ├── contrast_increase.png
│   │   ├── contrast_low.png
│   │   ├── control_eject.png
│   │   ├── control_eject_blue.png
│   │   ├── control_end.png
│   │   ├── control_end_blue.png
│   │   ├── control_equalizer.png
│   │   ├── control_equalizer_blue.png
│   │   ├── control_fastforward.png
│   │   ├── control_fastforward_blue.png
│   │   ├── control_pause.png
│   │   ├── control_pause_blue.png
│   │   ├── control_play.png
│   │   ├── control_play_blue.png
│   │   ├── control_repeat.png
│   │   ├── control_repeat_blue.png
│   │   ├── control_rewind.png
│   │   ├── control_rewind_blue.png
│   │   ├── control_start.png
│   │   ├── control_start_blue.png
│   │   ├── control_stop.png
│   │   ├── control_stop_blue.png
│   │   ├── controller.png
│   │   ├── controller_add.png
│   │   ├── controller_delete.png
│   │   ├── controller_error.png
│   │   ├── creditcards.png
│   │   ├── cross.png
│   │   ├── css.png
│   │   ├── css_add.png
│   │   ├── css_delete.png
│   │   ├── css_go.png
│   │   ├── css_valid.png
│   │   ├── cup.png
│   │   ├── cup_add.png
│   │   ├── cup_delete.png
│   │   ├── cup_edit.png
│   │   ├── cup_error.png
│   │   ├── cup_go.png
│   │   ├── cup_key.png
│   │   ├── cup_link.png
│   │   ├── cursor.png
│   │   ├── cut.png
│   │   ├── cut_red.png
│   │   ├── database.png
│   │   ├── database_add.png
│   │   ├── database_connect.png
│   │   ├── database_delete.png
│   │   ├── database_edit.png
│   │   ├── database_error.png
│   │   ├── database_gear.png
│   │   ├── database_go.png
│   │   ├── database_key.png
│   │   ├── database_lightning.png
│   │   ├── database_link.png
│   │   ├── database_refresh.png
│   │   ├── database_save.png
│   │   ├── database_table.png
│   │   ├── date.png
│   │   ├── date_add.png
│   │   ├── date_delete.png
│   │   ├── date_edit.png
│   │   ├── date_error.png
│   │   ├── date_go.png
│   │   ├── date_link.png
│   │   ├── date_magnify.png
│   │   ├── date_next.png
│   │   ├── date_previous.png
│   │   ├── delete.png
│   │   ├── disconnect.png
│   │   ├── disk.png
│   │   ├── disk_multiple.png
│   │   ├── door.png
│   │   ├── door_in.png
│   │   ├── door_open.png
│   │   ├── door_out.png
│   │   ├── drink.png
│   │   ├── drink_empty.png
│   │   ├── drive.png
│   │   ├── drive_add.png
│   │   ├── drive_burn.png
│   │   ├── drive_cd.png
│   │   ├── drive_cd_empty.png
│   │   ├── drive_delete.png
│   │   ├── drive_disk.png
│   │   ├── drive_edit.png
│   │   ├── drive_error.png
│   │   ├── drive_go.png
│   │   ├── drive_key.png
│   │   ├── drive_link.png
│   │   ├── drive_magnify.png
│   │   ├── drive_network.png
│   │   ├── drive_rename.png
│   │   ├── drive_user.png
│   │   ├── drive_web.png
│   │   ├── dvd.png
│   │   ├── dvd_add.png
│   │   ├── dvd_delete.png
│   │   ├── dvd_edit.png
│   │   ├── dvd_error.png
│   │   ├── dvd_go.png
│   │   ├── dvd_key.png
│   │   ├── dvd_link.png
│   │   ├── email.png
│   │   ├── email_add.png
│   │   ├── email_attach.png
│   │   ├── email_delete.png
│   │   ├── email_edit.png
│   │   ├── email_error.png
│   │   ├── email_go.png
│   │   ├── email_link.png
│   │   ├── email_open.png
│   │   ├── email_open_image.png
│   │   ├── emoticon_evilgrin.png
│   │   ├── emoticon_grin.png
│   │   ├── emoticon_happy.png
│   │   ├── emoticon_smile.png
│   │   ├── emoticon_surprised.png
│   │   ├── emoticon_tongue.png
│   │   ├── emoticon_unhappy.png
│   │   ├── emoticon_waii.png
│   │   ├── emoticon_wink.png
│   │   ├── error.png
│   │   ├── error_add.png
│   │   ├── error_delete.png
│   │   ├── error_go.png
│   │   ├── exclamation.png
│   │   ├── eye.png
│   │   ├── feed.png
│   │   ├── feed_add.png
│   │   ├── feed_delete.png
│   │   ├── feed_disk.png
│   │   ├── feed_edit.png
│   │   ├── feed_error.png
│   │   ├── feed_go.png
│   │   ├── feed_key.png
│   │   ├── feed_link.png
│   │   ├── feed_magnify.png
│   │   ├── female.png
│   │   ├── film.png
│   │   ├── film_add.png
│   │   ├── film_delete.png
│   │   ├── film_edit.png
│   │   ├── film_error.png
│   │   ├── film_go.png
│   │   ├── film_key.png
│   │   ├── film_link.png
│   │   ├── film_save.png
│   │   ├── find.png
│   │   ├── flag_blue.png
│   │   ├── flag_green.png
│   │   ├── flag_orange.png
│   │   ├── flag_pink.png
│   │   ├── flag_purple.png
│   │   ├── flag_red.png
│   │   ├── flag_yellow.png
│   │   ├── folder.png
│   │   ├── folder_add.png
│   │   ├── folder_bell.png
│   │   ├── folder_brick.png
│   │   ├── folder_bug.png
│   │   ├── folder_camera.png
│   │   ├── folder_database.png
│   │   ├── folder_delete.png
│   │   ├── folder_edit.png
│   │   ├── folder_error.png
│   │   ├── folder_explore.png
│   │   ├── folder_feed.png
│   │   ├── folder_find.png
│   │   ├── folder_go.png
│   │   ├── folder_heart.png
│   │   ├── folder_image.png
│   │   ├── folder_key.png
│   │   ├── folder_lightbulb.png
│   │   ├── folder_link.png
│   │   ├── folder_magnify.png
│   │   ├── folder_page.png
│   │   ├── folder_page_white.png
│   │   ├── folder_palette.png
│   │   ├── folder_picture.png
│   │   ├── folder_star.png
│   │   ├── folder_table.png
│   │   ├── folder_user.png
│   │   ├── folder_wrench.png
│   │   ├── font.png
│   │   ├── font_add.png
│   │   ├── font_delete.png
│   │   ├── font_go.png
│   │   ├── group.png
│   │   ├── group_add.png
│   │   ├── group_delete.png
│   │   ├── group_edit.png
│   │   ├── group_error.png
│   │   ├── group_gear.png
│   │   ├── group_go.png
│   │   ├── group_key.png
│   │   ├── group_link.png
│   │   ├── heart.png
│   │   ├── heart_add.png
│   │   ├── heart_delete.png
│   │   ├── help.png
│   │   ├── hourglass.png
│   │   ├── hourglass_add.png
│   │   ├── hourglass_delete.png
│   │   ├── hourglass_go.png
│   │   ├── hourglass_link.png
│   │   ├── house.png
│   │   ├── house_go.png
│   │   ├── house_link.png
│   │   ├── html.png
│   │   ├── html_add.png
│   │   ├── html_delete.png
│   │   ├── html_go.png
│   │   ├── html_valid.png
│   │   ├── image.png
│   │   ├── image_add.png
│   │   ├── image_delete.png
│   │   ├── image_edit.png
│   │   ├── image_link.png
│   │   ├── images.png
│   │   ├── information.png
│   │   ├── ipod.png
│   │   ├── ipod_cast.png
│   │   ├── ipod_cast_add.png
│   │   ├── ipod_cast_delete.png
│   │   ├── ipod_sound.png
│   │   ├── joystick.png
│   │   ├── joystick_add.png
│   │   ├── joystick_delete.png
│   │   ├── joystick_error.png
│   │   ├── key.png
│   │   ├── key_add.png
│   │   ├── key_delete.png
│   │   ├── key_go.png
│   │   ├── keyboard.png
│   │   ├── keyboard_add.png
│   │   ├── keyboard_delete.png
│   │   ├── keyboard_magnify.png
│   │   ├── layers.png
│   │   ├── layout.png
│   │   ├── layout_add.png
│   │   ├── layout_content.png
│   │   ├── layout_delete.png
│   │   ├── layout_edit.png
│   │   ├── layout_error.png
│   │   ├── layout_header.png
│   │   ├── layout_link.png
│   │   ├── layout_sidebar.png
│   │   ├── lightbulb.png
│   │   ├── lightbulb_add.png
│   │   ├── lightbulb_delete.png
│   │   ├── lightbulb_off.png
│   │   ├── lightning.png
│   │   ├── lightning_add.png
│   │   ├── lightning_delete.png
│   │   ├── lightning_go.png
│   │   ├── link.png
│   │   ├── link_add.png
│   │   ├── link_break.png
│   │   ├── link_delete.png
│   │   ├── link_edit.png
│   │   ├── link_error.png
│   │   ├── link_go.png
│   │   ├── lock.png
│   │   ├── lock_add.png
│   │   ├── lock_break.png
│   │   ├── lock_delete.png
│   │   ├── lock_edit.png
│   │   ├── lock_go.png
│   │   ├── lock_open.png
│   │   ├── lorry.png
│   │   ├── lorry_add.png
│   │   ├── lorry_delete.png
│   │   ├── lorry_error.png
│   │   ├── lorry_flatbed.png
│   │   ├── lorry_go.png
│   │   ├── lorry_link.png
│   │   ├── magifier_zoom_out.png
│   │   ├── magnifier.png
│   │   ├── magnifier_zoom_in.png
│   │   ├── male.png
│   │   ├── map.png
│   │   ├── map_add.png
│   │   ├── map_delete.png
│   │   ├── map_edit.png
│   │   ├── map_go.png
│   │   ├── map_magnify.png
│   │   ├── medal_bronze_1.png
│   │   ├── medal_bronze_2.png
│   │   ├── medal_bronze_3.png
│   │   ├── medal_bronze_add.png
│   │   ├── medal_bronze_delete.png
│   │   ├── medal_gold_1.png
│   │   ├── medal_gold_2.png
│   │   ├── medal_gold_3.png
│   │   ├── medal_gold_add.png
│   │   ├── medal_gold_delete.png
│   │   ├── medal_silver_1.png
│   │   ├── medal_silver_2.png
│   │   ├── medal_silver_3.png
│   │   ├── medal_silver_add.png
│   │   ├── medal_silver_delete.png
│   │   ├── money.png
│   │   ├── money_add.png
│   │   ├── money_delete.png
│   │   ├── money_dollar.png
│   │   ├── money_euro.png
│   │   ├── money_pound.png
│   │   ├── money_yen.png
│   │   ├── monitor.png
│   │   ├── monitor_add.png
│   │   ├── monitor_delete.png
│   │   ├── monitor_edit.png
│   │   ├── monitor_error.png
│   │   ├── monitor_go.png
│   │   ├── monitor_lightning.png
│   │   ├── monitor_link.png
│   │   ├── mouse.png
│   │   ├── mouse_add.png
│   │   ├── mouse_delete.png
│   │   ├── mouse_error.png
│   │   ├── music.png
│   │   ├── new.png
│   │   ├── newspaper.png
│   │   ├── newspaper_add.png
│   │   ├── newspaper_delete.png
│   │   ├── newspaper_go.png
│   │   ├── newspaper_link.png
│   │   ├── note.png
│   │   ├── note_add.png
│   │   ├── note_delete.png
│   │   ├── note_edit.png
│   │   ├── note_error.png
│   │   ├── note_go.png
│   │   ├── overlays.png
│   │   ├── package.png
│   │   ├── package_add.png
│   │   ├── package_delete.png
│   │   ├── package_go.png
│   │   ├── package_green.png
│   │   ├── package_link.png
│   │   ├── page.png
│   │   ├── page_add.png
│   │   ├── page_attach.png
│   │   ├── page_code.png
│   │   ├── page_copy.png
│   │   ├── page_delete.png
│   │   ├── page_edit.png
│   │   ├── page_error.png
│   │   ├── page_excel.png
│   │   ├── page_find.png
│   │   ├── page_gear.png
│   │   ├── page_go.png
│   │   ├── page_green.png
│   │   ├── page_key.png
│   │   ├── page_lightning.png
│   │   ├── page_link.png
│   │   ├── page_paintbrush.png
│   │   ├── page_paste.png
│   │   ├── page_red.png
│   │   ├── page_refresh.png
│   │   ├── page_save.png
│   │   ├── page_white.png
│   │   ├── page_white_acrobat.png
│   │   ├── page_white_actionscript.png
│   │   ├── page_white_add.png
│   │   ├── page_white_c.png
│   │   ├── page_white_camera.png
│   │   ├── page_white_cd.png
│   │   ├── page_white_code.png
│   │   ├── page_white_code_red.png
│   │   ├── page_white_coldfusion.png
│   │   ├── page_white_compressed.png
│   │   ├── page_white_copy.png
│   │   ├── page_white_cplusplus.png
│   │   ├── page_white_csharp.png
│   │   ├── page_white_cup.png
│   │   ├── page_white_database.png
│   │   ├── page_white_delete.png
│   │   ├── page_white_dvd.png
│   │   ├── page_white_edit.png
│   │   ├── page_white_error.png
│   │   ├── page_white_excel.png
│   │   ├── page_white_find.png
│   │   ├── page_white_flash.png
│   │   ├── page_white_freehand.png
│   │   ├── page_white_gear.png
│   │   ├── page_white_get.png
│   │   ├── page_white_go.png
│   │   ├── page_white_h.png
│   │   ├── page_white_horizontal.png
│   │   ├── page_white_key.png
│   │   ├── page_white_lightning.png
│   │   ├── page_white_link.png
│   │   ├── page_white_magnify.png
│   │   ├── page_white_medal.png
│   │   ├── page_white_office.png
│   │   ├── page_white_paint.png
│   │   ├── page_white_paintbrush.png
│   │   ├── page_white_paste.png
│   │   ├── page_white_php.png
│   │   ├── page_white_picture.png
│   │   ├── page_white_powerpoint.png
│   │   ├── page_white_put.png
│   │   ├── page_white_ruby.png
│   │   ├── page_white_stack.png
│   │   ├── page_white_star.png
│   │   ├── page_white_swoosh.png
│   │   ├── page_white_text.png
│   │   ├── page_white_text_width.png
│   │   ├── page_white_tux.png
│   │   ├── page_white_vector.png
│   │   ├── page_white_visualstudio.png
│   │   ├── page_white_width.png
│   │   ├── page_white_word.png
│   │   ├── page_white_world.png
│   │   ├── page_white_wrench.png
│   │   ├── page_white_zip.png
│   │   ├── page_word.png
│   │   ├── page_world.png
│   │   ├── paintbrush.png
│   │   ├── paintcan.png
│   │   ├── palette.png
│   │   ├── paste_plain.png
│   │   ├── paste_word.png
│   │   ├── pencil.png
│   │   ├── pencil_add.png
│   │   ├── pencil_delete.png
│   │   ├── pencil_go.png
│   │   ├── phone.png
│   │   ├── phone_add.png
│   │   ├── phone_delete.png
│   │   ├── phone_sound.png
│   │   ├── photo.png
│   │   ├── photo_add.png
│   │   ├── photo_delete.png
│   │   ├── photo_link.png
│   │   ├── photos.png
│   │   ├── picture.png
│   │   ├── picture_add.png
│   │   ├── picture_delete.png
│   │   ├── picture_edit.png
│   │   ├── picture_empty.png
│   │   ├── picture_error.png
│   │   ├── picture_go.png
│   │   ├── picture_key.png
│   │   ├── picture_link.png
│   │   ├── picture_save.png
│   │   ├── pictures.png
│   │   ├── pilcrow.png
│   │   ├── pill.png
│   │   ├── pill_add.png
│   │   ├── pill_delete.png
│   │   ├── pill_go.png
│   │   ├── plugin.png
│   │   ├── plugin_add.png
│   │   ├── plugin_delete.png
│   │   ├── plugin_disabled.png
│   │   ├── plugin_edit.png
│   │   ├── plugin_error.png
│   │   ├── plugin_go.png
│   │   ├── plugin_link.png
│   │   ├── printer.png
│   │   ├── printer_add.png
│   │   ├── printer_delete.png
│   │   ├── printer_empty.png
│   │   ├── printer_error.png
│   │   ├── rainbow.png
│   │   ├── report.png
│   │   ├── report_add.png
│   │   ├── report_delete.png
│   │   ├── report_disk.png
│   │   ├── report_edit.png
│   │   ├── report_go.png
│   │   ├── report_key.png
│   │   ├── report_link.png
│   │   ├── report_magnify.png
│   │   ├── report_picture.png
│   │   ├── report_user.png
│   │   ├── report_word.png
│   │   ├── resultset_first.png
│   │   ├── resultset_last.png
│   │   ├── resultset_next.png
│   │   ├── resultset_previous.png
│   │   ├── rosette.png
│   │   ├── rss.png
│   │   ├── rss_add.png
│   │   ├── rss_delete.png
│   │   ├── rss_go.png
│   │   ├── rss_valid.png
│   │   ├── ruby.png
│   │   ├── ruby_add.png
│   │   ├── ruby_delete.png
│   │   ├── ruby_gear.png
│   │   ├── ruby_get.png
│   │   ├── ruby_go.png
│   │   ├── ruby_key.png
│   │   ├── ruby_link.png
│   │   ├── ruby_put.png
│   │   ├── script.png
│   │   ├── script_add.png
│   │   ├── script_code.png
│   │   ├── script_code_red.png
│   │   ├── script_delete.png
│   │   ├── script_edit.png
│   │   ├── script_error.png
│   │   ├── script_gear.png
│   │   ├── script_go.png
│   │   ├── script_key.png
│   │   ├── script_lightning.png
│   │   ├── script_link.png
│   │   ├── script_palette.png
│   │   ├── script_save.png
│   │   ├── server.png
│   │   ├── server_add.png
│   │   ├── server_chart.png
│   │   ├── server_compressed.png
│   │   ├── server_connect.png
│   │   ├── server_database.png
│   │   ├── server_delete.png
│   │   ├── server_edit.png
│   │   ├── server_error.png
│   │   ├── server_go.png
│   │   ├── server_key.png
│   │   ├── server_lightning.png
│   │   ├── server_link.png
│   │   ├── server_uncompressed.png
│   │   ├── shading.png
│   │   ├── shape_align_bottom.png
│   │   ├── shape_align_center.png
│   │   ├── shape_align_left.png
│   │   ├── shape_align_middle.png
│   │   ├── shape_align_right.png
│   │   ├── shape_align_top.png
│   │   ├── shape_flip_horizontal.png
│   │   ├── shape_flip_vertical.png
│   │   ├── shape_group.png
│   │   ├── shape_handles.png
│   │   ├── shape_move_back.png
│   │   ├── shape_move_backwards.png
│   │   ├── shape_move_forwards.png
│   │   ├── shape_move_front.png
│   │   ├── shape_rotate_anticlockwise.png
│   │   ├── shape_rotate_clockwise.png
│   │   ├── shape_square.png
│   │   ├── shape_square_add.png
│   │   ├── shape_square_delete.png
│   │   ├── shape_square_edit.png
│   │   ├── shape_square_error.png
│   │   ├── shape_square_go.png
│   │   ├── shape_square_key.png
│   │   ├── shape_square_link.png
│   │   ├── shape_ungroup.png
│   │   ├── shield.png
│   │   ├── shield_add.png
│   │   ├── shield_delete.png
│   │   ├── shield_go.png
│   │   ├── sitemap.png
│   │   ├── sitemap_color.png
│   │   ├── sound.png
│   │   ├── sound_add.png
│   │   ├── sound_delete.png
│   │   ├── sound_low.png
│   │   ├── sound_mute.png
│   │   ├── sound_none.png
│   │   ├── spellcheck.png
│   │   ├── sport_8ball.png
│   │   ├── sport_basketball.png
│   │   ├── sport_football.png
│   │   ├── sport_golf.png
│   │   ├── sport_raquet.png
│   │   ├── sport_shuttlecock.png
│   │   ├── sport_soccer.png
│   │   ├── sport_tennis.png
│   │   ├── star.png
│   │   ├── status_away.png
│   │   ├── status_busy.png
│   │   ├── status_offline.png
│   │   ├── status_online.png
│   │   ├── stop.png
│   │   ├── style.png
│   │   ├── style_add.png
│   │   ├── style_delete.png
│   │   ├── style_edit.png
│   │   ├── style_go.png
│   │   ├── sum.png
│   │   ├── tab.png
│   │   ├── tab_add.png
│   │   ├── tab_delete.png
│   │   ├── tab_edit.png
│   │   ├── tab_go.png
│   │   ├── table.png
│   │   ├── table_add.png
│   │   ├── table_delete.png
│   │   ├── table_edit.png
│   │   ├── table_error.png
│   │   ├── table_gear.png
│   │   ├── table_go.png
│   │   ├── table_key.png
│   │   ├── table_lightning.png
│   │   ├── table_link.png
│   │   ├── table_multiple.png
│   │   ├── table_refresh.png
│   │   ├── table_relationship.png
│   │   ├── table_row_delete.png
│   │   ├── table_row_insert.png
│   │   ├── table_save.png
│   │   ├── table_sort.png
│   │   ├── tag.png
│   │   ├── tag_blue.png
│   │   ├── tag_blue_add.png
│   │   ├── tag_blue_delete.png
│   │   ├── tag_blue_edit.png
│   │   ├── tag_green.png
│   │   ├── tag_orange.png
│   │   ├── tag_pink.png
│   │   ├── tag_purple.png
│   │   ├── tag_red.png
│   │   ├── tag_yellow.png
│   │   ├── telephone.png
│   │   ├── telephone_add.png
│   │   ├── telephone_delete.png
│   │   ├── telephone_edit.png
│   │   ├── telephone_error.png
│   │   ├── telephone_go.png
│   │   ├── telephone_key.png
│   │   ├── telephone_link.png
│   │   ├── television.png
│   │   ├── television_add.png
│   │   ├── television_delete.png
│   │   ├── text_align_center.png
│   │   ├── text_align_justify.png
│   │   ├── text_align_left.png
│   │   ├── text_align_right.png
│   │   ├── text_allcaps.png
│   │   ├── text_bold.png
│   │   ├── text_columns.png
│   │   ├── text_dropcaps.png
│   │   ├── text_heading_1.png
│   │   ├── text_heading_2.png
│   │   ├── text_heading_3.png
│   │   ├── text_heading_4.png
│   │   ├── text_heading_5.png
│   │   ├── text_heading_6.png
│   │   ├── text_horizontalrule.png
│   │   ├── text_indent.png
│   │   ├── text_indent_remove.png
│   │   ├── text_italic.png
│   │   ├── text_kerning.png
│   │   ├── text_letter_omega.png
│   │   ├── text_letterspacing.png
│   │   ├── text_linespacing.png
│   │   ├── text_list_bullets.png
│   │   ├── text_list_numbers.png
│   │   ├── text_lowercase.png
│   │   ├── text_padding_bottom.png
│   │   ├── text_padding_left.png
│   │   ├── text_padding_right.png
│   │   ├── text_padding_top.png
│   │   ├── text_replace.png
│   │   ├── text_signature.png
│   │   ├── text_smallcaps.png
│   │   ├── text_strikethrough.png
│   │   ├── text_subscript.png
│   │   ├── text_superscript.png
│   │   ├── text_underline.png
│   │   ├── text_uppercase.png
│   │   ├── textfield.png
│   │   ├── textfield_add.png
│   │   ├── textfield_delete.png
│   │   ├── textfield_key.png
│   │   ├── textfield_rename.png
│   │   ├── thumb_down.png
│   │   ├── thumb_up.png
│   │   ├── tick.png
│   │   ├── time.png
│   │   ├── time_add.png
│   │   ├── time_delete.png
│   │   ├── time_go.png
│   │   ├── timeline_marker.png
│   │   ├── transmit.png
│   │   ├── transmit_add.png
│   │   ├── transmit_blue.png
│   │   ├── transmit_delete.png
│   │   ├── transmit_edit.png
│   │   ├── transmit_error.png
│   │   ├── transmit_go.png
│   │   ├── tux.png
│   │   ├── user.png
│   │   ├── user_add.png
│   │   ├── user_comment.png
│   │   ├── user_delete.png
│   │   ├── user_edit.png
│   │   ├── user_female.png
│   │   ├── user_go.png
│   │   ├── user_gray.png
│   │   ├── user_green.png
│   │   ├── user_orange.png
│   │   ├── user_red.png
│   │   ├── user_suit.png
│   │   ├── vcard.png
│   │   ├── vcard_add.png
│   │   ├── vcard_delete.png
│   │   ├── vcard_edit.png
│   │   ├── vector.png
│   │   ├── vector_add.png
│   │   ├── vector_delete.png
│   │   ├── wand.png
│   │   ├── weather_clouds.png
│   │   ├── weather_cloudy.png
│   │   ├── weather_lightning.png
│   │   ├── weather_rain.png
│   │   ├── weather_snow.png
│   │   ├── weather_sun.png
│   │   ├── webcam.png
│   │   ├── webcam_add.png
│   │   ├── webcam_delete.png
│   │   ├── webcam_error.png
│   │   ├── world.png
│   │   ├── world_add.png
│   │   ├── world_delete.png
│   │   ├── world_edit.png
│   │   ├── world_go.png
│   │   ├── world_link.png
│   │   ├── wrench.png
│   │   ├── wrench_orange.png
│   │   ├── xhtml.png
│   │   ├── xhtml_add.png
│   │   ├── xhtml_delete.png
│   │   ├── xhtml_go.png
│   │   ├── xhtml_valid.png
│   │   ├── zoom.png
│   │   ├── zoom_in.png
│   │   └── zoom_out.png
│   ├── logo
│   │   └── ozgurozbek
│   │       ├── pince_big.ai
│   │       ├── pince_big_cyan.png
│   │       ├── pince_big_gray.png
│   │       ├── pince_big_green.png
│   │       ├── pince_big_neon_blue.png
│   │       ├── pince_big_neon_orange.png
│   │       ├── pince_big_orange.png
│   │       ├── pince_big_red.png
│   │       ├── pince_big_tan.png
│   │       ├── pince_big_transparent.png
│   │       ├── pince_big_white.png
│   │       ├── pince_big_yellow.png
│   │       ├── pince_small.ai
│   │       ├── pince_small_carved_cyan.png
│   │       ├── pince_small_carved_orange.png
│   │       ├── pince_small_cyan.png
│   │       ├── pince_small_gray.png
│   │       ├── pince_small_green.png
│   │       ├── pince_small_orange.png
│   │       ├── pince_small_red.png
│   │       ├── pince_small_tan.png
│   │       ├── pince_small_transparent.png
│   │       ├── pince_small_white.png
│   │       └── pince_small_yellow.png
│   └── screenshots
│       ├── pince.png
│       ├── pince1.png
│       ├── pince2.png
│       ├── pince3.png
│       ├── pince4.png
│       ├── pince5.png
│       ├── pince6.png
│       ├── pince7.png
│       ├── pince8.png
│       └── pince9.png
├── run_tests.py
├── scanmem
└── tests
    ├── GDB_Engine_tests.py
    ├── GuiUtils_tests.py
    ├── SysUtils_tests.py
    ├── __init__.py
    └── common_defs.py

```

`AUTHORS`:

```
Copyright (C) 2016-2020 Korcan Karaokçu <korcankaraokcu@gmail.com>
Copyright (C) 2016-2020 Çağrı Ulaş <cagriulas@gmail.com>
Copyright (C) 2016-2020 Jakob Kreuze <jakob@memeware.net>
Copyright (C) 2020 Viktor Horsmanheimo <https://github.com/vikke1234>
Copyright (C) 2018 user202729
Copyright (C) 2018 Özgür Özbek <ozgurozbek1@yandex.com> [media/logo/ozgurozbek]

Copyright (C) Mark James 2005, 2006  Silk Icons <http://www.famfamfam.com> [media/icons/]

Silk Icons are licensed under Creative Commons Attribution 3.0
Unported License. See COPYING.CC-BY for conditions.

```

`COPYING`:

```
PINCE is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    {one line to give the program's name and a brief idea of what it does.}
    Copyright (C) {year}  {name of author}

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    {project}  Copyright (C) {year}  {fullname}
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

```

`COPYING.CC-BY`:

```CC-BY
Creative Commons Legal Code

Attribution 3.0 Unported

    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
    LEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN
    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
    INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
    REGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR
    DAMAGES RESULTING FROM ITS USE.

License

THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE
COMMONS PUBLIC LICENSE ("CCPL" OR "LICENSE"). THE WORK IS PROTECTED BY
COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS
AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.

BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE
TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY
BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS
CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND
CONDITIONS.

1. Definitions

 a. "Adaptation" means a work based upon the Work, or upon the Work and
    other pre-existing works, such as a translation, adaptation,
    derivative work, arrangement of music or other alterations of a
    literary or artistic work, or phonogram or performance and includes
    cinematographic adaptations or any other form in which the Work may be
    recast, transformed, or adapted including in any form recognizably
    derived from the original, except that a work that constitutes a
    Collection will not be considered an Adaptation for the purpose of
    this License. For the avoidance of doubt, where the Work is a musical
    work, performance or phonogram, the synchronization of the Work in
    timed-relation with a moving image ("synching") will be considered an
    Adaptation for the purpose of this License.
 b. "Collection" means a collection of literary or artistic works, such as
    encyclopedias and anthologies, or performances, phonograms or
    broadcasts, or other works or subject matter other than works listed
    in Section 1(f) below, which, by reason of the selection and
    arrangement of their contents, constitute intellectual creations, in
    which the Work is included in its entirety in unmodified form along
    with one or more other contributions, each constituting separate and
    independent works in themselves, which together are assembled into a
    collective whole. A work that constitutes a Collection will not be
    considered an Adaptation (as defined above) for the purposes of this
    License.
 c. "Distribute" means to make available to the public the original and
    copies of the Work or Adaptation, as appropriate, through sale or
    other transfer of ownership.
 d. "Licensor" means the individual, individuals, entity or entities that
    offer(s) the Work under the terms of this License.
 e. "Original Author" means, in the case of a literary or artistic work,
    the individual, individuals, entity or entities who created the Work
    or if no individual or entity can be identified, the publisher; and in
    addition (i) in the case of a performance the actors, singers,
    musicians, dancers, and other persons who act, sing, deliver, declaim,
    play in, interpret or otherwise perform literary or artistic works or
    expressions of folklore; (ii) in the case of a phonogram the producer
    being the person or legal entity who first fixes the sounds of a
    performance or other sounds; and, (iii) in the case of broadcasts, the
    organization that transmits the broadcast.
 f. "Work" means the literary and/or artistic work offered under the terms
    of this License including without limitation any production in the
    literary, scientific and artistic domain, whatever may be the mode or
    form of its expression including digital form, such as a book,
    pamphlet and other writing; a lecture, address, sermon or other work
    of the same nature; a dramatic or dramatico-musical work; a
    choreographic work or entertainment in dumb show; a musical
    composition with or without words; a cinematographic work to which are
    assimilated works expressed by a process analogous to cinematography;
    a work of drawing, painting, architecture, sculpture, engraving or
    lithography; a photographic work to which are assimilated works
    expressed by a process analogous to photography; a work of applied
    art; an illustration, map, plan, sketch or three-dimensional work
    relative to geography, topography, architecture or science; a
    performance; a broadcast; a phonogram; a compilation of data to the
    extent it is protected as a copyrightable work; or a work performed by
    a variety or circus performer to the extent it is not otherwise
    considered a literary or artistic work.
 g. "You" means an individual or entity exercising rights under this
    License who has not previously violated the terms of this License with
    respect to the Work, or who has received express permission from the
    Licensor to exercise rights under this License despite a previous
    violation.
 h. "Publicly Perform" means to perform public recitations of the Work and
    to communicate to the public those public recitations, by any means or
    process, including by wire or wireless means or public digital
    performances; to make available to the public Works in such a way that
    members of the public may access these Works from a place and at a
    place individually chosen by them; to perform the Work to the public
    by any means or process and the communication to the public of the
    performances of the Work, including by public digital performance; to
    broadcast and rebroadcast the Work by any means including signs,
    sounds or images.
 i. "Reproduce" means to make copies of the Work by any means including
    without limitation by sound or visual recordings and the right of
    fixation and reproducing fixations of the Work, including storage of a
    protected performance or phonogram in digital form or other electronic
    medium.

2. Fair Dealing Rights. Nothing in this License is intended to reduce,
limit, or restrict any uses free from copyright or rights arising from
limitations or exceptions that are provided for in connection with the
copyright protection under copyright law or other applicable laws.

3. License Grant. Subject to the terms and conditions of this License,
Licensor hereby grants You a worldwide, royalty-free, non-exclusive,
perpetual (for the duration of the applicable copyright) license to
exercise the rights in the Work as stated below:

 a. to Reproduce the Work, to incorporate the Work into one or more
    Collections, and to Reproduce the Work as incorporated in the
    Collections;
 b. to create and Reproduce Adaptations provided that any such Adaptation,
    including any translation in any medium, takes reasonable steps to
    clearly label, demarcate or otherwise identify that changes were made
    to the original Work. For example, a translation could be marked "The
    original work was translated from English to Spanish," or a
    modification could indicate "The original work has been modified.";
 c. to Distribute and Publicly Perform the Work including as incorporated
    in Collections; and,
 d. to Distribute and Publicly Perform Adaptations.
 e. For the avoidance of doubt:

     i. Non-waivable Compulsory License Schemes. In those jurisdictions in
        which the right to collect royalties through any statutory or
        compulsory licensing scheme cannot be waived, the Licensor
        reserves the exclusive right to collect such royalties for any
        exercise by You of the rights granted under this License;
    ii. Waivable Compulsory License Schemes. In those jurisdictions in
        which the right to collect royalties through any statutory or
        compulsory licensing scheme can be waived, the Licensor waives the
        exclusive right to collect such royalties for any exercise by You
        of the rights granted under this License; and,
   iii. Voluntary License Schemes. The Licensor waives the right to
        collect royalties, whether individually or, in the event that the
        Licensor is a member of a collecting society that administers
        voluntary licensing schemes, via that society, from any exercise
        by You of the rights granted under this License.

The above rights may be exercised in all media and formats whether now
known or hereafter devised. The above rights include the right to make
such modifications as are technically necessary to exercise the rights in
other media and formats. Subject to Section 8(f), all rights not expressly
granted by Licensor are hereby reserved.

4. Restrictions. The license granted in Section 3 above is expressly made
subject to and limited by the following restrictions:

 a. You may Distribute or Publicly Perform the Work only under the terms
    of this License. You must include a copy of, or the Uniform Resource
    Identifier (URI) for, this License with every copy of the Work You
    Distribute or Publicly Perform. You may not offer or impose any terms
    on the Work that restrict the terms of this License or the ability of
    the recipient of the Work to exercise the rights granted to that
    recipient under the terms of the License. You may not sublicense the
    Work. You must keep intact all notices that refer to this License and
    to the disclaimer of warranties with every copy of the Work You
    Distribute or Publicly Perform. When You Distribute or Publicly
    Perform the Work, You may not impose any effective technological
    measures on the Work that restrict the ability of a recipient of the
    Work from You to exercise the rights granted to that recipient under
    the terms of the License. This Section 4(a) applies to the Work as
    incorporated in a Collection, but this does not require the Collection
    apart from the Work itself to be made subject to the terms of this
    License. If You create a Collection, upon notice from any Licensor You
    must, to the extent practicable, remove from the Collection any credit
    as required by Section 4(b), as requested. If You create an
    Adaptation, upon notice from any Licensor You must, to the extent
    practicable, remove from the Adaptation any credit as required by
    Section 4(b), as requested.
 b. If You Distribute, or Publicly Perform the Work or any Adaptations or
    Collections, You must, unless a request has been made pursuant to
    Section 4(a), keep intact all copyright notices for the Work and
    provide, reasonable to the medium or means You are utilizing: (i) the
    name of the Original Author (or pseudonym, if applicable) if supplied,
    and/or if the Original Author and/or Licensor designate another party
    or parties (e.g., a sponsor institute, publishing entity, journal) for
    attribution ("Attribution Parties") in Licensor's copyright notice,
    terms of service or by other reasonable means, the name of such party
    or parties; (ii) the title of the Work if supplied; (iii) to the
    extent reasonably practicable, the URI, if any, that Licensor
    specifies to be associated with the Work, unless such URI does not
    refer to the copyright notice or licensing information for the Work;
    and (iv) , consistent with Section 3(b), in the case of an Adaptation,
    a credit identifying the use of the Work in the Adaptation (e.g.,
    "French translation of the Work by Original Author," or "Screenplay
    based on original Work by Original Author"). The credit required by
    this Section 4 (b) may be implemented in any reasonable manner;
    provided, however, that in the case of a Adaptation or Collection, at
    a minimum such credit will appear, if a credit for all contributing
    authors of the Adaptation or Collection appears, then as part of these
    credits and in a manner at least as prominent as the credits for the
    other contributing authors. For the avoidance of doubt, You may only
    use the credit required by this Section for the purpose of attribution
    in the manner set out above and, by exercising Your rights under this
    License, You may not implicitly or explicitly assert or imply any
    connection with, sponsorship or endorsement by the Original Author,
    Licensor and/or Attribution Parties, as appropriate, of You or Your
    use of the Work, without the separate, express prior written
    permission of the Original Author, Licensor and/or Attribution
    Parties.
 c. Except as otherwise agreed in writing by the Licensor or as may be
    otherwise permitted by applicable law, if You Reproduce, Distribute or
    Publicly Perform the Work either by itself or as part of any
    Adaptations or Collections, You must not distort, mutilate, modify or
    take other derogatory action in relation to the Work which would be
    prejudicial to the Original Author's honor or reputation. Licensor
    agrees that in those jurisdictions (e.g. Japan), in which any exercise
    of the right granted in Section 3(b) of this License (the right to
    make Adaptations) would be deemed to be a distortion, mutilation,
    modification or other derogatory action prejudicial to the Original
    Author's honor and reputation, the Licensor will waive or not assert,
    as appropriate, this Section, to the fullest extent permitted by the
    applicable national law, to enable You to reasonably exercise Your
    right under Section 3(b) of this License (right to make Adaptations)
    but not otherwise.

5. Representations, Warranties and Disclaimer

UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR
OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY
KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE,
INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY,
FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF
LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS,
WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION
OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.

6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE
LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR
ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES
ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

7. Termination

 a. This License and the rights granted hereunder will terminate
    automatically upon any breach by You of the terms of this License.
    Individuals or entities who have received Adaptations or Collections
    from You under this License, however, will not have their licenses
    terminated provided such individuals or entities remain in full
    compliance with those licenses. Sections 1, 2, 5, 6, 7, and 8 will
    survive any termination of this License.
 b. Subject to the above terms and conditions, the license granted here is
    perpetual (for the duration of the applicable copyright in the Work).
    Notwithstanding the above, Licensor reserves the right to release the
    Work under different license terms or to stop distributing the Work at
    any time; provided, however that any such election will not serve to
    withdraw this License (or any other license that has been, or is
    required to be, granted under the terms of this License), and this
    License will continue in full force and effect unless terminated as
    stated above.

8. Miscellaneous

 a. Each time You Distribute or Publicly Perform the Work or a Collection,
    the Licensor offers to the recipient a license to the Work on the same
    terms and conditions as the license granted to You under this License.
 b. Each time You Distribute or Publicly Perform an Adaptation, Licensor
    offers to the recipient a license to the original Work on the same
    terms and conditions as the license granted to You under this License.
 c. If any provision of this License is invalid or unenforceable under
    applicable law, it shall not affect the validity or enforceability of
    the remainder of the terms of this License, and without further action
    by the parties to this agreement, such provision shall be reformed to
    the minimum extent necessary to make such provision valid and
    enforceable.
 d. No term or provision of this License shall be deemed waived and no
    breach consented to unless such waiver or consent shall be in writing
    and signed by the party to be charged with such waiver or consent.
 e. This License constitutes the entire agreement between the parties with
    respect to the Work licensed here. There are no understandings,
    agreements or representations with respect to the Work not specified
    here. Licensor shall not be bound by any additional provisions that
    may appear in any communication from You. This License may not be
    modified without the mutual written agreement of the Licensor and You.
 f. The rights granted under, and the subject matter referenced, in this
    License were drafted utilizing the terminology of the Berne Convention
    for the Protection of Literary and Artistic Works (as amended on
    September 28, 1979), the Rome Convention of 1961, the WIPO Copyright
    Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996
    and the Universal Copyright Convention (as revised on July 24, 1971).
    These rights and subject matter take effect in the relevant
    jurisdiction in which the License terms are sought to be enforced
    according to the corresponding provisions of the implementation of
    those treaty provisions in the applicable national law. If the
    standard suite of rights granted under applicable copyright law
    includes additional rights not granted under this License, such
    additional rights are deemed to be included in the License; this
    License is not intended to restrict the license of any rights under
    applicable law.


Creative Commons Notice

    Creative Commons is not a party to this License, and makes no warranty
    whatsoever in connection with the Work. Creative Commons will not be
    liable to You or any party on any legal theory for any damages
    whatsoever, including without limitation any general, special,
    incidental or consequential damages arising in connection to this
    license. Notwithstanding the foregoing two (2) sentences, if Creative
    Commons has expressly identified itself as the Licensor hereunder, it
    shall have all rights and obligations of Licensor.

    Except for the limited purpose of indicating to the public that the
    Work is licensed under the CCPL, Creative Commons does not authorize
    the use by either party of the trademark "Creative Commons" or any
    related trademark or logo of Creative Commons without the prior
    written consent of Creative Commons. Any permitted use will be in
    compliance with Creative Commons' then-current trademark usage
    guidelines, as may be published on its website or otherwise made
    available upon request from time to time. For the avoidance of doubt,
    this trademark restriction does not form part of this License.

    Creative Commons may be contacted at https://creativecommons.org/.

```

`GUI/AboutWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'aboutwidget.ui'
#
# Created: Wed Jun 29 16:34:26 2016
#      by: PyQt5 UI code generator 5.2.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_TabWidget(object):
    def setupUi(self, TabWidget):
        TabWidget.setObjectName("TabWidget")
        TabWidget.resize(721, 659)
        self.tab_Contributors = QtWidgets.QWidget()
        self.tab_Contributors.setObjectName("tab_Contributors")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.tab_Contributors)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.textBrowser_Contributors = QtWidgets.QTextBrowser(self.tab_Contributors)
        self.textBrowser_Contributors.setObjectName("textBrowser_Contributors")
        self.gridLayout_2.addWidget(self.textBrowser_Contributors, 0, 0, 1, 1)
        TabWidget.addTab(self.tab_Contributors, "")
        self.tab_License = QtWidgets.QWidget()
        self.tab_License.setObjectName("tab_License")
        self.gridLayout = QtWidgets.QGridLayout(self.tab_License)
        self.gridLayout.setObjectName("gridLayout")
        self.textBrowser_License = QtWidgets.QTextBrowser(self.tab_License)
        self.textBrowser_License.setObjectName("textBrowser_License")
        self.gridLayout.addWidget(self.textBrowser_License, 0, 0, 1, 1)
        TabWidget.addTab(self.tab_License, "")

        self.retranslateUi(TabWidget)
        TabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(TabWidget)

    def retranslateUi(self, TabWidget):
        _translate = QtCore.QCoreApplication.translate
        TabWidget.setWindowTitle(_translate("TabWidget", "About PINCE"))
        TabWidget.setTabText(TabWidget.indexOf(self.tab_Contributors), _translate("TabWidget", "Contributors"))
        TabWidget.setTabText(TabWidget.indexOf(self.tab_License), _translate("TabWidget", "License"))


```

`GUI/AboutWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TabWidget</class>
 <widget class="QTabWidget" name="TabWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>721</width>
    <height>659</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>About PINCE</string>
  </property>
  <property name="currentIndex">
   <number>0</number>
  </property>
  <widget class="QWidget" name="tab_Contributors">
   <attribute name="title">
    <string>Contributors</string>
   </attribute>
   <layout class="QGridLayout" name="gridLayout_2">
    <item row="0" column="0">
     <widget class="QTextBrowser" name="textBrowser_Contributors"/>
    </item>
   </layout>
  </widget>
  <widget class="QWidget" name="tab_License">
   <attribute name="title">
    <string>License</string>
   </attribute>
   <layout class="QGridLayout" name="gridLayout">
    <item row="0" column="0">
     <widget class="QTextBrowser" name="textBrowser_License"/>
    </item>
   </layout>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/AddAddressManuallyDialog.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'AddAddressManuallyDialog.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(232, 248)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(Dialog.sizePolicy().hasHeightForWidth())
        Dialog.setSizePolicy(sizePolicy)
        Dialog.setMaximumSize(QtCore.QSize(16777215, 248))
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.buttonBox = QtWidgets.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 3, 0, 1, 1)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label = QtWidgets.QLabel(Dialog)
        self.label.setObjectName("label")
        self.verticalLayout_2.addWidget(self.label)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.lineEdit_address = QtWidgets.QLineEdit(Dialog)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lineEdit_address.sizePolicy().hasHeightForWidth())
        self.lineEdit_address.setSizePolicy(sizePolicy)
        self.lineEdit_address.setMinimumSize(QtCore.QSize(100, 0))
        self.lineEdit_address.setText("")
        self.lineEdit_address.setObjectName("lineEdit_address")
        self.horizontalLayout.addWidget(self.lineEdit_address)
        self.label_2 = QtWidgets.QLabel(Dialog)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout.addWidget(self.label_2)
        self.label_valueofaddress = QtWidgets.QLabel(Dialog)
        self.label_valueofaddress.setText("")
        self.label_valueofaddress.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_valueofaddress.setObjectName("label_valueofaddress")
        self.horizontalLayout.addWidget(self.label_valueofaddress)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        self.gridLayout.addLayout(self.verticalLayout_2, 0, 0, 1, 1)
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label_4 = QtWidgets.QLabel(Dialog)
        self.label_4.setObjectName("label_4")
        self.verticalLayout.addWidget(self.label_4)
        self.lineEdit_description = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_description.setText("")
        self.lineEdit_description.setObjectName("lineEdit_description")
        self.verticalLayout.addWidget(self.lineEdit_description)
        self.gridLayout.addLayout(self.verticalLayout, 1, 0, 1, 1)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.label_5 = QtWidgets.QLabel(Dialog)
        self.label_5.setObjectName("label_5")
        self.horizontalLayout_3.addWidget(self.label_5)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem1)
        self.checkBox_zeroterminate = QtWidgets.QCheckBox(Dialog)
        self.checkBox_zeroterminate.setChecked(True)
        self.checkBox_zeroterminate.setObjectName("checkBox_zeroterminate")
        self.horizontalLayout_3.addWidget(self.checkBox_zeroterminate)
        self.verticalLayout_3.addLayout(self.horizontalLayout_3)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.comboBox_ValueType = QtWidgets.QComboBox(Dialog)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.comboBox_ValueType.sizePolicy().hasHeightForWidth())
        self.comboBox_ValueType.setSizePolicy(sizePolicy)
        self.comboBox_ValueType.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
        self.comboBox_ValueType.setObjectName("comboBox_ValueType")
        self.horizontalLayout_2.addWidget(self.comboBox_ValueType)
        spacerItem2 = QtWidgets.QSpacerItem(13, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem2)
        self.label_length = QtWidgets.QLabel(Dialog)
        self.label_length.setObjectName("label_length")
        self.horizontalLayout_2.addWidget(self.label_length)
        self.lineEdit_length = QtWidgets.QLineEdit(Dialog)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lineEdit_length.sizePolicy().hasHeightForWidth())
        self.lineEdit_length.setSizePolicy(sizePolicy)
        self.lineEdit_length.setMaximumSize(QtCore.QSize(60, 16777215))
        self.lineEdit_length.setInputMask("")
        self.lineEdit_length.setObjectName("lineEdit_length")
        self.horizontalLayout_2.addWidget(self.lineEdit_length)
        self.verticalLayout_3.addLayout(self.horizontalLayout_2)
        self.gridLayout.addLayout(self.verticalLayout_3, 2, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.comboBox_ValueType.setCurrentIndex(-1)
        self.buttonBox.accepted.connect(Dialog.accept)
        self.buttonBox.rejected.connect(Dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Add Address Manually"))
        self.label.setText(_translate("Dialog", "Address:"))
        self.label_2.setText(_translate("Dialog", "="))
        self.label_4.setText(_translate("Dialog", "Description:"))
        self.label_5.setText(_translate("Dialog", "Type:"))
        self.checkBox_zeroterminate.setText(_translate("Dialog", "Zero-Terminated"))
        self.label_length.setText(_translate("Dialog", "Length"))
        self.lineEdit_length.setText(_translate("Dialog", "10"))


```

`GUI/AddAddressManuallyDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>232</width>
    <height>248</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="maximumSize">
   <size>
    <width>16777215</width>
    <height>248</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Add Address Manually</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="3" column="0">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
   <item row="0" column="0">
    <layout class="QVBoxLayout" name="verticalLayout_2">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Address:</string>
       </property>
      </widget>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout">
       <item>
        <widget class="QLineEdit" name="lineEdit_address">
         <property name="sizePolicy">
          <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="minimumSize">
          <size>
           <width>100</width>
           <height>0</height>
          </size>
         </property>
         <property name="text">
          <string/>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string>=</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_valueofaddress">
         <property name="text">
          <string/>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QLabel" name="label_4">
       <property name="text">
        <string>Description:</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_description">
       <property name="text">
        <string/>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item row="2" column="0">
    <layout class="QVBoxLayout" name="verticalLayout_3">
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_3">
       <item>
        <widget class="QLabel" name="label_5">
         <property name="text">
          <string>Type:</string>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer_3">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
       <item>
        <widget class="QCheckBox" name="checkBox_zeroterminate">
         <property name="text">
          <string>Zero-Terminated</string>
         </property>
         <property name="checked">
          <bool>true</bool>
         </property>
        </widget>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_2">
       <item>
        <widget class="QComboBox" name="comboBox_ValueType">
         <property name="sizePolicy">
          <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="currentIndex">
          <number>-1</number>
         </property>
         <property name="sizeAdjustPolicy">
          <enum>QComboBox::AdjustToContents</enum>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer_2">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>13</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
       <item>
        <widget class="QLabel" name="label_length">
         <property name="text">
          <string>Length</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLineEdit" name="lineEdit_length">
         <property name="sizePolicy">
          <sizepolicy hsizetype="Fixed" vsizetype="Expanding">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="maximumSize">
          <size>
           <width>60</width>
           <height>16777215</height>
          </size>
         </property>
         <property name="inputMask">
          <string/>
         </property>
         <property name="text">
          <string>10</string>
         </property>
        </widget>
       </item>
      </layout>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>280</x>
     <y>371</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>280</x>
     <y>371</y>
    </hint>
    <hint type="destinationlabel">
     <x>283</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/BookmarkWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'bookmarkwidget.ui'
#
# Created: Sat Jul  9 16:03:34 2016
#      by: PyQt5 UI code generator 5.2.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(900, 300)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(Form)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.listWidget = QtWidgets.QListWidget(Form)
        self.listWidget.setObjectName("listWidget")
        self.verticalLayout.addWidget(self.listWidget)
        self.horizontalLayout.addLayout(self.verticalLayout)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label_2 = QtWidgets.QLabel(Form)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_2.addWidget(self.label_2)
        self.lineEdit_Info = QtWidgets.QLineEdit(Form)
        self.lineEdit_Info.setReadOnly(True)
        self.lineEdit_Info.setObjectName("lineEdit_Info")
        self.verticalLayout_2.addWidget(self.lineEdit_Info)
        self.label_3 = QtWidgets.QLabel(Form)
        self.label_3.setObjectName("label_3")
        self.verticalLayout_2.addWidget(self.label_3)
        self.lineEdit_Comment = QtWidgets.QLineEdit(Form)
        self.lineEdit_Comment.setReadOnly(True)
        self.lineEdit_Comment.setObjectName("lineEdit_Comment")
        self.verticalLayout_2.addWidget(self.lineEdit_Comment)
        spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_2.addItem(spacerItem)
        self.horizontalLayout.addLayout(self.verticalLayout_2)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Bookmarks"))
        self.label.setText(_translate("Form", "Bookmarked Addresses"))
        self.label_2.setText(_translate("Form", "Info"))
        self.label_3.setText(_translate("Form", "Comment"))


```

`GUI/BookmarkWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>900</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Bookmarks</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <widget class="QLabel" name="label">
         <property name="text">
          <string>Bookmarked Addresses</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QListWidget" name="listWidget"/>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QVBoxLayout" name="verticalLayout_2">
       <item>
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string>Info</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLineEdit" name="lineEdit_Info">
         <property name="readOnly">
          <bool>true</bool>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_3">
         <property name="text">
          <string>Comment</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLineEdit" name="lineEdit_Comment">
         <property name="readOnly">
          <bool>true</bool>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="verticalSpacer">
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>20</width>
           <height>40</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/BreakpointInfoWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'BreakpointInfoWidget.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_TabWidget(object):
    def setupUi(self, TabWidget):
        TabWidget.setObjectName("TabWidget")
        TabWidget.resize(659, 496)
        self.tab_BreakpointInfo = QtWidgets.QWidget()
        self.tab_BreakpointInfo.setObjectName("tab_BreakpointInfo")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.tab_BreakpointInfo)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.tableWidget_BreakpointInfo = QtWidgets.QTableWidget(self.tab_BreakpointInfo)
        self.tableWidget_BreakpointInfo.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_BreakpointInfo.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_BreakpointInfo.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_BreakpointInfo.setObjectName("tableWidget_BreakpointInfo")
        self.tableWidget_BreakpointInfo.setColumnCount(9)
        self.tableWidget_BreakpointInfo.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(5, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(6, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(7, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(8, item)
        self.tableWidget_BreakpointInfo.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_BreakpointInfo.verticalHeader().setVisible(False)
        self.tableWidget_BreakpointInfo.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_BreakpointInfo.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout_2.addWidget(self.tableWidget_BreakpointInfo, 0, 0, 1, 1)
        TabWidget.addTab(self.tab_BreakpointInfo, "")
        self.tab_RawBreakpointInfo = QtWidgets.QWidget()
        self.tab_RawBreakpointInfo.setObjectName("tab_RawBreakpointInfo")
        self.gridLayout = QtWidgets.QGridLayout(self.tab_RawBreakpointInfo)
        self.gridLayout.setObjectName("gridLayout")
        self.textBrowser_BreakpointInfo = QtWidgets.QTextBrowser(self.tab_RawBreakpointInfo)
        self.textBrowser_BreakpointInfo.setObjectName("textBrowser_BreakpointInfo")
        self.gridLayout.addWidget(self.textBrowser_BreakpointInfo, 0, 0, 1, 1)
        TabWidget.addTab(self.tab_RawBreakpointInfo, "")

        self.retranslateUi(TabWidget)
        TabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(TabWidget)

    def retranslateUi(self, TabWidget):
        _translate = QtCore.QCoreApplication.translate
        TabWidget.setWindowTitle(_translate("TabWidget", "Breakpoints"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(0)
        item.setText(_translate("TabWidget", "No"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(1)
        item.setText(_translate("TabWidget", "Type"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(2)
        item.setText(_translate("TabWidget", "Disp"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(3)
        item.setText(_translate("TabWidget", "Enabled"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(4)
        item.setText(_translate("TabWidget", "Address"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(5)
        item.setText(_translate("TabWidget", "Size"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(6)
        item.setText(_translate("TabWidget", "On Hit"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(7)
        item.setText(_translate("TabWidget", "Hit Count"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(8)
        item.setText(_translate("TabWidget", "Condition"))
        TabWidget.setTabText(TabWidget.indexOf(self.tab_BreakpointInfo), _translate("TabWidget", "Interactive"))
        TabWidget.setTabText(TabWidget.indexOf(self.tab_RawBreakpointInfo), _translate("TabWidget", "Raw"))


```

`GUI/BreakpointInfoWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TabWidget</class>
 <widget class="QTabWidget" name="TabWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>659</width>
    <height>496</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Breakpoints</string>
  </property>
  <property name="currentIndex">
   <number>0</number>
  </property>
  <widget class="QWidget" name="tab_BreakpointInfo">
   <attribute name="title">
    <string>Interactive</string>
   </attribute>
   <layout class="QGridLayout" name="gridLayout_2">
    <item row="0" column="0">
     <widget class="QTableWidget" name="tableWidget_BreakpointInfo">
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
      <property name="selectionMode">
       <enum>QAbstractItemView::SingleSelection</enum>
      </property>
      <property name="selectionBehavior">
       <enum>QAbstractItemView::SelectRows</enum>
      </property>
      <attribute name="horizontalHeaderStretchLastSection">
       <bool>true</bool>
      </attribute>
      <attribute name="verticalHeaderVisible">
       <bool>false</bool>
      </attribute>
      <attribute name="verticalHeaderDefaultSectionSize">
       <number>16</number>
      </attribute>
      <attribute name="verticalHeaderMinimumSectionSize">
       <number>16</number>
      </attribute>
      <column>
       <property name="text">
        <string>No</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Type</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Disp</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Enabled</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Address</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Size</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>On Hit</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Hit Count</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Condition</string>
       </property>
      </column>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QWidget" name="tab_RawBreakpointInfo">
   <attribute name="title">
    <string>Raw</string>
   </attribute>
   <layout class="QGridLayout" name="gridLayout">
    <item row="0" column="0">
     <widget class="QTextBrowser" name="textBrowser_BreakpointInfo"/>
    </item>
   </layout>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/ConsoleWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'consolewidget.ui'
#
# Created: Thu Jul 21 18:11:36 2016
#      by: PyQt5 UI code generator 5.2.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(850, 500)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(Form.sizePolicy().hasHeightForWidth())
        Form.setSizePolicy(sizePolicy)
        Form.setMinimumSize(QtCore.QSize(850, 500))
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(Form)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.textBrowser = QtWidgets.QTextBrowser(Form)
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 255, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 255, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(128, 128, 128))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)
        self.textBrowser.setPalette(palette)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        font.setBold(False)
        font.setItalic(False)
        font.setWeight(50)
        self.textBrowser.setFont(font)
        self.textBrowser.setObjectName("textBrowser")
        self.verticalLayout.addWidget(self.textBrowser)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.lineEdit = QtWidgets.QLineEdit(Form)
        self.lineEdit.setObjectName("lineEdit")
        self.horizontalLayout.addWidget(self.lineEdit)
        self.pushButton_Send = QtWidgets.QPushButton(Form)
        self.pushButton_Send.setObjectName("pushButton_Send")
        self.horizontalLayout.addWidget(self.pushButton_Send)
        self.pushButton_SendCtrl = QtWidgets.QPushButton(Form)
        self.pushButton_SendCtrl.setObjectName("pushButton_SendCtrl")
        self.horizontalLayout.addWidget(self.pushButton_SendCtrl)
        self.radioButton_CLI = QtWidgets.QRadioButton(Form)
        self.radioButton_CLI.setObjectName("radioButton_CLI")
        self.horizontalLayout.addWidget(self.radioButton_CLI)
        self.radioButton_MI = QtWidgets.QRadioButton(Form)
        self.radioButton_MI.setChecked(True)
        self.radioButton_MI.setObjectName("radioButton_MI")
        self.horizontalLayout.addWidget(self.radioButton_MI)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.verticalLayout_2.addLayout(self.verticalLayout)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "GDB Console"))
        self.textBrowser.setHtml(_translate("Form", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'Monospace\'; font-size:9pt; font-weight:400; font-style:normal;\">\n"
"<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p></body></html>"))
        self.pushButton_Send.setText(_translate("Form", "Send"))
        self.pushButton_SendCtrl.setText(_translate("Form", "Send ctrl+c"))
        self.radioButton_CLI.setText(_translate("Form", "CLI"))
        self.radioButton_MI.setText(_translate("Form", "MI"))


```

`GUI/ConsoleWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>850</width>
    <height>500</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>850</width>
    <height>500</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>GDB Console</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_2">
   <item>
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QTextBrowser" name="textBrowser">
       <property name="palette">
        <palette>
         <active>
          <colorrole role="Text">
           <brush brushstyle="SolidPattern">
            <color alpha="255">
             <red>0</red>
             <green>255</green>
             <blue>0</blue>
            </color>
           </brush>
          </colorrole>
          <colorrole role="Base">
           <brush brushstyle="SolidPattern">
            <color alpha="255">
             <red>0</red>
             <green>0</green>
             <blue>0</blue>
            </color>
           </brush>
          </colorrole>
         </active>
         <inactive>
          <colorrole role="Text">
           <brush brushstyle="SolidPattern">
            <color alpha="255">
             <red>0</red>
             <green>255</green>
             <blue>0</blue>
            </color>
           </brush>
          </colorrole>
          <colorrole role="Base">
           <brush brushstyle="SolidPattern">
            <color alpha="255">
             <red>0</red>
             <green>0</green>
             <blue>0</blue>
            </color>
           </brush>
          </colorrole>
         </inactive>
         <disabled>
          <colorrole role="Text">
           <brush brushstyle="SolidPattern">
            <color alpha="255">
             <red>128</red>
             <green>128</green>
             <blue>128</blue>
            </color>
           </brush>
          </colorrole>
          <colorrole role="Base">
           <brush brushstyle="SolidPattern">
            <color alpha="255">
             <red>255</red>
             <green>255</green>
             <blue>255</blue>
            </color>
           </brush>
          </colorrole>
         </disabled>
        </palette>
       </property>
       <property name="font">
        <font>
         <family>Monospace</family>
         <weight>50</weight>
         <italic>false</italic>
         <bold>false</bold>
        </font>
       </property>
       <property name="html">
        <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
p, li { white-space: pre-wrap; }
&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Monospace'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
       </property>
      </widget>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout">
       <item>
        <widget class="QLineEdit" name="lineEdit"/>
       </item>
       <item>
        <widget class="QPushButton" name="pushButton_Send">
         <property name="text">
          <string>Send</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="pushButton_SendCtrl">
         <property name="text">
          <string>Send ctrl+c</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QRadioButton" name="radioButton_CLI">
         <property name="text">
          <string>CLI</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QRadioButton" name="radioButton_MI">
         <property name="text">
          <string>MI</string>
         </property>
         <property name="checked">
          <bool>true</bool>
         </property>
        </widget>
       </item>
      </layout>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/CustomAbstractTableModels/AsciiModel.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from PyQt5.QtCore import QVariant, Qt
from PyQt5.QtGui import QColor
from GUI.CustomAbstractTableModels.HexModel import QHexModel

from libpince import SysUtils, GDB_Engine


class QAsciiModel(QHexModel):
    def __init__(self, row_count, column_count, parent=None):
        super().__init__(row_count, column_count, parent)

    def data(self, QModelIndex, int_role=None):
        if not QModelIndex.isValid():
            return QVariant()
        if int_role == Qt.BackgroundColorRole:
            address = self.current_address + QModelIndex.row() * self.column_count + QModelIndex.column()
            if SysUtils.modulo_address(address, GDB_Engine.inferior_arch) in self.breakpoint_list:
                return QVariant(QColor(Qt.red))
        elif int_role != Qt.DisplayRole:
            return QVariant()
        if self.data_array is None:
            return QVariant()
        return QVariant(
            SysUtils.aob_to_str(self.data_array[QModelIndex.row() * self.column_count + QModelIndex.column()]))

```

`GUI/CustomAbstractTableModels/HexModel.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from PyQt5.QtCore import QAbstractTableModel, QVariant, Qt
from PyQt5.QtGui import QColor

from libpince import SysUtils, GDB_Engine


class QHexModel(QAbstractTableModel):
    def __init__(self, row_count, column_count, parent=None):
        super().__init__(parent)
        self.data_array = []
        self.breakpoint_list = set()
        self.row_count = row_count
        self.column_count = column_count
        self.current_address = 0

    def rowCount(self, QModelIndex_parent=None, *args, **kwargs):
        return self.row_count

    def columnCount(self, QModelIndex_parent=None, *args, **kwargs):
        return self.column_count

    def data(self, QModelIndex, int_role=None):
        if not QModelIndex.isValid():
            return QVariant()
        if int_role == Qt.BackgroundColorRole:
            address = self.current_address + QModelIndex.row() * self.column_count + QModelIndex.column()
            if SysUtils.modulo_address(address, GDB_Engine.inferior_arch) in self.breakpoint_list:
                return QVariant(QColor(Qt.red))
        elif int_role != Qt.DisplayRole:
            return QVariant()
        if self.data_array is None:
            return QVariant()
        return QVariant(self.data_array[QModelIndex.row() * self.column_count + QModelIndex.column()])

    def refresh(self, int_address, offset, data_array=None, breakpoint_info=None):
        int_address = SysUtils.modulo_address(int_address, GDB_Engine.inferior_arch)
        self.breakpoint_list.clear()
        if data_array is None:
            self.data_array = GDB_Engine.hex_dump(int_address, offset)
        else:
            self.data_array = data_array
        if breakpoint_info is None:
            breakpoint_info = GDB_Engine.get_breakpoint_info()
        for breakpoint in breakpoint_info:
            breakpoint_address = int(breakpoint.address, 16)
            for i in range(breakpoint.size):
                self.breakpoint_list.add(SysUtils.modulo_address(breakpoint_address + i, GDB_Engine.inferior_arch))
        self.current_address = int_address
        self.layoutChanged.emit()

```

`GUI/CustomLabels/FlagRegisterLabel.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from PyQt5.QtWidgets import QLabel
from PyQt5.QtGui import QCursor
from PyQt5.QtCore import Qt
from libpince import GDB_Engine
from PINCE import InputDialogForm


class QFlagRegisterLabel(QLabel):
    def __init__(self, parent=None):
        super().__init__(parent)

    def set_value(self, value):
        new = value
        old = self.text()
        if old != new:
            self.setStyleSheet("color: red")
        else:
            self.setStyleSheet("")
        self.setText(new)

    def enterEvent(self, QEvent):
        self.setCursor(QCursor(Qt.PointingHandCursor))

    def mouseDoubleClickEvent(self, QMouseEvent):
        registers = GDB_Engine.read_registers()
        current_flag = self.objectName().lower()
        label_text = "Enter the new value of flag " + self.objectName()
        register_dialog = InputDialogForm(item_list=[(label_text, ["0", "1", int(registers[current_flag])])])
        if register_dialog.exec_():
            GDB_Engine.set_register_flag(current_flag, register_dialog.get_values())
            self.set_value(GDB_Engine.read_registers()[current_flag])

```

`GUI/CustomLabels/RegisterLabel.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from PyQt5.QtWidgets import QLabel, QMenu
from PyQt5.QtGui import QCursor
from PyQt5.QtCore import Qt
from libpince import GDB_Engine
from libpince import GuiUtils
from PINCE import InputDialogForm


class QRegisterLabel(QLabel):
    def __init__(self, parent=None):
        super().__init__(parent)

    def set_value(self, value):
        new = self.objectName() + "=" + value
        old = self.text()
        if old != new:
            self.setStyleSheet("color: red")
        else:
            self.setStyleSheet("")
        self.setText(new)

    def enterEvent(self, QEvent):
        self.setCursor(QCursor(Qt.PointingHandCursor))

    def mouseDoubleClickEvent(self, QMouseEvent):
        registers = GDB_Engine.read_registers()
        current_register = self.objectName().lower()
        register_dialog = InputDialogForm(
            item_list=[("Enter the new value of register " + self.objectName(), registers[current_register])])
        if register_dialog.exec_():
            GDB_Engine.set_convenience_variable(current_register, register_dialog.get_values())
            self.set_value(GDB_Engine.read_registers()[current_register])

    def contextMenuEvent(self, QContextMenuEvent):
        menu = QMenu()
        show_in_hex_view = menu.addAction("Show in HexView")
        show_in_disassembler = menu.addAction("Show in Disassembler")
        font_size = self.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(QContextMenuEvent.globalPos())
        if action == show_in_hex_view:
            parent = GuiUtils.search_parents_by_function(self, "hex_dump_address")
            if parent.objectName() == "MainWindow_MemoryView":
                address = self.text().split("=")[-1]
                address_int = int(address, 16)
                parent.hex_dump_address(address_int)
        elif action == show_in_disassembler:
            parent = GuiUtils.search_parents_by_function(self, "disassemble_expression")
            if parent.objectName() == "MainWindow_MemoryView":
                address = self.text().split("=")[-1]
                parent.disassemble_expression(address)

```

`GUI/CustomTableViews/AsciiView.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from GUI.CustomTableViews.HexView import QHexView


class QAsciiView(QHexView):
    # data_array is returned from GDB_Engine.hex_dump()
    def __init__(self, parent=None):
        super().__init__(parent)
        self.horizontalHeader().setDefaultSectionSize(15)

```

`GUI/CustomTableViews/HexView.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from PyQt5.QtWidgets import QTableView, QAbstractItemView
from PyQt5.QtCore import Qt

from libpince import SysUtils, GDB_Engine


class QHexView(QTableView):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.horizontalHeader().setVisible(False)
        self.verticalHeader().setVisible(False)
        self.verticalHeader().setDefaultSectionSize(self.verticalHeader().minimumSectionSize())
        self.horizontalHeader().setDefaultSectionSize(self.horizontalHeader().minimumSectionSize())
        self.setStyleSheet("QTableView {background-color: transparent;}")
        self.setShowGrid(False)
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setAutoScroll(False)

    def wheelEvent(self, QWheelEvent):
        QWheelEvent.ignore()

    def resize_to_contents(self):
        size = self.columnWidth(0) * self.model().columnCount()
        self.setMinimumWidth(size)
        self.setMaximumWidth(size)

    def get_selected_address(self):
        ci = self.currentIndex()
        current_address = self.model().current_address + ci.row() * self.model().columnCount() + ci.column()
        return SysUtils.modulo_address(current_address, GDB_Engine.inferior_arch)

```

`GUI/CustomValidators/HexValidator.py`:

```py
from PyQt5.QtGui import QValidator


class QHexValidator(QValidator):
    def __init__(self, max_limit, parent=None):
        super().__init__(parent)
        self.max_limit = max_limit

    def validate(self, p_str, p_int):
        try:
            int_repr = int(p_str, 0)
        except ValueError:
            return QValidator.Intermediate, p_str, p_int
        if int_repr > self.max_limit:
            return QValidator.Invalid, p_str, p_int
        return QValidator.Acceptable, p_str, p_int

```

`GUI/DissectCodeDialog.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DissectCodeDialog.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(799, 412)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter = QtWidgets.QSplitter(Dialog)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.tableWidget_ExecutableMemoryRegions = QtWidgets.QTableWidget(self.splitter)
        self.tableWidget_ExecutableMemoryRegions.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_ExecutableMemoryRegions.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_ExecutableMemoryRegions.setObjectName("tableWidget_ExecutableMemoryRegions")
        self.tableWidget_ExecutableMemoryRegions.setColumnCount(2)
        self.tableWidget_ExecutableMemoryRegions.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_ExecutableMemoryRegions.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_ExecutableMemoryRegions.setHorizontalHeaderItem(1, item)
        self.tableWidget_ExecutableMemoryRegions.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_ExecutableMemoryRegions.verticalHeader().setVisible(False)
        self.tableWidget_ExecutableMemoryRegions.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_ExecutableMemoryRegions.verticalHeader().setMinimumSectionSize(16)
        self.layoutWidget = QtWidgets.QWidget(self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label_ScanInfo = QtWidgets.QLabel(self.layoutWidget)
        self.label_ScanInfo.setAlignment(QtCore.Qt.AlignCenter)
        self.label_ScanInfo.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_ScanInfo.setObjectName("label_ScanInfo")
        self.verticalLayout.addWidget(self.label_ScanInfo)
        self.label_RegionInfo = QtWidgets.QLabel(self.layoutWidget)
        self.label_RegionInfo.setAlignment(QtCore.Qt.AlignCenter)
        self.label_RegionInfo.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_RegionInfo.setObjectName("label_RegionInfo")
        self.verticalLayout.addWidget(self.label_RegionInfo)
        self.label_RegionCountInfo = QtWidgets.QLabel(self.layoutWidget)
        self.label_RegionCountInfo.setAlignment(QtCore.Qt.AlignCenter)
        self.label_RegionCountInfo.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_RegionCountInfo.setObjectName("label_RegionCountInfo")
        self.verticalLayout.addWidget(self.label_RegionCountInfo)
        self.label_4 = QtWidgets.QLabel(self.layoutWidget)
        self.label_4.setAlignment(QtCore.Qt.AlignCenter)
        self.label_4.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_4.setObjectName("label_4")
        self.verticalLayout.addWidget(self.label_4)
        self.label_CurrentRange = QtWidgets.QLabel(self.layoutWidget)
        self.label_CurrentRange.setAlignment(QtCore.Qt.AlignCenter)
        self.label_CurrentRange.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_CurrentRange.setObjectName("label_CurrentRange")
        self.verticalLayout.addWidget(self.label_CurrentRange)
        self.verticalLayout_2.addLayout(self.verticalLayout)
        self.line = QtWidgets.QFrame(self.layoutWidget)
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")
        self.verticalLayout_2.addWidget(self.line)
        self.label = QtWidgets.QLabel(self.layoutWidget)
        self.label.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label.setObjectName("label")
        self.verticalLayout_2.addWidget(self.label)
        self.label_StringReferenceCount = QtWidgets.QLabel(self.layoutWidget)
        self.label_StringReferenceCount.setText("")
        self.label_StringReferenceCount.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_StringReferenceCount.setObjectName("label_StringReferenceCount")
        self.verticalLayout_2.addWidget(self.label_StringReferenceCount)
        self.label_2 = QtWidgets.QLabel(self.layoutWidget)
        self.label_2.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_2.addWidget(self.label_2)
        self.label_JumpReferenceCount = QtWidgets.QLabel(self.layoutWidget)
        self.label_JumpReferenceCount.setText("")
        self.label_JumpReferenceCount.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_JumpReferenceCount.setObjectName("label_JumpReferenceCount")
        self.verticalLayout_2.addWidget(self.label_JumpReferenceCount)
        self.label_3 = QtWidgets.QLabel(self.layoutWidget)
        self.label_3.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_3.setObjectName("label_3")
        self.verticalLayout_2.addWidget(self.label_3)
        self.label_CallReferenceCount = QtWidgets.QLabel(self.layoutWidget)
        self.label_CallReferenceCount.setText("")
        self.label_CallReferenceCount.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_CallReferenceCount.setObjectName("label_CallReferenceCount")
        self.verticalLayout_2.addWidget(self.label_CallReferenceCount)
        self.line_2 = QtWidgets.QFrame(self.layoutWidget)
        self.line_2.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_2.setObjectName("line_2")
        self.verticalLayout_2.addWidget(self.line_2)
        self.checkBox_DiscardInvalidStrings = QtWidgets.QCheckBox(self.layoutWidget)
        self.checkBox_DiscardInvalidStrings.setChecked(True)
        self.checkBox_DiscardInvalidStrings.setObjectName("checkBox_DiscardInvalidStrings")
        self.verticalLayout_2.addWidget(self.checkBox_DiscardInvalidStrings)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.pushButton_StartCancel = QtWidgets.QPushButton(self.layoutWidget)
        self.pushButton_StartCancel.setText("")
        self.pushButton_StartCancel.setObjectName("pushButton_StartCancel")
        self.horizontalLayout.addWidget(self.pushButton_StartCancel)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        spacerItem2 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_2.addItem(spacerItem2)
        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dissect Code"))
        item = self.tableWidget_ExecutableMemoryRegions.horizontalHeaderItem(0)
        item.setText(_translate("Dialog", "Regions"))
        item = self.tableWidget_ExecutableMemoryRegions.horizontalHeaderItem(1)
        item.setText(_translate("Dialog", "Path"))
        self.label_ScanInfo.setText(_translate("Dialog", "Selected regions will be scanned"))
        self.label_RegionInfo.setText(_translate("Dialog", "-"))
        self.label_RegionCountInfo.setText(_translate("Dialog", "-"))
        self.label_4.setText(_translate("Dialog", "Currently scanning range:"))
        self.label_CurrentRange.setText(_translate("Dialog", "-"))
        self.label.setText(_translate("Dialog", "String references found:"))
        self.label_2.setText(_translate("Dialog", "Jumps found:"))
        self.label_3.setText(_translate("Dialog", "Calls found:"))
        self.checkBox_DiscardInvalidStrings.setToolTip(_translate("Dialog", "Entries that can\'t be decoded as utf-8 won\'t be included in referenced strings\n"
"Unchecking it makes ReferencedStringsWidget load slower but allows you to examine non-string pointers on it"))
        self.checkBox_DiscardInvalidStrings.setText(_translate("Dialog", "Discard invalid strings"))


```

`GUI/DissectCodeDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>799</width>
    <height>412</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dissect Code</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <widget class="QTableWidget" name="tableWidget_ExecutableMemoryRegions">
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
      <property name="selectionBehavior">
       <enum>QAbstractItemView::SelectRows</enum>
      </property>
      <attribute name="horizontalHeaderStretchLastSection">
       <bool>true</bool>
      </attribute>
      <attribute name="verticalHeaderVisible">
       <bool>false</bool>
      </attribute>
      <attribute name="verticalHeaderDefaultSectionSize">
       <number>16</number>
      </attribute>
      <attribute name="verticalHeaderMinimumSectionSize">
       <number>16</number>
      </attribute>
      <column>
       <property name="text">
        <string>Regions</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Path</string>
       </property>
      </column>
     </widget>
     <widget class="QWidget" name="layoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout_2">
       <item>
        <layout class="QVBoxLayout" name="verticalLayout">
         <item>
          <widget class="QLabel" name="label_ScanInfo">
           <property name="text">
            <string>Selected regions will be scanned</string>
           </property>
           <property name="alignment">
            <set>Qt::AlignCenter</set>
           </property>
           <property name="textInteractionFlags">
            <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLabel" name="label_RegionInfo">
           <property name="text">
            <string>-</string>
           </property>
           <property name="alignment">
            <set>Qt::AlignCenter</set>
           </property>
           <property name="textInteractionFlags">
            <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLabel" name="label_RegionCountInfo">
           <property name="text">
            <string>-</string>
           </property>
           <property name="alignment">
            <set>Qt::AlignCenter</set>
           </property>
           <property name="textInteractionFlags">
            <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLabel" name="label_4">
           <property name="text">
            <string>Currently scanning range:</string>
           </property>
           <property name="alignment">
            <set>Qt::AlignCenter</set>
           </property>
           <property name="textInteractionFlags">
            <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLabel" name="label_CurrentRange">
           <property name="text">
            <string>-</string>
           </property>
           <property name="alignment">
            <set>Qt::AlignCenter</set>
           </property>
           <property name="textInteractionFlags">
            <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="Line" name="line">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label">
         <property name="text">
          <string>String references found:</string>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_StringReferenceCount">
         <property name="text">
          <string/>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string>Jumps found:</string>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_JumpReferenceCount">
         <property name="text">
          <string/>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_3">
         <property name="text">
          <string>Calls found:</string>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_CallReferenceCount">
         <property name="text">
          <string/>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <widget class="Line" name="line_2">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="checkBox_DiscardInvalidStrings">
         <property name="toolTip">
          <string>Entries that can't be decoded as utf-8 won't be included in referenced strings
Unchecking it makes ReferencedStringsWidget load slower but allows you to examine non-string pointers on it</string>
         </property>
         <property name="text">
          <string>Discard invalid strings</string>
         </property>
         <property name="checked">
          <bool>true</bool>
         </property>
        </widget>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout">
         <item>
          <spacer name="horizontalSpacer_2">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>40</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
         <item>
          <widget class="QPushButton" name="pushButton_StartCancel">
           <property name="text">
            <string/>
           </property>
          </widget>
         </item>
         <item>
          <spacer name="horizontalSpacer">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>40</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
        </layout>
       </item>
       <item>
        <spacer name="verticalSpacer">
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>20</width>
           <height>40</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/EditTypeDialog.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'EditTypeDialog.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(345, 119)
        Dialog.setMaximumSize(QtCore.QSize(345, 119))
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(Dialog)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.comboBox_ValueType = QtWidgets.QComboBox(Dialog)
        self.comboBox_ValueType.setObjectName("comboBox_ValueType")
        self.verticalLayout.addWidget(self.comboBox_ValueType)
        self.horizontalLayout_3.addLayout(self.verticalLayout)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.label_Length = QtWidgets.QLabel(Dialog)
        self.label_Length.setObjectName("label_Length")
        self.verticalLayout_3.addWidget(self.label_Length)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.lineEdit_Length = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_Length.setObjectName("lineEdit_Length")
        self.horizontalLayout_2.addWidget(self.lineEdit_Length)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem)
        self.verticalLayout_3.addLayout(self.horizontalLayout_2)
        self.horizontalLayout_3.addLayout(self.verticalLayout_3)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_2.addItem(spacerItem1)
        self.checkBox_ZeroTerminate = QtWidgets.QCheckBox(Dialog)
        self.checkBox_ZeroTerminate.setChecked(True)
        self.checkBox_ZeroTerminate.setObjectName("checkBox_ZeroTerminate")
        self.verticalLayout_2.addWidget(self.checkBox_ZeroTerminate)
        self.horizontalLayout_3.addLayout(self.verticalLayout_2)
        self.gridLayout.addLayout(self.horizontalLayout_3, 0, 0, 1, 1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.buttonBox = QtWidgets.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.horizontalLayout.addWidget(self.buttonBox)
        spacerItem2 = QtWidgets.QSpacerItem(37, 17, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem2)
        self.gridLayout.addLayout(self.horizontalLayout, 1, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept)
        self.buttonBox.rejected.connect(Dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Type"))
        self.label.setText(_translate("Dialog", "Select the new type"))
        self.label_Length.setText(_translate("Dialog", "Length"))
        self.lineEdit_Length.setText(_translate("Dialog", "10"))
        self.checkBox_ZeroTerminate.setText(_translate("Dialog", "Zero-Terminated"))


```

`GUI/EditTypeDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>345</width>
    <height>119</height>
   </rect>
  </property>
  <property name="maximumSize">
   <size>
    <width>345</width>
    <height>119</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Type</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout_3">
     <item>
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <widget class="QLabel" name="label">
         <property name="text">
          <string>Select the new type</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QComboBox" name="comboBox_ValueType"/>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QVBoxLayout" name="verticalLayout_3">
       <item>
        <widget class="QLabel" name="label_Length">
         <property name="text">
          <string>Length</string>
         </property>
        </widget>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <item>
          <widget class="QLineEdit" name="lineEdit_Length">
           <property name="text">
            <string>10</string>
           </property>
          </widget>
         </item>
         <item>
          <spacer name="horizontalSpacer_2">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>40</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
        </layout>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QVBoxLayout" name="verticalLayout_2">
       <item>
        <spacer name="verticalSpacer">
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>20</width>
           <height>40</height>
          </size>
         </property>
        </spacer>
       </item>
       <item>
        <widget class="QCheckBox" name="checkBox_ZeroTerminate">
         <property name="text">
          <string>Zero-Terminated</string>
         </property>
         <property name="checked">
          <bool>true</bool>
         </property>
        </widget>
       </item>
      </layout>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QDialogButtonBox" name="buttonBox">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="standardButtons">
        <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>37</width>
         <height>17</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/ExamineReferrersWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ExamineReferrersWidget.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(1025, 530)
        Form.setToolTip("")
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter = QtWidgets.QSplitter(Form)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.layoutWidget = QtWidgets.QWidget(self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.lineEdit_Regex = QtWidgets.QLineEdit(self.layoutWidget)
        self.lineEdit_Regex.setObjectName("lineEdit_Regex")
        self.horizontalLayout_2.addWidget(self.lineEdit_Regex)
        self.checkBox_CaseSensitive = QtWidgets.QCheckBox(self.layoutWidget)
        self.checkBox_CaseSensitive.setObjectName("checkBox_CaseSensitive")
        self.horizontalLayout_2.addWidget(self.checkBox_CaseSensitive)
        self.checkBox_Regex = QtWidgets.QCheckBox(self.layoutWidget)
        self.checkBox_Regex.setObjectName("checkBox_Regex")
        self.horizontalLayout_2.addWidget(self.checkBox_Regex)
        self.pushButton_Search = QtWidgets.QPushButton(self.layoutWidget)
        self.pushButton_Search.setObjectName("pushButton_Search")
        self.horizontalLayout_2.addWidget(self.pushButton_Search)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.listWidget_Referrers = QtWidgets.QListWidget(self.layoutWidget)
        self.listWidget_Referrers.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.listWidget_Referrers.setObjectName("listWidget_Referrers")
        self.verticalLayout.addWidget(self.listWidget_Referrers)
        self.textBrowser_DisasInfo = QtWidgets.QTextBrowser(self.splitter)
        self.textBrowser_DisasInfo.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
        self.textBrowser_DisasInfo.setObjectName("textBrowser_DisasInfo")
        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Examine Referrers"))
        self.lineEdit_Regex.setToolTip(_translate("Form", "Enter a string or a python regex"))
        self.lineEdit_Regex.setPlaceholderText(_translate("Form", "Enter a string or a python regex"))
        self.checkBox_CaseSensitive.setToolTip(_translate("Form", "Ignore case if checked"))
        self.checkBox_CaseSensitive.setText(_translate("Form", "Case sensitive"))
        self.checkBox_Regex.setToolTip(_translate("Form", "Your string will be treated as a regex if checked"))
        self.checkBox_Regex.setText(_translate("Form", "Regex"))
        self.pushButton_Search.setText(_translate("Form", "Search(Enter)"))


```

`GUI/ExamineReferrersWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1025</width>
    <height>530</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Examine Referrers</string>
  </property>
  <property name="toolTip">
   <string/>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <widget class="QWidget" name="layoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <item>
          <widget class="QLineEdit" name="lineEdit_Regex">
           <property name="toolTip">
            <string>Enter a string or a python regex</string>
           </property>
           <property name="placeholderText">
            <string>Enter a string or a python regex</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="checkBox_CaseSensitive">
           <property name="toolTip">
            <string>Ignore case if checked</string>
           </property>
           <property name="text">
            <string>Case sensitive</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="checkBox_Regex">
           <property name="toolTip">
            <string>Your string will be treated as a regex if checked</string>
           </property>
           <property name="text">
            <string>Regex</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="pushButton_Search">
           <property name="text">
            <string>Search(Enter)</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QListWidget" name="listWidget_Referrers">
         <property name="editTriggers">
          <set>QAbstractItemView::NoEditTriggers</set>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QTextBrowser" name="textBrowser_DisasInfo">
      <property name="lineWrapMode">
       <enum>QTextEdit::NoWrap</enum>
      </property>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/FloatRegisterWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'floatregisterwidget.ui'
#
# Created: Tue Jul 19 01:12:53 2016
#      by: PyQt5 UI code generator 5.2.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_TabWidget(object):
    def setupUi(self, TabWidget):
        TabWidget.setObjectName("TabWidget")
        TabWidget.resize(400, 300)
        self.FPU = QtWidgets.QWidget()
        self.FPU.setObjectName("FPU")
        self.gridLayout = QtWidgets.QGridLayout(self.FPU)
        self.gridLayout.setObjectName("gridLayout")
        self.tableWidget_FPU = QtWidgets.QTableWidget(self.FPU)
        self.tableWidget_FPU.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_FPU.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_FPU.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_FPU.setObjectName("tableWidget_FPU")
        self.tableWidget_FPU.setColumnCount(2)
        self.tableWidget_FPU.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_FPU.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_FPU.setHorizontalHeaderItem(1, item)
        self.tableWidget_FPU.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_FPU.verticalHeader().setVisible(False)
        self.gridLayout.addWidget(self.tableWidget_FPU, 0, 0, 1, 1)
        TabWidget.addTab(self.FPU, "")
        self.XMM = QtWidgets.QWidget()
        self.XMM.setObjectName("XMM")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.XMM)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.tableWidget_XMM = QtWidgets.QTableWidget(self.XMM)
        self.tableWidget_XMM.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_XMM.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_XMM.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_XMM.setObjectName("tableWidget_XMM")
        self.tableWidget_XMM.setColumnCount(2)
        self.tableWidget_XMM.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_XMM.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_XMM.setHorizontalHeaderItem(1, item)
        self.tableWidget_XMM.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_XMM.verticalHeader().setVisible(False)
        self.gridLayout_2.addWidget(self.tableWidget_XMM, 0, 0, 1, 1)
        TabWidget.addTab(self.XMM, "")

        self.retranslateUi(TabWidget)
        TabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(TabWidget)

    def retranslateUi(self, TabWidget):
        _translate = QtCore.QCoreApplication.translate
        TabWidget.setWindowTitle(_translate("TabWidget", "Floating Point Registers"))
        item = self.tableWidget_FPU.horizontalHeaderItem(0)
        item.setText(_translate("TabWidget", "Register"))
        item = self.tableWidget_FPU.horizontalHeaderItem(1)
        item.setText(_translate("TabWidget", "Value"))
        TabWidget.setTabText(TabWidget.indexOf(self.FPU), _translate("TabWidget", "FPU"))
        item = self.tableWidget_XMM.horizontalHeaderItem(0)
        item.setText(_translate("TabWidget", "Register"))
        item = self.tableWidget_XMM.horizontalHeaderItem(1)
        item.setText(_translate("TabWidget", "Value"))
        TabWidget.setTabText(TabWidget.indexOf(self.XMM), _translate("TabWidget", "XMM"))


```

`GUI/FloatRegisterWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TabWidget</class>
 <widget class="QTabWidget" name="TabWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Floating Point Registers</string>
  </property>
  <property name="currentIndex">
   <number>0</number>
  </property>
  <widget class="QWidget" name="FPU">
   <attribute name="title">
    <string>FPU</string>
   </attribute>
   <layout class="QGridLayout" name="gridLayout">
    <item row="0" column="0">
     <widget class="QTableWidget" name="tableWidget_FPU">
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
      <property name="selectionMode">
       <enum>QAbstractItemView::SingleSelection</enum>
      </property>
      <property name="selectionBehavior">
       <enum>QAbstractItemView::SelectRows</enum>
      </property>
      <attribute name="horizontalHeaderStretchLastSection">
       <bool>true</bool>
      </attribute>
      <attribute name="verticalHeaderVisible">
       <bool>false</bool>
      </attribute>
      <column>
       <property name="text">
        <string>Register</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Value</string>
       </property>
      </column>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QWidget" name="XMM">
   <attribute name="title">
    <string>XMM</string>
   </attribute>
   <layout class="QGridLayout" name="gridLayout_2">
    <item row="0" column="0">
     <widget class="QTableWidget" name="tableWidget_XMM">
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
      <property name="selectionMode">
       <enum>QAbstractItemView::SingleSelection</enum>
      </property>
      <property name="selectionBehavior">
       <enum>QAbstractItemView::SelectRows</enum>
      </property>
      <attribute name="horizontalHeaderStretchLastSection">
       <bool>true</bool>
      </attribute>
      <attribute name="verticalHeaderVisible">
       <bool>false</bool>
      </attribute>
      <column>
       <property name="text">
        <string>Register</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Value</string>
       </property>
      </column>
     </widget>
    </item>
   </layout>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/FunctionsInfoWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'FunctionsInfoWidget.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(640, 555)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.tableWidget_SymbolInfo = QtWidgets.QTableWidget(Form)
        self.tableWidget_SymbolInfo.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_SymbolInfo.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_SymbolInfo.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_SymbolInfo.setObjectName("tableWidget_SymbolInfo")
        self.tableWidget_SymbolInfo.setColumnCount(2)
        self.tableWidget_SymbolInfo.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_SymbolInfo.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_SymbolInfo.setHorizontalHeaderItem(1, item)
        self.tableWidget_SymbolInfo.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_SymbolInfo.verticalHeader().setVisible(False)
        self.tableWidget_SymbolInfo.verticalHeader().setDefaultSectionSize(20)
        self.tableWidget_SymbolInfo.verticalHeader().setMinimumSectionSize(20)
        self.gridLayout.addWidget(self.tableWidget_SymbolInfo, 2, 0, 1, 1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.lineEdit_SearchInput = QtWidgets.QLineEdit(Form)
        self.lineEdit_SearchInput.setObjectName("lineEdit_SearchInput")
        self.horizontalLayout.addWidget(self.lineEdit_SearchInput)
        self.checkBox_CaseSensitive = QtWidgets.QCheckBox(Form)
        self.checkBox_CaseSensitive.setObjectName("checkBox_CaseSensitive")
        self.horizontalLayout.addWidget(self.checkBox_CaseSensitive)
        self.pushButton_Search = QtWidgets.QPushButton(Form)
        self.pushButton_Search.setObjectName("pushButton_Search")
        self.horizontalLayout.addWidget(self.pushButton_Search)
        self.pushButton_Help = QtWidgets.QPushButton(Form)
        self.pushButton_Help.setText("")
        self.pushButton_Help.setObjectName("pushButton_Help")
        self.horizontalLayout.addWidget(self.pushButton_Help)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        self.textBrowser_AddressInfo = QtWidgets.QTextBrowser(Form)
        self.textBrowser_AddressInfo.setObjectName("textBrowser_AddressInfo")
        self.gridLayout.addWidget(self.textBrowser_AddressInfo, 1, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Functions"))
        self.tableWidget_SymbolInfo.setSortingEnabled(True)
        item = self.tableWidget_SymbolInfo.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Address"))
        item = self.tableWidget_SymbolInfo.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Symbol"))
        self.lineEdit_SearchInput.setPlaceholderText(_translate("Form", "Enter the regex. Leave blank to see all functions"))
        self.checkBox_CaseSensitive.setToolTip(_translate("Form", "Ignore case if checked"))
        self.checkBox_CaseSensitive.setText(_translate("Form", "Case sensitive"))
        self.pushButton_Search.setText(_translate("Form", "Search(Enter)"))


```

`GUI/FunctionsInfoWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>640</width>
    <height>555</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Functions</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="2" column="0">
    <widget class="QTableWidget" name="tableWidget_SymbolInfo">
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>20</number>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>20</number>
     </attribute>
     <column>
      <property name="text">
       <string>Address</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Symbol</string>
      </property>
     </column>
    </widget>
   </item>
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLineEdit" name="lineEdit_SearchInput">
       <property name="placeholderText">
        <string>Enter the regex. Leave blank to see all functions</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_CaseSensitive">
       <property name="toolTip">
        <string>Ignore case if checked</string>
       </property>
       <property name="text">
        <string>Case sensitive</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Search">
       <property name="text">
        <string>Search(Enter)</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Help">
       <property name="text">
        <string/>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <widget class="QTextBrowser" name="textBrowser_AddressInfo"/>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/HandleSignalsDialog.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'HandleSignalsDialog.ui'
#
# Created by: PyQt5 UI code generator 5.14.1
#
# WARNING! All changes made in this file will be lost!


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(268, 244)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.tableWidget_Signals = QtWidgets.QTableWidget(Dialog)
        self.tableWidget_Signals.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_Signals.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_Signals.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_Signals.setObjectName("tableWidget_Signals")
        self.tableWidget_Signals.setColumnCount(2)
        self.tableWidget_Signals.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Signals.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Signals.setHorizontalHeaderItem(1, item)
        self.tableWidget_Signals.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Signals.verticalHeader().setVisible(False)
        self.tableWidget_Signals.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Signals.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout.addWidget(self.tableWidget_Signals, 0, 0, 1, 1)
        self.buttonBox = QtWidgets.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 1, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.rejected.connect(Dialog.reject)
        self.buttonBox.accepted.connect(Dialog.accept)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Handle Signals"))
        item = self.tableWidget_Signals.horizontalHeaderItem(0)
        item.setText(_translate("Dialog", "Signal"))
        item = self.tableWidget_Signals.horizontalHeaderItem(1)
        item.setText(_translate("Dialog", "Ignore"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(Dialog)
    Dialog.show()
    sys.exit(app.exec_())

```

`GUI/HandleSignalsDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>268</width>
    <height>244</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Handle Signals</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QTableWidget" name="tableWidget_Signals">
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>16</number>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>16</number>
     </attribute>
     <column>
      <property name="text">
       <string>Signal</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Ignore</string>
      </property>
     </column>
    </widget>
   </item>
   <item row="1" column="0">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/HexEditDialog.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'HexEditDialog.ui'
#
# Created: Fri Dec  9 21:31:02 2016
#      by: PyQt5 UI code generator 5.2.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(515, 138)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(Dialog)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.lineEdit_Address = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_Address.setObjectName("lineEdit_Address")
        self.horizontalLayout.addWidget(self.lineEdit_Address)
        self.label_2 = QtWidgets.QLabel(Dialog)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout.addWidget(self.label_2)
        self.lineEdit_Length = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_Length.setObjectName("lineEdit_Length")
        self.horizontalLayout.addWidget(self.lineEdit_Length)
        self.pushButton_Refresh = QtWidgets.QPushButton(Dialog)
        self.pushButton_Refresh.setObjectName("pushButton_Refresh")
        self.horizontalLayout.addWidget(self.pushButton_Refresh)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        self.lineEdit_AsciiView = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_AsciiView.setObjectName("lineEdit_AsciiView")
        self.gridLayout.addWidget(self.lineEdit_AsciiView, 1, 0, 1, 1)
        self.lineEdit_HexView = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_HexView.setObjectName("lineEdit_HexView")
        self.gridLayout.addWidget(self.lineEdit_HexView, 2, 0, 1, 1)
        self.buttonBox = QtWidgets.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 3, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept)
        self.buttonBox.rejected.connect(Dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Hex Edit"))
        self.label.setText(_translate("Dialog", "Address:"))
        self.label_2.setText(_translate("Dialog", "Length:"))
        self.pushButton_Refresh.setText(_translate("Dialog", "Refresh"))


```

`GUI/HexEditDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>515</width>
    <height>138</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Hex Edit</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Address:</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_Address"/>
     </item>
     <item>
      <widget class="QLabel" name="label_2">
       <property name="text">
        <string>Length:</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_Length"/>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Refresh">
       <property name="text">
        <string>Refresh</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <widget class="QLineEdit" name="lineEdit_AsciiView"/>
   </item>
   <item row="2" column="0">
    <widget class="QLineEdit" name="lineEdit_HexView"/>
   </item>
   <item row="3" column="0">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/InputDialog.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'InputDialog.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(188, 48)
        Dialog.setWindowTitle("")
        self.horizontalLayout = QtWidgets.QHBoxLayout(Dialog)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.buttonBox = QtWidgets.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.NoButton)
        self.buttonBox.setCenterButtons(True)
        self.buttonBox.setObjectName("buttonBox")
        self.verticalLayout.addWidget(self.buttonBox)
        self.horizontalLayout.addLayout(self.verticalLayout)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept)
        self.buttonBox.rejected.connect(Dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        pass


```

`GUI/InputDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>188</width>
    <height>48</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string/>
  </property>
  <layout class="QHBoxLayout" name="horizontalLayout">
   <item>
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QDialogButtonBox" name="buttonBox">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="standardButtons">
        <set>QDialogButtonBox::NoButton</set>
       </property>
       <property name="centerButtons">
        <bool>true</bool>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/LibpinceReferenceWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'LibpinceReferenceWidget.ui'
#
# Created by: PyQt5 UI code generator 5.14.1
#
# WARNING! All changes made in this file will be lost!


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(887, 569)
        self.gridLayout_2 = QtWidgets.QGridLayout(Form)
        self.gridLayout_2.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_2.setSpacing(0)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.splitter = QtWidgets.QSplitter(Form)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setHandleWidth(10)
        self.splitter.setObjectName("splitter")
        self.widget_TypeDefs = QtWidgets.QWidget(self.splitter)
        self.widget_TypeDefs.setObjectName("widget_TypeDefs")
        self.gridLayout = QtWidgets.QGridLayout(self.widget_TypeDefs)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.label_5 = QtWidgets.QLabel(self.widget_TypeDefs)
        self.label_5.setObjectName("label_5")
        self.horizontalLayout_4.addWidget(self.label_5)
        self.line = QtWidgets.QFrame(self.widget_TypeDefs)
        self.line.setFrameShape(QtWidgets.QFrame.VLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")
        self.horizontalLayout_4.addWidget(self.line)
        self.label_3 = QtWidgets.QLabel(self.widget_TypeDefs)
        self.label_3.setObjectName("label_3")
        self.horizontalLayout_4.addWidget(self.label_3)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem)
        self.gridLayout.addLayout(self.horizontalLayout_4, 0, 0, 1, 1)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.lineEdit_SearchText = QtWidgets.QLineEdit(self.widget_TypeDefs)
        self.lineEdit_SearchText.setObjectName("lineEdit_SearchText")
        self.horizontalLayout_2.addWidget(self.lineEdit_SearchText)
        self.pushButton_TextUp = QtWidgets.QPushButton(self.widget_TypeDefs)
        self.pushButton_TextUp.setText("")
        self.pushButton_TextUp.setObjectName("pushButton_TextUp")
        self.horizontalLayout_2.addWidget(self.pushButton_TextUp)
        self.pushButton_TextDown = QtWidgets.QPushButton(self.widget_TypeDefs)
        self.pushButton_TextDown.setText("")
        self.pushButton_TextDown.setObjectName("pushButton_TextDown")
        self.horizontalLayout_2.addWidget(self.pushButton_TextDown)
        self.label_FoundCount = QtWidgets.QLabel(self.widget_TypeDefs)
        self.label_FoundCount.setObjectName("label_FoundCount")
        self.horizontalLayout_2.addWidget(self.label_FoundCount)
        self.gridLayout.addLayout(self.horizontalLayout_2, 1, 0, 1, 1)
        self.textBrowser_TypeDefs = QtWidgets.QTextBrowser(self.widget_TypeDefs)
        self.textBrowser_TypeDefs.setObjectName("textBrowser_TypeDefs")
        self.gridLayout.addWidget(self.textBrowser_TypeDefs, 2, 0, 1, 1)
        self.widget_Resources = QtWidgets.QWidget(self.splitter)
        self.widget_Resources.setObjectName("widget_Resources")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.widget_Resources)
        self.gridLayout_3.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.stackedWidget_Resources = QtWidgets.QStackedWidget(self.widget_Resources)
        self.stackedWidget_Resources.setObjectName("stackedWidget_Resources")
        self.page = QtWidgets.QWidget()
        self.page.setObjectName("page")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.page)
        self.gridLayout_4.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_4.setSpacing(0)
        self.gridLayout_4.setObjectName("gridLayout_4")
        self.treeWidget_ResourceTree = QtWidgets.QTreeWidget(self.page)
        self.treeWidget_ResourceTree.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.treeWidget_ResourceTree.setObjectName("treeWidget_ResourceTree")
        self.treeWidget_ResourceTree.headerItem().setText(0, "Item Name")
        self.gridLayout_4.addWidget(self.treeWidget_ResourceTree, 0, 0, 1, 1)
        self.stackedWidget_Resources.addWidget(self.page)
        self.page_2 = QtWidgets.QWidget()
        self.page_2.setObjectName("page_2")
        self.gridLayout_5 = QtWidgets.QGridLayout(self.page_2)
        self.gridLayout_5.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_5.setSpacing(0)
        self.gridLayout_5.setObjectName("gridLayout_5")
        self.tableWidget_ResourceTable = QtWidgets.QTableWidget(self.page_2)
        self.tableWidget_ResourceTable.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_ResourceTable.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_ResourceTable.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_ResourceTable.setObjectName("tableWidget_ResourceTable")
        self.tableWidget_ResourceTable.setColumnCount(2)
        self.tableWidget_ResourceTable.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_ResourceTable.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_ResourceTable.setHorizontalHeaderItem(1, item)
        self.tableWidget_ResourceTable.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_ResourceTable.verticalHeader().setVisible(False)
        self.tableWidget_ResourceTable.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_ResourceTable.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout_5.addWidget(self.tableWidget_ResourceTable, 0, 0, 1, 1)
        self.stackedWidget_Resources.addWidget(self.page_2)
        self.gridLayout_3.addWidget(self.stackedWidget_Resources, 2, 0, 1, 1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label_4 = QtWidgets.QLabel(self.widget_Resources)
        self.label_4.setObjectName("label_4")
        self.verticalLayout_2.addWidget(self.label_4)
        self.lineEdit_Search = QtWidgets.QLineEdit(self.widget_Resources)
        self.lineEdit_Search.setObjectName("lineEdit_Search")
        self.verticalLayout_2.addWidget(self.lineEdit_Search)
        self.horizontalLayout.addLayout(self.verticalLayout_2)
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(self.widget_Resources)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.comboBox_SourceFile = QtWidgets.QComboBox(self.widget_Resources)
        self.comboBox_SourceFile.setObjectName("comboBox_SourceFile")
        self.verticalLayout.addWidget(self.comboBox_SourceFile)
        self.horizontalLayout.addLayout(self.verticalLayout)
        self.gridLayout_3.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.label_2 = QtWidgets.QLabel(self.widget_Resources)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_3.addWidget(self.label_2)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem1)
        self.pushButton_ShowTypeDefs = QtWidgets.QPushButton(self.widget_Resources)
        self.pushButton_ShowTypeDefs.setObjectName("pushButton_ShowTypeDefs")
        self.horizontalLayout_3.addWidget(self.pushButton_ShowTypeDefs)
        self.gridLayout_3.addLayout(self.horizontalLayout_3, 1, 0, 1, 1)
        self.gridLayout_2.addWidget(self.splitter, 0, 0, 1, 1)

        self.retranslateUi(Form)
        self.stackedWidget_Resources.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "libpince Reference"))
        self.label_5.setText(_translate("Form", "Search"))
        self.label_3.setText(_translate("Form", "type_defs(Type Definitions)"))
        self.label_FoundCount.setText(_translate("Form", "0/0"))
        self.treeWidget_ResourceTree.headerItem().setText(1, _translate("Form", "Value"))
        self.tableWidget_ResourceTable.setSortingEnabled(True)
        item = self.tableWidget_ResourceTable.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Item Name"))
        item = self.tableWidget_ResourceTable.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Value"))
        self.label_4.setText(_translate("Form", "Search"))
        self.label.setText(_translate("Form", "Source File"))
        self.label_2.setText(_translate("Form", "Resources(Mouse-over items to see docstrings)"))
        self.pushButton_ShowTypeDefs.setText(_translate("Form", "Hide type_defs"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Form = QtWidgets.QWidget()
    ui = Ui_Form()
    ui.setupUi(Form)
    Form.show()
    sys.exit(app.exec_())

```

`GUI/LibpinceReferenceWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>887</width>
    <height>569</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>libpince Reference</string>
  </property>
  <layout class="QGridLayout" name="gridLayout_2">
   <property name="leftMargin">
    <number>0</number>
   </property>
   <property name="topMargin">
    <number>0</number>
   </property>
   <property name="rightMargin">
    <number>0</number>
   </property>
   <property name="bottomMargin">
    <number>0</number>
   </property>
   <property name="spacing">
    <number>0</number>
   </property>
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="handleWidth">
      <number>10</number>
     </property>
     <widget class="QWidget" name="widget_TypeDefs" native="true">
      <layout class="QGridLayout" name="gridLayout">
       <property name="rightMargin">
        <number>0</number>
       </property>
       <item row="0" column="0">
        <layout class="QHBoxLayout" name="horizontalLayout_4">
         <item>
          <widget class="QLabel" name="label_5">
           <property name="text">
            <string>Search</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="Line" name="line">
           <property name="orientation">
            <enum>Qt::Vertical</enum>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLabel" name="label_3">
           <property name="text">
            <string>type_defs(Type Definitions)</string>
           </property>
          </widget>
         </item>
         <item>
          <spacer name="horizontalSpacer">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>40</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
        </layout>
       </item>
       <item row="1" column="0">
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <item>
          <widget class="QLineEdit" name="lineEdit_SearchText"/>
         </item>
         <item>
          <widget class="QPushButton" name="pushButton_TextUp">
           <property name="text">
            <string/>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="pushButton_TextDown">
           <property name="text">
            <string/>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLabel" name="label_FoundCount">
           <property name="text">
            <string>0/0</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item row="2" column="0">
        <widget class="QTextBrowser" name="textBrowser_TypeDefs"/>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="widget_Resources" native="true">
      <layout class="QGridLayout" name="gridLayout_3">
       <property name="leftMargin">
        <number>0</number>
       </property>
       <item row="2" column="0">
        <widget class="QStackedWidget" name="stackedWidget_Resources">
         <property name="currentIndex">
          <number>0</number>
         </property>
         <widget class="QWidget" name="page">
          <layout class="QGridLayout" name="gridLayout_4">
           <property name="leftMargin">
            <number>0</number>
           </property>
           <property name="topMargin">
            <number>0</number>
           </property>
           <property name="rightMargin">
            <number>0</number>
           </property>
           <property name="bottomMargin">
            <number>0</number>
           </property>
           <property name="spacing">
            <number>0</number>
           </property>
           <item row="0" column="0">
            <widget class="QTreeWidget" name="treeWidget_ResourceTree">
             <property name="editTriggers">
              <set>QAbstractItemView::NoEditTriggers</set>
             </property>
             <column>
              <property name="text">
               <string notr="true">Item Name</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Value</string>
              </property>
             </column>
            </widget>
           </item>
          </layout>
         </widget>
         <widget class="QWidget" name="page_2">
          <layout class="QGridLayout" name="gridLayout_5">
           <property name="leftMargin">
            <number>0</number>
           </property>
           <property name="topMargin">
            <number>0</number>
           </property>
           <property name="rightMargin">
            <number>0</number>
           </property>
           <property name="bottomMargin">
            <number>0</number>
           </property>
           <property name="spacing">
            <number>0</number>
           </property>
           <item row="0" column="0">
            <widget class="QTableWidget" name="tableWidget_ResourceTable">
             <property name="editTriggers">
              <set>QAbstractItemView::NoEditTriggers</set>
             </property>
             <property name="selectionMode">
              <enum>QAbstractItemView::SingleSelection</enum>
             </property>
             <property name="selectionBehavior">
              <enum>QAbstractItemView::SelectRows</enum>
             </property>
             <property name="sortingEnabled">
              <bool>true</bool>
             </property>
             <attribute name="horizontalHeaderStretchLastSection">
              <bool>true</bool>
             </attribute>
             <attribute name="verticalHeaderVisible">
              <bool>false</bool>
             </attribute>
             <attribute name="verticalHeaderMinimumSectionSize">
              <number>16</number>
             </attribute>
             <attribute name="verticalHeaderDefaultSectionSize">
              <number>16</number>
             </attribute>
             <column>
              <property name="text">
               <string>Item Name</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Value</string>
              </property>
             </column>
            </widget>
           </item>
          </layout>
         </widget>
        </widget>
       </item>
       <item row="0" column="0">
        <layout class="QHBoxLayout" name="horizontalLayout">
         <item>
          <layout class="QVBoxLayout" name="verticalLayout_2">
           <item>
            <widget class="QLabel" name="label_4">
             <property name="text">
              <string>Search</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QLineEdit" name="lineEdit_Search"/>
           </item>
          </layout>
         </item>
         <item>
          <layout class="QVBoxLayout" name="verticalLayout">
           <item>
            <widget class="QLabel" name="label">
             <property name="text">
              <string>Source File</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QComboBox" name="comboBox_SourceFile"/>
           </item>
          </layout>
         </item>
        </layout>
       </item>
       <item row="1" column="0">
        <layout class="QHBoxLayout" name="horizontalLayout_3">
         <item>
          <widget class="QLabel" name="label_2">
           <property name="text">
            <string>Resources(Mouse-over items to see docstrings)</string>
           </property>
          </widget>
         </item>
         <item>
          <spacer name="horizontalSpacer_2">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>40</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
         <item>
          <widget class="QPushButton" name="pushButton_ShowTypeDefs">
           <property name="text">
            <string>Hide type_defs</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/LoadingDialog.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'LoadingDialog.ui'
#
# Created: Tue Feb 21 22:38:30 2017
#      by: PyQt5 UI code generator 5.2.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(208, 89)
        self.gridLayout_2 = QtWidgets.QGridLayout(Dialog)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.label_Animated = QtWidgets.QLabel(Dialog)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_Animated.sizePolicy().hasHeightForWidth())
        self.label_Animated.setSizePolicy(sizePolicy)
        self.label_Animated.setText("")
        self.label_Animated.setScaledContents(False)
        self.label_Animated.setObjectName("label_Animated")
        self.horizontalLayout.addWidget(self.label_Animated)
        self.label_StatusText = QtWidgets.QLabel(Dialog)
        self.label_StatusText.setObjectName("label_StatusText")
        self.horizontalLayout.addWidget(self.label_StatusText)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.gridLayout_2.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        self.widget_Cancel = QtWidgets.QWidget(Dialog)
        self.widget_Cancel.setObjectName("widget_Cancel")
        self.gridLayout = QtWidgets.QGridLayout(self.widget_Cancel)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setObjectName("gridLayout")
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem2, 0, 0, 1, 1)
        self.pushButton_Cancel = QtWidgets.QPushButton(self.widget_Cancel)
        self.pushButton_Cancel.setObjectName("pushButton_Cancel")
        self.gridLayout.addWidget(self.pushButton_Cancel, 0, 1, 1, 1)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem3, 0, 2, 1, 1)
        self.gridLayout_2.addWidget(self.widget_Cancel, 1, 0, 1, 1)

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
        self.label_StatusText.setText(_translate("Dialog", "Processing"))
        self.pushButton_Cancel.setText(_translate("Dialog", "Cancel"))


```

`GUI/LoadingDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>208</width>
    <height>89</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QGridLayout" name="gridLayout_2">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QLabel" name="label_Animated">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="scaledContents">
        <bool>false</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLabel" name="label_StatusText">
       <property name="text">
        <string>Processing</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_2">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <widget class="QWidget" name="widget_Cancel" native="true">
     <layout class="QGridLayout" name="gridLayout">
      <item row="0" column="0">
       <spacer name="horizontalSpacer_3">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item row="0" column="1">
       <widget class="QPushButton" name="pushButton_Cancel">
        <property name="text">
         <string>Cancel</string>
        </property>
       </widget>
      </item>
      <item row="0" column="2">
       <spacer name="horizontalSpacer_4">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
     </layout>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/LogFileWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'LogFileWidget.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(582, 558)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label_FilePath = QtWidgets.QLabel(Form)
        self.label_FilePath.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_FilePath.setObjectName("label_FilePath")
        self.horizontalLayout.addWidget(self.label_FilePath)
        self.label_LoggingStatus = QtWidgets.QLabel(Form)
        self.label_LoggingStatus.setObjectName("label_LoggingStatus")
        self.horizontalLayout.addWidget(self.label_LoggingStatus)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        self.textBrowser_LogContent = QtWidgets.QTextBrowser(Form)
        self.textBrowser_LogContent.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
        self.textBrowser_LogContent.setObjectName("textBrowser_LogContent")
        self.gridLayout.addWidget(self.textBrowser_LogContent, 1, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        self.label_FilePath.setText(_translate("Form", "TextLabel"))
        self.label_LoggingStatus.setText(_translate("Form", "TextLabel"))


```

`GUI/LogFileWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>582</width>
    <height>558</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="label_FilePath">
       <property name="text">
        <string>TextLabel</string>
       </property>
       <property name="textInteractionFlags">
        <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLabel" name="label_LoggingStatus">
       <property name="text">
        <string>TextLabel</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <widget class="QTextBrowser" name="textBrowser_LogContent">
     <property name="lineWrapMode">
      <enum>QTextEdit::NoWrap</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/MainWindow.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'MainWindow.ui'
#
# Created by: PyQt5 UI code generator 5.14.1
#
# WARNING! All changes made in this file will be lost!


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(678, 636)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.treeWidget_AddressTable = QtWidgets.QTreeWidget(self.centralwidget)
        self.treeWidget_AddressTable.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.treeWidget_AddressTable.setDragDropMode(QtWidgets.QAbstractItemView.DragDrop)
        self.treeWidget_AddressTable.setDefaultDropAction(QtCore.Qt.MoveAction)
        self.treeWidget_AddressTable.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.treeWidget_AddressTable.setIndentation(12)
        self.treeWidget_AddressTable.setExpandsOnDoubleClick(False)
        self.treeWidget_AddressTable.setObjectName("treeWidget_AddressTable")
        self.gridLayout.addWidget(self.treeWidget_AddressTable, 3, 0, 1, 1)
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setSizeConstraint(QtWidgets.QLayout.SetMinAndMaxSize)
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.pushButton_MemoryView = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_MemoryView.setObjectName("pushButton_MemoryView")
        self.horizontalLayout_8.addWidget(self.pushButton_MemoryView)
        spacerItem = QtWidgets.QSpacerItem(120, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_8.addItem(spacerItem)
        self.pushButton_CopyToAddressTable = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_CopyToAddressTable.setText("")
        self.pushButton_CopyToAddressTable.setObjectName("pushButton_CopyToAddressTable")
        self.horizontalLayout_8.addWidget(self.pushButton_CopyToAddressTable)
        self.pushButton_CleanAddressTable = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_CleanAddressTable.setText("")
        self.pushButton_CleanAddressTable.setObjectName("pushButton_CleanAddressTable")
        self.horizontalLayout_8.addWidget(self.pushButton_CleanAddressTable)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_8.addItem(spacerItem1)
        self.pushButton_RefreshAdressTable = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_RefreshAdressTable.setText("")
        self.pushButton_RefreshAdressTable.setObjectName("pushButton_RefreshAdressTable")
        self.horizontalLayout_8.addWidget(self.pushButton_RefreshAdressTable)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_8.addItem(spacerItem2)
        self.pushButton_AddAddressManually = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_AddAddressManually.setObjectName("pushButton_AddAddressManually")
        self.horizontalLayout_8.addWidget(self.pushButton_AddAddressManually)
        self.gridLayout.addLayout(self.horizontalLayout_8, 2, 0, 1, 1)
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setSizeConstraint(QtWidgets.QLayout.SetFixedSize)
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.pushButton_AttachProcess = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pushButton_AttachProcess.sizePolicy().hasHeightForWidth())
        self.pushButton_AttachProcess.setSizePolicy(sizePolicy)
        self.pushButton_AttachProcess.setText("")
        self.pushButton_AttachProcess.setObjectName("pushButton_AttachProcess")
        self.horizontalLayout_5.addWidget(self.pushButton_AttachProcess)
        self.pushButton_Open = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pushButton_Open.sizePolicy().hasHeightForWidth())
        self.pushButton_Open.setSizePolicy(sizePolicy)
        self.pushButton_Open.setText("")
        self.pushButton_Open.setObjectName("pushButton_Open")
        self.horizontalLayout_5.addWidget(self.pushButton_Open)
        self.pushButton_Save = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pushButton_Save.sizePolicy().hasHeightForWidth())
        self.pushButton_Save.setSizePolicy(sizePolicy)
        self.pushButton_Save.setText("")
        self.pushButton_Save.setObjectName("pushButton_Save")
        self.horizontalLayout_5.addWidget(self.pushButton_Save)
        self.pushButton_Wiki = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_Wiki.setText("")
        self.pushButton_Wiki.setObjectName("pushButton_Wiki")
        self.horizontalLayout_5.addWidget(self.pushButton_Wiki)
        self.pushButton_About = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_About.setText("")
        self.pushButton_About.setObjectName("pushButton_About")
        self.horizontalLayout_5.addWidget(self.pushButton_About)
        self.label_SelectedProcess = QtWidgets.QLabel(self.centralwidget)
        self.label_SelectedProcess.setObjectName("label_SelectedProcess")
        self.horizontalLayout_5.addWidget(self.label_SelectedProcess)
        self.label_InferiorStatus = QtWidgets.QLabel(self.centralwidget)
        self.label_InferiorStatus.setText("")
        self.label_InferiorStatus.setObjectName("label_InferiorStatus")
        self.horizontalLayout_5.addWidget(self.label_InferiorStatus)
        self.progressBar = QtWidgets.QProgressBar(self.centralwidget)
        self.progressBar.setProperty("value", 0)
        self.progressBar.setOrientation(QtCore.Qt.Horizontal)
        self.progressBar.setObjectName("progressBar")
        self.horizontalLayout_5.addWidget(self.progressBar)
        self.pushButton_Console = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_Console.setText("")
        self.pushButton_Console.setObjectName("pushButton_Console")
        self.horizontalLayout_5.addWidget(self.pushButton_Console)
        self.pushButton_Settings = QtWidgets.QPushButton(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pushButton_Settings.sizePolicy().hasHeightForWidth())
        self.pushButton_Settings.setSizePolicy(sizePolicy)
        self.pushButton_Settings.setText("")
        self.pushButton_Settings.setObjectName("pushButton_Settings")
        self.horizontalLayout_5.addWidget(self.pushButton_Settings)
        self.gridLayout.addLayout(self.horizontalLayout_5, 0, 0, 1, 1)
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout()
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.label_MatchCount = QtWidgets.QLabel(self.centralwidget)
        self.label_MatchCount.setObjectName("label_MatchCount")
        self.verticalLayout_6.addWidget(self.label_MatchCount)
        self.tableWidget_valuesearchtable = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget_valuesearchtable.setEnabled(True)
        self.tableWidget_valuesearchtable.setAutoFillBackground(False)
        self.tableWidget_valuesearchtable.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.tableWidget_valuesearchtable.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_valuesearchtable.setAlternatingRowColors(True)
        self.tableWidget_valuesearchtable.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.tableWidget_valuesearchtable.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_valuesearchtable.setShowGrid(False)
        self.tableWidget_valuesearchtable.setObjectName("tableWidget_valuesearchtable")
        self.tableWidget_valuesearchtable.setColumnCount(3)
        self.tableWidget_valuesearchtable.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_valuesearchtable.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_valuesearchtable.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_valuesearchtable.setHorizontalHeaderItem(2, item)
        self.tableWidget_valuesearchtable.horizontalHeader().setSortIndicatorShown(True)
        self.tableWidget_valuesearchtable.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_valuesearchtable.verticalHeader().setVisible(False)
        self.tableWidget_valuesearchtable.verticalHeader().setDefaultSectionSize(23)
        self.tableWidget_valuesearchtable.verticalHeader().setMinimumSectionSize(20)
        self.verticalLayout_6.addWidget(self.tableWidget_valuesearchtable)
        self.horizontalLayout_9.addLayout(self.verticalLayout_6)
        self.QWidget_Toolbox = QtWidgets.QWidget(self.centralwidget)
        self.QWidget_Toolbox.setEnabled(True)
        self.QWidget_Toolbox.setObjectName("QWidget_Toolbox")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.QWidget_Toolbox)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.pushButton_NewFirstScan = QtWidgets.QPushButton(self.QWidget_Toolbox)
        self.pushButton_NewFirstScan.setObjectName("pushButton_NewFirstScan")
        self.horizontalLayout_6.addWidget(self.pushButton_NewFirstScan)
        self.pushButton_NextScan = QtWidgets.QPushButton(self.QWidget_Toolbox)
        self.pushButton_NextScan.setObjectName("pushButton_NextScan")
        self.horizontalLayout_6.addWidget(self.pushButton_NextScan)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_6.addItem(spacerItem3)
        self.pushButton_UndoScan = QtWidgets.QPushButton(self.QWidget_Toolbox)
        self.pushButton_UndoScan.setObjectName("pushButton_UndoScan")
        self.horizontalLayout_6.addWidget(self.pushButton_UndoScan)
        self.verticalLayout_5.addLayout(self.horizontalLayout_6)
        self.widget_Scan = QtWidgets.QWidget(self.QWidget_Toolbox)
        self.widget_Scan.setObjectName("widget_Scan")
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout(self.widget_Scan)
        self.horizontalLayout_7.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.widget_3 = QtWidgets.QWidget(self.widget_Scan)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_3.sizePolicy().hasHeightForWidth())
        self.widget_3.setSizePolicy(sizePolicy)
        self.widget_3.setObjectName("widget_3")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.widget_3)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setSpacing(0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.radioButton_Bits = QtWidgets.QRadioButton(self.widget_3)
        self.radioButton_Bits.setObjectName("radioButton_Bits")
        self.verticalLayout_2.addWidget(self.radioButton_Bits)
        self.radioButton_Decimal = QtWidgets.QRadioButton(self.widget_3)
        self.radioButton_Decimal.setObjectName("radioButton_Decimal")
        self.verticalLayout_2.addWidget(self.radioButton_Decimal)
        self.checkBox_Hex = QtWidgets.QCheckBox(self.widget_3)
        self.checkBox_Hex.setObjectName("checkBox_Hex")
        self.verticalLayout_2.addWidget(self.checkBox_Hex)
        self.horizontalLayout_7.addWidget(self.widget_3)
        self.lineEdit_Scan = QtWidgets.QLineEdit(self.widget_Scan)
        self.lineEdit_Scan.setObjectName("lineEdit_Scan")
        self.horizontalLayout_7.addWidget(self.lineEdit_Scan)
        self.label_Between = QtWidgets.QLabel(self.widget_Scan)
        self.label_Between.setObjectName("label_Between")
        self.horizontalLayout_7.addWidget(self.label_Between)
        self.lineEdit_Scan2 = QtWidgets.QLineEdit(self.widget_Scan)
        self.lineEdit_Scan2.setObjectName("lineEdit_Scan2")
        self.horizontalLayout_7.addWidget(self.lineEdit_Scan2)
        self.verticalLayout_5.addWidget(self.widget_Scan)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.widget = QtWidgets.QWidget(self.QWidget_Toolbox)
        self.widget.setObjectName("widget")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.widget)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label = QtWidgets.QLabel(self.widget)
        self.label.setObjectName("label")
        self.horizontalLayout_2.addWidget(self.label)
        self.comboBox_ScanType = QtWidgets.QComboBox(self.widget)
        self.comboBox_ScanType.setObjectName("comboBox_ScanType")
        self.horizontalLayout_2.addWidget(self.comboBox_ScanType)
        self.verticalLayout_4.addLayout(self.horizontalLayout_2)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label_2 = QtWidgets.QLabel(self.widget)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout.addWidget(self.label_2)
        self.comboBox_ValueType = QtWidgets.QComboBox(self.widget)
        self.comboBox_ValueType.setObjectName("comboBox_ValueType")
        self.horizontalLayout.addWidget(self.comboBox_ValueType)
        self.verticalLayout_4.addLayout(self.horizontalLayout)
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.label_ScanScope = QtWidgets.QLabel(self.widget)
        self.label_ScanScope.setObjectName("label_ScanScope")
        self.horizontalLayout_10.addWidget(self.label_ScanScope)
        self.comboBox_ScanScope = QtWidgets.QComboBox(self.widget)
        self.comboBox_ScanScope.setObjectName("comboBox_ScanScope")
        self.horizontalLayout_10.addWidget(self.comboBox_ScanScope)
        self.verticalLayout_4.addLayout(self.horizontalLayout_10)
        spacerItem4 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_4.addItem(spacerItem4)
        self.horizontalLayout_4.addWidget(self.widget)
        self.widget_2 = QtWidgets.QWidget(self.QWidget_Toolbox)
        self.widget_2.setObjectName("widget_2")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.widget_2)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setSpacing(0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.radioButton_RoundedDefault = QtWidgets.QRadioButton(self.widget_2)
        self.radioButton_RoundedDefault.setEnabled(False)
        self.radioButton_RoundedDefault.setObjectName("radioButton_RoundedDefault")
        self.verticalLayout.addWidget(self.radioButton_RoundedDefault)
        self.radioButton_RoundedExtreme = QtWidgets.QRadioButton(self.widget_2)
        self.radioButton_RoundedExtreme.setEnabled(False)
        self.radioButton_RoundedExtreme.setObjectName("radioButton_RoundedExtreme")
        self.verticalLayout.addWidget(self.radioButton_RoundedExtreme)
        self.radioButton_Truncated = QtWidgets.QRadioButton(self.widget_2)
        self.radioButton_Truncated.setEnabled(False)
        self.radioButton_Truncated.setObjectName("radioButton_Truncated")
        self.verticalLayout.addWidget(self.radioButton_Truncated)
        self.checkBox_Unicode = QtWidgets.QCheckBox(self.widget_2)
        self.checkBox_Unicode.setEnabled(False)
        self.checkBox_Unicode.setObjectName("checkBox_Unicode")
        self.verticalLayout.addWidget(self.checkBox_Unicode)
        self.checkBox_CaseSensitive = QtWidgets.QCheckBox(self.widget_2)
        self.checkBox_CaseSensitive.setEnabled(False)
        self.checkBox_CaseSensitive.setObjectName("checkBox_CaseSensitive")
        self.verticalLayout.addWidget(self.checkBox_CaseSensitive)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        spacerItem5 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_3.addItem(spacerItem5)
        self.checkBox_Unrandomizer = QtWidgets.QCheckBox(self.widget_2)
        self.checkBox_Unrandomizer.setEnabled(False)
        self.checkBox_Unrandomizer.setObjectName("checkBox_Unrandomizer")
        self.verticalLayout_3.addWidget(self.checkBox_Unrandomizer)
        self.verticalLayout.addLayout(self.verticalLayout_3)
        self.horizontalLayout_4.addWidget(self.widget_2)
        self.verticalLayout_5.addLayout(self.horizontalLayout_4)
        self.horizontalLayout_9.addWidget(self.QWidget_Toolbox)
        self.gridLayout.addLayout(self.horizontalLayout_9, 1, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 678, 30))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "PINCE"))
        self.treeWidget_AddressTable.headerItem().setText(0, _translate("MainWindow", "Freeze"))
        self.treeWidget_AddressTable.headerItem().setToolTip(0, _translate("MainWindow", "Freeze the value"))
        self.treeWidget_AddressTable.headerItem().setText(1, _translate("MainWindow", "Description"))
        self.treeWidget_AddressTable.headerItem().setText(2, _translate("MainWindow", "Address"))
        self.treeWidget_AddressTable.headerItem().setText(3, _translate("MainWindow", "Type"))
        self.treeWidget_AddressTable.headerItem().setText(4, _translate("MainWindow", "Value"))
        self.pushButton_MemoryView.setText(_translate("MainWindow", "Memory View"))
        self.pushButton_CopyToAddressTable.setToolTip(_translate("MainWindow", "Copy selected items to the address table"))
        self.pushButton_CleanAddressTable.setToolTip(_translate("MainWindow", "Erase all the table contents"))
        self.pushButton_RefreshAdressTable.setToolTip(_translate("MainWindow", "Refresh the address table[R]"))
        self.pushButton_AddAddressManually.setText(_translate("MainWindow", "Add Address Manually"))
        self.pushButton_AttachProcess.setToolTip(_translate("MainWindow", "Create or attach to a process"))
        self.pushButton_Open.setToolTip(_translate("MainWindow", "Open a cheat table"))
        self.pushButton_Save.setToolTip(_translate("MainWindow", "Save current table to a file"))
        self.pushButton_Wiki.setToolTip(_translate("MainWindow", "Wiki"))
        self.pushButton_About.setToolTip(_translate("MainWindow", "About"))
        self.label_SelectedProcess.setText(_translate("MainWindow", "No Process Selected"))
        self.pushButton_Console.setToolTip(_translate("MainWindow", "Open a gdb console"))
        self.pushButton_Settings.setToolTip(_translate("MainWindow", "Configure options"))
        self.label_MatchCount.setText(_translate("MainWindow", "Match count: 0"))
        item = self.tableWidget_valuesearchtable.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow", "Address"))
        item = self.tableWidget_valuesearchtable.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow", "Value"))
        item = self.tableWidget_valuesearchtable.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow", "Previous"))
        self.pushButton_NewFirstScan.setText(_translate("MainWindow", "First Scan"))
        self.pushButton_NextScan.setText(_translate("MainWindow", "Next Scan"))
        self.pushButton_UndoScan.setText(_translate("MainWindow", "Undo Scan"))
        self.radioButton_Bits.setText(_translate("MainWindow", "B&its"))
        self.radioButton_Decimal.setText(_translate("MainWindow", "&Decimal"))
        self.checkBox_Hex.setText(_translate("MainWindow", "Hex"))
        self.label_Between.setText(_translate("MainWindow", "<->"))
        self.label.setText(_translate("MainWindow", "Scan Type:"))
        self.label_2.setText(_translate("MainWindow", "Value Type:"))
        self.label_ScanScope.setText(_translate("MainWindow", "Scan Scope:"))
        self.radioButton_RoundedDefault.setToolTip(_translate("MainWindow", "Not currently supported"))
        self.radioButton_RoundedDefault.setText(_translate("MainWindow", "Ro&unded (Default)"))
        self.radioButton_RoundedExtreme.setToolTip(_translate("MainWindow", "Not currently supported"))
        self.radioButton_RoundedExtreme.setText(_translate("MainWindow", "Rou&nded (Extreme)"))
        self.radioButton_Truncated.setToolTip(_translate("MainWindow", "Not currently supported"))
        self.radioButton_Truncated.setText(_translate("MainWindow", "Truncated"))
        self.checkBox_Unicode.setToolTip(_translate("MainWindow", "Not currently supported"))
        self.checkBox_Unicode.setText(_translate("MainWindow", "Unicode"))
        self.checkBox_CaseSensitive.setToolTip(_translate("MainWindow", "Not currently supported"))
        self.checkBox_CaseSensitive.setText(_translate("MainWindow", "Case Sensitive"))
        self.checkBox_Unrandomizer.setToolTip(_translate("MainWindow", "Not currently supported"))
        self.checkBox_Unrandomizer.setText(_translate("MainWindow", "Unrandomizer"))

```

`GUI/MainWindow.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>678</width>
    <height>636</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>PINCE</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QGridLayout" name="gridLayout">
    <item row="3" column="0">
     <widget class="QTreeWidget" name="treeWidget_AddressTable">
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
      <property name="dragDropMode">
       <enum>QAbstractItemView::DragDrop</enum>
      </property>
      <property name="defaultDropAction">
       <enum>Qt::MoveAction</enum>
      </property>
      <property name="selectionMode">
       <enum>QAbstractItemView::ExtendedSelection</enum>
      </property>
      <property name="indentation">
       <number>12</number>
      </property>
      <property name="expandsOnDoubleClick">
       <bool>false</bool>
      </property>
      <column>
       <property name="text">
        <string>Freeze</string>
       </property>
       <property name="toolTip">
        <string>Freeze the value</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Description</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Address</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Type</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Value</string>
       </property>
      </column>
     </widget>
    </item>
    <item row="2" column="0">
     <layout class="QHBoxLayout" name="horizontalLayout_8">
      <property name="sizeConstraint">
       <enum>QLayout::SetMinAndMaxSize</enum>
      </property>
      <item>
       <widget class="QPushButton" name="pushButton_MemoryView">
        <property name="text">
         <string>Memory View</string>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer_2">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeType">
         <enum>QSizePolicy::Fixed</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>120</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_CopyToAddressTable">
        <property name="toolTip">
         <string>Copy selected items to the address table</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_CleanAddressTable">
        <property name="toolTip">
         <string>Erase all the table contents</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer_7">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_RefreshAdressTable">
        <property name="toolTip">
         <string>Refresh the address table[R]</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer_3">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_AddAddressManually">
        <property name="text">
         <string>Add Address Manually</string>
        </property>
       </widget>
      </item>
     </layout>
    </item>
    <item row="0" column="0">
     <layout class="QHBoxLayout" name="horizontalLayout_5">
      <property name="sizeConstraint">
       <enum>QLayout::SetFixedSize</enum>
      </property>
      <item>
       <widget class="QPushButton" name="pushButton_AttachProcess">
        <property name="sizePolicy">
         <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
          <horstretch>0</horstretch>
          <verstretch>0</verstretch>
         </sizepolicy>
        </property>
        <property name="toolTip">
         <string>Create or attach to a process</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Open">
        <property name="sizePolicy">
         <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
          <horstretch>0</horstretch>
          <verstretch>0</verstretch>
         </sizepolicy>
        </property>
        <property name="toolTip">
         <string>Open a cheat table</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Save">
        <property name="sizePolicy">
         <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
          <horstretch>0</horstretch>
          <verstretch>0</verstretch>
         </sizepolicy>
        </property>
        <property name="toolTip">
         <string>Save current table to a file</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Wiki">
        <property name="toolTip">
         <string>Wiki</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_About">
        <property name="toolTip">
         <string>About</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QLabel" name="label_SelectedProcess">
        <property name="text">
         <string>No Process Selected</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QLabel" name="label_InferiorStatus">
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QProgressBar" name="progressBar">
        <property name="value">
         <number>0</number>
        </property>
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Console">
        <property name="toolTip">
         <string>Open a gdb console</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Settings">
        <property name="sizePolicy">
         <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
          <horstretch>0</horstretch>
          <verstretch>0</verstretch>
         </sizepolicy>
        </property>
        <property name="toolTip">
         <string>Configure options</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
     </layout>
    </item>
    <item row="1" column="0">
     <layout class="QHBoxLayout" name="horizontalLayout_9">
      <item>
       <layout class="QVBoxLayout" name="verticalLayout_6">
        <item>
         <widget class="QLabel" name="label_MatchCount">
          <property name="text">
           <string>Match count: 0</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QTableWidget" name="tableWidget_valuesearchtable">
          <property name="enabled">
           <bool>true</bool>
          </property>
          <property name="autoFillBackground">
           <bool>false</bool>
          </property>
          <property name="horizontalScrollBarPolicy">
           <enum>Qt::ScrollBarAlwaysOff</enum>
          </property>
          <property name="editTriggers">
           <set>QAbstractItemView::NoEditTriggers</set>
          </property>
          <property name="alternatingRowColors">
           <bool>true</bool>
          </property>
          <property name="selectionMode">
           <enum>QAbstractItemView::ExtendedSelection</enum>
          </property>
          <property name="selectionBehavior">
           <enum>QAbstractItemView::SelectRows</enum>
          </property>
          <property name="showGrid">
           <bool>false</bool>
          </property>
          <attribute name="horizontalHeaderShowSortIndicator" stdset="0">
           <bool>true</bool>
          </attribute>
          <attribute name="horizontalHeaderStretchLastSection">
           <bool>true</bool>
          </attribute>
          <attribute name="verticalHeaderVisible">
           <bool>false</bool>
          </attribute>
          <attribute name="verticalHeaderMinimumSectionSize">
           <number>20</number>
          </attribute>
          <attribute name="verticalHeaderDefaultSectionSize">
           <number>23</number>
          </attribute>
          <column>
           <property name="text">
            <string>Address</string>
           </property>
          </column>
          <column>
           <property name="text">
            <string>Value</string>
           </property>
          </column>
          <column>
           <property name="text">
            <string>Previous</string>
           </property>
          </column>
         </widget>
        </item>
       </layout>
      </item>
      <item>
       <widget class="QWidget" name="QWidget_Toolbox" native="true">
        <property name="enabled">
         <bool>true</bool>
        </property>
        <layout class="QVBoxLayout" name="verticalLayout_5">
         <item>
          <layout class="QHBoxLayout" name="horizontalLayout_6">
           <item>
            <widget class="QPushButton" name="pushButton_NewFirstScan">
             <property name="text">
              <string>First Scan</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QPushButton" name="pushButton_NextScan">
             <property name="text">
              <string>Next Scan</string>
             </property>
            </widget>
           </item>
           <item>
            <spacer name="horizontalSpacer">
             <property name="orientation">
              <enum>Qt::Horizontal</enum>
             </property>
             <property name="sizeHint" stdset="0">
              <size>
               <width>40</width>
               <height>20</height>
              </size>
             </property>
            </spacer>
           </item>
           <item>
            <widget class="QPushButton" name="pushButton_UndoScan">
             <property name="text">
              <string>Undo Scan</string>
             </property>
            </widget>
           </item>
          </layout>
         </item>
         <item>
          <widget class="QWidget" name="widget_Scan" native="true">
           <layout class="QHBoxLayout" name="horizontalLayout_7">
            <property name="leftMargin">
             <number>0</number>
            </property>
            <property name="topMargin">
             <number>0</number>
            </property>
            <property name="rightMargin">
             <number>0</number>
            </property>
            <property name="bottomMargin">
             <number>0</number>
            </property>
            <item>
             <widget class="QWidget" name="widget_3" native="true">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <layout class="QVBoxLayout" name="verticalLayout_2">
               <property name="spacing">
                <number>0</number>
               </property>
               <property name="leftMargin">
                <number>0</number>
               </property>
               <property name="topMargin">
                <number>0</number>
               </property>
               <property name="rightMargin">
                <number>0</number>
               </property>
               <property name="bottomMargin">
                <number>0</number>
               </property>
               <item>
                <widget class="QRadioButton" name="radioButton_Bits">
                 <property name="text">
                  <string>B&amp;its</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QRadioButton" name="radioButton_Decimal">
                 <property name="text">
                  <string>&amp;Decimal</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QCheckBox" name="checkBox_Hex">
                 <property name="text">
                  <string>Hex</string>
                 </property>
                </widget>
               </item>
              </layout>
             </widget>
            </item>
            <item>
             <widget class="QLineEdit" name="lineEdit_Scan"/>
            </item>
            <item>
             <widget class="QLabel" name="label_Between">
              <property name="text">
               <string>&lt;-&gt;</string>
              </property>
             </widget>
            </item>
            <item>
             <widget class="QLineEdit" name="lineEdit_Scan2"/>
            </item>
           </layout>
          </widget>
         </item>
         <item>
          <layout class="QHBoxLayout" name="horizontalLayout_4">
           <item>
            <widget class="QWidget" name="widget" native="true">
             <layout class="QVBoxLayout" name="verticalLayout_4">
              <item>
               <layout class="QHBoxLayout" name="horizontalLayout_2">
                <item>
                 <widget class="QLabel" name="label">
                  <property name="text">
                   <string>Scan Type:</string>
                  </property>
                 </widget>
                </item>
                <item>
                 <widget class="QComboBox" name="comboBox_ScanType"/>
                </item>
               </layout>
              </item>
              <item>
               <layout class="QHBoxLayout" name="horizontalLayout">
                <item>
                 <widget class="QLabel" name="label_2">
                  <property name="text">
                   <string>Value Type:</string>
                  </property>
                 </widget>
                </item>
                <item>
                 <widget class="QComboBox" name="comboBox_ValueType"/>
                </item>
               </layout>
              </item>
              <item>
               <layout class="QHBoxLayout" name="horizontalLayout_10">
                <item>
                 <widget class="QLabel" name="label_ScanScope">
                  <property name="text">
                   <string>Scan Scope:</string>
                  </property>
                 </widget>
                </item>
                <item>
                 <widget class="QComboBox" name="comboBox_ScanScope"/>
                </item>
               </layout>
              </item>
              <item>
               <spacer name="verticalSpacer">
                <property name="orientation">
                 <enum>Qt::Vertical</enum>
                </property>
                <property name="sizeHint" stdset="0">
                 <size>
                  <width>20</width>
                  <height>40</height>
                 </size>
                </property>
               </spacer>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QWidget" name="widget_2" native="true">
             <layout class="QVBoxLayout" name="verticalLayout">
              <property name="spacing">
               <number>0</number>
              </property>
              <property name="leftMargin">
               <number>0</number>
              </property>
              <property name="topMargin">
               <number>0</number>
              </property>
              <property name="rightMargin">
               <number>0</number>
              </property>
              <property name="bottomMargin">
               <number>0</number>
              </property>
              <item>
               <widget class="QRadioButton" name="radioButton_RoundedDefault">
                <property name="enabled">
                 <bool>false</bool>
                </property>
                <property name="toolTip">
                 <string>Not currently supported</string>
                </property>
                <property name="text">
                 <string>Ro&amp;unded (Default)</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QRadioButton" name="radioButton_RoundedExtreme">
                <property name="enabled">
                 <bool>false</bool>
                </property>
                <property name="toolTip">
                 <string>Not currently supported</string>
                </property>
                <property name="text">
                 <string>Rou&amp;nded (Extreme)</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QRadioButton" name="radioButton_Truncated">
                <property name="enabled">
                 <bool>false</bool>
                </property>
                <property name="toolTip">
                 <string>Not currently supported</string>
                </property>
                <property name="text">
                 <string>Truncated</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QCheckBox" name="checkBox_Unicode">
                <property name="enabled">
                 <bool>false</bool>
                </property>
                <property name="toolTip">
                 <string>Not currently supported</string>
                </property>
                <property name="text">
                 <string>Unicode</string>
                </property>
               </widget>
              </item>
              <item>
               <widget class="QCheckBox" name="checkBox_CaseSensitive">
                <property name="enabled">
                 <bool>false</bool>
                </property>
                <property name="toolTip">
                 <string>Not currently supported</string>
                </property>
                <property name="text">
                 <string>Case Sensitive</string>
                </property>
               </widget>
              </item>
              <item>
               <layout class="QVBoxLayout" name="verticalLayout_3">
                <item>
                 <spacer name="verticalSpacer_2">
                  <property name="orientation">
                   <enum>Qt::Vertical</enum>
                  </property>
                  <property name="sizeHint" stdset="0">
                   <size>
                    <width>20</width>
                    <height>40</height>
                   </size>
                  </property>
                 </spacer>
                </item>
                <item>
                 <widget class="QCheckBox" name="checkBox_Unrandomizer">
                  <property name="enabled">
                   <bool>false</bool>
                  </property>
                  <property name="toolTip">
                   <string>Not currently supported</string>
                  </property>
                  <property name="text">
                   <string>Unrandomizer</string>
                  </property>
                 </widget>
                </item>
               </layout>
              </item>
             </layout>
            </widget>
           </item>
          </layout>
         </item>
        </layout>
       </widget>
      </item>
     </layout>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>678</width>
     <height>30</height>
    </rect>
   </property>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/MemoryRegionsWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'MemoryRegionsWidget.ui'
#
# Created: Fri Feb 24 20:41:26 2017
#      by: PyQt5 UI code generator 5.2.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(684, 539)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.tableWidget_MemoryRegions = QtWidgets.QTableWidget(Form)
        self.tableWidget_MemoryRegions.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_MemoryRegions.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_MemoryRegions.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_MemoryRegions.setObjectName("tableWidget_MemoryRegions")
        self.tableWidget_MemoryRegions.setColumnCount(13)
        self.tableWidget_MemoryRegions.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(5, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(6, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(7, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(8, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(9, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(10, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(11, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(12, item)
        self.tableWidget_MemoryRegions.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_MemoryRegions.verticalHeader().setVisible(False)
        self.tableWidget_MemoryRegions.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_MemoryRegions.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout.addWidget(self.tableWidget_MemoryRegions, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Memory Regions"))
        self.tableWidget_MemoryRegions.setSortingEnabled(True)
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Regions"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Perms"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(2)
        item.setText(_translate("Form", "Size"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(3)
        item.setText(_translate("Form", "Path"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(4)
        item.setText(_translate("Form", "RSS"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(5)
        item.setText(_translate("Form", "PSS"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(6)
        item.setText(_translate("Form", "Shared_Clean"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(7)
        item.setText(_translate("Form", "Shared_Dirty"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(8)
        item.setText(_translate("Form", "Private_Clean"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(9)
        item.setText(_translate("Form", "Private_Dirty"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(10)
        item.setText(_translate("Form", "Referenced"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(11)
        item.setText(_translate("Form", "Anonymous"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(12)
        item.setText(_translate("Form", "Swap"))


```

`GUI/MemoryRegionsWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>684</width>
    <height>539</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Memory Regions</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QTableWidget" name="tableWidget_MemoryRegions">
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>16</number>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>16</number>
     </attribute>
     <column>
      <property name="text">
       <string>Regions</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Perms</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Size</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Path</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>RSS</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>PSS</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Shared_Clean</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Shared_Dirty</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Private_Clean</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Private_Dirty</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Referenced</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Anonymous</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Swap</string>
      </property>
     </column>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/MemoryViewerWindow.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'MemoryViewerWindow.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow_MemoryView(object):
    def setupUi(self, MainWindow_MemoryView):
        MainWindow_MemoryView.setObjectName("MainWindow_MemoryView")
        MainWindow_MemoryView.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow_MemoryView)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_5 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_5.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_5.setSpacing(0)
        self.gridLayout_5.setObjectName("gridLayout_5")
        self.splitter_MainMiddle = QtWidgets.QSplitter(self.centralwidget)
        self.splitter_MainMiddle.setLineWidth(1)
        self.splitter_MainMiddle.setOrientation(QtCore.Qt.Vertical)
        self.splitter_MainMiddle.setOpaqueResize(True)
        self.splitter_MainMiddle.setHandleWidth(10)
        self.splitter_MainMiddle.setChildrenCollapsible(True)
        self.splitter_MainMiddle.setObjectName("splitter_MainMiddle")
        self.splitter_Disassemble_Registers = QtWidgets.QSplitter(self.splitter_MainMiddle)
        self.splitter_Disassemble_Registers.setOrientation(QtCore.Qt.Horizontal)
        self.splitter_Disassemble_Registers.setHandleWidth(10)
        self.splitter_Disassemble_Registers.setObjectName("splitter_Disassemble_Registers")
        self.widget_Disassemble = QtWidgets.QWidget(self.splitter_Disassemble_Registers)
        self.widget_Disassemble.setObjectName("widget_Disassemble")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.widget_Disassemble)
        self.gridLayout_2.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_2.setSpacing(0)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.tableWidget_Disassemble = QtWidgets.QTableWidget(self.widget_Disassemble)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.tableWidget_Disassemble.setFont(font)
        self.tableWidget_Disassemble.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.tableWidget_Disassemble.setAutoScroll(False)
        self.tableWidget_Disassemble.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_Disassemble.setAlternatingRowColors(True)
        self.tableWidget_Disassemble.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_Disassemble.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_Disassemble.setShowGrid(False)
        self.tableWidget_Disassemble.setObjectName("tableWidget_Disassemble")
        self.tableWidget_Disassemble.setColumnCount(4)
        self.tableWidget_Disassemble.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Disassemble.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Disassemble.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Disassemble.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Disassemble.setHorizontalHeaderItem(3, item)
        self.tableWidget_Disassemble.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Disassemble.verticalHeader().setVisible(False)
        self.tableWidget_Disassemble.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Disassemble.verticalHeader().setMinimumSectionSize(16)
        self.tableWidget_Disassemble.verticalHeader().setStretchLastSection(False)
        self.gridLayout_2.addWidget(self.tableWidget_Disassemble, 0, 0, 1, 1)
        self.verticalScrollBar_Disassemble = QtWidgets.QScrollBar(self.widget_Disassemble)
        self.verticalScrollBar_Disassemble.setOrientation(QtCore.Qt.Vertical)
        self.verticalScrollBar_Disassemble.setObjectName("verticalScrollBar_Disassemble")
        self.gridLayout_2.addWidget(self.verticalScrollBar_Disassemble, 0, 1, 1, 1)
        self.widget_Registers = QtWidgets.QWidget(self.splitter_Disassemble_Registers)
        self.widget_Registers.setMinimumSize(QtCore.QSize(0, 0))
        self.widget_Registers.setObjectName("widget_Registers")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.widget_Registers)
        self.gridLayout_4.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_4.setSpacing(0)
        self.gridLayout_4.setObjectName("gridLayout_4")
        self.scrollArea_Registers = QtWidgets.QScrollArea(self.widget_Registers)
        self.scrollArea_Registers.setWidgetResizable(True)
        self.scrollArea_Registers.setObjectName("scrollArea_Registers")
        self.scrollAreaWidgetContents_Registers = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_Registers.setGeometry(QtCore.QRect(0, 0, 331, 336))
        self.scrollAreaWidgetContents_Registers.setObjectName("scrollAreaWidgetContents_Registers")
        self.gridLayout_8 = QtWidgets.QGridLayout(self.scrollAreaWidgetContents_Registers)
        self.gridLayout_8.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_8.setSpacing(0)
        self.gridLayout_8.setObjectName("gridLayout_8")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setSpacing(0)
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.verticalLayout_19 = QtWidgets.QVBoxLayout()
        self.verticalLayout_19.setSpacing(0)
        self.verticalLayout_19.setObjectName("verticalLayout_19")
        self.label_3 = QtWidgets.QLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_3.setFont(font)
        self.label_3.setObjectName("label_3")
        self.verticalLayout_19.addWidget(self.label_3)
        self.line = QtWidgets.QFrame(self.scrollAreaWidgetContents_Registers)
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")
        self.verticalLayout_19.addWidget(self.line)
        self.stackedWidget = QtWidgets.QStackedWidget(self.scrollAreaWidgetContents_Registers)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stackedWidget.sizePolicy().hasHeightForWidth())
        self.stackedWidget.setSizePolicy(sizePolicy)
        self.stackedWidget.setMinimumSize(QtCore.QSize(0, 145))
        self.stackedWidget.setMaximumSize(QtCore.QSize(16777215, 145))
        self.stackedWidget.setObjectName("stackedWidget")
        self.registers_64 = QtWidgets.QWidget()
        self.registers_64.setObjectName("registers_64")
        self.gridLayout_7 = QtWidgets.QGridLayout(self.registers_64)
        self.gridLayout_7.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_7.setSpacing(0)
        self.gridLayout_7.setObjectName("gridLayout_7")
        self.verticalLayout_17 = QtWidgets.QVBoxLayout()
        self.verticalLayout_17.setSpacing(0)
        self.verticalLayout_17.setObjectName("verticalLayout_17")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setSpacing(0)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout_16 = QtWidgets.QVBoxLayout()
        self.verticalLayout_16.setSpacing(0)
        self.verticalLayout_16.setObjectName("verticalLayout_16")
        self.RAX = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.RAX.setFont(font)
        self.RAX.setObjectName("RAX")
        self.verticalLayout_16.addWidget(self.RAX)
        self.RBX = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.RBX.setFont(font)
        self.RBX.setObjectName("RBX")
        self.verticalLayout_16.addWidget(self.RBX)
        self.RCX = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.RCX.setFont(font)
        self.RCX.setObjectName("RCX")
        self.verticalLayout_16.addWidget(self.RCX)
        self.RDX = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.RDX.setFont(font)
        self.RDX.setObjectName("RDX")
        self.verticalLayout_16.addWidget(self.RDX)
        self.RSI = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.RSI.setFont(font)
        self.RSI.setObjectName("RSI")
        self.verticalLayout_16.addWidget(self.RSI)
        self.RDI = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.RDI.setFont(font)
        self.RDI.setObjectName("RDI")
        self.verticalLayout_16.addWidget(self.RDI)
        self.RBP = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.RBP.setFont(font)
        self.RBP.setObjectName("RBP")
        self.verticalLayout_16.addWidget(self.RBP)
        self.RSP = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.RSP.setFont(font)
        self.RSP.setObjectName("RSP")
        self.verticalLayout_16.addWidget(self.RSP)
        self.horizontalLayout.addLayout(self.verticalLayout_16)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setSpacing(0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.R8 = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.R8.setFont(font)
        self.R8.setObjectName("R8")
        self.verticalLayout_3.addWidget(self.R8)
        self.R9 = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.R9.setFont(font)
        self.R9.setObjectName("R9")
        self.verticalLayout_3.addWidget(self.R9)
        self.R10 = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.R10.setFont(font)
        self.R10.setObjectName("R10")
        self.verticalLayout_3.addWidget(self.R10)
        self.R11 = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.R11.setFont(font)
        self.R11.setObjectName("R11")
        self.verticalLayout_3.addWidget(self.R11)
        self.R12 = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.R12.setFont(font)
        self.R12.setObjectName("R12")
        self.verticalLayout_3.addWidget(self.R12)
        self.R13 = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.R13.setFont(font)
        self.R13.setObjectName("R13")
        self.verticalLayout_3.addWidget(self.R13)
        self.R14 = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.R14.setFont(font)
        self.R14.setObjectName("R14")
        self.verticalLayout_3.addWidget(self.R14)
        self.R15 = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.R15.setFont(font)
        self.R15.setObjectName("R15")
        self.verticalLayout_3.addWidget(self.R15)
        self.horizontalLayout.addLayout(self.verticalLayout_3)
        self.verticalLayout_17.addLayout(self.horizontalLayout)
        self.horizontalLayout_18 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_18.setSpacing(0)
        self.horizontalLayout_18.setObjectName("horizontalLayout_18")
        self.RIP = QRegisterLabel(self.registers_64)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.RIP.setFont(font)
        self.RIP.setObjectName("RIP")
        self.horizontalLayout_18.addWidget(self.RIP)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_18.addItem(spacerItem1)
        self.verticalLayout_17.addLayout(self.horizontalLayout_18)
        spacerItem2 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_17.addItem(spacerItem2)
        self.gridLayout_7.addLayout(self.verticalLayout_17, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.registers_64)
        self.registers_32 = QtWidgets.QWidget()
        self.registers_32.setObjectName("registers_32")
        self.gridLayout_6 = QtWidgets.QGridLayout(self.registers_32)
        self.gridLayout_6.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_6.setSpacing(0)
        self.gridLayout_6.setObjectName("gridLayout_6")
        self.verticalLayout_14 = QtWidgets.QVBoxLayout()
        self.verticalLayout_14.setSpacing(0)
        self.verticalLayout_14.setObjectName("verticalLayout_14")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setSpacing(0)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setSpacing(0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.EAX = QRegisterLabel(self.registers_32)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.EAX.setFont(font)
        self.EAX.setObjectName("EAX")
        self.verticalLayout_2.addWidget(self.EAX)
        self.EBX = QRegisterLabel(self.registers_32)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.EBX.setFont(font)
        self.EBX.setObjectName("EBX")
        self.verticalLayout_2.addWidget(self.EBX)
        self.ECX = QRegisterLabel(self.registers_32)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.ECX.setFont(font)
        self.ECX.setObjectName("ECX")
        self.verticalLayout_2.addWidget(self.ECX)
        self.EDX = QRegisterLabel(self.registers_32)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.EDX.setFont(font)
        self.EDX.setObjectName("EDX")
        self.verticalLayout_2.addWidget(self.EDX)
        self.ESI = QRegisterLabel(self.registers_32)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.ESI.setFont(font)
        self.ESI.setObjectName("ESI")
        self.verticalLayout_2.addWidget(self.ESI)
        self.EDI = QRegisterLabel(self.registers_32)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.EDI.setFont(font)
        self.EDI.setObjectName("EDI")
        self.verticalLayout_2.addWidget(self.EDI)
        self.EBP = QRegisterLabel(self.registers_32)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.EBP.setFont(font)
        self.EBP.setObjectName("EBP")
        self.verticalLayout_2.addWidget(self.EBP)
        self.ESP = QRegisterLabel(self.registers_32)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.ESP.setFont(font)
        self.ESP.setObjectName("ESP")
        self.verticalLayout_2.addWidget(self.ESP)
        self.EIP = QRegisterLabel(self.registers_32)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.EIP.setFont(font)
        self.EIP.setObjectName("EIP")
        self.verticalLayout_2.addWidget(self.EIP)
        self.horizontalLayout_3.addLayout(self.verticalLayout_2)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem3)
        self.verticalLayout_14.addLayout(self.horizontalLayout_3)
        self.gridLayout_6.addLayout(self.verticalLayout_14, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.registers_32)
        self.verticalLayout_19.addWidget(self.stackedWidget)
        self.label_29 = QtWidgets.QLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_29.setFont(font)
        self.label_29.setObjectName("label_29")
        self.verticalLayout_19.addWidget(self.label_29)
        self.line_2 = QtWidgets.QFrame(self.scrollAreaWidgetContents_Registers)
        self.line_2.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_2.setObjectName("line_2")
        self.verticalLayout_19.addWidget(self.line_2)
        self.horizontalLayout_21 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_21.setSpacing(0)
        self.horizontalLayout_21.setObjectName("horizontalLayout_21")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout()
        self.verticalLayout_5.setSpacing(0)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.label_31 = QtWidgets.QLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_31.setFont(font)
        self.label_31.setObjectName("label_31")
        self.verticalLayout_5.addWidget(self.label_31)
        self.CF = QFlagRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.CF.setFont(font)
        self.CF.setObjectName("CF")
        self.verticalLayout_5.addWidget(self.CF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_5)
        self.verticalLayout_6 = QtWidgets.QVBoxLayout()
        self.verticalLayout_6.setSpacing(0)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.label_35 = QtWidgets.QLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_35.setFont(font)
        self.label_35.setObjectName("label_35")
        self.verticalLayout_6.addWidget(self.label_35)
        self.PF = QFlagRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.PF.setFont(font)
        self.PF.setObjectName("PF")
        self.verticalLayout_6.addWidget(self.PF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_6)
        self.verticalLayout_7 = QtWidgets.QVBoxLayout()
        self.verticalLayout_7.setSpacing(0)
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.label_37 = QtWidgets.QLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_37.setFont(font)
        self.label_37.setObjectName("label_37")
        self.verticalLayout_7.addWidget(self.label_37)
        self.AF = QFlagRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.AF.setFont(font)
        self.AF.setObjectName("AF")
        self.verticalLayout_7.addWidget(self.AF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_7)
        self.verticalLayout_8 = QtWidgets.QVBoxLayout()
        self.verticalLayout_8.setSpacing(0)
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.label_39 = QtWidgets.QLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_39.setFont(font)
        self.label_39.setObjectName("label_39")
        self.verticalLayout_8.addWidget(self.label_39)
        self.ZF = QFlagRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.ZF.setFont(font)
        self.ZF.setObjectName("ZF")
        self.verticalLayout_8.addWidget(self.ZF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_8)
        self.verticalLayout_9 = QtWidgets.QVBoxLayout()
        self.verticalLayout_9.setSpacing(0)
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.label_41 = QtWidgets.QLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_41.setFont(font)
        self.label_41.setObjectName("label_41")
        self.verticalLayout_9.addWidget(self.label_41)
        self.SF = QFlagRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.SF.setFont(font)
        self.SF.setObjectName("SF")
        self.verticalLayout_9.addWidget(self.SF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_9)
        self.verticalLayout_10 = QtWidgets.QVBoxLayout()
        self.verticalLayout_10.setSpacing(0)
        self.verticalLayout_10.setObjectName("verticalLayout_10")
        self.label_43 = QtWidgets.QLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_43.setFont(font)
        self.label_43.setObjectName("label_43")
        self.verticalLayout_10.addWidget(self.label_43)
        self.TF = QFlagRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.TF.setFont(font)
        self.TF.setObjectName("TF")
        self.verticalLayout_10.addWidget(self.TF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_10)
        self.verticalLayout_11 = QtWidgets.QVBoxLayout()
        self.verticalLayout_11.setSpacing(0)
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.label_45 = QtWidgets.QLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_45.setFont(font)
        self.label_45.setObjectName("label_45")
        self.verticalLayout_11.addWidget(self.label_45)
        self.IF = QFlagRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.IF.setFont(font)
        self.IF.setObjectName("IF")
        self.verticalLayout_11.addWidget(self.IF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_11)
        self.verticalLayout_12 = QtWidgets.QVBoxLayout()
        self.verticalLayout_12.setSpacing(0)
        self.verticalLayout_12.setObjectName("verticalLayout_12")
        self.label_47 = QtWidgets.QLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_47.setFont(font)
        self.label_47.setObjectName("label_47")
        self.verticalLayout_12.addWidget(self.label_47)
        self.DF = QFlagRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.DF.setFont(font)
        self.DF.setObjectName("DF")
        self.verticalLayout_12.addWidget(self.DF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_12)
        self.verticalLayout_13 = QtWidgets.QVBoxLayout()
        self.verticalLayout_13.setSpacing(0)
        self.verticalLayout_13.setObjectName("verticalLayout_13")
        self.label_49 = QtWidgets.QLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_49.setFont(font)
        self.label_49.setObjectName("label_49")
        self.verticalLayout_13.addWidget(self.label_49)
        self.OF = QFlagRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.OF.setFont(font)
        self.OF.setObjectName("OF")
        self.verticalLayout_13.addWidget(self.OF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_13)
        self.verticalLayout_19.addLayout(self.horizontalLayout_21)
        spacerItem4 = QtWidgets.QSpacerItem(20, 15, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        self.verticalLayout_19.addItem(spacerItem4)
        self.label_30 = QtWidgets.QLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_30.setFont(font)
        self.label_30.setObjectName("label_30")
        self.verticalLayout_19.addWidget(self.label_30)
        self.line_3 = QtWidgets.QFrame(self.scrollAreaWidgetContents_Registers)
        self.line_3.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_3.setObjectName("line_3")
        self.verticalLayout_19.addWidget(self.line_3)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setSpacing(0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setSpacing(0)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.CS = QRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.CS.setFont(font)
        self.CS.setObjectName("CS")
        self.verticalLayout_4.addWidget(self.CS)
        self.ES = QRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.ES.setFont(font)
        self.ES.setObjectName("ES")
        self.verticalLayout_4.addWidget(self.ES)
        self.horizontalLayout_2.addLayout(self.verticalLayout_4)
        spacerItem5 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem5)
        self.verticalLayout_15 = QtWidgets.QVBoxLayout()
        self.verticalLayout_15.setSpacing(0)
        self.verticalLayout_15.setObjectName("verticalLayout_15")
        self.SS = QRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.SS.setFont(font)
        self.SS.setObjectName("SS")
        self.verticalLayout_15.addWidget(self.SS)
        self.GS = QRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.GS.setFont(font)
        self.GS.setObjectName("GS")
        self.verticalLayout_15.addWidget(self.GS)
        self.horizontalLayout_2.addLayout(self.verticalLayout_15)
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem6)
        self.verticalLayout_18 = QtWidgets.QVBoxLayout()
        self.verticalLayout_18.setSpacing(0)
        self.verticalLayout_18.setObjectName("verticalLayout_18")
        self.DS = QRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.DS.setFont(font)
        self.DS.setObjectName("DS")
        self.verticalLayout_18.addWidget(self.DS)
        self.FS = QRegisterLabel(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.FS.setFont(font)
        self.FS.setObjectName("FS")
        self.verticalLayout_18.addWidget(self.FS)
        self.horizontalLayout_2.addLayout(self.verticalLayout_18)
        self.verticalLayout_19.addLayout(self.horizontalLayout_2)
        self.pushButton_ShowFloatRegisters = QtWidgets.QPushButton(self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.pushButton_ShowFloatRegisters.setFont(font)
        self.pushButton_ShowFloatRegisters.setObjectName("pushButton_ShowFloatRegisters")
        self.verticalLayout_19.addWidget(self.pushButton_ShowFloatRegisters)
        spacerItem7 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_19.addItem(spacerItem7)
        self.horizontalLayout_4.addLayout(self.verticalLayout_19)
        spacerItem8 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem8)
        self.gridLayout_8.addLayout(self.horizontalLayout_4, 0, 0, 1, 1)
        self.scrollArea_Registers.setWidget(self.scrollAreaWidgetContents_Registers)
        self.gridLayout_4.addWidget(self.scrollArea_Registers, 0, 0, 1, 1)
        self.splitter_HexView_StackView = QtWidgets.QSplitter(self.splitter_MainMiddle)
        self.splitter_HexView_StackView.setOrientation(QtCore.Qt.Horizontal)
        self.splitter_HexView_StackView.setHandleWidth(10)
        self.splitter_HexView_StackView.setObjectName("splitter_HexView_StackView")
        self.widget_HexView = QtWidgets.QWidget(self.splitter_HexView_StackView)
        self.widget_HexView.setObjectName("widget_HexView")
        self.gridLayout = QtWidgets.QGridLayout(self.widget_HexView)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setHorizontalSpacing(0)
        self.gridLayout.setVerticalSpacing(4)
        self.gridLayout.setObjectName("gridLayout")
        self.scrollArea_Hex = QtWidgets.QScrollArea(self.widget_HexView)
        self.scrollArea_Hex.setWidgetResizable(True)
        self.scrollArea_Hex.setObjectName("scrollArea_Hex")
        self.scrollAreaWidgetContents_2 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_2.setGeometry(QtCore.QRect(0, 0, 546, 193))
        self.scrollAreaWidgetContents_2.setObjectName("scrollAreaWidgetContents_2")
        self.gridLayout_11 = QtWidgets.QGridLayout(self.scrollAreaWidgetContents_2)
        self.gridLayout_11.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_11.setSpacing(0)
        self.gridLayout_11.setObjectName("gridLayout_11")
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setSpacing(0)
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.tableWidget_HexView_Address = QtWidgets.QTableWidget(self.scrollAreaWidgetContents_2)
        self.tableWidget_HexView_Address.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_HexView_Address.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_HexView_Address.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_HexView_Address.setShowGrid(False)
        self.tableWidget_HexView_Address.setObjectName("tableWidget_HexView_Address")
        self.tableWidget_HexView_Address.setColumnCount(1)
        self.tableWidget_HexView_Address.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_HexView_Address.setHorizontalHeaderItem(0, item)
        self.tableWidget_HexView_Address.horizontalHeader().setVisible(False)
        self.tableWidget_HexView_Address.verticalHeader().setVisible(False)
        self.horizontalLayout_5.addWidget(self.tableWidget_HexView_Address)
        self.line_5 = QtWidgets.QFrame(self.scrollAreaWidgetContents_2)
        self.line_5.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_5.setObjectName("line_5")
        self.horizontalLayout_5.addWidget(self.line_5)
        self.tableView_HexView_Hex = QHexView(self.scrollAreaWidgetContents_2)
        self.tableView_HexView_Hex.setTextElideMode(QtCore.Qt.ElideNone)
        self.tableView_HexView_Hex.setObjectName("tableView_HexView_Hex")
        self.horizontalLayout_5.addWidget(self.tableView_HexView_Hex)
        self.line_4 = QtWidgets.QFrame(self.scrollAreaWidgetContents_2)
        self.line_4.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_4.setObjectName("line_4")
        self.horizontalLayout_5.addWidget(self.line_4)
        self.tableView_HexView_Ascii = QAsciiView(self.scrollAreaWidgetContents_2)
        self.tableView_HexView_Ascii.setTextElideMode(QtCore.Qt.ElideNone)
        self.tableView_HexView_Ascii.setObjectName("tableView_HexView_Ascii")
        self.horizontalLayout_5.addWidget(self.tableView_HexView_Ascii)
        spacerItem9 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_5.addItem(spacerItem9)
        self.gridLayout_11.addLayout(self.horizontalLayout_5, 2, 0, 1, 1)
        self.label_HexView_Information = QtWidgets.QLabel(self.scrollAreaWidgetContents_2)
        self.label_HexView_Information.setText("")
        self.label_HexView_Information.setObjectName("label_HexView_Information")
        self.gridLayout_11.addWidget(self.label_HexView_Information, 0, 0, 1, 1)
        self.line_6 = QtWidgets.QFrame(self.scrollAreaWidgetContents_2)
        self.line_6.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_6.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_6.setObjectName("line_6")
        self.gridLayout_11.addWidget(self.line_6, 1, 0, 1, 1)
        self.label_HexView_Information.raise_()
        self.line_6.raise_()
        self.scrollArea_Hex.setWidget(self.scrollAreaWidgetContents_2)
        self.gridLayout.addWidget(self.scrollArea_Hex, 0, 0, 1, 1)
        self.verticalScrollBar_HexView = QtWidgets.QScrollBar(self.widget_HexView)
        self.verticalScrollBar_HexView.setOrientation(QtCore.Qt.Vertical)
        self.verticalScrollBar_HexView.setObjectName("verticalScrollBar_HexView")
        self.gridLayout.addWidget(self.verticalScrollBar_HexView, 0, 1, 1, 1)
        self.widget_StackView = QtWidgets.QWidget(self.splitter_HexView_StackView)
        self.widget_StackView.setObjectName("widget_StackView")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.widget_StackView)
        self.gridLayout_3.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_3.setSpacing(0)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.stackedWidget_StackScreens = QtWidgets.QStackedWidget(self.widget_StackView)
        self.stackedWidget_StackScreens.setObjectName("stackedWidget_StackScreens")
        self.StackTrace = QtWidgets.QWidget()
        self.StackTrace.setObjectName("StackTrace")
        self.gridLayout_9 = QtWidgets.QGridLayout(self.StackTrace)
        self.gridLayout_9.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_9.setSpacing(0)
        self.gridLayout_9.setObjectName("gridLayout_9")
        self.tableWidget_StackTrace = QtWidgets.QTableWidget(self.StackTrace)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.tableWidget_StackTrace.setFont(font)
        self.tableWidget_StackTrace.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_StackTrace.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_StackTrace.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_StackTrace.setObjectName("tableWidget_StackTrace")
        self.tableWidget_StackTrace.setColumnCount(2)
        self.tableWidget_StackTrace.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_StackTrace.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_StackTrace.setHorizontalHeaderItem(1, item)
        self.tableWidget_StackTrace.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_StackTrace.verticalHeader().setVisible(False)
        self.tableWidget_StackTrace.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_StackTrace.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout_9.addWidget(self.tableWidget_StackTrace, 0, 0, 1, 1)
        self.stackedWidget_StackScreens.addWidget(self.StackTrace)
        self.Stack = QtWidgets.QWidget()
        self.Stack.setObjectName("Stack")
        self.gridLayout_10 = QtWidgets.QGridLayout(self.Stack)
        self.gridLayout_10.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_10.setSpacing(0)
        self.gridLayout_10.setObjectName("gridLayout_10")
        self.tableWidget_Stack = QtWidgets.QTableWidget(self.Stack)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.tableWidget_Stack.setFont(font)
        self.tableWidget_Stack.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_Stack.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_Stack.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_Stack.setObjectName("tableWidget_Stack")
        self.tableWidget_Stack.setColumnCount(3)
        self.tableWidget_Stack.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Stack.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Stack.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Stack.setHorizontalHeaderItem(2, item)
        self.tableWidget_Stack.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Stack.verticalHeader().setVisible(False)
        self.tableWidget_Stack.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Stack.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout_10.addWidget(self.tableWidget_Stack, 0, 0, 1, 1)
        self.stackedWidget_StackScreens.addWidget(self.Stack)
        self.gridLayout_3.addWidget(self.stackedWidget_StackScreens, 0, 0, 1, 1)
        self.gridLayout_5.addWidget(self.splitter_MainMiddle, 0, 0, 1, 1)
        MainWindow_MemoryView.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow_MemoryView)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 30))
        self.menubar.setObjectName("menubar")
        self.menuView = QtWidgets.QMenu(self.menubar)
        self.menuView.setObjectName("menuView")
        self.menuDebug = QtWidgets.QMenu(self.menubar)
        self.menuDebug.setObjectName("menuDebug")
        self.menuTools = QtWidgets.QMenu(self.menubar)
        self.menuTools.setObjectName("menuTools")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menuHelp = QtWidgets.QMenu(self.menubar)
        self.menuHelp.setObjectName("menuHelp")
        MainWindow_MemoryView.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow_MemoryView)
        self.statusbar.setObjectName("statusbar")
        MainWindow_MemoryView.setStatusBar(self.statusbar)
        self.actionBookmarks = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionBookmarks.setObjectName("actionBookmarks")
        self.actionStackTrace_Info = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionStackTrace_Info.setObjectName("actionStackTrace_Info")
        self.actionInject_so_file = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionInject_so_file.setObjectName("actionInject_so_file")
        self.actionRun = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionRun.setObjectName("actionRun")
        self.actionBreak = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionBreak.setObjectName("actionBreak")
        self.actionStep = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionStep.setObjectName("actionStep")
        self.actionStep_Over = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionStep_Over.setObjectName("actionStep_Over")
        self.actionExecute_Till_Return = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionExecute_Till_Return.setObjectName("actionExecute_Till_Return")
        self.actionToggle_Breakpoint = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionToggle_Breakpoint.setObjectName("actionToggle_Breakpoint")
        self.actionBreakpoints = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionBreakpoints.setObjectName("actionBreakpoints")
        self.actionFunctions = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionFunctions.setObjectName("actionFunctions")
        self.actionSet_Address = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionSet_Address.setObjectName("actionSet_Address")
        self.actionCall_Function = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionCall_Function.setObjectName("actionCall_Function")
        self.actionLoad_Trace = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionLoad_Trace.setObjectName("actionLoad_Trace")
        self.actionlibpince = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionlibpince.setObjectName("actionlibpince")
        self.actionGDB_Log_File = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionGDB_Log_File.setObjectName("actionGDB_Log_File")
        self.actionSearch_Opcode = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionSearch_Opcode.setObjectName("actionSearch_Opcode")
        self.actionMemory_Regions = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionMemory_Regions.setObjectName("actionMemory_Regions")
        self.actionDissect_Code = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionDissect_Code.setObjectName("actionDissect_Code")
        self.actionReferenced_Strings = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionReferenced_Strings.setObjectName("actionReferenced_Strings")
        self.actionReferenced_Calls = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionReferenced_Calls.setObjectName("actionReferenced_Calls")
        self.actionToggle_Attach = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionToggle_Attach.setObjectName("actionToggle_Attach")
        self.actionRestore_Instructions = QtWidgets.QAction(MainWindow_MemoryView)
        self.actionRestore_Instructions.setObjectName("actionRestore_Instructions")
        self.menuView.addAction(self.actionBookmarks)
        self.menuView.addAction(self.actionStackTrace_Info)
        self.menuView.addAction(self.actionBreakpoints)
        self.menuView.addAction(self.actionFunctions)
        self.menuView.addAction(self.actionGDB_Log_File)
        self.menuView.addAction(self.actionMemory_Regions)
        self.menuView.addAction(self.actionRestore_Instructions)
        self.menuView.addSeparator()
        self.menuView.addAction(self.actionReferenced_Strings)
        self.menuView.addAction(self.actionReferenced_Calls)
        self.menuDebug.addAction(self.actionRun)
        self.menuDebug.addAction(self.actionBreak)
        self.menuDebug.addSeparator()
        self.menuDebug.addAction(self.actionStep)
        self.menuDebug.addAction(self.actionStep_Over)
        self.menuDebug.addAction(self.actionExecute_Till_Return)
        self.menuDebug.addAction(self.actionToggle_Breakpoint)
        self.menuDebug.addAction(self.actionSet_Address)
        self.menuDebug.addSeparator()
        self.menuDebug.addAction(self.actionToggle_Attach)
        self.menuTools.addAction(self.actionInject_so_file)
        self.menuTools.addAction(self.actionCall_Function)
        self.menuTools.addAction(self.actionSearch_Opcode)
        self.menuTools.addAction(self.actionDissect_Code)
        self.menuFile.addAction(self.actionLoad_Trace)
        self.menuHelp.addAction(self.actionlibpince)
        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuView.menuAction())
        self.menubar.addAction(self.menuDebug.menuAction())
        self.menubar.addAction(self.menuTools.menuAction())
        self.menubar.addAction(self.menuHelp.menuAction())

        self.retranslateUi(MainWindow_MemoryView)
        self.stackedWidget.setCurrentIndex(1)
        self.stackedWidget_StackScreens.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow_MemoryView)

    def retranslateUi(self, MainWindow_MemoryView):
        _translate = QtCore.QCoreApplication.translate
        MainWindow_MemoryView.setWindowTitle(_translate("MainWindow_MemoryView", "Memory Viewer"))
        item = self.tableWidget_Disassemble.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow_MemoryView", "Address"))
        item = self.tableWidget_Disassemble.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow_MemoryView", "Bytes"))
        item = self.tableWidget_Disassemble.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow_MemoryView", "Opcodes"))
        item = self.tableWidget_Disassemble.horizontalHeaderItem(3)
        item.setText(_translate("MainWindow_MemoryView", "Comment"))
        self.label_3.setText(_translate("MainWindow_MemoryView", "Registers"))
        self.RAX.setText(_translate("MainWindow_MemoryView", "RAX="))
        self.RBX.setText(_translate("MainWindow_MemoryView", "RBX="))
        self.RCX.setText(_translate("MainWindow_MemoryView", "RCX="))
        self.RDX.setText(_translate("MainWindow_MemoryView", "RDX="))
        self.RSI.setText(_translate("MainWindow_MemoryView", "RSI="))
        self.RDI.setText(_translate("MainWindow_MemoryView", "RDI="))
        self.RBP.setText(_translate("MainWindow_MemoryView", "RBP="))
        self.RSP.setText(_translate("MainWindow_MemoryView", "RSP="))
        self.R8.setText(_translate("MainWindow_MemoryView", "R8="))
        self.R9.setText(_translate("MainWindow_MemoryView", "R9="))
        self.R10.setText(_translate("MainWindow_MemoryView", "R10="))
        self.R11.setText(_translate("MainWindow_MemoryView", "R11="))
        self.R12.setText(_translate("MainWindow_MemoryView", "R12="))
        self.R13.setText(_translate("MainWindow_MemoryView", "R13="))
        self.R14.setText(_translate("MainWindow_MemoryView", "R14="))
        self.R15.setText(_translate("MainWindow_MemoryView", "R15="))
        self.RIP.setText(_translate("MainWindow_MemoryView", "RIP="))
        self.EAX.setText(_translate("MainWindow_MemoryView", "EAX="))
        self.EBX.setText(_translate("MainWindow_MemoryView", "EBX="))
        self.ECX.setText(_translate("MainWindow_MemoryView", "ECX="))
        self.EDX.setText(_translate("MainWindow_MemoryView", "EDX="))
        self.ESI.setText(_translate("MainWindow_MemoryView", "ESI="))
        self.EDI.setText(_translate("MainWindow_MemoryView", "EDI="))
        self.EBP.setText(_translate("MainWindow_MemoryView", "EBP="))
        self.ESP.setText(_translate("MainWindow_MemoryView", "ESP="))
        self.EIP.setText(_translate("MainWindow_MemoryView", "EIP="))
        self.label_29.setText(_translate("MainWindow_MemoryView", "Flags"))
        self.label_31.setText(_translate("MainWindow_MemoryView", "CF"))
        self.CF.setText(_translate("MainWindow_MemoryView", "0"))
        self.label_35.setText(_translate("MainWindow_MemoryView", "PF"))
        self.PF.setText(_translate("MainWindow_MemoryView", "0"))
        self.label_37.setText(_translate("MainWindow_MemoryView", "AF"))
        self.AF.setText(_translate("MainWindow_MemoryView", "0"))
        self.label_39.setText(_translate("MainWindow_MemoryView", "ZF"))
        self.ZF.setText(_translate("MainWindow_MemoryView", "0"))
        self.label_41.setText(_translate("MainWindow_MemoryView", "SF"))
        self.SF.setText(_translate("MainWindow_MemoryView", "0"))
        self.label_43.setText(_translate("MainWindow_MemoryView", "TF"))
        self.TF.setText(_translate("MainWindow_MemoryView", "0"))
        self.label_45.setText(_translate("MainWindow_MemoryView", "IF"))
        self.IF.setText(_translate("MainWindow_MemoryView", "0"))
        self.label_47.setText(_translate("MainWindow_MemoryView", "DF"))
        self.DF.setText(_translate("MainWindow_MemoryView", "0"))
        self.label_49.setText(_translate("MainWindow_MemoryView", "OF"))
        self.OF.setText(_translate("MainWindow_MemoryView", "0"))
        self.label_30.setText(_translate("MainWindow_MemoryView", "Segment Registers"))
        self.CS.setText(_translate("MainWindow_MemoryView", "CS="))
        self.ES.setText(_translate("MainWindow_MemoryView", "ES="))
        self.SS.setText(_translate("MainWindow_MemoryView", "SS="))
        self.GS.setText(_translate("MainWindow_MemoryView", "GS="))
        self.DS.setText(_translate("MainWindow_MemoryView", "DS="))
        self.FS.setText(_translate("MainWindow_MemoryView", "FS="))
        self.pushButton_ShowFloatRegisters.setText(_translate("MainWindow_MemoryView", "Show Float Registers"))
        item = self.tableWidget_HexView_Address.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow_MemoryView", "Address"))
        item = self.tableWidget_StackTrace.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow_MemoryView", "Return Address"))
        item = self.tableWidget_StackTrace.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow_MemoryView", "Frame Address"))
        item = self.tableWidget_Stack.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow_MemoryView", "Address"))
        item = self.tableWidget_Stack.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow_MemoryView", "Value"))
        item = self.tableWidget_Stack.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow_MemoryView", "Points to"))
        self.menuView.setTitle(_translate("MainWindow_MemoryView", "V&iew"))
        self.menuDebug.setTitle(_translate("MainWindow_MemoryView", "&Debug"))
        self.menuTools.setTitle(_translate("MainWindow_MemoryView", "&Tools"))
        self.menuFile.setTitle(_translate("MainWindow_MemoryView", "Fi&le"))
        self.menuHelp.setTitle(_translate("MainWindow_MemoryView", "Help"))
        self.actionBookmarks.setText(_translate("MainWindow_MemoryView", "&Bookmarks"))
        self.actionStackTrace_Info.setText(_translate("MainWindow_MemoryView", "&StackTrace Info"))
        self.actionInject_so_file.setText(_translate("MainWindow_MemoryView", "&Inject .so file"))
        self.actionRun.setText(_translate("MainWindow_MemoryView", "&Break"))
        self.actionBreak.setText(_translate("MainWindow_MemoryView", "&Run"))
        self.actionStep.setText(_translate("MainWindow_MemoryView", "&Step[F7]"))
        self.actionStep_Over.setText(_translate("MainWindow_MemoryView", "Step &Over[F8]"))
        self.actionExecute_Till_Return.setText(_translate("MainWindow_MemoryView", "&Execute Till Return[Shift+F8]"))
        self.actionToggle_Breakpoint.setText(_translate("MainWindow_MemoryView", "&Toggle Breakpoint[F5]"))
        self.actionBreakpoints.setText(_translate("MainWindow_MemoryView", "B&reakpoints"))
        self.actionFunctions.setText(_translate("MainWindow_MemoryView", "&Functions"))
        self.actionSet_Address.setText(_translate("MainWindow_MemoryView", "Set Address[Shift+F4]"))
        self.actionCall_Function.setText(_translate("MainWindow_MemoryView", "&Call Function"))
        self.actionLoad_Trace.setText(_translate("MainWindow_MemoryView", "&Load Trace"))
        self.actionlibpince.setText(_translate("MainWindow_MemoryView", "&libpince"))
        self.actionGDB_Log_File.setText(_translate("MainWindow_MemoryView", "&GDB Log File"))
        self.actionSearch_Opcode.setText(_translate("MainWindow_MemoryView", "&Search Opcode"))
        self.actionMemory_Regions.setText(_translate("MainWindow_MemoryView", "&Memory Regions"))
        self.actionDissect_Code.setText(_translate("MainWindow_MemoryView", "&Dissect Code"))
        self.actionReferenced_Strings.setText(_translate("MainWindow_MemoryView", "R&eferenced Strings"))
        self.actionReferenced_Calls.setText(_translate("MainWindow_MemoryView", "Referenced &Calls"))
        self.actionToggle_Attach.setText(_translate("MainWindow_MemoryView", "To&ggle Attach"))
        self.actionRestore_Instructions.setText(_translate("MainWindow_MemoryView", "Restore Instructions"))
from GUI.CustomLabels.FlagRegisterLabel import QFlagRegisterLabel
from GUI.CustomLabels.RegisterLabel import QRegisterLabel
from GUI.CustomTableViews.AsciiView import QAsciiView
from GUI.CustomTableViews.HexView import QHexView

```

`GUI/MemoryViewerWindow.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow_MemoryView</class>
 <widget class="QMainWindow" name="MainWindow_MemoryView">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>800</width>
    <height>600</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Memory Viewer</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QGridLayout" name="gridLayout_5">
    <property name="leftMargin">
     <number>0</number>
    </property>
    <property name="topMargin">
     <number>0</number>
    </property>
    <property name="rightMargin">
     <number>0</number>
    </property>
    <property name="bottomMargin">
     <number>0</number>
    </property>
    <property name="spacing">
     <number>0</number>
    </property>
    <item row="0" column="0">
     <widget class="QSplitter" name="splitter_MainMiddle">
      <property name="lineWidth">
       <number>1</number>
      </property>
      <property name="orientation">
       <enum>Qt::Vertical</enum>
      </property>
      <property name="opaqueResize">
       <bool>true</bool>
      </property>
      <property name="handleWidth">
       <number>10</number>
      </property>
      <property name="childrenCollapsible">
       <bool>true</bool>
      </property>
      <widget class="QSplitter" name="splitter_Disassemble_Registers">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="handleWidth">
        <number>10</number>
       </property>
       <widget class="QWidget" name="widget_Disassemble" native="true">
        <layout class="QGridLayout" name="gridLayout_2">
         <property name="leftMargin">
          <number>0</number>
         </property>
         <property name="topMargin">
          <number>0</number>
         </property>
         <property name="rightMargin">
          <number>0</number>
         </property>
         <property name="bottomMargin">
          <number>0</number>
         </property>
         <property name="spacing">
          <number>0</number>
         </property>
         <item row="0" column="0">
          <widget class="QTableWidget" name="tableWidget_Disassemble">
           <property name="font">
            <font>
             <pointsize>9</pointsize>
            </font>
           </property>
           <property name="verticalScrollBarPolicy">
            <enum>Qt::ScrollBarAlwaysOff</enum>
           </property>
           <property name="autoScroll">
            <bool>false</bool>
           </property>
           <property name="editTriggers">
            <set>QAbstractItemView::NoEditTriggers</set>
           </property>
           <property name="alternatingRowColors">
            <bool>true</bool>
           </property>
           <property name="selectionMode">
            <enum>QAbstractItemView::SingleSelection</enum>
           </property>
           <property name="selectionBehavior">
            <enum>QAbstractItemView::SelectRows</enum>
           </property>
           <property name="showGrid">
            <bool>false</bool>
           </property>
           <attribute name="horizontalHeaderStretchLastSection">
            <bool>true</bool>
           </attribute>
           <attribute name="verticalHeaderVisible">
            <bool>false</bool>
           </attribute>
           <attribute name="verticalHeaderMinimumSectionSize">
            <number>16</number>
           </attribute>
           <attribute name="verticalHeaderDefaultSectionSize">
            <number>16</number>
           </attribute>
           <attribute name="verticalHeaderStretchLastSection">
            <bool>false</bool>
           </attribute>
           <column>
            <property name="text">
             <string>Address</string>
            </property>
           </column>
           <column>
            <property name="text">
             <string>Bytes</string>
            </property>
           </column>
           <column>
            <property name="text">
             <string>Opcodes</string>
            </property>
           </column>
           <column>
            <property name="text">
             <string>Comment</string>
            </property>
           </column>
          </widget>
         </item>
         <item row="0" column="1">
          <widget class="QScrollBar" name="verticalScrollBar_Disassemble">
           <property name="orientation">
            <enum>Qt::Vertical</enum>
           </property>
          </widget>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="widget_Registers" native="true">
        <property name="minimumSize">
         <size>
          <width>0</width>
          <height>0</height>
         </size>
        </property>
        <layout class="QGridLayout" name="gridLayout_4">
         <property name="leftMargin">
          <number>0</number>
         </property>
         <property name="topMargin">
          <number>0</number>
         </property>
         <property name="rightMargin">
          <number>0</number>
         </property>
         <property name="bottomMargin">
          <number>0</number>
         </property>
         <property name="spacing">
          <number>0</number>
         </property>
         <item row="0" column="0">
          <widget class="QScrollArea" name="scrollArea_Registers">
           <property name="widgetResizable">
            <bool>true</bool>
           </property>
           <widget class="QWidget" name="scrollAreaWidgetContents_Registers">
            <property name="geometry">
             <rect>
              <x>0</x>
              <y>0</y>
              <width>331</width>
              <height>336</height>
             </rect>
            </property>
            <layout class="QGridLayout" name="gridLayout_8">
             <property name="leftMargin">
              <number>0</number>
             </property>
             <property name="topMargin">
              <number>0</number>
             </property>
             <property name="rightMargin">
              <number>0</number>
             </property>
             <property name="bottomMargin">
              <number>0</number>
             </property>
             <property name="spacing">
              <number>0</number>
             </property>
             <item row="0" column="0">
              <layout class="QHBoxLayout" name="horizontalLayout_4">
               <property name="spacing">
                <number>0</number>
               </property>
               <item>
                <layout class="QVBoxLayout" name="verticalLayout_19">
                 <property name="spacing">
                  <number>0</number>
                 </property>
                 <item>
                  <widget class="QLabel" name="label_3">
                   <property name="font">
                    <font>
                     <pointsize>9</pointsize>
                    </font>
                   </property>
                   <property name="text">
                    <string>Registers</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="Line" name="line">
                   <property name="orientation">
                    <enum>Qt::Horizontal</enum>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="QStackedWidget" name="stackedWidget">
                   <property name="sizePolicy">
                    <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
                     <horstretch>0</horstretch>
                     <verstretch>0</verstretch>
                    </sizepolicy>
                   </property>
                   <property name="minimumSize">
                    <size>
                     <width>0</width>
                     <height>145</height>
                    </size>
                   </property>
                   <property name="maximumSize">
                    <size>
                     <width>16777215</width>
                     <height>145</height>
                    </size>
                   </property>
                   <property name="currentIndex">
                    <number>1</number>
                   </property>
                   <widget class="QWidget" name="registers_64">
                    <layout class="QGridLayout" name="gridLayout_7">
                     <property name="leftMargin">
                      <number>0</number>
                     </property>
                     <property name="topMargin">
                      <number>0</number>
                     </property>
                     <property name="rightMargin">
                      <number>0</number>
                     </property>
                     <property name="bottomMargin">
                      <number>0</number>
                     </property>
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item row="0" column="0">
                      <layout class="QVBoxLayout" name="verticalLayout_17">
                       <property name="spacing">
                        <number>0</number>
                       </property>
                       <item>
                        <layout class="QHBoxLayout" name="horizontalLayout">
                         <property name="spacing">
                          <number>0</number>
                         </property>
                         <item>
                          <layout class="QVBoxLayout" name="verticalLayout_16">
                           <property name="spacing">
                            <number>0</number>
                           </property>
                           <item>
                            <widget class="QRegisterLabel" name="RAX">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>RAX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RBX">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>RBX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RCX">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>RCX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RDX">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>RDX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RSI">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>RSI=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RDI">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>RDI=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RBP">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>RBP=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RSP">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>RSP=</string>
                             </property>
                            </widget>
                           </item>
                          </layout>
                         </item>
                         <item>
                          <spacer name="horizontalSpacer_2">
                           <property name="orientation">
                            <enum>Qt::Horizontal</enum>
                           </property>
                           <property name="sizeHint" stdset="0">
                            <size>
                             <width>40</width>
                             <height>20</height>
                            </size>
                           </property>
                          </spacer>
                         </item>
                         <item>
                          <layout class="QVBoxLayout" name="verticalLayout_3">
                           <property name="spacing">
                            <number>0</number>
                           </property>
                           <item>
                            <widget class="QRegisterLabel" name="R8">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>R8=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R9">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>R9=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R10">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>R10=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R11">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>R11=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R12">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>R12=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R13">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>R13=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R14">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>R14=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R15">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>R15=</string>
                             </property>
                            </widget>
                           </item>
                          </layout>
                         </item>
                        </layout>
                       </item>
                       <item>
                        <layout class="QHBoxLayout" name="horizontalLayout_18">
                         <property name="spacing">
                          <number>0</number>
                         </property>
                         <item>
                          <widget class="QRegisterLabel" name="RIP">
                           <property name="font">
                            <font>
                             <pointsize>9</pointsize>
                            </font>
                           </property>
                           <property name="text">
                            <string>RIP=</string>
                           </property>
                          </widget>
                         </item>
                         <item>
                          <spacer name="horizontalSpacer_19">
                           <property name="orientation">
                            <enum>Qt::Horizontal</enum>
                           </property>
                           <property name="sizeHint" stdset="0">
                            <size>
                             <width>40</width>
                             <height>20</height>
                            </size>
                           </property>
                          </spacer>
                         </item>
                        </layout>
                       </item>
                       <item>
                        <spacer name="verticalSpacer">
                         <property name="orientation">
                          <enum>Qt::Vertical</enum>
                         </property>
                         <property name="sizeHint" stdset="0">
                          <size>
                           <width>20</width>
                           <height>40</height>
                          </size>
                         </property>
                        </spacer>
                       </item>
                      </layout>
                     </item>
                    </layout>
                   </widget>
                   <widget class="QWidget" name="registers_32">
                    <layout class="QGridLayout" name="gridLayout_6">
                     <property name="leftMargin">
                      <number>0</number>
                     </property>
                     <property name="topMargin">
                      <number>0</number>
                     </property>
                     <property name="rightMargin">
                      <number>0</number>
                     </property>
                     <property name="bottomMargin">
                      <number>0</number>
                     </property>
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item row="0" column="0">
                      <layout class="QVBoxLayout" name="verticalLayout_14">
                       <property name="spacing">
                        <number>0</number>
                       </property>
                       <item>
                        <layout class="QHBoxLayout" name="horizontalLayout_3">
                         <property name="spacing">
                          <number>0</number>
                         </property>
                         <item>
                          <layout class="QVBoxLayout" name="verticalLayout_2">
                           <property name="spacing">
                            <number>0</number>
                           </property>
                           <item>
                            <widget class="QRegisterLabel" name="EAX">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>EAX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="EBX">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>EBX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="ECX">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>ECX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="EDX">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>EDX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="ESI">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>ESI=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="EDI">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>EDI=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="EBP">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>EBP=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="ESP">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>ESP=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="EIP">
                             <property name="font">
                              <font>
                               <pointsize>9</pointsize>
                              </font>
                             </property>
                             <property name="text">
                              <string>EIP=</string>
                             </property>
                            </widget>
                           </item>
                          </layout>
                         </item>
                         <item>
                          <spacer name="horizontalSpacer_10">
                           <property name="orientation">
                            <enum>Qt::Horizontal</enum>
                           </property>
                           <property name="sizeHint" stdset="0">
                            <size>
                             <width>40</width>
                             <height>20</height>
                            </size>
                           </property>
                          </spacer>
                         </item>
                        </layout>
                       </item>
                      </layout>
                     </item>
                    </layout>
                   </widget>
                  </widget>
                 </item>
                 <item>
                  <widget class="QLabel" name="label_29">
                   <property name="font">
                    <font>
                     <pointsize>9</pointsize>
                    </font>
                   </property>
                   <property name="text">
                    <string>Flags</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="Line" name="line_2">
                   <property name="orientation">
                    <enum>Qt::Horizontal</enum>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <layout class="QHBoxLayout" name="horizontalLayout_21">
                   <property name="spacing">
                    <number>0</number>
                   </property>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_5">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_31">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>CF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="CF">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_6">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_35">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>PF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="PF">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_7">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_37">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>AF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="AF">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_8">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_39">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>ZF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="ZF">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_9">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_41">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>SF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="SF">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_10">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_43">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>TF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="TF">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_11">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_45">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>IF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="IF">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_12">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_47">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>DF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="DF">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_13">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_49">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>OF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="OF">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                  </layout>
                 </item>
                 <item>
                  <spacer name="verticalSpacer_2">
                   <property name="orientation">
                    <enum>Qt::Vertical</enum>
                   </property>
                   <property name="sizeType">
                    <enum>QSizePolicy::Fixed</enum>
                   </property>
                   <property name="sizeHint" stdset="0">
                    <size>
                     <width>20</width>
                     <height>15</height>
                    </size>
                   </property>
                  </spacer>
                 </item>
                 <item>
                  <widget class="QLabel" name="label_30">
                   <property name="font">
                    <font>
                     <pointsize>9</pointsize>
                    </font>
                   </property>
                   <property name="text">
                    <string>Segment Registers</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="Line" name="line_3">
                   <property name="orientation">
                    <enum>Qt::Horizontal</enum>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <layout class="QHBoxLayout" name="horizontalLayout_2">
                   <property name="spacing">
                    <number>0</number>
                   </property>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_4">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QRegisterLabel" name="CS">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>CS=</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QRegisterLabel" name="ES">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>ES=</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <spacer name="horizontalSpacer">
                     <property name="orientation">
                      <enum>Qt::Horizontal</enum>
                     </property>
                     <property name="sizeHint" stdset="0">
                      <size>
                       <width>40</width>
                       <height>20</height>
                      </size>
                     </property>
                    </spacer>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_15">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QRegisterLabel" name="SS">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>SS=</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QRegisterLabel" name="GS">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>GS=</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <spacer name="horizontalSpacer_3">
                     <property name="orientation">
                      <enum>Qt::Horizontal</enum>
                     </property>
                     <property name="sizeHint" stdset="0">
                      <size>
                       <width>40</width>
                       <height>20</height>
                      </size>
                     </property>
                    </spacer>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_18">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QRegisterLabel" name="DS">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>DS=</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QRegisterLabel" name="FS">
                       <property name="font">
                        <font>
                         <pointsize>9</pointsize>
                        </font>
                       </property>
                       <property name="text">
                        <string>FS=</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                  </layout>
                 </item>
                 <item>
                  <widget class="QPushButton" name="pushButton_ShowFloatRegisters">
                   <property name="font">
                    <font>
                     <pointsize>9</pointsize>
                    </font>
                   </property>
                   <property name="text">
                    <string>Show Float Registers</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <spacer name="verticalSpacer_3">
                   <property name="orientation">
                    <enum>Qt::Vertical</enum>
                   </property>
                   <property name="sizeHint" stdset="0">
                    <size>
                     <width>20</width>
                     <height>40</height>
                    </size>
                   </property>
                  </spacer>
                 </item>
                </layout>
               </item>
               <item>
                <spacer name="horizontalSpacer_21">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
            </layout>
           </widget>
          </widget>
         </item>
        </layout>
       </widget>
      </widget>
      <widget class="QSplitter" name="splitter_HexView_StackView">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="handleWidth">
        <number>10</number>
       </property>
       <widget class="QWidget" name="widget_HexView" native="true">
        <layout class="QGridLayout" name="gridLayout">
         <property name="leftMargin">
          <number>0</number>
         </property>
         <property name="topMargin">
          <number>0</number>
         </property>
         <property name="rightMargin">
          <number>0</number>
         </property>
         <property name="bottomMargin">
          <number>0</number>
         </property>
         <property name="horizontalSpacing">
          <number>0</number>
         </property>
         <property name="verticalSpacing">
          <number>4</number>
         </property>
         <item row="0" column="0">
          <widget class="QScrollArea" name="scrollArea_Hex">
           <property name="widgetResizable">
            <bool>true</bool>
           </property>
           <widget class="QWidget" name="scrollAreaWidgetContents_2">
            <property name="geometry">
             <rect>
              <x>0</x>
              <y>0</y>
              <width>546</width>
              <height>193</height>
             </rect>
            </property>
            <layout class="QGridLayout" name="gridLayout_11">
             <property name="leftMargin">
              <number>0</number>
             </property>
             <property name="topMargin">
              <number>0</number>
             </property>
             <property name="rightMargin">
              <number>0</number>
             </property>
             <property name="bottomMargin">
              <number>0</number>
             </property>
             <property name="spacing">
              <number>0</number>
             </property>
             <item row="2" column="0">
              <layout class="QHBoxLayout" name="horizontalLayout_5">
               <property name="spacing">
                <number>0</number>
               </property>
               <item>
                <widget class="QTableWidget" name="tableWidget_HexView_Address">
                 <property name="editTriggers">
                  <set>QAbstractItemView::NoEditTriggers</set>
                 </property>
                 <property name="selectionMode">
                  <enum>QAbstractItemView::SingleSelection</enum>
                 </property>
                 <property name="selectionBehavior">
                  <enum>QAbstractItemView::SelectRows</enum>
                 </property>
                 <property name="showGrid">
                  <bool>false</bool>
                 </property>
                 <attribute name="horizontalHeaderVisible">
                  <bool>false</bool>
                 </attribute>
                 <attribute name="verticalHeaderVisible">
                  <bool>false</bool>
                 </attribute>
                 <column>
                  <property name="text">
                   <string>Address</string>
                  </property>
                 </column>
                </widget>
               </item>
               <item>
                <widget class="Line" name="line_5">
                 <property name="orientation">
                  <enum>Qt::Vertical</enum>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QHexView" name="tableView_HexView_Hex">
                 <property name="textElideMode">
                  <enum>Qt::ElideNone</enum>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="Line" name="line_4">
                 <property name="orientation">
                  <enum>Qt::Vertical</enum>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QAsciiView" name="tableView_HexView_Ascii">
                 <property name="textElideMode">
                  <enum>Qt::ElideNone</enum>
                 </property>
                </widget>
               </item>
               <item>
                <spacer name="horizontalSpacer_4">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item row="0" column="0">
              <widget class="QLabel" name="label_HexView_Information">
               <property name="text">
                <string/>
               </property>
              </widget>
             </item>
             <item row="1" column="0">
              <widget class="Line" name="line_6">
               <property name="orientation">
                <enum>Qt::Horizontal</enum>
               </property>
              </widget>
             </item>
            </layout>
            <zorder></zorder>
            <zorder>label_HexView_Information</zorder>
            <zorder>line_6</zorder>
           </widget>
          </widget>
         </item>
         <item row="0" column="1">
          <widget class="QScrollBar" name="verticalScrollBar_HexView">
           <property name="orientation">
            <enum>Qt::Vertical</enum>
           </property>
          </widget>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="widget_StackView" native="true">
        <layout class="QGridLayout" name="gridLayout_3">
         <property name="leftMargin">
          <number>0</number>
         </property>
         <property name="topMargin">
          <number>0</number>
         </property>
         <property name="rightMargin">
          <number>0</number>
         </property>
         <property name="bottomMargin">
          <number>0</number>
         </property>
         <property name="spacing">
          <number>0</number>
         </property>
         <item row="0" column="0">
          <widget class="QStackedWidget" name="stackedWidget_StackScreens">
           <property name="currentIndex">
            <number>0</number>
           </property>
           <widget class="QWidget" name="StackTrace">
            <layout class="QGridLayout" name="gridLayout_9">
             <property name="leftMargin">
              <number>0</number>
             </property>
             <property name="topMargin">
              <number>0</number>
             </property>
             <property name="rightMargin">
              <number>0</number>
             </property>
             <property name="bottomMargin">
              <number>0</number>
             </property>
             <property name="spacing">
              <number>0</number>
             </property>
             <item row="0" column="0">
              <widget class="QTableWidget" name="tableWidget_StackTrace">
               <property name="font">
                <font>
                 <pointsize>9</pointsize>
                </font>
               </property>
               <property name="editTriggers">
                <set>QAbstractItemView::NoEditTriggers</set>
               </property>
               <property name="selectionMode">
                <enum>QAbstractItemView::SingleSelection</enum>
               </property>
               <property name="selectionBehavior">
                <enum>QAbstractItemView::SelectRows</enum>
               </property>
               <attribute name="horizontalHeaderStretchLastSection">
                <bool>true</bool>
               </attribute>
               <attribute name="verticalHeaderVisible">
                <bool>false</bool>
               </attribute>
               <attribute name="verticalHeaderMinimumSectionSize">
                <number>16</number>
               </attribute>
               <attribute name="verticalHeaderDefaultSectionSize">
                <number>16</number>
               </attribute>
               <column>
                <property name="text">
                 <string>Return Address</string>
                </property>
               </column>
               <column>
                <property name="text">
                 <string>Frame Address</string>
                </property>
               </column>
              </widget>
             </item>
            </layout>
           </widget>
           <widget class="QWidget" name="Stack">
            <layout class="QGridLayout" name="gridLayout_10">
             <property name="leftMargin">
              <number>0</number>
             </property>
             <property name="topMargin">
              <number>0</number>
             </property>
             <property name="rightMargin">
              <number>0</number>
             </property>
             <property name="bottomMargin">
              <number>0</number>
             </property>
             <property name="spacing">
              <number>0</number>
             </property>
             <item row="0" column="0">
              <widget class="QTableWidget" name="tableWidget_Stack">
               <property name="font">
                <font>
                 <pointsize>9</pointsize>
                </font>
               </property>
               <property name="editTriggers">
                <set>QAbstractItemView::NoEditTriggers</set>
               </property>
               <property name="selectionMode">
                <enum>QAbstractItemView::SingleSelection</enum>
               </property>
               <property name="selectionBehavior">
                <enum>QAbstractItemView::SelectRows</enum>
               </property>
               <attribute name="horizontalHeaderStretchLastSection">
                <bool>true</bool>
               </attribute>
               <attribute name="verticalHeaderVisible">
                <bool>false</bool>
               </attribute>
               <attribute name="verticalHeaderMinimumSectionSize">
                <number>16</number>
               </attribute>
               <attribute name="verticalHeaderDefaultSectionSize">
                <number>16</number>
               </attribute>
               <column>
                <property name="text">
                 <string>Address</string>
                </property>
               </column>
               <column>
                <property name="text">
                 <string>Value</string>
                </property>
               </column>
               <column>
                <property name="text">
                 <string>Points to</string>
                </property>
               </column>
              </widget>
             </item>
            </layout>
           </widget>
          </widget>
         </item>
        </layout>
       </widget>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>800</width>
     <height>30</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuView">
    <property name="title">
     <string>V&amp;iew</string>
    </property>
    <addaction name="actionBookmarks"/>
    <addaction name="actionStackTrace_Info"/>
    <addaction name="actionBreakpoints"/>
    <addaction name="actionFunctions"/>
    <addaction name="actionGDB_Log_File"/>
    <addaction name="actionMemory_Regions"/>
    <addaction name="actionRestore_Instructions"/>
    <addaction name="separator"/>
    <addaction name="actionReferenced_Strings"/>
    <addaction name="actionReferenced_Calls"/>
   </widget>
   <widget class="QMenu" name="menuDebug">
    <property name="title">
     <string>&amp;Debug</string>
    </property>
    <addaction name="actionRun"/>
    <addaction name="actionBreak"/>
    <addaction name="separator"/>
    <addaction name="actionStep"/>
    <addaction name="actionStep_Over"/>
    <addaction name="actionExecute_Till_Return"/>
    <addaction name="actionToggle_Breakpoint"/>
    <addaction name="actionSet_Address"/>
    <addaction name="separator"/>
    <addaction name="actionToggle_Attach"/>
   </widget>
   <widget class="QMenu" name="menuTools">
    <property name="title">
     <string>&amp;Tools</string>
    </property>
    <addaction name="actionInject_so_file"/>
    <addaction name="actionCall_Function"/>
    <addaction name="actionSearch_Opcode"/>
    <addaction name="actionDissect_Code"/>
   </widget>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>Fi&amp;le</string>
    </property>
    <addaction name="actionLoad_Trace"/>
   </widget>
   <widget class="QMenu" name="menuHelp">
    <property name="title">
     <string>Help</string>
    </property>
    <addaction name="actionlibpince"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuView"/>
   <addaction name="menuDebug"/>
   <addaction name="menuTools"/>
   <addaction name="menuHelp"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <action name="actionBookmarks">
   <property name="text">
    <string>&amp;Bookmarks</string>
   </property>
  </action>
  <action name="actionStackTrace_Info">
   <property name="text">
    <string>&amp;StackTrace Info</string>
   </property>
  </action>
  <action name="actionInject_so_file">
   <property name="text">
    <string>&amp;Inject .so file</string>
   </property>
  </action>
  <action name="actionRun">
   <property name="text">
    <string>&amp;Break</string>
   </property>
  </action>
  <action name="actionBreak">
   <property name="text">
    <string>&amp;Run</string>
   </property>
  </action>
  <action name="actionStep">
   <property name="text">
    <string>&amp;Step[F7]</string>
   </property>
  </action>
  <action name="actionStep_Over">
   <property name="text">
    <string>Step &amp;Over[F8]</string>
   </property>
  </action>
  <action name="actionExecute_Till_Return">
   <property name="text">
    <string>&amp;Execute Till Return[Shift+F8]</string>
   </property>
  </action>
  <action name="actionToggle_Breakpoint">
   <property name="text">
    <string>&amp;Toggle Breakpoint[F5]</string>
   </property>
  </action>
  <action name="actionBreakpoints">
   <property name="text">
    <string>B&amp;reakpoints</string>
   </property>
  </action>
  <action name="actionFunctions">
   <property name="text">
    <string>&amp;Functions</string>
   </property>
  </action>
  <action name="actionSet_Address">
   <property name="text">
    <string>Set Address[Shift+F4]</string>
   </property>
  </action>
  <action name="actionCall_Function">
   <property name="text">
    <string>&amp;Call Function</string>
   </property>
  </action>
  <action name="actionLoad_Trace">
   <property name="text">
    <string>&amp;Load Trace</string>
   </property>
  </action>
  <action name="actionlibpince">
   <property name="text">
    <string>&amp;libpince</string>
   </property>
  </action>
  <action name="actionGDB_Log_File">
   <property name="text">
    <string>&amp;GDB Log File</string>
   </property>
  </action>
  <action name="actionSearch_Opcode">
   <property name="text">
    <string>&amp;Search Opcode</string>
   </property>
  </action>
  <action name="actionMemory_Regions">
   <property name="text">
    <string>&amp;Memory Regions</string>
   </property>
  </action>
  <action name="actionDissect_Code">
   <property name="text">
    <string>&amp;Dissect Code</string>
   </property>
  </action>
  <action name="actionReferenced_Strings">
   <property name="text">
    <string>R&amp;eferenced Strings</string>
   </property>
  </action>
  <action name="actionReferenced_Calls">
   <property name="text">
    <string>Referenced &amp;Calls</string>
   </property>
  </action>
  <action name="actionToggle_Attach">
   <property name="text">
    <string>To&amp;ggle Attach</string>
   </property>
  </action>
  <action name="actionRestore_Instructions">
   <property name="text">
    <string>Restore Instructions</string>
   </property>
  </action>
 </widget>
 <customwidgets>
  <customwidget>
   <class>QRegisterLabel</class>
   <extends>QLabel</extends>
   <header location="global">GUI.CustomLabels.RegisterLabel</header>
  </customwidget>
  <customwidget>
   <class>QFlagRegisterLabel</class>
   <extends>QLabel</extends>
   <header location="global">GUI.CustomLabels.FlagRegisterLabel</header>
  </customwidget>
  <customwidget>
   <class>QHexView</class>
   <extends>QTableView</extends>
   <header location="global">GUI.CustomTableViews.HexView</header>
  </customwidget>
  <customwidget>
   <class>QAsciiView</class>
   <extends>QTableView</extends>
   <header location="global">GUI.CustomTableViews.AsciiView</header>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>

```

`GUI/Notes.txt`:

```txt
IMPORTANT: SettingsDialog.ui: Don't try to add a QKeySequenceEdit to the 2nd widget of stacked widget, pyuic5 gives error when QKeySequenceEdit is used. I had to implement it in PINCE.py because of this unfortunately. Check SettingsDialogForm class for the usage.

6/10/2016 - HexView section of MemoryViewerWindow.ui: Changed listWidget_HexView_Address to tableWidget_HexView_Address in order to prevent possible future visual bugs. Logically, it should stay as a listwidget considering it's functionality. But it doesn't play nice with the other neighboring tablewidgets in different pyqt versions, forcing me to use magic numbers for adjusting, which is disgusting(I got the rhymes woohoo)
```

`GUI/ReferencedCallsWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ReferencedCallsWidget.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(1025, 530)
        Form.setToolTip("")
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter = QtWidgets.QSplitter(Form)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.layoutWidget = QtWidgets.QWidget(self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.lineEdit_Regex = QtWidgets.QLineEdit(self.layoutWidget)
        self.lineEdit_Regex.setObjectName("lineEdit_Regex")
        self.horizontalLayout_2.addWidget(self.lineEdit_Regex)
        self.checkBox_CaseSensitive = QtWidgets.QCheckBox(self.layoutWidget)
        self.checkBox_CaseSensitive.setObjectName("checkBox_CaseSensitive")
        self.horizontalLayout_2.addWidget(self.checkBox_CaseSensitive)
        self.checkBox_Regex = QtWidgets.QCheckBox(self.layoutWidget)
        self.checkBox_Regex.setObjectName("checkBox_Regex")
        self.horizontalLayout_2.addWidget(self.checkBox_Regex)
        self.pushButton_Search = QtWidgets.QPushButton(self.layoutWidget)
        self.pushButton_Search.setObjectName("pushButton_Search")
        self.horizontalLayout_2.addWidget(self.pushButton_Search)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.tableWidget_References = QtWidgets.QTableWidget(self.layoutWidget)
        self.tableWidget_References.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_References.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_References.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_References.setObjectName("tableWidget_References")
        self.tableWidget_References.setColumnCount(2)
        self.tableWidget_References.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_References.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_References.setHorizontalHeaderItem(1, item)
        self.tableWidget_References.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_References.verticalHeader().setVisible(False)
        self.tableWidget_References.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_References.verticalHeader().setMinimumSectionSize(16)
        self.verticalLayout.addWidget(self.tableWidget_References)
        self.listWidget_Referrers = QtWidgets.QListWidget(self.splitter)
        self.listWidget_Referrers.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.listWidget_Referrers.setObjectName("listWidget_Referrers")
        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Referenced Calls"))
        self.lineEdit_Regex.setPlaceholderText(_translate("Form", "Enter a string or a python regex"))
        self.checkBox_CaseSensitive.setToolTip(_translate("Form", "Ignore case if checked"))
        self.checkBox_CaseSensitive.setText(_translate("Form", "Case sensitive"))
        self.checkBox_Regex.setToolTip(_translate("Form", "Your string will be treated as a regex if checked"))
        self.checkBox_Regex.setText(_translate("Form", "Regex"))
        self.pushButton_Search.setText(_translate("Form", "Search(Enter)"))
        self.tableWidget_References.setSortingEnabled(True)
        item = self.tableWidget_References.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Address"))
        item = self.tableWidget_References.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Refcount"))


```

`GUI/ReferencedCallsWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1025</width>
    <height>530</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Referenced Calls</string>
  </property>
  <property name="toolTip">
   <string/>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <widget class="QWidget" name="layoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <item>
          <widget class="QLineEdit" name="lineEdit_Regex">
           <property name="placeholderText">
            <string>Enter a string or a python regex</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="checkBox_CaseSensitive">
           <property name="toolTip">
            <string>Ignore case if checked</string>
           </property>
           <property name="text">
            <string>Case sensitive</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="checkBox_Regex">
           <property name="toolTip">
            <string>Your string will be treated as a regex if checked</string>
           </property>
           <property name="text">
            <string>Regex</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="pushButton_Search">
           <property name="text">
            <string>Search(Enter)</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QTableWidget" name="tableWidget_References">
         <property name="editTriggers">
          <set>QAbstractItemView::NoEditTriggers</set>
         </property>
         <property name="selectionMode">
          <enum>QAbstractItemView::SingleSelection</enum>
         </property>
         <property name="selectionBehavior">
          <enum>QAbstractItemView::SelectRows</enum>
         </property>
         <property name="sortingEnabled">
          <bool>true</bool>
         </property>
         <attribute name="horizontalHeaderStretchLastSection">
          <bool>true</bool>
         </attribute>
         <attribute name="verticalHeaderVisible">
          <bool>false</bool>
         </attribute>
         <attribute name="verticalHeaderDefaultSectionSize">
          <number>16</number>
         </attribute>
         <attribute name="verticalHeaderMinimumSectionSize">
          <number>16</number>
         </attribute>
         <column>
          <property name="text">
           <string>Address</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Refcount</string>
          </property>
         </column>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QListWidget" name="listWidget_Referrers">
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/ReferencedStringsWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ReferencedStringsWidget.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(1025, 530)
        Form.setToolTip("")
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter = QtWidgets.QSplitter(Form)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.layoutWidget = QtWidgets.QWidget(self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.lineEdit_Regex = QtWidgets.QLineEdit(self.layoutWidget)
        self.lineEdit_Regex.setObjectName("lineEdit_Regex")
        self.horizontalLayout_2.addWidget(self.lineEdit_Regex)
        self.checkBox_CaseSensitive = QtWidgets.QCheckBox(self.layoutWidget)
        self.checkBox_CaseSensitive.setObjectName("checkBox_CaseSensitive")
        self.horizontalLayout_2.addWidget(self.checkBox_CaseSensitive)
        self.checkBox_Regex = QtWidgets.QCheckBox(self.layoutWidget)
        self.checkBox_Regex.setObjectName("checkBox_Regex")
        self.horizontalLayout_2.addWidget(self.checkBox_Regex)
        self.pushButton_Search = QtWidgets.QPushButton(self.layoutWidget)
        self.pushButton_Search.setObjectName("pushButton_Search")
        self.horizontalLayout_2.addWidget(self.pushButton_Search)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.tableWidget_References = QtWidgets.QTableWidget(self.layoutWidget)
        self.tableWidget_References.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_References.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_References.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_References.setObjectName("tableWidget_References")
        self.tableWidget_References.setColumnCount(3)
        self.tableWidget_References.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_References.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_References.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_References.setHorizontalHeaderItem(2, item)
        self.tableWidget_References.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_References.verticalHeader().setVisible(False)
        self.tableWidget_References.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_References.verticalHeader().setMinimumSectionSize(16)
        self.verticalLayout.addWidget(self.tableWidget_References)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.comboBox_ValueType = QtWidgets.QComboBox(self.layoutWidget)
        self.comboBox_ValueType.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
        self.comboBox_ValueType.setObjectName("comboBox_ValueType")
        self.horizontalLayout.addWidget(self.comboBox_ValueType)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.listWidget_Referrers = QtWidgets.QListWidget(self.splitter)
        self.listWidget_Referrers.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.listWidget_Referrers.setObjectName("listWidget_Referrers")
        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)

        self.retranslateUi(Form)
        self.comboBox_ValueType.setCurrentIndex(-1)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Referenced Strings and Values"))
        self.lineEdit_Regex.setPlaceholderText(_translate("Form", "Enter a string or a python regex"))
        self.checkBox_CaseSensitive.setToolTip(_translate("Form", "Ignore case if checked"))
        self.checkBox_CaseSensitive.setText(_translate("Form", "Case sensitive"))
        self.checkBox_Regex.setToolTip(_translate("Form", "Your string will be treated as a regex if checked"))
        self.checkBox_Regex.setText(_translate("Form", "Regex"))
        self.pushButton_Search.setText(_translate("Form", "Search(Enter)"))
        self.tableWidget_References.setSortingEnabled(True)
        item = self.tableWidget_References.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Address"))
        item = self.tableWidget_References.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Refcount"))
        item = self.tableWidget_References.horizontalHeaderItem(2)
        item.setText(_translate("Form", "Value"))


```

`GUI/ReferencedStringsWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1025</width>
    <height>530</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Referenced Strings and Values</string>
  </property>
  <property name="toolTip">
   <string/>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <widget class="QWidget" name="layoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <item>
          <widget class="QLineEdit" name="lineEdit_Regex">
           <property name="placeholderText">
            <string>Enter a string or a python regex</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="checkBox_CaseSensitive">
           <property name="toolTip">
            <string>Ignore case if checked</string>
           </property>
           <property name="text">
            <string>Case sensitive</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="checkBox_Regex">
           <property name="toolTip">
            <string>Your string will be treated as a regex if checked</string>
           </property>
           <property name="text">
            <string>Regex</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="pushButton_Search">
           <property name="text">
            <string>Search(Enter)</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QTableWidget" name="tableWidget_References">
         <property name="editTriggers">
          <set>QAbstractItemView::NoEditTriggers</set>
         </property>
         <property name="selectionMode">
          <enum>QAbstractItemView::SingleSelection</enum>
         </property>
         <property name="selectionBehavior">
          <enum>QAbstractItemView::SelectRows</enum>
         </property>
         <property name="sortingEnabled">
          <bool>true</bool>
         </property>
         <attribute name="horizontalHeaderStretchLastSection">
          <bool>true</bool>
         </attribute>
         <attribute name="verticalHeaderVisible">
          <bool>false</bool>
         </attribute>
         <attribute name="verticalHeaderDefaultSectionSize">
          <number>16</number>
         </attribute>
         <attribute name="verticalHeaderMinimumSectionSize">
          <number>16</number>
         </attribute>
         <column>
          <property name="text">
           <string>Address</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Refcount</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Value</string>
          </property>
         </column>
        </widget>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout">
         <item>
          <spacer name="horizontalSpacer">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>40</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
         <item>
          <widget class="QComboBox" name="comboBox_ValueType">
           <property name="currentIndex">
            <number>-1</number>
           </property>
           <property name="sizeAdjustPolicy">
            <enum>QComboBox::AdjustToContents</enum>
           </property>
          </widget>
         </item>
        </layout>
       </item>
      </layout>
     </widget>
     <widget class="QListWidget" name="listWidget_Referrers">
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/RestoreInstructionsWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'RestoreInstructionsWidget.ui'
#
# Created by: PyQt5 UI code generator 5.14.1
#
# WARNING! All changes made in this file will be lost!


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(400, 400)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.tableWidget_Instructions = QtWidgets.QTableWidget(Form)
        self.tableWidget_Instructions.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_Instructions.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_Instructions.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_Instructions.setObjectName("tableWidget_Instructions")
        self.tableWidget_Instructions.setColumnCount(2)
        self.tableWidget_Instructions.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Instructions.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Instructions.setHorizontalHeaderItem(1, item)
        self.tableWidget_Instructions.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Instructions.verticalHeader().setVisible(False)
        self.tableWidget_Instructions.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Instructions.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout.addWidget(self.tableWidget_Instructions, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Restore Instructions"))
        self.tableWidget_Instructions.setSortingEnabled(True)
        item = self.tableWidget_Instructions.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Address"))
        item = self.tableWidget_Instructions.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Original Instruction"))

```

`GUI/RestoreInstructionsWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>400</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Restore Instructions</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QTableWidget" name="tableWidget_Instructions">
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>16</number>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>16</number>
     </attribute>
     <column>
      <property name="text">
       <string>Address</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Original Instruction</string>
      </property>
     </column>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/SearchOpcodeWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'SearchOpcodeWidget.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(631, 490)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label_3 = QtWidgets.QLabel(Form)
        self.label_3.setObjectName("label_3")
        self.horizontalLayout_2.addWidget(self.label_3)
        self.lineEdit_Regex = QtWidgets.QLineEdit(Form)
        self.lineEdit_Regex.setObjectName("lineEdit_Regex")
        self.horizontalLayout_2.addWidget(self.lineEdit_Regex)
        self.checkBox_CaseSensitive = QtWidgets.QCheckBox(Form)
        self.checkBox_CaseSensitive.setObjectName("checkBox_CaseSensitive")
        self.horizontalLayout_2.addWidget(self.checkBox_CaseSensitive)
        self.checkBox_Regex = QtWidgets.QCheckBox(Form)
        self.checkBox_Regex.setObjectName("checkBox_Regex")
        self.horizontalLayout_2.addWidget(self.checkBox_Regex)
        self.pushButton_Search = QtWidgets.QPushButton(Form)
        self.pushButton_Search.setObjectName("pushButton_Search")
        self.horizontalLayout_2.addWidget(self.pushButton_Search)
        self.pushButton_Help = QtWidgets.QPushButton(Form)
        self.pushButton_Help.setText("")
        self.pushButton_Help.setObjectName("pushButton_Help")
        self.horizontalLayout_2.addWidget(self.pushButton_Help)
        self.gridLayout.addLayout(self.horizontalLayout_2, 0, 0, 1, 1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(Form)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.lineEdit_Start = QtWidgets.QLineEdit(Form)
        self.lineEdit_Start.setObjectName("lineEdit_Start")
        self.horizontalLayout.addWidget(self.lineEdit_Start)
        self.label_2 = QtWidgets.QLabel(Form)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout.addWidget(self.label_2)
        self.lineEdit_End = QtWidgets.QLineEdit(Form)
        self.lineEdit_End.setObjectName("lineEdit_End")
        self.horizontalLayout.addWidget(self.lineEdit_End)
        self.gridLayout.addLayout(self.horizontalLayout, 1, 0, 1, 1)
        self.tableWidget_Opcodes = QtWidgets.QTableWidget(Form)
        self.tableWidget_Opcodes.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_Opcodes.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_Opcodes.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_Opcodes.setObjectName("tableWidget_Opcodes")
        self.tableWidget_Opcodes.setColumnCount(2)
        self.tableWidget_Opcodes.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Opcodes.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Opcodes.setHorizontalHeaderItem(1, item)
        self.tableWidget_Opcodes.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Opcodes.verticalHeader().setVisible(False)
        self.tableWidget_Opcodes.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Opcodes.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout.addWidget(self.tableWidget_Opcodes, 2, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Search for Opcodes"))
        self.label_3.setText(_translate("Form", "Regex"))
        self.lineEdit_Regex.setPlaceholderText(_translate("Form", "Enter a string or a python regex"))
        self.checkBox_CaseSensitive.setToolTip(_translate("Form", "Ignore case if checked"))
        self.checkBox_CaseSensitive.setText(_translate("Form", "Case sensitive"))
        self.checkBox_Regex.setToolTip(_translate("Form", "Your string will be treated as a regex if checked"))
        self.checkBox_Regex.setText(_translate("Form", "Regex"))
        self.pushButton_Search.setText(_translate("Form", "Search(Enter)"))
        self.label.setText(_translate("Form", "Start"))
        self.label_2.setText(_translate("Form", "End"))
        self.tableWidget_Opcodes.setSortingEnabled(True)
        item = self.tableWidget_Opcodes.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Address"))
        item = self.tableWidget_Opcodes.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Opcodes"))


```

`GUI/SearchOpcodeWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>631</width>
    <height>490</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Search for Opcodes</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QLabel" name="label_3">
       <property name="text">
        <string>Regex</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_Regex">
       <property name="placeholderText">
        <string>Enter a string or a python regex</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_CaseSensitive">
       <property name="toolTip">
        <string>Ignore case if checked</string>
       </property>
       <property name="text">
        <string>Case sensitive</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_Regex">
       <property name="toolTip">
        <string>Your string will be treated as a regex if checked</string>
       </property>
       <property name="text">
        <string>Regex</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Search">
       <property name="text">
        <string>Search(Enter)</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Help">
       <property name="text">
        <string/>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Start</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_Start"/>
     </item>
     <item>
      <widget class="QLabel" name="label_2">
       <property name="text">
        <string>End</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_End"/>
     </item>
    </layout>
   </item>
   <item row="2" column="0">
    <widget class="QTableWidget" name="tableWidget_Opcodes">
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>16</number>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>16</number>
     </attribute>
     <column>
      <property name="text">
       <string>Address</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Opcodes</string>
      </property>
     </column>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/SelectProcess.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'SelectProcess.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.setWindowModality(QtCore.Qt.WindowModal)
        MainWindow.resize(443, 420)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.lineEdit_SearchProcess = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_SearchProcess.setObjectName("lineEdit_SearchProcess")
        self.horizontalLayout.addWidget(self.lineEdit_SearchProcess)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.tableWidget_ProcessTable = QtWidgets.QTableWidget(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tableWidget_ProcessTable.sizePolicy().hasHeightForWidth())
        self.tableWidget_ProcessTable.setSizePolicy(sizePolicy)
        self.tableWidget_ProcessTable.setAutoFillBackground(False)
        self.tableWidget_ProcessTable.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustIgnored)
        self.tableWidget_ProcessTable.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_ProcessTable.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_ProcessTable.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_ProcessTable.setObjectName("tableWidget_ProcessTable")
        self.tableWidget_ProcessTable.setColumnCount(3)
        self.tableWidget_ProcessTable.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_ProcessTable.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_ProcessTable.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignVCenter)
        self.tableWidget_ProcessTable.setHorizontalHeaderItem(2, item)
        self.tableWidget_ProcessTable.horizontalHeader().setDefaultSectionSize(70)
        self.tableWidget_ProcessTable.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_ProcessTable.verticalHeader().setVisible(False)
        self.tableWidget_ProcessTable.verticalHeader().setStretchLastSection(False)
        self.verticalLayout.addWidget(self.tableWidget_ProcessTable)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem)
        self.pushButton_Open = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_Open.setObjectName("pushButton_Open")
        self.horizontalLayout_2.addWidget(self.pushButton_Open)
        self.pushButton_Close = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_Close.setObjectName("pushButton_Close")
        self.horizontalLayout_2.addWidget(self.pushButton_Close)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem1)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem2)
        self.pushButton_CreateProcess = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_CreateProcess.setObjectName("pushButton_CreateProcess")
        self.horizontalLayout_3.addWidget(self.pushButton_CreateProcess)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem3)
        self.verticalLayout.addLayout(self.horizontalLayout_3)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Please select a Process"))
        self.label.setText(_translate("MainWindow", "Name of the Process:"))
        self.tableWidget_ProcessTable.setSortingEnabled(True)
        item = self.tableWidget_ProcessTable.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow", "PID"))
        item = self.tableWidget_ProcessTable.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow", "Username"))
        item = self.tableWidget_ProcessTable.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow", "Process Name"))
        self.pushButton_Open.setToolTip(_translate("MainWindow", "Attach to the selected process"))
        self.pushButton_Open.setText(_translate("MainWindow", "Open"))
        self.pushButton_Close.setText(_translate("MainWindow", "Cancel"))
        self.pushButton_CreateProcess.setToolTip(_translate("MainWindow", "Open an executable"))
        self.pushButton_CreateProcess.setText(_translate("MainWindow", "Create Process[F1]"))


```

`GUI/SelectProcess.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="windowModality">
   <enum>Qt::WindowModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>443</width>
    <height>420</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Please select a Process</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout">
    <item>
     <layout class="QHBoxLayout" name="horizontalLayout">
      <item>
       <widget class="QLabel" name="label">
        <property name="text">
         <string>Name of the Process:</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QLineEdit" name="lineEdit_SearchProcess"/>
      </item>
     </layout>
    </item>
    <item>
     <widget class="QTableWidget" name="tableWidget_ProcessTable">
      <property name="sizePolicy">
       <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
        <horstretch>0</horstretch>
        <verstretch>0</verstretch>
       </sizepolicy>
      </property>
      <property name="autoFillBackground">
       <bool>false</bool>
      </property>
      <property name="sizeAdjustPolicy">
       <enum>QAbstractScrollArea::AdjustIgnored</enum>
      </property>
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
      <property name="selectionMode">
       <enum>QAbstractItemView::SingleSelection</enum>
      </property>
      <property name="selectionBehavior">
       <enum>QAbstractItemView::SelectRows</enum>
      </property>
      <property name="sortingEnabled">
       <bool>true</bool>
      </property>
      <attribute name="horizontalHeaderDefaultSectionSize">
       <number>70</number>
      </attribute>
      <attribute name="horizontalHeaderStretchLastSection">
       <bool>true</bool>
      </attribute>
      <attribute name="verticalHeaderVisible">
       <bool>false</bool>
      </attribute>
      <attribute name="verticalHeaderStretchLastSection">
       <bool>false</bool>
      </attribute>
      <column>
       <property name="text">
        <string>PID</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Username</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Process Name</string>
       </property>
       <property name="textAlignment">
        <set>AlignLeading|AlignVCenter</set>
       </property>
      </column>
     </widget>
    </item>
    <item>
     <layout class="QHBoxLayout" name="horizontalLayout_2">
      <item>
       <spacer name="horizontalSpacer_3">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Open">
        <property name="toolTip">
         <string>Attach to the selected process</string>
        </property>
        <property name="text">
         <string>Open</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Close">
        <property name="text">
         <string>Cancel</string>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer_4">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
     </layout>
    </item>
    <item>
     <layout class="QHBoxLayout" name="horizontalLayout_3">
      <item>
       <spacer name="horizontalSpacer">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_CreateProcess">
        <property name="toolTip">
         <string>Open an executable</string>
        </property>
        <property name="text">
         <string>Create Process[F1]</string>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer_2">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
     </layout>
    </item>
   </layout>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/SettingsDialog.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'SettingsDialog.ui'
#
# Created by: PyQt5 UI code generator 5.14.1
#
# WARNING! All changes made in this file will be lost!


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(884, 633)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.listWidget_Options = QtWidgets.QListWidget(Dialog)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.listWidget_Options.sizePolicy().hasHeightForWidth())
        self.listWidget_Options.setSizePolicy(sizePolicy)
        self.listWidget_Options.setMaximumSize(QtCore.QSize(130, 16777215))
        self.listWidget_Options.setObjectName("listWidget_Options")
        item = QtWidgets.QListWidgetItem()
        self.listWidget_Options.addItem(item)
        item = QtWidgets.QListWidgetItem()
        self.listWidget_Options.addItem(item)
        item = QtWidgets.QListWidgetItem()
        self.listWidget_Options.addItem(item)
        item = QtWidgets.QListWidgetItem()
        self.listWidget_Options.addItem(item)
        item = QtWidgets.QListWidgetItem()
        self.listWidget_Options.addItem(item)
        self.horizontalLayout_2.addWidget(self.listWidget_Options)
        self.stackedWidget = QtWidgets.QStackedWidget(Dialog)
        self.stackedWidget.setMinimumSize(QtCore.QSize(500, 500))
        self.stackedWidget.setObjectName("stackedWidget")
        self.page = QtWidgets.QWidget()
        self.page.setObjectName("page")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.page)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout()
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.checkBox_AutoUpdateAddressTable = QtWidgets.QCheckBox(self.page)
        self.checkBox_AutoUpdateAddressTable.setChecked(True)
        self.checkBox_AutoUpdateAddressTable.setObjectName("checkBox_AutoUpdateAddressTable")
        self.verticalLayout_2.addWidget(self.checkBox_AutoUpdateAddressTable)
        self.verticalLayout_3.addLayout(self.verticalLayout_2)
        self.QWidget_UpdateInterval = QtWidgets.QWidget(self.page)
        self.QWidget_UpdateInterval.setObjectName("QWidget_UpdateInterval")
        self.horizontalLayout_UpdateInterval = QtWidgets.QHBoxLayout(self.QWidget_UpdateInterval)
        self.horizontalLayout_UpdateInterval.setContentsMargins(-1, 0, -1, -1)
        self.horizontalLayout_UpdateInterval.setObjectName("horizontalLayout_UpdateInterval")
        self.label = QtWidgets.QLabel(self.QWidget_UpdateInterval)
        self.label.setMinimumSize(QtCore.QSize(102, 0))
        self.label.setObjectName("label")
        self.horizontalLayout_UpdateInterval.addWidget(self.label)
        self.lineEdit_UpdateInterval = QtWidgets.QLineEdit(self.QWidget_UpdateInterval)
        self.lineEdit_UpdateInterval.setObjectName("lineEdit_UpdateInterval")
        self.horizontalLayout_UpdateInterval.addWidget(self.lineEdit_UpdateInterval)
        self.label_2 = QtWidgets.QLabel(self.QWidget_UpdateInterval)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_UpdateInterval.addWidget(self.label_2)
        self.verticalLayout_3.addWidget(self.QWidget_UpdateInterval)
        self.LockInterval = QtWidgets.QWidget(self.page)
        self.LockInterval.setObjectName("LockInterval")
        self.horizontalLayout_14 = QtWidgets.QHBoxLayout(self.LockInterval)
        self.horizontalLayout_14.setContentsMargins(-1, 0, -1, -1)
        self.horizontalLayout_14.setObjectName("horizontalLayout_14")
        self.label_12 = QtWidgets.QLabel(self.LockInterval)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_12.sizePolicy().hasHeightForWidth())
        self.label_12.setSizePolicy(sizePolicy)
        self.label_12.setMinimumSize(QtCore.QSize(102, 0))
        self.label_12.setBaseSize(QtCore.QSize(0, 0))
        self.label_12.setObjectName("label_12")
        self.horizontalLayout_14.addWidget(self.label_12)
        self.lineEdit_FreezeInterval = QtWidgets.QLineEdit(self.LockInterval)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lineEdit_FreezeInterval.sizePolicy().hasHeightForWidth())
        self.lineEdit_FreezeInterval.setSizePolicy(sizePolicy)
        self.lineEdit_FreezeInterval.setBaseSize(QtCore.QSize(20, 0))
        self.lineEdit_FreezeInterval.setObjectName("lineEdit_FreezeInterval")
        self.horizontalLayout_14.addWidget(self.lineEdit_FreezeInterval)
        self.label_10 = QtWidgets.QLabel(self.LockInterval)
        self.label_10.setObjectName("label_10")
        self.horizontalLayout_14.addWidget(self.label_10)
        self.verticalLayout_3.addWidget(self.LockInterval)
        self.horizontalLayout_7.addLayout(self.verticalLayout_3)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_7.addItem(spacerItem)
        self.verticalLayout_5.addLayout(self.horizontalLayout_7)
        self.checkBox_MessageBoxOnException = QtWidgets.QCheckBox(self.page)
        self.checkBox_MessageBoxOnException.setChecked(True)
        self.checkBox_MessageBoxOnException.setObjectName("checkBox_MessageBoxOnException")
        self.verticalLayout_5.addWidget(self.checkBox_MessageBoxOnException)
        self.checkBox_MessageBoxOnToggleAttach = QtWidgets.QCheckBox(self.page)
        self.checkBox_MessageBoxOnToggleAttach.setChecked(True)
        self.checkBox_MessageBoxOnToggleAttach.setObjectName("checkBox_MessageBoxOnToggleAttach")
        self.verticalLayout_5.addWidget(self.checkBox_MessageBoxOnToggleAttach)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.label_8 = QtWidgets.QLabel(self.page)
        self.label_8.setObjectName("label_8")
        self.horizontalLayout_3.addWidget(self.label_8)
        self.checkBox_OutputModeAsync = QtWidgets.QCheckBox(self.page)
        self.checkBox_OutputModeAsync.setChecked(True)
        self.checkBox_OutputModeAsync.setObjectName("checkBox_OutputModeAsync")
        self.horizontalLayout_3.addWidget(self.checkBox_OutputModeAsync)
        self.checkBox_OutputModeCommand = QtWidgets.QCheckBox(self.page)
        self.checkBox_OutputModeCommand.setChecked(True)
        self.checkBox_OutputModeCommand.setObjectName("checkBox_OutputModeCommand")
        self.horizontalLayout_3.addWidget(self.checkBox_OutputModeCommand)
        self.checkBox_OutputModeCommandInfo = QtWidgets.QCheckBox(self.page)
        self.checkBox_OutputModeCommandInfo.setChecked(True)
        self.checkBox_OutputModeCommandInfo.setObjectName("checkBox_OutputModeCommandInfo")
        self.horizontalLayout_3.addWidget(self.checkBox_OutputModeCommandInfo)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem1)
        self.verticalLayout_5.addLayout(self.horizontalLayout_3)
        self.horizontalLayout_12 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_12.setContentsMargins(-1, 0, -1, -1)
        self.horizontalLayout_12.setObjectName("horizontalLayout_12")
        self.label_9 = QtWidgets.QLabel(self.page)
        self.label_9.setObjectName("label_9")
        self.horizontalLayout_12.addWidget(self.label_9)
        self.lineEdit_AutoAttachList = QtWidgets.QLineEdit(self.page)
        self.lineEdit_AutoAttachList.setObjectName("lineEdit_AutoAttachList")
        self.horizontalLayout_12.addWidget(self.lineEdit_AutoAttachList)
        self.checkBox_AutoAttachRegex = QtWidgets.QCheckBox(self.page)
        self.checkBox_AutoAttachRegex.setObjectName("checkBox_AutoAttachRegex")
        self.horizontalLayout_12.addWidget(self.checkBox_AutoAttachRegex)
        self.verticalLayout_5.addLayout(self.horizontalLayout_12)
        self.horizontalLayout_15 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_15.setObjectName("horizontalLayout_15")
        self.label_11 = QtWidgets.QLabel(self.page)
        self.label_11.setObjectName("label_11")
        self.horizontalLayout_15.addWidget(self.label_11)
        self.comboBox_Logo = QtWidgets.QComboBox(self.page)
        self.comboBox_Logo.setObjectName("comboBox_Logo")
        self.horizontalLayout_15.addWidget(self.comboBox_Logo)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_15.addItem(spacerItem2)
        self.verticalLayout_5.addLayout(self.horizontalLayout_15)
        spacerItem3 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_5.addItem(spacerItem3)
        self.gridLayout_2.addLayout(self.verticalLayout_5, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.page)
        self.page_2 = QtWidgets.QWidget()
        self.page_2.setObjectName("page_2")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.page_2)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.label_3 = QtWidgets.QLabel(self.page_2)
        self.label_3.setObjectName("label_3")
        self.verticalLayout_4.addWidget(self.label_3)
        self.listWidget_Functions = QtWidgets.QListWidget(self.page_2)
        self.listWidget_Functions.setObjectName("listWidget_Functions")
        self.verticalLayout_4.addWidget(self.listWidget_Functions)
        self.horizontalLayout_5.addLayout(self.verticalLayout_4)
        self.verticalLayout_6 = QtWidgets.QVBoxLayout()
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.verticalLayout_Hotkey = QtWidgets.QVBoxLayout()
        self.verticalLayout_Hotkey.setObjectName("verticalLayout_Hotkey")
        self.label_4 = QtWidgets.QLabel(self.page_2)
        self.label_4.setObjectName("label_4")
        self.verticalLayout_Hotkey.addWidget(self.label_4)
        self.verticalLayout_6.addLayout(self.verticalLayout_Hotkey)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        spacerItem4 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem4)
        self.pushButton_ClearHotkey = QtWidgets.QPushButton(self.page_2)
        self.pushButton_ClearHotkey.setObjectName("pushButton_ClearHotkey")
        self.horizontalLayout_4.addWidget(self.pushButton_ClearHotkey)
        self.verticalLayout_6.addLayout(self.horizontalLayout_4)
        spacerItem5 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_6.addItem(spacerItem5)
        self.horizontalLayout_5.addLayout(self.verticalLayout_6)
        self.gridLayout_3.addLayout(self.horizontalLayout_5, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.page_2)
        self.page_3 = QtWidgets.QWidget()
        self.page_3.setObjectName("page_3")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.page_3)
        self.gridLayout_4.setObjectName("gridLayout_4")
        self.verticalLayout_9 = QtWidgets.QVBoxLayout()
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.verticalLayout_8 = QtWidgets.QVBoxLayout()
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.label_5 = QtWidgets.QLabel(self.page_3)
        self.label_5.setObjectName("label_5")
        self.verticalLayout_8.addWidget(self.label_5)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_6.addItem(spacerItem6)
        self.verticalLayout_7 = QtWidgets.QVBoxLayout()
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.radioButton_SimpleDLopenCall = QtWidgets.QRadioButton(self.page_3)
        self.radioButton_SimpleDLopenCall.setChecked(True)
        self.radioButton_SimpleDLopenCall.setObjectName("radioButton_SimpleDLopenCall")
        self.verticalLayout_7.addWidget(self.radioButton_SimpleDLopenCall)
        self.radioButton_AdvancedInjection = QtWidgets.QRadioButton(self.page_3)
        self.radioButton_AdvancedInjection.setEnabled(False)
        self.radioButton_AdvancedInjection.setObjectName("radioButton_AdvancedInjection")
        self.verticalLayout_7.addWidget(self.radioButton_AdvancedInjection)
        self.horizontalLayout_6.addLayout(self.verticalLayout_7)
        self.verticalLayout_8.addLayout(self.horizontalLayout_6)
        self.horizontalLayout_8.addLayout(self.verticalLayout_8)
        spacerItem7 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_8.addItem(spacerItem7)
        self.verticalLayout_9.addLayout(self.horizontalLayout_8)
        spacerItem8 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_9.addItem(spacerItem8)
        self.gridLayout_4.addLayout(self.verticalLayout_9, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.page_3)
        self.page_4 = QtWidgets.QWidget()
        self.page_4.setObjectName("page_4")
        self.gridLayout_5 = QtWidgets.QGridLayout(self.page_4)
        self.gridLayout_5.setObjectName("gridLayout_5")
        self.verticalLayout_10 = QtWidgets.QVBoxLayout()
        self.verticalLayout_10.setObjectName("verticalLayout_10")
        self.checkBox_BringDisassembleToFront = QtWidgets.QCheckBox(self.page_4)
        self.checkBox_BringDisassembleToFront.setChecked(True)
        self.checkBox_BringDisassembleToFront.setObjectName("checkBox_BringDisassembleToFront")
        self.verticalLayout_10.addWidget(self.checkBox_BringDisassembleToFront)
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.label_6 = QtWidgets.QLabel(self.page_4)
        self.label_6.setObjectName("label_6")
        self.horizontalLayout_9.addWidget(self.label_6)
        self.lineEdit_InstructionsPerScroll = QtWidgets.QLineEdit(self.page_4)
        self.lineEdit_InstructionsPerScroll.setObjectName("lineEdit_InstructionsPerScroll")
        self.horizontalLayout_9.addWidget(self.lineEdit_InstructionsPerScroll)
        self.horizontalLayout_10.addLayout(self.horizontalLayout_9)
        spacerItem9 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_10.addItem(spacerItem9)
        self.verticalLayout_10.addLayout(self.horizontalLayout_10)
        spacerItem10 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_10.addItem(spacerItem10)
        self.gridLayout_5.addLayout(self.verticalLayout_10, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.page_4)
        self.page_5 = QtWidgets.QWidget()
        self.page_5.setObjectName("page_5")
        self.gridLayout_6 = QtWidgets.QGridLayout(self.page_5)
        self.gridLayout_6.setObjectName("gridLayout_6")
        self.verticalLayout_11 = QtWidgets.QVBoxLayout()
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.horizontalLayout_11 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_11.setObjectName("horizontalLayout_11")
        self.horizontalLayout_101 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_101.setObjectName("horizontalLayout_101")
        self.label_7 = QtWidgets.QLabel(self.page_5)
        self.label_7.setObjectName("label_7")
        self.horizontalLayout_101.addWidget(self.label_7)
        self.lineEdit_GDBPath = QtWidgets.QLineEdit(self.page_5)
        self.lineEdit_GDBPath.setObjectName("lineEdit_GDBPath")
        self.horizontalLayout_101.addWidget(self.lineEdit_GDBPath)
        self.horizontalLayout_11.addLayout(self.horizontalLayout_101)
        self.pushButton_GDBPath = QtWidgets.QPushButton(self.page_5)
        self.pushButton_GDBPath.setText("")
        self.pushButton_GDBPath.setObjectName("pushButton_GDBPath")
        self.horizontalLayout_11.addWidget(self.pushButton_GDBPath)
        self.verticalLayout_11.addLayout(self.horizontalLayout_11)
        self.checkBox_GDBLogging = QtWidgets.QCheckBox(self.page_5)
        self.checkBox_GDBLogging.setObjectName("checkBox_GDBLogging")
        self.verticalLayout_11.addWidget(self.checkBox_GDBLogging)
        self.horizontalLayout_16 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_16.setObjectName("horizontalLayout_16")
        self.pushButton_HandleSignals = QtWidgets.QPushButton(self.page_5)
        self.pushButton_HandleSignals.setObjectName("pushButton_HandleSignals")
        self.horizontalLayout_16.addWidget(self.pushButton_HandleSignals)
        spacerItem11 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_16.addItem(spacerItem11)
        self.verticalLayout_11.addLayout(self.horizontalLayout_16)
        spacerItem12 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_11.addItem(spacerItem12)
        self.gridLayout_6.addLayout(self.verticalLayout_11, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.page_5)
        self.horizontalLayout_2.addWidget(self.stackedWidget)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.pushButton_ResetSettings = QtWidgets.QPushButton(Dialog)
        self.pushButton_ResetSettings.setObjectName("pushButton_ResetSettings")
        self.horizontalLayout.addWidget(self.pushButton_ResetSettings)
        spacerItem13 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem13)
        self.buttonBox = QtWidgets.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.horizontalLayout.addWidget(self.buttonBox)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.gridLayout.addLayout(self.verticalLayout, 0, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.stackedWidget.setCurrentIndex(0)
        self.listWidget_Functions.setCurrentRow(-1)
        self.buttonBox.accepted.connect(Dialog.accept)
        self.buttonBox.rejected.connect(Dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Settings"))
        __sortingEnabled = self.listWidget_Options.isSortingEnabled()
        self.listWidget_Options.setSortingEnabled(False)
        item = self.listWidget_Options.item(0)
        item.setText(_translate("Dialog", "General"))
        item = self.listWidget_Options.item(1)
        item.setText(_translate("Dialog", "Hotkeys"))
        item = self.listWidget_Options.item(2)
        item.setText(_translate("Dialog", "Code Injection"))
        item = self.listWidget_Options.item(3)
        item.setText(_translate("Dialog", "Disassemble"))
        item = self.listWidget_Options.item(4)
        item.setText(_translate("Dialog", "Debug"))
        self.listWidget_Options.setSortingEnabled(__sortingEnabled)
        self.checkBox_AutoUpdateAddressTable.setText(_translate("Dialog", "Auto-update address table"))
        self.label.setText(_translate("Dialog", "Update Interval"))
        self.lineEdit_UpdateInterval.setText(_translate("Dialog", "500"))
        self.label_2.setText(_translate("Dialog", "ms"))
        self.label_12.setText(_translate("Dialog", "Freeze Interval"))
        self.lineEdit_FreezeInterval.setText(_translate("Dialog", "100"))
        self.label_10.setText(_translate("Dialog", "ms"))
        self.checkBox_MessageBoxOnException.setText(_translate("Dialog", "Show a MessageBox on InferiorRunning and GDBInitialize exceptions"))
        self.checkBox_MessageBoxOnToggleAttach.setText(_translate("Dialog", "Show a MessageBox on Toggle Attach"))
        self.label_8.setText(_translate("Dialog", "GDB output:"))
        self.checkBox_OutputModeAsync.setText(_translate("Dialog", "Async"))
        self.checkBox_OutputModeCommand.setText(_translate("Dialog", "Command"))
        self.checkBox_OutputModeCommandInfo.setText(_translate("Dialog", "Command info"))
        self.label_9.setToolTip(_translate("Dialog", "On start, automatically attach to processes with name matching one of the entries\n"
"Patterns at former positions have higher priority if regex is off"))
        self.label_9.setText(_translate("Dialog", "Auto-attach on start"))
        self.checkBox_AutoAttachRegex.setText(_translate("Dialog", "Regex"))
        self.label_11.setText(_translate("Dialog", "Logo"))
        self.label_3.setText(_translate("Dialog", "Functions"))
        self.label_4.setText(_translate("Dialog", "Hotkey"))
        self.pushButton_ClearHotkey.setText(_translate("Dialog", "Clear"))
        self.label_5.setText(_translate("Dialog", "Code injection method:"))
        self.radioButton_SimpleDLopenCall.setText(_translate("Dialog", "Simp&le dlopen call"))
        self.radioButton_AdvancedInjection.setText(_translate("Dialog", "Advanced In&jection"))
        self.checkBox_BringDisassembleToFront.setText(_translate("Dialog", "Bring disassemble screen to front when the inferior is stopped"))
        self.label_6.setText(_translate("Dialog", "Instructions shown per scroll"))
        self.label_7.setText(_translate("Dialog", "GDB Path"))
        self.checkBox_GDBLogging.setText(_translate("Dialog", "GDB Logging"))
        self.pushButton_HandleSignals.setText(_translate("Dialog", "Handle Signals"))
        self.pushButton_ResetSettings.setText(_translate("Dialog", "Reset Settings"))

```

`GUI/SettingsDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>884</width>
    <height>633</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Settings</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_2">
       <item>
        <widget class="QListWidget" name="listWidget_Options">
         <property name="sizePolicy">
          <sizepolicy hsizetype="Fixed" vsizetype="Expanding">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="maximumSize">
          <size>
           <width>130</width>
           <height>16777215</height>
          </size>
         </property>
         <item>
          <property name="text">
           <string>General</string>
          </property>
         </item>
         <item>
          <property name="text">
           <string>Hotkeys</string>
          </property>
         </item>
         <item>
          <property name="text">
           <string>Code Injection</string>
          </property>
         </item>
         <item>
          <property name="text">
           <string>Disassemble</string>
          </property>
         </item>
         <item>
          <property name="text">
           <string>Debug</string>
          </property>
         </item>
        </widget>
       </item>
       <item>
        <widget class="QStackedWidget" name="stackedWidget">
         <property name="minimumSize">
          <size>
           <width>500</width>
           <height>500</height>
          </size>
         </property>
         <property name="currentIndex">
          <number>0</number>
         </property>
         <widget class="QWidget" name="page">
          <layout class="QGridLayout" name="gridLayout_2">
           <item row="0" column="0">
            <layout class="QVBoxLayout" name="verticalLayout_5">
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_7">
               <item>
                <layout class="QVBoxLayout" name="verticalLayout_3">
                 <item>
                  <layout class="QVBoxLayout" name="verticalLayout_2">
                   <item>
                    <widget class="QCheckBox" name="checkBox_AutoUpdateAddressTable">
                     <property name="text">
                      <string>Auto-update address table</string>
                     </property>
                     <property name="checked">
                      <bool>true</bool>
                     </property>
                    </widget>
                   </item>
                  </layout>
                 </item>
                 <item>
                  <widget class="QWidget" name="QWidget_UpdateInterval" native="true">
                   <layout class="QHBoxLayout" name="horizontalLayout_UpdateInterval">
                    <property name="topMargin">
                     <number>0</number>
                    </property>
                    <item>
                     <widget class="QLabel" name="label">
                      <property name="minimumSize">
                       <size>
                        <width>102</width>
                        <height>0</height>
                       </size>
                      </property>
                      <property name="text">
                       <string>Update Interval</string>
                      </property>
                     </widget>
                    </item>
                    <item>
                     <widget class="QLineEdit" name="lineEdit_UpdateInterval">
                      <property name="text">
                       <string>500</string>
                      </property>
                     </widget>
                    </item>
                    <item>
                     <widget class="QLabel" name="label_2">
                      <property name="text">
                       <string>ms</string>
                      </property>
                     </widget>
                    </item>
                   </layout>
                  </widget>
                 </item>
                 <item>
                  <widget class="QWidget" name="LockInterval" native="true">
                   <layout class="QHBoxLayout" name="horizontalLayout_14">
                    <property name="topMargin">
                     <number>0</number>
                    </property>
                    <item>
                     <widget class="QLabel" name="label_12">
                      <property name="sizePolicy">
                       <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
                        <horstretch>0</horstretch>
                        <verstretch>0</verstretch>
                       </sizepolicy>
                      </property>
                      <property name="minimumSize">
                       <size>
                        <width>102</width>
                        <height>0</height>
                       </size>
                      </property>
                      <property name="baseSize">
                       <size>
                        <width>0</width>
                        <height>0</height>
                       </size>
                      </property>
                      <property name="text">
                       <string>Freeze Interval</string>
                      </property>
                     </widget>
                    </item>
                    <item>
                     <widget class="QLineEdit" name="lineEdit_FreezeInterval">
                      <property name="sizePolicy">
                       <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
                        <horstretch>0</horstretch>
                        <verstretch>0</verstretch>
                       </sizepolicy>
                      </property>
                      <property name="baseSize">
                       <size>
                        <width>20</width>
                        <height>0</height>
                       </size>
                      </property>
                      <property name="text">
                       <string>100</string>
                      </property>
                     </widget>
                    </item>
                    <item>
                     <widget class="QLabel" name="label_10">
                      <property name="text">
                       <string>ms</string>
                      </property>
                     </widget>
                    </item>
                   </layout>
                  </widget>
                 </item>
                </layout>
               </item>
               <item>
                <spacer name="horizontalSpacer_4">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <widget class="QCheckBox" name="checkBox_MessageBoxOnException">
               <property name="text">
                <string>Show a MessageBox on InferiorRunning and GDBInitialize exceptions</string>
               </property>
               <property name="checked">
                <bool>true</bool>
               </property>
              </widget>
             </item>
             <item>
              <widget class="QCheckBox" name="checkBox_MessageBoxOnToggleAttach">
               <property name="text">
                <string>Show a MessageBox on Toggle Attach</string>
               </property>
               <property name="checked">
                <bool>true</bool>
               </property>
              </widget>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_3">
               <item>
                <widget class="QLabel" name="label_8">
                 <property name="text">
                  <string>GDB output:</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QCheckBox" name="checkBox_OutputModeAsync">
                 <property name="text">
                  <string>Async</string>
                 </property>
                 <property name="checked">
                  <bool>true</bool>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QCheckBox" name="checkBox_OutputModeCommand">
                 <property name="text">
                  <string>Command</string>
                 </property>
                 <property name="checked">
                  <bool>true</bool>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QCheckBox" name="checkBox_OutputModeCommandInfo">
                 <property name="text">
                  <string>Command info</string>
                 </property>
                 <property name="checked">
                  <bool>true</bool>
                 </property>
                </widget>
               </item>
               <item>
                <spacer name="horizontalSpacer_7">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_12">
               <property name="topMargin">
                <number>0</number>
               </property>
               <item>
                <widget class="QLabel" name="label_9">
                 <property name="toolTip">
                  <string>On start, automatically attach to processes with name matching one of the entries
Patterns at former positions have higher priority if regex is off</string>
                 </property>
                 <property name="text">
                  <string>Auto-attach on start</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QLineEdit" name="lineEdit_AutoAttachList"/>
               </item>
               <item>
                <widget class="QCheckBox" name="checkBox_AutoAttachRegex">
                 <property name="text">
                  <string>Regex</string>
                 </property>
                </widget>
               </item>
              </layout>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_15">
               <item>
                <widget class="QLabel" name="label_11">
                 <property name="text">
                  <string>Logo</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QComboBox" name="comboBox_Logo"/>
               </item>
               <item>
                <spacer name="horizontalSpacer_8">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <spacer name="verticalSpacer_2">
               <property name="orientation">
                <enum>Qt::Vertical</enum>
               </property>
               <property name="sizeHint" stdset="0">
                <size>
                 <width>20</width>
                 <height>40</height>
                </size>
               </property>
              </spacer>
             </item>
            </layout>
           </item>
          </layout>
         </widget>
         <widget class="QWidget" name="page_2">
          <layout class="QGridLayout" name="gridLayout_3">
           <item row="0" column="0">
            <layout class="QHBoxLayout" name="horizontalLayout_5">
             <item>
              <layout class="QVBoxLayout" name="verticalLayout_4">
               <item>
                <widget class="QLabel" name="label_3">
                 <property name="text">
                  <string>Functions</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QListWidget" name="listWidget_Functions">
                 <property name="currentRow">
                  <number>-1</number>
                 </property>
                </widget>
               </item>
              </layout>
             </item>
             <item>
              <layout class="QVBoxLayout" name="verticalLayout_6">
               <item>
                <layout class="QVBoxLayout" name="verticalLayout_Hotkey">
                 <item>
                  <widget class="QLabel" name="label_4">
                   <property name="text">
                    <string>Hotkey</string>
                   </property>
                  </widget>
                 </item>
                </layout>
               </item>
               <item>
                <layout class="QHBoxLayout" name="horizontalLayout_4">
                 <item>
                  <spacer name="horizontalSpacer">
                   <property name="orientation">
                    <enum>Qt::Horizontal</enum>
                   </property>
                   <property name="sizeHint" stdset="0">
                    <size>
                     <width>40</width>
                     <height>20</height>
                    </size>
                   </property>
                  </spacer>
                 </item>
                 <item>
                  <widget class="QPushButton" name="pushButton_ClearHotkey">
                   <property name="text">
                    <string>Clear</string>
                   </property>
                  </widget>
                 </item>
                </layout>
               </item>
               <item>
                <spacer name="verticalSpacer">
                 <property name="orientation">
                  <enum>Qt::Vertical</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>20</width>
                   <height>40</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
            </layout>
           </item>
          </layout>
         </widget>
         <widget class="QWidget" name="page_3">
          <layout class="QGridLayout" name="gridLayout_4">
           <item row="0" column="0">
            <layout class="QVBoxLayout" name="verticalLayout_9">
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_8">
               <item>
                <layout class="QVBoxLayout" name="verticalLayout_8">
                 <item>
                  <widget class="QLabel" name="label_5">
                   <property name="text">
                    <string>Code injection method:</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <layout class="QHBoxLayout" name="horizontalLayout_6">
                   <item>
                    <spacer name="horizontalSpacer_2">
                     <property name="orientation">
                      <enum>Qt::Horizontal</enum>
                     </property>
                     <property name="sizeHint" stdset="0">
                      <size>
                       <width>40</width>
                       <height>20</height>
                      </size>
                     </property>
                    </spacer>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_7">
                     <item>
                      <widget class="QRadioButton" name="radioButton_SimpleDLopenCall">
                       <property name="text">
                        <string>Simp&amp;le dlopen call</string>
                       </property>
                       <property name="checked">
                        <bool>true</bool>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QRadioButton" name="radioButton_AdvancedInjection">
                       <property name="enabled">
                        <bool>false</bool>
                       </property>
                       <property name="text">
                        <string>Advanced In&amp;jection</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                  </layout>
                 </item>
                </layout>
               </item>
               <item>
                <spacer name="horizontalSpacer_5">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <spacer name="verticalSpacer_3">
               <property name="orientation">
                <enum>Qt::Vertical</enum>
               </property>
               <property name="sizeHint" stdset="0">
                <size>
                 <width>20</width>
                 <height>40</height>
                </size>
               </property>
              </spacer>
             </item>
            </layout>
           </item>
          </layout>
         </widget>
         <widget class="QWidget" name="page_4">
          <layout class="QGridLayout" name="gridLayout_5">
           <item row="0" column="0">
            <layout class="QVBoxLayout" name="verticalLayout_10">
             <item>
              <widget class="QCheckBox" name="checkBox_BringDisassembleToFront">
               <property name="text">
                <string>Bring disassemble screen to front when the inferior is stopped</string>
               </property>
               <property name="checked">
                <bool>true</bool>
               </property>
              </widget>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_10">
               <item>
                <layout class="QHBoxLayout" name="horizontalLayout_9">
                 <item>
                  <widget class="QLabel" name="label_6">
                   <property name="text">
                    <string>Instructions shown per scroll</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="QLineEdit" name="lineEdit_InstructionsPerScroll"/>
                 </item>
                </layout>
               </item>
               <item>
                <spacer name="horizontalSpacer_6">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <spacer name="verticalSpacer_4">
               <property name="orientation">
                <enum>Qt::Vertical</enum>
               </property>
               <property name="sizeHint" stdset="0">
                <size>
                 <width>20</width>
                 <height>40</height>
                </size>
               </property>
              </spacer>
             </item>
            </layout>
           </item>
          </layout>
         </widget>
         <widget class="QWidget" name="page_5">
          <layout class="QGridLayout" name="gridLayout_6">
           <item row="0" column="0">
            <layout class="QVBoxLayout" name="verticalLayout_11">
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_11">
               <item>
                <layout class="QHBoxLayout" name="horizontalLayout_10">
                 <item>
                  <widget class="QLabel" name="label_7">
                   <property name="text">
                    <string>GDB Path</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="QLineEdit" name="lineEdit_GDBPath"/>
                 </item>
                </layout>
               </item>
               <item>
                <widget class="QPushButton" name="pushButton_GDBPath">
                 <property name="text">
                  <string/>
                 </property>
                </widget>
               </item>
              </layout>
             </item>
             <item>
              <widget class="QCheckBox" name="checkBox_GDBLogging">
               <property name="text">
                <string>GDB Logging</string>
               </property>
              </widget>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_16">
               <item>
                <widget class="QPushButton" name="pushButton_HandleSignals">
                 <property name="text">
                  <string>Handle Signals</string>
                 </property>
                </widget>
               </item>
               <item>
                <spacer name="horizontalSpacer_9">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <spacer name="verticalSpacer_5">
               <property name="orientation">
                <enum>Qt::Vertical</enum>
               </property>
               <property name="sizeHint" stdset="0">
                <size>
                 <width>20</width>
                 <height>40</height>
                </size>
               </property>
              </spacer>
             </item>
            </layout>
           </item>
          </layout>
         </widget>
        </widget>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout">
       <item>
        <widget class="QPushButton" name="pushButton_ResetSettings">
         <property name="text">
          <string>Reset Settings</string>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer_3">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
       <item>
        <widget class="QDialogButtonBox" name="buttonBox">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="standardButtons">
          <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
         </property>
        </widget>
       </item>
      </layout>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
 <designerdata>
  <property name="gridDeltaX">
   <number>5</number>
  </property>
  <property name="gridDeltaY">
   <number>5</number>
  </property>
  <property name="gridSnapX">
   <bool>true</bool>
  </property>
  <property name="gridSnapY">
   <bool>true</bool>
  </property>
  <property name="gridVisible">
   <bool>true</bool>
  </property>
 </designerdata>
</ui>

```

`GUI/StackTraceInfoWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'stacktraceinfowidget.ui'
#
# Created: Tue Jul 26 21:56:27 2016
#      by: PyQt5 UI code generator 5.2.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(768, 440)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter = QtWidgets.QSplitter(Form)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.widget = QtWidgets.QWidget(self.splitter)
        self.widget.setObjectName("widget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.widget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(self.widget)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.listWidget_ReturnAddresses = QtWidgets.QListWidget(self.widget)
        self.listWidget_ReturnAddresses.setObjectName("listWidget_ReturnAddresses")
        self.verticalLayout.addWidget(self.listWidget_ReturnAddresses)
        self.widget1 = QtWidgets.QWidget(self.splitter)
        self.widget1.setObjectName("widget1")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.widget1)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label_2 = QtWidgets.QLabel(self.widget1)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_2.addWidget(self.label_2)
        self.textBrowser_Info = QtWidgets.QTextBrowser(self.widget1)
        self.textBrowser_Info.setObjectName("textBrowser_Info")
        self.verticalLayout_2.addWidget(self.textBrowser_Info)
        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "StackTrace Information"))
        self.label.setText(_translate("Form", "Return Address"))
        self.label_2.setText(_translate("Form", "Info"))


```

`GUI/StackTraceInfoWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>768</width>
    <height>440</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>StackTrace Information</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <widget class="QWidget" name="">
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <widget class="QLabel" name="label">
         <property name="text">
          <string>Return Address</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QListWidget" name="listWidget_ReturnAddresses"/>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="">
      <layout class="QVBoxLayout" name="verticalLayout_2">
       <item>
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string>Info</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QTextBrowser" name="textBrowser_Info"/>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/TextEditDialog.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'TextEditDialog.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(568, 529)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.textEdit = QtWidgets.QTextEdit(Dialog)
        self.textEdit.setObjectName("textEdit")
        self.gridLayout.addWidget(self.textEdit, 0, 0, 1, 1)
        self.buttonBox = QtWidgets.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 1, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept)
        self.buttonBox.rejected.connect(Dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
        self.textEdit.setPlaceholderText(_translate("Dialog", "Hit Esc to cancel and Ctrl+Enter to accept"))


```

`GUI/TextEditDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>568</width>
    <height>529</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QTextEdit" name="textEdit">
     <property name="placeholderText">
      <string>Hit Esc to cancel and Ctrl+Enter to accept</string>
     </property>
    </widget>
   </item>
   <item row="1" column="0">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/TraceInstructionsPromptDialog.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'TraceInstructionsPromptDialog.ui'
#
# Created: Tue Jan 10 18:45:42 2017
#      by: PyQt5 UI code generator 5.2.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(306, 381)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(Dialog)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.lineEdit_MaxTraceCount = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_MaxTraceCount.setObjectName("lineEdit_MaxTraceCount")
        self.verticalLayout.addWidget(self.lineEdit_MaxTraceCount)
        self.label_3 = QtWidgets.QLabel(Dialog)
        self.label_3.setObjectName("label_3")
        self.verticalLayout.addWidget(self.label_3)
        self.lineEdit_TriggerCondition = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_TriggerCondition.setObjectName("lineEdit_TriggerCondition")
        self.verticalLayout.addWidget(self.lineEdit_TriggerCondition)
        self.label_2 = QtWidgets.QLabel(Dialog)
        self.label_2.setObjectName("label_2")
        self.verticalLayout.addWidget(self.label_2)
        self.lineEdit_StopCondition = QtWidgets.QLineEdit(Dialog)
        self.lineEdit_StopCondition.setObjectName("lineEdit_StopCondition")
        self.verticalLayout.addWidget(self.lineEdit_StopCondition)
        self.checkBox_StepOver = QtWidgets.QCheckBox(Dialog)
        self.checkBox_StepOver.setObjectName("checkBox_StepOver")
        self.verticalLayout.addWidget(self.checkBox_StepOver)
        self.checkBox_StopAfterTrace = QtWidgets.QCheckBox(Dialog)
        self.checkBox_StopAfterTrace.setObjectName("checkBox_StopAfterTrace")
        self.verticalLayout.addWidget(self.checkBox_StopAfterTrace)
        self.checkBox_GeneralRegisters = QtWidgets.QCheckBox(Dialog)
        self.checkBox_GeneralRegisters.setChecked(True)
        self.checkBox_GeneralRegisters.setObjectName("checkBox_GeneralRegisters")
        self.verticalLayout.addWidget(self.checkBox_GeneralRegisters)
        self.checkBox_FlagRegisters = QtWidgets.QCheckBox(Dialog)
        self.checkBox_FlagRegisters.setChecked(True)
        self.checkBox_FlagRegisters.setObjectName("checkBox_FlagRegisters")
        self.verticalLayout.addWidget(self.checkBox_FlagRegisters)
        self.checkBox_SegmentRegisters = QtWidgets.QCheckBox(Dialog)
        self.checkBox_SegmentRegisters.setChecked(True)
        self.checkBox_SegmentRegisters.setObjectName("checkBox_SegmentRegisters")
        self.verticalLayout.addWidget(self.checkBox_SegmentRegisters)
        self.checkBox_FloatRegisters = QtWidgets.QCheckBox(Dialog)
        self.checkBox_FloatRegisters.setChecked(True)
        self.checkBox_FloatRegisters.setObjectName("checkBox_FloatRegisters")
        self.verticalLayout.addWidget(self.checkBox_FloatRegisters)
        self.buttonBox = QtWidgets.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.verticalLayout.addWidget(self.buttonBox)
        self.gridLayout.addLayout(self.verticalLayout, 0, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept)
        self.buttonBox.rejected.connect(Dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Parameters for tracing"))
        self.label.setToolTip(_translate("Dialog", "Number of the instructions that\'ll be traced"))
        self.label.setText(_translate("Dialog", "Max trace count(1 or greater):"))
        self.lineEdit_MaxTraceCount.setText(_translate("Dialog", "1000"))
        self.label_3.setToolTip(_translate("Dialog", "Tracing will start if this condition is met"))
        self.label_3.setText(_translate("Dialog", "Trigger condition(Optional, gdb expression):"))
        self.label_2.setToolTip(_translate("Dialog", "Tracing will stop whenever this condition is met"))
        self.label_2.setText(_translate("Dialog", "Stop condition(Optional, gdb expression):"))
        self.checkBox_StepOver.setText(_translate("Dialog", "Step over instead of single step"))
        self.checkBox_StopAfterTrace.setText(_translate("Dialog", "Stop when tracing ends"))
        self.checkBox_GeneralRegisters.setText(_translate("Dialog", "Collect general registers"))
        self.checkBox_FlagRegisters.setText(_translate("Dialog", "Collect flag registers"))
        self.checkBox_SegmentRegisters.setText(_translate("Dialog", "Collect segment registers"))
        self.checkBox_FloatRegisters.setText(_translate("Dialog", "Collect float registers"))


```

`GUI/TraceInstructionsPromptDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>306</width>
    <height>381</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Parameters for tracing</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QLabel" name="label">
       <property name="toolTip">
        <string>Number of the instructions that'll be traced</string>
       </property>
       <property name="text">
        <string>Max trace count(1 or greater):</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_MaxTraceCount">
       <property name="text">
        <string>1000</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLabel" name="label_3">
       <property name="toolTip">
        <string>Tracing will start if this condition is met</string>
       </property>
       <property name="text">
        <string>Trigger condition(Optional, gdb expression):</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_TriggerCondition"/>
     </item>
     <item>
      <widget class="QLabel" name="label_2">
       <property name="toolTip">
        <string>Tracing will stop whenever this condition is met</string>
       </property>
       <property name="text">
        <string>Stop condition(Optional, gdb expression):</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_StopCondition"/>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_StepOver">
       <property name="text">
        <string>Step over instead of single step</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_StopAfterTrace">
       <property name="text">
        <string>Stop when tracing ends</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_GeneralRegisters">
       <property name="text">
        <string>Collect general registers</string>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_FlagRegisters">
       <property name="text">
        <string>Collect flag registers</string>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_SegmentRegisters">
       <property name="text">
        <string>Collect segment registers</string>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_FloatRegisters">
       <property name="text">
        <string>Collect float registers</string>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QDialogButtonBox" name="buttonBox">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="standardButtons">
        <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/TraceInstructionsWaitWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'TraceInstructionsWaitWidget.ui'
#
# Created: Sun Dec 25 15:05:53 2016
#      by: PyQt5 UI code generator 5.2.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(194, 91)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label_Animated = QtWidgets.QLabel(Form)
        self.label_Animated.setText("")
        self.label_Animated.setObjectName("label_Animated")
        self.verticalLayout.addWidget(self.label_Animated)
        self.label_StatusText = QtWidgets.QLabel(Form)
        self.label_StatusText.setText("")
        self.label_StatusText.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        self.label_StatusText.setObjectName("label_StatusText")
        self.verticalLayout.addWidget(self.label_StatusText)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.pushButton_Cancel = QtWidgets.QPushButton(Form)
        self.pushButton_Cancel.setObjectName("pushButton_Cancel")
        self.horizontalLayout.addWidget(self.pushButton_Cancel)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.gridLayout.addLayout(self.verticalLayout, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        self.pushButton_Cancel.setText(_translate("Form", "Cancel"))


```

`GUI/TraceInstructionsWaitWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>194</width>
    <height>91</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QLabel" name="label_Animated">
       <property name="text">
        <string/>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLabel" name="label_StatusText">
       <property name="text">
        <string/>
       </property>
       <property name="textInteractionFlags">
        <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
       </property>
      </widget>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout">
       <item>
        <spacer name="horizontalSpacer">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
       <item>
        <widget class="QPushButton" name="pushButton_Cancel">
         <property name="text">
          <string>Cancel</string>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer_2">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/TraceInstructionsWindow.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'TraceInstructionsWindow.ui'
#
# Created: Mon Jan 16 19:23:48 2017
#      by: PyQt5 UI code generator 5.2.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(704, 545)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter = QtWidgets.QSplitter(self.centralwidget)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.treeWidget_InstructionInfo = QtWidgets.QTreeWidget(self.splitter)
        self.treeWidget_InstructionInfo.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.treeWidget_InstructionInfo.setObjectName("treeWidget_InstructionInfo")
        self.treeWidget_InstructionInfo.headerItem().setText(0, "1")
        self.treeWidget_InstructionInfo.header().setVisible(False)
        self.textBrowser_RegisterInfo = QtWidgets.QTextBrowser(self.splitter)
        self.textBrowser_RegisterInfo.setObjectName("textBrowser_RegisterInfo")
        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 704, 22))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionOpen = QtWidgets.QAction(MainWindow)
        self.actionOpen.setObjectName("actionOpen")
        self.actionSave = QtWidgets.QAction(MainWindow)
        self.actionSave.setObjectName("actionSave")
        self.actionSave_as_a_text_file = QtWidgets.QAction(MainWindow)
        self.actionSave_as_a_text_file.setObjectName("actionSave_as_a_text_file")
        self.menuFile.addAction(self.actionOpen)
        self.menuFile.addAction(self.actionSave)
        self.menubar.addAction(self.menuFile.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Tracer"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.actionOpen.setText(_translate("MainWindow", "Open"))
        self.actionSave.setText(_translate("MainWindow", "Save"))
        self.actionSave_as_a_text_file.setText(_translate("MainWindow", "Save as a text file"))


```

`GUI/TraceInstructionsWindow.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>704</width>
    <height>545</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Tracer</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QGridLayout" name="gridLayout">
    <item row="0" column="0">
     <widget class="QSplitter" name="splitter">
      <property name="orientation">
       <enum>Qt::Horizontal</enum>
      </property>
      <widget class="QTreeWidget" name="treeWidget_InstructionInfo">
       <property name="editTriggers">
        <set>QAbstractItemView::NoEditTriggers</set>
       </property>
       <attribute name="headerVisible">
        <bool>false</bool>
       </attribute>
       <column>
        <property name="text">
         <string notr="true">1</string>
        </property>
       </column>
      </widget>
      <widget class="QTextBrowser" name="textBrowser_RegisterInfo"/>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>704</width>
     <height>22</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>File</string>
    </property>
    <addaction name="actionOpen"/>
    <addaction name="actionSave"/>
   </widget>
   <addaction name="menuFile"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <action name="actionOpen">
   <property name="text">
    <string>Open</string>
   </property>
  </action>
  <action name="actionSave">
   <property name="text">
    <string>Save</string>
   </property>
  </action>
  <action name="actionSave_as_a_text_file">
   <property name="text">
    <string>Save as a text file</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/TrackBreakpointWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'TrackBreakpointWidget.ui'
#
# Created by: PyQt5 UI code generator 5.5.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(549, 437)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.pushButton_Stop = QtWidgets.QPushButton(Form)
        self.pushButton_Stop.setObjectName("pushButton_Stop")
        self.horizontalLayout.addWidget(self.pushButton_Stop)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.comboBox_ValueType = QtWidgets.QComboBox(Form)
        self.comboBox_ValueType.setToolTip("")
        self.comboBox_ValueType.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
        self.comboBox_ValueType.setObjectName("comboBox_ValueType")
        self.horizontalLayout.addWidget(self.comboBox_ValueType)
        self.gridLayout.addLayout(self.horizontalLayout, 3, 0, 1, 1)
        self.tableWidget_TrackInfo = QtWidgets.QTableWidget(Form)
        self.tableWidget_TrackInfo.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_TrackInfo.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_TrackInfo.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_TrackInfo.setObjectName("tableWidget_TrackInfo")
        self.tableWidget_TrackInfo.setColumnCount(4)
        self.tableWidget_TrackInfo.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_TrackInfo.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_TrackInfo.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_TrackInfo.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_TrackInfo.setHorizontalHeaderItem(3, item)
        self.tableWidget_TrackInfo.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_TrackInfo.verticalHeader().setVisible(False)
        self.tableWidget_TrackInfo.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_TrackInfo.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout.addWidget(self.tableWidget_TrackInfo, 0, 0, 1, 1)
        self.label_Info = QtWidgets.QLabel(Form)
        self.label_Info.setText("")
        self.label_Info.setAlignment(QtCore.Qt.AlignCenter)
        self.label_Info.setObjectName("label_Info")
        self.gridLayout.addWidget(self.label_Info, 1, 0, 1, 1)
        self.label_AdditionalInfo = QtWidgets.QLabel(Form)
        self.label_AdditionalInfo.setAlignment(QtCore.Qt.AlignCenter)
        self.label_AdditionalInfo.setObjectName("label_AdditionalInfo")
        self.gridLayout.addWidget(self.label_AdditionalInfo, 2, 0, 1, 1)

        self.retranslateUi(Form)
        self.comboBox_ValueType.setCurrentIndex(-1)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        self.pushButton_Stop.setText(_translate("Form", "Stop"))
        item = self.tableWidget_TrackInfo.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Count"))
        item = self.tableWidget_TrackInfo.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Address"))
        item = self.tableWidget_TrackInfo.horizontalHeaderItem(2)
        item.setText(_translate("Form", "Value"))
        item = self.tableWidget_TrackInfo.horizontalHeaderItem(3)
        item.setText(_translate("Form", "Source"))
        self.label_AdditionalInfo.setText(_translate("Form", "Try changing combobox index if the \'Value\' part of table still isn\'t updated"))


```

`GUI/TrackBreakpointWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>549</width>
    <height>437</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="3" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QPushButton" name="pushButton_Stop">
       <property name="text">
        <string>Stop</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QComboBox" name="comboBox_ValueType">
       <property name="toolTip">
        <string/>
       </property>
       <property name="currentIndex">
        <number>-1</number>
       </property>
       <property name="sizeAdjustPolicy">
        <enum>QComboBox::AdjustToContents</enum>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item row="0" column="0">
    <widget class="QTableWidget" name="tableWidget_TrackInfo">
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>16</number>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>16</number>
     </attribute>
     <column>
      <property name="text">
       <string>Count</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Address</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Value</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Source</string>
      </property>
     </column>
    </widget>
   </item>
   <item row="1" column="0">
    <widget class="QLabel" name="label_Info">
     <property name="text">
      <string/>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item row="2" column="0">
    <widget class="QLabel" name="label_AdditionalInfo">
     <property name="text">
      <string>Try changing combobox index if the 'Value' part of table still isn't updated</string>
     </property>
     <property name="alignment">
      <set>Qt::AlignCenter</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/TrackWatchpointWidget.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'TrackWatchpointWidget.ui'
#
# Created: Fri Dec  2 21:30:54 2016
#      by: PyQt5 UI code generator 5.2.1
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(530, 493)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter_2 = QtWidgets.QSplitter(Form)
        self.splitter_2.setOrientation(QtCore.Qt.Vertical)
        self.splitter_2.setObjectName("splitter_2")
        self.splitter = QtWidgets.QSplitter(self.splitter_2)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.layoutWidget = QtWidgets.QWidget(self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.tableWidget_Opcodes = QtWidgets.QTableWidget(self.layoutWidget)
        self.tableWidget_Opcodes.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.tableWidget_Opcodes.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.tableWidget_Opcodes.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableWidget_Opcodes.setObjectName("tableWidget_Opcodes")
        self.tableWidget_Opcodes.setColumnCount(2)
        self.tableWidget_Opcodes.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Opcodes.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Opcodes.setHorizontalHeaderItem(1, item)
        self.tableWidget_Opcodes.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Opcodes.verticalHeader().setVisible(False)
        self.tableWidget_Opcodes.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Opcodes.verticalHeader().setMinimumSectionSize(16)
        self.verticalLayout.addWidget(self.tableWidget_Opcodes)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.pushButton_Refresh = QtWidgets.QPushButton(self.layoutWidget)
        self.pushButton_Refresh.setObjectName("pushButton_Refresh")
        self.horizontalLayout.addWidget(self.pushButton_Refresh)
        self.pushButton_Stop = QtWidgets.QPushButton(self.layoutWidget)
        self.pushButton_Stop.setObjectName("pushButton_Stop")
        self.horizontalLayout.addWidget(self.pushButton_Stop)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.textBrowser_Info = QtWidgets.QTextBrowser(self.splitter)
        self.textBrowser_Info.setObjectName("textBrowser_Info")
        self.textBrowser_Disassemble = QtWidgets.QTextBrowser(self.splitter_2)
        self.textBrowser_Disassemble.setObjectName("textBrowser_Disassemble")
        self.gridLayout.addWidget(self.splitter_2, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        item = self.tableWidget_Opcodes.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Count"))
        item = self.tableWidget_Opcodes.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Address"))
        self.pushButton_Refresh.setText(_translate("Form", "Refresh"))
        self.pushButton_Stop.setText(_translate("Form", "Stop"))


```

`GUI/TrackWatchpointWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>530</width>
    <height>493</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter_2">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <widget class="QSplitter" name="splitter">
      <property name="orientation">
       <enum>Qt::Horizontal</enum>
      </property>
      <widget class="QWidget" name="layoutWidget">
       <layout class="QVBoxLayout" name="verticalLayout">
        <item>
         <widget class="QTableWidget" name="tableWidget_Opcodes">
          <property name="editTriggers">
           <set>QAbstractItemView::NoEditTriggers</set>
          </property>
          <property name="selectionMode">
           <enum>QAbstractItemView::SingleSelection</enum>
          </property>
          <property name="selectionBehavior">
           <enum>QAbstractItemView::SelectRows</enum>
          </property>
          <attribute name="horizontalHeaderStretchLastSection">
           <bool>true</bool>
          </attribute>
          <attribute name="verticalHeaderVisible">
           <bool>false</bool>
          </attribute>
          <attribute name="verticalHeaderDefaultSectionSize">
           <number>16</number>
          </attribute>
          <attribute name="verticalHeaderMinimumSectionSize">
           <number>16</number>
          </attribute>
          <column>
           <property name="text">
            <string>Count</string>
           </property>
          </column>
          <column>
           <property name="text">
            <string>Address</string>
           </property>
          </column>
         </widget>
        </item>
        <item>
         <layout class="QHBoxLayout" name="horizontalLayout">
          <item>
           <widget class="QPushButton" name="pushButton_Refresh">
            <property name="text">
             <string>Refresh</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="pushButton_Stop">
            <property name="text">
             <string>Stop</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
       </layout>
      </widget>
      <widget class="QTextBrowser" name="textBrowser_Info"/>
     </widget>
     <widget class="QTextBrowser" name="textBrowser_Disassemble"/>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`MainWindow.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'MainWindow.ui'
#
# Created by: PyQt5 UI code generator 5.14.1
#
# WARNING! All changes made in this file will be lost!



```

`Notes.txt`:

```txt
Code Relocations:
	--libpince
		GuiUtils.py is used to contain GUI related utility functions
		SysUtils.py is used to contain all useful but non-GDB related libraries such as psutil
		GDB_Engine.py is used to contain all GDB related functions
		type_defs.py is used to contain all static&shared variable definitions
		All codes that'll be injected to the inferior go to the folder "Injection"
		/gdb_python_script/ contains all the python scripts that'll invoked from the gdb
	PINCE.py is used to interract with GUI and other utility libraries
	/media/ contains all the images, icons, logos n' stuff
**Don't touch anything in GUI folder, it contains auto-generated codes created by pyuic

27/3/2017 - All GUI classes that will be instanced multiple times must contain these code blocks to prevent getting removed by garbage collector:

    global instances
    instances.append(self)

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)

If you need to only create one instance of a GUI class, use this instead to create the instance:

    try:
        self.window.show()
    except AttributeError:
        self.window = WindowForm(self)  # self parameter is optional
        self.window.show()
    self.window.activateWindow()

If you need to pass self as a parameter, please don't use 'super().__init__(parent=parent)' in the child class, it makes Qt hide the child window. Use this in the child instead:
    super().__init__()
    self.parent = lambda: parent  # A quick hack to make other functions see the correct parent(). But Qt won't see it, so there'll be no bugs

28/8/2018 - All QMessageBoxes that's called from outside of their classes(via parent() etc.) must use 'QApplication.focusWidget()' instead of 'self' in their first parameter. Refer to issue #57 for more information

14/11/2018 - All logo requests should be posted in media/logo/your_username. Instead of opening a new issue, PR your logo files to that folder. Your PR must include at least one png file named pince_small, pince_medium or pince_big, according to its size. Optionally, you can also post your design files
So, a minimal PR will look like this:

/media/logo/your_username/pince_big.png

pince_big is interchangeable with pince_medium and pince_small
A full PR will look like this:

/media/logo/your_username/pince_big.png
/media/logo/your_username/pince_medium.png
/media/logo/your_username/pince_small.png
/media/logo/your_username/pince_big.ai
/media/logo/your_username/pince_medium.ai
/media/logo/your_username/pince_small.ai

It doesn't have to be ai extension, I just picked Adobe Illustrator for the example above

23/11/2018 - Don't use get_current_item or get_current_row within currentItemChanged or currentChanged signals. Qt doesn't update selected rows on first currentChanged or currentItemChanged calls
```

`PINCE.py`:

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>
Copyright (C) 2016-2017 Çağrı Ulaş <cagriulas@gmail.com>
Copyright (C) 2016-2017 Jakob Kreuze <jakob@memeware.net>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from PyQt5.QtGui import QIcon, QMovie, QPixmap, QCursor, QKeySequence, QColor, QTextCharFormat, QBrush, QTextCursor, \
    QKeyEvent, QRegExpValidator
from PyQt5.QtWidgets import QApplication, QMainWindow, QTableWidgetItem, QMessageBox, QDialog, QWidget, \
    QShortcut, QKeySequenceEdit, QTabWidget, QMenu, QFileDialog, QAbstractItemView, QTreeWidgetItem, \
    QTreeWidgetItemIterator, QCompleter, QLabel, QLineEdit, QComboBox, QDialogButtonBox, QCheckBox, QHBoxLayout
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QSize, QByteArray, QSettings, QEvent, \
    QItemSelectionModel, QTimer, QModelIndex, QStringListModel, QRegExp, QRunnable, QThreadPool, pyqtSlot
from time import sleep, time
import os, sys, traceback, signal, re, copy, io, queue, collections, ast, psutil, pexpect

from libpince import GuiUtils, SysUtils, GDB_Engine, type_defs
from libpince.libscanmem.scanmem import Scanmem

from GUI.MainWindow import Ui_MainWindow as MainWindow
from GUI.SelectProcess import Ui_MainWindow as ProcessWindow
from GUI.AddAddressManuallyDialog import Ui_Dialog as ManualAddressDialog
from GUI.EditTypeDialog import Ui_Dialog as EditTypeDialog
from GUI.LoadingDialog import Ui_Dialog as LoadingDialog
from GUI.InputDialog import Ui_Dialog as InputDialog
from GUI.TextEditDialog import Ui_Dialog as TextEditDialog
from GUI.SettingsDialog import Ui_Dialog as SettingsDialog
from GUI.HandleSignalsDialog import Ui_Dialog as HandleSignalsDialog
from GUI.ConsoleWidget import Ui_Form as ConsoleWidget
from GUI.AboutWidget import Ui_TabWidget as AboutWidget

# If you are going to change the name "Ui_MainWindow_MemoryView", review GUI/CustomLabels/RegisterLabel.py as well
from GUI.MemoryViewerWindow import Ui_MainWindow_MemoryView as MemoryViewWindow
from GUI.BookmarkWidget import Ui_Form as BookmarkWidget
from GUI.FloatRegisterWidget import Ui_TabWidget as FloatRegisterWidget
from GUI.StackTraceInfoWidget import Ui_Form as StackTraceInfoWidget
from GUI.BreakpointInfoWidget import Ui_TabWidget as BreakpointInfoWidget
from GUI.TrackWatchpointWidget import Ui_Form as TrackWatchpointWidget
from GUI.TrackBreakpointWidget import Ui_Form as TrackBreakpointWidget
from GUI.TraceInstructionsPromptDialog import Ui_Dialog as TraceInstructionsPromptDialog
from GUI.TraceInstructionsWaitWidget import Ui_Form as TraceInstructionsWaitWidget
from GUI.TraceInstructionsWindow import Ui_MainWindow as TraceInstructionsWindow
from GUI.FunctionsInfoWidget import Ui_Form as FunctionsInfoWidget
from GUI.HexEditDialog import Ui_Dialog as HexEditDialog
from GUI.LibpinceReferenceWidget import Ui_Form as LibpinceReferenceWidget
from GUI.LogFileWidget import Ui_Form as LogFileWidget
from GUI.SearchOpcodeWidget import Ui_Form as SearchOpcodeWidget
from GUI.MemoryRegionsWidget import Ui_Form as MemoryRegionsWidget
from GUI.DissectCodeDialog import Ui_Dialog as DissectCodeDialog
from GUI.ReferencedStringsWidget import Ui_Form as ReferencedStringsWidget
from GUI.ReferencedCallsWidget import Ui_Form as ReferencedCallsWidget
from GUI.ExamineReferrersWidget import Ui_Form as ExamineReferrersWidget
from GUI.RestoreInstructionsWidget import Ui_Form as RestoreInstructionsWidget

from GUI.CustomAbstractTableModels.HexModel import QHexModel
from GUI.CustomAbstractTableModels.AsciiModel import QAsciiModel
from GUI.CustomValidators.HexValidator import QHexValidator

from keyboard import add_hotkey, remove_hotkey

instances = []  # Holds temporary instances that will be deleted later on

# settings
current_settings_version = "master-22"  # Increase version by one if you change settings. Format: branch_name-version
update_table = bool
table_update_interval = int
FreezeInterval = int
show_messagebox_on_exception = bool
show_messagebox_on_toggle_attach = bool
gdb_output_mode = tuple
auto_attach_list = str
auto_attach_regex = bool
logo_path = str


class Hotkeys:
    class Hotkey:
        def __init__(self, name="", desc="", default="", func=None, custom="", handle=None):
            self.name = name
            self.desc = desc
            self.default = default
            self.func = func
            self.custom = custom
            if default == "" or func is None:
                self.handle = handle
            else:
                self.handle = add_hotkey(default, func)

        def change_key(self, custom):
            if self.handle is not None:
                remove_hotkey(self.handle)
                self.handle = None
            if custom == '':
                return
            self.handle = add_hotkey(custom.lower(), self.func)

        def change_func(self, func):
            self.func = func
            if self.handle is not None:
                remove_hotkey(self.handle)
            if self.custom != "":
                self.handle = add_hotkey(self.custom, func)
            else:
                self.handle = add_hotkey(self.default, func)

        def get_active_key(self):
            if self.custom == "":
                return self.default
            return self.custom

    pause_hotkey = Hotkey("pause_hotkey", "Pause the process", "F1")
    break_hotkey = Hotkey("break_hotkey", "Break the process", "F2")
    continue_hotkey = Hotkey("continue_hotkey", "Continue the process", "F3")
    toggle_attach_hotkey = Hotkey("toggle_attach_hotkey", "Toggle attach/detach", "Shift+F10")

    @staticmethod
    def get_hotkeys():
        return Hotkeys.pause_hotkey, Hotkeys.break_hotkey, Hotkeys.continue_hotkey, Hotkeys.toggle_attach_hotkey


code_injection_method = int
bring_disassemble_to_front = bool
instructions_per_scroll = int
gdb_path = str
gdb_logging = bool

ignored_signals = str
signal_list = ["SIGUSR1", "SIGPWR", "SIGSEGV"]

# represents the index of columns in instructions restore table
INSTR_ADDR_COL = 0
INSTR_AOB_COL = 1

# represents the index of columns in breakpoint table
BREAK_NUM_COL = 0
BREAK_TYPE_COL = 1
BREAK_DISP_COL = 2
BREAK_ENABLED_COL = 3
BREAK_ADDR_COL = 4
BREAK_SIZE_COL = 5
BREAK_ON_HIT_COL = 6
BREAK_HIT_COUNT_COL = 7
BREAK_COND_COL = 8

# row colours for disassemble qtablewidget
PC_COLOUR = Qt.blue
BOOKMARK_COLOUR = Qt.cyan
DEFAULT_COLOUR = Qt.white
BREAKPOINT_COLOUR = Qt.red
REF_COLOUR = Qt.lightGray

# represents the index of columns in address table
FROZEN_COL = 0  # Frozen
DESC_COL = 1  # Description
ADDR_COL = 2  # Address
TYPE_COL = 3  # Type
VALUE_COL = 4  # Value

# represents the index of columns in search results table
SEARCH_TABLE_ADDRESS_COL = 0
SEARCH_TABLE_VALUE_COL = 1
SEARCH_TABLE_PREVIOUS_COL = 2

# represents the index of columns in disassemble table
DISAS_ADDR_COL = 0
DISAS_BYTES_COL = 1
DISAS_OPCODES_COL = 2
DISAS_COMMENT_COL = 3

# represents the index of columns in floating point table
FLOAT_REGISTERS_NAME_COL = 0
FLOAT_REGISTERS_VALUE_COL = 1

# represents the index of columns in stacktrace table
STACKTRACE_RETURN_ADDRESS_COL = 0
STACKTRACE_FRAME_ADDRESS_COL = 1

# represents the index of columns in stack table
STACK_POINTER_ADDRESS_COL = 0
STACK_VALUE_COL = 1
STACK_POINTS_TO_COL = 2

# represents row and column counts of Hex table
HEX_VIEW_COL_COUNT = 16
HEX_VIEW_ROW_COUNT = 42  # J-JUST A COINCIDENCE, I SWEAR!

# represents the index of columns in track watchpoint table(what accesses this address thingy)
TRACK_WATCHPOINT_COUNT_COL = 0
TRACK_WATCHPOINT_ADDR_COL = 1

# represents the index of columns in track breakpoint table(which addresses this instruction accesses thingy)
TRACK_BREAKPOINT_COUNT_COL = 0
TRACK_BREAKPOINT_ADDR_COL = 1
TRACK_BREAKPOINT_VALUE_COL = 2
TRACK_BREAKPOINT_SOURCE_COL = 3

# represents the index of columns in function info table
FUNCTIONS_INFO_ADDR_COL = 0
FUNCTIONS_INFO_SYMBOL_COL = 1

# represents the index of columns in libpince reference resources table
LIBPINCE_REFERENCE_ITEM_COL = 0
LIBPINCE_REFERENCE_VALUE_COL = 1

# represents the index of columns in search opcode table
SEARCH_OPCODE_ADDR_COL = 0
SEARCH_OPCODE_OPCODES_COL = 1

# represents the index of columns in memory regions table
MEMORY_REGIONS_ADDR_COL = 0
MEMORY_REGIONS_PERM_COL = 1
MEMORY_REGIONS_SIZE_COL = 2
MEMORY_REGIONS_PATH_COL = 3
MEMORY_REGIONS_RSS_COL = 4
MEMORY_REGIONS_PSS_COL = 5
MEMORY_REGIONS_SHRCLN_COL = 6
MEMORY_REGIONS_SHRDRTY_COL = 7
MEMORY_REGIONS_PRIVCLN_COL = 8
MEMORY_REGIONS_PRIVDRTY_COL = 9
MEMORY_REGIONS_REF_COL = 10
MEMORY_REGIONS_ANON_COL = 11
MEMORY_REGIONS_SWAP_COL = 12

# represents the index of columns in dissect code table
DISSECT_CODE_ADDR_COL = 0
DISSECT_CODE_PATH_COL = 1

# represents the index of columns in referenced strings table
REF_STR_ADDR_COL = 0
REF_STR_COUNT_COL = 1
REF_STR_VAL_COL = 2

# represents the index of columns in referenced calls table
REF_CALL_ADDR_COL = 0
REF_CALL_COUNT_COL = 1

# used for automatically updating the values in the saved address tree widget
# see UpdateAddressTableThread
saved_addresses_changed_list = list()

# vars for communication/storage with the non blocking threads
Exiting = 0
ProgressRun = 0

threadpool = QThreadPool()
# Placeholder number, may have to be changed in the future
threadpool.setMaxThreadCount(10)


class Worker(QRunnable):
    def __init__(self, fn, *args, **kwargs):
        super(Worker, self).__init__()

        self.fn = fn
        self.args = args
        self.kwargs = kwargs

    @pyqtSlot()
    def run(self):
        self.fn(*self.args, **self.kwargs)


def except_hook(exception_type, value, tb):
    if show_messagebox_on_exception:
        focused_widget = app.focusWidget()
        if focused_widget:
            if exception_type == type_defs.GDBInitializeException:
                QMessageBox.information(focused_widget, "Error", "GDB isn't initialized yet")
            elif exception_type == type_defs.InferiorRunningException:
                error_dialog = InputDialogForm(item_list=[(
                    "Process is running" + "\nPress " + Hotkeys.break_hotkey.get_active_key() + " to stop process" +
                    "\n\nGo to Settings->General to disable this dialog",)], buttons=[QDialogButtonBox.Ok])
                error_dialog.exec_()
    traceback.print_exception(exception_type, value, tb)


# From version 5.5 and onwards, PyQT calls qFatal() when an exception has been encountered
# So, we must override sys.excepthook to avoid calling of qFatal()
sys.excepthook = except_hook


def signal_handler(signal, frame):
    GDB_Engine.cancel_last_command()
    raise KeyboardInterrupt


signal.signal(signal.SIGINT, signal_handler)


# Checks if the inferior has been terminated
class AwaitProcessExit(QThread):
    process_exited = pyqtSignal()

    def run(self):
        while True:
            with GDB_Engine.process_exited_condition:
                GDB_Engine.process_exited_condition.wait()
            self.process_exited.emit()


# Await async output from gdb
class AwaitAsyncOutput(QThread):
    async_output_ready = pyqtSignal(str)

    def __init__(self):
        super(AwaitAsyncOutput, self).__init__()
        self.queue_active = True

    def run(self):
        async_output_queue = GDB_Engine.gdb_async_output.register_queue()
        while self.queue_active:
            try:
                async_output = async_output_queue.get(timeout=5)
            except queue.Empty:
                pass
            else:
                self.async_output_ready.emit(async_output)
        GDB_Engine.gdb_async_output.delete_queue(async_output_queue)

    def stop(self):
        self.queue_active = False


class CheckInferiorStatus(QThread):
    process_stopped = pyqtSignal()
    process_running = pyqtSignal()

    def run(self):
        while True:
            with GDB_Engine.status_changed_condition:
                GDB_Engine.status_changed_condition.wait()
            if GDB_Engine.inferior_status == type_defs.INFERIOR_STATUS.INFERIOR_STOPPED:
                self.process_stopped.emit()
            elif GDB_Engine.inferior_status == type_defs.INFERIOR_STATUS.INFERIOR_RUNNING:
                self.process_running.emit()


# TODO undo scan, we would probably need to make some data structure we
# could pass to scanmem which then would set the current matches
# the mainwindow
class MainForm(QMainWindow, MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.hotkey_to_shortcut = {}
        hotkey_to_func = {
            Hotkeys.pause_hotkey: self.pause_hotkey_pressed,
            Hotkeys.break_hotkey: self.break_hotkey_pressed,
            Hotkeys.continue_hotkey: self.continue_hotkey_pressed,
            Hotkeys.toggle_attach_hotkey: self.toggle_attach_hotkey_pressed
        }
        for hotkey, func in hotkey_to_func.items():
            hotkey.change_func(func)
        GuiUtils.center(self)
        self.treeWidget_AddressTable.setColumnWidth(FROZEN_COL, 50)
        self.treeWidget_AddressTable.setColumnWidth(DESC_COL, 150)
        self.treeWidget_AddressTable.setColumnWidth(ADDR_COL, 150)
        self.treeWidget_AddressTable.setColumnWidth(TYPE_COL, 150)
        self.tableWidget_valuesearchtable.setColumnWidth(SEARCH_TABLE_ADDRESS_COL, 110)
        self.tableWidget_valuesearchtable.setColumnWidth(SEARCH_TABLE_VALUE_COL, 80)
        app.setOrganizationName("PINCE")
        app.setOrganizationDomain("github.com/korcankaraokcu/PINCE")
        app.setApplicationName("PINCE")
        QSettings.setPath(QSettings.NativeFormat, QSettings.UserScope,
                          SysUtils.get_user_path(type_defs.USER_PATHS.CONFIG_PATH))
        self.settings = QSettings()
        if not SysUtils.is_path_valid(self.settings.fileName()):
            self.set_default_settings()
        try:
            settings_version = self.settings.value("Misc/version", type=str)
        except Exception as e:
            print("An exception occurred while reading settings version\n", e)
            settings_version = None
        if settings_version != current_settings_version:
            print("Settings version mismatch, rolling back to the default configuration")
            self.settings.clear()
            self.set_default_settings()
        try:
            self.apply_settings()
        except Exception as e:
            print("An exception occurred while trying to load settings, rolling back to the default configuration\n", e)
            self.settings.clear()
            self.set_default_settings()
        try:
            GDB_Engine.init_gdb(gdb_path)
        except pexpect.EOF:
            text = "Unable to initialize GDB\n" \
                   "You might want to reinstall GDB or use the system GDB\n" \
                   "To change the current GDB path, check Settings->Debug"
            InputDialogForm(item_list=[(text, None)], buttons=[QDialogButtonBox.Ok]).exec_()
        else:
            self.apply_after_init()
        # this should be changed, only works if you use the current directory, fails if you for example install it to some place like bin
        libscanmem_path = os.path.join(os.getcwd(), "libpince", "libscanmem", "libscanmem.so")
        self.backend = Scanmem(libscanmem_path)
        self.backend.send_command("option noptrace 1")
        self.memory_view_window = MemoryViewWindowForm(self)
        self.about_widget = AboutWidgetForm()
        self.await_exit_thread = AwaitProcessExit()
        self.await_exit_thread.process_exited.connect(self.on_inferior_exit)
        self.await_exit_thread.start()
        self.check_status_thread = CheckInferiorStatus()
        self.check_status_thread.process_stopped.connect(self.on_status_stopped)
        self.check_status_thread.process_running.connect(self.on_status_running)
        self.check_status_thread.process_stopped.connect(self.memory_view_window.process_stopped)
        self.check_status_thread.process_running.connect(self.memory_view_window.process_running)
        self.check_status_thread.start()
        self.update_address_table_thread = Worker(self.update_address_table_loop)
        self.update_search_table_thread = Worker(self.update_search_table_loop)
        self.freeze_thread = Worker(self.freeze_loop)
        global threadpool
        threadpool.start(self.update_address_table_thread)
        threadpool.start(self.update_search_table_thread)
        threadpool.start(self.freeze_thread)
        self.shortcut_open_file = QShortcut(QKeySequence("Ctrl+O"), self)
        self.shortcut_open_file.activated.connect(self.pushButton_Open_clicked)
        GuiUtils.append_shortcut_to_tooltip(self.pushButton_Open, self.shortcut_open_file)
        self.shortcut_save_file = QShortcut(QKeySequence("Ctrl+S"), self)
        self.shortcut_save_file.activated.connect(self.pushButton_Save_clicked)
        GuiUtils.append_shortcut_to_tooltip(self.pushButton_Save, self.shortcut_save_file)
        # Saving the original function because super() doesn't work when we override functions like this
        self.treeWidget_AddressTable.keyPressEvent_original = self.treeWidget_AddressTable.keyPressEvent
        self.treeWidget_AddressTable.keyPressEvent = self.treeWidget_AddressTable_key_press_event
        self.treeWidget_AddressTable.contextMenuEvent = self.treeWidget_AddressTable_context_menu_event
        self.pushButton_AttachProcess.clicked.connect(self.pushButton_AttachProcess_clicked)
        self.pushButton_Open.clicked.connect(self.pushButton_Open_clicked)
        self.pushButton_Save.clicked.connect(self.pushButton_Save_clicked)
        self.pushButton_NewFirstScan.clicked.connect(self.pushButton_NewFirstScan_clicked)
        self.pushButton_NextScan.clicked.connect(self.pushButton_NextScan_clicked)
        self.scan_mode = type_defs.SCAN_MODE.ONGOING
        self.pushButton_NewFirstScan_clicked()
        self.comboBox_ScanScope_init()
        self.comboBox_ValueType_init()
        self.checkBox_Hex.stateChanged.connect(self.checkBox_Hex_stateChanged)
        self.comboBox_ValueType.currentIndexChanged.connect(self.comboBox_ValueType_current_index_changed)
        self.lineEdit_Scan.setValidator(QRegExpValidator(QRegExp("-?[0-9]*"), parent=self.lineEdit_Scan))
        self.lineEdit_Scan2.setValidator(QRegExpValidator(QRegExp("-?[0-9]*"), parent=self.lineEdit_Scan2))
        self.comboBox_ScanType.currentIndexChanged.connect(self.comboBox_ScanType_current_index_changed)
        self.comboBox_ScanType_current_index_changed()
        self.pushButton_Settings.clicked.connect(self.pushButton_Settings_clicked)
        self.pushButton_Console.clicked.connect(self.pushButton_Console_clicked)
        self.pushButton_Wiki.clicked.connect(self.pushButton_Wiki_clicked)
        self.pushButton_About.clicked.connect(self.pushButton_About_clicked)
        self.pushButton_AddAddressManually.clicked.connect(self.pushButton_AddAddressManually_clicked)
        self.pushButton_MemoryView.clicked.connect(self.pushButton_MemoryView_clicked)
        self.pushButton_RefreshAdressTable.clicked.connect(self.update_address_table)
        self.pushButton_CopyToAddressTable.clicked.connect(self.copy_to_address_table)
        self.pushButton_CleanAddressTable.clicked.connect(self.delete_address_table_contents)
        self.tableWidget_valuesearchtable.cellDoubleClicked.connect(
            self.tableWidget_valuesearchtable_cell_double_clicked)
        self.treeWidget_AddressTable.itemClicked.connect(self.treeWidget_AddressTable_item_clicked)
        self.treeWidget_AddressTable.itemDoubleClicked.connect(self.treeWidget_AddressTable_item_double_clicked)
        self.treeWidget_AddressTable.expanded.connect(self.resize_address_table)
        self.treeWidget_AddressTable.collapsed.connect(self.resize_address_table)
        icons_directory = GuiUtils.get_icons_directory()
        current_dir = SysUtils.get_current_script_directory()
        self.pushButton_AttachProcess.setIcon(QIcon(QPixmap(icons_directory + "/monitor.png")))
        self.pushButton_Open.setIcon(QIcon(QPixmap(icons_directory + "/folder.png")))
        self.pushButton_Save.setIcon(QIcon(QPixmap(icons_directory + "/disk.png")))
        self.pushButton_Settings.setIcon(QIcon(QPixmap(icons_directory + "/wrench.png")))
        self.pushButton_CopyToAddressTable.setIcon(QIcon(QPixmap(icons_directory + "/arrow_down.png")))
        self.pushButton_CleanAddressTable.setIcon(QIcon(QPixmap(icons_directory + "/bin_closed.png")))
        self.pushButton_RefreshAdressTable.setIcon(QIcon(QPixmap(icons_directory + "/table_refresh.png")))
        self.pushButton_Console.setIcon(QIcon(QPixmap(icons_directory + "/application_xp_terminal.png")))
        self.pushButton_Wiki.setIcon(QIcon(QPixmap(icons_directory + "/book_open.png")))
        self.pushButton_About.setIcon(QIcon(QPixmap(icons_directory + "/information.png")))
        self.auto_attach()

    def set_default_settings(self):
        self.settings.beginGroup("General")
        self.settings.setValue("auto_update_address_table", True)
        self.settings.setValue("address_table_update_interval", 500)
        self.settings.setValue("freeze_interval", 100)
        self.settings.setValue("show_messagebox_on_exception", True)
        self.settings.setValue("show_messagebox_on_toggle_attach", True)
        self.settings.setValue("gdb_output_mode", type_defs.gdb_output_mode(True, True, True))
        self.settings.setValue("auto_attach_list", "")
        self.settings.setValue("logo_path", "ozgurozbek/pince_small_transparent.png")
        self.settings.setValue("auto_attach_regex", False)
        self.settings.endGroup()
        self.settings.beginGroup("Hotkeys")
        for hotkey in Hotkeys.get_hotkeys():
            self.settings.setValue(hotkey.name, hotkey.default)
        self.settings.endGroup()
        self.settings.beginGroup("CodeInjection")
        self.settings.setValue("code_injection_method", type_defs.INJECTION_METHOD.SIMPLE_DLOPEN_CALL)
        self.settings.endGroup()
        self.settings.beginGroup("Disassemble")
        self.settings.setValue("bring_disassemble_to_front", False)
        self.settings.setValue("instructions_per_scroll", 2)
        self.settings.endGroup()
        self.settings.beginGroup("Debug")
        self.settings.setValue("gdb_path", type_defs.PATHS.GDB_PATH)
        self.settings.setValue("gdb_logging", False)
        self.settings.setValue("ignored_signals", "1,1,0")
        self.settings.endGroup()
        self.settings.beginGroup("Misc")
        self.settings.setValue("version", current_settings_version)
        self.settings.endGroup()
        self.apply_settings()

    @GDB_Engine.execute_with_temporary_interruption
    def apply_after_init(self):
        global gdb_logging
        global ignored_signals

        gdb_logging = self.settings.value("Debug/gdb_logging", type=bool)
        ignored_signals = self.settings.value("Debug/ignored_signals", type=str)
        GDB_Engine.set_logging(gdb_logging)
        for index, ignore_status in enumerate(ignored_signals.split(",")):
            if ignore_status == "1":
                GDB_Engine.ignore_signal(signal_list[index])
            else:
                GDB_Engine.unignore_signal(signal_list[index])

    def apply_settings(self):
        global update_table
        global table_update_interval
        global show_messagebox_on_exception
        global show_messagebox_on_toggle_attach
        global gdb_output_mode
        global auto_attach_list
        global logo_path
        global auto_attach_regex
        global code_injection_method
        global bring_disassemble_to_front
        global instructions_per_scroll
        global gdb_path
        global FreezeInterval

        update_table = self.settings.value("General/auto_update_address_table", type=bool)
        table_update_interval = self.settings.value("General/address_table_update_interval", type=int)
        FreezeInterval = self.settings.value("General/freeze_interval", type=int)
        show_messagebox_on_exception = self.settings.value("General/show_messagebox_on_exception", type=bool)
        show_messagebox_on_toggle_attach = self.settings.value("General/show_messagebox_on_toggle_attach", type=bool)
        gdb_output_mode = self.settings.value("General/gdb_output_mode", type=tuple)
        auto_attach_list = self.settings.value("General/auto_attach_list", type=str)
        logo_path = self.settings.value("General/logo_path", type=str)
        app.setWindowIcon(QIcon(os.path.join(SysUtils.get_logo_directory(), logo_path)))
        auto_attach_regex = self.settings.value("General/auto_attach_regex", type=bool)
        GDB_Engine.set_gdb_output_mode(gdb_output_mode)
        for hotkey in Hotkeys.get_hotkeys():
            hotkey.change_key(self.settings.value("Hotkeys/" + hotkey.name))
        try:
            self.memory_view_window.set_dynamic_debug_hotkeys()
        except AttributeError:
            pass
        code_injection_method = self.settings.value("CodeInjection/code_injection_method", type=int)
        bring_disassemble_to_front = self.settings.value("Disassemble/bring_disassemble_to_front", type=bool)
        instructions_per_scroll = self.settings.value("Disassemble/instructions_per_scroll", type=int)
        gdb_path = self.settings.value("Debug/gdb_path", type=str)
        if GDB_Engine.gdb_initialized:
            self.apply_after_init()

    # Check if any process should be attached to automatically
    # Patterns at former positions have higher priority if regex is off
    def auto_attach(self):
        if not auto_attach_list:
            return
        if auto_attach_regex:
            try:
                compiled_re = re.compile(auto_attach_list)
            except:
                print("Auto-attach failed: " + auto_attach_list + " isn't a valid regex")
                return
            for process in SysUtils.iterate_processes():
                try:
                    name = process.name()
                except psutil.NoSuchProcess:
                    continue
                if compiled_re.search(name):
                    self.attach_to_pid(process.pid)
                    return
        else:
            for target in auto_attach_list.split(";"):
                for process in SysUtils.iterate_processes():
                    try:
                        name = process.name()
                    except psutil.NoSuchProcess:
                        continue
                    if name.find(target) != -1:
                        self.attach_to_pid(process.pid)
                        return

    def pause_hotkey_pressed(self):
        GDB_Engine.interrupt_inferior(type_defs.STOP_REASON.PAUSE)

    def break_hotkey_pressed(self):
        GDB_Engine.interrupt_inferior()

    def continue_hotkey_pressed(self):
        GDB_Engine.continue_inferior()

    def toggle_attach_hotkey_pressed(self):
        result = GDB_Engine.toggle_attach()
        if not result:
            dialog_text = "Unable to toggle attach"
        elif result == type_defs.TOGGLE_ATTACH.DETACHED:
            self.on_status_detached()
            dialog_text = "GDB is detached from the process"
        else:
            dialog_text = "GDB is attached back to the process"
        if show_messagebox_on_toggle_attach:
            dialog = InputDialogForm(item_list=[(
                dialog_text + "\n\nGo to Settings->General to disable this dialog",)], buttons=[QDialogButtonBox.Ok])
            dialog.exec_()

    def treeWidget_AddressTable_context_menu_event(self, event):
        current_row = GuiUtils.get_current_item(self.treeWidget_AddressTable)
        menu = QMenu()
        edit_menu = menu.addMenu("Edit")
        edit_desc = edit_menu.addAction("Description[Ctrl+Enter]")
        edit_address = edit_menu.addAction("Address[Ctrl+Alt+Enter]")
        edit_type = edit_menu.addAction("Type[Alt+Enter]")
        edit_value = edit_menu.addAction("Value[Enter]")
        show_hex = menu.addAction("Show as hexadecimal")
        show_dec = menu.addAction("Show as decimal")
        show_unsigned = menu.addAction("Show as unsigned")
        show_signed = menu.addAction("Show as signed")
        toggle_record = menu.addAction("Toggle selected records[Space]")
        freeze_menu = menu.addMenu("Freeze")
        freeze_default = freeze_menu.addAction("Default")
        freeze_inc = freeze_menu.addAction("Incremental")
        freeze_dec = freeze_menu.addAction("Decremental")
        menu.addSeparator()
        browse_region = menu.addAction("Browse this memory region[Ctrl+B]")
        disassemble = menu.addAction("Disassemble this address[Ctrl+D]")
        menu.addSeparator()
        cut_record = menu.addAction("Cut selected records[Ctrl+X]")
        copy_record = menu.addAction("Copy selected records[Ctrl+C]")
        cut_record_recursively = menu.addAction("Cut selected records (recursive)[X]")
        copy_record_recursively = menu.addAction("Copy selected records (recursive)[C]")
        paste_record_before = menu.addAction("Paste selected records before[Ctrl+V]")
        paste_record_after = menu.addAction("Paste selected records after[V]")
        paste_record_inside = menu.addAction("Paste selected records inside[I]")
        delete_record = menu.addAction("Delete selected records[Del]")
        menu.addSeparator()
        what_writes = menu.addAction("Find out what writes to this address")
        what_reads = menu.addAction("Find out what reads this address")
        what_accesses = menu.addAction("Find out what accesses this address")
        if current_row is None:
            deletion_list = [edit_menu.menuAction(), show_hex, show_dec, show_unsigned, show_signed, toggle_record,
                             freeze_menu.menuAction(), browse_region, disassemble, what_writes, what_reads,
                             what_accesses]
            GuiUtils.delete_menu_entries(menu, deletion_list)
        else:
            value_type = current_row.data(TYPE_COL, Qt.UserRole)
            if type_defs.VALUE_INDEX.is_integer(value_type.value_index):
                if value_type.value_repr is type_defs.VALUE_REPR.HEX:
                    GuiUtils.delete_menu_entries(menu, [show_unsigned, show_signed, show_hex])
                elif value_type.value_repr is type_defs.VALUE_REPR.UNSIGNED:
                    GuiUtils.delete_menu_entries(menu, [show_unsigned, show_dec])
                elif value_type.value_repr is type_defs.VALUE_REPR.SIGNED:
                    GuiUtils.delete_menu_entries(menu, [show_signed, show_dec])
                if current_row.checkState(FROZEN_COL) == Qt.Unchecked:
                    GuiUtils.delete_menu_entries(menu, [freeze_menu.menuAction()])
            else:
                GuiUtils.delete_menu_entries(menu, [show_hex, show_dec, show_unsigned, show_signed,
                                                    freeze_menu.menuAction()])
        font_size = self.treeWidget_AddressTable.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            edit_desc: self.treeWidget_AddressTable_edit_desc,
            edit_address: self.treeWidget_AddressTable_edit_address,
            edit_type: self.treeWidget_AddressTable_edit_type,
            edit_value: self.treeWidget_AddressTable_edit_value,
            show_hex: lambda: self.treeWidget_AddressTable_change_repr(type_defs.VALUE_REPR.HEX),
            show_dec: lambda: self.treeWidget_AddressTable_change_repr(type_defs.VALUE_REPR.UNSIGNED),
            show_unsigned: lambda: self.treeWidget_AddressTable_change_repr(type_defs.VALUE_REPR.UNSIGNED),
            show_signed: lambda: self.treeWidget_AddressTable_change_repr(type_defs.VALUE_REPR.SIGNED),
            toggle_record: self.toggle_selected_records,
            freeze_default: lambda: self.change_freeze_type(type_defs.FREEZE_TYPE.DEFAULT),
            freeze_inc: lambda: self.change_freeze_type(type_defs.FREEZE_TYPE.INCREMENT),
            freeze_dec: lambda: self.change_freeze_type(type_defs.FREEZE_TYPE.DECREMENT),
            browse_region: self.browse_region_for_selected_row,
            disassemble: self.disassemble_selected_row,
            cut_record: self.cut_selected_records,
            copy_record: self.copy_selected_records,
            cut_record_recursively: self.cut_selected_records_recursively,
            copy_record_recursively: self.copy_selected_records_recursively,
            paste_record_before: lambda: self.paste_records(insert_after=False),
            paste_record_after: lambda: self.paste_records(insert_after=True),
            paste_record_inside: lambda: self.paste_records(insert_inside=True),
            delete_record: self.delete_selected_records,
            what_writes: lambda: self.exec_track_watchpoint_widget(type_defs.WATCHPOINT_TYPE.WRITE_ONLY),
            what_reads: lambda: self.exec_track_watchpoint_widget(type_defs.WATCHPOINT_TYPE.READ_ONLY),
            what_accesses: lambda: self.exec_track_watchpoint_widget(type_defs.WATCHPOINT_TYPE.BOTH)
        }
        try:
            actions[action]()
        except KeyError:
            pass

    @GDB_Engine.execute_with_temporary_interruption
    def exec_track_watchpoint_widget(self, watchpoint_type):
        selected_row = GuiUtils.get_current_item(self.treeWidget_AddressTable)
        if not selected_row:
            return
        address = selected_row.text(ADDR_COL)
        value_type = selected_row.data(TYPE_COL, Qt.UserRole)
        if type_defs.VALUE_INDEX.is_string(value_type.value_index):
            value_text = selected_row.text(VALUE_COL)
            encoding, option = type_defs.string_index_to_encoding_dict[value_type.value_index]
            byte_len = len(value_text.encode(encoding, option))
        elif value_type.value_index == type_defs.VALUE_INDEX.INDEX_AOB:
            byte_len = value_type.length
        else:
            byte_len = type_defs.index_to_valuetype_dict[value_type.value_index][0]
        TrackWatchpointWidgetForm(address, byte_len, watchpoint_type, self).show()

    def browse_region_for_selected_row(self):
        row = GuiUtils.get_current_item(self.treeWidget_AddressTable)
        if row:
            self.memory_view_window.hex_dump_address(int(row.text(ADDR_COL), 16))
            self.memory_view_window.show()
            self.memory_view_window.activateWindow()

    def disassemble_selected_row(self):
        row = GuiUtils.get_current_item(self.treeWidget_AddressTable)
        if row:
            if self.memory_view_window.disassemble_expression(row.text(ADDR_COL), append_to_travel_history=True):
                self.memory_view_window.show()
                self.memory_view_window.activateWindow()

    def change_freeze_type(self, freeze_type):
        for row in self.treeWidget_AddressTable.selectedItems():
            frozen = row.data(FROZEN_COL, Qt.UserRole)
            frozen.freeze_type = freeze_type

            # TODO: Create a QWidget subclass with signals so freeze type can be changed by clicking on the cell
            if freeze_type == type_defs.FREEZE_TYPE.DEFAULT:
                row.setText(FROZEN_COL, "")
                row.setForeground(FROZEN_COL, QBrush(QColor(0, 0, 0)))
            elif freeze_type == type_defs.FREEZE_TYPE.INCREMENT:
                row.setText(FROZEN_COL, "▲")
                row.setForeground(FROZEN_COL, QBrush(QColor(0, 255, 0)))
            elif freeze_type == type_defs.FREEZE_TYPE.DECREMENT:
                row.setText(FROZEN_COL, "▼")
                row.setForeground(FROZEN_COL, QBrush(QColor(255, 0, 0)))

    def toggle_selected_records(self):
        row = GuiUtils.get_current_item(self.treeWidget_AddressTable)
        if row:
            check_state = row.checkState(FROZEN_COL)
            new_check_state = Qt.Checked if check_state == Qt.Unchecked else Qt.Unchecked
            for row in self.treeWidget_AddressTable.selectedItems():
                row.setCheckState(FROZEN_COL, new_check_state)
                self.treeWidget_AddressTable_item_clicked(row, FROZEN_COL)

    def cut_selected_records(self):
        # Flat cut, does not preserve structure
        self.copy_selected_records()
        self.delete_selected_records()

    def copy_selected_records(self):
        # Flat copy, does not preserve structure
        app.clipboard().setText(repr([self.read_address_table_entries(selected_row, True) + ((),) for selected_row in
                                      self.treeWidget_AddressTable.selectedItems()]))
        # each element in the list has no children

    def cut_selected_records_recursively(self):
        self.copy_selected_records_recursively()
        self.delete_selected_records()

    def copy_selected_records_recursively(self):
        # Recursive copy
        items = self.treeWidget_AddressTable.selectedItems()

        def index_of(item):
            """Returns the index used to access the given QTreeWidgetItem
            as a list of ints."""
            result = []
            while True:
                parent = item.parent()
                if parent:
                    result.append(parent.indexOfChild(item))
                    item = parent
                else:
                    result.append(item.treeWidget().indexOfTopLevelItem(item))
                    return result[::-1]

        # First, order the items by their indices in the tree widget.
        # Store the indices for later usage.
        index_items = [(index_of(item), item) for item in items]
        index_items.sort(key=lambda x: x[0])  # sort by index

        # Now filter any selected items that is a descendant of another selected items.
        items = []
        last_index = [-1]  # any invalid list of indices are fine
        for index, item in index_items:
            if index[:len(last_index)] == last_index:
                continue  # this item is a descendant of the last item
            items.append(item)
            last_index = index

        app.clipboard().setText(repr([self.read_address_table_recursively(item) for item in items]))

    def insert_records(self, records, parent_row, insert_index):
        # parent_row should be a QTreeWidgetItem in treeWidget_AddressTable
        # records should be an iterable of valid output of read_address_table_recursively
        assert isinstance(parent_row, QTreeWidgetItem)

        rows = []
        for rec in records:
            row = QTreeWidgetItem()
            row.setCheckState(FROZEN_COL, Qt.Unchecked)
            frozen = type_defs.Frozen("", type_defs.FREEZE_TYPE.DEFAULT)
            row.setData(FROZEN_COL, Qt.UserRole, frozen)

            # Deserialize the value_type param
            value_type = type_defs.ValueType(*rec[2])
            self.change_address_table_entries(row, *rec[:-2], value_type)
            self.insert_records(rec[-1], row, 0)
            rows.append(row)

        parent_row.insertChildren(insert_index, rows)

    def paste_records(self, insert_after=None, insert_inside=False):
        try:
            records = ast.literal_eval(app.clipboard().text())
        except (SyntaxError, ValueError):
            QMessageBox.information(self, "Error", "Invalid clipboard content")
            return

        insert_row = GuiUtils.get_current_item(self.treeWidget_AddressTable)
        root = self.treeWidget_AddressTable.invisibleRootItem()
        if not insert_row:  # this is common when the treeWidget_AddressTable is empty
            self.insert_records(records, root, self.treeWidget_AddressTable.topLevelItemCount())
        elif insert_inside:
            self.insert_records(records, insert_row, 0)
        else:
            parent = insert_row.parent() or root
            self.insert_records(records, parent, parent.indexOfChild(insert_row) + insert_after)
        self.update_address_table()

    def delete_selected_records(self):
        root = self.treeWidget_AddressTable.invisibleRootItem()
        for item in self.treeWidget_AddressTable.selectedItems():
            (item.parent() or root).removeChild(item)

    def treeWidget_AddressTable_key_press_event(self, event):
        actions = type_defs.KeyboardModifiersTupleDict([
            ((Qt.NoModifier, Qt.Key_Delete), self.delete_selected_records),
            ((Qt.ControlModifier, Qt.Key_B), self.browse_region_for_selected_row),
            ((Qt.ControlModifier, Qt.Key_D), self.disassemble_selected_row),
            ((Qt.NoModifier, Qt.Key_R), self.update_address_table),
            ((Qt.NoModifier, Qt.Key_Space), self.toggle_selected_records),
            ((Qt.ControlModifier, Qt.Key_X), self.cut_selected_records),
            ((Qt.ControlModifier, Qt.Key_C), self.copy_selected_records),
            ((Qt.NoModifier, Qt.Key_X), self.cut_selected_records_recursively),
            ((Qt.NoModifier, Qt.Key_C), self.copy_selected_records_recursively),
            ((Qt.ControlModifier, Qt.Key_V), lambda: self.paste_records(insert_after=False)),
            ((Qt.NoModifier, Qt.Key_V), lambda: self.paste_records(insert_after=True)),
            ((Qt.NoModifier, Qt.Key_I), lambda: self.paste_records(insert_inside=True)),
            ((Qt.NoModifier, Qt.Key_Return), self.treeWidget_AddressTable_edit_value),
            ((Qt.ControlModifier, Qt.Key_Return), self.treeWidget_AddressTable_edit_desc),
            ((Qt.ControlModifier | Qt.AltModifier, Qt.Key_Return), self.treeWidget_AddressTable_edit_address),
            ((Qt.AltModifier, Qt.Key_Return), self.treeWidget_AddressTable_edit_type)
        ])
        try:
            actions[event.modifiers(), event.key()]()
        except KeyError:
            self.treeWidget_AddressTable.keyPressEvent_original(event)

    def update_address_table(self):
        if GDB_Engine.currentpid == -1 or self.treeWidget_AddressTable.topLevelItemCount() == 0:
            return
        it = QTreeWidgetItemIterator(self.treeWidget_AddressTable)
        mem_handle = GDB_Engine.memory_handle()
        address_expr_list = []
        rows = []
        while True:
            row = it.value()
            if not row:
                break
            it += 1
            address_expr_list.append(row.data(ADDR_COL, Qt.UserRole))
            rows.append(row)
        try:
            address_list = [item.address for item in GDB_Engine.examine_expressions(address_expr_list)]
        except type_defs.InferiorRunningException:
            address_list = address_expr_list
        for index, row in enumerate(rows):
            value_type = row.data(TYPE_COL, Qt.UserRole)
            address = address_list[index]
            signed = True if value_type.value_repr == type_defs.VALUE_REPR.SIGNED else False
            value = GDB_Engine.read_memory(address, value_type.value_index, value_type.length,
                                           value_type.zero_terminate, signed, mem_handle=mem_handle)
            row.setText(ADDR_COL, address or address_expr_list[index])
            if value is None:
                value = ""
            elif value_type.value_repr == type_defs.VALUE_REPR.HEX:
                value = hex(value)
            else:
                value = str(value)
            row.setText(VALUE_COL, value)

    def resize_address_table(self):
        self.treeWidget_AddressTable.resizeColumnToContents(FROZEN_COL)

    # gets the information from the dialog then adds it to addresstable
    def pushButton_AddAddressManually_clicked(self):
        manual_address_dialog = ManualAddressDialogForm()
        if manual_address_dialog.exec_():
            desc, address_expr, value_index, length, zero_terminate = manual_address_dialog.get_values()
            self.add_entry_to_addresstable(desc, address_expr, value_index, length, zero_terminate)

    def pushButton_MemoryView_clicked(self):
        self.memory_view_window.showMaximized()
        self.memory_view_window.activateWindow()

    def pushButton_Wiki_clicked(self):
        SysUtils.execute_shell_command_as_user('python3 -m webbrowser "https://github.com/korcankaraokcu/PINCE/wiki"')

    def pushButton_About_clicked(self):
        self.about_widget.show()
        self.about_widget.activateWindow()

    def pushButton_Settings_clicked(self):
        settings_dialog = SettingsDialogForm(self.set_default_settings)
        if settings_dialog.exec_():
            self.apply_settings()

    def pushButton_Console_clicked(self):
        console_widget = ConsoleWidgetForm()
        console_widget.showMaximized()

    def checkBox_Hex_stateChanged(self, state):
        if state == Qt.Checked:
            # allows only things that are hex, can also start with 0x
            self.lineEdit_Scan.setValidator(QRegExpValidator(QRegExp("(0x)?[A-Fa-f0-9]*$"), parent=self.lineEdit_Scan))
            self.lineEdit_Scan2.setValidator(
                QRegExpValidator(QRegExp("(0x)?[A-Fa-f0-9]*$"), parent=self.lineEdit_Scan2))
        else:
            # sets it back to integers only
            self.lineEdit_Scan.setValidator(QRegExpValidator(QRegExp("-?[0-9]*"), parent=self.lineEdit_Scan))
            self.lineEdit_Scan2.setValidator(QRegExpValidator(QRegExp("-?[0-9]*"), parent=self.lineEdit_Scan2))

    # TODO add a damn keybind for this...
    def pushButton_NewFirstScan_clicked(self):
        if self.scan_mode == type_defs.SCAN_MODE.ONGOING:
            self.scan_mode = type_defs.SCAN_MODE.NEW
            self.pushButton_NewFirstScan.setText("First Scan")
            self.backend.send_command("reset")
            self.tableWidget_valuesearchtable.setRowCount(0)
            self.comboBox_ValueType.setEnabled(True)
            self.pushButton_NextScan.setEnabled(False)
            self.comboBox_ScanScope.setEnabled(True)
            self.progressBar.setValue(0)
        else:
            self.scan_mode = type_defs.SCAN_MODE.ONGOING
            self.pushButton_NewFirstScan.setText("New Scan")
            self.comboBox_ValueType.setEnabled(False)
            self.pushButton_NextScan.setEnabled(True)
            search_scope = self.comboBox_ScanScope.currentData(Qt.UserRole)
            self.backend.send_command("option region_scan_level " + str(search_scope))
            self.backend.send_command("reset")
            self.comboBox_ScanScope.setEnabled(False)
            self.pushButton_NextScan_clicked()  # makes code a little simpler to just implement everything in nextscan
        self.comboBox_ScanType_init()

    def comboBox_ScanType_current_index_changed(self):
        hidden_types = [type_defs.SCAN_TYPE.INCREASED, type_defs.SCAN_TYPE.DECREASED, type_defs.SCAN_TYPE.CHANGED,
                        type_defs.SCAN_TYPE.UNCHANGED, type_defs.SCAN_TYPE.UNKNOWN]
        if self.comboBox_ScanType.currentData(Qt.UserRole) in hidden_types:
            self.widget_Scan.setEnabled(False)
        else:
            self.widget_Scan.setEnabled(True)
        if self.comboBox_ScanType.currentData(Qt.UserRole) == type_defs.SCAN_TYPE.BETWEEN:
            self.label_Between.setVisible(True)
            self.lineEdit_Scan2.setVisible(True)
        else:
            self.label_Between.setVisible(False)
            self.lineEdit_Scan2.setVisible(False)

    def comboBox_ScanType_init(self):
        current_type = self.comboBox_ScanType.currentData(Qt.UserRole)
        self.comboBox_ScanType.clear()
        if self.scan_mode == type_defs.SCAN_MODE.NEW:
            items = [type_defs.SCAN_TYPE.EXACT, type_defs.SCAN_TYPE.LESS, type_defs.SCAN_TYPE.MORE,
                     type_defs.SCAN_TYPE.BETWEEN, type_defs.SCAN_TYPE.UNKNOWN]
        else:
            items = [type_defs.SCAN_TYPE.EXACT, type_defs.SCAN_TYPE.INCREASED, type_defs.SCAN_TYPE.INCREASED_BY,
                     type_defs.SCAN_TYPE.DECREASED, type_defs.SCAN_TYPE.DECREASED_BY, type_defs.SCAN_TYPE.LESS,
                     type_defs.SCAN_TYPE.MORE, type_defs.SCAN_TYPE.BETWEEN, type_defs.SCAN_TYPE.CHANGED,
                     type_defs.SCAN_TYPE.UNCHANGED]
        old_index = 0
        for index, type_index in enumerate(items):
            if current_type == type_index:
                old_index = index
            self.comboBox_ScanType.addItem(type_defs.scan_type_to_text_dict[type_index], type_index)
        self.comboBox_ScanType.setCurrentIndex(old_index)

    def comboBox_ScanScope_init(self):
        for scope, text in type_defs.scan_scope_to_text_dict.items():
            self.comboBox_ScanScope.addItem(text, scope)
        self.comboBox_ScanScope.setCurrentIndex(1)  # type_defs.SCAN_SCOPE.NORMAL

    def comboBox_ValueType_init(self):
        self.comboBox_ValueType.clear()
        for value_index, value_text in type_defs.scan_index_to_text_dict.items():
            self.comboBox_ValueType.addItem(value_text, value_index)
        self.comboBox_ValueType.setCurrentIndex(type_defs.SCAN_INDEX.INDEX_INT32)
        self.comboBox_ValueType_current_index_changed()

    # :doc:
    # adds things like 0x when searching for etc, basically just makes the line valid for scanmem
    # this should cover most things, more things might be added later if need be
    def validate_search(self, search_for, search_for2):
        type_index = self.comboBox_ScanType.currentData(Qt.UserRole)
        symbol_map = {
            type_defs.SCAN_TYPE.INCREASED: "+",
            type_defs.SCAN_TYPE.DECREASED: "-",
            type_defs.SCAN_TYPE.CHANGED: "!=",
            type_defs.SCAN_TYPE.UNCHANGED: "=",
            type_defs.SCAN_TYPE.UNKNOWN: "snapshot"
        }
        if type_index in symbol_map:
            return symbol_map[type_index]

        # none of these should be possible to be true at the same time
        scan_index = self.comboBox_ValueType.currentData(Qt.UserRole)
        if scan_index == type_defs.SCAN_INDEX.INDEX_FLOAT32 or scan_index == type_defs.SCAN_INDEX.INDEX_FLOAT64:
            # this is odd, since when searching for floats from command line it uses `.` and not `,`
            search_for = search_for.replace(".", ",")
            search_for2 = search_for2.replace(".", ",")
        elif scan_index == type_defs.SCAN_INDEX.INDEX_STRING:
            search_for = "\" " + search_for
        elif self.checkBox_Hex.isChecked():
            if not search_for.startswith("0x"):
                search_for = "0x" + search_for
            if not search_for2.startswith("0x"):
                search_for2 = "0x" + search_for2
        if type_index == type_defs.SCAN_TYPE.BETWEEN:
            return search_for + ".." + search_for2
        cmp_symbols = {
            type_defs.SCAN_TYPE.INCREASED_BY: "+",
            type_defs.SCAN_TYPE.DECREASED_BY: "-",
            type_defs.SCAN_TYPE.LESS: "<",
            type_defs.SCAN_TYPE.MORE: ">"
        }
        if type_index in cmp_symbols:
            return cmp_symbols[type_index] + " " + search_for
        return search_for

    def pushButton_NextScan_clicked(self):
        global ProgressRun
        search_for = self.validate_search(self.lineEdit_Scan.text(), self.lineEdit_Scan2.text())

        # ProgressBar
        global threadpool
        threadpool.start(Worker(self.update_progress_bar))
        self.backend.send_command(search_for)
        matches = self.backend.matches()
        ProgressRun = 0
        match_count = self.backend.get_match_count()
        if match_count > 10000:
            self.label_MatchCount.setText("Match count: {} (10000 shown)".format(match_count))
        else:
            self.label_MatchCount.setText("Match count: {}".format(match_count))
        self.tableWidget_valuesearchtable.setRowCount(0)
        current_type = self.comboBox_ValueType.currentData(Qt.UserRole)
        length = self._scan_to_length(current_type)
        mem_handle = GDB_Engine.memory_handle()
        for n, address, offset, region_type, val, result_type in matches:
            n = int(n)
            address = "0x" + address
            current_item = QTableWidgetItem(address)
            result = result_type.split(" ")[0]
            value_index = type_defs.scanmem_result_to_index_dict[result]
            signed = False
            if type_defs.VALUE_INDEX.is_integer(value_index) and result.endswith("s"):
                signed = True
            current_item.setData(Qt.UserRole, (value_index, signed))
            value = str(GDB_Engine.read_memory(address, value_index, length, signed=signed, mem_handle=mem_handle))
            self.tableWidget_valuesearchtable.insertRow(self.tableWidget_valuesearchtable.rowCount())
            self.tableWidget_valuesearchtable.setItem(n, SEARCH_TABLE_ADDRESS_COL, current_item)
            self.tableWidget_valuesearchtable.setItem(n, SEARCH_TABLE_VALUE_COL, QTableWidgetItem(value))
            self.tableWidget_valuesearchtable.setItem(n, SEARCH_TABLE_PREVIOUS_COL, QTableWidgetItem(value))
            if n == 10000:
                break

    def _scan_to_length(self, type_index):
        if type_index == type_defs.SCAN_INDEX.INDEX_AOB:
            return self.lineEdit_Scan.text().count(" ") + 1
        if type_index == type_defs.SCAN_INDEX.INDEX_STRING:
            return len(self.lineEdit_Scan.text())
        return 0

    @GDB_Engine.execute_with_temporary_interruption
    def tableWidget_valuesearchtable_cell_double_clicked(self, row, col):
        current_item = self.tableWidget_valuesearchtable.item(row, SEARCH_TABLE_ADDRESS_COL)
        length = self._scan_to_length(self.comboBox_ValueType.currentData(Qt.UserRole))
        self.add_entry_to_addresstable("", current_item.text(), current_item.data(Qt.UserRole)[0], length)

    def comboBox_ValueType_current_index_changed(self):
        current_type = self.comboBox_ValueType.currentData(Qt.UserRole)
        validator_map = {
            "int": QRegExpValidator(QRegExp("-?[0-9]*"), parent=self.lineEdit_Scan),  # integers
            "float": QRegExpValidator(QRegExp("-?[0-9]+[.,]?[0-9]*")),
            # floats, should work fine with the small amount of testing I did
            "bytearray": QRegExpValidator(QRegExp("^(([A-Fa-f0-9?]{2} +)+)$"), parent=self.lineEdit_Scan),
            # array of bytes
            "string": None
        }
        scanmem_type = type_defs.scan_index_to_scanmem_dict[current_type]
        validator_str = scanmem_type  # used to get the correct validator

        # TODO this can probably be made to look nicer, though it doesn't really matter
        if "int" in validator_str:
            validator_str = "int"
            self.checkBox_Hex.setEnabled(True)
        else:
            self.checkBox_Hex.setChecked(False)
            self.checkBox_Hex.setEnabled(False)
        if "float" in validator_str or validator_str == "number":
            validator_str = "float"

        self.lineEdit_Scan.setValidator(validator_map[validator_str])
        self.lineEdit_Scan2.setValidator(validator_map[validator_str])
        self.backend.send_command("option scan_data_type {}".format(scanmem_type))
        # according to scanmem instructions you should always do `reset` after changing type
        self.backend.send_command("reset")

    def pushButton_AttachProcess_clicked(self):
        self.processwindow = ProcessForm(self)
        self.processwindow.show()

    def pushButton_Open_clicked(self):
        pct_file_path = SysUtils.get_user_path(type_defs.USER_PATHS.CHEAT_TABLES_PATH)
        file_paths = QFileDialog.getOpenFileNames(self, "Open PCT file(s)", pct_file_path,
                                                  "PINCE Cheat Table (*.pct);;All files (*)")[0]
        if not file_paths:
            return
        if self.treeWidget_AddressTable.topLevelItemCount() > 0:
            if InputDialogForm(item_list=[("Clear existing address table?",)]).exec_():
                self.treeWidget_AddressTable.clear()

        for file_path in file_paths:
            content = SysUtils.load_file(file_path)
            if content is None:
                QMessageBox.information(self, "Error", "File " + file_path + " does not exist, " +
                                        "is inaccessible or contains invalid content. Terminating...")
                break
            self.insert_records(content, self.treeWidget_AddressTable.invisibleRootItem(),
                                self.treeWidget_AddressTable.topLevelItemCount())

    def pushButton_Save_clicked(self):
        pct_file_path = SysUtils.get_user_path(type_defs.USER_PATHS.CHEAT_TABLES_PATH)
        file_path = QFileDialog.getSaveFileName(self, "Save PCT file", pct_file_path,
                                                "PINCE Cheat Table (*.pct);;All files (*)")[0]
        if not file_path:
            return
        content = [self.read_address_table_recursively(self.treeWidget_AddressTable.topLevelItem(i))
                   for i in range(self.treeWidget_AddressTable.topLevelItemCount())]
        file_path = SysUtils.append_file_extension(file_path, "pct")
        if not SysUtils.save_file(content, file_path):
            QMessageBox.information(self, "Error", "Cannot save to file")

    # Returns: a bool value indicates whether the operation succeeded.
    def attach_to_pid(self, pid):
        attach_result = GDB_Engine.attach(pid, gdb_path)
        if attach_result[0] == type_defs.ATTACH_RESULT.ATTACH_SUCCESSFUL:
            self.apply_after_init()
            self.backend.send_command("pid {}".format(pid))
            self.on_new_process()

            # TODO: This makes PINCE call on_process_stop twice when attaching
            # TODO: Signal design might have to change to something like mutexes eventually
            self.memory_view_window.on_process_stop()
            GDB_Engine.continue_inferior()
            return True
        else:
            QMessageBox.information(app.focusWidget(), "Error", attach_result[1])
            return False

    # Returns: a bool value indicates whether the operation succeeded.
    def create_new_process(self, file_path, args, ld_preload_path):
        if GDB_Engine.create_process(file_path, args, ld_preload_path):
            self.apply_after_init()
            self.on_new_process()
            return True
        else:
            QMessageBox.information(app.focusWidget(), "Error", "An error occurred while trying to create process")
            self.on_inferior_exit()
            return False

    # This is called whenever a new process is created/attached to by PINCE
    # in order to change the form appearance
    def on_new_process(self):
        # TODO add scanmem attachment here
        p = SysUtils.get_process_information(GDB_Engine.currentpid)
        self.label_SelectedProcess.setText(str(p.pid) + " - " + p.name())

        # enable scan GUI
        self.lineEdit_Scan.setPlaceholderText("Scan for")
        # self.QWidget_Toolbox.setEnabled(True)
        # self.pushButton_NextScan.setEnabled(False)
        # self.pushButton_UndoScan.setEnabled(False)

    def delete_address_table_contents(self):
        confirm_dialog = InputDialogForm(item_list=[("This will clear the contents of address table\nProceed?",)])
        if confirm_dialog.exec_():
            self.treeWidget_AddressTable.clear()

    def copy_to_address_table(self):
        i = -1
        length = self._scan_to_length(self.comboBox_ValueType.currentData(Qt.UserRole))
        for row in self.tableWidget_valuesearchtable.selectedItems():
            i = i + 1
            if i % 3 == 0:
                self.add_entry_to_addresstable("", row.text(), row.data(Qt.UserRole)[0], length)

    def on_inferior_exit(self):
        if GDB_Engine.currentpid == -1:
            self.on_status_running()
            GDB_Engine.init_gdb(gdb_path)
            self.apply_after_init()
            self.label_SelectedProcess.setText("No Process Selected")

    def on_status_detached(self):
        self.label_SelectedProcess.setStyleSheet("color: blue")
        self.label_InferiorStatus.setText("[detached]")
        self.label_InferiorStatus.setVisible(True)
        self.label_InferiorStatus.setStyleSheet("color: blue")

    def on_status_stopped(self):
        self.label_SelectedProcess.setStyleSheet("color: red")
        self.label_InferiorStatus.setText("[stopped]")
        self.label_InferiorStatus.setVisible(True)
        self.label_InferiorStatus.setStyleSheet("color: red")
        self.update_address_table()

    def on_status_running(self):
        self.label_SelectedProcess.setStyleSheet("")
        self.label_InferiorStatus.setVisible(False)

    # closes all windows on exit
    def closeEvent(self, event):
        GDB_Engine.detach()
        app.closeAllWindows()

    def add_entry_to_addresstable(self, description, address_expr, value_index, length=0, zero_terminate=True):
        current_row = QTreeWidgetItem()
        current_row.setCheckState(FROZEN_COL, Qt.Unchecked)
        frozen = type_defs.Frozen("", type_defs.FREEZE_TYPE.DEFAULT)
        current_row.setData(FROZEN_COL, Qt.UserRole, frozen)
        value_type = type_defs.ValueType(value_index, length, zero_terminate)
        self.treeWidget_AddressTable.addTopLevelItem(current_row)
        self.change_address_table_entries(current_row, description, address_expr, value_type)
        self.show()  # In case of getting called from elsewhere
        self.activateWindow()

    def treeWidget_AddressTable_item_double_clicked(self, row, column):
        action_for_column = {
            VALUE_COL: self.treeWidget_AddressTable_edit_value,
            DESC_COL: self.treeWidget_AddressTable_edit_desc,
            ADDR_COL: self.treeWidget_AddressTable_edit_address,
            TYPE_COL: self.treeWidget_AddressTable_edit_type
        }
        action_for_column = collections.defaultdict(lambda *args: lambda: None, action_for_column)
        action_for_column[column]()

    # ----------------------------------------------------
    # Async Functions

    def update_progress_bar(self):
        global ProgressRun
        global Exiting
        self.progressBar.setValue(0)
        ProgressRun = 1
        while ProgressRun == 1 and Exiting == 0:
            sleep(0.1)
            value = int(round(self.backend.get_scan_progress() * 100))
            self.progressBar.setValue(value)

    def update_address_table_loop(self):
        while Exiting == 0:
            sleep(table_update_interval / 1000)
            if update_table:
                try:
                    self.update_address_table()
                except:
                    print("Update Address Table failed :(")

    def update_search_table_loop(self):
        while Exiting == 0:
            sleep(0.5)
            try:
                self.update_search_table()
            except:
                print("Update Search Table failed :(")

    def freeze_loop(self):
        while Exiting == 0:
            sleep(FreezeInterval / 1000)
            try:
                self.freeze()
            except:
                print("Freeze failed :(")

    # ----------------------------------------------------

    def update_search_table(self):
        row_count = self.tableWidget_valuesearchtable.rowCount()
        if row_count > 0:
            length = self._scan_to_length(self.comboBox_ValueType.currentData(Qt.UserRole))
            mem_handle = GDB_Engine.memory_handle()
            for row_index in range(row_count):
                address_item = self.tableWidget_valuesearchtable.item(row_index, SEARCH_TABLE_ADDRESS_COL)
                previous_text = self.tableWidget_valuesearchtable.item(row_index, SEARCH_TABLE_PREVIOUS_COL).text()
                value_index, signed = address_item.data(Qt.UserRole)
                address = address_item.text()
                new_value = str(GDB_Engine.read_memory(address, value_index, length, signed=signed,
                                                       mem_handle=mem_handle))
                value_item = QTableWidgetItem(new_value)
                if new_value != previous_text:
                    value_item.setForeground(QBrush(QColor(255, 0, 0)))
                self.tableWidget_valuesearchtable.setItem(row_index, SEARCH_TABLE_VALUE_COL, value_item)

    def freeze(self):
        it = QTreeWidgetItemIterator(self.treeWidget_AddressTable)
        while it.value():
            row = it.value()
            if row.checkState(FROZEN_COL) == Qt.Checked:
                value_index = row.data(TYPE_COL, Qt.UserRole).value_index
                address = row.text(ADDR_COL)
                frozen = row.data(FROZEN_COL, Qt.UserRole)
                value = frozen.value
                freeze_type = frozen.freeze_type
                if type_defs.VALUE_INDEX.is_integer(value_index):
                    new_value = GDB_Engine.read_memory(address, value_index)
                    if freeze_type == type_defs.FREEZE_TYPE.INCREMENT and new_value > int(value, 0) or \
                            freeze_type == type_defs.FREEZE_TYPE.DECREMENT and new_value < int(value, 0):
                        frozen.value = str(new_value)
                        GDB_Engine.write_memory(address, value_index, frozen.value)
                        continue
                GDB_Engine.write_memory(address, value_index, value)
            it += 1

    def treeWidget_AddressTable_item_clicked(self, row, column):
        if column == FROZEN_COL:
            if row.checkState(FROZEN_COL) == Qt.Checked:
                frozen = row.data(FROZEN_COL, Qt.UserRole)
                frozen.value = row.text(VALUE_COL)
            else:
                row.setText(FROZEN_COL, "")
                row.setForeground(FROZEN_COL, QBrush(QColor(0, 0, 0)))

    def treeWidget_AddressTable_change_repr(self, new_repr):
        value_type = GuiUtils.get_current_item(self.treeWidget_AddressTable).data(TYPE_COL, Qt.UserRole)
        value_type.value_repr = new_repr
        for row in self.treeWidget_AddressTable.selectedItems():
            row.setData(TYPE_COL, Qt.UserRole, value_type)
            row.setText(TYPE_COL, value_type.text())
        self.update_address_table()

    def treeWidget_AddressTable_edit_value(self):
        row = GuiUtils.get_current_item(self.treeWidget_AddressTable)
        if not row:
            return
        value = row.text(VALUE_COL)
        value_index = row.data(TYPE_COL, Qt.UserRole).value_index
        label_text = "Enter the new value"
        dialog = InputDialogForm(item_list=[(label_text, value)], parsed_index=0, value_index=value_index)
        if dialog.exec_():
            new_value = dialog.get_values()
            for row in self.treeWidget_AddressTable.selectedItems():
                address = row.text(ADDR_COL)
                value_type = row.data(TYPE_COL, Qt.UserRole)
                if type_defs.VALUE_INDEX.has_length(value_type.value_index):
                    unknown_type = SysUtils.parse_string(new_value, value_type.value_index)
                    if unknown_type is not None:
                        value_type.length = len(unknown_type)
                        row.setText(TYPE_COL, value_type.text())
                frozen = row.data(FROZEN_COL, Qt.UserRole)
                frozen.value = new_value
                row.setData(FROZEN_COL, Qt.UserRole, frozen)
                GDB_Engine.write_memory(address, value_type.value_index, new_value)
            self.update_address_table()

    def treeWidget_AddressTable_edit_desc(self):
        row = GuiUtils.get_current_item(self.treeWidget_AddressTable)
        if not row:
            return
        description = row.text(DESC_COL)
        dialog = InputDialogForm(item_list=[("Enter the new description", description)])
        if dialog.exec_():
            description_text = dialog.get_values()
            for row in self.treeWidget_AddressTable.selectedItems():
                row.setText(DESC_COL, description_text)

    def treeWidget_AddressTable_edit_address(self):
        row = GuiUtils.get_current_item(self.treeWidget_AddressTable)
        if not row:
            return
        desc, address_expr, value_type = self.read_address_table_entries(row)
        manual_address_dialog = ManualAddressDialogForm(description=desc, address=address_expr,
                                                        index=value_type.value_index, length=value_type.length,
                                                        zero_terminate=value_type.zero_terminate)
        manual_address_dialog.setWindowTitle("Edit Address")
        if manual_address_dialog.exec_():
            desc, address_expr, value_index, length, zero_terminate = manual_address_dialog.get_values()
            value_type = type_defs.ValueType(value_index, length, zero_terminate, value_type.value_repr)
            self.change_address_table_entries(row, desc, address_expr, value_type)

    def treeWidget_AddressTable_edit_type(self):
        row = GuiUtils.get_current_item(self.treeWidget_AddressTable)
        if not row:
            return
        value_type = row.data(TYPE_COL, Qt.UserRole)
        dialog = EditTypeDialogForm(index=value_type.value_index, length=value_type.length,
                                    zero_terminate=value_type.zero_terminate)
        if dialog.exec_():
            value_index, length, zero_terminate = dialog.get_values()
            value_type = type_defs.ValueType(value_index, length, zero_terminate, value_type.value_repr)
            for row in self.treeWidget_AddressTable.selectedItems():
                row.setData(TYPE_COL, Qt.UserRole, value_type)
                row.setText(TYPE_COL, value_type.text())
            self.update_address_table()

    # Changes the column values of the given row
    def change_address_table_entries(self, row, description="", address_expr="", value_type=None):
        try:
            address = GDB_Engine.examine_expression(address_expr).address
        except type_defs.InferiorRunningException:
            address = address_expr
        value = ''
        if address:
            value = GDB_Engine.read_memory(address, value_type.value_index, value_type.length,
                                           value_type.zero_terminate)

        assert isinstance(row, QTreeWidgetItem)
        row.setText(DESC_COL, description)
        row.setData(ADDR_COL, Qt.UserRole, address_expr)
        row.setText(ADDR_COL, address or address_expr)
        row.setData(TYPE_COL, Qt.UserRole, value_type)
        row.setText(TYPE_COL, value_type.text())
        row.setText(VALUE_COL, "" if value is None else str(value))

    # Returns the column values of the given row
    def read_address_table_entries(self, row, serialize=False):
        description = row.text(DESC_COL)
        address_expr = row.data(ADDR_COL, Qt.UserRole)
        if serialize:
            value_type = row.data(TYPE_COL, Qt.UserRole).serialize()
        else:
            value_type = row.data(TYPE_COL, Qt.UserRole)
        return description, address_expr, value_type

    # Returns the values inside the given row and all of its descendants.
    # All values except the last are the same as read_address_table_entries output.
    # Last value is an iterable of information about its direct children.
    def read_address_table_recursively(self, row):
        return self.read_address_table_entries(row, True) + \
               ([self.read_address_table_recursively(row.child(i)) for i in range(row.childCount())],)


# process select window
class ProcessForm(QMainWindow, ProcessWindow):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)
        GuiUtils.center_to_parent(self)
        self.refresh_process_table(self.tableWidget_ProcessTable, SysUtils.iterate_processes())
        self.pushButton_Close.clicked.connect(self.close)
        self.pushButton_Open.clicked.connect(self.pushButton_Open_clicked)
        self.pushButton_CreateProcess.clicked.connect(self.pushButton_CreateProcess_clicked)
        self.lineEdit_SearchProcess.textChanged.connect(self.generate_new_list)
        self.tableWidget_ProcessTable.itemDoubleClicked.connect(self.pushButton_Open_clicked)

    # refreshes process list
    def generate_new_list(self):
        text = self.lineEdit_SearchProcess.text()
        processlist = SysUtils.search_in_processes_by_name(text)
        self.refresh_process_table(self.tableWidget_ProcessTable, processlist)

    def keyPressEvent(self, e):
        if e.key() == Qt.Key_Escape:
            # closes the window whenever ESC key is pressed
            self.close()
        elif e.key() == Qt.Key_Return:
            self.pushButton_Open_clicked()
        elif e.key() == Qt.Key_F1:
            self.pushButton_CreateProcess_clicked()
        elif e.key() == Qt.Key_Down or e.key() == Qt.Key_Up:
            self.tableWidget_ProcessTable.keyPressEvent(QKeyEvent(QEvent.KeyPress, e.key(), Qt.NoModifier))

    # lists currently working processes to table
    def refresh_process_table(self, tablewidget, processlist):
        tablewidget.setRowCount(0)
        for process in processlist:
            pid = str(process.pid)
            try:
                username = process.username()
                name = process.name()
            except psutil.NoSuchProcess:
                continue
            current_row = tablewidget.rowCount()
            tablewidget.insertRow(current_row)
            tablewidget.setItem(current_row, 0, QTableWidgetItem(pid))
            tablewidget.setItem(current_row, 1, QTableWidgetItem(username))
            tablewidget.setItem(current_row, 2, QTableWidgetItem(name))

    # gets the pid out of the selection to attach
    def pushButton_Open_clicked(self):
        current_item = self.tableWidget_ProcessTable.item(self.tableWidget_ProcessTable.currentIndex().row(), 0)
        if current_item is None:
            QMessageBox.information(self, "Error", "Please select a process first")
        else:
            pid = int(current_item.text())
            self.setCursor(QCursor(Qt.WaitCursor))
            if self.parent().attach_to_pid(pid):
                self.close()
            self.setCursor(QCursor(Qt.ArrowCursor))

    def pushButton_CreateProcess_clicked(self):
        file_path = QFileDialog.getOpenFileName(self, "Select the target binary")[0]
        if file_path:
            items = [("Enter the optional arguments", ""), ("LD_PRELOAD .so path (optional)", "")]
            arg_dialog = InputDialogForm(item_list=items)
            if arg_dialog.exec_():
                args, ld_preload_path = arg_dialog.get_values()
            else:
                return
            self.setCursor(QCursor(Qt.WaitCursor))
            if self.parent().create_new_process(file_path, args, ld_preload_path):
                self.close()
            self.setCursor(QCursor(Qt.ArrowCursor))


# Add Address Manually Dialog
class ManualAddressDialogForm(QDialog, ManualAddressDialog):
    def __init__(self, parent=None, description="No Description", address="0x",
                 index=type_defs.VALUE_INDEX.INDEX_INT32, length=10, zero_terminate=True):
        super().__init__(parent=parent)
        self.setupUi(self)
        self.adjustSize()
        self.setMinimumWidth(300)
        self.setFixedHeight(self.height())
        self.lineEdit_length.setValidator(QHexValidator(999, self))
        GuiUtils.fill_value_combobox(self.comboBox_ValueType, index)
        self.lineEdit_description.setText(description)
        self.lineEdit_address.setText(address)
        if type_defs.VALUE_INDEX.is_string(self.comboBox_ValueType.currentIndex()):
            self.label_length.show()
            self.lineEdit_length.show()
            try:
                length = str(length)
            except:
                length = "10"
            self.lineEdit_length.setText(length)
            self.checkBox_zeroterminate.show()
            self.checkBox_zeroterminate.setChecked(zero_terminate)
        elif self.comboBox_ValueType.currentIndex() == type_defs.VALUE_INDEX.INDEX_AOB:
            self.label_length.show()
            self.lineEdit_length.show()
            try:
                length = str(length)
            except:
                length = "10"
            self.lineEdit_length.setText(length)
            self.checkBox_zeroterminate.hide()
        else:
            self.label_length.hide()
            self.lineEdit_length.hide()
            self.checkBox_zeroterminate.hide()
        self.comboBox_ValueType.currentIndexChanged.connect(self.comboBox_ValueType_current_index_changed)
        self.lineEdit_length.textChanged.connect(self.update_value_of_address)
        self.checkBox_zeroterminate.stateChanged.connect(self.update_value_of_address)
        self.lineEdit_address.textChanged.connect(self.update_value_of_address)
        self.label_valueofaddress.contextMenuEvent = self.label_valueofaddress_context_menu_event
        self.update_value_of_address()

    def label_valueofaddress_context_menu_event(self, event):
        menu = QMenu()
        refresh = menu.addAction("Refresh")
        font_size = self.label_valueofaddress.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            refresh: self.update_value_of_address
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def update_value_of_address(self):
        address = self.lineEdit_address.text()
        try:
            address = GDB_Engine.examine_expression(address).address
        except type_defs.InferiorRunningException:
            pass
        if not address:
            self.label_valueofaddress.setText("<font color=red>??</font>")
            return
        address_type = self.comboBox_ValueType.currentIndex()
        if address_type == type_defs.VALUE_INDEX.INDEX_AOB:
            length = self.lineEdit_length.text()
            value = GDB_Engine.read_memory(address, address_type, length)
        elif type_defs.VALUE_INDEX.is_string(address_type):
            length = self.lineEdit_length.text()
            is_zeroterminate = self.checkBox_zeroterminate.isChecked()
            value = GDB_Engine.read_memory(address, address_type, length, is_zeroterminate)
        else:
            value = GDB_Engine.read_memory(address, address_type)
        self.label_valueofaddress.setText("<font color=red>??</font>" if value is None else str(value))

    def comboBox_ValueType_current_index_changed(self):
        if type_defs.VALUE_INDEX.is_string(self.comboBox_ValueType.currentIndex()):
            self.label_length.show()
            self.lineEdit_length.show()
            self.checkBox_zeroterminate.show()
        elif self.comboBox_ValueType.currentIndex() == type_defs.VALUE_INDEX.INDEX_AOB:
            self.label_length.show()
            self.lineEdit_length.show()
            self.checkBox_zeroterminate.hide()
        else:
            self.label_length.hide()
            self.lineEdit_length.hide()
            self.checkBox_zeroterminate.hide()
        self.update_value_of_address()

    def reject(self):
        super(ManualAddressDialogForm, self).reject()

    def accept(self):
        if self.label_length.isVisible():
            length = self.lineEdit_length.text()
            try:
                length = int(length, 0)
            except:
                QMessageBox.information(self, "Error", "Length is not valid")
                return
            if not length > 0:
                QMessageBox.information(self, "Error", "Length must be greater than 0")
                return
        super(ManualAddressDialogForm, self).accept()

    def get_values(self):
        description = self.lineEdit_description.text()
        address = self.lineEdit_address.text()
        length = self.lineEdit_length.text()
        try:
            length = int(length, 0)
        except:
            length = 0
        zero_terminate = False
        if self.checkBox_zeroterminate.isChecked():
            zero_terminate = True
        value_index = self.comboBox_ValueType.currentIndex()
        return description, address, value_index, length, zero_terminate


class EditTypeDialogForm(QDialog, EditTypeDialog):
    def __init__(self, parent=None, index=type_defs.VALUE_INDEX.INDEX_INT32, length=10, zero_terminate=True):
        super().__init__(parent=parent)
        self.setupUi(self)
        self.setMaximumSize(100, 100)
        self.lineEdit_Length.setValidator(QHexValidator(999, self))
        GuiUtils.fill_value_combobox(self.comboBox_ValueType, index)
        if type_defs.VALUE_INDEX.is_string(self.comboBox_ValueType.currentIndex()):
            self.label_Length.show()
            self.lineEdit_Length.show()
            try:
                length = str(length)
            except:
                length = "10"
            self.lineEdit_Length.setText(length)
            self.checkBox_ZeroTerminate.show()
            self.checkBox_ZeroTerminate.setChecked(zero_terminate)
        elif self.comboBox_ValueType.currentIndex() == type_defs.VALUE_INDEX.INDEX_AOB:
            self.label_Length.show()
            self.lineEdit_Length.show()
            try:
                length = str(length)
            except:
                length = "10"
            self.lineEdit_Length.setText(length)
            self.checkBox_ZeroTerminate.hide()
        else:
            self.label_Length.hide()
            self.lineEdit_Length.hide()
            self.checkBox_ZeroTerminate.hide()
        self.comboBox_ValueType.currentIndexChanged.connect(self.comboBox_ValueType_current_index_changed)

    def comboBox_ValueType_current_index_changed(self):
        if type_defs.VALUE_INDEX.is_string(self.comboBox_ValueType.currentIndex()):
            self.label_Length.show()
            self.lineEdit_Length.show()
            self.checkBox_ZeroTerminate.show()
        elif self.comboBox_ValueType.currentIndex() == type_defs.VALUE_INDEX.INDEX_AOB:
            self.label_Length.show()
            self.lineEdit_Length.show()
            self.checkBox_ZeroTerminate.hide()
        else:
            self.label_Length.hide()
            self.lineEdit_Length.hide()
            self.checkBox_ZeroTerminate.hide()

    def reject(self):
        super(EditTypeDialogForm, self).reject()

    def accept(self):
        if self.label_Length.isVisible():
            length = self.lineEdit_Length.text()
            try:
                length = int(length, 0)
            except:
                QMessageBox.information(self, "Error", "Length is not valid")
                return
            if not length > 0:
                QMessageBox.information(self, "Error", "Length must be greater than 0")
                return
        super(EditTypeDialogForm, self).accept()

    def get_values(self):
        length = self.lineEdit_Length.text()
        try:
            length = int(length, 0)
        except:
            length = 0
        zero_terminate = False
        if self.checkBox_ZeroTerminate.isChecked():
            zero_terminate = True
        address_type = self.comboBox_ValueType.currentIndex()
        return address_type, length, zero_terminate


class LoadingDialogForm(QDialog, LoadingDialog):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)
        self.setWindowFlags(self.windowFlags() | Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        if parent:
            GuiUtils.center_to_parent(self)
        self.keyPressEvent = QEvent.ignore

        # Make use of this background_thread when you spawn a LoadingDialogForm
        # Warning: overrided_func() can only return one value, so if your overridden function returns more than one
        # value, refactor your overriden function to return only one object(convert tuple to list etc.)
        # Check refresh_table method of FunctionsInfoWidgetForm for exemplary usage
        self.background_thread = self.BackgroundThread()
        self.background_thread.output_ready.connect(self.accept)
        self.pushButton_Cancel.clicked.connect(self.cancel_thread)
        media_directory = SysUtils.get_media_directory()
        self.movie = QMovie(media_directory + "/LoadingDialog/ajax-loader.gif", QByteArray())
        self.label_Animated.setMovie(self.movie)
        self.movie.setScaledSize(QSize(25, 25))
        self.movie.setCacheMode(QMovie.CacheAll)
        self.movie.setSpeed(100)
        self.movie.start()

    # This function only cancels the last command sent
    # Override this if you want to do dangerous stuff like, God forbid, background_thread.terminate()
    def cancel_thread(self):
        GDB_Engine.cancel_last_command()

    def exec_(self):
        self.background_thread.start()
        super(LoadingDialogForm, self).exec_()

    class BackgroundThread(QThread):
        output_ready = pyqtSignal(object)

        def __init__(self):
            super().__init__()

        def run(self):
            output = self.overrided_func()
            self.output_ready.emit(output)

        def overrided_func(self):
            print("Override this function")
            return 0


class InputDialogForm(QDialog, InputDialog):
    # Format of item_list->[(label_str, item_data, label_alignment), ...]
    # If label_str is None, no label will be created
    # If item_data is None, no input field will be created. If it's str, a QLineEdit containing the str will be created
    # If it's a list, a QComboBox with the items in the list will be created, last item of the list should be an integer
    # that points the current index of the QComboBox, for instance: ["0", "1", 1] will create a QCombobox with the items
    # "0" and "1" then will set current index to 1 (which is the item "1")
    # label_alignment is optional
    def __init__(self, parent=None, item_list=None, parsed_index=-1, value_index=type_defs.VALUE_INDEX.INDEX_INT32,
                 buttons=(QDialogButtonBox.Ok, QDialogButtonBox.Cancel)):
        super().__init__(parent=parent)
        self.setupUi(self)
        for button in buttons:
            self.buttonBox.addButton(button)
        self.object_list = []
        for item in item_list:
            if item[0] is not None:
                label = QLabel(self)
                try:
                    label.setAlignment(item[2])
                except IndexError:
                    label.setAlignment(Qt.AlignCenter)
                label.setText(item[0])
                label.setTextInteractionFlags(Qt.LinksAccessibleByMouse | Qt.TextSelectableByMouse)
                self.verticalLayout.addWidget(label)
            try:
                item_data = item[1]
            except IndexError:
                pass
            else:
                if item_data is not None:
                    if type(item_data) is str:
                        lineedit = QLineEdit(self)
                        lineedit.setText(item_data)
                        self.verticalLayout.addWidget(lineedit)
                        self.object_list.append(lineedit)
                    elif type(item_data) is list:
                        combobox = QComboBox(self)
                        current_index = item_data.pop()
                        combobox.addItems(item_data)
                        combobox.setCurrentIndex(current_index)
                        self.verticalLayout.addWidget(combobox)
                        self.object_list.append(combobox)
        self.adjustSize()
        self.verticalLayout.removeWidget(self.buttonBox)  # Pushing buttonBox to the end
        self.verticalLayout.addWidget(self.buttonBox)
        for widget in GuiUtils.get_layout_widgets(self.verticalLayout):
            if isinstance(widget, QLabel):
                continue
            widget.setFocus()  # Focus to the first input field
            break
        self.parsed_index = parsed_index
        self.value_index = value_index

    def get_text(self, item):
        try:
            string = item.text()
        except AttributeError:
            string = item.currentText()
        return string

    def get_values(self):
        return self.get_text(self.object_list[0]) if len(self.object_list) == 1 else [self.get_text(item) for item in
                                                                                      self.object_list]

    def accept(self):
        if self.parsed_index != -1:
            item = self.object_list[self.parsed_index]
            if SysUtils.parse_string(self.get_text(item), self.value_index) is None:
                QMessageBox.information(self, "Error", "Can't parse the input")
                return
        super(InputDialogForm, self).accept()


class TextEditDialogForm(QDialog, TextEditDialog):
    def __init__(self, parent=None, text=""):
        super().__init__(parent=parent)
        self.setupUi(self)
        self.textEdit.setPlainText(str(text))
        self.accept_shortcut = QShortcut(QKeySequence("Ctrl+Return"), self)
        self.accept_shortcut.activated.connect(self.accept)

    def get_values(self):
        return self.textEdit.toPlainText()

    def keyPressEvent(self, QKeyEvent):
        if QKeyEvent.key() == Qt.Key_Enter:
            pass
        else:
            super(TextEditDialogForm, self).keyPressEvent(QKeyEvent)


class SettingsDialogForm(QDialog, SettingsDialog):
    def __init__(self, set_default_settings_func, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)
        self.settings = QSettings()
        self.set_default_settings = set_default_settings_func
        self.hotkey_to_value = {}  # Dict[str:str]-->Dict[Hotkey.name:settings_value]

        # Yet another retarded hack, thanks to pyuic5 not supporting QKeySequenceEdit
        self.keySequenceEdit = QKeySequenceEdit()
        self.verticalLayout_Hotkey.addWidget(self.keySequenceEdit)
        self.listWidget_Options.currentRowChanged.connect(self.change_display)
        icons_directory = GuiUtils.get_icons_directory()
        self.pushButton_GDBPath.setIcon(QIcon(QPixmap(icons_directory + "/folder.png")))
        self.listWidget_Functions.currentRowChanged.connect(self.listWidget_Functions_current_row_changed)
        self.keySequenceEdit.keySequenceChanged.connect(self.keySequenceEdit_key_sequence_changed)
        self.pushButton_ClearHotkey.clicked.connect(self.pushButton_ClearHotkey_clicked)
        self.pushButton_ResetSettings.clicked.connect(self.pushButton_ResetSettings_clicked)
        self.pushButton_GDBPath.clicked.connect(self.pushButton_GDBPath_clicked)
        self.checkBox_AutoUpdateAddressTable.stateChanged.connect(self.checkBox_AutoUpdateAddressTable_state_changed)
        self.checkBox_AutoAttachRegex.stateChanged.connect(self.checkBox_AutoAttachRegex_state_changed)
        self.checkBox_AutoAttachRegex_state_changed()
        self.pushButton_HandleSignals.clicked.connect(self.pushButton_HandleSignals_clicked)
        self.handle_signals_data = None
        self.config_gui()

    def accept(self):
        try:
            current_table_update_interval = int(self.lineEdit_UpdateInterval.text())
        except:
            QMessageBox.information(self, "Error", "Update interval must be an int")
            return
        try:
            freezeinterval = int(self.lineEdit_FreezeInterval.text())
        except:
            QMessageBox.information(self, "Error", "Freeze interval must be an int")
            return
        try:
            current_instructions_shown = int(self.lineEdit_InstructionsPerScroll.text())
        except:
            QMessageBox.information(self, "Error", "Instruction count must be an integer")
            return
        if current_instructions_shown < 1:
            QMessageBox.information(self, "Error", "Instruction count cannot be lower than 1" +
                                    "\nIt would be silly anyway, wouldn't it?")
            return
        if not self.checkBox_AutoUpdateAddressTable.isChecked():
            pass
        elif current_table_update_interval < 0 or freezeinterval < 0:
            QMessageBox.information(self, "Error", "Interval cannot be a negative number")
            return
        elif current_table_update_interval == 0 or freezeinterval == 0:

            # Easter egg #2
            if not InputDialogForm(item_list=[("You are asking for it, aren't you?",)]).exec_():
                return
        elif current_table_update_interval < 100:
            if not InputDialogForm(item_list=[("Update interval should be bigger than 100 ms" +
                                               "\nSetting update interval less than 100 ms may cause slowdown"
                                               "\nProceed?",)]).exec_():
                return

        self.settings.setValue("General/auto_update_address_table", self.checkBox_AutoUpdateAddressTable.isChecked())
        if self.checkBox_AutoUpdateAddressTable.isChecked():
            self.settings.setValue("General/address_table_update_interval", current_table_update_interval)
        self.settings.setValue("General/freeze_interval", freezeinterval)
        self.settings.setValue("General/show_messagebox_on_exception", self.checkBox_MessageBoxOnException.isChecked())
        self.settings.setValue("General/show_messagebox_on_toggle_attach",
                               self.checkBox_MessageBoxOnToggleAttach.isChecked())
        current_gdb_output_mode = type_defs.gdb_output_mode(self.checkBox_OutputModeAsync.isChecked(),
                                                            self.checkBox_OutputModeCommand.isChecked(),
                                                            self.checkBox_OutputModeCommandInfo.isChecked())
        self.settings.setValue("General/gdb_output_mode", current_gdb_output_mode)
        if self.checkBox_AutoAttachRegex.isChecked():
            try:
                re.compile(self.lineEdit_AutoAttachList.text())
            except:
                QMessageBox.information(self, "Error", self.lineEdit_AutoAttachList.text() + " isn't a valid regex")
                return
        self.settings.setValue("General/auto_attach_list", self.lineEdit_AutoAttachList.text())
        self.settings.setValue("General/logo_path", self.comboBox_Logo.currentText())
        self.settings.setValue("General/auto_attach_regex", self.checkBox_AutoAttachRegex.isChecked())
        for hotkey in Hotkeys.get_hotkeys():
            self.settings.setValue("Hotkeys/" + hotkey.name, self.hotkey_to_value[hotkey.name])
        if self.radioButton_SimpleDLopenCall.isChecked():
            injection_method = type_defs.INJECTION_METHOD.SIMPLE_DLOPEN_CALL
        elif self.radioButton_AdvancedInjection.isChecked():
            injection_method = type_defs.INJECTION_METHOD.ADVANCED_INJECTION
        self.settings.setValue("CodeInjection/code_injection_method", injection_method)
        self.settings.setValue("Disassemble/bring_disassemble_to_front",
                               self.checkBox_BringDisassembleToFront.isChecked())
        self.settings.setValue("Disassemble/instructions_per_scroll", current_instructions_shown)
        selected_gdb_path = self.lineEdit_GDBPath.text()
        current_gdb_path = self.settings.value("Debug/gdb_path", type=str)
        if selected_gdb_path != current_gdb_path:
            if InputDialogForm(item_list=[("You have changed the GDB path, reset GDB now?",)]).exec_():
                GDB_Engine.init_gdb(selected_gdb_path)
        self.settings.setValue("Debug/gdb_path", selected_gdb_path)
        self.settings.setValue("Debug/gdb_logging", self.checkBox_GDBLogging.isChecked())
        if self.handle_signals_data is not None:
            self.settings.setValue("Debug/ignored_signals", ",".join(self.handle_signals_data))
        super(SettingsDialogForm, self).accept()

    def config_gui(self):
        self.checkBox_AutoUpdateAddressTable.setChecked(
            self.settings.value("General/auto_update_address_table", type=bool))
        self.lineEdit_UpdateInterval.setText(
            str(self.settings.value("General/address_table_update_interval", type=int)))
        self.lineEdit_FreezeInterval.setText(
            str(self.settings.value("General/freeze_interval", type=int)))
        self.checkBox_MessageBoxOnException.setChecked(
            self.settings.value("General/show_messagebox_on_exception", type=bool))
        self.checkBox_MessageBoxOnToggleAttach.setChecked(
            self.settings.value("General/show_messagebox_on_toggle_attach", type=bool))
        self.checkBox_OutputModeAsync.setChecked(self.settings.value("General/gdb_output_mode").async_output)
        self.checkBox_OutputModeCommand.setChecked(self.settings.value("General/gdb_output_mode").command_output)
        self.checkBox_OutputModeCommandInfo.setChecked(self.settings.value("General/gdb_output_mode").command_info)
        self.lineEdit_AutoAttachList.setText(self.settings.value("General/auto_attach_list", type=str))
        logo_directory = SysUtils.get_logo_directory()
        logo_list = SysUtils.search_files(logo_directory, "\.(png|jpg|jpeg|svg)$")
        self.comboBox_Logo.clear()
        for logo in logo_list:
            self.comboBox_Logo.addItem(QIcon(os.path.join(logo_directory, logo)), logo)
        self.comboBox_Logo.setCurrentIndex(logo_list.index(self.settings.value("General/logo_path", type=str)))
        self.checkBox_AutoAttachRegex.setChecked(self.settings.value("General/auto_attach_regex", type=bool))
        self.listWidget_Functions.clear()
        self.hotkey_to_value.clear()
        for hotkey in Hotkeys.get_hotkeys():
            self.listWidget_Functions.addItem(hotkey.desc)
            self.hotkey_to_value[hotkey.name] = self.settings.value("Hotkeys/" + hotkey.name)
        injection_method = self.settings.value("CodeInjection/code_injection_method", type=int)
        if injection_method == type_defs.INJECTION_METHOD.SIMPLE_DLOPEN_CALL:
            self.radioButton_SimpleDLopenCall.setChecked(True)
        elif injection_method == type_defs.INJECTION_METHOD.ADVANCED_INJECTION:
            self.radioButton_AdvancedInjection.setChecked(True)
        self.checkBox_BringDisassembleToFront.setChecked(
            self.settings.value("Disassemble/bring_disassemble_to_front", type=bool))
        self.lineEdit_InstructionsPerScroll.setText(
            str(self.settings.value("Disassemble/instructions_per_scroll", type=int)))
        self.lineEdit_GDBPath.setText(str(self.settings.value("Debug/gdb_path", type=str)))
        self.checkBox_GDBLogging.setChecked(self.settings.value("Debug/gdb_logging", type=bool))

    def change_display(self, index):
        self.stackedWidget.setCurrentIndex(index)

    def listWidget_Functions_current_row_changed(self, index):
        if index == -1:
            self.keySequenceEdit.clear()
        else:
            self.keySequenceEdit.setKeySequence(self.hotkey_to_value[Hotkeys.get_hotkeys()[index].name])

    def keySequenceEdit_key_sequence_changed(self):
        index = self.listWidget_Functions.currentIndex().row()
        if index == -1:
            self.keySequenceEdit.clear()
        else:
            self.hotkey_to_value[Hotkeys.get_hotkeys()[index].name] = self.keySequenceEdit.keySequence().toString()

    def pushButton_ClearHotkey_clicked(self):
        self.keySequenceEdit.clear()

    def pushButton_ResetSettings_clicked(self):
        confirm_dialog = InputDialogForm(item_list=[("This will reset to the default settings\nProceed?",)])
        if confirm_dialog.exec_():
            self.set_default_settings()
            self.handle_signals_data = None
            self.config_gui()

    def checkBox_AutoUpdateAddressTable_state_changed(self):
        if self.checkBox_AutoUpdateAddressTable.isChecked():
            self.QWidget_UpdateInterval.setEnabled(True)
        else:
            self.QWidget_UpdateInterval.setEnabled(False)

    def checkBox_AutoAttachRegex_state_changed(self):
        if self.checkBox_AutoAttachRegex.isChecked():
            self.lineEdit_AutoAttachList.setPlaceholderText("Mouse over on this text for examples")
            self.lineEdit_AutoAttachList.setToolTip("'asdf|qwer' searches for asdf or qwer\n" +
                                                    "'[as]df' searches for both adf and sdf\n" +
                                                    "Use the char '\\' to escape special chars such as '['\n" +
                                                    "'\[asdf\]' searches for opcodes that contain '[asdf]'")
        else:
            self.lineEdit_AutoAttachList.setPlaceholderText("Separate processes with ;")
            self.lineEdit_AutoAttachList.setToolTip("")

    def pushButton_GDBPath_clicked(self):
        current_path = self.lineEdit_GDBPath.text()
        file_path = QFileDialog.getOpenFileName(self, "Select the gdb binary", os.path.dirname(current_path))[0]
        if file_path:
            self.lineEdit_GDBPath.setText(file_path)

    def pushButton_HandleSignals_clicked(self):
        if self.handle_signals_data is None:
            self.handle_signals_data = self.settings.value("Debug/ignored_signals", type=str).split(",")
        signal_dialog = HandleSignalsDialogForm(self.handle_signals_data)
        if signal_dialog.exec_():
            self.handle_signals_data = signal_dialog.get_values()


class HandleSignalsDialogForm(QDialog, HandleSignalsDialog):
    def __init__(self, signal_data, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)
        self.tableWidget_Signals.setRowCount(len(signal_list))
        for index, state in enumerate(signal_data):
            self.tableWidget_Signals.setItem(index, 0, QTableWidgetItem(signal_list[index]))
            widget = QWidget()
            checkbox = QCheckBox()
            layout = QHBoxLayout(widget)
            layout.addWidget(checkbox)
            layout.setAlignment(Qt.AlignCenter)
            layout.setContentsMargins(0, 0, 0, 0)
            self.tableWidget_Signals.setCellWidget(index, 1, widget)
            if state == "1":
                checkbox.setCheckState(Qt.Checked)
            else:
                checkbox.setCheckState(Qt.Unchecked)

    def get_values(self):
        final_state = []
        for index in range(len(signal_list)):
            widget = self.tableWidget_Signals.cellWidget(index, 1)
            checkbox = widget.findChild(QCheckBox)
            if checkbox.checkState() == Qt.Checked:
                final_state.append("1")
            else:
                final_state.append("0")
        return final_state


class ConsoleWidgetForm(QWidget, ConsoleWidget):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)
        global instances
        instances.append(self)
        GuiUtils.center(self)
        self.completion_model = QStringListModel()
        self.completer = QCompleter()
        self.completer.setModel(self.completion_model)
        self.completer.setCompletionMode(QCompleter.UnfilteredPopupCompletion)
        self.completer.setMaxVisibleItems(8)
        self.lineEdit.setCompleter(self.completer)
        self.quit_commands = ("q", "quit", "-gdb-exit")
        self.input_history = [""]
        self.current_history_index = -1
        self.await_async_output_thread = AwaitAsyncOutput()
        self.await_async_output_thread.async_output_ready.connect(self.on_async_output)
        self.await_async_output_thread.start()
        self.pushButton_Send.clicked.connect(self.communicate)
        self.pushButton_SendCtrl.clicked.connect(lambda: self.communicate(control=True))
        self.shortcut_send = QShortcut(QKeySequence("Return"), self)
        self.shortcut_send.activated.connect(self.communicate)
        self.shortcut_complete_command = QShortcut(QKeySequence("Tab"), self)
        self.shortcut_complete_command.activated.connect(self.complete_command)
        self.shortcut_send_ctrl = QShortcut(QKeySequence("Ctrl+C"), self)
        self.shortcut_send_ctrl.activated.connect(lambda: self.communicate(control=True))
        self.shortcut_multiline_mode = QShortcut(QKeySequence("Ctrl+Return"), self)
        self.shortcut_multiline_mode.activated.connect(self.enter_multiline_mode)
        self.lineEdit.textEdited.connect(self.finish_completion)

        # Saving the original function because super() doesn't work when we override functions like this
        self.lineEdit.keyPressEvent_original = self.lineEdit.keyPressEvent
        self.lineEdit.keyPressEvent = self.lineEdit_key_press_event
        self.reset_console_text()

    def communicate(self, control=False):
        self.current_history_index = -1
        self.input_history[-1] = ""
        if control:
            console_input = "/Ctrl+C"
        else:
            console_input = self.lineEdit.text()
            last_input = self.input_history[-2] if len(self.input_history) > 1 else ""
            if console_input != last_input and console_input != "":
                self.input_history[-1] = console_input
                self.input_history.append("")
        if console_input.lower() == "/clear":
            self.lineEdit.clear()
            self.reset_console_text()
            return
        self.lineEdit.clear()
        if console_input.strip().lower() in self.quit_commands:
            console_output = "Quitting current session will crash PINCE"
        else:
            if not control:
                if self.radioButton_CLI.isChecked():
                    console_output = GDB_Engine.send_command(console_input, cli_output=True)
                else:
                    console_output = GDB_Engine.send_command(console_input)
                if not console_output:
                    if GDB_Engine.inferior_status == type_defs.INFERIOR_STATUS.INFERIOR_RUNNING:
                        console_output = "Inferior is running"
            else:
                GDB_Engine.interrupt_inferior()
                console_output = ""
        self.textBrowser.append("-->" + console_input)
        if console_output:
            self.textBrowser.append(console_output)
        self.scroll_to_bottom()

    def reset_console_text(self):
        self.textBrowser.clear()
        self.textBrowser.append("Hotkeys:")
        self.textBrowser.append("----------------------------")
        self.textBrowser.append("Send=Enter                 |")
        self.textBrowser.append("Send ctrl+c=Ctrl+C         |")
        self.textBrowser.append("Multi-line mode=Ctrl+Enter |")
        self.textBrowser.append("Complete command=Tab       |")
        self.textBrowser.append("----------------------------")
        self.textBrowser.append("Commands:")
        self.textBrowser.append("----------------------------------------------------------")
        self.textBrowser.append("/clear: Clear the console                                |")
        self.textBrowser.append("phase-out: Detach from the current process               |")
        self.textBrowser.append("phase-in: Attach back to the previously detached process |")
        self.textBrowser.append(
            "---------------------------------------------------------------------------------------------------")
        self.textBrowser.append(
            "pince-init-so-file so_file_path: Initializes 'lib' variable                                       |")
        self.textBrowser.append(
            "pince-get-so-file-information: Get information about current lib                                  |")
        self.textBrowser.append(
            "pince-execute-from-so-file lib.func(params): Execute a function from lib                          |")
        self.textBrowser.append(
            "# Check https://github.com/korcankaraokcu/PINCE/wiki#extending-pince-with-so-files for an example |")
        self.textBrowser.append(
            "# CLI output mode doesn't work very well with .so extensions, use MI output mode instead          |")
        self.textBrowser.append(
            "---------------------------------------------------------------------------------------------------")
        self.textBrowser.append("You can change the output mode from bottom right")
        self.textBrowser.append("Note: Changing output mode only affects commands sent. Any other " +
                                "output coming from external sources(e.g async output) will be shown in MI format")

    def scroll_to_bottom(self):
        cursor = self.textBrowser.textCursor()
        cursor.movePosition(QTextCursor.End)
        self.textBrowser.setTextCursor(cursor)
        self.textBrowser.ensureCursorVisible()

    def enter_multiline_mode(self):
        multiline_dialog = TextEditDialogForm(text=self.lineEdit.text())
        if multiline_dialog.exec_():
            self.lineEdit.setText(multiline_dialog.get_values())
            self.communicate()

    def on_async_output(self, async_output):
        self.textBrowser.append(async_output)
        self.scroll_to_bottom()

    def scroll_backwards_history(self):
        try:
            new_text = self.input_history[self.current_history_index - 1]
        except IndexError:
            return
        self.input_history[self.current_history_index] = self.lineEdit.text()
        self.current_history_index -= 1
        self.lineEdit.setText(new_text)

    def scroll_forwards_history(self):
        if self.current_history_index == -1:
            return
        self.input_history[self.current_history_index] = self.lineEdit.text()
        self.current_history_index += 1
        self.lineEdit.setText(self.input_history[self.current_history_index])

    def lineEdit_key_press_event(self, event):
        actions = type_defs.KeyboardModifiersTupleDict([
            ((Qt.NoModifier, Qt.Key_Up), self.scroll_backwards_history),
            ((Qt.NoModifier, Qt.Key_Down), self.scroll_forwards_history)
        ])
        try:
            actions[event.modifiers(), event.key()]()
        except KeyError:
            self.lineEdit.keyPressEvent_original(event)

    def finish_completion(self):
        self.completion_model.setStringList([])

    def complete_command(self):
        if GDB_Engine.gdb_initialized and GDB_Engine.currentpid != -1 and self.lineEdit.text() and \
                GDB_Engine.inferior_status == type_defs.INFERIOR_STATUS.INFERIOR_STOPPED:
            self.completion_model.setStringList(GDB_Engine.complete_command(self.lineEdit.text()))
            self.completer.complete()
        else:
            self.finish_completion()

    def closeEvent(self, QCloseEvent):
        self.await_async_output_thread.stop()
        global instances
        instances.remove(self)


class AboutWidgetForm(QTabWidget, AboutWidget):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)
        GuiUtils.center(self)
        license_text = open("COPYING").read()
        authors_text = open("AUTHORS").read()
        thanks_text = open("THANKS").read()
        self.textBrowser_License.setPlainText(license_text)
        self.textBrowser_Contributors.append(
            "This is only a placeholder, this section may look different when the project finishes" +
            "\nIn fact, something like a demo-scene for here would look absolutely fabulous <:")
        self.textBrowser_Contributors.append("\n########")
        self.textBrowser_Contributors.append("#AUTHORS#")
        self.textBrowser_Contributors.append("########\n")
        self.textBrowser_Contributors.append(authors_text)
        self.textBrowser_Contributors.append("\n#######")
        self.textBrowser_Contributors.append("#THANKS#")
        self.textBrowser_Contributors.append("#######\n")
        self.textBrowser_Contributors.append(thanks_text)


class MemoryViewWindowForm(QMainWindow, MemoryViewWindow):
    process_stopped = pyqtSignal()
    process_running = pyqtSignal()

    def set_dynamic_debug_hotkeys(self):
        self.actionBreak.setText("Break[" + Hotkeys.break_hotkey.get_active_key() + "]")
        self.actionRun.setText("Run[" + Hotkeys.continue_hotkey.get_active_key() + "]")
        self.actionToggle_Attach.setText("Toggle Attach[" + Hotkeys.toggle_attach_hotkey.get_active_key() + "]")

    def set_debug_menu_shortcuts(self):
        self.shortcut_step = QShortcut(QKeySequence("F7"), self)
        self.shortcut_step.activated.connect(self.step_instruction)
        self.shortcut_step_over = QShortcut(QKeySequence("F8"), self)
        self.shortcut_step_over.activated.connect(self.step_over_instruction)
        self.shortcut_execute_till_return = QShortcut(QKeySequence("Shift+F8"), self)
        self.shortcut_execute_till_return.activated.connect(self.execute_till_return)
        self.shortcut_toggle_breakpoint = QShortcut(QKeySequence("F5"), self)
        self.shortcut_toggle_breakpoint.activated.connect(self.toggle_breakpoint)
        self.shortcut_set_address = QShortcut(QKeySequence("Shift+F4"), self)
        self.shortcut_set_address.activated.connect(self.set_address)

    def initialize_file_context_menu(self):
        self.actionLoad_Trace.triggered.connect(self.show_trace_window)

    def initialize_debug_context_menu(self):
        self.actionBreak.triggered.connect(GDB_Engine.interrupt_inferior)
        self.actionRun.triggered.connect(GDB_Engine.continue_inferior)
        self.actionToggle_Attach.triggered.connect(self.parent().toggle_attach_hotkey_pressed)
        self.actionStep.triggered.connect(self.step_instruction)
        self.actionStep_Over.triggered.connect(self.step_over_instruction)
        self.actionExecute_Till_Return.triggered.connect(self.execute_till_return)

        # Ignore the "checked" bool param as we don't make use of it
        self.actionToggle_Breakpoint.triggered.connect(lambda checked: self.toggle_breakpoint())
        self.actionSet_Address.triggered.connect(self.set_address)

    def initialize_view_context_menu(self):
        self.actionBookmarks.triggered.connect(self.actionBookmarks_triggered)
        self.actionStackTrace_Info.triggered.connect(self.actionStackTrace_Info_triggered)
        self.actionBreakpoints.triggered.connect(self.actionBreakpoints_triggered)
        self.actionFunctions.triggered.connect(self.actionFunctions_triggered)
        self.actionGDB_Log_File.triggered.connect(self.actionGDB_Log_File_triggered)
        self.actionMemory_Regions.triggered.connect(self.actionMemory_Regions_triggered)
        self.actionRestore_Instructions.triggered.connect(self.actionRestore_Instructions_triggered)
        self.actionReferenced_Strings.triggered.connect(self.actionReferenced_Strings_triggered)
        self.actionReferenced_Calls.triggered.connect(self.actionReferenced_Calls_triggered)

    def initialize_tools_context_menu(self):
        self.actionInject_so_file.triggered.connect(self.actionInject_so_file_triggered)
        self.actionCall_Function.triggered.connect(self.actionCall_Function_triggered)
        self.actionSearch_Opcode.triggered.connect(self.actionSearch_Opcode_triggered)
        self.actionDissect_Code.triggered.connect(self.actionDissect_Code_triggered)

    def initialize_help_context_menu(self):
        self.actionlibpince.triggered.connect(self.actionlibpince_triggered)

    def __init__(self, parent=None):
        super().__init__()
        self.setupUi(self)
        self.parent = lambda: parent
        GuiUtils.center(self)
        self.updating_memoryview = False
        self.process_stopped.connect(self.on_process_stop)
        self.process_running.connect(self.on_process_running)
        self.set_debug_menu_shortcuts()
        self.set_dynamic_debug_hotkeys()
        self.initialize_file_context_menu()
        self.initialize_view_context_menu()
        self.initialize_debug_context_menu()
        self.initialize_tools_context_menu()
        self.initialize_help_context_menu()
        self.initialize_disassemble_view()
        self.initialize_register_view()
        self.initialize_stack_view()
        self.initialize_hex_view()

        self.label_HexView_Information.contextMenuEvent = self.label_HexView_Information_context_menu_event

        self.splitter_Disassemble_Registers.setStretchFactor(0, 1)
        self.splitter_MainMiddle.setStretchFactor(1, 1)
        self.widget_StackView.resize(420, self.widget_StackView.height())  # blaze it
        self.widget_Registers.resize(330, self.widget_Registers.height())

    def initialize_register_view(self):
        self.pushButton_ShowFloatRegisters.clicked.connect(self.pushButton_ShowFloatRegisters_clicked)

    def initialize_stack_view(self):
        self.stackedWidget_StackScreens.setCurrentWidget(self.StackTrace)
        self.tableWidget_StackTrace.setColumnWidth(STACKTRACE_RETURN_ADDRESS_COL, 350)

        self.tableWidget_Stack.contextMenuEvent = self.tableWidget_Stack_context_menu_event
        self.tableWidget_StackTrace.contextMenuEvent = self.tableWidget_StackTrace_context_menu_event
        self.tableWidget_Stack.itemDoubleClicked.connect(self.tableWidget_Stack_double_click)
        self.tableWidget_StackTrace.itemDoubleClicked.connect(self.tableWidget_StackTrace_double_click)

        # Saving the original function because super() doesn't work when we override functions like this
        self.tableWidget_Stack.keyPressEvent_original = self.tableWidget_Stack.keyPressEvent
        self.tableWidget_Stack.keyPressEvent = self.tableWidget_Stack_key_press_event

        # Saving the original function because super() doesn't work when we override functions like this
        self.tableWidget_StackTrace.keyPressEvent_original = self.tableWidget_StackTrace.keyPressEvent
        self.tableWidget_StackTrace.keyPressEvent = self.tableWidget_StackTrace_key_press_event

    def initialize_disassemble_view(self):
        self.tableWidget_Disassemble.setColumnWidth(DISAS_ADDR_COL, 300)
        self.tableWidget_Disassemble.setColumnWidth(DISAS_BYTES_COL, 150)
        self.tableWidget_Disassemble.setColumnWidth(DISAS_OPCODES_COL, 400)

        self.disassemble_last_selected_address_int = 0
        self.disassemble_currently_displayed_address = "0"
        self.widget_Disassemble.wheelEvent = self.widget_Disassemble_wheel_event

        self.tableWidget_Disassemble.wheelEvent = QEvent.ignore
        self.verticalScrollBar_Disassemble.wheelEvent = QEvent.ignore

        GuiUtils.center_scroll_bar(self.verticalScrollBar_Disassemble)
        self.verticalScrollBar_Disassemble.mouseReleaseEvent = self.verticalScrollBar_Disassemble_mouse_release_event

        self.disassemble_scroll_bar_timer = QTimer()
        self.disassemble_scroll_bar_timer.setInterval(100)
        self.disassemble_scroll_bar_timer.timeout.connect(self.check_disassemble_scrollbar)
        self.disassemble_scroll_bar_timer.start()

        # Format: [address1, address2, ...]
        self.tableWidget_Disassemble.travel_history = []

        # Format: {address1:comment1,address2:comment2, ...}
        self.tableWidget_Disassemble.bookmarks = {}

        # Saving the original function because super() doesn't work when we override functions like this
        self.tableWidget_Disassemble.keyPressEvent_original = self.tableWidget_Disassemble.keyPressEvent
        self.tableWidget_Disassemble.keyPressEvent = self.tableWidget_Disassemble_key_press_event
        self.tableWidget_Disassemble.contextMenuEvent = self.tableWidget_Disassemble_context_menu_event

        self.tableWidget_Disassemble.itemDoubleClicked.connect(self.tableWidget_Disassemble_item_double_clicked)
        self.tableWidget_Disassemble.itemSelectionChanged.connect(self.tableWidget_Disassemble_item_selection_changed)

    def initialize_hex_view(self):
        self.cached_breakpoint_info = []
        self.hex_view_last_selected_address_int = 0
        self.hex_view_current_region = type_defs.tuple_region_info(0, 0, None)
        self.widget_HexView.wheelEvent = self.widget_HexView_wheel_event
        self.tableView_HexView_Hex.contextMenuEvent = self.widget_HexView_context_menu_event
        self.tableView_HexView_Ascii.contextMenuEvent = self.widget_HexView_context_menu_event
        self.tableView_HexView_Hex.doubleClicked.connect(self.exec_hex_view_edit_dialog)
        self.tableView_HexView_Ascii.doubleClicked.connect(self.exec_hex_view_edit_dialog)

        # Saving the original function because super() doesn't work when we override functions like this
        self.tableView_HexView_Hex.keyPressEvent_original = self.tableView_HexView_Hex.keyPressEvent
        self.tableView_HexView_Hex.keyPressEvent = self.widget_HexView_key_press_event
        self.tableView_HexView_Ascii.keyPressEvent = self.widget_HexView_key_press_event

        self.verticalScrollBar_HexView.wheelEvent = QEvent.ignore
        self.tableWidget_HexView_Address.wheelEvent = QEvent.ignore
        self.scrollArea_Hex.keyPressEvent = QEvent.ignore
        self.tableWidget_HexView_Address.setAutoScroll(False)
        self.tableWidget_HexView_Address.setStyleSheet("QTableWidget {background-color: transparent;}")
        self.tableWidget_HexView_Address.setSelectionMode(QAbstractItemView.NoSelection)

        self.hex_model = QHexModel(HEX_VIEW_ROW_COUNT, HEX_VIEW_COL_COUNT)
        self.ascii_model = QAsciiModel(HEX_VIEW_ROW_COUNT, HEX_VIEW_COL_COUNT)
        self.tableView_HexView_Hex.setModel(self.hex_model)
        self.tableView_HexView_Ascii.setModel(self.ascii_model)

        self.tableView_HexView_Hex.selectionModel().currentChanged.connect(self.on_hex_view_current_changed)
        self.tableView_HexView_Ascii.selectionModel().currentChanged.connect(self.on_ascii_view_current_changed)

        self.scrollArea_Hex.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scrollArea_Hex.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.tableWidget_HexView_Address.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.tableWidget_HexView_Address.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.tableWidget_HexView_Address.verticalHeader().setDefaultSectionSize(
            self.tableView_HexView_Hex.verticalHeader().defaultSectionSize())

        GuiUtils.center_scroll_bar(self.verticalScrollBar_HexView)
        self.hex_view_scroll_bar_timer = QTimer()
        self.hex_view_scroll_bar_timer.setInterval(100)
        self.hex_view_scroll_bar_timer.timeout.connect(self.check_hex_view_scrollbar)
        self.hex_view_scroll_bar_timer.start()
        self.verticalScrollBar_HexView.mouseReleaseEvent = self.verticalScrollBar_HexView_mouse_release_event

    def show_trace_window(self):
        trace_instructions_window = TraceInstructionsWindowForm(prompt_dialog=False)
        trace_instructions_window.showMaximized()

    def step_instruction(self):
        if self.updating_memoryview:
            return
        GDB_Engine.step_instruction()

    def step_over_instruction(self):
        if self.updating_memoryview:
            return
        GDB_Engine.step_over_instruction()

    def execute_till_return(self):
        if self.updating_memoryview:
            return
        GDB_Engine.execute_till_return()

    def set_address(self):
        selected_row = GuiUtils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = SysUtils.extract_address(current_address_text)
        GDB_Engine.set_convenience_variable("pc", current_address)
        self.refresh_disassemble_view()

    def nop_instruction(self):
        selected_row = GuiUtils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = SysUtils.extract_address(current_address_text)
        current_address_int = int(current_address, 16)
        array_of_bytes = self.tableWidget_Disassemble.item(selected_row, DISAS_BYTES_COL).text()
        GDB_Engine.nop_instruction(current_address_int, array_of_bytes)
        self.refresh_disassemble_view()

    @GDB_Engine.execute_with_temporary_interruption
    def toggle_breakpoint(self):
        selected_row = GuiUtils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = SysUtils.extract_address(current_address_text)
        current_address_int = int(current_address, 16)
        if GDB_Engine.check_address_in_breakpoints(current_address_int):
            GDB_Engine.delete_breakpoint(current_address)
        else:
            if not GDB_Engine.add_breakpoint(current_address):
                QMessageBox.information(self, "Error", "Failed to set breakpoint at address " + current_address)
        self.refresh_disassemble_view()

    def toggle_watchpoint(self, address, watchpoint_type=type_defs.WATCHPOINT_TYPE.BOTH):
        if GDB_Engine.check_address_in_breakpoints(address):
            GDB_Engine.delete_breakpoint(hex(address))
        else:
            watchpoint_dialog = InputDialogForm(item_list=[("Enter the watchpoint length in size of bytes", "")])
            if watchpoint_dialog.exec_():
                user_input = watchpoint_dialog.get_values()
                user_input_int = SysUtils.parse_string(user_input, type_defs.VALUE_INDEX.INDEX_INT32)
                if user_input_int is None:
                    QMessageBox.information(self, "Error", user_input + " can't be parsed as an integer")
                    return
                if user_input_int < 1:
                    QMessageBox.information(self, "Error", "Breakpoint length can't be lower than 1")
                    return
                if len(GDB_Engine.add_watchpoint(hex(address), user_input_int, watchpoint_type)) < 1:
                    QMessageBox.information(self, "Error", "Failed to set watchpoint at address " + hex(address))
        self.refresh_hex_view()

    def label_HexView_Information_context_menu_event(self, event):
        def copy_to_clipboard():
            app.clipboard().setText(self.label_HexView_Information.text())

        menu = QMenu()
        copy_label = menu.addAction("Copy to Clipboard")
        font_size = self.label_HexView_Information.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            copy_label: copy_to_clipboard
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def widget_HexView_context_menu_event(self, event):
        selected_address = self.tableView_HexView_Hex.get_selected_address()
        menu = QMenu()
        edit = menu.addAction("Edit")
        menu.addSeparator()
        go_to = menu.addAction("Go to expression[Ctrl+G]")
        disassemble = menu.addAction("Disassemble this address[Ctrl+D]")
        menu.addSeparator()
        add_address = menu.addAction("Add this address to address list[Ctrl+A]")
        menu.addSeparator()
        refresh = menu.addAction("Refresh[R]")
        menu.addSeparator()
        watchpoint_menu = menu.addMenu("Set Watchpoint")
        watchpoint_write = watchpoint_menu.addAction("Write Only")
        watchpoint_read = watchpoint_menu.addAction("Read Only")
        watchpoint_both = watchpoint_menu.addAction("Both")
        add_condition = menu.addAction("Add/Change condition for breakpoint")
        delete_breakpoint = menu.addAction("Delete Breakpoint")
        if not GDB_Engine.check_address_in_breakpoints(selected_address):
            GuiUtils.delete_menu_entries(menu, [add_condition, delete_breakpoint])
        else:
            GuiUtils.delete_menu_entries(menu, [watchpoint_menu.menuAction()])
        font_size = self.widget_HexView.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            edit: self.exec_hex_view_edit_dialog,
            go_to: self.exec_hex_view_go_to_dialog,
            disassemble: lambda: self.disassemble_expression(hex(selected_address), append_to_travel_history=True),
            add_address: self.exec_hex_view_add_address_dialog,
            refresh: self.refresh_hex_view,
            watchpoint_write: lambda: self.toggle_watchpoint(selected_address, type_defs.WATCHPOINT_TYPE.WRITE_ONLY),
            watchpoint_read: lambda: self.toggle_watchpoint(selected_address, type_defs.WATCHPOINT_TYPE.READ_ONLY),
            watchpoint_both: lambda: self.toggle_watchpoint(selected_address, type_defs.WATCHPOINT_TYPE.BOTH),
            add_condition: lambda: self.add_breakpoint_condition(selected_address),
            delete_breakpoint: lambda: self.toggle_watchpoint(selected_address)
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def exec_hex_view_edit_dialog(self):
        selected_address = self.tableView_HexView_Hex.get_selected_address()
        HexEditDialogForm(hex(selected_address)).exec_()
        self.refresh_hex_view()

    def exec_hex_view_go_to_dialog(self):
        current_address = hex(self.tableView_HexView_Hex.get_selected_address())
        go_to_dialog = InputDialogForm(item_list=[("Enter the expression", current_address)])
        if go_to_dialog.exec_():
            expression = go_to_dialog.get_values()
            dest_address = GDB_Engine.examine_expression(expression).address
            if not dest_address:
                QMessageBox.information(self, "Error", expression + " is invalid")
                return
            self.hex_dump_address(int(dest_address, 16))

    def exec_hex_view_add_address_dialog(self):
        selected_address = self.tableView_HexView_Hex.get_selected_address()
        manual_address_dialog = ManualAddressDialogForm(address=hex(selected_address),
                                                        index=type_defs.VALUE_INDEX.INDEX_AOB)
        if manual_address_dialog.exec_():
            desc, address_expr, value_index, length, zero_terminate = manual_address_dialog.get_values()
            self.parent().add_entry_to_addresstable(desc, address_expr, value_index, length, zero_terminate)

    def verticalScrollBar_HexView_mouse_release_event(self, event):
        GuiUtils.center_scroll_bar(self.verticalScrollBar_HexView)

    def verticalScrollBar_Disassemble_mouse_release_event(self, event):
        GuiUtils.center_scroll_bar(self.verticalScrollBar_Disassemble)

    def check_hex_view_scrollbar(self):
        if GDB_Engine.inferior_status != type_defs.INFERIOR_STATUS.INFERIOR_STOPPED:
            return
        maximum = self.verticalScrollBar_HexView.maximum()
        minimum = self.verticalScrollBar_HexView.minimum()
        midst = (maximum + minimum) / 2
        current_value = self.verticalScrollBar_HexView.value()
        if midst - 10 < current_value < midst + 10:
            return
        current_address = self.hex_model.current_address
        if current_value < midst:
            next_address = current_address - 0x40
        else:
            next_address = current_address + 0x40
        self.hex_dump_address(next_address)

    def check_disassemble_scrollbar(self):
        if GDB_Engine.inferior_status != type_defs.INFERIOR_STATUS.INFERIOR_STOPPED:
            return
        maximum = self.verticalScrollBar_Disassemble.maximum()
        minimum = self.verticalScrollBar_Disassemble.minimum()
        midst = (maximum + minimum) / 2
        current_value = self.verticalScrollBar_Disassemble.value()
        if midst - 10 < current_value < midst + 10:
            return
        if current_value < midst:
            self.tableWidget_Disassemble_scroll("previous", instructions_per_scroll)
        else:
            self.tableWidget_Disassemble_scroll("next", instructions_per_scroll)

    def on_hex_view_current_changed(self, QModelIndex_current):
        self.tableWidget_HexView_Address.setSelectionMode(QAbstractItemView.SingleSelection)
        self.hex_view_last_selected_address_int = self.tableView_HexView_Hex.get_selected_address()
        self.tableView_HexView_Ascii.selectionModel().setCurrentIndex(QModelIndex_current,
                                                                      QItemSelectionModel.ClearAndSelect)
        self.tableWidget_HexView_Address.selectRow(QModelIndex_current.row())
        self.tableWidget_HexView_Address.setSelectionMode(QAbstractItemView.NoSelection)

    def on_ascii_view_current_changed(self, QModelIndex_current):
        self.tableWidget_HexView_Address.setSelectionMode(QAbstractItemView.SingleSelection)
        self.tableView_HexView_Hex.selectionModel().setCurrentIndex(QModelIndex_current,
                                                                    QItemSelectionModel.ClearAndSelect)
        self.tableWidget_HexView_Address.selectRow(QModelIndex_current.row())
        self.tableWidget_HexView_Address.setSelectionMode(QAbstractItemView.NoSelection)

    # TODO: Consider merging HexView_Address, HexView_Hex and HexView_Ascii into one UI class
    # TODO: Move this function to that class if that happens
    # TODO: Also consider moving shared fields of HexView and HexModel to that class(such as HexModel.current_address)
    def hex_dump_address(self, int_address, offset=HEX_VIEW_ROW_COUNT * HEX_VIEW_COL_COUNT):
        int_address = SysUtils.modulo_address(int_address, GDB_Engine.inferior_arch)
        if not (self.hex_view_current_region.start <= int_address < self.hex_view_current_region.end):
            information = SysUtils.get_region_info(GDB_Engine.currentpid, int_address)
            if information:
                self.hex_view_current_region = information
                self.label_HexView_Information.setText("Protection:" + information.region.perms + " | Base:" +
                                                       hex(information.start) + "-" + hex(information.end))
            else:
                self.hex_view_current_region = type_defs.tuple_region_info(0, 0, None)
                self.label_HexView_Information.setText("This region is invalid")
        self.tableWidget_HexView_Address.setRowCount(0)
        self.tableWidget_HexView_Address.setRowCount(HEX_VIEW_ROW_COUNT * HEX_VIEW_COL_COUNT)
        for row, current_offset in enumerate(range(HEX_VIEW_ROW_COUNT)):
            row_address = hex(SysUtils.modulo_address(int_address + current_offset * 16, GDB_Engine.inferior_arch))
            self.tableWidget_HexView_Address.setItem(row, 0, QTableWidgetItem(row_address))
        tableWidget_HexView_column_size = self.tableWidget_HexView_Address.sizeHintForColumn(0) + 5
        self.tableWidget_HexView_Address.setMaximumWidth(tableWidget_HexView_column_size)
        self.tableWidget_HexView_Address.setMinimumWidth(tableWidget_HexView_column_size)
        self.tableWidget_HexView_Address.setColumnWidth(0, tableWidget_HexView_column_size)
        data_array = GDB_Engine.hex_dump(int_address, offset)

        # TODO: Use GDB_Engine.breakpoint_on_hit_dict instead of caching breakpoints if possible
        # Currently, breakpoint_on_hit_dict is not updated if the user manually adds a breakpoint via gdb
        # A possible fix would be to hook the breakpoint commands but it needs to be tested thoroughly
        if GDB_Engine.inferior_status == type_defs.INFERIOR_STATUS.INFERIOR_RUNNING:
            breakpoint_info = self.cached_breakpoint_info
        else:
            breakpoint_info = GDB_Engine.get_breakpoint_info()
            self.cached_breakpoint_info = breakpoint_info
        self.hex_model.refresh(int_address, offset, data_array, breakpoint_info)
        self.ascii_model.refresh(int_address, offset, data_array, breakpoint_info)
        for index in range(offset):
            current_address = SysUtils.modulo_address(self.hex_model.current_address + index, GDB_Engine.inferior_arch)
            if current_address == self.hex_view_last_selected_address_int:
                row_index = int(index / HEX_VIEW_COL_COUNT)
                model_index = QModelIndex(self.hex_model.index(row_index, index % HEX_VIEW_COL_COUNT))
                self.tableView_HexView_Hex.selectionModel().setCurrentIndex(model_index,
                                                                            QItemSelectionModel.ClearAndSelect)
                self.tableView_HexView_Ascii.selectionModel().setCurrentIndex(model_index,
                                                                              QItemSelectionModel.ClearAndSelect)
                self.tableWidget_HexView_Address.setSelectionMode(QAbstractItemView.SingleSelection)
                self.tableWidget_HexView_Address.selectRow(row_index)
                self.tableWidget_HexView_Address.setSelectionMode(QAbstractItemView.NoSelection)
                break
        else:
            self.tableView_HexView_Hex.clearSelection()
            self.tableView_HexView_Ascii.clearSelection()

    def refresh_hex_view(self):
        if self.tableWidget_HexView_Address.rowCount() == 0:
            entry_point = GDB_Engine.find_entry_point()
            if not entry_point:
                # **Shrugs**
                entry_point = "0x00400000"
            self.hex_dump_address(int(entry_point, 16))
            self.tableView_HexView_Hex.resize_to_contents()
            self.tableView_HexView_Ascii.resize_to_contents()
        else:
            self.hex_dump_address(self.hex_model.current_address)

    # offset can also be an address as hex str
    # returns True if the given expression is disassembled correctly, False if not
    def disassemble_expression(self, expression, offset="+200", append_to_travel_history=False):
        disas_data = GDB_Engine.disassemble(expression, offset)
        if not disas_data:
            QMessageBox.information(app.focusWidget(), "Error", "Cannot access memory at expression " + expression)
            return False
        program_counter = GDB_Engine.examine_expression("$pc").address
        program_counter_int = int(program_counter, 16)
        row_colour = {}
        breakpoint_info = GDB_Engine.get_breakpoint_info()

        # TODO: Change this nonsense when the huge refactorization happens
        current_first_address = SysUtils.extract_address(disas_data[0][0])  # address of first list entry
        try:
            previous_first_address = SysUtils.extract_address(
                self.tableWidget_Disassemble.item(0, DISAS_ADDR_COL).text())
        except AttributeError:
            previous_first_address = current_first_address

        self.tableWidget_Disassemble.setRowCount(0)
        self.tableWidget_Disassemble.setRowCount(len(disas_data))
        jmp_dict, call_dict = GDB_Engine.get_dissect_code_data(False, True, True)
        for row, item in enumerate(disas_data):
            comment = ""
            current_address = int(SysUtils.extract_address(item[0]), 16)
            current_address_str = hex(current_address)
            jmp_ref_exists = False
            call_ref_exists = False
            try:
                jmp_referrers = jmp_dict[current_address_str]
                jmp_ref_exists = True
            except KeyError:
                pass
            try:
                call_referrers = call_dict[current_address_str]
                call_ref_exists = True
            except KeyError:
                pass
            if jmp_ref_exists or call_ref_exists:
                tooltip_text = "Referenced by:\n"
                ref_count = 0
                if jmp_ref_exists:
                    for referrer in jmp_referrers:
                        if ref_count > 30:
                            break
                        tooltip_text += "\n" + hex(referrer) + "(" + jmp_referrers[referrer] + ")"
                        ref_count += 1
                if call_ref_exists:
                    for referrer in call_referrers:
                        if ref_count > 30:
                            break
                        tooltip_text += "\n" + hex(referrer) + "(call)"
                        ref_count += 1
                if ref_count > 30:
                    tooltip_text += "\n..."
                tooltip_text += "\n\nPress 'Ctrl+E' to see a detailed list of referrers"
                try:
                    row_colour[row].append(REF_COLOUR)
                except KeyError:
                    row_colour[row] = [REF_COLOUR]
                real_ref_count = 0
                if jmp_ref_exists:
                    real_ref_count += len(jmp_referrers)
                if call_ref_exists:
                    real_ref_count += len(call_referrers)
                item[0] = "{" + str(real_ref_count) + "}" + item[0]
            if current_address == program_counter_int:
                item[0] = ">>>" + item[0]
                try:
                    row_colour[row].append(PC_COLOUR)
                except KeyError:
                    row_colour[row] = [PC_COLOUR]
            for bookmark_item in self.tableWidget_Disassemble.bookmarks.keys():
                if current_address == bookmark_item:
                    try:
                        row_colour[row].append(BOOKMARK_COLOUR)
                    except KeyError:
                        row_colour[row] = [BOOKMARK_COLOUR]
                    item[0] = "(M)" + item[0]
                    comment = self.tableWidget_Disassemble.bookmarks[bookmark_item]
                    break
            for breakpoint in breakpoint_info:
                int_breakpoint_address = int(breakpoint.address, 16)
                if current_address == int_breakpoint_address:
                    try:
                        row_colour[row].append(BREAKPOINT_COLOUR)
                    except KeyError:
                        row_colour[row] = [BREAKPOINT_COLOUR]
                    breakpoint_mark = "(B"
                    if breakpoint.enabled == "n":
                        breakpoint_mark += "-disabled"
                    else:
                        if breakpoint.disp != "keep":
                            breakpoint_mark += "-" + breakpoint.disp
                        if breakpoint.enable_count:
                            breakpoint_mark += "-" + breakpoint.enable_count
                    breakpoint_mark += ")"
                    item[0] = breakpoint_mark + item[0]
                    break
            if current_address == self.disassemble_last_selected_address_int:
                self.tableWidget_Disassemble.selectRow(row)
            addr_item = QTableWidgetItem(item[0])
            bytes_item = QTableWidgetItem(item[1])
            opcodes_item = QTableWidgetItem(item[2])
            comment_item = QTableWidgetItem(comment)
            if jmp_ref_exists or call_ref_exists:
                addr_item.setToolTip(tooltip_text)
                bytes_item.setToolTip(tooltip_text)
                opcodes_item.setToolTip(tooltip_text)
                comment_item.setToolTip(tooltip_text)
            self.tableWidget_Disassemble.setItem(row, DISAS_ADDR_COL, addr_item)
            self.tableWidget_Disassemble.setItem(row, DISAS_BYTES_COL, bytes_item)
            self.tableWidget_Disassemble.setItem(row, DISAS_OPCODES_COL, opcodes_item)
            self.tableWidget_Disassemble.setItem(row, DISAS_COMMENT_COL, comment_item)
        jmp_dict.close()
        call_dict.close()
        self.handle_colours(row_colour)

        # We append the old record to travel history as last action because we wouldn't like to see unnecessary
        # addresses in travel history if any error occurs while displaying the next location
        if append_to_travel_history:
            self.tableWidget_Disassemble.travel_history.append(previous_first_address)
        self.disassemble_currently_displayed_address = current_first_address
        return True

    def refresh_disassemble_view(self):
        self.disassemble_expression(self.disassemble_currently_displayed_address)

    # Set colour of a row if a specific address is encountered(e.g $pc, a bookmarked address etc.)
    def handle_colours(self, row_colour):
        for row in row_colour:
            current_row = row_colour[row]
            if PC_COLOUR in current_row:
                if BREAKPOINT_COLOUR in current_row:
                    colour = Qt.green
                elif BOOKMARK_COLOUR in current_row:
                    colour = Qt.yellow
                else:
                    colour = PC_COLOUR
                self.set_row_colour(row, colour)
                continue
            if BREAKPOINT_COLOUR in current_row:
                if BOOKMARK_COLOUR in current_row:
                    colour = Qt.magenta
                else:
                    colour = BREAKPOINT_COLOUR
                self.set_row_colour(row, colour)
                continue
            if BOOKMARK_COLOUR in current_row:
                self.set_row_colour(row, BOOKMARK_COLOUR)
                continue
            if REF_COLOUR in current_row:
                self.set_row_colour(row, REF_COLOUR)

    # color parameter should be Qt.colour
    def set_row_colour(self, row, colour):
        for col in range(self.tableWidget_Disassemble.columnCount()):
            self.tableWidget_Disassemble.item(row, col).setData(Qt.BackgroundColorRole, QColor(colour))

    def on_process_stop(self):
        if GDB_Engine.stop_reason == type_defs.STOP_REASON.PAUSE:
            self.setWindowTitle("Memory Viewer - Paused")
            return
        self.updating_memoryview = True
        time0 = time()
        thread_info = GDB_Engine.get_current_thread_information()
        if thread_info:
            self.setWindowTitle("Memory Viewer - Currently debugging " + thread_info)
        else:
            self.setWindowTitle("Error while getting thread information: " +
                                "Please invoke 'info threads' command in GDB Console and open an issue with the output")
        self.disassemble_expression("$pc")
        self.update_registers()
        if self.stackedWidget_StackScreens.currentWidget() == self.StackTrace:
            self.update_stacktrace()
        elif self.stackedWidget_StackScreens.currentWidget() == self.Stack:
            self.update_stack()
        self.refresh_hex_view()
        if bring_disassemble_to_front:
            self.showMaximized()
            self.activateWindow()
        try:
            if self.stacktrace_info_widget.isVisible():
                self.stacktrace_info_widget.update_stacktrace()
        except AttributeError:
            pass
        try:
            if self.float_registers_widget.isVisible():
                self.float_registers_widget.update_registers()
        except AttributeError:
            pass
        app.processEvents()
        time1 = time()
        print("UPDATED MEMORYVIEW IN:" + str(time1 - time0))
        self.updating_memoryview = False

    def on_process_running(self):
        self.setWindowTitle("Memory Viewer - Running")

    def add_breakpoint_condition(self, int_address):
        condition_text = "Enter the expression for condition, for instance:\n\n" + \
                         "$eax==0x523\n" + \
                         "$rax>0 && ($rbp<0 || $rsp==0)\n" + \
                         "printf($r10)==3"
        breakpoint = GDB_Engine.check_address_in_breakpoints(int_address)
        if breakpoint:
            condition_line_edit_text = breakpoint.condition
        else:
            condition_line_edit_text = ""
        condition_dialog = InputDialogForm(item_list=[(condition_text, condition_line_edit_text, Qt.AlignLeft)])
        if condition_dialog.exec_():
            condition = condition_dialog.get_values()
            if not GDB_Engine.modify_breakpoint(hex(int_address), type_defs.BREAKPOINT_MODIFY.CONDITION,
                                                condition=condition):
                QMessageBox.information(app.focusWidget(), "Error", "Failed to set condition for address " +
                                        hex(int_address) + "\nCheck terminal for details")

    def update_registers(self):
        registers = GDB_Engine.read_registers()
        if GDB_Engine.inferior_arch == type_defs.INFERIOR_ARCH.ARCH_64:
            self.stackedWidget.setCurrentWidget(self.registers_64)
            self.RAX.set_value(registers["rax"])
            self.RBX.set_value(registers["rbx"])
            self.RCX.set_value(registers["rcx"])
            self.RDX.set_value(registers["rdx"])
            self.RSI.set_value(registers["rsi"])
            self.RDI.set_value(registers["rdi"])
            self.RBP.set_value(registers["rbp"])
            self.RSP.set_value(registers["rsp"])
            self.RIP.set_value(registers["rip"])
            self.R8.set_value(registers["r8"])
            self.R9.set_value(registers["r9"])
            self.R10.set_value(registers["r10"])
            self.R11.set_value(registers["r11"])
            self.R12.set_value(registers["r12"])
            self.R13.set_value(registers["r13"])
            self.R14.set_value(registers["r14"])
            self.R15.set_value(registers["r15"])
        elif GDB_Engine.inferior_arch == type_defs.INFERIOR_ARCH.ARCH_32:
            self.stackedWidget.setCurrentWidget(self.registers_32)
            self.EAX.set_value(registers["eax"])
            self.EBX.set_value(registers["ebx"])
            self.ECX.set_value(registers["ecx"])
            self.EDX.set_value(registers["edx"])
            self.ESI.set_value(registers["esi"])
            self.EDI.set_value(registers["edi"])
            self.EBP.set_value(registers["ebp"])
            self.ESP.set_value(registers["esp"])
            self.EIP.set_value(registers["eip"])
        self.CF.set_value(registers["cf"])
        self.PF.set_value(registers["pf"])
        self.AF.set_value(registers["af"])
        self.ZF.set_value(registers["zf"])
        self.SF.set_value(registers["sf"])
        self.TF.set_value(registers["tf"])
        self.IF.set_value(registers["if"])
        self.DF.set_value(registers["df"])
        self.OF.set_value(registers["of"])
        self.CS.set_value(registers["cs"])
        self.SS.set_value(registers["ss"])
        self.DS.set_value(registers["ds"])
        self.ES.set_value(registers["es"])
        self.GS.set_value(registers["gs"])
        self.FS.set_value(registers["fs"])

    def update_stacktrace(self):
        stack_trace_info = GDB_Engine.get_stacktrace_info()
        self.tableWidget_StackTrace.setRowCount(0)
        self.tableWidget_StackTrace.setRowCount(len(stack_trace_info))
        for row, item in enumerate(stack_trace_info):
            self.tableWidget_StackTrace.setItem(row, STACKTRACE_RETURN_ADDRESS_COL, QTableWidgetItem(item[0]))
            self.tableWidget_StackTrace.setItem(row, STACKTRACE_FRAME_ADDRESS_COL, QTableWidgetItem(item[1]))

    def set_stack_widget(self, stack_widget):
        self.stackedWidget_StackScreens.setCurrentWidget(stack_widget)
        if stack_widget == self.Stack:
            self.update_stack()
        elif stack_widget == self.StackTrace:
            self.update_stacktrace()

    def tableWidget_StackTrace_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_StackTrace.item(row, column).text())

        selected_row = GuiUtils.get_current_row(self.tableWidget_StackTrace)

        menu = QMenu()
        switch_to_stack = menu.addAction("Full Stack")
        menu.addSeparator()
        clipboard_menu = menu.addMenu("Copy to Clipboard")
        copy_return = clipboard_menu.addAction("Copy Return Address")
        copy_frame = clipboard_menu.addAction("Copy Frame Address")
        if selected_row == -1:
            GuiUtils.delete_menu_entries(menu, [clipboard_menu.menuAction()])
        refresh = menu.addAction("Refresh[R]")
        font_size = self.tableWidget_StackTrace.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            switch_to_stack: lambda: self.set_stack_widget(self.Stack),
            copy_return: lambda: copy_to_clipboard(selected_row, STACKTRACE_RETURN_ADDRESS_COL),
            copy_frame: lambda: copy_to_clipboard(selected_row, STACKTRACE_FRAME_ADDRESS_COL),
            refresh: self.update_stacktrace
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def update_stack(self):
        stack_info = GDB_Engine.get_stack_info()
        self.tableWidget_Stack.setRowCount(0)
        self.tableWidget_Stack.setRowCount(len(stack_info))
        for row, item in enumerate(stack_info):
            self.tableWidget_Stack.setItem(row, STACK_POINTER_ADDRESS_COL, QTableWidgetItem(item[0]))
            self.tableWidget_Stack.setItem(row, STACK_VALUE_COL, QTableWidgetItem(item[1]))
            self.tableWidget_Stack.setItem(row, STACK_POINTS_TO_COL, QTableWidgetItem(item[2]))
        self.tableWidget_Stack.resizeColumnToContents(STACK_POINTER_ADDRESS_COL)
        self.tableWidget_Stack.resizeColumnToContents(STACK_VALUE_COL)

    def tableWidget_Stack_key_press_event(self, event):
        selected_row = GuiUtils.get_current_row(self.tableWidget_Stack)
        current_address_text = self.tableWidget_Stack.item(selected_row, STACK_VALUE_COL).text()
        current_address = SysUtils.extract_address(current_address_text)

        actions = type_defs.KeyboardModifiersTupleDict([
            ((Qt.NoModifier, Qt.Key_R), self.update_stack),
            ((Qt.ControlModifier, Qt.Key_D),
             lambda: self.disassemble_expression(current_address, append_to_travel_history=True)),
            ((Qt.ControlModifier, Qt.Key_H), lambda: self.hex_dump_address(int(current_address, 16)))
        ])
        try:
            actions[event.modifiers(), event.key()]()
        except KeyError:
            pass
        self.tableWidget_Stack.keyPressEvent_original(event)

    def tableWidget_Stack_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_Stack.item(row, column).text())

        selected_row = GuiUtils.get_current_row(self.tableWidget_Stack)
        current_address_text = self.tableWidget_Stack.item(selected_row, STACK_VALUE_COL).text()
        current_address = SysUtils.extract_address(current_address_text)

        menu = QMenu()
        switch_to_stacktrace = menu.addAction("Stacktrace")
        menu.addSeparator()
        clipboard_menu = menu.addMenu("Copy to Clipboard")
        copy_address = clipboard_menu.addAction("Copy Address")
        copy_value = clipboard_menu.addAction("Copy Value")
        copy_points_to = clipboard_menu.addAction("Copy Points to")
        refresh = menu.addAction("Refresh[R]")
        menu.addSeparator()
        show_in_disas = menu.addAction("Disassemble 'value' pointer address[Ctrl+D]")
        show_in_hex = menu.addAction("Show 'value' pointer in HexView[Ctrl+H]")
        if selected_row == -1:
            GuiUtils.delete_menu_entries(menu, [clipboard_menu.menuAction(), show_in_disas, show_in_hex])
        font_size = self.tableWidget_Stack.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            switch_to_stacktrace: lambda: self.set_stack_widget(self.StackTrace),
            copy_address: lambda: copy_to_clipboard(selected_row, STACK_POINTER_ADDRESS_COL),
            copy_value: lambda: copy_to_clipboard(selected_row, STACK_VALUE_COL),
            copy_points_to: lambda: copy_to_clipboard(selected_row, STACK_POINTS_TO_COL),
            refresh: self.update_stack,
            show_in_disas: lambda: self.disassemble_expression(current_address, append_to_travel_history=True),
            show_in_hex: lambda: self.hex_dump_address(int(current_address, 16))
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def tableWidget_Stack_double_click(self, index):
        selected_row = GuiUtils.get_current_row(self.tableWidget_Stack)
        if index.column() == STACK_POINTER_ADDRESS_COL:
            current_address_text = self.tableWidget_Stack.item(selected_row, STACK_POINTER_ADDRESS_COL).text()
            current_address = SysUtils.extract_address(current_address_text)
            self.hex_dump_address(int(current_address, 16))
        else:
            points_to_text = self.tableWidget_Stack.item(selected_row, STACK_POINTS_TO_COL).text()
            current_address_text = self.tableWidget_Stack.item(selected_row, STACK_VALUE_COL).text()
            current_address = SysUtils.extract_address(current_address_text)
            if points_to_text.startswith("(str)"):
                self.hex_dump_address(int(current_address, 16))
            else:
                self.disassemble_expression(current_address, append_to_travel_history=True)

    def tableWidget_StackTrace_double_click(self, index):
        selected_row = GuiUtils.get_current_row(self.tableWidget_StackTrace)
        if index.column() == STACKTRACE_RETURN_ADDRESS_COL:
            current_address_text = self.tableWidget_StackTrace.item(selected_row, STACKTRACE_RETURN_ADDRESS_COL).text()
            current_address = SysUtils.extract_address(current_address_text)
            self.disassemble_expression(current_address, append_to_travel_history=True)
        if index.column() == STACKTRACE_FRAME_ADDRESS_COL:
            current_address_text = self.tableWidget_StackTrace.item(selected_row, STACKTRACE_FRAME_ADDRESS_COL).text()
            current_address = SysUtils.extract_address(current_address_text)
            self.hex_dump_address(int(current_address, 16))

    def tableWidget_StackTrace_key_press_event(self, event):
        actions = type_defs.KeyboardModifiersTupleDict([
            ((Qt.NoModifier, Qt.Key_R), self.update_stacktrace)
        ])
        try:
            actions[event.modifiers(), event.key()]()
        except KeyError:
            pass
        self.tableWidget_StackTrace.keyPressEvent_original(event)

    def widget_Disassemble_wheel_event(self, event):
        steps = event.angleDelta()
        if steps.y() > 0:
            self.tableWidget_Disassemble_scroll("previous", instructions_per_scroll)
        else:
            self.tableWidget_Disassemble_scroll("next", instructions_per_scroll)

    def disassemble_check_viewport(self, where, instruction_count):
        current_row = GuiUtils.get_current_row(self.tableWidget_Disassemble)
        current_row_height = self.tableWidget_Disassemble.rowViewportPosition(current_row)
        row_height = self.tableWidget_Disassemble.verticalHeader().defaultSectionSize()
        max_height = self.tableWidget_Disassemble.maximumViewportSize().height()
        # visible_height = max_height - row_height
        height = max_height - row_height * 3  # lets us see the next 2 instructions after the last visible row
        if current_row_height > max_height:
            last_visible_row = 0
            for row in range(self.tableWidget_Disassemble.rowCount()):
                if self.tableWidget_Disassemble.rowViewportPosition(row) > height:
                    break
                last_visible_row += 1
            current_address = SysUtils.extract_address(
                self.tableWidget_Disassemble.item(current_row, DISAS_ADDR_COL).text())
            new_address = GDB_Engine.find_address_of_closest_instruction(current_address, "previous", last_visible_row)
            self.disassemble_expression(new_address)
        elif (where == "previous" and current_row == 0) or (where == "next" and current_row_height > height):
            self.tableWidget_Disassemble_scroll(where, instruction_count)

    def tableWidget_Disassemble_scroll(self, where, instruction_count):
        current_address = self.disassemble_currently_displayed_address
        new_address = GDB_Engine.find_address_of_closest_instruction(current_address, where, instruction_count)
        self.disassemble_expression(new_address)

    def widget_HexView_wheel_event(self, event):
        steps = event.angleDelta()
        current_address = self.hex_model.current_address
        if steps.y() > 0:
            next_address = current_address - 0x40
        else:
            next_address = current_address + 0x40
        self.hex_dump_address(next_address)

    def widget_HexView_key_press_event(self, event):
        selected_address = self.tableView_HexView_Hex.get_selected_address()

        actions = type_defs.KeyboardModifiersTupleDict([
            ((Qt.ControlModifier, Qt.Key_G), self.exec_hex_view_go_to_dialog),
            ((Qt.ControlModifier, Qt.Key_D),
             lambda: self.disassemble_expression(hex(selected_address), append_to_travel_history=True)),
            ((Qt.ControlModifier, Qt.Key_A), self.exec_hex_view_add_address_dialog),
            ((Qt.NoModifier, Qt.Key_R), self.refresh_hex_view)
        ])
        try:
            actions[event.modifiers(), event.key()]()
        except KeyError:
            pass
        self.tableView_HexView_Hex.keyPressEvent_original(event)

    def tableWidget_Disassemble_key_press_event(self, event):
        selected_row = GuiUtils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = SysUtils.extract_address(current_address_text)
        current_address_int = int(current_address, 16)

        actions = type_defs.KeyboardModifiersTupleDict([
            ((Qt.NoModifier, Qt.Key_Space), lambda: self.follow_instruction(selected_row)),
            ((Qt.ControlModifier, Qt.Key_E), lambda: self.exec_examine_referrers_widget(current_address_text)),
            ((Qt.ControlModifier, Qt.Key_G), self.exec_disassemble_go_to_dialog),
            ((Qt.ControlModifier, Qt.Key_H), lambda: self.hex_dump_address(current_address_int)),
            ((Qt.ControlModifier, Qt.Key_B), lambda: self.bookmark_address(current_address_int)),
            ((Qt.ControlModifier, Qt.Key_D), self.dissect_current_region),
            ((Qt.ControlModifier, Qt.Key_T), self.exec_trace_instructions_dialog),
            ((Qt.NoModifier, Qt.Key_R), self.refresh_disassemble_view),
            ((Qt.NoModifier, Qt.Key_Down), lambda: self.disassemble_check_viewport("next", 1)),
            ((Qt.NoModifier, Qt.Key_Up), lambda: self.disassemble_check_viewport("previous", 1))
        ])
        try:
            actions[event.modifiers(), event.key()]()
        except KeyError:
            pass
        self.tableWidget_Disassemble.keyPressEvent_original(event)

    def tableWidget_Disassemble_item_double_clicked(self, index):
        if index.column() == DISAS_COMMENT_COL:
            selected_row = GuiUtils.get_current_row(self.tableWidget_Disassemble)
            current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
            current_address = int(SysUtils.extract_address(current_address_text), 16)
            if current_address in self.tableWidget_Disassemble.bookmarks:
                self.change_bookmark_comment(current_address)
            else:
                self.bookmark_address(current_address)

    def tableWidget_Disassemble_item_selection_changed(self):
        try:
            selected_row = GuiUtils.get_current_row(self.tableWidget_Disassemble)
            selected_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
            self.disassemble_last_selected_address_int = int(SysUtils.extract_address(selected_address_text), 16)
        except (TypeError, ValueError, AttributeError):
            pass

    # Search the item in given row for location changing instructions
    # Go to the address pointed by that instruction if it contains any
    def follow_instruction(self, selected_row):
        address = SysUtils.instruction_follow_address(
            self.tableWidget_Disassemble.item(selected_row, DISAS_OPCODES_COL).text())
        if address:
            self.disassemble_expression(address, append_to_travel_history=True)

    def disassemble_go_back(self):
        if self.tableWidget_Disassemble.travel_history:
            last_location = self.tableWidget_Disassemble.travel_history[-1]
            self.disassemble_expression(last_location)
            self.tableWidget_Disassemble.travel_history.pop()

    def tableWidget_Disassemble_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_Disassemble.item(row, column).text())

        def copy_all_columns(row):
            copied_string = ""
            for column in range(self.tableWidget_Disassemble.columnCount()):
                copied_string += self.tableWidget_Disassemble.item(row, column).text() + "\t"
            app.clipboard().setText(copied_string)

        selected_row = GuiUtils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = SysUtils.extract_address(current_address_text)
        current_address_int = int(current_address, 16)

        menu = QMenu()
        go_to = menu.addAction("Go to expression[Ctrl+G]")
        back = menu.addAction("Back")
        show_in_hex_view = menu.addAction("Show this address in HexView[Ctrl+H]")
        menu.addSeparator()
        followable = SysUtils.instruction_follow_address(
            self.tableWidget_Disassemble.item(selected_row, DISAS_OPCODES_COL).text())
        follow = menu.addAction("Follow[Space]")
        if not followable:
            GuiUtils.delete_menu_entries(menu, [follow])
        examine_referrers = menu.addAction("Examine Referrers[Ctrl+E]")
        if not GuiUtils.contains_reference_mark(current_address_text):
            GuiUtils.delete_menu_entries(menu, [examine_referrers])
        bookmark = menu.addAction("Bookmark this address[Ctrl+B]")
        delete_bookmark = menu.addAction("Delete this bookmark")
        change_comment = menu.addAction("Change comment")
        is_bookmarked = current_address_int in self.tableWidget_Disassemble.bookmarks
        if not is_bookmarked:
            GuiUtils.delete_menu_entries(menu, [delete_bookmark, change_comment])
        else:
            GuiUtils.delete_menu_entries(menu, [bookmark])
        go_to_bookmark = menu.addMenu("Go to bookmarked address")
        address_list = [hex(address) for address in self.tableWidget_Disassemble.bookmarks.keys()]
        bookmark_actions = [go_to_bookmark.addAction(item.all) for item in GDB_Engine.examine_expressions(address_list)]
        menu.addSeparator()
        toggle_breakpoint = menu.addAction("Toggle Breakpoint[F5]")
        add_condition = menu.addAction("Add/Change condition for breakpoint")
        if not GDB_Engine.check_address_in_breakpoints(current_address_int):
            GuiUtils.delete_menu_entries(menu, [add_condition])
        menu.addSeparator()
        nop_instruction = menu.addAction("Replace instruction with NOPs")
        if self.tableWidget_Disassemble.item(selected_row, DISAS_BYTES_COL).text() == '90':
            GuiUtils.delete_menu_entries(menu, [nop_instruction])
        menu.addSeparator()
        track_breakpoint = menu.addAction("Find out which addresses this instruction accesses")
        trace_instructions = menu.addAction("Break and trace instructions[Ctrl+T]")
        dissect_region = menu.addAction("Dissect this region[Ctrl+D]")
        menu.addSeparator()
        refresh = menu.addAction("Refresh[R]")
        menu.addSeparator()
        clipboard_menu = menu.addMenu("Copy to Clipboard")
        copy_address = clipboard_menu.addAction("Copy Address")
        copy_bytes = clipboard_menu.addAction("Copy Bytes")
        copy_opcode = clipboard_menu.addAction("Copy Opcode")
        copy_comment = clipboard_menu.addAction("Copy Comment")
        copy_all = clipboard_menu.addAction("Copy All")
        font_size = self.tableWidget_Disassemble.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            go_to: self.exec_disassemble_go_to_dialog,
            back: self.disassemble_go_back,
            show_in_hex_view: lambda: self.hex_dump_address(current_address_int),
            follow: lambda: self.follow_instruction(selected_row),
            examine_referrers: lambda: self.exec_examine_referrers_widget(current_address_text),
            bookmark: lambda: self.bookmark_address(current_address_int),
            delete_bookmark: lambda: self.delete_bookmark(current_address_int),
            change_comment: lambda: self.change_bookmark_comment(current_address_int),
            toggle_breakpoint: self.toggle_breakpoint,
            add_condition: lambda: self.add_breakpoint_condition(current_address_int),
            nop_instruction: self.nop_instruction,
            track_breakpoint: self.exec_track_breakpoint_dialog,
            trace_instructions: self.exec_trace_instructions_dialog,
            dissect_region: self.dissect_current_region,
            refresh: self.refresh_disassemble_view,
            copy_address: lambda: copy_to_clipboard(selected_row, DISAS_ADDR_COL),
            copy_bytes: lambda: copy_to_clipboard(selected_row, DISAS_BYTES_COL),
            copy_opcode: lambda: copy_to_clipboard(selected_row, DISAS_OPCODES_COL),
            copy_comment: lambda: copy_to_clipboard(selected_row, DISAS_COMMENT_COL),
            copy_all: lambda: copy_all_columns(selected_row)
        }
        try:
            actions[action]()
        except KeyError:
            pass
        if action in bookmark_actions:
            self.disassemble_expression(SysUtils.extract_address(action.text()), append_to_travel_history=True)

    def dissect_current_region(self):
        selected_row = GuiUtils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = SysUtils.extract_address(current_address_text)
        dissect_code_dialog = DissectCodeDialogForm(int_address=int(current_address, 16))
        dissect_code_dialog.scan_finished_signal.connect(dissect_code_dialog.accept)
        dissect_code_dialog.exec_()
        self.refresh_disassemble_view()

    def exec_examine_referrers_widget(self, current_address_text):
        if not GuiUtils.contains_reference_mark(current_address_text):
            return
        current_address = SysUtils.extract_address(current_address_text)
        current_address_int = int(current_address, 16)
        examine_referrers_widget = ExamineReferrersWidgetForm(current_address_int, self)
        examine_referrers_widget.show()

    def exec_trace_instructions_dialog(self):
        selected_row = GuiUtils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = SysUtils.extract_address(current_address_text)
        trace_instructions_window = TraceInstructionsWindowForm(current_address, parent=self)
        trace_instructions_window.showMaximized()

    def exec_track_breakpoint_dialog(self):
        selected_row = GuiUtils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = SysUtils.extract_address(current_address_text)
        current_instruction = self.tableWidget_Disassemble.item(selected_row, DISAS_OPCODES_COL).text()
        track_breakpoint_widget = TrackBreakpointWidgetForm(current_address, current_instruction, self)
        track_breakpoint_widget.show()

    def exec_disassemble_go_to_dialog(self):
        selected_row = GuiUtils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = SysUtils.extract_address(current_address_text)

        go_to_dialog = InputDialogForm(item_list=[("Enter the expression", current_address)])
        if go_to_dialog.exec_():
            traveled_exp = go_to_dialog.get_values()
            self.disassemble_expression(traveled_exp, append_to_travel_history=True)

    def bookmark_address(self, int_address):
        if int_address in self.tableWidget_Disassemble.bookmarks:
            QMessageBox.information(app.focusWidget(), "Error", "This address has already been bookmarked")
            return
        comment_dialog = InputDialogForm(item_list=[("Enter the comment for bookmarked address", "")])
        if comment_dialog.exec_():
            comment = comment_dialog.get_values()
        else:
            return
        self.tableWidget_Disassemble.bookmarks[int_address] = comment
        self.refresh_disassemble_view()

    def change_bookmark_comment(self, int_address):
        current_comment = self.tableWidget_Disassemble.bookmarks[int_address]
        comment_dialog = InputDialogForm(item_list=[("Enter the comment for bookmarked address", current_comment)])
        if comment_dialog.exec_():
            new_comment = comment_dialog.get_values()
        else:
            return
        self.tableWidget_Disassemble.bookmarks[int_address] = new_comment
        self.refresh_disassemble_view()

    def delete_bookmark(self, int_address):
        if int_address in self.tableWidget_Disassemble.bookmarks:
            del self.tableWidget_Disassemble.bookmarks[int_address]
            self.refresh_disassemble_view()

    def actionBookmarks_triggered(self):
        bookmark_widget = BookmarkWidgetForm(self)
        bookmark_widget.show()
        bookmark_widget.activateWindow()

    def actionStackTrace_Info_triggered(self):
        self.stacktrace_info_widget = StackTraceInfoWidgetForm()
        self.stacktrace_info_widget.show()

    def actionBreakpoints_triggered(self):
        breakpoint_widget = BreakpointInfoWidgetForm(self)
        breakpoint_widget.show()
        breakpoint_widget.activateWindow()

    def actionFunctions_triggered(self):
        functions_info_widget = FunctionsInfoWidgetForm(self)
        functions_info_widget.show()

    def actionGDB_Log_File_triggered(self):
        log_file_widget = LogFileWidgetForm()
        log_file_widget.showMaximized()

    def actionMemory_Regions_triggered(self):
        memory_regions_widget = MemoryRegionsWidgetForm(self)
        memory_regions_widget.show()

    def actionRestore_Instructions_triggered(self):
        restore_instructions_widget = RestoreInstructionsWidgetForm(self)
        restore_instructions_widget.show()

    def actionReferenced_Strings_triggered(self):
        ref_str_widget = ReferencedStringsWidgetForm(self)
        ref_str_widget.show()

    def actionReferenced_Calls_triggered(self):
        ref_call_widget = ReferencedCallsWidgetForm(self)
        ref_call_widget.show()

    def actionInject_so_file_triggered(self):
        file_path = QFileDialog.getOpenFileName(self, "Select the .so file", "", "Shared object library (*.so)")[0]
        if file_path:
            if GDB_Engine.inject_with_dlopen_call(file_path):
                QMessageBox.information(self, "Success!", "The file has been injected")
            else:
                QMessageBox.information(self, "Error", "Failed to inject the .so file")

    def actionCall_Function_triggered(self):
        label_text = "Enter the expression for the function that'll be called from the inferior" \
                     "\nYou can view functions list from View->Functions" \
                     "\n\nFor instance:" \
                     '\nCalling printf("1234") will yield something like this' \
                     '\n↓' \
                     '\n$28 = 4' \
                     '\n\n$28 is the assigned convenience variable' \
                     '\n4 is the result' \
                     '\nYou can use the assigned variable from the GDB Console'
        call_dialog = InputDialogForm(item_list=[(label_text, "")])
        if call_dialog.exec_():
            result = GDB_Engine.call_function_from_inferior(call_dialog.get_values())
            if result[0]:
                QMessageBox.information(self, "Success!", result[0] + " = " + result[1])
            else:
                QMessageBox.information(self, "Failed", "Failed to call the expression " + call_dialog.get_values())

    def actionSearch_Opcode_triggered(self):
        start_address = int(self.disassemble_currently_displayed_address, 16)
        end_address = start_address + 0x30000
        search_opcode_widget = SearchOpcodeWidgetForm(hex(start_address), hex(end_address), self)
        search_opcode_widget.show()

    def actionDissect_Code_triggered(self):
        self.dissect_code_dialog = DissectCodeDialogForm()
        self.dissect_code_dialog.exec_()
        self.refresh_disassemble_view()

    def actionlibpince_triggered(self):
        libpince_widget = LibpinceReferenceWidgetForm(is_window=True)
        libpince_widget.showMaximized()

    def pushButton_ShowFloatRegisters_clicked(self):
        self.float_registers_widget = FloatRegisterWidgetForm()
        self.float_registers_widget.show()
        GuiUtils.center_to_window(self.float_registers_widget, self.widget_Registers)


class BookmarkWidgetForm(QWidget, BookmarkWidget):
    def __init__(self, parent=None):
        super().__init__()
        self.setupUi(self)
        self.parent = lambda: parent
        global instances
        instances.append(self)
        GuiUtils.center(self)
        self.setWindowFlags(Qt.Window)
        self.listWidget.contextMenuEvent = self.listWidget_context_menu_event
        self.listWidget.currentRowChanged.connect(self.change_display)
        self.listWidget.itemDoubleClicked.connect(self.listWidget_item_double_clicked)
        self.shortcut_delete = QShortcut(QKeySequence("Del"), self)
        self.shortcut_delete.activated.connect(self.delete_record)
        self.shortcut_refresh = QShortcut(QKeySequence("R"), self)
        self.shortcut_refresh.activated.connect(self.refresh_table)
        self.refresh_table()

    def refresh_table(self):
        self.listWidget.clear()
        address_list = [hex(address) for address in self.parent().tableWidget_Disassemble.bookmarks.keys()]
        self.listWidget.addItems([item.all for item in GDB_Engine.examine_expressions(address_list)])

    def change_display(self, row):
        current_address = SysUtils.extract_address(self.listWidget.item(row).text())
        self.lineEdit_Info.setText(GDB_Engine.get_address_info(current_address))
        self.lineEdit_Comment.setText(self.parent().tableWidget_Disassemble.bookmarks[int(current_address, 16)])

    def listWidget_item_double_clicked(self, item):
        self.parent().disassemble_expression(SysUtils.extract_address(item.text()), append_to_travel_history=True)

    def exec_add_entry_dialog(self):
        entry_dialog = InputDialogForm(item_list=[("Enter the expression", "")])
        if entry_dialog.exec_():
            text = entry_dialog.get_values()
            address = GDB_Engine.examine_expression(text).address
            if not address:
                QMessageBox.information(self, "Error", "Invalid expression or address")
                return
            self.parent().bookmark_address(int(address, 16))
            self.refresh_table()

    def exec_change_comment_dialog(self, current_address):
        self.parent().change_bookmark_comment(current_address)
        self.refresh_table()

    def listWidget_context_menu_event(self, event):
        current_item = GuiUtils.get_current_item(self.listWidget)
        if current_item:
            current_address = int(SysUtils.extract_address(current_item.text()), 16)
            if current_address not in self.parent().tableWidget_Disassemble.bookmarks:
                QMessageBox.information(self, "Error", "Invalid entries detected, refreshing the page")
                self.refresh_table()
                return
        else:
            current_address = None
        menu = QMenu()
        add_entry = menu.addAction("Add new entry")
        change_comment = menu.addAction("Change comment of this record")
        delete_record = menu.addAction("Delete this record[Del]")
        if current_item is None:
            GuiUtils.delete_menu_entries(menu, [change_comment, delete_record])
        menu.addSeparator()
        refresh = menu.addAction("Refresh[R]")
        font_size = self.listWidget.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            add_entry: self.exec_add_entry_dialog,
            change_comment: lambda: self.exec_change_comment_dialog(current_address),
            delete_record: self.delete_record,
            refresh: self.refresh_table
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def delete_record(self):
        current_item = GuiUtils.get_current_item(self.listWidget)
        if not current_item:
            return
        current_address = int(SysUtils.extract_address(current_item.text()), 16)
        self.parent().delete_bookmark(current_address)
        self.refresh_table()

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)


class FloatRegisterWidgetForm(QTabWidget, FloatRegisterWidget):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.Window)
        self.update_registers()
        self.tableWidget_FPU.itemDoubleClicked.connect(self.set_register)
        self.tableWidget_XMM.itemDoubleClicked.connect(self.set_register)

    def update_registers(self):
        self.tableWidget_FPU.setRowCount(0)
        self.tableWidget_FPU.setRowCount(8)
        self.tableWidget_XMM.setRowCount(0)
        self.tableWidget_XMM.setRowCount(8)
        float_registers = GDB_Engine.read_float_registers()
        for row, (st, xmm) in enumerate(zip(type_defs.REGISTERS.FLOAT.ST, type_defs.REGISTERS.FLOAT.XMM)):
            self.tableWidget_FPU.setItem(row, FLOAT_REGISTERS_NAME_COL, QTableWidgetItem(st))
            self.tableWidget_FPU.setItem(row, FLOAT_REGISTERS_VALUE_COL, QTableWidgetItem(float_registers[st]))
            self.tableWidget_XMM.setItem(row, FLOAT_REGISTERS_NAME_COL, QTableWidgetItem(xmm))
            self.tableWidget_XMM.setItem(row, FLOAT_REGISTERS_VALUE_COL, QTableWidgetItem(float_registers[xmm]))

    def set_register(self, index):
        current_row = index.row()
        if self.currentWidget() == self.FPU:
            current_table_widget = self.tableWidget_FPU
        elif self.currentWidget() == self.XMM:
            current_table_widget = self.tableWidget_XMM
        else:
            raise Exception("Current widget is invalid: " + str(self.currentWidget().objectName()))
        current_register = current_table_widget.item(current_row, FLOAT_REGISTERS_NAME_COL).text()
        current_value = current_table_widget.item(current_row, FLOAT_REGISTERS_VALUE_COL).text()
        label_text = "Enter the new value of register " + current_register.upper()
        register_dialog = InputDialogForm(item_list=[(label_text, current_value)])
        if register_dialog.exec_():
            if self.currentWidget() == self.XMM:
                current_register += ".v4_float"
            GDB_Engine.set_convenience_variable(current_register, register_dialog.get_values())
            self.update_registers()


class StackTraceInfoWidgetForm(QWidget, StackTraceInfoWidget):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)
        GuiUtils.center(self)
        self.setWindowFlags(Qt.Window)
        self.listWidget_ReturnAddresses.currentRowChanged.connect(self.update_frame_info)
        self.update_stacktrace()

    def update_stacktrace(self):
        self.listWidget_ReturnAddresses.clear()
        return_addresses = GDB_Engine.get_stack_frame_return_addresses()
        self.listWidget_ReturnAddresses.addItems(return_addresses)

    def update_frame_info(self, index):
        frame_info = GDB_Engine.get_stack_frame_info(index)
        self.textBrowser_Info.setText(frame_info)


class RestoreInstructionsWidgetForm(QWidget, RestoreInstructionsWidget):
    def __init__(self, parent=None):
        super().__init__()
        self.setupUi(self)
        self.parent = lambda: parent
        global instances
        instances.append(self)
        GuiUtils.center(self)
        self.setWindowFlags(Qt.Window)

        # Saving the original function because super() doesn't work when we override functions like this
        self.tableWidget_Instructions.keyPressEvent_original = self.tableWidget_Instructions.keyPressEvent
        self.tableWidget_Instructions.keyPressEvent = self.tableWidget_Instructions_key_press_event
        self.tableWidget_Instructions.contextMenuEvent = self.tableWidget_Instructions_context_menu_event
        self.refresh()

    def tableWidget_Instructions_context_menu_event(self, event):
        selected_row = GuiUtils.get_current_row(self.tableWidget_Instructions)
        menu = QMenu()
        restore_instruction = menu.addAction("Restore this instruction")
        if selected_row != -1:
            selected_address_text = self.tableWidget_Instructions.item(selected_row, INSTR_ADDR_COL).text()
            selected_address = SysUtils.extract_address(selected_address_text)
            selected_address_int = int(selected_address, 16)
        else:
            GuiUtils.delete_menu_entries(menu, [restore_instruction])
            selected_address_int = None
        menu.addSeparator()
        refresh = menu.addAction("Refresh[R]")
        font_size = self.tableWidget_Instructions.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            restore_instruction: lambda: self.restore_instruction(selected_address_int),
            refresh: self.refresh
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def restore_instruction(self, selected_address_int):
        GDB_Engine.restore_instruction(selected_address_int)
        self.refresh_all()

    def refresh(self):
        noped_instructions = GDB_Engine.get_noped_instructions()
        self.tableWidget_Instructions.setRowCount(len(noped_instructions))
        for row, (address, aob) in enumerate(noped_instructions.items()):
            self.tableWidget_Instructions.setItem(row, INSTR_ADDR_COL, QTableWidgetItem(hex(address)))
            self.tableWidget_Instructions.setItem(row, INSTR_AOB_COL, QTableWidgetItem(aob))
        GuiUtils.resize_to_contents(self.tableWidget_Instructions)

    def refresh_all(self):
        self.parent().refresh_hex_view()
        self.parent().refresh_disassemble_view()
        self.refresh()

    def tableWidget_Instructions_key_press_event(self, event):
        actions = type_defs.KeyboardModifiersTupleDict([
            ((Qt.NoModifier, Qt.Key_R), self.refresh)
        ])
        try:
            actions[event.modifiers(), event.key()]()
        except KeyError:
            pass
        self.tableWidget_Instructions.keyPressEvent_original(event)

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)


class BreakpointInfoWidgetForm(QTabWidget, BreakpointInfoWidget):
    def __init__(self, parent=None):
        super().__init__()
        self.setupUi(self)
        self.parent = lambda: parent
        global instances
        instances.append(self)
        GuiUtils.center(self)
        self.setWindowFlags(Qt.Window)
        self.tableWidget_BreakpointInfo.contextMenuEvent = self.tableWidget_BreakpointInfo_context_menu_event

        # Saving the original function because super() doesn't work when we override functions like this
        self.tableWidget_BreakpointInfo.keyPressEvent_original = self.tableWidget_BreakpointInfo.keyPressEvent
        self.tableWidget_BreakpointInfo.keyPressEvent = self.tableWidget_BreakpointInfo_key_press_event
        self.tableWidget_BreakpointInfo.itemDoubleClicked.connect(self.tableWidget_BreakpointInfo_double_clicked)
        self.refresh()

    def refresh(self):
        break_info = GDB_Engine.get_breakpoint_info()
        self.tableWidget_BreakpointInfo.setRowCount(0)
        self.tableWidget_BreakpointInfo.setRowCount(len(break_info))
        for row, item in enumerate(break_info):
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_NUM_COL, QTableWidgetItem(item.number))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_TYPE_COL, QTableWidgetItem(item.breakpoint_type))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_DISP_COL, QTableWidgetItem(item.disp))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_ENABLED_COL, QTableWidgetItem(item.enabled))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_ADDR_COL, QTableWidgetItem(item.address))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_SIZE_COL, QTableWidgetItem(str(item.size)))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_ON_HIT_COL, QTableWidgetItem(item.on_hit))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_HIT_COUNT_COL, QTableWidgetItem(item.hit_count))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_COND_COL, QTableWidgetItem(item.condition))
        GuiUtils.resize_to_contents(self.tableWidget_BreakpointInfo)
        self.textBrowser_BreakpointInfo.clear()
        self.textBrowser_BreakpointInfo.setText(GDB_Engine.send_command("info break", cli_output=True))

    def delete_breakpoint(self, address):
        if address is not None:
            GDB_Engine.delete_breakpoint(address)
            self.refresh_all()

    def tableWidget_BreakpointInfo_key_press_event(self, event):
        selected_row = GuiUtils.get_current_row(self.tableWidget_BreakpointInfo)
        if selected_row != -1:
            current_address_text = self.tableWidget_BreakpointInfo.item(selected_row, BREAK_ADDR_COL).text()
            current_address = SysUtils.extract_address(current_address_text)
        else:
            current_address = None

        actions = type_defs.KeyboardModifiersTupleDict([
            ((Qt.NoModifier, Qt.Key_Delete), lambda: self.delete_breakpoint(current_address)),
            ((Qt.NoModifier, Qt.Key_R), self.refresh)
        ])
        try:
            actions[event.modifiers(), event.key()]()
        except KeyError:
            pass
        self.tableWidget_BreakpointInfo.keyPressEvent_original(event)

    def exec_enable_count_dialog(self, current_address):
        hit_count_dialog = InputDialogForm(item_list=[("Enter the hit count(1 or higher)", "")])
        if hit_count_dialog.exec_():
            count = hit_count_dialog.get_values()
            try:
                count = int(count)
            except ValueError:
                QMessageBox.information(self, "Error", "Hit count must be an integer")
            else:
                if count < 1:
                    QMessageBox.information(self, "Error", "Hit count can't be lower than 1")
                else:
                    GDB_Engine.modify_breakpoint(current_address, type_defs.BREAKPOINT_MODIFY.ENABLE_COUNT,
                                                 count=count)

    def tableWidget_BreakpointInfo_context_menu_event(self, event):
        selected_row = GuiUtils.get_current_row(self.tableWidget_BreakpointInfo)
        if selected_row != -1:
            current_address_text = self.tableWidget_BreakpointInfo.item(selected_row, BREAK_ADDR_COL).text()
            current_address = SysUtils.extract_address(current_address_text)
            current_address_int = int(current_address, 16)
        else:
            current_address = None
            current_address_int = None

        menu = QMenu()
        change_condition = menu.addAction("Change condition of this breakpoint")
        enable = menu.addAction("Enable this breakpoint")
        disable = menu.addAction("Disable this breakpoint")
        enable_once = menu.addAction("Disable this breakpoint after hit")
        enable_count = menu.addAction("Disable this breakpoint after X hits")
        enable_delete = menu.addAction("Delete this breakpoint after hit")
        menu.addSeparator()
        delete_breakpoint = menu.addAction("Delete this breakpoint[Del]")
        menu.addSeparator()
        if current_address is None:
            deletion_list = [change_condition, enable, disable, enable_once, enable_count, enable_delete,
                             delete_breakpoint]
            GuiUtils.delete_menu_entries(menu, deletion_list)
        refresh = menu.addAction("Refresh[R]")
        font_size = self.tableWidget_BreakpointInfo.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            change_condition: lambda: self.parent().add_breakpoint_condition(current_address_int),
            enable: lambda: GDB_Engine.modify_breakpoint(current_address, type_defs.BREAKPOINT_MODIFY.ENABLE),
            disable: lambda: GDB_Engine.modify_breakpoint(current_address, type_defs.BREAKPOINT_MODIFY.DISABLE),
            enable_once: lambda: GDB_Engine.modify_breakpoint(current_address, type_defs.BREAKPOINT_MODIFY.ENABLE_ONCE),
            enable_count: lambda: self.exec_enable_count_dialog(current_address),
            enable_delete: lambda: GDB_Engine.modify_breakpoint(current_address,
                                                                type_defs.BREAKPOINT_MODIFY.ENABLE_DELETE),
            delete_breakpoint: lambda: GDB_Engine.delete_breakpoint(current_address),
            refresh: self.refresh
        }
        try:
            actions[action]()
        except KeyError:
            pass
        if action != -1 and action is not None:
            self.refresh_all()

    def refresh_all(self):
        self.parent().refresh_hex_view()
        self.parent().refresh_disassemble_view()
        self.refresh()

    def tableWidget_BreakpointInfo_double_clicked(self, index):
        current_address_text = self.tableWidget_BreakpointInfo.item(index.row(), BREAK_ADDR_COL).text()
        current_address = SysUtils.extract_address(current_address_text)
        current_address_int = int(current_address, 16)

        if index.column() == BREAK_COND_COL:
            self.parent().add_breakpoint_condition(current_address_int)
            self.refresh_all()
        else:
            current_breakpoint_type = self.tableWidget_BreakpointInfo.item(index.row(), BREAK_TYPE_COL).text()
            if "breakpoint" in current_breakpoint_type:
                self.parent().disassemble_expression(current_address, append_to_travel_history=True)
            else:
                self.parent().hex_dump_address(current_address_int)

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)


class TrackWatchpointWidgetForm(QWidget, TrackWatchpointWidget):
    def __init__(self, address, length, watchpoint_type, parent=None):
        super().__init__()
        self.setupUi(self)
        self.parent = lambda: parent
        global instances
        instances.append(self)
        GuiUtils.center(self)
        self.setWindowFlags(Qt.Window)
        if watchpoint_type == type_defs.WATCHPOINT_TYPE.WRITE_ONLY:
            string = "writing to"
        elif watchpoint_type == type_defs.WATCHPOINT_TYPE.READ_ONLY:
            string = "reading from"
        elif watchpoint_type == type_defs.WATCHPOINT_TYPE.BOTH:
            string = "accessing to"
        else:
            raise Exception("Watchpoint type is invalid: " + str(watchpoint_type))
        self.setWindowTitle("Opcodes " + string + " the address " + address)
        breakpoints = GDB_Engine.track_watchpoint(address, length, watchpoint_type)
        if not breakpoints:
            QMessageBox.information(self, "Error", "Unable to track watchpoint at expression " + address)
            return
        self.address = address
        self.breakpoints = breakpoints
        self.info = {}
        self.last_selected_row = 0
        self.stopped = False
        self.pushButton_Stop.clicked.connect(self.pushButton_Stop_clicked)
        self.pushButton_Refresh.clicked.connect(self.update_list)
        self.tableWidget_Opcodes.itemDoubleClicked.connect(self.tableWidget_Opcodes_item_double_clicked)
        self.tableWidget_Opcodes.selectionModel().currentChanged.connect(self.tableWidget_Opcodes_current_changed)
        self.update_timer = QTimer()
        self.update_timer.setInterval(100)
        self.update_timer.timeout.connect(self.update_list)
        self.update_timer.start()

    def update_list(self):
        info = GDB_Engine.get_track_watchpoint_info(self.breakpoints)
        if not info or self.info == info:
            return
        self.info = info
        self.tableWidget_Opcodes.setRowCount(0)
        self.tableWidget_Opcodes.setRowCount(len(info))
        for row, key in enumerate(info):
            self.tableWidget_Opcodes.setItem(row, TRACK_WATCHPOINT_COUNT_COL, QTableWidgetItem(str(info[key][0])))
            self.tableWidget_Opcodes.setItem(row, TRACK_WATCHPOINT_ADDR_COL, QTableWidgetItem(info[key][1]))
        GuiUtils.resize_to_contents(self.tableWidget_Opcodes)
        self.tableWidget_Opcodes.selectRow(self.last_selected_row)

    def tableWidget_Opcodes_current_changed(self, QModelIndex_current):
        current_row = QModelIndex_current.row()
        if current_row >= 0:
            self.last_selected_row = current_row

        info = self.info
        key_list = list(info)
        key = key_list[self.last_selected_row]
        self.textBrowser_Info.clear()
        for item in info[key][2]:
            self.textBrowser_Info.append(item + "=" + info[key][2][item])
        self.textBrowser_Info.append(" ")
        for item in info[key][3]:
            self.textBrowser_Info.append(item + "=" + info[key][3][item])
        self.textBrowser_Info.verticalScrollBar().setValue(self.textBrowser_Info.verticalScrollBar().minimum())
        self.textBrowser_Disassemble.setPlainText(info[key][4])

    def tableWidget_Opcodes_item_double_clicked(self, index):
        self.parent().memory_view_window.disassemble_expression(
            self.tableWidget_Opcodes.item(index.row(), TRACK_WATCHPOINT_ADDR_COL).text(),
            append_to_travel_history=True)
        self.parent().memory_view_window.show()
        self.parent().memory_view_window.activateWindow()

    def pushButton_Stop_clicked(self):
        if self.stopped:
            self.close()
        if not GDB_Engine.execute_func_temporary_interruption(GDB_Engine.delete_breakpoint, self.address):
            QMessageBox.information(self, "Error", "Unable to delete watchpoint at expression " + self.address)
            return
        self.stopped = True
        self.pushButton_Stop.setText("Close")

    @GDB_Engine.execute_with_temporary_interruption
    def closeEvent(self, QCloseEvent):
        global instances
        self.update_timer.stop()
        GDB_Engine.delete_breakpoint(self.address)
        self.deleteLater()
        instances.remove(self)


class TrackBreakpointWidgetForm(QWidget, TrackBreakpointWidget):
    def __init__(self, address, instruction, parent=None):
        super().__init__()
        self.setupUi(self)
        self.parent = lambda: parent
        global instances
        instances.append(self)
        self.setWindowFlags(Qt.Window)
        GuiUtils.center_to_parent(self)
        self.setWindowTitle("Addresses accessed by instruction '" + instruction + "'")
        label_text = "Enter the register expression(s) you want to track" \
                     "\nRegister names should start with a '$' sign" \
                     "\nEach expression should be separated with a comma" \
                     "\n\nFor instance:" \
                     "\nLet's say the instruction is 'mov [rax+rbx],30'" \
                     "\nThen you should enter '$rax+$rbx'(without quotes)" \
                     "\nSo PINCE can track address [rax+rbx]" \
                     "\n\nAnother example:" \
                     "\nIf you enter '$rax,$rbx*$rcx+4,$rbp'(without quotes)" \
                     "\nPINCE will track down addresses [rax],[rbx*rcx+4] and [rbp]"
        register_expression_dialog = InputDialogForm(item_list=[(label_text, "")])
        if register_expression_dialog.exec_():
            register_expressions = register_expression_dialog.get_values()
        else:
            return
        breakpoint = GDB_Engine.track_breakpoint(address, register_expressions)
        if not breakpoint:
            QMessageBox.information(self, "Error", "Unable to track breakpoint at expression " + address)
            return
        self.label_Info.setText("Pause the process to refresh 'Value' part of the table(" +
                                Hotkeys.pause_hotkey.get_active_key() + " or " + Hotkeys.break_hotkey.get_active_key() + ")")
        self.address = address
        self.breakpoint = breakpoint
        self.info = {}
        self.last_selected_row = 0
        self.stopped = False
        GuiUtils.fill_value_combobox(self.comboBox_ValueType)
        self.pushButton_Stop.clicked.connect(self.pushButton_Stop_clicked)
        self.tableWidget_TrackInfo.itemDoubleClicked.connect(self.tableWidget_TrackInfo_item_double_clicked)
        self.tableWidget_TrackInfo.selectionModel().currentChanged.connect(self.tableWidget_TrackInfo_current_changed)
        self.comboBox_ValueType.currentIndexChanged.connect(self.update_values)
        self.comboBox_ValueType.setToolTip("Allan please add details")  # planned easter egg
        self.update_timer = QTimer()
        self.update_timer.setInterval(100)
        self.update_timer.timeout.connect(self.update_list)
        self.update_timer.start()
        self.parent().process_stopped.connect(self.update_values)
        self.parent().refresh_disassemble_view()

    def update_list(self):
        info = GDB_Engine.get_track_breakpoint_info(self.breakpoint)
        if not info:
            return
        if info == self.info:
            return
        self.info = info
        self.tableWidget_TrackInfo.setRowCount(0)
        for register_expression in info:
            for row, address in enumerate(info[register_expression]):
                self.tableWidget_TrackInfo.setRowCount(self.tableWidget_TrackInfo.rowCount() + 1)
                self.tableWidget_TrackInfo.setItem(row, TRACK_BREAKPOINT_COUNT_COL,
                                                   QTableWidgetItem(str(info[register_expression][address])))
                self.tableWidget_TrackInfo.setItem(row, TRACK_BREAKPOINT_ADDR_COL, QTableWidgetItem(address))
                self.tableWidget_TrackInfo.setItem(row, TRACK_BREAKPOINT_SOURCE_COL,
                                                   QTableWidgetItem("[" + register_expression + "]"))
        GuiUtils.resize_to_contents(self.tableWidget_TrackInfo)
        self.tableWidget_TrackInfo.selectRow(self.last_selected_row)

    def update_values(self):
        mem_handle = GDB_Engine.memory_handle()
        value_type = self.comboBox_ValueType.currentIndex()
        for row in range(self.tableWidget_TrackInfo.rowCount()):
            address = self.tableWidget_TrackInfo.item(row, TRACK_BREAKPOINT_ADDR_COL).text()
            value = GDB_Engine.read_memory(address, value_type, 10, mem_handle=mem_handle)
            value = "" if value is None else str(value)
            self.tableWidget_TrackInfo.setItem(row, TRACK_BREAKPOINT_VALUE_COL, QTableWidgetItem(value))
        GuiUtils.resize_to_contents(self.tableWidget_TrackInfo)
        self.tableWidget_TrackInfo.selectRow(self.last_selected_row)

    def tableWidget_TrackInfo_current_changed(self, QModelIndex_current):
        current_row = QModelIndex_current.row()
        if current_row >= 0:
            self.last_selected_row = current_row

    def tableWidget_TrackInfo_item_double_clicked(self, index):
        address = self.tableWidget_TrackInfo.item(index.row(), TRACK_BREAKPOINT_ADDR_COL).text()
        self.parent().parent().add_entry_to_addresstable("Accessed by " + self.address, address,
                                                         self.comboBox_ValueType.currentData(Qt.UserRole), 10, True)

    def pushButton_Stop_clicked(self):
        if self.stopped:
            self.close()
        if not GDB_Engine.delete_breakpoint(self.address):
            QMessageBox.information(self, "Error", "Unable to delete breakpoint at expression " + self.address)
            return
        self.stopped = True
        self.pushButton_Stop.setText("Close")
        self.parent().refresh_disassemble_view()

    def closeEvent(self, QCloseEvent):
        if GDB_Engine.inferior_status == type_defs.INFERIOR_STATUS.INFERIOR_RUNNING:
            QCloseEvent.ignore()
            raise type_defs.InferiorRunningException
        try:
            self.update_timer.stop()
        except AttributeError:
            pass
        global instances
        instances.remove(self)
        GDB_Engine.execute_func_temporary_interruption(GDB_Engine.delete_breakpoint, self.address)
        self.parent().refresh_disassemble_view()


class TraceInstructionsPromptDialogForm(QDialog, TraceInstructionsPromptDialog):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)

    def get_values(self):
        max_trace_count = int(self.lineEdit_MaxTraceCount.text())
        trigger_condition = self.lineEdit_TriggerCondition.text()
        stop_condition = self.lineEdit_StopCondition.text()
        if self.checkBox_StepOver.isChecked():
            step_mode = type_defs.STEP_MODE.STEP_OVER
        else:
            step_mode = type_defs.STEP_MODE.SINGLE_STEP
        stop_after_trace = self.checkBox_StopAfterTrace.isChecked()
        collect_general_registers = self.checkBox_GeneralRegisters.isChecked()
        collect_flag_registers = self.checkBox_FlagRegisters.isChecked()
        collect_segment_registers = self.checkBox_SegmentRegisters.isChecked()
        collect_float_registers = self.checkBox_FloatRegisters.isChecked()
        return (max_trace_count, trigger_condition, stop_condition, step_mode, stop_after_trace,
                collect_general_registers, collect_flag_registers, collect_segment_registers, collect_float_registers)

    def accept(self):
        if int(self.lineEdit_MaxTraceCount.text()) >= 1:
            super(TraceInstructionsPromptDialogForm, self).accept()
        else:
            QMessageBox.information(self, "Error", "Max trace count must be greater than or equal to 1")


class TraceInstructionsWaitWidgetForm(QWidget, TraceInstructionsWaitWidget):
    widget_closed = pyqtSignal()

    def __init__(self, address, breakpoint, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)
        self.setWindowFlags(self.windowFlags() | Qt.Window | Qt.FramelessWindowHint)
        GuiUtils.center(self)
        self.address = address
        self.breakpoint = breakpoint
        media_directory = SysUtils.get_media_directory()
        self.movie = QMovie(media_directory + "/TraceInstructionsWaitWidget/ajax-loader.gif", QByteArray())
        self.label_Animated.setMovie(self.movie)
        self.movie.setScaledSize(QSize(215, 100))
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.movie.setCacheMode(QMovie.CacheAll)
        self.movie.setSpeed(100)
        self.movie.start()
        self.pushButton_Cancel.clicked.connect(self.close)
        self.status_timer = QTimer()
        self.status_timer.setInterval(30)
        self.status_timer.timeout.connect(self.change_status)
        self.status_timer.start()

    def change_status(self):
        status_info = GDB_Engine.get_trace_instructions_status(self.breakpoint)
        if status_info[0] == type_defs.TRACE_STATUS.STATUS_FINISHED or \
                status_info[0] == type_defs.TRACE_STATUS.STATUS_PROCESSING:
            self.close()
            return
        self.label_StatusText.setText(status_info[1])
        app.processEvents()

    def closeEvent(self, QCloseEvent):
        self.status_timer.stop()
        self.label_StatusText.setText("Processing the collected data")
        self.pushButton_Cancel.setVisible(False)
        self.adjustSize()
        app.processEvents()
        status_info = GDB_Engine.get_trace_instructions_status(self.breakpoint)
        if status_info[0] == type_defs.TRACE_STATUS.STATUS_TRACING or \
                status_info[0] == type_defs.TRACE_STATUS.STATUS_PROCESSING:
            GDB_Engine.cancel_trace_instructions(self.breakpoint)
            while GDB_Engine.get_trace_instructions_status(self.breakpoint)[0] \
                    != type_defs.TRACE_STATUS.STATUS_FINISHED:
                sleep(0.1)
                app.processEvents()
        try:
            GDB_Engine.delete_breakpoint(self.address)
        except type_defs.InferiorRunningException:
            pass
        self.widget_closed.emit()


class TraceInstructionsWindowForm(QMainWindow, TraceInstructionsWindow):
    def __init__(self, address="", prompt_dialog=True, parent=None):
        super().__init__()
        self.setupUi(self)
        self.parent = lambda: parent
        global instances
        instances.append(self)
        GuiUtils.center(self)
        self.address = address
        self.trace_data = None
        self.treeWidget_InstructionInfo.currentItemChanged.connect(self.display_collected_data)
        self.treeWidget_InstructionInfo.itemDoubleClicked.connect(self.treeWidget_InstructionInfo_item_double_clicked)
        self.treeWidget_InstructionInfo.contextMenuEvent = self.treeWidget_InstructionInfo_context_menu_event
        self.actionOpen.triggered.connect(self.load_file)
        self.actionSave.triggered.connect(self.save_file)
        self.splitter.setStretchFactor(0, 1)
        if not prompt_dialog:
            return
        prompt_dialog = TraceInstructionsPromptDialogForm()
        if prompt_dialog.exec_():
            params = (address,) + prompt_dialog.get_values()
            breakpoint = GDB_Engine.trace_instructions(*params)
            if not breakpoint:
                QMessageBox.information(self, "Error", "Failed to set breakpoint at address " + address)
                return
            self.breakpoint = breakpoint
            self.wait_dialog = TraceInstructionsWaitWidgetForm(address, breakpoint, self)
            self.wait_dialog.widget_closed.connect(self.show_trace_info)
            self.wait_dialog.show()

    def display_collected_data(self, QTreeWidgetItem_current):
        self.textBrowser_RegisterInfo.clear()
        current_dict = QTreeWidgetItem_current.trace_data[1]
        if current_dict:
            for key in current_dict:
                self.textBrowser_RegisterInfo.append(str(key) + " = " + str(current_dict[key]))
            self.textBrowser_RegisterInfo.verticalScrollBar().setValue(
                self.textBrowser_RegisterInfo.verticalScrollBar().minimum())

    def show_trace_info(self, trace_data=None):
        self.treeWidget_InstructionInfo.setStyleSheet("QTreeWidget::item{ height: 16px; }")
        parent = QTreeWidgetItem(self.treeWidget_InstructionInfo)
        self.treeWidget_InstructionInfo.setRootIndex(self.treeWidget_InstructionInfo.indexFromItem(parent))
        if trace_data:
            trace_tree, current_root_index = trace_data
        else:
            trace_data = GDB_Engine.get_trace_instructions_info(self.breakpoint)
            if trace_data:
                trace_tree, current_root_index = trace_data
            else:
                return
        self.trace_data = copy.deepcopy(trace_data)
        while current_root_index is not None:
            try:
                current_index = trace_tree[current_root_index][2][0]  # Get the first child
                current_item = trace_tree[current_index][0]
                del trace_tree[current_root_index][2][0]  # Delete it
            except IndexError:  # We've depleted the children
                current_root_index = trace_tree[current_root_index][1]  # traverse upwards
                parent = parent.parent()
                continue
            child = QTreeWidgetItem(parent)
            child.trace_data = current_item
            child.setText(0, current_item[0])
            if trace_tree[current_index][2]:  # If current item has children, traverse them
                current_root_index = current_index  # traverse downwards
                parent = child
        self.treeWidget_InstructionInfo.expandAll()

    def save_file(self):
        trace_file_path = SysUtils.get_user_path(type_defs.USER_PATHS.TRACE_INSTRUCTIONS_PATH)
        file_path = QFileDialog.getSaveFileName(self, "Save trace file", trace_file_path,
                                                "Trace File (*.trace);;All Files (*)")[0]
        if file_path:
            file_path = SysUtils.append_file_extension(file_path, "trace")
            if not SysUtils.save_file(self.trace_data, file_path):
                QMessageBox.information(self, "Error", "Cannot save to file")

    def load_file(self):
        trace_file_path = SysUtils.get_user_path(type_defs.USER_PATHS.TRACE_INSTRUCTIONS_PATH)
        file_path = QFileDialog.getOpenFileName(self, "Open trace file", trace_file_path,
                                                "Trace File (*.trace);;All Files (*)")[0]
        if file_path:
            content = SysUtils.load_file(file_path)
            if content is None:
                QMessageBox.information(self, "Error", "File " + file_path + " does not exist, " +
                                        "is inaccessible or contains invalid content. Terminating...")
                return
            self.treeWidget_InstructionInfo.clear()
            self.show_trace_info(content)

    def treeWidget_InstructionInfo_context_menu_event(self, event):
        menu = QMenu()
        expand_all = menu.addAction("Expand All")
        collapse_all = menu.addAction("Collapse All")
        font_size = self.treeWidget_InstructionInfo.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            expand_all: self.treeWidget_InstructionInfo.expandAll,
            collapse_all: self.treeWidget_InstructionInfo.collapseAll
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def treeWidget_InstructionInfo_item_double_clicked(self, index):
        current_item = GuiUtils.get_current_item(self.treeWidget_InstructionInfo)
        if not current_item:
            return
        address = SysUtils.extract_address(current_item.trace_data[0])
        if address:
            self.parent().disassemble_expression(address, append_to_travel_history=True)

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)


class FunctionsInfoWidgetForm(QWidget, FunctionsInfoWidget):
    def __init__(self, parent=None):
        super().__init__()
        self.setupUi(self)
        self.parent = lambda: parent
        global instances
        instances.append(self)
        GuiUtils.center(self)
        self.setWindowFlags(Qt.Window)
        self.textBrowser_AddressInfo.setFixedHeight(100)
        self.pushButton_Search.clicked.connect(self.refresh_table)
        self.shortcut_search = QShortcut(QKeySequence("Return"), self)
        self.shortcut_search.activated.connect(self.refresh_table)
        self.tableWidget_SymbolInfo.selectionModel().currentChanged.connect(self.tableWidget_SymbolInfo_current_changed)
        self.tableWidget_SymbolInfo.itemDoubleClicked.connect(self.tableWidget_SymbolInfo_item_double_clicked)
        self.tableWidget_SymbolInfo.contextMenuEvent = self.tableWidget_SymbolInfo_context_menu_event
        icons_directory = GuiUtils.get_icons_directory()
        self.pushButton_Help.setIcon(QIcon(QPixmap(icons_directory + "/help.png")))
        self.pushButton_Help.clicked.connect(self.pushButton_Help_clicked)

    def refresh_table(self):
        input_text = self.lineEdit_SearchInput.text()
        case_sensitive = self.checkBox_CaseSensitive.isChecked()
        self.loading_dialog = LoadingDialogForm(self)
        self.background_thread = self.loading_dialog.background_thread
        self.background_thread.overrided_func = lambda: self.process_data(input_text, case_sensitive)
        self.background_thread.output_ready.connect(self.apply_data)
        self.loading_dialog.exec_()

    def process_data(self, gdb_input, case_sensitive):
        return GDB_Engine.search_functions(gdb_input, case_sensitive)

    def apply_data(self, output):
        self.tableWidget_SymbolInfo.setSortingEnabled(False)
        self.tableWidget_SymbolInfo.setRowCount(0)
        self.tableWidget_SymbolInfo.setRowCount(len(output))
        for row, item in enumerate(output):
            address = item[0]
            if address:
                address_item = QTableWidgetItem(address)
            else:
                address_item = QTableWidgetItem("DEFINED")
                address_item.setBackground(Qt.green)
            self.tableWidget_SymbolInfo.setItem(row, FUNCTIONS_INFO_ADDR_COL, address_item)
            self.tableWidget_SymbolInfo.setItem(row, FUNCTIONS_INFO_SYMBOL_COL, QTableWidgetItem(item[1]))
        self.tableWidget_SymbolInfo.setSortingEnabled(True)
        GuiUtils.resize_to_contents(self.tableWidget_SymbolInfo)

    def tableWidget_SymbolInfo_current_changed(self, QModelIndex_current):
        self.textBrowser_AddressInfo.clear()
        address = self.tableWidget_SymbolInfo.item(QModelIndex_current.row(), FUNCTIONS_INFO_ADDR_COL).text()
        if SysUtils.extract_address(address):
            symbol = self.tableWidget_SymbolInfo.item(QModelIndex_current.row(), FUNCTIONS_INFO_SYMBOL_COL).text()
            for item in SysUtils.split_symbol(symbol):
                info = GDB_Engine.get_symbol_info(item)
                self.textBrowser_AddressInfo.append(info)
        else:
            text = "This symbol is defined. You can use its body as a gdb expression. For instance:\n\n" \
                   "void func(param) can be used as 'func' as a gdb expression"
            self.textBrowser_AddressInfo.append(text)

    def tableWidget_SymbolInfo_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_SymbolInfo.item(row, column).text())

        selected_row = GuiUtils.get_current_row(self.tableWidget_SymbolInfo)

        menu = QMenu()
        copy_address = menu.addAction("Copy Address")
        copy_symbol = menu.addAction("Copy Symbol")
        if selected_row == -1:
            GuiUtils.delete_menu_entries(menu, [copy_address, copy_symbol])
        font_size = self.tableWidget_SymbolInfo.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            copy_address: lambda: copy_to_clipboard(selected_row, FUNCTIONS_INFO_ADDR_COL),
            copy_symbol: lambda: copy_to_clipboard(selected_row, FUNCTIONS_INFO_SYMBOL_COL)
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def tableWidget_SymbolInfo_item_double_clicked(self, index):
        address = self.tableWidget_SymbolInfo.item(index.row(), FUNCTIONS_INFO_ADDR_COL).text()
        self.parent().disassemble_expression(address, append_to_travel_history=True)

    def pushButton_Help_clicked(self):
        text = "\tHere's some useful regex tips:" \
               "\n'^string' searches for everything that starts with 'string'" \
               "\n'[ab]cd' searches for both 'acd' and 'bcd'" \
               "\n\n\tHow to interpret symbols:" \
               "\nA symbol that looks like 'func(param)@plt' consists of 3 pieces" \
               "\nfunc, func(param), func(param)@plt" \
               "\nThese 3 functions will have different addresses" \
               "\n@plt means this function is a subroutine for the original one" \
               "\nThere can be more than one of the same function" \
               "\nIt means that the function is overloaded"
        InputDialogForm(item_list=[(text, None, Qt.AlignLeft)], buttons=[QDialogButtonBox.Ok]).exec_()

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)


class HexEditDialogForm(QDialog, HexEditDialog):
    def __init__(self, address, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)
        self.lineEdit_Length.setValidator(QHexValidator(999, self))
        self.lineEdit_Address.setText(address)
        self.lineEdit_Length.setText("20")
        self.refresh_view()
        self.lineEdit_AsciiView.selectionChanged.connect(self.lineEdit_AsciiView_selection_changed)

        # TODO: Implement this
        # self.lineEdit_HexView.selectionChanged.connect(self.lineEdit_HexView_selection_changed)
        self.lineEdit_HexView.textEdited.connect(self.lineEdit_HexView_text_edited)
        self.lineEdit_AsciiView.textEdited.connect(self.lineEdit_AsciiView_text_edited)
        self.pushButton_Refresh.pressed.connect(self.refresh_view)
        self.lineEdit_Address.textChanged.connect(self.refresh_view)
        self.lineEdit_Length.textChanged.connect(self.refresh_view)

    def lineEdit_AsciiView_selection_changed(self):
        length = len(SysUtils.str_to_aob(self.lineEdit_AsciiView.selectedText(), "utf-8"))
        start_index = self.lineEdit_AsciiView.selectionStart()
        start_index = len(SysUtils.str_to_aob(self.lineEdit_AsciiView.text()[0:start_index], "utf-8"))
        if start_index > 0:
            start_index += 1
        self.lineEdit_HexView.deselect()
        self.lineEdit_HexView.setSelection(start_index, length)

    def lineEdit_HexView_selection_changed(self):
        # TODO: Implement this
        print("TODO: Implement selectionChanged signal of lineEdit_HexView")
        raise NotImplementedError

    def lineEdit_HexView_text_edited(self):
        aob_string = self.lineEdit_HexView.text()
        if not SysUtils.parse_string(aob_string, type_defs.VALUE_INDEX.INDEX_AOB):
            self.lineEdit_HexView.setStyleSheet("QLineEdit {background-color: red;}")
            return
        aob_array = aob_string.split()
        try:
            self.lineEdit_AsciiView.setText(SysUtils.aob_to_str(aob_array, "utf-8"))
            self.lineEdit_HexView.setStyleSheet("QLineEdit {background-color: white;}")
        except ValueError:
            self.lineEdit_HexView.setStyleSheet("QLineEdit {background-color: red;}")

    def lineEdit_AsciiView_text_edited(self):
        ascii_str = self.lineEdit_AsciiView.text()
        try:
            self.lineEdit_HexView.setText(SysUtils.str_to_aob(ascii_str, "utf-8"))
            self.lineEdit_AsciiView.setStyleSheet("QLineEdit {background-color: white;}")
        except ValueError:
            self.lineEdit_AsciiView.setStyleSheet("QLineEdit {background-color: red;}")

    def refresh_view(self):
        self.lineEdit_AsciiView.clear()
        self.lineEdit_HexView.clear()
        address = GDB_Engine.examine_expression(self.lineEdit_Address.text()).address
        if not address:
            return
        length = self.lineEdit_Length.text()
        try:
            length = int(length, 0)
            address = int(address, 0)
        except ValueError:
            return
        aob_array = GDB_Engine.hex_dump(address, length)
        ascii_str = SysUtils.aob_to_str(aob_array, "utf-8")
        self.lineEdit_AsciiView.setText(ascii_str)
        self.lineEdit_HexView.setText(" ".join(aob_array))

    def accept(self):
        expression = self.lineEdit_Address.text()
        address = GDB_Engine.examine_expression(expression).address
        if not address:
            QMessageBox.information(self, "Error", expression + " isn't a valid expression")
            return
        value = self.lineEdit_HexView.text()
        GDB_Engine.write_memory(address, type_defs.VALUE_INDEX.INDEX_AOB, value)
        super(HexEditDialogForm, self).accept()


class LibpinceReferenceWidgetForm(QWidget, LibpinceReferenceWidget):
    def convert_to_modules(self, module_strings):
        return [eval(item) for item in module_strings]

    def __init__(self, is_window=False, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)
        self.found_count = 0
        self.current_found = 0
        global instances
        instances.append(self)
        if is_window:
            GuiUtils.center(self)
            self.setWindowFlags(Qt.Window)
        self.show_type_defs()
        self.splitter.setStretchFactor(0, 1)
        self.widget_Resources.resize(700, self.widget_Resources.height())
        libpince_directory = SysUtils.get_libpince_directory()
        self.textBrowser_TypeDefs.setText(open(libpince_directory + "/type_defs.py").read())
        source_menu_items = ["(Tagged only)", "(All)"]
        self.libpince_source_files = ["GDB_Engine", "SysUtils", "GuiUtils"]
        source_menu_items.extend(self.libpince_source_files)
        self.comboBox_SourceFile.addItems(source_menu_items)
        self.comboBox_SourceFile.setCurrentIndex(0)
        self.fill_resource_tree()
        icons_directory = GuiUtils.get_icons_directory()
        self.pushButton_TextUp.setIcon(QIcon(QPixmap(icons_directory + "/bullet_arrow_up.png")))
        self.pushButton_TextDown.setIcon(QIcon(QPixmap(icons_directory + "/bullet_arrow_down.png")))
        self.comboBox_SourceFile.currentIndexChanged.connect(self.comboBox_SourceFile_current_index_changed)
        self.pushButton_ShowTypeDefs.clicked.connect(self.toggle_type_defs)
        self.lineEdit_SearchText.textChanged.connect(self.highlight_text)
        self.pushButton_TextDown.clicked.connect(self.pushButton_TextDown_clicked)
        self.pushButton_TextUp.clicked.connect(self.pushButton_TextUp_clicked)
        self.lineEdit_Search.textChanged.connect(self.comboBox_SourceFile_current_index_changed)
        self.tableWidget_ResourceTable.contextMenuEvent = self.tableWidget_ResourceTable_context_menu_event
        self.treeWidget_ResourceTree.contextMenuEvent = self.treeWidget_ResourceTree_context_menu_event
        self.treeWidget_ResourceTree.expanded.connect(self.resize_resource_tree)
        self.treeWidget_ResourceTree.collapsed.connect(self.resize_resource_tree)

    def tableWidget_ResourceTable_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_ResourceTable.item(row, column).text())

        selected_row = GuiUtils.get_current_row(self.tableWidget_ResourceTable)

        menu = QMenu()
        refresh = menu.addAction("Refresh")
        menu.addSeparator()
        copy_item = menu.addAction("Copy Item")
        copy_value = menu.addAction("Copy Value")
        if selected_row == -1:
            GuiUtils.delete_menu_entries(menu, [copy_item, copy_value])
        font_size = self.tableWidget_ResourceTable.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            refresh: self.fill_resource_table,
            copy_item: lambda: copy_to_clipboard(selected_row, LIBPINCE_REFERENCE_ITEM_COL),
            copy_value: lambda: copy_to_clipboard(selected_row, LIBPINCE_REFERENCE_VALUE_COL)
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def treeWidget_ResourceTree_context_menu_event(self, event):
        def copy_to_clipboard(column):
            current_item = GuiUtils.get_current_item(self.treeWidget_ResourceTree)
            if current_item:
                app.clipboard().setText(current_item.text(column))

        def expand_all():
            self.treeWidget_ResourceTree.expandAll()
            self.resize_resource_tree()

        def collapse_all():
            self.treeWidget_ResourceTree.collapseAll()
            self.resize_resource_tree()

        selected_row = GuiUtils.get_current_row(self.treeWidget_ResourceTree)

        menu = QMenu()
        refresh = menu.addAction("Refresh")
        menu.addSeparator()
        copy_item = menu.addAction("Copy Item")
        copy_value = menu.addAction("Copy Value")
        if selected_row == -1:
            GuiUtils.delete_menu_entries(menu, [copy_item, copy_value])
        menu.addSeparator()
        expand_all_items = menu.addAction("Expand All")
        collapse_all_items = menu.addAction("Collapse All")
        font_size = self.treeWidget_ResourceTree.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            refresh: self.fill_resource_tree,
            copy_item: lambda: copy_to_clipboard(LIBPINCE_REFERENCE_ITEM_COL),
            copy_value: lambda: copy_to_clipboard(LIBPINCE_REFERENCE_VALUE_COL),
            expand_all_items: expand_all,
            collapse_all_items: collapse_all
        }

        # Thanks QT, for this unexplainable, mind blowing bug of yours
        self.treeWidget_ResourceTree.blockSignals(True)
        try:
            actions[action]()
        except KeyError:
            pass
        self.treeWidget_ResourceTree.blockSignals(False)

    def comboBox_SourceFile_current_index_changed(self):
        if self.comboBox_SourceFile.currentIndex() == 0:  # (Tagged only)
            self.fill_resource_tree()
        else:
            self.fill_resource_table()

    def resize_resource_tree(self):
        self.treeWidget_ResourceTree.resizeColumnToContents(LIBPINCE_REFERENCE_ITEM_COL)

    def fill_resource_tree(self):
        self.treeWidget_ResourceTree.setStyleSheet("QTreeWidget::item{ height: 16px; }")
        self.stackedWidget_Resources.setCurrentIndex(0)
        self.treeWidget_ResourceTree.clear()
        parent = self.treeWidget_ResourceTree
        checked_source_files = self.convert_to_modules(self.libpince_source_files)
        tag_dict = SysUtils.get_tags(checked_source_files, type_defs.tag_to_string, self.lineEdit_Search.text())
        docstring_dict = SysUtils.get_docstrings(checked_source_files, self.lineEdit_Search.text())
        for tag in tag_dict:
            child = QTreeWidgetItem(parent)
            child.setText(0, tag)
            for item in tag_dict[tag]:
                docstring = docstring_dict.get(item)
                docstr_child = QTreeWidgetItem(child)
                docstr_child.setText(LIBPINCE_REFERENCE_ITEM_COL, item)
                docstr_child.setText(LIBPINCE_REFERENCE_VALUE_COL, str(eval(item)))
                docstr_child.setToolTip(LIBPINCE_REFERENCE_ITEM_COL, docstring)
                docstr_child.setToolTip(LIBPINCE_REFERENCE_VALUE_COL, docstring)

        # Magic and mystery
        self.treeWidget_ResourceTree.blockSignals(True)
        if self.lineEdit_Search.text():
            self.treeWidget_ResourceTree.expandAll()
        self.resize_resource_tree()
        self.treeWidget_ResourceTree.blockSignals(False)

    def fill_resource_table(self):
        self.stackedWidget_Resources.setCurrentIndex(1)
        self.tableWidget_ResourceTable.setSortingEnabled(False)
        self.tableWidget_ResourceTable.setRowCount(0)
        if self.comboBox_SourceFile.currentIndex() == 1:  # (All)
            checked_source_files = self.libpince_source_files
        else:
            checked_source_files = [self.comboBox_SourceFile.currentText()]
        checked_source_files = self.convert_to_modules(checked_source_files)
        element_dict = SysUtils.get_docstrings(checked_source_files, self.lineEdit_Search.text())
        self.tableWidget_ResourceTable.setRowCount(len(element_dict))
        for row, item in enumerate(element_dict):
            docstring = element_dict.get(item)
            table_widget_item = QTableWidgetItem(item)
            table_widget_item_value = QTableWidgetItem(str(eval(item)))
            table_widget_item.setToolTip(docstring)
            table_widget_item_value.setToolTip(docstring)
            self.tableWidget_ResourceTable.setItem(row, LIBPINCE_REFERENCE_ITEM_COL, table_widget_item)
            self.tableWidget_ResourceTable.setItem(row, LIBPINCE_REFERENCE_VALUE_COL, table_widget_item_value)
        self.tableWidget_ResourceTable.setSortingEnabled(True)
        self.tableWidget_ResourceTable.sortByColumn(LIBPINCE_REFERENCE_ITEM_COL, Qt.AscendingOrder)
        GuiUtils.resize_to_contents(self.tableWidget_ResourceTable)

    def pushButton_TextDown_clicked(self):
        if self.found_count == 0:
            return
        cursor = self.textBrowser_TypeDefs.textCursor()
        cursor.clearSelection()
        cursor.movePosition(QTextCursor.Start)
        self.textBrowser_TypeDefs.setTextCursor(cursor)
        if self.current_found == self.found_count:
            self.current_found = 1
        else:
            self.current_found += 1
        pattern = self.lineEdit_SearchText.text()
        for x in range(self.current_found):
            self.textBrowser_TypeDefs.find(pattern)
        self.label_FoundCount.setText(str(self.current_found) + "/" + str(self.found_count))

    def pushButton_TextUp_clicked(self):
        if self.found_count == 0:
            return
        cursor = self.textBrowser_TypeDefs.textCursor()
        cursor.clearSelection()
        cursor.movePosition(QTextCursor.Start)
        self.textBrowser_TypeDefs.setTextCursor(cursor)
        if self.current_found == 1:
            self.current_found = self.found_count
        else:
            self.current_found -= 1
        pattern = self.lineEdit_SearchText.text()
        for x in range(self.current_found):
            self.textBrowser_TypeDefs.find(pattern)
        self.label_FoundCount.setText(str(self.current_found) + "/" + str(self.found_count))

    def highlight_text(self):
        self.textBrowser_TypeDefs.selectAll()
        self.textBrowser_TypeDefs.setTextBackgroundColor(QColor("white"))
        cursor = self.textBrowser_TypeDefs.textCursor()
        cursor.clearSelection()
        cursor.movePosition(QTextCursor.Start)
        self.textBrowser_TypeDefs.setTextCursor(cursor)

        highlight_format = QTextCharFormat()
        highlight_format.setBackground(QBrush(QColor("red")))
        pattern = self.lineEdit_SearchText.text()
        found_count = 0
        while True:
            if not self.textBrowser_TypeDefs.find(pattern):
                break
            cursor = self.textBrowser_TypeDefs.textCursor()
            cursor.mergeCharFormat(highlight_format)
            found_count += 1
        self.found_count = found_count
        if found_count == 0:
            self.label_FoundCount.setText("0/0")
            return
        cursor = self.textBrowser_TypeDefs.textCursor()
        cursor.clearSelection()
        cursor.movePosition(QTextCursor.Start)
        self.textBrowser_TypeDefs.setTextCursor(cursor)
        self.textBrowser_TypeDefs.find(pattern)
        self.current_found = 1
        self.label_FoundCount.setText("1/" + str(found_count))

    def toggle_type_defs(self):
        if self.type_defs_shown:
            self.hide_type_defs()
        else:
            self.show_type_defs()

    def hide_type_defs(self):
        self.type_defs_shown = False
        self.widget_TypeDefs.hide()
        self.pushButton_ShowTypeDefs.setText("Show type_defs")

    def show_type_defs(self):
        self.type_defs_shown = True
        self.widget_TypeDefs.show()
        self.pushButton_ShowTypeDefs.setText("Hide type_defs")

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)


class LogFileWidgetForm(QWidget, LogFileWidget):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setupUi(self)
        GuiUtils.center(self)
        global instances
        instances.append(self)
        self.setWindowFlags(Qt.Window)
        self.contents = ""
        self.refresh_contents()
        self.refresh_timer = QTimer()
        self.refresh_timer.setInterval(500)
        self.refresh_timer.timeout.connect(self.refresh_contents)
        self.refresh_timer.start()

    def refresh_contents(self):
        log_path = SysUtils.get_logging_file(GDB_Engine.currentpid)
        self.setWindowTitle("Log File of PID " + str(GDB_Engine.currentpid))
        self.label_FilePath.setText("Contents of " + log_path + " (only last 20000 bytes are shown)")
        logging_status = "<font color=blue>ON</font>" if gdb_logging else "<font color=red>OFF</font>"
        self.label_LoggingStatus.setText("<b>LOGGING: " + logging_status + "</b>")
        try:
            log_file = open(log_path)
        except OSError:
            self.textBrowser_LogContent.clear()
            error_message = "Unable to read log file at " + log_path + "\n"
            if not gdb_logging:
                error_message += "Go to Settings->Debug to enable logging"
            self.textBrowser_LogContent.setText(error_message)
            return
        log_file.seek(0, io.SEEK_END)
        end_pos = log_file.tell()
        if end_pos > 20000:
            log_file.seek(end_pos - 20000, io.SEEK_SET)
        else:
            log_file.seek(0, io.SEEK_SET)
        contents = log_file.read().split("\n", 1)[-1]
        if contents != self.contents:
            self.contents = contents
            self.textBrowser_LogContent.clear()
            self.textBrowser_LogContent.setPlainText(contents)

            # Scrolling to bottom
            cursor = self.textBrowser_LogContent.textCursor()
            cursor.movePosition(QTextCursor.End)
            self.textBrowser_LogContent.setTextCursor(cursor)
            self.textBrowser_LogContent.ensureCursorVisible()
        log_file.close()

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)
        self.refresh_timer.stop()


class SearchOpcodeWidgetForm(QWidget, SearchOpcodeWidget):
    def __init__(self, start="", end="", parent=None):
        super().__init__()
        self.setupUi(self)
        self.parent = lambda: parent
        global instances
        instances.append(self)
        GuiUtils.center(self)
        self.setWindowFlags(Qt.Window)
        self.lineEdit_Start.setText(start)
        self.lineEdit_End.setText(end)
        self.tableWidget_Opcodes.setColumnWidth(SEARCH_OPCODE_ADDR_COL, 250)
        icons_directory = GuiUtils.get_icons_directory()
        self.pushButton_Help.setIcon(QIcon(QPixmap(icons_directory + "/help.png")))
        self.pushButton_Help.clicked.connect(self.pushButton_Help_clicked)
        self.pushButton_Search.clicked.connect(self.refresh_table)
        self.shortcut_search = QShortcut(QKeySequence("Return"), self)
        self.shortcut_search.activated.connect(self.refresh_table)
        self.tableWidget_Opcodes.itemDoubleClicked.connect(self.tableWidget_Opcodes_item_double_clicked)
        self.tableWidget_Opcodes.contextMenuEvent = self.tableWidget_Opcodes_context_menu_event

    def refresh_table(self):
        start_address = self.lineEdit_Start.text()
        end_address = self.lineEdit_End.text()
        regex = self.lineEdit_Regex.text()
        case_sensitive = self.checkBox_CaseSensitive.isChecked()
        enable_regex = self.checkBox_Regex.isChecked()
        self.loading_dialog = LoadingDialogForm(self)
        self.background_thread = self.loading_dialog.background_thread
        self.background_thread.overrided_func = lambda: self.process_data(regex, start_address, end_address,
                                                                          case_sensitive, enable_regex)
        self.background_thread.output_ready.connect(self.apply_data)
        self.loading_dialog.exec_()

    def process_data(self, regex, start_address, end_address, case_sensitive, enable_regex):
        return GDB_Engine.search_opcode(regex, start_address, end_address, case_sensitive, enable_regex)

    def apply_data(self, disas_data):
        if disas_data is None:
            QMessageBox.information(self, "Error", "Given regex isn't valid, check terminal to see the error")
            return
        self.tableWidget_Opcodes.setSortingEnabled(False)
        self.tableWidget_Opcodes.setRowCount(0)
        self.tableWidget_Opcodes.setRowCount(len(disas_data))
        for row, item in enumerate(disas_data):
            self.tableWidget_Opcodes.setItem(row, SEARCH_OPCODE_ADDR_COL, QTableWidgetItem(item[0]))
            self.tableWidget_Opcodes.setItem(row, SEARCH_OPCODE_OPCODES_COL, QTableWidgetItem(item[1]))
        self.tableWidget_Opcodes.setSortingEnabled(True)

    def pushButton_Help_clicked(self):
        text = "\tHere's some useful regex examples:" \
               "\n'call|rax' searches for opcodes that contain 'call' or 'rax'" \
               "\n'[re]cx' searches for both 'rcx' and 'ecx'" \
               "\nUse the char '\\' to escape special chars such as '['" \
               "\n'\[rsp\]' searches for opcodes that contain '[rsp]'"
        InputDialogForm(item_list=[(text, None, Qt.AlignLeft)], buttons=[QDialogButtonBox.Ok]).exec_()

    def tableWidget_Opcodes_item_double_clicked(self, index):
        row = index.row()
        address = self.tableWidget_Opcodes.item(row, SEARCH_OPCODE_ADDR_COL).text()
        self.parent().disassemble_expression(SysUtils.extract_address(address), append_to_travel_history=True)

    def tableWidget_Opcodes_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_Opcodes.item(row, column).text())

        selected_row = GuiUtils.get_current_row(self.tableWidget_Opcodes)

        menu = QMenu()
        copy_address = menu.addAction("Copy Address")
        copy_opcode = menu.addAction("Copy Opcode")
        if selected_row == -1:
            GuiUtils.delete_menu_entries(menu, [copy_address, copy_opcode])
        font_size = self.tableWidget_Opcodes.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            copy_address: lambda: copy_to_clipboard(selected_row, SEARCH_OPCODE_ADDR_COL),
            copy_opcode: lambda: copy_to_clipboard(selected_row, SEARCH_OPCODE_OPCODES_COL)
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)


class MemoryRegionsWidgetForm(QWidget, MemoryRegionsWidget):
    def __init__(self, parent=None):
        super().__init__()
        self.setupUi(self)
        self.parent = lambda: parent
        global instances
        instances.append(self)
        GuiUtils.center(self)
        self.setWindowFlags(Qt.Window)
        self.refresh_table()
        self.tableWidget_MemoryRegions.contextMenuEvent = self.tableWidget_MemoryRegions_context_menu_event
        self.tableWidget_MemoryRegions.itemDoubleClicked.connect(self.tableWidget_MemoryRegions_item_double_clicked)
        self.shortcut_refresh = QShortcut(QKeySequence("R"), self)
        self.shortcut_refresh.activated.connect(self.refresh_table)

    def refresh_table(self):
        memory_regions = SysUtils.get_memory_regions(GDB_Engine.currentpid)
        self.tableWidget_MemoryRegions.setRowCount(0)
        self.tableWidget_MemoryRegions.setRowCount(len(memory_regions))
        for row, region in enumerate(memory_regions):
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_ADDR_COL, QTableWidgetItem(region.addr))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_PERM_COL, QTableWidgetItem(region.perms))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_SIZE_COL, QTableWidgetItem(hex(region.size)))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_PATH_COL, QTableWidgetItem(region.path))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_RSS_COL, QTableWidgetItem(hex(region.rss)))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_PSS_COL, QTableWidgetItem(hex(region.pss)))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_SHRCLN_COL,
                                                   QTableWidgetItem(hex(region.shared_clean)))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_SHRDRTY_COL,
                                                   QTableWidgetItem(hex(region.shared_dirty)))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_PRIVCLN_COL,
                                                   QTableWidgetItem(hex(region.private_clean)))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_PRIVDRTY_COL,
                                                   QTableWidgetItem(hex(region.private_dirty)))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_REF_COL,
                                                   QTableWidgetItem(hex(region.referenced)))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_ANON_COL,
                                                   QTableWidgetItem(hex(region.anonymous)))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_SWAP_COL, QTableWidgetItem(hex(region.swap)))
        GuiUtils.resize_to_contents(self.tableWidget_MemoryRegions)

    def tableWidget_MemoryRegions_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_MemoryRegions.item(row, column).text())

        selected_row = GuiUtils.get_current_row(self.tableWidget_MemoryRegions)

        menu = QMenu()
        refresh = menu.addAction("Refresh[R]")
        menu.addSeparator()
        copy_addresses = menu.addAction("Copy Addresses")
        copy_size = menu.addAction("Copy Size")
        copy_path = menu.addAction("Copy Path")
        if selected_row == -1:
            GuiUtils.delete_menu_entries(menu, [copy_addresses, copy_size, copy_path])
        font_size = self.tableWidget_MemoryRegions.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            refresh: self.refresh_table,
            copy_addresses: lambda: copy_to_clipboard(selected_row, MEMORY_REGIONS_ADDR_COL),
            copy_size: lambda: copy_to_clipboard(selected_row, MEMORY_REGIONS_SIZE_COL),
            copy_path: lambda: copy_to_clipboard(selected_row, MEMORY_REGIONS_PATH_COL)
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def tableWidget_MemoryRegions_item_double_clicked(self, index):
        row = index.row()
        address = self.tableWidget_MemoryRegions.item(row, MEMORY_REGIONS_ADDR_COL).text()
        address_int = int(address.split("-")[0], 16)
        self.parent().hex_dump_address(address_int)

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)


class DissectCodeDialogForm(QDialog, DissectCodeDialog):
    scan_finished_signal = pyqtSignal()

    def __init__(self, parent=None, int_address=-1):
        super().__init__(parent=parent)
        self.setupUi(self)
        self.init_pre_scan_gui()
        self.update_dissect_results()
        self.show_memory_regions()
        self.splitter.setStretchFactor(0, 1)
        self.pushButton_StartCancel.clicked.connect(self.pushButton_StartCancel_clicked)
        self.refresh_timer = QTimer()
        self.refresh_timer.setInterval(100)
        self.refresh_timer.timeout.connect(self.refresh_dissect_status)
        if int_address != -1:
            for row in range(self.tableWidget_ExecutableMemoryRegions.rowCount()):
                item = self.tableWidget_ExecutableMemoryRegions.item(row, DISSECT_CODE_ADDR_COL).text()
                start_addr, end_addr = item.split("-")
                if int(start_addr, 16) <= int_address <= int(end_addr, 16):
                    self.tableWidget_ExecutableMemoryRegions.clearSelection()
                    self.tableWidget_ExecutableMemoryRegions.selectRow(row)
                    self.pushButton_StartCancel_clicked()
                    break
            else:
                QMessageBox.information(self, "Error", hex(int_address) + " isn't in a valid region range")
        else:
            if self.tableWidget_ExecutableMemoryRegions.rowCount() > 0:
                self.tableWidget_ExecutableMemoryRegions.selectRow(0)

    class BackgroundThread(QThread):
        output_ready = pyqtSignal()
        is_canceled = False

        def __init__(self, region_list, discard_invalid_strings):
            super().__init__()
            self.region_list = region_list
            self.discard_invalid_strings = discard_invalid_strings

        def run(self):
            GDB_Engine.dissect_code(self.region_list, self.discard_invalid_strings)
            if not self.is_canceled:
                self.output_ready.emit()

    def init_pre_scan_gui(self):
        self.is_scanning = False
        self.is_canceled = False
        self.pushButton_StartCancel.setText("Start")

    def init_after_scan_gui(self):
        self.is_scanning = True
        self.label_ScanInfo.setText("Currently scanning region:")
        self.pushButton_StartCancel.setText("Cancel")

    def refresh_dissect_status(self):
        region, region_count, range, string_count, jump_count, call_count = GDB_Engine.get_dissect_code_status()
        if not region:
            return
        self.label_RegionInfo.setText(region)
        self.label_RegionCountInfo.setText(region_count)
        self.label_CurrentRange.setText(range)
        self.label_StringReferenceCount.setText(str(string_count))
        self.label_JumpReferenceCount.setText(str(jump_count))
        self.label_CallReferenceCount.setText(str(call_count))

    def update_dissect_results(self):
        try:
            referenced_strings, referenced_jumps, referenced_calls = GDB_Engine.get_dissect_code_data()
        except:
            return
        self.label_StringReferenceCount.setText(str(len(referenced_strings)))
        self.label_JumpReferenceCount.setText(str(len(referenced_jumps)))
        self.label_CallReferenceCount.setText(str(len(referenced_calls)))

    def show_memory_regions(self):
        executable_regions = SysUtils.filter_memory_regions(GDB_Engine.currentpid, "perms", "..x.")
        self.region_list = executable_regions
        self.tableWidget_ExecutableMemoryRegions.setRowCount(0)
        self.tableWidget_ExecutableMemoryRegions.setRowCount(len(executable_regions))
        for row, region in enumerate(executable_regions):
            self.tableWidget_ExecutableMemoryRegions.setItem(row, DISSECT_CODE_ADDR_COL, QTableWidgetItem(region.addr))
            self.tableWidget_ExecutableMemoryRegions.setItem(row, DISSECT_CODE_PATH_COL, QTableWidgetItem(region.path))
        GuiUtils.resize_to_contents(self.tableWidget_ExecutableMemoryRegions)

    def scan_finished(self):
        self.init_pre_scan_gui()
        if not self.is_canceled:
            self.label_ScanInfo.setText("Scan finished")
        self.is_canceled = False
        self.refresh_timer.stop()
        self.refresh_dissect_status()
        self.update_dissect_results()
        self.scan_finished_signal.emit()

    def pushButton_StartCancel_clicked(self):
        if self.is_scanning:
            self.is_canceled = True
            self.background_thread.is_canceled = True
            GDB_Engine.cancel_dissect_code()
            self.refresh_timer.stop()
            self.update_dissect_results()
            self.label_ScanInfo.setText("Scan was canceled")
            self.init_pre_scan_gui()
        else:
            if not GDB_Engine.inferior_status == type_defs.INFERIOR_STATUS.INFERIOR_STOPPED:
                QMessageBox.information(self, "Error", "Please stop the process first")
                return
            selected_rows = self.tableWidget_ExecutableMemoryRegions.selectionModel().selectedRows()
            if not selected_rows:
                QMessageBox.information(self, "Error", "Select at least one region")
                return
            selected_indexes = [selected_row.row() for selected_row in selected_rows]
            selected_regions = [self.region_list[selected_index] for selected_index in selected_indexes]
            self.background_thread = self.BackgroundThread(selected_regions,
                                                           self.checkBox_DiscardInvalidStrings.isChecked())
            self.background_thread.output_ready.connect(self.scan_finished)
            self.init_after_scan_gui()
            self.refresh_timer.start()
            self.background_thread.start()

    def closeEvent(self, QCloseEvent):
        GDB_Engine.cancel_dissect_code()
        self.refresh_timer.stop()


class ReferencedStringsWidgetForm(QWidget, ReferencedStringsWidget):
    def __init__(self, parent=None):
        super().__init__()
        self.setupUi(self)
        GuiUtils.fill_value_combobox(self.comboBox_ValueType, type_defs.VALUE_INDEX.INDEX_STRING_UTF8)
        self.parent = lambda: parent
        global instances
        instances.append(self)
        GuiUtils.center_to_parent(self)
        self.setWindowFlags(Qt.Window)
        self.tableWidget_References.setColumnWidth(REF_STR_ADDR_COL, 150)
        self.tableWidget_References.setColumnWidth(REF_STR_COUNT_COL, 80)
        self.splitter.setStretchFactor(0, 1)
        self.listWidget_Referrers.resize(400, self.listWidget_Referrers.height())
        self.hex_len = 16 if GDB_Engine.inferior_arch == type_defs.INFERIOR_ARCH.ARCH_64 else 8
        str_dict, jmp_dict, call_dict = GDB_Engine.get_dissect_code_data()
        str_dict_len, jmp_dict_len, call_dict_len = len(str_dict), len(jmp_dict), len(call_dict)
        str_dict.close()
        jmp_dict.close()
        call_dict.close()
        if str_dict_len == 0 and jmp_dict_len == 0 and call_dict_len == 0:
            confirm_dialog = InputDialogForm(item_list=[("You need to dissect code first\nProceed?",)])
            if confirm_dialog.exec_():
                dissect_code_dialog = DissectCodeDialogForm()
                dissect_code_dialog.scan_finished_signal.connect(dissect_code_dialog.accept)
                dissect_code_dialog.exec_()
        self.refresh_table()
        self.tableWidget_References.sortByColumn(REF_STR_ADDR_COL, Qt.AscendingOrder)
        self.tableWidget_References.selectionModel().currentChanged.connect(self.tableWidget_References_current_changed)
        self.listWidget_Referrers.itemDoubleClicked.connect(self.listWidget_Referrers_item_double_clicked)
        self.tableWidget_References.itemDoubleClicked.connect(self.tableWidget_References_item_double_clicked)
        self.tableWidget_References.contextMenuEvent = self.tableWidget_References_context_menu_event
        self.listWidget_Referrers.contextMenuEvent = self.listWidget_Referrers_context_menu_event
        self.pushButton_Search.clicked.connect(self.refresh_table)
        self.comboBox_ValueType.currentIndexChanged.connect(self.refresh_table)
        self.shortcut_search = QShortcut(QKeySequence("Return"), self)
        self.shortcut_search.activated.connect(self.refresh_table)

    def pad_hex(self, hex_str):
        index = hex_str.find(" ")
        if index == -1:
            self_len = 0
        else:
            self_len = len(hex_str) - index
        return '0x' + hex_str[2:].zfill(self.hex_len + self_len)

    def refresh_table(self):
        item_list = GDB_Engine.search_referenced_strings(self.lineEdit_Regex.text(),
                                                         self.comboBox_ValueType.currentIndex(),
                                                         self.checkBox_CaseSensitive.isChecked(),
                                                         self.checkBox_Regex.isChecked())
        if item_list is None:
            QMessageBox.information(self, "Error",
                                    "An exception occurred while trying to compile the given regex\n")
            return
        self.tableWidget_References.setSortingEnabled(False)
        self.tableWidget_References.setRowCount(0)
        self.tableWidget_References.setRowCount(len(item_list))
        for row, item in enumerate(item_list):
            self.tableWidget_References.setItem(row, REF_STR_ADDR_COL, QTableWidgetItem(self.pad_hex(item[0])))
            table_widget_item = QTableWidgetItem()
            table_widget_item.setData(Qt.EditRole, item[1])
            self.tableWidget_References.setItem(row, REF_STR_COUNT_COL, table_widget_item)
            table_widget_item = QTableWidgetItem()
            table_widget_item.setData(Qt.EditRole, item[2])
            self.tableWidget_References.setItem(row, REF_STR_VAL_COL, table_widget_item)
        self.tableWidget_References.setSortingEnabled(True)

    def tableWidget_References_current_changed(self, QModelIndex_current):
        if QModelIndex_current.row() < 0:
            return
        self.listWidget_Referrers.clear()
        str_dict = GDB_Engine.get_dissect_code_data(True, False, False)[0]
        addr = self.tableWidget_References.item(QModelIndex_current.row(), REF_STR_ADDR_COL).text()
        referrers = str_dict[hex(int(addr, 16))]
        addrs = [hex(address) for address in referrers]
        self.listWidget_Referrers.addItems([self.pad_hex(item.all) for item in GDB_Engine.examine_expressions(addrs)])
        self.listWidget_Referrers.sortItems(Qt.AscendingOrder)
        str_dict.close()

    def tableWidget_References_item_double_clicked(self, index):
        row = index.row()
        address = self.tableWidget_References.item(row, REF_STR_ADDR_COL).text()
        self.parent().hex_dump_address(int(address, 16))

    def listWidget_Referrers_item_double_clicked(self, item):
        self.parent().disassemble_expression(SysUtils.extract_address(item.text()), append_to_travel_history=True)

    def tableWidget_References_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_References.item(row, column).text())

        selected_row = GuiUtils.get_current_row(self.tableWidget_References)

        menu = QMenu()
        copy_address = menu.addAction("Copy Address")
        copy_value = menu.addAction("Copy Value")
        if selected_row == -1:
            GuiUtils.delete_menu_entries(menu, [copy_address, copy_value])
        font_size = self.tableWidget_References.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            copy_address: lambda: copy_to_clipboard(selected_row, REF_STR_ADDR_COL),
            copy_value: lambda: copy_to_clipboard(selected_row, REF_STR_VAL_COL)
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def listWidget_Referrers_context_menu_event(self, event):
        def copy_to_clipboard(row):
            app.clipboard().setText(self.listWidget_Referrers.item(row).text())

        selected_row = GuiUtils.get_current_row(self.listWidget_Referrers)

        menu = QMenu()
        copy_address = menu.addAction("Copy Address")
        if selected_row == -1:
            GuiUtils.delete_menu_entries(menu, [copy_address])
        font_size = self.listWidget_Referrers.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            copy_address: lambda: copy_to_clipboard(selected_row)
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)


class ReferencedCallsWidgetForm(QWidget, ReferencedCallsWidget):
    def __init__(self, parent=None):
        super().__init__()
        self.setupUi(self)
        self.parent = lambda: parent
        global instances
        instances.append(self)
        GuiUtils.center_to_parent(self)
        self.setWindowFlags(Qt.Window)
        self.tableWidget_References.setColumnWidth(REF_CALL_ADDR_COL, 480)
        self.splitter.setStretchFactor(0, 1)
        self.listWidget_Referrers.resize(400, self.listWidget_Referrers.height())
        self.hex_len = 16 if GDB_Engine.inferior_arch == type_defs.INFERIOR_ARCH.ARCH_64 else 8
        str_dict, jmp_dict, call_dict = GDB_Engine.get_dissect_code_data()
        str_dict_len, jmp_dict_len, call_dict_len = len(str_dict), len(jmp_dict), len(call_dict)
        str_dict.close()
        jmp_dict.close()
        call_dict.close()
        if str_dict_len == 0 and jmp_dict_len == 0 and call_dict_len == 0:
            confirm_dialog = InputDialogForm(item_list=[("You need to dissect code first\nProceed?",)])
            if confirm_dialog.exec_():
                dissect_code_dialog = DissectCodeDialogForm()
                dissect_code_dialog.scan_finished_signal.connect(dissect_code_dialog.accept)
                dissect_code_dialog.exec_()
        self.refresh_table()
        self.tableWidget_References.sortByColumn(REF_CALL_ADDR_COL, Qt.AscendingOrder)
        self.tableWidget_References.selectionModel().currentChanged.connect(self.tableWidget_References_current_changed)
        self.listWidget_Referrers.itemDoubleClicked.connect(self.listWidget_Referrers_item_double_clicked)
        self.tableWidget_References.itemDoubleClicked.connect(self.tableWidget_References_item_double_clicked)
        self.tableWidget_References.contextMenuEvent = self.tableWidget_References_context_menu_event
        self.listWidget_Referrers.contextMenuEvent = self.listWidget_Referrers_context_menu_event
        self.pushButton_Search.clicked.connect(self.refresh_table)
        self.shortcut_search = QShortcut(QKeySequence("Return"), self)
        self.shortcut_search.activated.connect(self.refresh_table)

    def pad_hex(self, hex_str):
        index = hex_str.find(" ")
        if index == -1:
            self_len = 0
        else:
            self_len = len(hex_str) - index
        return '0x' + hex_str[2:].zfill(self.hex_len + self_len)

    def refresh_table(self):
        item_list = GDB_Engine.search_referenced_calls(self.lineEdit_Regex.text(),
                                                       self.checkBox_CaseSensitive.isChecked(),
                                                       self.checkBox_Regex.isChecked())
        if item_list is None:
            QMessageBox.information(self, "Error",
                                    "An exception occurred while trying to compile the given regex\n")
            return
        self.tableWidget_References.setSortingEnabled(False)
        self.tableWidget_References.setRowCount(0)
        self.tableWidget_References.setRowCount(len(item_list))
        for row, item in enumerate(item_list):
            self.tableWidget_References.setItem(row, REF_CALL_ADDR_COL, QTableWidgetItem(self.pad_hex(item[0])))
            table_widget_item = QTableWidgetItem()
            table_widget_item.setData(Qt.EditRole, item[1])
            self.tableWidget_References.setItem(row, REF_CALL_COUNT_COL, table_widget_item)
        self.tableWidget_References.setSortingEnabled(True)

    def tableWidget_References_current_changed(self, QModelIndex_current):
        if QModelIndex_current.row() < 0:
            return
        self.listWidget_Referrers.clear()
        call_dict = GDB_Engine.get_dissect_code_data(False, False, True)[0]
        addr = self.tableWidget_References.item(QModelIndex_current.row(), REF_CALL_ADDR_COL).text()
        referrers = call_dict[hex(int(SysUtils.extract_address(addr), 16))]
        addrs = [hex(address) for address in referrers]
        self.listWidget_Referrers.addItems([self.pad_hex(item.all) for item in GDB_Engine.examine_expressions(addrs)])
        self.listWidget_Referrers.sortItems(Qt.AscendingOrder)
        call_dict.close()

    def tableWidget_References_item_double_clicked(self, index):
        row = index.row()
        address = self.tableWidget_References.item(row, REF_CALL_ADDR_COL).text()
        self.parent().disassemble_expression(SysUtils.extract_address(address), append_to_travel_history=True)

    def listWidget_Referrers_item_double_clicked(self, item):
        self.parent().disassemble_expression(SysUtils.extract_address(item.text()), append_to_travel_history=True)

    def tableWidget_References_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_References.item(row, column).text())

        selected_row = GuiUtils.get_current_row(self.tableWidget_References)

        menu = QMenu()
        copy_address = menu.addAction("Copy Address")
        if selected_row == -1:
            GuiUtils.delete_menu_entries(menu, [copy_address])
        font_size = self.tableWidget_References.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            copy_address: lambda: copy_to_clipboard(selected_row, REF_CALL_ADDR_COL)
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def listWidget_Referrers_context_menu_event(self, event):
        def copy_to_clipboard(row):
            app.clipboard().setText(self.listWidget_Referrers.item(row).text())

        selected_row = GuiUtils.get_current_row(self.listWidget_Referrers)

        menu = QMenu()
        copy_address = menu.addAction("Copy Address")
        if selected_row == -1:
            GuiUtils.delete_menu_entries(menu, [copy_address])
        font_size = self.listWidget_Referrers.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            copy_address: lambda: copy_to_clipboard(selected_row)
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)


class ExamineReferrersWidgetForm(QWidget, ExamineReferrersWidget):
    def __init__(self, int_address, parent=None):
        super().__init__()
        self.setupUi(self)
        self.parent = lambda: parent
        global instances
        instances.append(self)
        GuiUtils.center_to_parent(self)
        self.setWindowFlags(Qt.Window)
        self.splitter.setStretchFactor(0, 1)
        self.textBrowser_DisasInfo.resize(600, self.textBrowser_DisasInfo.height())
        self.referenced_hex = hex(int_address)
        self.hex_len = 16 if GDB_Engine.inferior_arch == type_defs.INFERIOR_ARCH.ARCH_64 else 8
        self.collect_referrer_data()
        self.refresh_table()
        self.listWidget_Referrers.sortItems(Qt.AscendingOrder)
        self.listWidget_Referrers.selectionModel().currentChanged.connect(self.listWidget_Referrers_current_changed)
        self.listWidget_Referrers.itemDoubleClicked.connect(self.listWidget_Referrers_item_double_clicked)
        self.listWidget_Referrers.contextMenuEvent = self.listWidget_Referrers_context_menu_event
        self.pushButton_Search.clicked.connect(self.refresh_table)
        self.shortcut_search = QShortcut(QKeySequence("Return"), self)
        self.shortcut_search.activated.connect(self.refresh_table)

    def pad_hex(self, hex_str):
        index = hex_str.find(" ")
        if index == -1:
            self_len = 0
        else:
            self_len = len(hex_str) - index
        return '0x' + hex_str[2:].zfill(self.hex_len + self_len)

    def collect_referrer_data(self):
        jmp_dict, call_dict = GDB_Engine.get_dissect_code_data(False, True, True)
        self.referrer_data = []
        try:
            jmp_referrers = jmp_dict[self.referenced_hex]
        except KeyError:
            pass
        else:
            jmp_referrers = [hex(item) for item in jmp_referrers]
            self.referrer_data.extend([item.all for item in GDB_Engine.examine_expressions(jmp_referrers)])
        try:
            call_referrers = call_dict[self.referenced_hex]
        except KeyError:
            pass
        else:
            call_referrers = [hex(item) for item in call_referrers]
            self.referrer_data.extend([item.all for item in GDB_Engine.examine_expressions(call_referrers)])
        jmp_dict.close()
        call_dict.close()

    def refresh_table(self):
        searched_str = self.lineEdit_Regex.text()
        case_sensitive = self.checkBox_CaseSensitive.isChecked()
        enable_regex = self.checkBox_Regex.isChecked()
        if enable_regex:
            try:
                if case_sensitive:
                    regex = re.compile(searched_str)
                else:
                    regex = re.compile(searched_str, re.IGNORECASE)
            except:
                QMessageBox.information(self, "Error",
                                        "An exception occurred while trying to compile the given regex\n")
                return
        self.listWidget_Referrers.setSortingEnabled(False)
        self.listWidget_Referrers.clear()
        for row, item in enumerate(self.referrer_data):
            if enable_regex:
                if not regex.search(item):
                    continue
            else:
                if case_sensitive:
                    if item.find(searched_str) == -1:
                        continue
                else:
                    if item.lower().find(searched_str.lower()) == -1:
                        continue
            self.listWidget_Referrers.addItem(item)
        self.listWidget_Referrers.setSortingEnabled(True)
        self.listWidget_Referrers.sortItems(Qt.AscendingOrder)

    def listWidget_Referrers_current_changed(self, QModelIndex_current):
        if QModelIndex_current.row() < 0:
            return
        self.textBrowser_DisasInfo.clear()
        disas_data = GDB_Engine.disassemble(
            SysUtils.extract_address(self.listWidget_Referrers.item(QModelIndex_current.row()).text()), "+200")
        for item in disas_data:
            self.textBrowser_DisasInfo.append(item[0] + item[2])
        cursor = self.textBrowser_DisasInfo.textCursor()
        cursor.movePosition(QTextCursor.Start)
        self.textBrowser_DisasInfo.setTextCursor(cursor)
        self.textBrowser_DisasInfo.ensureCursorVisible()

    def listWidget_Referrers_item_double_clicked(self, item):
        self.parent().disassemble_expression(SysUtils.extract_address(item.text()), append_to_travel_history=True)

    def listWidget_Referrers_context_menu_event(self, event):
        def copy_to_clipboard(row):
            app.clipboard().setText(self.listWidget_Referrers.item(row).text())

        selected_row = GuiUtils.get_current_row(self.listWidget_Referrers)

        menu = QMenu()
        copy_address = menu.addAction("Copy Address")
        if selected_row == -1:
            GuiUtils.delete_menu_entries(menu, [copy_address])
        font_size = self.listWidget_Referrers.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec_(event.globalPos())
        actions = {
            copy_address: lambda: copy_to_clipboard(selected_row)
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def closeEvent(self, QCloseEvent):
        global instances
        instances.remove(self)


def exitHandler():
    global Exiting
    Exiting = 1


if __name__ == "__main__":
    app = QApplication(sys.argv)
    app.aboutToQuit.connect(exitHandler)
    window = MainForm()
    window.show()
    sys.exit(app.exec_())

```

`PINCE.sh`:

```sh
#!/bin/bash
: '
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'

# Change this bullcrap when polkit is implemented
OS=$(lsb_release -si)
# Get rid of gksudo when Debian 8 support drops or polkit gets implemented
if [ $OS = "Debian" ] && [ -x "$(command -v gksudo)" ]; then
  gksudo python3 PINCE.py
else
  sudo -E python3 PINCE.py
fi

```

`README.md`:

```md
# PINCE
<!---
TODO: Include build status with the title when test coverage increases and Travis is maintained
[![Build Status](https://travis-ci.org/korcankaraokcu/PINCE.svg?branch=master)](https://travis-ci.org/korcankaraokcu/PINCE)
-->
PINCE is a front-end/reverse engineering tool for the GNU Project Debugger (GDB), focused on games. However, it can be used for any reverse-engineering related stuff. PINCE is an abbreviation for "PINCE is not Cheat Engine". PINCE is in development right now, read [Features](#features) part of the project to see what is done and [Roadmap](#current-roadmap) part to see what is currently planned. Also, please read [Wiki Page](https://github.com/korcankaraokcu/PINCE/wiki) of the project to understand how PINCE works.  

### [Feel free to join our discord server!](https://discord.gg/KCNDp9m)  

*Disclaimer: Do not trust to any source other than [Trusted Sources](#trusted-sources) that claims to have the source code or package for PINCE and remember to report them **immediately***

*Disclaimer: **YOU** are responsible for your actions. PINCE does **NOT** take any responsibility for the damage caused by the users*

Pre-release screenshots:  
![](media/screenshots/pince.png)
![](media/screenshots/pince1.png)
![](media/screenshots/pince2.png)
![](media/screenshots/pince3.png)
![](media/screenshots/pince4.png)
![](media/screenshots/pince5.png)
![](media/screenshots/pince6.png)
![](media/screenshots/pince7.png)
![](media/screenshots/pince8.png)
![](media/screenshots/pince9.png)
# Features  
- **Memory searching:** PINCE uses [libscanmem](https://github.com/scanmem/scanmem) to search the memory efficiently **[Done]**
- **Variable Inspection&Modification** **[Done/Basic]**
  * **CheatEngine-like value type support:** Currently supports all types of CE and scanmem along with extended strings(utf-8, utf-16, utf-32) **[Done]**
  * **Symbol Recognition:** See [here](https://github.com/korcankaraokcu/PINCE/wiki/About-GDB-Expressions) **[Done]**
  * **Automatic Variable Allocation:** See [here](https://github.com/korcankaraokcu/PINCE/wiki/About-GDB-Expressions) **[Done]**
  * **Dynamic Address Table:** Supports drag&drop, recursive copy&pasting&inserting and many more **[Done]**
  * **Smart casting:** PINCE lets you modify multiple different-type values together as long as the input is parsable. All parsing/memory errors are directed to the terminal **[Done]**
  * **Continuous Address Table Update:** You can adjust update timer or cancel updating by modifying settings **[Done]**
  * **Variable Locking:** PINCE lets you freeze(constantly write a value to memory cell) variables **[Done]**
- **Memory View** **[Done/Basic]**
  * **Infinite Scrolling:** PINCE automatically disassembles the next available instruction(s) on mouse wheel/scrollbar move. Instruction count can be changed from settings. Hex View also supports this feature **[Done]**
  * **Dissect Code:** You can dissect desired memory regions to find referenced calls, jumps and strings. Disassemble screen will automatically handle the referenced data and show you if there's a referenced address in the current dissasemble view. It can be used from Tools->Dissect Code in the MemoryView window. Using its hotkey instead in the MemoryView window automatically dissects the currently viewed region. You can separately view referenced calls and strings after the search from View->Referenced Calls/Strings. *Note: If you decide to uncheck 'Discard invalid strings' before the search, PINCE will try to search for regular pointers as well* **[Done]**
  * **Bookmarking:** Bookmark menu is dynamically created when right clicked in the disassemble screen. So unlike Cheat Engine, PINCE lets you set unlimited number of bookmarks. List of bookmarks can also be viewed from View->Bookmarks in the MemoryView window. Commenting on an address automatically bookmarks it. **[Done]**
  * **Modify on the fly:** PINCE lets you modify registers on the fly. Unlike CE, you can also change XMM and FPU registers. Check [GDB expressions in the Wiki page](https://github.com/korcankaraokcu/PINCE/wiki/About-GDB-Expressions) for additional information **[Done]**
  * **Opcode Search:** You can search opcodes with python regular expressions. To use this feature, click Tools->Search Opcode in the MemoryView window. **[Done]**  
- **Debugging** **[Done/Basic]**
  * Has basic debugging features such as stepping, stepping over, execute till return, break, continue. Also has breakpoints, watchpoints and breakpoint conditions. Has advanced debugging utilities such as Watchpoint/Breakpoint Tracking and Tracing
  * **Chained Breakpoints:** Just like CE, PINCE allows you to set multiple, connected breakpoints at once. If an event(such as condition modification or deletion) happens in one of the breakpoints, other connected breakpoints will get affected as well **[Done]**
  * **Watchpoint Tracking:** Allows you to see which instructions have been accessing to the specified address, just like "What accesses/writes to this address" feature in CE **[Done]**
  * **Breakpoint Tracking:** Allows you to track down addresses calculated by the given register expressions at the specified instruction, just like "Find out what addresses this instruction accesses" feature in CE with a little addon, you can enter multiple register expressions, this allows you to check the value of "esi" even if the instruction is something irrelevant like "mov [eax],edx" **[Done]**
  * **Tracing:** Almost the same with CE. But unlike CE, you can stop tracing whenever you want. Created from scratch with shittons of custom features instead of using gdb's trace&collect commands because some people have too much time on their hands **[Done]**
  * **Collision Detection:** GDB normally permits setting unlimited watchpoints next to each other. But this behaviour leads to unexpected outcomes such as causing GDB or the inferior become completely inoperable. GDB also doesn't care about the number(max 4) or the size(x86->max 4, x64->max 8) of hardware breakpoints. Fortunately, PINCE checks for these problems whenever you set a new breakpoint and detects them before they happen and then inhibits them in a smart way. Lets say you want to set a breakpoint in the size of 32 bytes. But the maximum size for a breakpoint is 8! So, PINCE creates 4 different breakpoints with the size of 8 bytes and then chains them for future actions **[Done]**
- **Code Injection** **[Working on it]**
  * **Run-time injection:** Only .so injection is supported for now. In Memory View window, click Tools->Inject .so file to select the .so file. An example for creating .so file can be found in "libpince/Injection/". PINCE will be able to inject single line instructions or code caves in near future **[Partially Done?]**
- **GDB Console** **[Done]**
  * Is the power of PINCE not enough for you? Then you can use the gdb console provided by PINCE, it's on the top right in main window
- **Simplified/Optimized gdb command alternatives** **[Working on it]**
  * Custom scripts instead of using gdb's x command for reading memory **[Done]**
  * Custom scripts instead of using gdb's set command for modifying memory **[Done]**
- **libpince - A reusable python library**
  * PINCE provides a reusable python library. You can either read the code or check Reference Widget by clicking Help->libpince in Memory Viewer window to see docstrings. Contents of this widget is automatically generated by looking at the docstrings of the source files. PINCE has a unique parsing technique that allows parsing variables. Check the function get_comments_of_variables in SysUtils for the details. This feature might be replaced with Sphinx in the future
- **Extendable with .so files at runtime**
  * See [here](https://github.com/korcankaraokcu/PINCE/wiki/Extending-PINCE-with-.so-files)
- **Automatic Trainer Generation:** **[Planned]**  
  * PINCE provides a trainer auto-generated from current address table on demand by using libpince and PyQT5 together

# Installing
Clone this repo by running `git clone --recursive https://github.com/korcankaraokcu/PINCE` then run ```sudo sh install_pince.sh``` in the PINCE directory. For Archlinux, you can also use the [AUR package](https://aur.archlinux.org/packages/pince-git/) as an alternative.

If you like to uninstall PINCE, just delete this folder, almost everything is installed locally. Config and user files of PINCE can be found in "~/.config/PINCE", you can manually delete them if you want.

***Notes:***
- GDB enhancements (peda, pwndbg, etc) that use a global gdbinit file might cause PINCE to misfunction at times. Please disable them or use them locally before starting PINCE
- If you are having problems with your default gdb version, you can use the `install_gdb.sh` script to install another version locally. Read the comments in it for more information
- Check https://github.com/korcankaraokcu/PINCE/issues/116 for a possible fix if you encounter `'GtkSettings' has no property named 'gtk-fallback-icon-theme'`

# Running PINCE  
Just run ```sh PINCE.sh``` in the PINCE directory

### For developers:  
```
sudo apt-get install qttools5-dev-tools (qt5 form designer)
sudo apt-get install pyqt5-dev-tools (pyuic5)
sudo pip3 install line_profiler (for performance testing)
```
How to use line_profiler: Add ```@profile``` tag to the desired function and run PINCE with ```sudo kernprof -l -v PINCE.py```
# History
- A few weeks till 17/01/2016 : Learned GDB, process of analysis
- 17/01/2016-22/01/2016 : Basic design, grasping of Python3 and Pyqt5, proof-testing
- 22/01/2016 : First commit
- 19/02/2016 : Moved to Github from Bitbucket
- 25/02/2016 : First successful implementation of thread injection[Update-08/05/2016 : PINCE now uses ```linux-inject``` as a secondary injection method]  
- 18/06/2016 : PINCE now supports all-stop mode instead of non-stop mode
- 21/06/2016 : Variable Inspection&Modification is finished(At basic level)  
- 21/08/2016 : Memory View is finished(At basic level)
- 24/08/2016 : PINCE no more uses linux-inject because of stability issues(a fix for the [race conditions in the inferior](https://github.com/gaffe23/linux-inject/issues/7) would be nice)
- 26/12/2016 : Debugging is finished(At basic level)  
- 19/05/2020 : libscanmem integration is complete, enjoy memory searching. Huge thanks to fisu, xk and 12345ieee (libscanmem team)  

# Current Roadmap
- Refactor file naming conventions(decide on snake_case or camelCase for modules etc)
- Create ```CONTRIBUTING.md``` and combine all non-tutorial notes within it
- Refactorize memory write/read functions
- - ReferencedStringsWidgetForm refreshes the cache everytime the comboBox_ValueType changes, this creates serious performance issues if total results are more than 800k. Only update the visible rows to prevent this(check ```disassemble_check_viewport``` for an example)
- - Implement same system for the TrackBreakpointWidgetForm if necessary. Do performance tests
- - Consider using a class instead of primitive return types to store the raw bytes. This class should also include a method to display None type as red '??' text for Qt
- - Provide an option to cut BOM bytes when writing to memory with the types UTF-16 and UTF-32
- - Put a warning for users about replacement bytes for non UTF-8 types
- - Extend string types with LE and BE variants of UTF-16 and UTF-32
- - Change comboBox_ValueType string order to be ... String_UTF-8 String_Others Array of Bytes
- - Implement a custom combobox class for comboBox_ValueType and create a context menu for String_Others item
- Indent docstrings properly like GDB_Engine.get_breakpoint_info does(independent from other steps)
- Implement "Investigate Registers" button to gather information about the addresses registers point to(independent from other steps)
- Implement selectionChanged signal of lineEdit_HexView
- Implement multi selection for HexView
- Add the ability to track down registers and addresses in tracer(unsure)(independent from other steps)
- Implement CE's Ultimap-like feature for tracing data, dissect code data and raw instruction list. Search for calls and store their hit counts to filter out the functions that haven't or have executed specific number of times. Implement a flexible input field for the execution count. For instance, 2^x only searches for hit counts 2, 4, 8 and so on, 3x only searches for 3, 6, 9 etc.(independent from other steps)([CE#358](https://github.com/cheat-engine/cheat-engine/issues/358))
- Extend search_referenced_strings with relative search
- Consider adding type guessing for the StackView(independent from other steps)
- Move GUI classes of PINCE.py to their own files
- Handle signals and internal errors that causes gdb to halt, such as SIGSEGV and overlapping breakpoints(independent from other steps)
- Use gdb python API breakpoints instead of breakpoint commands for optimization, also find a way to eliminate output coming from stepping commands such as ```stepi``` or ```nexti```(independent from other steps)
- Implement a psuedo-terminal for the inferior like edb does(independent from other steps)
- Implement libpince engine
- Implement auto-ESP&aimbot (depends on libpince engine)
- Try to optimize TrackBreakpoint and TrackWatchpoint return data structures further, adding an id field might simplify traversing of the tree, performance tests are required(independent from other steps)
- Extend tagging system to PINCE GUI functions
- Implement inject_with_advanced_injection(independent from other steps)
- Implement single-line code injection
- Implement multi-line code injection
- Break on/Catch signals and syscalls
- Move non-communication functions in GDB_Engine to ScriptUtils and create corresponding fields in GDB_Engine and GDBCommandExtensions automatically. This lets entire functionality of libpince to be used with both python scripts and gdb python scripts, thus allowing it to be used as a plugin for projects such as radare2
- Flowcharts based on disassembled output
- Automatic function bypassing(make it return the desired value, hook specific parts etc.)
- Implement speedhack(independent from other steps)
- Implement unrandomizer(independent from other steps)
- Implement pointer-scan
- Write at least one test for each function in libpince
- Migrate to Sphinx documentation from the custom libpince documentation(independent from other steps)
- Embedded tutorial videos
- Super-Uber-Rad credits roll with chiptune tunes
- Implement extra MemoryViewerWindow tabs(independent from other steps)
- ~~Consider removing the command file layer of IPC system for GDB_Engine.send_command to speed up things~~(independent from other steps)[Update-29/04/2018 : Delaying this until GDB/MI implements a native multiline command feature or improves ```interpreter-exec``` command to cover every single multiline command type(including ```define``` commands)]
- Implement thread info widget
- Add ability to change logo and other assets if people contribute more than one asset per usage. Also consider using [PINCE-media](https://github.com/korcankaraokcu/PINCE-media) for development if needed(independent from other steps)
- Implement developer mode in settings. Developer mode will include features like dissection of GUI elements on events such as mouse-over(independent from other steps)
- Add ability to include non-absolute calls for dissect code feature(i.e call rax). Should be considered after the first version release. Might be useful for multi-breakpoint related features
- Implement toggling of arrows for easier navigation for dissected regions(independent from other steps)
- Provide information about absolute addresses in disassemble screen(independent from other steps)
- Use type hints(py 3.5) and variable annotations(py 3.6) when support drops for older systems(independent from other steps)
- All tables that hold large amount of data should only update the visible rows(check ```disassemble_check_viewport``` for an example)(independent from other steps)
- Add different kinds of themes and the ability to change between them on runtime. Implement dark theme first. Also add the ability to create a custom theme and modify the existing ones(independent from other steps)

# License
GPLv3+. See COPYING file for details

# Contact Information
Korcan Karaokçu([korcankaraokcu](https://github.com/korcankaraokcu)) <korcankaraokcu@gmail.com>  
Çağrı Ulaş([cagriulas](https://github.com/cagriulas)) <cagriulas@gmail.com>  
Jakob Kreuze([TsarFox](https://github.com/TsarFox)) <jakob@memeware.net>  
Gibus <lilac66.dev@gmail.com>  

# Supported platforms
- Ubuntu and its flavors, actively tested on Kubuntu
- Debian and Debian-based (Kali, Mint etc.)
- Archlinux(tag [cagriulas](https://github.com/cagriulas) or [TsarFox](https://github.com/TsarFox) when creating an issue)
- SUSE

# Trusted Sources
  * [Official github page](https://github.com/korcankaraokcu/PINCE)
  * [AUR package for Archlinux](https://aur.archlinux.org/packages/pince-git/)

```

`THANKS`:

```
Sebastian Parschauer <s.parschauer@gmx.de>
Andrea Stacchiotti <https://github.com/12345ieee>
XutaxKamay <https://github.com/XutaxKamay>
Salih Marangoz <salihmarangoz.github@gmail.com>
Hjalte Skjold Hørsdal <hjaltello@gmail.com>
Juuso Lapinlampi <wub@partyvan.eu>
Özcan Esen <ozcanesen@gmail.com>

```

`install_gdb.sh`:

```sh
#!/bin/bash
: '
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'

# This script installs a specific gdb version locally, the default installation script doesn't need this anymore, you can use it as a fallback if system gdb is being problematic
# After installing a local gdb, you must specify its binary location via the Settings->Debug

GDB_VERSION="gdb-10.2"

mkdir -p gdb_pince
cd gdb_pince

# clean the directory if another installation happened
rm -rf $GDB_VERSION

if [ ! -e ${GDB_VERSION}.tar.gz ] ; then
    wget "http://ftp.gnu.org/gnu/gdb/${GDB_VERSION}.tar.gz"
fi
tar -zxvf ${GDB_VERSION}.tar.gz
cd $GDB_VERSION
echo "-------------------------------------------------------------------------"
echo "DISCLAIMER"
echo "-------------------------------------------------------------------------"
echo "If you're not on debian or a similar distro with the 'apt' package manager the follow will not work if you don't have gcc and g++ installed"
echo "Please install them manually for this to work, this issue will be addressed at a later date"
command -v gcc g++ # extremely lazy fix for other distros, if gcc&g++ is available it will work, if not it won't
if [ $? -gt 0 ]; then
    # Dependencies required for compiling GDB
    sudo apt-get install python3-dev
    sudo apt-get install gcc g++
    if [ $? -gt 0 ]; then
        sudo apt-get install software-properties-common
        sudo add-apt-repository ppa:ubuntu-toolchain-r/test
        sudo apt-get update
        sudo apt-get install gcc g++
        if [ $? -gt 0 ]; then
            echo "Failed to install gcc or g++, aborting..."
            exit 1
        fi
    fi
fi
CC=gcc CXX=g++ ./configure --prefix="$(pwd)" --with-python=python3 && make -j $(grep -m 1 "cpu cores" /proc/cpuinfo | cut -d: -f 2 | xargs) MAKEINFO=true && sudo make -C gdb install
if [ ! -e bin/gdb ] ; then
    echo "Failed to install GDB, restart the installation process"
    exit 1
fi

# In case of python part of gdb installation fails
sudo cp -R gdb/data-directory/* share/gdb/

```

`install_pince.sh`:

```sh
#!/bin/bash
: '
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'

# this file cannot (or any file) be named `install.sh` since libtoolize(automake) will not work properly if it does
# it will create the necessary files in PINCEs directory instead of scanmems, which will result in having to run `sh autogen.sh`
# twice, see this link https://github.com/protocolbuffers/protobuf/issues/149#issuecomment-473092810


CURRENT_USER="$(who mom likes | awk '{print $1}')"

# assumes you're in scanmem directory
compile_scanmem() {
    sh autogen.sh
    ./configure --prefix="$(pwd)"
    make -j $(grep -m 1 "cpu cores" /proc/cpuinfo | cut -d: -f 2 | xargs) libscanmem.la
    chown -R "${CURRENT_USER}":"${CURRENT_USER}" . # give permissions for normal user to change file
}

install_scanmem() {
    echo "Downloading scanmem"
    git submodule update --init --recursive
    
    if [ ! -d "libpince/libscanmem" ]; then
        mkdir libpince/libscanmem
        chown -R "${CURRENT_USER}":"${CURRENT_USER}" libpince/libscanmem
    fi
    (
        echo "Entering scanmem"
        cd scanmem || exit
        if [ -d "./.libs" ]; then 
            echo "Recompile scanmem? [y/n]"
            read -r answer
            if echo "$answer" | grep -iq "^[Yy]"; then
                compile_scanmem
            fi
        else
            compile_scanmem
        fi
        cp --preserve .libs/libscanmem.so ../libpince/libscanmem/libscanmem.so
        cp --preserve gui/scanmem.py ../libpince/libscanmem
        cp --preserve gui/misc.py ../libpince/libscanmem
        echo "Exitting scanmem"
    )
    # required for relative import, since it will throw an import error if it's just `import misc`
    sed -i 's/import misc/from \. import misc/g' libpince/libscanmem/scanmem.py
}

OS_NAME="Debian"
PKG_MGR="apt-get"
INSTALL_COMMAND="install"

PKG_NAMES_ALL="python3-pip gdb"
PKG_NAMES_DEBIAN="$PKG_NAMES_ALL python3-pyqt5 libtool libreadline-dev intltool"
PKG_NAMES_SUSE="$PKG_NAMES_ALL python3-qt5"
PKG_NAMES_ARCH="python-pip python-pyqt5 readline intltool gdb lsb-release" # arch defaults to py3 nowadays
PKG_NAMES="$PKG_NAMES_DEBIAN"
PKG_NAMES_PIP="psutil pexpect distorm3 pygdbmi keyboard"
PIP_COMMAND="pip3"

LSB_RELEASE="$(command -v lsb_release)"
if [ -n "$LSB_RELEASE" ] ; then
    OS_NAME="$(${LSB_RELEASE} -d -s)"
else
    . /etc/os-release
    OS_NAME="$NAME"
fi

case "$OS_NAME" in
*SUSE*)
    PKG_MGR="zypper"
    PKG_NAMES="$PKG_NAMES_SUSE"
    ;;
*Arch*)
    PKG_MGR="pacman"
    PKG_NAMES="$PKG_NAMES_ARCH"
    INSTALL_COMMAND="-S"
    PIP_COMMAND="pip"
    ;;
esac

sudo ${PKG_MGR} ${INSTALL_COMMAND} ${PKG_NAMES}
sudo ${PIP_COMMAND} install ${PKG_NAMES_PIP}

install_scanmem

echo "PINCE has been installed successfully!"
echo "Now, just run 'sh PINCE.sh' from terminal"

```

`libpince/GDB_Engine.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from threading import Lock, Thread, Condition
from time import sleep, time
from collections import OrderedDict, defaultdict
import pexpect, os, ctypes, pickle, json, shelve, re, struct, io
from . import SysUtils, type_defs, common_regexes

self_pid = os.getpid()
libc = ctypes.CDLL('libc.so.6')

#:tag:GDBInformation
#:doc:
# A boolean value. True if gdb is initialized, False if not
gdb_initialized = False

#:tag:InferiorInformation
#:doc:
# An integer. Can be a member of type_defs.INFERIOR_ARCH
inferior_arch = int

#:tag:InferiorInformation
#:doc:
# An integer. Can be a member of type_defs.INFERIOR_STATUS
inferior_status = -1

#:tag:InferiorInformation
#:doc:
# An integer. PID of the current attached/created process
currentpid = -1

#:tag:GDBInformation
#:doc:
# An integer. Can be a member of type_defs.STOP_REASON
stop_reason = int

#:tag:GDBInformation
#:doc:
# A dictionary. Holds breakpoint addresses and what to do on hit
# Format: {address1:on_hit1, address2:on_hit2, ...}
breakpoint_on_hit_dict = {}

#:tag:GDBInformation
#:doc:
# A dictionary. Holds address and aob of instructions that were nop'ed out
# Format: {address1:orig_instruction1_aob, address2:orig_instruction2_aob, ...}
noped_instructions_dict = {}

#:tag:GDBInformation
#:doc:
# If an action such as deletion or condition modification happens in one of the breakpoints in a list, others in the
# same list will get affected as well
# Format: [[[address1, size1], [address2, size2], ...], [[address1, size1], ...], ...]
chained_breakpoints = []

child = object  # this object will be used with pexpect operations

#:tag:ConditionsLocks
#:doc:
# This Lock is used by the function send_command to ensure synchronous execution
lock_send_command = Lock()

#:tag:ConditionsLocks
#:doc:
# This condition is notified whenever status of the inferior changes
# Use the variable inferior_status to get information about inferior's status
# See PINCE's CheckInferiorStatus class for an example
status_changed_condition = Condition()

#:tag:ConditionsLocks
#:doc:
# This condition is notified if the current inferior gets terminated
# See PINCE's AwaitProcessExit class for an example
process_exited_condition = Condition()

#:tag:ConditionsLocks
#:doc:
# This condition is notified if gdb starts to wait for the prompt output
# See function send_command for an example
gdb_waiting_for_prompt_condition = Condition()

#:tag:GDBInformation
#:doc:
# A string. Stores the output of the last command
gdb_output = ""

#:tag:GDBInformation
#:doc:
# An instance of type_defs.RegisterQueue. Updated whenever GDB receives an async event such as breakpoint modification
# See PINCE's AwaitAsyncOutput class for an example of usage
gdb_async_output = type_defs.RegisterQueue()

#:tag:GDBInformation
#:doc:
# A boolean value. Used to cancel the last gdb command sent
# Use the function cancel_last_command to make use of this variable
# Return value of the current send_command call will be an empty string
cancel_send_command = False

#:tag:GDBInformation
#:doc:
# A string. Holds the last command sent to gdb
last_gdb_command = ""

#:tag:GDBInformation
#:doc:
# A list of booleans. Used to adjust gdb output
# Use the function set_gdb_output_mode to make use of this variable
gdb_output_mode = type_defs.gdb_output_mode(True, True, True)

#:tag:InferiorInformation
#:doc:
# A string. memory file of the currently attached/created process
mem_file = "/proc/" + str(currentpid) + "/mem"

'''
When PINCE was first launched, it used gdb 7.7.1, which is a very outdated version of gdb
interpreter-exec mi command of gdb showed some buggy behaviour at that time
Because of that, PINCE couldn't support gdb/mi commands for a while
But PINCE is now updated with the new versions of gdb as much as possible and the interpreter-exec works much better
So, old parts of codebase still get their required information by parsing gdb console output
New parts can try to rely on gdb/mi output
'''


#:tag:GDBCommunication
def set_gdb_output_mode(output_mode_tuple):
    """Adjusts gdb output

    Args:
        output_mode_tuple (type_defs.gdb_output_mode): Setting any field True will enable the output that's associated
        with that field. Setting it False will disable the associated output
    """
    global gdb_output_mode
    gdb_output_mode = output_mode_tuple


#:tag:GDBCommunication
def cancel_last_command():
    """Cancels the last gdb command sent if it's still present"""
    if lock_send_command.locked():
        global cancel_send_command
        cancel_send_command = True


#:tag:GDBCommunication
def send_command(command, control=False, cli_output=False, send_with_file=False, file_contents_send=None,
                 recv_with_file=False):
    """Issues the command sent, raises an exception if the inferior is running or no inferior has been selected

    Args:
        command (str): The command that'll be sent
        control (bool): This param should be True if the command sent is ctrl+key instead of the regular command
        cli_output (bool): If True, returns the readable parsed cli output instead of gdb/mi garbage
        send_with_file (bool): Custom commands declared in GDBCommandExtensions.py requires file communication. If
        called command has any parameters, pass this as True
        file_contents_send (any type that pickle.dump supports): Arguments for the called custom gdb command
        recv_with_file (bool): Pass this as True if the called custom gdb command returns something

    Examples:
        send_command(c,control=True)--> Sends ctrl+c instead of the str "c"
        send_command("pince-read-addresses", file_contents_send=nested_list, recv_file=True)--> This line calls the
        custom gdb command "pince-read-addresses" with parameter nested_list and since that gdb command returns the
        addresses read as a list, we also pass the parameter recv_file as True

    Returns:
        str: Result of the command sent, commands in the form of "ctrl+key" always returns a null string
        ???: If recv_with_file is True. Content of the returned thing depends on the command sent

    Note:
        TODO:This bug doesn't seem like to exist anymore. Remove the unnecessary file communication layer of IPC
        File communication system is used to avoid BEL emitting bug of pexpect. If you send more than a certain amount
        of characters to gdb, the input will be sheared at somewhere and gdb won't be receiving all of the input
        Visit this page for more information-->http://pexpect.readthedocs.io/en/stable/commonissues.html

        You don't have to write interpreter-exec while sending a gdb/mi command. Just pass the gdb/mi command as itself.
        This function will convert it automatically.
    """
    global child
    global gdb_output
    global cancel_send_command
    global last_gdb_command
    with lock_send_command:
        if gdb_output_mode.command_info:
            time0 = time()
        if not gdb_initialized:
            raise type_defs.GDBInitializeException
        if inferior_status is type_defs.INFERIOR_STATUS.INFERIOR_RUNNING and not control:
            raise type_defs.InferiorRunningException
        gdb_output = ""
        if send_with_file:
            send_file = SysUtils.get_IPC_from_PINCE_file(currentpid)
            pickle.dump(file_contents_send, open(send_file, "wb"))
        if recv_with_file or cli_output:
            recv_file = SysUtils.get_IPC_to_PINCE_file(currentpid)

            # Truncating the recv_file because we wouldn't like to see output of previous command in case of errors
            open(recv_file, "w").close()
        command = str(command)
        command = 'interpreter-exec mi "' + command + '"' if command.startswith("-") else command
        last_gdb_command = command if not control else "Ctrl+" + command
        if gdb_output_mode.command_info:
            print("Last command: " + last_gdb_command)
        if control:
            child.sendcontrol(command)
        else:
            command_file = SysUtils.get_gdb_command_file(currentpid)
            command_fd = open(command_file, "r+")
            command_fd.truncate()
            command_fd.write(command)
            command_fd.close()
            if not cli_output:
                child.sendline("source " + command_file)
            else:
                child.sendline("cli-output source " + command_file)
        if not control:
            while not gdb_output:
                sleep(type_defs.CONST_TIME.GDB_INPUT_SLEEP)
                if cancel_send_command:
                    break
            if not cancel_send_command:
                if recv_with_file or cli_output:
                    output = pickle.load(open(recv_file, "rb"))
                else:
                    output = gdb_output
            else:
                output = ""
                child.sendcontrol("c")
                with gdb_waiting_for_prompt_condition:
                    gdb_waiting_for_prompt_condition.wait()
        else:
            output = ""
        if gdb_output_mode.command_info:
            time1 = time()
            try:
                print(time1 - time0)
            except NameError:
                pass
        cancel_send_command = False
        return output


def await_process_exit():
    """
    Checks if the current inferior is alive, uses conditions to inform other functions and threads about inferiors state
    Detaches if the current inferior dies while attached
    Should be called by creating a thread. Usually called in initialization process by attach function
    """
    while True:
        if currentpid == -1 or SysUtils.is_process_valid(currentpid):
            sleep(0.1)
        else:
            with process_exited_condition:
                print("Process terminated (PID:" + str(currentpid) + ")")
                process_exited_condition.notify_all()
                detach()
                break


def state_observe_thread():
    """
    Observes the state of gdb, uses conditions to inform other functions and threads about gdb's state
    Also generates output for send_command function
    Should be called by creating a thread. Usually called in initialization process by attach function
    """

    def check_inferior_status(cache=None):
        if cache:
            data = cache
        else:
            data = child.before
        matches = common_regexes.gdb_state_observe.findall(data)
        if len(matches) > 0:
            global stop_reason
            global inferior_status

            if matches[-1][0]:  # stopped
                stop_reason = type_defs.STOP_REASON.DEBUG
                inferior_status = type_defs.INFERIOR_STATUS.INFERIOR_STOPPED
            else:
                inferior_status = type_defs.INFERIOR_STATUS.INFERIOR_RUNNING
            with status_changed_condition:
                status_changed_condition.notify_all()

    global child
    global gdb_output
    stored_output = ""
    while True:
        child.expect_exact("\r\n")  # A new line for TTY devices
        child.before = child.before.strip()
        if not child.before:
            continue
        stored_output += "\n" + child.before
        if child.before == "(gdb)":
            check_inferior_status(stored_output)
            stored_output = ""
            continue
        command_file = re.escape(SysUtils.get_gdb_command_file(currentpid))
        if common_regexes.gdb_command_source(command_file).search(child.before):
            child.expect_exact("(gdb)")
            child.before = child.before.strip()
            check_inferior_status()
            gdb_output = child.before
            stored_output = ""
            with gdb_waiting_for_prompt_condition:
                gdb_waiting_for_prompt_condition.notify_all()
            if gdb_output_mode.command_output:
                print(child.before)
        else:
            if gdb_output_mode.async_output:
                print(child.before)
            gdb_async_output.broadcast_message(child.before)


def execute_with_temporary_interruption(func):
    """Decorator version of execute_func_temporary_interruption"""

    def wrapper(*args, **kwargs):
        execute_func_temporary_interruption(func, *args, **kwargs)

    return wrapper


#:tag:GDBCommunication
def execute_func_temporary_interruption(func, *args, **kwargs):
    """Interrupts the inferior before executing the given function, continues inferior's execution after calling the
    given function

    !!!WARNING!!! This function is NOT thread-safe. Use it with caution!

    Args:
        func (function): The function that'll be called between interrupt&continue routine
        *args (args): Arguments for the function that'll be called
        **kwargs (kwargs): Keyword arguments for the function that'll be called

    Returns:
        ???: Result of the given function. Return type depends on the given function
    """
    old_status = inferior_status
    if old_status == type_defs.INFERIOR_STATUS.INFERIOR_RUNNING:
        ___internal_interrupt_inferior(type_defs.STOP_REASON.PAUSE)
    result = func(*args, **kwargs)
    if old_status == type_defs.INFERIOR_STATUS.INFERIOR_RUNNING:
        try:
            ___internal_continue_inferior()
        except type_defs.InferiorRunningException:
            pass
    return result


#:tag:Debug
def ___internal_continue_inferior():
    """
        Continue the inferior
        DOES NOT TOGGLE temporary_execution_condition
        you should always use the real one
        if you don't toggle the temporary_execution_condition it will never be able to break
    """

    send_command("c")


#:tag:Debug
def ___internal_interrupt_inferior(interrupt_reason=type_defs.STOP_REASON.DEBUG):
    """Interrupt the inferior 
    see notes on ___internal_continue_inferior
    Args:
        interrupt_reason (int): Just changes the global variable stop_reason. Can be a member of type_defs.STOP_REASON
    """
    global stop_reason
    send_command("c", control=True)
    wait_for_stop()
    stop_reason = interrupt_reason


#:tag:Debug
def can_attach(pid):
    """Check if we can attach to the target

    Args:
        pid (int,str): PID of the process that'll be attached

    Returns:
        bool: True if attaching is successful, False otherwise
    """
    result = libc.ptrace(16, int(pid), 0, 0)  # 16 is PTRACE_ATTACH, check ptrace.h for details
    if result == -1:
        return False
    os.waitpid(int(pid), 0)
    libc.ptrace(17, int(pid), 0, 17)  # 17 is PTRACE_DETACH, check ptrace.h for details
    sleep(0.01)
    return True


#:tag:Debug
def wait_for_stop(timeout=1):
    """Block execution till the inferior stops

    Args:
        timeout (float): Timeout time in seconds
    """
    remaining_time = timeout
    while inferior_status == type_defs.INFERIOR_STATUS.INFERIOR_RUNNING:
        sleep(type_defs.CONST_TIME.GDB_INPUT_SLEEP)
        remaining_time -= type_defs.CONST_TIME.GDB_INPUT_SLEEP
        if remaining_time < 0:
            break


#:tag:Debug
def interrupt_inferior(interrupt_reason=type_defs.STOP_REASON.DEBUG):
    """Interrupt the inferior

    Args:
        interrupt_reason (int): Just changes the global variable stop_reason. Can be a member of type_defs.STOP_REASON
    """
    global stop_reason
    send_command("c", control=True)
    wait_for_stop()
    stop_reason = interrupt_reason


#:tag:Debug
def continue_inferior():
    """Continue the inferior"""
    send_command("c")


#:tag:Debug
def step_instruction():
    """Step one assembly instruction"""
    send_command("stepi")


#:tag:Debug
def step_over_instruction():
    """Step over one assembly instruction"""
    send_command("nexti")


#:tag:Debug
def execute_till_return():
    """Continues inferior till current stack frame returns"""
    send_command("finish")


#:tag:Debug
def ignore_signal(signal_name):
    """Ignores the given signal

    Args:
        signal_name (str): Name of the ignored signal
    """
    send_command("handle " + signal_name + " nostop noprint")


#:tag:Debug
def unignore_signal(signal_name):
    """Unignores the given signal

    Args:
        signal_name (str): Name of the unignored signal
    """
    send_command("handle " + signal_name + " stop print")


#:tag:GDBCommunication
def init_gdb(gdb_path=type_defs.PATHS.GDB_PATH):
    r"""Spawns gdb and initializes/resets some of the global variables

    Args:
        gdb_path (str): Path of the gdb binary

    Note:
        Calling init_gdb() will reset the current session
    """
    global child
    global gdb_initialized
    global breakpoint_on_hit_dict
    global chained_breakpoints
    global gdb_output
    global cancel_send_command
    global last_gdb_command
    SysUtils.init_user_files()
    detach()

    # Temporary IPC_PATH, this little hack is needed because send_command requires a valid IPC_PATH
    SysUtils.create_PINCE_IPC_PATH(currentpid)

    breakpoint_on_hit_dict.clear()
    chained_breakpoints.clear()
    gdb_output = ""
    cancel_send_command = False
    last_gdb_command = ""

    libpince_dir = SysUtils.get_libpince_directory()
    child = pexpect.spawn('sudo LC_NUMERIC=C ' + gdb_path + ' --interpreter=mi', cwd=libpince_dir,
                          encoding="utf-8")
    child.setecho(False)
    child.delaybeforesend = 0
    child.timeout = None
    child.expect_exact("(gdb)")
    status_thread = Thread(target=state_observe_thread)
    status_thread.daemon = True
    status_thread.start()
    gdb_initialized = True
    set_logging(False)
    send_command("source " + SysUtils.get_user_path(type_defs.USER_PATHS.GDBINIT_PATH))
    SysUtils.execute_script(SysUtils.get_user_path(type_defs.USER_PATHS.PINCEINIT_PATH))


#:tag:GDBCommunication
def set_logging(state):
    """Sets logging on or off

    Args:
        state (bool): Sets logging on if True, off if False
    """
    send_command("set logging off")
    send_command("set logging file " + SysUtils.get_logging_file(currentpid))
    if state:
        send_command("set logging on")


#:tag:GDBCommunication
def set_pince_paths():
    """Initializes $PINCE_PATH and $GDBINIT_AA_PATH convenience variables to make commands in GDBCommandExtensions.py
    and ScriptUtils.py work. GDB scripts need to know libpince and .config directories, unfortunately they don't start
    from the place where script exists
    """
    libpince_dir = SysUtils.get_libpince_directory()
    pince_dir = os.path.dirname(libpince_dir)
    gdbinit_aa_dir = SysUtils.get_user_path(type_defs.USER_PATHS.GDBINIT_AA_PATH)
    send_command('set $GDBINIT_AA_PATH=' + '"' + gdbinit_aa_dir + '"')
    send_command('set $PINCE_PATH=' + '"' + pince_dir + '"')
    send_command("source gdb_python_scripts/GDBCommandExtensions.py")


def init_referenced_dicts(pid):
    """Initializes referenced dict shelve databases

    Args:
        pid (int,str): PID of the attached process
    """
    shelve.open(SysUtils.get_referenced_strings_file(pid), "c")
    shelve.open(SysUtils.get_referenced_jumps_file(pid), "c")
    shelve.open(SysUtils.get_referenced_calls_file(pid), "c")


#:tag:Debug
def attach(pid, gdb_path=type_defs.PATHS.GDB_PATH):
    r"""Attaches gdb to the target and initializes some of the global variables

    Args:
        pid (int,str): PID of the process that'll be attached to
        gdb_path (str): Path of the gdb binary

    Returns:
        tuple: (A member of type_defs.ATTACH_RESULT, result_message)

    Note:
        If gdb is already initialized, gdb_path will be ignored
    """
    global currentpid
    pid = int(pid)
    traced_by = SysUtils.is_traced(pid)
    pid_control_list = [
        # Attaching PINCE to itself makes PINCE freeze immediately because gdb freezes the target on attach
        (lambda: pid == self_pid, type_defs.ATTACH_RESULT.ATTACH_SELF, "Nice try, smartass"),  # planned easter egg
        (lambda: not SysUtils.is_process_valid(pid), type_defs.ATTACH_RESULT.PROCESS_NOT_VALID,
         "Selected process is not valid"),
        (lambda: pid == currentpid, type_defs.ATTACH_RESULT.ALREADY_DEBUGGING, "You're debugging this process already"),
        (lambda: traced_by is not False, type_defs.ATTACH_RESULT.ALREADY_TRACED,
         "That process is already being traced by " + str(traced_by) + ", could not attach to the process"),
        (lambda: not can_attach(pid), type_defs.ATTACH_RESULT.PERM_DENIED,
         "Permission denied, could not attach to the process")
    ]
    for control_func, attach_result, error_message in pid_control_list:
        if control_func():
            print(error_message)
            return attach_result, error_message
    if currentpid != -1 or not gdb_initialized:
        init_gdb(gdb_path)
    global inferior_arch
    global mem_file
    currentpid = pid
    mem_file = "/proc/" + str(currentpid) + "/mem"
    SysUtils.create_PINCE_IPC_PATH(pid)
    send_command("attach " + str(pid))
    set_pince_paths()
    init_referenced_dicts(pid)
    inferior_arch = get_inferior_arch()
    await_exit_thread = Thread(target=await_process_exit)
    await_exit_thread.daemon = True
    await_exit_thread.start()
    result_message = "Successfully attached to the process with PID " + str(currentpid)
    print(result_message)
    SysUtils.execute_script(SysUtils.get_user_path(type_defs.USER_PATHS.PINCEINIT_AA_PATH))
    return type_defs.ATTACH_RESULT.ATTACH_SUCCESSFUL, result_message


#:tag:Debug
def create_process(process_path, args="", ld_preload_path="", gdb_path=type_defs.PATHS.GDB_PATH):
    r"""Creates a new process for debugging and initializes some of the global variables
    Current process will be detached even if the create_process call fails
    Make sure to save your data before calling this monstrosity

    Args:
        process_path (str): Absolute path of the target binary
        args (str): Arguments of the inferior, optional
        ld_preload_path (str): Path of the preloaded .so file, optional
        gdb_path (str): Path of the gdb binary

    Returns:
        bool: True if the process has been created successfully, False otherwise

    Note:
        If gdb is already initialized, gdb_path will be ignored
    """
    global currentpid
    global inferior_arch
    global mem_file
    if currentpid != -1 or not gdb_initialized:
        init_gdb(gdb_path)
    output = send_command("file " + process_path)
    if common_regexes.gdb_error.search(output):
        print("An error occurred while trying to create process from the file at " + process_path)
        detach()
        return False
    send_command("starti")
    wait_for_stop()
    entry_point = find_entry_point()
    if entry_point:
        send_command("tbreak *" + entry_point)
    else:
        send_command("tbreak _start")
    send_command("set args " + args)
    if ld_preload_path:
        send_command("set exec-wrapper env 'LD_PRELOAD=" + ld_preload_path + "'")
    send_command("run")

    # We have to wait till breakpoint hits
    wait_for_stop()
    pid = get_inferior_pid()
    currentpid = int(pid)
    mem_file = "/proc/" + str(currentpid) + "/mem"
    SysUtils.create_PINCE_IPC_PATH(pid)
    set_pince_paths()
    init_referenced_dicts(pid)
    inferior_arch = get_inferior_arch()
    await_exit_thread = Thread(target=await_process_exit)
    await_exit_thread.daemon = True
    await_exit_thread.start()
    SysUtils.execute_script(SysUtils.get_user_path(type_defs.USER_PATHS.PINCEINIT_AA_PATH))
    return True


#:tag:Debug
def detach():
    """See you, space cowboy"""
    global gdb_initialized
    global currentpid
    old_pid = currentpid
    if gdb_initialized:
        global child
        global inferior_status
        currentpid = -1
        inferior_status = -1
        gdb_initialized = False
        child.close()
    if old_pid != -1:
        SysUtils.delete_PINCE_IPC_PATH(old_pid)
    print("Detached from the process with PID:" + str(old_pid))


#:tag:Debug
def toggle_attach():
    """Detaches from the current process without ending the season if currently attached. Attaches back if detached

    Returns:
        int: The new state of the process as a member of type_defs.TOGGLE_ATTACH
        None: If detaching or attaching fails
    """
    if is_attached():
        if common_regexes.gdb_error.search(send_command("phase-out")):
            return
        return type_defs.TOGGLE_ATTACH.DETACHED
    if common_regexes.gdb_error.search(send_command("phase-in")):
        return
    return type_defs.TOGGLE_ATTACH.ATTACHED


#:tag:Debug
def is_attached():
    """Checks if gdb is attached to the current process

    Returns:
        bool: True if attached, False if not
    """
    if common_regexes.gdb_error.search(send_command("info proc")):
        return False
    return True


#:tag:Injection
def inject_with_advanced_injection(library_path):
    """Injects the given .so file to current process

    Args:
        library_path (str): Path to the .so file that'll be injected

    Returns:
        bool: Result of the injection

    Note:
        This function was reserved for linux-inject and since linux-inject is no more(F to pay respects), I'll leave
        this function as a template for now
    """
    raise NotImplementedError


#:tag:Injection
def inject_with_dlopen_call(library_path):
    """Injects the given .so file to current process
    This is a variant of the function inject_with_advanced_injection
    This function won't break the target process unlike other complex injection methods
    The downside is it fails if the target doesn't support dlopen calls or simply doesn't have the library

    Args:
        library_path (str): Path to the .so file that'll be injected

    Returns:
        bool: Result of the injection
    """
    injectionpath = '"' + library_path + '"'
    result = call_function_from_inferior("dlopen(" + injectionpath + ", 1)")[1]
    if result == "0" or not result:
        new_result = call_function_from_inferior("__libc_dlopen_mode(" + injectionpath + ", 1)")[1]
        if new_result == "0" or not new_result:
            return False
        return True
    return True


#:tag:MemoryRW
def memory_handle():
    """
    Acquire the handle of the currently attached process

    Returns:
        BinaryIO: A file handle that points to the memory file of the current process
    """
    return open(mem_file, "rb")


#:tag:MemoryRW
def read_memory(address, value_index, length=None, zero_terminate=True, signed=False, mem_handle=None):
    """Reads value from the given address

    Args:
        address (str, int): Can be a hex string or an integer.
        value_index (int): Determines the type of data read. Can be a member of type_defs.VALUE_INDEX
        length (int): Length of the data that'll be read. Must be greater than 0. Only used when the value_index is
        INDEX_STRING or INDEX_AOB. Ignored otherwise
        zero_terminate (bool): If True, data will be split when a null character has been read. Only used when
        value_index is INDEX_STRING. Ignored otherwise
        signed (bool): Casts the data as signed if True, unsigned if False. Only usable with integer types
        mem_handle (BinaryIO): A file handle that points to the memory file of the current process
        This parameter is used for optimization, See memory_handle
        Don't forget to close the handle after you're done if you use this parameter manually

    Returns:
        str: If the value_index is INDEX_STRING or INDEX_AOB
        float: If the value_index is INDEX_FLOAT32 or INDEX_FLOAT64
        int: If the value_index is anything else
        None: If an error occurs while reading the given address
    """
    try:
        value_index = int(value_index)
    except:
        # print(str(value_index) + " is not a valid value index")
        return
    if not type(address) == int:
        try:
            address = int(address, 0)
        except:
            # print(str(address) + " is not a valid address")
            return
    packed_data = type_defs.index_to_valuetype_dict.get(value_index, -1)
    if type_defs.VALUE_INDEX.is_string(value_index):
        try:
            length = int(length)
        except:
            # print(str(length) + " is not a valid length")
            return
        if not length > 0:
            # print("length must be greater than 0")
            return
        expected_length = length * type_defs.string_index_to_multiplier_dict.get(value_index, 1)
    elif value_index is type_defs.VALUE_INDEX.INDEX_AOB:
        try:
            expected_length = int(length)
        except:
            # print(str(length) + " is not a valid length")
            return
        if not expected_length > 0:
            # print("length must be greater than 0")
            return
    else:
        expected_length = packed_data[0]
        data_type = packed_data[1]
    try:
        if not mem_handle:
            mem_handle = open(mem_file, "rb")
        mem_handle.seek(address)
        data_read = mem_handle.read(expected_length)
    except (OSError, ValueError):
        # TODO (read/write error output)
        # Disabled read error printing. If needed, find a way to implement error logging with this function
        # I've initially thought about enabling it on demand via a parameter but this function already has too many
        # Maybe creating a function that toggles logging on and off? Other functions could use it too
        # print("Can't access the memory at address " + hex(address) + " or offset " + hex(address + expected_length))
        return
    if type_defs.VALUE_INDEX.is_string(value_index):
        encoding, option = type_defs.string_index_to_encoding_dict[value_index]
        returned_string = data_read.decode(encoding, option)
        if zero_terminate:
            if returned_string.startswith('\x00'):
                returned_string = '\x00'
            else:
                returned_string = returned_string.split('\x00')[0]
        return returned_string[0:length]
    elif value_index is type_defs.VALUE_INDEX.INDEX_AOB:
        return " ".join(format(n, '02x') for n in data_read)
    else:
        if type_defs.VALUE_INDEX.is_integer(value_index) and signed:
            data_type = data_type.lower()
        return struct.unpack_from(data_type, data_read)[0]


#:tag:MemoryRW
def write_memory(address, value_index, value):
    """Sets the given value to the given address

    If any errors occurs while setting value to the according address, it'll be ignored but the information about
    error will be printed to the terminal.

    Args:
        address (str, int): Can be a hex string or an integer
        value_index (int): Can be a member of type_defs.VALUE_INDEX
        value (str): The value that'll be written to the given address

    Notes:
        TODO: Implement a mem_handle parameter for optimization, check read_memory for an example
        If a file handle fails to write to an address, it becomes unusable
        You have to reopen the file to continue writing
    """
    if not type(address) == int:
        try:
            address = int(address, 0)
        except:
            # print(str(address) + " is not a valid address")
            return
    write_data = SysUtils.parse_string(value, value_index)
    if write_data is None:
        return
    encoding, option = type_defs.string_index_to_encoding_dict.get(value_index, (None, None))
    if encoding is None:
        if value_index is type_defs.VALUE_INDEX.INDEX_AOB:
            write_data = bytearray(write_data)
        else:
            data_type = type_defs.index_to_struct_pack_dict.get(value_index, -1)
            write_data = struct.pack(data_type, write_data)
    else:
        write_data = write_data.encode(encoding, option) + b"\x00"  # Zero-terminated by default
    FILE = open(mem_file, "rb+")
    try:
        FILE.seek(address)
        FILE.write(write_data)
        FILE.close()
    except (OSError, ValueError):
        # Refer to TODO (read/write error output)
        # print("Can't access the memory at address " + hex(address) + " or offset " + hex(address + len(write_data)))
        return


#:tag:Assembly
def disassemble(expression, offset_or_address):
    """Disassembles the address evaluated by the given expression

    Args:
        expression (str): Any gdb expression
        offset_or_address (str): If you pass this parameter as an offset, you should add "+" in front of it
        (e.g "+42" or "+0x42"). If you pass this parameter as an hex address, the address range between the expression
        and the secondary address is disassembled.
        If the second parameter is an address. it always should be bigger than the first address.

    Returns:
        list: A list of str values in this format-->[[address1,bytes1,opcodes1],[address2, ...], ...]
    """
    output = send_command("disas /r " + expression + "," + offset_or_address)
    return [list(item) for item in common_regexes.disassemble_output.findall(output)]


#:tag:GDBExpressions
def examine_expression(expression):
    """Evaluates the given expression and returns evaluated value, address and symbol

    Args:
        expression (str): Any gdb expression

    Returns:
        type_defs.tuple_examine_expression: Evaluated value, address and symbol in a tuple
        Any erroneous field will be returned as None instead of str
    """
    return send_command("pince-examine-expressions", send_with_file=True, file_contents_send=[expression],
                        recv_with_file=True)[0]


def examine_expressions(expression_list):
    """Optimized version of examine_expression for multiple inputs

    Args:
        expression_list (list): List of gdb expressions as str

    Returns:
        list: List of type_defs.tuple_examine_expression
    """
    return send_command("pince-examine-expressions", send_with_file=True, file_contents_send=expression_list,
                        recv_with_file=True)


#:tag:GDBExpressions
def parse_and_eval(expression, cast=str):
    """Calls gdb.parse_and_eval with the given expression and returns the value after casting with the given type
    Use examine_expression if your data can be expressed as an address or a symbol, use this function otherwise
    Unlike examine_expression, this function can read data that has void type or multiple type representations
    For instance:
        $eflags has both str and int reprs
        $_siginfo is a struct with many fields
        x64 register convenience vars such as $rax are void if the process is x86

    Args:
        expression (str): Any gdb expression
        cast (type): Evaluated value will be cast to this type in gdb

    Returns:
        cast: Self-explanatory
        None: If casting fails
    """
    return send_command("pince-parse-and-eval", send_with_file=True, file_contents_send=(expression, cast),
                        recv_with_file=True)


#:tag:Threads
def get_current_thread_information():
    """Invokes "info threads" command and returns the line corresponding to the current thread

    Returns:
        str: Current thread information
        None: If the output doesn't fit the regex
    """
    thread_info = send_command("info threads")
    return re.sub(r'\\"', r'"', common_regexes.thread_info.search(thread_info).group(1))


#:tag:Assembly
def find_address_of_closest_instruction(address, instruction_location="next", instruction_count=1):
    """Finds address of the closest instruction next to the given address, assuming that the given address is valid

    Args:
        address (str): Hex address or any gdb expression that can be used in disas command
        instruction_location (str): If it's "next", instructions coming after the address is searched
        If it's "previous", the instructions coming before the address is searched instead
        instruction_count (int): Number of the instructions that'll be looked for

    Returns:
        str: The address found as hex string. If starting/ending of a valid memory range is reached, starting/ending
        address is returned instead as hex string.

    Note:
        From gdb version 7.12 and onwards, inputting negative numbers in x command are supported(x/-3i for instance)
        So, modifying this function according to the changes in 7.12 may speed up things a little bit but also breaks
        the backwards compatibility. The speed gain is not much of a big deal compared to backwards compatibility, so
        I'm not changing this function for now
    """
    assert instruction_location in ["next", "previous"], "invalid instruction_location"
    if instruction_location == "next":
        offset = "+" + str(instruction_count * 30)
        disas_data = disassemble(address, address + offset)
    else:
        offset = "-" + str(instruction_count * 30)
        disas_data = disassemble(address + offset, address)
    if not disas_data:
        if instruction_location != "next":
            start_address = hex(SysUtils.get_region_info(currentpid, address).start)
            disas_data = disassemble(start_address, address)
    if instruction_location == "next":
        try:
            return SysUtils.extract_address(disas_data[instruction_count][0])
        except IndexError:
            return hex(SysUtils.get_region_info(currentpid, address).end)
    else:
        try:
            return SysUtils.extract_address(disas_data[-instruction_count][0])
        except IndexError:
            try:
                return start_address
            except UnboundLocalError:
                return hex(SysUtils.get_region_info(currentpid, address).start)


#:tag:GDBExpressions
def get_address_info(expression):
    """Runs the gdb command "info symbol" for given expression and returns the result of it

    Args:
        expression (str): Any gdb expression

    Returns:
        str: The result of the command "info symbol" for given expression
    """
    return send_command("info symbol " + expression, cli_output=True)


#:tag:GDBExpressions
def get_symbol_info(expression):
    """Runs the gdb command "info address" for given expression and returns the result of it

    Args:
        expression (str): Any gdb expression

    Returns:
        str: The result of the command "info address" for given expression
    """
    return send_command("info address " + expression, cli_output=True)


#:tag:Tools
def search_functions(expression, case_sensitive=False):
    """Runs the gdb command "info functions" for given expression and returns the result of it

    Args:
        expression (str): Any gdb expression
        case_sensitive (bool): If True, search will be case sensitive

    Returns:
        list: A list of str-->[(address1, symbol1), (address2, symbol2), ...]
            address will be None if the corresponding symbol is in defined category

    Todo:
        GDB-MI wiki points out to the command -symbol-list-functions but apparently it isn't implemented yet
        If the feature below gets implemented, use it instead
        https://sourceware.org/bugzilla/show_bug.cgi?id=23796

        Add ability to show addresses of defined symbols when it gets implemented by gdb
        Please don't try to write a symbol parser for every single language out there, it's an overkill
        https://sourceware.org/bugzilla/show_bug.cgi?id=23899
    """
    return send_command("pince-search-functions", send_with_file=True, file_contents_send=(expression, case_sensitive),
                        recv_with_file=True)


#:tag:InferiorInformation
def get_inferior_pid():
    """Get pid of the current inferior

    Returns:
        str: pid
    """
    output = send_command("info inferior")
    return common_regexes.inferior_pid.search(output).group(1)


#:tag:InferiorInformation
def get_inferior_arch():
    """Returns the architecture of the current inferior

    Returns:
        int: A member of type_defs.INFERIOR_ARCH
    """
    if parse_and_eval("$rax") == "void":
        return type_defs.INFERIOR_ARCH.ARCH_32
    return type_defs.INFERIOR_ARCH.ARCH_64


#:tag:Registers
def read_registers():
    """Returns the current registers

    Returns:
        dict: A dict that holds general, flag and segment registers. Check type_defs.REGISTERS for the full list
    """
    return send_command("pince-read-registers", recv_with_file=True)


#:tag:Registers
def read_float_registers():
    """Returns the current floating point registers

    Returns:
        dict: A dict that holds floating point registers. Check type_defs.REGISTERS.FLOAT for the full list

    Note:
        Returned xmm values are based on xmm.v4_float
    """
    return send_command("pince-read-float-registers", recv_with_file=True)


#:tag:GDBExpressions
#:tag:Registers
def set_convenience_variable(variable, value):
    """Sets given convenience variable to given value
    Can be also used for modifying registers directly

    Args:
        variable (str): Any gdb convenience variable(with "$" character removed)
        value (str): Anything
    """
    send_command("set $" + variable + "=" + value)


#:tag:Registers
def set_register_flag(flag, value):
    """Sets given register flag to given value

    Args:
        flag (str): A member of type_defs.REGISTERS.FLAG
        value (Union[int,str]): 0 or 1
    """
    registers = read_registers()
    value = str(value)
    registers[flag] = value
    if value != "0" and value != "1":
        raise Exception(value + " isn't valid value. It can be only 0 or 1")
    if flag not in type_defs.REGISTERS.FLAG:
        raise Exception(flag + " isn't a valid flag, must be a member of type_defs.REGISTERS.FLAG")
    eflags_hex_value = hex(int(
        registers["of"] + registers["df"] + registers["if"] + registers["tf"] + registers["sf"] + registers[
            "zf"] + "0" + registers["af"] + "0" + registers["pf"] + "0" + registers["cf"], 2))
    set_convenience_variable("eflags", eflags_hex_value)


#:tag:Stack
def get_stacktrace_info():
    """Returns information about current stacktrace

    Returns:
        list: A list of str values in this format-->[[return_address_info1,frame_address_info1],[info2, ...], ...]

        return_address_info looks like this-->Return address of frame+symbol-->0x40c431 <_start>
        frame_address_info looks like this-->Beginning of frame+distance from stack pointer-->0x7ffe1e989a40(rsp+0x100)
    """
    return send_command("pince-get-stack-trace-info", recv_with_file=True)


#:tag:Stack
def get_stack_info():
    """Returns information about current stack

    Returns:
        list: A list of str values in this format--▼
        [[stack_pointer_info1,hex_value1,pointer_info1],[stack_pointer_info2, ...], ...]

        stack_pointer_info looks like this-->Hex address+distance from stack pointer-->0x7ffd0d232f88(rsp+0xff8)
        hex_value looks like this-->Value hold by corresponding address-->0x1bfda20
        pointer_info shows the value hold by hex_value address. It looks like this--▼
        if points to a string-->(str)Some String
        if points to a symbol-->(ptr)<function_name>
        pointer_info becomes a null string if pointer isn't valid
    """
    return send_command("pince-get-stack-info", recv_with_file=True)


#:tag:Stack
def get_stack_frame_return_addresses():
    """Returns return addresses of stack frames

    Returns:
        list: A list of str values in this format-->[return_address_info1,return_address_info2, ...]

        return_address_info looks like this-->Return address of frame+symbol-->0x40c431 <_start>
    """
    return send_command("pince-get-frame-return-addresses", recv_with_file=True)


#:tag:Stack
def get_stack_frame_info(index):
    """Returns information about stack by the given index

    Args:
        index (int,str): Index of the frame

    Returns:
        str: Information that looks like this--▼
        Stack level 0, frame at 0x7ffc5f87f6a0:
            rip = 0x7fd1d639412d in poll (../sysdeps/unix/syscall-template.S:81); saved rip = 0x7fd1d27fcfe4
            called by frame at 0x7ffc5f87f700
            source language asm.
            Arglist at 0x7ffc5f87f688, args:
            Locals at 0x7ffc5f87f688, Previous frame's sp is 0x7ffc5f87f6a0
            Saved registers:
                rip at 0x7ffc5f87f698
    """
    return send_command("pince-get-frame-info", send_with_file=True, file_contents_send=str(index), recv_with_file=True)


#:tag:MemoryRW
def hex_dump(address, offset):
    """Returns hex dump of range (address to address+offset)

    Args:
        address (int): Self-explanatory
        offset (int): The range that'll be read

    Returns:
        list: List of strings read as str. If an error occurs while reading a memory cell, that cell is returned as "??"
        An empty list is returned if an error occurs

    Examples:
        returned list-->["??","??","??","7f","43","67","40","??","??, ...]
    """
    hex_byte_list = []
    with open(mem_file, "rb") as FILE:
        try:
            FILE.seek(address)
        except (OSError, ValueError):
            pass
        for item in range(offset):
            try:
                current_item = " ".join(format(n, '02x') for n in FILE.read(1))
            except OSError:
                current_item = "??"
                try:
                    FILE.seek(1, io.SEEK_CUR)  # Necessary since read() failed to execute
                except (OSError, ValueError):
                    pass
            hex_byte_list.append(current_item)
    return hex_byte_list


#:tag:MemoryRW
def get_noped_instructions():
    """Returns currently NOP'ed out instructions

    Returns:
        dict: A dictionary where the key is the start address of instruction and value is the aob before NOP'ing

    """
    global noped_instructions_dict
    return noped_instructions_dict


#:tag:MemoryRW
def nop_instruction(start_address, array_of_bytes):
    """Replaces an instruction's opcodes with NOPs

    Args:
        start_address (int): Self-explanatory
        array_of_bytes (str): String that contains the bytes of the instruction

    Returns:
        None
    """
    global noped_instructions_dict
    noped_instructions_dict[start_address] = array_of_bytes

    nop_aob = '90 ' * len(array_of_bytes.split())
    write_memory(start_address, type_defs.VALUE_INDEX.INDEX_AOB, nop_aob)


#:tag:MemoryRW
def restore_instruction(start_address):
    """Restores a NOP'ed out instruction to it's original opcodes

    Args:
        start_address (int): Self-explanatory

    Returns:
        None
    """
    global noped_instructions_dict
    array_of_bytes = noped_instructions_dict.pop(start_address)
    write_memory(start_address, type_defs.VALUE_INDEX.INDEX_AOB, array_of_bytes)


#:tag:BreakWatchpoints
def get_breakpoint_info():
    """Returns current breakpoint/watchpoint list

    Returns:
        list: A list of type_defs.tuple_breakpoint_info where;
            number is the gdb breakpoint number
            breakpoint_type is the breakpoint type
            disp shows what will be done after breakpoint hits
            enabled shows if the breakpoint enabled or disabled
            address is the address of breakpoint
            size is the size of breakpoint
            on_hit is the action that'll happen when the breakpoint is reached
            hit_count shows how many times the breakpoint has been hit
            enable_count shows how many times the breakpoint will get hit before it gets disabled
            condition is the condition of breakpoint

            size-->int
            everything else-->str

    Note:
        GDB's python API can't detect hardware breakpoints, that's why we are using parser for this job
    """
    returned_list = []
    multiple_break_data = OrderedDict()
    raw_info = send_command("-break-list")
    # Temporary fix for https://sourceware.org/bugzilla/show_bug.cgi?id=9659
    # TODO:Delete this line when gdb or pygdbmi fixes the problem
    raw_info = re.sub("script={(.*?)}", "script=[\g<1>]", raw_info)  # Please refer to issue #53
    for item in SysUtils.parse_response(raw_info)['payload']['BreakpointTable']['body']:
        item = defaultdict(lambda: "", item)
        number, breakpoint_type, disp, enabled, address, what, condition, hit_count, enable_count = \
            item['number'], item['type'], item['disp'], item['enabled'], item['addr'], item['what'], item['cond'], \
            item['times'], item['enable']
        if address == "<MULTIPLE>":
            multiple_break_data[number] = (breakpoint_type, disp, condition, hit_count)
            continue
        if not breakpoint_type:
            number = number.split(".")[0]
            breakpoint_type, disp, condition, hit_count = multiple_break_data[number]
        if what:
            address = SysUtils.extract_address(what)
            if not address:
                address = examine_expression(what).address
        try:
            int_address = int(address, 16)
        except ValueError:
            on_hit = type_defs.on_hit_to_text_dict.get(type_defs.BREAKPOINT_ON_HIT.BREAK)
        else:
            on_hit_dict_value = breakpoint_on_hit_dict.get(int_address, type_defs.BREAKPOINT_ON_HIT.BREAK)
            on_hit = type_defs.on_hit_to_text_dict.get(on_hit_dict_value, "Unknown")
        if breakpoint_type.find("breakpoint") >= 0:
            size = 1
        else:
            possible_size = common_regexes.breakpoint_size.search(what)
            if possible_size:
                size = int(possible_size.group(1))
            else:
                size = 1
        returned_list.append(
            type_defs.tuple_breakpoint_info(number, breakpoint_type, disp, enabled, address, size, on_hit, hit_count,
                                            enable_count, condition))
    return returned_list


#:tag:BreakWatchpoints
def check_address_in_breakpoints(address, range_offset=0):
    """Checks if given address exists in breakpoint list

    Args:
        address (int,str): Hex address or an int
        range_offset (int): If this parameter is different than 0, the range between address and address+offset is
        checked instead of just address itself

    Returns:
        type_defs.tuple_breakpoint_info: Info of the existing breakpoint for given address range
        None: If it doesn't exist
    """
    if type(address) != int:
        address = int(address, 0)
    max_address = max(address, address + range_offset)
    min_address = min(address, address + range_offset)
    breakpoint_info = get_breakpoint_info()
    for item in breakpoint_info:
        breakpoint_address = int(item.address, 16)
        if not (max_address < breakpoint_address or min_address > breakpoint_address + item.size - 1):
            return item


#:tag:BreakWatchpoints
def hardware_breakpoint_available():
    """Checks if there is an available hardware breakpoint slot

    Returns:
        bool: True if there is at least one available slot, False if not

    Todo:
        Check debug registers to determine hardware breakpoint state rather than relying on gdb output because inferior
        might modify it's own debug registers
    """
    breakpoint_info = get_breakpoint_info()
    hw_bp_total = 0
    for item in breakpoint_info:
        if common_regexes.hw_breakpoint_count.search(item.breakpoint_type):
            hw_bp_total += 1

    # Maximum number of hardware breakpoints is limited to 4 in x86 architecture
    return hw_bp_total < 4


#:tag:BreakWatchpoints
def add_breakpoint(expression, breakpoint_type=type_defs.BREAKPOINT_TYPE.HARDWARE_BP,
                   on_hit=type_defs.BREAKPOINT_ON_HIT.BREAK):
    """Adds a breakpoint at the address evaluated by the given expression. Uses a software breakpoint if all hardware
    breakpoint slots are being used

    Args:
        expression (str): Any gdb expression
        breakpoint_type (int): Can be a member of type_defs.BREAKPOINT_TYPE
        on_hit (int): Can be a member of type_defs.BREAKPOINT_ON_HIT

    Returns:
        str: Number of the breakpoint set
        None: If setting breakpoint fails
    """
    output = ""
    str_address = examine_expression(expression).address
    if not str_address:
        print("expression for breakpoint is not valid")
        return
    if check_address_in_breakpoints(str_address):
        print("breakpoint/watchpoint for address " + str_address + " is already set")
        return
    if breakpoint_type == type_defs.BREAKPOINT_TYPE.HARDWARE_BP:
        if hardware_breakpoint_available():
            output = send_command("hbreak *" + str_address)
        else:
            print("All hardware breakpoint slots are being used, using a software breakpoint instead")
            output = send_command("break *" + str_address)
    elif breakpoint_type == type_defs.BREAKPOINT_TYPE.SOFTWARE_BP:
        output = send_command("break *" + str_address)
    if common_regexes.breakpoint_created.search(output):
        global breakpoint_on_hit_dict
        breakpoint_on_hit_dict[int(str_address, 16)] = on_hit
        return common_regexes.breakpoint_number.search(output).group(1)
    else:
        return


#:tag:BreakWatchpoints
def add_watchpoint(expression, length=4, watchpoint_type=type_defs.WATCHPOINT_TYPE.BOTH,
                   on_hit=type_defs.BREAKPOINT_ON_HIT.BREAK):
    """Adds a watchpoint at the address evaluated by the given expression

    Args:
        expression (str): Any gdb expression
        length (int): Length of the watchpoint
        watchpoint_type (int): Can be a member of type_defs.WATCHPOINT_TYPE
        on_hit (int): Can be a member of type_defs.BREAKPOINT_ON_HIT

    Returns:
        list: Numbers of the successfully set breakpoints as strings
    """
    str_address = examine_expression(expression).address
    if not str_address:
        print("expression for watchpoint is not valid")
        return
    if watchpoint_type == type_defs.WATCHPOINT_TYPE.WRITE_ONLY:
        watch_command = "watch"
    elif watchpoint_type == type_defs.WATCHPOINT_TYPE.READ_ONLY:
        watch_command = "rwatch"
    elif watchpoint_type == type_defs.WATCHPOINT_TYPE.BOTH:
        watch_command = "awatch"
    remaining_length = length
    breakpoints_set = []
    arch = get_inferior_arch()
    str_address_int = int(str_address, 16)
    breakpoint_addresses = []
    if arch == type_defs.INFERIOR_ARCH.ARCH_64:
        max_length = 8
    else:
        max_length = 4
    while remaining_length > 0:
        if check_address_in_breakpoints(str_address_int):
            print("breakpoint/watchpoint for address " + hex(str_address_int) + " is already set. Bailing out...")
            break
        if not hardware_breakpoint_available():
            print("All hardware breakpoint slots are being used, unable to set a new watchpoint. Bailing out...")
            break
        if remaining_length >= max_length:
            breakpoint_length = max_length
        else:
            breakpoint_length = remaining_length
        output = send_command(watch_command + " * (char[" + str(breakpoint_length) + "] *) " + hex(str_address_int))
        if common_regexes.breakpoint_created.search(output):
            breakpoint_addresses.append([str_address_int, breakpoint_length])
        else:
            print("Failed to create a watchpoint at address " + hex(str_address_int) + ". Bailing out...")
            break
        breakpoint_number = common_regexes.breakpoint_number.search(output).group(1)
        breakpoints_set.append(breakpoint_number)
        global breakpoint_on_hit_dict
        breakpoint_on_hit_dict[str_address_int] = on_hit
        remaining_length -= max_length
        str_address_int += max_length
    global chained_breakpoints
    chained_breakpoints.append(breakpoint_addresses)
    return breakpoints_set


#:tag:BreakWatchpoints
def modify_breakpoint(expression, modify_what, condition=None, count=None):
    """Adds a condition to the breakpoint at the address evaluated by the given expression

    Args:
        expression (str): Any gdb expression
        modify_what (int): Can be a member of type_defs.BREAKPOINT_MODIFY_TYPES
        This function modifies condition of the breakpoint if CONDITION, enables the breakpoint if ENABLE, disables the
        breakpoint if DISABLE, enables once then disables after hit if ENABLE_ONCE, enables for specified count then
        disables after the count is reached if ENABLE_COUNT, enables once then deletes the breakpoint if ENABLE_DELETE
        condition (str): Any gdb condition expression. This parameter is only used if modify_what passed as CONDITION
        count (int): Only used if modify_what passed as ENABLE_COUNT

    Returns:
        bool: True if the condition has been set successfully, False otherwise

    Examples:
        modify_what-->type_defs.BREAKPOINT_MODIFY_TYPES.CONDITION
        condition-->$eax==0x523
        condition-->$rax>0 && ($rbp<0 || $rsp==0)
        condition-->printf($r10)==3

        modify_what-->type_defs.BREAKPOINT_MODIFY_TYPES.ENABLE_COUNT
        count-->10
    """
    str_address = examine_expression(expression).address
    if not str_address:
        print("expression for breakpoint is not valid")
        return False
    str_address_int = int(str_address, 16)
    modification_list = [[str_address_int]]
    for n, item in enumerate(chained_breakpoints):
        for breakpoint in item:
            if breakpoint[0] <= str_address_int <= breakpoint[0] + breakpoint[1] - 1:
                modification_list = item
                break
    for breakpoint in modification_list:
        found_breakpoint = check_address_in_breakpoints(breakpoint[0])
        if not found_breakpoint:
            print("no such breakpoint exists for address " + str_address)
            continue
        else:
            breakpoint_number = found_breakpoint.number
        if modify_what == type_defs.BREAKPOINT_MODIFY.CONDITION:
            if condition is None:
                print("Please set condition first")
                return False
            send_command("condition " + breakpoint_number + " " + condition)
        elif modify_what == type_defs.BREAKPOINT_MODIFY.ENABLE:
            send_command("enable " + breakpoint_number)
        elif modify_what == type_defs.BREAKPOINT_MODIFY.DISABLE:
            send_command("disable " + breakpoint_number)
        elif modify_what == type_defs.BREAKPOINT_MODIFY.ENABLE_ONCE:
            send_command("enable once " + breakpoint_number)
        elif modify_what == type_defs.BREAKPOINT_MODIFY.ENABLE_COUNT:
            if count is None:
                print("Please set count first")
                return False
            elif count < 1:
                print("Count can't be lower than 1")
                return False
            send_command("enable count " + str(count) + " " + breakpoint_number)
        elif modify_what == type_defs.BREAKPOINT_MODIFY.ENABLE_DELETE:
            send_command("enable delete " + breakpoint_number)
        else:
            print("Parameter modify_what is not valid")
            return False
    return True


#:tag:BreakWatchpoints
def delete_breakpoint(expression):
    """Deletes a breakpoint at the address evaluated by the given expression

    Args:
        expression (str): Any gdb expression

    Returns:
        bool: True if the breakpoint has been deleted successfully, False otherwise
    """
    str_address = examine_expression(expression).address
    if not str_address:
        print("expression for breakpoint is not valid")
        return False
    str_address_int = int(str_address, 16)
    deletion_list = [[str_address_int]]
    global chained_breakpoints
    for n, item in enumerate(chained_breakpoints):
        for breakpoint in item:
            if breakpoint[0] <= str_address_int <= breakpoint[0] + breakpoint[1] - 1:
                deletion_list = item
                del chained_breakpoints[n]
                break
    for breakpoint in deletion_list:
        found_breakpoint = check_address_in_breakpoints(breakpoint[0])
        if not found_breakpoint:
            print("no such breakpoint exists for address " + str_address)
            continue
        else:
            breakpoint_number = found_breakpoint.number
        global breakpoint_on_hit_dict
        try:
            del breakpoint_on_hit_dict[breakpoint[0]]
        except KeyError:
            pass
        send_command("delete " + str(breakpoint_number))
    return True


#:tag:BreakWatchpoints
def track_watchpoint(expression, length, watchpoint_type):
    """Starts tracking a value by setting a watchpoint at the address holding it
    Use get_track_watchpoint_info() to get info about the watchpoint you set

    Args:
        expression (str): Any gdb expression
        length (int): Length of the watchpoint
        watchpoint_type (int): Can be a member of type_defs.WATCHPOINT_TYPE

    Returns:
        list: Numbers of the successfully set breakpoints as strings
        None: If fails to set any watchpoint
    """
    breakpoints = add_watchpoint(expression, length, watchpoint_type, type_defs.BREAKPOINT_ON_HIT.FIND_CODE)
    if not breakpoints:
        return
    for breakpoint in breakpoints:
        send_command("commands " + breakpoint
                     + "\npince-get-track-watchpoint-info " + str(breakpoints)
                     + "\nc"
                     + "\nend")
    return breakpoints


#:tag:BreakWatchpoints
def get_track_watchpoint_info(watchpoint_list):
    """Gathers the information for the tracked watchpoint(s)

    Args:
        watchpoint_list (list): A list that holds the watchpoint numbers, must be returned from track_watchpoint()

    Returns:
        dict: Holds the program counter addresses at the moment watchpoint hits as keys
        Format of dict--> {address1:info_list1, address2:info_list2, ...}
        Format of info_list--> [count, previous_pc_address, register_info, float_info, disas_info]
        count-->(int) Count of the hits for the same pc address
        previous_pc_address-->(str) The address of the instruction that comes before the instruction pc address
        holds. If there's no previous address available(end of region etc.), previous_pc_address=pc_address
        register_info-->(dict) Same dict returned from read_registers()
        float_info-->(dict) Same dict returned from read_float_registers()
        disas_info-->(str) A small section that's disassembled just after previous_pc_counter
    """
    track_watchpoint_file = SysUtils.get_track_watchpoint_file(currentpid, watchpoint_list)
    try:
        output = pickle.load(open(track_watchpoint_file, "rb"))
    except:
        output = ""
    return output


#:tag:BreakWatchpoints
def track_breakpoint(expression, register_expressions):
    """Starts tracking a value by setting a breakpoint at the address holding it
    Use get_track_breakpoint_info() to get info about the breakpoint you set

    Args:
        expression (str): Any gdb expression
        register_expressions (str): Register expressions, separated by a comma. Registers should start with "$"
        PINCE will gather info about values presented by register expressions every time the breakpoint is reached
        For instance, passing "$rax,$rcx+5,$rbp+$r12" will make PINCE track values rax, rcx+5 and rbp+r12

    Returns:
        str: Number of the breakpoint set
        None: If fails to set any breakpoint
    """
    breakpoint = add_breakpoint(expression, on_hit=type_defs.BREAKPOINT_ON_HIT.FIND_ADDR)
    if not breakpoint:
        return
    send_command("commands " + breakpoint
                 + "\npince-get-track-breakpoint-info " + register_expressions.replace(" ", "") + "," + breakpoint
                 + "\nc"
                 + "\nend")
    return breakpoint


#:tag:BreakWatchpoints
def get_track_breakpoint_info(breakpoint):
    """Gathers the information for the tracked breakpoint

    Args:
        breakpoint (str): breakpoint number, must be returned from track_breakpoint()

    Returns:
        dict: Holds the register expressions as keys and their info as values
        Format of dict--> {expression1:expression_info_dict1, expression2:expression_info_dict2, ...}
        expression-->(str) The register expression
        Format of expression_info_dict--> {value1:count1, value2:count2, ...}
        value-->(str) Value calculated by given register expression as hex str
        count-->(int) How many times this expression has been reached
    """
    track_breakpoint_file = SysUtils.get_track_breakpoint_file(currentpid, breakpoint)
    try:
        output = pickle.load(open(track_breakpoint_file, "rb"))
    except:
        output = ""
    return output


#:tag:Tools
def trace_instructions(expression, max_trace_count=1000, trigger_condition="", stop_condition="",
                       step_mode=type_defs.STEP_MODE.SINGLE_STEP,
                       stop_after_trace=False, collect_general_registers=True, collect_flag_registers=True,
                       collect_segment_registers=True, collect_float_registers=True):
    """Starts tracing instructions at the address evaluated by the given expression
    There can be only one tracing process at a time, calling this function without waiting the first tracing process
    meet an end may cause bizarre behaviour
    Use get_trace_instructions_info() to get info about the breakpoint you set

    Args:
        expression (str): Any gdb expression
        max_trace_count (int): Maximum number of steps will be taken while tracing. Must be greater than or equal to 1
        trigger_condition (str): Optional, any gdb expression. Tracing will start if the condition is met
        stop_condition (str): Optional, any gdb expression. Tracing will stop whenever the condition is met
        step_mode (int): Can be a member of type_defs.STEP_MODE
        stop_after_trace (bool): Inferior won't be continuing after the tracing process
        collect_general_registers (bool): Collect general registers while stepping
        collect_flag_registers (bool): Collect flag registers while stepping
        collect_segment_registers (bool): Collect segment registers while stepping
        collect_float_registers (bool): Collect float registers while stepping

    Returns:
        str: Number of the breakpoint set
        None: If fails to set any breakpoint or if max_trace_count is not valid
    """
    if max_trace_count < 1:
        print("max_trace_count must be greater than or equal to 1")
        return
    if type(max_trace_count) != int:
        print("max_trace_count must be an integer")
        return
    breakpoint = add_breakpoint(expression, on_hit=type_defs.BREAKPOINT_ON_HIT.TRACE)
    if not breakpoint:
        return
    modify_breakpoint(expression, type_defs.BREAKPOINT_MODIFY.CONDITION, condition=trigger_condition)
    contents_send = (type_defs.TRACE_STATUS.STATUS_IDLE, "Waiting for breakpoint to trigger")
    trace_status_file = SysUtils.get_trace_instructions_status_file(currentpid, breakpoint)
    pickle.dump(contents_send, open(trace_status_file, "wb"))
    param_str = (
        breakpoint, max_trace_count, stop_condition, step_mode, stop_after_trace, collect_general_registers,
        collect_flag_registers, collect_segment_registers, collect_float_registers)
    send_command("commands " + breakpoint
                 + "\npince-trace-instructions " + str(param_str)
                 + "\nend")
    return breakpoint


#:tag:Tools
def get_trace_instructions_info(breakpoint):
    """Gathers the information of the tracing process for the given breakpoint

    Args:
        breakpoint (str): breakpoint number, must be returned from trace_instructions()

    Returns:
        list: [node1, node2, node3, ...]
        node-->[(line_info, register_dict), parent_index, child_index_list]
        If an error occurs while reading, an empty list returned instead

        Check PINCE.TraceInstructionsWindowForm.show_trace_info() to see how to traverse the tree
        If you just want to search something in the trace data, you can enumerate the tree instead of traversing
        Root always be an empty node, it's up to you to use or delete it
        Any "call" instruction creates a node in SINGLE_STEP mode
        Any "ret" instruction creates a parent regardless of the mode
    """
    trace_instructions_file = SysUtils.get_trace_instructions_file(currentpid, breakpoint)
    try:
        output = json.load(open(trace_instructions_file, "r"), object_pairs_hook=OrderedDict)
    except:
        output = []
    return output


#:tag:Tools
def get_trace_instructions_status(breakpoint):
    """Returns the current state of tracing process for given breakpoint

    Args:
        breakpoint (str): breakpoint number, must be returned from trace_instructions()

    Returns:
        tuple:(status_id, status_str)

        status_id-->(int) A member of type_defs.TRACE_STATUS
        status_str-->(str) Status string

        Returns a tuple of (False, "") if fails to gather info
    """
    trace_status_file = SysUtils.get_trace_instructions_status_file(currentpid, breakpoint)
    try:
        output = pickle.load(open(trace_status_file, "rb"))
    except:
        output = False, ""
    return output


#:tag:Tools
def cancel_trace_instructions(breakpoint):
    """Finishes the trace instruction process early on for the given breakpoint

    Args:
        breakpoint (str): breakpoint number, must be returned from trace_instructions()
    """
    status_info = (type_defs.TRACE_STATUS.STATUS_CANCELED, "Tracing has been canceled")
    trace_status_file = SysUtils.get_trace_instructions_status_file(currentpid, breakpoint)
    pickle.dump(status_info, open(trace_status_file, "wb"))


#:tag:Tools
def call_function_from_inferior(expression):
    """Calls the given function expression from the inferior

    Args:
        expression (str): Any gdb expression

    Returns:
        tuple: A tuple containing assigned value and result, both as str
        Returns a tuple of (False, False) if the call fails

    Examples:
        call_function_from_inferior("printf('123')") returns ("$26","3")
    """
    result = send_command("call (char *) " + expression)
    filtered_result = common_regexes.convenience_variable.search(result)
    if filtered_result:
        return filtered_result.group(1), filtered_result.group(2)
    return False, False


#:tag:InferiorInformation
def find_entry_point():
    """Finds entry point of the inferior

    Returns:
        str: Entry point as hex str
        None: If fails to find an entry point
    """
    result = send_command("info file")
    filtered_result = common_regexes.entry_point.search(result)
    if filtered_result:
        return filtered_result.group(1)


#:tag:Tools
def search_opcode(searched_str, starting_address, ending_address_or_offset, case_sensitive=False, enable_regex=False):
    """Searches for the given str in the disassembled output

    Args:
        searched_str (str): String that will be searched
        starting_address (str): Any gdb expression
        ending_address_or_offset (str): If you pass this parameter as an offset, you should add "+" in front of it
        (e.g "+42" or "+0x42"). If you pass this parameter as an hex address, the address range between the expression
        and the secondary address is disassembled.
        If the second parameter is an address. it always should be bigger than the first address.
        case_sensitive (bool): If True, search will be case sensitive
        enable_regex (bool): If True, searched_str will be treated as a regex expression

    Returns:
        list: A list of str values in this format-->[[address1,opcodes1],[address2, ...], ...]
        None: If enable_regex is True and given regex isn't valid
    """
    if enable_regex:
        try:
            if case_sensitive:
                regex = re.compile(searched_str)
            else:
                regex = re.compile(searched_str, re.IGNORECASE)
        except Exception as e:
            print("An exception occurred while trying to compile the given regex\n", str(e))
            return
    returned_list = []
    disas_output = disassemble(starting_address, ending_address_or_offset)
    for item in disas_output:
        address = item[0]
        opcode = item[2]
        if enable_regex:
            if not regex.search(opcode):
                continue
        else:
            if case_sensitive:
                if opcode.find(searched_str) == -1:
                    continue
            else:
                if opcode.lower().find(searched_str.lower()) == -1:
                    continue
        returned_list.append([address, opcode])
    return returned_list


#:tag:Tools
def dissect_code(region_list, discard_invalid_strings=True):
    """Searches given regions for jumps, calls and string references
    Use function get_dissect_code_data() to gather the results

    Args:
        region_list (list): A list of psutil._pslinux.pmmap_ext objects
        Can be returned from functions like SysUtils.filter_memory_regions
        discard_invalid_strings (bool): Entries that can't be decoded as utf-8 won't be included in referenced strings
    """
    send_command("pince-dissect-code", send_with_file=True, file_contents_send=(region_list, discard_invalid_strings))


#:tag:Tools
def get_dissect_code_status():
    """Returns the current state of dissect code process

    Returns:
        tuple:(current_region, current_region_count, referenced_strings_count,
                               referenced_jumps_count, referenced_calls_count)

        current_region-->(str) Currently scanned memory region
        current_region_count-->(str) "Region x of y"
        current_range-->(str) Currently scanned memory range(current buffer)
        referenced_strings_count-->(int) Count of referenced strings
        referenced_jumps_count-->(int) Count of referenced jumps
        referenced_calls_count-->(int) Count of referenced calls

        Returns a tuple of ("", "", "", 0, 0, 0) if fails to gather info
    """
    dissect_code_status_file = SysUtils.get_dissect_code_status_file(currentpid)
    try:
        output = pickle.load(open(dissect_code_status_file, "rb"))
    except:
        output = "", "", "", 0, 0, 0
    return output


#:tag:Tools
def cancel_dissect_code():
    """Finishes the current dissect code process early on"""
    if last_gdb_command.find("pince-dissect-code") != -1:
        cancel_last_command()


#:tag:Tools
def get_dissect_code_data(referenced_strings=True, referenced_jumps=True, referenced_calls=True):
    """Returns shelve.DbfilenameShelf objects of referenced dicts

    Args:
        referenced_strings (bool): If True, include referenced strings in the returned list
        referenced_jumps (bool): If True, include referenced jumps in the returned list
        referenced_calls (bool): If True, include referenced calls in the returned list

    Returns:
        list: A list of shelve.DbfilenameShelf objects. Can be used as dicts, they are backwards compatible

        For instance, if you call this function with default params, you'll get this--▼
        [referenced_strings_dict,referenced_jumps_dict,referenced_calls_dict]

        And if you, let's say, pass referenced_jumps as False, you'll get this instead--▼
        [referenced_strings_dict,referenced_calls_dict]

        referenced_strings_dict-->(shelve.DbfilenameShelf object) Holds referenced string addresses
        Format: {referenced_address1:referrer_address_set1, referenced_address2:referrer_address_set2, ...}

        referenced_jumps_dict-->(shelve.DbfilenameShelf object) Holds referenced jump addresses
        Format: {referenced_address1:referenced_by_dict1, referenced_address2:referenced_by_dict2, ...}
        Format of referenced_by_dict: {address1:opcode1, address2:opcode2, ...}

        referenced_calls_dict-->(shelve.DbfilenameShelf object) Holds referenced call addresses
        Format: {referenced_address1:referrer_address_set1, referenced_address2:referrer_address_set2, ...}
    """
    dict_list = []
    if referenced_strings:
        dict_list.append(shelve.open(SysUtils.get_referenced_strings_file(currentpid), "r"))
    if referenced_jumps:
        dict_list.append(shelve.open(SysUtils.get_referenced_jumps_file(currentpid), "r"))
    if referenced_calls:
        dict_list.append(shelve.open(SysUtils.get_referenced_calls_file(currentpid), "r"))
    return dict_list


#:tag:Tools
def search_referenced_strings(searched_str, value_index=type_defs.VALUE_INDEX.INDEX_STRING_UTF8, case_sensitive=False,
                              enable_regex=False):
    """Searches for given str in the referenced strings

    Args:
        searched_str (str): String that will be searched
        value_index (int): Can be a member of type_defs.VALUE_INDEX
        case_sensitive (bool): If True, search will be case sensitive
        enable_regex (bool): If True, searched_str will be treated as a regex expression

    Returns:
        list: [[referenced_address1, reference_count1, found_value1], ...]
        None: If enable_regex is True and searched_str isn't a valid regex expression
    """
    if enable_regex:
        try:
            if case_sensitive:
                regex = re.compile(searched_str)
            else:
                regex = re.compile(searched_str, re.IGNORECASE)
        except Exception as e:
            print("An exception occurred while trying to compile the given regex\n", str(e))
            return
    str_dict = get_dissect_code_data(True, False, False)[0]
    mem_handle = memory_handle()
    returned_list = []
    for address, refs in str_dict.items():
        value = read_memory(int(address, 16), value_index, 100, mem_handle=mem_handle)
        value_str = "" if value is None else str(value)
        if not value_str:
            continue
        if enable_regex:
            if not regex.search(value_str):
                continue
        else:
            if case_sensitive:
                if value_str.find(searched_str) == -1:
                    continue
            else:
                if value_str.lower().find(searched_str.lower()) == -1:
                    continue
        returned_list.append((address, len(refs), value))
    str_dict.close()
    mem_handle.close()
    return returned_list


#:tag:Tools
def search_referenced_calls(searched_str, case_sensitive=True, enable_regex=False):
    """Searches for given str in the referenced calls

    Args:
        searched_str (str): String that will be searched
        case_sensitive (bool): If True, search will be case sensitive
        enable_regex (bool): If True, searched_str will be treated as a regex expression

    Returns:
        list: [[referenced_address1, found_string1], ...]
        None: If enable_regex is True and searched_str isn't a valid regex expression
    """
    param_str = (searched_str, case_sensitive, enable_regex)
    return send_command("pince-search-referenced-calls " + str(param_str), recv_with_file=True)


def complete_command(gdb_command):
    """Tries to complete the given gdb command and returns completion possibilities

    Args:
        gdb_command (str): The gdb command that'll be completed

    Returns:
        list: Possible completions as a list of str
    """
    returned_list = []
    for item in send_command("complete " + gdb_command, cli_output=True).splitlines():
        if not common_regexes.max_completions_reached.search(item):
            returned_list.append(item)
    return returned_list

```

`libpince/GuiUtils.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
# PyQt5 isn't needed to run tests with travis. To reduce the testing time and complexity, we ignore the PyQt5 imports
# There'll be no tests for PyQt5 related functions in GuiUtils.py
try:
    from PyQt5.QtWidgets import QDesktopWidget
except ImportError:
    pass
from . import SysUtils, type_defs, common_regexes


#:tag:GUI
def get_icons_directory():
    """Gets the directory of the icons

    Returns:
        str: Path to the icons directory
    """
    return SysUtils.get_current_script_directory() + "/media/icons"


#:tag:GUI
def center(window):
    """Center the given window to desktop

    Args:
        window (QMainWindow, QWidget etc.): The window that'll be centered to desktop
    """
    window.move(QDesktopWidget().availableGeometry().center() - window.frameGeometry().center())


#:tag:GUI
def center_to_parent(window):
    """Center the given window to it's parent

    Args:
        window (QMainWindow, QWidget etc.): The window that'll be centered to it's parent
    """
    window.move(window.parent().frameGeometry().center() - window.frameGeometry().center())


#:tag:GUI
def center_to_window(window_secondary, window_main):
    """Center the given window_secondary to window_main

    Args:
        window_secondary (QMainWindow, QWidget etc.): The window that'll be centered to window_main
        window_main (QMainWindow, QWidget etc.): The window that window_secondary will centered to
    """
    window_secondary.move(window_main.frameGeometry().center() - window_secondary.frameGeometry().center())


#:tag:GUI
def center_scroll_bar(QScrollBar):
    """Center the given scrollbar

    Args:
        QScrollBar (QScrollbar): The scrollbar that'll be centered
    """
    maximum = QScrollBar.maximum()
    minimum = QScrollBar.minimum()
    QScrollBar.setValue((maximum + minimum) // 2)


#:tag:GUI
def resize_to_contents(QTableWidget):
    """Resizes the columns of the given QTableWidget to its contents
    This also fixes the stretch problem of the last column

    Args:
        QTableWidget (QTableWidget): Self-explanatory
    """
    QTableWidget.resizeColumnsToContents()
    default_size = QTableWidget.horizontalHeader().defaultSectionSize()
    QTableWidget.horizontalHeader().resizeSection(QTableWidget.columnCount() - 1, default_size)


#:tag:GUI
def fill_value_combobox(QCombobox, current_index=type_defs.VALUE_INDEX.INDEX_INT32):
    """Fills the given QCombobox with value_index strings

    Args:
        QCombobox (QCombobox): The combobox that'll be filled
        current_index (int): Can be a member of type_defs.VALUE_INDEX
    """
    for key in type_defs.index_to_text_dict:
        QCombobox.addItem(type_defs.index_to_text_dict[key])
    QCombobox.setCurrentIndex(current_index)


#:tag:GUI
def get_current_row(QObject):
    """Returns the currently selected row index for the given QObject
    If you try to use only selectionModel().currentIndex().row() for this purpose, you'll get the last selected row even
    if it was unselected afterwards. This is why this function exists, it checks the selection state before returning
    the selected row

    Args:
        QObject (QObject): Self-explanatory

    Returns:
        int: Currently selected row. Returns -1 if nothing is selected

    Note:
        This function doesn't work properly when used within signals such as currentItemChanged, currentIndexChanged,
        currentChanged and currentRowChanged. Use the row, item, QModelIndex or whatever the signal provides instead.
        This bug occurs because those signals only update the changed row, not the selectionModel. This causes
        selectionModel().selectedRows() to return None and this function to behave improperly

        For developers: You can use the regex \.current.*\.connect to search signals if a cleanup is needed
    """
    if QObject.selectionModel().selectedRows():
        return QObject.selectionModel().currentIndex().row()
    return -1


#:tag:GUI
def get_current_item(QObject):
    """Returns the currently selected item for the given QObject
    If you try to use only selectionModel().currentItem() for this purpose, you'll get the last selected item even
    if it was unselected afterwards. This is why this function exists, it checks the selection state before returning
    the selected item. Unlike get_current_row, this function can be used with QTreeWidget

    Args:
        QObject (QObject): Self-explanatory

    Returns:
        Any: Currently selected item. Returns None if nothing is selected

    Note:
        This function doesn't work properly when used within signals such as currentItemChanged, currentIndexChanged,
        currentChanged and currentRowChanged. Use the row, item, QModelIndex or whatever the signal provides instead.
        This bug occurs because those signals only update the changed row, not the selectionModel. This causes
        selectionModel().selectedRows() to return None and this function to behave improperly

        For developers: You can use the regex \.current.*\.connect to search signals if a cleanup is needed
    """
    if QObject.selectionModel().selectedRows():
        return QObject.currentItem()


#:tag:GUI
def delete_menu_entries(QMenu, QAction_list):
    """Deletes given QActions from the QMenu recursively and cleans up the remaining redundant separators and menus
    Doesn't support menus that includes types other than actions, separators and menus

    Args:
        QMenu (QMenu): Self-explanatory
        QAction_list (list): List of QActions. Leave blank if you just want to clean the redundant separators up
    """

    def remove_entries(menu):
        for action in menu.actions():
            try:
                QAction_list.index(action)
            except ValueError:
                if action.menu():
                    remove_entries(action.menu())
            else:
                menu.removeAction(action)

    def clean_entries(menu):
        for action in menu.actions():
            if action.menu():
                clean_entries(action.menu())
                if not action.menu().actions():
                    menu.removeAction(action.menu().menuAction())
            elif action.isSeparator():
                actions = menu.actions()
                current_index = actions.index(action)
                if len(actions) == 1 or (current_index == 0 and actions[1].isSeparator()) or \
                        (current_index == -1 and actions[-2].isSeparator()) or \
                        (actions[current_index - 1].isSeparator() and actions[current_index + 1].isSeparator()):
                    menu.removeAction(action)

    remove_entries(QMenu)
    clean_entries(QMenu)


# TODO: This is a really bad design pattern, remove this function after moving classes to their own files
#:tag:GUI
def search_parents_by_function(qt_object, func_name):
    """Search for func_name in the parents of given qt_object. Once function is found, parent that possesses func_name
    is returned

    Args:
        qt_object (object): The object that'll be searched for it's parents
        func_name (str): The name of the function that'll be searched
    """
    while qt_object is not None:
        qt_object = qt_object.parent()
        if func_name in dir(qt_object):
            return qt_object


#:tag:GUI
def get_layout_widgets(layout):
    """Returns the widgets of a layout as a list

    Args:
        layout: Self-explanatory

    Returns:
        list: A list that contains the widgets of the given layout
    """
    return [layout.itemAt(x).widget() for x in range(layout.count())]


#:tag:GUI
def contains_reference_mark(string):
    """Checks if given string contains the reference mark

    Args:
        string (str): String that'll be checked for the reference mark

    Returns:
        bool: True if given string contains the reference mark, False otherwise
    """
    return True if common_regexes.reference_mark.search(string) else False


#:tag:GUI
def append_shortcut_to_tooltip(QObject, QShortcut):
    """Appends key string of the given QShortcut to the toolTip of the given QObject

    Args:
        QObject (QObject): Self-explanatory
        QShortcut (QShortcut): Self-explanatory
    """
    QObject.setToolTip(QObject.toolTip() + "[" + QShortcut.key().toString() + "]")

```

`libpince/Injection/Notes.txt`:

```txt
Compile C files with -g option for gdb to read their symbols.

For example:

"gcc -pthread -shared -g -O2 -o example.so -fPIC example.c"

```

`libpince/Injection/example.c`:

```c
/*
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <stdlib.h>

void *infinite_thread(void *a);

//Injects a thread that runs forever at the background
__attribute__((constructor))
void inject_infinite_thread()
{
	int *a=1;
	pthread_t* threadinf=(pthread_t*) malloc(sizeof(pthread_t));
	pthread_create(threadinf, NULL, infinite_thread, (void*) a);
}

void *infinite_thread(void *a)
{
	while(1)
	{
		sleep(1);
	}
}
```

`libpince/Notes.txt`:

```txt
2/5/2018 - All docstrings that has "\" character in them should start with "r" to make themselves interpreted as raw strings. Otherwise SysUtils.get_docstrings() won't be able to escape "\" by itself. Check these functions for examples:
SysUtils.get_comments_of_variables()
GDB_Engine.create_process()
GDB_Engine.attach()
GDB_Engine.init_gdb()

2/9/2018 - All functions with docstrings should have their subfunctions written after their docstrings. For instance:

    def test():
        """documentation for test"""
        def subtest():
            return
        return

If test is declared like above, test.__doc__ will return "documentation for test" correctly. This is the correct documentation

    def test():
        def subtest():
            return
        """documentation for test"""
        return

If test is declared like above, test.__doc__ will return a null string because subtest blocks the docstring. This is the wrong documentation
All functions that has a subfunction can be found with the regex def.*:.*\s+def

2/9/2018 - Seek methods of all file handles that read directly from the memory(/proc/pid/mem etc.) should be wrapped in a try/except block that catches both OSError and ValueError exceptions. For instance:

    try:
        self.memory.seek(start_addr)
    except (OSError, ValueError):
        break

OSError handles I/O related errors and ValueError handles the off_t limit error that prints "cannot fit 'int' into an offset-sized integer"

12/9/2018 - All namedtuples must have the same field name with their variable names. This makes the namedtuple transferable via pickle. For instance:

    tuple_examine_expression = collections.namedtuple("tuple_examine_expression", "all address symbol")
```

`libpince/PINCEBackend.py`:

```py
"""
    GameConquerorBackend: communication with libscanmem

    Copyright (C) 2010,2011,2013 Wang Lu <coolwanglu(a)gmail.com>
    Copyright (C) 2018 Sebastian Parschauer <s.parschauer(a)gmx.de>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import ctypes, tempfile, os, sys
from ctypes import byref
import re

# taken from https://github.com/scanmem/scanmem/blob/6a5e2e86ebacd87bed132dea354433d722081abf/gui/backend.py
# see https://github.com/scanmem/scanmem/issues/225 for future improvements
class PINCEBackend():
    BACKEND_FUNCTIONS = {
        "sm_init": (ctypes.c_bool, ),
        "sm_cleanup": (None, ),
        "sm_set_backend": (None, ),
        "sm_backend_exec_cmd" : (None, ctypes.c_char_p),
        "sm_get_num_matches" : (ctypes.c_ulong, ),
        "sm_get_version" : (ctypes.c_char_p, ),
        "sm_get_scan_progress" : (ctypes.c_double, ),
        "sm_set_stop_flag" : (None, ctypes.c_bool),
        "sm_process_is_dead": (ctypes.c_bool, )
    }

    """
        scans the current dirrectory (PINCE/libpince) for libscanmem
        @param libname
    """
    def __init__(self, libname="scanmem.so"):
        self.lib = ctypes.CDLL(os.path.dirname(__file__) + os.path.sep + libname)
        self.libc = ctypes.CDLL("libc.so.6")
        self.init_sm_funcs()
        self.lib.sm_init()

    def init_sm_funcs(self):
        for k, v in PINCEBackend.BACKEND_FUNCTIONS.items():
            f = getattr(self.lib, k)
            f.restype = v[0]
            f.argtypes = v[1:]

    def sm_cleanup(self):
        self.lib.sm_cleanup()

    # Used for most of the things, like searching etc
    def sm_exec_cmd(self, cmd, get_output = False):
        if get_output:
            with tempfile.TemporaryFile() as directed_file:
                backup_stdout_fileno = os.dup(sys.stdout.fileno())
                os.dup2(directed_file.fileno(), sys.stdout.fileno())

                self.lib.sm_backend_exec_cmd(ctypes.c_char_p(cmd.encode("ascii")))

                os.dup2(backup_stdout_fileno, sys.stdout.fileno())
                os.close(backup_stdout_fileno)
                directed_file.seek(0)
                return directed_file.read()
        else:
            self.lib.sm_backend_exec_cmd(ctypes.c_char_p(cmd.encode("ascii")))
    def sm_get_num_matches(self):
        return self.lib.sm_get_num_matches()

    def sm_get_version(self):
        return self.lib.sm_get_version()

    def sm_get_scan_progress(self):
        return self.lib.sm_get_scan_progress()

    def sm_set_stop_flag(self, stop_flag):
        self.lib.sm_set_stop_flag(stop_flag)

    def sm_process_is_dead(self, pid):
        self.lib.sm_process_is_dead(pid)

    """
        @param string the string that's returned by libscanmem
        @returns a dictionary with the key as the n:th match, and value the rest of the structure that's returned
    """
    def parse_string(self, string):
        # based on information from the scanmem source, the format for a line from scanmem is:
        # n     address       region id* offset   region type   value   type(s)
        #[4425] 7fd3ef3cf488, 31 +       8cf488,  misc,         12,     [I8 ]
        # * region id = line number in /proc/pid/maps
        # region id can later be probably be used to get like "executable + offset"
        if string == None:
            return None
        ret = dict()
        string = string.decode("utf-8").splitlines()
        if string == None:
            return None
        line_match = re.compile(r"^\[ *(\d+)\] +([\da-f]+), +\d+ \+ +([\da-f]+), +(\w+), (.*), +\[([\w ]+)\]$")
        for row in string:
            (n, address, offset, region_type, value, t) = line_match.match(row).groups()
            ret[n] = {
                "address": address,
                "offset": offset,
                "region_type": region_type,
                "value": value,
                "type": t
            }

```

`libpince/SysUtils.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

# Fixes the ImportError problem in GDBCommandExtensions.py for Archlinux
# This makes any psutil based function that's called from GDB unusable for Archlinux
# Currently there's none but we can't take it for granted, can we?
# TODO: Research the reason behind it or at least find a workaround
try:
    import psutil
except ImportError:
    print("WARNING: GDB couldn't locate the package psutil, psutil based user-defined functions won't work\n" +
          "If you are getting this message without invoking GDB, it means that installation has failed, well, sort of")
import os, shutil, sys, binascii, pickle, json, traceback, re, pwd, pathlib
from . import type_defs, common_regexes
from collections import OrderedDict
from importlib.machinery import SourceFileLoader
from pygdbmi import gdbmiparser


#:tag:Processes
def iterate_processes():
    """Returns a generator of psutil.Process objects corresponding to currently running processes

    Returns:
        generator: Generator of psutil.Process objects

    Note:
        Calling any function from the iterated processes will give the psutil.NoSuchProcess exception if the iterated
        process doesn't exist anymore. Use functions in a try/except block for safety
    """
    return psutil.process_iter()


#:tag:Processes
def get_process_information(pid):
    """Returns a psutil.Process object corresponding to given pid

    Args:
        pid (int): PID of the process

    Returns:
        psutil.Process: psutil.Process object corresponding to the given pid
    """
    return psutil.Process(pid)


#:tag:Processes
def search_in_processes_by_name(process_name):
    """Searches currently running processes and returns a list of psutil.Process objects corresponding to processes that
    has the str process_name in them

    Args:
        process_name (str): Name of the process that'll be searched for

    Returns:
        list: List of psutil.Process objects corresponding to the filtered processes

    Note:
        Calling any function from the iterated processes will give the psutil.NoSuchProcess exception if the iterated
        process doesn't exist anymore. Use functions in a try/except block for safety
    """
    processlist = []
    for p in psutil.process_iter():
        try:
            name = p.name()
        except psutil.NoSuchProcess:
            continue
        if re.search(process_name, name, re.IGNORECASE):
            processlist.append(p)
    return processlist


#:tag:Processes
def get_memory_regions(pid):
    """Returns memory regions as a list of psutil._pslinux.pmmap_ext objects

    Args:
        pid (int): PID of the process

    Returns:
        list: List of psutil._pslinux.pmmap_ext objects corresponding to the given pid
    """
    return psutil.Process(pid).memory_maps(grouped=False)


#:tag:Processes
def get_region_info(pid, address):
    """Finds the closest valid starting/ending address and region to given address, assuming given address is in the
    valid address range

    Args:
        pid (int): PID of the process
        address (int,str): Can be an int or a hex str

    Returns:
        type_defs.tuple_region_info: Starting address as int, ending address as int and region corresponding to
        the given address as psutil._pslinux.pmmap_ext object
        None: If the given address isn't in any valid address range

    Note:
        This function is very slow because of the poor performance on psutil's part. You might want to optimize your
        code while using this function. Check MemoryViewWindowForm.hex_dump_address() for an optimization example
    """
    if type(pid) != int:
        pid = int(pid)
    if type(address) != int:
        address = int(address, 0)
    region_list = get_memory_regions(pid)
    for item in region_list:
        splitted_address = item.addr.split("-")
        start = int(splitted_address[0], 16)
        end = int(splitted_address[1], 16)
        if start <= address < end:
            return type_defs.tuple_region_info(start, end, item)


#:tag:Processes
def filter_memory_regions(pid, attribute, regex, case_sensitive=False):
    """Filters memory regions by searching for the given regex within the given attribute

    Args:
        pid (int): PID of the process
        attribute (str): The attribute that'll be filtered. Can be "addr", "perms" or "path"
        regex (str): Regex statement that'll be searched
        case_sensitive (bool): If True, search will be case sensitive

    Returns:
        list: A list of psutil._pslinux.pmmap_ext objects
    """
    assert attribute in ["addr", "perms", "path"], "invalid attribute"
    if case_sensitive:
        compiled_regex = re.compile(regex)
    else:
        compiled_regex = re.compile(regex, re.IGNORECASE)
    filtered_regions = []
    p = psutil.Process(pid)
    for m in p.memory_maps(grouped=False):
        current_attribute = getattr(m, attribute)
        if compiled_regex.search(current_attribute):
            filtered_regions.append(m)
    return filtered_regions


#:tag:Processes
def is_traced(pid):
    """Check if the process corresponding to given pid traced by any other process

    Args:
        pid (int): PID of the process

    Returns:
        str: Name of the tracer if the specified process is being traced
        bool: False, if the specified process is not being traced or the process doesn't exist anymore
    """
    try:
        status_file = open("/proc/%d/status" % pid)
    except FileNotFoundError:
        return False
    for line in status_file.readlines():
        if line.startswith("TracerPid:"):
            tracer_pid = line.split(":", 1)[1].strip()
            if tracer_pid == "0":
                return False
            else:
                return psutil.Process(int(tracer_pid)).name()


#:tag:Processes
def is_process_valid(pid):
    """Check if the process corresponding to given pid is valid

    Args:
        pid (int): PID of the process

    Returns:
        bool: True if the process is still running, False if not
    """
    return is_path_valid("/proc/%d" % pid)


#:tag:Utilities
def get_current_script_directory():
    """Get current working directory

    Returns:
        str: A string pointing to the current working directory
    """
    return sys.path[0]


#:tag:Utilities
def get_media_directory():
    """Get media directory

    Returns:
        str: A string pointing to the media directory
    """
    return sys.path[0] + "/media"


#:tag:Utilities
def get_logo_directory():
    """Get logo directory

    Returns:
        str: A string pointing to the logo directory
    """
    return sys.path[0] + "/media/logo"


#:tag:Utilities
def get_libpince_directory():
    """Get libpince directory

    Returns:
        str: A string pointing to the libpince directory

    Note:
        In fact this function returns the directory where SysUtils in and considering the fact that SysUtils resides in
        libpince, it works. So, please don't move out SysUtils outside of libpince folder!
    """
    return os.path.dirname(os.path.realpath(__file__))


#:tag:Utilities
def is_path_valid(dest_path, issue_path=""):
    """Check if the given path is valid

    Args:
        dest_path (str): Path
        issue_path (str): If this parameter is passed as "delete", given path will be deleted if it's valid.
        If this parameter is passed as "create", given path path will be created if it's not valid.

    Returns:
        bool: True if path is valid, False if not
    """
    if os.path.exists(dest_path):
        if issue_path == "delete":
            shutil.rmtree(dest_path)
        return True
    else:
        if issue_path == "create":
            os.makedirs(dest_path)
        return False


#:tag:GDBCommunication
def delete_PINCE_IPC_PATH(pid):
    """Deletes the IPC directory of given pid

    Args:
        pid (int,str): PID of the process
    """
    is_path_valid(get_PINCE_IPC_directory(pid), "delete")


#:tag:GDBCommunication
def create_PINCE_IPC_PATH(pid):
    """Creates the IPC directory of given pid

    Args:
        pid (int,str): PID of the process
    """
    delete_PINCE_IPC_PATH(pid)
    is_path_valid(get_PINCE_IPC_directory(pid), "create")

    # Opening the command file with 'w' each time GDB_Engine.send_command() gets invoked slows down the process
    # Instead, here we create the command file for only once when IPC path gets initialized
    # Then, open the command file with 'r' in GDB_Engine.send_command() to get a better performance
    command_file = get_gdb_command_file(pid)
    open(command_file, "w").close()


#:tag:GDBCommunication
def get_PINCE_IPC_directory(pid):
    """Get the IPC directory of given pid

    Args:
        pid (int): PID of the process

    Returns:
        str: Path of IPC directory
    """
    return type_defs.IPC_PATHS.PINCE_IPC_PATH + str(pid)


#:tag:GDBCommunication
def get_logging_file(pid):
    """Get the path of gdb logfile of given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of gdb logfile
    """
    return get_PINCE_IPC_directory(pid) + "/gdb_log.txt"


#:tag:GDBCommunication
def get_gdb_command_file(pid):
    """Get the path of gdb command file of given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of gdb command file
    """
    return get_PINCE_IPC_directory(pid) + "/gdb_command.txt"


#:tag:BreakWatchpoints
def get_track_watchpoint_file(pid, watchpoint_list):
    """Get the path of track watchpoint file for given pid and watchpoint

    Args:
        pid (int,str): PID of the process
        watchpoint_list (list,str): Numbers of the watchpoints

    Returns:
        str: Path of track watchpoint file
    """
    return get_PINCE_IPC_directory(pid) + "/" + str(watchpoint_list) + "_track_watchpoint.txt"


#:tag:BreakWatchpoints
def get_track_breakpoint_file(pid, breakpoint):
    """Get the path of track breakpoint file for given pid and breakpoint

    Args:
        pid (int,str): PID of the process
        breakpoint (str): breakpoint number

    Returns:
        str: Path of track breakpoint file
    """
    return get_PINCE_IPC_directory(pid) + "/" + breakpoint + "_track_breakpoint.txt"


#:tag:Tools
def get_trace_instructions_file(pid, breakpoint):
    """Get the path of trace instructions file for given pid and breakpoint

    Args:
        pid (int,str): PID of the process
        breakpoint (str): breakpoint number

    Returns:
        str: Path of trace instructions file
    """
    return get_PINCE_IPC_directory(pid) + "/" + breakpoint + "_trace.txt"


#:tag:Utilities
def append_file_extension(string, extension):
    """Appends the given extension to the given string if it doesn't end with the given extension

    Args:
        string (str): Self-explanatory
        extension (str): Self-explanatory, you don't have to include the dot

    Returns:
        str: Given string with the extension
    """
    extension = extension.strip(".")
    return string if string.endswith("." + extension) else string + "." + extension


#:tag:Utilities
def save_file(data, file_path, save_method="json"):
    """Saves the specified data to given path

    Args:
        data (??): Saved data, can be anything, must be supported by save_method
        file_path (str): Path of the saved file
        save_method (str): Can be "json" or "pickle"

    Returns:
        bool: True if saved successfully, False if not
    """
    if save_method == "json":
        try:
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            json.dump(data, open(file_path, "w"))
            return True
        except Exception as e:
            print("Encountered an exception while dumping the data\n", e)
            return False
    elif save_method == "pickle":
        try:
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            pickle.dump(data, open(file_path, "wb"))
            return True
        except Exception as e:
            print("Encountered an exception while dumping the data\n", e)
            return False
    else:
        print("Unsupported save_method, bailing out...")
        return False


#:tag:Utilities
def load_file(file_path, load_method="json"):
    """Loads data from the given path

    Args:
        file_path (str): Path of the saved file
        load_method (str): Can be "json" or "pickle"

    Returns:
        ??: file_path is like a box of chocolates, you never know what you're gonna get
        None: If loading fails
    """
    if load_method == "json":
        try:
            output = json.load(open(file_path, "r"), object_pairs_hook=OrderedDict)
        except Exception as e:
            print("Encountered an exception while loading the data\n", e)
            return
    elif load_method == "pickle":
        try:
            output = pickle.load(open(file_path, "rb"))
        except Exception as e:
            print("Encountered an exception while loading the data\n", e)
            return
    else:
        print("Unsupported load_method, bailing out...")
        return
    return output


#:tag:Tools
def get_trace_instructions_status_file(pid, breakpoint):
    """Get the path of trace instructions status file for given pid and breakpoint

    Args:
        pid (int,str): PID of the process
        breakpoint (str): breakpoint number

    Returns:
        str: Path of trace instructions status file
    """
    return get_PINCE_IPC_directory(pid) + "/" + breakpoint + "_trace_status.txt"


#:tag:Tools
def get_dissect_code_status_file(pid):
    """Get the path of dissect code status file for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of dissect code status file
    """
    return get_PINCE_IPC_directory(pid) + "/dissect_code_status.txt"


#:tag:Tools
def get_referenced_strings_file(pid):
    """Get the path of referenced strings dict file for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of referenced strings dict file
    """
    return get_PINCE_IPC_directory(pid) + "/referenced_strings_dict.txt"


#:tag:Tools
def get_referenced_jumps_file(pid):
    """Get the path of referenced jumps dict file for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of referenced jumps dict file
    """
    return get_PINCE_IPC_directory(pid) + "/referenced_jumps_dict.txt"


#:tag:Tools
def get_referenced_calls_file(pid):
    """Get the path of referenced strings dict file for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of referenced calls dict file
    """
    return get_PINCE_IPC_directory(pid) + "/referenced_calls_dict.txt"


#:tag:GDBCommunication
def get_IPC_from_PINCE_file(pid):
    """Get the path of IPC file sent to custom gdb commands from PINCE for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of IPC file
    """
    return get_PINCE_IPC_directory(pid) + type_defs.IPC_PATHS.IPC_FROM_PINCE_PATH


#:tag:GDBCommunication
def get_IPC_to_PINCE_file(pid):
    """Get the path of IPC file sent to PINCE from custom gdb commands for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of IPC file
    """
    return get_PINCE_IPC_directory(pid) + type_defs.IPC_PATHS.IPC_TO_PINCE_PATH


#:tag:ValueType
def parse_string(string, value_index):
    """Parses the string according to the given value_index

    Args:
        string (str): String that'll be parsed
        value_index (int): Determines the type of data. Can be a member of type_defs.VALUE_INDEX

    Returns:
        str: If the value_index is INDEX_STRING
        list: If the value_index is INDEX_AOB. A list of ints is returned
        float: If the value_index is INDEX_FLOAT32 or INDEX_FLOAT64
        int: If the value_index is anything else
        None: If the string is not parsable by using the parameter value_index

    Examples:
        string="42 DE AD BE EF 24",value_index=type_defs.VALUE_INDEX.INDEX_AOB--▼
        returned_list=[66, 222, 173, 190, 239, 36]
    """
    string = str(string)
    if not string:
        print("please enter a string first")
        return
    try:
        value_index = int(value_index)
    except:
        print(str(value_index) + " can't be converted to int")
        return
    if type_defs.VALUE_INDEX.is_string(value_index):
        return string
    string = string.strip()
    if value_index is type_defs.VALUE_INDEX.INDEX_AOB:
        try:
            string_list = common_regexes.whitespaces.split(string)
            for item in string_list:
                if len(item) > 2:
                    print(string + " can't be parsed as array of bytes")
                    return
            hex_list = [int(x, 16) for x in string_list]
            return hex_list
        except:
            print(string + " can't be parsed as array of bytes")
            return
    elif value_index is type_defs.VALUE_INDEX.INDEX_FLOAT32 or value_index is type_defs.VALUE_INDEX.INDEX_FLOAT64:
        try:
            string = float(string)
        except:
            try:
                string = float(int(string, 0))
            except:
                print(string + " can't be parsed as floating point variable")
                return
        return string
    else:
        try:
            string = int(string, 0)
        except:
            try:
                string = int(float(string))
            except:
                print(string + " can't be parsed as integer or hexadecimal")
                return
        if value_index is type_defs.VALUE_INDEX.INDEX_INT8:
            string = string % 0x100  # 256
        elif value_index is type_defs.VALUE_INDEX.INDEX_INT16:
            string = string % 0x10000  # 65536
        elif value_index is type_defs.VALUE_INDEX.INDEX_INT32:
            string = string % 0x100000000  # 4294967296
        elif value_index is type_defs.VALUE_INDEX.INDEX_INT64:
            string = string % 0x10000000000000000  # 18446744073709551616
        return string


#:tag:Assembly
def instruction_follow_address(string):
    """Searches for the location changing instructions such as Jcc, CALL and LOOPcc in the given string. Returns the hex
    address the instruction jumps to

    Args:
        string (str): An assembly expression

    Returns:
        str: Hex address
        None: If no hex address is found or no location changing instructions found
    """
    result = common_regexes.instruction_follow.search(string)
    if result:
        return result.group(2)


#:tag:Utilities
def extract_address(string):
    """Extracts hex address from the given string

    Args:
        string (str): The string that the hex address will be extracted from

    Returns:
        str: Hex address
        None: If no hex address is found
    """
    result = common_regexes.hex_number.search(string)
    if result:
        return result.group(0)


#:tag:Utilities
def modulo_address(int_address, arch_type):
    """Calculates the modulo of the given integer based on the given architecture type to make sure that it doesn't
    exceed the borders of the given architecture type (0xffffffff->x86, 0xffffffffffffffff->x64)

    Args:
        int_address (int): Self-explanatory
        arch_type (int): Architecture type (x86, x64). Can be a member of type_defs.INFERIOR_ARCH

    Returns:
        int: Modulo of the given integer based on the given architecture type
    """
    if arch_type == type_defs.INFERIOR_ARCH.ARCH_32:
        return int_address % 0x100000000
    elif arch_type == type_defs.INFERIOR_ARCH.ARCH_64:
        return int_address % 0x10000000000000000
    raise Exception("arch_type must be a member of type_defs.INFERIOR_ARCH")


#:tag:ValueType
def aob_to_str(list_of_bytes, encoding="ascii"):
    """Converts given array of hex strings to str

    Args:
        list_of_bytes (list): Must be returned from GDB_Engine.hex_dump()
        encoding (str): See here-->https://docs.python.org/3/library/codecs.html#standard-encodings

    Returns:
        str: str equivalent of array
    """

    # 3f is ascii hex representation of char "?"
    return bytes.fromhex("".join(list_of_bytes).replace("??", "3f")).decode(encoding, "surrogateescape")


#:tag:ValueType
def str_to_aob(string, encoding="ascii"):
    """Converts given string to aob string

    Args:
        string (str): Any string
        encoding (str): See here-->https://docs.python.org/3/library/codecs.html#standard-encodings

    Returns:
        str: AoB equivalent of the given string
    """
    s = str(binascii.hexlify(string.encode(encoding, "surrogateescape")), "ascii")
    return " ".join(s[i:i + 2] for i in range(0, len(s), 2))


#:tag:GDBExpressions
def split_symbol(symbol_string):
    """Splits symbol part of type_defs.tuple_function_info into smaller fractions
    Fraction count depends on the the symbol_string. See Examples section for demonstration

    Args:
        symbol_string (str): symbol part of type_defs.tuple_function_info

    Returns:
        list: A list containing parts of the splitted symbol

    Examples:
        symbol_string-->"func(param)@plt"
        returned_list-->["func","func(param)","func(param)@plt"]

        symbol_string-->"malloc@plt"
        returned_list-->["malloc", "malloc@plt"]

        symbol_string-->"printf"
        returned_list-->["printf"]
    """
    returned_list = []
    p_count = 0
    # this algorithm searches for balanced parentheses and removes the outer group
    # using string reversing with recursive re.split makes the code confusing as hell, going with this one instead
    # searching for balanced parentheses works because apparently no demangled symbol can finish with <.*>
    # XXX: run this code to test while attached to a process and open a detailed issue if you get a result
    """
    from libpince import GDB_Engine
    import re
    result=GDB_Engine.search_functions("")
    for address, symbol in result:
        if re.search("<.*>[^()]+$", symbol):
            print(symbol)
    """
    for index, letter in enumerate(symbol_string[::-1]):
        if letter == ")":
            p_count += 1
        elif letter == "(":
            p_count -= 1
            if p_count == 0:
                returned_list.append((symbol_string[:-(index + 1)]))
                break
            assert p_count >= 0, symbol_string + " contains unhealthy amount of left parentheses\nGotta give him some" \
                                                 ' right parentheses. Like Bob always says "everyone needs a friend"'
    assert p_count == 0, symbol_string + " contains unbalanced parentheses"
    if "@plt" in symbol_string:
        returned_list.append(symbol_string.rsplit("@plt", maxsplit=1)[0])
    returned_list.append(symbol_string)
    return returned_list


#:tag:Utilities
def execute_shell_command_as_user(command):
    """Executes given command as user

    Args:
        command (str): Command that'll be invoked from the shell
    """
    uid, gid = get_user_ids()
    os.system("sudo -u '#" + uid + "' " + command)


#:tag:Utilities
def get_docstrings(modules, search_for=""):
    """Gathers docstrings from a list of modules
    For now, this function only supports variables and functions
    See get_comments_of_variables function to learn documenting variables in PINCE style

    Args:
        modules (list): A list of modules
        search_for (str): String that will be searched in variables and functions

    Returns:
        dict: A dict containing docstrings for documented variables and functions
        Format-->{variable1:docstring1, variable2:docstring2, ...}
    """
    element_dict = {}
    variable_comment_dict = get_comments_of_variables(modules)
    for item in modules:
        for key, value in item.__dict__.items():
            name_with_module = get_module_name(item) + "." + key
            if name_with_module in variable_comment_dict:
                element_dict[name_with_module] = variable_comment_dict[name_with_module]
            else:
                element_dict[name_with_module] = value.__doc__
    for item in list(element_dict):
        if item.split(".")[-1].find(search_for) == -1:
            del element_dict[item]
    return element_dict


#:tag:Utilities
def get_comments_of_variables(modules, search_for=""):
    r"""Gathers comments from a list of modules
    Python normally doesn't allow modifying __doc__ variable of the variables
    This function is designed to bring a solution to this problem
    The documentation must be PINCE style. It must start with this--> "#:doc:"
    See examples for more details

    Args:
        modules (list): A list of modules
        search_for (str): String that will be searched in variables

    Returns:
        dict: A dict containing docstrings for documented variables
        Format-->{variable1:docstring1, variable2:docstring2, ...}

    Example for single line comments:
        Code--▼
            #:doc:
            #Documentation for the variable
            some_variable = blablabla
        Returns--▼
            {"some_variable":"Documentation for the variable"}

    Example for multi line comments:
        Code--▼
            #:doc:
            '''Some Header
            Documentation for the variable
            Some Ending Word'''
            some_variable = blablabla
        Returns--▼
            {"some_variable":"Some Header\nDocumentation for the variable\nSome Ending Word"}
    """
    comment_dict = {}
    source_files = []
    for module in modules:
        source_files.append(module.__file__)
    for index, file_path in enumerate(source_files):
        source_file = open(file_path, "r")
        lines = source_file.readlines()
        for row, line in enumerate(lines):
            stripped_line = line.strip()
            if stripped_line.startswith("#:doc:"):
                docstring_list = []
                while True:
                    row += 1
                    current_line = lines[row].strip()
                    if current_line.startswith("#"):
                        docstring_list.append(current_line.replace("#", "", 1))
                    elif current_line.startswith("'''"):
                        current_line = current_line.replace("'''", "", 1)
                        if current_line.endswith("'''"):
                            current_line = current_line.replace("'''", "")
                            docstring_list.append(current_line)
                            continue
                        docstring_list.append(current_line)
                        while True:
                            row += 1
                            current_line = lines[row].strip()
                            if current_line.endswith("'''"):
                                current_line = current_line.replace("'''", "")
                                docstring_list.append(current_line)
                                break
                            docstring_list.append(current_line)
                    else:
                        while True:
                            stripped_current_line = common_regexes.docstring_variable.search(current_line)
                            if stripped_current_line:
                                variable = stripped_current_line.group(1)
                                break
                            row += 1
                            current_line = lines[row].strip()
                        break
                if variable.find(search_for) == -1:
                    continue
                comment_dict[get_module_name(modules[index]) + "." + variable] = "\n".join(docstring_list)
    return comment_dict


#:tag:Utilities
def get_tags(modules, tag_to_string, search_for=""):
    """Gathers tags from a python source file
    The documentation must be PINCE style. It must start like this--> "#:tag:tag_name"
    For now, tagging system only supports variables and functions
    See examples for more details

    Args:
        modules (list): A list of modules
        tag_to_string (dict): A dictionary that holds tag descriptions in this format-->{tag:tag_description}
        Check type_defs.tag_to_string for an example
        search_for (str): String that will be searched in tags

    Returns:
        dict: A dict containing tag keys for tagged variables
        Format-->{tag1_desc:variable_list1, tag2_desc:variable_list2, ...}

    Examples:
        Code--▼
            #:tag:tag_name
            #Documentation for the variable
            some_variable = blablabla

            or

            #:tag:tag_name
            def func_name(...)
        Returns--▼
            {tag_to_string["tag_name"]:list of some_variables or func_names that have the tag tag_name}
    """
    tag_dict = {}
    source_files = []
    for module in modules:
        source_files.append(module.__file__)
    for index, file_path in enumerate(source_files):
        source_file = open(file_path, "r")
        lines = source_file.readlines()
        for row, line in enumerate(lines):
            stripped_line = line.strip()
            if stripped_line.startswith("#:tag:"):
                tag = stripped_line.replace("#:tag:", "", 1)
                while True:
                    row += 1
                    current_line = lines[row].strip()
                    stripped_current_line = common_regexes.docstring_function_or_variable.search(current_line)
                    if stripped_current_line:
                        for item in stripped_current_line.groups():
                            if item:
                                if item.find(search_for) == -1:
                                    break
                                item = get_module_name(modules[index]) + "." + item
                                try:
                                    tag_dict[tag].append(item)
                                except KeyError:
                                    tag_dict[tag] = [item]
                                break
                            else:
                                continue
                        break
    ordered_tag_dict = OrderedDict()
    for tag, desc in tag_to_string.items():
        if tag in tag_dict:
            ordered_tag_dict[desc] = tag_dict[tag]
        else:
            continue
    return ordered_tag_dict


def get_module_name(module):
    """Gets the name of the given module without the package name

    Args:
        module (module): A module

    Returns:
        str: Name of the module
    """
    return module.__name__.replace(module.__package__ + ".", "", 1)


#:tag:Utilities
def init_user_files():
    """Initializes user files"""
    for directory in type_defs.USER_PATHS.get_init_directories():
        is_path_valid(get_user_path(directory), "create")
    for file in type_defs.USER_PATHS.get_init_files():
        file = get_user_path(file)
        try:
            open(file).close()
        except FileNotFoundError:
            open(file, "w").close()


#:tag:Utilities
def get_user_ids():
    """Gets uid and gid of the current user

    Returns:
        tuple: (str, str)-->uid and gid of the current user
    """
    uid = os.getenv("SUDO_UID") or str(os.getuid())
    gid = os.getenv("SUDO_GID") or str(os.getgid())
    return uid, gid


#:tag:Utilities
def get_user_home_dir():
    """Returns the home directory of the current user

    Returns:
        str: Home directory of the current user
    """
    uid, _ = get_user_ids()
    return pwd.getpwuid(int(uid)).pw_dir


#:tag:Utilities
def get_user_path(user_path):
    """Returns the specified user path for the current user

    Args:
        user_path (str): Can be a member of type_defs.USER_PATHS

    Returns:
        str: Specified user path of the current user
    """
    # TODO: Use XDG specification
    homedir = get_user_home_dir()
    return os.path.join(homedir, user_path)


#:tag:Tools
def execute_script(file_path):
    """Loads and executes the script in the given path

    Args:
        file_path (str): Self-explanatory

    Returns:
        tuple: (module, exception)
        module--> Loaded script as module
        exception--> traceback as str

        Returns (None, exception) if fails to load the script
        Returns (module, None) if script gets loaded successfully
    """
    head, tail = os.path.split(file_path)
    file_name = tail.split(".", maxsplit=1)[0]
    try:
        module = SourceFileLoader(file_name, file_path).load_module()
    except Exception as e:
        print("Encountered an exception while loading the script located at " + file_path)
        tb = traceback.format_exception(None, e, e.__traceback__)
        tb.insert(0, "------->You can ignore the importlib part if the source file is valid<-------\n")
        tb = "".join(tb)
        print(tb)
        return None, tb
    return module, None


#:tag:Utilities
def parse_response(response, line_num=0):
    """Parses the given GDB/MI output. Wraps gdbmiparser.parse_response
    GDB_Engine.send_command returns an additional "^done" output because of the "source" command
    This function is used to get rid of that output before parsing

    Args:
        response (str): GDB/MI response
        line_num (int): Which line of the response will be parsed

    Returns:
        dict: Contents of the dict depends on the response
    """
    return gdbmiparser.parse_response(response.splitlines()[line_num])


#:tag:Utilities
def search_files(directory, regex):
    """Searches the files in given directory for given regex recursively

    Args:
        directory (str): Directory to search for
        regex (str): Regex to search for

    Returns:
        list: Sorted list of the relative paths(to the given directory) of the files found
    """
    file_list = []
    for file in pathlib.Path(directory).rglob("*.*"):
        result = re.search(regex, file.name, re.IGNORECASE)
        if result:
            file_list.append(str(file.relative_to(directory)))
    return sorted(file_list)

```

`libpince/common_regexes.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from re import compile

# The comments near regular expressions shows the expected gdb output, hope it helps to the future developers

# --------------------------------------------GDB_Engine----------------------------------------------------------------

# stopped-threads="all"  # *running,thread-id="all"
gdb_state_observe = compile(r"(stopped)-threads=\"all\"|\*(running),thread-id=\"all\"")
gdb_error = compile(r"\^error")
hex_plain = compile(r"[0-9a-fA-F]+")
hex_number = compile(r"0x" + hex_plain.pattern)
hex_number_grouped = compile(r"(" + hex_number.pattern + r")")
address_with_symbol = compile(r"(" + hex_number_grouped.pattern + r"\s*(<.+>)?)")  # 0x7f3067f1174d <poll+45>\n
thread_info = compile(r"\*\s+\d+\s+(.*)\\n")
inferior_pid = compile(r"process\s+(\d+)")
hw_breakpoint_count = compile(r"(hw|read|acc)")
breakpoint_size = compile(r"char\[(\d+)\]")
breakpoint_created = compile(r"breakpoint-created")
breakpoint_number = compile(r"number=\"(\d+)\"")
convenience_variable = compile(r'"(\$\d+)\s+=\s+(.*)"')  # "$26 = 3"
entry_point = compile(r"Entry\s+point:\s+" + hex_number_grouped.pattern)
# The command will always start with the word "source", check GDB_Engine.send_command function for the cause
gdb_command_source = lambda command_file: compile(r"&\".*source\s" + command_file + r"\\n\"")  # &"command\n"
# 0x00007fd81d4c7400 <__printf+0>:\t48 81 ec d8 00 00 00\tsub    rsp,0xd8\n
disassemble_output = compile(r"(" + hex_number.pattern + r".*)\\t(.+)\\t(.+)\\n")
info_functions_non_debugging = compile(hex_number_grouped.pattern + r"\s+(.*)")
max_completions_reached = compile(r"\*\*\*\s+List\s+may\s+be\s+truncated,\s+max-completions\s+reached\.\s+\*\*\*")

# --------------------------------------------SysUtils------------------------------------------------------------------

instruction_follow = compile(r"(j|call|loop).*\s+" + hex_number_grouped.pattern)
docstring_variable = compile(r"(\w+)\s*=")
docstring_function_or_variable = compile(r"def\s+(\w+)|" + docstring_variable.pattern)
whitespaces = compile(r"\s+")

# --------------------------------------------GuiUtils------------------------------------------------------------------

reference_mark = compile(r"\{\d*\}")

# --------------------------------------------GDBCommandExtensions------------------------------------------------------

max_frame_count = compile(r"#(\d+)\s+.*")
frame_address = compile(r"frame\s+at\s+" + hex_number_grouped.pattern)  # frame at 0x7ffe1e989950
return_address = compile(r"saved.*=\s+" + hex_number_grouped.pattern)  # saved rip = 0x7f633a853fe4
trace_instructions_ret = compile(r":\s+ret")  # 0x7f71a4dc5ff8 <poll+72>:	ret
trace_instructions_call = compile(r":\s+call")  # 0x7f71a4dc5fe4 <poll+52>:	call   0x7f71a4de1100
dissect_code_valid_address = compile(r"(\s+|\[|,)" + hex_number.pattern + "(\s+|\]|,|$)")
alphanumerics = compile(r"\w+")

```

`libpince/gdb_python_scripts/GDBCommandExtensions.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import gdb, pickle, json, sys, re, struct, ctypes, os, shelve, distorm3
from collections import OrderedDict

# This is some retarded hack
gdbvalue = gdb.parse_and_eval("$PINCE_PATH")
PINCE_PATH = gdbvalue.string()
sys.path.append(PINCE_PATH)  # Adds the PINCE directory to PYTHONPATH to import libraries from PINCE

from libpince.gdb_python_scripts import ScriptUtils
from libpince import SysUtils, type_defs, common_regexes

inferior = gdb.selected_inferior()
pid = inferior.pid
recv_file = SysUtils.get_IPC_from_PINCE_file(pid)
send_file = SysUtils.get_IPC_to_PINCE_file(pid)

lib = None

# Format of info_list: [count, previous_pc_address, register_info, float_info, disas_info]
# Format of watchpoint_dict: {address1:info_list1, address2:info_list2, ...}
# Format of watchpoint_numbers: str([1,2,3,4,..])
# Format: {watchpoint_numbers1:watchpoint_dict1, watchpoint_numbers2:track_watchpoint_dict2, ...}
track_watchpoint_dict = {}

# Format of expression_info_dict: {value1:count1, value2:count2, ...}
# Format of register_expression_dict: {expression1:expression_info_dict1, expression2:expression_info_dict2, ...}
# Format: {breakpoint_number1:register_expression_dict1, breakpoint_number2:register_expression_dict2, ...}
track_breakpoint_dict = {}


def receive_from_pince():
    return pickle.load(open(recv_file, "rb"))


def send_to_pince(contents_send):
    pickle.dump(contents_send, open(send_file, "wb"))


ScriptUtils.gdbinit()


class IgnoreErrors(gdb.Command):
    def __init__(self):
        super(IgnoreErrors, self).__init__("ignore-errors", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        try:
            gdb.execute(arg, from_tty)
        except:
            pass


class CLIOutput(gdb.Command):
    def __init__(self):
        super(CLIOutput, self).__init__("cli-output", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        try:
            contents_send = gdb.execute(arg, from_tty, to_string=True)
        except Exception as e:
            contents_send = str(e)
        print(contents_send)
        send_to_pince(contents_send)


class ParseAndEval(gdb.Command):
    def __init__(self):
        super(ParseAndEval, self).__init__("pince-parse-and-eval", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        expression, cast = receive_from_pince()
        try:
            value = gdb.parse_and_eval(expression)
            parsed_value = cast(value)
        except Exception as e:
            print(e)
            print("Expression: " + expression)
            print("Cast type: " + str(cast))
            parsed_value = None
        send_to_pince(parsed_value)


class ReadRegisters(gdb.Command):
    def __init__(self):
        super(ReadRegisters, self).__init__("pince-read-registers", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        registers = ScriptUtils.get_general_registers()
        registers.update(ScriptUtils.get_flag_registers())
        registers.update(ScriptUtils.get_segment_registers())
        send_to_pince(registers)


class ReadFloatRegisters(gdb.Command):
    def __init__(self):
        super(ReadFloatRegisters, self).__init__("pince-read-float-registers", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        send_to_pince(ScriptUtils.get_float_registers())


class GetStackTraceInfo(gdb.Command):
    def __init__(self):
        super(GetStackTraceInfo, self).__init__("pince-get-stack-trace-info", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        stacktrace_info_list = []
        if ScriptUtils.current_arch == type_defs.INFERIOR_ARCH.ARCH_64:
            sp_register = "rsp"
        else:
            sp_register = "esp"
        stack_pointer_int = int(ScriptUtils.examine_expression("$" + sp_register).address, 16)
        result = gdb.execute("bt", from_tty, to_string=True)
        max_frame = common_regexes.max_frame_count.findall(result)[-1]

        # +1 because frame numbers start from 0
        for item in range(int(max_frame) + 1):
            result = gdb.execute("info frame " + str(item), from_tty, to_string=True)
            frame_address = common_regexes.frame_address.search(result).group(1)
            difference = hex(int(frame_address, 16) - stack_pointer_int)
            frame_address_with_difference = frame_address + "(" + sp_register + "+" + difference + ")"
            return_address = common_regexes.return_address.search(result)
            if return_address:
                return_address_with_info = ScriptUtils.examine_expression(return_address.group(1)).all
            else:
                return_address_with_info = "<unavailable>"
            stacktrace_info_list.append([return_address_with_info, frame_address_with_difference])
        send_to_pince(stacktrace_info_list)


class GetStackInfo(gdb.Command):
    def __init__(self):
        super(GetStackInfo, self).__init__("pince-get-stack-info", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        stack_info_list = []
        if ScriptUtils.current_arch == type_defs.INFERIOR_ARCH.ARCH_64:
            chunk_size = 8
            int_format = "Q"
            sp_register = "rsp"
        else:
            chunk_size = 4
            int_format = "I"
            sp_register = "esp"
        sp_address = int(ScriptUtils.examine_expression("$" + sp_register).address, 16)
        with open(ScriptUtils.mem_file, "rb") as FILE:
            try:
                old_position = FILE.seek(sp_address)
            except (OSError, ValueError):
                send_to_pince(stack_info_list)
                return
            for index in range(int(4096 / chunk_size)):
                current_offset = chunk_size * index
                stack_indicator = hex(sp_address + current_offset) + "(" + sp_register + "+" + hex(current_offset) + ")"
                try:
                    FILE.seek(old_position)
                    read = FILE.read(chunk_size)
                except (OSError, ValueError):
                    print("Can't access the stack after address " + stack_indicator)
                    break
                old_position = FILE.tell()
                int_addr = struct.unpack_from(int_format, read)[0]
                hex_repr = hex(int_addr)
                try:
                    FILE.seek(int_addr)
                    read_pointer = FILE.read(20)
                except (OSError, ValueError):
                    pointer_data = ""
                else:
                    symbol = ScriptUtils.examine_expression(hex_repr).symbol
                    if not symbol:
                        pointer_data = "(str)" + read_pointer.decode("utf-8", "ignore")
                    else:
                        pointer_data = "(ptr)" + symbol
                stack_info_list.append([stack_indicator, hex_repr, pointer_data])
        send_to_pince(stack_info_list)


class GetFrameReturnAddresses(gdb.Command):
    def __init__(self):
        super(GetFrameReturnAddresses, self).__init__("pince-get-frame-return-addresses", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        return_address_list = []
        result = gdb.execute("bt", from_tty, to_string=True)
        max_frame = common_regexes.max_frame_count.findall(result)[-1]

        # +1 because frame numbers start from 0
        for item in range(int(max_frame) + 1):
            result = gdb.execute("info frame " + str(item), from_tty, to_string=True)
            return_address = common_regexes.return_address.search(result)
            if return_address:
                return_address_with_info = ScriptUtils.examine_expression(return_address.group(1)).all
            else:
                return_address_with_info = "<unavailable>"
            return_address_list.append(return_address_with_info)
        send_to_pince(return_address_list)


class GetFrameInfo(gdb.Command):
    def __init__(self):
        super(GetFrameInfo, self).__init__("pince-get-frame-info", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        frame_number = receive_from_pince()
        result = gdb.execute("bt", from_tty, to_string=True)
        max_frame = common_regexes.max_frame_count.findall(result)[-1]
        if 0 <= int(frame_number) <= int(max_frame):
            frame_info = gdb.execute("info frame " + frame_number, from_tty, to_string=True)
        else:
            print("Frame " + frame_number + " doesn't exist")
            frame_info = None
        send_to_pince(frame_info)


class GetTrackWatchpointInfo(gdb.Command):
    def __init__(self):
        super(GetTrackWatchpointInfo, self).__init__("pince-get-track-watchpoint-info", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        breakpoints = arg
        current_pc_int = int(SysUtils.extract_address(str(gdb.parse_and_eval("$pc"))), 16)
        try:
            disas_output = gdb.execute("disas $pc-30,$pc", to_string=True)

            # Just before the line "End of assembler dump"
            last_instruction = disas_output.splitlines()[-2]
            previous_pc_address = SysUtils.extract_address(last_instruction)
        except:
            previous_pc_address = hex(current_pc_int)
        global track_watchpoint_dict
        try:
            count = track_watchpoint_dict[breakpoints][current_pc_int][0] + 1
        except KeyError:
            if breakpoints not in track_watchpoint_dict:
                track_watchpoint_dict[breakpoints] = OrderedDict()
            count = 1
        register_info = ScriptUtils.get_general_registers()
        register_info.update(ScriptUtils.get_flag_registers())
        register_info.update(ScriptUtils.get_segment_registers())
        float_info = ScriptUtils.get_float_registers()
        disas_info = gdb.execute("disas " + previous_pc_address + ",+40", to_string=True).replace("=>", "  ")
        track_watchpoint_dict[breakpoints][current_pc_int] = [count, previous_pc_address, register_info, float_info,
                                                              disas_info]
        track_watchpoint_file = SysUtils.get_track_watchpoint_file(pid, breakpoints)
        pickle.dump(track_watchpoint_dict[breakpoints], open(track_watchpoint_file, "wb"))


class GetTrackBreakpointInfo(gdb.Command):
    def __init__(self):
        super(GetTrackBreakpointInfo, self).__init__("pince-get-track-breakpoint-info", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        arg_list = arg.split(",")
        breakpoint_number = arg_list.pop()
        register_expressions = arg_list
        global track_breakpoint_dict
        if not breakpoint_number in track_breakpoint_dict:
            track_breakpoint_dict[breakpoint_number] = OrderedDict()
        for register_expression in register_expressions:
            if not register_expression:
                continue
            if not register_expression in track_breakpoint_dict[breakpoint_number]:
                track_breakpoint_dict[breakpoint_number][register_expression] = OrderedDict()
            try:
                address = ScriptUtils.examine_expression(register_expression).address
            except:
                address = None
            if address:
                if address not in track_breakpoint_dict[breakpoint_number][register_expression]:
                    track_breakpoint_dict[breakpoint_number][register_expression][address] = 1
                else:
                    track_breakpoint_dict[breakpoint_number][register_expression][address] += 1
        track_breakpoint_file = SysUtils.get_track_breakpoint_file(pid, breakpoint_number)
        pickle.dump(track_breakpoint_dict[breakpoint_number], open(track_breakpoint_file, "wb"))


class PhaseOut(gdb.Command):
    def __init__(self):
        super(PhaseOut, self).__init__("phase-out", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        gdb.execute("detach")
        gdb.execute("echo Successfully detached from the target pid: " + str(pid))


class PhaseIn(gdb.Command):
    def __init__(self):
        super(PhaseIn, self).__init__("phase-in", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        gdb.execute("attach " + str(pid))
        gdb.execute("echo Successfully attached back to the target pid: " + str(pid))


class TraceInstructions(gdb.Command):
    def __init__(self):
        super(TraceInstructions, self).__init__("pince-trace-instructions", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        (breakpoint, max_trace_count, stop_condition, step_mode, stop_after_trace, collect_general_registers,
         collect_flag_registers, collect_segment_registers, collect_float_registers) = eval(arg)
        gdb.execute("delete " + breakpoint)
        trace_status_file = SysUtils.get_trace_instructions_status_file(pid, breakpoint)

        # The reason we don't use a tree class is to make the tree json-compatible
        # tree format-->[node1, node2, node3, ...]
        # node-->[(line_info, register_dict), parent_index, child_index_list]
        tree = []
        current_index = 0  # Avoid calling len()
        current_root_index = 0
        root_index = 0

        # Root always be an empty node, it's up to you to use or delete it
        tree.append([("", None), None, []])
        for x in range(max_trace_count):
            try:
                output = pickle.load(open(trace_status_file, "rb"))
                if output[0] == type_defs.TRACE_STATUS.STATUS_CANCELED:
                    break
            except:
                pass
            line_info = gdb.execute("x/i $pc", to_string=True).split(maxsplit=1)[1]
            collect_dict = OrderedDict()
            if collect_general_registers:
                collect_dict.update(ScriptUtils.get_general_registers())
            if collect_flag_registers:
                collect_dict.update(ScriptUtils.get_flag_registers())
            if collect_segment_registers:
                collect_dict.update(ScriptUtils.get_segment_registers())
            if collect_float_registers:
                collect_dict.update(ScriptUtils.get_float_registers())
            current_index += 1
            tree.append([(line_info, collect_dict), current_root_index, []])
            tree[current_root_index][2].append(current_index)  # Add a child
            status_info = (type_defs.TRACE_STATUS.STATUS_TRACING,
                           line_info + " (" + str(x + 1) + "/" + str(max_trace_count) + ")")
            pickle.dump(status_info, open(trace_status_file, "wb"))
            if common_regexes.trace_instructions_ret.search(line_info):
                if tree[current_root_index][1] is None:  # If no parents exist
                    current_index += 1
                    tree.append([("", None), None, [current_root_index]])
                    tree[current_root_index][1] = current_index  # Set new parent
                    current_root_index = current_index  # current_node=current_node.parent
                    root_index = current_root_index  # set new root
                else:
                    current_root_index = tree[current_root_index][1]  # current_node=current_node.parent
            elif step_mode == type_defs.STEP_MODE.SINGLE_STEP:
                if common_regexes.trace_instructions_call.search(line_info):
                    current_root_index = current_index
            if stop_condition:
                try:
                    if str(gdb.parse_and_eval(stop_condition)) == "1":
                        break
                except:
                    pass
            if step_mode == type_defs.STEP_MODE.SINGLE_STEP:
                gdb.execute("stepi", to_string=True)
            elif step_mode == type_defs.STEP_MODE.STEP_OVER:
                gdb.execute("nexti", to_string=True)
        status_info = (type_defs.TRACE_STATUS.STATUS_PROCESSING, "Processing the collected data")
        pickle.dump(status_info, open(trace_status_file, "wb"))
        trace_instructions_file = SysUtils.get_trace_instructions_file(pid, breakpoint)
        json.dump((tree, root_index), open(trace_instructions_file, "w"))
        status_info = (type_defs.TRACE_STATUS.STATUS_FINISHED, "Tracing has been completed")
        pickle.dump(status_info, open(trace_status_file, "wb"))
        if not stop_after_trace:
            gdb.execute("c")


class InitSoFile(gdb.Command):
    """Usage: pince-init-so-file so_file_path"""

    def __init__(self):
        super(InitSoFile, self).__init__("pince-init-so-file", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        global lib
        lib = ctypes.CDLL(arg)
        print("Successfully loaded so file from " + arg)


class GetSoFileInformation(gdb.Command):
    def __init__(self):
        super(GetSoFileInformation, self).__init__("pince-get-so-file-information", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        if not lib:
            print("so file isn't initialized, use the command pince-init-so-file")
            return
        print("Loaded so file:\n" + str(lib) + "\n")
        print("Available resources:")
        print(os.system("nm -D --defined-only " + lib._name))


class ExecuteFromSoFile(gdb.Command):
    """Usage: pince-execute-from-so-file lib.func(params)"""

    def __init__(self):
        super(ExecuteFromSoFile, self).__init__("pince-execute-from-so-file", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        global lib
        gdb.execute("p " + str(eval(arg.strip())))


class DissectCode(gdb.Command):
    def __init__(self):
        super(DissectCode, self).__init__("pince-dissect-code", gdb.COMMAND_USER)

    def is_memory_valid(self, int_address, discard_invalid_strings=False):
        try:
            self.memory.seek(int_address)
        except (OSError, ValueError):
            return False  # vsyscall is ignored if vDSO is present, so we can safely ignore vsyscall
        try:
            if discard_invalid_strings:
                data_read = self.memory.read(32)
                if data_read.startswith(b"\0"):
                    return False
                data_read = data_read.split(b"\0", maxsplit=1)[0]
                data_read.decode("utf-8")
            else:
                self.memory.read(1)
        except:
            return False
        return True

    def invoke(self, arg, from_tty):
        if ScriptUtils.current_arch == type_defs.INFERIOR_ARCH.ARCH_64:
            disas_option = distorm3.Decode64Bits
        else:
            disas_option = distorm3.Decode32Bits
        referenced_strings_dict = shelve.open(SysUtils.get_referenced_strings_file(pid), writeback=True)
        referenced_jumps_dict = shelve.open(SysUtils.get_referenced_jumps_file(pid), writeback=True)
        referenced_calls_dict = shelve.open(SysUtils.get_referenced_calls_file(pid), writeback=True)
        region_list, discard_invalid_strings = receive_from_pince()
        dissect_code_status_file = SysUtils.get_dissect_code_status_file(pid)
        region_count = len(region_list)
        self.memory = open(ScriptUtils.mem_file, "rb")

        # Has the best record of 111 secs. Tested on Torchlight 2 with Intel i7-4702MQ CPU and 8GB RAM
        buffer = 0x10000  # Aligned to 2**16
        ref_str_count = len(referenced_strings_dict)
        ref_jmp_count = len(referenced_jumps_dict)
        ref_call_count = len(referenced_calls_dict)
        for region_index, region in enumerate(region_list):
            region_info = region.addr, "Region " + str(region_index + 1) + " of " + str(region_count)
            start_addr, end_addr = region.addr.split("-")
            start_addr = int(start_addr, 16)  # Becomes address of the last disassembled instruction later on
            end_addr = int(end_addr, 16)
            region_finished = False
            while not region_finished:
                remaining_space = end_addr - start_addr
                if remaining_space < buffer:
                    offset = remaining_space
                    region_finished = True
                else:
                    offset = buffer
                status_info = region_info + (hex(start_addr)[2:] + "-" + hex(start_addr + offset)[2:],
                                             ref_str_count, ref_jmp_count, ref_call_count)
                pickle.dump(status_info, open(dissect_code_status_file, "wb"))
                try:
                    self.memory.seek(start_addr)
                except (OSError, ValueError):
                    break
                code = self.memory.read(offset)
                disas_data = distorm3.Decode(start_addr, code, disas_option)
                if not region_finished:
                    last_disas_addr = disas_data[-4][0]
                    for index in range(4):
                        del disas_data[-1]  # Get rid of last 4 instructions to ensure correct bytecode translation
                else:
                    last_disas_addr = 0
                for (instruction_offset, size, instruction, hexdump) in disas_data:
                    if isinstance(instruction, bytes):
                        instruction = instruction.decode()
                    if instruction.startswith("J") or instruction.startswith("LOOP"):
                        found = common_regexes.dissect_code_valid_address.search(instruction)
                        if found:
                            referenced_address_str = common_regexes.hex_number.search(found.group(0)).group(0)
                            referenced_address_int = int(referenced_address_str, 16)
                            if self.is_memory_valid(referenced_address_int):
                                instruction_only = common_regexes.alphanumerics.search(instruction).group(0).casefold()
                                try:
                                    referenced_jumps_dict[referenced_address_str][instruction_offset] = instruction_only
                                except KeyError:
                                    referenced_jumps_dict[referenced_address_str] = {}
                                    referenced_jumps_dict[referenced_address_str][instruction_offset] = instruction_only
                                    ref_jmp_count += 1
                    elif instruction.startswith("CALL"):
                        found = common_regexes.dissect_code_valid_address.search(instruction)
                        if found:
                            referenced_address_str = common_regexes.hex_number.search(found.group(0)).group(0)
                            referenced_address_int = int(referenced_address_str, 16)
                            if self.is_memory_valid(referenced_address_int):
                                try:
                                    referenced_calls_dict[referenced_address_str].add(instruction_offset)
                                except KeyError:
                                    referenced_calls_dict[referenced_address_str] = set()
                                    referenced_calls_dict[referenced_address_str].add(instruction_offset)
                                    ref_call_count += 1
                    else:
                        found = common_regexes.dissect_code_valid_address.search(instruction)
                        if found:
                            referenced_address_str = common_regexes.hex_number.search(found.group(0)).group(0)
                            referenced_address_int = int(referenced_address_str, 16)
                            if self.is_memory_valid(referenced_address_int, discard_invalid_strings):
                                try:
                                    referenced_strings_dict[referenced_address_str].add(instruction_offset)
                                except KeyError:
                                    referenced_strings_dict[referenced_address_str] = set()
                                    referenced_strings_dict[referenced_address_str].add(instruction_offset)
                                    ref_str_count += 1
                start_addr = last_disas_addr
        self.memory.close()


class SearchReferencedCalls(gdb.Command):
    def __init__(self):
        super(SearchReferencedCalls, self).__init__("pince-search-referenced-calls", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        searched_str, case_sensitive, enable_regex = eval(arg)
        if enable_regex:
            try:
                if case_sensitive:
                    regex = re.compile(searched_str)
                else:
                    regex = re.compile(searched_str, re.IGNORECASE)
            except Exception as e:
                print("An exception occurred while trying to compile the given regex\n", str(e))
                return
        str_dict = shelve.open(SysUtils.get_referenced_calls_file(pid), "r")
        returned_list = []
        for index, item in enumerate(str_dict):
            symbol = ScriptUtils.examine_expression(item).all
            if not symbol:
                continue
            if enable_regex:
                if not regex.search(symbol):
                    continue
            else:
                if case_sensitive:
                    if symbol.find(searched_str) == -1:
                        continue
                else:
                    if symbol.lower().find(searched_str.lower()) == -1:
                        continue
            returned_list.append((symbol, len(str_dict[item])))
        str_dict.close()
        send_to_pince(returned_list)


class ExamineExpressions(gdb.Command):
    def __init__(self):
        super(ExamineExpressions, self).__init__("pince-examine-expressions", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        data_read_list = []
        contents_recv = receive_from_pince()
        # contents_recv format: [expression1, expression2, ...]
        for expression in contents_recv:
            result_tuple = ScriptUtils.examine_expression(expression)
            data_read_list.append(result_tuple)
        send_to_pince(data_read_list)


class SearchFunctions(gdb.Command):
    def __init__(self):
        super(SearchFunctions, self).__init__("pince-search-functions", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        expression, case_sensitive = receive_from_pince()
        function_list = []
        if case_sensitive:
            gdb.execute("set case-sensitive on")
        else:
            gdb.execute("set case-sensitive off")
        output = gdb.execute("info functions " + expression, to_string=True).splitlines()
        gdb.execute("set case-sensitive auto")
        for line in output:
            non_debugging = common_regexes.info_functions_non_debugging.search(line)
            if non_debugging:
                function_list.append((non_debugging.group(1), non_debugging.group(2)))
            else:
                if line.endswith(";"):  # defined
                    function_list.append((None, line[:-1]))
        send_to_pince(function_list)


IgnoreErrors()
CLIOutput()
ParseAndEval()
ReadRegisters()
ReadFloatRegisters()
GetStackTraceInfo()
GetStackInfo()
GetFrameReturnAddresses()
GetFrameInfo()
GetTrackWatchpointInfo()
GetTrackBreakpointInfo()
PhaseOut()
PhaseIn()
TraceInstructions()
InitSoFile()
GetSoFileInformation()
ExecuteFromSoFile()
DissectCode()
SearchReferencedCalls()
ExamineExpressions()
SearchFunctions()

```

`libpince/gdb_python_scripts/ScriptUtils.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import gdb, sys, traceback, functools
from collections import OrderedDict

# This is some retarded hack
PINCE_PATH = gdb.parse_and_eval("$PINCE_PATH").string()
GDBINIT_AA_PATH = gdb.parse_and_eval("$GDBINIT_AA_PATH").string()
sys.path.append(PINCE_PATH)  # Adds the PINCE directory to PYTHONPATH to import libraries from PINCE

from libpince import type_defs, common_regexes

inferior = gdb.selected_inferior()
pid = inferior.pid
mem_file = "/proc/" + str(pid) + "/mem"

void_ptr = gdb.lookup_type("void").pointer()

if str(gdb.parse_and_eval("$rax")) == "void":
    current_arch = type_defs.INFERIOR_ARCH.ARCH_32
else:
    current_arch = type_defs.INFERIOR_ARCH.ARCH_64


# Use this function instead of the .gdbinit file
# If you have to load a .gdbinit file, just load it in this function with command "source"
def gdbinit():
    try:
        gdb.execute("source " + GDBINIT_AA_PATH)
    except Exception as e:
        print(e)
    gdb.execute("set disassembly-flavor intel")
    gdb.execute("set case-sensitive auto")
    gdb.execute("set code-cache off")
    gdb.execute("set stack-cache off")


# A decorator for printing exception information because GDB doesn't give proper information about exceptions
# GDB also overrides sys.excepthook apparently. So this is a proper solution to the exception problem
def print_exception(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        try:
            func(*args, **kwargs)
        except Exception as e:
            traceback.print_exception(type(e), e, e.__traceback__)

    return wrapper


def get_general_registers():
    contents_send = OrderedDict()
    if current_arch == type_defs.INFERIOR_ARCH.ARCH_64:
        general_register_list = type_defs.REGISTERS.GENERAL_64
    else:
        general_register_list = type_defs.REGISTERS.GENERAL_32
    for item in general_register_list:
        contents_send[item] = examine_expression("$" + item).address
    return contents_send


def get_flag_registers():
    contents_send = OrderedDict()
    bitwise_flags = bin(int(gdb.parse_and_eval("$eflags")))[2:]
    reversed_bitwise_flags = "".join(reversed(bitwise_flags))
    (contents_send["cf"], contents_send["pf"], contents_send["af"], contents_send["zf"], contents_send["sf"],
     contents_send["tf"], contents_send["if"], contents_send["df"], contents_send["of"]) = ["0"] * 9
    try:
        contents_send["cf"] = reversed_bitwise_flags[0]
        contents_send["pf"] = reversed_bitwise_flags[2]
        contents_send["af"] = reversed_bitwise_flags[4]
        contents_send["zf"] = reversed_bitwise_flags[6]
        contents_send["sf"] = reversed_bitwise_flags[7]
        contents_send["tf"] = reversed_bitwise_flags[8]
        contents_send["if"] = reversed_bitwise_flags[9]
        contents_send["df"] = reversed_bitwise_flags[10]
        contents_send["of"] = reversed_bitwise_flags[11]
    except IndexError:
        pass
    return contents_send


def get_segment_registers():
    contents_send = OrderedDict()
    for item in type_defs.REGISTERS.SEGMENT:
        contents_send[item] = examine_expression("$" + item).address
    return contents_send


def get_float_registers():
    contents_send = OrderedDict()
    for register in type_defs.REGISTERS.FLOAT.ST:
        value = gdb.parse_and_eval("$" + register)
        contents_send[register] = str(value)
    for register in type_defs.REGISTERS.FLOAT.XMM:
        value = gdb.parse_and_eval("$" + register + ".v4_float")
        contents_send[register] = str(value)
    return contents_send


def examine_expression(expression):
    try:
        value = gdb.parse_and_eval(expression).cast(void_ptr)
    except Exception as e:
        print(e, "for expression " + expression)
        return type_defs.tuple_examine_expression(None, None, None)
    result = common_regexes.address_with_symbol.search(str(value))
    return type_defs.tuple_examine_expression(*result.groups())

```

`libpince/gdb_python_scripts/tests/Notes.txt`:

```txt
You can create a .so file from example.c by executing "gcc -shared -o example.so -fPIC example.c" in terminal
```

`libpince/gdb_python_scripts/tests/example.c`:

```c
/*
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <stdio.h>

int hello_world(int count);

int hello_world(int count)
{
  int a;
  for(a=42;a<count+42;a++){
    printf("Hello World! for %d times\n", a-41);
  }
  return a-41;
}
```

`libpince/type_defs.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

# IMPORTANT: Any constant involving only PINCE.py should be declared in PINCE.py

import collections.abc, queue, sys


class CONST_TIME:
    GDB_INPUT_SLEEP = sys.float_info.min


class PATHS:
    GDB_PATH = "/bin/gdb"


class IPC_PATHS:
    PINCE_IPC_PATH = "/dev/shm/PINCE-connection/"  # Use SysUtils.get_PINCE_IPC_directory()
    IPC_FROM_PINCE_PATH = "/from_PINCE_file"  # Use SysUtils.get_IPC_from_PINCE_file()
    IPC_TO_PINCE_PATH = "/to_PINCE_file"  # Use SysUtils.get_IPC_to_PINCE_file()


class USER_PATHS:
    # Use SysUtils.get_user_path() to make use of these

    CONFIG_PATH = ".config/"
    ROOT_PATH = CONFIG_PATH + "PINCE/PINCE_USER_FILES/"
    TRACE_INSTRUCTIONS_PATH = ROOT_PATH + "TraceInstructions/"
    CHEAT_TABLES_PATH = ROOT_PATH + "CheatTables/"
    GDBINIT_PATH = ROOT_PATH + "gdbinit"
    GDBINIT_AA_PATH = ROOT_PATH + "gdbinit_after_attach"
    PINCEINIT_PATH = ROOT_PATH + "pinceinit.py"
    PINCEINIT_AA_PATH = ROOT_PATH + "pinceinit_after_attach.py"

    @staticmethod
    def get_init_directories():
        return USER_PATHS.ROOT_PATH, USER_PATHS.TRACE_INSTRUCTIONS_PATH, USER_PATHS.CHEAT_TABLES_PATH

    @staticmethod
    def get_init_files():
        return USER_PATHS.GDBINIT_PATH, USER_PATHS.GDBINIT_AA_PATH, USER_PATHS.PINCEINIT_PATH, \
               USER_PATHS.PINCEINIT_AA_PATH


class INFERIOR_STATUS:
    INFERIOR_RUNNING = 1
    INFERIOR_STOPPED = 2


class INFERIOR_ARCH:
    ARCH_32 = 1
    ARCH_64 = 2


class INJECTION_METHOD:
    SIMPLE_DLOPEN_CALL = 1
    ADVANCED_INJECTION = 2


class BREAKPOINT_TYPE:
    HARDWARE_BP = 1
    SOFTWARE_BP = 2


class WATCHPOINT_TYPE:
    WRITE_ONLY = 1
    READ_ONLY = 2
    BOTH = 3


class BREAKPOINT_ON_HIT:
    BREAK = 1
    FIND_CODE = 2
    FIND_ADDR = 3
    TRACE = 4


class BREAKPOINT_MODIFY:
    CONDITION = 1
    ENABLE = 2
    DISABLE = 3
    ENABLE_ONCE = 4
    ENABLE_COUNT = 5
    ENABLE_DELETE = 6


class STEP_MODE:
    SINGLE_STEP = 1
    STEP_OVER = 2


class TRACE_STATUS:
    STATUS_IDLE = 1
    STATUS_TRACING = 2
    STATUS_CANCELED = 3
    STATUS_PROCESSING = 4
    STATUS_FINISHED = 5


class STOP_REASON:
    PAUSE = 1
    DEBUG = 2


class ATTACH_RESULT:
    ATTACH_SELF = 1
    ATTACH_SUCCESSFUL = 2
    PROCESS_NOT_VALID = 3
    ALREADY_DEBUGGING = 4
    ALREADY_TRACED = 5
    PERM_DENIED = 6


class TOGGLE_ATTACH:
    ATTACHED = 1
    DETACHED = 2


class REGISTERS:
    GENERAL_32 = ["eax", "ebx", "ecx", "edx", "esi", "edi", "ebp", "esp", "eip"]
    GENERAL_64 = ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "rsp", "rip", "r8", "r9", "r10", "r11", "r12",
                  "r13", "r14", "r15"]
    SEGMENT = ["cs", "ss", "ds", "es", "fs", "gs"]
    FLAG = ["cf", "pf", "af", "zf", "sf", "tf", "if", "df", "of"]

    class FLOAT:
        ST = ["st" + str(i) for i in range(8)]
        XMM = ["xmm" + str(i) for i in range(8)]


class FREEZE_TYPE:
    DEFAULT = 0
    INCREMENT = 1
    DECREMENT = 2


class VALUE_REPR:
    UNSIGNED = 0
    SIGNED = 1
    HEX = 2


class VALUE_INDEX:
    # Beginning of the integer indexes, new integer indexes should be added between 0 and 3
    INDEX_INT8 = 0
    INDEX_INT16 = 1
    INDEX_INT32 = 2
    INDEX_INT64 = 3
    # Ending of the integer indexes

    INDEX_FLOAT32 = 4
    INDEX_FLOAT64 = 5

    # Beginning of the string indexes, new string indexes should be added between 6 and 9
    INDEX_STRING_ASCII = 6
    INDEX_STRING_UTF8 = 7
    INDEX_STRING_UTF16 = 8
    INDEX_STRING_UTF32 = 9
    # Ending of the string indexes

    INDEX_AOB = 10  # Array of Bytes

    @staticmethod
    def is_integer(value_index):
        return VALUE_INDEX.INDEX_INT8 <= value_index <= VALUE_INDEX.INDEX_INT32

    @staticmethod
    def is_string(value_index):
        return VALUE_INDEX.INDEX_STRING_ASCII <= value_index <= VALUE_INDEX.INDEX_STRING_UTF32

    @staticmethod
    def has_length(value_index):
        return VALUE_INDEX.INDEX_STRING_ASCII <= value_index <= VALUE_INDEX.INDEX_STRING_UTF32 or \
               value_index == VALUE_INDEX.INDEX_AOB


class SCAN_INDEX:
    INDEX_INT_ANY = 0
    INDEX_INT8 = 1
    INDEX_INT16 = 2
    INDEX_INT32 = 3
    INDEX_INT64 = 4
    INDEX_FLOAT_ANY = 5
    INDEX_FLOAT32 = 6
    INDEX_FLOAT64 = 7
    INDEX_ANY = 8
    INDEX_STRING = 9
    INDEX_AOB = 10  # Array of Bytes


on_hit_to_text_dict = {
    BREAKPOINT_ON_HIT.BREAK: "Break",
    BREAKPOINT_ON_HIT.FIND_CODE: "Find Code",
    BREAKPOINT_ON_HIT.FIND_ADDR: "Find Address",
    BREAKPOINT_ON_HIT.TRACE: "Trace"
}

# Represents the texts at indexes in the address table
index_to_text_dict = collections.OrderedDict([
    (VALUE_INDEX.INDEX_INT8, "Int8"),
    (VALUE_INDEX.INDEX_INT16, "Int16"),
    (VALUE_INDEX.INDEX_INT32, "Int32"),
    (VALUE_INDEX.INDEX_INT64, "Int64"),
    (VALUE_INDEX.INDEX_FLOAT32, "Float32"),
    (VALUE_INDEX.INDEX_FLOAT64, "Float64"),
    (VALUE_INDEX.INDEX_STRING_ASCII, "String_ASCII"),
    (VALUE_INDEX.INDEX_STRING_UTF8, "String_UTF8"),
    (VALUE_INDEX.INDEX_STRING_UTF16, "String_UTF16"),
    (VALUE_INDEX.INDEX_STRING_UTF32, "String_UTF32"),
    (VALUE_INDEX.INDEX_AOB, "Array of Bytes")
])

text_to_index_dict = collections.OrderedDict()
for key in index_to_text_dict:
    text_to_index_dict[index_to_text_dict[key]] = key

scanmem_result_to_index_dict = collections.OrderedDict([
    ("I8", VALUE_INDEX.INDEX_INT8),
    ("I8u", VALUE_INDEX.INDEX_INT8),
    ("I8s", VALUE_INDEX.INDEX_INT8),
    ("I16", VALUE_INDEX.INDEX_INT16),
    ("I16u", VALUE_INDEX.INDEX_INT16),
    ("I16s", VALUE_INDEX.INDEX_INT16),
    ("I32", VALUE_INDEX.INDEX_INT32),
    ("I32u", VALUE_INDEX.INDEX_INT32),
    ("I32s", VALUE_INDEX.INDEX_INT32),
    ("I64", VALUE_INDEX.INDEX_INT64),
    ("I64u", VALUE_INDEX.INDEX_INT64),
    ("I64s", VALUE_INDEX.INDEX_INT64),
    ("F32", VALUE_INDEX.INDEX_FLOAT32),
    ("F64", VALUE_INDEX.INDEX_FLOAT64),
    ("string", VALUE_INDEX.INDEX_STRING_UTF8),
    ("bytearray", VALUE_INDEX.INDEX_AOB),
])

# Represents the texts at indexes in scan combobox
scan_index_to_text_dict = collections.OrderedDict([
    (SCAN_INDEX.INDEX_INT_ANY, "Int(any)"),
    (SCAN_INDEX.INDEX_INT8, "Int8"),
    (SCAN_INDEX.INDEX_INT16, "Int16"),
    (SCAN_INDEX.INDEX_INT32, "Int32"),
    (SCAN_INDEX.INDEX_INT64, "Int64"),
    (SCAN_INDEX.INDEX_FLOAT_ANY, "Float(any)"),
    (SCAN_INDEX.INDEX_FLOAT32, "Float32"),
    (SCAN_INDEX.INDEX_FLOAT64, "Float64"),
    (SCAN_INDEX.INDEX_ANY, "Any(int, float)"),
    (SCAN_INDEX.INDEX_STRING, "String"),
    (VALUE_INDEX.INDEX_AOB, "Array of Bytes")
])

# Used in scan_data_type option of scanmem
scan_index_to_scanmem_dict = collections.OrderedDict([
    (SCAN_INDEX.INDEX_INT_ANY, "int"),
    (SCAN_INDEX.INDEX_INT8, "int8"),
    (SCAN_INDEX.INDEX_INT16, "int16"),
    (SCAN_INDEX.INDEX_INT32, "int32"),
    (SCAN_INDEX.INDEX_INT64, "int64"),
    (SCAN_INDEX.INDEX_FLOAT_ANY, "float"),
    (SCAN_INDEX.INDEX_FLOAT32, "float32"),
    (SCAN_INDEX.INDEX_FLOAT64, "float64"),
    (SCAN_INDEX.INDEX_ANY, "number"),
    (SCAN_INDEX.INDEX_STRING, "string"),
    (VALUE_INDEX.INDEX_AOB, "bytearray")
])


class SCAN_TYPE:
    EXACT = 0
    INCREASED = 1
    INCREASED_BY = 2
    DECREASED = 3
    DECREASED_BY = 4
    LESS = 5
    MORE = 6
    BETWEEN = 7
    CHANGED = 8
    UNCHANGED = 9
    UNKNOWN = 10


# Represents the texts at indexes in combobox
scan_type_to_text_dict = collections.OrderedDict([
    (SCAN_TYPE.EXACT, "Exact Scan"),
    (SCAN_TYPE.INCREASED, "Increased"),
    (SCAN_TYPE.INCREASED_BY, "Increased by"),
    (SCAN_TYPE.DECREASED, "Decreased"),
    (SCAN_TYPE.DECREASED_BY, "Decreased by"),
    (SCAN_TYPE.LESS, "Less Than"),
    (SCAN_TYPE.MORE, "More Than"),
    (SCAN_TYPE.BETWEEN, "Between"),
    (SCAN_TYPE.CHANGED, "Changed"),
    (SCAN_TYPE.UNCHANGED, "Unchanged"),
    (SCAN_TYPE.UNKNOWN, "Unknown Value")
])


class SCAN_MODE:
    NEW = 0
    ONGOING = 1


class SCAN_SCOPE:
    BASIC = 1
    NORMAL = 2
    FULL_RW = 3
    FULL = 4


scan_scope_to_text_dict = collections.OrderedDict([
    (SCAN_SCOPE.BASIC, "Basic"),
    (SCAN_SCOPE.NORMAL, "Normal"),
    (SCAN_SCOPE.FULL_RW, "Read+Write"),
    (SCAN_SCOPE.FULL, "Full")
])

string_index_to_encoding_dict = {
    VALUE_INDEX.INDEX_STRING_UTF8: ["utf-8", "surrogateescape"],
    VALUE_INDEX.INDEX_STRING_UTF16: ["utf-16", "replace"],
    VALUE_INDEX.INDEX_STRING_UTF32: ["utf-32", "replace"],
    VALUE_INDEX.INDEX_STRING_ASCII: ["ascii", "replace"],
}

string_index_to_multiplier_dict = {
    VALUE_INDEX.INDEX_STRING_UTF8: 2,
    VALUE_INDEX.INDEX_STRING_UTF16: 4,
    VALUE_INDEX.INDEX_STRING_UTF32: 8,
}

# first value is the length and the second one is the type
# Check ScriptUtils for an exemplary usage
index_to_valuetype_dict = {
    VALUE_INDEX.INDEX_INT8: [1, "B"],
    VALUE_INDEX.INDEX_INT16: [2, "H"],
    VALUE_INDEX.INDEX_INT32: [4, "I"],
    VALUE_INDEX.INDEX_INT64: [8, "Q"],
    VALUE_INDEX.INDEX_FLOAT32: [4, "f"],
    VALUE_INDEX.INDEX_FLOAT64: [8, "d"],
    VALUE_INDEX.INDEX_STRING_ASCII: [None, None],
    VALUE_INDEX.INDEX_STRING_UTF8: [None, None],
    VALUE_INDEX.INDEX_STRING_UTF16: [None, None],
    VALUE_INDEX.INDEX_STRING_UTF32: [None, None],
    VALUE_INDEX.INDEX_AOB: [None, None]
}

# Check ScriptUtils for an exemplary usage
index_to_struct_pack_dict = {
    VALUE_INDEX.INDEX_INT8: "B",
    VALUE_INDEX.INDEX_INT16: "H",
    VALUE_INDEX.INDEX_INT32: "I",
    VALUE_INDEX.INDEX_INT64: "Q",
    VALUE_INDEX.INDEX_FLOAT32: "f",
    VALUE_INDEX.INDEX_FLOAT64: "d"
}

# Format: {tag:tag_description}
tag_to_string = collections.OrderedDict([
    ("MemoryRW", "Memory Read/Write"),
    ("ValueType", "Value Type"),
    ("Injection", "Injection"),
    ("Debug", "Debugging"),
    ("BreakWatchpoints", "Breakpoints&Watchpoints"),
    ("Threads", "Threads"),
    ("Registers", "Registers"),
    ("Stack", "Stack&StackTrace"),
    ("Assembly", "Disassemble&Assemble"),
    ("GDBExpressions", "GDB Expressions"),
    ("GDBCommunication", "GDB Communication"),
    ("Tools", "Tools"),
    ("Utilities", "Utilities"),
    ("Processes", "Processes"),
    ("GUI", "GUI"),
    ("ConditionsLocks", "Conditions&Locks"),
    ("GDBInformation", "GDB Information"),
    ("InferiorInformation", "Inferior Information"),
])

# size-->int, any other field-->str
tuple_breakpoint_info = collections.namedtuple("tuple_breakpoint_info", "number breakpoint_type \
                                                disp enabled address size on_hit hit_count enable_count condition")

# start, end-->int, region-->psutil.Process.memory_maps()[item]
tuple_region_info = collections.namedtuple("tuple_region_info", "start end region")

# all fields-->str/None
tuple_examine_expression = collections.namedtuple("tuple_examine_expression", "all address symbol")

# all fields-->bool
gdb_output_mode = collections.namedtuple("gdb_output_mode", "async_output command_output command_info")


class InferiorRunningException(Exception):
    def __init__(self, message="Inferior is running"):
        super(InferiorRunningException, self).__init__(message)


class GDBInitializeException(Exception):
    def __init__(self, message="GDB not initialized"):
        super(GDBInitializeException, self).__init__(message)


class Frozen:
    def __init__(self, value, freeze_type):
        self.value = value
        self.freeze_type = freeze_type


class ValueType:
    def __init__(self, value_index, length, zero_terminate, value_repr=VALUE_REPR.UNSIGNED):
        """
        Args:
            value_index (int): Determines the type of data. Can be a member of VALUE_INDEX
            length (int): Length of the data. Only used when the value_index is INDEX_STRING or INDEX_AOB
            zero_terminate (bool): If False, ",NZT" will be appended to the text representation
            Only used when value_index is INDEX_STRING. Ignored otherwise. "NZT" stands for "Not Zero Terminate"
            value_repr (int): Determines how the data is represented. Can be a member of VALUE_REPR
        """
        self.value_index = value_index
        self.length = length
        self.zero_terminate = zero_terminate
        self.value_repr = value_repr

    def serialize(self):
        return self.value_index, self.length, self.zero_terminate, self.value_repr

    def text(self):
        """Returns the text representation according to its members

        Returns:
            str: A str generated by given parameters

        Examples:
            value_index=VALUE_INDEX.INDEX_STRING_UTF16, length=15, zero_terminate=False--▼
            returned str="String_UTF16[15],NZT"
            value_index=VALUE_INDEX.INDEX_AOB, length=42-->returned str="AoB[42]"
        """
        returned_string = index_to_text_dict[self.value_index]
        if VALUE_INDEX.is_string(self.value_index):
            returned_string = returned_string + "[" + str(self.length) + "]"
            if not self.zero_terminate:
                returned_string += ",NZT"
        elif self.value_index == VALUE_INDEX.INDEX_AOB:
            returned_string += "[" + str(self.length) + "]"
        if VALUE_INDEX.is_integer(self.value_index):
            if self.value_repr == VALUE_REPR.SIGNED:
                returned_string += "(s)"
            elif self.value_repr == VALUE_REPR.HEX:
                returned_string += "(h)"
        return returned_string


class RegisterQueue:
    def __init__(self):
        self.queue_list = []

    def register_queue(self):
        new_queue = queue.Queue()
        self.queue_list.append(new_queue)
        return new_queue

    def broadcast_message(self, message):
        for item in self.queue_list:
            item.put(message)

    def delete_queue(self, queue_instance):
        try:
            self.queue_list.remove(queue_instance)
        except ValueError:
            pass


class KeyboardModifiersTupleDict(collections.abc.Mapping):
    def _convert_to_int(self, tuple_key):
        return tuple(int(x) for x in tuple_key)

    def __init__(self, OrderedDict_like_list):
        new_dict = {}
        for tuple_key, value in OrderedDict_like_list:
            new_dict[self._convert_to_int(tuple_key)] = value
        self._storage = new_dict

    def __getitem__(self, tuple_key):
        return self._storage[self._convert_to_int(tuple_key)]

    def __iter__(self):
        return iter(self._storage)

    def __len__(self):
        return len(self._storage)

```

`run_tests.py`:

```py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import unittest, argparse, psutil
from libpince import GDB_Engine, SysUtils

desc = 'Runs all unit tests by creating or attaching to a process'
ex = 'Example of Usage:' \
     + '\n\tsudo python3 run_tests.py -a kmines' \
     + '\n\tsudo python3 run_tests.py -c /usr/games/kmines -o="-v"'

parser = argparse.ArgumentParser(description=desc, epilog=ex, formatter_class=argparse.RawDescriptionHelpFormatter)
parser.add_argument("-a", metavar="process_name", type=str, help="Attaches to the process with given name")
parser.add_argument("-c", metavar="file_path", type=str, help="Creates a new process with given path")
parser.add_argument("-o", metavar="options", type=str, default="",
                    help="Arguments that'll be passed to the inferior, only can be used with -c, optional")
parser.add_argument("-l", metavar="ld_preload_path", type=str, default="",
                    help="Path of the preloaded .so file, only can be used with -c, optional")

args = parser.parse_args()
if args.a:
    process_list = SysUtils.search_in_processes_by_name(args.a)
    if not process_list:
        parser.error("There's no process with the name " + args.a)
    if len(process_list) > 1:
        for p in process_list:
            try:
                name = p.name()
            except psutil.NoSuchProcess:
                print("Process with pid", p.pid, "does not exist anymore")
                continue
            print(name)
        print("There are more than one process with the name " + args.a)
        exit()
    pid = process_list[0].pid
    if not GDB_Engine.can_attach(pid):
        parser.error("Failed to attach to the process with pid " + str(pid))
    GDB_Engine.attach(pid)
elif args.c:
    if not GDB_Engine.create_process(args.c, args.o, args.l):
        parser.error("Couldn't create the process with current args")
else:
    parser.error("Provide at least one of these arguments: -a or -c")
unittest.main(module="tests.GDB_Engine_tests", exit=False, argv=[""])
unittest.main(module="tests.SysUtils_tests", exit=False, argv=[""])
unittest.main(module="tests.GuiUtils_tests", exit=False, argv=[""])
GDB_Engine.detach()

```

`tests/GDB_Engine_tests.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import unittest
from libpince import GDB_Engine, type_defs, common_regexes


class GDB_Engine_tests(unittest.TestCase):
    def test_read_registers(self):
        register_dict = GDB_Engine.read_registers()
        if GDB_Engine.inferior_arch == type_defs.INFERIOR_ARCH.ARCH_64:
            test_register = "rax"
        else:
            test_register = "eax"
        self.assertRegex(register_dict[test_register], common_regexes.hex_number.pattern)

```

`tests/GuiUtils_tests.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import unittest


# from libpince import GuiUtils


class GuiUtils_tests(unittest.TestCase):
    def test_change_text_length(self):
        self.assertEqual(True, True)
        # The function below was removed during refactorization, thus making this test just a placeholder for now
        # self.assertEqual(GuiUtils.change_text_length("AoB[42]", 30), "AoB[30]")

```

`tests/SysUtils_tests.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import unittest
from libpince import SysUtils


class SysUtils_tests(unittest.TestCase):
    def test_split_symbol(self):
        self.assertListEqual(SysUtils.split_symbol("func(param)@plt"), ["func", "func(param)", "func(param)@plt"])

```

`tests/common_defs.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
# This source file will be used for things that are shared between test modules

```