Project Path: arc_gmh5225_DLLirant_whgllz04

Source Tree:

```txt
arc_gmh5225_DLLirant_whgllz04
├── DLLirant.NET
│   ├── App.config
│   ├── App.xaml
│   ├── App.xaml.cs
│   ├── Classes
│   │   ├── CodeGenerator.cs
│   │   ├── FileOperations.cs
│   │   └── PEAnalyser.cs
│   ├── DLLProxying.xaml
│   ├── DLLProxying.xaml.cs
│   ├── DLLirant.NET.csproj
│   ├── FodyWeavers.xml
│   ├── MainWindow.xaml
│   ├── MainWindow.xaml.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   ├── Resources.resx
│   │   ├── Settings.Designer.cs
│   │   └── Settings.settings
│   ├── ViewModel
│   │   └── DataContextViewModel.cs
│   ├── background.png
│   ├── background2.png
│   ├── dllirant.ico
│   └── packages.config
├── DLLirant.NET.sln
├── LICENSE
├── README.md
├── live.gif
├── old-python-version
│   ├── DLLirant.py
│   ├── DLLirantDLL
│   │   └── dllmain-preset.cpp
│   ├── live.gif
│   └── screenshot.png
├── screenshot.png
└── screenshot2.png

```

`DLLirant.NET.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32421.90
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DLLirant.NET", "DLLirant.NET\DLLirant.NET.csproj", "{AF730346-CEF0-4CC6-A1CA-7FC0F6BA4DF1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AF730346-CEF0-4CC6-A1CA-7FC0F6BA4DF1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{AF730346-CEF0-4CC6-A1CA-7FC0F6BA4DF1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{AF730346-CEF0-4CC6-A1CA-7FC0F6BA4DF1}.Debug|x64.ActiveCfg = Debug|x64
		{AF730346-CEF0-4CC6-A1CA-7FC0F6BA4DF1}.Debug|x64.Build.0 = Debug|x64
		{AF730346-CEF0-4CC6-A1CA-7FC0F6BA4DF1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{AF730346-CEF0-4CC6-A1CA-7FC0F6BA4DF1}.Release|Any CPU.Build.0 = Release|Any CPU
		{AF730346-CEF0-4CC6-A1CA-7FC0F6BA4DF1}.Release|x64.ActiveCfg = Release|x64
		{AF730346-CEF0-4CC6-A1CA-7FC0F6BA4DF1}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F41CD02F-8AF4-480E-9D6D-C85F33C686E9}
	EndGlobalSection
EndGlobal

```

`DLLirant.NET/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.2" />
    </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="ControlzEx" publicKeyToken="69f1c32f803d307e" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.1.2" newVersion="4.0.1.2" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Security.Cryptography.Pkcs" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-6.0.0.1" newVersion="6.0.0.1" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.2.0" newVersion="4.1.2.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Reflection" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.2.0" newVersion="4.1.2.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Diagnostics.Tracing" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.2.0.0" newVersion="4.2.0.0" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>

```

`DLLirant.NET/App.xaml`:

```xaml
<Application x:Class="DLLirant.NET.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:DLLirant.NET"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <!-- MahApps.Metro resource dictionaries. Make sure that all file names are Case Sensitive! -->
                <ResourceDictionary Source="pack://application:,,,/MahApps.Metro;component/Styles/Controls.xaml" />
                <ResourceDictionary Source="pack://application:,,,/MahApps.Metro;component/Styles/Fonts.xaml" />
                <!-- Theme setting -->
                <ResourceDictionary Source="pack://application:,,,/MahApps.Metro;component/Styles/Themes/Dark.Green.xaml" />
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
</Application>

```

`DLLirant.NET/App.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;

namespace DLLirant.NET
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
    }
}

```

`DLLirant.NET/Classes/CodeGenerator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Management;

namespace DLLirant.NET.Classes
{
    internal class CodeGenerator
    {
        public string CppCode;

        public enum TypeDLLHijacking
        {
            DLLSearchOrderHijacking,
            OrdinalBased
        }

        public void GenerateDLL(string dllmain, List<string> functions = null, TypeDLLHijacking typeDLLHijacking = TypeDLLHijacking.DLLSearchOrderHijacking)
        {
            CppCode = string.Empty;
            if (typeDLLHijacking == TypeDLLHijacking.DLLSearchOrderHijacking)
            {
                CppCode =
                "#include <windows.h>\r\n" +
                "#include <stdio.h>\r\n\r\n" +

                "#pragma comment (lib, \"User32.lib\")\r\n\r\n" +
                "int Main() {\r\n" +
                    "\tFILE* fptr;\r\n" +
                    "\tfopen_s(&fptr, \"C:\\\\DLLirant\\\\output.txt\", \"w\");\r\n" +
                    "\tfprintf(fptr, \"%s\", \"It works !\");\r\n" +
                    "\tfclose(fptr);\r\n" +
                    "\tMessageBoxW(0, L\"DLL Hijack found!\", L\"DLL Hijack\", 0);\r\n" +
                    "\treturn 1;\r\n" +
                "}\r\n\r\n" +
                "BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)\r\n" +
                "{\r\n" +
                    "\tswitch (ul_reason_for_call) {\r\n" +
                        "\t\tcase DLL_PROCESS_ATTACH:\r\n" +
                            "\t\t\t" + dllmain + "\r\n" +
                            "\t\t\tbreak;\r\n" +
                        "\t\tcase DLL_THREAD_ATTACH:\r\n" +
                        "\t\tcase DLL_THREAD_DETACH:\r\n" +
                        "\t\tcase DLL_PROCESS_DETACH:\r\n" +
                            "\t\t\tbreak;\r\n" +
                    "\t}\r\n" +
                    "\treturn TRUE;\r\n" +
                    "}\r\n\r\n";
            }
            else
            {
                CppCode =
                "#include <windows.h>\r\n" +
                "#include <string>\r\n" +

                "#pragma comment (lib, \"User32.lib\")\r\n\r\n" +
                "int Main(int nb) {\r\n" +
                    "\tstd::wstring message = std::to_wstring(nb);\r\n" +
                    "\tMessageBoxW(0, message.data(), L\"DLL Hijack\", 0);\r\n" +
                "\treturn 1;\r\n" +
                "}\r\n\r\n" +
                "BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)\r\n" +
                "{\r\n" +
                    "\tswitch (ul_reason_for_call) {\r\n" +
                        "\t\tcase DLL_PROCESS_ATTACH:\r\n" +
                            "\t\t\t" + dllmain + "\r\n" +
                            "\t\t\tbreak;\r\n" +
                        "\t\tcase DLL_THREAD_ATTACH:\r\n" +
                        "\t\tcase DLL_THREAD_DETACH:\r\n" +
                        "\t\tcase DLL_PROCESS_DETACH:\r\n" +
                            "\t\t\tbreak;\r\n" +
                    "\t}\r\n" +
                    "\treturn TRUE;\r\n" +
                    "}\r\n\r\n";
            }

            if (functions != null) { CppCode += string.Join("\n", functions.ToArray()); };

            using (StreamWriter writer = new StreamWriter("output/dllmain.cpp"))
            {
                writer.WriteLine(CppCode);
            }

            ExecuteCommand("cmd.exe", "/C clang++.exe dllmain.cpp -o DLLirantDLL.dll -shared");
        }

        public bool StartExecutable(string path)
        {
            ExecuteCommand(path);

            if (File.Exists("C:\\DLLirant\\output.txt"))
                return true;
            return false;
        }

        private void ExecuteCommand(string path, string arguments = null, int maxRetries = 3)
        {
            Process process = new Process();
            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.WindowStyle = ProcessWindowStyle.Hidden;
            startInfo.FileName = path;
            if (arguments != null)
                startInfo.Arguments = arguments;
            startInfo.WorkingDirectory = $"{Directory.GetCurrentDirectory()}\\output";
            process.StartInfo = startInfo;
            process.Start();
            while (!process.HasExited)
            {
                process.WaitForExit(3000);
                maxRetries--;
                if (maxRetries <= 0)
                {
                    KillProcessAndChildrens(process.Id);
                }
            }
        }

        private static void KillProcessAndChildrens(int pid)
        {
            ManagementObjectSearcher processSearcher = new ManagementObjectSearcher
              ("Select * From Win32_Process Where ParentProcessID=" + pid);
            ManagementObjectCollection processCollection = processSearcher.Get();

            // We must kill child processes first!
            if (processCollection != null)
                foreach (ManagementObject mo in processCollection)
                {
                    KillProcessAndChildrens(Convert.ToInt32(mo["ProcessID"]));
                }

            // Then kill parents.
            try
            {
                Process proc = Process.GetProcessById(pid);
                if (!proc.HasExited) proc.Kill();
            }
            catch(System.ComponentModel.Win32Exception)
            {
                // Access Denied.
            }
            catch (ArgumentException)
            {
                // Process already exited.
            }
        }
    }
}

```

`DLLirant.NET/Classes/FileOperations.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Windows;

namespace DLLirant.NET.Classes
{
    internal class FileOperations
    {
        public void CreateDirectory(string path)
        {
            if (!Directory.Exists(path))
                Directory.CreateDirectory(path);
        }

        public void DeleteDirectory(string path)
        {
            if (Directory.Exists(path))
                try
                {
                    Directory.Delete(path, true);
                }
                catch (UnauthorizedAccessException) { }
                catch (IOException) { MessageBox.Show("ERROR: The output directory is used by another process"); }
        }

        public void CopyFile(string file)
        {
            if (!File.Exists($"output/{Path.GetFileName(file)}"))
                File.Copy(file, $"output/{Path.GetFileName(file)}");
        }

        public void RenameFile(string path, string newpath)
        {
            if (File.Exists(path) && !File.Exists(newpath))
                File.Move(path, newpath);
        }

        public void CopyFilesDirToDir(string dllname, string sourceDir, string targetDir)
        {
            if (Directory.Exists(sourceDir))
                foreach (string file in Directory.GetFiles(sourceDir))
                {
                    if (Path.GetFileName(file) != dllname)
                        File.Copy(file, Path.Combine(targetDir, Path.GetFileName(file)));
                }
        }

        public void RecreateOutputDirectories(List<string> directories)
        {
            foreach (string dir in directories)
            {
                DeleteDirectory(dir);
                CreateDirectory(dir);
            }
        }

        public void SaveDllHijackingLogs(string outputfile, string module, string pefile, List<string> functions)
        {
            using (StreamWriter sw = File.AppendText(outputfile))
            {
                sw.WriteLine($"[+] DLL SEARCH ORDER HIJACKING FOUND IN: {module}\n");
                sw.WriteLine($"BINARY: {pefile}");
                foreach (string function in functions)
                {
                    sw.WriteLine($"extern \"C\" __declspec(dllexport) void {function}() {{ Main(); }}");
                }
                sw.WriteLine("\n");
            }
        }

        public void SaveDllLivePaths(string outputfile, string pefile, List<string> modules)
        {
            using (StreamWriter sw = File.AppendText(outputfile))
            {
                sw.WriteLine($"[+] POTENTIAL DLL SIDE LOADING IN: {pefile}\n");
                foreach (string module in modules)
                {
                    sw.WriteLine(module);
                }
                sw.WriteLine("\n");
            }
        }

        public void SaveCppCode(string outputfile, string code)
        {
            CreateDirectory("dll-hijack-codes-found");
            using (StreamWriter sw = File.CreateText($"dll-hijack-codes-found\\{outputfile}"))
            {
                sw.WriteLine(code);
            }
        }
    }
}

```

`DLLirant.NET/Classes/PEAnalyser.cs`:

```cs
using PeNet;
using System.Collections.Generic;

namespace DLLirant.NET.Classes
{
    internal class PEAnalyser
    {
        public string SelectedBinaryPath;

        private PeFile peFile;

        public PEAnalyser(string path)
        {
            SelectedBinaryPath = path;
            peFile = new PeFile(SelectedBinaryPath);
        }

        public List<string> GetPEInformations()
        {
            List<string> peInformations = new List<string>();

            if (peFile.HasValidSignature)
            {
                peInformations.Add("Is signature valid: Yes");
            }
            else
            {
                peInformations.Add("Is signature valid: No");
            }

            if (peFile.Is64Bit)
            {
                peInformations.Add("Architecture: x64");
            }
            else if (peFile.Is32Bit)
            {
                peInformations.Add("Architecture: x86");
            }
            else
            {
                peInformations.Add("Architecture: Unknown");
            }

            peInformations.Add($"MD5: {peFile.Md5}");
            peInformations.Add($"SHA1: {peFile.Sha1}");
            peInformations.Add($"SHA256: {peFile.Sha256}");
            return peInformations;
        }

        public string CheckIfSigned()
        {
            if (peFile.IsSigned)
            {
                return "Is signed: Yes";
            }
            else
            {
                return "Is signed: No";
            }
        }

        public List<string> GetModules(List<string> excludesList)
        {
            List<string> modules = new List<string>();
            foreach (PeNet.Header.Pe.ImportFunction func in peFile.ImportedFunctions)
            {
                bool isExcluded = false;
                foreach (string exclude in excludesList)
                {
                    if (func.DLL.ToLower().Contains(exclude.ToLower()))
                    {
                        isExcluded = true;
                        break;
                    }
                }
                if (!modules.Contains(func.DLL) && !isExcluded)
                {
                    modules.Add(func.DLL);
                }
            }
            return modules;
        }

        public List<string> GetImportedFunctions(string moduleName)
        {
            List<string> importedFunctions = new List<string>();
            foreach (PeNet.Header.Pe.ImportFunction func in peFile.ImportedFunctions)
            {
                if(func.DLL == moduleName && func.Name != null)
                {
                    importedFunctions.Add(func.Name);
                }
            }
            return importedFunctions;
        }
    }
}

```

`DLLirant.NET/DLLProxying.xaml`:

```xaml
<UserControl x:Class="DLLirant.NET.DLLProxying"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:local="clr-namespace:DLLirant.NET"
             mc:Ignorable="d" 
             d:DesignHeight="450" d:DesignWidth="700">
    <Grid Background="Black">
        <Image Source="background2.png" Stretch="Fill" Height="{Binding ActualHeight, ElementName=ItemsContainer}" VerticalAlignment="Top" />
        <Grid>
            <Grid.ColumnDefinitions>
                <ColumnDefinition />
                <ColumnDefinition />
            </Grid.ColumnDefinitions>
            <Grid Grid.Column="0">
                <StackPanel>
                    <TextBlock Margin="5, 20, 5, 0" HorizontalAlignment="Center" Text="Generate a classic proxy DLL:" Foreground="White" FontWeight="Bold" FontStyle="Italic" FontFamily="Consolas" />
                    <TextBlock Margin="10" Text="Select the targeted DLL:" Foreground="White" FontFamily="Consolas" TextAlignment="Center" />
                    <Button Margin="5" Width="100" Content="Browse" Click="Button_Click" />
                    <TextBlock Margin="10" Text="Targeted DLL:" Foreground="White" FontFamily="Consolas" TextAlignment="Center" />
                    <TextBlock x:Name="TargetedDLL" Margin="10" Text="None" Foreground="White" FontFamily="Consolas" TextAlignment="Center" TextWrapping="Wrap" />
                    <TextBlock Margin="10" Text="Path to use in the Proxy DLL (by default it will be 'proxy' but you can use full path like 'C:\\Windows\\System32\\foobar.dll'):" Foreground="White" FontFamily="Consolas" TextAlignment="Center" TextWrapping="Wrap" />
                    <TextBox x:Name="TextBoxPathProxyDLL" Margin="5" ToolTip="Write the path of the proxy DLL" Width="200" />
                    <Button x:Name="ButtonGenerateClassicDLL" Margin="5" Width="200" Content="Generate" Click="Button_Click_2" IsEnabled="False" />
                </StackPanel>
            </Grid>
            <Grid Grid.Column="1">
                <StackPanel>
                    <TextBlock Margin="5, 20, 5, 0" HorizontalAlignment="Center" Text="Generate an Ordinal based proxy DLL:" Foreground="White" FontWeight="Bold" FontStyle="Italic" FontFamily="Consolas" />
                    <TextBlock Margin="10" Text="Name of the DLL to generate:" Foreground="White" FontFamily="Consolas" TextAlignment="Center" />
                    <TextBox x:Name="TextBoxOrdinalDLLName" Margin="5" ToolTip="Write the name of the DLL that you want to generate" Width="200" />
                    <TextBlock Margin="10" Text="Number of Ordinal to export:" Foreground="White" FontFamily="Consolas" TextAlignment="Center" />
                    <DockPanel Margin="10" VerticalAlignment="Center" Width="300">
                        <TextBox Text="{Binding ElementName=sliderValue, Path=Value, UpdateSourceTrigger=PropertyChanged}" DockPanel.Dock="Right" TextAlignment="Right" Width="45" Margin="10,0,0,0" />
                        <Slider Maximum="10000" TickFrequency="1" IsSnapToTickEnabled="True" Name="sliderValue" />
                    </DockPanel>
                    <Button Margin="5" Width="200" Content="Generate" Click="Button_Click_3" />
                </StackPanel>
            </Grid>
        </Grid>
    </Grid>
</UserControl>

```

`DLLirant.NET/DLLProxying.xaml.cs`:

```cs
using DLLirant.NET.Classes;
using Microsoft.Win32;
using PeNet;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;

namespace DLLirant.NET
{
    /// <summary>
    /// Interaction logic for DLLProxying.xaml
    /// </summary>
    public partial class DLLProxying : UserControl
    {
        string SelectedDLL;

        public DLLProxying()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            OpenFileDialog openFileDialog = new OpenFileDialog
            {
                Filter = "DLL files (*.dll)|*.dll",
                Multiselect = false
            };

            if (openFileDialog.ShowDialog() == true)
            {
                SelectedDLL = openFileDialog.FileName;
                if (SelectedDLL.EndsWith(".dll"))
                {
                    ButtonGenerateClassicDLL.IsEnabled = true;
                    TargetedDLL.Text = SelectedDLL;
                }
            }
        }

        private async void Button_Click_2(object sender, RoutedEventArgs e)
        {
            Button button = (Button)sender;
            button.Content = "Generating...";
            button.IsEnabled = false;

            PeFile peFile = new PeFile(SelectedDLL);
            FileOperations fileOp = new FileOperations();
            CodeGenerator codeGenerator = new CodeGenerator();

            fileOp.RecreateOutputDirectories(new List<string> { "output/" });

            List<string> exportedFunctions = new List<string>();
            string proxyPath = "proxy";
            if (TextBoxPathProxyDLL.Text.Length > 0)
            {
                proxyPath = TextBoxPathProxyDLL.Text.Replace(".dll", string.Empty);
            }
            foreach (PeNet.Header.Pe.ExportFunction func in peFile.ExportedFunctions)
            {
                exportedFunctions.Add($"#pragma comment(linker,\"/export:{func.Name}={proxyPath}.{func.Name},@{func.Ordinal}\")");
            }
            await Task.Run(() =>
            {
                codeGenerator.GenerateDLL("Main();", exportedFunctions);
            });

            if (proxyPath.StartsWith("C:"))
            {
                fileOp.RenameFile("output/DLLirantDLL.dll", $"output/{Path.GetFileName(SelectedDLL)}");
            }
            else
            {
                fileOp.CopyFile(SelectedDLL);
                fileOp.RenameFile($"output/{Path.GetFileName(SelectedDLL)}", $"output/{proxyPath}.dll");
                fileOp.RenameFile("output/DLLirantDLL.dll", $"output/{Path.GetFileName(SelectedDLL)}");
            }

            button.Content = "Success!";
            await Task.Run(() =>
            {
                Thread.Sleep(2000);
            });
            button.Content = "Generate";
            button.IsEnabled = true;
        }

        private async void Button_Click_3(object sender, RoutedEventArgs e)
        {
            Button button = (Button)sender;
            button.Content = "Generating...";
            button.IsEnabled = false;
            FileOperations fileOp = new FileOperations();
            CodeGenerator codeGenerator = new CodeGenerator();

            fileOp.RecreateOutputDirectories(new List<string> { "output/" });

            string dllName = TextBoxOrdinalDLLName.Text;
            List<string> exportedFunctions = new List<string>();
            for (int i = 0; i < sliderValue.Value; i++)
            {
                exportedFunctions.Add($"extern \"C\" __declspec(dllexport) void DLLIrant{i}() {{ Main({i}); }};");
            }

            await Task.Run(() =>
            {
                codeGenerator.GenerateDLL(string.Empty, exportedFunctions, CodeGenerator.TypeDLLHijacking.OrdinalBased);
            });
            if (dllName.Length > 0)
            {
                if (!dllName.EndsWith(".dll"))
                {
                    dllName = $"{dllName}.dll";
                }
                fileOp.RenameFile("output/DLLirantDLL.dll", $"output/{dllName}");
            }
            button.Content = "Success!";
            await Task.Run(() =>
            {
                Thread.Sleep(2000);
            });
            button.Content = "Generate";
            button.IsEnabled = true;
        }
    }
}

```

`DLLirant.NET/DLLirant.NET.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="..\packages\Costura.Fody.5.7.0\build\Costura.Fody.props" Condition="Exists('..\packages\Costura.Fody.5.7.0\build\Costura.Fody.props')" />
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{AF730346-CEF0-4CC6-A1CA-7FC0F6BA4DF1}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>DLLirant.NET</RootNamespace>
    <AssemblyName>DLLirant.NET</AssemblyName>
    <TargetFrameworkVersion>v4.6.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
    <TargetFrameworkProfile />
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>dllirant.ico</ApplicationIcon>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="ControlzEx, Version=5.0.0.0, Culture=neutral, PublicKeyToken=69f1c32f803d307e, processorArchitecture=MSIL">
      <HintPath>..\packages\ControlzEx.5.0.1\lib\net462\ControlzEx.dll</HintPath>
    </Reference>
    <Reference Include="Costura, Version=5.7.0.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>..\packages\Costura.Fody.5.7.0\lib\netstandard1.0\Costura.dll</HintPath>
    </Reference>
    <Reference Include="MahApps.Metro, Version=2.0.0.0, Culture=neutral, PublicKeyToken=51482d6f650b2b3f, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.2.4.9\lib\net46\MahApps.Metro.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.BootstrapIcons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.BootstrapIcons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.BoxIcons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.BoxIcons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Codicons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Codicons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Coolicons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Coolicons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Core.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Entypo, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Entypo.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.EvaIcons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.EvaIcons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.FeatherIcons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.FeatherIcons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.FileIcons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.FileIcons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Fontaudio, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Fontaudio.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.FontAwesome, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.FontAwesome.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Fontisto, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Fontisto.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.ForkAwesome, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.ForkAwesome.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Ionicons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Ionicons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.JamIcons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.JamIcons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Material, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Material.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.MaterialDesign, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.MaterialDesign.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.MaterialLight, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.MaterialLight.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Microns, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Microns.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Modern, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Modern.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Octicons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Octicons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.PicolIcons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.PicolIcons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.PixelartIcons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.PixelartIcons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.RadixIcons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.RadixIcons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.RemixIcon, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.RemixIcon.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.RPGAwesome, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.RPGAwesome.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.SimpleIcons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.SimpleIcons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Typicons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Typicons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Unicons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Unicons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.VaadinIcons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.VaadinIcons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.WeatherIcons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.WeatherIcons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Zondicons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>..\packages\MahApps.Metro.IconPacks.4.11.0\lib\net46\MahApps.Metro.IconPacks.Zondicons.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.Win32.Primitives, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Win32.Primitives.4.3.0\lib\net46\Microsoft.Win32.Primitives.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.Xaml.Behaviors, Version=1.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Xaml.Behaviors.Wpf.1.1.39\lib\net45\Microsoft.Xaml.Behaviors.dll</HintPath>
    </Reference>
    <Reference Include="PeNet, Version=2.9.8.0, Culture=neutral, PublicKeyToken=6cf2bfba59bcfb3f, processorArchitecture=MSIL">
      <HintPath>..\packages\PeNet.2.9.8\lib\netstandard2.0\PeNet.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="PeNet.Asn1, Version=2.0.0.0, Culture=neutral, PublicKeyToken=1e2e3568f0050bf5, processorArchitecture=MSIL">
      <HintPath>..\packages\PeNet.Asn1.2.0.0\lib\net461\PeNet.Asn1.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.AppContext, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.AppContext.4.3.0\lib\net46\System.AppContext.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Buffers, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Buffers.4.5.1\lib\net461\System.Buffers.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.ComponentModel.Composition" />
    <Reference Include="System.ComponentModel.DataAnnotations" />
    <Reference Include="System.Configuration" />
    <Reference Include="System.Console, Version=4.0.1.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Console.4.3.1\lib\net46\System.Console.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Data" />
    <Reference Include="System.Diagnostics.DiagnosticSource, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Diagnostics.DiagnosticSource.6.0.0\lib\net461\System.Diagnostics.DiagnosticSource.dll</HintPath>
    </Reference>
    <Reference Include="System.Diagnostics.Tracing, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Diagnostics.Tracing.4.3.0\lib\net462\System.Diagnostics.Tracing.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Globalization.Calendars, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Globalization.Calendars.4.3.0\lib\net46\System.Globalization.Calendars.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.4.3.0\lib\net462\System.IO.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.Compression, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.Compression.4.3.0\lib\net46\System.IO.Compression.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.Compression.FileSystem" />
    <Reference Include="System.IO.Compression.ZipFile, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.Compression.ZipFile.4.3.0\lib\net46\System.IO.Compression.ZipFile.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.FileSystem.4.3.0\lib\net46\System.IO.FileSystem.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.FileSystem.Primitives, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.FileSystem.Primitives.4.3.0\lib\net46\System.IO.FileSystem.Primitives.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Linq, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Linq.4.3.0\lib\net463\System.Linq.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Linq.Expressions, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Linq.Expressions.4.3.0\lib\net463\System.Linq.Expressions.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Management" />
    <Reference Include="System.Memory, Version=4.0.1.2, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Memory.4.5.5\lib\net461\System.Memory.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Net.Http, Version=4.1.1.3, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Net.Http.4.3.4\lib\net46\System.Net.Http.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Net.Sockets.4.3.0\lib\net46\System.Net.Sockets.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Numerics" />
    <Reference Include="System.Numerics.Vectors, Version=4.1.4.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Numerics.Vectors.4.5.0\lib\net46\System.Numerics.Vectors.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Reflection, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Reflection.4.3.0\lib\net462\System.Reflection.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime, Version=4.1.1.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.4.3.1\lib\net462\System.Runtime.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.CompilerServices.Unsafe, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.CompilerServices.Unsafe.6.0.0\lib\net461\System.Runtime.CompilerServices.Unsafe.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.Extensions, Version=4.1.1.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.Extensions.4.3.1\lib\net462\System.Runtime.Extensions.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.InteropServices, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.InteropServices.4.3.0\lib\net462\System.Runtime.InteropServices.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.InteropServices.RuntimeInformation, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.InteropServices.RuntimeInformation.4.3.0\lib\net45\System.Runtime.InteropServices.RuntimeInformation.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security" />
    <Reference Include="System.Security.Cryptography.Algorithms, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.Algorithms.4.3.1\lib\net461\System.Security.Cryptography.Algorithms.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Encoding, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.Encoding.4.3.0\lib\net46\System.Security.Cryptography.Encoding.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Pkcs, Version=6.0.0.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.Pkcs.6.0.1\lib\net461\System.Security.Cryptography.Pkcs.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Primitives, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.Primitives.4.3.0\lib\net46\System.Security.Cryptography.Primitives.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.X509Certificates, Version=4.1.1.2, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Cryptography.X509Certificates.4.3.2\lib\net461\System.Security.Cryptography.X509Certificates.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Text.RegularExpressions, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Text.RegularExpressions.4.3.1\lib\net463\System.Text.RegularExpressions.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Web" />
    <Reference Include="System.Web.Extensions" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="System.Xml.ReaderWriter, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Xml.ReaderWriter.4.3.1\lib\net46\System.Xml.ReaderWriter.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="Classes\CodeGenerator.cs" />
    <Compile Include="Classes\FileOperations.cs" />
    <Compile Include="Classes\PEAnalyser.cs" />
    <Compile Include="DLLProxying.xaml.cs">
      <DependentUpon>DLLProxying.xaml</DependentUpon>
    </Compile>
    <Compile Include="ViewModel\DataContextViewModel.cs" />
    <Page Include="DLLProxying.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <None Include="packages.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <Resource Include="FodyWeavers.xml" />
  </ItemGroup>
  <ItemGroup>
    <Resource Include="background.png" />
  </ItemGroup>
  <ItemGroup>
    <Resource Include="dllirant.ico" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.6.2">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.6.2 %28x86 et x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="background2.png" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\packages\Fody.6.6.3\build\Fody.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Fody.6.6.3\build\Fody.targets'))" />
    <Error Condition="!Exists('..\packages\Costura.Fody.5.7.0\build\Costura.Fody.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Costura.Fody.5.7.0\build\Costura.Fody.props'))" />
    <Error Condition="!Exists('..\packages\Costura.Fody.5.7.0\build\Costura.Fody.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Costura.Fody.5.7.0\build\Costura.Fody.targets'))" />
    <Error Condition="!Exists('..\packages\NETStandard.Library.2.0.3\build\netstandard2.0\NETStandard.Library.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\NETStandard.Library.2.0.3\build\netstandard2.0\NETStandard.Library.targets'))" />
  </Target>
  <Import Project="..\packages\Fody.6.6.3\build\Fody.targets" Condition="Exists('..\packages\Fody.6.6.3\build\Fody.targets')" />
  <Import Project="..\packages\Costura.Fody.5.7.0\build\Costura.Fody.targets" Condition="Exists('..\packages\Costura.Fody.5.7.0\build\Costura.Fody.targets')" />
  <Import Project="..\packages\NETStandard.Library.2.0.3\build\netstandard2.0\NETStandard.Library.targets" Condition="Exists('..\packages\NETStandard.Library.2.0.3\build\netstandard2.0\NETStandard.Library.targets')" />
</Project>
```

`DLLirant.NET/FodyWeavers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
	<Costura IncludeAssemblies="System.*|Microsoft.*|ControlzEx|MahApps.Metro|MahApps.Metro.IconPacks.Core|MahApps.Metro.IconPacks.Unicons|PeNet*" />
</Weavers>
```

`DLLirant.NET/MainWindow.xaml`:

```xaml
<mah:MetroWindow x:Class="DLLirant.NET.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:mah="clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro"
        xmlns:iconPacks="http://metro.mahapps.com/winfx/xaml/iconpacks"
        xmlns:local="clr-namespace:DLLirant.NET"
        mc:Ignorable="d"
        Title="DLLirant.NET" Height="720" Width="1280" WindowStartupLocation="CenterScreen">
    <Window.DataContext>
        <local:DataContextViewModel />
    </Window.DataContext>
    <mah:MetroWindow.LeftWindowCommands>
        <mah:WindowCommands>
            <Button Click="ButtonOpenGitHub_Click" ToolTip="Open up the GitHub site">
                <iconPacks:PackIconUnicons Width="22" Height="22" Kind="Github" />
            </Button>
        </mah:WindowCommands>
    </mah:MetroWindow.LeftWindowCommands>
    <mah:MetroWindow.RightWindowCommands>
        <mah:WindowCommands>
            <Button Click="ButtonDllProxying_Click" ToolTip="DLL Proxying">
                <Button.ContentTemplate>
                    <DataTemplate>
                        <StackPanel Orientation="Horizontal">
                            <iconPacks:PackIconUnicons Width="22" Height="22" VerticalAlignment="Center" Kind="FileMedicalAlt" />
                            <TextBlock Margin="5 0 0 0" VerticalAlignment="Center" Text="DLL Proxying" />
                        </StackPanel>
                    </DataTemplate>
                </Button.ContentTemplate>
            </Button>
            <Button Click="ButtonSelectBinary_Click" ToolTip="Select your targeted PE file">
                <Button.ContentTemplate>
                    <DataTemplate>
                        <StackPanel Orientation="Horizontal">
                            <iconPacks:PackIconUnicons Width="22" Height="22" VerticalAlignment="Center" Kind="FileImport" />
                            <TextBlock Margin="5 0 0 0" VerticalAlignment="Center" Text="Select PE File" />
                        </StackPanel>
                    </DataTemplate>
                </Button.ContentTemplate>
            </Button>
            <Button x:Name="ButtonStart" IsEnabled="False" ToolTip="Analyze the binary automatically to find DLL Search Order Hijackings or Proxying your dll" Click="ButtonStart_Click">
                <Button.ContentTemplate>
                    <DataTemplate>
                        <StackPanel Orientation="Horizontal">
                            <iconPacks:PackIconUnicons Width="22" Height="22" VerticalAlignment="Center" Kind="Play" />
                            <TextBlock Margin="5 0 0 0" VerticalAlignment="Center" Text="Find DLL Hijackings" />
                        </StackPanel>
                    </DataTemplate>
                </Button.ContentTemplate>
            </Button>
        </mah:WindowCommands>
    </mah:MetroWindow.RightWindowCommands>
    <Grid Background="Black">
        <Image Source="background.png" Stretch="Fill" Height="{Binding ActualHeight, ElementName=ItemsContainer}" VerticalAlignment="Top" />
        <Grid>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="2*" />
                <ColumnDefinition />
            </Grid.ColumnDefinitions>
            <ListBox Grid.Column="0" ItemsSource="{Binding Logs}" HorizontalContentAlignment="Stretch" Background="Transparent" Foreground="White">
                <ListBox.Resources>
                    <Style TargetType="{x:Type ListBoxItem}">
                        <Setter Property="Background" Value="Transparent" />
                    </Style>
                </ListBox.Resources>
            </ListBox>
            <Grid Grid.Column="1">
                <Grid.RowDefinitions>
                    <RowDefinition Height="3.5*" />
                    <RowDefinition />
                </Grid.RowDefinitions>
                <ListBox x:Name="ListBoxExcludes" Grid.Row="0" ItemsSource="{Binding ExcludesDLLs}" HorizontalContentAlignment="Right" Background="Transparent" Foreground="White">
                    <ListBox.Resources>
                        <Style TargetType="{x:Type ListBoxItem}">
                            <Setter Property="Background" Value="Transparent" />
                        </Style>
                    </ListBox.Resources>
                </ListBox>
                <StackPanel Grid.Row="1" Margin="0,5,0,5" VerticalAlignment="Bottom">
                    <TextBlock Text="Add a DLL in the exclusion list:" Foreground="White" TextAlignment="Center" FontFamily="Consolas" />
                    <Grid Margin="0,5,0,0">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="2*" />
                            <ColumnDefinition />
                        </Grid.ColumnDefinitions>
                        <TextBox x:Name="TextBoxExcludeAdd" Grid.Column="0" Margin="5,0,5,0" Background="Transparent" />
                        <Button Grid.Column="1" Content="ADD" Foreground="White" Margin="5,0,5,0" Background="Transparent" Click="ButtonAddExclude_Click" />
                    </Grid>
                    <Button Content="Delete Selected DLL" Margin="5" Background="Transparent" Click="ButtonDeleteExclude_Click" />
                </StackPanel>
            </Grid>
        </Grid>
    </Grid>
</mah:MetroWindow>
```

`DLLirant.NET/MainWindow.xaml.cs`:

```cs
using System.Windows;
using System.Windows.Controls;
using MahApps.Metro.Controls;
using Microsoft.Win32;
using System.IO;
using System.Collections.Generic;
using DLLirant.NET.Classes;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Threading;
using System;
using System.Linq;

namespace DLLirant.NET
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : MetroWindow
    {
        readonly DataContextViewModel data = new DataContextViewModel();
        
        PEAnalyser peAnalyser;

        bool isStarted = false;

        public MainWindow()
        {
            InitializeComponent();
            DataContext = data;
            data.Logs.Clear();
        }

        private void DisplayPEFileInformations()
        {
            data.Logs.Clear();
            foreach (string info in peAnalyser.GetPEInformations())
            {
                data.Logs.Add(info);
            }
            data.Logs.Add("===========================================================");
        }

        private void ButtonSelectBinary_Click(object sender, RoutedEventArgs e)
        {
            Button button = (Button)sender;
            TextBlock textBlock = button.FindChild<TextBlock>();

            OpenFileDialog openFileDialog = new OpenFileDialog();
            openFileDialog.Filter = "PE files (*.exe)|*.exe";
            openFileDialog.Multiselect = false;

            if (openFileDialog.ShowDialog() == true)
            {
                textBlock.Text = Path.GetFileName(openFileDialog.FileName);
                if (openFileDialog.FileName.EndsWith(".exe"))
                {
                    ButtonStart.IsEnabled = true;
                    peAnalyser = new PEAnalyser(openFileDialog.FileName);
                }
            }
        }

        private async void ButtonStart_Click(object sender, RoutedEventArgs e)
        {
            Button button = (Button)sender;
            TextBlock textBlock = button.FindChild<TextBlock>();
            if (!isStarted)
            {
                textBlock.Text = "Stop";
                isStarted = true;
            } else {
                textBlock.Text = "Find DLL Hijackings";
                isStarted = false;
            }

            SynchronizationContext uiContext = SynchronizationContext.Current;
            FileOperations fileOp = new FileOperations();
            CodeGenerator codeGenerator = new CodeGenerator();

            if (isStarted) {
                if (MessageBox.Show("Do you want to test dll hijackings? If you click on NO, the application will go to live debugging to recover potential files that could be hijacked.", "Test dll hijackings?", MessageBoxButton.YesNo) == MessageBoxResult.Yes)
                {
                    // Get Modules.
                    List<string> modules = peAnalyser.GetModules(data.ExcludesDLLs.ToList());
                    foreach (string module in modules)
                    {
                        if (isStarted)
                        {
                            bool isDllHijackingFound = false;

                            // Get PE Informations and display them.
                            DisplayPEFileInformations();
                            fileOp.RecreateOutputDirectories(new List<string> { "output/", "C:\\DLLirant\\" });
                            fileOp.CopyFilesDirToDir(module, "import/", "output/");

                            // Testing DllMain().
                            data.Logs.Add($"Testing DllMain...");
                            await Task.Run(() =>
                            {
                                codeGenerator.GenerateDLL("CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)Main, NULL, NULL, NULL);");
                                fileOp.CopyFile(peAnalyser.SelectedBinaryPath);
                                fileOp.RenameFile("output/DLLirantDLL.dll", $"output/{module}");
                                isDllHijackingFound = codeGenerator.StartExecutable(Path.GetFileName(peAnalyser.SelectedBinaryPath));
                            });

                            if (isDllHijackingFound)
                            {
                                data.Logs.Add($"[+] DLL Search Order Hijacking found in the binary {Path.GetFileName(peAnalyser.SelectedBinaryPath)} with the DLL {module} !");
                                fileOp.SaveDllHijackingLogs("hijackings-found.txt", module, peAnalyser.SelectedBinaryPath, new List<string> { "DllMain" });
                                isDllHijackingFound = false;
                            }

                            // Get Imported Functions and test them one by one.
                            List<string> importedFunctions = peAnalyser.GetImportedFunctions(module);
                            List<string> functionsToTest = new List<string>();
                            foreach (string importedFunc in importedFunctions)
                            {
                                if (isStarted)
                                {
                                    DisplayPEFileInformations();
                                    fileOp.RecreateOutputDirectories(new List<string> { "output/", "C:\\DLLirant\\" });
                                    fileOp.CopyFilesDirToDir(module, "import/", "output/");

                                    data.Logs.Add($"Testing {module}...");

                                    functionsToTest.Add($"extern \"C\" __declspec(dllexport) void {importedFunc}() {{ Main(); }}");
                                    foreach (string function in functionsToTest)
                                    {
                                        data.Logs.Add(function);
                                    }
                                    data.Logs.Add("==========================");

                                    await Task.Run(() =>
                                    {
                                        codeGenerator.GenerateDLL(string.Empty, functionsToTest);
                                        fileOp.CopyFile(peAnalyser.SelectedBinaryPath);
                                        fileOp.RenameFile("output/DLLirantDLL.dll", $"output/{module}");
                                        isDllHijackingFound = codeGenerator.StartExecutable(Path.GetFileName(peAnalyser.SelectedBinaryPath));
                                    });

                                    if (isDllHijackingFound)
                                    {
                                        data.Logs.Add($"[+] DLL Search Order Hijacking found in the binary {Path.GetFileName(peAnalyser.SelectedBinaryPath)} with the DLL {module} !");
                                        fileOp.SaveDllHijackingLogs("hijackings-found.txt", module, peAnalyser.SelectedBinaryPath, functionsToTest);
                                        fileOp.SaveCppCode($"{Path.GetFileName(peAnalyser.SelectedBinaryPath)}-{module}.cpp", codeGenerator.CppCode);
                                        isDllHijackingFound = false;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Testing the binary in live debugging to find DLL hijackings via absolute path
            if (isStarted)
            {
                DisplayPEFileInformations();
                data.Logs.Add($"Starting the original pefile {Path.GetFileName(peAnalyser.SelectedBinaryPath)} to find live modules hijackings...");
                await Task.Run(() =>
                {
                    List<string> modulesList = new List<string>();
                    Process process = new Process();
                    ProcessStartInfo startInfo = new ProcessStartInfo
                    {
                        WindowStyle = ProcessWindowStyle.Normal,
                        FileName = peAnalyser.SelectedBinaryPath
                    };
                    process.StartInfo = startInfo;
                    process.Start();

                    while (!process.HasExited)
                    {
                        try
                        {
                            process.WaitForExit(2000);
                            foreach (ProcessModule module in process.Modules)
                            {
                                if (module.ModuleName != Path.GetFileName(peAnalyser.SelectedBinaryPath))
                                {
                                    if (!module.FileName.ToLower().StartsWith("c:\\windows\\system32") && !modulesList.Contains(module.FileName))
                                    {
                                        PEAnalyser pe = new PEAnalyser(module.FileName);
                                        uiContext.Send(x => data.Logs.Add($"MODULE: {module.FileName} - {pe.CheckIfSigned()}"), null);
                                        modulesList.Add(module.FileName);
                                    }
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine(ex.Message);
                        }
                    }
                    if (modulesList.Count > 0)
                    {
                        fileOp.SaveDllLivePaths("live-paths-found.txt", peAnalyser.SelectedBinaryPath, modulesList);
                    }
                });
            }
            data.Logs.Add("Done.");
            isStarted = false;
            textBlock.Text = "Find DLL Hijackings";
        }

        private void ButtonDllProxying_Click(object sender, RoutedEventArgs e)
        {
            MetroWindow container = new MetroWindow();
            DLLProxying contentControl = new DLLProxying();
            container.Title = "DLL PROXYING";
            container.Width = 700;
            container.Height = 450;
            container.WindowStartupLocation = WindowStartupLocation.CenterScreen;
            container.Content = contentControl;
            container.Show();
        }

        private void ButtonOpenGitHub_Click(object sender, RoutedEventArgs e)
        {
            Process.Start("https://github.com/redteamsocietegenerale/DLLirant");
        }

        private void ButtonAddExclude_Click(object sender, RoutedEventArgs e)
        {
            if (TextBoxExcludeAdd.Text.Length > 0 && !data.ExcludesDLLs.Contains(TextBoxExcludeAdd.Text.ToLower()))
            {
                string text = TextBoxExcludeAdd.Text.ToLower().Replace(" ", string.Empty);
                data.ExcludesDLLs.Add(text);
            }
        }

        private void ButtonDeleteExclude_Click(object sender, RoutedEventArgs e)
        {
            if (ListBoxExcludes.SelectedValue != null)
            {
                data.ExcludesDLLs.Remove(ListBoxExcludes.SelectedValue.ToString());
            }
        }
    }
}

```

`DLLirant.NET/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DLLirant.NET")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("DLLirant.NET")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

//In order to begin building localizable applications, set
//<UICulture>CultureYouAreCodingWith</UICulture> in your .csproj file
//inside a <PropertyGroup>.  For example, if you are using US english
//in your source files, set the <UICulture> to en-US.  Then uncomment
//the NeutralResourceLanguage attribute below.  Update the "en-US" in
//the line below to match the UICulture setting in the project file.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]


[assembly: ThemeInfo(
    ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located
                                     //(used if a resource is not found in the page,
                                     // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located
                                              //(used if a resource is not found in the page,
                                              // app, or any theme specific resource dictionaries)
)]


// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`DLLirant.NET/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.42000
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DLLirant.NET.Properties {
    using System;
    
    
    /// <summary>
    ///   Une classe de ressource fortement typée destinée, entre autres, à la consultation des chaînes localisées.
    /// </summary>
    // Cette classe a été générée automatiquement par la classe StronglyTypedResourceBuilder
    // à l'aide d'un outil, tel que ResGen ou Visual Studio.
    // Pour ajouter ou supprimer un membre, modifiez votre fichier .ResX, puis réexécutez ResGen
    // avec l'option /str ou régénérez votre projet VS.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Retourne l'instance ResourceManager mise en cache utilisée par cette classe.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DLLirant.NET.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Remplace la propriété CurrentUICulture du thread actuel pour toutes
        ///   les recherches de ressources à l'aide de cette classe de ressource fortement typée.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}

```

`DLLirant.NET/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`DLLirant.NET/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.42000
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DLLirant.NET.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "17.2.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}

```

`DLLirant.NET/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>
```

`DLLirant.NET/ViewModel/DataContextViewModel.cs`:

```cs
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace DLLirant.NET
{
    public class DataContextViewModel : INotifyPropertyChanged
    {
        public DataContextViewModel()
        {
            logs = new ObservableCollection<string>();
            logs.Add("test1");
            logs.Add("test2");
            logs.Add("test3");
            logs.Add("test4");
            logs.Add("test5");
            logs.Add("test6");

            excludesDlls = new ObservableCollection<string>();
            excludesDlls.Add("api-ms");
            excludesDlls.Add("ext-ms");
            excludesDlls.Add("ntdll");
            excludesDlls.Add("kernel32");
            excludesDlls.Add("user32");
            excludesDlls.Add("shell32");
            excludesDlls.Add("comctl32");
            excludesDlls.Add("imm32");
            excludesDlls.Add("gdi32");
            excludesDlls.Add("msvcr");
            excludesDlls.Add("ws2_32");
            excludesDlls.Add("ole32");
            excludesDlls.Add("ninput");
            excludesDlls.Add("setupapi");
            excludesDlls.Add("mscoree");
            excludesDlls.Add("msvcp_win");
            excludesDlls.Add("oleaut32");
            excludesDlls.Add("advapi32");
            excludesDlls.Add("crypt32");
        }

        private ObservableCollection<string> logs;
        public ObservableCollection<string> Logs {
            get { return logs; }
            set
            {
                logs = value;
                OnPropertyChanged();
            }
        }

        private ObservableCollection<string> excludesDlls;
        public ObservableCollection<string> ExcludesDLLs
        {
            get { return excludesDlls; }
            set
            {
                excludesDlls = value;
                OnPropertyChanged();
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}

```

`DLLirant.NET/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="ControlzEx" version="5.0.1" targetFramework="net462" />
  <package id="Costura.Fody" version="5.7.0" targetFramework="net462" developmentDependency="true" />
  <package id="Fody" version="6.6.3" targetFramework="net462" developmentDependency="true" />
  <package id="MahApps.Metro" version="2.4.9" targetFramework="net462" />
  <package id="MahApps.Metro.IconPacks" version="4.11.0" targetFramework="net462" />
  <package id="Microsoft.NETCore.Platforms" version="6.0.5" targetFramework="net462" />
  <package id="Microsoft.Win32.Primitives" version="4.3.0" targetFramework="net462" />
  <package id="Microsoft.Xaml.Behaviors.Wpf" version="1.1.39" targetFramework="net462" />
  <package id="NETStandard.Library" version="2.0.3" targetFramework="net462" />
  <package id="PeNet" version="2.9.8" targetFramework="net462" />
  <package id="PeNet.Asn1" version="2.0.0" targetFramework="net462" />
  <package id="System.AppContext" version="4.3.0" targetFramework="net462" />
  <package id="System.Buffers" version="4.5.1" targetFramework="net462" />
  <package id="System.Collections" version="4.3.0" targetFramework="net462" />
  <package id="System.Collections.Concurrent" version="4.3.0" targetFramework="net462" />
  <package id="System.Console" version="4.3.1" targetFramework="net462" />
  <package id="System.Diagnostics.Debug" version="4.3.0" targetFramework="net462" />
  <package id="System.Diagnostics.DiagnosticSource" version="6.0.0" targetFramework="net462" />
  <package id="System.Diagnostics.Tools" version="4.3.0" targetFramework="net462" />
  <package id="System.Diagnostics.Tracing" version="4.3.0" targetFramework="net462" />
  <package id="System.Globalization" version="4.3.0" targetFramework="net462" />
  <package id="System.Globalization.Calendars" version="4.3.0" targetFramework="net462" />
  <package id="System.IO" version="4.3.0" targetFramework="net462" />
  <package id="System.IO.Compression" version="4.3.0" targetFramework="net462" />
  <package id="System.IO.Compression.ZipFile" version="4.3.0" targetFramework="net462" />
  <package id="System.IO.FileSystem" version="4.3.0" targetFramework="net462" />
  <package id="System.IO.FileSystem.Primitives" version="4.3.0" targetFramework="net462" />
  <package id="System.Linq" version="4.3.0" targetFramework="net462" />
  <package id="System.Linq.Expressions" version="4.3.0" targetFramework="net462" />
  <package id="System.Memory" version="4.5.5" targetFramework="net462" />
  <package id="System.Net.Http" version="4.3.4" targetFramework="net462" />
  <package id="System.Net.Primitives" version="4.3.1" targetFramework="net462" />
  <package id="System.Net.Sockets" version="4.3.0" targetFramework="net462" />
  <package id="System.Numerics.Vectors" version="4.5.0" targetFramework="net462" />
  <package id="System.ObjectModel" version="4.3.0" targetFramework="net462" />
  <package id="System.Reflection" version="4.3.0" targetFramework="net462" />
  <package id="System.Reflection.Extensions" version="4.3.0" targetFramework="net462" />
  <package id="System.Reflection.Primitives" version="4.3.0" targetFramework="net462" />
  <package id="System.Resources.ResourceManager" version="4.3.0" targetFramework="net462" />
  <package id="System.Runtime" version="4.3.1" targetFramework="net462" />
  <package id="System.Runtime.CompilerServices.Unsafe" version="6.0.0" targetFramework="net462" />
  <package id="System.Runtime.Extensions" version="4.3.1" targetFramework="net462" />
  <package id="System.Runtime.Handles" version="4.3.0" targetFramework="net462" />
  <package id="System.Runtime.InteropServices" version="4.3.0" targetFramework="net462" />
  <package id="System.Runtime.InteropServices.RuntimeInformation" version="4.3.0" targetFramework="net462" />
  <package id="System.Runtime.Numerics" version="4.3.0" targetFramework="net462" />
  <package id="System.Security.Cryptography.Algorithms" version="4.3.1" targetFramework="net462" />
  <package id="System.Security.Cryptography.Encoding" version="4.3.0" targetFramework="net462" />
  <package id="System.Security.Cryptography.Pkcs" version="6.0.1" targetFramework="net462" />
  <package id="System.Security.Cryptography.Primitives" version="4.3.0" targetFramework="net462" />
  <package id="System.Security.Cryptography.X509Certificates" version="4.3.2" targetFramework="net462" />
  <package id="System.Text.Encoding" version="4.3.0" targetFramework="net462" />
  <package id="System.Text.Encoding.Extensions" version="4.3.0" targetFramework="net462" />
  <package id="System.Text.RegularExpressions" version="4.3.1" targetFramework="net462" />
  <package id="System.Threading" version="4.3.0" targetFramework="net462" />
  <package id="System.Threading.Tasks" version="4.3.0" targetFramework="net462" />
  <package id="System.Threading.Timer" version="4.3.0" targetFramework="net462" />
  <package id="System.Xml.ReaderWriter" version="4.3.1" targetFramework="net462" />
  <package id="System.Xml.XDocument" version="4.3.0" targetFramework="net462" />
</packages>
```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Société Générale

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# DLLirant

DLLirant is a tool to automatize the DLL Hijacking and DLL Proxying researches on a specified binary.

![alt text](https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/screenshot.png)
![alt text](https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/screenshot2.png)

## Live Demo

![alt text](https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/live.gif)

## How to install

* Install LLVM for Windows x64 (LLVM-version-win64.exe): https://github.com/llvm/llvm-project/releases
* Do not forget to check the "Add LLVM to the system PATH for current user" during the installation.

## How to use

Select the desired PE file, if it is an .exe, the application will currently search for DLL Search Order Hijacking, if you select a DLL, the application will offer you to proxy it.

Regarding the second option, you must specify a path for the proxy DLL, this path can be specified in two ways:

* With a name, this will generate the proxy DLL and rename it with the name of the selected DLL, and the application will copy the selected (original) DLL and rename it with the name you selected.

* With a path, this option will generate a single file, the proxy DLL that will call the functions exported from the DLL specified in the text box.

You can also create an `import` directory and place the missing DLL files that your application need if necessary (the DLL files will be copied automatically in the `output` directory with the targeted binary).

**Important**

Concerning the error messages of your targeted application, I tried to avoid the error messages, but you can't really because the messagebox is generated by the System via csrss.exe, not via the targeted application, so you can try to kill the threads, the child windows, use SetErrorMode etc... it will not work.

## Python version

This version is deprecated but if you want to use it, you must install `pefile` with pip and:

Use the `cd` command to your DLLirant directory and to test a binary:

```
python3 DLLirant.py -f "C:\THEFULLPATH\YourBinary.exe"
```

If you want to create a proxy dll, you can use the -p option on the original vulnerable dll (read https://itm4n.github.io/dll-proxying/ for more informations):

```
python3 DLLirant.py -p "C:\THEFULLPATH\VulnerableDLL.dll"
```

## How it works

The script will create an output directory in the same directory of DLLirant, copy the targeted binary to the output directory.

Via the PeNet library, the script will extract the dll names required by the binary, and test each imports functions available one by one by compilate a custom DLL with the required exported functions.

If a function required by the binary is executed, the custom DLL will create a `C:\DLLirant\output.txt` file and display a MessageBox to be sure that a DLL Hijacking is possible.

A `DLLirant-results.txt` will be also created in the DLLirant directory with all potential DLL Hijacking available.

## Technical posts (in French)

* https://sh0ckfr.com/pages/martine-a-la-recherche-de-la-dll-hijacking-perdue/
* https://sh0ckfr.com/pages/martin-et-le-dll-proxying-de-cristal/

```

`old-python-version/DLLirant.py`:

```py
#!/usr/bin/env python
# coding: utf-8

import os
import sys
import shutil
import time
import argparse
import subprocess
import pefile
import string
import random

PARSER = argparse.ArgumentParser()
PARSER.add_argument('-f', '--file', type=str, help='define the targeted binary (use it alone without -p or -n)', required=False)
PARSER.add_argument('-p', '--proxydll', type=str, help='create a proxy dll (redirecting all the functions to the original DLL)', required=False)
ARGS = PARSER.parse_args()

# The DLL filenames who starts with one element of this list will not be checked.
dlls_excludes = {
	'api-ms',
	'ext-ms',
	'ntdll',
	'kernel32',
	'user32',
	'shell32',
	'comctl32',
	'imm32',
	'gdi32',
	'msvcr',
	'ws2_32',
	'ole32',
	'ninput',
	'setupapi',
	'mscoree',
	'msvcp_win',
	'oleaut32',
	'advapi32',
	'crypt32'
}

def ascii():
	print('·▄▄▄▄  ▄▄▌  ▄▄▌  ▪  ▄▄▄   ▄▄▄·  ▐ ▄ ▄▄▄▄▄')
	print('██▪ ██ ██•  ██•  ██ ▀▄ █·▐█ ▀█ •█▌▐█•██  ')
	print('▐█· ▐█▌██▪  ██▪  ▐█·▐▀▀▄ ▄█▀▀█ ▐█▐▐▌ ▐█.▪')
	print('██. ██ ▐█▌▐▌▐█▌▐▌▐█▌▐█•█▌▐█ ▪▐▌██▐█▌ ▐█▌·')
	print('▀▀▀▀▀• .▀▀▀ .▀▀▀ ▀▀▀.▀  ▀ ▀  ▀ ▀▀ █▪ ▀▀▀  v0.4 - Sh0ck (@Sh0ckFR)')

def rreplace(s, old, new):
	return (s[::-1].replace(old[::-1],new[::-1], 1))[::-1]

def delete_dir(directory):
	if os.path.exists(directory):
		try:
			shutil.rmtree(directory)
		except PermissionError:
			pass

def create_dir(directory):
	if not os.path.exists(directory):
		os.makedirs(directory)

def delete_file(file):
	if os.path.exists(file):
		os.remove(file)

def copy_binary_to_ouput_dir(binary_path):
	if not os.path.exists(binary_path):
		return False
	binary_name = os.path.basename(binary_path).replace(' ', '_')
	try:
		shutil.copyfile(binary_path, f'output/{binary_name}')
		return True
	except FileNotFoundError:
		return False
	except PermissionError:
		return False

def copy_binary_and_required_files(binary):
	copy_binary_to_ouput_dir(binary)
	if os.path.exists('import'):
		for (dirpath, dirnames, filenames) in os.walk('import'):
			for file in filenames:
				copy_binary_to_ouput_dir(f'import/{file}')

def check_if_excluded(dll_name):
	for exclude in dlls_excludes:
		if dll_name.lower().startswith(exclude) or dll_name.upper().startswith(exclude):
			return True
	return False

def get_imports_functions(dll_name, imports):
	functions = []
	for imp in imports:
		if imp.name is not None:
			functions.append(imp.name.decode('utf-8'))
	return functions

def generate_test_dll(functions = None):
	exported_functions = []
	with open('DLLirantDLL\\dllmain-preset.cpp', 'r') as fin:
		with open('DLLirantDLL\\dllmain.cpp', 'w') as fout:
			if functions is not None:
				for line in fin:
					if '##DLL_MAIN##' in line:
						if ARGS.proxydll:
							fout.write(line.replace('##DLL_MAIN##', 'CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)Main, NULL, NULL, NULL);\nbreak;'))
						else:
							fout.write(line.replace('##DLL_MAIN##', ''))
					elif '##EXPORTED_FUNCTIONS##' in line:
						if ARGS.proxydll:
							fout.write(line.replace('##EXPORTED_FUNCTIONS##', functions))
						else:
							for func in functions:
								if len(func) > 0:
									exported_functions.append(f'extern "C" __declspec(dllexport) void {func}()' + '{ Main(); }')
							exported_functions = '\n'.join(exported_functions)
							fout.write(line.replace('##EXPORTED_FUNCTIONS##', exported_functions))
					else:
						fout.write(line)
			else:
				for line in fin:
					if '##DLL_MAIN##' in line:
						fout.write(line.replace('##DLL_MAIN##', 'CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)Main, NULL, NULL, NULL);\nbreak;'))
					elif '##EXPORTED_FUNCTIONS##' in line:
						fout.write(line.replace('##EXPORTED_FUNCTIONS##', ''))
					else:
						fout.write(line)
	os.system('cd DLLirantDLL && clang++ dllmain.cpp -o DLLirantDLL.dll -shared')
	delete_file('DLLirantDLL\\DLLirantDLL.exp')
	delete_file('DLLirantDLL\\DLLirantDLL.lib')
	delete_file('DLLirantDLL\\dllmain.cpp')
	return exported_functions

def check_dll_hijacking(binary_name, binary_original_directory, dll_name, exported_functions = 'DllMain'):
	if not os.path.exists('DLLirantDLL\\DLLirantDLL.dll'):
		return False
	os.system(f'copy DLLirantDLL\\DLLirantDLL.dll output\\{dll_name}')
	delete_file('DLLirantDLL\\DLLirantDLL.dll')
	ascii()
	print('==================================================')
	print(f'[+] Testing {dll_name}')
	print(f'BINARY: {binary_original_directory}\\{binary_name}')
	print(f'EXPORTED FUNCTIONS:\n')
	print(exported_functions)
	print('==================================================')
	try:
		binary_name = binary_name.replace(' ', '_')
		process = subprocess.Popen(f'output/{binary_name}')
		time.sleep(2)
		if os.path.exists('C:\\DLLirant\\output.txt'):
			with open('results.txt', 'a') as file:
				file.write(f'[+] POTENTIAL DLL HIJACKING FOUND IN: {dll_name}\n')
				file.write(f'BINARY: {binary_original_directory}\\{binary_name}\n')
				file.write(f'{exported_functions}\n\n')
			delete_file('C:\\DLLirant\\output.txt')
			input(f'\n\n[+] Potential DLL Hijacking found in the binary {binary_name} with the dll {dll_name} ! Press enter to continue.')
			os.system(f'taskkill /F /pid {process.pid}')
			return True
		os.system(f'taskkill /F /pid {process.pid}')
		return False
	except OSError:
		with open('admin-required.txt', 'a') as file:
			file.write(f'[!] ADMIN PRIVS REQUIRED ON {binary_original_directory}\\{binary_name}\n')
			file.write(f'DLL: {dll_name}\n')
			file.write(f'{exported_functions}\n\n')
		input(f'\n\n[+] [!] Admin privs required on {binary_name} start it manually to test the dll hijack and press enter to continue.')
		return False

def generate_proxy_dll():
	exported_functions = []

	letters = string.ascii_letters
	name_dll = ''.join(random.choice(letters) for i in range(5))
	original_name = os.path.basename(ARGS.proxydll)

	pe = pefile.PE(ARGS.proxydll)

	for entry in pe.DIRECTORY_ENTRY_EXPORT.symbols:
		func = entry.name.decode('utf-8')
		exported_functions.append(f'#pragma comment(linker,"/export:{func}={name_dll}.{func},@{entry.ordinal}")')
	exported_functions = '\n'.join(exported_functions)
	
	ascii()
	generate_test_dll(exported_functions)
	os.system(f'copy DLLirantDLL\\DLLirantDLL.dll output\\DLLirantProxy.dll')
	delete_file('DLLirantDLL\\DLLirantDLL.dll')
	print(f'\n\n[+] Rename the original dll file {name_dll}.dll and copy the compiled dll DLLirantProxy.dll to the original directory as {original_name}')

def main():
	if ARGS.proxydll:
		generate_proxy_dll()
		sys.exit()

	# Create output dir if not exists.
	create_dir('output')

	# Create or recreate the directory used by the DLLirant DLL specified in dllmain-preset.c file.
	delete_dir('C:\\DLLirant')
	create_dir('C:\\DLLirant')
	delete_dir('output')
	create_dir('output')

	# Name of the binary specified and his directory.
	binary_name = os.path.basename(ARGS.file)
	binary_original_directory = os.path.dirname(os.path.realpath(ARGS.file))

	# Copy the binary to the output directory and copy the required files placed by the user in the "import" directory if exists.
	copy_binary_and_required_files(ARGS.file)

	pe = pefile.PE(ARGS.file)
	pe.parse_data_directories()

	# For each dll files...
	for entry in pe.DIRECTORY_ENTRY_IMPORT:
		# Get the name of the dll.
		dll_name = entry.dll.decode('utf-8')

		if check_if_excluded(dll_name) is False:
			# Get the entry import functions.
			functions = get_imports_functions(dll_name, entry.imports)

			# Generate the DLLirant test dll file without exported functions.
			generate_test_dll()

			# Test the generated dll to check if a dll hijacking is possible.
			check_dll_hijacking(binary_name, binary_original_directory, dll_name)

			# Test all functions one by one.
			functions_list = []
			for func in functions:
				functions_list.append(func)
				exported_functions = generate_test_dll(functions_list)
				check_dll_hijacking(binary_name, binary_original_directory, dll_name, exported_functions)

			# Delete and recreate the output directory to test the others dll files.
			delete_dir('output')
			create_dir('output')

			# Recopy the binary and the required files.
			copy_binary_and_required_files(ARGS.file)

if __name__ == '__main__':
	main()

```

`old-python-version/DLLirantDLL/dllmain-preset.cpp`:

```cpp
#include <windows.h>
#include <stdio.h>

#pragma comment (lib, "User32.lib")

int Main() {
    FILE* fptr;
    fopen_s(&fptr, "C:\\DLLirant\\output.txt", "w");
    fprintf(fptr, "%s", "It works !\n");
    fclose(fptr);
    MessageBoxW(0, L"DLL Hijack found!", L"DLL Hijack", 0);
    return 1;
}

BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        ##DLL_MAIN##
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

##EXPORTED_FUNCTIONS##

```