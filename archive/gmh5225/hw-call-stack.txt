Project Path: arc_gmh5225_hw-call-stack_8l570tam

Source Tree:

```txt
arc_gmh5225_hw-call-stack_8l570tam
├── Makefile
├── README.md
├── dist
│   ├── hw_call_stack.x64.exe
│   └── hw_call_stack.x86.exe
├── include
│   ├── dinvoke.h
│   ├── hw_breakpoint.h
│   ├── main.h
│   ├── ntdefs.h
│   ├── output.h
│   ├── spoof_callstack.h
│   ├── syscalls.h
│   └── utils.h
├── resources
│   └── demo.png
├── scripts
│   └── get_name_hash.py
└── source
    ├── dinvoke.c
    ├── hw_breakpoint.c
    ├── main.c
    ├── spoof_callstack.c
    └── syscalls.c

```

`Makefile`:

```
CC_x64 := x86_64-w64-mingw32-gcc
CC_x86 := i686-w64-mingw32-gcc
OPTIONS := -masm=intel -Wall -I include -DDEBUG

hw_call_stack: clean
	$(CC_x64) source/hw_breakpoint.c source/dinvoke.c source/spoof_callstack.c source/syscalls.c source/main.c -o dist/hw_call_stack.x64.exe $(OPTIONS)
	$(CC_x86) source/hw_breakpoint.c source/dinvoke.c source/spoof_callstack.c source/syscalls.c source/main.c -o dist/hw_call_stack.x86.exe $(OPTIONS)

clean:
	rm -f dist/*

```

`README.md`:

```md
# HW Call Stack

Yet another "Call Stack Spoofing" implementation. Works for syscalls and APIs, supports x64, x86 and WoW64.  

![screenshot](resources/demo.png)

## Compile
Use the MinGW compiler:
```bash
make
```

This should create two binaries:
```
$ ls dist  
hw_call_stack.x64.exe  hw_call_stack.x86.exe
```

## Example output
```
PS C:\Windows\Temp> .\hw_call_stack.x64.exe
usage: C:\Windows\Temp\hw_call_stack.x64.exe <pid> <dll>

PS Z:\> .\hw_call_stack.x64.exe 700 kernel32.dll
-- HW Call Stack --

calling NtOpenProcess...
DEBUG: source/spoof_callstack.c:850:create_fake_callstack(): obtained the stack ranges: 0x000000287d3fd000 - 0x000000287d400000
DEBUG: source/spoof_callstack.c:863:create_fake_callstack(): using the NtOpenProcess call stack
DEBUG: source/spoof_callstack.c:892:create_fake_callstack(): storing area is at: 0x0000020121124940
DEBUG: source/spoof_callstack.c:920:create_fake_callstack(): size of the fake stack: 0x158
DEBUG: source/spoof_callstack.c:924:create_fake_callstack(): fake stack on the heap: 0x00000201211315a0 - 0x00000201211316f8
DEBUG: source/spoof_callstack.c:933:create_fake_callstack(): backup of the stack real stack: 0x0000020121131700 - 0x0000020121134700
DEBUG: source/spoof_callstack.c:943:create_fake_callstack(): the spoofed call stack will be stored at: 0x000000287d3ffea8 - 0x000000287d400000
DEBUG: source/spoof_callstack.c:1010:create_fake_callstack(): fake stack layout:
DEBUG: source/spoof_callstack.c:1011:create_fake_callstack():     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DEBUG: source/spoof_callstack.c:1021:create_fake_callstack():     ret address: KernelBase!ProcessIdToSessionId+0x96 <-- stack pointer: 0x000000287d3ffea8
DEBUG: source/spoof_callstack.c:1039:create_fake_callstack():     -------------------------------
DEBUG: source/spoof_callstack.c:1040:create_fake_callstack():         <0x78 bytes of space>
DEBUG: source/spoof_callstack.c:1032:create_fake_callstack():     ret address: Kernel32!BaseThreadInitThunk+0x14
DEBUG: source/spoof_callstack.c:1039:create_fake_callstack():     -------------------------------
DEBUG: source/spoof_callstack.c:1040:create_fake_callstack():         <0x28 bytes of space>
DEBUG: source/spoof_callstack.c:1032:create_fake_callstack():     ret address: ntdll!RtlUserThreadStart+0x21
DEBUG: source/spoof_callstack.c:1039:create_fake_callstack():     -------------------------------
DEBUG: source/spoof_callstack.c:1040:create_fake_callstack():         <0x78 bytes of space>
DEBUG: source/spoof_callstack.c:1044:create_fake_callstack():     ret address: 0x0000000000000000
DEBUG: source/spoof_callstack.c:1045:create_fake_callstack():     -------------------------------
DEBUG: source/spoof_callstack.c:1046:create_fake_callstack():     canary: 0xdeadbeefcafebabe
DEBUG: source/spoof_callstack.c:1047:create_fake_callstack():     storing ptr: 0x0000020121124940
DEBUG: source/spoof_callstack.c:1048:create_fake_callstack():         <0x10 bytes of space>       <-- stack bottom: 0x000000287d3fd000
DEBUG: source/spoof_callstack.c:1049:create_fake_callstack():     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DEBUG: source/syscalls.c:630:trigger_syscall(): created the fake callstack
DEBUG: source/syscalls.c:644:trigger_syscall(): hardware breakpoint set at 0x00007ffa42db9f06
DEBUG: source/syscalls.c:674:trigger_syscall(): triggering the syscall...
DEBUG: source/syscalls.c:676:trigger_syscall(): done.
status: 0x0

calling LoadLibraryA...
DEBUG: source/spoof_callstack.c:850:create_fake_callstack(): obtained the stack ranges: 0x000000287d3fd000 - 0x000000287d400000
DEBUG: source/spoof_callstack.c:867:create_fake_callstack(): using the LoadLibraryA call stack
DEBUG: source/spoof_callstack.c:892:create_fake_callstack(): storing area is at: 0x00000201211376f0
DEBUG: source/spoof_callstack.c:920:create_fake_callstack(): size of the fake stack: 0x1f8
DEBUG: source/spoof_callstack.c:924:create_fake_callstack(): fake stack on the heap: 0x00000201211317e0 - 0x00000201211319d8
DEBUG: source/spoof_callstack.c:933:create_fake_callstack(): backup of the stack real stack: 0x0000020121138a50 - 0x000002012113ba50
DEBUG: source/spoof_callstack.c:943:create_fake_callstack(): the spoofed call stack will be stored at: 0x000000287d3ffe08 - 0x000000287d400000
DEBUG: source/spoof_callstack.c:1010:create_fake_callstack(): fake stack layout:
DEBUG: source/spoof_callstack.c:1011:create_fake_callstack():     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DEBUG: source/spoof_callstack.c:1025:create_fake_callstack():     ret address: advapi32+0x4a25e <-- stack pointer: 0x000000287d3ffe08
DEBUG: source/spoof_callstack.c:1039:create_fake_callstack():     -------------------------------
DEBUG: source/spoof_callstack.c:1040:create_fake_callstack():         <0x118 bytes of space>
DEBUG: source/spoof_callstack.c:1032:create_fake_callstack():     ret address: Kernel32!BaseThreadInitThunk+0x14
DEBUG: source/spoof_callstack.c:1039:create_fake_callstack():     -------------------------------
DEBUG: source/spoof_callstack.c:1040:create_fake_callstack():         <0x28 bytes of space>
DEBUG: source/spoof_callstack.c:1032:create_fake_callstack():     ret address: ntdll!RtlUserThreadStart+0x21
DEBUG: source/spoof_callstack.c:1039:create_fake_callstack():     -------------------------------
DEBUG: source/spoof_callstack.c:1040:create_fake_callstack():         <0x78 bytes of space>
DEBUG: source/spoof_callstack.c:1044:create_fake_callstack():     ret address: 0x0000000000000000
DEBUG: source/spoof_callstack.c:1045:create_fake_callstack():     -------------------------------
DEBUG: source/spoof_callstack.c:1046:create_fake_callstack():     canary: 0xdeadbeefcafebabe
DEBUG: source/spoof_callstack.c:1047:create_fake_callstack():     storing ptr: 0x00000201211376f0
DEBUG: source/spoof_callstack.c:1048:create_fake_callstack():         <0x10 bytes of space>       <-- stack bottom: 0x000000287d3fd000
DEBUG: source/spoof_callstack.c:1049:create_fake_callstack():     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DEBUG: source/syscalls.c:733:trigger_api(): created the fake callstack
DEBUG: source/syscalls.c:747:trigger_api(): hardware breakpoint set at 0x00007ffa4331a25e
DEBUG: source/syscalls.c:775:trigger_api(): triggering the API...
DEBUG: source/syscalls.c:777:trigger_api(): done.
Kernel32.dll has been loaded at 0x00007ffa435e0000

Bye!
```

## Credits
Thanks to [William Burgess](https://twitter.com/joehowwolf) for [Spoofing Call Stacks To Confuse EDRs](https://labs.withsecure.com/blog/spoofing-call-stacks-to-confuse-edrs).

```

`include/dinvoke.h`:

```h
#pragma once

#include <windows.h>
#include <winternl.h>

#include "utils.h"
#include "syscalls.h"
#include "output.h"

#define LdrLoadDll_SW3_HASH 0x7F6F58FC

#define MZ 0x5A4D

typedef NTSTATUS(WINAPI* LdrLoadDll_t)(PWCHAR, ULONG, PUNICODE_STRING, PHANDLE);

typedef struct _ND_LDR_DATA_TABLE_ENTRY
{
    //struct _LIST_ENTRY InLoadOrderLinks;
    struct _LIST_ENTRY InMemoryOrderLinks;
    struct _LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
} ND_LDR_DATA_TABLE_ENTRY, *PND_LDR_DATA_TABLE_ENTRY;

typedef struct _ND_PEB_LDR_DATA
{
    ULONG Length;
    UCHAR Initialized;
    PVOID SsHandle;
    struct _LIST_ENTRY InLoadOrderModuleList;
    struct _LIST_ENTRY InMemoryOrderModuleList;
    struct _LIST_ENTRY InInitializationOrderModuleList;
} ND_PEB_LDR_DATA, *PND_PEB_LDR_DATA;

typedef struct _ND_PEB
{
    BYTE Reserved1[2];
    BYTE BeingDebugged;
    BYTE Reserved2[1];
    PVOID Reserved3[2];
    PND_PEB_LDR_DATA Ldr;
} ND_PEB, *PND_PEB;

BOOL is_dll(
    IN HMODULE hLibrary);

PVOID find_legacy_export(
    IN HMODULE hOriginalLibrary,
    IN DWORD fhash);

PVOID resolve_reference(
    IN HMODULE hOriginalLibrary,
    IN PVOID addr);

PVOID get_function_address(
    IN HMODULE hLibrary,
    IN DWORD fhash,
    IN WORD ordinal);

HANDLE get_library_address(
    IN LPWSTR lib_path,
    IN BOOL DoLoad);

PVOID find_dll_by_pointer(
    IN PVOID adddres);

```

`include/hw_breakpoint.h`:

```h

#include <windows.h>

#include "dinvoke.h"
#include "output.h"
#include "ntdefs.h"

#define DEBUG_REGISTER_INDEX 0
//#define DEBUG_REGISTER_INDEX 1
//#define DEBUG_REGISTER_INDEX 2
//#define DEBUG_REGISTER_INDEX 3

typedef PVOID(WINAPI* RtlAddVectoredExceptionHandler_t) (ULONG First, PVECTORED_EXCEPTION_HANDLER Handler);
typedef ULONG(WINAPI* RtlRemoveVectoredExceptionHandler_t) (PVOID Handle);

#define RtlAddVectoredExceptionHandler_SW3_HASH 0xFB10D0CD
#define RtlRemoveVectoredExceptionHandler_SW3_HASH 0x60AF1749

ULONG_PTR set_bits(
    ULONG_PTR dw,
    int lowBit,
    int bits,
    ULONG_PTR newValue);

VOID clear_breakpoint(
    CONTEXT* ctx,
    int index);

VOID enable_breakpoint(
    CONTEXT* ctx,
    PVOID address,
    int index);

LONG hwbp_handler(
    PEXCEPTION_POINTERS exceptions);

BOOL set_hwbp(
    PVOID address,
    PHANDLE phHwBpHandler);

VOID unset_hwbp(
    HANDLE hHwBpHandler);

```

`include/ntdefs.h`:

```h
#pragma once

#include <windows.h>
#include <winternl.h>

#define NTDLL_DLL L"ntdll.dll"
#define KERNEL32_DLL L"Kernel32.dll"
#define KERNELBASE_DLL L"KernelBase.dll"

#define NtCurrentThread() ( (HANDLE)(LONG_PTR) -2 )

#define STATUS_SUCCESS 0x00000000
#define STATUS_UNSUCCESSFUL 0xC0000001

```

`include/output.h`:

```h
#pragma once

#include <windows.h>
#include <stdio.h>

#define PRINT(...) { \
 fprintf(stdout, __VA_ARGS__); \
 fprintf(stdout, "\n"); \
}

#define PRINT_ERR(...) { \
 fprintf(stdout, __VA_ARGS__); \
 fprintf(stdout, "\n"); \
}

#if defined(DEBUG)
 #define DPRINT(...) { \
     fprintf(stderr, "DEBUG: %s:%d:%s(): ", __FILE__, __LINE__, __FUNCTION__); \
     fprintf(stderr, __VA_ARGS__); \
     fprintf(stderr, "\n"); \
 }
#else
 #define DPRINT(...)
#endif

#if defined(DEBUG)
 #define DPRINT_ERR(...) { \
     fprintf(stderr, "ERROR: %s:%d:%s(): ", __FILE__, __LINE__, __FUNCTION__); \
     fprintf(stderr, __VA_ARGS__); \
     fprintf(stderr, "\n"); \
 }
#else
 #define DPRINT_ERR(...)
#endif

#define syscall_failed(syscall_name, status) \
    DPRINT_ERR( \
        "Failed to call %s, status: 0x%lx", \
        syscall_name, \
        status \
    )

#define function_failed(function) \
    DPRINT_ERR( \
        "Call to '%s' failed, error: %ld", \
        function, \
        GetLastError() \
    )

#define malloc_failed() function_failed("HeapAlloc")

#define api_not_found(function) \
    DPRINT_ERR( \
        "The address of '%s' was not found", \
        function \
    )

```

`include/spoof_callstack.h`:

```h
#pragma once

#include <windows.h>
#include <winternl.h>

#include "dinvoke.h"

#ifndef UNWIND_HISTORY_TABLE_SIZE

  #define UNWIND_HISTORY_TABLE_SIZE 12

  typedef struct _FRAME_POINTERS {
    ULONGLONG MemoryStackFp;
    ULONGLONG BackingStoreFp;
  } FRAME_POINTERS,*PFRAME_POINTERS;

  typedef struct _RUNTIME_FUNCTION {
      ULONG BeginAddress;
      ULONG EndAddress;
      ULONG UnwindData;
  } RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

  typedef struct _UNWIND_HISTORY_TABLE_ENTRY {
    ULONG64 ImageBase;
    ULONG64 Gp;
    PRUNTIME_FUNCTION FunctionEntry;
  } UNWIND_HISTORY_TABLE_ENTRY,*PUNWIND_HISTORY_TABLE_ENTRY;

  typedef struct _UNWIND_HISTORY_TABLE {
    ULONG Count;
    UCHAR Search;
    ULONG64 LowAddress;
    ULONG64 HighAddress;
    UNWIND_HISTORY_TABLE_ENTRY Entry[UNWIND_HISTORY_TABLE_SIZE];
  } UNWIND_HISTORY_TABLE,*PUNWIND_HISTORY_TABLE;

#endif

#ifndef UNW_FLAG_CHAININFO
  #define UNW_FLAG_CHAININFO  0x4
#endif

#define UNUSED(x) (void)(x)

#define MAX_FRAME_NUM 30
#define RBP_OP_INFO 0x5

//
// Used to store information for individual stack frames for call stack to spoof.
//
typedef struct _STACK_FRAME {
    WCHAR targetDll[MAX_PATH];
    WCHAR target_dll_name[MAX_PATH];
    DWORD functionHash;
    CHAR function_name[MAX_PATH];
    ULONG offset;
    ULONG totalStackSize;
    BOOL setsFramePointer;
    PVOID returnAddress;
    BOOL pushRbp;
    ULONG countOfCodes;
    BOOL pushRbpIndex;
    ULONG32 pattern_size;
    CHAR pattern[256];
    BYTE byte_match[256];
    BOOL is_valid;
    PVOID function_addr;
    ULONG32 final_offset;
    BOOL push_frame;
    BOOL is_exception;
} STACK_FRAME, *PSTACK_FRAME;

//
// Unwind op codes: https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170
//
typedef enum _UNWIND_OP_CODES {
    UWOP_PUSH_NONVOL = 0, /* info == register number */
    UWOP_ALLOC_LARGE,     /* no info, alloc size in next 2 slots */
    UWOP_ALLOC_SMALL,     /* info == size of allocation / 8 - 1 */
    UWOP_SET_FPREG,       /* no info, FP = RSP + UNWIND_INFO.FPRegOffset*16 */
    UWOP_SAVE_NONVOL,     /* info == register number, offset in next slot */
    UWOP_SAVE_NONVOL_FAR, /* info == register number, offset in next 2 slots */
    UWOP_EPILOG,
    UWOP_SPARE_CODE,
    UWOP_SAVE_XMM128, /* info == XMM reg number, offset in next slot */
    UWOP_SAVE_XMM128_FAR, /* info == XMM reg number, offset in next 2 slots */
    UWOP_PUSH_MACHFRAME   /* info == 0: no error-code, 1: error-code */
} UNWIND_CODE_OPS;

typedef unsigned char UBYTE;

typedef union _UNWIND_CODE {
    struct {
        UBYTE CodeOffset;
        UBYTE UnwindOp : 4;
        UBYTE OpInfo   : 4;
    };
    USHORT FrameOffset;
} UNWIND_CODE, *PUNWIND_CODE;

typedef struct _UNWIND_INFO {
    UBYTE Version       : 3;
    UBYTE Flags         : 5;
    UBYTE SizeOfProlog;
    UBYTE CountOfCodes;
    UBYTE FrameRegister : 4;
    UBYTE FrameOffset   : 4;
    UNWIND_CODE UnwindCode[1];
/*  UNWIND_CODE MoreUnwindCode[((CountOfCodes + 1) & ~1) - 1];
*   union {
*       OPTIONAL ULONG ExceptionHandler;
*       OPTIONAL ULONG FunctionEntry;
*   };
*   OPTIONAL ULONG ExceptionData[]; */
} UNWIND_INFO, *PUNWIND_INFO;

typedef struct _STACK_INFO {
    PVOID full_stack_base;
    ULONG64 full_stack_size;
    PVOID full_stack_backup_addr;
    PVOID fake_stack_heap_addr;
    ULONG64 fake_stack_size;
    PVOID fake_stack_target_addr;
    PVOID fake_stack_rsp;
    PVOID fake_stack_rbp;
    PVOID canary_addr;
    PVOID first_ret_addr;
    PVOID storing_area;
} STACK_INFO, *PSTACK_INFO;

BOOL lookup_function_entry(
    IN ULONG_PTR ControlPc,
    PRUNTIME_FUNCTION* pFunctionEntry,
    PVOID* pImageBase);

DWORD64 get_module_base(VOID);

BOOL create_fake_callstack(
    PSTACK_INFO stack_info,
    ULONG32 function_hash);

```

`include/syscalls.h`:

```h
#pragma once

#ifndef SW3_HEADER_H_
#define SW3_HEADER_H_

#include <windows.h>

#include "hw_breakpoint.h"
#include "spoof_callstack.h"
#include "dinvoke.h"
#include "utils.h"
#include "output.h"

#define NtOpenProcess_SW3_HASH 0x825c9bd0
#define LoadLibraryA_SW3_HASH 0xC52B9BB4

#ifdef _WIN64

typedef struct _SYSCALL_DATA
{
    PVOID full_stack_base;        // 0x00
    ULONG_PTR full_stack_size;    // 0x08
    PVOID full_stack_backup_addr; // 0x10
    PVOID fake_stack_heap_addr;   // 0x18
    ULONG_PTR fake_stack_size;    // 0x20
    PVOID fake_stack_target_addr; // 0x28
    PVOID fake_stack_rsp;         // 0x30
    PVOID fake_stack_rbp;         // 0x38
    PVOID canary_addr;            // 0x40
    union {
        PVOID syscall_addr;       // 0x48
        PVOID api_addr;           // 0x48
    };
    ULONG32 syscall_number;       // 0x50
    BOOL is_api_call;             // 0x54
    BOOL is_wow64;                // 0x58
    ULONG32 num_params;           // 0x5c
    ULONG_PTR params[10];         // 0x60+0x8*i
} SYSCALL_DATA, *PSYSCALL_DATA;

#else

typedef struct _SYSCALL_DATA
{
    PVOID full_stack_base;        // 0x00
    ULONG_PTR full_stack_size;    // 0x04
    PVOID full_stack_backup_addr; // 0x08
    PVOID fake_stack_heap_addr;   // 0x0c
    ULONG_PTR fake_stack_size;    // 0x10
    PVOID fake_stack_target_addr; // 0x14
    PVOID fake_stack_rsp;         // 0x18
    PVOID fake_stack_rbp;         // 0x1c
    PVOID canary_addr;            // 0x20
    union {
        PVOID syscall_addr;       // 0x24
        PVOID api_addr;           // 0x24
    };
    ULONG32 syscall_number;       // 0x28
    BOOL is_api_call;             // 0x2c
    BOOL is_wow64;                // 0x30
    ULONG32 num_params;           // 0x34
    ULONG_PTR params[10];         // 0x38+0x4*i
} SYSCALL_DATA, *PSYSCALL_DATA;

#endif

#define SW3_SEED 0x1337C0DE
#define SW3_ROL8(v) (v << 8 | v >> 24)
#define SW3_ROR8(v) (v >> 8 | v << 24)
#define SW3_ROX8(v) ((v % 2) ? SW3_ROL8(v) : SW3_ROR8(v))
#define SW3_MAX_ENTRIES 500
#define SW3_RVA2VA(Type, DllBase, Rva) (Type)((ULONG_PTR) DllBase + Rva)

#ifdef _M_IX86
 // x86 has conflicting types with these functions
 #define NtClose _NtClose
 #define NtQueryInformationProcess _NtQueryInformationProcess
 #define NtCreateFile _NtCreateFile
 #define NtQuerySystemInformation _NtQuerySystemInformation
 #define NtWaitForSingleObject _NtWaitForSingleObject
 #define NtQueryInformationFile _NtQueryInformationFile
#endif
// Typedefs are prefixed to avoid pollution.

typedef struct _SW3_SYSCALL_ENTRY
{
    DWORD Hash;
    DWORD Address;
    PVOID SyscallAddress;
} SW3_SYSCALL_ENTRY, *PSW3_SYSCALL_ENTRY;

typedef struct _SW3_SYSCALL_LIST
{
    DWORD Count;
    SW3_SYSCALL_ENTRY Entries[SW3_MAX_ENTRIES];
} SW3_SYSCALL_LIST, *PSW3_SYSCALL_LIST;

typedef struct _SW3_PEB_LDR_DATA {
    BYTE Reserved1[8];
    PVOID Reserved2[3];
    LIST_ENTRY InMemoryOrderModuleList;
} SW3_PEB_LDR_DATA, *PSW3_PEB_LDR_DATA;

typedef struct _SW3_LDR_DATA_TABLE_ENTRY {
    PVOID Reserved1[2];
    LIST_ENTRY InMemoryOrderLinks;
    PVOID Reserved2[2];
    PVOID DllBase;
} SW3_LDR_DATA_TABLE_ENTRY, *PSW3_LDR_DATA_TABLE_ENTRY;

typedef struct _SW3_PEB {
    BYTE Reserved1[2];
    BYTE BeingDebugged;
    BYTE Reserved2[1];
    PVOID Reserved3[2];
    PSW3_PEB_LDR_DATA Ldr;
} SW3_PEB, *PSW3_PEB;

DWORD SW3_HashSyscall(
    IN PCSTR FunctionName);

PVOID GetSyscallAddress(
    IN PVOID nt_api_address,
    IN ULONG32 size_of_ntapi);

BOOL SW3_PopulateSyscallList(VOID);

BOOL local_is_wow64(VOID);

void SyscallNotFound(VOID);

#if defined(__GNUC__)
DWORD SW3_GetSyscallNumber(IN DWORD FunctionHash) asm ("SW3_GetSyscallNumber");
PVOID SW3_GetSyscallAddress(IN DWORD FunctionHash) asm ("SW3_GetSyscallAddress");
#else
DWORD SW3_GetSyscallNumber(IN DWORD FunctionHash);
PVOID SW3_GetSyscallAddress(IN DWORD FunctionHash);
#endif

#ifndef InitializeObjectAttributes
#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );        \
    (p)->RootDirectory = r;                           \
    (p)->Attributes = a;                              \
    (p)->ObjectName = n;                              \
    (p)->SecurityDescriptor = s;                      \
    (p)->SecurityQualityOfService = NULL;             \
}
#endif

typedef struct _PS_ATTRIBUTE
{
    ULONG  Attribute;
    SIZE_T Size;
    union
    {
        ULONG Value;
        PVOID ValuePtr;
    } u1;
    PSIZE_T ReturnLength;
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;

typedef struct _PS_ATTRIBUTE_LIST
{
    SIZE_T       TotalLength;
    PS_ATTRIBUTE Attributes[1];
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;

NTSTATUS _NtGetContextThread(
    IN HANDLE ThreadHandle,
    IN OUT PCONTEXT ThreadContext);

NTSTATUS _NtSetContextThread(
    IN HANDLE ThreadHandle,
    IN PCONTEXT Context);

NTSTATUS _NtOpenProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PVOID ClientId OPTIONAL);

HMODULE _LoadLibraryA(
  IN LPCSTR lpLibFileName);

#endif

```

`include/utils.h`:

```h
#pragma once

#include "ntdefs.h"

#define intAlloc(size) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size)
#define intFree(addr) HeapFree(GetProcessHeap(), 0, addr)

#define RVA(type, base_addr, rva) (type)(ULONG_PTR)((ULONG_PTR) base_addr + rva)

#ifdef _WIN64
 #define PEB_OFFSET 0x60
 #define READ_MEMLOC __readgsqword
#else
 #define PEB_OFFSET 0x30
 #define READ_MEMLOC __readfsdword
#endif


```

`scripts/get_name_hash.py`:

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# NOTE: this is a slightly different hash than the one used in SW3

import sys
import random
import struct


def get_function_hash(seed, function_name, is_syscall=True):
    function_hash = seed
    #function_name = function_name.replace('_', '')
    if is_syscall and function_name[:2] == 'Nt':
        function_name = 'Zw' + function_name[2:]
    name = function_name + '\0'
    ror8 = lambda v: ((v >> 8) & (2 ** 32 - 1)) | ((v << 24) & (2 ** 32 - 1))
    rol8 = lambda v: ((v << 8) & (2 ** 32 - 1)) | ((v >> 24) & (2 ** 32 - 1))
    rox8 = lambda v: (rol8(v) if (v % 2) != 0 else ror8(v))

    for segment in [s for s in [name[i:i + 2] for i in range(len(name))] if len(s) == 2]:
        partial_name_short = struct.unpack('<H', segment.encode())[0]
        function_hash ^= partial_name_short + rox8(function_hash)

    return function_hash


def main():
    seed = 0x1337c0de
    function_name = sys.argv[1]
    new_hash = get_function_hash(seed, function_name, is_syscall=True)
    exit(f'{function_name}: 0x{new_hash:08X}')


if __name__ == '__main__':
    if len(sys.argv) != 2:
        exit(f'usage: {sys.argv[0]} <function_name>')
    main()

```

`source/dinvoke.c`:

```c
#include "dinvoke.h"

/*
 * Check that hLibrary is indeed a DLL and not something else
 */
BOOL is_dll(
    IN HMODULE hLibrary)
{
    PIMAGE_DOS_HEADER dos;
    PIMAGE_NT_HEADERS nt;

    if (!hLibrary)
        return FALSE;

    dos = (PIMAGE_DOS_HEADER)hLibrary;

    // check the MZ magic bytes
    if (dos->e_magic != MZ)
        return FALSE;

    nt = RVA(PIMAGE_NT_HEADERS, hLibrary, dos->e_lfanew);

    // check the NT_HEADER signature
    if (nt->Signature != IMAGE_NT_SIGNATURE)
        return FALSE;

    // check that it is a DLL and not a PE
    USHORT Characteristics = nt->FileHeader.Characteristics;
    if ((Characteristics & IMAGE_FILE_DLL) != IMAGE_FILE_DLL)
        return FALSE;

    return TRUE;
}

/*
 * Look among all loaded DLLs for an export with certain function hash
 */
PVOID find_legacy_export(
    IN HMODULE hOriginalLibrary,
    IN DWORD fhash)
{
    PVOID addr;
    PND_PEB Peb = (PND_PEB)READ_MEMLOC(PEB_OFFSET);
    PND_PEB_LDR_DATA Ldr = Peb->Ldr;
    PVOID FirstEntry = &Ldr->InMemoryOrderModuleList.Flink;
    PND_LDR_DATA_TABLE_ENTRY Entry = (PND_LDR_DATA_TABLE_ENTRY)Ldr->InMemoryOrderModuleList.Flink;

    for (; Entry != FirstEntry; Entry = (PND_LDR_DATA_TABLE_ENTRY)Entry->InMemoryOrderLinks.Flink)
    {
        // avoid looking in the DLL that brought us here
        if (Entry->DllBase == hOriginalLibrary)
            continue;

        // check if this DLL has an export with the function hash we are looking for
        addr = get_function_address(
            Entry->DllBase,
            fhash,
            0);
        if (!addr)
            continue;

        return addr;
    }

    return NULL;
}

/*
 * Follow the reference and return the real address of the function
 */
PVOID resolve_reference(
    IN HMODULE hOriginalLibrary,
    IN PVOID addr)
{
    HANDLE hLibrary;
    PVOID new_addr;
    LPCSTR api;

    // addr points to a string like: NewLibrary.NewFunctionName
    api = &strrchr(addr, '.')[1];
    DWORD dll_length = (DWORD)((ULONG_PTR)api - (ULONG_PTR)addr);
    char dll[MAX_PATH + 1] = {0};
    strncpy(dll, (LPCSTR)addr, dll_length);
    strncat(dll, "dll", MAX_PATH);
    wchar_t wc_dll[MAX_PATH] = {0};
    mbstowcs(wc_dll, dll, MAX_PATH);

    // try to find the library NewLibrary
    hLibrary = get_library_address(wc_dll, FALSE);
    if (!hLibrary)
    {
        // the library is not loaded, meaning it is a legacy DLL
        new_addr = find_legacy_export(
            hOriginalLibrary,
            SW3_HashSyscall(api));

        return new_addr;
    }

    // get the address of NewFunction in NewLibrary
    new_addr = get_function_address(
        hLibrary,
        SW3_HashSyscall(api),
        0);

    return new_addr;
}

/*
 * Find an export in a DLL
 */
PVOID get_function_address(
    IN HMODULE hLibrary,
    IN DWORD fhash,
    IN WORD ordinal)
{
    PIMAGE_DOS_HEADER       dos;
    PIMAGE_NT_HEADERS       nt;
    PIMAGE_DATA_DIRECTORY   data;
    PIMAGE_EXPORT_DIRECTORY exp;
    DWORD                   exp_size;
    PDWORD                  adr;
    PDWORD                  sym;
    PWORD                   ord;
    LPCSTR                  api;
    PVOID                   addr;

    if (!is_dll(hLibrary))
        return NULL;

    dos  = (PIMAGE_DOS_HEADER)hLibrary;
    nt   = RVA(PIMAGE_NT_HEADERS, hLibrary, dos->e_lfanew);
    data = (PIMAGE_DATA_DIRECTORY)nt->OptionalHeader.DataDirectory;

    if (!data->Size || !data->VirtualAddress)
        return NULL;

    exp      = RVA(PIMAGE_EXPORT_DIRECTORY, hLibrary, data->VirtualAddress);
    exp_size = data[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

    adr = RVA(PDWORD, hLibrary, exp->AddressOfFunctions);
    sym = RVA(PDWORD, hLibrary, exp->AddressOfNames);
    ord = RVA(PWORD,  hLibrary, exp->AddressOfNameOrdinals);

    addr = NULL;
    if (fhash)
    {
        // iterate over all the exports
        for (DWORD i = 0; i < exp->NumberOfNames; i++)
        {
            api = RVA(LPCSTR, hLibrary, sym[i]);
            //addr = RVA(PVOID, hLibrary, adr[ord[i]]);
            //DPRINT("%lx -> %s -> 0x%llx", fhash, api, (ULONG_PTR)addr-(ULONG_PTR)hLibrary);
            if (fhash == SW3_HashSyscall(api))
            {
                addr = RVA(PVOID, hLibrary, adr[ord[i]]);
                break;
            }
        }
    }
    else
    {
        addr = RVA(PVOID, hLibrary, adr[ordinal - exp->Base]);
    }
    if (!addr)
        return NULL;

    // check if addr is a pointer to another function in another DLL
    if ((ULONG_PTR)addr >= (ULONG_PTR)exp &&
        (ULONG_PTR)addr <  RVA(ULONG_PTR, exp, exp_size))
    {
        // the function seems to be defined somewhere else
        addr = resolve_reference(
            hLibrary,
            addr);
    }
    return addr;
}

/*
 * Get the base address of a DLL
 */
HANDLE get_library_address(
    IN LPWSTR lib_path,
    IN BOOL DoLoad)
{
    PND_PEB Peb = (PND_PEB)READ_MEMLOC(PEB_OFFSET);
    PND_PEB_LDR_DATA Ldr = Peb->Ldr;
    PVOID FirstEntry = &Ldr->InMemoryOrderModuleList.Flink;
    PND_LDR_DATA_TABLE_ENTRY Entry = (PND_LDR_DATA_TABLE_ENTRY)Ldr->InMemoryOrderModuleList.Flink;
    BOOL is_full_path = wcsrchr(lib_path, '\\') ? TRUE : FALSE;

    do
    {
        if (is_full_path)
        {
            // the dll name was provided
            if (!_wcsicmp(lib_path, Entry->FullDllName.Buffer))
                return Entry->DllBase;
        }
        else
        {
            // the full path was provided
            if (!_wcsicmp(lib_path, Entry->BaseDllName.Buffer))
                return Entry->DllBase;
        }

        Entry = (PND_LDR_DATA_TABLE_ENTRY)Entry->InMemoryOrderLinks.Flink;
    } while (Entry != FirstEntry);

    if (!DoLoad)
        return NULL;

    // the library is not currently loaded
    // get the address of LdrLoadDll
    LdrLoadDll_t LdrLoadDll = (LdrLoadDll_t)(ULONG_PTR)get_function_address(
        get_library_address(NTDLL_DLL, FALSE),
        LdrLoadDll_SW3_HASH,
        0);
    if (!LdrLoadDll)
    {
        api_not_found("LdrLoadDll");
        return NULL;
    }

    // create a UNICODE_STRING with the library name
    UNICODE_STRING ModuleFileName = { 0 };
    ModuleFileName.Buffer = lib_path;
    ModuleFileName.Length = (USHORT)wcsnlen(ModuleFileName.Buffer, MAX_PATH);
    ModuleFileName.Length *= 2;
    ModuleFileName.MaximumLength = ModuleFileName.Length + 2;

    // load the library
    HANDLE hLibrary = NULL;
    NTSTATUS status = LdrLoadDll(
        NULL,
        0,
        &ModuleFileName,
        &hLibrary);
    if (!NT_SUCCESS(status))
    {
        DPRINT_ERR(
            "Failed to load %ls, status: 0x%lx\n",
            lib_path,
            status);
        return NULL;
    }
    //DPRINT("Loaded %ls at 0x%p", lib_path, hLibrary);

    return hLibrary;
}

PVOID find_dll_by_pointer(
    IN PVOID address)
{
    PND_PEB Peb = (PND_PEB)READ_MEMLOC(PEB_OFFSET);
    PND_PEB_LDR_DATA Ldr = Peb->Ldr;
    PVOID FirstEntry = &Ldr->InMemoryOrderModuleList.Flink;
    PND_LDR_DATA_TABLE_ENTRY Entry = (PND_LDR_DATA_TABLE_ENTRY)Ldr->InMemoryOrderModuleList.Flink;

    do
    {
        if ((ULONG_PTR)address >= (ULONG_PTR)Entry->DllBase &&
            (ULONG_PTR)address < RVA(ULONG_PTR, Entry->DllBase, Entry->SizeOfImage))
            return Entry->DllBase;

        Entry = (PND_LDR_DATA_TABLE_ENTRY)Entry->InMemoryOrderLinks.Flink;
    } while (Entry != FirstEntry);

    DPRINT_ERR("Could not find the target DLL from the pointer 0x%p", address);

    return NULL;
}

```

`source/hw_breakpoint.c`:

```c

#include "hw_breakpoint.h"

ULONG_PTR set_bits(
    ULONG_PTR dw,
    int lowBit,
    int bits,
    ULONG_PTR newValue)
{
    ULONG_PTR mask = (1UL << bits) - 1UL;
    dw = (dw & ~(mask << lowBit)) | (newValue << lowBit);
    return dw;
}

VOID clear_breakpoint(
    CONTEXT* ctx,
    int index)
{
    //Clear the releveant hardware breakpoint
    switch (index)
    {
        case 0:
            ctx->Dr0 = 0;
            break;
        case 1:
            ctx->Dr1 = 0;
            break;
        case 2:
            ctx->Dr2 = 0;
            break;
        case 3:
            ctx->Dr3 = 0;
            break;
    }
     //Clear DRx HBP to disable for local mode
    ctx->Dr7 = set_bits(ctx->Dr7, (index * 2), 1, 0);
    ctx->Dr6 = 0;
    ctx->EFlags = 0;
}

VOID enable_breakpoint(
    CONTEXT* ctx,
    PVOID address,
    int index)
{
    switch (index)
    {
        case 0:
            ctx->Dr0 = (ULONG_PTR)address;
            break;
        case 1:
            ctx->Dr1 = (ULONG_PTR)address;
            break;
        case 2:
            ctx->Dr2 = (ULONG_PTR)address;
            break;
        case 3:
            ctx->Dr3 = (ULONG_PTR)address;
            break;
    }

    //Set bits 16-31 as 0, which sets
    //DR0-DR3 HBP's for execute HBP
    ctx->Dr7 = set_bits(ctx->Dr7, 16, 16, 0);

    //Set DRx HBP as enabled for local mode
    ctx->Dr7 = set_bits(ctx->Dr7, (index * 2), 1, 1);
    ctx->Dr6 = 0;
}

/*
 * This function is responsible for:
 * 1) find the relevant information after the canary
 * 2) restore the registers
 * 3) restore the original stack
 * 4) return to trigger_syscall/trigger_api
 */
__declspec(naked) LONG hwbp_handler(
    PEXCEPTION_POINTERS exceptions)
{
#if defined(_WIN64)
    asm(
        // check that the ExceptionCode is EXCEPTION_SINGLE_STEP
        "mov rax, [rcx] \n"
        "mov eax, [rax] \n"
        "cmp eax, 0x80000004 \n"
        "jnz leave \n"
        // get the status code
        "mov rax, rcx \n"
        "mov rcx, [rax+0x08] \n"
        "mov rax, [rcx+0x78] \n"
        // search for the canary
        // r11: exceptions->ContextRecord->Rsp
        "mov r11, [rcx+0x98] \n"
        "mov r9, 0xDEADBEEFCAFEBABE \n"
        "search_loop: \n"
        "add r11, 0x8 \n"
        "cmp [r11], r9 \n"
        "jne search_loop \n"
        // r11: storing_area
        "mov r11, [r11+0x08] \n"
        // full_stack_size
        "mov rcx, [r11+0x00] \n"
        // full_stack_backup_addr
        "mov rdx, [r11+0x08] \n"
        // full_stack_base
        "mov r9, [r11+0x10] \n"
        // restore RBX
        "mov rbx, [r11+0x18] \n"
        // restore RBP
        "mov rbp, [r11+0x20] \n"
        // restore RSP
        "mov rsp, [r11+0x28] \n"
        // restore RIP
        "mov r8, [r11+0x30] \n"
        // restore the original stack
        "xor r11, r11 \n"
        "restore_stack_loop: \n"
        "mov r10b, [rdx+r11] \n"
        "mov [r9+r11], r10b \n"
        "inc r11 \n"
        "cmp r11, rcx \n"
        "jne restore_stack_loop \n"
        // jump back to the Nt* function
        "jmp r8 \n"
        "leave: \n"
        "mov eax, 0xffffffff \n"
        "ret \n"
    );
#else
    asm(
        // check that the ExceptionCode is EXCEPTION_SINGLE_STEP
        "mov ecx, [esp+0x04] \n"
        "mov eax, [ecx] \n"
        "mov eax, [eax] \n"
        "cmp eax, 0x80000004 \n"
        "jnz leave \n"
        // ecx: ContextRecord
        "mov ecx, [ecx+0x04] \n"
        // get the status
        "mov eax, [ecx+0xb0] \n"
        // search for the canary
        // edi: exceptions->ContextRecord->Rsp
        "mov edi, [ecx+0xc4] \n"
        "mov esi, 0xDEADBEEF \n"
        "search_loop: \n"
        "add edi, 0x04 \n"
        "cmp dword ptr [edi], esi \n"
        "jne search_loop \n"
        // edi: storing_area
        "mov edi, [edi+0x04] \n"
        // restore the original stack
        // full_stack_size
        "mov ecx, [edi+0x00] \n"
        // full_stack_backup_addr
        "mov esi, [edi+0x04] \n"
        // full_stack_base
        "mov edx, [edi+0x08] \n"
        "restore_stack_loop: \n"
        "mov bl, [esi+ecx-0x1] \n"
        "mov [edx+ecx-0x1], bl \n"
        "dec ecx \n"
        "cmp ecx, 0x0 \n"
        "jne restore_stack_loop \n"
        // restore registers
        "mov ebx, [edi+0x0c] \n"
        "mov ebp, [edi+0x10] \n"
        "mov esp, [edi+0x14] \n"
        "mov edi, [edi+0x18] \n"
        // jump back to the Nt* function
        "jmp edi \n"
        "leave: \n"
        "mov eax, 0xffffffff \n"
        "ret \n"
    );
#endif
}

BOOL set_hwbp(
    PVOID address,
    PHANDLE phHwBpHandler)
{
    BOOL ret_val = FALSE;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    HANDLE hHwBpHandler = NULL;
    CONTEXT threadCtx = { 0 };
    memset(&threadCtx, 0, sizeof(threadCtx));
    threadCtx.ContextFlags = CONTEXT_ALL;
    RtlAddVectoredExceptionHandler_t RtlAddVectoredExceptionHandler = NULL;

    // find the address of RtlAddVectoredExceptionHandler_t dynamically
    RtlAddVectoredExceptionHandler = (RtlAddVectoredExceptionHandler_t)(ULONG_PTR)get_function_address(
        get_library_address(NTDLL_DLL, TRUE),
        RtlAddVectoredExceptionHandler_SW3_HASH,
        0);
    if (!RtlAddVectoredExceptionHandler)
    {
        api_not_found("RtlAddVectoredExceptionHandler");
        goto cleanup;
    }

    hHwBpHandler = RtlAddVectoredExceptionHandler(1, (PVECTORED_EXCEPTION_HANDLER)hwbp_handler);
    if (!hHwBpHandler)
    {
        function_failed("RtlAddVectoredExceptionHandler");
        goto cleanup;
    }

    status = _NtGetContextThread(NtCurrentThread(), &threadCtx);
    if (!NT_SUCCESS(status))
    {
        syscall_failed("NtGetContextThread", status);
        goto cleanup;
    }

    enable_breakpoint(&threadCtx, address, DEBUG_REGISTER_INDEX);

    status = _NtSetContextThread(NtCurrentThread(), &threadCtx);
    if (!NT_SUCCESS(status))
    {
        syscall_failed("NtSetContextThread", status);
        goto cleanup;
    }

    *phHwBpHandler = hHwBpHandler;
    ret_val = TRUE;

cleanup:
    return ret_val;
}

VOID unset_hwbp(
    HANDLE hHwBpHandler)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    CONTEXT threadCtx = { 0 };
    memset(&threadCtx, 0, sizeof(threadCtx));
    threadCtx.ContextFlags = CONTEXT_ALL;
    ULONG ret_val = 0;
    RtlRemoveVectoredExceptionHandler_t RtlRemoveVectoredExceptionHandler = NULL;

    // find the address of RtlRemoveVectoredExceptionHandler dynamically
    RtlRemoveVectoredExceptionHandler = (RtlRemoveVectoredExceptionHandler_t)(ULONG_PTR)get_function_address(
        get_library_address(NTDLL_DLL, TRUE),
        RtlRemoveVectoredExceptionHandler_SW3_HASH,
        0);
    if (!RtlRemoveVectoredExceptionHandler)
    {
        api_not_found("RtlRemoveVectoredExceptionHandler");
        goto cleanup;
    }

    status = _NtGetContextThread(NtCurrentThread(), &threadCtx);
    if (!NT_SUCCESS(status))
    {
        syscall_failed("NtGetContextThread", status);
        goto cleanup;
    }

    clear_breakpoint(&threadCtx, DEBUG_REGISTER_INDEX);

    status = _NtSetContextThread(NtCurrentThread(), &threadCtx);
    if (!NT_SUCCESS(status))
    {
        syscall_failed("NtSetContextThread", status);
        goto cleanup;
    }

    ret_val = RtlRemoveVectoredExceptionHandler(hHwBpHandler);
    if (!ret_val)
    {
        function_failed("RtlRemoveVectoredExceptionHandler");
        goto cleanup;
    }

cleanup:
    return;
}

```

`source/main.c`:

```c

#include "main.h"
#include "syscalls.h"

int main(int argc, char *argv[])
{
    if (argc != 3)
    {
        PRINT_ERR("usage: %s <pid> <dll>", argv[0]);
        return -1;
    }

    PRINT("-- HW Call Stack --\n")

    HMODULE hLib = NULL;
    LPSTR dll_path = NULL;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    ACCESS_MASK DesiredAccess = PROCESS_QUERY_LIMITED_INFORMATION;

    // variables passed by reference must be stored on the heap
    PHANDLE ProcessHandle = intAlloc(sizeof(HANDLE));
    POBJECT_ATTRIBUTES ObjectAttributes = intAlloc(sizeof(OBJECT_ATTRIBUTES));
    PCLIENT_ID uPid = intAlloc(sizeof(CLIENT_ID));
    dll_path = intAlloc(MAX_PATH);
    strncpy(dll_path, argv[2], MAX_PATH);
    uPid->UniqueProcess = (HANDLE)(ULONG_PTR)atoi(argv[1]);
    uPid->UniqueThread = (HANDLE)0;
    InitializeObjectAttributes(
        ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL);

    PRINT("calling NtOpenProcess...");
    status = _NtOpenProcess(
        ProcessHandle,
        DesiredAccess,
        ObjectAttributes,
        uPid);
    PRINT("status: 0x%lx", status);

    PRINT("\ncalling LoadLibraryA...");
    hLib = _LoadLibraryA(dll_path);
    PRINT("Kernel32.dll has been loaded at 0x%p", hLib);

    PRINT("\nBye!");

    intFree(ProcessHandle);
    intFree(ObjectAttributes);
    intFree(uPid);
    intFree(dll_path);

    return 0;
}

```

`source/spoof_callstack.c`:

```c
#include "spoof_callstack.h"

PVOID from_fake_to_real(PSTACK_INFO stack_info, PVOID pointer)
{
    if (!pointer)
        return pointer;

    PVOID target_stack_bottom = RVA(PVOID, stack_info->fake_stack_target_addr, stack_info->fake_stack_size);
    return (PVOID)(ULONG_PTR)((ULONG_PTR)target_stack_bottom - ((ULONG_PTR)stack_info->fake_stack_heap_addr + stack_info->fake_stack_size - (ULONG_PTR)pointer));
}

VOID set_frame_info(
    OUT PSTACK_FRAME frame,
    IN LPWSTR path,
    IN DWORD api_hash,
    IN LPCSTR api_name,
    IN PCHAR pattern,
    IN PBYTE byte_match,
    IN ULONG offset)
{
    ULONG32 pattern_size = 0;

    memset(frame, 0, sizeof(STACK_FRAME));
    wcsncpy(frame->targetDll, path, wcsnlen(path, MAX_PATH));
    if (wcsrchr(path, '\\'))
        wcsncpy(frame->target_dll_name, &wcsrchr(path, '\\')[1], wcsnlen(path, MAX_PATH));
    else
        wcsncpy(frame->target_dll_name, path, wcsnlen(path, MAX_PATH));
    for (int i = 0; i < MAX_PATH; ++i)
    {
        if (frame->target_dll_name[i] == '.')
        {
            frame->target_dll_name[i] = 0;
            break;
        }
    }
    frame->functionHash = api_hash;
    if (api_name)
        strncpy(frame->function_name, api_name, MAX_PATH);
    frame->offset = offset;
    frame->totalStackSize = 0;
    frame->setsFramePointer = FALSE;
    frame->returnAddress = 0;
    frame->pushRbp = FALSE;
    frame->countOfCodes = 0;
    frame->pushRbpIndex = 0;
    if (pattern && byte_match)
    {
        pattern_size = strnlen(pattern, sizeof(frame->pattern) - 1);
        memcpy(frame->pattern, pattern, pattern_size);
        memcpy(frame->byte_match, byte_match, pattern_size);
    }
    frame->is_valid = FALSE;
    frame->push_frame = FALSE;
    frame->is_exception = FALSE;
}

BOOL compare_bytes(
    IN PBYTE pData,
    IN PBYTE bMask,
    IN PCHAR szMask)
{
    for (; *szMask; ++szMask, ++pData, ++bMask)
    {
        if (*szMask == 'x' && *pData != *bMask)
            return FALSE;
    }

    return TRUE;
}

BOOL find_pattern(
    IN PVOID dwAddress,
    IN ULONG32 dwLen,
    IN PBYTE bMask,
    IN PCHAR szMask,
    OUT PVOID* pattern_addr)
{
    PVOID current_address = NULL;
    for (ULONG32 i = 0; i < dwLen; i++)
    {
        current_address = RVA(PVOID, dwAddress, i);
        if (compare_bytes(current_address, bMask, szMask))
        {
            *pattern_addr = current_address;
            return TRUE;
        }
    }

    return FALSE;
}

VOID set_loadlibrarya_callstack(
    IN PSTACK_FRAME callstack,
    OUT PDWORD number_of_frames)
{
    DWORD i = 0;
#ifdef _WIN64
    // advapi32.dll+0x49d1e after calling LoadLibraryA("wldap32.dll")
    set_frame_info(
        &callstack[i++],
        L"advapi32.dll",
        0,
        NULL,
        "xxx?xxx?xxx?xxx?x",
        (PBYTE)"\x48\x89\x5d\x07\x48\x89\x5d\xdf\x48\x89\x5d\xef\x48\x89\x5d\xa7\x48",
        23);
    // kernel32.dll!BaseThreadInitThunk+0x14 after the call instruction
    set_frame_info(
        &callstack[i++],
        L"Kernel32.dll",
        0xA63E8FBC,
        "BaseThreadInitThunk",
        "x??x?????x",
        (PBYTE)"\x48\x8b\xc2\xff\x15\x24\xcc\x06\x00\x8b",
        9);
    // ntdll.dll!RtlUserThreadStart+0x21 after the call instruction
    set_frame_info(
        &callstack[i++],
        L"ntdll.dll",
        0x551C5A87,
        "RtlUserThreadStart",
        "x",
        (PBYTE)"\xff",
        6);
#else
    // advapi32.dll+0x49d1e after calling LoadLibraryA("wldap32.dll")
    set_frame_info(
        &callstack[i++],
        L"advapi32.dll",
        0,
        NULL,
        "xx?xx?xx?xx?x",
        (PBYTE)"\x89\x75\xc8\x89\x75\xc0\x89\x75\xec\x89\x45\xbc\xff",
        18);
    // kernel32.dll!BaseThreadInitThunk+0x14 after the call instruction
    set_frame_info(
        &callstack[i++],
        L"Kernel32.dll",
        0xA63E8FBC,
        "BaseThreadInitThunk",
        "xx????x",
        (PBYTE)"\xff\x15\x38\x20\x88\x6b\xff",
        8);
    // ntdll.dll!RtlUserThreadStart+0x21 after the call instruction
    set_frame_info(
        &callstack[i++],
        L"ntdll.dll",
        0x551C5A87,
        "RtlUserThreadStart",
        "xx????x",
        (PBYTE)"\xff\x15\xe0\x91\x3a\x4b\xff",
        8);
#endif
    *number_of_frames = i;
}

VOID set_ntopenprocess_callstack(
    IN PSTACK_FRAME callstack,
    OUT PDWORD number_of_frames)
{
    DWORD i = 0;
#ifdef _WIN64
    // kernelbase.dll!ProcessIdToSessionId+0x96 after calling NtOpenProcess
    set_frame_info(
        &callstack[i++],
        L"KernelBase.dll",
        0xF495D426,
        "ProcessIdToSessionId",
        "xxx",
        (PBYTE)"\x48\xff\x15",
        7);
    // kernel32.dll!BaseThreadInitThunk+0x14 after the call instruction
    set_frame_info(
        &callstack[i++],
        L"Kernel32.dll",
        0xA63E8FBC,
        "BaseThreadInitThunk",
        "x??x?????x",
        (PBYTE)"\x48\x8b\xc2\xff\x15\x24\xcc\x06\x00\x8b",
        9);
    // ntdll.dll!RtlUserThreadStart+0x21 after the call instruction
    set_frame_info(
        &callstack[i++],
        L"ntdll.dll",
        0x551C5A87,
        "RtlUserThreadStart",
        "x",
        (PBYTE)"\xff",
        6);
#else
    // kernelbase.dll!ProcessIdToSessionId+0x96 after calling NtOpenProcess
    set_frame_info(
        &callstack[i++],
        L"KernelBase.dll",
        0xF495D426,
        "ProcessIdToSessionId",
        "xx????x",
        (PBYTE)"\xff\x15\x8c\x38\x1e\x10\x85",
        6);
    // kernel32.dll!BaseThreadInitThunk+0x14 after the call instruction
    set_frame_info(
        &callstack[i++],
        L"Kernel32.dll",
        0xA63E8FBC,
        "BaseThreadInitThunk",
        "xx????x",
        (PBYTE)"\xff\x15\x38\x20\x88\x6b\xff",
        8);
    // ntdll.dll!RtlUserThreadStart+0x21 after the call instruction
    set_frame_info(
        &callstack[i++],
        L"ntdll.dll",
        0x551C5A87,
        "RtlUserThreadStart",
        "xx????x",
        (PBYTE)"\xff\x15\xe0\x91\x3a\x4b\xff",
        8);
#endif
    *number_of_frames = i;
}

VOID set_default_callstack(
    IN PSTACK_FRAME callstack,
    OUT PDWORD number_of_frames)
{
    DWORD i = 0;
#ifdef _WIN64
    // kernel32.dll!BaseThreadInitThunk+0x14 after the call instruction
    set_frame_info(
        &callstack[i++],
        L"Kernel32.dll",
        0xA63E8FBC,
        "BaseThreadInitThunk",
        "x??x?????x",
        (PBYTE)"\x48\x8b\xc2\xff\x15\x24\xcc\x06\x00\x8b",
        9);
    // ntdll.dll!RtlUserThreadStart+0x21 after the call instruction
    set_frame_info(
        &callstack[i++],
        L"ntdll.dll",
        0x551C5A87,
        "RtlUserThreadStart",
        "x",
        (PBYTE)"\xff",
        6);
#else
    // kernel32.dll!BaseThreadInitThunk+0x14 after the call instruction
    set_frame_info(
        &callstack[i++],
        L"Kernel32.dll",
        0xA63E8FBC,
        "BaseThreadInitThunk",
        "xx????x",
        (PBYTE)"\xff\x15\x38\x20\x88\x6b\xff",
        8);
    // ntdll.dll!RtlUserThreadStart+0x21 after the call instruction
    set_frame_info(
        &callstack[i++],
        L"ntdll.dll",
        0x551C5A87,
        "RtlUserThreadStart",
        "xx????x",
        (PBYTE)"\xff\x15\xe0\x91\x3a\x4b\xff",
        8);
#endif
    *number_of_frames = i;
}

BOOL get_text_section(
    PVOID image_base,
    PVOID* ptext_section_addr,
    PDWORD ptext_section_size)
{
    BOOL ret_val = FALSE;
    PIMAGE_DOS_HEADER dos = NULL;
    PIMAGE_NT_HEADERS nt = NULL;
    PIMAGE_SECTION_HEADER section_hdr = NULL;

    dos = (PIMAGE_DOS_HEADER)image_base;
    nt = RVA(PIMAGE_NT_HEADERS, dos, dos->e_lfanew);
    section_hdr = RVA(PIMAGE_SECTION_HEADER, &nt->OptionalHeader, nt->FileHeader.SizeOfOptionalHeader);

    for (DWORD i = 0; i < nt->FileHeader.NumberOfSections; i++)
    {
        if (strcmp(".text", (char*)section_hdr[i].Name) == 0)
        {
            *ptext_section_addr = RVA(PVOID, image_base, section_hdr[i].VirtualAddress);
            *ptext_section_size = section_hdr[i].SizeOfRawData;
            ret_val = TRUE;
            break;
        }
    }

    return ret_val;
}

/*
 * Calculate the return address for fake frame
 * always ensuring that it ends up in a valid address
 */
BOOL calculate_return_address(
    IN OUT PSTACK_FRAME frame)
{
    BOOL success = FALSE;
    BOOL ret_val = FALSE;
    PVOID image_base = NULL;
    PVOID func_base = NULL;
    ULONG32 max_look_range = 0;
    PVOID text_section_addr = 0;
    DWORD text_section_size = 0;
    PVOID pattern_addr = NULL;

    // get library base address
    image_base = (PVOID)get_library_address(frame->targetDll, TRUE);
    if (!image_base)
    {
        DPRINT_ERR("failed to get image base of %ls", frame->targetDll);
        goto cleanup;
    }

    success = get_text_section(
        image_base,
        &text_section_addr,
        &text_section_size);
    if (!success)
    {
        DPRINT_ERR("could not find the .text section of %ls", frame->targetDll);
        goto cleanup;
    }

    // set the return address to the start of the .text section
    frame->returnAddress = text_section_addr;

    if (frame->function_name[0] || frame->functionHash)
    {
        // get the address of the API
        if (frame->function_name[0])
        {
            func_base = get_function_address(
                image_base,
                SW3_HashSyscall(frame->function_name),
                0);
        }
        else
        {
            func_base = get_function_address(
                image_base,
                frame->functionHash,
                0);
        }
        if (!func_base)
        {
            if (frame->function_name[0])
            {
                DPRINT_ERR("could not find function with name %s in %ls", frame->function_name, frame->targetDll);
            }
            else
            {
                DPRINT_ERR("could not find function with hash 0x%lx in %ls", frame->functionHash, frame->targetDll);
            }
            goto cleanup;
        }
        // set the return address as the start of the function
        frame->returnAddress = func_base;
        // save the function address for pretty printing the stack layout
        frame->function_addr = func_base;
    }

    if (frame->pattern[0])
    {
        // make sure the pattern is within limits of the .text section
        max_look_range = text_section_size - ((ULONG_PTR)frame->returnAddress - (ULONG_PTR)text_section_addr) - 1;

        success = find_pattern(
            frame->returnAddress,
            max_look_range,
            frame->byte_match,
            frame->pattern,
            &pattern_addr);
        if (!success)
        {
            if (frame->function_name[0])
            {
                DPRINT_ERR("failed to find pattern match for the function with name %s", frame->function_name);
            }
            else
            {
                DPRINT_ERR("failed to find pattern match for the function with hash 0x%lx", frame->functionHash);
            }
            goto cleanup;
        }
        // set the return address to the start of the pattern found
        frame->returnAddress = pattern_addr;
    }

    if (frame->offset)
    {
        // make sure the offset is within limits of the .text section
        max_look_range = text_section_size - ((ULONG_PTR)frame->returnAddress - (ULONG_PTR)text_section_addr) - 1;
        if (frame->offset > max_look_range)
        {
            if (frame->function_name[0])
            {
                DPRINT_ERR("the offset 0x%lx for the function with name %s is too large", frame->offset, frame->function_name);
            }
            else
            {
                DPRINT_ERR("the offset 0x%lx for the function with hash 0x%lx is too large", frame->offset, frame->functionHash);
            }
            goto cleanup;
        }
        // add an offset to the current return address
        frame->returnAddress = RVA(PVOID, frame->returnAddress, frame->offset);
    }

    // save the final offset for pretty printing the stack layout
    if (frame->function_addr)
        frame->final_offset = (ULONG_PTR)frame->returnAddress - (ULONG_PTR)frame->function_addr;
    else
        frame->final_offset = (ULONG_PTR)frame->returnAddress - (ULONG_PTR)image_base;

    ret_val = TRUE;

cleanup:
    return ret_val;
}

#ifdef _WIN64

/*
 * Calculates the total stack space used by the fake stack frame. Uses
 * a minimal implementation of RtlVirtualUnwind to parse the unwind codes
 * for target function and add up total stack size. Largely based on:
 * https://github.com/hzqst/unicorn_pe/blob/master/unicorn_pe/except.cpp#L773
 */
BOOL calculate_function_stack_size_internal(
    IN OUT PSTACK_FRAME frame,
    IN ULONG32 frame_index,
    IN ULONG32 number_of_frames,
    PRUNTIME_FUNCTION pRuntimeFunction,
    PVOID image_base)
{
    BOOL ret_val = FALSE;
    PUNWIND_INFO pUnwindInfo = NULL;
    ULONG unwindOperation = 0;
    ULONG operationInfo = 0;
    ULONG index = 0;
    ULONG frameOffset = 0;
    ULONG PrologOffset = 0;
    BOOL success = TRUE;
    UCHAR m_RtlpUnwindOpSlotTable[12];

    UCHAR slottable[] = {
        1,          // UWOP_PUSH_NONVOL
        2,          // UWOP_ALLOC_LARGE (or 3, special cased in lookup code)
        1,          // UWOP_ALLOC_SMALL
        1,          // UWOP_SET_FPREG
        2,          // UWOP_SAVE_NONVOL
        3,          // UWOP_SAVE_NONVOL_FAR
        1,          // UWOP_EPILOG
        0,          // UWOP_SPARE_CODE
        2,          // UWOP_SAVE_XMM128
        3,          // UWOP_SAVE_XMM128_FAR
        1,          // UWOP_PUSH_MACHFRAME
        1           // UWOP_SET_FPREG_LARGE
    };
    memcpy(m_RtlpUnwindOpSlotTable, slottable, sizeof(slottable));

    do
    {
        unwindOperation = 0;
        operationInfo = 0;
        index = 0;
        frameOffset = 0 ;
        success = TRUE;
        pUnwindInfo = (PUNWIND_INFO)(ULONG_PTR)(pRuntimeFunction->UnwindData + (ULONG_PTR)image_base);
        PrologOffset = (ULONG)(ULONG_PTR)(frame->returnAddress - (pRuntimeFunction->BeginAddress + (ULONG_PTR)image_base));

        /*
         * [1] Loop over unwind info.
         * NB As this is a PoC, it does not handle every unwind operation, but
         * rather the minimum set required to successfully mimic the default
         * call stacks included.
         */
        while (index < pUnwindInfo->CountOfCodes)
        {
            unwindOperation = pUnwindInfo->UnwindCode[index].UnwindOp;
            operationInfo = pUnwindInfo->UnwindCode[index].OpInfo;

            if (PrologOffset >= pUnwindInfo->UnwindCode[index].CodeOffset)
            {
                /*
                 * [2] Loop over unwind codes and calculate
                 * total stack space used by target function.
                 */
                if (unwindOperation == UWOP_PUSH_NONVOL)
                {
                    // UWOP_PUSH_NONVOL is 8 bytes.
                    frame->totalStackSize += 8;
                    // Record if it pushes rbp as
                    // this is important for UWOP_SET_FPREG.
                    if (RBP_OP_INFO == operationInfo)
                    {
                        frame->pushRbp = TRUE;
                        // Record when rbp is pushed to stack.
                        frame->countOfCodes = pUnwindInfo->CountOfCodes;
                        frame->pushRbpIndex = index + 1;
                    }
                }
                else if (unwindOperation == UWOP_SAVE_NONVOL)
                {
                    // UWOP_SAVE_NONVOL doesn't contribute to stack size
                    // but you do need to increment index.
                    index += 1;
                }
                else if (unwindOperation == UWOP_SAVE_NONVOL_FAR)
                {
                    // UWOP_SAVE_NONVOL_FAR doesn't contribute to stack size
                    // but you do need to increment index.
                    index += 2;
                }
                else if (unwindOperation == UWOP_ALLOC_SMALL)
                {
                    //Alloc size is op info field * 8 + 8.
                    frame->totalStackSize += ((operationInfo * 8) + 8);
                }
                else if (unwindOperation == UWOP_ALLOC_LARGE)
                {
                    // Alloc large is either:
                    // 1) If op info == 0 then size of alloc / 8
                    // is in the next slot (i.e. index += 1).
                    // 2) If op info == 1 then size is in next
                    // two slots.
                    index += 1;
                    frameOffset = pUnwindInfo->UnwindCode[index].FrameOffset;
                    if (operationInfo == 0)
                    {
                        frameOffset *= 8;
                    }
                    else
                    {
                        index += 1;
                        frameOffset += (pUnwindInfo->UnwindCode[index].FrameOffset << 16);
                    }
                    frame->totalStackSize += frameOffset;
                }
                else if (unwindOperation == UWOP_SET_FPREG)
                {
                    // This sets rsp == rbp (mov rsp,rbp), so we need to ensure
                    // that rbp is the expected value (in the frame above) when
                    // it comes to spoof this frame in order to ensure the
                    // call stack is correctly unwound.
                    frame->setsFramePointer = TRUE;

                    // if the frame sets the FramePointer but is the top frame,
                    // reduce the totalStackSize by 0x10 bytes (no idea why this works)
                    if (frame_index == 0)
                        frame->totalStackSize -= 0x10;
                }
                else if (unwindOperation == UWOP_EPILOG)
                {
                    // do nothing
                }
                else if (unwindOperation == UWOP_SAVE_XMM128)
                {
                    // do nothing
                    index += 1;
                }
                else if (unwindOperation == UWOP_SAVE_XMM128_FAR)
                {
                    // do nothing
                    index += 2;
                }
                else if (unwindOperation == UWOP_PUSH_MACHFRAME)
                {
                    frame->push_frame = TRUE;
                    frame->is_exception = operationInfo != 0;
                    break;
                }
                else
                {
                    PRINT_ERR("unsupported Unwind Op Code: 0x%lx", unwindOperation);
                    success = FALSE;
                }

                index += 1;
            }
            else
            {
                //
                // Skip this unwind operation by advancing the slot index by the
                // number of slots consumed by this operation.
                //

                index += m_RtlpUnwindOpSlotTable[unwindOperation];

                //
                // Special case any unwind operations that can consume a variable
                // number of slots.
                //

                if (unwindOperation == UWOP_ALLOC_LARGE)
                {
                    if (operationInfo != 0)
                    {
                        index += 1;
                    }

                }
            }
        }

        if (!success)
            goto cleanup;

        // If chained unwind information is present then we need to
        // also recursively parse this and add to total stack size.
        if (pUnwindInfo->Flags & UNW_FLAG_CHAININFO)
        {
            index = pUnwindInfo->CountOfCodes;
            if (0 != (index & 1))
            {
                index += 1;
            }
            pRuntimeFunction = (PRUNTIME_FUNCTION)(&pUnwindInfo->UnwindCode[index]);
        }
    } while(pUnwindInfo->Flags & UNW_FLAG_CHAININFO);

    // Add the size of the return address (8 bytes).
    frame->totalStackSize += 8;

    ret_val = TRUE;

cleanup:
    return ret_val;
}

#endif

/*
 * Retrieves the runtime function entry for given fake ret address
 * and calls CalculateFunctionStackSize, which will recursively
 * calculate the total stack space utilisation.
 */
BOOL calculate_function_stack_size(
    IN OUT PSTACK_FRAME frame,
    IN ULONG32 frame_index,
    IN ULONG32 number_of_frames)
{
#ifdef _WIN64

    BOOL ret_val = FALSE;
    BOOL success = FALSE;
    PRUNTIME_FUNCTION pRuntimeFunction = NULL;
    PVOID ImageBase = NULL;

    success = lookup_function_entry(
        (ULONG_PTR)frame->returnAddress,
        &pRuntimeFunction,
        &ImageBase);
    if (!pRuntimeFunction)
        goto cleanup;

    /*
     * [2] Recursively calculate the total stack size for
     * the function we are "returning" to
     */
    success = calculate_function_stack_size_internal(
        frame,
        frame_index,
        number_of_frames,
        pRuntimeFunction,
        ImageBase);
    if (!success)
        goto cleanup;

    ret_val = TRUE;

cleanup:
    return ret_val;

#else

    // set the totalStackSize to a value large enough to store many parameters
    frame->totalStackSize = 0x70;
    return TRUE;

#endif
}

/*
 * Takes a target call stack and configures it ready for use
 * via loading any required dlls, resolving module addresses
 * and calculating spoofed return addresses.
 */
VOID initialize_spoofed_callstack(
    PSTACK_FRAME callstack,
    DWORD number_of_frames)
{
    BOOL success = FALSE;
    PSTACK_FRAME frame = NULL;

    for (DWORD i = 0; i < number_of_frames; i++)
    {
        frame = &callstack[i];
        frame->is_valid = FALSE;

        // [1] Calculate ret address for current stack frame.
        success = calculate_return_address(frame);
        if (!success)
            continue;

        // [2] Calculate the total stack size for ret function.
        success = calculate_function_stack_size(frame, i, number_of_frames);
        if (!success)
            continue;

        frame->is_valid = TRUE;
    }
}

// Pushes a value to the stack of a Context structure.
//
VOID push_to_stack(
    PSTACK_INFO stack_info,
    ULONG_PTR value)
{
#ifdef _WIN64
    stack_info->fake_stack_rsp -= 0x8;
    *(PULONG64)(stack_info->fake_stack_rsp) = value;
#else
    stack_info->fake_stack_rsp -= 0x4;
    *(PULONG32)(stack_info->fake_stack_rsp) = value;
#endif
}

#ifdef _WIN64

VOID initialize_fake_thread_state(
    PSTACK_FRAME callstack,
    DWORD number_of_frames,
    PSTACK_INFO stack_info)
{
    ULONG_PTR childSp = 0;
    BOOL bPreviousFrameSetUWOP_SET_FPREG = FALSE;
    PSTACK_FRAME stackFrame = NULL;
    stack_info->fake_stack_rbp = NULL;

    // As an extra sanity check explicitly clear
    // the last RET address to stop any further unwinding.
    push_to_stack(stack_info, 0);

    // [2] Loop through target call stack *backwards*
    // and modify the stack so it resembles the fake
    // call stack e.g. essentially making the top of
    // the fake stack look like the diagram below:
    //      |                |
    //       ----------------
    //      |  RET ADDRESS   |
    //       ----------------
    //      |                |
    //      |     Unwind     |
    //      |     Stack      |
    //      |      Size      |
    //      |                |
    //       ----------------
    //      |  RET ADDRESS   |
    //       ----------------
    //      |                |
    //      |     Unwind     |
    //      |     Stack      |
    //      |      Size      |
    //      |                |
    //       ----------------
    //      |   RET ADDRESS  |
    //       ----------------   <--- RSP when NtOpenProcess is called
    //
    for (DWORD i = 0; i < number_of_frames; i++)
    {
        // loop from the last to the first
        stackFrame = &callstack[number_of_frames - i - 1];

        // if the frame is not valid, simply ignore it
        if (!stackFrame->is_valid)
            continue;

        if (stackFrame->push_frame)
        {
            PVOID prev_ret_addr = *((PVOID*)stack_info->fake_stack_rsp);
            PVOID prev_rsp = RVA(PVOID, stack_info->fake_stack_rsp, 0x8);

            stack_info->fake_stack_rsp -= stackFrame->totalStackSize;

            // push a machine frame: https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170

            ULONG32 base = stackFrame->totalStackSize - 0x8;

            // if there is an excepcion, the error code is pushed last
            if (stackFrame->is_exception)
                base += 0x8;

            // SS
            *(PVOID*)((ULONG_PTR)stack_info->fake_stack_rsp + base + 0x28) = 0x0;
            // Old RSP
            *(PVOID*)((ULONG_PTR)stack_info->fake_stack_rsp + base + 0x20) = from_fake_to_real(stack_info, prev_rsp);
            // EFLAGS
            *(PVOID*)((ULONG_PTR)stack_info->fake_stack_rsp + base + 0x18) = 0x0;
            // CS
            *(PVOID*)((ULONG_PTR)stack_info->fake_stack_rsp + base + 0x10) = 0x0;
            // RIP
            *(PVOID*)((ULONG_PTR)stack_info->fake_stack_rsp + base + 0x08) = prev_ret_addr;
            // Error code
            if (stackFrame->is_exception)
                *(PVOID*)((ULONG_PTR)stack_info->fake_stack_rsp + base + 0x00) = 0x0;

            // write the ret address
            *(PVOID*)((ULONG_PTR)stack_info->fake_stack_rsp) = stackFrame->returnAddress;
            // update RBP
            stack_info->fake_stack_rbp = RVA(PVOID, stack_info->fake_stack_rsp, - 0x8);
        }
        // [2.1] Check if the last frame set UWOP_SET_FPREG.
        // If the previous frame uses the UWOP_SET_FPREG
        // op, it will reset the stack pointer to rbp.
        // Therefore, we need to find the next function in
        // the chain which pushes rbp and make sure it writes
        // the correct value to the stack so it is propagated
        // to the frame after that needs it (otherwise stackwalk
        // will fail). The required value is the childSP
        // of the function that used UWOP_SET_FPREG (i.e. the
        // value of RSP after it is done adjusting the stack and
        // before it pushes its RET address).
        else if (bPreviousFrameSetUWOP_SET_FPREG && stackFrame->pushRbp)
        {
            // [2.2] Check when RBP was pushed to the stack in function
            // prologue. UWOP_PUSH_NONVOls will always be last:
            // "Because of the constraints on epilogs, UWOP_PUSH_NONVOL
            // unwind codes must appear first in the prolog and
            // correspondingly, last in the unwind code array."
            // Hence, subtract the push rbp code index from the
            // total count to work out when it is pushed onto stack.
            // E.g. diff will be 1 below, so rsp -= 0x8 then write childSP:
            // RPCRT4!LrpcIoComplete:
            // 00007ffd`b342b480 4053            push    rbx
            // 00007ffd`b342b482 55              push    rbp
            // 00007ffd`b342b483 56              push    rsi
            // If diff == 0, rbp is pushed first etc.
            DWORD diff = stackFrame->countOfCodes - stackFrame->pushRbpIndex;
            DWORD tmpStackSizeCounter = 0;
            for (ULONG j = 0; j < diff; j++)
            {
                // e.g. push rbx
                push_to_stack(stack_info, 0x0);
                tmpStackSizeCounter += 0x8;
            }
            // push rbp
            push_to_stack(stack_info, (ULONG_PTR)from_fake_to_real(stack_info, (PVOID)childSp));

            // [2.3] Minus off the remaining function stack size
            // and continue unwinding.
            stack_info->fake_stack_rsp -= (stackFrame->totalStackSize - (tmpStackSizeCounter + 0x8));
            *(PVOID*)(stack_info->fake_stack_rsp) = stackFrame->returnAddress;

            // update RBP
            stack_info->fake_stack_rbp = RVA(PVOID, stack_info->fake_stack_rsp, - 0x8);

            // [2.4] From my testing it seems you only need to get rbp
            // right for the next available frame in the chain which pushes it.
            // Hence, there can be a frame in between which does not push rbp.
            // Ergo set this to false once you have resolved rbp for frame
            // which needed it. This is pretty flimsy though so this assumption
            // may break for other more complicated examples.
            bPreviousFrameSetUWOP_SET_FPREG = FALSE;
        }
        else
        {
            // [3] If normal frame, decrement total stack size
            // and write RET address.
            stack_info->fake_stack_rsp -= stackFrame->totalStackSize;
            *(PVOID*)(stack_info->fake_stack_rsp) = stackFrame->returnAddress;

            // update RBP
            stack_info->fake_stack_rbp = RVA(PVOID, stack_info->fake_stack_rsp, - 0x8);
        }

        // [4] Check if the current function sets frame pointer
        // when unwinding e.g. mov rsp,rbp / UWOP_SET_FPREG
        // and record its childSP.
        if (stackFrame->setsFramePointer)
        {
            childSp = (ULONG_PTR)stack_info->fake_stack_rsp;
            childSp += 0x8;
            bPreviousFrameSetUWOP_SET_FPREG = TRUE;
        }
    }
}

#else

VOID initialize_fake_thread_state(
    PSTACK_FRAME callstack,
    DWORD number_of_frames,
    PSTACK_INFO stack_info)
{
    PSTACK_FRAME stackFrame = NULL;
    stack_info->fake_stack_rbp = NULL;

    // As an extra sanity check explicitly clear
    // the last RET address to stop any further unwinding.
    push_to_stack(stack_info, 0);

    for (DWORD i = 0; i < number_of_frames; i++)
    {
        // loop from the last to the first
        stackFrame = &callstack[number_of_frames - i - 1];

        // if the frame is not valid, simply ignore it
        if (!stackFrame->is_valid)
            continue;

        // push the value for EBP
        push_to_stack(stack_info, (ULONG_PTR)from_fake_to_real(stack_info, stack_info->fake_stack_rbp));

        // update RBP
        stack_info->fake_stack_rbp = stack_info->fake_stack_rsp;

        // add the size of the stack frame to the stack
        stack_info->fake_stack_rsp -= stackFrame->totalStackSize - 0x4;

        // write the return address
        *(PVOID*)(stack_info->fake_stack_rsp) = stackFrame->returnAddress;
    }
}

#endif

__declspec(naked) PVOID get_rip(VOID)
{
#if defined(_WIN64)
    asm(
        "mov rax, [rsp] \n"
        "ret \n"
    );
#else
    asm(
        "mov eax, [esp] \n"
        "ret \n"
    );
#endif
}

__declspec(naked) PVOID get_rsp(VOID)
{
#if defined(_WIN64)
    asm(
        "lea rax, [rsp+0x8] \n"
        "ret \n"
    );
#else
    asm(
        "lea eax, [esp+0x4] \n"
        "ret \n"
    );
#endif
}

#ifdef _WIN64

VOID lookup_function_table(
    IN PVOID ControlPc,
    OUT PVOID* pImageBase,
    OUT PRUNTIME_FUNCTION* runtime_function,
    OUT PULONG32 size)
{
    PIMAGE_DOS_HEADER dos = find_dll_by_pointer(ControlPc);
    if (!dos)
        return;

    PIMAGE_NT_HEADERS nt = RVA(PIMAGE_NT_HEADERS, dos, dos->e_lfanew);
    ULONG32 rva = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
    ULONG32 Size = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;
    if (Size)
    {
        *pImageBase = dos;
        *size = Size / sizeof(RUNTIME_FUNCTION);
        *runtime_function = RVA(PRUNTIME_FUNCTION, dos, rva);
    }
    else
    {
        *size = 0;
        *runtime_function = NULL;
        DPRINT_ERR("the module at 0x%p has no exception directory", dos);
    }
}

BOOL lookup_function_entry(
    IN ULONG_PTR ControlPc,
    PRUNTIME_FUNCTION* pFunctionEntry,
    PVOID* pImageBase)
{
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG IndexLo, IndexHi, IndexMid;
    PVOID ImageBase = 0;
    PRUNTIME_FUNCTION FunctionTable = NULL;
    ULONG32 TableLength = 0;

    lookup_function_table(
        (PVOID)ControlPc,
        &ImageBase,
        &FunctionTable,
        &TableLength);
    if (!FunctionTable)
        return FALSE;

    /* Use relative virtual address */
    ControlPc -= (ULONG_PTR)ImageBase;

    /* Do a binary search */
    IndexLo = 0;
    IndexHi = TableLength;
    while (IndexHi > IndexLo)
    {
        IndexMid = (IndexLo + IndexHi) / 2;
        FunctionEntry = &FunctionTable[IndexMid];

        if (ControlPc < FunctionEntry->BeginAddress)
        {
            /* Continue search in lower half */
            IndexHi = IndexMid;
        }
        else if (ControlPc >= FunctionEntry->EndAddress)
        {
            /* Continue search in upper half */
            IndexLo = IndexMid + 1;
        }
        else
        {
            /* ControlPc is within limits, return entry */
            *pFunctionEntry = FunctionEntry;
            *pImageBase = ImageBase;
            return TRUE;
        }
    }

    /* Nothing found, return NULL */
    PRINT_ERR("the function at 0x%p is a leaf function, try another one.", RVA(PVOID, ImageBase, ControlPc));
    return FALSE;
}

#endif

__declspec(naked) PNT_TIB get_tib(VOID)
{
#if defined(_WIN64)
    asm(
        "mov eax, 0x30 \n"
        "mov rax, gs:[rax] \n"
        "ret \n"
    );
#else
    asm(
        "mov eax, 0x18 \n"
        "mov eax, fs:[eax] \n"
        "ret \n"
    );
#endif
}

BOOL create_fake_callstack(
    PSTACK_INFO stack_info,
    ULONG32 function_hash)
{
    BOOL ret_val = FALSE;
    PSTACK_FRAME callstack = NULL;
    DWORD number_of_frames = 0;
    ULONG64 stack_space_needed = 0;
    PVOID real_stack_backup = NULL;
    PVOID fake_stack_heap_addr = NULL;
    PVOID target_stack_top = NULL;
    PVOID target_stack_bottom = NULL;
    PVOID full_stack_base = NULL;
    ULONG64 full_stack_size = 0;
    ULONG32 values_stored_after_canary = 7;
    ULONG32 empty_space = 0;
    PVOID storing_area = NULL;
    PNT_TIB tib = NULL;
#ifdef _WIN64
    ULONG32 ptr_size = 8;
    ULONG_PTR canary_value = 0xDEADBEEFCAFEBABE;
#else
    ULONG32 ptr_size = 4;
    ULONG_PTR canary_value = 0xDEADBEEF;
#endif

    // get the address and size of the stack
    tib = get_tib();
    full_stack_base = tib->StackLimit;
    full_stack_size = (ULONG_PTR)tib->StackBase - (ULONG_PTR)tib->StackLimit;
    DPRINT("obtained the stack ranges: 0x%p - 0x%p", tib->StackLimit, tib->StackBase);

    callstack = intAlloc(sizeof(STACK_FRAME) * MAX_FRAME_NUM);
    if (!callstack)
    {
        malloc_failed();
        goto cleanup;
    }

    // you can have a different stack layout for each syscall
    switch (function_hash)
    {
        case NtOpenProcess_SW3_HASH:
            DPRINT("using the NtOpenProcess call stack");
            set_ntopenprocess_callstack(callstack, &number_of_frames);
            break;
        case LoadLibraryA_SW3_HASH:
            DPRINT("using the LoadLibraryA call stack");
            set_loadlibrarya_callstack(callstack, &number_of_frames);
            break;
        default:
            DPRINT("using the default call stack");
            set_default_callstack(callstack, &number_of_frames);
            break;
    }

    if (number_of_frames > MAX_FRAME_NUM)
    {
        PRINT_ERR("too many frames!");
        goto cleanup;
    }

    /*
     * Initialise our target call stack to spoof. This
     * will load any required dlls, calculate ret addresses,
     * and individual stack sizes needed to mimic the call stack.
     */
    initialize_spoofed_callstack(
        callstack,
        number_of_frames);

    storing_area = intAlloc(ptr_size * values_stored_after_canary);
    DPRINT("storing area is at: 0x%p", storing_area);
    if (!storing_area)
    {
        malloc_failed();
        goto cleanup;
    }

    // calculate how much space do we need to fit the fake stack
    // add space for the first ret addr
    stack_space_needed += ptr_size;
    for (int i = 0; i < number_of_frames; ++i)
    {
        if (callstack[i].is_valid)
            stack_space_needed += callstack[i].totalStackSize;
    }
    // add space for the canary
    stack_space_needed += ptr_size;
    // add space for the address of the storing area
    stack_space_needed += ptr_size;
    // add unsued bytes at the bottom of the fake stack
    // so that when saving RIP we don't write outside the stack's lower bound

    // make sure the stack is kept 16 bytes alligned
    if ((stack_space_needed & ptr_size) == ptr_size)
        empty_space = ptr_size * 2;
    else
        empty_space = ptr_size;
    stack_space_needed += empty_space;

    DPRINT("size of the fake stack: 0x%llx", stack_space_needed);

    // allocate space where the fake stack will be created
    fake_stack_heap_addr = intAlloc(stack_space_needed);
    DPRINT("fake stack on the heap: 0x%p - 0x%p", fake_stack_heap_addr, RVA(PVOID, fake_stack_heap_addr, stack_space_needed));
    if (!fake_stack_heap_addr)
    {
        malloc_failed();
        goto cleanup;
    }

    // allocate space where the real stack will be stored
    real_stack_backup = intAlloc(full_stack_size);
    DPRINT("backup of the stack real stack: 0x%p - 0x%p", real_stack_backup, RVA(PVOID, real_stack_backup, full_stack_size));
    if (!real_stack_backup)
    {
        malloc_failed();
        goto cleanup;
    }

    target_stack_bottom = RVA(PVOID, full_stack_base, full_stack_size);
    target_stack_top = RVA(PVOID, full_stack_base, full_stack_size - stack_space_needed);

    DPRINT("the spoofed call stack will be stored at: 0x%p - 0x%p", target_stack_top, target_stack_bottom);

    // get the address of the first return address
    // this is used for calling APIs with a fake callstack
    for (int i = 0; i < number_of_frames; ++i)
    {
        if (callstack[i].is_valid && callstack[i].returnAddress)
        {
            stack_info->first_ret_addr = callstack[i].returnAddress;
            break;
        }
    }

    // the fake stack will be constructed on the heap
    // then it will be moved to the bottom of the real stack
    stack_info->full_stack_base = full_stack_base;
    stack_info->full_stack_size = full_stack_size;
    stack_info->full_stack_backup_addr = real_stack_backup;
    stack_info->fake_stack_heap_addr = fake_stack_heap_addr;
    stack_info->fake_stack_size = stack_space_needed;
    stack_info->fake_stack_target_addr = target_stack_top;
    stack_info->fake_stack_rsp = RVA(PVOID, stack_info->fake_stack_heap_addr, stack_info->fake_stack_size);
    stack_info->storing_area = storing_area;

    /*
     * layout:
     * 0x0000 top of the stack
     * - <fake call stack>
     * - canary
     * - storing_area
     * - <unused>
     * 0xffff stack bottom
     *
     * storing_area:
     * - full_stack_size
     * - full_stack_backup_addr
     * - full_stack_base
     * - RBX
     * - RBP
     * - RSP
     * - RIP
    */

    // save some bytes that will be left unused
    stack_info->fake_stack_rsp -= empty_space;
    // save space for the address of the storing area
    stack_info->fake_stack_rsp -= ptr_size;
    // write the storing area pointer
    *((PVOID*)stack_info->fake_stack_rsp) = storing_area;
    // save space for the canary
    stack_info->fake_stack_rsp -= ptr_size;
    // write the canary
    *((PVOID*)stack_info->fake_stack_rsp) = (PVOID)canary_value;

    stack_info->canary_addr = stack_info->fake_stack_rsp;

    // Initialise fake thread state.
    initialize_fake_thread_state(
        callstack,
        number_of_frames,
        stack_info);

    // 'translate' the addresses of the RSP, RBP and the canary
    stack_info->fake_stack_rsp = from_fake_to_real(stack_info, stack_info->fake_stack_rsp);
    stack_info->fake_stack_rbp = from_fake_to_real(stack_info, stack_info->fake_stack_rbp);
    stack_info->canary_addr = from_fake_to_real(stack_info, stack_info->canary_addr);

    DPRINT("fake stack layout:")
    DPRINT("    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
    BOOL is_first = TRUE;
    for (int i = 0; i < number_of_frames; ++i)
    {
        if (callstack[i].is_valid)
        {
            if (is_first)
            {
                if (callstack[i].function_name[0])
                {
                    DPRINT("    ret address: %ls!%s+0x%x <-- stack pointer: 0x%p", callstack[i].target_dll_name, callstack[i].function_name, callstack[i].final_offset, stack_info->fake_stack_rsp);
                }
                else
                {
                    DPRINT("    ret address: %ls+0x%x <-- stack pointer: 0x%p", callstack[i].target_dll_name, callstack[i].final_offset, stack_info->fake_stack_rsp);
                }
            }
            else
            {
                if (callstack[i].function_name[0])
                {
                    DPRINT("    ret address: %ls!%s+0x%x", callstack[i].target_dll_name, callstack[i].function_name, callstack[i].final_offset);
                }
                else
                {
                    DPRINT("    ret address: %ls+0x%x", callstack[i].target_dll_name, callstack[i].final_offset);
                }
            }
            DPRINT("    -------------------------------");
            DPRINT("        <0x%lx bytes of space>", callstack[i].totalStackSize - ptr_size);
            is_first = FALSE;
        }
    }
    DPRINT("    ret address: 0x%p", NULL);
    DPRINT("    -------------------------------");
    DPRINT("    canary: 0x%p", (PVOID)canary_value);
    DPRINT("    storing ptr: 0x%p", stack_info->storing_area);
    DPRINT("        <0x%x bytes of space>       <-- stack bottom: 0x%p", empty_space, full_stack_base);
    DPRINT("    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

    ret_val = TRUE;

cleanup:
    if (!ret_val && fake_stack_heap_addr)
        intFree(fake_stack_heap_addr);
    if (!ret_val && real_stack_backup)
        intFree(real_stack_backup);
    if (!ret_val && storing_area)
        intFree(storing_area);
    if (callstack)
        intFree(callstack);

    return ret_val;
}

```

`source/syscalls.c`:

```c
#include "syscalls.h"


SW3_SYSCALL_LIST SW3_SyscallList;

/*
 * If no 'syscall' instruction is found in NTDLL,
 * this function will be called.
 * By default just returns STATUS_NOT_FOUND.
 * The idea is to avoid having a 'syscall' instruction
 * on this program's .text section to evade static analysis
 */

__declspec(naked) void SyscallNotFound(void)
{
    asm(
        "mov eax, 0xC0DEDEAD \n"
        "ret \n"
    );
}

/*
 * the idea here is to find a 'syscall' instruction in 'ntdll.dll'
 * so that we can call it from our code and try to hide the fact
 * that we use direct syscalls
 */
PVOID GetSyscallAddress(
    IN PVOID nt_api_address,
    IN ULONG32 size_of_ntapi)
{
    PVOID syscall_address = NULL;
#ifdef _WIN64
    BYTE syscall_code[] = { 0x0f, 0x05, 0xc3 };
#else
    BYTE syscall_code[] = { 0x0f, 0x34, 0xc3 };
#endif

    // we will loook for a syscall;ret up to the end of the api
    ULONG32 max_look_range = size_of_ntapi - sizeof(syscall_code) + 1;

#ifdef _M_IX86
    if (local_is_wow64())
    {
        // if we are a WoW64 process, jump to WOW32Reserved
        syscall_address = (PVOID)READ_MEMLOC(0xc0);
        return syscall_address;
    }
#endif

    for (ULONG32 offset = 0; offset < max_look_range; offset++)
    {
        // we don't really care if there is a 'jmp' between
        // nt_api_address and the 'syscall; ret' instructions
        syscall_address = SW3_RVA2VA(PVOID, nt_api_address, offset);

        if (!memcmp((PVOID)syscall_code, syscall_address, sizeof(syscall_code)))
        {
            // we can use the original code for this system call :)
            return syscall_address;
        }
    }

    // the 'syscall; ret' intructions have not been found,
    // we will try to use one near it, similarly to HalosGate

    for (ULONG32 num_jumps = 1; num_jumps < SW3_MAX_ENTRIES; num_jumps++)
    {
        // let's try with an Nt* API below our syscall
        for (ULONG32 offset = 0; offset < max_look_range; offset++)
        {
            syscall_address = SW3_RVA2VA(
                PVOID,
                nt_api_address,
                offset + num_jumps * size_of_ntapi);
            if (!memcmp((PVOID)syscall_code, syscall_address, sizeof(syscall_code)))
                return syscall_address;
        }

        // let's try with an Nt* API above our syscall
        for (ULONG32 offset = 0; offset < max_look_range; offset++)
        {
            syscall_address = SW3_RVA2VA(
                PVOID,
                nt_api_address,
                offset - num_jumps * size_of_ntapi);
            if (!memcmp((PVOID)syscall_code, syscall_address, sizeof(syscall_code)))
                return syscall_address;
        }
    }

    return SyscallNotFound;
}

DWORD SW3_HashSyscall(
    IN PCSTR FunctionName)
{
    DWORD i = 0;
    DWORD Hash = SW3_SEED;

    while (FunctionName[i])
    {
        WORD PartialName = *(WORD*)((ULONG_PTR)FunctionName + i++);
        Hash ^= PartialName + SW3_ROX8(Hash);
    }

    return Hash;
}

BOOL SW3_PopulateSyscallList(VOID)
{
    // Return early if the list is already populated.
    if (SW3_SyscallList.Count) return TRUE;

    PSW3_PEB Peb = (PSW3_PEB)READ_MEMLOC(PEB_OFFSET);
    PSW3_PEB_LDR_DATA Ldr = Peb->Ldr;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    PVOID DllBase = NULL;

    // Get the DllBase address of NTDLL.dll. NTDLL is not guaranteed to be the second
    // in the list, so it's safer to loop through the full list and find it.
    PSW3_LDR_DATA_TABLE_ENTRY LdrEntry;
    for (LdrEntry = (PSW3_LDR_DATA_TABLE_ENTRY)Ldr->Reserved2[1]; LdrEntry->DllBase != NULL; LdrEntry = (PSW3_LDR_DATA_TABLE_ENTRY)LdrEntry->Reserved1[0])
    {
        DllBase = LdrEntry->DllBase;
        PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)DllBase;
        PIMAGE_NT_HEADERS NtHeaders = SW3_RVA2VA(PIMAGE_NT_HEADERS, DllBase, DosHeader->e_lfanew);
        PIMAGE_DATA_DIRECTORY DataDirectory = (PIMAGE_DATA_DIRECTORY)NtHeaders->OptionalHeader.DataDirectory;
        DWORD VirtualAddress = DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        if (VirtualAddress == 0) continue;

        ExportDirectory = SW3_RVA2VA(PIMAGE_EXPORT_DIRECTORY, DllBase, VirtualAddress);

        // If this is NTDLL.dll, exit loop.
        PCHAR DllName = SW3_RVA2VA(PCHAR, DllBase, ExportDirectory->Name);
        if ((*(ULONG*)DllName | 0x20202020) != 0x6c64746e) continue;
        if ((*(ULONG*)(DllName + 4) | 0x20202020) == 0x6c642e6c) break;
    }

    if (!ExportDirectory) return FALSE;

    DWORD NumberOfNames = ExportDirectory->NumberOfNames;
    PDWORD Functions = SW3_RVA2VA(PDWORD, DllBase, ExportDirectory->AddressOfFunctions);
    PDWORD Names = SW3_RVA2VA(PDWORD, DllBase, ExportDirectory->AddressOfNames);
    PWORD Ordinals = SW3_RVA2VA(PWORD, DllBase, ExportDirectory->AddressOfNameOrdinals);

    // Populate SW3_SyscallList with unsorted Zw* entries.
    DWORD i = 0;
    PSW3_SYSCALL_ENTRY Entries = SW3_SyscallList.Entries;
    do
    {
        PCHAR FunctionName = SW3_RVA2VA(PCHAR, DllBase, Names[NumberOfNames - 1]);

        // Is this a system call?
        if (*(USHORT*)FunctionName == 0x775a)
        {
            Entries[i].Hash = SW3_HashSyscall(FunctionName);
            Entries[i].Address = Functions[Ordinals[NumberOfNames - 1]];

            i++;
            if (i == SW3_MAX_ENTRIES) break;
        }
    } while (--NumberOfNames);

    // Save total number of system calls found.
    SW3_SyscallList.Count = i;

    // Sort the list by address in ascending order.
    for (i = 0; i < SW3_SyscallList.Count - 1; i++)
    {
        for (DWORD j = 0; j < SW3_SyscallList.Count - i - 1; j++)
        {
            if (Entries[j].Address > Entries[j + 1].Address)
            {
                // Swap entries.
                SW3_SYSCALL_ENTRY TempEntry = { 0 };

                TempEntry.Hash = Entries[j].Hash;
                TempEntry.Address = Entries[j].Address;

                Entries[j].Hash = Entries[j + 1].Hash;
                Entries[j].Address = Entries[j + 1].Address;

                Entries[j + 1].Hash = TempEntry.Hash;
                Entries[j + 1].Address = TempEntry.Address;
            }
        }
    }

    // we need to know this in order to better search for syscall ids
    ULONG size_of_ntapi = Entries[1].Address - Entries[0].Address;

    // finally calculate the address of each syscall
    for (i = 0; i < SW3_SyscallList.Count - 1; i++)
    {
        PVOID nt_api_address = SW3_RVA2VA(PVOID, DllBase, Entries[i].Address);
        Entries[i].SyscallAddress = GetSyscallAddress(nt_api_address, size_of_ntapi);
    }

    return TRUE;
}

EXTERN_C DWORD SW3_GetSyscallNumber(
    IN DWORD FunctionHash)
{
    if (!SW3_PopulateSyscallList())
    {
        DPRINT_ERR("SW3_PopulateSyscallList failed");
        return 0;
    }

    for (DWORD i = 0; i < SW3_SyscallList.Count; i++)
    {
        if (FunctionHash == SW3_SyscallList.Entries[i].Hash)
        {
            return i;
        }
    }
    DPRINT_ERR("syscall with hash 0x%lx not found", FunctionHash);
    return 0;
}

EXTERN_C PVOID SW3_GetSyscallAddress(
    IN DWORD FunctionHash)
{
    if (!SW3_PopulateSyscallList())
    {
        DPRINT_ERR("SW3_PopulateSyscallList failed");
        return NULL;
    }

    for (DWORD i = 0; i < SW3_SyscallList.Count; i++)
    {
        if (FunctionHash == SW3_SyscallList.Entries[i].Hash)
        {
            return SW3_SyscallList.Entries[i].SyscallAddress;
        }
    }
    DPRINT_ERR("syscall with hash 0x%lx not found", FunctionHash);
    return NULL;
}

__declspec(naked) BOOL local_is_wow64(void)
{
#if defined(_WIN64)
    asm(
        "mov rax, 0 \n"
        "ret \n"
    );
#else
    asm(
        "mov eax, fs:[0xc0] \n"
        "test eax, eax \n"
        "jne wow64 \n"
        "mov eax, 0 \n"
        "ret \n"
        "wow64: \n"
        "mov eax, 1 \n"
        "ret \n"
    );
#endif
}

// use indirect syscalls for NtGetContextThread
__declspec(naked) NTSTATUS _NtGetContextThread(
    IN HANDLE ThreadHandle,
    IN OUT PCONTEXT ThreadContext)
{
#if defined(_WIN64)
    asm(
        "mov [rsp +8], rcx \n"
        "mov [rsp+16], rdx \n"
        "mov [rsp+24], r8 \n"
        "mov [rsp+32], r9 \n"
        "mov rcx, 0x74D6BFF9 \n"
        "push rcx \n"
        "sub rsp, 0x28 \n"
        "call SW3_GetSyscallAddress \n"
        "add rsp, 0x28 \n"
        "pop rcx \n"
        "push rax \n"
        "sub rsp, 0x28 \n"
        "call SW3_GetSyscallNumber \n"
        "add rsp, 0x28 \n"
        "pop r11 \n"
        "mov rcx, [rsp+8] \n"
        "mov rdx, [rsp+16] \n"
        "mov r8, [rsp+24] \n"
        "mov r9, [rsp+32] \n"
        "mov r10, rcx \n"
        "jmp r11 \n"
    );
#else
    asm(
        "push 0x74D6BFF9 \n"
        "call SW3_GetSyscallAddress \n"
        "pop ebx \n"
        "push eax \n"
        "push ebx \n"
        "call SW3_GetSyscallNumber \n"
        "add esp, 4 \n"
        "pop ebx \n"
        "mov edx, esp \n"
        "sub edx, 4 \n"
        "call ebx \n"
        "ret \n"
    );
#endif
}

// use indirect syscalls for NtSetContextThread
__declspec(naked) NTSTATUS _NtSetContextThread(
    IN HANDLE ThreadHandle,
    IN PCONTEXT Context)
{
#if defined(_WIN64)
    asm(
        "mov [rsp +8], rcx \n"
        "mov [rsp+16], rdx \n"
        "mov [rsp+24], r8 \n"
        "mov [rsp+32], r9 \n"
        "mov rcx, 0x74DFB87F \n"
        "push rcx \n"
        "sub rsp, 0x28 \n"
        "call SW3_GetSyscallAddress \n"
        "add rsp, 0x28 \n"
        "pop rcx \n"
        "push rax \n"
        "sub rsp, 0x28 \n"
        "call SW3_GetSyscallNumber \n"
        "add rsp, 0x28 \n"
        "pop r11 \n"
        "mov rcx, [rsp+8] \n"
        "mov rdx, [rsp+16] \n"
        "mov r8, [rsp+24] \n"
        "mov r9, [rsp+32] \n"
        "mov r10, rcx \n"
        "jmp r11 \n"
    );
#else
    asm(
        "push 0x74DFB87F \n"
        "call SW3_GetSyscallAddress \n"
        "pop ebx \n"
        "push eax \n"
        "push ebx \n"
        "call SW3_GetSyscallNumber \n"
        "add esp, 4 \n"
        "pop ebx \n"
        "mov edx, esp \n"
        "sub edx, 4 \n"
        "call ebx \n"
        "ret \n"
    );
#endif
}

/*
 * This function is responsible for:
 * 1) create the backup of the stack
 * 2) copy over the fake stack
 * 3) save all the information required by the handler
 * 4) set all the parameters
 * 5) set RSP and RBP to the fake callstack
 * 6) set the syscall number
 * 7) jump to the syscall address
 */
__declspec(naked) ULONG_PTR jumper(
    PVOID syscall_data)
{
#if defined(_WIN64)
    asm(
        // save the return address
        "pop r11 \n"
        // backup the full stack
        "xor rax, rax \n"
        // rdx: full_stack_size
        "mov rdx, [rcx+0x08] \n"
        // r8: full_stack_backup_addr
        "mov r8, [rcx+0x10] \n"
        // r9: full_stack_base
        "mov r9, [rcx] \n"
        "bkp_stack_loop: \n"
        "mov r10b, [r9+rax] \n"
        "mov [r8+rax], r10b \n"
        "inc rax \n"
        "cmp rax, rdx \n"
        "jne bkp_stack_loop \n"
        // copy the fake stack
        "xor rax, rax \n"
        // r8: fake_stack_heap_addr
        "mov r8, [rcx+0x18] \n"
        // r9: fake_stack_target_addr
        "mov r9, [rcx+0x28] \n"
        // rdx: fake_stack_size
        "mov rdx, [rcx+0x20] \n "
        "cpy_fake_stack_loop: \n"
        "mov r10b, [r8+rax] \n"
        "mov [r9+rax], r10b \n"
        "inc rax \n"
        "cmp rax, rdx \n"
        "jne cpy_fake_stack_loop \n"
        // save full_stack_size, full_stack_backup_addr, full_stack_base,
        // RBX, RBP, RSP and RIP after the canary
        // rax: canary_addr
        "mov rax, [rcx+0x40] \n"
        // rax: storing_area
        "mov rax, [rax+0x08] \n"
        // full_stack_size
        "mov rdx, [rcx+0x08] \n"
        "mov [rax+0x00], rdx \n"
        // full_stack_backup_addr
        "mov rdx, [rcx+0x10] \n"
        "mov [rax+0x08], rdx \n"
        // full_stack_base
        "mov rdx, [rcx] \n"
        "mov [rax+0x10], rdx \n"
        // RBX
        "mov [rax+0x18], rbx \n"
        // RBP
        "mov [rax+0x20], rbp \n"
        // RSP
        "mov [rax+0x28], rsp \n"
        // RIP
        "mov [rax+0x30], r11 \n"
        // set the parameters
        // are there more than 0 params?
        "xor rax, rax \n"
        // eax: num_params
        "mov eax, [rcx+0x5c] \n"
        // r10: syscall_data
        "mov r10, rcx \n"
        "cmp eax, 0x1 \n"
        "jl params_ready \n"
        // set parameter 1
        "mov rcx, [r10+0x60] \n"
        // is there more than 1 param?
        "cmp eax, 0x2 \n"
        "jl params_ready \n"
        // set parameter 2
        "mov rdx, [r10+0x68] \n"
        // are there more than 2 params?
        "cmp eax, 0x3 \n"
        "jl params_ready \n"
        // set parameter 3
        "mov r8, [r10+0x70] \n"
        // are there more than 3 params?
        "cmp eax, 0x4 \n"
        "jl params_ready \n"
        // set parameter 4
        "mov r9, [r10+0x78] \n"
        // set the rest of the parameters
        "sub eax, 0x4 \n"
        // rbp: fake_stack_rsp
        "mov rbp, [r10+0x30] \n"
        "stack_params_loop: \n"
        "cmp eax, 0x1 \n"
        "jl params_ready \n"
        "mov rbx, [r10+0x78+rax*0x8] \n"
        "mov [rbp+0x20+rax*0x8], rbx \n"
        "dec rax \n"
        "jmp stack_params_loop \n"
        "params_ready: \n"
        // set the RSP
        "mov rsp, [r10+0x30] \n"
        // set the RBP
        "mov rbp, [r10+0x38] \n"
        // set the syscall number
        "mov eax, [r10+0x50] \n"
        // r11: syscall_addr
        "mov r11, [r10+0x48] \n"
        // r10 must be equal to rcx for some reason
        "mov r10, rcx \n"
        // jump to the syscall address :^)
        "jmp r11 \n"
    );
#else
    asm(
        // ecx: syscall_data
        "mov ecx, [esp+0x04] \n"
        // backup the full stack
        "xor eax, eax \n"
        // edx: full_stack_size
        "mov edx, [ecx+0x04] \n"
        // edi: full_stack_backup_addr
        "mov edi, [ecx+0x08] \n"
        // esi: full_stack_base
        "mov esi, [ecx] \n"
        "bkp_stack_loop: \n"
        "mov bl, [esi+eax] \n"
        "mov [edi+eax], bl \n"
        "inc eax \n"
        "cmp eax, edx \n"
        "jne bkp_stack_loop \n"
        // copy the fake stack
        "xor eax, eax \n"
        // esi: fake_stack_heap_addr
        "mov esi, [ecx+0x0c] \n"
        // edi: fake_stack_target_addr
        "mov edi, [ecx+0x14] \n"
        // edx: fake_stack_size
        "mov edx, [ecx+0x10] \n "
        "cpy_fake_stack_loop: \n"
        "mov bl, [esi+eax] \n"
        "mov [edi+eax], bl \n"
        "inc eax \n"
        "cmp eax, edx \n"
        "jne cpy_fake_stack_loop \n"
        // save full_stack_size, full_stack_backup_addr, full_stack_base,
        // EBX, EBP, ESP and EIP in the storing_area
        // eax: canary_addr
        "mov eax, [ecx+0x20] \n"
        // eax: storing_area
        "mov eax, [eax+0x04] \n"
        // full_stack_size
        "mov edx, [ecx+0x04] \n"
        "mov [eax+0x00], edx \n"
        // full_stack_backup_addr
        "mov edx, [ecx+0x08] \n"
        "mov [eax+0x04], edx \n"
        // full_stack_base
        "mov edx, [ecx] \n"
        "mov [eax+0x08], edx \n"
        // RBX
        "mov [eax+0x0c], ebx \n"
        // RBP
        "mov [eax+0x10], ebp \n"
        // RSP
        "pop edx \n"
        "mov [eax+0x14], esp \n"
        // RIP
        "mov [eax+0x18], edx \n"
        // set the parameters
        // eax: num_params
        "mov eax, [ecx+0x34] \n"
        // ebp: fake_stack_rsp
        "mov ebp, [ecx+0x18] \n"
        // edx: is_api_call
        "mov edx, [ecx+0x2c] \n"
        "cmp edx, 0x0 \n"
        "jne stack_params_loop \n"
        // syscalls in x86 have a different stack layout
        // 1) address of the 'ret' instruction next to the sysenter
        // 2) the actual return address
        // 3) parameters
        // save the real return address in the second position
        // edx: ret addr
        "mov edx, [ebp] \n"
        "mov [ebp+0x4], edx \n"
        // save the address of the 'ret' instruction in the first position
        // edx: syscall address
        "mov edx, [ecx+0x24] \n"
        // edx: address of the 'ret' instruction
        "add edx, 0x2 \n"
        "mov [ebp], edx \n"
        // save the parameters on the third and not second position
        "add ebp, 0x4 \n"
        // edx: is_wow64
        "mov edx, [ecx+0x30] \n"
        "cmp edx, 0x0 \n"
        "je stack_params_loop \n"
        // syscalls in WoW64 have a different stack layout
        // 1) the actual return address
        // 2) 0x4 bytes of space
        // 3) parameters
        "mov edx, [ebp] \n"
        "mov [ebp-0x4], edx \n"
        "stack_params_loop: \n"
        "cmp eax, 0x1 \n"
        "jl params_ready \n"
        "mov ebx, [ecx+0x34+eax*0x4] \n"
        "mov [ebp+eax*0x4], ebx \n"
        "dec eax \n"
        "jmp stack_params_loop \n"
        "params_ready: \n"
        // set the RSP
        "mov esp, [ecx+0x18] \n"
        // set the RBP
        "mov ebp, [ecx+0x1c] \n"
        // set the syscall number
        "mov eax, [ecx+0x28] \n"
        // ebx: syscall_addr
        "mov ebx, [ecx+0x24] \n"
        // edx must to be equal to esp for some reason
        "mov edx, esp \n"
        // jump to the syscall address :^)
        "jmp ebx \n"
    );
#endif
}

/*
 * This function is responsible for:
 * 1) get the address and number of the syscall
 * 2) create fake call stack
 * 3) set the hardware breakpoint
 * 4) call the jumper
 * 5) unset the hardware breakpoint
 */
NTSTATUS trigger_syscall(
    IN ULONG32 syscall_hash,
    IN ULONG32 num_params,
    ...)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    STACK_INFO stack_info = { 0 };
    PVOID syscall_addr = NULL;
    PVOID ret_addr = NULL;
    ULONG32 syscall_number = 0;
    HANDLE hHwBpHandler = NULL;
    BOOL success = FALSE;
    PSYSCALL_DATA syscall_data = NULL;
    va_list valist;

    va_start(valist, num_params);

    // get the syscall address
    syscall_addr = SW3_GetSyscallAddress(syscall_hash);
    if (!syscall_addr)
        goto cleanup;

    // get the syscall number
    syscall_number = SW3_GetSyscallNumber(syscall_hash);
    if (!syscall_number)
        goto cleanup;

    // create the fake callstack
    success = create_fake_callstack(&stack_info, syscall_hash);
    if (!success)
        goto cleanup;
    DPRINT("created the fake callstack");

    // get the first ret address in the fake callstack
    ret_addr = stack_info.first_ret_addr;
    if (!ret_addr)
    {
        // if there is none, use the 'ret' instruction after the syscall
        ret_addr = SW3_RVA2VA(PVOID, syscall_addr, 2);
    }

    // set the hardware breakpoint at the ret addr
    success = set_hwbp(ret_addr, &hHwBpHandler);
    if (!success)
        goto cleanup;
    DPRINT("hardware breakpoint set at 0x%p", ret_addr);

    // because the syscall data is on the heap,
    // overwriting the stack won't affect it
    syscall_data = intAlloc(sizeof(SYSCALL_DATA));
    if (!syscall_data)
    {
        malloc_failed();
        goto cleanup;
    }

    syscall_data->full_stack_base = stack_info.full_stack_base;
    syscall_data->full_stack_size = stack_info.full_stack_size;
    syscall_data->full_stack_backup_addr = stack_info.full_stack_backup_addr;
    syscall_data->fake_stack_heap_addr = stack_info.fake_stack_heap_addr;
    syscall_data->fake_stack_size = stack_info.fake_stack_size;
    syscall_data->fake_stack_target_addr = stack_info.fake_stack_target_addr;
    syscall_data->fake_stack_rsp = stack_info.fake_stack_rsp;
    syscall_data->fake_stack_rbp = stack_info.fake_stack_rbp;
    syscall_data->canary_addr = stack_info.canary_addr;
    syscall_data->is_api_call = FALSE;
    syscall_data->is_wow64 = local_is_wow64();
    syscall_data->syscall_addr = syscall_addr;
    syscall_data->syscall_number = syscall_number;
    syscall_data->num_params = num_params;
    for (int i = 0; i < num_params; ++i)
    {
        syscall_data->params[i] = va_arg(valist, ULONG_PTR);
    }

    DPRINT("triggering the syscall...");
    status = (NTSTATUS)jumper(syscall_data);
    DPRINT("done.");

cleanup:
    if (syscall_data)
        intFree(syscall_data);
    if (stack_info.full_stack_backup_addr)
        intFree(stack_info.full_stack_backup_addr);
    if (stack_info.fake_stack_heap_addr)
        intFree(stack_info.fake_stack_heap_addr);
    if (stack_info.storing_area)
        intFree(stack_info.storing_area);
    if (hHwBpHandler)
        unset_hwbp(hHwBpHandler);
    va_end(valist);

    return status;
}

/*
 * This function is responsible for:
 * 1) get the address of the API
 * 2) create fake call stack
 * 3) set the hardware breakpoint
 * 4) call the jumper
 * 5) unset the hardware breakpoint
 */
PVOID trigger_api(
    IN ULONG32 api_hash,
    IN LPWSTR dll_path,
    IN ULONG32 num_params,
    ...)
{
    PVOID ret_val = NULL;
    STACK_INFO stack_info = { 0 };
    PVOID ret_addr = NULL;
    PVOID api_addr = NULL;
    HANDLE hHwBpHandler = NULL;
    BOOL success = FALSE;
    PSYSCALL_DATA api_data = NULL;
    va_list valist;

    va_start(valist, num_params);

    api_addr = get_function_address(
        get_library_address(dll_path, TRUE),
        api_hash,
        0);
    if (!api_addr)
    {
        DPRINT_ERR("could not find export with hash 0x%x on %ls", api_hash, dll_path);
        goto cleanup;
    }

    // create the fake callstack
    success = create_fake_callstack(&stack_info, api_hash);
    if (!success)
        goto cleanup;
    DPRINT("created the fake callstack");

    // get the first ret address in the fake callstack
    ret_addr = stack_info.first_ret_addr;
    if (!ret_addr)
    {
        PRINT_ERR("the return address for an API can't be NULL");
        goto cleanup;
    }

    // set the hardware breakpoint at the ret addr
    success = set_hwbp(ret_addr, &hHwBpHandler);
    if (!success)
        goto cleanup;
    DPRINT("hardware breakpoint set at 0x%p", ret_addr);

    // because the api data is on the heap,
    // overwriting the stack won't affect it
    api_data = intAlloc(sizeof(SYSCALL_DATA));
    if (!api_data)
    {
        malloc_failed();
        goto cleanup;
    }

    api_data->full_stack_base = stack_info.full_stack_base;
    api_data->full_stack_size = stack_info.full_stack_size;
    api_data->full_stack_backup_addr = stack_info.full_stack_backup_addr;
    api_data->fake_stack_heap_addr = stack_info.fake_stack_heap_addr;
    api_data->fake_stack_size = stack_info.fake_stack_size;
    api_data->fake_stack_target_addr = stack_info.fake_stack_target_addr;
    api_data->fake_stack_rsp = stack_info.fake_stack_rsp;
    api_data->fake_stack_rbp = stack_info.fake_stack_rbp;
    api_data->canary_addr = stack_info.canary_addr;
    api_data->is_api_call = TRUE;
    api_data->api_addr = api_addr;
    api_data->num_params = num_params;
    for (int i = 0; i < num_params; ++i)
    {
        api_data->params[i] = va_arg(valist, ULONG_PTR);
    }

    DPRINT("triggering the API...");
    ret_val = (PVOID)jumper(api_data);
    DPRINT("done.");

cleanup:
    if (api_data)
        intFree(api_data);
    if (stack_info.full_stack_backup_addr)
        intFree(stack_info.full_stack_backup_addr);
    if (stack_info.fake_stack_heap_addr)
        intFree(stack_info.fake_stack_heap_addr);
    if (stack_info.storing_area)
        intFree(stack_info.storing_area);
    if (hHwBpHandler)
        unset_hwbp(hHwBpHandler);
    va_end(valist);

    return ret_val;
}

NTSTATUS _NtOpenProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PVOID ClientId OPTIONAL)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    status = trigger_syscall(
        NtOpenProcess_SW3_HASH,
        4,
        ProcessHandle,
        DesiredAccess,
        ObjectAttributes,
        ClientId);

    return status;
}

HMODULE _LoadLibraryA(
  IN LPCSTR lpLibFileName)
{
    HMODULE ret_val = NULL;

    ret_val = (HMODULE)trigger_api(
        LoadLibraryA_SW3_HASH,
        KERNELBASE_DLL,
        1,
        lpLibFileName);

    return ret_val;
}

```