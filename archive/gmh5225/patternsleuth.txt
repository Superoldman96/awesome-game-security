Project Path: arc_gmh5225_patternsleuth_qv6mb2oy

Source Tree:

```txt
arc_gmh5225_patternsleuth_qv6mb2oy
├── Cargo.lock
├── Cargo.toml
├── README.md
├── examples
│   └── dll_hook
│       ├── Cargo.toml
│       └── src
│           ├── app.rs
│           ├── gui.rs
│           ├── hooks.rs
│           ├── lib.rs
│           ├── object_cache.rs
│           └── ue.rs
├── patternsleuth
│   ├── Cargo.toml
│   └── src
│       ├── image
│       │   ├── elf.rs
│       │   ├── macros.rs
│       │   ├── mod.rs
│       │   └── pe.rs
│       ├── lib.rs
│       ├── process
│       │   ├── external.rs
│       │   ├── internal.rs
│       │   └── mod.rs
│       ├── resolvers
│       │   ├── mod.rs
│       │   └── unreal
│       │       ├── aes.rs
│       │       ├── blueprint_library.rs
│       │       ├── engine_version.rs
│       │       ├── fname.rs
│       │       ├── ftext.rs
│       │       ├── fuobject_hash_tables.rs
│       │       ├── game_loop.rs
│       │       ├── gmalloc.rs
│       │       ├── guobject_array.rs
│       │       ├── kismet.rs
│       │       ├── mod.rs
│       │       ├── pak.rs
│       │       ├── save_game.rs
│       │       ├── static_construct_object.rs
│       │       └── static_find_object.rs
│       ├── symbols.rs
│       └── uesym.rs
├── patternsleuth_cli
│   ├── Cargo.toml
│   ├── build.rs
│   └── src
│       ├── db.rs
│       ├── disassemble.rs
│       └── main.rs
├── patternsleuth_scanner
│   ├── Cargo.toml
│   ├── benches
│   │   └── scan.rs
│   └── src
│       └── lib.rs
└── rust-toolchain.toml

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "ab_glyph"
version = "0.2.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80179d7dd5d7e8c285d67c4a1e652972a92de7475beddfb92028c76463b13225"
dependencies = [
 "ab_glyph_rasterizer",
 "owned_ttf_parser",
]

[[package]]
name = "ab_glyph_rasterizer"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c71b1793ee61086797f5c80b6efa2b8ffa6d5dd703f118545808a7f2e27f7046"

[[package]]
name = "accesskit"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca8410747ed85a17c4a1e9ed3f5a74d3e7bdcc876cf9a18ff40ae21d645997b2"

[[package]]
name = "accesskit_consumer"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c17cca53c09fbd7288667b22a201274b9becaa27f0b91bf52a526db95de45e6"
dependencies = [
 "accesskit",
]

[[package]]
name = "accesskit_macos"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd3b6ae1eabbfbced10e840fd3fce8a93ae84f174b3e4ba892ab7bcb42e477a7"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "objc2",
 "once_cell",
]

[[package]]
name = "accesskit_unix"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09f46c18d99ba61ad7123dd13eeb0c104436ab6af1df6a1cd8c11054ed394a08"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "async-channel",
 "async-once-cell",
 "atspi",
 "futures-lite 1.13.0",
 "once_cell",
 "serde",
 "zbus",
]

[[package]]
name = "accesskit_windows"
version = "0.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "afcae27ec0974fc7c3b0b318783be89fd1b2e66dd702179fe600166a38ff4a0b"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "once_cell",
 "paste",
 "static_assertions",
 "windows 0.48.0",
]

[[package]]
name = "accesskit_winit"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88e39fcec2e10971e188730b7a76bab60647dacc973d4591855ebebcadfaa738"
dependencies = [
 "accesskit",
 "accesskit_macos",
 "accesskit_unix",
 "accesskit_windows",
 "winit",
]

[[package]]
name = "addr2line"
version = "0.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a30b2e23b9e17a9f90641c7ab1549cd9b44f296d3ccbf309d2863cfe398a0cb"
dependencies = [
 "gimli",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "ahash"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77c3a9648d43b9cd48db467b3f87fdd6e146bcc88ab0180006cef2179fe11d01"
dependencies = [
 "cfg-if",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2969dcb958b36655471fc61f7e416fa76033bdd4bfed0678d8fee1e2d07a1f0"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0942ffc6dcaadf03badf6e6a2d0228460359d5e34b57ccdc720b7382dfbd5ec5"

[[package]]
name = "android-activity"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64529721f27c2314ced0890ce45e469574a73e5e6fdd6e9da1860eb29285f5e0"
dependencies = [
 "android-properties",
 "bitflags 1.3.2",
 "cc",
 "jni-sys",
 "libc",
 "log",
 "ndk",
 "ndk-context",
 "ndk-sys",
 "num_enum 0.6.1",
]

[[package]]
name = "android-properties"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc7eb209b1518d6bb87b283c20095f5228ecda460da70b44f0802523dea6da04"

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anes"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b46cbb362ab8752921c97e041f5e366ee6297bd428a31275b9fcf1e380f7299"

[[package]]
name = "anstream"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d664a92ecae85fd0a7392615844904654d1d5f5514837f471ddef4a057aba1b6"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7079075b41f533b8c61d2a4d073c4676e1f8b249ff94a393b0595db304e0dd87"

[[package]]
name = "anstyle-parse"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c75ac65da39e5fe5ab759307499ddad880d724eed2f6ce5b5e8a26f4f387928c"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e28923312444cdd728e4738b3f9c9cac739500909bb3d3c94b43551b16517648"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0699d10d2f4d628a98ee7b57b289abbc98ff3bad977cb3152709d4bf2330628"
dependencies = [
 "anstyle",
 "windows-sys 0.48.0",
]

[[package]]
name = "anyhow"
version = "1.0.79"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "080e9890a082662b09c1ad45f567faeeb47f22b5fb23895fbe1e651e718e25ca"

[[package]]
name = "arboard"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aafb29b107435aa276664c1db8954ac27a6e105cdad3c88287a199eb0e313c08"
dependencies = [
 "clipboard-win",
 "log",
 "objc",
 "objc-foundation",
 "objc_id",
 "parking_lot 0.12.1",
 "thiserror",
 "winapi",
 "x11rb",
]

[[package]]
name = "arc-swap"
version = "0.4.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dabe5a181f83789739c194cbe5a897dde195078fac08568d09221fd6137a7ba8"

[[package]]
name = "arrayref"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b4930d2cb77ce62f89ee5d5289b4ac049559b1c45539271f5ed4fdc7db34545"

[[package]]
name = "arrayvec"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96d30a06541fbafbc7f82ed10c06164cfbd2c401138f6addd8404629c4b16711"

[[package]]
name = "async-broadcast"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c48ccdbf6ca6b121e0f586cbc0e73ae440e56c67c30fa0873b4e110d9c26d2b"
dependencies = [
 "event-listener 2.5.3",
 "futures-core",
]

[[package]]
name = "async-channel"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1ca33f4bc4ed1babef42cad36cc1f51fa88be00420404e5b1e80ab1b18f7678c"
dependencies = [
 "concurrent-queue",
 "event-listener 4.0.0",
 "event-listener-strategy",
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "async-executor"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17ae5ebefcc48e7452b4987947920dac9450be1110cadf34d1b8c116bdbaf97c"
dependencies = [
 "async-lock 3.2.0",
 "async-task",
 "concurrent-queue",
 "fastrand 2.0.1",
 "futures-lite 2.1.0",
 "slab",
]

[[package]]
name = "async-fs"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "279cf904654eeebfa37ac9bb1598880884924aab82e290aa65c9e77a0e142e06"
dependencies = [
 "async-lock 2.8.0",
 "autocfg",
 "blocking",
 "futures-lite 1.13.0",
]

[[package]]
name = "async-io"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fc5b45d93ef0529756f812ca52e44c221b35341892d3dcc34132ac02f3dd2af"
dependencies = [
 "async-lock 2.8.0",
 "autocfg",
 "cfg-if",
 "concurrent-queue",
 "futures-lite 1.13.0",
 "log",
 "parking",
 "polling 2.8.0",
 "rustix 0.37.27",
 "slab",
 "socket2",
 "waker-fn",
]

[[package]]
name = "async-io"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6d3b15875ba253d1110c740755e246537483f152fa334f91abd7fe84c88b3ff"
dependencies = [
 "async-lock 3.2.0",
 "cfg-if",
 "concurrent-queue",
 "futures-io",
 "futures-lite 2.1.0",
 "parking",
 "polling 3.3.1",
 "rustix 0.38.28",
 "slab",
 "tracing",
 "windows-sys 0.52.0",
]

[[package]]
name = "async-lock"
version = "2.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "287272293e9d8c41773cec55e365490fe034813a2f172f502d6ddcf75b2f582b"
dependencies = [
 "event-listener 2.5.3",
]

[[package]]
name = "async-lock"
version = "3.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7125e42787d53db9dd54261812ef17e937c95a51e4d291373b670342fa44310c"
dependencies = [
 "event-listener 4.0.0",
 "event-listener-strategy",
 "pin-project-lite",
]

[[package]]
name = "async-once-cell"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9338790e78aa95a416786ec8389546c4b6a1dfc3dc36071ed9518a9413a542eb"

[[package]]
name = "async-process"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea6438ba0a08d81529c69b36700fa2f95837bfe3e776ab39cde9c14d9149da88"
dependencies = [
 "async-io 1.13.0",
 "async-lock 2.8.0",
 "async-signal",
 "blocking",
 "cfg-if",
 "event-listener 3.1.0",
 "futures-lite 1.13.0",
 "rustix 0.38.28",
 "windows-sys 0.48.0",
]

[[package]]
name = "async-recursion"
version = "1.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5fd55a5ba1179988837d24ab4c7cc8ed6efdeff578ede0416b4225a5fca35bd0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "async-signal"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e47d90f65a225c4527103a8d747001fc56e375203592b25ad103e1ca13124c5"
dependencies = [
 "async-io 2.2.1",
 "async-lock 2.8.0",
 "atomic-waker",
 "cfg-if",
 "futures-core",
 "futures-io",
 "rustix 0.38.28",
 "signal-hook-registry",
 "slab",
 "windows-sys 0.48.0",
]

[[package]]
name = "async-task"
version = "4.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1d90cd0b264dfdd8eb5bad0a2c217c1f88fa96a8573f40e7b12de23fb468f46"

[[package]]
name = "async-trait"
version = "0.1.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c980ee35e870bd1a4d2c8294d4c04d0499e67bca1e4b5cefcc693c2fa00caea9"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "atspi"
version = "0.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6059f350ab6f593ea00727b334265c4dfc7fd442ee32d264794bd9bdc68e87ca"
dependencies = [
 "atspi-common",
 "atspi-connection",
 "atspi-proxies",
]

[[package]]
name = "atspi-common"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92af95f966d2431f962bc632c2e68eda7777330158bf640c4af4249349b2cdf5"
dependencies = [
 "enumflags2",
 "serde",
 "static_assertions",
 "zbus",
 "zbus_names",
 "zvariant",
]

[[package]]
name = "atspi-connection"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a0c65e7d70f86d4c0e3b2d585d9bf3f979f0b19d635a336725a88d279f76b939"
dependencies = [
 "atspi-common",
 "atspi-proxies",
 "futures-lite 1.13.0",
 "zbus",
]

[[package]]
name = "atspi-proxies"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6495661273703e7a229356dcbe8c8f38223d697aacfaf0e13590a9ac9977bb52"
dependencies = [
 "atspi-common",
 "serde",
 "zbus",
]

[[package]]
name = "autocfg"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"

[[package]]
name = "backtrace"
version = "0.3.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2089b7e3f35b9dd2d0ed921ead4f6d318c27680d4a5bd167b3ee120edb105837"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
]

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "327762f6e5a765692301e5bb513e0d9fef63be86bbc14528052b1cd3e6f03e07"

[[package]]
name = "block"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d8c1fef690941d3e7788d328517591fecc684c084084702d6ff1641e993699a"

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "block-sys"
version = "0.1.0-beta.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fa55741ee90902547802152aaf3f8e5248aab7e21468089560d4c8840561146"
dependencies = [
 "objc-sys",
]

[[package]]
name = "block2"
version = "0.2.0-alpha.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8dd9e63c1744f755c2f60332b88de39d341e5e86239014ad839bd71c106dec42"
dependencies = [
 "block-sys",
 "objc2-encode",
]

[[package]]
name = "blocking"
version = "1.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a37913e8dc4ddcc604f0c6d3bf2887c995153af3611de9e23c352b44c1b9118"
dependencies = [
 "async-channel",
 "async-lock 3.2.0",
 "async-task",
 "fastrand 2.0.1",
 "futures-io",
 "futures-lite 2.1.0",
 "piper",
 "tracing",
]

[[package]]
name = "bstr"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c48f0051a4b4c5e0b6d365cd04af53aeaa209e3cc15ec2cdb69e73cc87fbd0dc"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "bumpalo"
version = "3.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f30e7476521f6f8af1a1c4c0b8cc94f0bee37d91763d0ca2665f299b6cd8aec"

[[package]]
name = "bytemuck"
version = "1.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "374d28ec25809ee0e23827c2ab573d729e293f281dfe393500e7ad618baa61c6"
dependencies = [
 "bytemuck_derive",
]

[[package]]
name = "bytemuck_derive"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "965ab7eb5f8f97d2a083c799f3a1b994fc397b2fe2da5d1da1626ce15a39f2b1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2bd12c1caf447e69cd4528f47f94d203fd2582878ecb9e9465484c4148a8223"

[[package]]
name = "calloop"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52e0d00eb1ea24371a97d2da6201c6747a633dc6dc1988ef503403b4c59504a8"
dependencies = [
 "bitflags 1.3.2",
 "log",
 "nix 0.25.1",
 "slotmap",
 "thiserror",
 "vec_map",
]

[[package]]
name = "cast"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37b2a672a2cb129a2e41c10b1224bb368f9f37a2b16b612598138befd7b37eb5"

[[package]]
name = "cc"
version = "1.0.83"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1174fb0b6ec23863f8b971027804a42614e347eafb0a95bf0b12cdae21fc4d0"
dependencies = [
 "jobserver",
 "libc",
]

[[package]]
name = "cesu8"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cfg_aliases"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd16c4719339c4530435d38e511904438d07cce7950afa3718a84ac36c10e89e"

[[package]]
name = "cgl"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ced0551234e87afee12411d535648dd89d2e7f34c78b753395567aff3d447ff"
dependencies = [
 "libc",
]

[[package]]
name = "chrono"
version = "0.4.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f2c685bad3eb3d45a01354cedb7d5faa66194d1d58ba6e267a8de788f79db38"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-targets 0.48.5",
]

[[package]]
name = "ciborium"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "effd91f6c78e5a4ace8a5d3c0b6bfaec9e2baaef55f3efc00e45fb2e477ee926"
dependencies = [
 "ciborium-io",
 "ciborium-ll",
 "serde",
]

[[package]]
name = "ciborium-io"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdf919175532b369853f5d5e20b26b43112613fd6fe7aee757e35f7a44642656"

[[package]]
name = "ciborium-ll"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "defaa24ecc093c77630e6c15e17c51f5e187bf35ee514f4e2d67baaa96dae22b"
dependencies = [
 "ciborium-io",
 "half",
]

[[package]]
name = "clap"
version = "4.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33e92c5c1a78c62968ec57dbc2440366a2d6e5a23faf829970ff1585dc6b18e2"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4323769dc8a61e2c39ad7dc26f6f2800524691a44d74fe3d1071a5c24db6370"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf9804afaaf59a91e75b022a30fb7229a7901f60c755489cc61c9b423b836442"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "clap_lex"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "702fc72eb24e5a1e48ce58027a675bc24edd52096d5397d4aea7c6dd9eca0bd1"

[[package]]
name = "clipboard-win"
version = "4.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7191c27c2357d9b7ef96baac1773290d4ca63b24205b82a3fd8a0637afcf0362"
dependencies = [
 "error-code",
 "str-buf",
 "winapi",
]

[[package]]
name = "cocoa"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f425db7937052c684daec3bd6375c8abe2d146dca4b8b143d6db777c39138f3a"
dependencies = [
 "bitflags 1.3.2",
 "block",
 "cocoa-foundation",
 "core-foundation",
 "core-graphics",
 "foreign-types",
 "libc",
 "objc",
]

[[package]]
name = "cocoa-foundation"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c6234cbb2e4c785b456c0644748b1ac416dd045799740356f8363dfe00c93f7"
dependencies = [
 "bitflags 1.3.2",
 "block",
 "core-foundation",
 "core-graphics-types",
 "libc",
 "objc",
]

[[package]]
name = "color_quant"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d7b894f5411737b7867f4827955924d7c254fc9f4d91a6aad6b097804b1018b"

[[package]]
name = "colorchoice"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "acbf1af155f9b9ef647e42cdc158db4b64a1b61f743629225fde6f3e0be2a7c7"

[[package]]
name = "colored"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbf2150cce219b664a8a70df7a1f933836724b503f8a413af9365b4dcc4d90b8"
dependencies = [
 "lazy_static",
 "windows-sys 0.48.0",
]

[[package]]
name = "combine"
version = "4.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "35ed6e9d84f0b51a7f52daf1c7d71dd136fd7a3f41a8462b8cdb8c78d920fad4"
dependencies = [
 "bytes",
 "memchr",
]

[[package]]
name = "concurrent-queue"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d16048cd947b08fa32c24458a22f5dc5e835264f689f4f5653210c69fd107363"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "console"
version = "0.15.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c926e00cc70edefdc64d3a5ff31cc65bb97a3460097762bd23afb4d8145fccf8"
dependencies = [
 "encode_unicode 0.3.6",
 "lazy_static",
 "libc",
 "unicode-width",
 "windows-sys 0.45.0",
]

[[package]]
name = "convert_case"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb4a24b1aaf0fd0ce8b45161144d6f42cd91677fd5940fd431183eb023b3a2b8"

[[package]]
name = "core-foundation"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "194a7a9e6de53fa55116934067c844d9d749312f75c6f6d0980e8c252f8c2146"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e496a50fda8aacccc86d7529e2c1e0892dbd0f898a6b5645b5561b89c3210efa"

[[package]]
name = "core-graphics"
version = "0.22.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2581bbab3b8ffc6fcbd550bf46c355135d16e9ff2a6ea032ad6b9bf1d7efe4fb"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation",
 "core-graphics-types",
 "foreign-types",
 "libc",
]

[[package]]
name = "core-graphics-types"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bb142d41022986c1d8ff29103a1411c8a3dfad3552f87a4f8dc50d61d4f4e33"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation",
 "libc",
]

[[package]]
name = "cpufeatures"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce420fe07aecd3e67c5f910618fe65e94158f6dcc0adf44e00d69ce2bdfe0fd0"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b540bd8bc810d3885c6ea91e2018302f68baba2129ab3e88f32389ee9370880d"
dependencies = [
 "cfg-if",
]

[[package]]
name = "criterion"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2b12d017a929603d80db1831cd3a24082f8137ce19c69e6447f54f5fc8d692f"
dependencies = [
 "anes",
 "cast",
 "ciborium",
 "clap",
 "criterion-plot",
 "is-terminal",
 "itertools 0.10.5",
 "num-traits",
 "once_cell",
 "oorandom",
 "plotters",
 "rayon",
 "regex",
 "serde",
 "serde_derive",
 "serde_json",
 "tinytemplate",
 "walkdir",
]

[[package]]
name = "criterion-plot"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b50826342786a51a89e2da3a28f1c32b06e387201bc2d19791f622c673706b1"
dependencies = [
 "cast",
 "itertools 0.10.5",
]

[[package]]
name = "crossbeam"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1137cd7e7fc0fb5d3c5a8678be38ec56e819125d8d7907411fe24ccb943faca8"
dependencies = [
 "crossbeam-channel",
 "crossbeam-deque",
 "crossbeam-epoch",
 "crossbeam-queue",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "176dc175b78f56c0f321911d9c8eb2b77a78a4860b9c19db83835fea1a46649b"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613f8cc01fe9cf1a3eb3d7f488fd2fa8388403e97039e2f73692932e291a770d"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-queue"
version = "0.3.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df0346b5d5e76ac2fe4e327c5fd1118d6be7c51dfb18f9b7922923f287471e35"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "248e3bacc7dc6baa3b21e405ee045c3047101a49145e7e9eca583ab4c2ca5345"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "csv"
version = "1.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "626ae34994d3d8d668f4269922248239db4ae42d538b14c398b74a52208e8086"
dependencies = [
 "csv-core",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "csv-core"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b2466559f260f48ad25fe6317b3c8dac77b5bdb5763ac7d9d6103530663bc90"
dependencies = [
 "memchr",
]

[[package]]
name = "dashmap"
version = "5.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "978747c1d849a7d2ee5e8adc0159961c48fb7e5db2f06af6723b80123bb53856"
dependencies = [
 "cfg-if",
 "hashbrown 0.14.3",
 "lock_api",
 "once_cell",
 "parking_lot_core 0.9.9",
]

[[package]]
name = "deranged"
version = "0.3.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8eb30d70a07a3b04884d2677f06bec33509dc67ca60d92949e5535352d3191dc"
dependencies = [
 "powerfmt",
]

[[package]]
name = "derivative"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "derive_more"
version = "0.99.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fb810d30a7c1953f91334de7244731fc3f3c10d7fe163338a35b9f640960321"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "dirs-next"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b98cf8ebf19c3d1b223e151f99a4f9f0690dca41414773390fc824184ac833e1"
dependencies = [
 "cfg-if",
 "dirs-sys-next",
]

[[package]]
name = "dirs-sys-next"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ebda144c4fe02d1f7ea1a7d9641b6fc6b580adcfa024ae48797ecdeb6825b4d"
dependencies = [
 "libc",
 "redox_users",
 "winapi",
]

[[package]]
name = "dispatch"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd0c93bb4b0c6d9b77f4435b0ae98c24d17f1c45b2ff844c6151a07256ca923b"

[[package]]
name = "dlib"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "330c60081dcc4c72131f8eb70510f1ac07223e5d4163db481a04a0befcffa412"
dependencies = [
 "libloading 0.8.1",
]

[[package]]
name = "dll_hook"
version = "0.1.0"
dependencies = [
 "anyhow",
 "backtrace",
 "bitflags 2.4.1",
 "eframe",
 "egui-winit",
 "indexmap 2.1.0",
 "itertools 0.12.0",
 "parking_lot 0.12.1",
 "patternsleuth",
 "regex",
 "retour",
 "simple-log",
 "thread_local",
 "widestring",
 "windows 0.52.0",
]

[[package]]
name = "downcast-rs"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ea835d29036a4087793836fa931b08837ad5e957da9e23886b29586fb9b6650"

[[package]]
name = "ecolor"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b7637fc2e74d17e52931bac90ff4fc061ac776ada9c7fa272f24cdca5991972"
dependencies = [
 "bytemuck",
]

[[package]]
name = "eframe"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdd73918a828c35a7efb4d7188ea973df4bffc589178ed95f521c917b03ddcfa"
dependencies = [
 "bytemuck",
 "cocoa",
 "egui",
 "egui-winit",
 "egui_glow",
 "glow",
 "glutin",
 "glutin-winit",
 "image",
 "js-sys",
 "log",
 "objc",
 "parking_lot 0.12.1",
 "percent-encoding",
 "raw-window-handle",
 "static_assertions",
 "thiserror",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "winapi",
 "winit",
]

[[package]]
name = "egui"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c55bcb864b764eb889515a38b8924757657a250738ad15126637ee2df291ee6b"
dependencies = [
 "accesskit",
 "ahash",
 "epaint",
 "log",
 "nohash-hasher",
]

[[package]]
name = "egui-winit"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b673606b6606b12b95e3a3194d7882bf5cff302db36a520b8144c7c342e4e84"
dependencies = [
 "accesskit_winit",
 "arboard",
 "egui",
 "log",
 "raw-window-handle",
 "smithay-clipboard",
 "web-time",
 "webbrowser",
 "winit",
]

[[package]]
name = "egui_glow"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "262151f9d57c557c02a40a46f27b9e050a6eb0b006b94dced9c6f4519a04d489"
dependencies = [
 "bytemuck",
 "egui",
 "glow",
 "log",
 "memoffset 0.7.1",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "either"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a26ae43d7bcc3b814de94796a5e736d4029efb0ee900c12e2d54c993ad1a1e07"

[[package]]
name = "emath"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a045c6c0b44b35e98513fc1e9d183ab42881ac27caccb9fa345465601f56cce4"
dependencies = [
 "bytemuck",
]

[[package]]
name = "encode_unicode"
version = "0.3.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a357d28ed41a50f9c765dbfe56cbc04a64e53e5fc58ba79fbc34c10ef3df831f"

[[package]]
name = "encode_unicode"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34aa73646ffb006b8f5147f3dc182bd4bcb190227ce861fc4a4844bf8e3cb2c0"

[[package]]
name = "enumflags2"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5998b4f30320c9d93aed72f63af821bfdac50465b75428fce77b48ec482c3939"
dependencies = [
 "enumflags2_derive",
 "serde",
]

[[package]]
name = "enumflags2_derive"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f95e2801cd355d4a1a3e3953ce6ee5ae9603a5c833455343a8bfe3f44d418246"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "epaint"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d1b9e000d21bab9b535ce78f9f7745be28b3f777f6c7223936561c5c7fefab8"
dependencies = [
 "ab_glyph",
 "ahash",
 "bytemuck",
 "ecolor",
 "emath",
 "log",
 "nohash-hasher",
 "parking_lot 0.12.1",
]

[[package]]
name = "equivalent"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"

[[package]]
name = "erased-serde"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55d05712b2d8d88102bc9868020c9e5c7a1f5527c452b9b97450a1d006140ba7"
dependencies = [
 "serde",
]

[[package]]
name = "errno"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a258e46cdc063eb8519c00b9fc845fc47bcfca4130e2f08e88665ceda8474245"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "error-code"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64f18991e7bf11e7ffee451b5318b5c1a73c52d0d0ada6e5a3017c8c1ced6a21"
dependencies = [
 "libc",
 "str-buf",
]

[[package]]
name = "event-listener"
version = "2.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0206175f82b8d6bf6652ff7d71a1e27fd2e4efde587fd368662814d6ec1d9ce0"

[[package]]
name = "event-listener"
version = "3.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d93877bcde0eb80ca09131a08d23f0a5c18a620b01db137dba666d18cd9b30c2"
dependencies = [
 "concurrent-queue",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "event-listener"
version = "4.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "770d968249b5d99410d61f5bf89057f3199a077a04d087092f58e7d10692baae"
dependencies = [
 "concurrent-queue",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "event-listener-strategy"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "958e4d70b6d5e81971bebec42271ec641e7ff4e170a6fa605f2b8a8b65cb97d3"
dependencies = [
 "event-listener 4.0.0",
 "pin-project-lite",
]

[[package]]
name = "fallible-iterator"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4443176a9f2c162692bd3d352d745ef9413eec5782a80d8fd6f8a1ac692a07f7"

[[package]]
name = "fallible-iterator"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2acce4a10f12dc2fb14a218589d4f1f62ef011b2d0cc4b3cb1bba8e94da14649"

[[package]]
name = "fallible-streaming-iterator"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7360491ce676a36bf9bb3c56c1aa791658183a54d2744120f27285738d90465a"

[[package]]
name = "fastrand"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e51093e27b0797c359783294ca4f0a911c270184cb10f85783b118614a1501be"
dependencies = [
 "instant",
]

[[package]]
name = "fastrand"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25cbce373ec4653f1a01a31e8a5e5ec0c622dc27ff9c4e6606eefef5cbbed4a5"

[[package]]
name = "fdeflate"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "209098dd6dfc4445aa6111f0e98653ac323eaa4dfd212c9ca3931bf9955c31bd"
dependencies = [
 "simd-adler32",
]

[[package]]
name = "flate2"
version = "1.0.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46303f565772937ffe1d394a4fac6f411c6013172fadde9dcdb1e147a086940e"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "form_urlencoded"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "futures"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "645c6916888f6cb6350d2550b80fb63e734897a8498abe35cfb732b6487804b0"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eac8f7d7865dcb88bd4373ab671c8cf4508703796caa2b1985a9ca867b3fcb78"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfc6580bb841c5a68e9ef15c77ccc837b40a7504914d52e47b8b0e9bbda25a1d"

[[package]]
name = "futures-executor"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a576fc72ae164fca6b9db127eaa9a9dda0d61316034f33a0a0d4eda41f02b01d"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a44623e20b9681a318efdd71c299b6b222ed6f231972bfe2f224ebad6311f0c1"

[[package]]
name = "futures-lite"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49a9d51ce47660b1e808d3c990b4709f2f415d928835a17dfd16991515c46bce"
dependencies = [
 "fastrand 1.9.0",
 "futures-core",
 "futures-io",
 "memchr",
 "parking",
 "pin-project-lite",
 "waker-fn",
]

[[package]]
name = "futures-lite"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aeee267a1883f7ebef3700f262d2d54de95dfaf38189015a74fdc4e0c7ad8143"
dependencies = [
 "fastrand 2.0.1",
 "futures-core",
 "futures-io",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "futures-macro"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87750cf4b7a4c0625b1529e4c543c2182106e4dedc60a2a6455e00d212c489ac"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "futures-scopes"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ffdcf32827e803f1a3cd04c4319feb99156cb5968a3b393f8541efefa1e3b24c"
dependencies = [
 "crossbeam-channel",
 "dashmap",
 "futures",
 "pin-project",
]

[[package]]
name = "futures-sink"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fb8e00e87438d937621c1c6269e53f536c14d3fbd6a042bb24879e57d474fb5"

[[package]]
name = "futures-task"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38d84fa142264698cdce1a9f9172cf383a0c82de1bddcf3092901442c4097004"

[[package]]
name = "futures-util"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d6401deb83407ab3da39eba7e33987a73c3df0c82b4bb5813ee871c19c41d48"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "gethostname"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb65d4ba3173c56a500b555b532f72c42e8d1fe64962b518897f8959fae2c177"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "getrandom"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe9006bed769170c11f845cf00c7c1e9092aeb3f268e007c3e760ac68008070f"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "gimli"
version = "0.28.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4271d37baee1b8c7e4b708028c57d816cf9d2434acb33a549475f78c181f6253"
dependencies = [
 "fallible-iterator 0.3.0",
 "indexmap 2.1.0",
 "stable_deref_trait",
]

[[package]]
name = "gl_generator"
version = "0.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a95dfc23a2b4a9a2f5ab41d194f8bfda3cabec42af4e39f08c339eb2a0c124d"
dependencies = [
 "khronos_api",
 "log",
 "xml-rs",
]

[[package]]
name = "globset"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57da3b9b5b85bd66f31093f8c408b90a74431672542466497dcbdfdc02034be1"
dependencies = [
 "aho-corasick",
 "bstr",
 "log",
 "regex-automata 0.4.3",
 "regex-syntax 0.8.2",
]

[[package]]
name = "glow"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca0fe580e4b60a8ab24a868bc08e2f03cbcb20d3d676601fa909386713333728"
dependencies = [
 "js-sys",
 "slotmap",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "glutin"
version = "0.30.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fc93b03242719b8ad39fb26ed2b01737144ce7bd4bfc7adadcef806596760fe"
dependencies = [
 "bitflags 1.3.2",
 "cfg_aliases",
 "cgl",
 "core-foundation",
 "dispatch",
 "glutin_egl_sys",
 "glutin_glx_sys",
 "glutin_wgl_sys",
 "libloading 0.7.4",
 "objc2",
 "once_cell",
 "raw-window-handle",
 "wayland-sys 0.30.1",
 "windows-sys 0.45.0",
 "x11-dl",
]

[[package]]
name = "glutin-winit"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "629a873fc04062830bfe8f97c03773bcd7b371e23bcc465d0a61448cd1588fa4"
dependencies = [
 "cfg_aliases",
 "glutin",
 "raw-window-handle",
 "winit",
]

[[package]]
name = "glutin_egl_sys"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af784eb26c5a68ec85391268e074f0aa618c096eadb5d6330b0911cf34fe57c5"
dependencies = [
 "gl_generator",
 "windows-sys 0.45.0",
]

[[package]]
name = "glutin_glx_sys"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b53cb5fe568964aa066a3ba91eac5ecbac869fb0842cd0dc9e412434f1a1494"
dependencies = [
 "gl_generator",
 "x11-dl",
]

[[package]]
name = "glutin_wgl_sys"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef89398e90033fc6bc65e9bd42fd29bbbfd483bda5b56dc5562f455550618165"
dependencies = [
 "gl_generator",
]

[[package]]
name = "half"
version = "1.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eabb4a44450da02c90444cf74558da904edde8fb4e9035a9a6a4e15445af0bd7"

[[package]]
name = "hashbrown"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"

[[package]]
name = "hashbrown"
version = "0.14.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "290f1a1d9242c78d09ce40a5e87e7554ee637af1351968159f4952f028f75604"
dependencies = [
 "ahash",
 "allocator-api2",
]

[[package]]
name = "hashlink"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8094feaf31ff591f651a2664fb9cfd92bba7a60ce3197265e9482ebe753c8f7"
dependencies = [
 "hashbrown 0.14.3",
]

[[package]]
name = "heck"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8"

[[package]]
name = "hermit-abi"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d77f7ec81a6d05a3abb01ab6eb7590f6083d08449fe5a1c8b1e620283546ccb7"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "home"
version = "0.5.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3d1354bf6b7235cb4a0576c2619fd4ed18183f689b12b006a0ee7329eeff9a5"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "humantime"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df004cfca50ef23c36850aaaa59ad52cc70d0e90243c3c7737a4dd32dc7a3c4f"
dependencies = [
 "quick-error",
]

[[package]]
name = "iana-time-zone"
version = "0.1.58"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8326b86b6cff230b97d0d312a6c40a60726df3332e721f72a1b035f451663b20"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "wasm-bindgen",
 "windows-core 0.51.1",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "iced-x86"
version = "1.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdd366a53278429c028367e0ba22a46cab6d565a57afb959f06e92c7a69e7828"
dependencies = [
 "lazy_static",
]

[[package]]
name = "idna"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "634d9b1461af396cad843f47fdba5597a4f9e6ddd4bfb6ff5d85028c25cb12f6"
dependencies = [
 "unicode-bidi",
 "unicode-normalization",
]

[[package]]
name = "image"
version = "0.24.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f3dfdbdd72063086ff443e297b61695500514b1e41095b6fb9a5ab48a70a711"
dependencies = [
 "bytemuck",
 "byteorder",
 "color_quant",
 "num-rational",
 "num-traits",
 "png",
]

[[package]]
name = "indexmap"
version = "1.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
dependencies = [
 "autocfg",
 "hashbrown 0.12.3",
]

[[package]]
name = "indexmap"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d530e1a18b1cb4c484e6e34556a0d948706958449fca0cab753d649f2bce3d1f"
dependencies = [
 "equivalent",
 "hashbrown 0.14.3",
]

[[package]]
name = "indicatif"
version = "0.17.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb28741c9db9a713d93deb3bb9515c20788cef5815265bee4980e87bde7e0f25"
dependencies = [
 "console",
 "instant",
 "number_prefix",
 "portable-atomic",
 "rayon",
 "unicode-width",
]

[[package]]
name = "instant"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c"
dependencies = [
 "cfg-if",
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "inventory"
version = "0.3.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c8573b2b1fb643a372c73b23f4da5f888677feef3305146d68a539250a9bccc7"

[[package]]
name = "io-lifetimes"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eae7b9aee968036d54dce06cebaefd919e4472e753296daccd6d344e3e2df0c2"
dependencies = [
 "hermit-abi",
 "libc",
 "windows-sys 0.48.0",
]

[[package]]
name = "is-terminal"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb0889898416213fab133e1d33a0e5858a48177452750691bde3666d0fdbaf8b"
dependencies = [
 "hermit-abi",
 "rustix 0.38.28",
 "windows-sys 0.48.0",
]

[[package]]
name = "is_debug"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06d198e9919d9822d5f7083ba8530e04de87841eaf21ead9af8f2304efd57c89"

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "itertools"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25db6b064527c5d482d0423354fcd07a89a2dfe07b67892e62411946db7f07b0"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b1a46d1a171d865aa5f83f92695765caa047a9b4cbae2cbf37dbd613a793fd4c"

[[package]]
name = "jni"
version = "0.21.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a87aa2bb7d2af34197c04845522473242e1aa17c12f4935d5856491a7fb8c97"
dependencies = [
 "cesu8",
 "cfg-if",
 "combine",
 "jni-sys",
 "log",
 "thiserror",
 "walkdir",
 "windows-sys 0.45.0",
]

[[package]]
name = "jni-sys"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8eaf4bc02d17cbdd7ff4c7438cafcdf7fb9a4613313ad11b4f8fefe7d3fa0130"

[[package]]
name = "jobserver"
version = "0.1.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c37f63953c4c63420ed5fd3d6d398c719489b9f872b9fa683262f8edd363c7d"
dependencies = [
 "libc",
]

[[package]]
name = "js-sys"
version = "0.3.64"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c5f195fe497f702db0f318b07fdd68edb16955aed830df8363d837542f8f935a"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "khronos_api"
version = "3.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2db585e1d738fc771bf08a151420d3ed193d9d895a36df7f6f8a9456b911ddc"

[[package]]
name = "lazy_static"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"

[[package]]
name = "libc"
version = "0.2.152"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13e3bf6590cbc649f4d1a3eefc9d5d6eb746f5200ffb04e5e142700b8faa56e7"

[[package]]
name = "libloading"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f"
dependencies = [
 "cfg-if",
 "winapi",
]

[[package]]
name = "libloading"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c571b676ddfc9a8c12f1f3d3085a7b163966a8fd8098a90640953ce5f6170161"
dependencies = [
 "cfg-if",
 "windows-sys 0.48.0",
]

[[package]]
name = "libredox"
version = "0.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3af92c55d7d839293953fcd0fda5ecfe93297cfde6ffbdec13b41d99c0ba6607"
dependencies = [
 "bitflags 2.4.1",
 "libc",
 "redox_syscall 0.4.1",
]

[[package]]
name = "libsqlite3-sys"
version = "0.27.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf4e226dcd58b4be396f7bd3c20da8fdee2911400705297ba7d2d7cc2c30f716"
dependencies = [
 "cc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "linked-hash-map"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0717cef1bc8b636c6e1c1bbdefc09e6322da8a9321966e8928ef80d20f7f770f"

[[package]]
name = "linux-raw-sys"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef53942eb7bf7ff43a617b3e2c1c4a5ecf5944a7c1bc12d7ee39bbb15e5c1519"

[[package]]
name = "linux-raw-sys"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4cd1a83af159aa67994778be9070f0ae1bd732942279cabb14f86f986a21456"

[[package]]
name = "lock_api"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c168f8615b12bc01f9c17e2eb0cc07dcae1940121185446edc3744920e8ef45"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5e6163cb8c49088c2c36f57875e58ccd8c87c7427f7fbd50ea6710b2f3f2e8f"
dependencies = [
 "serde",
]

[[package]]
name = "log-mdc"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a94d21414c1f4a51209ad204c1776a3d0765002c76c6abcb602a6f09f1e881c7"

[[package]]
name = "log4rs"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1e1ad45e4584824d760c35d71868dd7e6e5acd8f5195a9573743b369fc86cd6"
dependencies = [
 "arc-swap",
 "chrono",
 "flate2",
 "fnv",
 "humantime",
 "libc",
 "log",
 "log-mdc",
 "parking_lot 0.11.2",
 "serde",
 "serde-value",
 "serde_derive",
 "serde_json",
 "serde_yaml",
 "thread-id",
 "winapi",
]

[[package]]
name = "mach"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b823e83b2affd8f40a9ee8c29dbc56404c1e34cd2710921f2801e2cf29527afa"
dependencies = [
 "libc",
]

[[package]]
name = "malloc_buf"
version = "0.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62bb907fe88d54d8d9ce32a3cceab4218ed2f6b7d35617cafe9adf84e43919cb"
dependencies = [
 "libc",
]

[[package]]
name = "matchers"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558"
dependencies = [
 "regex-automata 0.1.10",
]

[[package]]
name = "memchr"
version = "2.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149"

[[package]]
name = "memmap2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83faa42c0a078c393f6b29d5db232d8be22776a891f8f56e5284faee4a20b327"
dependencies = [
 "libc",
]

[[package]]
name = "memoffset"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce"
dependencies = [
 "autocfg",
]

[[package]]
name = "memoffset"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5de893c32cde5f383baa4c04c5d6dbdd735cfd4a794b0debdb2bb1b421da5ff4"
dependencies = [
 "autocfg",
]

[[package]]
name = "miniz_oxide"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7810e0be55b428ada41041c41f32c9f1a42817901b4ccf45fa3d4b6561e74c7"
dependencies = [
 "adler",
 "simd-adler32",
]

[[package]]
name = "mio"
version = "0.8.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f3d0b296e374a4e6f3c7b0a1f5a51d748a0d34c85e7dc48fc3fa9a87657fe09"
dependencies = [
 "libc",
 "log",
 "wasi",
 "windows-sys 0.48.0",
]

[[package]]
name = "mmap-fixed-fixed"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0681853891801e4763dc252e843672faf32bcfee27a0aa3b19733902af450acc"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "msvc-demangler"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfb67c6dd0fa9b00619c41c5700b6f92d5f418be49b45ddb9970fbd4569df3c8"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "ndk"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "451422b7e4718271c8b5b3aadf5adedba43dc76312454b387e98fae0fc951aa0"
dependencies = [
 "bitflags 1.3.2",
 "jni-sys",
 "ndk-sys",
 "num_enum 0.5.11",
 "raw-window-handle",
 "thiserror",
]

[[package]]
name = "ndk-context"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27b02d87554356db9e9a873add8782d4ea6e3e58ea071a9adb9a2e8ddb884a8b"

[[package]]
name = "ndk-sys"
version = "0.4.1+23.1.7779620"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3cf2aae958bd232cac5069850591667ad422d263686d75b52a065f9badeee5a3"
dependencies = [
 "jni-sys",
]

[[package]]
name = "nix"
version = "0.24.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa52e972a9a719cecb6864fb88568781eb706bac2cd1d4f04a648542dbf78069"
dependencies = [
 "bitflags 1.3.2",
 "cfg-if",
 "libc",
 "memoffset 0.6.5",
]

[[package]]
name = "nix"
version = "0.25.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f346ff70e7dbfd675fe90590b92d59ef2de15a8779ae305ebcbfd3f0caf59be4"
dependencies = [
 "autocfg",
 "bitflags 1.3.2",
 "cfg-if",
 "libc",
 "memoffset 0.6.5",
]

[[package]]
name = "nix"
version = "0.26.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "598beaf3cc6fdd9a5dfb1630c2800c7acd31df7aaf0f565796fba2b53ca1af1b"
dependencies = [
 "bitflags 1.3.2",
 "cfg-if",
 "libc",
 "memoffset 0.7.1",
]

[[package]]
name = "nohash-hasher"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bf50223579dc7cdcfb3bfcacf7069ff68243f8c363f62ffa99cf000a6b9c451"

[[package]]
name = "nu-ansi-term"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84"
dependencies = [
 "overload",
 "winapi",
]

[[package]]
name = "num-conv"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"

[[package]]
name = "num-integer"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "225d3389fb3509a24c93f5c29eb6bde2586b98d9f016636dff58d7c6f7569cd9"
dependencies = [
 "autocfg",
 "num-traits",
]

[[package]]
name = "num-rational"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0638a1c9d0a3c0914158145bc76cff373a75a627e6ecbfb71cbe6f453a5a19b0"
dependencies = [
 "autocfg",
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39e3200413f237f41ab11ad6d161bc7239c84dcb631773ccd7de3dfe4b5c267c"
dependencies = [
 "autocfg",
]

[[package]]
name = "num_enum"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f646caf906c20226733ed5b1374287eb97e3c2a5c227ce668c1f2ce20ae57c9"
dependencies = [
 "num_enum_derive 0.5.11",
]

[[package]]
name = "num_enum"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a015b430d3c108a207fd776d2e2196aaf8b1cf8cf93253e3a097ff3085076a1"
dependencies = [
 "num_enum_derive 0.6.1",
]

[[package]]
name = "num_enum_derive"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcbff9bc912032c62bf65ef1d5aea88983b420f4f839db1e9b0c281a25c9c799"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "num_enum_derive"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96667db765a921f7b295ffee8b60472b686a51d4f21c2ee4ffdb94c7013b65a6"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "num_threads"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2819ce041d2ee131036f4fc9d6ae7ae125a3a40e97ba64d04fe799ad9dabbb44"
dependencies = [
 "libc",
]

[[package]]
name = "number_prefix"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830b246a0e5f20af87141b25c173cd1b609bd7779a4617d6ec582abaf90870f3"

[[package]]
name = "objc"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "915b1b472bc21c53464d6c8461c9d3af805ba1ef837e1cac254428f4a77177b1"
dependencies = [
 "malloc_buf",
]

[[package]]
name = "objc-foundation"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1add1b659e36c9607c7aab864a76c7a4c2760cd0cd2e120f3fb8b952c7e22bf9"
dependencies = [
 "block",
 "objc",
 "objc_id",
]

[[package]]
name = "objc-sys"
version = "0.2.0-beta.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df3b9834c1e95694a05a828b59f55fa2afec6288359cda67146126b3f90a55d7"

[[package]]
name = "objc2"
version = "0.3.0-beta.3.patch-leaks.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e01640f9f2cb1220bbe80325e179e532cb3379ebcd1bf2279d703c19fe3a468"
dependencies = [
 "block2",
 "objc-sys",
 "objc2-encode",
]

[[package]]
name = "objc2-encode"
version = "2.0.0-pre.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "abfcac41015b00a120608fdaa6938c44cb983fee294351cc4bac7638b4e50512"
dependencies = [
 "objc-sys",
]

[[package]]
name = "objc_id"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c92d4ddb4bd7b50d730c215ff871754d0da6b2178849f8a2a2ab69712d0c073b"
dependencies = [
 "objc",
]

[[package]]
name = "object"
version = "0.32.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6a622008b6e321afc04970976f62ee297fdbaa6f95318ca343e3eebb9648441"
dependencies = [
 "flate2",
 "memchr",
 "ruzstd",
]

[[package]]
name = "once_cell"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"

[[package]]
name = "oorandom"
version = "11.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ab1bc2a289d34bd04a330323ac98a1b4bc82c9d9fcb1e66b63caa84da26b575"

[[package]]
name = "orbclient"
version = "0.3.47"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52f0d54bde9774d3a51dcf281a5def240c71996bc6ca05d2c847ec8b2b216166"
dependencies = [
 "libredox",
]

[[package]]
name = "ordered-float"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3305af35278dd29f46fcdd139e0b1fbfae2153f0e5928b39b035542dd31e37b7"
dependencies = [
 "num-traits",
]

[[package]]
name = "ordered-stream"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9aa2b01e1d916879f73a53d01d1d6cee68adbb31d6d9177a8cfce093cced1d50"
dependencies = [
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "overload"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39"

[[package]]
name = "owned_ttf_parser"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4586edfe4c648c71797a74c84bacb32b52b212eff5dfe2bb9f2c599844023e7"
dependencies = [
 "ttf-parser",
]

[[package]]
name = "parking"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb813b8af86854136c6922af0598d719255ecb2179515e6e7730d468f05c9cae"

[[package]]
name = "parking_lot"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99"
dependencies = [
 "instant",
 "lock_api",
 "parking_lot_core 0.8.6",
]

[[package]]
name = "parking_lot"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f"
dependencies = [
 "lock_api",
 "parking_lot_core 0.9.9",
]

[[package]]
name = "parking_lot_core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60a2cfe6f0ad2bfc16aefa463b497d5c7a5ecd44a23efa72aa342d90177356dc"
dependencies = [
 "cfg-if",
 "instant",
 "libc",
 "redox_syscall 0.2.16",
 "smallvec",
 "winapi",
]

[[package]]
name = "parking_lot_core"
version = "0.9.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c42a9226546d68acdd9c0a280d17ce19bfe27a46bf68784e4066115788d008e"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.4.1",
 "smallvec",
 "windows-targets 0.48.5",
]

[[package]]
name = "paste"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c"

[[package]]
name = "patricia_tree"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31f2f4539bffe53fc4b4da301df49d114b845b077bd5727b7fe2bd9d8df2ae68"
dependencies = [
 "bitflags 2.4.1",
]

[[package]]
name = "patternsleuth"
version = "0.1.0"
dependencies = [
 "anyhow",
 "futures",
 "futures-scopes",
 "gimli",
 "iced-x86",
 "inventory",
 "itertools 0.12.0",
 "libc",
 "memchr",
 "msvc-demangler",
 "object",
 "patternsleuth_scanner",
 "pdb",
 "rayon",
 "serde",
 "strum",
 "tracing",
 "typetag",
 "windows 0.52.0",
]

[[package]]
name = "patternsleuth_cli"
version = "0.1.0"
dependencies = [
 "anyhow",
 "clap",
 "colored",
 "crossbeam",
 "globset",
 "iced-x86",
 "indicatif",
 "itertools 0.12.0",
 "libc",
 "memchr",
 "msvc-demangler",
 "object",
 "patricia_tree",
 "patternsleuth",
 "pdb",
 "prettytable-rs",
 "rayon",
 "regex",
 "rusqlite",
 "serde",
 "serde_json",
 "strum",
 "time",
 "tracing",
 "tracing-subscriber",
]

[[package]]
name = "patternsleuth_scanner"
version = "0.1.0"
dependencies = [
 "anyhow",
 "criterion",
 "memchr",
 "object",
 "rand",
 "rayon",
]

[[package]]
name = "pdb"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82040a392923abe6279c00ab4aff62d5250d1c8555dc780e4b02783a7aa74863"
dependencies = [
 "fallible-iterator 0.2.0",
 "scroll",
 "uuid",
]

[[package]]
name = "percent-encoding"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"

[[package]]
name = "pin-project"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fda4ed1c6c173e3fc7a83629421152e01d7b1f9b7f65fb301e490e8cfc656422"
dependencies = [
 "pin-project-internal",
]

[[package]]
name = "pin-project-internal"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4359fd9c9171ec6e8c62926d6faaf553a8dc3f64e1507e76da7911b4f6a04405"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "pin-project-lite"
version = "0.2.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8afb450f006bf6385ca15ef45d71d2288452bc3683ce2e2cacc0d18e4be60b58"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "piper"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "668d31b1c4eba19242f2088b2bf3316b82ca31082a8335764db4e083db7485d4"
dependencies = [
 "atomic-waker",
 "fastrand 2.0.1",
 "futures-io",
]

[[package]]
name = "pkg-config"
version = "0.3.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69d3587f8a9e599cc7ec2c00e331f71c4e69a5f9a4b8a6efd5b07466b9736f9a"

[[package]]
name = "plotters"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2c224ba00d7cadd4d5c660deaf2098e5e80e07846537c51f9cfa4be50c1fd45"
dependencies = [
 "num-traits",
 "plotters-backend",
 "plotters-svg",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "plotters-backend"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e76628b4d3a7581389a35d5b6e2139607ad7c75b17aed325f210aa91f4a9609"

[[package]]
name = "plotters-svg"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38f6d39893cca0701371e3c27294f09797214b86f1fb951b89ade8ec04e2abab"
dependencies = [
 "plotters-backend",
]

[[package]]
name = "png"
version = "0.17.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd75bf2d8dd3702b9707cdbc56a5b9ef42cec752eb8b3bafc01234558442aa64"
dependencies = [
 "bitflags 1.3.2",
 "crc32fast",
 "fdeflate",
 "flate2",
 "miniz_oxide",
]

[[package]]
name = "polling"
version = "2.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b2d323e8ca7996b3e23126511a523f7e62924d93ecd5ae73b333815b0eb3dce"
dependencies = [
 "autocfg",
 "bitflags 1.3.2",
 "cfg-if",
 "concurrent-queue",
 "libc",
 "log",
 "pin-project-lite",
 "windows-sys 0.48.0",
]

[[package]]
name = "polling"
version = "3.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf63fa624ab313c11656b4cda960bfc46c410187ad493c41f6ba2d8c1e991c9e"
dependencies = [
 "cfg-if",
 "concurrent-queue",
 "pin-project-lite",
 "rustix 0.38.28",
 "tracing",
 "windows-sys 0.52.0",
]

[[package]]
name = "portable-atomic"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7170ef9988bc169ba16dd36a7fa041e5c4cbeb6a35b76d4c03daded371eae7c0"

[[package]]
name = "powerfmt"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"

[[package]]
name = "ppv-lite86"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"

[[package]]
name = "prettytable-rs"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eea25e07510aa6ab6547308ebe3c036016d162b8da920dbb079e3ba8acf3d95a"
dependencies = [
 "csv",
 "encode_unicode 1.0.0",
 "is-terminal",
 "lazy_static",
 "term",
 "unicode-width",
]

[[package]]
name = "proc-macro-crate"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f4c021e1093a56626774e81216a4ce732a735e5bad4868a03f3ed65ca0c3919"
dependencies = [
 "once_cell",
 "toml_edit",
]

[[package]]
name = "proc-macro2"
version = "1.0.76"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95fc56cda0b5c3325f5fbbd7ff9fda9e02bb00bb3dac51252d2f1bfa1cb8cc8c"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quick-error"
version = "1.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0"

[[package]]
name = "quote"
version = "1.0.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "291ec9ab5efd934aaf503a6466c5d5251535d108ee747472c3977cc5acc868ef"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "raw-window-handle"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2ff9a1f06a88b01621b7ae906ef0211290d1c8a168a15542486a8f61c0833b9"

[[package]]
name = "rayon"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c27db03db7734835b3f53954b534c91069375ce6ccaa2e065441e07d9b6cdb1"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ce3fb6ad83f861aac485e76e1985cd109d9a3713802152be56c3b1f0e0658ed"
dependencies = [
 "crossbeam-deque",
 "crossbeam-utils",
]

[[package]]
name = "redox_syscall"
version = "0.1.57"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41cc0f7e4d5d4544e8861606a285bb08d3e70712ccc7d2b84d7c0ccfaf4b05ce"

[[package]]
name = "redox_syscall"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567664f262709473930a4bf9e51bf2ebf3348f2e748ccc50dea20646858f8f29"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4722d768eff46b75989dd134e5c353f0d6296e5aaa3132e776cbdb56be7731aa"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_users"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b033d837a7cf162d7993aded9304e30a83213c648b6e389db233191f891e5c2b"
dependencies = [
 "getrandom",
 "redox_syscall 0.2.16",
 "thiserror",
]

[[package]]
name = "regex"
version = "1.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "380b951a9c5e80ddfd6136919eef32310721aa4aacd4889a8d39124b026ab343"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata 0.4.3",
 "regex-syntax 0.8.2",
]

[[package]]
name = "regex-automata"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
dependencies = [
 "regex-syntax 0.6.29",
]

[[package]]
name = "regex-automata"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f804c7828047e88b2d32e2d7fe5a105da8ee3264f01902f796c8e067dc2483f"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.8.2",
]

[[package]]
name = "regex-syntax"
version = "0.6.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"

[[package]]
name = "regex-syntax"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08c74e62047bb2de4ff487b251e4a92e24f48745648451635cec7d591162d9f"

[[package]]
name = "region"
version = "3.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76e189c2369884dce920945e2ddf79b3dff49e071a167dd1817fa9c4c00d512e"
dependencies = [
 "bitflags 1.3.2",
 "libc",
 "mach",
 "winapi",
]

[[package]]
name = "retour"
version = "0.4.0-alpha.2"
source = "git+https://github.com/Hpmason/retour-rs#19f213249b765d23a1cdde3f0b7c7989838d19d2"
dependencies = [
 "cfg-if",
 "generic-array",
 "iced-x86",
 "libc",
 "mmap-fixed-fixed",
 "once_cell",
 "region",
 "slice-pool2",
]

[[package]]
name = "rusqlite"
version = "0.30.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a78046161564f5e7cd9008aff3b2990b3850dc8e0349119b98e8f251e099f24d"
dependencies = [
 "bitflags 2.4.1",
 "fallible-iterator 0.3.0",
 "fallible-streaming-iterator",
 "hashlink",
 "libsqlite3-sys",
 "smallvec",
]

[[package]]
name = "rustc-demangle"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d626bb9dae77e28219937af045c257c28bfd3f69333c512553507f5f9798cb76"

[[package]]
name = "rustix"
version = "0.37.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fea8ca367a3a01fe35e6943c400addf443c0f57670e6ec51196f71a4b8762dd2"
dependencies = [
 "bitflags 1.3.2",
 "errno",
 "io-lifetimes",
 "libc",
 "linux-raw-sys 0.3.8",
 "windows-sys 0.48.0",
]

[[package]]
name = "rustix"
version = "0.38.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72e572a5e8ca657d7366229cdde4bd14c4eb5499a9573d4d366fe1b599daa316"
dependencies = [
 "bitflags 2.4.1",
 "errno",
 "libc",
 "linux-raw-sys 0.4.12",
 "windows-sys 0.52.0",
]

[[package]]
name = "rustversion"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ffc183a10b4478d04cbbbfc96d0873219d962dd5accaff2ffbd4ceb7df837f4"

[[package]]
name = "ruzstd"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "58c4eb8a81997cf040a091d1f7e1938aeab6749d3a0dfa73af43cdc32393483d"
dependencies = [
 "byteorder",
 "derive_more",
 "twox-hash",
]

[[package]]
name = "ryu"
version = "1.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f98d2aa92eebf49b69786be48e4477826b256916e84a57ff2a4f21923b48eb4c"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "scoped-tls"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1cf6437eb19a8f4a6cc0f7dca544973b0b78843adbfeb3683d1a94a0024a294"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "scroll"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04c565b551bafbef4157586fa379538366e4385d42082f255bfd96e4fe8519da"

[[package]]
name = "sctk-adwaita"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cda4e97be1fd174ccc2aae81c8b694e803fa99b34e8fd0f057a9d70698e3ed09"
dependencies = [
 "ab_glyph",
 "log",
 "memmap2",
 "smithay-client-toolkit",
 "tiny-skia",
]

[[package]]
name = "serde"
version = "1.0.195"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "63261df402c67811e9ac6def069e4786148c4563f4b50fd4bf30aa370d626b02"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde-value"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a65a7291a8a568adcae4c10a677ebcedbc6c9cec91c054dee2ce40b0e3290eb"
dependencies = [
 "ordered-float",
 "serde",
]

[[package]]
name = "serde_derive"
version = "1.0.195"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46fe8f8603d81ba86327b23a2e9cdf49e1255fb94a4c5f297f6ee0547178ea2c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "serde_json"
version = "1.0.111"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "176e46fa42316f18edd598015a5166857fc835ec732f5215eac6b7bdbf0a84f4"
dependencies = [
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "serde_repr"
version = "0.1.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3081f5ffbb02284dda55132aa26daecedd7372a42417bbbab6f14ab7d6bb9145"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "serde_yaml"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "578a7433b776b56a35785ed5ce9a7e777ac0598aac5a6dd1b4b18a307c7fc71b"
dependencies = [
 "indexmap 1.9.3",
 "ryu",
 "serde",
 "yaml-rust",
]

[[package]]
name = "sha1"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "signal-hook-registry"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8229b473baa5980ac72ef434c4415e70c4b5e71b423043adb4ba059f89c99a1"
dependencies = [
 "libc",
]

[[package]]
name = "simd-adler32"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d66dc143e6b11c1eddc06d5c423cfc97062865baf299914ab64caa38182078fe"

[[package]]
name = "simple-log"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "110feefe2a808cadb7fe8c07c615ac82e899f1795fec063ed2fb1d72de5d417b"
dependencies = [
 "convert_case",
 "is_debug",
 "log",
 "log4rs",
 "once_cell",
 "serde",
]

[[package]]
name = "slab"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67"
dependencies = [
 "autocfg",
]

[[package]]
name = "slice-pool2"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a3d689654af89bdfeba29a914ab6ac0236d382eb3b764f7454dde052f2821f8"

[[package]]
name = "slotmap"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbff4acf519f630b3a3ddcfaea6c06b42174d9a44bc70c620e9ed1649d58b82a"
dependencies = [
 "version_check",
]

[[package]]
name = "smallvec"
version = "1.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4dccd0940a2dcdf68d092b8cbab7dc0ad8fa938bf95787e1b916b0e3d0e8e970"

[[package]]
name = "smithay-client-toolkit"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "870427e30b8f2cbe64bf43ec4b86e88fe39b0a84b3f15efd9c9c2d020bc86eb9"
dependencies = [
 "bitflags 1.3.2",
 "calloop",
 "dlib",
 "lazy_static",
 "log",
 "memmap2",
 "nix 0.24.3",
 "pkg-config",
 "wayland-client",
 "wayland-cursor",
 "wayland-protocols",
]

[[package]]
name = "smithay-clipboard"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a345c870a1fae0b1b779085e81b51e614767c239e93503588e54c5b17f4b0e8"
dependencies = [
 "smithay-client-toolkit",
 "wayland-client",
]

[[package]]
name = "socket2"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9f7916fc008ca5542385b89a3d3ce689953c143e9304a9bf8beec1de48994c0d"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "str-buf"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e08d8363704e6c71fc928674353e6b7c23dcea9d82d7012c8faf2a3a025f8d0"

[[package]]
name = "strict-num"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6637bab7722d379c8b41ba849228d680cc12d0a45ba1fa2b48f2a30577a06731"

[[package]]
name = "strsim"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"

[[package]]
name = "strum"
version = "0.25.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "290d54ea6f91c969195bdbcd7442c8c2a2ba87da8bf60a7ee86a235d4bc1e125"
dependencies = [
 "strum_macros",
]

[[package]]
name = "strum_macros"
version = "0.25.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23dc1fa9ac9c169a78ba62f0b841814b7abae11bdd047b9c58f893439e309ea0"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "rustversion",
 "syn 2.0.48",
]

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.48"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0f3531638e407dfc0814761abb7c00a5b54992b849452a0646b7f65c9f770f3f"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tempfile"
version = "3.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "01ce4141aa927a6d1bd34a041795abd0db1cccba5d5f24b009f694bdf3a1f3fa"
dependencies = [
 "cfg-if",
 "fastrand 2.0.1",
 "redox_syscall 0.4.1",
 "rustix 0.38.28",
 "windows-sys 0.52.0",
]

[[package]]
name = "term"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c59df8ac95d96ff9bede18eb7300b0fda5e5d8d90960e76f8e14ae765eedbf1f"
dependencies = [
 "dirs-next",
 "rustversion",
 "winapi",
]

[[package]]
name = "thiserror"
version = "1.0.56"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d54378c645627613241d077a3a79db965db602882668f9136ac42af9ecb730ad"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.56"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa0faa943b50f3db30a20aa7e265dbc66076993efed8463e8de414e5d06d3471"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "thread-id"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7fbf4c9d56b320106cd64fd024dadfa0be7cb4706725fc44a7d7ce952d820c1"
dependencies = [
 "libc",
 "redox_syscall 0.1.57",
 "winapi",
]

[[package]]
name = "thread_local"
version = "1.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdd6f064ccff2d6567adcb3873ca630700f00b5ad3f060c25b5dcfd9a4ce152"
dependencies = [
 "cfg-if",
 "once_cell",
]

[[package]]
name = "time"
version = "0.3.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5dfd88e563464686c916c7e46e623e520ddc6d79fa6641390f2e3fa86e83e885"
dependencies = [
 "deranged",
 "itoa",
 "libc",
 "num-conv",
 "num_threads",
 "powerfmt",
 "serde",
 "time-core",
 "time-macros",
]

[[package]]
name = "time-core"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef927ca75afb808a4d64dd374f00a2adf8d0fcff8e7b184af886c3c87ec4a3f3"

[[package]]
name = "time-macros"
version = "0.2.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f252a68540fde3a3877aeea552b832b40ab9a69e318efd078774a01ddee1ccf"
dependencies = [
 "num-conv",
 "time-core",
]

[[package]]
name = "tiny-skia"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df8493a203431061e901613751931f047d1971337153f96d0e5e363d6dbf6a67"
dependencies = [
 "arrayref",
 "arrayvec",
 "bytemuck",
 "cfg-if",
 "png",
 "tiny-skia-path",
]

[[package]]
name = "tiny-skia-path"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adbfb5d3f3dd57a0e11d12f4f13d4ebbbc1b5c15b7ab0a156d030b21da5f677c"
dependencies = [
 "arrayref",
 "bytemuck",
 "strict-num",
]

[[package]]
name = "tinytemplate"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be4d6b5f19ff7664e8c98d03e2139cb510db9b0a60b55f8e8709b689d939b6bc"
dependencies = [
 "serde",
 "serde_json",
]

[[package]]
name = "tinyvec"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87cc5ceb3875bb20c2890005a4e226a4651264a5c75edb2421b52861a0a0cb50"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "toml_datetime"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3550f4e9685620ac18a50ed434eb3aec30db8ba93b0287467bca5826ea25baf1"

[[package]]
name = "toml_edit"
version = "0.19.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421"
dependencies = [
 "indexmap 2.1.0",
 "toml_datetime",
 "winnow",
]

[[package]]
name = "tracing"
version = "0.1.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3523ab5a71916ccf420eebdf5521fcef02141234bbc0b8a49f2fdc4544364ef"
dependencies = [
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34704c8d6ebcbc939824180af020566b01a7c01f80641264eba0999f6c2b6be7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "tracing-core"
version = "0.1.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c06d3da6113f116aaee68e4d601191614c9053067f9ab7f6edbcb161237daa54"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ad0f048c97dbd9faa9b7df56362b8ebcaa52adb06b498c050d2f4e32f90a7a8b"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "ttf-parser"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17f77d76d837a7830fe1d4f12b7b4ba4192c1888001c7164257e4bc6d21d96b4"

[[package]]
name = "twox-hash"
version = "1.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97fee6b57c6a41524a810daee9286c02d7752c4253064d0b05472833a438f675"
dependencies = [
 "cfg-if",
 "static_assertions",
]

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "typetag"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "661d18414ec032a49ece2d56eee03636e43c4e8d577047ab334c0ba892e29aaf"
dependencies = [
 "erased-serde",
 "inventory",
 "once_cell",
 "serde",
 "typetag-impl",
]

[[package]]
name = "typetag-impl"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac73887f47b9312552aa90ef477927ff014d63d1920ca8037c6c1951eab64bb1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "uds_windows"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce65604324d3cce9b966701489fbd0cf318cb1f7bd9dd07ac9a4ee6fb791930d"
dependencies = [
 "tempfile",
 "winapi",
]

[[package]]
name = "unicode-bidi"
version = "0.3.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f2528f27a9eb2b21e69c95319b30bd0efd85d09c379741b0f78ea1d86be2416"

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "unicode-normalization"
version = "0.1.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
dependencies = [
 "tinyvec",
]

[[package]]
name = "unicode-width"
version = "0.1.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e51733f11c9c4f72aa0c160008246859e340b00807569a0da0e7a1079b27ba85"

[[package]]
name = "url"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31e6302e3bb753d46e83516cae55ae196fc0c309407cf11ab35cc51a4c2a4633"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
]

[[package]]
name = "utf8parse"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "711b9620af191e0cdc7468a8d14e709c3dcdb115b36f838e601583af800a370a"

[[package]]
name = "uuid"
version = "1.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e395fcf16a7a3d8127ec99782007af141946b4795001f876d54fb0d55978560"

[[package]]
name = "valuable"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830b7e5d4d90034032940e4ace0d9a9a057e7a45cd94e6c007832e39edb82f6d"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "vec_map"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bddf1187be692e79c5ffeab891132dfb0f236ed36a43c7ed39f1165ee20191"

[[package]]
name = "version_check"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"

[[package]]
name = "waker-fn"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3c4517f54858c779bbcbf228f4fca63d121bf85fbecb2dc578cdf4a39395690"

[[package]]
name = "walkdir"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71d857dc86794ca4c280d616f7da00d2dbfd8cd788846559a6813e6aa4b54ee"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.87"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7706a72ab36d8cb1f80ffbf0e071533974a60d0a308d01a5d0375bf60499a342"
dependencies = [
 "cfg-if",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.87"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ef2b6d3c510e9625e5fe6f509ab07d66a760f0885d858736483c32ed7809abd"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn 2.0.48",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c02dbc21516f9f1f04f187958890d7e6026df8d16540b7ad9492bc34a67cea03"
dependencies = [
 "cfg-if",
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.87"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dee495e55982a3bd48105a7b947fd2a9b4a8ae3010041b9e0faab3f9cd028f1d"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.87"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "54681b18a46765f095758388f2d0cf16eb8d4169b639ab575a8f5693af210c7b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.87"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca6ad05a4870b2bf5fe995117d3728437bd27d7cd5f06f13c17443ef369775a1"

[[package]]
name = "wayland-client"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f3b068c05a039c9f755f881dc50f01732214f5685e379829759088967c46715"
dependencies = [
 "bitflags 1.3.2",
 "downcast-rs",
 "libc",
 "nix 0.24.3",
 "scoped-tls",
 "wayland-commons",
 "wayland-scanner",
 "wayland-sys 0.29.5",
]

[[package]]
name = "wayland-commons"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8691f134d584a33a6606d9d717b95c4fa20065605f798a3f350d78dced02a902"
dependencies = [
 "nix 0.24.3",
 "once_cell",
 "smallvec",
 "wayland-sys 0.29.5",
]

[[package]]
name = "wayland-cursor"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6865c6b66f13d6257bef1cd40cbfe8ef2f150fb8ebbdb1e8e873455931377661"
dependencies = [
 "nix 0.24.3",
 "wayland-client",
 "xcursor",
]

[[package]]
name = "wayland-protocols"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b950621f9354b322ee817a23474e479b34be96c2e909c14f7bc0100e9a970bc6"
dependencies = [
 "bitflags 1.3.2",
 "wayland-client",
 "wayland-commons",
 "wayland-scanner",
]

[[package]]
name = "wayland-scanner"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f4303d8fa22ab852f789e75a967f0a2cdc430a607751c0499bada3e451cbd53"
dependencies = [
 "proc-macro2",
 "quote",
 "xml-rs",
]

[[package]]
name = "wayland-sys"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be12ce1a3c39ec7dba25594b97b42cb3195d54953ddb9d3d95a7c3902bc6e9d4"
dependencies = [
 "dlib",
 "lazy_static",
 "pkg-config",
]

[[package]]
name = "wayland-sys"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96b2a02ac608e07132978689a6f9bf4214949c85998c247abadd4f4129b1aa06"
dependencies = [
 "dlib",
 "lazy_static",
 "log",
 "pkg-config",
]

[[package]]
name = "web-sys"
version = "0.3.64"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b85cbef8c220a6abc02aefd892dfc0fc23afb1c6a426316ec33253a3877249b"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "web-time"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57099a701fb3a8043f993e8228dc24229c7b942e2b009a1b962e54489ba1d3bf"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "webbrowser"
version = "0.8.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82b2391658b02c27719fc5a0a73d6e696285138e8b12fba9d4baa70451023c71"
dependencies = [
 "core-foundation",
 "home",
 "jni",
 "log",
 "ndk-context",
 "objc",
 "raw-window-handle",
 "url",
 "web-sys",
]

[[package]]
name = "widestring"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "653f141f39ec16bba3c5abe400a0c60da7468261cc2cbf36805022876bc721a8"

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f29e6f9198ba0d26b4c9f07dbe6f9ed633e1f3d5b8b414090084349e46a52596"
dependencies = [
 "winapi",
]

[[package]]
name = "winapi-wsapoll"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44c17110f57155602a80dca10be03852116403c9ff3cd25b079d666f2aa3df6e"
dependencies = [
 "winapi",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e686886bc078bc1b0b600cac0147aadb815089b6e4da64016cbd754b6342700f"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-targets 0.48.5",
]

[[package]]
name = "windows"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e48a53791691ab099e5e2ad123536d0fff50652600abaf43bbf952894110d0be"
dependencies = [
 "windows-core 0.52.0",
 "windows-targets 0.52.0",
]

[[package]]
name = "windows-core"
version = "0.51.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1f8cf84f35d2db49a46868f947758c7a1138116f7fac3bc844f43ade1292e64"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-core"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
dependencies = [
 "windows-targets 0.52.0",
]

[[package]]
name = "windows-implement"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e2ee588991b9e7e6c8338edf3333fbe4da35dc72092643958ebb43f0ab2c49c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "windows-interface"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6fb8df20c9bcaa8ad6ab513f7b40104840c8867d5751126e4df3b08388d0cc7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "windows-sys"
version = "0.45.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
dependencies = [
 "windows-targets 0.42.2",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.0",
]

[[package]]
name = "windows-targets"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
dependencies = [
 "windows_aarch64_gnullvm 0.42.2",
 "windows_aarch64_msvc 0.42.2",
 "windows_i686_gnu 0.42.2",
 "windows_i686_msvc 0.42.2",
 "windows_x86_64_gnu 0.42.2",
 "windows_x86_64_gnullvm 0.42.2",
 "windows_x86_64_msvc 0.42.2",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a18201040b24831fbb9e4eb208f8892e1f50a37feb53cc7ff887feb8f50e7cd"
dependencies = [
 "windows_aarch64_gnullvm 0.52.0",
 "windows_aarch64_msvc 0.52.0",
 "windows_i686_gnu 0.52.0",
 "windows_i686_msvc 0.52.0",
 "windows_x86_64_gnu 0.52.0",
 "windows_x86_64_gnullvm 0.52.0",
 "windows_x86_64_msvc 0.52.0",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb7764e35d4db8a7921e09562a0304bf2f93e0a51bfccee0bd0bb0b666b015ea"

[[package]]
name = "windows_aarch64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbaa0368d4f1d2aaefc55b6fcfee13f41544ddf36801e793edbbfd7d7df075ef"

[[package]]
name = "windows_i686_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a28637cb1fa3560a16915793afb20081aba2c92ee8af57b4d5f28e4b3e7df313"

[[package]]
name = "windows_i686_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ffe5e8e31046ce6230cc7215707b816e339ff4d4d67c65dffa206fd0f7aa7b9a"

[[package]]
name = "windows_x86_64_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d6fa32db2bc4a2f5abeacf2b69f7992cd09dca97498da74a151a3132c26befd"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a657e1e9d3f514745a572a6846d3c7aa7dbe1658c056ed9c3344c4109a6949e"

[[package]]
name = "windows_x86_64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dff9641d1cd4be8d1a070daf9e3773c5f67e78b4d9d42263020c057706765c04"

[[package]]
name = "winit"
version = "0.28.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9596d90b45384f5281384ab204224876e8e8bf7d58366d9b795ad99aa9894b94"
dependencies = [
 "android-activity",
 "bitflags 1.3.2",
 "cfg_aliases",
 "core-foundation",
 "core-graphics",
 "dispatch",
 "instant",
 "libc",
 "log",
 "mio",
 "ndk",
 "objc2",
 "once_cell",
 "orbclient",
 "percent-encoding",
 "raw-window-handle",
 "redox_syscall 0.3.5",
 "sctk-adwaita",
 "smithay-client-toolkit",
 "wasm-bindgen",
 "wayland-client",
 "wayland-commons",
 "wayland-protocols",
 "wayland-scanner",
 "web-sys",
 "windows-sys 0.45.0",
 "x11-dl",
]

[[package]]
name = "winnow"
version = "0.5.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c830786f7720c2fd27a1a0e27a709dbd3c4d009b56d098fc742d4f4eab91fe2"
dependencies = [
 "memchr",
]

[[package]]
name = "x11-dl"
version = "2.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38735924fedd5314a6e548792904ed8c6de6636285cb9fec04d5b1db85c1516f"
dependencies = [
 "libc",
 "once_cell",
 "pkg-config",
]

[[package]]
name = "x11rb"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b1641b26d4dec61337c35a1b1aaf9e3cba8f46f0b43636c609ab0291a648040a"
dependencies = [
 "gethostname",
 "nix 0.26.4",
 "winapi",
 "winapi-wsapoll",
 "x11rb-protocol",
]

[[package]]
name = "x11rb-protocol"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82d6c3f9a0fb6701fab8f6cea9b0c0bd5d6876f1f89f7fada07e558077c344bc"
dependencies = [
 "nix 0.26.4",
]

[[package]]
name = "xcursor"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a0ccd7b4a5345edfcd0c3535718a4e9ff7798ffc536bb5b5a0e26ff84732911"

[[package]]
name = "xdg-home"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2769203cd13a0c6015d515be729c526d041e9cf2c0cc478d57faee85f40c6dcd"
dependencies = [
 "nix 0.26.4",
 "winapi",
]

[[package]]
name = "xml-rs"
version = "0.8.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fcb9cbac069e033553e8bb871be2fbdffcab578eb25bd0f7c508cedc6dcd75a"

[[package]]
name = "yaml-rust"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56c1936c4cc7a1c9ab21a1ebb602eb942ba868cbd44a99cb7cdc5892335e1c85"
dependencies = [
 "linked-hash-map",
]

[[package]]
name = "zbus"
version = "3.14.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31de390a2d872e4cd04edd71b425e29853f786dc99317ed72d73d6fcf5ebb948"
dependencies = [
 "async-broadcast",
 "async-executor",
 "async-fs",
 "async-io 1.13.0",
 "async-lock 2.8.0",
 "async-process",
 "async-recursion",
 "async-task",
 "async-trait",
 "blocking",
 "byteorder",
 "derivative",
 "enumflags2",
 "event-listener 2.5.3",
 "futures-core",
 "futures-sink",
 "futures-util",
 "hex",
 "nix 0.26.4",
 "once_cell",
 "ordered-stream",
 "rand",
 "serde",
 "serde_repr",
 "sha1",
 "static_assertions",
 "tracing",
 "uds_windows",
 "winapi",
 "xdg-home",
 "zbus_macros",
 "zbus_names",
 "zvariant",
]

[[package]]
name = "zbus_macros"
version = "3.14.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41d1794a946878c0e807f55a397187c11fc7a038ba5d868e7db4f3bd7760bc9d"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "regex",
 "syn 1.0.109",
 "zvariant_utils",
]

[[package]]
name = "zbus_names"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb80bb776dbda6e23d705cf0123c3b95df99c4ebeaec6c2599d4a5419902b4a9"
dependencies = [
 "serde",
 "static_assertions",
 "zvariant",
]

[[package]]
name = "zerocopy"
version = "0.7.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74d4d3961e53fa4c9a25a8637fc2bfaf2595b3d3ae34875568a5cf64787716be"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ce1b18ccd8e73a9321186f97e46f9f04b778851177567b1975109d26a08d2a6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.48",
]

[[package]]
name = "zvariant"
version = "3.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44b291bee0d960c53170780af148dca5fa260a63cdd24f1962fa82e03e53338c"
dependencies = [
 "byteorder",
 "enumflags2",
 "libc",
 "serde",
 "static_assertions",
 "zvariant_derive",
]

[[package]]
name = "zvariant_derive"
version = "3.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "934d7a7dfc310d6ee06c87ffe88ef4eca7d3e37bb251dece2ef93da8f17d8ecd"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
 "zvariant_utils",
]

[[package]]
name = "zvariant_utils"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7234f0d811589db492d16893e3f21e8e2fd282e6d01b0cddee310322062cc200"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

```

`Cargo.toml`:

```toml
[workspace]
resolver = "2"
members = [
    "patternsleuth",
    "patternsleuth_cli",
    "patternsleuth_scanner",
    "examples/*",
]
default-members = ["patternsleuth_*"]

[workspace.package]
repository = "https://github.com/trumank/patternsleuth"
authors = [ "trumank" ]
license = "MIT OR Apache-2.0"
version = "0.1.0"
edition = "2021"

[profile.release]
incremental = true
debug = true

[workspace.dependencies]
anyhow = "1.0.79"
clap = { version = "4.4.14", features = ["derive"] }
colored = "2.1.0"
globset = "0.4.14"
iced-x86 = "1.20.0"
itertools = "0.12.0"
memchr = "2.7.1"
msvc-demangler = "0.9.0"
object = "0.32.2"
pdb = "0.8.0"
prettytable-rs = "0.10.0"
rayon = "1.8.0"
regex = "1.10.2"
serde = "1.0.195"
strum = {version = "0.25.0", features = ["strum_macros", "derive"]}
windows = { version = "0.52.0" }

```

`README.md`:

```md
# patternsleuth
A test suite for finding robust patterns used to locate common functions and globals in Unreal Engine games. For use with [UE4SS](https://github.com/UE4SS-RE/RE-UE4SS).

## usage
Drop the game executables into the `games` directory:

```bash
$ tree games
games
├── AstroColony
│   └── AstroColony-Win64-Shipping.exe
├── FSD
│   └── FSD-Win64-Shipping.exe
└── TwinStick
    └── TwinStick-Win64-Shipping.exe
```

Run tests

```bash
$ cargo run --release
```

![tests](https://github.com/trumank/patternsleuth/assets/1144160/0591093c-ea8d-4201-998c-8c6eb4a7fdff)

## acknowledgements
Thanks to,
- [LongerWarrior](https://github.com/LongerWarrior) - for providing a truly massive collection of games to test against as well as finding many very reliable patterns and providing lots of assistance with reversing of more unusual games
- [Narknon](https://github.com/Narknon) - for providing many games as well as clean source builds with symbols
- [FransBouma](https://github.com/FransBouma) - for seeding the project with [UUU](https://opm.fransbouma.com/uuuv5.htm) patterns and many game dumps
- [praydog](https://github.com/praydog) - for inspiration and ideas behind string based symbol resolvers, similar to those used in [UEVR](https://github.com/praydog/UEVR)

```

`examples/dll_hook/Cargo.toml`:

```toml
[package]
name = "dll_hook"
repository.workspace = true
authors.workspace = true
license.workspace = true
version.workspace = true
edition.workspace = true

[lib]
path = "src/lib.rs"
crate-type = ["cdylib"]

[dependencies]
anyhow = { workspace = true }
backtrace = "0.3.69"
bitflags = "2.4.1"
eframe = "0.24.0"
egui-winit = { version = "0.24.0", default-features = false }
indexmap = "2.1.0"
itertools.workspace = true
parking_lot = "0.12.1"
patternsleuth = { path = "../../patternsleuth", features = ["process-internal", "image-pe"] }
regex.workspace = true
retour = { git = "https://github.com/Hpmason/retour-rs", features = ["static-detour"] }
simple-log = "1.6.0"
thread_local = "1.1.7"
widestring = "1.0.2"
windows = { workspace = true, features = [
  "Win32_Foundation",
  "Win32_UI_WindowsAndMessaging",
  "Win32_Security",
  "Win32_System_Kernel",
  "Win32_System_LibraryLoader",
  "Win32_System_Memory",
  "Win32_System_ProcessStatus",
  "Win32_System_SystemServices",
  "Win32_System_Threading",
] }

```

`examples/dll_hook/src/app.rs`:

```rs
use std::path::Path;

use anyhow::Result;
use simple_log::info;

use crate::{globals, ue};

pub fn run(_bin_dir: impl AsRef<Path>) -> Result<()> {
    std::thread::spawn(move || {
        //unsafe { testing(); }
        //gui::run().unwrap();
    });
    Ok(())
}

unsafe fn testing() {
    loop {
        info!("a");
        let objects = globals().guobject_array_unchecked().objects();
        let refs = objects
            .iter()
            .filter(|obj| {
                if let Some(obj) = obj {
                    obj.name_private
                        .to_string()
                        .to_ascii_lowercase()
                        .contains("get")
                } else {
                    false
                }
            })
            .collect::<Vec<_>>();
        for (i, obj) in refs.iter().enumerate() {
            if let Some(obj) = obj {
                let name = obj.name_private.to_string();

                let class = &(*obj.class_private)
                    .ustruct
                    .ufield
                    .uobject
                    .uobject_base_utility
                    .uobject_base
                    .name_private
                    .to_string();

                if class == "Function" {
                    // TODO safe casting
                    let s = &*((*obj as *const _) as *const ue::UStruct);
                    if !s.script.is_empty() {
                        info!("{:x?}", s.script);
                        info!("{i:10} {} {}", class, name.to_string());
                    }
                }
            }
        }
        std::thread::sleep(std::time::Duration::from_millis(1000));
    }
}

```

`examples/dll_hook/src/gui.rs`:

```rs
use std::sync::{mpsc::Receiver, Arc, OnceLock, RwLock};

use eframe::egui;

#[cfg(windows)]
use egui_winit::winit::platform::windows::EventLoopBuilderExtWindows;
#[cfg(unix)]
use egui_winit::winit::platform::x11::EventLoopBuilderExtX11;
use indexmap::IndexMap;

use super::*;

pub fn run() -> Result<(), eframe::Error> {
    let event_loop_builder: Option<eframe::EventLoopBuilderHook> =
        Some(Box::new(|event_loop_builder| {
            event_loop_builder.with_any_thread(true);
        }));
    let options = eframe::NativeOptions {
        event_loop_builder,
        viewport: egui::ViewportBuilder::default().with_inner_size([320.0, 240.0]),
        ..Default::default()
    };
    eframe::run_native(
        "My egui App",
        options,
        Box::new(|_cc| Box::new(MyApp::new())),
    )
}

type ObjectIndex = i32;
#[derive(Debug, Clone)]
struct ObjectCache {
    name: String,
    //weak_ptr: FWeakObjectPtr,
}

#[derive(Debug)]
enum Event {
    CreateUObject(ObjectIndex, ObjectCache),
    DeleteUObject(ObjectIndex),
    KismetMessage {
        message: String,
        verbosity: u8,
        warning_id: ue::FName,
    },
    KismetPrintMessage {
        message: String,
    },
}

#[allow(unused)]
struct Listeners {
    create_uobject: Arc<dyn Fn(&ue::UObjectBase)>,
    delete_uobject: Arc<dyn Fn(&ue::UObjectBase)>,
    kismet_message: Arc<dyn Fn(&widestring::U16CStr, u8, ue::FName)>,
    kismet_print_message: Arc<dyn Fn(&str)>,
}

struct ObjectFilter {
    name_search: String,
}
impl ObjectFilter {
    fn matches(&self, object: &ObjectCache) -> bool {
        if self.name_search.is_empty() {
            true
        } else {
            object.name.to_ascii_lowercase().contains(&self.name_search)
        }
    }
}

#[derive(Default, Clone)]
struct ObjectNameCache {
    names: IndexMap<ObjectIndex, ObjectCache>,
}
impl ObjectNameCache {
    fn get(&self, index: ObjectIndex) -> Option<&ObjectCache> {
        self.names.get(&index)
    }
    fn remove(&mut self, index: ObjectIndex) {
        self.names.remove(&index);
    }
    fn get_or_init<'a>(&'a mut self, object: &ue::UObjectBase) -> &'a ObjectCache {
        self.names
            .entry(object.internal_index)
            .or_insert_with(|| ObjectCache {
                name: object.name_private.to_string(),
            })
    }
}

struct MyApp {
    filter: ObjectFilter,
    filter2: String,
    events: Receiver<Event>,
    listeners: Listeners,
    objects: Arc<RwLock<ObjectNameCache>>,
    filtered: IndexMap<ObjectIndex, ObjectCache>,
    kismet_log: String,
    ctx: Arc<OnceLock<egui::Context>>,
}

macro_rules! move_clone {
    ( ( $($($arg:ident)+$(,)?)* ), $expr:expr) => {
        {
            $( $(
                    let $arg = $arg.clone();
            )*)*
            $expr
        }
    };
}

impl MyApp {
    fn new() -> Self {
        let (tx, events) = std::sync::mpsc::channel();
        let ctx: Arc<OnceLock<egui::Context>> = Default::default();
        let cache: Arc<RwLock<ObjectNameCache>> = Default::default();

        let create_uobject = move_clone!(
            (tx, ctx, cache),
            Arc::new(move |object: &ue::UObjectBase| {
                //info!("before create_uobject");
                cache.write().unwrap().get_or_init(object);
                tx.send(Event::CreateUObject(
                    object.internal_index,
                    ObjectCache {
                        name: object.name_private.to_string(),
                    },
                ))
                .unwrap();
                if let Some(ctx) = ctx.get() {
                    ctx.request_repaint();
                }
            })
        );

        let delete_uobject = move_clone!(
            (tx, ctx, cache),
            Arc::new(move |object: &ue::UObjectBase| {
                //info!("before delete_uobject");
                cache.write().unwrap().remove(object.internal_index);
                tx.send(Event::DeleteUObject(object.internal_index))
                    .unwrap();
                if let Some(ctx) = ctx.get() {
                    ctx.request_repaint();
                }
            })
        );
        let kismet_message = move_clone!(
            (tx, ctx),
            Arc::new(
                move |message: &widestring::U16CStr, verbosity: u8, warning_id: ue::FName| {
                    tx.send(Event::KismetMessage {
                        message: message.to_string().unwrap(),
                        verbosity,
                        warning_id,
                    })
                    .unwrap();
                    if let Some(ctx) = ctx.get() {
                        ctx.request_repaint();
                    }
                },
            )
        );
        let txc = tx.clone();
        let kismet_print = Arc::new(move |message: &str| {
            txc.send(Event::KismetPrintMessage {
                message: message.into(),
            })
            .unwrap();
        });
        Self {
            filter: ObjectFilter {
                name_search: "".into(),
            },
            filter2: String::new(),
            events,
            listeners: Listeners {
                create_uobject: hooks::create_uobject::register(create_uobject),
                delete_uobject: hooks::delete_uobject::register(delete_uobject),
                kismet_message: hooks::kismet_execution_message::register(kismet_message),
                kismet_print_message: hooks::kismet_print_message::register(kismet_print),
            },
            objects: cache,
            filtered: Default::default(),
            kismet_log: "".into(),
            ctx,
        }
    }
}

impl eframe::App for MyApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        //let object_lock = guobject_array();

        self.ctx.get_or_init(|| ctx.clone());

        for event in self.events.try_iter() {
            match event {
                Event::CreateUObject(index, object) => {
                    if self.filter.matches(&object) {
                        self.filtered.insert(index, object.clone());
                    }
                }
                Event::DeleteUObject(index) => {
                    self.filtered.remove(&index);
                }
                Event::KismetMessage {
                    message,
                    verbosity: _,
                    warning_id: _,
                } => {
                    self.kismet_log.push_str(&format!("Kismet VM: {message}\n"));
                }
                Event::KismetPrintMessage { message } => {
                    self.kismet_log
                        .push_str(&format!("PrintString: {message}\n"));
                }
            };
        }

        ctx.set_visuals(egui::Visuals::dark());

        egui::CentralPanel::default().show(ctx, |ui| {
            ui.heading("My egui Application");

            ui.horizontal(|ui| {
                let name_label = ui.label("Search: ");
                let res = ui
                    .text_edit_singleline(&mut self.filter.name_search)
                    .labelled_by(name_label.id);
                if res.changed() {
                    self.filtered = self
                        .objects
                        .read()
                        .unwrap()
                        .names
                        .iter()
                        .filter_map(|(index, obj)| {
                            if self.filter.matches(obj) {
                                Some((*index, obj.clone()))
                            } else {
                                None
                            }
                        })
                        .collect::<IndexMap<_, _>>();
                }
            });

            let text_style = egui::TextStyle::Body;
            let row_height = ui.text_style_height(&text_style);

            egui::ScrollArea::vertical().show_rows(
                ui,
                row_height,
                self.filtered.len(),
                |ui, row_range| {
                    for (i, obj) in self
                        .filtered
                        .iter()
                        .skip(row_range.start)
                        .take(row_range.len())
                    {
                        ui.label(format!("{i:10} {}", obj.name));
                    }
                    ui.allocate_space(ui.available_size());
                },
            );

            egui::Window::new("object search 2")
                .default_height(500.)
                .show(ctx, |ui| {
                    let name_label = ui.label("Search: ");
                    let _res = ui
                        .text_edit_singleline(&mut self.filter2)
                        .labelled_by(name_label.id);

                    let text_style = egui::TextStyle::Body;
                    let row_height = ui.text_style_height(&text_style);

                    //info!("before names lock");
                    let objects = unsafe { globals().guobject_array_unchecked() }.objects();
                    let mut names = self.objects.write().unwrap();

                    //info!("before filter");
                    let filtered = objects
                        .iter()
                        //.take(100)
                        .flatten()
                        .filter(|obj| {
                            let cached = &names.get_or_init(obj);
                            cached.name.contains(&self.filter2)
                        })
                        .collect::<Vec<_>>();
                    //let filtered = vec!["h"];

                    //info!("before print");
                    egui::ScrollArea::vertical().show_rows(
                        ui,
                        row_height,
                        filtered.len(),
                        |ui, row_range| {
                            for (i, obj) in filtered
                                .iter()
                                .enumerate()
                                .skip(row_range.start)
                                .take(row_range.len())
                            {
                                ui.label(format!(
                                    "{i:10} {}",
                                    names.get(obj.internal_index).unwrap().name
                                ));
                            }
                            ui.allocate_space(ui.available_size());
                        },
                    );
                });

            let _log_window = |name: &str, mut log: &str| {
                egui::Window::new(name)
                    .default_height(500.)
                    .show(ctx, |ui| {
                        egui::ScrollArea::vertical()
                            .stick_to_bottom(true)
                            .show(ui, |ui| {
                                ui.add(
                                    egui::TextEdit::multiline(&mut log)
                                        .desired_width(f32::INFINITY)
                                        .desired_rows(10)
                                        .font(egui::TextStyle::Monospace),
                                );
                            });
                    });
            };

            //log_window("Kismet Messages", &self.kismet_log);
        });
    }
}

```

`examples/dll_hook/src/hooks.rs`:

```rs
use std::{
    ffi::c_void,
    sync::{Arc, LazyLock, Mutex, Weak},
};

use anyhow::Result;

use crate::{assert_main_thread, globals, object_cache, ue};

retour::static_detour! {
    static HookUGameEngineTick: unsafe extern "system" fn(*mut c_void, f32, u8);
    static HookFEngineLoopInit: unsafe extern "system" fn(*mut c_void);
    static HookAllocateUObject: unsafe extern "system" fn(*mut c_void, *const ue::UObjectBase, bool);
    static HookFreeUObject: unsafe extern "system" fn(*mut ue::UObjectBase, *const c_void); // inlined into UObject dtor so args are messed up
    static HookKismetPrintString: unsafe extern "system" fn(*mut ue::UObjectBase, *mut ue::kismet::FFrame, *mut c_void);
    static HookKismetExecutionMessage: unsafe extern "system" fn(*const u16, u8, ue::FName);
    static HookUFunctionBind: unsafe extern "system" fn(*mut ue::UFunction);
}

macro_rules! event {
    ($name:ident ( $($($arg_name:ident: $arg_ty:ty)+$(,)?)* ) ) => {
        pub mod $name {
            use super::*;

            pub type Listener = dyn Fn( $($($arg_ty,)*)* ) + Send + Sync;
            fn get() -> &'static Mutex<Vec<Weak<Listener>>> {
                static OBJECTS: LazyLock<Mutex<Vec<Weak<Listener>>>> = LazyLock::new(|| Default::default());
                &*OBJECTS
            }
            pub fn register(listener: Arc<Listener>) -> Arc<Listener> {
                get().lock().unwrap().push(Arc::downgrade(&listener));
                listener
            }
            pub fn call( $($($arg_name: $arg_ty,)*)* ) {
                get().lock().unwrap().retain(|f| {
                    if let Some(f) = f.upgrade() {
                        f( $($($arg_name,)*)* );
                        true
                    } else {
                        false
                    }
                });
            }
        }
    };
}

event!(create_uobject(/*uobject_array: &UObjectLock,*/ object: &ue::UObjectBase));
event!(delete_uobject(/*uobject_array: &UObjectLock,*/ object: &ue::UObjectBase));
event!(kismet_execution_message(message: &widestring::U16CStr, verbosity: u8, warning_id: ue::FName));
event!(kismet_print_message(message: &str));

pub type UObjectLock = parking_lot::FairMutexGuard<'static, &'static ue::FUObjectArray>;
static mut GUOBJECT_LOCK: Option<UObjectLock> = None;

pub unsafe fn initialize() -> Result<()> {
    assert_main_thread!();

    GUOBJECT_LOCK = Some(globals().guobject_array());

    HookFEngineLoopInit.initialize(
        std::mem::transmute(globals().resolution.engine_loop_init.0),
        move |engine_loop| {
            assert_main_thread!();

            HookFEngineLoopInit.call(engine_loop);
            simple_log::info!("ENGINE LOOP INIT");
        },
    )?;
    HookFEngineLoopInit.enable()?;

    HookUGameEngineTick.initialize(
        std::mem::transmute(globals().resolution.game_tick.0),
        move |game_engine, delta_seconds, idle_mode| {
            assert_main_thread!();

            //info!("tick time={:0.5}", delta_seconds);

            GUOBJECT_LOCK.take();
            HookUGameEngineTick.call(game_engine, delta_seconds, idle_mode);
            GUOBJECT_LOCK = Some(globals().guobject_array());
        },
    )?;
    HookUGameEngineTick.enable()?;

    HookAllocateUObject.initialize(
        std::mem::transmute(globals().resolution.allocate_uobject.0),
        |this, object, merging_threads| {
            //assert_main_thread!();

            //info!("allocate uobject {:?}", object);

            HookAllocateUObject.call(this, object, merging_threads);

            object_cache::object_created(&*object);
            create_uobject::call(/*GUOBJECT_LOCK.as_ref().unwrap(),*/ &*object);
        },
    )?;
    HookAllocateUObject.enable()?;

    HookFreeUObject.initialize(
        std::mem::transmute(globals().resolution.free_uobject.0),
        |this, object| {
            //assert_main_thread!();

            //info!("delete uobject {:?}", object);

            object_cache::object_deleted(&*this);
            delete_uobject::call(/*GUOBJECT_LOCK.as_ref().unwrap(),*/ &*this);

            HookFreeUObject.call(this, object);
        },
    )?;
    HookFreeUObject.enable()?;

    HookKismetPrintString.initialize(
        std::mem::transmute(
            *globals()
                .resolution
                .kismet_system_library
                .0
                .get("PrintString")
                .unwrap(),
        ),
        |_context, stack, _result| {
            let stack = &mut *stack;

            let mut ctx: Option<&ue::UObject> = None;
            let mut string = ue::FString::default();
            let mut print_to_screen = false;
            let mut print_to_log = false;
            let mut color = ue::FLinearColor::default();
            let mut duration = 0f32;

            ue::kismet::arg(stack, &mut ctx);
            ue::kismet::arg(stack, &mut string);
            ue::kismet::arg(stack, &mut print_to_screen);
            ue::kismet::arg(stack, &mut print_to_log);
            ue::kismet::arg(stack, &mut color);
            ue::kismet::arg(stack, &mut duration);

            //let s = string.to_string();
            //info!("PrintString({s:?})");
            kismet_print_message::call(&string.to_string());

            if !stack.code.is_null() {
                stack.code = stack.code.add(1);
            }
        },
    )?;
    HookKismetPrintString.enable()?;

    HookKismetExecutionMessage.initialize(
        std::mem::transmute(globals().resolution.fframe_kismet_execution_message.0),
        |message, verbosity, warning_id| {
            kismet_execution_message::call(
                widestring::U16CStr::from_ptr_str(message),
                verbosity,
                warning_id,
            );
            HookKismetExecutionMessage.call(message, verbosity, warning_id);
        },
    )?;
    HookKismetExecutionMessage.enable()?;

    type ExecFn = unsafe extern "system" fn(*mut ue::UObject, *mut ue::kismet::FFrame, *mut c_void);

    let hooks = [
        (
            "/Game/_AssemblyStorm/TestMod/BPL_NativeTest.BPL_NativeTest_C:Do Stuff",
            do_stuff as ExecFn,
        ),
        (
            "/Game/_AssemblyStorm/TestMod/BPL_NativeTest.BPL_NativeTest_C:Regex",
            exec_regex as ExecFn,
        ),
    ]
    .into_iter()
    .collect::<std::collections::HashMap<_, ExecFn>>();

    HookUFunctionBind.initialize(
        std::mem::transmute(globals().resolution.ufunction_bind.0),
        move |function| {
            HookUFunctionBind.call(function);
            if let Some(function) = function.as_mut() {
                let path = function
                    .ustruct
                    .ufield
                    .uobject
                    .uobject_base_utility
                    .uobject_base
                    .get_path_name(None);
                if let Some(hook) = hooks.get(path.as_str()) {
                    simple_log::info!(
                        "UFunction::Bind({path}) func = {:?} flags = {:?}",
                        function.func,
                        function.function_flags
                    );
                    function
                        .function_flags
                        .insert(ue::EFunctionFlags::FUNC_Native | ue::EFunctionFlags::FUNC_Final);
                    function.func = *hook;
                }
            }
        },
    )?;
    HookUFunctionBind.enable()?;

    Ok(())
}

unsafe extern "system" fn do_stuff(
    _context: *mut ue::UObject,
    stack: *mut ue::kismet::FFrame,
    _result: *mut c_void,
) {
    let stack = stack.as_mut().unwrap();
    let mut ctx: Option<&ue::UObject> = None;
    ue::kismet::arg(stack, &mut ctx);

    simple_log::info!("doing stuff!!");

    stack.code = stack.code.add(1);
}

unsafe extern "system" fn exec_regex(
    _context: *mut ue::UObject,
    stack: *mut ue::kismet::FFrame,
    _result: *mut c_void,
) {
    let stack = stack.as_mut().unwrap();

    let mut ctx: Option<&ue::UObject> = None;
    let mut regex = ue::FString::default();
    let mut input = ue::FString::default();
    let mut matches: ue::TArray<ue::FString> = Default::default();

    ue::kismet::arg(stack, &mut regex);
    ue::kismet::arg(stack, &mut input);
    ue::kismet::arg(stack, &mut ctx);
    ue::kismet::arg(stack, &mut matches);
    let matches_address = (stack.most_recent_property_address as *mut ue::TArray<ue::FString>)
        .as_mut()
        .unwrap();

    matches_address.clear();
    if let Ok(re) = regex::Regex::new(&regex.to_string()) {
        for cap in re.captures(&input.to_string()).iter() {
            for cap in cap.iter() {
                let new_str = ue::FString::from(
                    widestring::U16CString::from_str(
                        cap.as_ref().map(|m| m.as_str()).unwrap_or_default(),
                    )
                    .unwrap()
                    .as_slice_with_nul(),
                );
                matches_address.push(new_str);
            }
        }
    }

    std::mem::forget(matches);

    stack.code = stack.code.add(1);
}

```

`examples/dll_hook/src/lib.rs`:

```rs
#![feature(backtrace_frames)]

mod app;
mod gui;
mod hooks;
mod object_cache;
mod ue;

use std::path::PathBuf;

use anyhow::{anyhow, Context, Result};
use patternsleuth::resolvers::impl_try_collector;
use patternsleuth::resolvers::unreal::blueprint_library::UFunctionBind;
use patternsleuth::resolvers::unreal::UObjectBaseUtilityGetPathName;
use patternsleuth::resolvers::unreal::{
    fname::FNameToString,
    game_loop::{FEngineLoopInit, UGameEngineTick},
    gmalloc::GMalloc,
    guobject_array::{
        FUObjectArrayAllocateUObjectIndex, FUObjectArrayFreeUObjectIndex, GUObjectArray,
    },
    kismet::{FFrameStep, FFrameStepExplicitProperty, FFrameStepViaExec},
    KismetSystemLibrary,
};
use simple_log::{error, info, LogConfigBuilder};
use windows::Win32::{
    Foundation::HMODULE,
    System::{
        SystemServices::*,
        Threading::{GetCurrentThread, QueueUserAPC},
    },
};

// x3daudio1_7.dll
#[no_mangle]
#[allow(non_snake_case, unused_variables)]
extern "system" fn X3DAudioCalculate() {}
#[no_mangle]
#[allow(non_snake_case, unused_variables)]
extern "system" fn X3DAudioInitialize() {}

// d3d9.dll
#[no_mangle]
#[allow(non_snake_case, unused_variables)]
extern "system" fn D3DPERF_EndEvent() {}
#[no_mangle]
#[allow(non_snake_case, unused_variables)]
extern "system" fn D3DPERF_BeginEvent() {}

// d3d11.dll
#[no_mangle]
#[allow(non_snake_case, unused_variables)]
extern "system" fn D3D11CreateDevice() {}

// dxgi.dll
#[no_mangle]
#[allow(non_snake_case, unused_variables)]
extern "system" fn CreateDXGIFactory() {}
#[no_mangle]
#[allow(non_snake_case, unused_variables)]
extern "system" fn CreateDXGIFactory1() {}

#[no_mangle]
#[allow(non_snake_case, unused_variables)]
extern "system" fn DllMain(dll_module: HMODULE, call_reason: u32, _: *mut ()) -> bool {
    unsafe {
        match call_reason {
            DLL_PROCESS_ATTACH => {
                QueueUserAPC(Some(init), GetCurrentThread(), 0);
            }
            DLL_PROCESS_DETACH => (),
            _ => (),
        }

        true
    }
}

unsafe extern "system" fn init(_: usize) {
    if let Ok(bin_dir) = setup() {
        info!("dll_hook loaded",);

        if let Err(e) = patch(bin_dir) {
            error!("{e:#}");
        }
    }
}

fn setup() -> Result<PathBuf> {
    let exe_path = std::env::current_exe()?;
    let bin_dir = exe_path.parent().context("could not find exe parent dir")?;
    let config = LogConfigBuilder::builder()
        .path(bin_dir.join("dll_hook.txt").to_str().unwrap()) // TODO why does this not take a path??
        .time_format("%Y-%m-%d %H:%M:%S.%f")
        .level("debug")
        .output_file()
        .size(u64::MAX)
        .build();
    simple_log::new(config).map_err(|e| anyhow!("{e}"))?;
    Ok(bin_dir.to_path_buf())
}

#[derive(Debug, PartialEq)]
pub struct FFrameKismetExecutionMessage(usize);

mod resolvers {
    use super::*;

    use patternsleuth::{
        resolvers::{futures::future::join_all, *},
        scanner::Pattern,
    };

    impl_resolver_singleton!(collect, FFrameKismetExecutionMessage);
    impl_resolver_singleton!(PEImage, FFrameKismetExecutionMessage, |ctx| async {
        // void FFrame::KismetExecutionMessage(wchar16 const* Message, enum ELogVerbosity::Type Verbosity, class FName WarningId)
        let patterns = ["48 89 5C 24 ?? 57 48 83 EC 40 0F B6 DA 48 8B F9"];
        let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;
        Ok(Self(ensure_one(res.into_iter().flatten())?))
    });
}

impl_try_collector! {
    #[derive(Debug, PartialEq, Clone)]
    struct DllHookResolution {
        gmalloc: GMalloc,
        guobject_array: GUObjectArray,
        fnametostring: FNameToString,
        allocate_uobject: FUObjectArrayAllocateUObjectIndex,
        free_uobject: FUObjectArrayFreeUObjectIndex,
        game_tick: UGameEngineTick,
        engine_loop_init: FEngineLoopInit,
        kismet_system_library: KismetSystemLibrary,
        fframe_step_via_exec: FFrameStepViaExec,
        fframe_step: FFrameStep,
        fframe_step_explicit_property: FFrameStepExplicitProperty,
        fframe_kismet_execution_message: FFrameKismetExecutionMessage,
        ufunction_bind: UFunctionBind,
        uobject_base_utility_get_path_name: UObjectBaseUtilityGetPathName,
    }
}

static mut GLOBALS: Option<Globals> = None;

pub struct Globals {
    resolution: DllHookResolution,
    guobject_array: parking_lot::FairMutex<&'static ue::FUObjectArray>,
    main_thread_id: std::thread::ThreadId,
}

impl Globals {
    pub fn gmalloc(&self) -> &ue::FMalloc {
        unsafe { &**(self.resolution.gmalloc.0 as *const *const ue::FMalloc) }
    }
    pub fn fframe_step(&self) -> ue::FnFFrameStep {
        unsafe { std::mem::transmute(self.resolution.fframe_step.0) }
    }
    pub fn fframe_step_explicit_property(&self) -> ue::FnFFrameStepExplicitProperty {
        unsafe { std::mem::transmute(self.resolution.fframe_step_explicit_property.0) }
    }
    pub fn fname_to_string(&self) -> ue::FnFNameToString {
        unsafe { std::mem::transmute(self.resolution.fnametostring.0) }
    }
    pub fn uobject_base_utility_get_path_name(&self) -> ue::FnUObjectBaseUtilityGetPathName {
        unsafe { std::mem::transmute(self.resolution.uobject_base_utility_get_path_name.0) }
    }
    pub fn guobject_array(&self) -> parking_lot::FairMutexGuard<'static, &ue::FUObjectArray> {
        self.guobject_array.lock()
    }
    pub unsafe fn guobject_array_unchecked(&self) -> &ue::FUObjectArray {
        *self.guobject_array.data_ptr()
    }
}

pub fn globals() -> &'static Globals {
    unsafe { GLOBALS.as_ref().unwrap() }
}

#[macro_export]
macro_rules! assert_main_thread {
    () => {
        assert_eq!(std::thread::current().id(), globals().main_thread_id);
    };
}

fn dump_backtrace() {
    info!(
        "Dumping backtrace on thread {:?}:",
        std::thread::current().id()
    );
    let backtrace = backtrace::Backtrace::new();
    for (index, frame) in backtrace.frames().iter().enumerate() {
        info!("  {index}: {:?} {:?}", frame.ip(), frame.symbols());
    }
}

unsafe fn patch(bin_dir: PathBuf) -> Result<()> {
    let exe = patternsleuth::process::internal::read_image()?;

    info!("starting scan");
    let resolution = exe.resolve(DllHookResolution::resolver())?;
    info!("finished scan");

    info!("results: {:?}", resolution);

    let guobject_array: &'static ue::FUObjectArray =
        &*(resolution.guobject_array.0 as *const ue::FUObjectArray);

    GLOBALS = Some(Globals {
        guobject_array: guobject_array.into(),
        resolution,
        main_thread_id: std::thread::current().id(),
    });

    hooks::initialize()?;

    info!("initialized");

    app::run(bin_dir)
}

```

`examples/dll_hook/src/object_cache.rs`:

```rs
use std::{
    collections::HashMap,
    sync::{Mutex, OnceLock},
};

use crate::ue;

type InternalIndex = i32;
type Objects = HashMap<InternalIndex, ObjectProxy>;

fn objects() -> &'static Mutex<Objects> {
    static OBJECTS: OnceLock<Mutex<Objects>> = OnceLock::new();
    OBJECTS.get_or_init(Default::default)
}

// call from main thread
pub fn object_created(object: &ue::UObjectBase) {
    let proxy = ObjectProxy {
        name: object.name_private.to_string(),
    };
    objects()
        .lock()
        .unwrap()
        .insert(object.internal_index, proxy);
}
// call from main thread
pub fn object_deleted(object: &ue::UObjectBase) {
    objects().lock().unwrap().remove(&object.internal_index);
}

#[derive(Debug)]
struct ObjectProxy {
    name: String,
}

```

`examples/dll_hook/src/ue.rs`:

```rs
use std::{
    cell::UnsafeCell,
    ffi::c_void,
    fmt::Display,
    ops::{Deref, DerefMut},
};

use windows::Win32::System::Threading::{
    EnterCriticalSection, LeaveCriticalSection, CRITICAL_SECTION,
};

use crate::globals;

pub type FnFFrameStep =
    unsafe extern "system" fn(stack: &mut kismet::FFrame, *mut UObject, result: *mut c_void);
pub type FnFFrameStepExplicitProperty = unsafe extern "system" fn(
    stack: &mut kismet::FFrame,
    result: *mut c_void,
    property: *const FProperty,
);

pub type FnFNameToString = unsafe extern "system" fn(&FName, &mut FString);
impl Display for FName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut string = FString::new();
        unsafe {
            (globals().fname_to_string())(self, &mut string);
        };
        write!(f, "{string}")
    }
}

pub type FnUObjectBaseUtilityGetPathName =
    unsafe extern "system" fn(&UObjectBase, Option<&UObject>, &mut FString);
impl UObjectBase {
    pub fn get_path_name(&self, stop_outer: Option<&UObject>) -> String {
        let mut string = FString::new();
        unsafe {
            (globals().uobject_base_utility_get_path_name())(self, stop_outer, &mut string);
        }
        string.to_string()
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct FMalloc {
    vtable: *const FMallocVTable,
}
unsafe impl Sync for FMalloc {}
unsafe impl Send for FMalloc {}
impl FMalloc {
    pub fn malloc(&self, count: usize, alignment: u32) -> *mut c_void {
        unsafe { ((*self.vtable).malloc)(self, count, alignment) }
    }
    pub fn realloc(&self, original: *mut c_void, count: usize, alignment: u32) -> *mut c_void {
        unsafe { ((*self.vtable).realloc)(self, original, count, alignment) }
    }
    pub fn free(&self, original: *mut c_void) {
        unsafe { ((*self.vtable).free)(self, original) }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct FMallocVTable {
    pub __vec_del_dtor: *const (),
    pub exec: *const (),
    pub malloc:
        unsafe extern "system" fn(this: &FMalloc, count: usize, alignment: u32) -> *mut c_void,
    pub try_malloc:
        unsafe extern "system" fn(this: &FMalloc, count: usize, alignment: u32) -> *mut c_void,
    pub realloc: unsafe extern "system" fn(
        this: &FMalloc,
        original: *mut c_void,
        count: usize,
        alignment: u32,
    ) -> *mut c_void,
    pub try_realloc: unsafe extern "system" fn(
        this: &FMalloc,
        original: *mut c_void,
        count: usize,
        alignment: u32,
    ) -> *mut c_void,
    pub free: unsafe extern "system" fn(this: &FMalloc, original: *mut c_void),
    pub quantize_size: *const (),
    pub get_allocation_size: *const (),
    pub trim: *const (),
    pub setup_tls_caches_on_current_thread: *const (),
    pub clear_and_disable_tlscaches_on_current_thread: *const (),
    pub initialize_stats_metadata: *const (),
    pub update_stats: *const (),
    pub get_allocator_stats: *const (),
    pub dump_allocator_stats: *const (),
    pub is_internally_thread_safe: *const (),
    pub validate_heap: *const (),
    pub get_descriptive_name: *const (),
}

#[derive(Debug)]
#[repr(C)]
pub struct FWindowsCriticalSection(UnsafeCell<CRITICAL_SECTION>);
impl FWindowsCriticalSection {
    fn crit_ptr_mut(&self) -> *mut CRITICAL_SECTION {
        &self.0 as *const _ as *mut _
    }
    unsafe fn lock(&self) {
        simple_log::info!("LOCKING objects");
        EnterCriticalSection(self.crit_ptr_mut());
    }
    unsafe fn unlock(&self) {
        simple_log::info!("UNLOCKING objects");
        LeaveCriticalSection(self.crit_ptr_mut());
    }
}

pub struct CriticalSectionGuard<'crit, 'data, T: ?Sized + 'data> {
    critical_section: &'crit FWindowsCriticalSection,
    data: &'data UnsafeCell<T>,
}
impl<'crit, 'data, T: ?Sized> CriticalSectionGuard<'crit, 'data, T> {
    fn lock(critical_section: &'crit FWindowsCriticalSection, data: &'data UnsafeCell<T>) -> Self {
        unsafe {
            critical_section.lock();
        }
        Self {
            critical_section,
            data,
        }
    }
}
impl<T: ?Sized> Drop for CriticalSectionGuard<'_, '_, T> {
    fn drop(&mut self) {
        unsafe { self.critical_section.unlock() }
    }
}
impl<T: ?Sized> Deref for CriticalSectionGuard<'_, '_, T> {
    type Target = T;

    fn deref(&self) -> &T {
        unsafe { &*self.data.get() }
    }
}
impl<T: ?Sized> DerefMut for CriticalSectionGuard<'_, '_, T> {
    fn deref_mut(&mut self) -> &mut T {
        unsafe { &mut *self.data.get() }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct FUObjectCreateListener;

#[derive(Debug)]
#[repr(C)]
pub struct FUObjectDeleteListener;

type ObjectIndex = i32;

#[derive(Debug)]
#[repr(C)]
pub struct FUObjectArray {
    obj_first_gcindex: i32,
    obj_last_non_gcindex: i32,
    max_objects_not_considered_by_gc: i32,
    open_for_disregard_for_gc: bool,

    obj_objects: UnsafeCell<FChunkedFixedUObjectArray>,
    obj_objects_critical: FWindowsCriticalSection,
    obj_available_list: [u8; 0x88],
    uobject_create_listeners: TArray<*const FUObjectCreateListener>,
    uobject_delete_listeners: TArray<*const FUObjectDeleteListener>,
    uobject_delete_listeners_critical: FWindowsCriticalSection,
    master_serial_number: std::sync::atomic::AtomicI32,
}
impl FUObjectArray {
    pub fn objects(&self) -> CriticalSectionGuard<'_, '_, FChunkedFixedUObjectArray> {
        CriticalSectionGuard::lock(&self.obj_objects_critical, &self.obj_objects)
    }
    pub fn allocate_serial_number(&self, index: ObjectIndex) -> i32 {
        use std::sync::atomic::Ordering;

        let objects = unsafe { &*self.obj_objects.get() };
        let item = objects.item(index);

        let current = item.serial_number.load(Ordering::SeqCst);
        if current != 0 {
            current
        } else {
            let new = self.master_serial_number.fetch_add(1, Ordering::SeqCst);

            let exchange =
                item.serial_number
                    .compare_exchange(0, new, Ordering::SeqCst, Ordering::SeqCst);
            match exchange {
                Ok(_) => new,
                Err(old) => old,
            }
        }
    }
}

pub struct ObjectIterator<'a> {
    array: &'a FChunkedFixedUObjectArray,
    index: i32,
}
impl<'a> Iterator for ObjectIterator<'a> {
    type Item = Option<&'a UObjectBase>;
    fn size_hint(&self) -> (usize, Option<usize>) {
        let size = self.array.num_elements as usize;
        (size, Some(size))
    }
    fn nth(&mut self, n: usize) -> Option<Self::Item> {
        let n = n as i32;
        if self.index < n {
            self.index = n;
        }
        self.next()
    }
    fn next(&mut self) -> Option<Option<&'a UObjectBase>> {
        if self.index >= self.array.num_elements {
            None
        } else {
            let obj = unsafe { self.array.item(self.index).object.as_ref() };

            self.index += 1;
            Some(obj)
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct FChunkedFixedUObjectArray {
    pub objects: *const *const FUObjectItem,
    pub pre_allocated_objects: *const FUObjectItem,
    pub max_elements: i32,
    pub num_elements: i32,
    pub max_chunks: i32,
    pub num_chunks: i32,
}
impl FChunkedFixedUObjectArray {
    pub fn iter(&self) -> ObjectIterator<'_> {
        ObjectIterator {
            array: self,
            index: 0,
        }
    }
    fn item_ptr(&self, index: ObjectIndex) -> *const FUObjectItem {
        let per_chunk = self.max_elements / self.max_chunks;

        unsafe {
            (*self.objects.add((index / per_chunk) as usize)).add((index % per_chunk) as usize)
        }
    }
    fn item(&self, index: ObjectIndex) -> &FUObjectItem {
        unsafe { &*self.item_ptr(index) }
    }
    fn item_mut(&mut self, index: ObjectIndex) -> &mut FUObjectItem {
        unsafe { &mut *(self.item_ptr(index) as *mut FUObjectItem) }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct FUObjectItem {
    pub object: *const UObjectBase,
    pub flags: i32,
    pub cluster_root_index: i32,
    pub serial_number: std::sync::atomic::AtomicI32,
}

#[derive(Debug, Clone, Copy)]
#[repr(C)]
pub struct FWeakObjectPtr {
    object_index: i32,
    object_serial_number: i32,
}
impl FWeakObjectPtr {
    pub fn new(object: &UObjectBase) -> Self {
        Self::new_from_index(object.internal_index)
    }
    pub fn new_from_index(index: ObjectIndex) -> Self {
        Self {
            object_index: index,
            // serial allocation performs only atomic operations
            object_serial_number: unsafe {
                globals()
                    .guobject_array_unchecked()
                    .allocate_serial_number(index)
            },
        }
    }
    pub fn get(&self, object_array: &FUObjectArray) -> Option<&UObjectBase> {
        // TODO check valid
        unsafe {
            let objects = &*object_array.obj_objects.get();
            let item = objects.item(self.object_index);
            Some(&*item.object)
        }
    }
}

bitflags::bitflags! {
    #[derive(Debug, Clone)]
    pub struct EObjectFlags: u32 {
        const RF_NoFlags = 0x0000;
        const RF_Public = 0x0001;
        const RF_Standalone = 0x0002;
        const RF_MarkAsNative = 0x0004;
        const RF_Transactional = 0x0008;
        const RF_ClassDefaultObject = 0x0010;
        const RF_ArchetypeObject = 0x0020;
        const RF_Transient = 0x0040;
        const RF_MarkAsRootSet = 0x0080;
        const RF_TagGarbageTemp = 0x0100;
        const RF_NeedInitialization = 0x0200;
        const RF_NeedLoad = 0x0400;
        const RF_KeepForCooker = 0x0800;
        const RF_NeedPostLoad = 0x1000;
        const RF_NeedPostLoadSubobjects = 0x2000;
        const RF_NewerVersionExists = 0x4000;
        const RF_BeginDestroyed = 0x8000;
        const RF_FinishDestroyed = 0x00010000;
        const RF_BeingRegenerated = 0x00020000;
        const RF_DefaultSubObject = 0x00040000;
        const RF_WasLoaded = 0x00080000;
        const RF_TextExportTransient = 0x00100000;
        const RF_LoadCompleted = 0x00200000;
        const RF_InheritableComponentTemplate = 0x00400000;
        const RF_DuplicateTransient = 0x00800000;
        const RF_StrongRefOnFrame = 0x01000000;
        const RF_NonPIEDuplicateTransient = 0x02000000;
        const RF_Dynamic = 0x04000000;
        const RF_WillBeLoaded = 0x08000000;
    }
}
bitflags::bitflags! {
    #[derive(Debug, Clone)]
    pub struct EFunctionFlags: u32 {
        const FUNC_None = 0x0000;
        const FUNC_Final = 0x0001;
        const FUNC_RequiredAPI = 0x0002;
        const FUNC_BlueprintAuthorityOnly = 0x0004;
        const FUNC_BlueprintCosmetic = 0x0008;
        const FUNC_Net = 0x0040;
        const FUNC_NetReliable = 0x0080;
        const FUNC_NetRequest = 0x0100;
        const FUNC_Exec = 0x0200;
        const FUNC_Native = 0x0400;
        const FUNC_Event = 0x0800;
        const FUNC_NetResponse = 0x1000;
        const FUNC_Static = 0x2000;
        const FUNC_NetMulticast = 0x4000;
        const FUNC_UbergraphFunction = 0x8000;
        const FUNC_MulticastDelegate = 0x00010000;
        const FUNC_Public = 0x00020000;
        const FUNC_Private = 0x00040000;
        const FUNC_Protected = 0x00080000;
        const FUNC_Delegate = 0x00100000;
        const FUNC_NetServer = 0x00200000;
        const FUNC_HasOutParms = 0x00400000;
        const FUNC_HasDefaults = 0x00800000;
        const FUNC_NetClient = 0x01000000;
        const FUNC_DLLImport = 0x02000000;
        const FUNC_BlueprintCallable = 0x04000000;
        const FUNC_BlueprintEvent = 0x08000000;
        const FUNC_BlueprintPure = 0x10000000;
        const FUNC_EditorOnly = 0x20000000;
        const FUNC_Const = 0x40000000;
        const FUNC_NetValidate = 0x80000000;
        const FUNC_AllFlags = 0xffffffff;
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct UObjectBase {
    pub vtable: *const c_void,
    pub object_flags: EObjectFlags,
    pub internal_index: i32,
    pub class_private: *const UClass,
    pub name_private: FName,
    pub outer_private: *const UObject,
}

#[derive(Debug)]
#[repr(C)]
pub struct UObjectBaseUtility {
    pub uobject_base: UObjectBase,
}

#[derive(Debug)]
#[repr(C)]
pub struct UObject {
    pub uobject_base_utility: UObjectBaseUtility,
}

#[derive(Debug)]
#[repr(C)]
struct FOutputDevice {
    vtable: *const c_void,
    b_suppress_event_tag: bool,
    b_auto_emit_line_terminator: bool,
}

#[derive(Debug)]
#[repr(C)]
pub struct UField {
    pub uobject: UObject,
    pub next: *const UField,
}

#[derive(Debug)]
#[repr(C)]
pub struct FStructBaseChain {
    pub struct_base_chain_array: *const *const FStructBaseChain,
    pub num_struct_bases_in_chain_minus_one: i32,
}

#[derive(Debug)]
#[repr(C)]
struct FFieldClass {
    // TODO
    name: FName,
}

#[derive(Debug)]
#[repr(C)]
struct FFieldVariant {
    container: *const c_void,
    b_is_uobject: bool,
}

#[derive(Debug)]
#[repr(C)]
pub struct FField {
    class_private: *const FFieldClass,
    owner: FFieldVariant,
    next: *const FField,
    name_private: FName,
    flags_private: EObjectFlags,
}

pub struct FProperty {
    // TODO
}

#[derive(Debug)]
#[repr(C)]
pub struct UStruct {
    pub ufield: UField,
    pub fstruct_base_chain: FStructBaseChain,
    pub super_struct: *const UStruct,
    pub children: *const UField,
    pub child_properties: *const FField,
    pub properties_size: i32,
    pub min_alignment: i32,
    pub script: TArray<u8>,
    pub property_link: *const FProperty,
    pub ref_link: *const FProperty,
    pub destructor_link: *const FProperty,
    pub post_construct_link: *const FProperty,
    pub script_and_property_object_references: TArray<*const UObject>,
    pub unresolved_script_properties: *const (), //TODO pub TArray<TTuple<TFieldPath<FField>,int>,TSizedDefaultAllocator<32> >*
    pub unversioned_schema: *const (),           //TODO const FUnversionedStructSchema*
}

#[derive(Debug)]
#[repr(C)]
pub struct UFunction {
    pub ustruct: UStruct,
    pub function_flags: EFunctionFlags,
    pub num_parms: u8,
    pub parms_size: u16,
    pub return_value_offset: u16,
    pub rpc_id: u16,
    pub rpc_response_id: u16,
    pub first_property_to_init: *const FProperty,
    pub event_graph_function: *const UFunction,
    pub event_graph_call_offset: i32,
    pub func: unsafe extern "system" fn(*mut UObject, *mut kismet::FFrame, *mut c_void),
}

#[derive(Debug)]
#[repr(C)]
pub struct UClass {
    pub ustruct: UStruct,
}

#[derive(Debug, Clone, Copy)]
#[repr(C)]
pub struct FName {
    pub comparison_index: FNameEntryId,
    pub number: u32,
}

#[derive(Debug, Clone, Copy)]
#[repr(C)]
pub struct FNameEntryId {
    pub value: u32,
}

#[derive(Debug)]
#[repr(C)]
pub struct TSharedPtr<T> {
    pub object: *const T,
    pub reference_controller: *const FReferenceControllerBase,
}

#[derive(Debug)]
#[repr(C)]
pub struct FReferenceControllerBase {
    pub shared_reference_count: i32,
    pub weak_reference_count: i32,
}

pub type FString = TArray<u16>;

#[derive(Debug)]
#[repr(C)]
pub struct TArray<T> {
    data: *const T,
    num: i32,
    max: i32,
}
impl<T> TArray<T> {
    fn new() -> Self {
        Self {
            data: std::ptr::null(),
            num: 0,
            max: 0,
        }
    }
}
impl<T> Drop for TArray<T> {
    fn drop(&mut self) {
        unsafe {
            std::ptr::drop_in_place(std::ptr::slice_from_raw_parts_mut(
                self.data.cast_mut(),
                self.num as usize,
            ))
        }
        globals().gmalloc().free(self.data as *mut c_void);
    }
}
impl<T> Default for TArray<T> {
    fn default() -> Self {
        Self {
            data: std::ptr::null(),
            num: 0,
            max: 0,
        }
    }
}
impl<T> TArray<T> {
    pub fn with_capacity(capacity: usize) -> Self {
        Self {
            data: globals().gmalloc().malloc(
                capacity * std::mem::size_of::<T>(),
                std::mem::align_of::<T>() as u32,
            ) as *const T,
            num: 0,
            max: capacity as i32,
        }
    }
    pub fn len(&self) -> usize {
        self.num as usize
    }
    pub fn capacity(&self) -> usize {
        self.max as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn as_slice(&self) -> &[T] {
        if self.num == 0 {
            &[]
        } else {
            unsafe { std::slice::from_raw_parts(self.data, self.num as usize) }
        }
    }
    pub fn as_mut_slice(&mut self) -> &mut [T] {
        if self.num == 0 {
            &mut []
        } else {
            unsafe { std::slice::from_raw_parts_mut(self.data as *mut _, self.num as usize) }
        }
    }
    pub fn clear(&mut self) {
        let elems: *mut [T] = self.as_mut_slice();

        unsafe {
            self.num = 0;
            std::ptr::drop_in_place(elems);
        }
    }
    pub fn push(&mut self, new_value: T) {
        if self.num >= self.max {
            self.max = u32::next_power_of_two((self.max + 1) as u32) as i32;
            let new = globals().gmalloc().realloc(
                self.data as *mut c_void,
                self.max as usize * std::mem::size_of::<T>(),
                std::mem::align_of::<T>() as u32,
            ) as *const T;
            self.data = new;
        }
        unsafe {
            std::ptr::write(self.data.add(self.num as usize).cast_mut(), new_value);
        }
        self.num += 1;
    }
}

impl<T> From<&[T]> for TArray<T>
where
    T: Copy,
{
    fn from(value: &[T]) -> Self {
        let mut new = Self::with_capacity(value.len());
        // TODO this is probably unsound
        new.num = value.len() as i32;
        new.as_mut_slice().copy_from_slice(value);
        new
    }
}

impl Display for FString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let slice = self.as_slice();
        let last = slice.len()
            - slice
                .iter()
                .cloned()
                .rev()
                .position(|c| c != 0)
                .unwrap_or_default();
        write!(
            f,
            "{}",
            widestring::U16Str::from_slice(&slice[..last])
                .to_string()
                .unwrap()
        )
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct FVector {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct FLinearColor {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}

pub mod kismet {
    use super::*;

    #[derive(Debug)]
    #[repr(C)]
    pub struct FFrame {
        pub base: FOutputDevice,
        pub node: *const c_void,
        pub object: *mut UObject,
        pub code: *const c_void,
        pub locals: *const c_void,
        pub most_recent_property: *const FProperty,
        pub most_recent_property_address: *const c_void,
        pub flow_stack: [u8; 0x30],
        pub previous_frame: *const FFrame,
        pub out_parms: *const c_void,
        pub property_chain_for_compiled_in: *const FField,
        pub current_native_function: *const c_void,
        pub b_array_context_failed: bool,
    }

    pub fn arg<T: Sized>(stack: &mut FFrame, output: &mut T) {
        let output = output as *const _ as *mut _;
        unsafe {
            if stack.code.is_null() {
                let cur = stack.property_chain_for_compiled_in;
                stack.property_chain_for_compiled_in = (*cur).next;
                (globals().fframe_step_explicit_property())(stack, output, cur as *const FProperty);
            } else {
                (globals().fframe_step())(stack, stack.object, output);
            }
        }
    }
}

```

`patternsleuth/Cargo.toml`:

```toml
[package]
name = "patternsleuth"
repository.workspace = true
authors.workspace = true
license.workspace = true
version.workspace = true
edition.workspace = true

[dependencies]
patternsleuth_scanner = { path = "../patternsleuth_scanner" }
anyhow = { workspace = true }
memchr = { workspace = true }
object = { workspace = true }
rayon = { workspace = true }
strum = { workspace = true }
pdb = { workspace = true, optional = true }
msvc-demangler = { workspace = true, optional = true}
iced-x86.workspace = true
futures = "0.3.30"
futures-scopes = "0.2.0"
inventory = "0.3.14"
itertools.workspace = true
serde = { workspace = true, optional = true, features = ["derive"] }
typetag = { version = "0.2.15", optional = true }
gimli = { version = "0.28.1", optional = true }
tracing = "0.1.40"

[target.'cfg(target_os = "linux")'.dependencies]
libc = { version = "0.2.152", optional = true }

[target.'cfg(windows)'.dependencies]
windows = { workspace = true, optional = true, features = [
  "Win32_Foundation",
  "Win32_System_LibraryLoader",
  "Win32_System_ProcessStatus",
  "Win32_System_Threading",
  "Win32_System_Diagnostics_Debug",
] }

[features]
default = []
patterns = []
serde-resolvers = ["dep:serde", "dep:typetag"]
symbols = ["dep:pdb", "dep:msvc-demangler"]
process-external = ["image-pe", "dep:libc", "dep:windows"]
process-internal = ["dep:libc", "dep:windows"]
image-pe = []
image-elf = ["dep:gimli"]

```

`patternsleuth/src/image/elf.rs`:

```rs
use std::{collections::HashMap, mem, ops::Range};

use crate::{
    Memory, MemoryAccessError, MemoryAccessorTrait, MemoryTrait, NamedMemorySection,
    RuntimeFunction,
};

use super::{Image, ImageType};
use gimli::{BaseAddresses, CieOrFde, EhFrame, EhFrameHdr, NativeEndian, UnwindSection};

#[cfg(feature = "symbols")]
use crate::uesym;
use anyhow::{bail, Context, Error, Result};
use object::{
    elf::ProgramHeader64, read::elf::ElfFile64, read::elf::ProgramHeader, Endianness, File, Object,
    ObjectSection, SectionKind,
};

pub struct ElfImage {
    pub functions: Option<Vec<Range<usize>>>,
}

#[allow(dead_code)]
struct Elf64Phdr {
    pub p_type: u32,
    pub p_flags: u32,
    pub p_offset: u64,
    pub p_vaddr: u64,
    pub p_paddr: u64,
    pub p_filesz: u64,
    pub p_memsz: u64,
    pub p_align: u64,
}

impl ElfImage {
    pub fn get_function(
        &self,
        image: &Image<'_>,
        address: usize,
    ) -> Result<Option<RuntimeFunction>, MemoryAccessError> {
        self.get_root_function(image, address)
    }
    pub fn get_root_function(
        &self,
        _image: &Image<'_>,
        address: usize,
    ) -> Result<Option<RuntimeFunction>, MemoryAccessError> {
        self.get_root_function_range(_image, address).map(|range| {
            range.map(|r| RuntimeFunction {
                range: r,
                unwind: 0,
            })
        })
    }
    pub fn get_root_function_range(
        &self,
        _image: &Image<'_>,
        address: usize,
    ) -> Result<Option<Range<usize>>, MemoryAccessError> {
        let x = self.functions.as_ref().unwrap();
        Ok(x.iter().find(|p| p.contains(&address)).cloned())
    }
    pub fn get_child_functions(
        &self,
        image: &Image<'_>,
        address: usize,
    ) -> Result<Vec<RuntimeFunction>, MemoryAccessError> {
        match self.get_function(image, address) {
            Ok(Some(f)) => Ok(vec![f]),
            Ok(None) => Ok(vec![]),
            Err(e) => Err(e),
        }
    }
    pub fn get_root_functions(
        &self,
        _: &Image<'_>,
    ) -> Result<Vec<Range<usize>>, MemoryAccessError> {
        Ok(self.functions.as_ref().unwrap().to_vec())
    }
}

// read_inner
impl ElfImage {
    /// Read and parse ELF object, using data from memory
    pub fn read_inner_memory<'data, P: AsRef<std::path::Path>>(
        base_address: usize,
        #[allow(unused_variables)] exe_path: Option<P>,
        linked: bool,
        memory: Memory<'data>,
        object: ElfFile64<'data>,
    ) -> Result<Image<'data>, anyhow::Error> {
        // start to parse eh_frame

        let endian = object.endian();
        let phdr_map = |segment: &ProgramHeader64<Endianness>| Elf64Phdr {
            p_type: segment.p_type(endian),
            p_flags: segment.p_flags(endian),
            p_offset: segment.p_offset(endian),
            p_vaddr: segment.p_vaddr(endian),
            p_paddr: segment.p_paddr(endian),
            p_filesz: segment.p_filesz(endian),
            p_memsz: segment.p_memsz(endian),
            p_align: segment.p_align(endian),
        };

        let get_offset = |segment: &Elf64Phdr| {
            if linked {
                // for Elf loaded in memory, the map starts from smallest p_vaddr
                (segment.p_vaddr as usize + base_address)
                    ..(segment.p_vaddr as usize + segment.p_memsz as usize + base_address)
            } else {
                // for Elf file loaded as file, the map starts from 0
                segment.p_offset as usize..(segment.p_offset + segment.p_filesz) as usize
            }
        };

        let functions = if linked {
            // try get address from phdr only when it's loaded in memory
            // otherwise, use section to avoid possible relocation problem with
            // eh_frame_hdr.
            // I assume if the encoding for the pointer is DW_EH_PE_indirect
            // that address might need to be filled by relocation, so if
            // the elf is opened as file, the address is not ready to use.
            let eh_frame_hdr = object
                .raw_segments()
                .iter()
                .find(|segment| segment.p_type(endian) == object::elf::PT_GNU_EH_FRAME)
                .map(phdr_map)
                .context("Cannot find PT_GNU_EH_FRAME phdr");

            eh_frame_hdr
                .map(|p| -> Result<Vec<Range<usize>>, Error> {
                    //eprintln!("Found GNU_EH_FRAME");
                    let text_vaddr = memory
                        .sections()
                        .iter()
                        .find(|s| s.name == ".text")
                        .context("Cannot find .text section")?
                        .address();
                    let ehframe_hdr_start = base_address + p.p_vaddr as usize;
                    let bases = BaseAddresses::default()
                        .set_eh_frame_hdr(ehframe_hdr_start as _)
                        .set_text((text_vaddr + base_address) as _);
                    let ehframe_hdr_range = get_offset(&p);

                    let ehframe_hdr: gimli::ParsedEhFrameHdr<
                        gimli::EndianSlice<'_, gimli::LittleEndian>,
                    > = EhFrameHdr::new(memory.range(ehframe_hdr_range)?, NativeEndian)
                        .parse(&bases, mem::size_of::<usize>() as _)
                        .context("Failed to parse eh_frame_hdr")?;

                    let ehframe_realaddr = match ehframe_hdr.eh_frame_ptr() {
                        gimli::Pointer::Direct(ptr) => ptr as usize,
                        // should I subtract base_address?
                        gimli::Pointer::Indirect(ptr) => memory.u64_le(ptr as _)? as _,
                    };

                    let bases = bases.set_eh_frame(ehframe_realaddr as _);
                    let eh_frame =
                        EhFrame::new(memory.range_from(ehframe_realaddr..)?, NativeEndian);

                    let mut entries = eh_frame.entries(&bases);

                    let mut result = Vec::<Range<usize>>::new();
                    while let Some(entry) = entries.next().context("Iter over entry failed")? {
                        match entry {
                            CieOrFde::Fde(partial) => {
                                let fde = partial
                                    .parse(&mut EhFrame::cie_from_offset)
                                    .context("Failed parse fde item")?;
                                // right now it's real address
                                let start = fde.initial_address() as usize;
                                let len = fde.len() as usize;
                                result.push(start..(start + len));
                            }
                            CieOrFde::Cie(_) => {}
                        }
                    }
                    result.sort_by(|a, b| a.start.cmp(&b.start));
                    Ok(result)
                })
                .context("Cannot find eh_frame")?
        } else {
            let eh_frame = object
                .section_by_name(".eh_frame")
                .context("Cannot find section .eh_frame in elf")?;
            let eh_frame_hdr = object
                .section_by_name(".eh_frame_hdr")
                .context("Cannot find section .eh_frame_hdr in elf")?;
            let text = object.section_by_name(".text").unwrap();
            let bases = gimli::BaseAddresses::default()
                .set_eh_frame_hdr(eh_frame_hdr.address() as _)
                .set_eh_frame(eh_frame.address())
                .set_text(text.address() as _);
            let eh_frameparsed = EhFrame::new(eh_frame.data().unwrap(), NativeEndian);
            let mut entries = eh_frameparsed.entries(&bases);

            let mut result = Vec::<Range<usize>>::new();

            while let Some(entry) = entries.next().context("Iter over entry failed")? {
                match entry {
                    CieOrFde::Fde(partial) => {
                        let fde = partial
                            .parse(&mut EhFrame::cie_from_offset)
                            .context("Failed parse fde item")?;
                        // right now it's real address
                        let start = fde.initial_address() as usize;
                        let len = fde.len() as usize;
                        result.push(start..(start + len));
                    }
                    CieOrFde::Cie(_) => {}
                }
            }
            result.sort_by(|a, b| a.start.cmp(&b.start));
            // eprintln!("Found {} fde", result.len());
            Ok(result)
        }?;

        #[cfg(feature = "symbols")]
        let symbols = if let Some(exe_path) = exe_path {
            let sym_path = exe_path.as_ref().with_extension("sym");
            sym_path
                .exists()
                .then(|| -> Result<HashMap<_, _>> {
                    let syms = uesym::dump_ue_symbols(sym_path, base_address)?;
                    Ok((functions.iter().flat_map(
                        |f| -> Option<(usize, crate::symbols::Symbol)> {
                            Some((f.start, syms.get(&f.start)?.clone()))
                        },
                    ))
                    .collect())
                })
                .transpose()?
        } else {
            None
        };
        Ok(Image {
            base_address,
            memory,
            #[cfg(feature = "symbols")]
            symbols,
            imports: HashMap::default(),
            image_type: ImageType::ElfImage(ElfImage {
                functions: Some(functions),
            }),
        })
    }

    /// Read and parse ELF object, using data from object.data()
    pub fn read_inner<P: AsRef<std::path::Path>>(
        base_addr: Option<usize>,
        exe_path: Option<P>,
        _cache_functions: bool,
        object: object::File<'_>,
    ) -> Result<Image<'_>, anyhow::Error> {
        let base_address = base_addr.unwrap_or(object.relative_address_base() as usize);
        let linked = base_addr.is_some();
        let calc_kind = |flag: u32| {
            if flag & object::elf::PF_X == object::elf::PF_X {
                SectionKind::Text
            } else if flag & object::elf::PF_W == object::elf::PF_W {
                SectionKind::Data
            } else if flag & object::elf::PF_R == object::elf::PF_R {
                SectionKind::ReadOnlyData
            } else {
                SectionKind::Unknown
            }
        };

        // the elf may not contains section table if it's in memory, use phdr instead.
        if let File::Elf64(object) = object {
            let endian = object.endian();
            let phdr_map = |segment: &ProgramHeader64<Endianness>| Elf64Phdr {
                p_type: segment.p_type(endian),
                p_flags: segment.p_flags(endian),
                p_offset: segment.p_offset(endian),
                p_vaddr: segment.p_vaddr(endian),
                p_paddr: segment.p_paddr(endian),
                p_filesz: segment.p_filesz(endian),
                p_memsz: segment.p_memsz(endian),
                p_align: segment.p_align(endian),
            };
            let phdrs = object
                .raw_segments()
                .iter()
                .filter(|segment| segment.p_type(endian) == object::elf::PT_LOAD)
                .map(phdr_map)
                .collect::<Vec<_>>();

            let _map_end = phdrs
                .iter()
                .map(|p| p.p_vaddr + p.p_memsz)
                .max()
                .unwrap_or_default();
            let map_start = phdrs.iter().map(|p| p.p_vaddr).min().unwrap_or_default();

            let get_offset = |segment: &Elf64Phdr| {
                if linked {
                    // for Elf loaded in memory, the map starts from smallest p_vaddr
                    (segment.p_vaddr - map_start) as usize
                        ..(segment.p_vaddr + segment.p_memsz - map_start) as usize
                } else {
                    // for Elf file loaded as file, the map starts from 0
                    segment.p_offset as usize..(segment.p_offset + segment.p_filesz) as usize
                }
            };

            let entrypoint = object.entry();
            let sections = phdrs
                .iter()
                .enumerate()
                .map(|(idx, segment)| {
                    let vaddr_range = segment.p_vaddr..(segment.p_vaddr + segment.p_filesz);
                    let offset_range = get_offset(segment);
                    let section_name = if !vaddr_range.contains(&entrypoint) {
                        format!("FakeSection {}", idx + 1)
                    } else {
                        ".text".to_owned()
                    };
                    NamedMemorySection::new(
                        section_name,
                        base_address + segment.p_vaddr as usize,
                        calc_kind(segment.p_flags),
                        &object.data()[offset_range],
                    )
                })
                .collect::<Vec<_>>();

            let memory = Memory { sections };

            Self::read_inner_memory(base_address, exe_path, linked, memory, object)
        } else {
            bail!("Not a elf file")
        }
    }
}

/*



        let eh_frame = object.section_by_name(".eh_frame").unwrap();
        let eh_frame_hdr = object.section_by_name(".eh_frame_hdr").unwrap();
        let text = object.section_by_name(".text").unwrap();
        let bases = gimli::BaseAddresses::default()
                .set_eh_frame_hdr(eh_frame_hdr.address() as _)
                .set_eh_frame(eh_frame.address())
                .set_text(text.address() as _);
        let eh_frameparsed = EhFrame::new(
            eh_frame.data().unwrap(),
            NativeEndian
        );
        let mut entries = eh_frameparsed.entries(&bases);

        let mut result = Vec::<Range<usize>>::new();
        let mut syms = HashMap::default();

        while let Some(entry) = entries.next().context("Iter over entry failed")? {
            match entry {
                CieOrFde::Fde(partial) => {
                    let fde = partial
                        .parse(&mut EhFrame::cie_from_offset)
                        .context("Failed parse fde item")?;
                    // right now it's real address
                    let start = fde.initial_address() as usize;
                    let len = fde.len() as usize;
                    result.push(start .. (start + len));
                    syms.insert(start, format!("sub_{}", start));
                }
                CieOrFde::Cie(_) => {},
            }
        }
        result.sort_by(|a,b| a.start.cmp(&b.start));

*/

```

`patternsleuth/src/image/macros.rs`:

```rs
/// Define a set of functions that dispatch to the appropriate image type as its inner type
/// @define_imagetype accepts enum name and its variants inside a block, and defines the enum
/// @define_matcharm accepts the enum name and its variants inside a block, self to avoid hygienic issues, the function name, and the function arguments
macro_rules! image_type_dispatch {
    (
        @enum $enum_name_it:ident as $enum_name_macro_it:ident $enum_tt:tt
        @fns {
            $(fn $fnname_it:ident($($arg:ident: $arg_ty:ty),*) -> $ret:ty);* $(;)?
        }
    ) => {
        image_type_dispatch!(@define_imagetype $enum_name_it $enum_tt);
        impl<'data> Image<'data> {
            $(
                pub fn $fnname_it(&self, $($arg: $arg_ty),*) -> $ret {
                    image_type_dispatch!(@define_matcharm $enum_name_it $enum_tt, self, $fnname_it, $($arg),*)
                }
            )*
        }
        image_type_dispatch!(@generate_macro_for_enum $enum_name_it $enum_name_macro_it $enum_tt);
    };
    (@define_imagetype $enum_name_it:ident { $( $img_ident:ident( $img_ty:ty, $img_feature:literal )),* $(,)? }) => {
        pub enum $enum_name_it {
            $(
                #[cfg(feature = $img_feature)]
                $img_ident($img_ty),
            )*
        }
    };
    (@define_matcharm $enum_name_it:ident { $( $img_ident:ident( $img_ty:ty, $img_feature:literal )),* $(,)? }, $self:ident, $fnname_it:ident, $args_tt:tt) => {
        match &$self.image_type {
            $(
                #[cfg(feature = $img_feature)]
                $enum_name_it::$img_ident(inner) => inner.$fnname_it($self, $args_tt),
            )*
        }
    };

    (@define_matcharm $enum_name_it:ident { $( $img_ident:ident( $img_ty:ty, $img_feature:literal )),* $(,)? }, $self:ident, $fnname_it:ident, ) => {
        match &$self.image_type {
            $(
                #[cfg(feature = $img_feature)]
                $enum_name_it::$img_ident(inner) => inner.$fnname_it($self),
            )*
        }
    };

    (@generate_macro_for_enum $enum_name_it:ident $enum_name_macro_it:ident { $( $img_ident:ident( $img_ty:ty, $img_feature:literal )),* $(,)? }) => {
        #[allow(unused_macros)]
        #[macro_export]
        macro_rules! $enum_name_macro_it {
            (all, $macroname:ident; $id:ident; $arg:tt) => {
                $macroname!($id, $enum_name_it {$( $img_ident($img_ty, $img_feature),)*}, $arg)
            };
        }

        #[allow(unused_imports)]
        pub(crate) use $enum_name_macro_it;
    };
}

pub(crate) use image_type_dispatch;

```

`patternsleuth/src/image/mod.rs`:

```rs
#[cfg(feature = "image-elf")]
pub mod elf;
mod macros;
#[cfg(feature = "image-pe")]
pub mod pe;

use crate::*;
use anyhow::Error;
#[cfg(feature = "image-elf")]
use elf::ElfImage;
#[cfg(feature = "image-pe")]
use pe::PEImage;

use macros::*;

#[cfg(not(any(feature = "image-pe", feature = "image-elf")))]
compile_error!("requires at least one of image-pe or image-elf features");

image_type_dispatch! {
    @enum ImageType as _image_type_reflection {
        PEImage(PEImage, "image-pe"),
        ElfImage(ElfImage, "image-elf"),
    }

    @fns {
        fn get_function(address: usize) -> Result<Option<RuntimeFunction>, MemoryAccessError>;
        fn get_root_function(address: usize) -> Result<Option<RuntimeFunction>, MemoryAccessError>;
        fn get_root_function_range(address: usize) -> Result<Option<Range<usize>>, MemoryAccessError>;
        fn get_child_functions(address: usize) -> Result<Vec<RuntimeFunction>, MemoryAccessError>;
        fn get_root_functions() -> Result<Vec<Range<usize>>, MemoryAccessError>;
    }
}

pub use _image_type_reflection as image_type_reflection;

pub struct Image<'data> {
    pub base_address: usize,
    pub memory: Memory<'data>,
    #[cfg(feature = "symbols")]
    pub symbols: Option<HashMap<usize, symbols::Symbol>>,
    pub imports: HashMap<String, HashMap<String, usize>>,
    pub image_type: ImageType,
}

// Type-independent
impl<'data> Image<'data> {
    pub fn read<P: AsRef<Path>>(
        base_addr: Option<usize>,
        data: &'data [u8],
        exe_path: Option<P>,
        cache_functions: bool,
    ) -> Result<Image<'data>> {
        let object = object::File::parse(data)?;
        match object {
            #[cfg(feature = "image-elf")]
            object::File::Elf64(_) => {
                ElfImage::read_inner(base_addr, exe_path, cache_functions, object)
            }
            #[cfg(feature = "image-pe")]
            object::File::Pe64(_) => {
                PEImage::read_inner(base_addr, exe_path, cache_functions, object)
            }
            _ => Err(Error::msg("Unsupported file format")),
        }
    }
    pub fn builder() -> ImageBuilder {
        Default::default()
    }
    pub fn resolve<T: Send + Sync>(
        &self,
        resolver: &'static resolvers::ResolverFactory<T>,
    ) -> resolvers::Result<T> {
        resolvers::resolve(self, resolver)
    }

    pub fn resolve_many(
        &self,
        resolvers: &[fn() -> &'static resolvers::DynResolverFactory],
    ) -> Vec<resolvers::Result<std::sync::Arc<dyn resolvers::Resolution>>> {
        resolvers::resolve_many(self, resolvers)
    }

    pub fn scan<'patterns, S>(
        &self,
        pattern_configs: &'patterns [PatternConfig<S>],
    ) -> Result<ScanResult<'patterns, S>> {
        let mut results = vec![];

        struct PendingScan {
            original_config_index: usize,
            scan: Scan,
        }

        let scan_queue = pattern_configs
            .iter()
            .enumerate()
            .map(|(index, config)| PendingScan {
                original_config_index: index,
                scan: config.scan.clone(), // TODO clone isn't ideal but makes handling multi-stage scans a lot easier
            })
            .collect::<Vec<_>>();

        for section in self.memory.sections() {
            let base_address = section.address();
            let data = section.data();

            let (pattern_scans, patterns): (Vec<_>, Vec<_>) = scan_queue
                .iter()
                .filter_map(|scan| {
                    scan.scan
                        .section
                        .map(|s| s == section.kind())
                        .unwrap_or(true)
                        .then(|| {
                            scan.scan
                                .scan_type
                                .get_pattern()
                                .map(|pattern| (scan, pattern))
                        })
                        .flatten()
                })
                .unzip();

            let (xref_scans, xrefs): (Vec<_>, Vec<_>) = scan_queue
                .iter()
                .filter_map(|scan| {
                    scan.scan
                        .section
                        .map(|s| s == section.kind())
                        .unwrap_or(true)
                        .then(|| scan.scan.scan_type.get_xref().map(|xref| (scan, xref)))
                        .flatten()
                })
                .unzip();

            let scan_results = scanner::scan_pattern(&patterns, base_address, data)
                .into_iter()
                .chain(scanner::scan_xref(&xrefs, base_address, data))
                .zip(pattern_scans.iter().chain(xref_scans.iter()));

            for (addresses, scan) in scan_results {
                for address in addresses {
                    results.push((
                        &pattern_configs[scan.original_config_index],
                        Resolution { address },
                    ));
                }
            }
        }

        Ok(ScanResult { results })
    }
}

#[derive(Default)]
pub struct ImageBuilder {
    functions: bool,
}
pub struct ImageBuilderWithSymbols<P: AsRef<Path>> {
    symbols: Option<P>,
    functions: bool,
}
impl ImageBuilder {
    pub fn functions(mut self, functions: bool) -> Self {
        self.functions = functions;
        self
    }
    #[cfg(feature = "symbols")]
    pub fn symbols<P: AsRef<Path>>(self, exe_path: P) -> ImageBuilderWithSymbols<P> {
        ImageBuilderWithSymbols {
            symbols: Some(exe_path),
            functions: self.functions,
        }
    }
    pub fn build(self, data: &[u8]) -> Result<Image<'_>> {
        Image::read::<&str>(None, data, None, self.functions)
    }
}
impl<P: AsRef<Path>> ImageBuilderWithSymbols<P> {
    pub fn functions(mut self, functions: bool) -> Self {
        self.functions = functions;
        self
    }
    #[cfg(feature = "symbols")]
    pub fn symbols(mut self, exe_path: P) -> Self {
        self.symbols = Some(exe_path);
        self
    }
    pub fn build(self, data: &[u8]) -> Result<Image<'_>> {
        Image::read(None, data, self.symbols, self.functions)
    }
}

```

`patternsleuth/src/image/pe.rs`:

```rs
use std::collections::{HashMap, HashSet};
use std::ops::Range;

use anyhow::{bail, Context, Result};
use itertools::Itertools;

use super::{Image, ImageType};
#[cfg(feature = "symbols")]
use crate::symbols;
use crate::{Memory, MemoryAccessError, MemoryAccessorTrait, MemoryTrait, RuntimeFunction};
use object::Object;

pub struct PEImage {
    pub exception_directory_range: Range<usize>,
    pub exception_children_cache: HashMap<usize, Vec<RuntimeFunction>>,
}

impl PEImage {
    pub fn get_function(
        &self,
        image: &Image<'_>,
        address: usize,
    ) -> Result<Option<RuntimeFunction>, MemoryAccessError> {
        // place holder only
        let size = 12;
        let mut min = 0;
        let mut max = self.exception_directory_range.len() / size - 1;

        while min <= max {
            let i = (max + min) / 2;
            let addr = i * size + self.exception_directory_range.start;

            let addr_begin = image.base_address + image.memory.u32_le(addr)? as usize;
            if addr_begin <= address {
                let addr_end = image.base_address + image.memory.u32_le(addr + 4)? as usize;
                if addr_end > address {
                    let unwind = image.base_address + image.memory.u32_le(addr + 8)? as usize;

                    return Ok(Some(RuntimeFunction {
                        range: addr_begin..addr_end,
                        unwind,
                    }));
                } else {
                    min = i + 1;
                }
            } else {
                max = i - 1;
            }
        }
        Ok(None)
    }
    pub fn get_root_function(
        &self,
        image: &Image<'_>,
        address: usize,
    ) -> Result<Option<RuntimeFunction>, MemoryAccessError> {
        if let Some(f) = self.get_function(image, address)? {
            let mut f = RuntimeFunction {
                range: f.range,
                unwind: f.unwind,
            };

            loop {
                let mut unwind_addr = f.unwind;

                let section = image.memory.get_section_containing(unwind_addr)?;

                let has_chain_info = section.section.index(unwind_addr)? >> 3 == 0x4;
                if has_chain_info {
                    let unwind_code_count = section.section.index(unwind_addr + 2)?;

                    unwind_addr += 4 + 2 * unwind_code_count as usize;
                    if unwind_addr % 4 != 0 {
                        // align
                        unwind_addr += 2;
                    }

                    if section.address() + section.data().len() > unwind_addr + 12 {
                        f = RuntimeFunction::read(section, image.base_address, unwind_addr)?;
                    } else {
                        todo!("not adding chain info {unwind_addr}");
                    }
                } else {
                    return Ok(Some(f));
                }
            }
        } else {
            Ok(None)
        }
    }

    pub fn get_root_function_range(
        &self,
        image: &Image<'_>,
        address: usize,
    ) -> Result<Option<Range<usize>>, MemoryAccessError> {
        let exception = self.get_root_function(image, address)?;
        if let Some(exception) = exception {
            let fns = self
                .get_child_functions(image, exception.range.start)
                .unwrap();
            let min = fns.iter().map(|f| f.range.start).min().unwrap();
            let max = fns.iter().map(|f| f.range.end).max().unwrap();
            if exception.range.start != address {
                // why comapreing exception but not min?
                Err(MemoryAccessError::MisalginedAddress(
                    exception.range.start,
                    address,
                ))
            } else {
                Ok(Some(min..max)) // TODO does not handle sparse ranges
            }
        } else {
            Ok(None)
        }
    }

    pub fn get_child_functions(
        &self,
        image: &Image<'_>,
        address: usize,
    ) -> Result<Vec<RuntimeFunction>, MemoryAccessError> {
        let mut queue = vec![address];
        let mut all_children = vec![self.get_function(image, address)?.unwrap()];
        while let Some(next) = queue.pop() {
            if let Some(children) = self.exception_children_cache.get(&next) {
                for child in children {
                    queue.push(child.range().start);
                    all_children.push(child.clone());
                }
            }
        }
        Ok(all_children)
    }

    pub fn get_root_functions(
        &self,
        image: &Image<'_>,
    ) -> Result<Vec<Range<usize>>, MemoryAccessError> {
        let mut functions = self.exception_children_cache.keys().collect::<HashSet<_>>();
        for e in self.exception_children_cache.values() {
            for c in e {
                functions.remove(&c.range.start);
            }
        }
        functions
            .iter()
            .map(|function| -> Result<Range<usize>, MemoryAccessError> {
                let fns = self
                    .get_child_functions(
                        image,
                        self.get_function(image, **function)?
                            .ok_or(MemoryAccessError::MemoryOutOfBoundsError)?
                            .range
                            .start,
                    )
                    .unwrap();
                let min = fns.iter().map(|f| f.range.start).min().unwrap();
                let max = fns.iter().map(|f| f.range.end).max().unwrap();
                Ok(min..max)
            })
            .try_collect()
    }
}

impl Image<'_> {
    // this function is privately used by pe image
    fn populate_exception_cache(&mut self) -> Result<(), MemoryAccessError> {
        #[allow(irrefutable_let_patterns)]
        if let ImageType::PEImage(ref mut pe) = self.image_type {
            for i in pe.exception_directory_range.clone().step_by(12) {
                let f = RuntimeFunction::read(&self.memory, self.base_address, i)?;
                pe.exception_children_cache.insert(f.range.start, vec![]);

                let Ok(section) = self.memory.get_section_containing(f.unwind) else {
                    // TODO disabled cause spammy
                    //println!("invalid unwind info addr {:x}", f.unwind);
                    continue;
                };

                let mut unwind = f.unwind;
                let has_chain_info = section.section.index(unwind)? >> 3 == 0x4;
                if has_chain_info {
                    let unwind_code_count = section.section.index(unwind + 2)?;

                    unwind += 4 + 2 * unwind_code_count as usize;
                    if unwind % 4 != 0 {
                        // align
                        unwind += 2;
                    }

                    if section.address() + section.data().len() > unwind + 12 {
                        let chained = RuntimeFunction::read(section, self.base_address, unwind)?;

                        // TODO disabled because it spams the log too much
                        //let referenced = self.get_function(chained.range.start);

                        //assert_eq!(Some(&chained), referenced.as_ref());
                        //if Some(&chained) != referenced.as_ref() {
                        //println!("mismatch {:x?} {referenced:x?}", Some(&chained));
                        //}

                        pe.exception_children_cache
                            .entry(chained.range.start)
                            .or_default()
                            .push(f);
                    } else {
                        println!("invalid unwind addr {:x}", unwind);
                    }
                }
            }

            //println!("{:#x?}", self.exception_children_cache);
            Ok(())
        } else {
            unreachable!("not a PE image")
        }
    }
}

impl PEImage {
    /// Read and parse ELF object, using data from memory
    pub fn read_inner_memory<'data, P: AsRef<std::path::Path>>(
        base_address: usize,
        #[allow(unused_variables)] exe_path: Option<P>,
        cache_functions: bool,
        memory: Memory<'data>,
        object: object::File<'_>,
    ) -> Result<Image<'data>, anyhow::Error> {
        #[cfg(feature = "symbols")]
        let symbols = if let Some(exe_path) = exe_path {
            let pdb_path = exe_path.as_ref().with_extension("pdb");
            pdb_path
                .exists()
                .then(|| symbols::dump_pdb_symbols(pdb_path, base_address))
                .transpose()?
        } else {
            None
        };

        let get_ex_dir = || -> Result<Range<usize>> {
            Ok(match object {
                object::File::Pe64(ref inner) => {
                    let exception_directory = inner
                        .data_directory(object::pe::IMAGE_DIRECTORY_ENTRY_EXCEPTION)
                        .context("no exception directory")?;

                    let (address, size) = exception_directory.address_range();
                    base_address + address as usize..base_address + (address + size) as usize
                }
                _ => bail!("not a PE file"),
            })
        };

        let get_imports = || -> Result<_> {
            Ok(match object {
                object::File::Pe64(ref inner) => {
                    use object::pe::ImageNtHeaders64;
                    use object::read::pe::ImageThunkData;
                    use object::LittleEndian as LE;

                    let mut imports: HashMap<String, HashMap<String, usize>> = Default::default();

                    let import_table = inner.import_table()?.unwrap();
                    let mut import_descs = import_table.descriptors()?;

                    while let Some(import_desc) = import_descs.next()? {
                        let mut cur = HashMap::new();

                        let Ok(lib_name) = import_table.name(import_desc.name.get(LE)) else {
                            continue;
                        };
                        let lib_name = std::str::from_utf8(lib_name)?.to_ascii_lowercase();
                        let mut thunks =
                            import_table.thunks(import_desc.original_first_thunk.get(LE))?;
                        let mut address = base_address + import_desc.first_thunk.get(LE) as usize;
                        while let Some(thunk) = thunks.next::<ImageNtHeaders64>()? {
                            if let Ok((_hint, name)) = import_table.hint_name(thunk.address()) {
                                cur.insert(std::str::from_utf8(name)?.to_owned(), address);
                                address += 8;
                            }
                        }
                        imports.insert(lib_name, cur);
                    }
                    imports
                }
                _ => bail!("not a PE file"),
            })
        };

        let mut new = Image {
            base_address,
            memory,
            #[cfg(feature = "symbols")]
            symbols,
            imports: get_imports().unwrap_or_default(),
            image_type: ImageType::PEImage(PEImage {
                exception_directory_range: get_ex_dir().unwrap_or_default(),
                exception_children_cache: Default::default(),
            }),
        };

        if cache_functions {
            new.populate_exception_cache()?;
        }
        Ok(new)
    }

    pub fn read_inner<P: AsRef<std::path::Path>>(
        base_addr: Option<usize>,
        exe_path: Option<P>,
        cache_functions: bool,
        object: object::File<'_>,
    ) -> Result<Image<'_>, anyhow::Error> {
        let base_address = base_addr.unwrap_or(object.relative_address_base() as usize);
        let memory = Memory::new(&object)?;
        Self::read_inner_memory(base_address, exe_path, cache_functions, memory, object)
    }
}

```

`patternsleuth/src/lib.rs`:

```rs
pub mod image;
pub mod process;
pub mod resolvers;
#[cfg(feature = "symbols")]
pub mod symbols;
#[cfg(feature = "symbols")]
pub mod uesym;

pub mod scanner {
    pub use patternsleuth_scanner::*;
}

use scanner::{Pattern, Xref};
use std::{
    borrow::Cow,
    collections::HashMap,
    ops::{Index, Range, RangeFrom, RangeTo},
    path::Path,
};

use anyhow::{bail, Context, Result};
use object::{File, Object, ObjectSection};

use image::Image;

pub struct ResolveContext<'data, 'pattern> {
    pub exe: &'data Image<'data>,
    pub memory: &'data Memory<'data>,
    pub section: String,
    pub match_address: usize,
    pub scan: &'pattern Scan,
}

#[derive(Debug, Hash, Ord, PartialOrd, Eq, PartialEq)]
pub struct Resolution {
    pub address: usize,
}

#[derive(Debug, Clone)]
pub struct Scan {
    pub section: Option<object::SectionKind>,
    pub scan_type: ScanType,
}
#[derive(Debug, Clone)]
pub enum ScanType {
    Pattern(Pattern),
    Xref(Xref),
}
impl ScanType {
    pub fn get_pattern(&self) -> Option<&Pattern> {
        match self {
            Self::Pattern(pattern) => Some(pattern),
            _ => None,
        }
    }
    pub fn get_xref(&self) -> Option<&Xref> {
        match self {
            Self::Xref(xref) => Some(xref),
            _ => None,
        }
    }
}
impl From<Pattern> for ScanType {
    fn from(value: Pattern) -> Self {
        Self::Pattern(value)
    }
}
impl From<Xref> for ScanType {
    fn from(value: Xref) -> Self {
        Self::Xref(value)
    }
}

#[derive(Debug)]
pub struct PatternConfig<S> {
    pub sig: S,
    pub name: String,
    pub scan: Scan,
}
impl<S> PatternConfig<S> {
    pub fn new(
        sig: S,
        name: String,
        section: Option<object::SectionKind>,
        pattern: Pattern,
    ) -> Self {
        Self {
            sig,
            name,
            scan: Scan {
                section,
                scan_type: pattern.into(),
            },
        }
    }
    pub fn xref(sig: S, name: String, section: Option<object::SectionKind>, xref: Xref) -> Self {
        Self {
            sig,
            name,
            scan: Scan {
                section,
                scan_type: xref.into(),
            },
        }
    }
}

#[derive(Debug)]
pub struct ScanResult<'a, S> {
    pub results: Vec<(&'a PatternConfig<S>, Resolution)>,
}
impl<'a, S: std::fmt::Debug + PartialEq> ScanResult<'a, S> {
    pub fn get_unique_sig_address(&self, sig: S) -> Result<usize> {
        let mut address = None;
        for (config, res) in &self.results {
            if config.sig == sig {
                if let Some(existing) = address {
                    if existing != res.address {
                        bail!("sig {sig:?} matched multiple addresses")
                    }
                } else {
                    address = Some(res.address)
                }
            }
        }
        address.with_context(|| format!("sig {sig:?} not found"))
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct RuntimeFunction {
    pub range: Range<usize>,
    pub unwind: usize,
}
impl RuntimeFunction {
    pub fn read<'data>(
        memory: &impl MemoryTrait<'data>,
        base_address: usize,
        address: usize,
    ) -> Result<Self, MemoryAccessError> {
        let addr_begin = base_address + memory.u32_le(address)? as usize;
        let addr_end = base_address + memory.u32_le(address + 4)? as usize;
        let unwind = base_address + memory.u32_le(address + 8)? as usize;

        Ok(RuntimeFunction {
            range: addr_begin..addr_end,
            unwind,
        })
    }
}
impl RuntimeFunction {
    pub fn range(&self) -> Range<usize> {
        self.range.clone()
    }
}

#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub enum MemoryAccessError {
    MemoryOutOfBoundsError,
    Utf8Error,
    Utf16Error,
    MisalginedAddress(usize, usize),
}
impl std::error::Error for MemoryAccessError {}
impl std::fmt::Display for MemoryAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::MemoryOutOfBoundsError => write!(f, "MemoryOutOfBoundsError"),
            Self::Utf8Error => write!(f, "Utf8Error"),
            Self::Utf16Error => write!(f, "Utf16Error"),
            Self::MisalginedAddress(addr, align) => {
                write!(f, "MisalginedAddress: address {:#x} != {:#x}", addr, align)
            }
        }
    }
}
impl From<std::str::Utf8Error> for MemoryAccessError {
    fn from(_: std::str::Utf8Error) -> Self {
        Self::Utf8Error
    }
}
impl From<std::string::FromUtf16Error> for MemoryAccessError {
    fn from(_: std::string::FromUtf16Error) -> Self {
        Self::Utf16Error
    }
}

/// Continuous section of memory
pub trait MemoryBlockTrait<'data> {
    /// Return starting address of block
    fn address(&self) -> usize;
    /// Returned contained memory
    fn data(&self) -> &[u8];
}

/// Potentially sparse section of memory
pub trait MemoryTrait<'data> {
    /// Return u8 at `address`
    fn index(&self, address: usize) -> Result<u8, MemoryAccessError>;
    /// Return slice of u8 at `range`
    fn range(&self, range: Range<usize>) -> Result<&[u8], MemoryAccessError>;
    /// Return slice of u8 from start of `range` to end of block
    fn range_from(&self, range: RangeFrom<usize>) -> Result<&[u8], MemoryAccessError>;
    /// Return slice of u8 from end of `range` to start of block (not useful because start of block
    /// is unknown to caller)
    fn range_to(&self, range: RangeTo<usize>) -> Result<&[u8], MemoryAccessError>;
}

/// Memory accessor helpers
pub trait MemoryAccessorTrait<'data>: MemoryTrait<'data> {
    /// Return i16 at `address`
    fn i16_le(&self, address: usize) -> Result<i16, MemoryAccessError> {
        Ok(i16::from_le_bytes(
            self.range(address..address + std::mem::size_of::<i16>())?
                .try_into()
                .unwrap(),
        ))
    }
    /// Return u16 at `address`
    fn u16_le(&self, address: usize) -> Result<u16, MemoryAccessError> {
        Ok(u16::from_le_bytes(
            self.range(address..address + std::mem::size_of::<u16>())?
                .try_into()
                .unwrap(),
        ))
    }
    /// Return i32 at `address`
    fn i32_le(&self, address: usize) -> Result<i32, MemoryAccessError> {
        Ok(i32::from_le_bytes(
            self.range(address..address + std::mem::size_of::<i32>())?
                .try_into()
                .unwrap(),
        ))
    }
    /// Return u32 at `address`
    fn u32_le(&self, address: usize) -> Result<u32, MemoryAccessError> {
        Ok(u32::from_le_bytes(
            self.range(address..address + std::mem::size_of::<u32>())?
                .try_into()
                .unwrap(),
        ))
    }
    /// Return u64 at `address`
    fn u64_le(&self, address: usize) -> Result<u64, MemoryAccessError> {
        Ok(u64::from_le_bytes(
            self.range(address..address + std::mem::size_of::<u64>())?
                .try_into()
                .unwrap(),
        ))
    }
    /// Return ptr (usize) at `address`
    fn ptr(&self, address: usize) -> Result<usize, MemoryAccessError> {
        Ok(self.u64_le(address)? as usize)
    }
    /// Return instruction relative address at `address`
    fn rip4(&self, address: usize) -> Result<usize, MemoryAccessError> {
        Ok((address + 4)
            .checked_add_signed(self.i32_le(address)? as isize)
            .unwrap())
    }

    /// Read null terminated string from `address`
    fn read_string(&self, address: usize) -> Result<String, MemoryAccessError> {
        let data = &self
            .range_from(address..)?
            .iter()
            .cloned()
            .take_while(|n| *n != 0)
            .collect::<Vec<u8>>();

        Ok(std::str::from_utf8(data)?.to_string())
    }

    /// Read null terminated wide string from `address`
    fn read_wstring(&self, address: usize) -> Result<String, MemoryAccessError> {
        let data = &self
            .range_from(address..)?
            .chunks(2)
            .map(|chunk| ((chunk[1] as u16) << 8) + chunk[0] as u16)
            .take_while(|n| *n != 0)
            .collect::<Vec<u16>>();

        Ok(String::from_utf16(data)?)
    }
}

impl<'data, T: MemoryTrait<'data>> MemoryAccessorTrait<'data> for T {}

impl<'data, T: MemoryBlockTrait<'data>> MemoryTrait<'data> for T {
    fn index(&self, address: usize) -> Result<u8, MemoryAccessError> {
        // TODO bounds
        Ok(self.data()[address - self.address()])
    }
    fn range(&self, range: Range<usize>) -> Result<&[u8], MemoryAccessError> {
        // TODO bounds
        Ok(&self.data()[range.start - self.address()..range.end - self.address()])
    }
    fn range_from(&self, range: RangeFrom<usize>) -> Result<&[u8], MemoryAccessError> {
        // TODO bounds
        Ok(&self.data()[range.start - self.address()..])
    }
    fn range_to(&self, range: RangeTo<usize>) -> Result<&[u8], MemoryAccessError> {
        // TODO bounds
        Ok(&self.data()[..range.end - self.address()])
    }
}

impl<'data> MemoryTrait<'data> for Memory<'data> {
    fn index(&self, address: usize) -> Result<u8, MemoryAccessError> {
        self.get_section_containing(address)?.index(address)
    }
    fn range(&self, range: Range<usize>) -> Result<&[u8], MemoryAccessError> {
        self.get_section_containing(range.start)?.range(range)
    }
    fn range_from(&self, range: RangeFrom<usize>) -> Result<&[u8], MemoryAccessError> {
        self.get_section_containing(range.start)?.range_from(range)
    }
    fn range_to(&self, range: RangeTo<usize>) -> Result<&[u8], MemoryAccessError> {
        self.get_section_containing(range.end)?.range_to(range)
    }
}

pub struct MemorySection<'data> {
    address: usize,
    data: Cow<'data, [u8]>,
}
impl<'data> MemoryBlockTrait<'data> for MemorySection<'data> {
    fn address(&self) -> usize {
        self.address
    }
    fn data(&self) -> &[u8] {
        &self.data
    }
}

pub struct NamedMemorySection<'data> {
    name: String,
    kind: object::SectionKind,
    section: MemorySection<'data>,
}

impl<'data> NamedMemorySection<'data> {
    fn new<T: Into<Cow<'data, [u8]>>>(
        name: String,
        address: usize,
        kind: object::SectionKind,
        data: T,
    ) -> Self {
        Self {
            name,
            kind,
            section: MemorySection {
                address,
                data: data.into(),
            },
        }
    }
}
impl NamedMemorySection<'_> {
    pub fn name(&self) -> &str {
        &self.name
    }
    pub fn kind(&self) -> object::SectionKind {
        self.kind
    }
    pub fn address(&self) -> usize {
        self.section.address()
    }
    pub fn data(&self) -> &[u8] {
        self.section.data()
    }
    pub fn len(&self) -> usize {
        self.section.data.len()
    }
    pub fn is_empty(&self) -> bool {
        self.section.data.is_empty()
    }
}
impl<'data> MemoryBlockTrait<'data> for NamedMemorySection<'data> {
    fn address(&self) -> usize {
        self.section.address()
    }
    fn data(&self) -> &[u8] {
        self.section.data()
    }
}

pub struct Memory<'data> {
    sections: Vec<NamedMemorySection<'data>>,
}

impl<'data> Memory<'data> {
    pub fn new(object: &File<'data>) -> Result<Self> {
        Ok(Self {
            sections: object
                .sections()
                .map(|s| {
                    Ok(NamedMemorySection::new(
                        s.name()?.to_string(),
                        s.address() as usize,
                        s.kind(),
                        s.data()?,
                    ))
                })
                .collect::<Result<Vec<_>>>()?,
        })
    }
    pub fn new_external_data(sections: Vec<(object::Section<'_, '_>, Vec<u8>)>) -> Result<Self> {
        Ok(Self {
            sections: sections
                .into_iter()
                .map(|(s, d)| {
                    Ok(NamedMemorySection::new(
                        s.name()?.to_string(),
                        s.address() as usize,
                        s.kind(),
                        d,
                    ))
                })
                .collect::<Result<Vec<_>>>()?,
        })
    }
    pub fn new_internal_data(
        sections: Vec<(object::Section<'_, '_>, &'data [u8])>,
    ) -> Result<Self> {
        Ok(Self {
            sections: sections
                .into_iter()
                .map(|(s, d)| {
                    Ok(NamedMemorySection::new(
                        s.name()?.to_string(),
                        s.address() as usize,
                        s.kind(),
                        d,
                    ))
                })
                .collect::<Result<Vec<_>>>()?,
        })
    }
    pub fn sections(&self) -> &[NamedMemorySection] {
        &self.sections
    }
    pub fn get_section_containing(
        &self,
        address: usize,
    ) -> Result<&NamedMemorySection<'data>, MemoryAccessError> {
        self.sections
            .iter()
            .find(|section| {
                address >= section.section.address
                    && address < section.section.address + section.section.data.len()
            })
            .ok_or(MemoryAccessError::MemoryOutOfBoundsError)
    }
    pub fn find<F>(&self, kind: object::SectionKind, filter: F) -> Option<usize>
    where
        F: Fn(usize, &[u8]) -> bool,
    {
        self.sections.iter().find_map(|section| {
            if section.kind == kind {
                section
                    .section
                    .data
                    .windows(4)
                    .enumerate()
                    .find_map(|(i, slice)| {
                        filter(section.section.address + i, slice)
                            .then_some(section.section.address + i)
                    })
            } else {
                None
            }
        })
    }
}
impl<'data> Index<usize> for Memory<'data> {
    type Output = u8;
    fn index(&self, index: usize) -> &Self::Output {
        self.sections
            .iter()
            .find_map(|section| section.section.data.get(index - section.section.address))
            .unwrap()
    }
}
impl<'data> Index<Range<usize>> for Memory<'data> {
    type Output = [u8];
    fn index(&self, index: Range<usize>) -> &Self::Output {
        self.sections
            .iter()
            .find_map(|section| {
                if index.start >= section.section.address
                    && index.end <= section.section.address + section.section.data.len()
                {
                    let relative_range =
                        index.start - section.section.address..index.end - section.section.address;
                    Some(&section.section.data[relative_range])
                } else {
                    None
                }
            })
            .unwrap()
    }
}

pub trait Addressable {
    fn rip(&self) -> usize;
    fn ptr(&self) -> usize;
    fn u32(&self) -> u32;
}
impl Addressable for patternsleuth_scanner::Capture<'_> {
    fn rip(&self) -> usize {
        (self.address + 4)
            .checked_add_signed(i32::from_le_bytes(self.data.try_into().unwrap()) as isize)
            .unwrap()
    }
    fn ptr(&self) -> usize {
        usize::from_le_bytes(self.data.try_into().unwrap())
    }
    fn u32(&self) -> u32 {
        u32::from_le_bytes(self.data.try_into().unwrap())
    }
}

pub trait Matchable<'data> {
    fn captures(
        &'data self,
        pattern: &Pattern,
        address: usize,
    ) -> Result<Option<Vec<patternsleuth_scanner::Capture<'data>>>, MemoryAccessError>;
}

impl<'data> Matchable<'data> for Memory<'data> {
    fn captures(
        &'data self,
        pattern: &Pattern,
        address: usize,
    ) -> Result<Option<Vec<patternsleuth_scanner::Capture<'data>>>, MemoryAccessError> {
        let s = self.get_section_containing(address)?;
        // TODO bounds check data passed to captures
        Ok(pattern.captures(s.data(), s.address(), address - s.address()))
    }
}

pub mod disassemble {
    use std::{collections::HashSet, ops::Range};

    use iced_x86::{Decoder, DecoderOptions, FlowControl, Formatter, Instruction, NasmFormatter};

    use crate::{Image, MemoryAccessError, MemoryTrait};

    pub fn function_range(
        exe: &Image<'_>,
        address: usize,
    ) -> Result<Range<usize>, MemoryAccessError> {
        let min = address;
        let mut max = min;
        disassemble(exe, address, |inst| {
            let cur = inst.ip() as usize;
            if Some(address) != exe.get_root_function(cur)?.map(|f| f.range.start) {
                return Ok(Control::Break);
            }
            max = max.max(cur + inst.len());
            Ok(Control::Continue)
        })?;
        Ok(min..max)
    }

    pub fn disassemble_single<'mem, 'img: 'mem>(
        exe: &'img Image<'mem>,
        address: usize,
    ) -> Result<Option<Instruction>, MemoryAccessError> {
        Ok(Decoder::with_ip(
            64,
            exe.memory.range_from(address..)?,
            address as u64,
            DecoderOptions::NONE,
        )
        .iter()
        .next())
    }

    pub enum Control {
        Continue,
        Break,
        Exit,
    }

    pub fn disassemble<'mem, 'img: 'mem, F>(
        exe: &'img Image<'mem>,
        address: usize,
        mut visitor: F,
    ) -> Result<(), MemoryAccessError>
    where
        F: FnMut(&Instruction) -> Result<Control, MemoryAccessError>,
    {
        struct Ctx<'mem, 'img: 'mem> {
            exe: &'img Image<'mem>,
            queue: Vec<usize>,
            visited: HashSet<usize>,
            address: usize,
            block: &'mem [u8],
            decoder: Decoder<'mem>,
            instruction: Instruction,
        }

        let block = exe.memory.range_from(address..)?;
        let mut ctx = Ctx {
            exe,
            queue: Default::default(),
            visited: Default::default(),
            address,
            block,
            decoder: Decoder::with_ip(64, block, address as u64, DecoderOptions::NONE),
            instruction: Default::default(),
        };

        impl<'img, 'mem> Ctx<'img, 'mem> {
            #[allow(unused)]
            fn print(&self) {
                let mut formatter = NasmFormatter::new();
                //formatter.options_mut().set_digit_separator("`");
                //formatter.options_mut().set_first_operand_char_index(10);

                let mut output = String::new();
                formatter.format(&self.instruction, &mut output);

                // Eg. "00007FFAC46ACDB2 488DAC2400FFFFFF     lea       rbp,[rsp-100h]"
                print!("{:016X} ", self.instruction.ip());
                let start_index = self.instruction.ip() as usize - self.address;
                let instr_bytes = &self.block[start_index..start_index + self.instruction.len()];
                for b in instr_bytes.iter() {
                    print!("{:02X}", b);
                }
                if instr_bytes.len() < 0x10 {
                    for _ in 0..0x10 - instr_bytes.len() {
                        print!("  ");
                    }
                }
                println!(" {}", output);
            }
            fn start(&mut self, address: usize) -> Result<(), MemoryAccessError> {
                //println!("starting at {address:x}");
                self.address = address;
                self.block = self.exe.memory.range_from(self.address..)?;
                self.decoder =
                    Decoder::with_ip(64, self.block, self.address as u64, DecoderOptions::NONE);
                Ok(())
            }
            /// Returns true if pop was successful
            fn pop(&mut self) -> Result<bool, MemoryAccessError> {
                Ok(if let Some(next) = self.queue.pop() {
                    self.start(next)?;
                    true
                } else {
                    false
                })
            }
        }

        while ctx.decoder.can_decode() {
            ctx.decoder.decode_out(&mut ctx.instruction);

            let addr = ctx.instruction.ip() as usize;

            if ctx.visited.contains(&addr) {
                if ctx.pop()? {
                    continue;
                } else {
                    break;
                }
            } else {
                ctx.visited.insert(addr);
                match visitor(&ctx.instruction)? {
                    Control::Continue => {}
                    Control::Break => {
                        if ctx.pop()? {
                            continue;
                        } else {
                            break;
                        }
                    }
                    Control::Exit => {
                        break;
                    }
                }
            }

            /*
            if !matches!(ctx.instruction.flow_control(), FlowControl::Next) {
                //println!();
            }
            ctx.print();
            if !matches!(ctx.instruction.flow_control(), FlowControl::Next) {
                //println!();
            }
            */

            match ctx.instruction.flow_control() {
                FlowControl::Next => {}
                FlowControl::UnconditionalBranch => {
                    // TODO figure out how to handle tail calls
                    ctx.start(ctx.instruction.near_branch_target() as usize)?;
                }
                //FlowControl::IndirectBranch => todo!(),
                FlowControl::ConditionalBranch => {
                    ctx.queue
                        .push(ctx.instruction.near_branch_target() as usize);
                }
                FlowControl::Return => {
                    if !ctx.pop()? {
                        break;
                    }
                }
                //FlowControl::Call => todo!(),
                //FlowControl::IndirectCall => todo!(),
                //FlowControl::Interrupt => todo!(),
                //FlowControl::XbeginXabortXend => todo!(),
                //FlowControl::Exception => todo!(),
                _ => {}
            }
        }
        Ok(())
    }
}

```

`patternsleuth/src/process/external.rs`:

```rs
#[cfg(target_os = "linux")]
pub use linux::*;

#[cfg(target_os = "linux")]
mod linux {
    use std::ops::Range;

    use anyhow::{bail, Context, Result};
    use object::{Object, ObjectSection};

    use crate::{image, Image, Memory};

    fn read_process_mem(pid: i32, address: usize, buffer: &mut [u8]) -> Result<usize> {
        unsafe {
            let read = libc::process_vm_readv(
                pid as _,
                &libc::iovec {
                    iov_base: buffer.as_mut_ptr() as _,
                    iov_len: buffer.len(),
                },
                1,
                &libc::iovec {
                    iov_base: address as _,
                    iov_len: buffer.len(),
                },
                1,
                0,
            );

            if read == -1 {
                bail!("failed to read PID={pid} addr=0x{address:x}")
            }

            Ok(read as usize)
        }
    }

    /// Read `/proc/<PID>/maps` and find region ending with ".exe" which is the main module for
    /// processes running under WINE
    fn find_main_module(pid: i32) -> Result<Range<usize>> {
        let maps = std::fs::read_to_string(format!("/proc/{pid}/maps"))
            .with_context(|| format!("could not read process maps (PID={pid})"))?;
        for line in maps.lines() {
            let mut split = line.splitn(6, |c: char| c.is_whitespace());
            if let [Some(range), Some(_permissions), Some(_offset), Some(_device), Some(_inode), Some(path)] = [
                split.next(),
                split.next(),
                split.next(),
                split.next(),
                split.next(),
                split.next(),
            ] {
                if path.ends_with(".exe") {
                    let (start, end) = range
                        .split_once('-')
                        .context("failed to parse map range: {range?}")?;
                    let range = usize::from_str_radix(start, 16)?..usize::from_str_radix(end, 16)?;
                    //println!("{range:x?} {permissions:?} {offset:?} {device:?} {inode:?} {:?}", path.trim_start());
                    return Ok(range);
                }
            } else {
                bail!("failed to parse line of maps: {line:?}");
            }
        }
        bail!("no main module found")
    }

    pub fn read_image_from_pid<'data>(pid: i32) -> Result<Image<'data>> {
        let main_module = find_main_module(pid)?;

        let mut image_header = vec![0; main_module.len()];

        read_process_mem(pid, main_module.start, &mut image_header)?;

        let object = object::File::parse(image_header.as_slice())?;

        let mut sections = vec![];
        for section in object.sections() {
            let mut data = vec![0; section.size() as usize];
            read_process_mem(pid, section.address() as usize, &mut data)?;
            sections.push((section, data));
        }

        let memory = Memory::new_external_data(sections)?;

        image::pe::PEImage::read_inner_memory::<String>(
            object.relative_address_base() as usize,
            None,
            false,
            memory,
            object,
        )
    }
}

#[cfg(target_os = "macos")]
pub use macos::*;

#[cfg(target_os = "macos")]
mod macos {
    use anyhow::Result;

    use crate::Image;

    pub fn read_image_from_pid<'data>(pid: i32) -> Result<Image<'data>> {
        todo!()
    }
}

#[cfg(windows)]
pub use windows::*;

#[cfg(windows)]
mod windows {
    use anyhow::{bail, Result};
    use object::{Object, ObjectSection};

    use crate::image::pe::PEImage;
    use crate::{Image, Memory};

    use windows::Win32::Foundation::HMODULE;
    use windows::Win32::System::Diagnostics::Debug::ReadProcessMemory;
    use windows::Win32::System::ProcessStatus::{
        EnumProcessModules, GetModuleInformation, MODULEINFO,
    };
    use windows::Win32::System::Threading::{
        OpenProcess, PROCESS_QUERY_INFORMATION, PROCESS_VM_READ,
    };

    pub fn read_image_from_pid<'data>(pid: i32) -> Result<Image<'data>> {
        let (memory, base) = unsafe {
            let process = OpenProcess(
                PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
                false,
                pid as u32,
            )?;

            let mut modules = [Default::default(); 1];
            let mut out_len = 0;
            EnumProcessModules(
                process,
                modules.as_mut_ptr(),
                (modules.len() * std::mem::size_of::<HMODULE>()) as u32,
                &mut out_len,
            )?;

            if out_len < 1 {
                bail!("expected at least one module");
            }

            let mut info = MODULEINFO::default();
            GetModuleInformation(
                process,
                modules[0],
                &mut info,
                std::mem::size_of::<MODULEINFO>() as u32,
            )?;

            let mut mem = vec![0u8; info.SizeOfImage as usize];
            ReadProcessMemory(
                process,
                info.lpBaseOfDll,
                mem.as_mut_ptr() as *mut std::ffi::c_void,
                mem.len(),
                None,
            )?;

            (mem, info.lpBaseOfDll as usize)
        };

        let object = object::File::parse(memory.as_slice())?;

        let mut sections = vec![];
        for section in object.sections() {
            let mut data = vec![0; section.size() as usize];
            let start = section.address() as usize - object.relative_address_base() as usize;
            let end = section.size() as usize + start;
            // TODO avoid this copy and re-allocation
            data.copy_from_slice(&memory[start..end]);
            sections.push((section, data));
        }

        let memory = Memory::new_external_data(sections)?;

        PEImage::read_inner_memory::<String>(base, None, false, memory, object)
    }
}

```

`patternsleuth/src/process/internal.rs`:

```rs
#[cfg(target_os = "linux")]
pub use linux::*;

#[cfg(target_os = "linux")]
mod linux {
    use std::ptr::{null, null_mut};

    use anyhow::Result;

    use crate::Image;
    use libc::{dl_iterate_phdr, Elf64_Addr, Elf64_Phdr, Elf64_Sxword, Elf64_Xword, PT_LOAD};

    #[repr(C)]
    #[derive(Debug)]
    pub struct Elf64Dyn {
        pub d_tag: Elf64_Sxword,
        pub d_val: Elf64_Xword,
    }

    const DT_NUM: usize = 34;

    #[repr(C)]
    #[derive(Debug)]
    pub struct LinkMap {
        pub l_addr: Elf64_Addr,
        pub l_name: *const libc::c_char,
        pub l_ld: *const Elf64Dyn,
        pub l_next: *const LinkMap,
        pub l_prev: *const LinkMap,
        pub l_real: *const LinkMap,
        pub l_ns: usize,
        pub l_libname: *const libc::c_void,
        pub l_info: [*const Elf64Dyn; DT_NUM],
    }

    unsafe extern "C" fn dl_iterate_phdr_callback(
        info: *mut libc::dl_phdr_info,
        _size: usize,
        data: *mut std::ffi::c_void,
    ) -> i32 {
        let name = unsafe { std::ffi::CStr::from_ptr((*info).dlpi_name) };
        let name = name.to_str().unwrap();
        let image = data as *mut libc::dl_phdr_info;
        //eprintln!("Name: {}", name);
        //eprintln!("BaseAddr: {:08x}", (*info).dlpi_addr);
        if name.is_empty() {
            // find the main
            //eprintln!("Base addr from iter = {:08x}", (*info).dlpi_addr);
            *image = *info;
        }
        0
    }

    pub fn read_image<'data>() -> Result<Image<'data>> {
        unsafe {
            let mut info = libc::dl_phdr_info {
                dlpi_addr: 0,
                dlpi_name: null(),
                dlpi_phdr: null(),
                dlpi_phnum: 0,
                dlpi_adds: 0,
                dlpi_subs: 0,
                dlpi_tls_modid: 0,
                dlpi_tls_data: null_mut(),
            };
            dl_iterate_phdr(
                Some(dl_iterate_phdr_callback),
                (&mut info) as *mut libc::dl_phdr_info as *mut std::ffi::c_void,
            );

            // base addr is the offset to the real map from the vaddr in elf
            let base_addr = (info).dlpi_addr as usize;
            //eprintln!("Base addr {} (should be zero)", base_addr);

            //eprintln!("ph num = {}", info.dlpi_phnum);
            let phdr_slice = std::slice::from_raw_parts_mut(
                (info).dlpi_phdr as *mut Elf64_Phdr,
                (info).dlpi_phnum as usize,
            );
            // print all phdr
            /*for p in phdr_slice.iter() {
                eprintln!("Range: {:08x} -- {:08x} ", p.p_vaddr, p.p_vaddr + p.p_memsz);
                eprintln!("P_TYPE: {} (load = 1)", p.p_type);
            }*/
            let map_end = phdr_slice
                .iter()
                .filter(|p| p.p_type == PT_LOAD)
                .map(|p| p.p_vaddr + p.p_memsz)
                .max()
                .unwrap_or_default() as usize;
            let map_start = phdr_slice
                .iter()
                .filter(|p| p.p_type == PT_LOAD)
                .map(|p| p.p_vaddr)
                .min()
                .unwrap_or_default() as usize;

            let data = std::slice::from_raw_parts(
                (base_addr + map_start) as *const u8,
                map_end - map_start,
            );
            #[cfg(feature = "symbols")]
            let exe_path = std::fs::read_link("/proc/self/exe").ok();
            #[cfg(not(feature = "symbols"))]
            let exe_path: Option<std::path::PathBuf> = None;
            //eprintln!("Reading image internal");
            Image::read(Some(base_addr), data, exe_path, false)
        }
    }
}

#[cfg(windows)]
pub use windows::*;

#[cfg(windows)]
mod windows {
    use anyhow::{Context, Result};
    use object::{Object, ObjectSection};
    use windows::Win32::System::{
        LibraryLoader::GetModuleHandleA,
        ProcessStatus::{GetModuleInformation, MODULEINFO},
        Threading::GetCurrentProcess,
    };

    use crate::image::pe::PEImage;
    use crate::{Image, Memory};

    pub fn read_image<'data>() -> Result<Image<'data>> {
        let main_module =
            unsafe { GetModuleHandleA(None) }.context("could not find main module")?;
        let process = unsafe { GetCurrentProcess() };

        let mut mod_info = MODULEINFO::default();
        unsafe {
            GetModuleInformation(
                process,
                main_module,
                &mut mod_info as *mut _,
                std::mem::size_of::<MODULEINFO>() as u32,
            )?
        };

        let memory = unsafe {
            std::slice::from_raw_parts(
                mod_info.lpBaseOfDll as *mut u8,
                mod_info.SizeOfImage as usize,
            )
        };

        let object = object::File::parse(memory)?;

        let image_base_address = object.relative_address_base() as usize;

        let mut sections = vec![];
        for section in object.sections() {
            let addr = section.address() as usize - image_base_address;
            let size = section.size() as usize;
            sections.push((section, &memory[addr..addr + size]));
        }

        let memory = Memory::new_internal_data(sections)?;

        PEImage::read_inner_memory::<String>(image_base_address, None, false, memory, object)
    }
}

```

`patternsleuth/src/process/mod.rs`:

```rs
#[cfg(feature = "process-external")]
pub mod external;
#[cfg(feature = "process-internal")]
pub mod internal;

```

`patternsleuth/src/resolvers/mod.rs`:

```rs
pub mod unreal;

use crate::{Image, MemoryAccessError};
use futures::{
    channel::oneshot,
    executor::LocalPool,
    future::{join_all, BoxFuture},
};
use futures_scopes::{
    relay::{new_relay_scope, RelayScopeLocalSpawning},
    ScopedSpawnExt, SpawnScope,
};
use patternsleuth_scanner::Pattern;
use std::{
    any::{Any, TypeId},
    borrow::Cow,
    collections::HashMap,
    error::Error,
    sync::{Arc, Mutex},
};

/// Given an iterator of values, returns Ok(value) if all values are equal or Err
pub fn ensure_one<T: std::fmt::Debug + PartialEq>(data: impl IntoIterator<Item = T>) -> Result<T> {
    try_ensure_one(data.into_iter().map(|v| Ok(v)))
}

/// Given an iterator of values, returns Ok(value) if all values are equal or Err
pub fn try_ensure_one<T: std::fmt::Debug + PartialEq>(
    data: impl IntoIterator<Item = Result<T>>,
) -> Result<T> {
    let mut reached_max = false;

    // TODO use a stack vec to eliminate heap allocation
    let mut unique = vec![];
    for value in data.into_iter() {
        let value = value?;
        if !unique.contains(&value) {
            unique.push(value);
        }
        if unique.len() >= 4 {
            reached_max = true;
            break;
        }
    }
    match unique.len() {
        0 => Err(ResolveError::Msg("expected at least one value".into())),
        1 => Ok(unique.swap_remove(0)),
        len => Err(ResolveError::Msg(
            format!(
                "found {}{len} unique values {unique:X?}",
                if reached_max { ">=" } else { "" }
            )
            .into(),
        )),
    }
}

pub type Result<T> = std::result::Result<T, ResolveError>;
#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub enum ResolveError {
    Msg(Cow<'static, str>),
    MemoryAccessOutOfBounds(MemoryAccessError),
}
impl std::fmt::Display for ResolveError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ResolveError::Msg(msg) => write!(f, "{msg}"),
            ResolveError::MemoryAccessOutOfBounds(err) => err.fmt(f),
        }
    }
}
impl Error for ResolveError {}

impl From<MemoryAccessError> for ResolveError {
    fn from(value: MemoryAccessError) -> Self {
        Self::MemoryAccessOutOfBounds(value)
    }
}

#[macro_export]
macro_rules! _bail_out {
    ($msg:expr) => {
        return Err($crate::resolvers::ResolveError::Msg($msg.into()));
    };
}
pub use _bail_out as bail_out;

pub trait Context<T>
where
    Self: Sized,
{
    fn context(self, msg: &'static str) -> Result<T>;
}
impl<T> Context<T> for Option<T> {
    fn context(self, msg: &'static str) -> Result<T> {
        match self {
            Some(value) => Ok(value),
            None => Err(ResolveError::Msg(msg.into())),
        }
    }
}

pub struct NamedResolver {
    pub name: &'static str,
    pub getter: fn() -> &'static DynResolverFactory,
}

inventory::collect!(NamedResolver);
pub fn resolvers() -> impl Iterator<Item = &'static NamedResolver> {
    inventory::iter::<NamedResolver>()
}

type DynResolver<'ctx> = BoxFuture<'ctx, Result<Arc<dyn Resolution>>>;
type Resolver<'ctx, T> = BoxFuture<'ctx, Result<T>>;

#[cfg_attr(feature = "serde-resolvers", typetag::serde(tag = "type"))]
pub trait Resolution: std::fmt::Debug + std::any::Any + Send + Sync + Singleton + DynEq {}

/// Allow comparison of dyn Resolution
/// https://users.rust-lang.org/t/how-to-compare-two-trait-objects-for-equality/88063/3
pub trait DynEq: Any + DynEqHelper {
    fn as_any(&self) -> &dyn Any;
    fn as_dyn_eq_helper(&self) -> &dyn DynEqHelper;
    fn level_one(&self, arg2: &dyn DynEqHelper) -> bool;

    fn dyn_eq<T: PartialEq + 'static>(&self, other: &T) -> bool
    where
        Self: Sized,
    {
        if let Some(this) = self.as_any().downcast_ref::<T>() {
            this == other
        } else {
            false
        }
    }
}
pub trait DynEqHelper {
    fn level_two(&self, arg1: &dyn DynEq) -> bool;
}
impl<T: Any + PartialEq> DynEq for T {
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_dyn_eq_helper(&self) -> &dyn DynEqHelper {
        self
    }
    fn level_one(&self, arg2: &dyn DynEqHelper) -> bool {
        arg2.level_two(self)
    }
}
impl<T: Any + PartialEq> DynEqHelper for T {
    fn level_two(&self, arg1: &dyn DynEq) -> bool {
        if let Some(other) = arg1.as_any().downcast_ref::<Self>() {
            other.dyn_eq(self)
        } else {
            false
        }
    }
}
impl PartialEq for dyn Resolution {
    fn eq(&self, other: &Self) -> bool {
        self.level_one(other.as_dyn_eq_helper())
    }
}

pub struct DynResolverFactory {
    pub factory: for<'ctx> fn(&'ctx AsyncContext<'_>) -> DynResolver<'ctx>,
}

pub struct ResolverFactory<T> {
    pub factory: for<'ctx> fn(&'ctx AsyncContext<'_>) -> Resolver<'ctx, T>,
}

pub use ::futures;
pub use ::inventory;
#[cfg(feature = "serde-resolvers")]
pub use ::typetag;

pub trait PleaseAddCollectForMe {}

#[macro_export]
macro_rules! _matcharm_generator {
    ($enum_name_it:ident { $( $img_ident:ident( $img_ty:ty, $img_feature:literal )),* $(,)? }, {$ctx:ident, $name:ident}) => {
        {
            let img = &$ctx.image().image_type;
            let mut res = None;
            $(
                $crate::resolvers::cfg_image::$img_ident! {
                    if matches!(img, $crate::image::$enum_name_it::$img_ident(_)) {
                        res = Some($name::$img_ident($ctx).await);
                    }
                }
            )*
            res.unwrap()
        }
    }
}

#[cfg(feature = "image-pe")]
#[macro_export]
macro_rules! _cfg_image_pe { ($($args:tt)*) => { $($args)* } }
#[cfg(not(feature = "image-pe"))]
#[macro_export]
macro_rules! _cfg_image_pe {
    ($($args:tt)*) => {};
}
#[cfg(feature = "image-elf")]
#[macro_export]
macro_rules! _cfg_image_elf { ($($args:tt)*) => { $($args)* } }
#[cfg(not(feature = "image-elf"))]
#[macro_export]
macro_rules! _cfg_image_elf {
    ($($args:tt)*) => {};
}

#[macro_export]
macro_rules! _impl_resolver {
    (all, $name:ident, |$ctx:ident| async $x:block ) => {
        $crate::_impl_resolver_inner!($name, |$ctx| async $x);

        impl $crate::resolvers::Singleton for $name {
            fn get(&self) -> Option<usize> {
                None
            }
        }
    };

    ($arch:ident, $name:ident, |$ctx:ident| async $x:block ) => {
        $crate::resolvers::cfg_image::$arch! {
            impl $name where $name: $crate::resolvers::PleaseAddCollectForMe {
                #[allow(non_snake_case)]
                pub async fn $arch($ctx: &$crate::resolvers::AsyncContext<'_>) -> $crate::resolvers::Result<$name> $x
            }
        }
    };

    (collect, $name:ident) => {
        $crate::_impl_resolver_inner!($name, |ctx| async {
            $crate::image::image_type_reflection!(all, impl_resolver; generate; {ctx, $name})
        });

        impl $crate::resolvers::Singleton for $name {
            fn get(&self) -> Option<usize> {
                None
            }
        }

        impl $crate::resolvers::PleaseAddCollectForMe for $name {}
    };

    (generate, $enum_name_it:ident { $( $img_ident:ident( $img_ty:ty, $img_feature:literal )),* $(,)? }, {$ctx:ident, $name:ident}) => {
        $crate::resolvers::matcharm_generator!(
            $enum_name_it { $( $img_ident( $img_ty, $img_feature )),* },
            { $ctx, $name }
        )
    };
}

#[macro_export]
macro_rules! _impl_resolver_singleton {
    (all, $name:ident, |$ctx:ident| async $x:block ) => {
        $crate::_impl_resolver_inner!($name, |$ctx| async {
            if let Some(a) = std::env::var(concat!("PATTERNSLEUTH_RES_", stringify!($name))).ok().and_then(|s| (s.strip_prefix("0x").map(|s| usize::from_str_radix(s, 16).ok()).unwrap_or_else(|| s.parse().ok()))) {
                return Ok($name(a));
            }
            $x
        });

        impl $crate::resolvers::Singleton for $name {
            fn get(&self) -> Option<usize> {
                Some(self.0)
            }
        }
    };

    ($arch:ident, $name:ident, |$ctx:ident| async $x:block ) => {
        $crate::resolvers::cfg_image::$arch! {
            impl $name where $name: $crate::resolvers::PleaseAddCollectForMe {
                #[allow(non_snake_case)]
                async fn $arch($ctx: &$crate::resolvers::AsyncContext<'_>) -> $crate::resolvers::Result<$name> $x
            }
        }
    };

    (collect, $name:ident) => {
        $crate::_impl_resolver_inner!($name, |ctx| async {
            if let Some(a) = std::env::var(concat!("PATTERNSLEUTH_RES_", stringify!($name))).ok().and_then(|s| (s.strip_prefix("0x").map(|s| usize::from_str_radix(s, 16).ok()).unwrap_or_else(|| s.parse().ok()))) {
                return Ok($name(a));
            }
            $crate::image::image_type_reflection!(all, impl_resolver_singleton; generate; {ctx, $name})
        });

        impl $crate::resolvers::Singleton for $name {
            fn get(&self) -> Option<usize> {
                Some(self.0)
            }
        }

        impl $crate::resolvers::PleaseAddCollectForMe for $name {}
    };

    (generate, $enum_name_it:ident { $( $img_ident:ident( $img_ty:ty, $img_feature:literal )),* $(,)? }, {$ctx:ident, $name:ident}) => {
        $crate::resolvers::matcharm_generator!(
            $enum_name_it { $( $img_ident( $img_ty, $img_feature )),* },
            { $ctx, $name }
        )
    };
}
#[macro_export]
macro_rules! _impl_resolver_inner {
    ( $name:ident, |$ctx:ident| async $x:block ) => {
        $crate::resolvers::inventory::submit! {
            $crate::resolvers::NamedResolver { name: stringify!($name), getter: $name::dyn_resolver }
        }

        #[cfg_attr(feature = "serde-resolvers", $crate::resolvers::typetag::serde)]
        impl $crate::resolvers::Resolution for $name {}

        impl $name {
            pub fn resolver() -> &'static $crate::resolvers::ResolverFactory<$name> {
                static GLOBAL: ::std::sync::OnceLock<&$crate::resolvers::ResolverFactory<$name>> = ::std::sync::OnceLock::new();

                GLOBAL.get_or_init(|| &$crate::resolvers::ResolverFactory {
                    factory: |$ctx: &$crate::resolvers::AsyncContext| -> $crate::resolvers::futures::future::BoxFuture<$crate::resolvers::Result<$name>> {
                        Box::pin(async $x)
                    },
                })
            }
            pub fn dyn_resolver() -> &'static $crate::resolvers::DynResolverFactory {
                static GLOBAL: ::std::sync::OnceLock<&$crate::resolvers::DynResolverFactory> = ::std::sync::OnceLock::new();

                GLOBAL.get_or_init(|| &$crate::resolvers::DynResolverFactory {
                    factory: |$ctx: &$crate::resolvers::AsyncContext| -> $crate::resolvers::futures::future::BoxFuture<$crate::resolvers::Result<::std::sync::Arc<dyn $crate::resolvers::Resolution>>> {
                        Box::pin(async {
                            $ctx.resolve(Self::resolver()).await.map(|ok| -> ::std::sync::Arc<dyn $crate::resolvers::Resolution> { ok })
                        })
                    },
                })
            }
        }
    };
}

#[macro_export]
macro_rules! _impl_try_collector {
    (
        $(#[$outer:meta])*
        $struct_vis:vis struct $struct_name:ident {
            $(
                $(#[$inner:ident $($args:tt)*])*
                $member_vis:vis $member_name:ident: $resolver:path,
            )*
        }
    ) => {
        #[allow(non_snake_case)]
        $(#[$outer])*
        $struct_vis struct $struct_name {
            $(
                $(#[$inner $($args)*])*
                $member_vis $member_name: ::std::sync::Arc<$resolver>,
            )*
        }
        $crate::_impl_resolver!(all, $struct_name, |ctx| async {
            #[allow(non_snake_case)]
            let (
                $( $member_name, )*
            ) = $crate::resolvers::futures::try_join!(
                $( ctx.resolve($resolver::resolver()), )*
            )?;
            Ok($struct_name {
                $( $member_name, )*
            })
        });
    };
}

#[macro_export]
macro_rules! _impl_collector {
    (
        $(#[$outer:meta])*
        $struct_vis:vis struct $struct_name:ident {
            $(
                $(#[$inner:ident $($args:tt)*])*
                $member_vis:vis $member_name:ident: $resolver:path,
            )*
        }
    ) => {
        #[allow(non_snake_case)]
        $(#[$outer])*
        $struct_vis struct $struct_name {
            $(
                $(#[$inner $($args)*])*
                $member_vis $member_name: $crate::resolvers::Result<::std::sync::Arc<$resolver>>,
            )*
        }
        $crate::_impl_resolver!(all, $struct_name, |ctx| async {
            #[allow(non_snake_case)]
            let (
                $( $member_name, )*
            ) = $crate::resolvers::futures::join!(
                $( ctx.resolve($resolver::resolver()), )*
            );
            Ok($struct_name {
                $( $member_name, )*
            })
        });
    };
}

pub use _impl_collector as impl_collector;
pub use _impl_resolver as impl_resolver;
pub use _impl_resolver_singleton as impl_resolver_singleton;
pub use _impl_try_collector as impl_try_collector;
pub use _matcharm_generator as matcharm_generator;
pub mod cfg_image {
    pub use _cfg_image_elf as ElfImage;
    pub use _cfg_image_pe as PEImage;
}

pub trait Singleton {
    fn get(&self) -> Option<usize>;
}

type AnyValue = Result<Arc<dyn Any + Send + Sync>>;

#[derive(Debug)]
struct PatternMatches {
    pattern: Pattern,
    matches: Vec<usize>,
}

#[derive(Default)]
struct AsyncContextInnerWrite {
    resolvers: HashMap<TypeId, AnyValue>,
    pending_resolvers: HashMap<TypeId, Vec<oneshot::Sender<AnyValue>>>,
    queue: Vec<(Pattern, oneshot::Sender<PatternMatches>)>,
}

struct AsyncContextInnerRead<'data> {
    write: Mutex<AsyncContextInnerWrite>,
    image: &'data Image<'data>,
}

#[derive(Clone)]
pub struct AsyncContext<'data> {
    read: Arc<AsyncContextInnerRead<'data>>,
}

impl<'data> AsyncContext<'data> {
    fn new(image: &'data Image<'data>) -> Self {
        Self {
            read: Arc::new(AsyncContextInnerRead {
                write: Default::default(),
                image,
            }),
        }
    }
    pub fn image(&self) -> &Image<'_> {
        self.read.image
    }
    pub async fn scan(&self, pattern: Pattern) -> Vec<usize> {
        self.scan_tagged((), pattern).await.2
    }
    pub async fn scan_tagged2<T: Copy>(&self, tag: T, pattern: Pattern) -> Vec<(T, usize)> {
        self.scan_tagged(tag, pattern)
            .await
            .2
            .into_iter()
            .map(|a| (tag, a))
            .collect()
    }
    pub async fn scan_tagged<T>(&self, tag: T, pattern: Pattern) -> (T, Pattern, Vec<usize>) {
        let (tx, rx) = oneshot::channel::<PatternMatches>();
        {
            let mut lock = self.read.write.lock().unwrap();
            lock.queue.push((pattern, tx));
        }
        let PatternMatches { pattern, matches } = rx.await.unwrap();
        (tag, pattern, matches)
    }
    pub async fn resolve<'ctx, T: Send + Sync + 'static>(
        &'ctx self,
        resolver: &ResolverFactory<T>,
    ) -> Result<Arc<T>> {
        let t = TypeId::of::<T>();
        let rx = {
            // first check to see if we've already computed the resolver
            let mut lock = self.read.write.lock().unwrap();
            if let Some(res) = lock.resolvers.get(&t) {
                return res.clone().map(|ok| ok.downcast::<T>().unwrap());
            }

            // no value found so check if there is a pending resolver for the same type
            if let Some(res) = lock.pending_resolvers.get_mut(&t) {
                // there is, so wait for it to complete by adding a channel
                let (tx, rx) = oneshot::channel::<AnyValue>();
                res.push(tx);

                Some(rx)
            } else {
                // TODO may be possible to used a shared future instead
                // https://docs.rs/futures/latest/futures/future/trait.FutureExt.html#method.shared
                // we're the future that is computing the resolver so init the listener vec
                lock.pending_resolvers.entry(t).or_default();
                None
            }
        };

        // some convoluted logic to drop the lock to make the future `Send`
        if let Some(rx) = rx {
            return rx.await.unwrap().map(|ok| ok.downcast::<T>().unwrap());
        }

        // compute the resolver value
        let resolver = (resolver.factory)(self);
        let res = resolver.await.map(Arc::new);

        let cache: Result<Arc<dyn Any + Send + Sync>> = match res.as_ref() {
            Ok(ok) => Ok(ok.clone()),
            Err(e) => Err(e.clone()),
        };

        // insert new value
        let mut lock = self.read.write.lock().unwrap();
        lock.resolvers.insert(t, cache.clone());

        // update any other listening futures
        for tx in lock.pending_resolvers.remove(&t).unwrap() {
            tx.send(cache.clone()).unwrap();
        }

        res
    }
}

#[tracing::instrument(level = "debug", skip_all, fields(stages))]
pub fn eval<F, T: Send + Sync>(image: &Image<'_>, f: F) -> T
where
    F: for<'ctx> FnOnce(&'ctx AsyncContext<'_>) -> BoxFuture<'ctx, T> + Send + Sync,
{
    {
        tracing::debug!("starting eval");

        let ctx = AsyncContext::new(image);
        let (rx, tx) = std::sync::mpsc::channel();

        let scope = new_relay_scope!();
        let mut pool = LocalPool::new();
        let _ = pool.spawner().spawn_scope(scope);

        scope
            .spawner()
            .spawn_scoped({
                let ctx = ctx.clone();
                async move {
                    rx.send(f(&ctx).await).unwrap();
                }
            })
            .unwrap();

        let mut i = 0;

        loop {
            i += 1;

            tracing::debug_span!("resolvers", stage = i).in_scope(|| {
                pool.run_until_stalled();
            });

            if let Ok(res) = tx.try_recv() {
                tracing::Span::current().record("stages", i);
                break res;
            } else {
                let queue: Vec<_> = std::mem::take(&mut ctx.read.write.lock().unwrap().queue);
                let (patterns, rx): (Vec<_>, Vec<_>) = queue.into_iter().unzip();
                let setup = patterns.iter().collect::<Vec<_>>();

                let span = tracing::debug_span!("patterns", patterns = setup.len()).entered();
                for p in &setup {
                    tracing::debug!("pattern = {p:?}");
                }

                let mut all_results = rx.into_iter().map(|rx| (rx, vec![])).collect::<Vec<_>>();

                for section in image.memory.sections() {
                    let span = tracing::debug_span!(
                        "section",
                        section = section.name(),
                        kind = format!("{:?}", section.kind()),
                        results = tracing::field::Empty
                    )
                    .entered();

                    let base_address = section.address();
                    let data = section.data();

                    let scan_results =
                        patternsleuth_scanner::scan_pattern(&setup, base_address, data);

                    let mut total = 0;

                    for (i, res) in scan_results.iter().enumerate() {
                        total += res.len();
                        all_results[i].1.extend(res)
                    }

                    span.record("results", total);
                }

                drop(span);

                for ((rx, matches), pattern) in all_results.into_iter().zip(patterns) {
                    rx.send(PatternMatches { pattern, matches }).unwrap();
                }
            }
        }
    }
}

pub fn resolve<T: Send + Sync>(
    image: &Image<'_>,
    resolver: &'static ResolverFactory<T>,
) -> Result<T> {
    eval(image, |ctx| Box::pin(async { ctx.resolve(resolver).await }))
        .map(|ok| Arc::<T>::into_inner(ok).unwrap())
}

pub fn resolve_many(
    image: &Image<'_>,
    resolvers: &[fn() -> &'static DynResolverFactory],
) -> Vec<Result<Arc<dyn Resolution>>> {
    let fns = resolvers.iter().map(|r| r().factory).collect::<Vec<_>>();
    eval(image, |ctx| {
        Box::pin(async { join_all(fns.into_iter().map(|f| f(ctx))).await })
    })
}

```

`patternsleuth/src/resolvers/unreal/aes.rs`:

```rs
use std::fmt::{Debug, Display};

use futures::future::join_all;

use patternsleuth_scanner::Pattern;

use crate::{
    resolvers::{impl_resolver, Result},
    MemoryTrait,
};

#[derive(PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct AESKeys(Vec<AESKey>);
impl Debug for AESKeys {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AESKeys ")?;
        f.debug_list().entries(self.0.iter()).finish()
    }
}

#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
#[derive(PartialEq, Eq, PartialOrd, Ord)]
pub struct AESKey([u8; 32]);
impl Display for AESKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "0x")?;
        for b in self.0 {
            write!(f, "{:02x}", b)?;
        }
        Ok(())
    }
}
impl Debug for AESKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        Display::fmt(&self, f)
    }
}

impl_resolver!(collect, AESKeys);
impl_resolver!(PEImage, AESKeys, |ctx| async {
    #[derive(Debug, Clone, Copy)]
    enum KeyType {
        A,
        B,
        C,
    }
    let patterns = [
        (KeyType::A, "C7 45 D0 ?? ?? ?? ?? C7 45 D4 ?? ?? ?? ?? ?? ?? ?? ?? C7 45 D8 ?? ?? ?? ?? C7 45 DC ?? ?? ?? ?? C7 45 E0 ?? ?? ?? ?? C7 45 E4 ?? ?? ?? ?? C7 45 E8 ?? ?? ?? ?? C7 45 EC ?? ?? ?? ??"),
        (KeyType::B, "C7 01 ?? ?? ?? ?? C7 41 04 ?? ?? ?? ?? C7 41 08 ?? ?? ?? ?? C7 41 0C ?? ?? ?? ?? C7 41 10 ?? ?? ?? ?? C7 41 14 ?? ?? ?? ?? C7 41 18 ?? ?? ?? ?? C7 41 1C ?? ?? ?? ?? C3"),
        (KeyType::C, "C7 45 D0 ?? ?? ?? ?? C7 45 D4 ?? ?? ?? ?? C7 45 D8 ?? ?? ?? ?? C7 45 DC ?? ?? ?? ?? 0F 10 45 D0 C7 45 E0 ?? ?? ?? ?? C7 45 E4 ?? ?? ?? ?? C7 45 E8 ?? ?? ?? ?? C7 45 EC ?? ?? ?? ??"),
    ];

    let res = join_all(
        patterns
            .iter()
            .map(|(tag, p)| ctx.scan_tagged(tag, Pattern::new(p).unwrap())),
    )
    .await;

    let mem = &ctx.image().memory;

    let extract_key = |key_type: KeyType, addresses: Vec<usize>| {
        addresses.into_iter().map(move |addr| -> Result<_> {
            let mut key = [0; 32];
            match key_type {
                KeyType::A => {
                    let data = &mem.range(addr..addr + 60)?;
                    (key[0..4]).copy_from_slice(&data[3..7]);
                    (key[4..8]).copy_from_slice(&data[10..14]);
                    (key[8..12]).copy_from_slice(&data[21..25]);
                    (key[12..16]).copy_from_slice(&data[28..32]);
                    (key[16..20]).copy_from_slice(&data[35..39]);
                    (key[20..24]).copy_from_slice(&data[42..46]);
                    (key[24..28]).copy_from_slice(&data[49..53]);
                    (key[28..32]).copy_from_slice(&data[56..60]);
                }
                KeyType::B => {
                    let data = &mem.range(addr..addr + 55)?;
                    (key[0..4]).copy_from_slice(&data[2..6]);
                    (key[4..8]).copy_from_slice(&data[9..13]);
                    (key[8..12]).copy_from_slice(&data[16..20]);
                    (key[12..16]).copy_from_slice(&data[23..27]);
                    (key[16..20]).copy_from_slice(&data[30..34]);
                    (key[20..24]).copy_from_slice(&data[37..41]);
                    (key[24..28]).copy_from_slice(&data[44..48]);
                    (key[28..32]).copy_from_slice(&data[51..55]);
                }
                KeyType::C => {
                    let data = &mem.range(addr..addr + 60)?;
                    (key[0..4]).copy_from_slice(&data[3..7]);
                    (key[4..8]).copy_from_slice(&data[10..14]);
                    (key[8..12]).copy_from_slice(&data[17..21]);
                    (key[12..16]).copy_from_slice(&data[24..28]);
                    (key[16..20]).copy_from_slice(&data[35..39]);
                    (key[20..24]).copy_from_slice(&data[42..46]);
                    (key[24..28]).copy_from_slice(&data[49..53]);
                    (key[28..32]).copy_from_slice(&data[56..60]);
                }
            };
            Ok(if key == *b"\x6f\x16\x80\x73\xb9\xb2\x14\x49\xd7\x42\x24\x17\x00\x06\x8a\xda\xbc\x30\x6f\xa9\xaa\x38\x31\x16\x4d\xee\x8d\xe3\x4e\x0e\xfb\xb0" {
                None
            } else {
                Some(AESKey(key))
            })
        })
    };

    Ok(Self(
        res.into_iter()
            .flat_map(|(key, _, addresses)| extract_key(*key, addresses))
            .flat_map(|i| i.transpose())
            .collect::<Result<Vec<_>>>()?,
    ))
});

impl_resolver!(ElfImage, AESKeys, |_ctx| async {
    super::bail_out!("ElfImage unimplemented");
});

```

`patternsleuth/src/resolvers/unreal/blueprint_library.rs`:

```rs
use std::fmt::Debug;

use futures::{future::join_all, join};

use patternsleuth_scanner::Pattern;

use crate::{
    resolvers::{ensure_one, impl_resolver, impl_resolver_singleton, Context},
    Addressable, Matchable,
};

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct BlueprintLibraryInit {
    pub uclass_compiled_in_defer: usize,
    pub uobject_compiled_in_defer: usize,
    pub construct_uclass: usize,
    pub get_private_static_class_body: usize,
    pub uobject_static_class: usize,
    pub ublueprint_function_library_static_class: usize,
}

impl_resolver!(all, BlueprintLibraryInit, |ctx| async {
    let mem = &ctx.image().memory;

    let class_str = Pattern::from_bytes(
        "UKismetStringTableLibrary\x00"
            .encode_utf16()
            .flat_map(u16::to_le_bytes)
            .collect(),
    )
    .unwrap();

    let class_str = ctx.scan(class_str).await;

    let pattern_dyn_init_class = |s: usize| {
        Pattern::new(format!("41 b9 ?? ?? ?? ?? 48 8d 15 X0x{:x} 41 b8 28 00 00 00 48 8d 0d [ ?? ?? ?? ?? ] e9 [ ?? ?? ?? ?? ]", s)).unwrap()
    };
    let pattern_dyn_init_object = |s: usize| {
        Pattern::new(format!(
            "
                48 83 ec 48
                33 c0
                4c 8d 0d ?? ?? ?? ??
                48 89 44 24 30
                4c 8d 05 X0x{:x}
                48 89 44 24 28
                48 8d 15 [ ?? ?? ?? ?? ]
                48 8d 0d [ ?? ?? ?? ?? ]
                88 44 24 20
                e8 [ ?? ?? ?? ?? ]
                48 83 c4 48
                c3
            ",
            s
        ))
        .unwrap()
    };

    let construct_uclass_pattern = Pattern::new(
        "
            48 83 ec 28
            48 8b 05 ?? ?? ?? ??
            48 85 c0
            75 1a
            48 8d 15 ?? ?? ?? ??
            48 8d 0d ?? ?? ?? ??
            e8 [ ?? ?? ?? ?? ]
            48 8b 05 ?? ?? ?? ??
            48 83 c4 28
            c3
        ",
    )
    .unwrap();

    let (init_class_refs, init_object_refs) = join!(
        join_all(
            class_str
                .iter()
                .map(|s| ctx.scan_tagged((), pattern_dyn_init_class(*s)))
        ),
        join_all(
            class_str
                .iter()
                .map(|s| ctx.scan_tagged((), pattern_dyn_init_object(*s)))
        )
    );

    let uclass_compiled_in_defer =
        ensure_one(init_class_refs.into_iter().flat_map(|(_, p, a)| {
            a.into_iter()
                .flat_map(move |a| mem.captures(&p, a).ok().flatten().map(|c| c[1].rip()))
        }))?;
    let (get_private_static_class_wrapper, construct_uclass_wrapper, uobject_compiled_in_defer) =
        ensure_one(init_object_refs.into_iter().flat_map(|(_, p, a)| {
            a.into_iter().flat_map(move |a| {
                mem.captures(&p, a)
                    .ok()
                    .flatten()
                    .map(|c| (c[0].rip(), c[1].rip(), c[2].rip()))
            })
        }))?;

    let construct_uclass = mem
        .captures(&construct_uclass_pattern, construct_uclass_wrapper)?
        .context("Construct_UClass pattern did not match")?[0]
        .rip();

    let get_private_static_class_pattern = Pattern::new(
        "
            4c 8b dc
            48 81 ec 88 00 00 00
            48 8b 05 ?? ?? ?? ??
            48 85 c0
            0f 85 90 00 00 00
            33 c9
            48 8d 05 [ ?? ?? ?? ?? ]
            49 89 4b f0
            4c 8d 0d ?? ?? ?? ??
            88 4c 24 70
            4c 8d 05 ?? ?? ?? ??
            49 89 43 e0
            48 8d 15 ?? ?? ?? ??
            48 8d 05 [ ?? ?? ?? ?? ]
            49 89 43 d8
            48 8d 05 ?? ?? ?? ??
            49 89 43 d0
            48 8d 05 ?? ?? ?? ??
            49 89 43 c8
            48 8d 05 ?? ?? ?? ??
            49 89 43 c0
            48 8d 05 ?? ?? ?? ??
            49 89 43 b8
            49 89 4b b0
            48 8d 0d ?? ?? ?? ??
            c7 44 24 30 ?? ?? ?? ??
            c7 44 24 28 ?? ?? ?? ??
            c7 44 24 20 ?? ?? ?? ??
            e8 [ ?? ?? ?? ?? ]
            48 8b 05 ?? ?? ?? ??
            48 81 c4 88 00 00 00
            c3
    ",
    )
    .unwrap();

    let (
        uobject_static_class,
        ublueprint_function_library_static_class,
        get_private_static_class_body,
    ) = {
        let captures = mem
            .captures(
                &get_private_static_class_pattern,
                get_private_static_class_wrapper,
            )?
            .context("Construct_UClass pattern did not match")?;

        (captures[0].rip(), captures[1].rip(), captures[2].rip())
    };

    Ok(Self {
        uclass_compiled_in_defer,
        uobject_compiled_in_defer,
        construct_uclass,
        get_private_static_class_body,
        uobject_static_class,
        ublueprint_function_library_static_class,
    })
});

/// UFunction::Bind
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct UFunctionBind(pub usize);
impl_resolver_singleton!(collect, UFunctionBind);
impl_resolver_singleton!(PEImage, UFunctionBind, |ctx| async {
    use crate::resolvers::unreal::util;

    let string = async {
        let strings = ctx
            .scan(util::utf16_pattern(
                "Failed to bind native function %s.%s\0",
            ))
            .await;
        let refs = util::scan_xrefs(ctx, &strings).await;
        util::root_functions(ctx, &refs)
    };

    let pattern = async {
        let patterns = [
            "48 89 5C 24 ?? 57 48 83 EC 20 33 D2 48 8B F9 48 8B D9 48 85 C9 74 3D 48 85 D2 75 38 48 85 DB 74 28 E8",
        ];

        join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await
    };

    let (string, pattern) = join!(string, pattern);

    Ok(Self(ensure_one(
        string?.into_iter().chain(pattern.into_iter().flatten()),
    )?))
});

impl_resolver_singleton!(ElfImage, UFunctionBind, |ctx| async {
    // maybe find symbol of vtable?
    let pattern = Pattern::new("41 56 53 50 49 89 fe 48 89 fb 66 0f 1f 44 00 00 e8 ?? ?? ?? ?? 48 8b 4b 10 48 63 50 38 3b 51 38 7e ?? 31 c0 48 8b 5b 20 48 85 db 75 ?? eb ?? 90 48 83 c0 30").unwrap();
    let fns = ctx.scan(pattern).await;
    Ok(Self(ensure_one(fns)?))
});

```

`patternsleuth/src/resolvers/unreal/engine_version.rs`:

```rs
use std::fmt::{Debug, Display};

use futures::future::join_all;

use itertools::Itertools;
use patternsleuth_scanner::Pattern;

use crate::{
    resolvers::{bail_out, impl_resolver, try_ensure_one},
    MemoryAccessorTrait,
};

#[derive(PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct EngineVersion {
    pub major: u16,
    pub minor: u16,
}
impl Display for EngineVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}.{}", self.major, self.minor)
    }
}
impl Debug for EngineVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EngineVersion({}.{})", self.major, self.minor)
    }
}

impl_resolver!(all, EngineVersion, |ctx| async {
    let patterns = [
        "C7 03 | 04 00 ?? 00 66 89 4B 04 48 3B F8 74 ?? 48",
        "C7 05 ?? ?? ?? ?? | 04 00 ?? 00 66 89 ?? ?? ?? ?? ?? C7 05",
        "C7 05 ?? ?? ?? ?? | 04 00 ?? 00 66 89 ?? ?? ?? ?? ?? 89",
        "41 C7 ?? | 04 00 ?? 00 ?? ?? 00 00 00 66 41 89",
        "41 C7 ?? | 04 00 18 00 66 41 89 ?? 04",
        "41 C7 04 24 | 04 00 ?? 00 66 ?? 89 ?? 24",
        "41 C7 04 24 | 04 00 ?? 00 B9 ?? 00 00 00",
        "C7 05 ?? ?? ?? ?? | 04 00 ?? 00 89 05 ?? ?? ?? ?? E8",
        "C7 05 ?? ?? ?? ?? | 04 00 ?? 00 66 89 ?? ?? ?? ?? ?? 89 05",
        "C7 46 20 | 04 00 ?? 00 66 44 89 76 24 44 89 76 28 48 39 C7",
        "C7 03 | 04 00 ?? 00 66 44 89 63 04 C7 43 08 C1 5C 08 80 E8",
        "C7 47 20 | 04 00 ?? 00 66 89 6F 24 C7 47 28 ?? ?? ?? ?? 49",
        "C7 03 | 04 00 ?? 00 66 89 6B 04 89 7B 08 48 83 C3 10",
        "41 C7 06 | 05 00 ?? ?? 48 8B 5C 24 ?? 49 8D 76 ?? 33 ED 41 89 46",
        "C7 06 | 05 00 ?? ?? 48 8B 5C 24 20 4C 8D 76 10 33 ED",
        "11 76 30 c7 46 20 | 04 00 ?? 00",
        // maybe better go from BuildSettings::GetBranchName -> FGlobalEngineVersions::FGlobalEngineVersions
        "0f 57 c0 0f 11 43 10 c7 03 | 05 ?? ?? ?? 66 c7 43 04 ?? ??", // <- last one is patch
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    try_ensure_one(
        res.iter()
            .flatten()
            .map(|a| {
                Ok(EngineVersion {
                    major: ctx.image().memory.u16_le(*a)?,
                    minor: ctx.image().memory.u16_le(a + 2)?,
                })
            })
            .filter_ok(|ver| match ver.major {
                // TODO 4.0 can false positive so ignore it. need to harden if this is to work on 4.0 games
                4 if (1..=27).contains(&ver.minor) => true,
                5 if (0..).contains(&ver.minor) => true,
                _ => false,
            }),
    )
});

/// currently seems to be 4.22+
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct EngineVersionStrings {
    pub branch_name: String,
    pub build_date: String,
    pub build_version: String,
}
impl_resolver!(collect, EngineVersionStrings);
// "++UE5+Release-{}.{}"
impl_resolver!(ElfImage, EngineVersionStrings, |ctx| async {
    use crate::resolvers::{ensure_one, unreal::util};

    let pattern_name = util::utf16_pattern("++UE5+Release-");
    let name_scan = ctx.scan(pattern_name).await;

    let mut name_scan: Vec<_> = name_scan
        .iter()
        .flat_map(|&addr| ctx.image().memory.read_wstring(addr))
        .collect();

    if name_scan.len() != 2 {
        bail_out!("not found");
    }

    name_scan.sort();
    let (branch_name, build_version) = (name_scan[0].clone(), name_scan[1].clone());

    let build_date = join_all(
        [
            "Jan ", "Feb ", "Mar ", "Apr ", "May ", "Jun ", "Jul ", "Aug ", "Sep ", "Oct ", "Nov ",
            "Dec ",
        ]
        .map(|p| ctx.scan(util::utf16_pattern(p))),
    )
    .await
    .into_iter()
    .flatten()
    .flat_map(|addr| ctx.image().memory.read_wstring(addr))
    .filter(|p| {
        let sp = p.split_whitespace().collect_vec();
        if sp.len() == 3 {
            let (dd, yyyy) = (
                sp[1].parse::<u32>().unwrap_or(0),
                sp[2].parse::<u32>().unwrap_or(0),
            );
            !(dd >= 32 || yyyy >= 2100 || yyyy <= 2000)
        } else {
            false
        }
    });

    let build_date = ensure_one(build_date)?;

    Ok(Self {
        branch_name,
        build_date,
        build_version,
    })
});

impl_resolver!(PEImage, EngineVersionStrings, |ctx| async {
    use crate::{Addressable, Matchable, MemoryTrait};
    use std::collections::HashSet;

    let patterns = [
        "48 8D 05 [ ?? ?? ?? ?? ] C3 CC CC CC CC CC CC CC CC 48 8D 05 [ ?? ?? ?? ?? ] C3 CC CC CC CC CC CC CC CC 48 8D 05 [ ?? ?? ?? ?? ] C3 CC CC CC CC CC CC CC CC",
    ];

    let res = join_all(
        patterns
            .iter()
            .map(|p| ctx.scan_tagged((), Pattern::new(p).unwrap())),
    )
    .await;

    let mem = &ctx.image().memory;

    let months = [
        "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    ]
    .into_iter()
    .map(|month| month.encode_utf16().flat_map(u16::to_le_bytes).collect())
    .collect::<HashSet<Vec<u8>>>();

    for (_, pattern, addresses) in res {
        for a in addresses {
            let caps = mem.captures(&pattern, a)?.unwrap();
            let date = caps[1].rip();
            if mem
                .range(date..date + 6)
                .ok()
                .filter(|r| months.contains(&r[..]))
                .is_some()
            {
                return Ok(EngineVersionStrings {
                    branch_name: mem.read_wstring(caps[0].rip())?,
                    build_date: mem.read_wstring(caps[1].rip())?,
                    build_version: mem.read_wstring(caps[2].rip())?,
                });
            }
        }
    }

    bail_out!("not found");
});

```

`patternsleuth/src/resolvers/unreal/fname.rs`:

```rs
use std::fmt::Debug;

use futures::future::join_all;

use patternsleuth_scanner::Pattern;

use crate::{
    resolvers::{ensure_one, impl_resolver_singleton, try_ensure_one, unreal::util, Result},
    MemoryAccessorTrait,
};

/// public: __cdecl FName::FName(wchar_t const *, enum EFindName)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FNameCtorWchar(pub usize);
impl_resolver_singleton!(collect, FNameCtorWchar);

// for linux we find a function caontains following strings
/*
FEngineLoop::LoadPreInitModules:
 FModuleManager::LoadModule called with following FName
    Engine
    Renderer
    AnimGraphRuntime
    Landscape
    RenderCore
*/
impl_resolver_singleton!(ElfImage, FNameCtorWchar, |ctx| async {
    use crate::resolvers::ResolveError;
    use std::collections::HashSet;

    let strings = [
        "\0Engine\0",
        "\0Renderer\0",
        "\0AnimGraphRuntime\0",
        "\0Landscape\0",
        "\0RenderCore\0",
    ];

    // find the strings
    let strings = join_all(strings.iter().map(|s| ctx.scan(util::utf16_pattern(s)))).await;
    let strings: Vec<Vec<_>> = strings
        .into_iter()
        .map(|pats| pats.into_iter().map(|addr| addr + 2).collect())
        .collect();
    //eprintln!("Find each pattern @ {:?}", strings);
    // find refs to them
    let refs: Vec<_> = join_all(strings.iter().map(|addr| util::scan_xrefs(ctx, addr))).await;
    //eprintln!("Find pattern refs @ {:?}", refs);
    let fns: Vec<_> = refs
        .into_iter()
        .flat_map(|addr| util::root_functions(ctx, &addr).ok())
        .collect();
    //eprintln!("Find pattern fns @ {:?}", fns);
    //strings.into_iter().map(|addr| async move { util::root_functions(ctx, &util::scan_xrefs(ctx, &addr).await ) } ).collect();

    // find fns of these refs
    let fns = fns
        .into_iter()
        .reduce(|x, y| {
            let x: HashSet<usize> = HashSet::from_iter(x.into_iter());
            let y: HashSet<usize> = HashSet::from_iter(y.into_iter());
            x.intersection(&y).cloned().collect::<Vec<_>>()
        })
        .unwrap();

    // output fns
    //eprintln!("Found all fns at {:?}", fns);
    let fnLoadPreInitModules = ensure_one(fns)?;
    let pattern = Pattern::new("ba 01 00 00 00 e8 | ?? ?? ?? ??").unwrap();
    // found fLoadPreInitModules, try find target
    /*
        03f30310 53              PUSH       RBX
        03f30311 48  83  ec       SUB        RSP ,0x30
                 30
        03f30315 e8  c6  25       CALL       FUN_06c928e0                                     undefined FUN_06c928e0()
                 d6  02
        03f3031a 48  89  c3       MOV        RBX ,RAX
        03f3031d 48  8d  7c       LEA        RDI => local_10 ,[RSP  + 0x28 ]
                 24  28
        03f30322 be  38  8a       MOV        ESI ,u_Engine_00868a38                           = u"Engine"
                 86  00
        03f30327 ba  01  00       MOV        EDX ,0x1 <--- pat
                 00  00
        03f3032c e8  af  71       CALL       FName::FName     <- call                                void FName(undefined8 * this, us
                 dc  02
    */
    let mem = ctx
        .image()
        .memory
        .get_section_containing(fnLoadPreInitModules)
        .unwrap();
    let index = fnLoadPreInitModules - mem.address();
    let mut result = None;
    for i in 0..48 {
        if pattern.is_match(mem.data(), mem.address(), index + i) {
            result = ctx
                .image()
                .memory
                .rip4(fnLoadPreInitModules + i + pattern.custom_offset)
                .ok();
        }
    }
    // how to scan code from X?
    let result = result.ok_or(ResolveError::Msg("cannot find address".into()))?;
    /*
    Post check
    if util::root_functions(ctx, &[result]).unwrap()[0] == result {
        eprintln!("ok!!");
    }
    */
    Ok(Self(result))
});

impl_resolver_singleton!(PEImage, FNameCtorWchar, |ctx| async {
    use crate::{resolvers::Context, MemoryTrait};
    use futures::join;
    use iced_x86::{Code, Decoder, DecoderOptions};

    let strings = async {
        let strings = ["TGPUSkinVertexFactoryUnlimited\0", "MovementComponent0\0"];
        join_all(strings.iter().map(|s| ctx.scan(util::utf16_pattern(s)))).await
    };
    let patterns = async {
        ctx.scan(Pattern::new("EB 07 48 8D 15 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 41 B8 01 00 00 00 E8 | ?? ?? ?? ??").unwrap()).await
    };
    let (patterns, strings) = join!(patterns, strings);

    // sometimes the call gets inlined so use patterns if any match
    if !patterns.is_empty() {
        return Ok(Self(try_ensure_one(
            patterns
                .iter()
                .map(|a| -> Result<usize> { Ok(ctx.image().memory.rip4(*a)?) }),
        )?));
    }

    #[derive(Clone, Copy)]
    enum Tag {
        Direct,
        FirstCall,
    }

    let refs = join_all(strings.iter().flatten().flat_map(|s| {
        [
            (
                Tag::FirstCall,
                format!("48 8d 15 X0x{s:x} 4c 8d 05 ?? ?? ?? ?? 41 b1 01 e8 | ?? ?? ?? ??"),
            ),
            (
                Tag::Direct,
                format!("48 8d 15 X0x{s:x} 48 8d 0d ?? ?? ?? ?? e8 | ?? ?? ?? ??"),
            ),
            (
                Tag::Direct,
                format!(
                    "41 b8 01 00 00 00 48 8d 15 X0x{s:x} 48 8d 0d ?? ?? ?? ?? e9 | ?? ?? ?? ??"
                ),
            ),
        ]
        .into_iter()
        .map(|(t, p)| ctx.scan_tagged2(t, Pattern::new(p).unwrap()))
    }))
    .await;

    Ok(Self(try_ensure_one(refs.iter().flatten().map(
        |(tag, address)| {
            let f = ctx.image().memory.rip4(*address)?;
            match tag {
                Tag::Direct => Ok(f),
                Tag::FirstCall => {
                    let bytes = ctx.image().memory.range(f..f + 0x200)?;
                    let mut decoder = Decoder::with_ip(64, bytes, f as u64, DecoderOptions::NONE);

                    decoder
                        .iter()
                        .find_map(|i| {
                            (i.code() == Code::Call_rel32_64)
                                .then_some(i.memory_displacement64() as usize)
                        })
                        .context("did not find CALL instruction")
                }
            }
        },
    ))?))
});

/// Can be either of the following:
/// `public: class FString __cdecl FName::ToString(void) const`
/// `public: void __cdecl FName::ToString(class FString &) const`
///
/// They take the same arguments and either can be used as long as the return value isn't used.
///
/// !! Be aware anyone try play with this code in Linux, they're different and you should stick with the
/// second one.
///
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FNameToString(pub usize);
impl_resolver_singleton!(collect, FNameToString);

impl_resolver_singleton!(ElfImage, FNameToString, |ctx| async {
    let strings = ctx.scan(util::utf16_pattern("SkySphereMesh\0")).await;
    let str_addr = ensure_one(strings)?;
    let pattern = Pattern::new(format!(
        "e8 | ?? ?? ?? ?? 49 8b 5f 10 48 8d 7c 24 30 be 0x{str_addr:08x}"
    ))
    .unwrap();
    let refs = ctx.scan(pattern).await;
    Ok(Self(try_ensure_one(
        refs.into_iter().map(|a| Ok(ctx.image().memory.rip4(a)?)),
    )?))
});

impl_resolver_singleton!(PEImage, FNameToString, |ctx| async {
    use crate::{resolvers::Context, MemoryTrait};
    use futures::join;
    use iced_x86::{Code, Decoder, DecoderOptions};

    let patterns = async {
        let patterns = ["56 57 48 83 EC 28 48 89 D6 48 89 CF 83 79 ?? 00 74"];

        join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap())))
            .await
            .into_iter()
            .flatten()
            .collect::<Vec<_>>()
    };

    let string = async {
        // Locates either variant by searching for a string ref and finding the first function
        // call directly above it. Which variant depends on how much inlining has occured
        let s = Pattern::from_bytes(
            "  DrivingBone: %s\nDrivenParamet"
                .encode_utf16()
                .flat_map(u16::to_le_bytes)
                .collect(),
        )
        .unwrap();
        let strings = ctx.scan(s).await;

        let refs = join_all(
            strings
                .iter()
                .map(|s| ctx.scan(Pattern::new(format!("48 8d 15 X0x{s:x}")).unwrap())),
        )
        .await;

        let fn_gather_debug_data = ensure_one(
            refs.into_iter()
                .flatten()
                .map(|r| -> Result<_> {
                    Ok(ctx.image().get_root_function(r)?.map(|f| f.range.start..r))
                })
                .collect::<Result<Vec<_>>>()? // TODO avoid this collect?
                .into_iter()
                .flatten(),
        )?;

        let bytes = ctx.image().memory.range(fn_gather_debug_data.clone())?;

        let mut decoder = Decoder::with_ip(
            64,
            bytes,
            fn_gather_debug_data.start as u64,
            DecoderOptions::NONE,
        );

        let addr = decoder
            .iter()
            .filter_map(|i| {
                (i.code() == Code::Call_rel32_64).then_some(i.memory_displacement64() as usize)
            })
            .last()
            .context("did not find CALL instruction")?;

        let res: Result<usize> = Ok(addr);

        res
    };

    let any = join!(
        ctx.resolve(FNameToStringFString::resolver()),
        ctx.resolve(FNameToStringVoid::resolver()),
        string,
        patterns,
    );

    // use pattern if found
    if !any.3.is_empty() {
        return Ok(Self(ensure_one(any.3)?));
    }

    Ok(FNameToString(
        any.0.map(|r| r.0).or(any.1.map(|r| r.0)).or(any.2)?,
    ))
});

/// public: class FString __cdecl FName::ToString(void) const
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FNameToStringVoid(pub usize);
impl_resolver_singleton!(all, FNameToStringVoid, |ctx| async {
    let patterns = [
        "E8 | ?? ?? ?? ?? ?? 01 00 00 00 ?? 39 ?? 48 0F 8E",
        "E8 | ?? ?? ?? ?? BD 01 00 00 00 41 39 6E ?? 0F 8E",
        "E8 | ?? ?? ?? ?? 48 8B 4C 24 ?? 8B FD 48 85 C9",
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(FNameToStringVoid(try_ensure_one(
        res.iter()
            .flatten()
            .map(|a| -> Result<usize> { Ok(ctx.image().memory.rip4(*a)?) }),
    )?))
});

/// public: void __cdecl FName::ToString(class FString &) const
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FNameToStringFString(pub usize);
impl_resolver_singleton!(all, FNameToStringFString, |ctx| async {
    let patterns =
        ["48 8b 48 ?? 48 89 4c 24 ?? 48 8d 4c 24 ?? e8 | ?? ?? ?? ?? 83 7c 24 ?? 00 48 8d"];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(FNameToStringFString(try_ensure_one(
        res.iter()
            .flatten()
            .map(|a| -> Result<usize> { Ok(ctx.image().memory.rip4(*a)?) }),
    )?))
});

/// FNamePool
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FNamePool(pub usize);
impl_resolver_singleton!(all, FNamePool, |ctx| async {
    let patterns = [
        "74 ?? 4C 8D 05 | ?? ?? ?? ?? EB ?? 48 8D 0D",
        "48 8d 0d | ?? ?? ?? ?? e8 ?? ?? ?? ?? 48 8b d0 c6 05 dc ?? ?? ?? ?? 48 8b 44 24 30 48 c1 e8 20 03 c0 48 03 44 da 10 48 83 c4 20 5b c3",
        "48 8d 2d | ?? ?? ?? ?? ?? ?? ?? ?? 48 bf cd cc cc cc cc cc cc",
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(Self(try_ensure_one(res.iter().flatten().map(
        |a| -> Result<usize> { Ok(ctx.image().memory.rip4(*a)?) },
    ))?))
});

```

`patternsleuth/src/resolvers/unreal/ftext.rs`:

```rs
use std::fmt::Debug;

use futures::future::join_all;

use patternsleuth_scanner::Pattern;

use crate::{
    resolvers::{impl_resolver_singleton, try_ensure_one},
    MemoryAccessorTrait,
};

/// private: __cdecl FText::FText(class FString &&)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FTextFString(pub usize);
impl_resolver_singleton!(all, FTextFString, |ctx| async {
    #[derive(Debug)]
    enum Directness {
        Direct,
        Indirect,
    }
    let patterns = [
        (Directness::Indirect, "40 53 48 83 ec ?? 48 8b d9 e8 | ?? ?? ?? ?? 83 4b ?? 12 48 8b c3 48 83 ?? ?? 5b c3"),
        (Directness::Indirect, "eb 12 48 8d ?? 24 ?? e8 | ?? ?? ?? ?? ?? 02 00 00 00 48 8b 10 48 89 17"),
        (Directness::Indirect, "eb 12 48 8d ?? 24 ?? e8 | ?? ?? ?? ?? ?? 02 00 00 00 48 8b 10 89"),
        (Directness::Direct, "48 89 5C 24 10 48 89 6C 24 18 56 57 41 54 41 56 41 57 48 83 EC 40 45 33 E4 48 8B F1 41 8B DC 4C 8B F2 89 5C 24 70 41 8D 4C 24 70 E8 ?? ?? ?? FF 48 8B F8 48 85 C0 0F 84 ?? 00 00 00 49 63 5E 08 ?? 8B ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 8B ?? EB 2E 45 33 C0 48 8D 4C 24 20 8B D3 E8"),
        (Directness::Direct, "48 89 5C 24 10 48 89 6C 24 18 57 48 83 EC 50 33 ED 48 8D 05 ?? ?? ?? 03 48 8B F9 48 89 6C 24 38 48 8B DA 48 89 6C 24 48 48 89 44 24 30 8D 4D 60 48 89 44 24 40 E8 ?? ?? ?? FF 4C 8B C0 48 85 C0 74 65 0F 10 44 24 30 C7 40 08 01 00 00 00 0F 10 4C 24 40 C7 40 0C 01 00 00 00 48 8D 05 ?? ?? ?? 03 49 89 00"),
        (Directness::Direct, "48 89 5C 24 10 48 89 6C 24 18 56 57 41 54 41 56 41 57 48 83 EC 50 45 33 E4 48 8B F9 41 8B DC 4C 8B F2 89 9C 24 80 00 00 00 41 8D 4C 24 70 E8 ?? ?? ?? ?? 48 8B F0 48 85 C0 0F 84 98 00 00 00 49 63 5E 08 41 8B EC 4D 8B 3E 4C 89 64 24 20 89 5C 24 28 85 DB 75 05 45 8B FC EB 2E 45 33 C0 48 8D 4C 24 20 8B"),
        (Directness::Direct, "48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 48 89 7C 24 ?? 41 54 41 56 41 57 48 83 EC 40 4C 8B F1 48 8B F2"),
        (Directness::Direct, "48 89 5C 24 ?? 48 89 6C 24 ?? 56 57 41 54 41 56 41 57 48 83 EC 40 45 33 E4 48 8B F1"),
        (Directness::Direct, "40 53 56 48 83 EC 48 33 DB 48 89 6C 24 68 48 8B F1 48 89 7C 24 70 4C 89 74 24 78 4C 8B F2 89 5C 24 60 8D 4B 70 E8 ?? ?? ?? FF 48 8B F8 48 85 C0 0F 84 9E 00 00 00 49 63 5E 08 33 ED 4C 89 7C 24 40 4D 8B 3E 48 89 6C 24 20 89 5C 24 28 85 DB 75 05 45 33 FF EB 2E 45 33 C0 48 8D 4C 24 20 8B D3 E8"),
        (Directness::Direct, "41 57 41 56 41 54 56 57 55 53 48 83 EC 40 48 89 D7 48 89 CE 48 8B 0D"),
        // FText::AsCultureInvariant on Linux
        (Directness::Indirect, "48 85 c9 74 13 f0 83 41 08 01 eb 0c 48 89 df e8 | ?? ?? ?? ?? 48 8d 43 10"),
        // FText::FText signature
        (Directness::Direct, "41 57 41 56 53 48 83 ec 20 49 89 f7 49 89 fe 0f 57 c0 0f 29 44 24 10 0f 29 04 24 48 8d 5c 24 10 48 89 e7 e8 ?? ?? ?? ?? 48 89 df e8 ?? ?? ?? ?? bf 60 00 00 00 e8"),
    ];

    let res = join_all(
        patterns
            .iter()
            .map(|(tag, p)| ctx.scan_tagged(tag, Pattern::new(p).unwrap())),
    )
    .await;

    let mem = &ctx.image().memory;

    Ok(FTextFString(try_ensure_one(res.iter().flat_map(
        |(directness, _, a)| match directness {
            Directness::Direct => itertools::Either::Right(a.iter().map(|a| Ok(*a))),
            Directness::Indirect => itertools::Either::Left(a.iter().map(|a| Ok(mem.rip4(*a)?))),
        },
    ))?))
});

```

`patternsleuth/src/resolvers/unreal/fuobject_hash_tables.rs`:

```rs
use std::fmt::Debug;

use futures::future::join_all;

use patternsleuth_scanner::Pattern;

use crate::{
    resolvers::{impl_resolver_singleton, try_ensure_one, Result},
    MemoryAccessorTrait,
};

/// public: static class FUObjectHashTables & __cdecl FUObjectHashTables::Get(void)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FUObjectHashTablesGet(pub usize);
// try find u16"Hash efficiency statistics for the Outer Object Hash"
// LogHashOuterStatistics(FOutputDevice& Ar, const bool bShowHashBucketCollisionInfo)
// FHashTableLock HashLock(FUObjectHashTables::Get());
impl_resolver_singleton!(all, FUObjectHashTablesGet, |ctx| async {
    let patterns = [
        "48 89 5C 24 08 48 89 6C 24 10 48 89 74 24 18 57 48 83 EC 40 41 0F B6 F9 49 8B D8 48 8B F2 48 8B E9 E8 | ?? ?? ?? ?? 44 8B 84 24 80 00 00 00 4C 8B CB 44 ?? ?? 24 ?? 48 8B D5 44 ?? 44 24 ?? ?? ?? ?? ?? ?? 44 ?? ?? 44 ?? ?? ?? ?? ?? 44 ?? ?? 24 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 48",
        "48 89 5C 24 08 48 89 74 24 10 4C 89 44 24 18 57 48 83 EC 40 41 0F B6 D9 48 8B FA 48 8B F1 E8 | ?? ?? ?? ?? 44 8B 84 24 80 00 00 00 48 8B D6 ?? 8B ?? 24 ?? 48 8B C8 ?? ?? ?? 24 ?? ?? ?? ?? ?? ?? 44 89 44 24 ?? 44 0F B6 44 24 70 44 ?? ?? 24 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 48 8B",
        "48 89 5C 24 08 48 89 6C 24 10 48 89 74 24 18 57 48 83 EC 40 41 0F B6 F9 49 8B D8 48 8B F2 48 8B E9 E8 | ?? ?? ?? ?? 44 8B 44 24 78 4C 8B CB 44 89 44 24 38 48 8B D5 44 8B 44 24 70 48 8B C8 44 89 44 24 30 4C 8B C6 C6 44 24 28 00 40 88 7C 24 20 E8 ?? ?? ?? ?? 48 8B 5C 24 50 48 8B 6C 24 58 48 8B 74 24 60",
        "e8 | ?? ?? ?? ?? 45 33 ff 48 8b f0 33 c0 f0 44 0f b1 3d",
        // linux pattern
        "0f 84 ?? ?? ?? ?? e8 | ?? ?? ?? ?? 84 c0 74 18 e8 ?? ?? ?? ?? 84 c0 74 0f b0 01 89 44 24 0c 31 c0 48 89 44 24 10 eb",
    ];
    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(Self(try_ensure_one(res.iter().flatten().map(
        |a| -> Result<usize> { Ok(ctx.image().memory.rip4(*a)?) },
    ))?))
});

```

`patternsleuth/src/resolvers/unreal/game_loop.rs`:

```rs
use std::fmt::Debug;

use futures::future::join_all;

use crate::resolvers::{ensure_one, impl_resolver_singleton, unreal::util};

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct Main(pub usize);
impl_resolver_singleton!(collect, Main);
impl_resolver_singleton!(PEImage, Main, |ctx| async {
    let strings = ctx.scan(util::utf16_pattern("UnrealEngine4\0")).await;
    let refs = util::scan_xrefs(ctx, &strings).await;
    let fns = util::root_functions(ctx, &refs)?;
    Ok(Self(ensure_one(fns)?))
});
impl_resolver_singleton!(ElfImage, Main, |_ctx| async {
    super::bail_out!("ElfImage unimplemented");
});

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FEngineLoopTick(pub usize);
impl_resolver_singleton!(collect, FEngineLoopTick);
impl_resolver_singleton!(PEImage, FEngineLoopTick, |ctx| async {
    let strings = ["DeferredTickTime\0", "ConcurrentWithSlateTickTasks_Wait\0"];
    let strings: Vec<_> = join_all(strings.map(|s| ctx.scan(util::utf8_pattern(s))))
        .await
        .into_iter()
        .flatten()
        .collect();
    let refs = util::scan_xrefs(ctx, &strings).await;
    let fns = util::root_functions(ctx, &refs)?;
    Ok(Self(ensure_one(fns)?))
});
impl_resolver_singleton!(ElfImage, FEngineLoopTick, |_ctx| async {
    super::bail_out!("ElfImage unimplemented");
});

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct UGameEngineTick(pub usize);
impl_resolver_singleton!(collect, UGameEngineTick);

impl_resolver_singleton!(PEImage, UGameEngineTick, |ctx| async {
    use crate::resolvers::Result;
    use patternsleuth_scanner::Pattern;

    let strings = ctx
        .scan(Pattern::from_bytes(b"EngineTickMisc\x00".to_vec()).unwrap())
        .await;

    let refs = join_all(
        strings
            .iter()
            // TODO maybe mask out specific register
            .map(|s| ctx.scan(Pattern::new(format!("48 8d 0d X0x{s:X}")).unwrap())),
    )
    .await;

    let fns = refs
        .into_iter()
        .flatten()
        .map(|r| -> Result<_> { Ok(ctx.image().get_root_function(r)?.map(|f| f.range.start)) })
        .collect::<Result<Vec<_>>>()? // TODO avoid this collect?
        .into_iter()
        .flatten();

    Ok(UGameEngineTick(ensure_one(fns)?))
});

// on linux we use u16"causeevent="
impl_resolver_singleton!(ElfImage, UGameEngineTick, |ctx| async {
    let strings = ["causeevent=\0", "CAUSEEVENT \0"];
    let strings: Vec<_> = join_all(strings.map(|s| ctx.scan(util::utf16_pattern(s))))
        .await
        .into_iter()
        .flatten()
        .collect();

    let refs = util::scan_xrefs(ctx, &strings).await;

    let fns = util::root_functions(ctx, &refs)?;

    Ok(UGameEngineTick(ensure_one(fns)?))
});

/// int32_t FEngineLoop::Init(class FEngineLoop* this)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FEngineLoopInit(pub usize);
impl_resolver_singleton!(collect, FEngineLoopInit);

impl_resolver_singleton!(PEImage, FEngineLoopInit, |ctx| async {
    let search_strings = [
        "FEngineLoop::Init\0",
        "Failed to load UnrealEd Engine class '%s'.",
        "One or more modules failed PostEngineInit",
    ];
    let strings = join_all(
        search_strings
            .into_iter()
            .map(|s| ctx.scan(util::utf16_pattern(s))),
    )
    .await
    .into_iter()
    .flatten()
    .collect::<Vec<_>>();

    let refs = util::scan_xrefs(ctx, &strings).await;
    let fns = util::root_functions(ctx, &refs)?;
    Ok(Self(ensure_one(fns)?))
});

impl_resolver_singleton!(ElfImage, FEngineLoopInit, |ctx| async {
    let search_strings = [
        util::utf8_pattern("FEngineLoop::Init\0"),
        // this is a standalone function called by FEngineLoopInit
        // util::utf16_pattern("Failed to load UnrealEd Engine class '%s'."),
        util::utf16_pattern("One or more modules failed PostEngineInit"),
    ];
    let strings = join_all(search_strings.into_iter().map(|s| ctx.scan(s)))
        .await
        .into_iter()
        .flatten()
        .collect::<Vec<_>>();

    let refs = util::scan_xrefs(ctx, &strings).await;
    let fns = util::root_functions(ctx, &refs)?;
    Ok(Self(ensure_one(fns)?))
});

```

`patternsleuth/src/resolvers/unreal/gmalloc.rs`:

```rs
use std::fmt::Debug;

use futures::{future::join_all, join};
use iced_x86::{Code, OpKind, Register};
use itertools::Itertools;
use patternsleuth_scanner::Pattern;

use crate::{
    disassemble::{disassemble, Control},
    resolvers::{impl_resolver_singleton, try_ensure_one, unreal::util, Result},
    MemoryAccessorTrait,
};

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct GMalloc(pub usize);
impl_resolver_singleton!(all, GMalloc, |ctx| async {
    //eprintln!("GMalloc Scan Start!");
    let (patterns, strings) = join!(
        ctx.resolve(GMallocPatterns::resolver()),
        ctx.resolve(GMallocString::resolver()),
    );
    Ok(Self(patterns.map(|r| r.0).or(strings.map(|r| r.0))?))
});

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct GMallocPatterns(pub usize);
impl_resolver_singleton!(all, GMallocPatterns, |ctx| async {
    let patterns = [
        "48 ?? ?? f0 ?? 0f b1 ?? | ?? ?? ?? ?? 74 ?? ?? 85 ?? 74 ?? ?? 8b", // Purgatory
        "eb 03 ?? 8b ?? 48 8b ?? f0 ?? 0f b1 ?? | ?? ?? ?? ?? 74 ?? ?? 85 ?? 74 ?? ?? 8b", // Purg_notX
        "e8 ?? ?? ?? ?? 48 8b ?? f0 ?? 0f b1 ?? | ?? ?? ?? ?? 74 ?? ?? 85 ?? 74 ?? ?? 8b", // Purg_withX
        "48 85 C9 74 2E 53 48 83 EC 20 48 8B D9 48 8B ?? | ?? ?? ?? ?? 48 85 C9", // A
        "75 ?? E8 ?? ?? ?? ?? 48 8b 0d | ?? ?? ?? ?? 48 8b ?? 48 ?? ?? ff 50 ?? 48 83 c4 ?? ?? c3", // bnew1
        "48 85 C9 74 ?? 4C 8B 05 | ?? ?? ?? ?? 4D 85 C0 0F 84", // altshort
        "48 ?? ?? ?? ?? ?? ?? e8 ?? ?? ?? ?? 48 8b 0d | ?? ?? ?? ?? 48 8b 01 ff 50 ?? 84 c0 75 ?? b9 38 00 00 00", // gcreatemallocshort
        "84 C0 75 ?? B9 38 00 00 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 48 85 c0 74 ?? 48 8b 0d | ?? ?? ?? ?? 48 8d 05 ?? ?? ?? ?? 48 89", // gcreatemallocmiddle
        "ff 15 ?? ?? ?? ?? 48 8b 5c 24 ?? 48 89 3d | ?? ?? ?? ?? 48 8b 7c 24 20 48 83 c4 28 c3", // gcreatemallocend
        "48 89 ?? f0 ?? 0f b1 ?? | ?? ?? ?? ?? 48 39 ?? 74 ?? 48 8b 1d", // clang1
        "48 89 ?? f0 ?? 0f b1 ?? | ?? ?? ?? ?? 48 39 ?? 75 ?? 48 83 c4", // clang2
        "48 89 5C 24 08 57 48 83 EC 20 48 8B F9 ?? ?? ?? ?? ?? ?? ?? ?? ?? 48 85 C9 75 ?? E8 ?? ?? ?? FF 48 8B 0D | ?? ?? ?? ?? ?? 8B ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 48 ?? ?? ?? ?? 48",
        "48 89 5C 24 08 57 48 83 EC ?? 48 83 3D ?? ?? ?? ?? 00 8B DA 48 8B F9 75 07 E8 ?? ?? ?? FF EB 07 33 C9 E8 ?? ?? ?? FF 48 8B 0D | ?? ?? ?? ?? 44 8B C3 48 8B D7 48 8B 01 FF 50 10 80 3D ?? ?? ?? ?? 00 48 8B D8 75 ?? 48 8B 05 ?? ?? ?? ?? 48 85 C0 75 05 E8 ?? ?? ?? FF ?? 44 24 ?? 01",
        "48 89 5C 24 08 57 48 83 EC 20 48 8B F9 8B DA 48 8B 0D | ?? ?? ?? ?? 48 85 C9 75 2E 65 48 8B 04 25 58 00 00 00 44 8B 05 ?? ?? ?? ?? BA 18 00 00 00 4E 8B 04 C0 42 8B 04 02 39 05 ?? ?? ?? ?? 7E 09 EB 1E 48 8B 0D ?? ?? ?? ?? 48 8B 01 44 8B C3 48 8B D7 48 8B 5C 24 30 48 83 C4 20 5F 48 FF 60 10 48 8D 0D",
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(Self(try_ensure_one(res.iter().flatten().map(
        |a| -> Result<usize> { Ok(ctx.image().memory.rip4(*a)?) },
    ))?))
});

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct GMallocString(pub usize);
impl_resolver_singleton!(collect, GMallocString);

impl_resolver_singleton!(PEImage, GMallocString, |ctx| async {
    use crate::Image;
    use iced_x86::FlowControl;
    use std::collections::HashSet;

    let strings = ctx.scan(util::utf16_pattern("DeleteFile %s\0")).await;
    let refs = util::scan_xrefs(ctx, &strings).await;

    let fns = util::root_functions(ctx, &refs)?;

    fn find_global(
        img: &Image<'_>,
        f: usize,
        depth: usize,
        searched: &mut HashSet<usize>,
    ) -> Result<Option<usize>> {
        searched.insert(f);

        //println!("searching {f:x?}");

        let mut mov_rcx = None;
        let mut possible_gmalloc = vec![];
        let mut calls = vec![];

        disassemble(img, f, |inst| {
            let cur = inst.ip() as usize;
            if !(f..f + 1000).contains(&cur)
                && Some(f) != img.get_root_function(cur)?.map(|f| f.range.start)
            {
                //println!("bailing at {:x}", inst.ip());
                return Ok(Control::Break);
            }

            if inst.code() == Code::Cmp_rm64_imm8
                && inst.memory_base() == Register::RIP
                && inst.op0_kind() == OpKind::Memory
                && inst.op1_kind() == OpKind::Immediate8to64
                && inst.immediate8() == 0
            {
                possible_gmalloc.push(inst.ip_rel_memory_address() as usize);
            }

            if inst.code() == Code::Test_rm64_r64
                && inst.op0_register() == Register::RCX
                && inst.op1_register() == Register::RCX
            {
                if let Some(mov_rcx) = mov_rcx {
                    possible_gmalloc.push(mov_rcx);
                }
            }

            if inst.code() == Code::Mov_r64_rm64
                && inst.memory_base() == Register::RIP
                && inst.op0_register() == Register::RCX
            {
                /*
                println!(
                    "{depth} {:x} {:x} {:x?}",
                    inst.ip(),
                    inst.ip_rel_memory_address(),
                    inst
                );
                */
                mov_rcx = Some(inst.ip_rel_memory_address() as usize);
            } else {
                mov_rcx = None;
            }

            match inst.flow_control() {
                FlowControl::Call
                | FlowControl::ConditionalBranch
                | FlowControl::UnconditionalBranch => {
                    let call = inst.near_branch_target() as usize;
                    //println!("{:x} {:x}", inst.ip(), call);
                    if Some(f) != img.get_root_function(call)?.map(|f| f.range.start) {
                        calls.push(call);
                    }
                }
                _ => {}
            }

            Ok(Control::Continue)
        })?;

        if let [gmalloc] = possible_gmalloc.as_slice() {
            Ok(Some(*gmalloc))
        } else {
            if depth > 0 {
                for call in calls.iter().rev() {
                    if !searched.contains(call) {
                        let res = find_global(img, *call, depth - 1, searched)?;
                        if res.is_some() {
                            return Ok(res);
                        }
                    }
                }
            }
            Ok(None)
        }
    }

    let fns = fns
        .into_iter()
        .map(|f| find_global(ctx.image(), f, 3, &mut Default::default()))
        .flatten_ok();

    Ok(Self(try_ensure_one(fns)?))
});

impl_resolver_singleton!(ElfImage, GMallocString, |ctx| async {
    use futures::try_join;
    use std::ops::Range;

    //eprintln!("GMalloc String Scan");
    let string_xref_used_by = |pattern: &'static str| async {
        let strings = ctx.scan(util::utf8_pattern(pattern)).await;
        //eprintln!("Found /proc/meminfo @ {:?} ", strings);
        let refs = util::scan_xrefs(ctx, &strings).await;
        //eprintln!("Found {} refs", refs.len());

        let fns = util::root_functions(ctx, &refs)?;
        //eprintln!("Found related functions @ {:?}", fns);

        Result::<Vec<usize>>::Ok(util::scan_xcalls(ctx, &fns).await)
    };

    let find_string_pattern1 = || async { string_xref_used_by("/proc/meminfo\0").await };

    let find_string_pattern2 = || async {
        let fns2 = string_xref_used_by("Refusing to run with the root privileges.\n\0").await?;
        //eprintln!("Found {} xcall fns2 @ {:?}", fns2.len(), fns2);
        let fns2 = fns2.iter().map(|&x| x..(x + 24)).collect_vec();
        // another possible address for FMemory::GCreateMalloc
        Result::<Vec<Range<usize>>>::Ok(fns2)
    };

    let (fns, fns2) = try_join!(find_string_pattern1(), find_string_pattern2())?;

    let fns = fns
        .into_iter()
        .filter(|x| fns2.iter().any(|y| y.contains(x)))
        .map(|f| -> Result<Option<usize>> {
            let mut possible_gmalloc = vec![];
            // eprintln!("disassemble @ {}", f);
            disassemble(ctx.image(), f, |inst| {
                let cur = inst.ip() as usize;
                if !(f..f + 20).contains(&cur) {
                    return Ok(Control::Break);
                }

                // find mov rdi
                if inst.code() == Code::Mov_r64_rm64
                    && inst.memory_base() == Register::RIP
                    && inst.op0_kind() == OpKind::Register
                    && inst.op1_kind() == OpKind::Memory
                {
                    // eprintln!("Found one possible gmlaaoc @ {:#08X}", inst.ip_rel_memory_address() as usize);
                    possible_gmalloc.push(inst.ip_rel_memory_address() as usize);
                }
                Ok(Control::Continue)
            })?;
            Ok(
                (possible_gmalloc.len() == 2 && possible_gmalloc[0] == possible_gmalloc[1])
                    .then_some(possible_gmalloc[0]),
            )
        })
        .flatten_ok();

    Ok(Self(try_ensure_one(fns)?))
});

// pattern Linux
// string -> "MemAvailable:" -> func FUnixPlatformMemory::GetStats() -> FMemory::GCreateMalloc
/*
        06b602dc e8  5f  e7       CALL       FUN_06cdea40                                     undefined FUN_06cdea40() <- fn2
                 17  00
        06b602e1 48  89  05       MOV        qword ptr [GMalloc ],RAX
                 10  05  e8
                 04
        06b602e8 48  8d  7c       LEA        RDI => local_88 ,[RSP  + 0x10 ]
                 24  10
        06b602ed e8  9e  f7       CALL       FUnixPlatformMemory::GetStats                    undefined GetStats() <- fn1
                 17  00
        06b602f2 48  8b  3d       MOV        RDI ,qword ptr [GMalloc ]
                 ff  04  e8
                 04
        06b602f9 e8  a2  bf       CALL       FUN_06b1c2a0                                     undefined FUN_06b1c2a0()
                 fb  ff
        06b602fe 48  8b  3d       MOV        RDI ,qword ptr [GMalloc ]
                 f3  04  e8
                 04
        06b60305 48  8b  07       MOV        RAX ,qword ptr [RDI ]
        06b60308 ff  90  88       CALL       qword ptr [RAX  + 0x88 ]
                 00  00  00
        06b6030e 84  c0           TEST       AL ,AL

*/

```

`patternsleuth/src/resolvers/unreal/guobject_array.rs`:

```rs
use std::fmt::Debug;

use futures::{future::join_all, try_join};

use patternsleuth_scanner::Pattern;

use crate::{
    resolvers::{ensure_one, impl_resolver_singleton, try_ensure_one, unreal::util, Result},
    MemoryAccessorTrait,
};

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct GUObjectArray(pub usize);
impl_resolver_singleton!(all, GUObjectArray, |ctx| async {
    let patterns = [
        "8B 05 ?? ?? ?? ?? 3B 05 ?? ?? ?? ?? 75 ?? 48 8D 15 ?? ?? ?? ?? 48 8D 0D | ?? ?? ?? ?? E8 ?? ?? ?? ?? 48 8D 05",
        "74 ?? 48 8D 0D | ?? ?? ?? ?? C6 05 ?? ?? ?? ?? 01 E8 ?? ?? ?? ?? C6 05 ?? ?? ?? ?? 01",
        "75 ?? 48 ?? ?? 48 8D 0D | ?? ?? ?? ?? E8 ?? ?? ?? ?? 45 33 C9 4C 89 74 24",
        "45 84 c0 48 c7 41 10 00 00 00 00 b8 ff ff ff ff 4c 8d 1d | ?? ?? ?? ?? 89 41 08 4c 8b d1 4c 89 19 0f 45 05 ?? ?? ?? ?? ff c0 89 41 08 3b 05",
        "81 ce 00 00 00 02 83 e0 fb 89 47 08 48 8d 0d | ?? ?? ?? ?? 48 89 fa 45 31 c0 e8 ?? ?? ?? ??",
    ];
    // mov imm32 pattern for linux
    let patterns1 = [
        /*
        06f97b32 41  39  ee       CMP        R14D ,EBP
        06f97b35 0f  8e  7e       JLE        LAB_06f97cb9
                 01  00  00
        06f97b3b bf  d8  c5       MOV        param_1 ,GUObjectArray
                 ac  0b
        06f97b40 48  8b  74       MOV        param_2 ,qword ptr [RSP  + local_68 ]
                 24  10
        06f97b45 e8  16  d2       CALL       FUN_06f64d60                                     undefined FUN_06f64d60()
                 fc  ff
        06f97b4a e9  6a  01       JMP        LAB_06f97cb9
                 00  00
         */
        "41 39 ee 0f 8e ?? ?? ?? ?? bf | ?? ?? ?? ?? 48 8b 74 24 10 e8 ?? ?? ?? ?? e9",
        /*
        06fa15c8 8b  6f  3c       MOV        EBP ,dword ptr [RDI  + 0x3c ]
        06fa15cb 4c  89  f7       MOV        RDI ,R14
        06fa15ce 31  f6           XOR        ESI ,ESI
        06fa15d0 e8  1b  09       CALL       FUN_06fa1ef0                                     undefined FUN_06fa1ef0()
                 00  00
        06fa15d5 41  39  ef       CMP        R15D ,EBP
        06fa15d8 7e  0d           JLE        LAB_06fa15e7
        06fa15da bf  d8  c5       MOV        EDI ,GUObjectArray
                 ac  0b
        06fa15df 48  89  de       MOV        RSI ,RBX
        06fa15e2 e8  79  37       CALL       FUN_06f64d60                                     undefined FUN_06f64d60()
                 fc  ff
         */
        "8b 6f ?? 4c 89 f7 31 f6 e8 ?? ?? ?? ?? 41 39 ef 7e 0d bf | ?? ?? ?? ?? 48 89 de e8",
    ];
    let res0 = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;
    let res1 = join_all(patterns1.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;
    let res1 = res1
        .iter()
        .flatten()
        .map(|a| -> Result<usize> { Ok(ctx.image().memory.u32_le(*a)? as usize) });
    Ok(GUObjectArray(try_ensure_one(
        res0.iter()
            .flatten()
            .map(|a| -> Result<usize> { Ok(ctx.image().memory.rip4(*a)?) })
            .chain(res1),
    )?))
});

/// public: void __cdecl FUObjectArray::AllocateUObjectIndex(class UObjectBase *, bool)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FUObjectArrayAllocateUObjectIndex(pub usize);
impl_resolver_singleton!(all, FUObjectArrayAllocateUObjectIndex, |ctx| async {
    let strings = ctx
        .scan(util::utf16_pattern(
            "Unable to add more objects to disregard for GC pool (Max: %d)\0",
        ))
        .await;
    let refs = util::scan_xrefs(ctx, &strings).await;
    let fns = util::root_functions(ctx, &refs)?;
    Ok(Self(ensure_one(fns)?))
});

/// public: void __cdecl FUObjectArray::FreeUObjectIndex(class UObjectBase *)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FUObjectArrayFreeUObjectIndex(pub usize);
impl_resolver_singleton!(all, FUObjectArrayFreeUObjectIndex, |ctx| async {
    let refs_future = async {
        let search_strings = [
            "Removing object (0x%016llx) at index %d but the index points to a different object (0x%016llx)!",
            "Unexpected concurency while adding new object",
        ];
        let strings = join_all(
            search_strings
                .into_iter()
                .map(|s| ctx.scan(util::utf16_pattern(s))),
        )
        .await
        .into_iter()
        .flatten()
        .collect::<Vec<_>>();
        Ok(util::scan_xrefs(ctx, &strings).await)
    };

    // same string is present in both functions so resolve the other so we can filter it out
    let (allocate_uobject, refs) = try_join!(
        ctx.resolve(FUObjectArrayAllocateUObjectIndex::resolver()),
        refs_future,
    )?;

    let fns = refs
        .into_iter()
        .map(|r| -> Result<_> { Ok(ctx.image().get_root_function(r)?.map(|f| f.range.start)) })
        .collect::<Result<Vec<_>>>()? // TODO avoid this collect?
        .into_iter()
        .flatten()
        .filter(|f| *f != allocate_uobject.0);

    Ok(FUObjectArrayFreeUObjectIndex(ensure_one(fns)?))
});

/// void __cdecl UObjectBaseShutdown(void)
/// could be used to determine object listener offsets, but only for recent UE versions
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct UObjectBaseShutdown(pub usize);
impl_resolver_singleton!(collect, UObjectBaseShutdown);

impl_resolver_singleton!(PEImage, UObjectBaseShutdown, |ctx| async {
    let strings = ctx
        .scan(util::utf16_pattern(
                "All UObject delete listeners should be unregistered when shutting down the UObject array\0"
        ))
        .await;
    let refs = util::scan_xrefs(ctx, &strings).await;
    let fns = util::root_functions(ctx, &refs)?;
    Ok(UObjectBaseShutdown(ensure_one(fns)?))
});

impl_resolver_singleton!(ElfImage, UObjectBaseShutdown, |ctx| async {
    let strings = ctx
        .scan(util::utf16_pattern(
                "All UObject delete listeners should be unregistered when shutting down the UObject array\0"
        ))
        .await;
    let refs = util::scan_xrefs(ctx, &strings).await;
    let fns = util::root_functions(ctx, &refs)?;
    let fns = {
        // on linux both functions are not inlined, we need to find the caller
        let callsites = util::scan_xcalls(ctx, &fns).await;
        util::root_functions(ctx, &callsites)?
    };
    Ok(UObjectBaseShutdown(ensure_one(fns)?))
});

```

`patternsleuth/src/resolvers/unreal/kismet.rs`:

```rs
use std::fmt::Debug;

use futures::future::join_all;
use iced_x86::{Decoder, DecoderOptions, Instruction};
use patternsleuth_scanner::Pattern;

use crate::{
    resolvers::{
        bail_out, ensure_one, impl_resolver, impl_resolver_singleton, try_ensure_one, Result,
    },
    Addressable, Matchable, MemoryTrait,
};

/// public: void __cdecl UObject::SkipFunction(struct FFrame &, void *const, class UFunction *)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct UObjectSkipFunction(pub usize);
impl_resolver_singleton!(all, UObjectSkipFunction, |ctx| async {
    let patterns = [
        "40 55 41 54 41 55 41 56 41 57 48 83 EC 30 48 8D 6C 24 20 48 89 5D 40 48 89 75 48 48 89 7D 50 48 8B 05 ?? ?? ?? ?? 48 33 C5 48 89 45 00 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 4D 8B ?? ?? 8B ?? 85 ?? 75 05 41 8B FC EB ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 48 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 48 ?? E0",

        // linux
        "55 01001??? 89 e5 01000??? 57 01000??? 56 01000??? 55 01000??? 54 53 50 01001??? 89 cf 01001??? 89 d6 01001??? 89 f3 01001??? 63 51 58 01001??? 85 d2 74 ??  01001??? 63 67 5c 01001??? 83 fc 10 7f ?? 01001??? 89 e4 01001??? 8d 42 1e 01001??? 83 e0 f0 01001??? 29 c4 01001??? 89 e4 eb ??"
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(UObjectSkipFunction(ensure_one(res.into_iter().flatten())?))
});

// GNatives
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct GNatives(pub usize);
impl_resolver_singleton!(collect, GNatives);
impl_resolver_singleton!(PEImage, GNatives, |ctx| async {
    use iced_x86::{Code, Register};

    let skip_function = ctx.resolve(UObjectSkipFunction::resolver()).await?;
    let bytes = ctx.image().memory.range_from(skip_function.0..)?;

    let mut decoder = Decoder::with_ip(
        64,
        &bytes[0..bytes.len().min(500)],
        skip_function.0 as u64,
        DecoderOptions::NONE,
    );

    // TODO recursive decode candidate
    let mut instruction = Instruction::default();
    while decoder.can_decode() {
        decoder.decode_out(&mut instruction);
        if instruction.code() == Code::Lea_r64_m && instruction.memory_base() == Register::RIP {
            return Ok(GNatives(instruction.memory_displacement64() as usize));
        }
    }

    bail_out!("failed to not find LEA instruction");
});

impl_resolver_singleton!(ElfImage, GNatives, |ctx| async {
    let skip_function = ctx.resolve(UObjectSkipFunction::resolver()).await?;
    let bytes = ctx.image().memory.range_from(skip_function.0..)?;

    let mut decoder = Decoder::with_ip(
        64,
        &bytes[0..bytes.len().min(500)],
        skip_function.0 as u64,
        DecoderOptions::NONE,
    );

    // TODO recursive decode candidate
    let mut instruction = Instruction::default();
    while decoder.can_decode() {
        decoder.decode_out(&mut instruction);
        if instruction.is_call_near_indirect() && instruction.memory_index_scale() == 8 {
            return Ok(GNatives(instruction.memory_displacement32() as usize));
        }
    }

    bail_out!("failed to not find LEA instruction");
});

/// public: void __cdecl FFrame::Step(class UObject *, void *const)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FFrameStep(pub usize);
impl_resolver_singleton!(all, FFrameStep, |ctx| async {
    let patterns = [
        "48 8B 41 20 4C 8B D2 48 8B D1 44 0F B6 08 48 FF C0 48 89 41 20 41 8B C1 4C 8D 0D ?? ?? ?? ?? 49 8B CA 49 FF 24 C1",
        // linux
        "01001??? 89 f8 01001??? 8b 4f 20 01001??? 8d 79 01 01001??? 89 78 20 0f b6 09 01001??? 8b 0c ?????101 ?? ?? ?? ?? 01001??? 89 f7 01001??? 89 c6 ff e1",
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(FFrameStep(ensure_one(res.into_iter().flatten())?))
});

/// public: void __cdecl FFrame::StepExplicitProperty(void *const, class FProperty *)
/// public: void __cdecl FFrame::StepExplicitProperty(void *const, class UProperty *)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FFrameStepExplicitProperty(pub usize);
impl_resolver_singleton!(all, FFrameStepExplicitProperty, |ctx| async {
    let patterns = [
         "41 8B 40 40 4D 8B C8 4C 8B D1 48 0F BA E0 08 73 ?? 48 8B ?? ?? ?? ?? 00 ?? ?? ?? ?? ?? ?? ?? 00 48 8B 40 10 4C 39 08 75 F7 48 8B 48 08 49 89 4A 38 ?? ?? ?? 40 ?? ?? ?? ?? ?? 4C ?? 41 ?? 49",
         "48 89 5C 24 ?? 48 89 ?? 24 ?? 57 48 83 EC 20 41 8B 40 40 49 8B D8 48 8B ?? 48 8B F9 48 0F BA E0 08 73 ?? 48 8B ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 48 8B 40 10 48 39 18 75 F7 48 8B ?? 08 48 89 ?? 38 48",
         // linux
         "41 57 41 56 53 48 89 d3 49 89 ff f6 42 41 01 75 ?? 01001??? 89 f6 01001??? 8b 47 28 01001??? 63 4b 4c 01001??? 01 c1 01001??? 89 4f 38 01001??? 89 47 40 01001??? 8b 03 01001??? 89 df ff 90 88 00 00 00 84 c0 74 ?? 01001??? 8b 43 08 b9 00 00 00 24 23 48 10 01001??? 8b 7f 40 81 f9 00 00 00 04",
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(FFrameStepExplicitProperty(ensure_one(
        res.into_iter().flatten(),
    )?))
});

/// public: static void __cdecl UKismetStringLibrary::execLen(class UObject *, struct FFrame &, void *const)
/// public: void __cdecl UKismetStringLibrary::execLen(struct FFrame &, void *const)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FFrameStepViaExec {
    pub step: usize,
    pub step_explicit_property: usize,
}
impl_resolver!(all, FFrameStepViaExec, |ctx| async {
    let patterns = [
        "48 89 5C 24 08 48 89 74 24 10 57 48 83 EC ?? 33 FF 33 C0 49 8B F0 48 8B DA 48 8B CA 48 89 7C 24 20 48 89 7C 24 28 48 39 42 20 74 10 48 8B 52 18 4C 8D 44 24 20 E8 [ ?? ?? ?? ?? ] EB 1C 4C 8B 82 80 00 00 00 49 8B 40 ?? 48 89 82 80 00 00 00 48 8D 54 24 20 E8 [ ?? ?? ?? ?? ] 48 8B 43 20 48 8D 4C 24 20 48 85 C0",
        "48 89 5C 24 08 48 89 74 24 10 57 48 83 EC ?? 33 FF 49 8B F0 48 8B DA 48 89 7C 24 20 48 ?? ?? ?? ?? ?? ?? ?? 48 39 7A 20 74 10 48 8B 52 18 4C 8D 44 24 20 E8 [ ?? ?? ?? ?? ] EB 1C 4C 8B 82 80 00 00 00 49 8B 40 ?? 48 89 82 80 00 00 00 48 8D 54 24 20 E8 [ ?? ?? ?? ?? ] 48 8B 43 20 48 8D 4C 24 20 48 85 C0 40 0F",
        "48 89 5C 24 08 48 89 74 24 10 57 48 83 EC 30 33 ?? 49 8B F0 48 89 ?? 24 20 48 8B ?? 48 89 ?? 24 28 E8 [ ?? ?? ?? ?? ] 48 8B ?? 48 39 ?? 20 74 10 48 8B ?? 18 4C 8D 44 24 20 E8 ?? ?? ?? ?? EB 1C 4C 8B ?? ?? 00 00 00 48 8D 54 24 20 49 8B 40 20 48 89 ?? ?? 00 00 00 E8 [ ?? ?? ?? ?? ] 48 8B ?? 20 48",
        "41 56 53 01001??? 83 ec 18 01001??? 89 d6 01001??? 89 f3 0f 57 c0 0f 29 04 ??100??? e8 ?? ?? ?? ?? 01001??? 83 7b 20 00 74 ?? 01001??? 8b 73 18 01001??? 89 e2 01001??? 89 df e8 [ ?? ?? ?? ?? ] eb ?? 01001??? 8b 93 88 00 00 00 01001??? 8b 42 20 01001??? 89 83 88 00 00 00 01001??? 89 e6 01001??? 89 df e8 [ ?? ?? ?? ?? ]"
    ];

    let res = join_all(
        patterns
            .iter()
            .map(|p| ctx.scan_tagged((), Pattern::new(p).unwrap())),
    )
    .await;

    ensure_one(
        res.into_iter()
            .flat_map(|(_, pattern, addresses)| -> Result<_> {
                try_ensure_one(addresses.iter().map(|a| -> Result<_> {
                    let caps = ctx.image().memory.captures(&pattern, *a)?.unwrap();
                    Ok(FFrameStepViaExec {
                        step: caps[0].rip(),
                        step_explicit_property: caps[1].rip(),
                    })
                }))
            }),
    )
});

```

`patternsleuth/src/resolvers/unreal/mod.rs`:

```rs
pub mod aes;
pub mod blueprint_library;
pub mod engine_version;
pub mod fname;
pub mod ftext;
pub mod fuobject_hash_tables;
pub mod game_loop;
pub mod gmalloc;
pub mod guobject_array;
pub mod kismet;
pub mod pak;
pub mod save_game;
pub mod static_construct_object;
pub mod static_find_object;

use std::{
    collections::{HashMap, HashSet},
    fmt::Debug,
};

use futures::future::join_all;
use iced_x86::FlowControl;
use itertools::Itertools;
use patternsleuth_scanner::Pattern;

use crate::{
    disassemble::{disassemble, Control},
    resolvers::{
        bail_out, ensure_one, impl_resolver, impl_resolver_singleton, try_ensure_one, Result,
    },
    Addressable, Image, Matchable, MemoryAccessorTrait,
};

#[allow(unused)]
mod util {
    use crate::resolvers::AsyncContext;

    use super::*;

    #[derive(Debug, Clone, Copy)]
    pub(crate) struct Call {
        pub(crate) index: usize,
        pub(crate) ip: usize,
        pub(crate) callee: usize,
    }

    pub(crate) fn utf16(string: &str) -> Vec<u8> {
        string.encode_utf16().flat_map(u16::to_le_bytes).collect()
    }
    pub(crate) fn utf8_pattern(string: &str) -> Pattern {
        Pattern::from_bytes(string.as_bytes().to_vec()).unwrap()
    }
    pub(crate) fn utf16_pattern(string: &str) -> Pattern {
        Pattern::from_bytes(utf16(string)).unwrap()
    }
    pub(crate) async fn scan_xrefs(
        ctx: &AsyncContext<'_>,
        addresses: impl IntoIterator<Item = &usize> + Copy,
    ) -> Vec<usize> {
        let refs_indirect = join_all(
            addresses
                .into_iter()
                .map(|s| ctx.scan(Pattern::from_bytes(usize::to_le_bytes(*s).into()).unwrap())),
        )
        .await;

        let refs = join_all(
            addresses
                .into_iter()
                .copied()
                .chain(refs_indirect.into_iter().flatten())
                .flat_map(|s| {
                    let mut scans =
                        vec![format!("48 8d ?? X0x{s:X}"), format!("4c 8d ?? X0x{s:X}")];
                    if TryInto::<u32>::try_into(s).is_ok() {
                        // mov reg, imm32 if address is 32 bit
                        scans.extend([
                            format!("b8 0x{s:X}"),
                            format!("b9 0x{s:X}"),
                            format!("ba 0x{s:X}"),
                            format!("bb 0x{s:X}"),
                            format!("bc 0x{s:X}"),
                            format!("bd 0x{s:X}"),
                            format!("be 0x{s:X}"),
                            format!("bf 0x{s:X}"),
                        ]);
                    }
                    scans
                })
                .map(|p| ctx.scan(Pattern::new(p).unwrap())),
        )
        .await;

        refs.into_iter().flatten().collect()
    }

    pub(crate) async fn scan_xcalls(
        ctx: &AsyncContext<'_>,
        addresses: impl IntoIterator<Item = &usize> + Copy,
    ) -> Vec<usize> {
        let refs_indirect = join_all(
            addresses
                .into_iter()
                .map(|s| ctx.scan(Pattern::from_bytes(usize::to_le_bytes(*s).into()).unwrap())),
        )
        .await;

        let refs = join_all(
            addresses
                .into_iter()
                .copied()
                .chain(refs_indirect.into_iter().flatten())
                .flat_map(|s| {
                    [
                        //ctx.scan(Pattern::new(format!("10111??? 0x{s:X}")).unwrap()), // mov reg, imm32
                        ctx.scan(Pattern::new(format!("e8 X0x{s:X}")).unwrap()),
                        ctx.scan(Pattern::new(format!("e9 X0x{s:X}")).unwrap()),
                    ]
                }),
        )
        .await;

        refs.into_iter().flatten().collect()
    }

    pub(crate) fn root_functions<'a, I>(ctx: &AsyncContext<'_>, addresses: I) -> Result<Vec<usize>>
    where
        I: IntoIterator<Item = &'a usize> + Copy,
    {
        Ok(addresses
            .into_iter()
            .map(|r| -> Result<_> { Ok(ctx.image().get_root_function(*r)?.map(|f| f.range.start)) })
            .collect::<Result<Vec<_>>>()?
            .into_iter()
            .flatten()
            .collect())
    }

    pub(crate) fn find_calls(img: &Image<'_>, f: usize) -> Result<Vec<Call>> {
        let mut calls = vec![];

        disassemble(img, f, |inst| {
            let cur = inst.ip() as usize;
            if Some(f) != img.get_root_function(cur)?.map(|f| f.range.start) {
                return Ok(Control::Break);
            }

            match inst.flow_control() {
                FlowControl::Call
                | FlowControl::ConditionalBranch
                | FlowControl::UnconditionalBranch => {
                    let call = inst.near_branch_target() as usize;
                    if Some(f) != img.get_root_function(call)?.map(|f| f.range.start) {
                        calls.push(Call {
                            index: 0,
                            ip: inst.ip() as usize,
                            callee: call,
                        });
                    }
                }
                _ => {}
            }

            Ok(Control::Continue)
        })?;

        calls.sort_by_key(|c| c.ip);
        for (i, call) in calls.iter_mut().enumerate() {
            call.index = i;
        }
        Ok(calls)
    }

    pub(crate) fn find_path(
        img: &Image<'_>,
        f: usize,
        depth: usize,
        searched: &mut HashSet<usize>,
        path: &mut Vec<Call>,
        needle: usize,
    ) -> Result<Vec<String>> {
        searched.insert(f);

        let mut result = vec![];
        let mut calls = vec![];

        disassemble(img, f, |inst| {
            let cur = inst.ip() as usize;
            if !(f..f + 1000).contains(&cur)
                && Some(f) != img.get_root_function(cur)?.map(|f| f.range.start)
            {
                println!("bailing at {:x}", inst.ip());
                return Ok(Control::Break);
            }

            match inst.flow_control() {
                FlowControl::Call
                | FlowControl::ConditionalBranch
                | FlowControl::UnconditionalBranch => {
                    let call = inst.near_branch_target() as usize;
                    println!("{:x} {:x}", inst.ip(), call);
                    if Some(f) != img.get_root_function(call)?.map(|f| f.range.start) {
                        calls.push(Call {
                            index: 0, // unknown for now
                            ip: cur,
                            callee: call,
                        });
                    }
                }
                _ => {}
            }

            Ok(Control::Continue)
        })?;

        for (i, call) in calls.iter_mut().sorted_by_key(|c| c.ip).enumerate() {
            call.index = i;
            if !searched.contains(&call.callee) {
                path.push(*call);
                if call.callee == needle {
                    println!("{path:x?}");
                    result.push(format!("{path:x?}"));
                }
                if depth > 0 {
                    result.extend(find_path(
                        img,
                        call.callee,
                        depth - 1,
                        searched,
                        path,
                        needle,
                    )?);
                }
                path.pop();
            }
        }
        Ok(result)
    }
}

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct KismetSystemLibrary(pub HashMap<String, usize>);

impl_resolver!(all, KismetSystemLibrary, |ctx| async {
    let mem = &ctx.image().memory;

    let s = Pattern::from_bytes(
        "KismetSystemLibrary\x00"
            .encode_utf16()
            .flat_map(u16::to_le_bytes)
            .collect(),
    )
    .unwrap();
    let strings = ctx.scan(s).await;

    let refs = join_all(strings.iter().map(|s| {
        ctx.scan(
            Pattern::new(format!(
        // fragile (only 4.25-4.27 most likely)
        "4c 8d 0d [ ?? ?? ?? ?? ] 88 4c 24 70 4c 8d 05 ?? ?? ?? ?? 49 89 43 e0 48 8d 15 X0x{:x}",
        s
    ))
            .unwrap(),
        )
    }))
    .await;

    let cap = Pattern::new("4c 8d 0d [ ?? ?? ?? ?? ]").unwrap();

    let register_natives_addr =
        try_ensure_one(refs.iter().flatten().map(|a| -> Result<_> {
            Ok(ctx.image().memory.captures(&cap, *a)?.unwrap()[0].rip())
        }))?;

    let register_natives = Pattern::new("48 83 ec 28 e8 ?? ?? ?? ?? 41 b8 [ ?? ?? ?? ?? ] 48 8d 15 [ ?? ?? ?? ?? ] 48 8b c8 48 83 c4 28 e9 ?? ?? ?? ??").unwrap();

    let captures = ctx
        .image()
        .memory
        .captures(&register_natives, register_natives_addr);

    if let Some([num, data]) = captures?.as_deref() {
        let mut res = HashMap::new();

        let ptr = data.rip();
        for i in 0..(num.u32() as usize) {
            let a = ptr + i * 0x10;
            res.insert(mem.read_string(mem.ptr(a)?)?, mem.ptr(a + 8)?);
        }
        Ok(KismetSystemLibrary(res))
    } else {
        bail_out!("did not match");
    }
});

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct ConsoleManagerSingleton(usize);

impl_resolver_singleton!(all, ConsoleManagerSingleton, |ctx| async {
    let strings = join_all([
        ctx.scan(
            Pattern::from_bytes(
                "r.DumpingMovie"
                    .encode_utf16()
                    .flat_map(u16::to_le_bytes)
                    .collect(),
            )
            .unwrap(),
        ),
        ctx.scan(
            Pattern::from_bytes(
                "vr.pixeldensity"
                    .encode_utf16()
                    .flat_map(u16::to_le_bytes)
                    .collect(),
            )
            .unwrap(),
        ),
    ])
    .await;

    let refs = join_all(
        strings
            .into_iter()
            .flatten()
            .map(|addr| ctx.scan(Pattern::new(format!("48 8d 15 X0x{addr:x}")).unwrap())),
    )
    .await;

    let fns = refs
        .into_iter()
        .flatten()
        .map(|r| -> Result<_> { Ok(ctx.image().get_root_function(r)?.map(|f| f.range.start)) })
        .collect::<Result<Vec<_>>>()? // TODO avoid this collect?
        .into_iter()
        .flatten();

    Ok(ConsoleManagerSingleton(ensure_one(fns)?))
});

/// void UObjectBaseUtility::GetPathName(class UObjectBaseUtility const* this, class UObject const* StopOuter, class FString* ResultString)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct UObjectBaseUtilityGetPathName(pub usize);
impl_resolver_singleton!(all, UObjectBaseUtilityGetPathName, |ctx| async {
    let patterns = [
        "40 53 48 81 EC 50 02 00 00 48 8B 05 ?? ?? ?? ?? 48 33 C4 48 89 84 24 ?? ?? ?? ?? 48 8D 44 24",
    ];
    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;
    Ok(Self(ensure_one(res.into_iter().flatten())?))
});

/// useful for extracting strings from common patterns for analysis
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct UtilStringExtractor(pub HashSet<String>);
impl_resolver!(all, UtilStringExtractor, |ctx| async {
    let strings = ctx
        .scan(
            Pattern::new(
                "48 8d 55 f8 49 8b c8 e8 | ?? ?? ?? ?? 0f 28 45 f0 48 8d 55 f0 44 8b c8 66 0f 7f 45 f0 41 b8 01 00 00 00 48 8d 0d ?? ?? ?? ?? e8 ?? ?? ?? ??",
            )
            .unwrap(),
        )
        .await;

    let mem = &ctx.image().memory;

    Ok(UtilStringExtractor(
        strings
            .into_iter()
            .map(|a| -> Result<_> { Ok(mem.read_wstring(mem.rip4(a)?)?) })
            .filter_map(|s| s.ok())
            .collect::<HashSet<String>>(),
    ))
});

/// useful for extracting strings from common patterns for analysis
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct A(pub HashSet<usize>);
impl_resolver!(all, A, |ctx| async {
    let strings = ctx
        .scan(
            Pattern::new(
                "48 8d 55 f8 49 8b c8 e8 ?? ?? ?? ?? 0f 28 45 f0 48 8d 55 f0 44 8b c8 66 0f 7f 45 f0 41 b8 01 00 00 00 48 8d 0d ?? ?? ?? ?? e8 | ?? ?? ?? ??",
            )
            .unwrap(),
        )
        .await;

    let mem = &ctx.image().memory;

    Ok(A(strings
        .into_iter()
        .map(|a| Ok(mem.rip4(a)?))
        .collect::<Result<HashSet<_>>>()?))
});

```

`patternsleuth/src/resolvers/unreal/pak.rs`:

```rs
use std::fmt::Debug;

use futures::future::join_all;

use crate::resolvers::{ensure_one, impl_resolver_singleton, unreal::util};

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct FPakPlatformFileInitialize(pub usize);
impl_resolver_singleton!(collect, FPakPlatformFileInitialize);
impl_resolver_singleton!(PEImage, FPakPlatformFileInitialize, |ctx| async {
    let string_xrefs = |strings: &'static [&'static str]| async {
        let strings: Vec<_> = join_all(strings.iter().map(|s| ctx.scan(util::utf16_pattern(s))))
            .await
            .into_iter()
            .flatten()
            .collect();
        let refs = util::scan_xrefs(ctx, &strings).await;
        ensure_one(util::root_functions(ctx, &refs)?)
    };

    let (a, b) = futures::join!(
        string_xrefs(&["%sPaks/%s-\0"]),
        string_xrefs(&[
            "ushaderbytecode\0",
            "%sPaks/global\0",
            "fileopenlog\0",
            "Signedpak\0"
        ]),
    );
    Ok(Self(b.or(a)?))
});
impl_resolver_singleton!(ElfImage, FPakPlatformFileInitialize, |_ctx| async {
    super::bail_out!("ElfImage unimplemented");
});

```

`patternsleuth/src/resolvers/unreal/save_game.rs`:

```rs
use std::fmt::Debug;

use futures::future::join_all;

use patternsleuth_scanner::Pattern;

use crate::resolvers::{ensure_one, impl_resolver_singleton};

/// public: static bool __cdecl UGameplayStatics::SaveGameToMemory(class USaveGame *, class TArray<unsigned char, class TSizedDefaultAllocator<32> > &)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct UGameplayStaticsSaveGameToMemory(pub usize);
impl_resolver_singleton!(all, UGameplayStaticsSaveGameToMemory, |ctx| async {
    let patterns = [
        "48 89 5C 24 10 48 89 7C 24 18 55 48 8D AC 24 ?? FF FF FF 48 81 EC ?? 01 00 00 48 8B DA 48 8B F9 48 85 C9 0F 84 ?? 02 00 00 0F 57 C0 48 C7 85 ?? 00 00 00 00 00 00 00",
        "48 89 5C 24 10 48 89 7C 24 18 55 48 8D AC 24 20 FF FF FF 48 81 EC E0 01 00 00 48 8B DA 48 8B F9 48 85 C9 0F 84 ?? ?? 00 00 0F 57 C0 48 C7 85 F0 00 00 00 00 00 00 00 33 C0 48 8D 4D 80 0F 11 45 80 48 89 45 10 0F 11 45 90 0F 11 45 A0 0F 11 45 B0 0F 11 45 C0 0F 11 45 D0 0F 11 45 E0 0F 11 45 F0 0F 11 45",
        "48 89 5C 24 10 48 89 7C 24 18 55 48 8D AC 24 ?? FF FF FF 48 81 EC ?? 01 00 00 48 8B DA 48 8B F9 48 85 C9 0F 84 71 01 00 00 33 D2 48 C7 85 ?? 00 00 00 00 00 00 00 41 B8 ?? 00 00 00 48 8D 4D 80 E8 ?? ?? ?? ?? 48 8D 4D 80 E8 ?? ?? ?? ?? 48 8D 05 ?? ?? ?? ?? 48 C7 45 ?? 00 00 00 00 48 89 45 80 48 8D 4D",
        //linux
        "41 57 41 56 53 01001??? 81 ec b0 01 00 00 01001??? 89 fb 01001??? 85 ff 0f 84 ?? ?? ?? ?? 01001??? 89 f7 0f 57 c0 0f 29 84 ??100100 80 00 00 00 0f 29 44 ??100100 70 0f 29 44 ??100100 60 0f 29 44 ??100100 50 0f 29 44 ??100100 40 0f 29 44 ??100100 30 0f 29 44 ??100100 20 0f 29 44 ??100100 10 0f 29 04 ??100100 01001??? c7 84 ??100100 90 00 00 00 00 00 00 00 01001??? 89 e6",
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(UGameplayStaticsSaveGameToMemory(ensure_one(
        res.into_iter().flatten(),
    )?))
});

/// public: static bool __cdecl UGameplayStatics::SaveGameToSlot(class USaveGame *, class FString const &, int)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct UGameplayStaticsSaveGameToSlot(pub usize);
impl_resolver_singleton!(all, UGameplayStaticsSaveGameToSlot, |ctx| async {
    let patterns = [
        "48 89 5C 24 08 48 89 74 24 10 57 48 83 EC 40 ?? 8B ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? E8 ?? ?? FF FF 84 C0 74 58 E8 ?? ?? ?? ?? 48 8B ?? 48 8B ?? FF 52 ?? 4C 8B D0 48 85 C0 74 42 39 74 24 38 7E 3C 8B 53 08 ?? ?? ?? ?? ?? 0F 44 CE 85 C9 7E 2D",
        "48 89 5C 24 08 48 89 74 24 10 48 89 7C 24 18 55 41 56 41 57 48 8D AC 24 ?? FF FF FF 48 81 EC ?? ?? 00 00 48 8B F1 45 33 FF 48 8B 0D ?? ?? ?? ?? 45 8B F0 48 8B ?? 48 85 C9 75 27 41 8D 4F 08 E8 ?? ?? ?? ?? 48 8B C8 48 85 C0 74 0C 48 8D 05 ?? ?? ?? ?? 48 89 01 EB 03 49 8B CF 48 89 0D ?? ?? ?? ?? 48 8B",
        "40 55 56 57 41 54 41 55 41 ?? 48 8D AC 24 ?? ?? FF FF 48 81 EC ?? ?? 00 00 48 8B 05 ?? ?? ?? ?? 48 33 C4 48 89 85 ?? ?? 00 00 4C 8B ?? 45 33 ED 48 8B 0D ?? ?? ?? ?? 45 8B E0 48 8B FA 48 85 C9 75 27 41 8D 4D 08 E8 ?? ?? ?? ?? 48 8B C8 48 85 C0 74 0C 48 8D 05 ?? ?? ?? ?? 48 89 01 EB 03 49 8B CD 48 89",
        // linux
        "55 53 01001??? 83 ec 18 89 d5 01001??? 89 f3 0f 57 c0 0f 29 04 ??100??? 01001??? 89 e6 e8 ?? ?? ?? ?? 84 c0 74 ?? 01001??? 8b 3d ?? ?? ?? ?? 01001??? 85 ff 74 ?? 01001??? 8b 07 ff 50 48 01001??? 85 c0 75 ?? eb ??",
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(UGameplayStaticsSaveGameToSlot(ensure_one(
        res.into_iter().flatten(),
    )?))
});

/// public: static class USaveGame * __cdecl UGameplayStatics::LoadGameFromMemory(class TArray<unsigned char, class TSizedDefaultAllocator<32> > const &)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct UGameplayStaticsLoadGameFromMemory(pub usize);
impl_resolver_singleton!(all, UGameplayStaticsLoadGameFromMemory, |ctx| async {
    let patterns = [
        "48 89 5C 24 20 55 48 8D AC 24 10 FF FF FF 48 81 EC F0 01 00 00 83 79 08 00 48 8B D9 75 13 33 C0 48 8B 9C 24 18 02 00 00 48 81 C4 F0 01 00 00 5D C3 0F 57 C0 48 89 ?? 24 ?? 02 00 00 48 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 0F 11 45 ?? 0F 11 45 ?? 0F 11 45 ?? 0F 11 45 ?? 0F 11 45 ?? 0F 11 45 ?? 0F 11",
        "40 55 48 8D AC 24 00 FF FF FF 48 81 EC 00 02 00 00 83 79 08 00 75 0B 33 C0 48 81 C4 00 02 00 00 5D C3 48 8B D1 48 89 9C 24 20 02 00 00 48 89 BC 24 28 02 00 00 48 8D 4D A0 41 B0 01 33 FF E8 ?? ?? ?? ?? 0F 57 C0 89 7C 24 50 48 8D 4C 24 50 66 0F 7F 44 24 40 66 89 7C 24 54 89 7C 24 58 48 89 7C 24 60 48",
        "40 55 48 8D AC 24 ?? ?? FF FF 48 81 EC ?? 02 00 00 83 79 08 00 75 0B 33 C0 48 81 C4 ?? 02 00 00 5D C3 48 89 9C 24 ?? 02 00 00 48 8B D1 48 89 B4 24 ?? 02 00 00 48 8D 4D A0 48 89 BC 24 ?? 02 00 00 41 B0 01 33 FF E8 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 24 ?? ?? 89 7C 24",
        "48 89 5C 24 20 55 48 8D AC 24 ?? FF FF FF 48 81 EC ?? ?? 00 00 83 79 08 00 48 8B D9 75 13 33 C0 48 8B 9C 24 ?? 02 00 00 48 81 C4 ?? ?? 00 00 5D C3 48 89 B4 24 ?? 02 00 00 48 8D 4D A0 48 89 BC 24 ?? 02 00 00 33",
        "40 55 53 48 8D AC 24 08 FF FF FF 48 81 EC F8 01 00 00 83 79 08 00 48 8B D9 75 0C 33 C0 48 81 C4 F8 01 00 00 5B 5D C3 48 89 B4 24 18 02 00 00 48 8D 4D A0 48 89 BC 24 20 02 00 00 33 FF 4C 89 B4 24 F0 01 00 00 E8 ?? ?? ?? ?? 48 8D 05 ?? ?? ?? 00 48 89 7D 30 48 89 45 A0 48 8D 4D A0 48 B8 FF FF FF FF FF",
        // linux
        "41 57 41 56 53 01001??? 81 ec c0 01 00 00 83 7f 08 00 0f 84 ?? ?? ?? ?? 01001??? 89 fb 0f 57 c0 0f 29 84 ??100100 e0 00 00 00 0f 29 84 ??100100 d0 00 00 00 0f 29 84 ??100100 c0 00 00 00 0f 29 84 ??100100 b0 00 00 00 0f 29 84 ??100100 a0 00 00 00 0f 29 84 ??100100 90 00 00 00 0f 29 84 ??100100 80 00 00 00 0f 29 44 ??100100 70 0f 29 44 ??100100 60 01001??? c7 84 ??100100 f0 00 00 00 00 00 00 00 01001??? 8d 74 ??100100 60 01001??? 89 f7 e8 ?? ?? ?? ?? 01001??? c7 84 ??100100 f8 00 00 00 00 00 00 00 01001??? c7 44 ??100100 60 ?? ?? ?? ?? 01001??? 89 9c ??100100 00 01 00 00 ",
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(UGameplayStaticsLoadGameFromMemory(ensure_one(
        res.into_iter().flatten(),
    )?))
});

/// public: static class USaveGame * __cdecl UGameplayStatics::LoadGameFromSlot(class FString const &, int)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct UGameplayStaticsLoadGameFromSlot(pub usize);
impl_resolver_singleton!(all, UGameplayStaticsLoadGameFromSlot, |ctx| async {
    let patterns = [
        "48 8B C4 55 ?? 48 8D A8 ?? FE FF FF 48 81 EC ?? 02 00 00 48 89 ?? 08 33 ?? 48 89 ?? 10 48 8B ?? 4C 89 70 E8 44 8B F2 48 89 ?? 24 40 48 89 ?? 24 48 E8 ?? ?? ?? ?? 48 8B C8 4C 8B 00 41 FF 50 40 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 48 8D 35",
        "48 89 5C 24 08 48 89 74 24 10 57 48 83 EC 40 33 DB 8B F2 48 89 5C 24 30 48 8B F9 48 89 5C 24 38 E8 ?? ?? ?? ?? 48 8B C8 4C 8B 00 41 FF 50 40 4C 8B D0 48 85 C0 74 4A 8B 57 08 85 D2 8D 4A FF 0F 44 CB 85 C9 7E 3B 85 D2 74 05 4C 8B 07 EB 07 4C 8D 05 ?? ?? ?? ?? 48 8B 00 48 8D 4C 24 30 48 89 4C 24 20 44",
        "48 89 5C 24 10 55 57 41 56 48 8D AC 24 00 FF FF FF 48 81 EC 00 02 00 00 48 8B D9 33 FF 48 8B 0D ?? ?? ?? ?? 44 8B F2 48 85 C9 75 26 8D 4F 08 E8 ?? ?? ?? ?? 48 8B C8 48 85 C0 74 0C 48 8D 05 ?? ?? ?? ?? 48 89 01 EB 03 48 8B CF 48 89 0D ?? ?? ?? ?? 48 8B 01",
        "48 89 5C 24 08 55 56 57 48 8D AC 24 ?? FF FF FF 48 81 EC ?? 01 00 00 48 8B D9 ?? ?? ?? ?? ?? ?? ?? ?? ?? 8B F2 48 85 C9 75 26 8D 4F 08 E8 ?? ?? ?? FF 48 8B C8 48 85 C0 74 0C 48 8D 05 ?? ?? ?? ?? 48 89 01 EB 03 48 8B CF 48 89 0D ?? ?? ?? ?? 48 8B 01 FF 50 40 48 8B C8 48 85 C0 0F 84 ?? ?? 00 00 8B 43",
        "48 89 5C 24 18 55 56 57 48 8D AC 24 ?? FF FF FF 48 81 EC ?? ?? 00 00 48 8B 05 ?? ?? ?? ?? 48 33 C4 48 89 85 ?? 00 00 00 48 8B D9 33 FF 48 8B 0D ?? ?? ?? ?? 8B F2 48 85 C9 75 26 8D 4F 08 E8 ?? ?? ?? ?? 48 8B C8 48 85 C0 74 0C 48 8D 05 ?? ?? ?? ?? 48 89 01 EB 03 48 8B CF 48 89 0D ?? ?? ?? ?? 48 8B 01",
        // linux
        "55 53 48 83 ec 18 89 f5 01001??? 89 fb 0f 57 c0 0f 29 04 ??100100 01001??? 8b 3d ?? ?? ?? ?? 01001??? 85 ff 74 ?? 01001??? 8b 07 ff 50 48 01001??? 85 c0 75 ?? eb ?? bf 08 00 00 00 e8 ?? ?? ?? ?? 01001??? 89 c7 01001??? c7 00 ?? ?? ?? ?? 01001??? 89 05 ?? ?? ?? ?? 01001??? 8b 07 ff 01010??? ?? 01001??? 85 c0 74 ??"
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(UGameplayStaticsLoadGameFromSlot(ensure_one(
        res.into_iter().flatten(),
    )?))
});

// not exists on linux
/// public: static bool __cdecl UGameplayStatics::DoesSaveGameExist(class FString const &, int)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct UGameplayStaticsDoesSaveGameExist(pub usize);
impl_resolver_singleton!(all, UGameplayStaticsDoesSaveGameExist, |ctx| async {
    let patterns = [
        "48 89 5C 24 08 57 48 83 EC 20 8B FA 48 8B D9 E8 ?? ?? ?? ?? 48 8B C8 4C 8B 00 41 FF 50 ?? 48 85 C0 74 3D 83 7B 08 00 4C 8B 00 4D 8B 48 ?? 74 16 48 8B 13 44 8B C7 48 8B C8 48 8B 5C 24 30 48 83 C4 20 5F 49 FF E1 48 8D 15 ?? ?? ?? ?? 44 8B C7 48 8B C8 48 8B 5C 24 30 48 83 C4 20 5F 49 FF E1 48 8B 5C 24",
        "48 89 5C 24 08 57 48 83 EC 20 8B FA 48 8B D9 E8 ?? ?? ?? ?? 48 8B C8 4C 8B 00 41 FF 50 40 48 8B C8 48 85 C0 74 38 83 7B 08 00 74 17 48 8B 00 44 8B C7 48 8B 13 48 8B 5C 24 30 48 83 C4 20 5F 48 FF 60 08 48 8B 00 48 8D 15 ?? ?? ?? ?? 44 8B C7 48 8B 5C 24 30 48 83 C4 20 5F 48 FF 60 08 48 8B 5C 24 30 48",
        "48 89 5C 24 08 57 48 83 EC 20 48 8B D9 ?? ?? ?? ?? ?? ?? ?? ?? ?? 48 85 C9 75 27 B9 08 00 00 00 E8 ?? ?? ?? ?? 48 8B C8 48 85 C0 74 0C 48 8D 05 ?? ?? ?? ?? 48 89 01 EB 02 33 C9 48 89 0D ?? ?? ?? ?? 48 8B 01 FF 50 40 48 8B C8 48 85 C0 74 38 83 7B 08 00 74 17 48 8B 00 ?? 8B ?? ?? 8B ?? 48 8B 5C 24 30",
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(UGameplayStaticsDoesSaveGameExist(ensure_one(
        res.into_iter().flatten(),
    )?))
});

```

`patternsleuth/src/resolvers/unreal/static_construct_object.rs`:

```rs
use std::{collections::HashSet, fmt::Debug};

use futures::{future::join_all, join};
use patternsleuth_scanner::Pattern;

use crate::{
    disassemble::{disassemble, Control},
    resolvers::{ensure_one, impl_resolver_singleton, try_ensure_one, unreal::util, Result},
    MemoryAccessorTrait,
};

/// class UObject * __cdecl StaticConstructObject_Internal(struct FStaticConstructObjectParameters const &)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct StaticConstructObjectInternal(pub usize);
impl_resolver_singleton!(all, StaticConstructObjectInternal, |ctx| async {
    let any = join!(
        ctx.resolve(StaticConstructObjectInternalPatterns::resolver()),
        ctx.resolve(StaticConstructObjectInternalString::resolver()),
    );

    Ok(Self(*ensure_one(
        [any.0.map(|r| r.0), any.1.map(|r| r.0)]
            .iter()
            .filter_map(|r| r.as_ref().ok()),
    )?))
});

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct StaticConstructObjectInternalPatterns(pub usize);
impl_resolver_singleton!(all, StaticConstructObjectInternalPatterns, |ctx| async {
    let patterns = [
        "48 89 44 24 28 C7 44 24 20 00 00 00 00 E8 | ?? ?? ?? ?? 48 8B 5C 24 ?? 48 8B ?? 24",
        "E8 | ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? C0 E9 ?? 32 88 ?? ?? ?? ?? 80 E1 01 30 88 ?? ?? ?? ?? 48",
        "E8 | ?? ?? ?? ?? 48 8B D8 48 39 75 30 74 15",
        /*
                03f4df3f c6  44  24       MOV        byte ptr [RSP  + local_88 ],0x0
                         30  00
                03f4df44 0f  57  c0       XORPS      XMM0 ,XMM0
                03f4df47 0f  11  44       MOVUPS     xmmword ptr [RSP  + local_80[0] ],XMM0
                         24  38
                03f4df4c 4c  89  ff       MOV        RDI ,R15
                03f4df4f e8  2c  b6       CALL       StaticConstructObject_Internal                   undefined StaticConstructObject_
                         02  03
                03f4df54 48  89  c3       MOV        RBX ,RAX

         */
        "c6 44 24 30  00 0f 57 c0 0f 11 44 24 38 4c 89 ff e8 | ?? ?? ?? ?? 48 89"
    ];

    let res = join_all(patterns.iter().map(|p| ctx.scan(Pattern::new(p).unwrap()))).await;

    Ok(Self(try_ensure_one(res.iter().flatten().map(
        |a| -> Result<usize> { Ok(ctx.image().memory.rip4(*a)?) },
    ))?))
});

#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct StaticConstructObjectInternalString(pub usize);

impl_resolver_singleton!(collect, StaticConstructObjectInternalString);

impl_resolver_singleton!(ElfImage, StaticConstructObjectInternalString, |ctx| async {
    let strings = ctx
        .scan(util::utf16_pattern(
            "NewObject with empty name can\'t be used to create default",
        ))
        .await;
    let refs = util::scan_xrefs(ctx, &strings).await;
    let target_addr = refs
        .iter()
        .take(6)
        .flat_map(|&addr| -> Option<Vec<(usize, usize)>> {
            // find e8 call
            let mut callsites = Vec::default();
            // ...06f83ff0 is the real one?
            disassemble(ctx.image(), addr, |inst| {
                let cur = inst.ip() as usize;
                if !(addr..addr + 130).contains(&cur) {
                    return Ok(Control::Break);
                }
                if !inst.is_call_near_indirect() && inst.is_call_near() {
                    // eprintln!("Found call to @ {:08x}", inst.ip_rel_memory_address());
                    callsites.push(inst.ip_rel_memory_address() as usize);
                }
                Ok(Control::Continue)
            })
            .ok()?;
            // eprintln!("");
            // the seq is always
            // call FStaticConstructObjectParameters::FStaticConstructObjectParameters .0
            // call StaticConstructObjectInternal .1

            let callsites = callsites
                .iter()
                .zip(callsites.iter().skip(1))
                .map(|(&x, &y)| (x, y))
                .collect::<Vec<_>>();
            Some(callsites)
        })
        .reduce(|x, y| {
            let x: HashSet<(usize, usize)> = HashSet::from_iter(x);
            let y: HashSet<(usize, usize)> = HashSet::from_iter(y);
            let z = x.intersection(&y);
            z.cloned().collect()
        })
        .unwrap_or_default();
    Ok(Self(ensure_one(target_addr)?.1))
});

impl_resolver_singleton!(PEImage, StaticConstructObjectInternalString, |ctx| async {
    use iced_x86::{Code, FlowControl, OpKind, Register};
    use itertools::Itertools;

    use crate::{
        disassemble::disassemble_single,
        resolvers::{bail_out, Context, Result},
        Image, MemoryTrait,
    };

    let strings = join_all(
        [
            "UBehaviorTreeManager\0",
            "ULeaderboardFlushCallbackProxy\0",
            "UPlayMontageCallbackProxy\0",
        ]
        .iter()
        .map(|s| {
            ctx.scan(
                Pattern::from_bytes(s.encode_utf16().flat_map(u16::to_le_bytes).collect()).unwrap(),
            )
        }),
    )
    .await;

    let refs_indirect = join_all(
        strings
            .iter()
            .flatten()
            .map(|s| ctx.scan(Pattern::from_bytes(usize::to_le_bytes(*s).into()).unwrap())),
    )
    .await;

    let refs = join_all(
        strings
            .iter()
            .flatten()
            .chain(refs_indirect.iter().flatten())
            .flat_map(|s| {
                [
                    ctx.scan(Pattern::new(format!("48 8d ?? X0x{s:X}")).unwrap()),
                    ctx.scan(Pattern::new(format!("4c 8d ?? X0x{s:X}")).unwrap()),
                    ctx.scan(Pattern::new(format!("48 8d ?? X0x{:X}", s + 2)).unwrap()),
                    ctx.scan(Pattern::new(format!("4c 8d ?? X0x{:X}", s + 2)).unwrap()),
                ]
            }),
    )
    .await;

    let fns = refs
        .into_iter()
        .flatten()
        .map(|r| -> Result<_> { Ok(ctx.image().get_root_function(r)?.map(|f| f.range.start)) })
        .collect::<Result<Vec<_>>>()? // TODO avoid this collect?
        .into_iter()
        .flatten();

    fn check_is_new_object(img: &Image<'_>, f: usize) -> Result<bool> {
        let cmp = "NewObject with empty name can't"
            .encode_utf16()
            .flat_map(u16::to_le_bytes)
            .collect_vec();

        let check = |f| -> Result<bool> {
            let mut is = false;
            disassemble(img, f, |inst| {
                let cur = inst.ip() as usize;
                if Some(f) != img.get_root_function(cur)?.map(|f| f.range.start) {
                    return Ok(Control::Break);
                }

                if inst.code() == Code::Lea_r64_m
                    && inst.memory_base() == Register::RIP
                    && inst.op0_kind() == OpKind::Register
                    && inst.op1_kind() == OpKind::Memory
                {
                    let ptr = inst.ip_rel_memory_address() as usize;
                    if img
                        .memory
                        .range(ptr..ptr + cmp.len())
                        .map(|data| data == cmp)
                        .unwrap_or(false)
                    {
                        is = true;
                        return Ok(Control::Exit);
                    }
                }

                Ok(Control::Continue)
            })?;
            Ok(is)
        };

        if check(f)? {
            return Ok(true);
        } else {
            // sometimes can be a call deep so check all outgoing calls as well
            for call in util::find_calls(img, f)? {
                let mut f = call.callee;
                // sometimes there's a jmp stub between
                if let Some(inst) = disassemble_single(img, f)? {
                    if inst.flow_control() == FlowControl::UnconditionalBranch {
                        f = inst.near_branch_target() as usize;
                    }
                }

                if check(f)? {
                    return Ok(true);
                }
            }
        }
        Ok(false)
    }

    fn check_is_static_construct(img: &Image<'_>, f: usize) -> Result<bool> {
        let mut is = false;
        disassemble(img, f, |inst| {
            let cur = inst.ip() as usize;
            if Some(f) != img.get_root_function(cur)?.map(|f| f.range.start) {
                return Ok(Control::Break);
            }

            if inst.immediate32() == 0x10000080 {
                is = true;
                return Ok(Control::Exit);
            }

            Ok(Control::Continue)
        })?;
        Ok(is)
    }

    let new_object = {
        let mut fns = fns.collect_vec();

        let mut new_object = None;
        for f in &fns {
            if check_is_new_object(ctx.image(), *f)? {
                new_object = Some(*f);
                break;
            }
        }

        'root: for _ in 0..2 {
            #[derive(Clone, Copy)]
            enum CallType {
                Call,
                Jump,
            }

            if new_object.is_none() {
                let calls = join_all(fns.into_iter().flat_map(|f| {
                    [
                        ctx.scan_tagged2(
                            CallType::Call,
                            Pattern::new(format!("e8 X0x{f:x}")).unwrap(),
                        ),
                        ctx.scan_tagged2(
                            CallType::Jump,
                            Pattern::new(format!("e9 X0x{f:x}")).unwrap(),
                        ),
                    ]
                }))
                .await;

                fns = calls
                    .into_iter()
                    .flatten()
                    .map(|(t, r)| -> Result<_> {
                        Ok(match t {
                            CallType::Call => {
                                ctx.image().get_root_function(r)?.map(|f| f.range.start)
                            }
                            CallType::Jump => Some(r),
                        })
                    })
                    .collect::<Result<Vec<_>>>()? // TODO avoid this collect?
                    .into_iter()
                    .flatten()
                    .collect_vec();
            }

            for f in &fns {
                if check_is_new_object(ctx.image(), *f)? {
                    new_object = Some(*f);
                    break 'root;
                }
            }
        }
        new_object
    }
    .context("could not find NewObject<>")?;

    let mut checked = HashSet::new();
    for call in util::find_calls(ctx.image(), new_object)? {
        if !checked.contains(&call.callee) {
            checked.insert(call.callee);

            let mut f = call.callee;
            if let Some(inst) = disassemble_single(ctx.image(), f)? {
                if inst.flow_control() == FlowControl::UnconditionalBranch {
                    f = inst.near_branch_target() as usize;
                }
            }

            if check_is_static_construct(ctx.image(), f)? {
                return Ok(Self(call.callee));
            }
        }
    }
    // try one call deeper
    for f in checked.clone().into_iter() {
        for call in util::find_calls(ctx.image(), f)? {
            if !checked.contains(&call.callee) {
                checked.insert(call.callee);
                if check_is_static_construct(ctx.image(), call.callee)? {
                    return Ok(Self(call.callee));
                }
            }
        }
    }

    bail_out!("could not find StaticConstructObject_Internal call");
});

```

`patternsleuth/src/resolvers/unreal/static_find_object.rs`:

```rs
use crate::resolvers::{ensure_one, impl_resolver_singleton, unreal::util};

/// class UObject * __cdecl StaticFindObjectFast(class UClass *, class UObject *, class FName, bool, bool, enum EObjectFlags, enum EInternalObjectFlags)
/// class UObject * __cdecl StaticFindObjectFast(class UClass *, class UObject *, class FName, bool, enum EObjectFlags, enum EInternalObjectFlags)
/// class UObject * __cdecl StaticFindObjectFast(class UClass *, class UObject *, class FName, bool, bool, enum EObjectFlags)
#[derive(Debug, PartialEq)]
#[cfg_attr(
    feature = "serde-resolvers",
    derive(serde::Serialize, serde::Deserialize)
)]
pub struct StaticFindObjectFast(pub usize);
impl_resolver_singleton!(all, StaticFindObjectFast, |ctx| async {
    let strings = ctx.scan(util::utf16_pattern("Illegal call to StaticFindObjectFast() while serializing object data or garbage collecting!\0")).await;

    let refs = util::scan_xrefs(ctx, &strings).await;
    let fns = util::root_functions(ctx, &refs)?;
    Ok(Self(ensure_one(fns)?))
});

```

`patternsleuth/src/symbols.rs`:

```rs
use anyhow::Result;

use std::{collections::HashMap, path::Path};

use pdb::FallibleIterator;

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Symbol {
    pub name: String,
}
impl Symbol {
    pub fn demangle(&self) -> String {
        let name = self.name.to_string().to_string();
        msvc_demangler::demangle(&name, msvc_demangler::DemangleFlags::llvm())
            .unwrap_or_else(|_| name.to_string())
    }
}

fn print_symbol(
    symbols: &mut HashMap<usize, Symbol>,
    address_map: &pdb::AddressMap<'_>,
    base_address: usize,
    symbol: &pdb::Symbol<'_>,
) -> pdb::Result<()> {
    #[allow(clippy::single_match)]
    match symbol.parse()? {
        pdb::SymbolData::Public(data) => {
            if let Some(rva) = data.offset.to_rva(address_map) {
                let address = base_address + rva.0 as usize;
                symbols.insert(
                    address,
                    Symbol {
                        name: data.name.to_string().to_string(),
                    },
                );
            }
        }
        // procedure symbols don't seem to always be availble so instead we use the exception table to get the function bounds
        /*
        pdb::SymbolData::Procedure(data) => {
            let name_demangled = demangle(data.name);
            if filter(&name_demangled) {
                if let Some(rva) = data.offset.to_rva(address_map) {
                    println!(
                        "{:016x} proc len={:08x} {}",
                        rva.0, data.len, name_demangled
                    );
                }
            }
        }
        */
        _ => {}
    }

    Ok(())
}

fn walk_symbols(
    symbols_map: &mut HashMap<usize, Symbol>,
    address_map: &pdb::AddressMap<'_>,
    base_address: usize,
    mut symbols: pdb::SymbolIter<'_>,
) -> pdb::Result<()> {
    while let Some(symbol) = symbols.next()? {
        print_symbol(symbols_map, address_map, base_address, &symbol).ok();
    }
    Ok(())
}

pub fn dump_pdb_symbols<P: AsRef<Path>>(
    filename: P,
    base_address: usize,
) -> Result<HashMap<usize, Symbol>> {
    let mut symbols = HashMap::new();

    let file = std::fs::File::open(filename)?;
    let mut pdb = pdb::PDB::open(file)?;
    let symbol_table = pdb.global_symbols()?;
    let address_map = pdb.address_map()?;
    walk_symbols(
        &mut symbols,
        &address_map,
        base_address,
        symbol_table.iter(),
    )?;

    let dbi = pdb.debug_information()?;
    let mut modules = dbi.modules()?;
    while let Some(module) = modules.next()? {
        let Some(info) = pdb.module_info(&module)? else {
            continue;
        };
        walk_symbols(&mut symbols, &address_map, base_address, info.symbols()?)?;
    }
    Ok(symbols)
}

```

`patternsleuth/src/uesym.rs`:

```rs
use anyhow::{anyhow, Result};
use object::{from_bytes, slice_from_bytes, Pod};
use std::{collections::HashMap, path::Path};

use crate::symbols::Symbol;

#[repr(C, packed)]
#[derive(Clone, Copy)]
struct Header {
    record_count: u32,
}

#[repr(C, packed)]
#[derive(Clone, Copy)]
struct Record {
    address: u64,
    line_number: u32,
    file_relative_offset: u32,
    symbol_relative_offset: u32,
}

/// Safety: `Record` contains only a counter
/// and can be safely parsed from bytes.
unsafe impl Pod for Record {}

/// Safety: `Header` contains only a plain numbers
/// and offsets, thus it can be safely parsed from bytes.
unsafe impl Pod for Header {}

struct RawUESymbols<'data> {
    records: &'data [Record],
    data: &'data [u8],
}

pub struct WrapRecord<'a, 'data> {
    record: &'a Record,
    symbol: &'a RawUESymbols<'data>,
}

impl<'data> RawUESymbols<'data> {
    fn new(data: &'data [u8]) -> Result<RawUESymbols<'data>> {
        let (header, data) =
            from_bytes::<Header>(data).map_err(|_| anyhow!("Can't read haeder"))?;
        let (records, data) = slice_from_bytes::<Record>(data, header.record_count as usize)
            .map_err(|_| anyhow!("Can't read Records"))?;
        Ok(RawUESymbols { records, data })
    }

    fn iter(&self) -> impl Iterator<Item = WrapRecord<'_, 'data>> {
        self.records.iter().map(move |record| WrapRecord {
            record,
            symbol: self,
        })
    }
}

#[allow(dead_code)]
impl WrapRecord<'_, '_> {
    fn read_str(&self, relative_offset: usize) -> &'_ str {
        let start = relative_offset;
        let end = self.symbol.data[start..]
            .iter()
            .position(|&b| b == 0 || b == b'\n')
            .unwrap();
        std::str::from_utf8(&self.symbol.data[start..start + end]).unwrap()
    }

    fn symbol(&self) -> &'_ str {
        self.read_str(self.record.symbol_relative_offset as usize)
    }

    fn filename(&self) -> &'_ str {
        self.read_str(self.record.file_relative_offset as usize)
    }

    fn line(&self) -> u32 {
        self.record.line_number
    }

    fn address(&self) -> usize {
        self.record.address as usize
    }
}

pub fn dump_ue_symbols<P: AsRef<Path>>(
    filename: P,
    base_address: usize,
) -> Result<HashMap<usize, Symbol>> {
    let data = std::fs::read(filename)?;
    let symbols = RawUESymbols::new(data.as_slice())?;
    Ok(HashMap::from_iter(symbols.iter().map(|rec| {
        (
            rec.record.address as usize + base_address,
            Symbol {
                name: rec.symbol().to_string(),
            },
        )
    })))
}

```

`patternsleuth_cli/Cargo.toml`:

```toml
[package]
name = "patternsleuth_cli"
repository.workspace = true
authors.workspace = true
license.workspace = true
version.workspace = true
edition.workspace = true

[[bin]]
name = "patternsleuth"
path = "src/main.rs"

[dependencies]
patternsleuth = { path = "../patternsleuth", features = ["process-external", "symbols", "serde-resolvers", "image-pe", "image-elf"] }
anyhow = { workspace = true }
clap = { workspace = true }
colored = { workspace = true }
globset = { workspace = true }
iced-x86 = { workspace = true }
itertools = { workspace = true }
memchr = { workspace = true }
msvc-demangler = { workspace = true }
object = { workspace = true }
pdb = { workspace = true }
prettytable-rs = { workspace = true }
rayon.workspace = true
regex = { workspace = true }
strum = { workspace = true }
indicatif = { version = "0.17.7", features = ["rayon"] }
rusqlite = { version = "0.30.0", features = ["bundled"] }
crossbeam = "0.8.4"
patricia_tree = "0.8.0"
libc = "0.2.152"
serde = { workspace = true, features = ["rc"] }
serde_json = "1.0.111"
time = { version = "0.3.31", features = ["formatting", "macros", "local-offset"] }
tracing-subscriber = { version = "0.3.18", features = ["env-filter"] }
tracing = "0.1.40"

```

`patternsleuth_cli/build.rs`:

```rs
use std::process::Command;

fn main() {
    if let Some(git_hash) = Command::new("git")
        .args(["rev-parse", "HEAD"])
        .output()
        .ok()
        .and_then(|output| String::from_utf8(output.stdout).ok())
    {
        println!("cargo:rustc-env=GIT_HASH={}", git_hash);
    }

    if Command::new("git")
        .args(["diff-index", "--quiet", "HEAD"])
        .status()
        .ok()
        .map(|status| !status.success())
        .unwrap_or(false)
    {
        println!("cargo:rustc-env=GIT_DIRTY=true");
    }
}

```

`patternsleuth_cli/src/db.rs`:

```rs
use std::{
    borrow::Cow,
    collections::{HashMap, HashSet},
    fs,
};

use anyhow::Result;
use itertools::Itertools;
use patternsleuth::{image::Image, scanner::Pattern, PatternConfig};
use prettytable::{Cell, Row, Table};
use rayon::prelude::*;
use rusqlite::{Connection, OptionalExtension};

use crate::{
    disassemble, get_games, CommandAutoGen, CommandBuildIndex, CommandViewSymbol, GameFileEntry,
};

fn generate_patterns_for_symbol(symbol: &str) -> Result<Vec<Pattern>> {
    let conn = Connection::open("data.db")?;

    struct SqlFunction {
        data: Vec<u8>,
    }

    let mut stmt = conn.prepare(
        "SELECT data FROM functions JOIN symbols USING(game, address) WHERE symbol = ?1",
    )?;
    let rows = stmt.query_map((symbol,), |row| Ok(SqlFunction { data: row.get(0)? }))?;

    fn count_unequal<T: PartialEq>(a: &[T], b: &[T]) -> usize {
        a.iter().zip(b).filter(|(a, b)| a != b).count() + a.len().abs_diff(b.len())
    }

    struct Function {
        index: usize,
        sql: SqlFunction,
    }

    let mut functions = vec![];

    for row in rows {
        let sql = row?;

        let index = functions.len();
        functions.push(Function { index, sql });
    }

    let max = 100;

    let mut distances = HashMap::new();
    for (
        a_i,
        Function {
            sql: SqlFunction { data: a, .. },
            ..
        },
    ) in functions.iter().enumerate()
    {
        let mut cells = vec![Cell::new(&a_i.to_string())];
        for (
            b_i,
            Function {
                sql: SqlFunction { data: b, .. },
                ..
            },
        ) in functions.iter().enumerate()
        {
            let distance = count_unequal(&a[..a.len().min(max)], &b[..b.len().min(max)]);
            distances.insert((a_i, b_i), distance);
            distances.insert((b_i, a_i), distance);
            cells.push(Cell::new(&distance.to_string()));
        }
    }

    let groups = if let Some(last) = functions.pop() {
        let mut groups = vec![vec![last]];
        while let Some(b) = functions.pop() {
            let (d, group) = groups
                .iter_mut()
                .map(|group| {
                    (
                        group
                            .iter()
                            .map(|a| distances.get(&(a.index, b.index)).unwrap())
                            .max()
                            .unwrap(),
                        group,
                    )
                })
                .min_by_key(|(d, _)| *d)
                .unwrap();
            if *d < 50 {
                group.push(b);
            } else {
                groups.push(vec![b]);
            }
        }
        groups
    } else {
        vec![]
    };

    let patterns = groups
        .iter()
        .flat_map(|g| {
            build_common_pattern(
                g.iter()
                    .map(|f| &f.sql.data[..f.sql.data.len().min(max)])
                    .collect::<Vec<_>>(),
            )
            .map(|s| Pattern::new(s).unwrap())
        })
        .collect::<Vec<_>>();

    Ok(patterns)
}

pub(crate) fn auto_gen(_command: CommandAutoGen) -> Result<()> {
    let conn = Connection::open("data.db")?;

    #[derive(Debug)]
    struct QueryResult {
        symbol: String,
    }

    let mut stmt = conn.prepare("SELECT COUNT(*) AS count, symbol FROM symbols JOIN functions USING(game, address) WHERE demangled LIKE '% %' GROUP BY symbol HAVING count > 20")?;
    let rows = stmt.query_map((), |row| {
        Ok(QueryResult {
            symbol: row.get(1)?,
        })
    })?;

    let mut pattern_map: HashMap<String, Vec<Pattern>> = Default::default();

    for row in rows {
        let row = row?;
        dbg!(&row);
        let patterns = generate_patterns_for_symbol(&row.symbol)?;
        pattern_map
            .entry(row.symbol)
            .or_default()
            .extend(patterns.into_iter());
    }
    println!("testing {} symbols", pattern_map.len());

    let mut scan_patterns = vec![];

    for (symbol, patterns) in &pattern_map {
        for (i, pattern) in patterns.iter().enumerate() {
            scan_patterns.push(PatternConfig::new(
                (i, symbol.as_str()),
                "".into(),
                None,
                pattern.clone(),
            ))
        }
    }

    let mut matches: HashMap<&str, usize> = Default::default();
    let mut bad = HashSet::new();

    let games_vec = get_games([])?;
    for GameFileEntry { name, exe_path } in games_vec {
        println!("{:?} {:?}", name, exe_path.display());

        let bin_data = fs::read(&exe_path)?;

        let exe = match Image::builder().build(&bin_data) {
            Ok(exe) => exe,
            Err(err) => {
                println!("err reading {}: {}", exe_path.display(), err);
                continue;
            }
        };

        let scan = exe.scan(&scan_patterns)?;

        // group results by Sig
        let folded_scans = scan
            .results
            .iter()
            .map(|(config, m)| (&config.sig.1, (config.sig.0, m.address)))
            .fold(
                HashMap::new(),
                |mut map: HashMap<_, HashMap<usize, Vec<_>>>, (k, (i, v))| {
                    map.entry(k).or_default().entry(i).or_default().push(v);
                    map
                },
            );

        let mut to_remove = HashSet::new();

        for (symbol, results) in folded_scans {
            let mut any_match = false;
            for (pattern_index, addresses) in results {
                if addresses.len() > 1 {
                    let sig = (pattern_index, *symbol);
                    println!("\t{:?} matched multiple, removing", sig);
                    to_remove.insert(sig);
                    bad.insert(sig);
                } else {
                    println!("\t{:?}: {addresses:x?}", (pattern_index, symbol));
                    any_match = true;
                }
            }
            if any_match {
                *matches.entry(symbol).or_default() += 1;
            }
        }
        drop(scan);
        scan_patterns.retain(|p| !to_remove.contains(&p.sig));
    }

    let mut output: HashMap<_, Vec<_>> = Default::default();

    for (symbol, count) in matches.iter().sorted_by_key(|(_, v)| *v) {
        println!("{count}: {symbol}");
        for (index, pattern) in pattern_map.get(*symbol).unwrap().iter().enumerate() {
            if !bad.contains(&(index, *symbol)) {
                println!("\t{pattern}");
                output.entry(symbol).or_default().push(format!("{pattern}"));
            }
        }
    }

    std::fs::write("patterns.json", serde_json::to_string(&output)?)?;

    Ok(())
}

pub(crate) fn view(command: CommandViewSymbol) -> Result<()> {
    println!("symbols={:?}", command.symbol);
    let conn = Connection::open("data.db")?;

    struct Function {
        game: String,
        address: usize,
        data: Vec<u8>,
    }

    struct IndexedFunction {
        index: usize,
        function: Function,
    }

    let mut functions = vec![];
    for symbol in command.symbol {
        let mut stmt = conn.prepare("SELECT game, address, data FROM functions JOIN symbols USING(game, address) WHERE symbol = ?1")?;
        for row in stmt.query_map((&symbol,), |row| {
            Ok(Function {
                game: row.get(0)?,
                address: row.get(1)?,
                data: row.get(2)?,
            })
        })? {
            functions.push(row?)
        }
    }

    for function in command.function {
        let data = fs::read(&function.path)?;
        let img = Image::builder().build(&data).unwrap();
        functions.push(Function {
            game: function.path,
            address: function.start,
            data: img.memory[function.start..function.end].to_vec(),
        });
    }

    let resolvers = command
        .resolver
        .into_iter()
        .map(|res| res.getter)
        .collect::<Vec<_>>();

    if !resolvers.is_empty() {
        let mut games: HashSet<String> = Default::default();

        for game in crate::get_games([])? {
            #[allow(unused_assignments)]
            let mut bin_data = None;

            let GameFileEntry { name, exe_path } = game;

            bin_data = Some(fs::read(&exe_path)?);

            let exe = {
                let bin_data = bin_data.as_ref().unwrap();
                match Image::builder().functions(false).build(bin_data) {
                    Ok(exe) => exe,
                    Err(err) => {
                        println!("err reading {}: {err}", exe_path.display());
                        continue;
                    }
                }
            };

            games.insert(name.to_string());

            let resolution = exe.resolve_many(&resolvers);
            println!("{resolution:#x?}");
            for res in resolution.into_iter().flatten() {
                let start = res.get().unwrap();
                let bounds = patternsleuth::disassemble::function_range(&exe, start)?;
                functions.push(Function {
                    game: exe_path.to_string_lossy().to_string(),
                    address: start,
                    data: exe.memory[bounds].to_vec(),
                });
            }
        }
    }

    let mut functions = functions
        .into_iter()
        .enumerate()
        .map(|(index, function)| IndexedFunction { index, function })
        .collect::<Vec<_>>();

    fn count_unequal<T: PartialEq>(a: &[T], b: &[T]) -> usize {
        a.iter().zip(b).filter(|(a, b)| a != b).count() + a.len().abs_diff(b.len())
    }

    if !functions.is_empty() {
        /*
        let mut table = Table::new();
        table.add_row(Row::new(
            [Cell::new("")]
                .into_iter()
                .chain(
                    functions
                        .iter()
                        .enumerate()
                        .map(|(i, _)| Cell::new(&i.to_string())),
                )
                .collect(),
        ));
        */
        let max = 100;

        let mut distances = HashMap::new();
        for (
            a_i,
            IndexedFunction {
                function: Function { data: a, .. },
                ..
            },
        ) in functions.iter().enumerate()
        {
            //let mut cells = vec![Cell::new(&a_i.to_string())];
            for (
                b_i,
                IndexedFunction {
                    function: Function { data: b, .. },
                    ..
                },
            ) in functions.iter().enumerate()
            {
                let distance = count_unequal(&a[..a.len().min(max)], &b[..b.len().min(max)]);
                distances.insert((a_i, b_i), distance);
                distances.insert((b_i, a_i), distance);
                //cells.push(Cell::new(&distance.to_string()));
            }
            //table.add_row(Row::new(cells));
        }
        //table.printstd();

        let function_count = functions.len();

        let groups = if let Some(last) = functions.pop() {
            let mut groups = vec![vec![last]];
            while let Some(b) = functions.pop() {
                let (d, group) = groups
                    .iter_mut()
                    .map(|group| {
                        (
                            group
                                .iter()
                                .map(|a| distances.get(&(a.index, b.index)).unwrap())
                                .max()
                                .unwrap(),
                            group,
                        )
                    })
                    .min_by_key(|(d, _)| *d)
                    .unwrap();
                if *d < 50 {
                    group.push(b);
                } else {
                    groups.push(vec![b]);
                }
            }
            groups
        } else {
            vec![]
        };

        let mut patterns = vec![];

        println!(
            "{} total functions in {} group",
            function_count,
            groups.len()
        );

        for function in &functions {
            println!(
                "{:2} {:08X} {}",
                function.index, function.function.address, function.function.game
            );
        }

        for group in &groups {
            if let Some(pattern) = build_common_pattern(
                group
                    .iter()
                    .map(|f| &f.function.data[..f.function.data.len().min(max)])
                    .collect::<Vec<_>>(),
            ) {
                println!("{}", pattern);
                patterns.push(pattern);
                println!(
                    "{:#?}",
                    group
                        .iter()
                        .map(|f| &f.function.game)
                        .sorted()
                        .collect::<Vec<_>>()
                );
            }
        }

        println!("./run.sh scan --skip-exceptions --summary \\");
        for pattern in &patterns {
            println!("  -p '{}' \\", pattern);
        }

        for (group, pattern) in groups.iter().zip(patterns) {
            let mut table = Table::new();
            table.set_titles(group.iter().map(|f| &f.function.game).collect());
            table.add_row(Row::new(
                group
                    .iter()
                    .map(|f| {
                        Cell::new(&disassemble::disassemble_bytes_with_symbols(
                            f.function.address,
                            &f.function.data,
                            Some(&Pattern::new(&pattern).unwrap()),
                            |address| -> Option<String> {
                                command.show_symbols.then(||
                                conn
                                    .query_row_and_then(
                                        "SELECT symbol FROM symbols WHERE game = ?1 AND address = ?2",
                                        (&f.function.game, address),
                                        |row| row.get(0).optional(),
                                    )
                                    .ok()
                                    .flatten()).flatten()
                            }
                        ))
                    })
                    .collect(),
            ));
            table.printstd();
        }

        /*
        let mut table = Table::new();
        table.set_titles(cells.iter().map(|c| c.0.clone()).collect());
        table.add_row(Row::new(
            cells.into_iter().map(|c| Cell::new(&c.1)).collect(),
        ));
        table.printstd();
        */
    } else {
        println!("not found");
    }

    Ok(())
}

pub(crate) fn build(command: CommandBuildIndex) -> Result<()> {
    use crossbeam::channel::bounded;

    #[derive(Debug)]
    enum Insert {
        Function((String, usize, Vec<u8>)),
        Symbol {
            game: String,
            address: usize,
            symbol: String,
            demangled: String,
        },
        Xref((String, usize, usize, usize)),
    }

    let mut conn = Connection::open("data.db")?;

    conn.pragma_update(None, "synchronous", "OFF")?;
    conn.pragma_update(None, "journal_mode", "OFF")?;
    conn.pragma_update(None, "cache_size", "1000000")?;
    conn.pragma_update(None, "temp_store", "MEMORY")?;
    conn.pragma_update(None, "locking_mode", "EXCLUSIVE")?;

    conn.execute(
        "CREATE TABLE IF NOT EXISTS functions (
            game    TEXT NOT NULL,
            address INTEGER NOT NULL,
            data    BLOB NOT NULL
        )",
        (),
    )?;
    conn.execute(
        "CREATE TABLE IF NOT EXISTS symbols (
            game      TEXT NOT NULL,
            address   INTEGER NOT NULL,
            symbol    TEXT NOT NULL,
            demangled TEXT NOT NULL
        )",
        (),
    )?;
    conn.execute(
        "CREATE TABLE IF NOT EXISTS xrefs (
            game      TEXT NOT NULL,
            address_function    INTEGER NOT NULL,
            address_instruction INTEGER NOT NULL,
            address_reference   INTEGER NOT NULL
        )",
        (),
    )?;

    let (tx, rx) = bounded::<Insert>(0);

    let existing_games = {
        let mut stmt = conn.prepare("SELECT DISTINCT game FROM functions")?;
        #[warn(clippy::let_and_return)]
        let result = stmt
            .query_map((), |row| {
                Ok(std::path::PathBuf::from(row.get::<_, String>(0)?))
            })?
            .collect::<rusqlite::Result<HashSet<_>>>()?;
        result
    };

    crossbeam::scope(|scope| -> Result<()> {
        scope.spawn(|_| -> Result<()> {
            let transction = conn.transaction()?;
            while let Ok(msg) = rx.recv() {
                match msg {
                    Insert::Symbol{game, address, symbol, demangled} => {
                        let r = transction.execute(
                            "INSERT INTO symbols (game, address, symbol, demangled) VALUES (?1, ?2, ?3, ?4)",
                            (game, address, symbol, demangled),
                        );
                        if let Err(e) = r {
                            panic!("{:?}", e);
                        }
                    }
                    Insert::Function(i) => {
                        let r = transction.execute(
                            "INSERT INTO functions (game, address, data) VALUES (?1, ?2, ?3)",
                            i.clone(),
                        );
                        if let Err(e) = r {
                            panic!("{:?} {:?}", e, i);
                        }
                    }
                    Insert::Xref(i) => {
                        let r = transction.execute(
                            "INSERT INTO xrefs (game, address_function, address_instruction, address_reference) VALUES (?1, ?2, ?3, ?4)",
                            i.clone(),
                        );
                        if let Err(e) = r {
                            panic!("{:?} {:?}", e, i);
                        }
                    }
                }
            }
            transction.commit()?;
            Ok(())
        });

        let games_with_symbols = get_games(command.game)?
            .into_iter()
            .filter(|g| !existing_games.contains(&g.exe_path) && g.exe_path.with_extension("pdb").exists())
            .collect::<Vec<_>>();

        use indicatif::ParallelProgressIterator;
        use indicatif::ProgressIterator;

        let m = indicatif::MultiProgress::new();
        let sty = indicatif::ProgressStyle::with_template(
            "[{elapsed_precise}] {bar:40.cyan/blue} {pos:>7}/{len:7} {msg}",
        )
        .unwrap()
        .progress_chars("##-");

        let pb = m.add(indicatif::ProgressBar::new(games_with_symbols.len() as u64));
        pb.set_style(sty.clone());

        games_with_symbols
            .par_iter()
            .progress_with(pb.clone())
            .try_for_each(|GameFileEntry { name, exe_path }| -> Result<()> {
                pb.set_message("total");

                let bin_data = fs::read(exe_path)?;
                let exe = match Image::builder()
                    .functions(true)
                    .symbols(exe_path)
                    .build(&bin_data)
                {
                    Ok(exe) => exe,
                    Err(err) => {
                        println!("err reading {}: {}", exe_path.display(), err);
                        return Ok(());
                    }
                };

                let symbols = exe.symbols.as_ref().unwrap();

                let pb = m.add(indicatif::ProgressBar::new(symbols.len() as u64));
                pb.set_style(sty.clone());
                pb.set_message(format!("inserting symbols for {}", name));

                symbols.iter().progress_with(pb).try_for_each(
                    |(address, sym)| -> Result<()> {
                        tx.send(Insert::Symbol{
                            game: exe_path.to_string_lossy().to_string(),
                            address: *address,
                            symbol: sym.name.to_string(),
                            demangled: sym.demangle(),
                        })
                        .unwrap();

                        Ok(())
                    },
                )?;

                // collect root exceptions / functions
                let functions = exe.get_root_functions()?;

                let pb = m.add(indicatif::ProgressBar::new(functions.len() as u64));
                pb.set_style(sty.clone());
                pb.set_message(format!("inserting functions for {}", name));

                functions.iter().progress_with(pb).try_for_each(
                    |function| -> Result<()> {
                        let range = function;

                        let bytes = &exe.memory[range.clone()];

                        tx.send(Insert::Function((
                            exe_path.to_string_lossy().to_string(),
                            range.start,
                            bytes.into(),
                        )))
                        .unwrap();

                        for (inst, xref) in disassemble::get_xrefs(range.start, bytes) {
                            tx.send(Insert::Xref((
                                exe_path.to_string_lossy().to_string(),
                                range.start,
                                inst,
                                xref,
                            )))
                            .unwrap();
                        }

                        Ok(())
                    },
                )?;

                Ok(())
            })?;
        drop(tx);
        Ok(())
    })
    .unwrap()?;

    conn.execute(
        "CREATE INDEX IF NOT EXISTS functions_game_address_idx ON functions (game, address)",
        (),
    )?;
    conn.execute(
        "CREATE INDEX IF NOT EXISTS symbols_game_address_idx ON symbols (game, address)",
        (),
    )?;
    conn.execute(
        "CREATE INDEX IF NOT EXISTS symbols_symbol_game_address_idx ON symbols (symbol, game, address)",
        (),
    )?;
    conn.execute(
        "CREATE INDEX IF NOT EXISTS symbols_symbol_idx ON symbols (symbol)",
        (),
    )?;
    conn.execute(
        "CREATE INDEX IF NOT EXISTS xrefs_game_address_reference_idx ON xrefs (game, address_reference)",
        (),
    )?;

    Ok(())
}

fn build_common_pattern<B: AsRef<[u8]>>(function_bodies: impl AsRef<[B]>) -> Option<String> {
    let function_bodies = function_bodies.as_ref();
    if let Some(len) = function_bodies.iter().map(|b| b.as_ref().len()).min() {
        let mut sig = vec![];
        let mut mask = vec![];

        let mut last_eq = 0;

        for i in 0..len {
            if function_bodies.iter().map(|b| b.as_ref()[i]).all_equal() {
                sig.push(function_bodies[0].as_ref()[i]);
                mask.push(0xff);
                last_eq = i + 1;
            } else if i == 0 {
                // first byte cannot be wildcard
                return None;
            } else {
                sig.push(0);
                mask.push(0);
            }
        }
        sig.truncate(last_eq);
        mask.truncate(last_eq);

        Some(
            sig.iter()
                .zip(mask)
                .map(|(sig, mask)| match mask {
                    0xff => Cow::Owned(format!("{sig:02X?}")),
                    0 => "??".into(),
                    _ => unreachable!(),
                })
                .join(" "),
        )
    } else {
        None
    }
}

```

`patternsleuth_cli/src/disassemble.rs`:

```rs
use std::ops::Range;

use colored::{ColoredString, Colorize};
use iced_x86::{
    Decoder, DecoderOptions, Formatter, FormatterOutput, FormatterTextKind, IntelFormatter, OpKind,
};
use patternsleuth::{image::Image, scanner::Pattern, MemoryTrait};

#[derive(Default)]
struct Output {
    pub buffer: String,
}

impl FormatterOutput for Output {
    fn write(&mut self, text: &str, kind: FormatterTextKind) {
        #[allow(clippy::unnecessary_to_owned)]
        self.buffer.push_str(&get_color(text, kind).to_string());
    }
}

pub(crate) fn disassemble(exe: &Image, address: usize, pattern: Option<&Pattern>) -> String {
    let context = 20; // number of instructions before and after
    let max_inst = 16; // max size of x86 instruction in bytes

    let mut output = Output::default();

    if let Ok(section) = exe.memory.get_section_containing(address) {
        output.buffer.push_str(&format!(
            "{:016x}\n{:016x} - {:016x} = {}\n",
            address,
            section.address(),
            section.address() + section.data().len(),
            section.name(),
        ));

        let (is_fn, data, start_address) = if let Ok(Some(f)) = exe.get_root_function(address) {
            let fns = exe.get_child_functions(f.range.start).unwrap();
            let min = fns.iter().map(|f| f.range.start).min().unwrap();
            let max = fns.iter().map(|f| f.range.end).max().unwrap();
            let range = min..max;

            output.buffer.push_str(&format!(
                "{:016x} - {:016x} = function\n",
                range.start, range.end
            ));
            if let Some(symbols) = &exe.symbols {
                if let Some(symbol) = symbols.get(&range.start) {
                    #[allow(clippy::unnecessary_to_owned)]
                    output
                        .buffer
                        .push_str(&symbol.name.bright_yellow().to_string());
                    output.buffer.push_str(&"".normal().to_string());
                    output.buffer.push('\n');
                }
            }
            let start_address = range.start as u64;
            let data = section.range(range).unwrap();
            (true, data, start_address)
        } else {
            output.buffer.push_str("no function");

            let data = &section.data()[(address - context * max_inst)
                .saturating_sub(section.address())
                ..(address + context * max_inst).saturating_sub(section.address())];
            let start_address = (address - context * max_inst) as u64;
            (false, data, start_address)
        };

        output.buffer.push('\n');

        let mut decoder = Decoder::with_ip(64, data, start_address, DecoderOptions::NONE);

        let instructions = decoder.iter().collect::<Vec<_>>();
        let instructions = if let Some((middle, _)) = (!is_fn)
            .then(|| {
                instructions
                    .iter()
                    .enumerate()
                    .find(|(_, inst)| inst.ip() >= address as u64)
            })
            .flatten()
        {
            instructions
                .into_iter()
                .skip(middle - context)
                .take(context * 2 + 1)
                .collect::<Vec<_>>()
        } else {
            instructions
        };

        let mut formatter = IntelFormatter::new();
        formatter.options_mut().set_first_operand_char_index(8);
        for instruction in instructions {
            let ip = format!("{:016x}", instruction.ip());
            if (instruction.ip()..instruction.ip() + instruction.len() as u64)
                .contains(&(address as u64))
            {
                #[allow(clippy::unnecessary_to_owned)]
                output.buffer.push_str(&ip.reversed().to_string());
            } else {
                output.buffer.push_str(&ip);
            }
            output.buffer.push_str(":  ");

            let index = (instruction.ip() - start_address) as usize;
            for (i, b) in data[index..index + instruction.len()].iter().enumerate() {
                let highlight = pattern
                    .and_then(|p| -> Option<bool> {
                        let offset = (instruction.ip() as usize) - address + i + p.custom_offset;
                        Some(*p.simple.mask.get(offset)? != 0)
                    })
                    .unwrap_or_default();
                let s = format!("{:02x}", b);
                let mut colored = if highlight {
                    s.bright_white()
                } else {
                    s.bright_black()
                };
                if instruction
                    .ip()
                    .checked_add(i as u64)
                    .map(|a| a == address as u64)
                    .unwrap_or_default()
                {
                    colored = colored.reversed();
                }
                #[allow(clippy::unnecessary_to_owned)]
                output.buffer.push_str(&colored.to_string());
                output.buffer.push(' ');
            }

            for _ in 0..8usize.saturating_sub(instruction.len()) {
                output.buffer.push_str("   ");
            }

            formatter.format(&instruction, &mut output);
            output.buffer.push('\n');
        }
    } else {
        output
            .buffer
            .push_str(&format!("{:016x}\nno section", address));
    }
    output.buffer
}

pub(crate) fn disassemble_range(exe: &Image, range: Range<usize>) -> String {
    let address = range.start;
    let mut output = Output::default();

    if let Ok(section) = exe.memory.get_section_containing(address) {
        let data = &section.range(range).unwrap();

        output.buffer.push_str(&format!(
            "{:016x}\n{:016x} - {:016x} = {}\n",
            address,
            section.address(),
            section.address() + section.data().len(),
            section.name(),
        ));

        if let Ok(Some(f)) = exe.get_root_function(address) {
            output.buffer.push_str(&format!(
                "{:016x} - {:016x} = function\n",
                f.range.start, f.range.end
            ));
            if let Some(symbols) = &exe.symbols {
                if let Some(symbol) = symbols.get(&f.range.start) {
                    #[allow(clippy::unnecessary_to_owned)]
                    output
                        .buffer
                        .push_str(&format!("{}\n", symbol.name).bright_yellow().to_string());
                }
            }
        } else {
            output.buffer.push_str("no function");
        }

        output.buffer.push('\n');

        let mut decoder = Decoder::with_ip(64, data, address as u64, DecoderOptions::NONE);

        let instructions = decoder.iter().collect::<Vec<_>>();

        let mut formatter = IntelFormatter::new();
        formatter.options_mut().set_first_operand_char_index(8);
        for instruction in instructions {
            let ip = format!("{:016x}", instruction.ip());
            output.buffer.push_str(&ip);
            output.buffer.push_str(":  ");

            let index = instruction.ip() as usize - address;
            for b in data[index..index + instruction.len()].iter() {
                let s = format!("{:02x}", b);
                #[allow(clippy::unnecessary_to_owned)]
                output.buffer.push_str(&s.bright_white().to_string());
                output.buffer.push(' ');
            }

            for _ in 0..8usize.saturating_sub(instruction.len()) {
                output.buffer.push_str("   ");
            }

            formatter.format(&instruction, &mut output);
            output.buffer.push('\n');
        }
    } else {
        output
            .buffer
            .push_str(&format!("{:016x}\nno section", address));
    }
    output.buffer
}

pub(crate) fn disassemble_bytes_with_symbols<F>(
    address: usize,
    data: &[u8],
    pattern: Option<&Pattern>,
    symbols: F,
) -> String
where
    F: Fn(usize) -> Option<String>,
{
    let mut output = Output::default();

    output.buffer.push_str(&format!(
        "{:016x} - {:016x}\n",
        address,
        address + data.len()
    ));

    if let Some(symbol) = symbols(address) {
        #[allow(clippy::unnecessary_to_owned)]
        output
            .buffer
            .push_str(&format!("{}", symbol.bright_yellow().to_owned()));
    }

    output.buffer.push_str("\n\n");

    let mut formatter = IntelFormatter::new();
    formatter.options_mut().set_first_operand_char_index(8);
    for instruction in Decoder::with_ip(64, data, address as u64, DecoderOptions::NONE) {
        let ip = format!("{:016x}", instruction.ip());
        output.buffer.push_str(&ip);
        output.buffer.push_str(":  ");

        let index = instruction.ip() as usize - address;
        for (i, b) in data[index..index + instruction.len()].iter().enumerate() {
            let highlight = pattern
                .and_then(|p| -> Option<bool> {
                    let offset = (instruction.ip() as usize) - address + i + p.custom_offset;
                    Some(*p.simple.mask.get(offset)? != 0)
                })
                .unwrap_or_default();

            let s = format!("{:02x}", b);
            let mut colored = if highlight {
                s.bright_white()
            } else {
                s.bright_black()
            };

            if instruction
                .ip()
                .checked_add(i as u64)
                .map(|a| a == address as u64)
                .unwrap_or_default()
            {
                colored = colored.reversed();
            }
            #[allow(clippy::unnecessary_to_owned)]
            output.buffer.push_str(&colored.to_string());
            output.buffer.push(' ');
        }

        for _ in 0..8usize.saturating_sub(instruction.len()) {
            output.buffer.push_str("   ");
        }

        formatter.format(&instruction, &mut output);

        if instruction.op_kinds().any(|op| op == OpKind::NearBranch64) {
            if let Some(symbol) = symbols(instruction.near_branch64() as usize) {
                #[allow(clippy::unnecessary_to_owned)]
                output
                    .buffer
                    .push_str(&format!(" {}", symbol.bright_yellow().to_owned()));
            }
        }
        output.buffer.push('\n');
    }
    output.buffer
}

pub(crate) fn get_xrefs(address: usize, data: &[u8]) -> Vec<(usize, usize)> {
    let mut xrefs = vec![];
    for instruction in Decoder::with_ip(64, data, address as u64, DecoderOptions::NONE) {
        if instruction.op_kinds().any(|op| op == OpKind::NearBranch64) {
            xrefs.push((
                instruction.ip() as usize,
                instruction.near_branch64() as usize,
            ));
        }
    }
    xrefs
}

fn get_color(s: &str, kind: FormatterTextKind) -> ColoredString {
    match kind {
        FormatterTextKind::Directive | FormatterTextKind::Keyword => s.bright_yellow(),
        FormatterTextKind::Prefix | FormatterTextKind::Mnemonic => s.bright_red(),
        FormatterTextKind::Register => s.bright_blue(),
        FormatterTextKind::Number => s.bright_cyan(),
        _ => s.white(),
    }
}

```

`patternsleuth_cli/src/main.rs`:

```rs
mod db;
mod disassemble;

use std::borrow::Cow;
use std::collections::{BTreeMap, HashMap, HashSet};
use std::fs;
use std::path::{Path, PathBuf};
use std::str::FromStr;

use anyhow::{bail, Context, Result};
use clap::builder::{
    IntoResettable, PossibleValue, PossibleValuesParser, TypedValueParser, ValueParser,
};
use clap::Parser;
use indicatif::ProgressBar;
use itertools::Itertools;
use patricia_tree::StringPatriciaMap;
use patternsleuth::image::Image;
use patternsleuth::resolvers::{resolvers, NamedResolver};

use patternsleuth::scanner::Xref;
use patternsleuth::symbols::Symbol;
use patternsleuth::{scanner::Pattern, PatternConfig, Resolution};

#[derive(Parser)]
enum Commands {
    Scan(CommandScan),
    Report(CommandReport),
    DiffReport(CommandDiffReport),
    Symbols(CommandSymbols),
    BuildIndex(CommandBuildIndex),
    ViewSymbol(CommandViewSymbol),
    AutoGen(CommandAutoGen),
}

fn parse_maybe_hex(s: &str) -> Result<usize> {
    Ok(s.strip_prefix("0x")
        .map(|s| usize::from_str_radix(s, 16))
        .unwrap_or_else(|| s.parse())?)
}

fn resolver_parser() -> impl IntoResettable<ValueParser> {
    fn parse_resolver(s: &str) -> Result<&'static NamedResolver> {
        resolvers()
            .find(|res| s == res.name)
            .context("Resolver not found")
    }
    fn possible_resolvers() -> Vec<PossibleValue> {
        resolvers().map(|r| r.name.into()).collect()
    }
    PossibleValuesParser::new(possible_resolvers()).map(|v| parse_resolver(&v).unwrap())
}

#[derive(Parser)]
struct CommandScan {
    /// A game to scan (can be specified multiple times). Scans everything if omitted. Supports
    /// globs
    #[arg(short, long)]
    game: Vec<String>,

    /// A game process ID to attach to and scan
    #[arg(long)]
    pid: Option<i32>,

    /// A resolver to scan for (can be specified multiple times)
    #[arg(short, long, value_parser(resolver_parser()))]
    resolver: Vec<&'static NamedResolver>,

    /// Show disassembly context for each stage of every match (I recommend only using with
    /// aggressive filters)
    #[arg(short, long)]
    disassemble: bool,

    /// Show disassembly context for each matched address
    #[arg(long)]
    disassemble_merged: bool,

    /// A pattern to scan for (can be specified multiple times)
    #[arg(short, long, value_parser(|s: &_| Pattern::new(s)))]
    patterns: Vec<Pattern>,

    /// A path to a JSON pattern config file
    #[arg(long)]
    pattern_config: Option<PathBuf>,

    /// An xref to scan for (can be specified multiple times)
    #[arg(short, long, value_parser(|s: &str| parse_maybe_hex(s).map(Xref)))]
    xref: Vec<Xref>,

    /// Load and display symbols from PDBs when available (can be slow)
    #[arg(long)]
    symbols: bool,

    /// Skip parsing of exception table
    #[arg(long)]
    skip_exceptions: bool,

    /// Show scan summary
    #[arg(long)]
    summary: bool,

    /// Show scan progress
    #[arg(long)]
    progress: bool,
}

#[derive(Parser)]
struct CommandReport {
    /// A game to scan (can be specified multiple times). Scans everything if omitted. Supports
    /// globs
    #[arg(short, long)]
    game: Vec<String>,

    /// A resolver to scan for (can be specified multiple times)
    #[arg(short, long, value_parser(resolver_parser()))]
    resolver: Vec<&'static NamedResolver>,
}

#[derive(Parser)]
struct CommandDiffReport {
    /// Path to first report
    a: PathBuf,

    /// Path to second report
    b: PathBuf,
}

#[derive(Parser)]
struct CommandSymbols {
    /// A game to scan (can be specified multiple times). Scans everything if omitted. Supports
    /// globs
    #[arg(short, long)]
    game: Vec<String>,

    #[arg(short, long)]
    symbol: Vec<regex::Regex>,
}

#[derive(Parser)]
struct CommandBuildIndex {
    /// A game to scan (can be specified multiple times). Scans everything if omitted. Supports
    /// globs
    #[arg(short, long)]
    game: Vec<String>,
}

#[derive(Parser)]
struct CommandReadIndex {}

#[derive(Parser)]
struct CommandSearchIndex {
    #[arg()]
    symbol: String,
}

#[derive(Debug, Clone)]
struct FunctionSpec {
    path: String,
    start: usize,
    end: usize,
}
impl FromStr for FunctionSpec {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self> {
        let mut iter = s.split(':');
        if let (Some(path), Some(start), Some(end), None) =
            (iter.next(), iter.next(), iter.next(), iter.next())
        {
            Ok(FunctionSpec {
                path: path.to_owned(),
                start: parse_maybe_hex(start)?,
                end: parse_maybe_hex(end)?,
            })
        } else {
            bail!("failed to parse function definition: expected format <path.exe>:<start>:<end>")
        }
    }
}

#[derive(Parser)]
struct CommandViewSymbol {
    #[arg(short, long)]
    symbol: Vec<String>,

    #[arg(short, long)]
    function: Vec<FunctionSpec>,

    #[arg(short, long, value_parser(resolver_parser()))]
    resolver: Vec<&'static NamedResolver>,

    /// Whether to show symbols in function disassembly
    #[arg(long)]
    show_symbols: bool,
}

#[derive(Parser)]
struct CommandAutoGen {}

fn find_ext<P: AsRef<Path>, E: AsRef<str>>(dir: P, ext: &[E]) -> Result<Option<PathBuf>> {
    for f in fs::read_dir(dir)? {
        let f = f?.path();
        if f.is_file()
            && f.extension()
                .and_then(std::ffi::OsStr::to_str)
                .map(|e| ext.iter().any(|m| m.as_ref().eq_ignore_ascii_case(e)))
                .unwrap_or_default()
        {
            return Ok(Some(f));
        }
    }
    Ok(None)
}

fn main() -> Result<()> {
    use tracing_subscriber::{fmt, fmt::format::FmtSpan, EnvFilter};

    fmt()
        .compact()
        .with_level(true)
        .with_target(false)
        .with_span_events(FmtSpan::CLOSE)
        .with_env_filter(EnvFilter::builder().from_env_lossy())
        .init();

    match Commands::parse() {
        Commands::Scan(command) => scan(command),
        Commands::Report(command) => report(command),
        Commands::DiffReport(command) => diff_report(command),
        Commands::Symbols(command) => symbols(command),
        Commands::BuildIndex(command) => db::build(command),
        Commands::ViewSymbol(command) => db::view(command),
        Commands::AutoGen(command) => db::auto_gen(command),
    }
}

// TODO remove, only used for patterns/xrefs from CLI
#[derive(Debug, Clone, Eq, Hash, PartialEq)]
struct Sig(String);
impl std::fmt::Display for Sig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self, f)
    }
}

fn scan(command: CommandScan) -> Result<()> {
    let include_default = command.patterns.is_empty() && command.xref.is_empty();
    // TODO warn if empty?
    let patterns = command
        .patterns
        .into_iter()
        .enumerate()
        .map(|(i, p)| PatternConfig::new(Sig("arg".to_string()), format!("pattern {i}"), None, p))
        .chain(command.xref.into_iter().enumerate().map(|(i, p)| {
            PatternConfig::xref(Sig("arg".to_string()), format!("xref {i}"), None, p)
        }))
        .chain(command.pattern_config.into_iter().flat_map(|path| {
            let file = std::fs::read_to_string(path).unwrap();
            let config: HashMap<String, Vec<String>> = serde_json::from_str(&file).unwrap();

            config.into_iter().flat_map(|(symbol, patterns)| {
                patterns.into_iter().enumerate().map(move |(i, p)| {
                    PatternConfig::new(
                        Sig(format!("file {symbol}")),
                        format!("#{i} {symbol}"),
                        None,
                        Pattern::new(p).unwrap(),
                    )
                })
            })
        }))
        .collect_vec();

    let resolvers = if command.resolver.is_empty() && include_default {
        resolvers().collect::<Vec<_>>()
    } else {
        command.resolver
    };
    let dyn_resolvers = resolvers.iter().map(|res| res.getter).collect::<Vec<_>>();

    let sigs = patterns
        .iter()
        .map(|p| p.sig.clone())
        .collect::<HashSet<_>>();

    let mut games: HashSet<String> = Default::default();

    let mut all: HashMap<(String, (&Sig, &String)), Vec<Resolution>> = HashMap::new();
    let mut all_resolutions: HashMap<String, _> = Default::default();

    use colored::Colorize;
    use indicatif::ProgressIterator;
    use itertools::join;
    use prettytable::{format, row, Cell, Row, Table};

    enum Output {
        Stdout,
        Progress(ProgressBar),
    }

    impl Output {
        fn println<M: AsRef<str>>(&self, msg: M) {
            match self {
                Output::Stdout => println!("{}", msg.as_ref()),
                Output::Progress(progress) => progress.println(msg),
            }
        }
    }

    let mut games_vec = vec![];

    if let Some(pid) = command.pid {
        games_vec.push(GameEntry::Process(GameProcessEntry { pid }));
    } else {
        games_vec.extend(get_games(command.game)?.into_iter().map(GameEntry::File));
    }

    let (output, iter): (_, Box<dyn Iterator<Item = _>>) = if command.progress {
        let progress = ProgressBar::new(games_vec.len() as u64);
        (
            Output::Progress(progress.clone()),
            Box::new(games_vec.iter().progress_with(progress)),
        )
    } else {
        (Output::Stdout, Box::new(games_vec.iter()))
    };

    for game in iter {
        #[allow(unused_assignments)]
        let mut bin_data = None;

        let (name, exe) = match game {
            GameEntry::File(GameFileEntry { name, exe_path }) => {
                output.println(format!("{:?} {:?}", name, exe_path.display()));

                bin_data = Some(fs::read(exe_path)?);

                (Cow::Borrowed(name), {
                    let bin_data = bin_data.as_ref().unwrap();
                    let builder = Image::builder().functions(!command.skip_exceptions);
                    let exe = if command.symbols {
                        builder.symbols(exe_path).build(bin_data)
                    } else {
                        builder.build(bin_data)
                    };
                    match exe {
                        Ok(exe) => exe,
                        Err(err) => {
                            output.println(format!("err reading {}: {}", exe_path.display(), err));
                            continue;
                        }
                    }
                })
            }
            GameEntry::Process(GameProcessEntry { pid }) => {
                output.println(format!("PID={pid}"));

                (
                    Cow::Owned(format!("PID={pid}")),
                    patternsleuth::process::external::read_image_from_pid(*pid)?,
                )
            }
        };

        games.insert(name.to_string());

        let scan = exe.scan(&patterns)?;

        // group results by Sig
        let folded_scans = scan
            .results
            .iter()
            .map(|(config, m)| (&config.sig, (config, m)))
            .fold(HashMap::new(), |mut map: HashMap<_, Vec<_>>, (k, v)| {
                map.entry(k).or_default().push(v);
                map
            });

        let mut table = Table::new();
        table.set_titles(row!["sig", "offline scan"]);

        for sig in &sigs {
            let mut cells = vec![];
            cells.push(Cell::new(&sig.to_string()));

            if let Some(sig_scans) = folded_scans.get(&sig) {
                if command.disassemble {
                    let mut table = Table::new();
                    table.set_format(*format::consts::FORMAT_NO_BORDER);
                    for m in sig_scans.iter() {
                        let mut cells = vec![];
                        cells.push(Cell::new(&format!(
                            "{}\n{}",
                            m.0.name,
                            disassemble::disassemble(
                                &exe,
                                m.1.address,
                                m.0.scan.scan_type.get_pattern()
                            )
                        )));
                        table.add_row(Row::new(cells));
                    }
                    cells.push(Cell::new(&table.to_string()));
                } else if command.disassemble_merged {
                    cells.push(Cell::new({
                        let cells = sig_scans
                            .iter()
                            .fold(
                                HashMap::<&Resolution, HashMap<&str, usize>>::new(),
                                |mut map, m| {
                                    *map.entry(m.1).or_default().entry(&m.0.name).or_default() += 1;
                                    map
                                },
                            )
                            .iter()
                            // sort by pattern name, then match address
                            .sorted_by_key(|&data| data.0)
                            .map(|(m, counts)| {
                                let dis = disassemble::disassemble(&exe, m.address, None);

                                let mut lines = vec![];
                                for (name, count) in counts.iter().sorted_by_key(|e| e.0) {
                                    let count = if *count > 1 {
                                        format!(" (x{count})")
                                    } else {
                                        "".to_string()
                                    };

                                    lines.push(format!("{:?}{}", name, count).normal().to_string());
                                }
                                lines.push(dis);

                                Cell::new(&join(lines, "\n"))
                            })
                            .collect::<Vec<_>>();

                        let mut table = Table::new();
                        table.set_format(*format::consts::FORMAT_NO_BORDER);

                        table.add_row(Row::new(cells));

                        &table.to_string()
                    }));
                } else {
                    cells.push(Cell::new({
                        let mut lines = sig_scans
                            .iter()
                            // group and count matches by (pattern name, address)
                            .fold(
                                HashMap::<(&String, &Resolution), usize>::new(),
                                |mut map, m| {
                                    *map.entry((&m.0.name, m.1)).or_default() += 1;
                                    map
                                },
                            )
                            .iter()
                            // sort by pattern name, then match address
                            .sorted_by_key(|&data| data.0)
                            .map(|(m, count)| {
                                // add count indicator if more than 1
                                let count = if *count > 1 {
                                    format!(" (x{count})")
                                } else {
                                    "".to_string()
                                };

                                (
                                    format!("{:016x} {:?}{}", m.1.address, m.0, count)
                                        .normal()
                                        .to_string(),
                                    exe.symbols
                                        .as_ref()
                                        .and_then(|symbols| symbols.get(&m.1.address)),
                                )
                            })
                            .collect::<Vec<_>>();
                        let max_len = lines.iter().map(|(line, _)| line.len()).max();
                        for (line, symbol) in &mut lines {
                            if let Some(symbol) = symbol {
                                line.push_str(&format!(
                                    "{}{}",
                                    " ".repeat(1 + max_len.unwrap() - line.len()),
                                    symbol.name.bright_yellow()
                                ));
                            }
                        }
                        &join(lines.iter().map(|(line, _)| line), "\n").to_string()
                    }));
                }
            } else {
                #[allow(clippy::unnecessary_to_owned)]
                cells.push(Cell::new(&"not found".red().to_string()));
            }

            table.add_row(Row::new(cells));
        }

        let game_name = match game {
            GameEntry::File(GameFileEntry { name, .. }) => name.clone(),
            GameEntry::Process(GameProcessEntry { pid }) => format!("pid={pid}"),
        };

        let resolution = tracing::info_span!("scan", game = game_name)
            .in_scope(|| exe.resolve_many(&dyn_resolvers));

        for (resolver, resolution) in resolvers.iter().zip(&resolution) {
            table.add_row(Row::new(
                [
                    Cell::new(resolver.name),
                    match resolution {
                        Ok(res) => Cell::new(&format!("{:#x?}", res)),
                        Err(err) =>
                        {
                            #[allow(clippy::unnecessary_to_owned)]
                            Cell::new(&format!("{:x?}", err).red().to_string())
                        }
                    },
                ]
                .to_vec(),
            ));
        }

        if !resolution.is_empty() {
            all_resolutions.insert(name.to_string(), resolution);
        }

        output.println(table.to_string());

        // fold current game scans into summary scans
        scan.results.into_iter().fold(&mut all, |map, m| {
            map.entry((name.to_string(), (&m.0.sig, &m.0.name)))
                .or_default()
                .push(m.1);
            map
        });
    }

    // force any progress output to be dropped
    let output = Output::Stdout;

    if command.summary {
        #[derive(Debug, Default)]
        struct Summary {
            matches: usize,
        }
        impl Summary {
            fn format(&self) -> String {
                if self.matches == 0 {
                    "none".to_owned()
                } else {
                    format!("M={}", self.matches)
                }
            }
        }

        let mut summary = Table::new();
        let title_strs: Vec<String> = ["".into(), "unqiue addresses".into()]
            .into_iter()
            .chain(
                patterns
                    .iter()
                    .map(|conf| format!("{:?}({})", conf.sig, conf.name)),
            )
            .chain(resolvers.iter().map(|r| r.name.to_string()))
            .collect();
        summary.set_titles(Row::new(title_strs.iter().map(|s| Cell::new(s)).collect()));
        let mut totals = patterns.iter().map(|_| Summary::default()).collect_vec();

        let mut no_matches = 0;
        let mut one_match = 0;
        let mut gt_one_match = 0;

        for game in games.iter().sorted() {
            let mut row = vec![Cell::new(game)];

            let mut matched_addresses = HashSet::new();

            let summaries: Vec<Summary> = patterns
                .iter()
                .map(|conf| {
                    let res = all.get(&(game.to_string(), (&conf.sig, &conf.name)));
                    if let Some(res) = res {
                        for res in res {
                            matched_addresses.insert(res.address);
                        }
                        Summary { matches: res.len() }
                    } else {
                        Summary { matches: 0 }
                    }
                })
                .collect();

            for (i, s) in summaries.iter().enumerate() {
                if s.matches > 0 {
                    totals[i].matches += 1;
                }
            }

            match matched_addresses.len() {
                0 => {
                    no_matches += 1;
                }
                1 => {
                    one_match += 1;
                }
                _ => {
                    gt_one_match += 1;
                }
            }

            row.push(Cell::new(&format!("unique={}", matched_addresses.len())));

            let cell_strs: Vec<String> = summaries.iter().map(Summary::format).collect();
            row.extend(cell_strs.iter().map(|s| Cell::new(s)));

            if let Some(res) = all_resolutions.get(game) {
                for res in res {
                    match res {
                        Ok(res) => row.push(Cell::new(&format!("{:x?}", res))),
                        Err(err) => {
                            #[allow(clippy::unnecessary_to_owned)]
                            row.push(Cell::new(&format!("{:x?}", err).red().to_string()));
                        }
                    }
                }
            }

            summary.add_row(Row::new(row));
        }

        let total_strs = [
            format!("total={}", games.len()),
            format!("0={} 1={} >1={}", no_matches, one_match, gt_one_match),
        ]
        .into_iter()
        .chain(totals.iter().map(Summary::format))
        .chain(resolvers.iter().enumerate().map(|(i, _)| {
            let ok = all_resolutions.values().filter(|r| r[i].is_ok()).count();
            format!(
                "Ok={ok}/{} ({:.2}%)",
                games.len(),
                100. * ok as f64 / games.len() as f64
            )
        }))
        .collect_vec();
        summary.add_row(Row::new(
            total_strs.iter().map(|s| Cell::new(s)).collect_vec(),
        ));

        //let games: HashSet<String> = all.keys().map(|(game, _)| game).cloned().collect();
        //println!("{:#?}", all);

        output.println(summary.to_string());
    }

    Ok(())
}

fn report(command: CommandReport) -> Result<()> {
    use rayon::prelude::*;

    fn load_game(path: impl AsRef<Path>, data: &mut Vec<u8>) -> Result<Image<'_>> {
        use std::io::Read;
        data.clear();
        fs::File::open(path)?.read_to_end(data)?;
        Image::builder().build(data)
    }

    let resolvers = command
        .resolver
        .iter()
        .map(|res| res.getter)
        .collect::<Vec<_>>();

    let time = time::OffsetDateTime::now_local()?.format(time::macros::format_description!(
        "[year]-[month]-[day]_[hour]-[minute]-[second]"
    ))?;

    let games = get_games(command.game)?;

    let results = std::sync::Arc::new(std::sync::Mutex::new(BTreeMap::new()));

    let progress = ProgressBar::new(games.len() as u64);
    games.into_par_iter().try_for_each(|game| -> Result<()> {
        progress.println(format!("{:?} {:?}", game.name, game.exe_path.display()));

        let mut data = vec![];
        let exe = match load_game(&game.exe_path, &mut data) {
            Ok(exe) => exe,
            Err(err) => {
                progress.println(format!("err reading {}: {}", game.exe_path.display(), err));
                progress.inc(1);
                return Ok(());
            }
        };

        let resolution = exe.resolve_many(&resolvers);

        let map = command
            .resolver
            .iter()
            .zip(resolution)
            .map(|(resolver, resolution)| (resolver.name, resolution))
            .collect::<BTreeMap<_, _>>();
        results.lock().unwrap().insert(game.name, map);

        progress.inc(1);

        Ok(())
    })?;

    fs::create_dir_all("reports")?;
    fs::write(
        format!(
            "reports/{}{}{}.json",
            time,
            option_env!("GIT_HASH")
                .map(|hash| format!("-{}", &hash[..10]))
                .unwrap_or_default(),
            option_env!("GIT_DIRTY")
                .map(|_| "-dirty")
                .unwrap_or_default(),
        ),
        serde_json::to_vec(
            &std::sync::Arc::try_unwrap(results)
                .unwrap()
                .into_inner()
                .unwrap(),
        )
        .unwrap(),
    )?;

    Ok(())
}
fn diff_report(command: CommandDiffReport) -> Result<()> {
    use colored::Colorize;
    use patternsleuth::resolvers::{Resolution, ResolveError};
    use prettytable::{Cell, Row, Table};
    type Report = BTreeMap<String, BTreeMap<String, Result<Box<dyn Resolution>, ResolveError>>>;

    let a: Report = serde_json::from_slice(&fs::read(command.a)?)?;
    let b: Report = serde_json::from_slice(&fs::read(command.b)?)?;

    let mut games_only_in_a = vec![];
    let mut games_only_in_b = vec![];

    type Res<'r> = Result<&'r Box<dyn Resolution + 'static>, &'r ResolveError>;
    let mut diffs: BTreeMap<&str, BTreeMap<&str, (Res, Res)>> = Default::default();

    for game in a.keys().chain(b.keys()).unique() {
        let game_a = a.get(game);
        let game_b = b.get(game);
        if game_a.is_none() {
            games_only_in_b.push(game);
        }
        if game_b.is_none() {
            games_only_in_a.push(game);
        }
        if let (Some(game_a), Some(game_b)) = (game_a, game_b) {
            for res in game_a.keys().chain(game_b.keys()).unique() {
                if let (Some(res_a), Some(res_b)) = (game_a.get(res), game_b.get(res)) {
                    diffs
                        .entry(res)
                        .or_default()
                        .insert(game, (res_a.as_ref(), res_b.as_ref()));
                } else {
                    // TODO warn if mismatched set of resolvers
                }
            }
        }
    }

    dbg!(games_only_in_a);
    dbg!(games_only_in_b);

    fn local<I, O, F: FnOnce(I) -> O>(i: I, f: F) -> O {
        f(i)
    }

    fn format_res(res: Result<&dyn Resolution, &ResolveError>) -> String {
        local(format!("{:x?}", res).bold(), |s| match res {
            Ok(_) => s,
            Err(_) => s.red(),
        })
        .to_string()
    }

    fn format_percent_diff(percent_diff: f32) -> String {
        local(
            format!("{:+.2?}%", percent_diff).bold(),
            |s| match percent_diff {
                f if f < 0. => s.red(),
                f if f > 0. => s.green(),
                _ => s,
            },
        )
        .to_string()
    }

    struct ResEntry {
        ok_diff: usize,
        percent_a: f32,
        percent_b: f32,
        percent_diff: f32,
    }

    let mut results = vec![];

    for (res, entries) in diffs {
        let mut table = Table::new();

        let total = entries.len();
        let ok_a = entries.values().filter(|res| res.0.is_ok()).count();
        let ok_b = entries.values().filter(|res| res.1.is_ok()).count();
        let diff = entries
            .iter()
            .filter(|(_, (a, b))| a.ok() != b.ok())
            .collect::<Vec<_>>();
        let ok_diff = diff
            .iter()
            .filter(|(_, pair)| matches!(pair, (Ok(a), Ok(b)) if a != b))
            .count();

        let percent_a = ok_a as f32 / total as f32 * 100.;
        let percent_b = ok_b as f32 / total as f32 * 100.;
        let percent_diff = percent_b - percent_a;

        results.push((
            res,
            ResEntry {
                ok_diff,
                percent_a,
                percent_b,
                percent_diff,
            },
        ));

        if diff.is_empty() {
            continue;
        }

        let score = format_percent_diff(percent_diff);
        let changed = if ok_diff == 0 {
            "".to_string()
        } else {
            format!("{ok_diff} changed").yellow().bold().to_string()
        };
        let title = format!(
            "{res} - {ok_a}/{total} ({percent_a:.2}%) => {ok_b}/{total} ({percent_b:.2}%): {score} {changed}"
        );
        table.set_titles(Row::new(vec![Cell::new(&title).with_hspan(3)]));

        for (game, (res_a, res_b)) in diff {
            table.add_row(Row::new(vec![
                Cell::new(game),
                Cell::new(&format_res(res_a.map(|ok| ok.as_ref()))),
                Cell::new(&format_res(res_b.map(|ok| ok.as_ref()))),
            ]));
        }

        table.printstd();
    }

    let mut table = Table::new();
    table.set_titles(Row::new(vec![
        Cell::new("resolver"),
        Cell::new("a"),
        Cell::new("b"),
        Cell::new("increase"),
        Cell::new("changed"),
    ]));
    for (res, entry) in results {
        table.add_row(Row::new(vec![
            Cell::new(res),
            Cell::new(&format!("{:.2}%", entry.percent_a)),
            Cell::new(&format!("{:.2}%", entry.percent_b)),
            Cell::new(&format_percent_diff(entry.percent_diff)),
            Cell::new(
                &local(format!("{}", entry.ok_diff), |s| match entry.ok_diff {
                    0 => s.normal(),
                    _ => s.yellow().bold(),
                })
                .to_string(),
            ),
        ]));
    }
    table.printstd();

    Ok(())
}

fn symbols(command: CommandSymbols) -> Result<()> {
    let re = &command.symbol;
    let filter = |sym: &Symbol| re.iter().any(|re| re.is_match(&sym.name));

    use prettytable::{Cell, Row, Table};

    let mut cells = vec![];

    for GameFileEntry { name, exe_path } in get_games(command.game)? {
        if !exe_path.with_extension("pdb").exists() && !exe_path.with_extension("sym").exists() {
            continue;
        }

        println!("{:?} {:?}", name, exe_path.display());
        let bin_data = fs::read(&exe_path)?;
        let exe = match Image::builder()
            .functions(true)
            .symbols(&exe_path)
            .build(&bin_data)
        {
            Ok(exe) => exe,
            Err(err) => {
                println!("err reading {}: {}", exe_path.display(), err);
                continue;
            }
        };

        for (address, sym) in exe.symbols.as_ref().unwrap() {
            if filter(sym) {
                if let Ok(Some(full_range)) = exe.get_root_function_range(*address) {
                    cells.push((
                        sym.clone(),
                        disassemble::disassemble_range(&exe, full_range),
                    ));
                } else {
                    println!("{:016x} [NO EXCEPT] {}", address, sym.name);
                }
            }
        }
    }

    let mut table = Table::new();
    table.set_titles(cells.iter().map(|c| c.0.name.clone()).collect());
    table.add_row(Row::new(
        cells.into_iter().map(|c| Cell::new(&c.1)).collect(),
    ));
    table.printstd();

    Ok(())
}

enum GameEntry {
    File(GameFileEntry),
    Process(GameProcessEntry),
}

struct GameFileEntry {
    name: String,
    exe_path: PathBuf,
}

struct GameProcessEntry {
    pid: i32,
}

fn get_games(filter: impl AsRef<[String]>) -> Result<Vec<GameFileEntry>> {
    let games_filter = filter
        .as_ref()
        .iter()
        .map(|g| {
            Ok(globset::GlobBuilder::new(g)
                .case_insensitive(true)
                .build()?
                .compile_matcher())
        })
        .collect::<Result<Vec<_>>>()?;
    //eprintln!("{}", std::env::current_dir().unwrap().to_str().unwrap());
    fs::read_dir("games")?
        .collect::<Result<Vec<_>, _>>()?
        .iter()
        .map(|entry| -> Result<Option<(String, PathBuf)>> {
            //eprintln!("FSOK!");
            let dir_name = entry.file_name();
            let name = dir_name.to_string_lossy().to_string();
            if !games_filter
                .is_empty()
                .then_some(true)
                .unwrap_or_else(|| games_filter.iter().any(|g| g.is_match(&name)))
            {
                return Ok(None);
            }

            let Some(exe_path) = find_ext(entry.path(), &["exe", "elf"])
                .transpose()
                .transpose()?
            else {
                return Ok(None);
            };
            Ok(Some((name, exe_path)))
        })
        .filter_map(|r| r.transpose())
        .collect::<Result<Vec<(String, _)>>>()
        .map(|entries| {
            sample_order(entries, 3)
                .into_iter()
                .map(|(name, exe_path)| GameFileEntry { name, exe_path })
                .collect::<Vec<GameFileEntry>>()
        })
}

/// Distribute pairs such that unique prefixes are encountered early
/// e.g.
/// 7_a 8_a 9_a 7_b 7_c 7_d 8_b 8_c 9_b
fn sample_order<V>(entries: Vec<(String, V)>, prefix_size: usize) -> Vec<(String, V)> {
    let mut trie = StringPatriciaMap::from_iter(entries);
    let mut len = 1;
    let mut result = vec![];
    while !trie.is_empty() {
        let mut prefixes = HashSet::new();
        for (k, _v) in trie.iter() {
            if k.chars().count() >= len {
                prefixes.insert(k.chars().take(len).collect::<String>());
            }
        }
        for p in prefixes.iter().sorted() {
            let take = trie
                .iter_prefix(p)
                .take(prefix_size)
                .map(|(k, _v)| k)
                .collect_vec();
            for k in take {
                let v = trie.remove(k.clone()).unwrap();
                result.push((k, v));
            }
        }
        len += 1;
    }
    result
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_sample_cont() {
        let entries = ["aa", "ba", "ca", "ab", "ac", "bc"]
            .iter()
            .map(|k| (k.to_string(), ()))
            .collect_vec();
        let ordered = sample_order(entries.clone(), 1);
        assert_eq!(entries, ordered);
    }
}

```

`patternsleuth_scanner/Cargo.toml`:

```toml
[package]
name = "patternsleuth_scanner"
repository.workspace = true
authors.workspace = true
license.workspace = true
version.workspace = true
edition.workspace = true

[[bench]]
name = "scan"
harness = false

[dependencies]
rayon = { workspace = true }
memchr = { workspace = true }
anyhow = { workspace = true }

[dev-dependencies]
criterion = { version = "0.5.1", features = ["html_reports"] }
rand = "0.8.5"
object = { workspace = true }

```

`patternsleuth_scanner/benches/scan.rs`:

```rs
use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};
use patternsleuth_scanner::*;

fn gig(c: &mut Criterion) {
    use rand::prelude::*;
    let size = 1024 * 1024 * 1024;
    let mut data: Vec<u8> = Vec::with_capacity(size);
    let mut rng = rand::thread_rng();

    let needle = b"\xf9\x82\xdb\xdb\x2d\x32\x6f\x15\x11\x44\x54\xf4\xc8\xaa\xd1\x72\x53\x96\xa5\x7b\x22\x24\x94\x7f\xec\x28\xc7\xe0\x5e\xd4\xae\x39";

    data.extend((0..size - needle.len()).map(|_| rng.gen::<u8>()));
    data.extend(needle);

    let pattern = Pattern::new("f9 82 db db 2d ?? 6f 15 ?? 44 54 f4 c8 aa d1 72 53 ?? a5 7b 22 24 94 7f ec 28 ?? e0 5e d4 ae 39").unwrap();

    let result = scan_pattern(&[&pattern], 0, &data);
    assert_eq!(result, vec![vec![size - needle.len()]]);

    c.bench_function("gig scan", |b| {
        b.iter(|| scan_pattern(&[&pattern], 0, &data))
    });
}

fn gig_multi(c: &mut Criterion) {
    let patterns = [
        "48 8D ?? X0x144F64F58",
        "4C 8D ?? X0x144F64F58",
        "B8 58 4F F6 44",
        "B9 58 4F F6 44",
        "BA 58 4F F6 44",
        "BB 58 4F F6 44",
        "BC 58 4F F6 44",
        "BD 58 4F F6 44",
        "BE 58 4F F6 44",
        "BF 58 4F F6 44",
        "48 8D ?? X0x1446245D8",
        "4C 8D ?? X0x1446245D8",
        "48 8D ?? X0x1446245DA",
        "4C 8D ?? X0x1446245DA",
        "48 8D ?? X0x1446D27D8",
        "4C 8D ?? X0x1446D27D8",
        "48 8D ?? X0x1446D27DA",
        "4C 8D ?? X0x1446D27DA",
        "48 8D ?? X0x1446340B8",
        "4C 8D ?? X0x1446340B8",
        "48 8D ?? X0x1446340BA",
        "4C 8D ?? X0x1446340BA",
        "48 8D ?? X0x144F92190",
        "4C 8D ?? X0x144F92190",
        "B8 90 21 F9 44",
        "B9 90 21 F9 44",
        "BA 90 21 F9 44",
        "BB 90 21 F9 44",
        "BC 90 21 F9 44",
        "BD 90 21 F9 44",
        "BE 90 21 F9 44",
        "BF 90 21 F9 44",
        "48 8D ?? X0x144F922C0",
        "4C 8D ?? X0x144F922C0",
        "B8 C0 22 F9 44",
        "B9 C0 22 F9 44",
        "BA C0 22 F9 44",
        "BB C0 22 F9 44",
        "BC C0 22 F9 44",
        "BD C0 22 F9 44",
        "BE C0 22 F9 44",
        "BF C0 22 F9 44",
    ]
    .iter()
    .map(|p| Pattern::new(p).unwrap())
    .collect::<Vec<_>>();
    let pattern_refs: Vec<_> = patterns.iter().collect();

    let base_address = 0x146d73000;
    let data = std::fs::read("../impdata.bin").unwrap();

    c.bench_function("gig scan multi", |b| {
        b.iter(|| scan_pattern(&pattern_refs, base_address, &data))
    });
}

fn xref(c: &mut Criterion) {
    use object::Object;
    use object::ObjectSection;

    let bin_data = std::fs::read("../games/FSD/FSD-Win64-Shipping.exe").unwrap();
    let obj_file = object::File::parse(&*bin_data).unwrap();
    let section = obj_file.section_by_name(".text").unwrap();
    let base_address = section.address() as usize;
    let data = section.data().unwrap();

    let raw_patterns = [
        Xref(0x146CAC280),
        Xref(0x146CAC288),
        Xref(0x141DBABA0),
        Xref(0x1450BB188),
        Xref(0x1450BB1A8),
        Xref(0x1450BB378),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
        Xref(0x146CAC280),
        Xref(0x146CAC288),
        Xref(0x141DBABA0),
        Xref(0x1450BB188),
        Xref(0x1450BB1A8),
        Xref(0x1450BB378),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
        Xref(0x146CAC280),
        Xref(0x146CAC288),
        Xref(0x141DBABA0),
        Xref(0x1450BB188),
        Xref(0x1450BB1A8),
        Xref(0x1450BB378),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
        Xref(0x146CAC280),
        Xref(0x146CAC288),
        Xref(0x141DBABA0),
        Xref(0x1450BB188),
        Xref(0x1450BB1A8),
        Xref(0x1450BB378),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
        Xref(0x146CAC280),
        Xref(0x146CAC288),
        Xref(0x141DBABA0),
        Xref(0x1450BB188),
        Xref(0x1450BB1A8),
        Xref(0x1450BB378),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
        Xref(0x146CAC280),
        Xref(0x146CAC288),
        Xref(0x141DBABA0),
        Xref(0x1450BB188),
        Xref(0x1450BB1A8),
        Xref(0x1450BB378),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
        Xref(0x146CAC280),
        Xref(0x146CAC288),
        Xref(0x141DBABA0),
        Xref(0x1450BB188),
        Xref(0x1450BB1A8),
        Xref(0x1450BB378),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
        Xref(0x146CAC280),
        Xref(0x146CAC288),
        Xref(0x141DBABA0),
        Xref(0x1450BB188),
        Xref(0x1450BB1A8),
        Xref(0x1450BB378),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
        Xref(0x146CAC280),
        Xref(0x146CAC288),
        Xref(0x141DBABA0),
        Xref(0x1450BB188),
        Xref(0x1450BB1A8),
        Xref(0x1450BB378),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
        Xref(0x146CAC280),
        Xref(0x146CAC288),
        Xref(0x141DBABA0),
        Xref(0x1450BB188),
        Xref(0x1450BB1A8),
        Xref(0x1450BB378),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
        Xref(0x146CAC280),
        Xref(0x146CAC288),
        Xref(0x141DBABA0),
        Xref(0x1450BB188),
        Xref(0x1450BB1A8),
        Xref(0x1450BB378),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
        Xref(0x146CAC280),
        Xref(0x146CAC288),
        Xref(0x141DBABA0),
        Xref(0x1450BB188),
        Xref(0x1450BB1A8),
        Xref(0x1450BB378),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
        Xref(0x1450BB398),
        Xref(0x144F4DA28),
        Xref(0x144F4DA40),
        Xref(0x144F4D6D8),
    ];

    let id_patterns = raw_patterns.iter().collect::<Vec<_>>();

    let mut group = c.benchmark_group("xref");

    let t = 5;
    for f in 0..t {
        let size = (raw_patterns.len() as f64 * f as f64 / t as f64).round() as usize;
        let p = &id_patterns[0..size];
        group.bench_with_input(BenchmarkId::new("xref", size), &size, |b, _size| {
            b.iter(|| scan_xref(p, base_address, data))
        });
    }

    group.finish();
}

criterion_group! {
    name = bench1;
    config = Criterion::default().sample_size(30);
    targets = gig
}
criterion_group! {
    name = bench3;
    config = Criterion::default().sample_size(30);
    targets = gig_multi
}
criterion_group!(bench2, xref);

criterion_main!(bench1, bench2, bench3);

```

`patternsleuth_scanner/src/lib.rs`:

```rs
use anyhow::{bail, Context, Error, Result};

#[derive(Clone, Eq, PartialEq)]
pub struct PatternSimple {
    pub sig: Vec<u8>,
    pub mask: Vec<u8>,
}
impl PatternSimple {
    #[inline(always)]
    pub fn is_match(&self, data: &[u8], index: usize) -> bool {
        for i in 0..self.len() {
            if data[index + i] & self.mask[i] != self.sig[i] {
                return false;
            }
        }
        true
    }
    #[allow(clippy::len_without_is_empty)]
    pub fn len(&self) -> usize {
        self.sig.len()
    }
    pub fn iter(&self) -> std::iter::Zip<std::slice::Iter<u8>, std::slice::Iter<u8>> {
        self.sig.iter().zip(&self.mask)
    }
}

fn fmt_byte(f: &mut std::fmt::Formatter<'_>, sig: u8, mask: u8) -> std::fmt::Result {
    if mask == 0 {
        write!(f, "??")?;
    } else if mask == 0xff {
        write!(f, "{:02X}", sig)?;
    } else if mask == 0x0f {
        write!(f, "?{:X}", sig & 0xf)?;
    } else if mask == 0xf0 {
        write!(f, "{:X}?", sig >> 4)?;
    } else {
        for bit in (0..8).rev() {
            if mask >> bit & 1 == 1 {
                write!(f, "{}", sig >> bit & 1)?;
            } else {
                write!(f, "?")?;
            }
        }
    }
    Ok(())
}

impl Display for PatternSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:02X}", self.sig[0])?;
        for (sig, mask) in self.iter().skip(1) {
            write!(f, " ")?;
            fmt_byte(f, *sig, *mask)?;
        }
        Ok(())
    }
}
impl std::fmt::Debug for PatternSimple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PatternSimple(\"{self}\")")
    }
}

#[derive(Clone, Eq, PartialEq)]
pub struct Pattern {
    pub simple: PatternSimple,
    pub custom_offset: usize,
    pub captures: Vec<std::ops::Range<usize>>,
    pub xrefs: Vec<(usize, Xref)>,
}

#[derive(Debug, Eq, PartialEq)]
pub struct Capture<'data> {
    pub address: usize,
    pub data: &'data [u8],
}

impl TryFrom<String> for Pattern {
    type Error = Error;
    fn try_from(string: String) -> Result<Self, <Self as TryFrom<String>>::Error> {
        Self::new(string)
    }
}
impl TryFrom<&str> for Pattern {
    type Error = Error;
    fn try_from(string: &str) -> Result<Self, <Self as TryFrom<&str>>::Error> {
        Self::new(string)
    }
}

impl Pattern {
    fn parse_binary_patern(s: &str) -> Option<(u8, u8)> {
        if s.len() == 8 {
            let mut sig = 0;
            let mut mask = 0;
            for (i, b) in s.chars().enumerate() {
                let i = 7 - i;
                match b {
                    '0' => {
                        mask |= 1 << i;
                    }
                    '1' => {
                        sig |= 1 << i;
                        mask |= 1 << i;
                    }
                    '?' => {}
                    _ => return None,
                }
            }
            Some((sig, mask))
        } else {
            None
        }
    }

    fn parse_hex_pattern(s: &str) -> Option<(u8, u8)> {
        if s.len() == 2 {
            let mut sig = 0;
            let mut mask = 0;
            for (i, b) in s.chars().enumerate() {
                let i = (1 - i) * 4;
                if let Some(digit) = b.to_digit(16) {
                    sig |= (digit as u8) << i;
                    mask |= 0xf << i;
                } else if b != '?' {
                    return None;
                }
            }
            Some((sig, mask))
        } else {
            None
        }
    }

    fn parse_maybe_hex(s: &str) -> Result<usize> {
        Ok(s.strip_prefix("0x")
            .map(|s| usize::from_str_radix(s, 16))
            .unwrap_or_else(|| s.parse())?)
    }

    fn parse_maybe_hex_u32(s: &str) -> Result<u32> {
        Ok(s.strip_prefix("0x")
            .map(|s| u32::from_str_radix(s, 16))
            .unwrap_or_else(|| s.parse())?)
    }

    pub fn new<S: AsRef<str>>(s: S) -> Result<Self> {
        let mut sig = vec![];
        let mut mask = vec![];
        let mut custom_offset = 0;

        let mut capture_stack = vec![];
        let mut captures = vec![];
        let mut xrefs = vec![];

        let mut i = 0;
        for w in s.as_ref().split_whitespace() {
            if let Some((s, m)) =
                Self::parse_hex_pattern(w).or_else(|| Self::parse_binary_patern(w))
            {
                sig.push(s);
                mask.push(m);
                i += 1;
            } else {
                match w {
                    "|" => {
                        custom_offset = i;
                    }
                    "[" => {
                        capture_stack.push(i);
                    }
                    "]" => {
                        if let Some(start) = capture_stack.pop() {
                            captures.push(start..i);
                        } else {
                            bail!("unexpected closing capture at word {i}");
                        }
                    }
                    _ => {
                        if let Some(xref) = w.strip_prefix('X').map(Self::parse_maybe_hex) {
                            let xref =
                                Xref(xref.with_context(|| format!("failed to parse xref {w}"))?);
                            xrefs.push((sig.len(), xref));
                            for _ in 0..4 {
                                sig.push(0);
                                mask.push(0);
                            }
                            i += 4;
                        } else if w.starts_with("0x") {
                            sig.extend(u32::to_le_bytes(
                                Self::parse_maybe_hex_u32(w)
                                    .with_context(|| format!("failed to parse 4-bytes hex {w}"))?,
                            ));
                            mask.extend([0xff; 4]);
                            i += 4;
                        } else {
                            bail!("bad pattern word \"{}\"", w)
                        }
                    }
                }
            }
        }
        if let Some(start) = capture_stack.pop() {
            bail!("unclosed capture at word {start}");
        }
        if sig.is_empty() {
            bail!("pattern must match at least one byte");
        }

        Ok(Self {
            simple: PatternSimple { sig, mask },
            custom_offset,
            captures,
            xrefs,
        })
    }
    /// Create a pattern from a literal `Vec<u8>` with `mask` filled with 0xff and `custom_offset = 0`.
    pub fn from_bytes(sig: Vec<u8>) -> Result<Self> {
        Ok(Self {
            simple: PatternSimple {
                mask: vec![0xff; sig.len()],
                sig,
            },
            custom_offset: 0,
            captures: vec![],
            xrefs: vec![],
        })
    }
    #[inline(always)]
    pub fn is_match(&self, data: &[u8], base_address: usize, index: usize) -> bool {
        self.simple.is_match(data, index)
            && self.xrefs.iter().all(|(offset, xref)| {
                (base_address + index + offset + 4)
                    .checked_add_signed(i32::from_le_bytes(
                        data[index + offset..index + offset + 4].try_into().unwrap(),
                    ) as isize)
                    .map(|x| x == xref.0)
                    .unwrap_or(false)
            })
    }
    pub fn captures<'data>(
        &self,
        data: &'data [u8],
        base_address: usize,
        index: usize,
    ) -> Option<Vec<Capture<'data>>> {
        self.is_match(data, base_address, index).then(|| {
            self.captures
                .iter()
                .map(|c| Capture {
                    address: base_address + index + c.start,
                    data: &data[c.start + index..c.end + index],
                })
                .collect()
        })
    }
    /// compute virtual address from address relative to section as well as account for
    /// custom_offset
    pub fn compute_result(&self, _data: &[u8], base_address: usize, index: usize) -> usize {
        base_address + index + self.custom_offset
    }
}

impl Display for Pattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:02X}", self.simple.sig[0])?;
        let mut iter = self.simple.iter().enumerate().skip(1);
        while let Some((i, (sig, mask))) = iter.next() {
            if i == self.custom_offset {
                write!(f, " |")?;
            }
            write!(f, " ")?;
            if *mask == 0 {
                if let Some((_offset, xref)) =
                    self.xrefs.iter().find(|(offset, _xref)| *offset == i)
                {
                    write!(f, "X0x{:X}", xref.0)?;
                    iter.nth(2); // skip 3
                    continue;
                }
            }
            fmt_byte(f, *sig, *mask)?;
        }
        Ok(())
    }
}
impl std::fmt::Debug for Pattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Pattern(\"{self}\")")
    }
}

#[derive(Debug, Clone, Copy, Hash, Eq, Ord, PartialEq, PartialOrd)]
pub struct Xref(pub usize);

use std::{
    collections::{BTreeMap, BTreeSet, HashMap, HashSet},
    fmt::Display,
};

#[derive(Debug, Eq, PartialEq)]
struct PatternPair<'p> {
    pattern: &'p Pattern,
    partial: PatternSimple,
    offset: usize,
}
impl PatternPair<'_> {
    #[inline(always)]
    fn add_match(
        &self,
        data: &[u8],
        base_address: usize,
        offset: usize,
        pattern_index: usize,
        matches: &mut Vec<(usize, usize)>,
    ) {
        if self.partial.is_match(data, offset)
            && offset >= self.offset
            && self
                .pattern
                .is_match(data, base_address, offset - self.offset)
        {
            matches.push((
                pattern_index,
                self.pattern
                    .compute_result(data, base_address, offset - self.offset),
            ));
        }
    }
}

fn group_patterns<'p>(patterns: &[&'p Pattern]) -> Vec<PatternPair<'p>> {
    let mut pattern_pairs: Vec<Option<PatternPair>> = patterns.iter().map(|_| None).collect();

    // common first bytes that should be avoided if possible
    let bans = [0x00, 0x24, 0x48, 0xff];

    #[derive(Debug, Default, Eq, PartialEq)]
    struct ByteSelector {
        is_banned: bool,
        position_score: usize,
        pattern_indexes: BTreeSet<usize>,
    }
    impl std::cmp::PartialOrd for ByteSelector {
        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
            Some(self.cmp(other))
        }
    }
    impl std::cmp::Ord for ByteSelector {
        fn cmp(&self, other: &Self) -> std::cmp::Ordering {
            self.is_banned
                .cmp(&other.is_banned)
                .reverse()
                .then(self.pattern_indexes.len().cmp(&other.pattern_indexes.len()))
                .then(self.position_score.cmp(&other.position_score).reverse())
        }
    }

    let mut patterns: Vec<Option<&Pattern>> = patterns.iter().map(|p| Some(*p)).collect();
    while patterns.iter().any(Option::is_some) {
        let mut counts: BTreeMap<u8, ByteSelector> = Default::default();
        for (pi, p) in patterns
            .iter()
            .enumerate()
            .filter_map(|(i, p)| p.map(|p| (i, &p.simple)))
        {
            let unique = p
                .iter()
                .enumerate()
                .filter_map(|(i, (sig, mask))| (*mask == 0xff).then_some((*sig, i)))
                .rev()
                .collect::<HashMap<u8, usize>>();
            for (u, i) in unique {
                let counts = counts.entry(u).or_insert_with(|| ByteSelector {
                    is_banned: bans.contains(&u),
                    ..Default::default()
                });
                // TODO potentially score by distance from end instead of distance from start
                counts.position_score += i;
                counts.pattern_indexes.insert(pi);
            }
        }
        let (
            max_key,
            ByteSelector {
                pattern_indexes, ..
            },
        ) = counts.iter().max_by_key(|a| a.1).unwrap();
        for (i, p) in patterns.iter().enumerate() {
            if let Some(p) = p {
                if pattern_indexes.contains(&i) {
                    let pos = p
                        .simple
                        .iter()
                        .enumerate()
                        .find_map(|(i, (sig, mask))| (sig == max_key && *mask == 0xff).then_some(i))
                        .unwrap();

                    pattern_pairs[i] = Some(PatternPair {
                        pattern: p,
                        partial: PatternSimple {
                            sig: p.simple.sig[pos..].to_vec(),
                            mask: p.simple.mask[pos..].to_vec(),
                        },
                        offset: pos,
                    });
                }
            }
        }

        for take in pattern_indexes {
            patterns[*take].take();
        }
    }
    pattern_pairs.into_iter().flatten().collect()
}

pub fn scan_pattern(patterns: &[&Pattern], base_address: usize, data: &[u8]) -> Vec<Vec<usize>> {
    use rayon::prelude::*;

    let mut result_bins = patterns.iter().map(|_| vec![]).collect::<Vec<_>>();

    if patterns.is_empty() {
        return result_bins;
    }

    const WIDE1: usize = 2;
    const WIDE2: usize = 4;

    let pattern_pairs = group_patterns(patterns);

    let mut all_bins = HashSet::new();
    let mut short_bins: HashMap<u8, Vec<_>> = Default::default();
    let mut wide1_bins: HashMap<[u8; WIDE1], Vec<_>> = Default::default();
    let mut wide2_bins: HashMap<[u8; WIDE2], Vec<_>> = Default::default();
    for (pi, pair) in pattern_pairs.iter().enumerate() {
        let p = &pair.partial;

        all_bins.insert(p.sig[0]);
        if p.mask.iter().take(WIDE2).filter(|m| **m == 0xff).count() == WIDE2 {
            let mut buf = [0; WIDE2];
            buf.copy_from_slice(&p.sig[0..WIDE2]);
            wide2_bins.entry(buf).or_default().push((pi, pair));
        } else if p.mask.iter().take(WIDE1).filter(|m| **m == 0xff).count() == WIDE1 {
            let mut buf = [0; WIDE1];
            buf.copy_from_slice(&p.sig[0..WIDE1]);
            wide1_bins.entry(buf).or_default().push((pi, pair));
        } else {
            short_bins.entry(p.sig[0]).or_default().push((pi, pair));
        }
    }
    let all_bins = Vec::from_iter(all_bins);

    let max = patterns.iter().map(|p| p.simple.len()).max().unwrap();

    // cut middle short such that even the longest pattern doesn't have to bounds check
    let middle = &data[0..data.len().saturating_sub(max)];

    let mut matches = vec![];

    // middle
    let chunk_size = (middle.len()
        / std::thread::available_parallelism().unwrap_or(std::num::NonZeroUsize::new(1).unwrap()))
    .max(1);
    let chunks: Vec<_> = middle.chunks(chunk_size).enumerate().collect();
    matches.append(
        &mut chunks
            .par_iter()
            .map(|(index, chunk)| {
                let mut matches = vec![];
                let offset = index * chunk_size;

                for first in &all_bins {
                    for i in memchr::memchr_iter(*first, chunk) {
                        let j = offset + i;
                        if let Some(patterns) = short_bins.get(first) {
                            for (pi, p) in patterns.iter() {
                                p.add_match(data, base_address, j, *pi, &mut matches)
                            }
                        }
                        if !wide2_bins.is_empty() {
                            let mut buf = [0; WIDE2];
                            buf.copy_from_slice(&data[j..j + WIDE2]);
                            if let Some(patterns) = wide2_bins.get(&buf) {
                                for (pi, p) in patterns.iter() {
                                    p.add_match(data, base_address, j, *pi, &mut matches)
                                }
                            }
                        }
                        if !wide1_bins.is_empty() {
                            let mut buf = [0; WIDE1];
                            buf.copy_from_slice(&data[j..j + WIDE1]);
                            if let Some(patterns) = wide1_bins.get(&buf) {
                                for (pi, p) in patterns.iter() {
                                    p.add_match(data, base_address, j, *pi, &mut matches)
                                }
                            }
                        }
                    }
                }
                matches
            })
            .flatten()
            .collect(),
    );

    // suffix
    let start = middle.len();
    for (pi, p) in pattern_pairs.iter().enumerate() {
        for i in (start.saturating_sub(p.offset))
            ..start + (data.len() - middle.len()).saturating_sub(p.pattern.simple.len() - 1)
        {
            if p.pattern.is_match(data, base_address, i) {
                matches.push((pi, base_address + i));
            }
        }
    }

    for (pi, addr) in matches {
        result_bins[pi].push(addr);
    }

    result_bins
}

pub fn scan_xref(patterns: &[&Xref], base_address: usize, data: &[u8]) -> Vec<Vec<usize>> {
    use rayon::prelude::*;

    let mut bins = patterns.iter().map(|_| vec![]).collect::<Vec<_>>();

    if patterns.is_empty() {
        return bins;
    }

    let mut patterns = patterns.to_vec();
    patterns.sort();

    let mut matches = vec![];

    let width = 4;

    let first_byte_data = &data[0..data.len().saturating_sub(width - 1)];
    let chunk_size = (first_byte_data.len()
        / std::thread::available_parallelism().unwrap_or(std::num::NonZeroUsize::new(1).unwrap()))
    .max(1);

    let chunks: Vec<_> = first_byte_data.chunks(chunk_size).enumerate().collect();
    matches.append(
        &mut chunks
            .par_iter()
            .map(|(chunk_index, chunk)| {
                let mut matches = vec![];
                let offset = chunk_index * chunk_size;

                for j in offset..offset + chunk.len() {
                    if let Some(address) = (base_address + width + j).checked_add_signed(
                        i32::from_le_bytes(data[j..j + width].try_into().unwrap())
                            .try_into()
                            .unwrap(),
                    ) {
                        if let Ok(i) = patterns.binary_search_by_key(&address, |p| p.0) {
                            // match found
                            let addr = base_address + j;
                            {
                                // walk backwards until unequal
                                let mut i = i - 1;
                                while let Some(prev) = patterns.get(i) {
                                    if prev.0 != address {
                                        break;
                                    }
                                    matches.push((i, addr));
                                    i -= 1;
                                }
                            }
                            {
                                // walk forwards until unequal
                                let mut i = i;
                                while let Some(next) = patterns.get(i) {
                                    if next.0 != address {
                                        break;
                                    }
                                    matches.push((i, addr));
                                    i += 1;
                                }
                            }
                        }
                    }
                }
                matches
            })
            .flatten()
            .collect::<Vec<_>>(),
    );

    for (pi, addr) in matches {
        bins[pi].push(addr);
    }

    bins
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse_bits() {
        assert_eq!(None, Pattern::parse_binary_patern("0000000"));
        assert_eq!(None, Pattern::parse_binary_patern("000000000"));
        assert_eq!(Some((0, 0xff)), Pattern::parse_binary_patern("00000000"));
        assert_eq!(
            Some((0b0000_0000, 0b0111_1111)),
            Pattern::parse_binary_patern("?0000000")
        );
        assert_eq!(
            Some((0b0100_0000, 0b0111_1111)),
            Pattern::parse_binary_patern("?1000000")
        );
    }

    #[test]
    fn test_parse_hex() {
        assert_eq!(Some((0xff, 0xff)), Pattern::parse_hex_pattern("ff"));
        assert_eq!(Some((0x00, 0xff)), Pattern::parse_hex_pattern("00"));
        assert_eq!(Some((0x0f, 0x0f)), Pattern::parse_hex_pattern("?f"));
        assert_eq!(Some((0x00, 0x0f)), Pattern::parse_hex_pattern("?0"));
        assert_eq!(Some((0x00, 0xf0)), Pattern::parse_hex_pattern("0?"));
        assert_eq!(None, Pattern::parse_hex_pattern("z0"));
        assert_eq!(None, Pattern::parse_hex_pattern("0"));
        assert_eq!(None, Pattern::parse_hex_pattern("000"));
    }

    #[test]
    fn test_build_pattern() {
        assert!(Pattern::new("?? ??").is_ok());
        assert_eq!(
            Pattern {
                simple: PatternSimple {
                    sig: vec![0, 0],
                    mask: vec![0xff, 0],
                },
                custom_offset: 0,
                captures: vec![],
                xrefs: vec![],
            },
            Pattern::new("00 ??").unwrap()
        );
        assert_eq!(
            Pattern {
                simple: PatternSimple {
                    sig: vec![0x10, 0],
                    mask: vec![0xff, 0],
                },
                custom_offset: 0,
                captures: vec![],
                xrefs: vec![],
            },
            Pattern::new("10 ??").unwrap()
        );
        assert_eq!(
            Pattern {
                simple: PatternSimple {
                    sig: vec![0x10, 0, 0b01010011],
                    mask: vec![0xff, 0, 0b11011011],
                },
                custom_offset: 0,
                captures: vec![],
                xrefs: vec![],
            },
            Pattern::new("10 ?? 01?10?11").unwrap()
        );
    }

    #[test]
    fn test_display_pattern() {
        assert_eq!(
            Pattern::new("12 34 | 56").unwrap().to_string(),
            "12 34 | 56"
        );
        assert_eq!(
            Pattern::new("12 34 | 56").unwrap().simple.to_string(),
            "12 34 56"
        );

        assert_eq!(Pattern::new("12 34 56").unwrap().to_string(), "12 34 56");
        assert_eq!(
            Pattern::new("12 34 56").unwrap().simple.to_string(),
            "12 34 56"
        );

        assert_eq!(
            Pattern::new("12 X0x34 56").unwrap().to_string(),
            "12 X0x34 56"
        );
        assert_eq!(
            Pattern::new("12 X0x34 56").unwrap().simple.to_string(),
            "12 ?? ?? ?? ?? 56"
        );

        assert_eq!(
            Pattern::new("12 ?3 45").unwrap().simple.to_string(),
            "12 ?3 45"
        );
        assert_eq!(
            Pattern::new("12 3? 45").unwrap().simple.to_string(),
            "12 3? 45"
        );
        assert_eq!(
            Pattern::new("12 ?0000001 45").unwrap().simple.to_string(),
            "12 ?0000001 45"
        );
        assert_eq!(
            Pattern::new("12 ??100??1 45").unwrap().simple.to_string(),
            "12 ??100??1 45"
        );
    }

    #[test]
    fn test_captures() {
        assert!(Pattern::new("?? [ ??").is_err());
        assert!(Pattern::new("?? ] ??").is_err());
        assert!(Pattern::new("[ ] ?? ] ??").is_err());
        assert_eq!(
            Pattern {
                simple: PatternSimple {
                    sig: vec![0, 0, 0x10, 0x20],
                    mask: vec![0xff, 0, 0xff, 0xff],
                },
                custom_offset: 0,
                captures: vec![2..2, 1..2, 2..4],
                xrefs: vec![],
            },
            Pattern::new("00 [ ?? [ ] ] [ 10 20 ]").unwrap()
        );

        assert_eq!(
            Some(vec![Capture {
                address: 100 + 3,
                data: &[0x99]
            }]),
            Pattern::new("10 20 30 [ ?? ]")
                .unwrap()
                .captures(b"\x10\x20\x30\x99", 100, 0)
        );

        assert_eq!(
            Some(vec![Capture {
                address: 100 + 2,
                data: &[0x30]
            }]),
            Pattern::new("20 [ ?? ]")
                .unwrap()
                .captures(b"\x10\x20\x30\x99\x24", 100, 1)
        );
    }

    #[test]
    fn test_group_patterns() {
        // simple
        assert_eq!(
            group_patterns(&[
                &Pattern::new("12 34").unwrap(),
                &Pattern::new("34 56").unwrap(),
            ]),
            vec![
                PatternPair {
                    pattern: &Pattern::new("12 34").unwrap(),
                    partial: Pattern::new("34").unwrap().simple,
                    offset: 1,
                },
                PatternPair {
                    pattern: &Pattern::new("34 56").unwrap(),
                    partial: Pattern::new("34 56").unwrap().simple,
                    offset: 0,
                },
            ]
        );

        // duplicate bytes
        assert_eq!(
            group_patterns(&[
                &Pattern::new("12 12 12 34").unwrap(),
                &Pattern::new("34 56 12").unwrap(),
            ]),
            vec![
                PatternPair {
                    pattern: &Pattern::new("12 12 12 34").unwrap(),
                    partial: Pattern::new("12 12 12 34").unwrap().simple,
                    offset: 0,
                },
                PatternPair {
                    pattern: &Pattern::new("34 56 12").unwrap(),
                    partial: Pattern::new("12").unwrap().simple,
                    offset: 2,
                },
            ]
        );

        // multiple possible groupings (use first)
        assert_eq!(
            group_patterns(&[
                &Pattern::new("12 34 56").unwrap(),
                &Pattern::new("34 56").unwrap(),
            ]),
            vec![
                PatternPair {
                    pattern: &Pattern::new("12 34 56").unwrap(),
                    partial: Pattern::new("34 56").unwrap().simple,
                    offset: 1,
                },
                PatternPair {
                    pattern: &Pattern::new("34 56").unwrap(),
                    partial: Pattern::new("34 56").unwrap().simple,
                    offset: 0,
                },
            ]
        );

        // test bans
        assert_eq!(
            group_patterns(&[
                &Pattern::new("12 00").unwrap(),
                &Pattern::new("00 56").unwrap(),
            ]),
            vec![
                PatternPair {
                    pattern: &Pattern::new("12 00").unwrap(),
                    partial: Pattern::new("12 00").unwrap().simple,
                    offset: 0,
                },
                PatternPair {
                    pattern: &Pattern::new("00 56").unwrap(),
                    partial: Pattern::new("56").unwrap().simple,
                    offset: 1,
                },
            ]
        );

        // test bans
        assert_eq!(
            group_patterns(&[&Pattern::new("00").unwrap(),]),
            vec![PatternPair {
                pattern: &Pattern::new("00").unwrap(),
                partial: Pattern::new("00").unwrap().simple,
                offset: 0,
            },]
        );
    }

    type PatternScanFn =
        fn(patterns: &[&Pattern], base_address: usize, data: &[u8]) -> Vec<Vec<usize>>;

    type XrefScanFn = fn(patterns: &[&Xref], base_address: usize, data: &[u8]) -> Vec<Vec<usize>>;

    #[test]
    fn test_scan_pattern() {
        test_scan_algo(scan_pattern);
    }

    fn test_scan_algo(scan: PatternScanFn) {
        let patterns = [&Pattern::new("01").unwrap()];

        let len = 64;
        let lanes = 32;
        let base = 123;

        let data = vec![1; len + lanes];
        let matches: Vec<_> = (base..len + base).collect();

        for i in 0..lanes {
            let slice = &data[i..i + len];
            assert_eq!(vec![matches.clone()], scan(&patterns, base, slice));
        }

        let patterns = [&Pattern::new("01 02").unwrap()];

        // obtuse generator to test every combination of chunk boundaries
        let data: Vec<_> = std::iter::repeat([1, 2, 3]).take(32).flatten().collect();
        let matches: Vec<_> = (0..3)
            .map(|offset| {
                (0..len / 3)
                    .map(|i| i * 3 + offset + base)
                    .collect::<Vec<_>>()
            })
            .collect();

        for i in 0..(len - lanes) {
            let slice = &data[i..i + len];
            let res = scan(&patterns, base, slice);
            assert_eq!(vec![matches[(3 - (i % 3)) % 3].clone()], res);
        }
    }

    #[test]
    fn test_scan_xref() {
        test_scan_xref_algo(scan_xref);
    }

    fn test_scan_xref_algo(scan: XrefScanFn) {
        let scans = [
            &Xref(0x504030a),
            &Xref(0x504030a),
            &Xref(0x504030a),
            &Xref(0x504030a),
        ];

        let mut res = scan(&scans, 3, &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
        res.sort();
        assert_eq!(vec![vec![4], vec![4], vec![4], vec![4]], res);
    }
}

```

`rust-toolchain.toml`:

```toml
[toolchain]
channel = "nightly"

```