Project Path: arc_gmh5225_Dainsleif_wbodoyhc

Source Tree:

```txt
arc_gmh5225_Dainsleif_wbodoyhc
├── CMakeLists.txt
├── Dainsleif
│   ├── ClientClass.h
│   ├── DefaultSettings.h
│   ├── Entity.cpp
│   ├── Entity.h
│   ├── Hacks
│   │   ├── Aimbot.cpp
│   │   ├── Aimbot.h
│   │   ├── AntiAFK.cpp
│   │   ├── AntiAFK.h
│   │   ├── AntiRecoil.cpp
│   │   ├── AntiRecoil.h
│   │   ├── Bunnyhop.cpp
│   │   ├── Bunnyhop.h
│   │   ├── Esp.cpp
│   │   ├── Esp.h
│   │   ├── Glow.cpp
│   │   ├── Glow.h
│   │   ├── MinimapHack.cpp
│   │   ├── MinimapHack.h
│   │   ├── Triggerbot.cpp
│   │   └── Triggerbot.h
│   ├── Hook
│   │   ├── ControlCursor.cpp
│   │   ├── ControlCursor.h
│   │   ├── DrawGUI.cpp
│   │   ├── DrawGUI.h
│   │   ├── GraphicHook.cpp
│   │   ├── GraphicHook.h
│   │   ├── Hooks.cpp
│   │   ├── Hooks.h
│   │   ├── ImGuiTheme.cpp
│   │   └── ImGuiTheme.h
│   ├── Interfaces
│   │   ├── CInput.h
│   │   ├── CInterfaceList.cpp
│   │   ├── CInterfaceList.h
│   │   ├── IBaseClientDll.h
│   │   ├── IClientModeShared.h
│   │   ├── ISurface.h
│   │   └── IVEngineClient.h
│   ├── Modules.cpp
│   ├── Modules.h
│   ├── Offsets.cpp
│   ├── Offsets.h
│   ├── PatternScanner.cpp
│   ├── PatternScanner.h
│   ├── Player.cpp
│   ├── Player.h
│   ├── Save
│   │   ├── OffsetsToml.cpp
│   │   ├── OffsetsToml.h
│   │   ├── SettingsToml.cpp
│   │   ├── SettingsToml.h
│   │   ├── TabStateToml.cpp
│   │   └── TabStateToml.h
│   ├── Utils.h
│   ├── Vector.cpp
│   ├── Vector.h
│   ├── Weapon.cpp
│   ├── Weapon.h
│   ├── dllmain.cpp
│   ├── dllmain.h
│   ├── pch.cpp
│   └── pch.h
├── Dependencies
│   ├── imgui
│   ├── minhook
│   └── toml11
│       ├── toml
│       │   ├── color.hpp
│       │   ├── combinator.hpp
│       │   ├── comments.hpp
│       │   ├── datetime.hpp
│       │   ├── exception.hpp
│       │   ├── from.hpp
│       │   ├── get.hpp
│       │   ├── into.hpp
│       │   ├── lexer.hpp
│       │   ├── literal.hpp
│       │   ├── parser.hpp
│       │   ├── region.hpp
│       │   ├── result.hpp
│       │   ├── serializer.hpp
│       │   ├── source_location.hpp
│       │   ├── storage.hpp
│       │   ├── string.hpp
│       │   ├── traits.hpp
│       │   ├── types.hpp
│       │   ├── utility.hpp
│       │   └── value.hpp
│       └── toml.hpp
├── LICENSE
├── README.md
├── README_jp.md
└── compile.bat

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)
project(Dainsleif)

set(CMAKE_CXX_STANDARD 17)

if(CMAKE_GENERATOR MATCHES "Visual Studio")
  set_property(GLOBAL PROPERTY USE_FOLDERS ON)
  file(GLOB_RECURSE SOURCE_LIST RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} CONFIGURE_DEPENDS *.c *.cpp *.h *.hpp)
  source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${SOURCE_LIST})
endif()

#main directory and its sub-directories
file(GLOB_RECURSE MAIN CONFIGURE_DEPENDS
  ${CMAKE_CURRENT_LIST_DIR}/Dainsleif/*.cpp
  ${CMAKE_CURRENT_LIST_DIR}/Dainsleif/*.h)

#minhook
file(GLOB_RECURSE MINHOOK CONFIGURE_DEPENDS
  ${CMAKE_CURRENT_LIST_DIR}/Dependencies/minhook/*.c
  ${CMAKE_CURRENT_LIST_DIR}/Dependencies/minhook/*.h)

#imgui
file(GLOB IMGUI CONFIGURE_DEPENDS
  ${CMAKE_CURRENT_LIST_DIR}/Dependencies/imgui/*.cpp
  ${CMAKE_CURRENT_LIST_DIR}/Dependencies/imgui/*.h
  ${CMAKE_CURRENT_LIST_DIR}/Dependencies/imgui/backends/imgui_impl_dx9.*
  ${CMAKE_CURRENT_LIST_DIR}/Dependencies/imgui/backends/imgui_impl_win32.*)

#toml11
file(GLOB_RECURSE TOML CONFIGURE_DEPENDS
  ${CMAKE_CURRENT_LIST_DIR}/Dependencies/toml11/*.hpp)

set(DEPENDENCIES
  ${MINHOOK}
  ${IMGUI}
  ${TOML})

add_library(Dainsleif SHARED ${MAIN} ${DEPENDENCIES})

target_include_directories(Dainsleif PRIVATE
  ${CMAKE_CURRENT_LIST_DIR}/Dependencies/imgui
  ${CMAKE_CURRENT_LIST_DIR}/Dependencies/imgui/backends
  ${CMAKE_CURRENT_LIST_DIR}/Dependencies/minhook/include
  ${CMAKE_CURRENT_LIST_DIR}/Dependencies/toml11
  $ENV{DXSDK_DIR}/Include)

find_library(D3D9 d3d9.lib $ENV{DXSDK_DIR}/Lib/x86)
find_library(D3DX9 d3dx9.lib $ENV{DXSDK_DIR}/Lib/x86)
target_link_libraries(Dainsleif ${D3D9} ${D3DX9})
```

`Dainsleif/ClientClass.h`:

```h
#pragma once

enum class ClassID : int
{
    CAI_BaseNPC = 0,
    CAK47,
    CBaseAnimating,
    CBaseAnimatingOverlay,
    CBaseAttributableItem,
    CBaseButton,
    CBaseCombatCharacter,
    CBaseCombatWeapon,
    CBaseCSGrenade,
    CBaseCSGrenadeProjectile,
    CBaseDoor,
    CBaseEntity,
    CBaseFlex,
    CBaseGrenade,
    CBaseParticleEntity,
    CBasePlayer,
    CBasePropDoor,
    CBaseTeamObjectiveResource,
    CBaseTempEntity,
    CBaseToggle,
    CBaseTrigger,
    CBaseViewModel,
    CBaseVPhysicsTrigger,
    CBaseWeaponWorldModel,
    CBeam,
    CBeamSpotlight,
    CBoneFollower,
    CBRC4Target,
    CBreachCharge,
    CBreachChargeProjectile,
    CBreakableProp,
    CBreakableSurface,
    CBumpMine,
    CBumpMineProjectile,
    CC4,
    CCascadeLight,
    CChicken,
    CColorCorrection,
    CColorCorrectionVolume,
    CCSGameRulesProxy,
    CCSPlayer,
    CCSPlayerResource,
    CCSRagdoll,
    CCSTeam,
    CDangerZone,
    CDangerZoneController,
    CDEagle,
    CDecoyGrenade,
    CDecoyProjectile,
    CDrone,
    CDronegun,
    CDynamicLight,
    CDynamicProp,
    CEconEntity,
    CEconWearable,
    CEmbers,
    CEntityDissolve,
    CEntityFlame,
    CEntityFreezing,
    CEntityParticleTrail,
    CEnvAmbientLight,
    CEnvDetailController,
    CEnvDOFController,
    CEnvGasCanister,
    CEnvParticleScript,
    CEnvProjectedTexture,
    CEnvQuadraticBeam,
    CEnvScreenEffect,
    CEnvScreenOverlay,
    CEnvTonemapController,
    CEnvWind,
    CFEPlayerDecal,
    CFireCrackerBlast,
    CFireSmoke,
    CFireTrail,
    CFish,
    CFists,
    CFlashbang,
    CFogController,
    CFootstepControl,
    CFunc_Dust,
    CFunc_LOD,
    CFuncAreaPortalWindow,
    CFuncBrush,
    CFuncConveyor,
    CFuncLadder,
    CFuncMonitor,
    CFuncMoveLinear,
    CFuncOccluder,
    CFuncReflectiveGlass,
    CFuncRotating,
    CFuncSmokeVolume,
    CFuncTrackTrain,
    CGameRulesProxy,
    CGrassBurn,
    CHandleTest,
    CHEGrenade,
    CHostage,
    CHostageCarriableProp,
    CIncendiaryGrenade,
    CInferno,
    CInfoLadderDismount,
    CInfoMapRegion,
    CInfoOverlayAccessor,
    CItem_Healthshot,
    CItemCash,
    CItemDogtags,
    CKnife,
    CKnifeGG,
    CLightGlow,
    CMaterialModifyControl,
    CMelee,
    CMolotovGrenade,
    CMolotovProjectile,
    CMovieDisplay,
    CParadropChopper,
    CParticleFire,
    CParticlePerformanceMonitor,
    CParticleSystem,
    CPhysBox,
    CPhysBoxMultiplayer,
    CPhysicsProp,
    CPhysicsPropMultiplayer,
    CPhysMagnet,
    CPhysPropAmmoBox,
    CPhysPropLootCrate,
    CPhysPropRadarJammer,
    CPhysPropWeaponUpgrade,
    CPlantedC4,
    CPlasma,
    CPlayerPing,
    CPlayerResource,
    CPointCamera,
    CPointCommentaryNode,
    CPointWorldText,
    CPoseController,
    CPostProcessController,
    CPrecipitation,
    CPrecipitationBlocker,
    CPredictedViewModel,
    CProp_Hallucination,
    CPropCounter,
    CPropDoorRotating,
    CPropJeep,
    CPropVehicleDriveable,
    CRagdollManager,
    CRagdollProp,
    CRagdollPropAttached,
    CRopeKeyframe,
    CSCAR17,
    CSceneEntity,
    CSensorGrenade,
    CSensorGrenadeProjectile,
    CShadowControl,
    CSlideshowDisplay,
    CSmokeGrenade,
    CSmokeGrenadeProjectile,
    CSmokeStack,
    CSnowball,
    CSnowballPile,
    CSnowballProjectile,
    CSpatialEntity,
    CSpotlightEnd,
    CSprite,
    CSpriteOriented,
    CSpriteTrail,
    CStatueProp,
    CSteamJet,
    CSun,
    CSunlightShadowControl,
    CSurvivalSpawnChopper,
    CTablet,
    CTeam,
    CTeamplayRoundBasedRulesProxy,
    CTEArmorRicochet,
    CTEBaseBeam,
    CTEBeamEntPoint,
    CTEBeamEnts,
    CTEBeamFollow,
    CTEBeamLaser,
    CTEBeamPoints,
    CTEBeamRing,
    CTEBeamRingPoint,
    CTEBeamSpline,
    CTEBloodSprite,
    CTEBloodStream,
    CTEBreakModel,
    CTEBSPDecal,
    CTEBubbles,
    CTEBubbleTrail,
    CTEClientProjectile,
    CTEDecal,
    CTEDust,
    CTEDynamicLight,
    CTEEffectDispatch,
    CTEEnergySplash,
    CTEExplosion,
    CTEFireBullets,
    CTEFizz,
    CTEFootprintDecal,
    CTEFoundryHelpers,
    CTEGaussExplosion,
    CTEGlowSprite,
    CTEImpact,
    CTEKillPlayerAttachments,
    CTELargeFunnel,
    CTEMetalSparks,
    CTEMuzzleFlash,
    CTEParticleSystem,
    CTEPhysicsProp,
    CTEPlantBomb,
    CTEPlayerAnimEvent,
    CTEPlayerDecal,
    CTEProjectedDecal,
    CTERadioIcon,
    CTEShatterSurface,
    CTEShowLine,
    CTesla,
    CTESmoke,
    CTESparks,
    CTESprite,
    CTESpriteSpray,
    CTest_ProxyToggle_Networkable,
    CTestTraceline,
    CTEWorldDecal,
    CTriggerPlayerMovement,
    CTriggerSoundOperator,
    CVGuiScreen,
    CVoteController,
    CWaterBullet,
    CWaterLODControl,
    CWeaponAug,
    CWeaponAWP,
    CWeaponBaseItem,
    CWeaponBizon,
    CWeaponCSBase,
    CWeaponCSBaseGun,
    CWeaponCycler,
    CWeaponElite,
    CWeaponFamas,
    CWeaponFiveSeven,
    CWeaponG3SG1,
    CWeaponGalil,
    CWeaponGalilAR,
    CWeaponGlock,
    CWeaponHKP2000,
    CWeaponM249,
    CWeaponM3,
    CWeaponM4A1,
    CWeaponMAC10,
    CWeaponMag7,
    CWeaponMP5Navy,
    CWeaponMP7,
    CWeaponMP9,
    CWeaponNegev,
    CWeaponNOVA,
    CWeaponP228,
    CWeaponP250,
    CWeaponP90,
    CWeaponSawedoff,
    CWeaponSCAR20,
    CWeaponScout,
    CWeaponSG550,
    CWeaponSG552,
    CWeaponSG556,
    CWeaponShield,
    CWeaponSSG08,
    CWeaponTaser,
    CWeaponTec9,
    CWeaponTMP,
    CWeaponUMP45,
    CWeaponUSP,
    CWeaponXM1014,
    CWorld,
    CWorldVguiText,
    DustTrail,
    MovieExplosion,
    ParticleSmokeGrenade,
    RocketTrail,
    SmokeTrail,
    SporeExplosion,
    SporeTrail,
};

struct RecvProxyData;
struct RecvTable;
struct RecvProp;

using RecvVarProxyFn = void(__cdecl*)(const RecvProxyData*, void*, void*);
using CreateClientClassFn = void* (*)(int entnum, int serialNum);
using CreateEventFn = void* (*)();

struct DVariant
{
    union
    {
        float m_Float;
        long m_Int;
        char* m_pString;
        void* m_pData;
        float m_Vector[3];
        __int64 m_Int64;
    };

    int m_Type;
};

struct RecvProxyData
{
    const RecvProp* m_pRecvProp;
    DVariant m_Value;
    int m_iElement;
    int m_ObjectID;
};

struct RecvTable
{
    RecvProp* m_pProps;
    int m_nProps;
    void* m_pDecoder;
    char* m_pNetTableName;
    char pad_01[0x2];
};

struct RecvProp
{
    char* m_pVarName;
    int m_RecvType;
    int m_Flags;
    int m_StringBufferSize;
    bool m_bInsideArray;
    const void* m_pExtraData;
    RecvProp* m_pArrayProp;
    void* m_ArrayLengthProxy;
    RecvVarProxyFn m_ProxyFn;
    void* m_DataTableProxyFn;
    RecvTable* m_pDataTable;
    int m_Offset;
    int m_ElementStride;
    int m_nElements;
    const char* m_pParentArrayPropName;
};

struct ClientClass
{
    CreateClientClassFn m_pCreateFn;
    CreateEventFn m_pCreateEventFn;
    char* m_pNetworkName;
    RecvTable* m_pRecvTable;
    ClientClass* m_pNext;
    ClassID m_ClassID;
};
```

`Dainsleif/DefaultSettings.h`:

```h
#pragma once
#include "imgui.h"


namespace Default {
    //Aimbot
    const bool bAimbot = false;
    const float aimSmoothness = 0.2f;
    const float range = 10.f;

    //Glow hack
    const bool bGlowhack = false;
    const ImVec4 enemyGlowColor = ImVec4(0.8f,0.1f,0.15f,1.f);
    const ImVec4 localGlowColor = ImVec4(0.f,0.255f,0.7f,1.f);

    //Anti Recoil
    const bool bAntiRecoil = false;

    //Trigger bot
    const bool bTriggerBot = false;

    //Bunnyhop
    const bool bBunnyhop = false;

    //FOV
    const int fov = 90;

    //Anti AFK
    const bool bAntiAFK = false;

    //ESP
    const bool bEsp = false;
    const bool bLineOverlay = false;
    const bool bRectOverlay = false;

    //Minimap hack
    const bool bMinimapHack = false;
}
```

`Dainsleif/Entity.cpp`:

```cpp
#include "pch.h"
#include "Entity.h"

Entity* Entity::GetByIndex(int index)
{
    return *reinterpret_cast<Entity**>(Modules::client + dwEntityList + sizeof(EntInfo) * index);
}

std::vector<Entity*> Entity::GetAll()
{
    std::vector<Entity*> allEntities;
    for (EntInfo* entInfo = reinterpret_cast<EntInfo*>(Modules::client + dwEntityList); entInfo; entInfo = entInfo->m_pNext)
    {
        if (entInfo->m_pEntity == nullptr)
        {
            continue;
        }

        allEntities.push_back(entInfo->m_pEntity);

        if (entInfo->m_pNext == nullptr || entInfo->m_pNext == entInfo->m_pPrev)
        {
            break;
        }
    }
    return allEntities;
}

void* Entity::GetClientNetworkable()
{
    return this + 0x8;
}

ClientClass* Entity::GetClientClass()
{
    return Utils::CallVirtualFunction<ClientClass*>(GetClientNetworkable(), 2);
}

bool Entity::IsDormant()
{
    return ReadValue<bool>(m_bDormant);
}
```

`Dainsleif/Entity.h`:

```h
#pragma once
#include "pch.h"
#include "ClientClass.h"

class Entity
{
public:
    static Entity* GetByIndex(int index);

    static std::vector<Entity*> GetAll();

    template <typename T>
    T ReadValue(std::ptrdiff_t offset)
    {
        return *reinterpret_cast<T*>(this + offset);
    }

    template <typename T>
    void WriteValue(std::ptrdiff_t offset, T value)
    {
        *reinterpret_cast<T*>(this + offset) = value;
    }

    template <typename T>
    T Cast()
    {
        return reinterpret_cast<T>(this);
    }

    void* GetClientNetworkable();
    ClientClass* GetClientClass();
    bool IsDormant();
};

struct EntInfo
{
    Entity* m_pEntity;
    int m_SerialNumber;
    EntInfo* m_pPrev;
    EntInfo* m_pNext;
};
```

`Dainsleif/Hacks/Aimbot.cpp`:

```cpp
#include "Aimbot.h"

const double PI = 3.14159265358;
float aimSmoothness = 0.2f;
float range;

// sign() checks if the argument is positive or negative
int sign(float A)
{
    return (A > 0) - (A < 0);
}

float GetDistance(Vector3 targetPos, Vector3 basePos, Vector3& deltaVector)
{
    deltaVector = targetPos - basePos;
    return sqrt(deltaVector.x * deltaVector.x + deltaVector.y * deltaVector.y + deltaVector.z * deltaVector.z);
}

Player* GetClosestEnemyFromCrosshair(std::vector<Player*> playerList, Player* localPlayer)
{
    float closestDistance = 1000000.f;
    int closestPlayerIndex = -1;
    auto* viewAngles = reinterpret_cast<Vector3*>(*reinterpret_cast<uintptr_t*>(Modules::engine + dwClientState) + dwClientState_ViewAngles);
    for (int i = 0; i < playerList.size(); ++i)
    {
        Vector3 delta{};

        if (!playerList[i]->GetBoneMatrix()) continue; //null pointer check

        Vector3 playerHeadPosition = playerList[i]->GetBonePosition();

        GetDistance(playerHeadPosition, localPlayer->GetHeadPosition(), delta);
        float yaw = atan2(delta.y, delta.x) * (180 / static_cast<float>(PI));
        float yawDistance = fabs(yaw - viewAngles->y);

        if (yawDistance < closestDistance) {
            closestDistance = yawDistance;
            closestPlayerIndex = i;
        }
    }
    if (closestPlayerIndex == -1 || playerList[closestPlayerIndex]->IsDormant())
    {
        return nullptr;
    }
    return playerList[closestPlayerIndex];
}

void Aimbot::Run(std::vector<Player*> playerList)
{

    Player* localPlayer = Player::GetLocalPlayer();
    static const WeaponID rejectWeaponList[11] = { KNIFE, C4, GN_DECOY, GN_FLASH_, GN_HE, GN_MOLOTOV, GN_SMOKE, SR_SSG08, SR_AWP, SR_G3SG1 };
    Weapon* activeWeapon = localPlayer->GetActiveWeapon();
    WeaponID activeWeaponID = activeWeapon->GetWeaponID();
    for (WeaponID rejW : rejectWeaponList) {
        if (rejW == activeWeaponID) {
            return;
        }
    }
    static auto* viewAngles = reinterpret_cast<Vector3*>(*reinterpret_cast<uintptr_t*>(Modules::engine + dwClientState) + dwClientState_ViewAngles);

    Player* closestEnt = GetClosestEnemyFromCrosshair(playerList, localPlayer);
    if (!closestEnt)
        return;

    Vector3 delta{};
    float hypotenuse = GetDistance(closestEnt->GetBonePosition(), localPlayer->GetHeadPosition(), delta);
    float pitch = -asin(delta.z / hypotenuse) * (180 / static_cast<float>(PI));
    float yaw = atan2(delta.y, delta.x) * (180 / static_cast<float>(PI));

    if (pitch >= -89 && pitch <= 89 && yaw >= -180 && yaw <= 180)
    {
        float pitchDistance = fabs(pitch - viewAngles->x);
        float yawDistance = fabs(yaw - viewAngles->y);
        if (pitchDistance >= range || yawDistance >= range) {
            return;
        }

        float num = aimSmoothness / max(pitchDistance, yawDistance);
        float x = num * min(pitchDistance, yawDistance);

        /*
        aimSmoothness is a base of how smooth the aim pulling should be.
        num * max == 0.5f.
        Bigger:0.5 = Smoller:x
        */
        float pf, yf;
        if (pitchDistance > yawDistance)
        {
            pf = aimSmoothness;
            yf = x;
        }
        else {
            pf = x;
            yf = aimSmoothness;
        }

        float rangeAimFix = aimSmoothness * 0.5f; //rangeAimFix holds the value representing area around enemy's head that allows viewAngle to be free.
        if (aimSmoothness <= 0.2)
            rangeAimFix = 0.1f;

        if (pitchDistance > rangeAimFix) {
            if (viewAngles->x < pitch)  //my view is smaller than pitch.
            {
                viewAngles->x += pf;
            }
            else if (viewAngles->x > pitch)
            {
                viewAngles->x -= pf;
            }
        }

        if (yawDistance > rangeAimFix) {
            if (viewAngles->y < yaw)
            {
                if (sign(viewAngles->y) == -1 && sign(yaw) == 1 && viewAngles->y <= -90) //When yaw is like 170 and viewAngle steps over -180
                {
                    viewAngles->y -= yf;
                }
                else {
                    viewAngles->y += yf;
                }
            }
            else if (viewAngles->y > yaw) {
                if (sign(viewAngles->y) == 1 && sign(yaw) == -1 && viewAngles->y >= 90)  //When yaw is like -170 and viewAngle steps over 180
                {
                    viewAngles->y += yf;
                }
                else {
                    viewAngles->y -= yf;
                }

            }
        }
    }
}
```

`Dainsleif/Hacks/Aimbot.h`:

```h
#pragma once

#include "../pch.h"
#include "../Player.h"

namespace Aimbot
{
    //AimBot lets local player aim at enemy's head with full precision.
    void Run(std::vector<Player*> playerList);
}
```

`Dainsleif/Hacks/AntiAFK.cpp`:

```cpp
#include "../pch.h"
#include "AntiAFK.h"
#include <thread>

using namespace std::literals::chrono_literals;

void AntiAFK::MakeMeaninglessMoves()
{
    int* forceBackward = reinterpret_cast<int*>(Modules::client + dwForceBackward);
    int* forceForward = reinterpret_cast<int*>(Modules::client + dwForceForward);
    int* forceRight = reinterpret_cast<int*>(Modules::client + dwForceRight);
    int* forceLeft = reinterpret_cast<int*>(Modules::client + dwForceLeft);
    int* forceJump = reinterpret_cast<int*>(Modules::client + dwForceJump);

    *forceBackward = 1;
    std::this_thread::sleep_for(1s);
    *forceBackward = 0;

    *forceForward = 1;
    std::this_thread::sleep_for(1s);
    *forceForward = 0;

    *forceJump = 5;

    *forceLeft = 1;
    std::this_thread::sleep_for(1.5s);
    *forceLeft = 0;
    *forceJump = 4;

    *forceRight = 1;
    std::this_thread::sleep_for(1.5s);
    *forceRight = 0;
}

void AntiAFK::Run(bool *bAntiAFK) {
    while(*bAntiAFK) {
        std::this_thread::sleep_for(50s);
        if (*bAntiAFK) { // Checking if bAntiAFK hasn't been changed to false during this sleep.
            MakeMeaninglessMoves();
        }
    }
}
```

`Dainsleif/Hacks/AntiAFK.h`:

```h
#pragma once

namespace AntiAFK
{
    void Run(bool *bAntiAFK);
    void MakeMeaninglessMoves();
}
```

`Dainsleif/Hacks/AntiRecoil.cpp`:

```cpp
#include "../pch.h"
#include "../Player.h"
#include "AntiRecoil.h"

Vector3 oldPunch = { 0, 0, 0 };
int oldShotCount = 0;

void AntiRecoil::Run() {
    static const WeaponID rejectWeaponList[19] = { KNIFE, C4, GN_DECOY, GN_FLASH_, GN_HE, GN_MOLOTOV, GN_SMOKE, HG_GLOCK, HG_DUAL_BERETTAS, HG_P250, HG_TEC9,HG_DESERT_EAGLE,
                                                  SG_NOVA, SG_XM1014, SG_SAWED_OFF, SR_SSG08, SR_AWP, SR_G3SG1 };
    Player* localPlayer = Player::GetLocalPlayer();
    Weapon* activeWeapon = localPlayer->GetActiveWeapon();
    WeaponID activeWeaponID = activeWeapon->GetWeaponID();
    for (WeaponID rejW : rejectWeaponList) {
        if (rejW == activeWeaponID) {
            return;
        }
    }

    int shotCount = localPlayer->GetShotsFired();

    if (shotCount >= 1) {
        if (shotCount != oldShotCount) {
            //This refers to the cursor position after local player shot. Bullet's gonna be shot out over the cursor by twice.
            Vector3 aimPunchAngle = localPlayer->GetAimPunchAngle();
            Vector3* viewAngle = reinterpret_cast<Vector3*>(*reinterpret_cast<uintptr_t*>(Modules::engine + dwClientState) + dwClientState_ViewAngles);
            Vector3 rcsAngle{};
            rcsAngle.y = viewAngle->y + (oldPunch.y - aimPunchAngle.y * 2.f);
            rcsAngle.x = viewAngle->x + (oldPunch.x - aimPunchAngle.x * 2.f);

            viewAngle->Normalize();

            oldPunch.y = aimPunchAngle.y * 2.f;
            oldPunch.x = aimPunchAngle.x * 2.f;
            viewAngle->y = rcsAngle.y;
            viewAngle->x = rcsAngle.x;
            oldShotCount = shotCount;
        }
    }
    else {
        oldPunch = { 0, 0, 0 };
        oldShotCount = 0;
    }
}
```

`Dainsleif/Hacks/AntiRecoil.h`:

```h
#pragma once

namespace AntiRecoil {
    void Run();
}

```

`Dainsleif/Hacks/Bunnyhop.cpp`:

```cpp
#include "Bunnyhop.h"

void Bhop::ForceJump()
{
	auto* forceJump = reinterpret_cast<int*>(Modules::client + dwForceJump);
	*forceJump = 6;
}

void Bhop::Run()
{
	Player* localPlayer = Player::GetLocalPlayer();
	uintptr_t flags = localPlayer->GetFlags();
	if (flags & (1 << 0))
	{
		Bhop::ForceJump();
	}
}

```

`Dainsleif/Hacks/Bunnyhop.h`:

```h
#pragma once
#include "../pch.h"
#include "../Player.h"
#include "../dllmain.h"

namespace Bhop
{
	void Run();
	void ForceJump();
}
```

`Dainsleif/Hacks/Esp.cpp`:

```cpp
#include "Esp.h"
#include <optional>

std::optional<Vector2> WorldToScreen(Vector3 entPos, WindowSize& windowSize) {
    float viewMatrix[4][4];
    memcpy(&viewMatrix, (PBYTE*)(Modules::client + dwViewMatrix), sizeof(viewMatrix));
    Vector4 clipCoords{};
    clipCoords.x = entPos.x * viewMatrix[0][0] + entPos.y * viewMatrix[0][1] + entPos.z * viewMatrix[0][2] + viewMatrix[0][3];
    clipCoords.y = entPos.x * viewMatrix[1][0] + entPos.y * viewMatrix[1][1] + entPos.z * viewMatrix[1][2] + viewMatrix[1][3];
    clipCoords.z = entPos.x * viewMatrix[2][0] + entPos.y * viewMatrix[2][1] + entPos.z * viewMatrix[2][2] + viewMatrix[2][3];
    clipCoords.w = entPos.x * viewMatrix[3][0] + entPos.y * viewMatrix[3][1] + entPos.z * viewMatrix[3][2] + viewMatrix[3][3];

    if (clipCoords.w < 0.1f)
        return {};

    Vector3 NDC{};
    NDC.x = clipCoords.x / clipCoords.w;
    NDC.y = clipCoords.y / clipCoords.w;
    NDC.z = clipCoords.z / clipCoords.w;
    std::optional<Vector2> screen = Vector2{};
    screen->x = (windowSize.w / 2 * NDC.x) + (NDC.x + windowSize.w / 2);
    screen->y = -(windowSize.h / 2 * NDC.y) + (NDC.y + windowSize.h / 2);
    return screen;
}

void Esp::DrawLine(int x1, int y1, int x2, int y2, int thickness, D3DCOLOR color) {
    ID3DXLine* LineL;
    D3DXCreateLine(&this->pDevice, &LineL);

    D3DXVECTOR2 Line[2];
    Line[0] = D3DXVECTOR2(x1, y1);
    Line[1] = D3DXVECTOR2(x2, y2);
    LineL->SetWidth(thickness);
    LineL->Draw(Line, 2, color);
    LineL->Release();
}

void Esp::DrawOutLineRect(Vector2 top, Vector2 bottom, int thickness, D3DCOLOR color) {
    ID3DXLine* LineL;
    D3DXCreateLine(&this->pDevice, &LineL);

    float height = fabs(top.y - bottom.y);

    // apparently, height / 2 is the horizontal length of the rectangle.
    // top.x and bottom.x is located at the center of the entity
    // so x coordinate -(+) height / 4 should be the left and right end of the rectangle.
    D3DXVECTOR2 topLine[2] = {D3DXVECTOR2(top.x - height / 4, top.y), D3DXVECTOR2(top.x + height / 4, top.y)};
    D3DXVECTOR2 bottomLine[2] = {D3DXVECTOR2(bottom.x - height / 4, bottom.y), D3DXVECTOR2(bottom.x + height / 4, bottom.y)};
    D3DXVECTOR2 rightLine[2] = {D3DXVECTOR2(top.x + height / 4, top.y), D3DXVECTOR2(bottom.x + height / 4, bottom.y)};
    D3DXVECTOR2 leftLine[2] = {D3DXVECTOR2(top.x - height / 4, top.y), D3DXVECTOR2(bottom.x - height / 4, bottom.y)};

    LineL->SetWidth(thickness);
    LineL->Draw(topLine, 2, color);
    LineL->Draw(bottomLine, 2, color);
    LineL->Draw(rightLine, 2, color);
    LineL->Draw(leftLine, 2, color);
    LineL->Release();
}

void Esp::DrawFilledRect(Vector2 top, Vector2 bottom, D3DCOLOR color) {
    float height = fabs(top.y - bottom.y);

    LONG width = (static_cast<LONG>(bottom.x + height / 4)) - (static_cast<LONG>(top.x + height / 4));

    D3DRECT rect = {static_cast<LONG>(top.x + height / 4), static_cast<LONG>(top.y), static_cast<LONG>(bottom.x + height / 4), static_cast<LONG>(bottom.y)};
    this->pDevice.Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
}

void Esp::LineOverlay() {
    for (auto& player : this->playerList) {
        if (player->GetHealth() && !player->IsDormant()) {
            std::optional<Vector2> entFootPos2D = WorldToScreen(player->GetBodyPosition(), this->windowSize);
            if (entFootPos2D) {
                D3DCOLOR color;
                if (player->GetTeam() == this->localTeamNum)
                    color = D3DCOLOR_ARGB(255, 0, 255, 0);
                else
                    color = D3DCOLOR_ARGB(255, 255, 0, 0);
                DrawLine(entFootPos2D->x, entFootPos2D->y, windowSize.w / 2, windowSize.h, 2, color);
            }
        }
    }
}

void Esp::RectangleOverlay() {
    for (auto& player : this->playerList) {
        if (player->GetHealth() && !player->IsDormant()) {
            std::optional<Vector2> entHeadPos2D = WorldToScreen(player->GetBonePosition(), this->windowSize);
            std::optional<Vector2> entFootPos2D = WorldToScreen(player->GetBodyPosition(), this->windowSize);
            if (entHeadPos2D && entFootPos2D) {
                D3DCOLOR color;
                if (player->GetTeam() == this->localTeamNum)
                    color = D3DCOLOR_ARGB(255, 0, 255, 0);
                else
                    color = D3DCOLOR_ARGB(255, 255, 0, 0);
                DrawOutLineRect(*entHeadPos2D, *entFootPos2D, 1, color);
            }
        }
    }
}

void Esp::HealthOverlay() {
    for (auto& player : this->playerList) {
        if (player->GetHealth() && !player->IsDormant()) {
            std::optional<Vector2> entHeadPos2D = WorldToScreen(player->GetBonePosition(), this->windowSize);
            std::optional<Vector2> entFootPos2D = WorldToScreen(player->GetBodyPosition(), this->windowSize);
            if (entHeadPos2D && entFootPos2D) {
                this->DrawFilledRect(*entHeadPos2D, *entFootPos2D, D3DCOLOR_ARGB(255, 255, 51, 51));
            }
        }
    }
}
```

`Dainsleif/Hacks/Esp.h`:

```h
#pragma once
#include "../pch.h"
#include "../Player.h"
#include "../Hook/GraphicHook.h"
#include <optional>
#include <utility>

std::optional<Vector2> WorldToScreen(Vector3 entPos, WindowSize& windowSize);
class Esp {
    const int& localTeamNum;
    std::vector<Player*>& playerList;
    IDirect3DDevice9& pDevice;
    WindowSize& windowSize;

    void DrawOutLineRect(Vector2 top, Vector2 bottom, int thickness, D3DCOLOR color);
    void DrawLine(int x1, int y1, int x2, int y2, int thickness, D3DCOLOR color);
    void DrawFilledRect(Vector2 top, Vector2 bottom, D3DCOLOR color);

public:
    Esp(const int& localTeamNum, std::vector<Player*>& playerList, IDirect3DDevice9& pDevice, WindowSize& windowSize)
    : localTeamNum(localTeamNum), playerList(playerList), pDevice(pDevice), windowSize(windowSize){}

    void LineOverlay();
    void RectangleOverlay();
    void HealthOverlay();
};

```

`Dainsleif/Hacks/Glow.cpp`:

```cpp
#include "../pch.h"
#include "Glow.h"

ImVec4 enemyGlowColor, localGlowColor;

uintptr_t GetGlowObjectManager() {
    return *reinterpret_cast<uintptr_t*>(Modules::client + dwGlowObjectManager);
}

void Glow::Run(Player* player)
{
    uintptr_t glowObjectManager = GetGlowObjectManager();
    uintptr_t glowIndex = player->GetGlowIndex();
    GlowObject* glowObject = reinterpret_cast<GlowObject*>(glowObjectManager + (glowIndex * sizeof(GlowObject)));

    Player* localPlayer = Player::GetLocalPlayer();

    int teamNum = player->GetTeam();

    if (teamNum == localPlayer->GetTeam())
    {
        glowObject->r = localGlowColor.x;
        glowObject->g = localGlowColor.y;
        glowObject->b = localGlowColor.z;
        glowObject->a = localGlowColor.w;
    }
    else if (teamNum != localPlayer->GetTeam() && !player->IsDormant())
    {
        glowObject->r = enemyGlowColor.x;
        glowObject->g = enemyGlowColor.y;
        glowObject->b = enemyGlowColor.z;
        glowObject->a = enemyGlowColor.w;
    }
    glowObject->m_bRenderWhenOccluded = true; //If I set this to false, the entire glow disappear
    glowObject->m_bRenderWhenUnoccluded = false; //if i set this true, the damage indicater go out of the outline.
}
```

`Dainsleif/Hacks/Glow.h`:

```h
#pragma once
#include "../Player.h"

namespace Glow {
    void Run(Player* player);
}

struct GlowObject {
    int m_nNextFreeSlot;
    Entity* m_pEntity;
    float r;
    float g;
    float b;
    float a;
    bool m_bGlowAlphaCappedByRenderAlpha;
    std::byte pad0[0x3];
    float m_flGlowAlphaFunctionOfMaxVelocity;
    float m_flGlowAlphaMax;
    float m_flGlowPulseOverdrive;
    bool m_bRenderWhenOccluded;
    bool m_bRenderWhenUnoccluded;
    bool m_bFullBloomRender;
    std::byte pad1[0x1];
    int m_nFullBloomStencilTestValue;
    int m_nRenderStyle;
    int m_nSplitScreenSlot;
};
```

`Dainsleif/Hacks/MinimapHack.cpp`:

```cpp
#include "MinimapHack.h"

void Minimap::Run(std::vector<Player*> playerList) {
    for (auto& player : playerList) {
        player->WriteValue<bool>(m_bSpotted, true);
    }
}
```

`Dainsleif/Hacks/MinimapHack.h`:

```h
#pragma once
#include "../pch.h"
#include "../Player.h"

namespace Minimap
{
    void Run(std::vector<Player*> playerList);
    void Stop(std::vector<Player*> playerList);
}
```

`Dainsleif/Hacks/Triggerbot.cpp`:

```cpp
#include "../pch.h"
#include "Triggerbot.h"
#include "../dllmain.h"

void Triggerbot::Run()
{
    Player* localPlayer = Player::GetLocalPlayer();
    Weapon* weapon = localPlayer->GetActiveWeapon();
    WeaponID weaponId = weapon->GetWeaponID();
    static const WeaponID rejectWeaponList[8] = {KNIFE, C4, GN_DECOY, GN_FLASH_, GN_HE, GN_MOLOTOV, GN_SMOKE};
    for (auto& rejW : rejectWeaponList) {
        if (rejW == weaponId)
            return;
    }

    //if bFreeMouse is false, mouse move will set to be free.
    static bool bFreeMouse;
    auto* forceAttack = reinterpret_cast<int*>(Modules::client + dwForceAttack);
    int crosshairID = localPlayer->GetCrosshairID();
    if (crosshairID != 0) {
        //When you kill all enemy, it's somehow gonna be a number more than 300.

        Entity* target = Entity::GetByIndex(crosshairID - 1);
        if (target->GetClientClass()->m_ClassID == ClassID::CCSPlayer && localPlayer->GetTeam() != target->Cast<Player*>()->GetTeam())
        {
            bFreeMouse = false;
            if (HackFlags::bAimbot && *forceAttack == 4)
            {
                Sleep(60);
            }
            *forceAttack = 5;
        }
    }


    if (crosshairID == 0 && !bFreeMouse) {
        *forceAttack = 4;
        bFreeMouse = true;
    }
}
```

`Dainsleif/Hacks/Triggerbot.h`:

```h
#pragma once
#include "../Player.h"

namespace Triggerbot {
    void Run();
}

```

`Dainsleif/Hook/ControlCursor.cpp`:

```cpp
#include "ControlCursor.h"

#include "../Interfaces/CInterfaceList.h"
#include "../dllmain.h"

tLockCursor oLockCursor;

void __fastcall hLockCursor ( ISurface* surface, uintptr_t edx )
{
    if ( g_ShowMenu )
    {
        g_csgo.surface->UnlockCursor ( );
        return;
    }
    oLockCursor ( g_csgo.surface );
}

void HookLockCursor ( )
{
    void* lockCursor = Utils::GetVirtualFunction<void*>(g_csgo.surface, 67);
    if (MH_CreateHookEx(lockCursor, &hLockCursor, &oLockCursor) != MH_OK)
    {
        throw std::runtime_error("Failed to hook LockCursor!");
    }
}

```

`Dainsleif/Hook/ControlCursor.h`:

```h
#pragma once

#include "../Interfaces/ISurface.h"

using tLockCursor = void(__thiscall*) ( ISurface* );

void HookLockCursor ( );

```

`Dainsleif/Hook/DrawGUI.cpp`:

```cpp
#include "DrawGUI.h"
#include <map>
#include "../Player.h"
#include "../Save/OffsetsToml.h"
#include "GraphicHook.h"

extern int fov; //declared in dllmain.cpp
extern float aimSmoothness, range; //declared in Hacks/Aimbot.cpp
extern ImVec4 enemyGlowColor, localGlowColor;

extern bool inGame;
extern std::string offsetsFile; //declared in dllmain.cpp

void HelpMarker(const char* title, const std::string& desc)
{
    ImGui::TextDisabled("%s", title);
    if (ImGui::IsItemHovered())
    {
        ImGui::BeginTooltip();
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc.c_str());
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

bool show_updated_modal = false;

std::map<std::string, uintptr_t> UpdateOffsets() {
    OffsetsToml::Update(offsetsFile);
    std::map<std::string, uintptr_t> offsets = OffsetsToml::Fetch(offsetsFile);
    show_updated_modal = true;
    return offsets;
}

void ShowModal(const char* message) {
    ImGui::OpenPopup("Modal");

    // Always center this window when appearing
    ImVec2 center(ImGui::GetIO().DisplaySize.x * 0.5f, ImGui::GetIO().DisplaySize.y * 0.5f);
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

    if (ImGui::BeginPopupModal("Modal", NULL, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::Spacing();
        ImGui::Spacing();
        ImGui::TextColored((ImVec4)ImColor::HSV(0.57f, 0.6f, 0.8f), "%s", message);
        ImGui::Spacing();
        ImGui::Spacing();

        ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(0.57f, 0.6f, 0.6f));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(0.57f, 0.7f, 0.7f));
        ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(0.57f, 0.8f, 0.8f));
        if (ImGui::Button("OK", ImVec2(170, 0))) {
            ImGui::CloseCurrentPopup();
            show_updated_modal = false;
        }
        ImGui::PopStyleColor(3);
        ImGui::SetItemDefaultFocus();
        ImGui::EndPopup();
    }
}

/* NOTE: When a new element which manipulates a hack parameter is added to the menu, you have to modify following 4 places in this project.
         * Fetch() in OffsetsToml.cpp
         * Save() in OffsetsToml.cpp
         * setToDefault function
         * DefaultSettings.h
*/

void setToDefault(Hack_label label) {
    switch (label) {
        case ALL:
            HackFlags::bAimbot = Default::bAimbot;
            aimSmoothness = Default::aimSmoothness;
            range = Default::range;
            HackFlags::bGlowHack = Default::bGlowhack;
            enemyGlowColor = Default::enemyGlowColor;
            localGlowColor = Default::localGlowColor;
            HackFlags::bAntiRecoil = Default::bAntiRecoil;
            HackFlags::bTriggerBot = Default::bTriggerBot;
            HackFlags::bBunnyhop = Default::bBunnyhop;
            HackFlags::bAntiAFK = Default::bAntiAFK;
            HackFlags::bEsp = Default::bEsp;
            HackFlags::bLineOverlay = Default::bLineOverlay;
            HackFlags::bRectOverlay = Default::bRectOverlay;
            HackFlags:: bMinimapHack = Default::bMinimapHack;
            fov = Default::fov;
            break;
        case AIMBOT:
            HackFlags::bAimbot = Default::bAimbot;
            aimSmoothness = Default::aimSmoothness;
            range = Default::range;
            break;
        case GLOWHACK:
            HackFlags::bGlowHack = Default::bGlowhack;
            enemyGlowColor = Default::enemyGlowColor;
            localGlowColor = Default::localGlowColor;
            break;
        case ANTIRECOIL:
            HackFlags::bAntiRecoil = Default::bAntiRecoil;
            break;
        case TRIGGERBOT:
            HackFlags::bTriggerBot = Default::bTriggerBot;
            break;
        case BUNNYHOP:
            HackFlags::bBunnyhop = Default::bBunnyhop;
            break;
        case FOV:
            fov = Default::fov;
            break;
        case ANTIAFK:
            HackFlags::bAntiAFK = Default::bAntiAFK;
        case ESP:
            HackFlags::bEsp = Default::bEsp;
            HackFlags::bLineOverlay = Default::bLineOverlay;
            HackFlags::bRectOverlay = Default::bRectOverlay;
        case MINIMAPHACK:
            HackFlags::bMinimapHack = Default::bMinimapHack;
    }
}

void ShowMenuBar(std::map<std::string, bool>& visibleHacks)
{
    static std::map<std::string, uintptr_t> newOffsets;
    if(show_updated_modal) {
        std::string offsetString;
        offsetString.reserve(300); //allocating memory beforehand for performance reason.
        offsetString = "Updating offsets has done!\nNew offsets:\n\n";
        for (auto& offset : newOffsets) {
            offsetString += offset.first;
            offsetString += ": ";
            offsetString += std::to_string(offset.second);
            offsetString += "\n";
        }
        ShowModal(offsetString.data());
    }

    if (ImGui::BeginMenuBar()) {
        // Menu 1
        if (ImGui::BeginMenu("Menu")) {
            // First menu in Menu
            if (ImGui::BeginMenu("Set to default")) {
                if (ImGui::MenuItem("Everything")) {
                    setToDefault(ALL);
                } else if (ImGui::MenuItem("Aim bot")) {
                    setToDefault(AIMBOT);
                } else if (ImGui::MenuItem("Glow hack")){
                    setToDefault(GLOWHACK);
                } else if (ImGui::MenuItem("Anti recoil")) {
                    setToDefault(ANTIRECOIL);
                } else if (ImGui::MenuItem("Trigger bot")) {
                    setToDefault(TRIGGERBOT);
                } else if (ImGui::MenuItem("Bunnyhop")) {
                    setToDefault(BUNNYHOP);
                } else if (ImGui::MenuItem("Anti AFK")) {
                    setToDefault(ANTIAFK);
                } else if (ImGui::MenuItem("FOV")) {
                    setToDefault(FOV);
                } else if (ImGui::MenuItem("ESP")) {
                    setToDefault(ESP);
                } else if (ImGui::MenuItem("Minimap hack")) {
                    setToDefault(MINIMAPHACK);
                }
                ImGui::EndMenu();
            }
            if (ImGui::MenuItem("Update offsets")) {
                newOffsets = UpdateOffsets();
            }
            if (ImGui::MenuItem("Remove hack"))
                HackFlags::bQuit = true;
            ImGui::EndMenu();
        }
        // Menu 2
        if (ImGui::BeginMenu("Hacks")) {
            for (auto& [key, value] : visibleHacks) {
                ImGui::MenuItem(key.c_str(), NULL, &value);
            }
            ImGui::EndMenu();
        }
        ImGui::EndMenuBar();
    }
}

void ShowTabMenu(std::map<std::string, bool>& visibleHacks) {
    Player* localPlayer = Player::GetLocalPlayer();
    static ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_Reorderable;
    if (ImGui::BeginTabBar("Hack_tab_bar", tab_bar_flags))
    {
        if (ImGui::BeginTabItem("Aim bot", &visibleHacks.at("Aim Bot")))
        {
            ImGui::Checkbox("Enable Aim bot", &HackFlags::bAimbot);
            ImGui::SliderFloat("Smoothness", &aimSmoothness, 0.005f, 0.4f);
            ImGui::SliderFloat("Range", &range, 1.f, 30.f);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Glow hack", &visibleHacks.at("Glow Hack")))
        {
            ImGui::Checkbox("Enable Glow hack", &HackFlags::bGlowHack);
            ImGui::ColorEdit4("Enemy Color", (float*)&enemyGlowColor);
            ImGui::ColorEdit4("Teammate color", (float*)&localGlowColor);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Anti Recoil", &visibleHacks.at("Anti Recoil")))
        {
            ImGui::Checkbox("Enable Anti recoil", &HackFlags::bAntiRecoil);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Trigger bot", &visibleHacks.at("Trigger Bot")))
        {
            ImGui::Checkbox("Enable Trigger bot", &HackFlags::bTriggerBot);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Bunnyhop", &visibleHacks.at("Bunnyhop")))
        {
            ImGui::Checkbox("Enable Bunnyhop", &HackFlags::bBunnyhop);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Anti AFK", &visibleHacks.at("Anti AFK")))
        {
            ImGui::Checkbox("Enable AntiAFK", &HackFlags::bAntiAFK);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Field of View", &visibleHacks.at("Fov")))
        {
            ImGui::SliderInt("Field of view(FOV)", &fov, 60, 120);
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("ESP           ", &visibleHacks.at("Esp")))
        {
            ImGui::Checkbox("Enable ESP", &HackFlags::bEsp);
            if (HackFlags::bEsp) {
                ImGui::Checkbox("Enable Line overlay", &HackFlags::bLineOverlay);
                ImGui::Checkbox("Enable Rectangle overlay", &HackFlags::bRectOverlay);
            }
            ImGui::EndTabItem();
        }
        if (ImGui::BeginTabItem("Minimap hack", &visibleHacks.at("Minimap Hack")))
        {
            ImGui::Checkbox("Enable Minimap hack", &HackFlags::bMinimapHack);
            ImGui::EndTabItem();
        }

    }
        ImGui::EndTabBar();
}
```

`Dainsleif/Hook/DrawGUI.h`:

```h
#pragma once

#include <string>
#include <map>

enum Hack_label {
    ALL,
    AIMBOT,
    GLOWHACK,
    ANTIRECOIL,
    TRIGGERBOT,
    BUNNYHOP,
    ANTIAFK,
    FOV,
    ESP,
    MINIMAPHACK
};

void ShowMenuBar(std::map<std::string, bool>& visibleHacks);
void ShowTabMenu(std::map<std::string, bool>& visibleHacks);
void HelpMarker(const char* title, const std::string& desc);

```

`Dainsleif/Hook/GraphicHook.cpp`:

```cpp
#include "GraphicHook.h"

#include "../Interfaces/CInterfaceList.h"
#include "../Hacks/Esp.h"
#include "../dllmain.h"

namespace HackFlags
{
    bool bEsp, bLineOverlay, bRectOverlay;
}

extern bool inGame; //decleard in dllmain.cpp

extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler ( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam );

using FnEndScene = HRESULT (__stdcall*)(IDirect3DDevice9* pDevice);
FnEndScene originalEndScene = nullptr; //An original endscene which is null now.

using FnReset = HRESULT (__stdcall*)(IDirect3DDevice9* pDevice, D3DPRESENT_PARAMETERS* pPresentationParameters);
FnReset originalReset = nullptr;

HWND window = nullptr;
WNDPROC originalWndProc = nullptr;

LRESULT WINAPI WndProc ( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    if ( g_ShowMenu )
    {
        if ( ImGui_ImplWin32_WndProcHandler ( hWnd, msg, wParam, lParam ) )
            return true;
        
        if ( g_csgo.engine->IsActiveApp ( ) )
        {
            switch ( msg )
            {
            case WM_KEYDOWN:
            case WM_KEYUP:
            case WM_MOUSEHWHEEL:
            case WM_MOUSEACTIVATE:
            case WM_MOVE:
            case WM_MOVING:
            case WM_MOUSEMOVE:
            case WM_NCMOUSEMOVE:
            case WM_SYSKEYDOWN:
            case WM_SYSKEYUP:
            case WM_CHAR:
            case WM_DEADCHAR:
            case WM_SYSCHAR:
            case WM_SYSDEADCHAR:
            case WM_RBUTTONUP:
            case WM_LBUTTONDOWN:
            case WM_LBUTTONUP:
            case WM_LBUTTONDBLCLK:
            case WM_RBUTTONDOWN:
            case WM_RBUTTONDBLCLK:
            case WM_MBUTTONDOWN:
            case WM_MBUTTONUP:
            case WM_MBUTTONDBLCLK:
            case WM_MOUSEWHEEL:
                return 0;

            default: ;
            }
        }
    }
    return CallWindowProc ( originalWndProc, hWnd, msg, wParam, lParam );
}

void InitImGui ( IDirect3DDevice9* pDevice )
{
    IMGUI_CHECKVERSION ( );
    ImGui::CreateContext ( );
    ImGui::CreateContext ( );
    ImGuiIO& io = ImGui::GetIO ( );
    LoadFont ( io );

    ImGui::StyleColorsDark ( );

    ImGui_ImplWin32_Init ( window );
    ImGui_ImplDX9_Init ( pDevice );
}

void ShutdownImGui ( )
{
    ImGui_ImplDX9_Shutdown ( );
    ImGui_ImplWin32_Shutdown ( );
    ImGui::DestroyContext ( );
}

WindowSize GetWindowSize ( )
{
    RECT size;
    WindowSize windowSize{ };
    GetWindowRect ( window, &size );
    windowSize.w = size.right - size.left;
    windowSize.w -= 5; //removing pixels sidebar has.
    windowSize.h = size.bottom - size.top;
    windowSize.h -= 29; //removing pixels topbar has.
    return windowSize;
}

extern std::map< std::string, bool > visibleHacks;

HRESULT __stdcall HookedEndScene ( IDirect3DDevice9* pDevice ) //A function containing a bunch of rendering process, that is gonna be hooked.
{
    static Player* oldLocalPlayer = nullptr;
    Player* localPlayer = Player::GetLocalPlayer ( );
    int gameState = *reinterpret_cast< int* > ( *reinterpret_cast< uintptr_t* > ( Modules::engine + dwClientState ) + dwClientState_State );

    if ( localPlayer != oldLocalPlayer && localPlayer && HackFlags::bEsp )
    {
        std::vector< Player* > playerList = Player::GetAll ( );
        WindowSize ws = GetWindowSize ( );
        Esp esp = Esp ( localPlayer->GetTeam ( ), playerList, *pDevice, ws );
        if ( HackFlags::bLineOverlay )
        {
            esp.LineOverlay ( );
        }

        if ( HackFlags::bRectOverlay )
            esp.RectangleOverlay ( );
    }

    if ( gameState != 6 && inGame )
    {
        oldLocalPlayer = localPlayer;
        inGame = false;
    }


    if ( g_ShowMenu )
    {
        ImGui_ImplDX9_NewFrame ( );
        ImGui_ImplWin32_NewFrame ( );
        ImGui::NewFrame ( );

        LoadTheme ( );

        ImGuiWindowFlags window_flags = ImGuiWindowFlags_MenuBar;
        ImGui::Begin ( "Dainsleif", &g_ShowMenu, window_flags );

        ShowMenuBar ( visibleHacks ); //tab

        ShowTabMenu ( visibleHacks ); //main view


        ImGui::Separator ( );
        ImGui::Spacing ( );
        ImGui::Spacing ( );
        ImGui::Spacing ( );
        HelpMarker ( "[HACK NOT WORKING?]", "Click \"Update offset\" in the menu bar" );
        ImGui::End ( );

        ImGui::EndFrame ( );
        ImGui::Render ( );
        ImGui_ImplDX9_RenderDrawData ( ImGui::GetDrawData ( ) );
    }
    return originalEndScene ( pDevice );
}

HRESULT __stdcall HookedReset(IDirect3DDevice9* pDevice, D3DPRESENT_PARAMETERS* pPresentationParameters) {
    ImGui_ImplDX9_InvalidateDeviceObjects();

    HRESULT result = originalReset(pDevice, pPresentationParameters);
    if (result == D3D_OK)
    {
        ImGui_ImplDX9_CreateDeviceObjects();
    }

    return result;
}

void InitializeGraphicHook ( )
{
    auto shaderapidx9 = reinterpret_cast< uintptr_t > ( GetModuleHandle ( "shaderapidx9.dll" ) );
    IDirect3DDevice9* pDevice = *reinterpret_cast< IDirect3DDevice9** > ( shaderapidx9 + dwppDirect3DDevice9 );

    D3DDEVICE_CREATION_PARAMETERS parameters;
    pDevice->GetCreationParameters ( &parameters );

    window = parameters.hFocusWindow;
    originalWndProc = reinterpret_cast< WNDPROC > ( SetWindowLongPtr ( window, GWLP_WNDPROC, reinterpret_cast< LONG_PTR > ( WndProc ) ) );

    InitImGui ( pDevice );

    void* endScene = Utils::GetVirtualFunction<void*>(pDevice, 42);
    if (MH_CreateHookEx(endScene, &HookedEndScene, &originalEndScene) != MH_OK)
    {
        throw std::runtime_error("Failed to hook EndScene!");
    }

    void* reset = Utils::GetVirtualFunction<void*>(pDevice, 16);
    if (MH_CreateHookEx(reset, &HookedReset, &originalReset) != MH_OK)
    {
        throw std::runtime_error("Failed to hook Reset!");
    }
}

void ShutDownGraphicHook ( )
{
    SetWindowLong ( window, GWL_WNDPROC, reinterpret_cast< LONG > ( originalWndProc ) );

    ShutdownImGui ( );
}

```

`Dainsleif/Hook/GraphicHook.h`:

```h
#pragma once
#include "../pch.h"
#include "ImGuiTheme.h"
#include "GraphicHook.h"
#include "DrawGUI.h"
#include <map>

namespace HackFlags {
    extern bool bEsp, bLineOverlay, bRectOverlay;
}

struct WindowSize {
    int w;
    int h;
};

void InitializeGraphicHook();
void ShutDownGraphicHook();

extern std::map<std::string, bool> visibleHacks;
```

`Dainsleif/Hook/Hooks.cpp`:

```cpp
#include "Hooks.h"
#include <stdexcept>
#include <MinHook.h>
#include "ControlCursor.h"
#include "GraphicHook.h"
#include "../Interfaces/CInterfaceList.h"
#include "../Utils.h"
#include "../Player.h"

extern int fov; //declared in dllmain.cpp

namespace Hooks
{
    using FnOverrideView = void (__thiscall*)(IClientModeShared* clientMode, ViewSetup* setup);
    FnOverrideView originalOverrideView = nullptr;

    void __fastcall HookedOverrideView(IClientModeShared* clientMode, int edx, ViewSetup* setup)
    {
        Player* localPlayer = Player::GetLocalPlayer();
        if (!localPlayer || localPlayer->isScoped()) {
            originalOverrideView(clientMode, setup);
            return;
        }

        setup->m_flFOV = fov;
        originalOverrideView(clientMode, setup);
    }

    void Initialize()
    {
        if (MH_Initialize() != MH_OK)
        {
            throw std::runtime_error("Failed to initialize minhook!");
        }

        InitializeGraphicHook();
        HookLockCursor();

        void* overrideView = Utils::GetVirtualFunction<void*>(g_csgo.clientMode, 18);
        if (MH_CreateHookEx(overrideView, &HookedOverrideView, &originalOverrideView) != MH_OK)
        {
            throw std::runtime_error("Failed to hook OverrideView!");
        }

        if (MH_EnableHook(MH_ALL_HOOKS) != MH_OK)
        {
            throw std::runtime_error("Failed to enable hooks!");
        }
    }

    void Restore()
    {
        if (MH_DisableHook(MH_ALL_HOOKS) != MH_OK)
        {
            throw std::runtime_error("Failed to disable hooks!");
        }

        ShutDownGraphicHook();

        if (MH_Uninitialize() != MH_OK)
        {
            throw std::runtime_error("Failed to uninitialize minhook!");
        }
    }
}
```

`Dainsleif/Hook/Hooks.h`:

```h
#pragma once

namespace Hooks
{
    void Initialize();
    void Restore();
}
```

`Dainsleif/Hook/ImGuiTheme.cpp`:

```cpp
//
// Created by PC on 2020/07/31.
//
#include "imgui.h"

void LoadTheme() {
    ImGuiStyle * style = &ImGui::GetStyle();

    style->WindowPadding = ImVec2(15, 15);
    style->WindowRounding = 5.0f;
    style->FramePadding = ImVec2(5, 5);
    style->FrameRounding = 4.0f;
    style->ItemSpacing = ImVec2(12, 8);
    style->ItemInnerSpacing = ImVec2(8, 6);
    style->IndentSpacing = 25.0f;
    style->ScrollbarSize = 15.0f;
    style->ScrollbarRounding = 9.0f;
    style->GrabMinSize = 5.0f;
    style->GrabRounding = 3.0f;

    style->Colors[ImGuiCol_Text] = ImVec4(0.80f, 0.80f, 0.83f, 1.00f);
    style->Colors[ImGuiCol_TextDisabled] = ImVec4(0.24f, 0.23f, 0.29f, 1.00f);
    style->Colors[ImGuiCol_WindowBg] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f);
    style->Colors[ImGuiCol_PopupBg] = ImVec4(0.07f, 0.07f, 0.09f, 1.00f);
    style->Colors[ImGuiCol_Border] = ImVec4(0.80f, 0.80f, 0.83f, 0.88f);
    style->Colors[ImGuiCol_BorderShadow] = ImVec4(0.92f, 0.91f, 0.88f, 0.00f);
    style->Colors[ImGuiCol_FrameBg] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f);
    style->Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.24f, 0.23f, 0.29f, 1.00f);
    style->Colors[ImGuiCol_FrameBgActive] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f);
    style->Colors[ImGuiCol_TitleBg] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f);
    style->Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.00f, 0.98f, 0.95f, 0.75f);
    style->Colors[ImGuiCol_TitleBgActive] = ImVec4(0.07f, 0.07f, 0.09f, 1.00f);
    style->Colors[ImGuiCol_MenuBarBg] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f);
    style->Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f);
    style->Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.80f, 0.80f, 0.83f, 0.31f);
    style->Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f);
    style->Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f);
    style->Colors[ImGuiCol_CheckMark] = ImVec4(0.80f, 0.80f, 0.83f, 0.31f);
    style->Colors[ImGuiCol_SliderGrab] = ImVec4(0.80f, 0.80f, 0.83f, 0.31f);
    style->Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f);
    style->Colors[ImGuiCol_Button] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f);
    style->Colors[ImGuiCol_ButtonHovered] = ImVec4(0.24f, 0.23f, 0.29f, 1.00f);
    style->Colors[ImGuiCol_ButtonActive] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f);
    style->Colors[ImGuiCol_Header] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f);
    style->Colors[ImGuiCol_HeaderHovered] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f);
    style->Colors[ImGuiCol_HeaderActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f);
    style->Colors[ImGuiCol_ResizeGrip] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    style->Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f);
    style->Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f);
    style->Colors[ImGuiCol_PlotLines] = ImVec4(0.40f, 0.39f, 0.38f, 0.63f);
    style->Colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.25f, 1.00f, 0.00f, 1.00f);
    style->Colors[ImGuiCol_PlotHistogram] = ImVec4(0.40f, 0.39f, 0.38f, 0.63f);
    style->Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.25f, 1.00f, 0.00f, 1.00f);
    style->Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.25f, 1.00f, 0.00f, 0.43f);
    style->Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(1.00f, 0.98f, 0.95f, 0.73f);
}

void LoadFont(ImGuiIO io) {
    io.Fonts->AddFontFromFileTTF("C:/Windows/Fonts/calibrib.ttf", 13);
    io.Fonts->AddFontFromFileTTF("C:/Windows/Fonts/calibrib.ttf", 11);
    io.Fonts->AddFontFromFileTTF("C:/Windows/Fonts/calibrib.ttf", 15);
    io.Fonts->AddFontFromFileTTF("C:/Windows/Fonts/calibrib.ttf", 19);
}
```

`Dainsleif/Hook/ImGuiTheme.h`:

```h
//
// Created by PC on 2020/07/31.
//

#include "imgui.h"

void LoadTheme();
void LoadFont(ImGuiIO io);
```

`Dainsleif/Interfaces/CInput.h`:

```h
#pragma once
#include "../Utils.h"
#include "../Vector.h"

class CUserCmd;
struct CVerifiedUserCmd;

class CInput
{
public:
    void* vTable;
    bool trackIrAvailable;
    bool mouseInitialized;
    bool mouseActive;
    bool joyStickAdvancedInit;
    char m_pad_0x08[ 0x2C ];
    void* keys;
    char m_pad_0x38[ 0x64 ];
    int m_pad_0x41;
    int m_pad_0x42;
    int m_pad_0x43;
    int m_pad_0x44;
    bool cameraInterceptingMouse;
    bool cameraInThirdperson;
    bool cameraMovingWithMouse;
    Vector3 cameraOffset;
    bool cameraDistanceMove;
    int cameraOldX;
    int cameraOldY;
    int cameraX;
    int cameraY;
    bool cameraIsOrthographic;
    Vector3 previousViewAngles;
    Vector3 previousViewAnglesTilt;
    float lastForwardMove;
    int clearInputState;
    CUserCmd* userCommands;
    CVerifiedUserCmd* verifiedUserCommands;

    CALL_VFUNC(39, ResetInputState(), void(__thiscall*)(CInput*)) ()
};

```

`Dainsleif/Interfaces/CInterfaceList.cpp`:

```cpp
#include "CInterfaceList.h"

CInterfaceList g_csgo;

void CInterfaceList::Initialize ( )
{
    const fnCreateInterface clientFactory = GetModuleFactory(GetModuleHandleA("client.dll"));
    const fnCreateInterface engineFactory = GetModuleFactory ( GetModuleHandleA ( "engine.dll" ) );
    const fnCreateInterface surfaceFactory = GetModuleFactory ( GetModuleHandleA ( "vguimatsurface.dll" ) );

    client = GetInterface<IBaseClientDll>(clientFactory, "VClient018");
    clientMode = **reinterpret_cast<IClientModeShared***>(Utils::GetVirtualFunction<std::uintptr_t>(client, 10) + 0x5); //CHLClient::HudProcessInput + 0x5
    engine = GetInterface< IVEngineClient > ( engineFactory, "VEngineClient014" );
    surface = GetInterface< ISurface > ( surfaceFactory, "VGUI_Surface031" );

#if _DEBUG
    PrintInterfaces ( );
#endif
}

```

`Dainsleif/Interfaces/CInterfaceList.h`:

```h
#pragma once
#include "../pch.h"

#include "IBaseClientDll.h"
#include "IClientModeShared.h"
#include "IVEngineClient.h"
#include "ISurface.h"
#include "CInput.h"

#define PRINT_INTERFACE(inter) std::cout << #inter << ": " << "0x" << ##inter << "\n";

class CInterfaceList
{
public:
    void Initialize ( );
public:
    IBaseClientDll* client = nullptr;
    IClientModeShared* clientMode = nullptr;
    IVEngineClient* engine = nullptr;
    ISurface* surface = nullptr;
    CInput* input = nullptr;
private:
    using fnCreateInterface = void*(*) ( const char*, int* );
private:
    template < typename T >
    static T* GetInterface ( const fnCreateInterface createInterface, const std::string_view& version )
    {
        return static_cast< T* > ( createInterface ( version.data ( ), nullptr ) );
    }

    static fnCreateInterface GetModuleFactory ( const HMODULE mod )
    {
        return reinterpret_cast< fnCreateInterface > ( GetProcAddress ( mod, "CreateInterface" ) );
    }

    __forceinline void PrintInterfaces ( )
    {
        PRINT_INTERFACE(client);
        PRINT_INTERFACE(clientMode);
        PRINT_INTERFACE ( engine );
        PRINT_INTERFACE ( surface );
        PRINT_INTERFACE ( input );
    }
};

extern CInterfaceList g_csgo;

```

`Dainsleif/Interfaces/IBaseClientDll.h`:

```h
#pragma once

class IBaseClientDll
{
public:

};

```

`Dainsleif/Interfaces/IClientModeShared.h`:

```h
#pragma once
#include "../Vector.h"

class IClientModeShared
{
public:

};

struct ViewSetup
{
    int m_iX;
    int m_iUnscaledX;
    int m_iY;
    int m_iUnscaledY;
    int m_iWidth;
    int m_iUnscaledWidth;
    int m_iHeight;
    int m_iUnscaledHeight;
    bool m_bOrtho;
    float m_flOrthoLeft;
    float m_flOrthoTop;
    float m_flOrthoRight;
    float m_flOrthoBottom;
    std::byte m_pad0[0x7C];
    float m_flFOV;
    float m_flViewModelFOV;
    Vector3 m_vecOrigin;
    Vector3 m_angView;
    float m_flNearZ;
    float m_flFarZ;
    float m_flNearViewmodelZ;
    float m_flFarViewmodelZ;
    float m_flAspectRatio;
    float m_flNearBlurDepth;
    float m_flNearFocusDepth;
    float m_flFarFocusDepth;
    float m_flFarBlurDepth;
    float m_flNearBlurRadius;
    float m_flFarBlurRadius;
    float m_flDoFQuality;
    int m_nMotionBlurMode;
    float m_flShutterTime;
    Vector3 m_vecShutterOpenPosition;
    Vector3 m_vecShutterOpenAngles;
    Vector3 m_vecShutterClosePosition;
    Vector3 m_vecShutterCloseAngles;
    float m_flOffCenterTop;
    float m_flOffCenterBottom;
    float m_flOffCenterLeft;
    float m_flOffCenterRight;
    bool m_bOffCenter : 1;
    bool m_bRenderToSubrectOfLargerScreen : 1;
    bool m_bDoBloomAndToneMapping : 1;
    bool m_bDoDepthOfField : 1;
    bool m_bHDRTarget : 1;
    bool m_bDrawWorldNormal : 1;
    bool m_bCullFontFaces : 1;
    bool m_bCacheFullSceneState : 1;
    bool m_bCSMView : 1;
};

```

`Dainsleif/Interfaces/ISurface.h`:

```h
#pragma once
#include "../Utils.h"

class ISurface
{
public:
    CALL_VFUNC ( 66, UnlockCursor(), void(__thiscall*)(ISurface*) ) ( )
};

```

`Dainsleif/Interfaces/IVEngineClient.h`:

```h
#pragma once

#include "../Utils.h"

class IVEngineClient
{
public:
    CALL_VFUNC ( 196, IsActiveApp(), bool(__thiscall*)(IVEngineClient*) ) ( );
};

```

`Dainsleif/Modules.cpp`:

```cpp
#include "Modules.h"
#include <Windows.h>

namespace Modules
{
    uintptr_t client;
    uintptr_t engine;

    void Initialize()
    {
        client = reinterpret_cast<uintptr_t>(GetModuleHandle("client.dll"));
        engine = reinterpret_cast<uintptr_t>(GetModuleHandle("engine.dll"));
    }
}
```

`Dainsleif/Modules.h`:

```h
#pragma once
#include <cstdint>

namespace Modules
{
    extern uintptr_t client;
    extern uintptr_t engine;

    void Initialize();
}
```

`Dainsleif/Offsets.cpp`:

```cpp
#include <iostream>

uintptr_t dwClientState;
uintptr_t dwClientState_State;
uintptr_t dwClientState_MaxPlayer;
uintptr_t dwClientState_ViewAngles;
uintptr_t dwppDirect3DDevice9;
uintptr_t dwEntityList;
uintptr_t dwLocalPlayer;
uintptr_t dwGlowObjectManager;
uintptr_t dwForceAttack;
uintptr_t dwForceForward;
uintptr_t dwForceBackward;
uintptr_t dwForceRight;
uintptr_t dwForceLeft;
uintptr_t dwForceJump;
uintptr_t dwViewMatrix;

uintptr_t m_vecOrigin;
uintptr_t m_iHealth;
uintptr_t m_fFlags;
uintptr_t m_vecViewOffset;
uintptr_t m_dwBoneMatrix;
uintptr_t m_iTeamNum;
uintptr_t m_iGlowIndex;
uintptr_t m_aimPunchAngle;
uintptr_t m_iShotsFired;
uintptr_t m_iCrosshairId;
uintptr_t m_iFOV;
uintptr_t m_bDormant;
uintptr_t m_hActiveWeapon;
uintptr_t m_iItemDefinitionIndex;
uintptr_t m_bSpotted;
uintptr_t m_bIsScoped;

```

`Dainsleif/Offsets.h`:

```h
#pragma once

extern uintptr_t dwppDirect3DDevice9;
extern uintptr_t dwEntityList;
extern uintptr_t dwLocalPlayer;
extern uintptr_t dwGlowObjectManager;
extern uintptr_t dwForceAttack;
extern uintptr_t dwForceForward;
extern uintptr_t dwForceBackward;
extern uintptr_t dwForceRight;
extern uintptr_t dwForceLeft;
extern uintptr_t dwForceJump;
extern uintptr_t dwViewMatrix;

extern uintptr_t m_vecOrigin;
extern uintptr_t m_iHealth;
extern uintptr_t m_fFlags;
extern uintptr_t m_vecViewOffset;
extern uintptr_t m_dwBoneMatrix;
extern uintptr_t m_iTeamNum;
extern uintptr_t m_iGlowIndex;
extern uintptr_t m_aimPunchAngle;
extern uintptr_t m_iShotsFired;
extern uintptr_t m_iCrosshairId;
extern uintptr_t m_iFOV;
extern uintptr_t m_bDormant;
extern uintptr_t m_hActiveWeapon;
extern uintptr_t m_iItemDefinitionIndex;
extern uintptr_t dwClientState;
extern uintptr_t dwClientState_State;
extern uintptr_t dwClientState_MaxPlayer;
extern uintptr_t dwClientState_ViewAngles;
extern uintptr_t m_bSpotted;
extern uintptr_t m_bIsScoped;

```

`Dainsleif/PatternScanner.cpp`:

```cpp
#include "PatternScanner.h"
#include <optional>

//FindPattern expects an input like this -> \x0F\x11\x05????\x83\xC8\x01
//For example: BB [0C45572F] 83 FF 01 -> offset should be 1. offset has to be the number of byte before address we need.
std::optional<uintptr_t> PatternScanner::FindPattern()
{
    HMODULE hModule = GetModuleHandle(this->moduleName);
    if (!hModule)
        return std::nullopt;
    MODULEINFO moduleInfo;
    if (!GetModuleInformation(GetCurrentProcess(), hModule, &moduleInfo, sizeof(moduleInfo)))
        return std::nullopt;

    auto beginningOfModule = static_cast<const char*>(moduleInfo.lpBaseOfDll);
    const auto end = beginningOfModule + moduleInfo.SizeOfImage; //This is the last element of beginningOfModule array.

    auto current = beginningOfModule;
    auto patternCopy = this->pattern;

    while (current < end && *patternCopy) {
        //*current refers to the each element of current array and basically cycle through the char array to check if they are matched.
        if (*current == *patternCopy || *patternCopy == '?') {
            ++current;
            ++patternCopy;
        } else {
            current = ++beginningOfModule; //increment beginningOfModule value and assign to current
            patternCopy = this->pattern; //"pattern" variable holds the original value of pattern.
        }
    }

    // If nothing found, return optional containing nothing
    if (beginningOfModule == end){
        return std::nullopt;
    }

    //back to the address of where current was located by subtracting the length of original pattern.
    current -= strlen(this->pattern);

    return *reinterpret_cast<uintptr_t*>(reinterpret_cast<uintptr_t>(current) + this->offset);
}

//Sometimes desired pointer is not illustrated in the module, so find an address which is located near desired one, and add extra bytes to reach the address.
uintptr_t PatternScanner::CalculateOffset(uintptr_t base, int extra) {
    std::optional<uintptr_t> o_pattern = FindPattern();
    if (o_pattern) {
        return o_pattern.value() - base + extra;
    } else {
        return 0000000;
    }
}
```

`Dainsleif/PatternScanner.h`:

```h
#pragma once
#include <iostream>
#include <Windows.h>
#include <Psapi.h>
#include <optional>

class PatternScanner {
    char* moduleName;
    const char* pattern;
    int offset;

    //FindPattern basically find passed pattern and return the 4 bytes address.
    std::optional<uintptr_t> FindPattern();
public:
    PatternScanner(char* moduleName, const char* pattern, int offset)
    : moduleName(moduleName), pattern(pattern), offset(offset)
    {
    }

    uintptr_t CalculateOffset(uintptr_t base, int extra);
};
```

`Dainsleif/Player.cpp`:

```cpp
#include "pch.h"
#include "Player.h"

Player* Player::GetLocalPlayer()
{
    return *reinterpret_cast<Player**>(Modules::client + dwLocalPlayer);
}

std::vector<Player*> Player::GetAll()
{
    std::vector<Player*> allPlayers;
    for (int i = 1; i <= GetMaxPlayers(); i++)
    {
        Entity* entity = Entity::GetByIndex(i);
        if (!entity || entity->GetClientClass()->m_ClassID != ClassID::CCSPlayer)
        {
            continue;
        }

        Player* player = entity->Cast<Player*>();
        allPlayers.push_back(player);
    }
    return allPlayers;
}

// FilterOutIrrelevant basically filter out the dead enemies and allies from playerList.
void FilterOutIrrelevant(std::vector<Player*>& playerList, Player* localPlayer)
{
    for (int i = 0;i < static_cast<int>(playerList.size());) {
        if (playerList[i]->GetTeam() == localPlayer->GetTeam() || !playerList[i]->GetHealth()) {
            playerList.erase(playerList.begin() + i);
        } else {
            ++i;
        }
    }
}

std::vector<Player*> Player::GetLivingOpponents() {
    Player* localPlayer = GetLocalPlayer();
    std::vector<Player*> playerList = GetAll();
    FilterOutIrrelevant(playerList, localPlayer);
    return playerList;
}

int Player::GetMaxPlayers()
{
    uintptr_t clientState = *reinterpret_cast<uintptr_t*>(Modules::engine + dwClientState);
    return *reinterpret_cast<int*>(clientState + dwClientState_MaxPlayer);
}

uintptr_t Player::GetBoneMatrix()
{
    return ReadValue<uintptr_t>(m_dwBoneMatrix);
}

uintptr_t Player::GetGlowIndex()
{
    return ReadValue<uintptr_t>(m_iGlowIndex);
}

Vector3 Player::GetBodyPosition()
{
    return ReadValue<Vector3>(m_vecOrigin);
}

Vector3 Player::GetViewOffset()
{
    return ReadValue<Vector3>(m_vecViewOffset);
}

Vector3 Player::GetAimPunchAngle()
{
    return ReadValue<Vector3>(m_aimPunchAngle);
}

#define boneID 8
Vector3 Player::GetBonePosition()
{
    uintptr_t boneMatrix = GetBoneMatrix();
    if (!boneMatrix) //When the game starts with bAimbot on, the game is gonna crash.
    {
        return {};
    }
    return {*reinterpret_cast<float*>(boneMatrix + 0x30 * boneID + 0x0C),
            *reinterpret_cast<float*>(boneMatrix + 0x30 * boneID + 0x1C),
            *reinterpret_cast<float*>(boneMatrix + 0x30 * boneID + 0x2C)};
}

Vector3 Player::GetHeadPosition()
{
    return GetBodyPosition() + GetViewOffset();
}

int Player::GetHealth()
{
    return ReadValue<int>(m_iHealth);
}

int Player::GetTeam()
{
    return ReadValue<int>(m_iTeamNum);
}

int Player::GetShotsFired()
{
    return ReadValue<int>(m_iShotsFired);
}

int Player::GetCrosshairID()
{
    return ReadValue<int>(m_iCrosshairId);
}

Weapon* Player::GetActiveWeapon()
{
    uintptr_t activeWeaponHandle = ReadValue<uintptr_t>(m_hActiveWeapon);
    int index = (activeWeaponHandle & 0xFFF) - 1;
    return Entity::GetByIndex(index)->Cast<Weapon*>();
}

void Player::SetFOV(int fov)
{
    if (this)
        WriteValue<int>(m_iFOV, fov);
}

uintptr_t Player::GetFlags()
{
    uintptr_t flags = ReadValue<uintptr_t>(m_fFlags);
    return flags;
}

bool Player::isScoped()
{
    return ReadValue<bool>(m_bIsScoped);
}

```

`Dainsleif/Player.h`:

```h
#pragma once
#include "pch.h"
#include "Entity.h"
#include "Weapon.h"

class Player : public Entity
{
public:
    static Player* GetLocalPlayer();

    static std::vector<Player*> GetAll();

    static std::vector<Player*> GetLivingOpponents();

    static int GetMaxPlayers();

    uintptr_t GetBoneMatrix();

    uintptr_t GetGlowIndex();

    //GetBodyPosition retrieves where player's body is as vector3.
    Vector3 GetBodyPosition();

    //GetViewOffset returns the distance between the body position and the actual sight of player.
    Vector3 GetViewOffset();

    Vector3 GetAimPunchAngle();


    Vector3 GetBonePosition();

    //GetHeadPosition calculates head position by view offset and body position.
	Vector3 GetHeadPosition();

    //GetHealth retrieves player's health.
    int GetHealth();

    //GetTeam returns teamNumber so that I can distinguish either the player is friendly or hostile.
    int GetTeam();

    int GetShotsFired();

    int GetCrosshairID();

    Weapon* GetActiveWeapon();

    void SetFOV(int fov);

    uintptr_t GetFlags();

    bool isScoped();
};
```

`Dainsleif/Save/OffsetsToml.cpp`:

```cpp
#include "OffsetsToml.h"

std::map<std::string, uintptr_t> OffsetsToml::Fetch(std::string& filename) {
    auto saveData = toml::parse(filename);
    dwClientState = toml::find_or(saveData, "dwClientState", dwClientState);
    dwEntityList = toml::find_or(saveData, "dwEntityList", dwEntityList);
    dwLocalPlayer = toml::find_or(saveData, "dwLocalPlayer", dwLocalPlayer);
    dwGlowObjectManager = toml::find_or(saveData, "dwGlowObjectManager", dwGlowObjectManager);
    dwForceAttack = toml::find_or(saveData, "dwForceAttack", dwForceAttack);
    dwForceForward = toml::find_or(saveData, "dwForceForward", dwForceForward);
    dwForceBackward = toml::find_or(saveData, "dwForceBackward", dwForceBackward);
    dwForceRight = toml::find_or(saveData, "dwForceRight", dwForceRight);
    dwForceLeft = toml::find_or(saveData, "dwForceLeft", dwForceLeft);
    dwForceJump = toml::find_or(saveData, "dwForceJump", dwForceJump);
    dwViewMatrix = toml::find_or(saveData, "dwViewMatrix", dwViewMatrix);

    dwClientState_State = toml::find_or(saveData, "dwClientState_State", dwClientState_State);
    dwClientState_MaxPlayer = toml::find_or(saveData, "dwClientState_MaxPlayer", dwClientState_MaxPlayer);
    dwClientState_ViewAngles = toml::find_or(saveData, "dwClientState_ViewAngles", dwClientState_ViewAngles);
    dwppDirect3DDevice9 = toml::find_or(saveData, "dwppDirect3DDevice9", dwppDirect3DDevice9);
    m_vecOrigin = toml::find_or(saveData, "m_vecOrigin", m_vecOrigin);
    m_iHealth = toml::find_or(saveData, "m_iHealth", m_iHealth);
    m_fFlags = toml::find_or(saveData, "m_fFlags", m_fFlags);
    m_vecViewOffset = toml::find_or(saveData, "m_vecViewOffset", m_vecViewOffset);
    m_dwBoneMatrix = toml::find_or(saveData, "m_dwBoneMatrix", m_dwBoneMatrix);
    m_iTeamNum = toml::find_or(saveData, "m_iTeamNum", m_iTeamNum);
    m_iGlowIndex = toml::find_or(saveData, "m_iGlowIndex", m_iGlowIndex);
    m_aimPunchAngle = toml::find_or(saveData, "m_aimPunchAngle", m_aimPunchAngle);
    m_iShotsFired = toml::find_or(saveData, "m_iShotsFired", m_iShotsFired);
    m_iCrosshairId = toml::find_or(saveData, "m_iCrosshairId", m_iCrosshairId);
    m_iFOV = toml::find_or(saveData, "m_iFOV", m_iFOV);
    m_bDormant = toml::find_or(saveData, "m_bDormant", m_bDormant);
    m_hActiveWeapon = toml::find_or(saveData, "m_hActiveWeapon", m_hActiveWeapon);
    m_iItemDefinitionIndex = toml::find_or(saveData, "m_iItemDefinitionIndex", m_iItemDefinitionIndex);
    m_bSpotted = toml::find_or(saveData, "m_bSpotted", m_bSpotted);
    m_bIsScoped = toml::find_or(saveData, "m_bIsScoped", m_bIsScoped);

    return std::map<std::string, uintptr_t>
            {
        {"dwClientState", dwClientState},
        {"dwForceAttack", dwForceAttack},
        {"dwEntityList", dwEntityList},
        {"dwGlowObjectManager", dwGlowObjectManager},
        {"dwLocalPlayer", dwLocalPlayer},
        {"dwForceForward", dwForceForward},
        {"dwForceBackward", dwForceBackward},
        {"dwForceRight", dwForceRight},
        {"dwForceLeft", dwForceLeft},
        {"dwForceJump", dwForceJump},
        {"dwViewMatrix", dwViewMatrix}
            };
}

//This is a wrap function to be passed to std::async
uintptr_t Scan(std::string dllName, std::string signature, int offset, uintptr_t moduleBase, int extra) {
    return PatternScanner(dllName.data(), signature.data(), offset).CalculateOffset(moduleBase, extra);
}

void OffsetsToml::Update(std::string& filename)
{
    uintptr_t a_entityList = std::async(std::launch::async, Scan, "client.dll", "\xBB????\x83??\x7C?", 1, Modules::client, 0).get();
    uintptr_t a_glowObjectManager = std::async(std::launch::async, Scan, "client.dll", "\x11?????\x83??\xC7?????????\x0F\x28?????\x68????", 2, Modules::client, 0).get();
    uintptr_t a_localPlayer = std::async(std::launch::async, Scan, "client.dll", "\x8D\x34\x85????\x89\x15????\x8B\x41\x08\x8B\x48\x04\x83\xF9\xFF", 3, Modules::client, 4).get();
    uintptr_t a_clientState = std::async(std::launch::async, Scan, "engine.dll", "\xA1????\x8B?????\x85?\x74?\x8B?", 1, Modules::engine, 0).get();
    uintptr_t a_forceAttack = std::async(std::launch::async, Scan, "client.dll", "\x89\x0D????\x8B\x0D????\x8B\xF2\x8B\xC1\x83\xCE\x04", 2, Modules::client, 0).get();
    uintptr_t a_forceBackward = std::async(std::launch::async, Scan, "client.dll", "\x55\x8B\xEC\x51\x53\x8A\x5D\x08", 287, Modules::client, 0).get();
    uintptr_t a_forceForward = std::async(std::launch::async, Scan, "client.dll","\x55\x8B\xEC\x51\x53\x8A\x5D\x08", 245, Modules::client, 0).get();
    uintptr_t a_forceJump = std::async(std::launch::async, Scan, "client.dll", "\x8B\x0D????\x8B\xD6\x8B\xC1\x83\xCA\x02", 2, Modules::client, 0).get();
    uintptr_t a_forceLeft = std::async(std::launch::async, Scan, "client.dll", "\x55\x8B\xEC\x51\x53\x8A\x5D\x08", 465, Modules::client, 0).get();
    uintptr_t a_forceRight = std::async(std::launch::async, Scan, "client.dll", "\x55\x8B\xEC\x51\x53\x8A\x5D\x08", 512, Modules::client, 0).get();
    uintptr_t a_viewMatrix = std::async(std::launch::async, Scan, "client.dll", "\x0F\x10\x05????\x8D\x85????\xB9", 3, Modules::client, 176).get();

    const toml::value data {
            {"dwForceAttack", a_forceAttack},
            {"dwEntityList", a_entityList},
            {"dwGlowObjectManager", a_glowObjectManager},
            {"dwLocalPlayer", a_localPlayer},
            {"dwClientState", a_clientState},
            {"dwForceBackward", a_forceBackward},
            {"dwForceForward", a_forceForward},
            {"dwForceRight", a_forceRight},
            {"dwForceJump", a_forceJump},
            {"dwForceLeft", a_forceLeft},
            {"dwViewMatrix", a_viewMatrix},
            {"dwClientState_State", 0x108},
            {"dwClientState_MaxPlayer", 0x388},
            {"dwClientState_ViewAngles", 0x4D90},
            {"dwppDirect3DDevice9", 0xA7050},
            {"m_vecOrigin", 0x138},
            {"m_iHealth", 0x100},
            {"m_fFlags", 0x104},
            {"m_vecViewOffset", 0x108},
            {"m_dwBoneMatrix", 0x26A8},
            {"m_iTeamNum", 0xF4},
            {"m_iGlowIndex", 0x10488},
            {"m_aimPunchAngle", 0x303C},
            {"m_iShotsFired", 0x103E0},
            {"m_iCrosshairId", 0x11438},
            {"m_iFOV", 0x31F4},
            {"m_bDormant", 0xED},
            {"m_bSpotted", 0x93D},
            {"m_hActiveWeapon", 0x2F08},
            {"m_iItemDefinitionIndex", 0x2FBA},
            {"m_bIsScoped", 0x9974},
    };

    std::ofstream file;
    file.open(filename, std::ios::out);
    file << data;
    file.close();
}


// When you add new offset, go to Initialize(), Update(), Fetch(), Offsets.cpp, Offsets.h
void OffsetsToml::Initialize(std::string& filename)
{
    const toml::value data {
            {"dwClientState", 0x58CFC4},
            {"dwForceAttack", 0x3202970},
            {"dwForceBackward", 0x320291C},
            {"dwForceForward", 0x32029A0},
            {"dwForceJump", 0x527C38C},
            {"dwForceLeft", 0x3202928},
            {"dwForceRight", 0x3202934},
            {"dwEntityList", 0x4DD245C},
            {"dwLocalPlayer", 0xDB65DC},
            {"dwGlowObjectManager", 0x531B048},
            {"dwViewMatrix", 0x4DC3D74},
            {"dwClientState_State", 0x108},
            {"dwClientState_MaxPlayer", 0x388},
            {"dwClientState_ViewAngles", 0x4D90},
            {"dwppDirect3DDevice9", 0xA7050},
            {"m_vecOrigin", 0x138},
            {"m_iHealth", 0x100},
            {"m_fFlags", 0x104},
            {"m_vecViewOffset", 0x108},
            {"m_dwBoneMatrix", 0x26A8},
            {"m_iTeamNum", 0xF4},
            {"m_iGlowIndex", 0x10488},
            {"m_aimPunchAngle", 0x303C},
            {"m_iShotsFired", 0x103E0},
            {"m_iCrosshairId", 0x11438},
            {"m_iFOV", 0x31F4},
            {"m_bDormant", 0xED},
            {"m_bSpotted", 0x93D},
            {"m_hActiveWeapon", 0x2F08},
            {"m_iItemDefinitionIndex", 0x2FBA},
            {"m_bIsScoped", 0x9974},
    };

    std::ofstream file;
    file.open(filename, std::ios::out);
    file << data;
    file.close();
}

```

`Dainsleif/Save/OffsetsToml.h`:

```h
#pragma once
#include "../pch.h"
#include <map>
#include <future>
#include "SettingsToml.h"
#include "../PatternScanner.h"

namespace OffsetsToml {
    std::map<std::string, uintptr_t> Fetch(std::string& filename);
    void Update(std::string& filename);
    void Initialize(std::string& filename);
}

```

`Dainsleif/Save/SettingsToml.cpp`:

```cpp
#include "SettingsToml.h"


extern ImVec4 enemyGlowColor, localGlowColor;
extern float aimSmoothness; //declared in Hacks/Aimbot.cpp
extern int fov; //declared in dllmain.cpp
extern float range;

void SettingsToml::Fetch(std::string& filename)
{
    auto saveData = toml::parse(filename);

    // find specified values associated with one keys, and assign them into each variable.
    HackFlags::bAimbot = toml::find_or<bool>(saveData, "bAimbot", Default::bAimbot);
    aimSmoothness = toml::find_or(saveData, "aimSmoothness", Default::aimSmoothness);
    range = toml::find_or(saveData, "range", Default::range);
    HackFlags::bGlowHack = toml::find_or<bool>(saveData, "bGlowHack", Default::bGlowhack);
    HackFlags::bAntiRecoil = toml::find_or<bool>(saveData, "bAntiRecoil", Default::bAntiRecoil);
    HackFlags::bTriggerBot = toml::find_or<bool>(saveData, "bTriggerBot", Default::bTriggerBot);
    HackFlags::bBunnyhop = toml::find_or<bool>(saveData, "bBunnyhop", Default::bBunnyhop);
    HackFlags::bAntiAFK = toml::find_or<bool>(saveData, "bAntiAFK", Default::bAntiAFK);
    fov = toml::find_or(saveData, "fov", Default::fov);
    HackFlags::bEsp = toml::find_or(saveData, "bEsp", Default::bEsp);
    HackFlags::bLineOverlay = toml::find_or(saveData, "bLineOverlay", Default::bLineOverlay);
    HackFlags::bRectOverlay = toml::find_or(saveData, "bRectOverlay", Default::bRectOverlay);
    HackFlags::bMinimapHack = toml::find_or(saveData, "bMinimapHack", Default::bMinimapHack);

    auto& enemyGlowColorTable = toml::find_or(saveData, "enemyGlowColor", {});
    enemyGlowColor = ImVec4(toml::find_or(enemyGlowColorTable, "Red", Default::enemyGlowColor.x), toml::find_or(enemyGlowColorTable, "Green", Default::enemyGlowColor.y), toml::find_or(enemyGlowColorTable, "Blue", Default::enemyGlowColor.z), toml::find_or(enemyGlowColorTable, "Alpha", Default::enemyGlowColor.w));

    auto& localGlowColorTable = toml::find_or(saveData, "localGlowColor", {});
    localGlowColor = ImVec4(toml::find_or(localGlowColorTable, "Red", Default::localGlowColor.x), toml::find_or(localGlowColorTable, "Green", Default::localGlowColor.y), toml::find_or(localGlowColorTable, "Blue", Default::localGlowColor.z), toml::find_or(localGlowColorTable, "Alpha", Default::localGlowColor.w));

}

void SettingsToml::Save(std::string& filename)
{
    //Make a variable that holds keys and values.
    const toml::value data
    {
        {"bAimbot",        HackFlags::bAimbot},
        {"bGlowHack", HackFlags::bGlowHack},
        {"bAntiRecoil",    HackFlags::bAntiRecoil},
        {"bTriggerBot", HackFlags::bTriggerBot},
        {"bBunnyhop", HackFlags::bBunnyhop},
        {"bAntiAFK", HackFlags::bAntiAFK},
        {"fov", fov},
        {"enemyGlowColor",{
            {"Red", enemyGlowColor.x},
            {"Green", enemyGlowColor.y},
            {"Blue", enemyGlowColor.z},
            {"Alpha", enemyGlowColor.w}
        }},
        {"localGlowColor", {
            {"Red", localGlowColor.x},
            {"Green", localGlowColor.y},
            {"Blue", localGlowColor.z},
            {"Alpha", localGlowColor.w}
        }},
        {"aimSmoothness",  aimSmoothness},
        {"range", range},
        {"bEsp",           HackFlags::bEsp},
        {"bLineOverlay", HackFlags::bLineOverlay},
        {"bRectOverlay", HackFlags::bRectOverlay},
        {"bMinimapHack",   HackFlags::bMinimapHack}
    };
    //Open file and write it in toml syntax.
    std::ofstream file;
    file.open(filename, std::ios::out);
    file << data;
    file.close();
}


```

`Dainsleif/Save/SettingsToml.h`:

```h
#pragma once
#include <map>
#include "../pch.h"
#include "../PatternScanner.h"
#include "../dllmain.h"
#include "../Hook/GraphicHook.h"

namespace SettingsToml {
    void Fetch(std::string& filename);
    void Save(std::string& filename);
}
```

`Dainsleif/Save/TabStateToml.cpp`:

```cpp
#include "TabStateToml.h"

//When you add new tab, modify visibleHacks in GraphicHook.cpp
void TabStateToml::Save(std::string& filename)
{
        const toml::value data = visibleHacks;
        std::ofstream file;
        file.open(filename, std::ios::out);
        file << data;
        file.close();
}

void TabStateToml::Fetch(std::string& filename)
{
    auto prevTabState = toml::parse(filename);
    TabFlags::t_aimBot = toml::find_or(prevTabState, "Aim Bot", true);
    TabFlags::t_glowHack = toml::find_or(prevTabState, "Glow Hack", true);
    TabFlags::t_antiRecoil = toml::find_or(prevTabState, "Anti Recoil", true);
    TabFlags::t_triggerBot = toml::find_or(prevTabState, "Trigger Bot", true);
    TabFlags::t_triggerBot = toml::find_or(prevTabState, "Bunnyhop", true);
    TabFlags::t_antiAFK = toml::find_or(prevTabState, "Anti AFK", false);
    TabFlags::t_fov = toml::find_or(prevTabState, "Fov", false);
    TabFlags::t_esp = toml::find_or(prevTabState, "Esp", false);
    TabFlags::t_minimapHack = toml::find_or(prevTabState, "Minimap Hack", false);
}
```

`Dainsleif/Save/TabStateToml.h`:

```h
#pragma once
#include "../Hook/GraphicHook.h"
#include "../pch.h"
#include "../dllmain.h"

namespace TabStateToml {
    void Save(std::string& filename);
    void Fetch(std::string& filename);
}
```

`Dainsleif/Utils.h`:

```h
#pragma once
#include <cstddef>
#include <MinHook.h>

namespace Utils
{
    template < typename T >
    T GetVirtualFunction ( void* baseClass, int index )
    {
        return ( *static_cast< T** > ( baseClass ) )[ index ];
    }

    template < typename T, typename ... Args >
    T CallVirtualFunction ( void* baseClass, int index, Args ... args )
    {
        return GetVirtualFunction< T(__thiscall*) (void*, Args ... ) > ( baseClass, index )(baseClass, args...);
    }
}

template <typename T>
inline MH_STATUS MH_CreateHookEx(LPVOID pTarget, LPVOID pDetour, T** ppOriginal) {
    return MH_CreateHook(pTarget, pDetour, reinterpret_cast<LPVOID*>(ppOriginal));
}

#define MEMBER_FUNC_ARGS(...) (this, __VA_ARGS__); };
#define CALL_VFUNC(index, func, type) __forceinline auto func { return Utils::GetVirtualFunction<type>(this, index) MEMBER_FUNC_ARGS

/*EXAMPLE OF USING CALL_VFUNC:
* PARAMS: index, func, type
* $param(index): the index of the virtual function you want to call.
* $param(func): the name of the function, and its parameters if any.
* $param(type): the type of the function (usually a __thiscall*, but others can be used aswell.)
* CALL_VFUNC(25, some_func(int arg1, int arg2), void(__thiscall*)(type*, int, int)) (arg1, arg2)
*/

```

`Dainsleif/Vector.cpp`:

```cpp
#include "pch.h"
#include "Vector.h"
```

`Dainsleif/Vector.h`:

```h
#pragma once

class Vector3 {
public:
	float x, y, z;
	
	Vector3& operator+(Vector3 arg)
	{
		x += arg.x;
		y += arg.y;
		z += arg.z;
		return *this;
	}

	Vector3& operator-(Vector3 arg)
	{
		x -= arg.x;
		y -= arg.y;
		z -= arg.z;
		return *this;
	}

	Vector3& operator*(float arg)
	{
		x *= arg;
		y *= arg;
		z *= arg;
		return *this;
	}

	void Normalize() {
        while (y > 180)
            y -= 360;
        while (y < -180)
            y += 360;

        if (x > 89.f)
            x = 89.f;
        else if (x < -89.f)
            x = -89.f;
	}
};

class Vector2 {
public:
    float  x, y;
};

class Vector4 {
public:
    float x, y, z, w;
};
```

`Dainsleif/Weapon.cpp`:

```cpp
#include "pch.h"
#include "Weapon.h"

WeaponID Weapon::GetWeaponID()
{
    return ReadValue<WeaponID>(m_iItemDefinitionIndex);
}
```

`Dainsleif/Weapon.h`:

```h
#pragma once
#include "pch.h"
#include "Entity.h"

enum WeaponID {
    NULLWEAPON = 0,
    KNIFE = 59,
    C4 = 49,

    HG_GLOCK = 4,
    HG_DUAL_BERETTAS = 2,
    HG_P250 = 36,
    HG_TEC9 = 30,
    HG_DESERT_EAGLE = 1,

    SG_NOVA = 35,
    SG_XM1014 = 25,
    SG_SAWED_OFF = 29,

    HEAVY_M249 = 14,
    HEAVY_NEGEV = 28,

    SMG_MAC10 = 17,
    SMG_MP7 = 33,
    SMG_UMP45 = 24,
    SMG_P90 = 19,
    SMG_PP_BIZON = 26,

    AR_GALIL = 13,
    AR_AK47 = 7,
    AR_SG553 = 39,

    SR_SSG08 = 40,
    SR_AWP = 9,
    SR_G3SG1 = 11,

    GN_MOLOTOV = 46,
    GN_DECOY = 47,
    GN_FLASH_ = 43,
    GN_HE = 44,
    GN_SMOKE = 45,

    ZEUS_X27 = 31,
};

class Weapon : public Entity
{
public:
    WeaponID GetWeaponID();
};
```

`Dainsleif/dllmain.cpp`:

```cpp
#include "dllmain.h"
#include "pch.h"
#include "Hook/Hooks.h"
#include "Interfaces/CInterfaceList.h"

namespace HackFlags
{
    bool bQuit, bAimbot, bGlowHack, bAntiRecoil, bTriggerBot, bBunnyhop, bAntiAFK, bMinimapHack;
}

namespace TabFlags
{
    bool t_aimBot = true, t_glowHack = true, t_antiRecoil = true, t_triggerBot = true, t_bunnyHop = true, t_antiAFK, t_fov, t_esp, t_minimapHack;
}

int fov;
bool g_ShowMenu = false;
bool inGame = false;

std::string settingsFile;
std::string offsetsFile;
std::string tabStateFile;

VOID WINAPI Detach ( )
{
    Hooks::Restore();

    FREECONSOLE ( );
}

std::map< std::string, bool > visibleHacks;

int loadSettingsFiles() {

    TCHAR dir[ MAX_PATH ];

    SHGetSpecialFolderPath ( NULL, dir, CSIDL_COMMON_DOCUMENTS, 0 ); //Find the Document directory location

    settingsFile = static_cast< std::string > ( dir ) + "/Dainsleif/savedata.toml"; //Set file path.
    offsetsFile = static_cast< std::string > ( dir ) + "/Dainsleif/offsets.toml";
    tabStateFile = static_cast< std::string > ( dir ) + "/Dainsleif/tabstate.toml";

    std::filesystem::path path1{ settingsFile }, path2{ offsetsFile }, path3{ tabStateFile };
    std::filesystem::create_directories ( path1.parent_path ( ) );

    if ( !std::filesystem::exists ( path1 ) )
    {
        std::ofstream stream{ path1 };
        stream.close ( );
        LOGHEX("error loading file savedata.toml", 1);
    }

    if ( !std::filesystem::exists ( path2 ) )
    {
        std::ofstream stream{ path2 };
        OffsetsToml::Initialize ( offsetsFile );
        stream.close ( );
        LOGHEX("error loading file offsets.toml", 2);
    }

    if ( !std::filesystem::exists ( path3 ) )
    {
        std::ofstream stream{ path3 };
        stream.close ( );
        LOGHEX("error loading file tabstate.toml", 3);
    }

    SettingsToml::Fetch ( settingsFile );
    OffsetsToml::Fetch ( offsetsFile );
    TabStateToml::Fetch ( tabStateFile );
    return 0;
}

DWORD WINAPI fMain ( LPVOID lpParameter )
{
    ALLOCCONSOLE ( );
    
    loadSettingsFiles();

    visibleHacks = {
        { "Aim Bot", TabFlags::t_aimBot },
        { "Glow Hack", TabFlags::t_glowHack },
        { "Anti Recoil", TabFlags::t_antiRecoil },
        { "Trigger Bot", TabFlags::t_triggerBot },
        { "Bunnyhop", TabFlags::t_bunnyHop },
        { "Anti AFK", TabFlags::t_antiAFK },
        { "Fov", TabFlags::t_fov },
        { "Esp", TabFlags::t_esp },
        { "Minimap Hack", TabFlags::t_minimapHack }
    };

    Modules::Initialize ( );

    dwClientState = PatternScanner ( "engine.dll", "\xA1????\x8B?????\x85?\x74?\x8B?", 1 ).CalculateOffset ( Modules::engine, 0 );

    LOGHEX ("client.dll", Modules::client);
    LOGHEX ("engine.dll", Modules::engine);

    g_csgo.Initialize();

    Hooks::Initialize();

    std::vector< Player* > playerList;

    //MUST save this to use as a flag cuz the value of local player's gonna be stored at the same address even the match ended.
    Player* oldLocalPlayer = nullptr;

    bool checkState_bAntiAFK = false;

    //Hack loop entry point.
    while (!(GetAsyncKeyState(VK_DELETE) & 1 || HackFlags::bQuit))
    {
        int gameState = *reinterpret_cast<int*>( *reinterpret_cast<uintptr_t*>(Modules::engine + dwClientState) + dwClientState_State);

        Player* localPlayer = Player::GetLocalPlayer();

        if ( gameState != 6 && inGame )
        {   //Not 6 means user's in menu.//true means user used to be in game.
            SettingsToml::Save (settingsFile);
            TabStateToml::Save (tabStateFile);
            oldLocalPlayer = localPlayer;
            inGame = false;
        }

        if (GetAsyncKeyState (VK_INSERT) & 1)
        {
            g_ShowMenu = !g_ShowMenu;
            if (!g_ShowMenu)
            {
                SettingsToml::Save (settingsFile);
                TabStateToml::Save (tabStateFile);
            }
        }

        if (gameState != 6 || !localPlayer || localPlayer == oldLocalPlayer)
            continue;

        if (!localPlayer->GetActiveWeapon())
            continue;

        //If we have values to set in initializing phase, have to be written here.
        if (!inGame)
        {
            inGame = true;
        }

        if (HackFlags::bBunnyhop && GetAsyncKeyState(VK_SPACE))
        {
            Bhop::Run();
        }

        if (HackFlags::bTriggerBot || HackFlags::bGlowHack || HackFlags::bAntiRecoil)
        {
            playerList = Player::GetAll();
        }

        if (HackFlags::bTriggerBot)
        {
            Triggerbot::Run();
        }

        if (HackFlags::bGlowHack)
        {
            for (Player* player : playerList)
            {
                Glow::Run (player);
            }
        }

        if (HackFlags::bAntiRecoil)
        {
            AntiRecoil::Run();
        }

        std::vector< Player* > pl = Player::GetLivingOpponents ();

        if (HackFlags::bAimbot)
        {
            Aimbot::Run (pl);
        }

        if (HackFlags::bMinimapHack)
        {
            Minimap::Run (pl);
        }

        if ( !checkState_bAntiAFK && HackFlags::bAntiAFK )
        { //First loop after user ticks the checkbox.
            std::thread worker ( AntiAFK::Run, &HackFlags::bAntiAFK );
            worker.detach ( );
            checkState_bAntiAFK = true;
        }
        else if ( checkState_bAntiAFK && !HackFlags::bAntiAFK )
        { //First loop after user unticks the checkbox.
            checkState_bAntiAFK = false;
        }

        Sleep ( 1 ); //sleep for performance aspect
    }

    SettingsToml::Save(settingsFile);
    TabStateToml::Save(tabStateFile);

    FreeLibraryAndExitThread ( static_cast< HMODULE > ( lpParameter ), EXIT_SUCCESS );
}

BOOL APIENTRY DllMain ( HMODULE hModule, DWORD dwReason, LPVOID lpReserved )
{
    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        DisableThreadLibraryCalls ( hModule );

        HANDLE hThread = CreateThread ( nullptr, 0, fMain, hModule, 0, nullptr );
        if ( hThread )
        {
            CloseHandle ( hThread );
        }
    }
    else if ( dwReason == DLL_PROCESS_DETACH && !lpReserved )
    {
        Detach ( );
    }
    return TRUE;
}

```

`Dainsleif/dllmain.h`:

```h
#pragma once

#include "Save/SettingsToml.h"
#include "Save/OffsetsToml.h"
#include "Hacks/Aimbot.h"
#include "Hacks/Glow.h"
#include "Hacks/AntiRecoil.h"
#include "Hacks/Triggerbot.h"
#include "Hacks/AntiAFK.h"
#include "Hacks/MinimapHack.h"
#include "Hacks/Bunnyhop.h"
#include "Save/TabStateToml.h"
#include <thread>

//#define DEBUG

#ifdef DEBUG
#define LOGHEX(name, val) std::cout << name << ": " << std::hex << val << std::endl;
#define LOG(x) std::cout << x << std::endl;
#define ALLOCCONSOLE()\
{\
    AllocConsole();\
    freopen_s(reinterpret_cast<FILE**>(stdout), "CONOUT$", "w", stdout);\
}
#define FREECONSOLE()\
{\
    fclose(stdout);\
    FreeConsole();\
}
#else
#define LOGHEX(name, val)
#define ALLOCCONSOLE()
#define FREECONSOLE()
#endif

namespace HackFlags {
    extern bool bQuit, bAimbot, bGlowHack, bAntiRecoil, bTriggerBot, bBunnyhop, bAntiAFK, bMinimapHack;
}

namespace TabFlags {
    extern bool t_aimBot, t_glowHack, t_antiRecoil, t_triggerBot, t_bunnyHop, t_antiAFK, t_fov, t_esp, t_minimapHack;
}

extern bool g_ShowMenu;

int loadSettingsFiles();
```

`Dainsleif/pch.cpp`:

```cpp
#include "pch.h"

```

`Dainsleif/pch.h`:

```h
#ifndef PCH_H
#define PCH_H

//standard library
#include <fstream>
#include <direct.h>
#include <sys/stat.h>
#include <iostream>
#include <shlobj.h>
#include <vector>
#include <filesystem>
#include <Windows.h>
#include <d3d9.h>
#include <d3dx9core.h>


//my header
#include "Hook/ImGuiTheme.h"
#include "Vector.h"
#include "DefaultSettings.h"
#include "Offsets.h"
#include "Modules.h"
#include "Utils.h"

//external library
#include "imgui.h"
#include "imgui_impl_dx9.h"
#include "imgui_impl_win32.h"
#include "toml.hpp"


#endif

```

`Dependencies/toml11/toml.hpp`:

```hpp
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2017 Toru Niina
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#ifndef TOML_FOR_MODERN_CPP
#define TOML_FOR_MODERN_CPP

#ifndef __cplusplus
#    error "__cplusplus is not defined"
#endif

#if __cplusplus < 201103L && _MSC_VER < 1900
#    error "toml11 requires C++11 or later."
#endif

#define TOML11_VERSION_MAJOR 3
#define TOML11_VERSION_MINOR 5
#define TOML11_VERSION_PATCH 0

#include "toml/parser.hpp"
#include "toml/literal.hpp"
#include "toml/serializer.hpp"
#include "toml/get.hpp"

#endif// TOML_FOR_MODERN_CPP

```

`Dependencies/toml11/toml/color.hpp`:

```hpp
#ifndef TOML11_COLOR_HPP
#define TOML11_COLOR_HPP
#include <cstdint>
#include <ostream>

#ifdef TOML11_COLORIZE_ERROR_MESSAGE
#define TOML11_ERROR_MESSAGE_COLORIZED true
#else
#define TOML11_ERROR_MESSAGE_COLORIZED false
#endif

namespace toml
{

// put ANSI escape sequence to ostream
namespace color_ansi
{
namespace detail
{
inline int colorize_index()
{
    static const int index = std::ios_base::xalloc();
    return index;
}
} // detail

inline std::ostream& colorize(std::ostream& os)
{
    // by default, it is zero.
    os.iword(detail::colorize_index()) = 1;
    return os;
}
inline std::ostream& nocolorize(std::ostream& os)
{
    os.iword(detail::colorize_index()) = 0;
    return os;
}
inline std::ostream& reset  (std::ostream& os)
{if(os.iword(detail::colorize_index()) == 1) {os << "\033[00m";} return os;}
inline std::ostream& bold   (std::ostream& os)
{if(os.iword(detail::colorize_index()) == 1) {os << "\033[01m";} return os;}
inline std::ostream& grey   (std::ostream& os)
{if(os.iword(detail::colorize_index()) == 1) {os << "\033[30m";} return os;}
inline std::ostream& red    (std::ostream& os)
{if(os.iword(detail::colorize_index()) == 1) {os << "\033[31m";} return os;}
inline std::ostream& green  (std::ostream& os)
{if(os.iword(detail::colorize_index()) == 1) {os << "\033[32m";} return os;}
inline std::ostream& yellow (std::ostream& os)
{if(os.iword(detail::colorize_index()) == 1) {os << "\033[33m";} return os;}
inline std::ostream& blue   (std::ostream& os)
{if(os.iword(detail::colorize_index()) == 1) {os << "\033[34m";} return os;}
inline std::ostream& magenta(std::ostream& os)
{if(os.iword(detail::colorize_index()) == 1) {os << "\033[35m";} return os;}
inline std::ostream& cyan   (std::ostream& os)
{if(os.iword(detail::colorize_index()) == 1) {os << "\033[36m";} return os;}
inline std::ostream& white  (std::ostream& os)
{if(os.iword(detail::colorize_index()) == 1) {os << "\033[37m";} return os;}
} // color_ansi

// ANSI escape sequence is the only and default colorization method currently
namespace color = color_ansi;

} // toml
#endif// TOML11_COLOR_HPP

```

`Dependencies/toml11/toml/combinator.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_COMBINATOR_HPP
#define TOML11_COMBINATOR_HPP
#include <cassert>
#include <cctype>
#include <cstdio>

#include <array>
#include <iomanip>
#include <iterator>
#include <limits>
#include <type_traits>

#include "region.hpp"
#include "result.hpp"
#include "traits.hpp"
#include "utility.hpp"

// they scans characters and returns region if it matches to the condition.
// when they fail, it does not change the location.
// in lexer.hpp, these are used.

namespace toml
{
namespace detail
{

// to output character as an error message.
inline std::string show_char(const char c)
{
    // It supress an error that occurs only in Debug mode of MSVC++ on Windows.
    // I'm not completely sure but they check the value of char to be in the
    // range [0, 256) and some of the COMPLETELY VALID utf-8 character sometimes
    // has negative value (if char has sign). So here it re-interprets c as
    // unsigned char through pointer. In general, converting pointer to a
    // pointer that has different type cause UB, but `(signed|unsigned)?char`
    // are one of the exceptions. Converting pointer only to char and std::byte
    // (c++17) are valid.
    if(std::isgraph(*reinterpret_cast<unsigned char const*>(std::addressof(c))))
    {
        return std::string(1, c);
    }
    else
    {
        std::array<char, 5> buf;
        buf.fill('\0');
        const auto r = std::snprintf(
                buf.data(), buf.size(), "0x%02x", static_cast<int>(c) & 0xFF);
        (void) r; // Unused variable warning
        assert(r == static_cast<int>(buf.size()) - 1);
        return std::string(buf.data());
    }
}

template<char C>
struct character
{
    static constexpr char target = C;

    static result<region, none_t>
    invoke(location& loc)
    {
        if(loc.iter() == loc.end()) {return none();}
        const auto first = loc.iter();

        const char c = *(loc.iter());
        if(c != target)
        {
            return none();
        }
        loc.advance(); // update location

        return ok(region(loc, first, loc.iter()));
    }
};
template<char C>
constexpr char character<C>::target;

// closed interval [Low, Up]. both Low and Up are included.
template<char Low, char Up>
struct in_range
{
    // assuming ascii part of UTF-8...
    static_assert(Low <= Up, "lower bound should be less than upper bound.");

    static constexpr char upper = Up;
    static constexpr char lower = Low;

    static result<region, none_t>
    invoke(location& loc)
    {
        if(loc.iter() == loc.end()) {return none();}
        const auto first = loc.iter();

        const char c = *(loc.iter());
        if(c < lower || upper < c)
        {
            return none();
        }

        loc.advance();
        return ok(region(loc, first, loc.iter()));
    }
};
template<char L, char U> constexpr char in_range<L, U>::upper;
template<char L, char U> constexpr char in_range<L, U>::lower;

// keep iterator if `Combinator` matches. otherwise, increment `iter` by 1 char.
// for detecting invalid characters, like control sequences in toml string.
template<typename Combinator>
struct exclude
{
    static result<region, none_t>
    invoke(location& loc)
    {
        if(loc.iter() == loc.end()) {return none();}
        auto first = loc.iter();

        auto rslt = Combinator::invoke(loc);
        if(rslt.is_ok())
        {
            loc.reset(first);
            return none();
        }
        loc.reset(std::next(first)); // XXX maybe loc.advance() is okay but...
        return ok(region(loc, first, loc.iter()));
    }
};

// increment `iter`, if matches. otherwise, just return empty string.
template<typename Combinator>
struct maybe
{
    static result<region, none_t>
    invoke(location& loc)
    {
        const auto rslt = Combinator::invoke(loc);
        if(rslt.is_ok())
        {
            return rslt;
        }
        return ok(region(loc));
    }
};

template<typename ... Ts>
struct sequence;

template<typename Head, typename ... Tail>
struct sequence<Head, Tail...>
{
    static result<region, none_t>
    invoke(location& loc)
    {
        const auto first = loc.iter();
        const auto rslt = Head::invoke(loc);
        if(rslt.is_err())
        {
            loc.reset(first);
            return none();
        }
        return sequence<Tail...>::invoke(loc, std::move(rslt.unwrap()), first);
    }

    // called from the above function only, recursively.
    template<typename Iterator>
    static result<region, none_t>
    invoke(location& loc, region reg, Iterator first)
    {
        const auto rslt = Head::invoke(loc);
        if(rslt.is_err())
        {
            loc.reset(first);
            return none();
        }
        reg += rslt.unwrap(); // concat regions
        return sequence<Tail...>::invoke(loc, std::move(reg), first);
    }
};

template<typename Head>
struct sequence<Head>
{
    // would be called from sequence<T ...>::invoke only.
    template<typename Iterator>
    static result<region, none_t>
    invoke(location& loc, region reg, Iterator first)
    {
        const auto rslt = Head::invoke(loc);
        if(rslt.is_err())
        {
            loc.reset(first);
            return none();
        }
        reg += rslt.unwrap(); // concat regions
        return ok(reg);
    }
};

template<typename ... Ts>
struct either;

template<typename Head, typename ... Tail>
struct either<Head, Tail...>
{
    static result<region, none_t>
    invoke(location& loc)
    {
        const auto rslt = Head::invoke(loc);
        if(rslt.is_ok()) {return rslt;}
        return either<Tail...>::invoke(loc);
    }
};
template<typename Head>
struct either<Head>
{
    static result<region, none_t>
    invoke(location& loc)
    {
        return Head::invoke(loc);
    }
};

template<typename T, typename N>
struct repeat;

template<std::size_t N> struct exactly{};
template<std::size_t N> struct at_least{};
struct unlimited{};

template<typename T, std::size_t N>
struct repeat<T, exactly<N>>
{
    static result<region, none_t>
    invoke(location& loc)
    {
        region retval(loc);
        const auto first = loc.iter();
        for(std::size_t i=0; i<N; ++i)
        {
            auto rslt = T::invoke(loc);
            if(rslt.is_err())
            {
                loc.reset(first);
                return none();
            }
            retval += rslt.unwrap();
        }
        return ok(std::move(retval));
    }
};

template<typename T, std::size_t N>
struct repeat<T, at_least<N>>
{
    static result<region, none_t>
    invoke(location& loc)
    {
        region retval(loc);

        const auto first = loc.iter();
        for(std::size_t i=0; i<N; ++i)
        {
            auto rslt = T::invoke(loc);
            if(rslt.is_err())
            {
                loc.reset(first);
                return none();
            }
            retval += rslt.unwrap();
        }
        while(true)
        {
            auto rslt = T::invoke(loc);
            if(rslt.is_err())
            {
                return ok(std::move(retval));
            }
            retval += rslt.unwrap();
        }
    }
};

template<typename T>
struct repeat<T, unlimited>
{
    static result<region, none_t>
    invoke(location& loc)
    {
        region retval(loc);
        while(true)
        {
            auto rslt = T::invoke(loc);
            if(rslt.is_err())
            {
                return ok(std::move(retval));
            }
            retval += rslt.unwrap();
        }
    }
};

} // detail
} // toml
#endif// TOML11_COMBINATOR_HPP

```

`Dependencies/toml11/toml/comments.hpp`:

```hpp
//     Copyright Toru Niina 2019.
// Distributed under the MIT License.
#ifndef TOML11_COMMENTS_HPP
#define TOML11_COMMENTS_HPP
#include <initializer_list>
#include <iterator>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>

// This file provides mainly two classes, `preserve_comments` and `discard_comments`.
// Those two are a container that have the same interface as `std::vector<std::string>`
// but bahaves in the opposite way. `preserve_comments` is just the same as
// `std::vector<std::string>` and each `std::string` corresponds to a comment line.
// Conversely, `discard_comments` discards all the strings and ignores everything
// assigned in it. `discard_comments` is always empty and you will encounter an
// error whenever you access to the element.
namespace toml
{
struct discard_comments; // forward decl

// use it in the following way
//
// const toml::basic_value<toml::preserve_comments> data =
//     toml::parse<toml::preserve_comments>("example.toml");
//
// the interface is almost the same as std::vector<std::string>.
struct preserve_comments
{
    // `container_type` is not provided in discard_comments.
    // do not use this inner-type in a generic code.
    using container_type         = std::vector<std::string>;

    using size_type              = container_type::size_type;
    using difference_type        = container_type::difference_type;
    using value_type             = container_type::value_type;
    using reference              = container_type::reference;
    using const_reference        = container_type::const_reference;
    using pointer                = container_type::pointer;
    using const_pointer          = container_type::const_pointer;
    using iterator               = container_type::iterator;
    using const_iterator         = container_type::const_iterator;
    using reverse_iterator       = container_type::reverse_iterator;
    using const_reverse_iterator = container_type::const_reverse_iterator;

    preserve_comments()  = default;
    ~preserve_comments() = default;
    preserve_comments(preserve_comments const&) = default;
    preserve_comments(preserve_comments &&)     = default;
    preserve_comments& operator=(preserve_comments const&) = default;
    preserve_comments& operator=(preserve_comments &&)     = default;

    explicit preserve_comments(const std::vector<std::string>& c): comments(c){}
    explicit preserve_comments(std::vector<std::string>&& c)
        : comments(std::move(c))
    {}
    preserve_comments& operator=(const std::vector<std::string>& c)
    {
        comments = c;
        return *this;
    }
    preserve_comments& operator=(std::vector<std::string>&& c)
    {
        comments = std::move(c);
        return *this;
    }

    explicit preserve_comments(const discard_comments&) {}

    explicit preserve_comments(size_type n): comments(n) {}
    preserve_comments(size_type n, const std::string& x): comments(n, x) {}
    preserve_comments(std::initializer_list<std::string> x): comments(x) {}
    template<typename InputIterator>
    preserve_comments(InputIterator first, InputIterator last)
        : comments(first, last)
    {}

    template<typename InputIterator>
    void assign(InputIterator first, InputIterator last) {comments.assign(first, last);}
    void assign(std::initializer_list<std::string> ini)  {comments.assign(ini);}
    void assign(size_type n, const std::string& val)     {comments.assign(n, val);}

    // Related to the issue #97.
    //
    // It is known that `std::vector::insert` and `std::vector::erase` in
    // the standard library implementation included in GCC 4.8.5 takes
    // `std::vector::iterator` instead of `std::vector::const_iterator`.
    // Because of the const-correctness, we cannot convert a `const_iterator` to
    // an `iterator`. It causes compilation error in GCC 4.8.5.
#if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__) && !defined(__clang__)
#  if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) <= 40805
#    define TOML11_WORKAROUND_GCC_4_8_X_STANDARD_LIBRARY_IMPLEMENTATION
#  endif
#endif

#ifdef TOML11_WORKAROUND_GCC_4_8_X_STANDARD_LIBRARY_IMPLEMENTATION
    iterator insert(iterator p, const std::string& x)
    {
        return comments.insert(p, x);
    }
    iterator insert(iterator p, std::string&&      x)
    {
        return comments.insert(p, std::move(x));
    }
    void insert(iterator p, size_type n, const std::string& x)
    {
        return comments.insert(p, n, x);
    }
    template<typename InputIterator>
    void insert(iterator p, InputIterator first, InputIterator last)
    {
        return comments.insert(p, first, last);
    }
    void insert(iterator p, std::initializer_list<std::string> ini)
    {
        return comments.insert(p, ini);
    }

    template<typename ... Ts>
    iterator emplace(iterator p, Ts&& ... args)
    {
        return comments.emplace(p, std::forward<Ts>(args)...);
    }

    iterator erase(iterator pos) {return comments.erase(pos);}
    iterator erase(iterator first, iterator last)
    {
        return comments.erase(first, last);
    }
#else
    iterator insert(const_iterator p, const std::string& x)
    {
        return comments.insert(p, x);
    }
    iterator insert(const_iterator p, std::string&&      x)
    {
        return comments.insert(p, std::move(x));
    }
    iterator insert(const_iterator p, size_type n, const std::string& x)
    {
        return comments.insert(p, n, x);
    }
    template<typename InputIterator>
    iterator insert(const_iterator p, InputIterator first, InputIterator last)
    {
        return comments.insert(p, first, last);
    }
    iterator insert(const_iterator p, std::initializer_list<std::string> ini)
    {
        return comments.insert(p, ini);
    }

    template<typename ... Ts>
    iterator emplace(const_iterator p, Ts&& ... args)
    {
        return comments.emplace(p, std::forward<Ts>(args)...);
    }

    iterator erase(const_iterator pos) {return comments.erase(pos);}
    iterator erase(const_iterator first, const_iterator last)
    {
        return comments.erase(first, last);
    }
#endif

    void swap(preserve_comments& other) {comments.swap(other.comments);}

    void push_back(const std::string& v) {comments.push_back(v);}
    void push_back(std::string&&      v) {comments.push_back(std::move(v));}
    void pop_back()                      {comments.pop_back();}

    template<typename ... Ts>
    void emplace_back(Ts&& ... args) {comments.emplace_back(std::forward<Ts>(args)...);}

    void clear() {comments.clear();}

    size_type size()     const noexcept {return comments.size();}
    size_type max_size() const noexcept {return comments.max_size();}
    size_type capacity() const noexcept {return comments.capacity();}
    bool      empty()    const noexcept {return comments.empty();}

    void reserve(size_type n)                      {comments.reserve(n);}
    void resize(size_type n)                       {comments.resize(n);}
    void resize(size_type n, const std::string& c) {comments.resize(n, c);}
    void shrink_to_fit()                           {comments.shrink_to_fit();}

    reference       operator[](const size_type n)       noexcept {return comments[n];}
    const_reference operator[](const size_type n) const noexcept {return comments[n];}
    reference       at(const size_type n)       {return comments.at(n);}
    const_reference at(const size_type n) const {return comments.at(n);}
    reference       front()       noexcept {return comments.front();}
    const_reference front() const noexcept {return comments.front();}
    reference       back()        noexcept {return comments.back();}
    const_reference back()  const noexcept {return comments.back();}

    pointer         data()        noexcept {return comments.data();}
    const_pointer   data()  const noexcept {return comments.data();}

    iterator       begin()        noexcept {return comments.begin();}
    iterator       end()          noexcept {return comments.end();}
    const_iterator begin()  const noexcept {return comments.begin();}
    const_iterator end()    const noexcept {return comments.end();}
    const_iterator cbegin() const noexcept {return comments.cbegin();}
    const_iterator cend()   const noexcept {return comments.cend();}

    reverse_iterator       rbegin()        noexcept {return comments.rbegin();}
    reverse_iterator       rend()          noexcept {return comments.rend();}
    const_reverse_iterator rbegin()  const noexcept {return comments.rbegin();}
    const_reverse_iterator rend()    const noexcept {return comments.rend();}
    const_reverse_iterator crbegin() const noexcept {return comments.crbegin();}
    const_reverse_iterator crend()   const noexcept {return comments.crend();}

    friend bool operator==(const preserve_comments&, const preserve_comments&);
    friend bool operator!=(const preserve_comments&, const preserve_comments&);
    friend bool operator< (const preserve_comments&, const preserve_comments&);
    friend bool operator<=(const preserve_comments&, const preserve_comments&);
    friend bool operator> (const preserve_comments&, const preserve_comments&);
    friend bool operator>=(const preserve_comments&, const preserve_comments&);

    friend void swap(preserve_comments&, std::vector<std::string>&);
    friend void swap(std::vector<std::string>&, preserve_comments&);

  private:

    container_type comments;
};

inline bool operator==(const preserve_comments& lhs, const preserve_comments& rhs) {return lhs.comments == rhs.comments;}
inline bool operator!=(const preserve_comments& lhs, const preserve_comments& rhs) {return lhs.comments != rhs.comments;}
inline bool operator< (const preserve_comments& lhs, const preserve_comments& rhs) {return lhs.comments <  rhs.comments;}
inline bool operator<=(const preserve_comments& lhs, const preserve_comments& rhs) {return lhs.comments <= rhs.comments;}
inline bool operator> (const preserve_comments& lhs, const preserve_comments& rhs) {return lhs.comments >  rhs.comments;}
inline bool operator>=(const preserve_comments& lhs, const preserve_comments& rhs) {return lhs.comments >= rhs.comments;}

inline void swap(preserve_comments& lhs, preserve_comments& rhs)
{
    lhs.swap(rhs);
    return;
}
inline void swap(preserve_comments& lhs, std::vector<std::string>& rhs)
{
    lhs.comments.swap(rhs);
    return;
}
inline void swap(std::vector<std::string>& lhs, preserve_comments& rhs)
{
    lhs.swap(rhs.comments);
    return;
}

template<typename charT, typename traits>
std::basic_ostream<charT, traits>&
operator<<(std::basic_ostream<charT, traits>& os, const preserve_comments& com)
{
    for(const auto& c : com)
    {
        os << '#' << c << '\n';
    }
    return os;
}

namespace detail
{

// To provide the same interface with `preserve_comments`, `discard_comments`
// should have an iterator. But it does not contain anything, so we need to
// add an iterator that points nothing.
//
// It always points null, so DO NOT unwrap this iterator. It always crashes
// your program.
template<typename T, bool is_const>
struct empty_iterator
{
    using value_type        = T;
    using reference_type    = typename std::conditional<is_const, T const&, T&>::type;
    using pointer_type      = typename std::conditional<is_const, T const*, T*>::type;
    using difference_type   = std::ptrdiff_t;
    using iterator_category = std::random_access_iterator_tag;

    empty_iterator()  = default;
    ~empty_iterator() = default;
    empty_iterator(empty_iterator const&) = default;
    empty_iterator(empty_iterator &&)     = default;
    empty_iterator& operator=(empty_iterator const&) = default;
    empty_iterator& operator=(empty_iterator &&)     = default;

    // DO NOT call these operators.
    reference_type operator*()  const noexcept {std::terminate();}
    pointer_type   operator->() const noexcept {return nullptr;}
    reference_type operator[](difference_type) const noexcept {return this->operator*();}

    // These operators do nothing.
    empty_iterator& operator++()    noexcept {return *this;}
    empty_iterator  operator++(int) noexcept {return *this;}
    empty_iterator& operator--()    noexcept {return *this;}
    empty_iterator  operator--(int) noexcept {return *this;}

    empty_iterator& operator+=(difference_type) noexcept {return *this;}
    empty_iterator& operator-=(difference_type) noexcept {return *this;}

    empty_iterator  operator+(difference_type) const noexcept {return *this;}
    empty_iterator  operator-(difference_type) const noexcept {return *this;}
};

template<typename T, bool C>
bool operator==(const empty_iterator<T, C>&, const empty_iterator<T, C>&) noexcept {return true;}
template<typename T, bool C>
bool operator!=(const empty_iterator<T, C>&, const empty_iterator<T, C>&) noexcept {return false;}
template<typename T, bool C>
bool operator< (const empty_iterator<T, C>&, const empty_iterator<T, C>&) noexcept {return false;}
template<typename T, bool C>
bool operator<=(const empty_iterator<T, C>&, const empty_iterator<T, C>&) noexcept {return true;}
template<typename T, bool C>
bool operator> (const empty_iterator<T, C>&, const empty_iterator<T, C>&) noexcept {return false;}
template<typename T, bool C>
bool operator>=(const empty_iterator<T, C>&, const empty_iterator<T, C>&) noexcept {return true;}

template<typename T, bool C>
typename empty_iterator<T, C>::difference_type
operator-(const empty_iterator<T, C>&, const empty_iterator<T, C>&) noexcept {return 0;}

template<typename T, bool C>
empty_iterator<T, C>
operator+(typename empty_iterator<T, C>::difference_type, const empty_iterator<T, C>& rhs) noexcept {return rhs;}
template<typename T, bool C>
empty_iterator<T, C>
operator+(const empty_iterator<T, C>& lhs, typename empty_iterator<T, C>::difference_type) noexcept {return lhs;}

} // detail

// The default comment type. It discards all the comments. It requires only one
// byte to contain, so the memory footprint is smaller than preserve_comments.
//
// It just ignores `push_back`, `insert`, `erase`, and any other modifications.
// IT always returns size() == 0, the iterator taken by `begin()` is always the
// same as that of `end()`, and accessing through `operator[]` or iterators
// always causes a segmentation fault. DO NOT access to the element of this.
//
// Why this is chose as the default type is because the last version (2.x.y)
// does not contain any comments in a value. To minimize the impact on the
// efficiency, this is choosed as a default.
//
// To reduce the memory footprint, later we can try empty base optimization (EBO).
struct discard_comments
{
    using size_type              = std::size_t;
    using difference_type        = std::ptrdiff_t;
    using value_type             = std::string;
    using reference              = std::string&;
    using const_reference        = std::string const&;
    using pointer                = std::string*;
    using const_pointer          = std::string const*;
    using iterator               = detail::empty_iterator<std::string, false>;
    using const_iterator         = detail::empty_iterator<std::string, true>;
    using reverse_iterator       = detail::empty_iterator<std::string, false>;
    using const_reverse_iterator = detail::empty_iterator<std::string, true>;

    discard_comments() = default;
    ~discard_comments() = default;
    discard_comments(discard_comments const&) = default;
    discard_comments(discard_comments &&)     = default;
    discard_comments& operator=(discard_comments const&) = default;
    discard_comments& operator=(discard_comments &&)     = default;

    explicit discard_comments(const std::vector<std::string>&) noexcept {}
    explicit discard_comments(std::vector<std::string>&&)      noexcept {}
    discard_comments& operator=(const std::vector<std::string>&) noexcept {return *this;}
    discard_comments& operator=(std::vector<std::string>&&)      noexcept {return *this;}

    explicit discard_comments(const preserve_comments&)        noexcept {}

    explicit discard_comments(size_type) noexcept {}
    discard_comments(size_type, const std::string&) noexcept {}
    discard_comments(std::initializer_list<std::string>) noexcept {}
    template<typename InputIterator>
    discard_comments(InputIterator, InputIterator) noexcept {}

    template<typename InputIterator>
    void assign(InputIterator, InputIterator)       noexcept {}
    void assign(std::initializer_list<std::string>) noexcept {}
    void assign(size_type, const std::string&)      noexcept {}

    iterator insert(const_iterator, const std::string&)                 {return iterator{};}
    iterator insert(const_iterator, std::string&&)                      {return iterator{};}
    iterator insert(const_iterator, size_type, const std::string&)      {return iterator{};}
    template<typename InputIterator>
    iterator insert(const_iterator, InputIterator, InputIterator)       {return iterator{};}
    iterator insert(const_iterator, std::initializer_list<std::string>) {return iterator{};}

    template<typename ... Ts>
    iterator emplace(const_iterator, Ts&& ...)     {return iterator{};}
    iterator erase(const_iterator)                 {return iterator{};}
    iterator erase(const_iterator, const_iterator) {return iterator{};}

    void swap(discard_comments&) {return;}

    void push_back(const std::string&) {return;}
    void push_back(std::string&&     ) {return;}
    void pop_back()                    {return;}

    template<typename ... Ts>
    void emplace_back(Ts&& ...) {return;}

    void clear() {return;}

    size_type size()     const noexcept {return 0;}
    size_type max_size() const noexcept {return 0;}
    size_type capacity() const noexcept {return 0;}
    bool      empty()    const noexcept {return true;}

    void reserve(size_type)                    {return;}
    void resize(size_type)                     {return;}
    void resize(size_type, const std::string&) {return;}
    void shrink_to_fit()                       {return;}

    // DO NOT access to the element of this container. This container is always
    // empty, so accessing through operator[], front/back, data causes address
    // error.

    reference       operator[](const size_type)       noexcept {return *data();}
    const_reference operator[](const size_type) const noexcept {return *data();}
    reference       at(const size_type)       {throw std::out_of_range("toml::discard_comment is always empty.");}
    const_reference at(const size_type) const {throw std::out_of_range("toml::discard_comment is always empty.");}
    reference       front()       noexcept {return *data();}
    const_reference front() const noexcept {return *data();}
    reference       back()        noexcept {return *data();}
    const_reference back()  const noexcept {return *data();}

    pointer         data()        noexcept {return nullptr;}
    const_pointer   data()  const noexcept {return nullptr;}

    iterator       begin()        noexcept {return iterator{};}
    iterator       end()          noexcept {return iterator{};}
    const_iterator begin()  const noexcept {return const_iterator{};}
    const_iterator end()    const noexcept {return const_iterator{};}
    const_iterator cbegin() const noexcept {return const_iterator{};}
    const_iterator cend()   const noexcept {return const_iterator{};}

    reverse_iterator       rbegin()        noexcept {return iterator{};}
    reverse_iterator       rend()          noexcept {return iterator{};}
    const_reverse_iterator rbegin()  const noexcept {return const_iterator{};}
    const_reverse_iterator rend()    const noexcept {return const_iterator{};}
    const_reverse_iterator crbegin() const noexcept {return const_iterator{};}
    const_reverse_iterator crend()   const noexcept {return const_iterator{};}
};

inline bool operator==(const discard_comments&, const discard_comments&) noexcept {return true;}
inline bool operator!=(const discard_comments&, const discard_comments&) noexcept {return false;}
inline bool operator< (const discard_comments&, const discard_comments&) noexcept {return false;}
inline bool operator<=(const discard_comments&, const discard_comments&) noexcept {return true;}
inline bool operator> (const discard_comments&, const discard_comments&) noexcept {return false;}
inline bool operator>=(const discard_comments&, const discard_comments&) noexcept {return true;}

inline void swap(const discard_comments&, const discard_comments&) noexcept {return;}

template<typename charT, typename traits>
std::basic_ostream<charT, traits>&
operator<<(std::basic_ostream<charT, traits>& os, const discard_comments&)
{
    return os;
}

} // toml11
#endif// TOML11_COMMENTS_HPP

```

`Dependencies/toml11/toml/datetime.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_DATETIME_HPP
#define TOML11_DATETIME_HPP
#include <cstdint>
#include <cstdlib>
#include <ctime>

#include <array>
#include <chrono>
#include <iomanip>
#include <ostream>
#include <tuple>

namespace toml
{

// To avoid non-threadsafe std::localtime. In C11 (not C++11!), localtime_s is
// provided in the absolutely same purpose, but C++11 is actually not compatible
// with C11. We need to dispatch the function depending on the OS.
namespace detail
{
// TODO: find more sophisticated way to handle this
#if (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 1) || defined(_XOPEN_SOURCE) || defined(_BSD_SOURCE) || defined(_SVID_SOURCE) || defined(_POSIX_SOURCE)
inline std::tm localtime_s(const std::time_t* src)
{
    std::tm dst;
    const auto result = ::localtime_r(src, &dst);
    if (!result) { throw std::runtime_error("localtime_r failed."); }
    return dst;
}
inline std::tm gmtime_s(const std::time_t* src)
{
    std::tm dst;
    const auto result = ::gmtime_r(src, &dst);
    if (!result) { throw std::runtime_error("gmtime_r failed."); }
    return dst;
}
#elif defined(_MSC_VER)
inline std::tm localtime_s(const std::time_t* src)
{
    std::tm dst;
    const auto result = ::localtime_s(&dst, src);
    if (result) { throw std::runtime_error("localtime_s failed."); }
    return dst;
}
inline std::tm gmtime_s(const std::time_t* src)
{
    std::tm dst;
    const auto result = ::gmtime_s(&dst, src);
    if (result) { throw std::runtime_error("gmtime_s failed."); }
    return dst;
}
#else // fallback. not threadsafe
inline std::tm localtime_s(const std::time_t* src)
{
    const auto result = std::localtime(src);
    if (!result) { throw std::runtime_error("localtime failed."); }
    return *result;
}
inline std::tm gmtime_s(const std::time_t* src)
{
    const auto result = std::gmtime(src);
    if (!result) { throw std::runtime_error("gmtime failed."); }
    return *result;
}
#endif
} // detail

enum class month_t : std::uint8_t
{
    Jan =  0,
    Feb =  1,
    Mar =  2,
    Apr =  3,
    May =  4,
    Jun =  5,
    Jul =  6,
    Aug =  7,
    Sep =  8,
    Oct =  9,
    Nov = 10,
    Dec = 11
};

struct local_date
{
    std::int16_t year;   // A.D. (like, 2018)
    std::uint8_t month;  // [0, 11]
    std::uint8_t day;    // [1, 31]

    local_date(int y, month_t m, int d)
        : year (static_cast<std::int16_t>(y)),
          month(static_cast<std::uint8_t>(m)),
          day  (static_cast<std::uint8_t>(d))
    {}

    explicit local_date(const std::tm& t)
        : year (static_cast<std::int16_t>(t.tm_year + 1900)),
          month(static_cast<std::uint8_t>(t.tm_mon)),
          day  (static_cast<std::uint8_t>(t.tm_mday))
    {}

    explicit local_date(const std::chrono::system_clock::time_point& tp)
    {
        const auto t    = std::chrono::system_clock::to_time_t(tp);
        const auto time = detail::localtime_s(&t);
        *this = local_date(time);
    }

    explicit local_date(const std::time_t t)
        : local_date(std::chrono::system_clock::from_time_t(t))
    {}

    operator std::chrono::system_clock::time_point() const
    {
        // std::mktime returns date as local time zone. no conversion needed
        std::tm t;
        t.tm_sec   = 0;
        t.tm_min   = 0;
        t.tm_hour  = 0;
        t.tm_mday  = static_cast<int>(this->day);
        t.tm_mon   = static_cast<int>(this->month);
        t.tm_year  = static_cast<int>(this->year) - 1900;
        t.tm_wday  = 0; // the value will be ignored
        t.tm_yday  = 0; // the value will be ignored
        t.tm_isdst = -1;
        return std::chrono::system_clock::from_time_t(std::mktime(&t));
    }

    operator std::time_t() const
    {
        return std::chrono::system_clock::to_time_t(
                std::chrono::system_clock::time_point(*this));
    }

    local_date() = default;
    ~local_date() = default;
    local_date(local_date const&) = default;
    local_date(local_date&&)      = default;
    local_date& operator=(local_date const&) = default;
    local_date& operator=(local_date&&)      = default;
};

inline bool operator==(const local_date& lhs, const local_date& rhs)
{
    return std::make_tuple(lhs.year, lhs.month, lhs.day) ==
           std::make_tuple(rhs.year, rhs.month, rhs.day);
}
inline bool operator!=(const local_date& lhs, const local_date& rhs)
{
    return !(lhs == rhs);
}
inline bool operator< (const local_date& lhs, const local_date& rhs)
{
    return std::make_tuple(lhs.year, lhs.month, lhs.day) <
           std::make_tuple(rhs.year, rhs.month, rhs.day);
}
inline bool operator<=(const local_date& lhs, const local_date& rhs)
{
    return (lhs < rhs) || (lhs == rhs);
}
inline bool operator> (const local_date& lhs, const local_date& rhs)
{
    return !(lhs <= rhs);
}
inline bool operator>=(const local_date& lhs, const local_date& rhs)
{
    return !(lhs < rhs);
}

template<typename charT, typename traits>
std::basic_ostream<charT, traits>&
operator<<(std::basic_ostream<charT, traits>& os, const local_date& date)
{
    os << std::setfill('0') << std::setw(4) << static_cast<int>(date.year )     << '-';
    os << std::setfill('0') << std::setw(2) << static_cast<int>(date.month) + 1 << '-';
    os << std::setfill('0') << std::setw(2) << static_cast<int>(date.day  )    ;
    return os;
}

struct local_time
{
    std::uint8_t  hour;        // [0, 23]
    std::uint8_t  minute;      // [0, 59]
    std::uint8_t  second;      // [0, 60]
    std::uint16_t millisecond; // [0, 999]
    std::uint16_t microsecond; // [0, 999]
    std::uint16_t nanosecond;  // [0, 999]

    local_time(int h, int m, int s,
               int ms = 0, int us = 0, int ns = 0)
        : hour  (static_cast<std::uint8_t>(h)),
          minute(static_cast<std::uint8_t>(m)),
          second(static_cast<std::uint8_t>(s)),
          millisecond(static_cast<std::uint16_t>(ms)),
          microsecond(static_cast<std::uint16_t>(us)),
          nanosecond (static_cast<std::uint16_t>(ns))
    {}

    explicit local_time(const std::tm& t)
        : hour  (static_cast<std::uint8_t>(t.tm_hour)),
          minute(static_cast<std::uint8_t>(t.tm_min)),
          second(static_cast<std::uint8_t>(t.tm_sec)),
          millisecond(0), microsecond(0), nanosecond(0)
    {}

    template<typename Rep, typename Period>
    explicit local_time(const std::chrono::duration<Rep, Period>& t)
    {
        const auto h = std::chrono::duration_cast<std::chrono::hours>(t);
        this->hour = static_cast<std::uint8_t>(h.count());
        const auto t2 = t - h;
        const auto m = std::chrono::duration_cast<std::chrono::minutes>(t2);
        this->minute = static_cast<std::uint8_t>(m.count());
        const auto t3 = t2 - m;
        const auto s = std::chrono::duration_cast<std::chrono::seconds>(t3);
        this->second = static_cast<std::uint8_t>(s.count());
        const auto t4 = t3 - s;
        const auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(t4);
        this->millisecond = static_cast<std::uint16_t>(ms.count());
        const auto t5 = t4 - ms;
        const auto us = std::chrono::duration_cast<std::chrono::microseconds>(t5);
        this->microsecond = static_cast<std::uint16_t>(us.count());
        const auto t6 = t5 - us;
        const auto ns = std::chrono::duration_cast<std::chrono::nanoseconds>(t6);
        this->nanosecond = static_cast<std::uint16_t>(ns.count());
    }

    operator std::chrono::nanoseconds() const
    {
        return std::chrono::nanoseconds (this->nanosecond)  +
               std::chrono::microseconds(this->microsecond) +
               std::chrono::milliseconds(this->millisecond) +
               std::chrono::seconds(this->second) +
               std::chrono::minutes(this->minute) +
               std::chrono::hours(this->hour);
    }

    local_time() = default;
    ~local_time() = default;
    local_time(local_time const&) = default;
    local_time(local_time&&)      = default;
    local_time& operator=(local_time const&) = default;
    local_time& operator=(local_time&&)      = default;
};

inline bool operator==(const local_time& lhs, const local_time& rhs)
{
    return std::make_tuple(lhs.hour, lhs.minute, lhs.second, lhs.millisecond, lhs.microsecond, lhs.nanosecond) ==
           std::make_tuple(rhs.hour, rhs.minute, rhs.second, rhs.millisecond, rhs.microsecond, rhs.nanosecond);
}
inline bool operator!=(const local_time& lhs, const local_time& rhs)
{
    return !(lhs == rhs);
}
inline bool operator< (const local_time& lhs, const local_time& rhs)
{
    return std::make_tuple(lhs.hour, lhs.minute, lhs.second, lhs.millisecond, lhs.microsecond, lhs.nanosecond) <
           std::make_tuple(rhs.hour, rhs.minute, rhs.second, rhs.millisecond, rhs.microsecond, rhs.nanosecond);
}
inline bool operator<=(const local_time& lhs, const local_time& rhs)
{
    return (lhs < rhs) || (lhs == rhs);
}
inline bool operator> (const local_time& lhs, const local_time& rhs)
{
    return !(lhs <= rhs);
}
inline bool operator>=(const local_time& lhs, const local_time& rhs)
{
    return !(lhs < rhs);
}

template<typename charT, typename traits>
std::basic_ostream<charT, traits>&
operator<<(std::basic_ostream<charT, traits>& os, const local_time& time)
{
    os << std::setfill('0') << std::setw(2) << static_cast<int>(time.hour  ) << ':';
    os << std::setfill('0') << std::setw(2) << static_cast<int>(time.minute) << ':';
    os << std::setfill('0') << std::setw(2) << static_cast<int>(time.second);
    if(time.millisecond != 0 || time.microsecond != 0 || time.nanosecond != 0)
    {
        os << '.';
        os << std::setfill('0') << std::setw(3) << static_cast<int>(time.millisecond);
        if(time.microsecond != 0 || time.nanosecond != 0)
        {
            os << std::setfill('0') << std::setw(3) << static_cast<int>(time.microsecond);
            if(time.nanosecond != 0)
            {
                os << std::setfill('0') << std::setw(3) << static_cast<int>(time.nanosecond);
            }
        }
    }
    return os;
}

struct time_offset
{
    std::int8_t hour;   // [-12, 12]
    std::int8_t minute; // [-59, 59]

    time_offset(int h, int m)
        : hour  (static_cast<std::int8_t>(h)),
          minute(static_cast<std::int8_t>(m))
    {}

    operator std::chrono::minutes() const
    {
        return std::chrono::minutes(this->minute) +
               std::chrono::hours(this->hour);
    }

    time_offset() = default;
    ~time_offset() = default;
    time_offset(time_offset const&) = default;
    time_offset(time_offset&&)      = default;
    time_offset& operator=(time_offset const&) = default;
    time_offset& operator=(time_offset&&)      = default;
};

inline bool operator==(const time_offset& lhs, const time_offset& rhs)
{
    return std::make_tuple(lhs.hour, lhs.minute) ==
           std::make_tuple(rhs.hour, rhs.minute);
}
inline bool operator!=(const time_offset& lhs, const time_offset& rhs)
{
    return !(lhs == rhs);
}
inline bool operator< (const time_offset& lhs, const time_offset& rhs)
{
    return std::make_tuple(lhs.hour, lhs.minute) <
           std::make_tuple(rhs.hour, rhs.minute);
}
inline bool operator<=(const time_offset& lhs, const time_offset& rhs)
{
    return (lhs < rhs) || (lhs == rhs);
}
inline bool operator> (const time_offset& lhs, const time_offset& rhs)
{
    return !(lhs <= rhs);
}
inline bool operator>=(const time_offset& lhs, const time_offset& rhs)
{
    return !(lhs < rhs);
}

template<typename charT, typename traits>
std::basic_ostream<charT, traits>&
operator<<(std::basic_ostream<charT, traits>& os, const time_offset& offset)
{
    if(offset.hour == 0 && offset.minute == 0)
    {
        os << 'Z';
        return os;
    }
    int minute = static_cast<int>(offset.hour) * 60 + offset.minute;
    if(minute < 0){os << '-'; minute = std::abs(minute);} else {os << '+';}
    os << std::setfill('0') << std::setw(2) << minute / 60 << ':';
    os << std::setfill('0') << std::setw(2) << minute % 60;
    return os;
}

struct local_datetime
{
    local_date date;
    local_time time;

    local_datetime(local_date d, local_time t): date(d), time(t) {}

    explicit local_datetime(const std::tm& t): date(t), time(t){}

    explicit local_datetime(const std::chrono::system_clock::time_point& tp)
    {
        const auto t = std::chrono::system_clock::to_time_t(tp);
        std::tm ltime = detail::localtime_s(&t);

        this->date = local_date(ltime);
        this->time = local_time(ltime);

        // std::tm lacks subsecond information, so diff between tp and tm
        // can be used to get millisecond & microsecond information.
        const auto t_diff = tp -
            std::chrono::system_clock::from_time_t(std::mktime(&ltime));
        this->time.millisecond = static_cast<std::uint16_t>(
          std::chrono::duration_cast<std::chrono::milliseconds>(t_diff).count());
        this->time.microsecond = static_cast<std::uint16_t>(
          std::chrono::duration_cast<std::chrono::microseconds>(t_diff).count());
        this->time.nanosecond = static_cast<std::uint16_t>(
          std::chrono::duration_cast<std::chrono::nanoseconds >(t_diff).count());
    }

    explicit local_datetime(const std::time_t t)
        : local_datetime(std::chrono::system_clock::from_time_t(t))
    {}

    operator std::chrono::system_clock::time_point() const
    {
        using internal_duration =
            typename std::chrono::system_clock::time_point::duration;

        // Normally DST begins at A.M. 3 or 4. If we re-use conversion operator
        // of local_date and local_time independently, the conversion fails if
        // it is the day when DST begins or ends. Since local_date considers the
        // time is 00:00 A.M. and local_time does not consider DST because it
        // does not have any date information. We need to consider both date and
        // time information at the same time to convert it correctly.

        std::tm t;
        t.tm_sec   = static_cast<int>(this->time.second);
        t.tm_min   = static_cast<int>(this->time.minute);
        t.tm_hour  = static_cast<int>(this->time.hour);
        t.tm_mday  = static_cast<int>(this->date.day);
        t.tm_mon   = static_cast<int>(this->date.month);
        t.tm_year  = static_cast<int>(this->date.year) - 1900;
        t.tm_wday  = 0; // the value will be ignored
        t.tm_yday  = 0; // the value will be ignored
        t.tm_isdst = -1;

        // std::mktime returns date as local time zone. no conversion needed
        auto dt = std::chrono::system_clock::from_time_t(std::mktime(&t));
        dt += std::chrono::duration_cast<internal_duration>(
                std::chrono::milliseconds(this->time.millisecond) +
                std::chrono::microseconds(this->time.microsecond) +
                std::chrono::nanoseconds (this->time.nanosecond));
        return dt;
    }

    operator std::time_t() const
    {
        return std::chrono::system_clock::to_time_t(
                std::chrono::system_clock::time_point(*this));
    }

    local_datetime() = default;
    ~local_datetime() = default;
    local_datetime(local_datetime const&) = default;
    local_datetime(local_datetime&&)      = default;
    local_datetime& operator=(local_datetime const&) = default;
    local_datetime& operator=(local_datetime&&)      = default;
};

inline bool operator==(const local_datetime& lhs, const local_datetime& rhs)
{
    return std::make_tuple(lhs.date, lhs.time) ==
           std::make_tuple(rhs.date, rhs.time);
}
inline bool operator!=(const local_datetime& lhs, const local_datetime& rhs)
{
    return !(lhs == rhs);
}
inline bool operator< (const local_datetime& lhs, const local_datetime& rhs)
{
    return std::make_tuple(lhs.date, lhs.time) <
           std::make_tuple(rhs.date, rhs.time);
}
inline bool operator<=(const local_datetime& lhs, const local_datetime& rhs)
{
    return (lhs < rhs) || (lhs == rhs);
}
inline bool operator> (const local_datetime& lhs, const local_datetime& rhs)
{
    return !(lhs <= rhs);
}
inline bool operator>=(const local_datetime& lhs, const local_datetime& rhs)
{
    return !(lhs < rhs);
}

template<typename charT, typename traits>
std::basic_ostream<charT, traits>&
operator<<(std::basic_ostream<charT, traits>& os, const local_datetime& dt)
{
    os << dt.date << 'T' << dt.time;
    return os;
}

struct offset_datetime
{
    local_date  date;
    local_time  time;
    time_offset offset;

    offset_datetime(local_date d, local_time t, time_offset o)
        : date(d), time(t), offset(o)
    {}
    offset_datetime(const local_datetime& dt, time_offset o)
        : date(dt.date), time(dt.time), offset(o)
    {}
    explicit offset_datetime(const local_datetime& ld)
        : date(ld.date), time(ld.time), offset(get_local_offset(nullptr))
          // use the current local timezone offset
    {}
    explicit offset_datetime(const std::chrono::system_clock::time_point& tp)
        : offset(0, 0) // use gmtime
    {
        const auto timet = std::chrono::system_clock::to_time_t(tp);
        const auto tm    = detail::gmtime_s(&timet);
        this->date = local_date(tm);
        this->time = local_time(tm);
    }
    explicit offset_datetime(const std::time_t& t)
        : offset(0, 0) // use gmtime
    {
        const auto tm    = detail::gmtime_s(&t);
        this->date = local_date(tm);
        this->time = local_time(tm);
    }
    explicit offset_datetime(const std::tm& t)
        : offset(0, 0) // assume gmtime
    {
        this->date = local_date(t);
        this->time = local_time(t);
    }

    operator std::chrono::system_clock::time_point() const
    {
        // get date-time
        using internal_duration =
            typename std::chrono::system_clock::time_point::duration;

        // first, convert it to local date-time information in the same way as
        // local_datetime does. later we will use time_t to adjust time offset.
        std::tm t;
        t.tm_sec   = static_cast<int>(this->time.second);
        t.tm_min   = static_cast<int>(this->time.minute);
        t.tm_hour  = static_cast<int>(this->time.hour);
        t.tm_mday  = static_cast<int>(this->date.day);
        t.tm_mon   = static_cast<int>(this->date.month);
        t.tm_year  = static_cast<int>(this->date.year) - 1900;
        t.tm_wday  = 0; // the value will be ignored
        t.tm_yday  = 0; // the value will be ignored
        t.tm_isdst = -1;
        const std::time_t tp_loc = std::mktime(std::addressof(t));

        auto tp = std::chrono::system_clock::from_time_t(tp_loc);
        tp += std::chrono::duration_cast<internal_duration>(
                std::chrono::milliseconds(this->time.millisecond) +
                std::chrono::microseconds(this->time.microsecond) +
                std::chrono::nanoseconds (this->time.nanosecond));

        // Since mktime uses local time zone, it should be corrected.
        // `12:00:00+09:00` means `03:00:00Z`. So mktime returns `03:00:00Z` if
        // we are in `+09:00` timezone. To represent `12:00:00Z` there, we need
        // to add `+09:00` to `03:00:00Z`.
        //    Here, it uses the time_t converted from date-time info to handle
        // daylight saving time.
        const auto ofs = get_local_offset(std::addressof(tp_loc));
        tp += std::chrono::hours  (ofs.hour);
        tp += std::chrono::minutes(ofs.minute);

        // We got `12:00:00Z` by correcting local timezone applied by mktime.
        // Then we will apply the offset. Let's say `12:00:00-08:00` is given.
        // And now, we have `12:00:00Z`. `12:00:00-08:00` means `20:00:00Z`.
        // So we need to subtract the offset.
        tp -= std::chrono::minutes(this->offset);
        return tp;
    }

    operator std::time_t() const
    {
        return std::chrono::system_clock::to_time_t(
                std::chrono::system_clock::time_point(*this));
    }

    offset_datetime() = default;
    ~offset_datetime() = default;
    offset_datetime(offset_datetime const&) = default;
    offset_datetime(offset_datetime&&)      = default;
    offset_datetime& operator=(offset_datetime const&) = default;
    offset_datetime& operator=(offset_datetime&&)      = default;

  private:

    static time_offset get_local_offset(const std::time_t* tp)
    {
        // get local timezone with the same date-time information as mktime
        const auto t = detail::localtime_s(tp);

        std::array<char, 6> buf;
        const auto result = std::strftime(buf.data(), 6, "%z", &t); // +hhmm\0
        if(result != 5)
        {
            throw std::runtime_error("toml::offset_datetime: cannot obtain "
                                     "timezone information of current env");
        }
        const int ofs = std::atoi(buf.data());
        const int ofs_h = ofs / 100;
        const int ofs_m = ofs - (ofs_h * 100);
        return time_offset(ofs_h, ofs_m);
    }
};

inline bool operator==(const offset_datetime& lhs, const offset_datetime& rhs)
{
    return std::make_tuple(lhs.date, lhs.time, lhs.offset) ==
           std::make_tuple(rhs.date, rhs.time, rhs.offset);
}
inline bool operator!=(const offset_datetime& lhs, const offset_datetime& rhs)
{
    return !(lhs == rhs);
}
inline bool operator< (const offset_datetime& lhs, const offset_datetime& rhs)
{
    return std::make_tuple(lhs.date, lhs.time, lhs.offset) <
           std::make_tuple(rhs.date, rhs.time, rhs.offset);
}
inline bool operator<=(const offset_datetime& lhs, const offset_datetime& rhs)
{
    return (lhs < rhs) || (lhs == rhs);
}
inline bool operator> (const offset_datetime& lhs, const offset_datetime& rhs)
{
    return !(lhs <= rhs);
}
inline bool operator>=(const offset_datetime& lhs, const offset_datetime& rhs)
{
    return !(lhs < rhs);
}

template<typename charT, typename traits>
std::basic_ostream<charT, traits>&
operator<<(std::basic_ostream<charT, traits>& os, const offset_datetime& dt)
{
    os << dt.date << 'T' << dt.time << dt.offset;
    return os;
}

}//toml
#endif// TOML11_DATETIME

```

`Dependencies/toml11/toml/exception.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_EXCEPTION_HPP
#define TOML11_EXCEPTION_HPP
#include <stdexcept>
#include <string>

#include "source_location.hpp"

namespace toml
{

struct exception : public std::exception
{
  public:
    explicit exception(const source_location& loc): loc_(loc) {}
    virtual ~exception() noexcept override = default;
    virtual const char* what() const noexcept override {return "";}
    virtual source_location const& location() const noexcept {return loc_;}

  protected:
    source_location loc_;
};

struct syntax_error : public toml::exception
{
  public:
    explicit syntax_error(const std::string& what_arg, const source_location& loc)
        : exception(loc), what_(what_arg)
    {}
    virtual ~syntax_error() noexcept override = default;
    virtual const char* what() const noexcept override {return what_.c_str();}

  protected:
    std::string what_;
};

struct type_error : public toml::exception
{
  public:
    explicit type_error(const std::string& what_arg, const source_location& loc)
        : exception(loc), what_(what_arg)
    {}
    virtual ~type_error() noexcept override = default;
    virtual const char* what() const noexcept override {return what_.c_str();}

  protected:
    std::string what_;
};

struct internal_error : public toml::exception
{
  public:
    explicit internal_error(const std::string& what_arg, const source_location& loc)
        : exception(loc), what_(what_arg)
    {}
    virtual ~internal_error() noexcept override = default;
    virtual const char* what() const noexcept override {return what_.c_str();}

  protected:
    std::string what_;
};

} // toml
#endif // TOML_EXCEPTION

```

`Dependencies/toml11/toml/from.hpp`:

```hpp
//     Copyright Toru Niina 2019.
// Distributed under the MIT License.
#ifndef TOML11_FROM_HPP
#define TOML11_FROM_HPP
#include "traits.hpp"

namespace toml
{

template<typename T>
struct from;
// {
//     static T from_toml(const toml::value& v)
//     {
//         // User-defined conversions ...
//     }
// };

} // toml
#endif // TOML11_FROM_HPP

```

`Dependencies/toml11/toml/get.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_GET_HPP
#define TOML11_GET_HPP
#include <algorithm>

#include "from.hpp"
#include "result.hpp"
#include "value.hpp"

namespace toml
{

// ============================================================================
// exact toml::* type

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T> &
get(basic_value<C, M, V>& v)
{
    return v.template cast<detail::type_to_enum<T, basic_value<C, M, V>>::value>();
}

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T> const&
get(const basic_value<C, M, V>& v)
{
    return v.template cast<detail::type_to_enum<T, basic_value<C, M, V>>::value>();
}

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T>
get(basic_value<C, M, V>&& v)
{
    return T(std::move(v).template cast<detail::type_to_enum<T, basic_value<C, M, V>>::value>());
}

// ============================================================================
// T == toml::value; identity transformation.

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
inline detail::enable_if_t<std::is_same<T, basic_value<C, M, V>>::value, T>&
get(basic_value<C, M, V>& v)
{
    return v;
}

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
inline detail::enable_if_t<std::is_same<T, basic_value<C, M, V>>::value, T> const&
get(const basic_value<C, M, V>& v)
{
    return v;
}

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
inline detail::enable_if_t<std::is_same<T, basic_value<C, M, V>>::value, T>
get(basic_value<C, M, V>&& v)
{
    return basic_value<C, M, V>(std::move(v));
}

// ============================================================================
// T == toml::basic_value<C2, M2, V2>; basic_value -> basic_value

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
inline detail::enable_if_t<detail::conjunction<detail::is_basic_value<T>,
    detail::negation<std::is_same<T, basic_value<C, M, V>>>
    >::value, T>
get(const basic_value<C, M, V>& v)
{
    return T(v);
}

// ============================================================================
// integer convertible from toml::Integer

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
inline detail::enable_if_t<detail::conjunction<
    std::is_integral<T>,                            // T is integral
    detail::negation<std::is_same<T, bool>>,        // but not bool
    detail::negation<                               // but not toml::integer
        detail::is_exact_toml_type<T, basic_value<C, M, V>>>
    >::value, T>
get(const basic_value<C, M, V>& v)
{
    return static_cast<T>(v.as_integer());
}

// ============================================================================
// floating point convertible from toml::Float

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
inline detail::enable_if_t<detail::conjunction<
    std::is_floating_point<T>,                      // T is floating_point
    detail::negation<                               // but not toml::floating
        detail::is_exact_toml_type<T, basic_value<C, M, V>>>
    >::value, T>
get(const basic_value<C, M, V>& v)
{
    return static_cast<T>(v.as_floating());
}

// ============================================================================
// std::string; toml uses its own toml::string, but it should be convertible to
// std::string seamlessly

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
inline detail::enable_if_t<std::is_same<T, std::string>::value, std::string>&
get(basic_value<C, M, V>& v)
{
    return v.as_string().str;
}

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
inline detail::enable_if_t<std::is_same<T, std::string>::value, std::string> const&
get(const basic_value<C, M, V>& v)
{
    return v.as_string().str;
}

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
inline detail::enable_if_t<std::is_same<T, std::string>::value, std::string>
get(basic_value<C, M, V>&& v)
{
    return std::string(std::move(v.as_string().str));
}

// ============================================================================
// std::string_view

#if __cplusplus >= 201703L
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
inline detail::enable_if_t<std::is_same<T, std::string_view>::value, std::string_view>
get(const basic_value<C, M, V>& v)
{
    return std::string_view(v.as_string().str);
}
#endif

// ============================================================================
// std::chrono::duration from toml::local_time.

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
inline detail::enable_if_t<detail::is_chrono_duration<T>::value, T>
get(const basic_value<C, M, V>& v)
{
    return std::chrono::duration_cast<T>(
            std::chrono::nanoseconds(v.as_local_time()));
}

// ============================================================================
// std::chrono::system_clock::time_point from toml::datetime variants

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
inline detail::enable_if_t<
    std::is_same<std::chrono::system_clock::time_point, T>::value, T>
get(const basic_value<C, M, V>& v)
{
    switch(v.type())
    {
        case value_t::local_date:
        {
            return std::chrono::system_clock::time_point(v.as_local_date());
        }
        case value_t::local_datetime:
        {
            return std::chrono::system_clock::time_point(v.as_local_datetime());
        }
        case value_t::offset_datetime:
        {
            return std::chrono::system_clock::time_point(v.as_offset_datetime());
        }
        default:
        {
            throw type_error(detail::format_underline("toml::value: "
                "bad_cast to std::chrono::system_clock::time_point", {
                    {v.location(), concat_to_string("the actual type is ", v.type())}
                }), v.location());
        }
    }
}

// ============================================================================
// forward declaration to use this recursively. ignore this and go ahead.

// array-like type with push_back(value) method
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::conjunction<
    detail::is_container<T>,         // T is a container
    detail::has_push_back_method<T>, // T::push_back(value) works
    detail::negation<                // but not toml::array
        detail::is_exact_toml_type<T, basic_value<C, M, V>>>
    >::value, T>
get(const basic_value<C, M, V>&);

// array-like type without push_back(value) method
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::conjunction<
    detail::is_container<T>,                           // T is a container
    detail::negation<detail::has_push_back_method<T>>, // w/o push_back(...)
    detail::negation<                                  // not toml::array
        detail::is_exact_toml_type<T, basic_value<C, M, V>>>
    >::value, T>
get(const basic_value<C, M, V>&);

// std::pair<T1, T2>
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::is_std_pair<T>::value, T>
get(const basic_value<C, M, V>&);

// std::tuple<T1, T2, ...>
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::is_std_tuple<T>::value, T>
get(const basic_value<C, M, V>&);

// map-like classes
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::conjunction<
    detail::is_map<T>, // T is map
    detail::negation<  // but not toml::table
        detail::is_exact_toml_type<T, basic_value<C, M, V>>>
    >::value, T>
get(const basic_value<C, M, V>&);

// T.from_toml(v)
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::conjunction<
    detail::negation<                         // not a toml::* type
        detail::is_exact_toml_type<T, basic_value<C, M, V>>>,
    detail::has_from_toml_method<T, C, M, V>, // but has from_toml(toml::value)
    std::is_default_constructible<T>          // and default constructible
    >::value, T>
get(const basic_value<C, M, V>&);

// toml::from<T>::from_toml(v)
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V,
         std::size_t S = sizeof(::toml::from<T>)>
T get(const basic_value<C, M, V>&);

// T(const toml::value&) and T is not toml::basic_value
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::conjunction<
    detail::negation<detail::is_basic_value<T>>,
    std::is_constructible<T, const basic_value<C, M, V>&>
    >::value, T>
get(const basic_value<C, M, V>&);

// ============================================================================
// array-like types; most likely STL container, like std::vector, etc.

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::conjunction<
    detail::is_container<T>,         // T is a container
    detail::has_push_back_method<T>, // container.push_back(elem) works
    detail::negation<                // but not toml::array
        detail::is_exact_toml_type<T, basic_value<C, M, V>>>
    >::value, T>
get(const basic_value<C, M, V>& v)
{
    using value_type = typename T::value_type;
    const auto& ary = v.as_array();

    T container;
    try_reserve(container, ary.size());

    for(const auto& elem : ary)
    {
        container.push_back(get<value_type>(elem));
    }
    return container;
}

// ============================================================================
// std::forward_list does not have push_back, insert, or emplace.
// It has insert_after, emplace_after, push_front.

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::is_std_forward_list<T>::value, T>
get(const basic_value<C, M, V>& v)
{
    using value_type = typename T::value_type;
    T container;
    for(const auto& elem : v.as_array())
    {
        container.push_front(get<value_type>(elem));
    }
    container.reverse();
    return container;
}

// ============================================================================
// array-like types, without push_back(). most likely [std|boost]::array.

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::conjunction<
    detail::is_container<T>,                           // T is a container
    detail::negation<detail::has_push_back_method<T>>, // w/o push_back
    detail::negation<                                  // T is not toml::array
        detail::is_exact_toml_type<T, basic_value<C, M, V>>>
    >::value, T>
get(const basic_value<C, M, V>& v)
{
    using value_type = typename T::value_type;
    const auto& ar = v.as_array();

    T container;
    if(ar.size() != container.size())
    {
        throw std::out_of_range(detail::format_underline(concat_to_string(
            "toml::get: specified container size is ", container.size(),
            " but there are ", ar.size(), " elements in toml array."), {
                {v.location(), "here"}
            }));
    }
    std::transform(ar.cbegin(), ar.cend(), container.begin(),
                   [](const value& x){return ::toml::get<value_type>(x);});
    return container;
}

// ============================================================================
// std::pair.

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::is_std_pair<T>::value, T>
get(const basic_value<C, M, V>& v)
{
    using first_type  = typename T::first_type;
    using second_type = typename T::second_type;

    const auto& ar = v.as_array();
    if(ar.size() != 2)
    {
        throw std::out_of_range(detail::format_underline(concat_to_string(
            "toml::get: specified std::pair but there are ", ar.size(),
            " elements in toml array."), {{v.location(), "here"}}));
    }
    return std::make_pair(::toml::get<first_type >(ar.at(0)),
                          ::toml::get<second_type>(ar.at(1)));
}

// ============================================================================
// std::tuple.

namespace detail
{
template<typename T, typename Array, std::size_t ... I>
T get_tuple_impl(const Array& a, index_sequence<I...>)
{
    return std::make_tuple(
        ::toml::get<typename std::tuple_element<I, T>::type>(a.at(I))...);
}
} // detail

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::is_std_tuple<T>::value, T>
get(const basic_value<C, M, V>& v)
{
    const auto& ar = v.as_array();
    if(ar.size() != std::tuple_size<T>::value)
    {
        throw std::out_of_range(detail::format_underline(concat_to_string(
            "toml::get: specified std::tuple with ",
            std::tuple_size<T>::value, " elements, but there are ", ar.size(),
            " elements in toml array."), {{v.location(), "here"}}));
    }
    return detail::get_tuple_impl<T>(ar,
            detail::make_index_sequence<std::tuple_size<T>::value>{});
}

// ============================================================================
// map-like types; most likely STL map, like std::map or std::unordered_map.

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::conjunction<
    detail::is_map<T>, // T is map
    detail::negation<  // but not toml::array
        detail::is_exact_toml_type<T, basic_value<C, M, V>>>
    >::value, T>
get(const basic_value<C, M, V>& v)
{
    using key_type    = typename T::key_type;
    using mapped_type = typename T::mapped_type;
    static_assert(std::is_convertible<std::string, key_type>::value,
                  "toml::get only supports map type of which key_type is "
                  "convertible from std::string.");
    T map;
    for(const auto& kv : v.as_table())
    {
        map.emplace(key_type(kv.first), get<mapped_type>(kv.second));
    }
    return map;
}

// ============================================================================
// user-defined, but compatible types.

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::conjunction<
    detail::negation<                         // not a toml::* type
        detail::is_exact_toml_type<T, basic_value<C, M, V>>>,
    detail::has_from_toml_method<T, C, M, V>, // but has from_toml(toml::value) memfn
    std::is_default_constructible<T>          // and default constructible
    >::value, T>
get(const basic_value<C, M, V>& v)
{
    T ud;
    ud.from_toml(v);
    return ud;
}
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V,
         std::size_t>
T get(const basic_value<C, M, V>& v)
{
    return ::toml::from<T>::from_toml(v);
}

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::conjunction<
    detail::negation<detail::is_basic_value<T>>,
    std::is_constructible<T, const basic_value<C, M, V>&>
    >::value, T>
get(const basic_value<C, M, V>& v)
{
    return T(v);
}

// ============================================================================
// find

// ----------------------------------------------------------------------------
// these overloads do not require to set T. and returns value itself.
template<typename C,
         template<typename ...> class M, template<typename ...> class V>
basic_value<C, M, V> const& find(const basic_value<C, M, V>& v, const key& ky)
{
    const auto& tab = v.as_table();
    if(tab.count(ky) == 0)
    {
        detail::throw_key_not_found_error(v, ky);
    }
    return tab.at(ky);
}
template<typename C,
         template<typename ...> class M, template<typename ...> class V>
basic_value<C, M, V>& find(basic_value<C, M, V>& v, const key& ky)
{
    auto& tab = v.as_table();
    if(tab.count(ky) == 0)
    {
        detail::throw_key_not_found_error(v, ky);
    }
    return tab.at(ky);
}
template<typename C,
         template<typename ...> class M, template<typename ...> class V>
basic_value<C, M, V> find(basic_value<C, M, V>&& v, const key& ky)
{
    typename basic_value<C, M, V>::table_type tab = std::move(v).as_table();
    if(tab.count(ky) == 0)
    {
        detail::throw_key_not_found_error(v, ky);
    }
    return basic_value<C, M, V>(std::move(tab.at(ky)));
}

// ----------------------------------------------------------------------------
// find(value, idx)
template<typename C,
         template<typename ...> class M, template<typename ...> class V>
basic_value<C, M, V> const&
find(const basic_value<C, M, V>& v, const std::size_t idx)
{
    const auto& ary = v.as_array();
    if(ary.size() <= idx)
    {
        throw std::out_of_range(detail::format_underline(concat_to_string(
            "index ", idx, " is out of range"), {{v.location(), "in this array"}}));
    }
    return ary.at(idx);
}
template<typename C,
         template<typename ...> class M, template<typename ...> class V>
basic_value<C, M, V>& find(basic_value<C, M, V>& v, const std::size_t idx)
{
    auto& ary = v.as_array();
    if(ary.size() <= idx)
    {
        throw std::out_of_range(detail::format_underline(concat_to_string(
            "index ", idx, " is out of range"), {{v.location(), "in this array"}}));
    }
    return ary.at(idx);
}
template<typename C,
         template<typename ...> class M, template<typename ...> class V>
basic_value<C, M, V> find(basic_value<C, M, V>&& v, const std::size_t idx)
{
    auto& ary = v.as_array();
    if(ary.size() <= idx)
    {
        throw std::out_of_range(detail::format_underline(concat_to_string(
            "index ", idx, " is out of range"), {{v.location(), "in this array"}}));
    }
    return basic_value<C, M, V>(std::move(ary.at(idx)));
}

// ----------------------------------------------------------------------------
// find<T>(value, key);

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
decltype(::toml::get<T>(std::declval<basic_value<C, M, V> const&>()))
find(const basic_value<C, M, V>& v, const key& ky)
{
    const auto& tab = v.as_table();
    if(tab.count(ky) == 0)
    {
        detail::throw_key_not_found_error(v, ky);
    }
    return ::toml::get<T>(tab.at(ky));
}

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
decltype(::toml::get<T>(std::declval<basic_value<C, M, V>&>()))
find(basic_value<C, M, V>& v, const key& ky)
{
    auto& tab = v.as_table();
    if(tab.count(ky) == 0)
    {
        detail::throw_key_not_found_error(v, ky);
    }
    return ::toml::get<T>(tab.at(ky));
}

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
decltype(::toml::get<T>(std::declval<basic_value<C, M, V>&&>()))
find(basic_value<C, M, V>&& v, const key& ky)
{
    typename basic_value<C, M, V>::table_type tab = std::move(v).as_table();
    if(tab.count(ky) == 0)
    {
        detail::throw_key_not_found_error(v, ky);
    }
    return ::toml::get<T>(std::move(tab.at(ky)));
}

// ----------------------------------------------------------------------------
// find<T>(value, idx)
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
decltype(::toml::get<T>(std::declval<basic_value<C, M, V> const&>()))
find(const basic_value<C, M, V>& v, const std::size_t idx)
{
    const auto& ary = v.as_array();
    if(ary.size() <= idx)
    {
        throw std::out_of_range(detail::format_underline(concat_to_string(
            "index ", idx, " is out of range"), {{v.location(), "in this array"}}));
    }
    return ::toml::get<T>(ary.at(idx));
}
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
decltype(::toml::get<T>(std::declval<basic_value<C, M, V>&>()))
find(basic_value<C, M, V>& v, const std::size_t idx)
{
    auto& ary = v.as_array();
    if(ary.size() <= idx)
    {
        throw std::out_of_range(detail::format_underline(concat_to_string(
            "index ", idx, " is out of range"), {{v.location(), "in this array"}}));
    }
    return ::toml::get<T>(ary.at(idx));
}
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
decltype(::toml::get<T>(std::declval<basic_value<C, M, V>&&>()))
find(basic_value<C, M, V>&& v, const std::size_t idx)
{
    typename basic_value<C, M, V>::array_type ary = std::move(v).as_array();
    if(ary.size() <= idx)
    {
        throw std::out_of_range(detail::format_underline(concat_to_string(
            "index ", idx, " is out of range"), {{v.location(), "in this array"}}));
    }
    return ::toml::get<T>(std::move(ary.at(idx)));
}

// --------------------------------------------------------------------------
// toml::find(toml::value, toml::key, Ts&& ... keys)

namespace detail
{
// It suppresses warnings by -Wsign-conversion. Let's say we have the following
// code.
// ```cpp
// const auto x = toml::find<std::string>(data, "array", 0);
// ```
// Here, the type of literal number `0` is `int`. `int` is a signed integer.
// `toml::find` takes `std::size_t` as an index. So it causes implicit sign
// conversion and `-Wsign-conversion` warns about it. Using `0u` instead of `0`
// suppresses the warning, but it makes user code messy.
//     To suppress this warning, we need to be aware of type conversion caused
// by `toml::find(v, key1, key2, ... keys)`. But the thing is that the types of
// keys can be any combination of {string-like, size_t-like}. Of course we can't
// write down all the combinations. Thus we need to use some function that
// recognize the type of argument and cast it into `std::string` or
// `std::size_t` depending on the context.
//     `key_cast` does the job. It has 2 overloads. One is invoked when the
// argument type is an integer and cast the argument into `std::size_t`. The
// other is invoked when the argument type is not an integer, possibly one of
// std::string, const char[N] or const char*, and construct std::string from
// the argument.
//     `toml::find(v, k1, k2, ... ks)` uses `key_cast` before passing `ks` to
// `toml::find(v, k)` to suppress -Wsign-conversion.

template<typename T>
enable_if_t<conjunction<std::is_integral<remove_cvref_t<T>>,
            negation<std::is_same<remove_cvref_t<T>, bool>>>::value, std::size_t>
key_cast(T&& v) noexcept
{
    return std::size_t(v);
}
template<typename T>
enable_if_t<negation<conjunction<std::is_integral<remove_cvref_t<T>>,
            negation<std::is_same<remove_cvref_t<T>, bool>>>>::value, std::string>
key_cast(T&& v) noexcept
{
    return std::string(std::forward<T>(v));
}
} // detail

template<typename C,
         template<typename ...> class M, template<typename ...> class V,
         typename Key1, typename Key2, typename ... Keys>
const basic_value<C, M, V>&
find(const basic_value<C, M, V>& v, Key1&& k1, Key2&& k2, Keys&& ... keys)
{
    return ::toml::find(::toml::find(v, detail::key_cast(k1)),
            detail::key_cast(k2), std::forward<Keys>(keys)...);
}
template<typename C,
         template<typename ...> class M, template<typename ...> class V,
         typename Key1, typename Key2, typename ... Keys>
basic_value<C, M, V>&
find(basic_value<C, M, V>& v, Key1&& k1, Key2&& k2, Keys&& ... keys)
{
    return ::toml::find(::toml::find(v, detail::key_cast(k1)),
            detail::key_cast(k2), std::forward<Keys>(keys)...);
}
template<typename C,
         template<typename ...> class M, template<typename ...> class V,
         typename Key1, typename Key2, typename ... Keys>
basic_value<C, M, V>
find(basic_value<C, M, V>&& v, Key1&& k1, Key2&& k2, Keys&& ... keys)
{
    return ::toml::find(::toml::find(std::move(v), std::forward<Key1>(k1)),
            detail::key_cast(k2), std::forward<Keys>(keys)...);
}

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V,
         typename Key1, typename Key2, typename ... Keys>
decltype(::toml::get<T>(std::declval<const basic_value<C, M, V>&>()))
find(const basic_value<C, M, V>& v, Key1&& k1, Key2&& k2, Keys&& ... keys)
{
    return ::toml::find<T>(::toml::find(v, detail::key_cast(k1)),
            detail::key_cast(k2), std::forward<Keys>(keys)...);
}
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V,
         typename Key1, typename Key2, typename ... Keys>
decltype(::toml::get<T>(std::declval<basic_value<C, M, V>&>()))
find(basic_value<C, M, V>& v, Key1&& k1, Key2&& k2, Keys&& ... keys)
{
    return ::toml::find<T>(::toml::find(v, detail::key_cast(k1)),
            detail::key_cast(k2), std::forward<Keys>(keys)...);
}
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V,
         typename Key1, typename Key2, typename ... Keys>
decltype(::toml::get<T>(std::declval<basic_value<C, M, V>&&>()))
find(basic_value<C, M, V>&& v, Key1&& k1, Key2&& k2, Keys&& ... keys)
{
    return ::toml::find<T>(::toml::find(std::move(v), detail::key_cast(k1)),
            detail::key_cast(k2), std::forward<Keys>(keys)...);
}

// ============================================================================
// get_or(value, fallback)

template<typename C,
         template<typename ...> class M, template<typename ...> class V>
basic_value<C, M, V> const&
get_or(const basic_value<C, M, V>& v, const basic_value<C, M, V>&)
{
    return v;
}
template<typename C,
         template<typename ...> class M, template<typename ...> class V>
basic_value<C, M, V>&
get_or(basic_value<C, M, V>& v, basic_value<C, M, V>&)
{
    return v;
}
template<typename C,
         template<typename ...> class M, template<typename ...> class V>
basic_value<C, M, V>
get_or(basic_value<C, M, V>&& v, basic_value<C, M, V>&&)
{
    return v;
}

// ----------------------------------------------------------------------------
// specialization for the exact toml types (return type becomes lvalue ref)

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<
    detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T> const&
get_or(const basic_value<C, M, V>& v, const T& opt)
{
    try
    {
        return get<detail::remove_cvref_t<T>>(v);
    }
    catch(...)
    {
        return opt;
    }
}
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<
    detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T>&
get_or(basic_value<C, M, V>& v, T& opt)
{
    try
    {
        return get<detail::remove_cvref_t<T>>(v);
    }
    catch(...)
    {
        return opt;
    }
}
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::is_exact_toml_type<detail::remove_cvref_t<T>,
    basic_value<C, M, V>>::value, detail::remove_cvref_t<T>>
get_or(basic_value<C, M, V>&& v, T&& opt)
{
    try
    {
        return get<detail::remove_cvref_t<T>>(std::move(v));
    }
    catch(...)
    {
        return detail::remove_cvref_t<T>(std::forward<T>(opt));
    }
}

// ----------------------------------------------------------------------------
// specialization for std::string (return type becomes lvalue ref)

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<std::is_same<detail::remove_cvref_t<T>, std::string>::value,
    std::string> const&
get_or(const basic_value<C, M, V>& v, const T& opt)
{
    try
    {
        return v.as_string().str;
    }
    catch(...)
    {
        return opt;
    }
}
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<std::is_same<T, std::string>::value, std::string>&
get_or(basic_value<C, M, V>& v, T& opt)
{
    try
    {
        return v.as_string().str;
    }
    catch(...)
    {
        return opt;
    }
}
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<
    std::is_same<detail::remove_cvref_t<T>, std::string>::value, std::string>
get_or(basic_value<C, M, V>&& v, T&& opt)
{
    try
    {
        return std::move(v.as_string().str);
    }
    catch(...)
    {
        return std::string(std::forward<T>(opt));
    }
}

// ----------------------------------------------------------------------------
// specialization for string literal

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::is_string_literal<
    typename std::remove_reference<T>::type>::value, std::string>
get_or(const basic_value<C, M, V>& v, T&& opt)
{
    try
    {
        return std::move(v.as_string().str);
    }
    catch(...)
    {
        return std::string(std::forward<T>(opt));
    }
}

// ----------------------------------------------------------------------------
// others (require type conversion and return type cannot be lvalue reference)

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::conjunction<
    detail::negation<detail::is_exact_toml_type<detail::remove_cvref_t<T>,
        basic_value<C, M, V>>>,
    detail::negation<std::is_same<std::string, detail::remove_cvref_t<T>>>,
    detail::negation<detail::is_string_literal<
        typename std::remove_reference<T>::type>>
    >::value, detail::remove_cvref_t<T>>
get_or(const basic_value<C, M, V>& v, T&& opt)
{
    try
    {
        return get<detail::remove_cvref_t<T>>(v);
    }
    catch(...)
    {
        return detail::remove_cvref_t<T>(std::forward<T>(opt));
    }
}

// ===========================================================================
// find_or(value, key, fallback)

template<typename C,
         template<typename ...> class M, template<typename ...> class V>
basic_value<C, M, V> const&
find_or(const basic_value<C, M, V>& v, const key& ky,
        const basic_value<C, M, V>& opt)
{
    if(!v.is_table()) {return opt;}
    const auto& tab = v.as_table();
    if(tab.count(ky) == 0) {return opt;}
    return tab.at(ky);
}

template<typename C,
         template<typename ...> class M, template<typename ...> class V>
basic_value<C, M, V>&
find_or(basic_value<C, M, V>& v, const toml::key& ky, basic_value<C, M, V>& opt)
{
    if(!v.is_table()) {return opt;}
    auto& tab = v.as_table();
    if(tab.count(ky) == 0) {return opt;}
    return tab.at(ky);
}

template<typename C,
         template<typename ...> class M, template<typename ...> class V>
basic_value<C, M, V>
find_or(basic_value<C, M, V>&& v, const toml::key& ky, basic_value<C, M, V>&& opt)
{
    if(!v.is_table()) {return opt;}
    auto tab = std::move(v).as_table();
    if(tab.count(ky) == 0) {return opt;}
    return basic_value<C, M, V>(std::move(tab.at(ky)));
}

// ---------------------------------------------------------------------------
// exact types (return type can be a reference)
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<
    detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T> const&
find_or(const basic_value<C, M, V>& v, const key& ky, const T& opt)
{
    if(!v.is_table()) {return opt;}
    const auto& tab = v.as_table();
    if(tab.count(ky) == 0) {return opt;}
    return get_or(tab.at(ky), opt);
}

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<
    detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T>&
find_or(basic_value<C, M, V>& v, const toml::key& ky, T& opt)
{
    if(!v.is_table()) {return opt;}
    auto& tab = v.as_table();
    if(tab.count(ky) == 0) {return opt;}
    return get_or(tab.at(ky), opt);
}

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<
    detail::is_exact_toml_type<T, basic_value<C, M, V>>::value,
    detail::remove_cvref_t<T>>
find_or(basic_value<C, M, V>&& v, const toml::key& ky, T&& opt)
{
    if(!v.is_table()) {return std::forward<T>(opt);}
    auto tab = std::move(v).as_table();
    if(tab.count(ky) == 0) {return std::forward<T>(opt);}
    return get_or(std::move(tab.at(ky)), std::forward<T>(opt));
}

// ---------------------------------------------------------------------------
// std::string (return type can be a reference)

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<std::is_same<T, std::string>::value, std::string> const&
find_or(const basic_value<C, M, V>& v, const key& ky, const T& opt)
{
    if(!v.is_table()) {return opt;}
    const auto& tab = v.as_table();
    if(tab.count(ky) == 0) {return opt;}
    return get_or(tab.at(ky), opt);
}
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<std::is_same<T, std::string>::value, std::string>&
find_or(basic_value<C, M, V>& v, const toml::key& ky, T& opt)
{
    if(!v.is_table()) {return opt;}
    auto& tab = v.as_table();
    if(tab.count(ky) == 0) {return opt;}
    return get_or(tab.at(ky), opt);
}
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<std::is_same<T, std::string>::value, std::string>
find_or(basic_value<C, M, V>&& v, const toml::key& ky, T&& opt)
{
    if(!v.is_table()) {return std::forward<T>(opt);}
    auto tab = std::move(v).as_table();
    if(tab.count(ky) == 0) {return std::forward<T>(opt);}
    return get_or(std::move(tab.at(ky)), std::forward<T>(opt));
}

// ---------------------------------------------------------------------------
// string literal (deduced as std::string)
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<
    detail::is_string_literal<typename std::remove_reference<T>::type>::value,
    std::string>
find_or(const basic_value<C, M, V>& v, const toml::key& ky, T&& opt)
{
    if(!v.is_table()) {return std::string(opt);}
    const auto& tab = v.as_table();
    if(tab.count(ky) == 0) {return std::string(opt);}
    return get_or(tab.at(ky), std::forward<T>(opt));
}

// ---------------------------------------------------------------------------
// others (require type conversion and return type cannot be lvalue reference)
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
detail::enable_if_t<detail::conjunction<
    // T is not an exact toml type
    detail::negation<detail::is_exact_toml_type<
        detail::remove_cvref_t<T>, basic_value<C, M, V>>>,
    // T is not std::string
    detail::negation<std::is_same<std::string, detail::remove_cvref_t<T>>>,
    // T is not a string literal
    detail::negation<detail::is_string_literal<
        typename std::remove_reference<T>::type>>
    >::value, detail::remove_cvref_t<T>>
find_or(const basic_value<C, M, V>& v, const toml::key& ky, T&& opt)
{
    if(!v.is_table()) {return std::forward<T>(opt);}
    const auto& tab = v.as_table();
    if(tab.count(ky) == 0) {return std::forward<T>(opt);}
    return get_or(tab.at(ky), std::forward<T>(opt));
}

// ============================================================================
// expect

template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
result<T, std::string> expect(const basic_value<C, M, V>& v) noexcept
{
    try
    {
        return ok(get<T>(v));
    }
    catch(const std::exception& e)
    {
        return err(e.what());
    }
}
template<typename T, typename C,
         template<typename ...> class M, template<typename ...> class V>
result<T, std::string>
expect(const basic_value<C, M, V>& v, const toml::key& k) noexcept
{
    try
    {
        return ok(find<T>(v, k));
    }
    catch(const std::exception& e)
    {
        return err(e.what());
    }
}

} // toml
#endif// TOML11_GET

```

`Dependencies/toml11/toml/into.hpp`:

```hpp
//     Copyright Toru Niina 2019.
// Distributed under the MIT License.
#ifndef TOML11_INTO_HPP
#define TOML11_INTO_HPP
#include "traits.hpp"

namespace toml
{

template<typename T>
struct into;
// {
//     static toml::value into_toml(const T& user_defined_type)
//     {
//         // User-defined conversions ...
//     }
// };

} // toml
#endif // TOML11_INTO_HPP

```

`Dependencies/toml11/toml/lexer.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_LEXER_HPP
#define TOML11_LEXER_HPP
#include <istream>
#include <sstream>
#include <stdexcept>
#include <fstream>

#include "combinator.hpp"

namespace toml
{
namespace detail
{

// these scans contents from current location in a container of char
// and extract a region that matches their own pattern.
// to see the implementation of each component, see combinator.hpp.

using lex_wschar  = either<character<' '>, character<'\t'>>;
using lex_ws      = repeat<lex_wschar, at_least<1>>;
using lex_newline = either<character<'\n'>,
                           sequence<character<'\r'>, character<'\n'>>>;
using lex_lower   = in_range<'a', 'z'>;
using lex_upper   = in_range<'A', 'Z'>;
using lex_alpha   = either<lex_lower, lex_upper>;
using lex_digit   = in_range<'0', '9'>;
using lex_nonzero = in_range<'1', '9'>;
using lex_oct_dig = in_range<'0', '7'>;
using lex_bin_dig = in_range<'0', '1'>;
using lex_hex_dig = either<lex_digit, in_range<'A', 'F'>, in_range<'a', 'f'>>;

using lex_hex_prefix = sequence<character<'0'>, character<'x'>>;
using lex_oct_prefix = sequence<character<'0'>, character<'o'>>;
using lex_bin_prefix = sequence<character<'0'>, character<'b'>>;
using lex_underscore = character<'_'>;
using lex_plus       = character<'+'>;
using lex_minus      = character<'-'>;
using lex_sign       = either<lex_plus, lex_minus>;

// digit | nonzero 1*(digit | _ digit)
using lex_unsigned_dec_int = either<sequence<lex_nonzero, repeat<
    either<lex_digit, sequence<lex_underscore, lex_digit>>, at_least<1>>>,
    lex_digit>;
// (+|-)? unsigned_dec_int
using lex_dec_int = sequence<maybe<lex_sign>, lex_unsigned_dec_int>;

// hex_prefix hex_dig *(hex_dig | _ hex_dig)
using lex_hex_int = sequence<lex_hex_prefix, sequence<lex_hex_dig, repeat<
    either<lex_hex_dig, sequence<lex_underscore, lex_hex_dig>>, unlimited>>>;
// oct_prefix oct_dig *(oct_dig | _ oct_dig)
using lex_oct_int = sequence<lex_oct_prefix, sequence<lex_oct_dig, repeat<
    either<lex_oct_dig, sequence<lex_underscore, lex_oct_dig>>, unlimited>>>;
// bin_prefix bin_dig *(bin_dig | _ bin_dig)
using lex_bin_int = sequence<lex_bin_prefix, sequence<lex_bin_dig, repeat<
    either<lex_bin_dig, sequence<lex_underscore, lex_bin_dig>>, unlimited>>>;

// (dec_int | hex_int | oct_int | bin_int)
using lex_integer = either<lex_bin_int, lex_oct_int, lex_hex_int, lex_dec_int>;

// ===========================================================================

using lex_inf = sequence<character<'i'>, character<'n'>, character<'f'>>;
using lex_nan = sequence<character<'n'>, character<'a'>, character<'n'>>;
using lex_special_float = sequence<maybe<lex_sign>, either<lex_inf, lex_nan>>;

using lex_zero_prefixable_int = sequence<lex_digit, repeat<either<lex_digit,
    sequence<lex_underscore, lex_digit>>, unlimited>>;

using lex_fractional_part = sequence<character<'.'>, lex_zero_prefixable_int>;

using lex_exponent_part   = sequence<either<character<'e'>, character<'E'>>,
        maybe<lex_sign>, lex_zero_prefixable_int>;

using lex_float = either<lex_special_float,
      sequence<lex_dec_int, either<lex_exponent_part,
      sequence<lex_fractional_part, maybe<lex_exponent_part>>>>>;

// ===========================================================================

using lex_true = sequence<character<'t'>, character<'r'>,
                          character<'u'>, character<'e'>>;
using lex_false = sequence<character<'f'>, character<'a'>, character<'l'>,
                           character<'s'>, character<'e'>>;
using lex_boolean = either<lex_true, lex_false>;

// ===========================================================================

using lex_date_fullyear = repeat<lex_digit, exactly<4>>;
using lex_date_month    = repeat<lex_digit, exactly<2>>;
using lex_date_mday     = repeat<lex_digit, exactly<2>>;
using lex_time_delim    = either<character<'T'>, character<'t'>, character<' '>>;
using lex_time_hour     = repeat<lex_digit, exactly<2>>;
using lex_time_minute   = repeat<lex_digit, exactly<2>>;
using lex_time_second   = repeat<lex_digit, exactly<2>>;
using lex_time_secfrac  = sequence<character<'.'>,
                                   repeat<lex_digit, at_least<1>>>;

using lex_time_numoffset = sequence<either<character<'+'>, character<'-'>>,
                                    sequence<lex_time_hour, character<':'>,
                                             lex_time_minute>>;
using lex_time_offset = either<character<'Z'>, character<'z'>,
                               lex_time_numoffset>;

using lex_partial_time = sequence<lex_time_hour,   character<':'>,
                                  lex_time_minute, character<':'>,
                                  lex_time_second, maybe<lex_time_secfrac>>;
using lex_full_date    = sequence<lex_date_fullyear, character<'-'>,
                                  lex_date_month,    character<'-'>,
                                  lex_date_mday>;
using lex_full_time    = sequence<lex_partial_time, lex_time_offset>;

using lex_offset_date_time = sequence<lex_full_date, lex_time_delim, lex_full_time>;
using lex_local_date_time  = sequence<lex_full_date, lex_time_delim, lex_partial_time>;
using lex_local_date       = lex_full_date;
using lex_local_time       = lex_partial_time;

// ===========================================================================

using lex_quotation_mark  = character<'"'>;
using lex_basic_unescaped = exclude<either<in_range<0x00, 0x08>, // 0x09 (tab)
                                           in_range<0x0a, 0x1F>, // is allowed
                                           character<0x22>, character<0x5C>,
                                           character<0x7F>>>;

using lex_escape          = character<'\\'>;
using lex_escape_unicode_short = sequence<character<'u'>,
                                          repeat<lex_hex_dig, exactly<4>>>;
using lex_escape_unicode_long  = sequence<character<'U'>,
                                          repeat<lex_hex_dig, exactly<8>>>;
using lex_escape_seq_char = either<character<'"'>, character<'\\'>,
                                   character<'b'>, character<'f'>,
                                   character<'n'>, character<'r'>,
                                   character<'t'>,
                                   lex_escape_unicode_short,
                                   lex_escape_unicode_long
                                   >;
using lex_escaped      = sequence<lex_escape, lex_escape_seq_char>;
using lex_basic_char   = either<lex_basic_unescaped, lex_escaped>;
using lex_basic_string = sequence<lex_quotation_mark,
                                  repeat<lex_basic_char, unlimited>,
                                  lex_quotation_mark>;

// After toml post-v0.5.0, it is explicitly clarified how quotes in ml-strings
// are allowed to be used.
// After this, the following strings are *explicitly* allowed.
// - One or two `"`s in a multi-line basic string is allowed wherever it is.
// - Three consecutive `"`s in a multi-line basic string is considered as a delimiter.
// - One or two `"`s can appear just before or after the delimiter.
// ```toml
// str4 = """Here are two quotation marks: "". Simple enough."""
// str5 = """Here are three quotation marks: ""\"."""
// str6 = """Here are fifteen quotation marks: ""\"""\"""\"""\"""\"."""
// str7 = """"This," she said, "is just a pointless statement.""""
// ```
// In the current implementation (v3.3.0), it is difficult to parse `str7` in
// the above example. It is difficult to recognize `"` at the end of string body
// collectly. It will be misunderstood as a `"""` delimiter and an additional,
// invalid `"`. Like this:
// ```console
//   what():  [error] toml::parse_table: invalid line format
//  --> hoge.toml
//     |
//  13 | str7 = """"This," she said, "is just a pointless statement.""""
//     |                                                               ^- expected newline, but got '"'.
// ```
// As a quick workaround for this problem, `lex_ml_basic_string_delim` was
// splitted into two, `lex_ml_basic_string_open` and `lex_ml_basic_string_close`.
// `lex_ml_basic_string_open` allows only `"""`. `_close` allows 3-5 `"`s.
// In parse_ml_basic_string() function, the trailing `"`s will be attached to
// the string body.
//
using lex_ml_basic_string_delim = repeat<lex_quotation_mark, exactly<3>>;
using lex_ml_basic_string_open  = lex_ml_basic_string_delim;
using lex_ml_basic_string_close = sequence<
        repeat<lex_quotation_mark, exactly<3>>,
        maybe<lex_quotation_mark>, maybe<lex_quotation_mark>
    >;

using lex_ml_basic_unescaped    = exclude<either<in_range<0x00, 0x08>, // 0x09
                                                 in_range<0x0a, 0x1F>, // is tab
                                                 character<0x5C>, // backslash
                                                 character<0x7F>, // DEL
                                                 lex_ml_basic_string_delim>>;

using lex_ml_basic_escaped_newline = sequence<
        lex_escape, maybe<lex_ws>, lex_newline,
        repeat<either<lex_ws, lex_newline>, unlimited>>;

using lex_ml_basic_char = either<lex_ml_basic_unescaped, lex_escaped>;
using lex_ml_basic_body = repeat<either<lex_ml_basic_char, lex_newline,
                                        lex_ml_basic_escaped_newline>,
                                 unlimited>;
using lex_ml_basic_string = sequence<lex_ml_basic_string_open,
                                     lex_ml_basic_body,
                                     lex_ml_basic_string_close>;

using lex_literal_char = exclude<either<in_range<0x00, 0x08>,
                                        in_range<0x10, 0x19>, character<0x27>>>;
using lex_apostrophe = character<'\''>;
using lex_literal_string = sequence<lex_apostrophe,
                                    repeat<lex_literal_char, unlimited>,
                                    lex_apostrophe>;

// the same reason as above.
using lex_ml_literal_string_delim = repeat<lex_apostrophe, exactly<3>>;
using lex_ml_literal_string_open  = lex_ml_literal_string_delim;
using lex_ml_literal_string_close = sequence<
        repeat<lex_apostrophe, exactly<3>>,
        maybe<lex_apostrophe>, maybe<lex_apostrophe>
    >;

using lex_ml_literal_char = exclude<either<in_range<0x00, 0x08>,
                                           in_range<0x10, 0x1F>,
                                           character<0x7F>,
                                           lex_ml_literal_string_delim>>;
using lex_ml_literal_body = repeat<either<lex_ml_literal_char, lex_newline>,
                                   unlimited>;
using lex_ml_literal_string = sequence<lex_ml_literal_string_open,
                                       lex_ml_literal_body,
                                       lex_ml_literal_string_close>;

using lex_string = either<lex_ml_basic_string,   lex_basic_string,
                          lex_ml_literal_string, lex_literal_string>;

// ===========================================================================

using lex_comment_start_symbol = character<'#'>;
using lex_non_eol = either<character<'\t'>, exclude<in_range<0x00, 0x19>>>;
using lex_comment = sequence<lex_comment_start_symbol,
                             repeat<lex_non_eol, unlimited>>;

using lex_dot_sep = sequence<maybe<lex_ws>, character<'.'>, maybe<lex_ws>>;

using lex_unquoted_key = repeat<either<lex_alpha, lex_digit,
                                       character<'-'>, character<'_'>>,
                                at_least<1>>;
using lex_quoted_key = either<lex_basic_string, lex_literal_string>;
using lex_simple_key = either<lex_unquoted_key, lex_quoted_key>;
using lex_dotted_key = sequence<lex_simple_key,
                                repeat<sequence<lex_dot_sep, lex_simple_key>,
                                       at_least<1>
                                       >
                                >;
using lex_key = either<lex_dotted_key, lex_simple_key>;

using lex_keyval_sep = sequence<maybe<lex_ws>,
                                character<'='>,
                                maybe<lex_ws>>;

using lex_std_table_open  = character<'['>;
using lex_std_table_close = character<']'>;
using lex_std_table       = sequence<lex_std_table_open,
                                     maybe<lex_ws>,
                                     lex_key,
                                     maybe<lex_ws>,
                                     lex_std_table_close>;

using lex_array_table_open  = sequence<lex_std_table_open,  lex_std_table_open>;
using lex_array_table_close = sequence<lex_std_table_close, lex_std_table_close>;
using lex_array_table       = sequence<lex_array_table_open,
                                       maybe<lex_ws>,
                                       lex_key,
                                       maybe<lex_ws>,
                                       lex_array_table_close>;

} // detail
} // toml
#endif // TOML_LEXER_HPP

```

`Dependencies/toml11/toml/literal.hpp`:

```hpp
//     Copyright Toru Niina 2019.
// Distributed under the MIT License.
#ifndef TOML11_LITERAL_HPP
#define TOML11_LITERAL_HPP
#include "parser.hpp"

namespace toml
{
inline namespace literals
{
inline namespace toml_literals
{

inline ::toml::value operator"" _toml(const char* str, std::size_t len)
{
    ::toml::detail::location
        loc(/* filename = */ std::string("TOML literal encoded in a C++ code"),
            /* contents = */ std::vector<char>(str, str + len));

    // if there are some comments or empty lines, skip them.
    using skip_line = ::toml::detail::repeat<toml::detail::sequence<
            ::toml::detail::maybe<::toml::detail::lex_ws>,
            ::toml::detail::maybe<::toml::detail::lex_comment>,
            ::toml::detail::lex_newline
        >, ::toml::detail::at_least<1>>;
    skip_line::invoke(loc);

    // if there are some whitespaces before a value, skip them.
    using skip_ws = ::toml::detail::repeat<
        ::toml::detail::lex_ws, ::toml::detail::at_least<1>>;
    skip_ws::invoke(loc);

    // to distinguish arrays and tables, first check it is a table or not.
    //
    // "[1,2,3]"_toml;   // this is an array
    // "[table]"_toml;   // a table that has an empty table named "table" inside.
    // "[[1,2,3]]"_toml; // this is an array of arrays
    // "[[table]]"_toml; // this is a table that has an array of tables inside.
    //
    // "[[1]]"_toml;     // this can be both... (currently it becomes a table)
    // "1 = [{}]"_toml;  // this is a table that has an array of table named 1.
    // "[[1,]]"_toml;    // this is an array of arrays.
    // "[[1],]"_toml;    // this also.

    const auto the_front = loc.iter();

    const bool is_table_key = ::toml::detail::lex_std_table::invoke(loc);
    loc.reset(the_front);

    const bool is_aots_key  = ::toml::detail::lex_array_table::invoke(loc);
    loc.reset(the_front);

    // If it is neither a table-key or a array-of-table-key, it may be a value.
    if(!is_table_key && !is_aots_key)
    {
        if(auto data = ::toml::detail::parse_value<::toml::value>(loc))
        {
            return data.unwrap();
        }
    }

    // Note that still it can be a table, because the literal might be something
    // like the following.
    // ```cpp
    // R"( // c++11 raw string literals
    //   key = "value"
    //   int = 42
    // )"_toml;
    // ```
    // It is a valid toml file.
    // It should be parsed as if we parse a file with this content.

    if(auto data = ::toml::detail::parse_toml_file<::toml::value>(loc))
    {
        return data.unwrap();
    }
    else // none of them.
    {
        throw ::toml::syntax_error(data.unwrap_err(), source_location(loc));
    }
}

} // toml_literals
} // literals
} // toml
#endif//TOML11_LITERAL_HPP

```

`Dependencies/toml11/toml/parser.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_PARSER_HPP
#define TOML11_PARSER_HPP
#include <cstring>
#include <fstream>
#include <sstream>

#include "combinator.hpp"
#include "lexer.hpp"
#include "region.hpp"
#include "result.hpp"
#include "types.hpp"
#include "value.hpp"

#if __cplusplus >= 201703L
#if __has_include(<filesystem>)
#define TOML11_HAS_STD_FILESYSTEM
#include <filesystem>
#endif // has_include(<string_view>)
#endif // cplusplus   >= C++17

namespace toml
{
namespace detail
{

inline result<std::pair<boolean, region>, std::string>
parse_boolean(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_boolean::invoke(loc))
    {
        const auto reg = token.unwrap();
        if     (reg.str() == "true")  {return ok(std::make_pair(true,  reg));}
        else if(reg.str() == "false") {return ok(std::make_pair(false, reg));}
        else // internal error.
        {
            throw internal_error(format_underline(
                "toml::parse_boolean: internal error",
                {{source_location(reg), "invalid token"}}),
                source_location(reg));
        }
    }
    loc.reset(first); //rollback
    return err(format_underline("toml::parse_boolean: ",
               {{source_location(loc), "the next token is not a boolean"}}));
}

inline result<std::pair<integer, region>, std::string>
parse_binary_integer(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_bin_int::invoke(loc))
    {
        auto str = token.unwrap().str();
        assert(str.size() > 2); // minimum -> 0b1
        integer retval(0), base(1);
        for(auto i(str.rbegin()), e(str.rend() - 2); i!=e; ++i)
        {
            if     (*i == '1'){retval += base; base *= 2;}
            else if(*i == '0'){base *= 2;}
            else if(*i == '_'){/* do nothing. */}
            else // internal error.
            {
                throw internal_error(format_underline(
                    "toml::parse_integer: internal error",
                    {{source_location(token.unwrap()), "invalid token"}}),
                    source_location(loc));
            }
        }
        return ok(std::make_pair(retval, token.unwrap()));
    }
    loc.reset(first);
    return err(format_underline("toml::parse_binary_integer:",
               {{source_location(loc), "the next token is not an integer"}}));
}

inline result<std::pair<integer, region>, std::string>
parse_octal_integer(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_oct_int::invoke(loc))
    {
        auto str = token.unwrap().str();
        str.erase(std::remove(str.begin(), str.end(), '_'), str.end());
        str.erase(str.begin()); str.erase(str.begin()); // remove `0o` prefix

        std::istringstream iss(str);
        integer retval(0);
        iss >> std::oct >> retval;
        return ok(std::make_pair(retval, token.unwrap()));
    }
    loc.reset(first);
    return err(format_underline("toml::parse_octal_integer:",
               {{source_location(loc), "the next token is not an integer"}}));
}

inline result<std::pair<integer, region>, std::string>
parse_hexadecimal_integer(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_hex_int::invoke(loc))
    {
        auto str = token.unwrap().str();
        str.erase(std::remove(str.begin(), str.end(), '_'), str.end());
        str.erase(str.begin()); str.erase(str.begin()); // remove `0x` prefix

        std::istringstream iss(str);
        integer retval(0);
        iss >> std::hex >> retval;
        return ok(std::make_pair(retval, token.unwrap()));
    }
    loc.reset(first);
    return err(format_underline("toml::parse_hexadecimal_integer",
               {{source_location(loc), "the next token is not an integer"}}));
}

inline result<std::pair<integer, region>, std::string>
parse_integer(location& loc)
{
    const auto first = loc.iter();
    if(first != loc.end() && *first == '0')
    {
        const auto second = std::next(first);
        if(second == loc.end()) // the token is just zero.
        {
            loc.advance();
            return ok(std::make_pair(0, region(loc, first, second)));
        }

        if(*second == 'b') {return parse_binary_integer     (loc);} // 0b1100
        if(*second == 'o') {return parse_octal_integer      (loc);} // 0o775
        if(*second == 'x') {return parse_hexadecimal_integer(loc);} // 0xC0FFEE

        if(std::isdigit(*second))
        {
            return err(format_underline("toml::parse_integer: "
                "leading zero in an Integer is not allowed.",
                {{source_location(loc), "leading zero"}}));
        }
        else if(std::isalpha(*second))
        {
             return err(format_underline("toml::parse_integer: "
                "unknown integer prefix appeared.",
                {{source_location(loc), "none of 0x, 0o, 0b"}}));
        }
    }

    if(const auto token = lex_dec_int::invoke(loc))
    {
        auto str = token.unwrap().str();
        str.erase(std::remove(str.begin(), str.end(), '_'), str.end());

        std::istringstream iss(str);
        integer retval(0);
        iss >> retval;
        return ok(std::make_pair(retval, token.unwrap()));
    }
    loc.reset(first);
    return err(format_underline("toml::parse_integer: ",
               {{source_location(loc), "the next token is not an integer"}}));
}

inline result<std::pair<floating, region>, std::string>
parse_floating(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_float::invoke(loc))
    {
        auto str = token.unwrap().str();
        if(str == "inf" || str == "+inf")
        {
            if(std::numeric_limits<floating>::has_infinity)
            {
                return ok(std::make_pair(
                    std::numeric_limits<floating>::infinity(), token.unwrap()));
            }
            else
            {
                throw std::domain_error("toml::parse_floating: inf value found"
                    " but the current environment does not support inf. Please"
                    " make sure that the floating-point implementation conforms"
                    " IEEE 754/ISO 60559 international standard.");
            }
        }
        else if(str == "-inf")
        {
            if(std::numeric_limits<floating>::has_infinity)
            {
                return ok(std::make_pair(
                    -std::numeric_limits<floating>::infinity(), token.unwrap()));
            }
            else
            {
                throw std::domain_error("toml::parse_floating: inf value found"
                    " but the current environment does not support inf. Please"
                    " make sure that the floating-point implementation conforms"
                    " IEEE 754/ISO 60559 international standard.");
            }
        }
        else if(str == "nan" || str == "+nan")
        {
            if(std::numeric_limits<floating>::has_quiet_NaN)
            {
                return ok(std::make_pair(
                    std::numeric_limits<floating>::quiet_NaN(), token.unwrap()));
            }
            else if(std::numeric_limits<floating>::has_signaling_NaN)
            {
                return ok(std::make_pair(
                    std::numeric_limits<floating>::signaling_NaN(), token.unwrap()));
            }
            else
            {
                throw std::domain_error("toml::parse_floating: NaN value found"
                    " but the current environment does not support NaN. Please"
                    " make sure that the floating-point implementation conforms"
                    " IEEE 754/ISO 60559 international standard.");
            }
        }
        else if(str == "-nan")
        {
            if(std::numeric_limits<floating>::has_quiet_NaN)
            {
                return ok(std::make_pair(
                    -std::numeric_limits<floating>::quiet_NaN(), token.unwrap()));
            }
            else if(std::numeric_limits<floating>::has_signaling_NaN)
            {
                return ok(std::make_pair(
                    -std::numeric_limits<floating>::signaling_NaN(), token.unwrap()));
            }
            else
            {
                throw std::domain_error("toml::parse_floating: NaN value found"
                    " but the current environment does not support NaN. Please"
                    " make sure that the floating-point implementation conforms"
                    " IEEE 754/ISO 60559 international standard.");
            }
        }
        str.erase(std::remove(str.begin(), str.end(), '_'), str.end());
        std::istringstream iss(str);
        floating v(0.0);
        iss >> v;
        return ok(std::make_pair(v, token.unwrap()));
    }
    loc.reset(first);
    return err(format_underline("toml::parse_floating: ",
               {{source_location(loc), "the next token is not a float"}}));
}

inline std::string read_utf8_codepoint(const region& reg, const location& loc)
{
    const auto str = reg.str().substr(1);
    std::uint_least32_t codepoint;
    std::istringstream iss(str);
    iss >> std::hex >> codepoint;

    const auto to_char = [](const std::uint_least32_t i) noexcept -> char {
        const auto uc = static_cast<unsigned char>(i);
        return *reinterpret_cast<const char*>(std::addressof(uc));
    };

    std::string character;
    if(codepoint < 0x80) // U+0000 ... U+0079 ; just an ASCII.
    {
        character += static_cast<char>(codepoint);
    }
    else if(codepoint < 0x800) //U+0080 ... U+07FF
    {
        // 110yyyyx 10xxxxxx; 0x3f == 0b0011'1111
        character += to_char(0xC0| codepoint >> 6);
        character += to_char(0x80|(codepoint & 0x3F));
    }
    else if(codepoint < 0x10000) // U+0800...U+FFFF
    {
        if(0xD800 <= codepoint && codepoint <= 0xDFFF)
        {
            throw syntax_error(format_underline(
                "toml::read_utf8_codepoint: codepoints in the range "
                "[0xD800, 0xDFFF] are not valid UTF-8.", {{
                    source_location(loc), "not a valid UTF-8 codepoint"
                }}), source_location(loc));
        }
        assert(codepoint < 0xD800 || 0xDFFF < codepoint);
        // 1110yyyy 10yxxxxx 10xxxxxx
        character += to_char(0xE0| codepoint >> 12);
        character += to_char(0x80|(codepoint >> 6 & 0x3F));
        character += to_char(0x80|(codepoint      & 0x3F));
    }
    else if(codepoint < 0x110000) // U+010000 ... U+10FFFF
    {
        // 11110yyy 10yyxxxx 10xxxxxx 10xxxxxx
        character += to_char(0xF0| codepoint >> 18);
        character += to_char(0x80|(codepoint >> 12 & 0x3F));
        character += to_char(0x80|(codepoint >> 6  & 0x3F));
        character += to_char(0x80|(codepoint       & 0x3F));
    }
    else // out of UTF-8 region
    {
        throw syntax_error(format_underline("toml::read_utf8_codepoint:"
            " input codepoint is too large.",
            {{source_location(loc), "should be in [0x00..0x10FFFF]"}}),
            source_location(loc));
    }
    return character;
}

inline result<std::string, std::string> parse_escape_sequence(location& loc)
{
    const auto first = loc.iter();
    if(first == loc.end() || *first != '\\')
    {
        return err(format_underline("toml::parse_escape_sequence: ", {{
            source_location(loc), "the next token is not a backslash \"\\\""}}));
    }
    loc.advance();
    switch(*loc.iter())
    {
        case '\\':{loc.advance(); return ok(std::string("\\"));}
        case '"' :{loc.advance(); return ok(std::string("\""));}
        case 'b' :{loc.advance(); return ok(std::string("\b"));}
        case 't' :{loc.advance(); return ok(std::string("\t"));}
        case 'n' :{loc.advance(); return ok(std::string("\n"));}
        case 'f' :{loc.advance(); return ok(std::string("\f"));}
        case 'r' :{loc.advance(); return ok(std::string("\r"));}
        case 'u' :
        {
            if(const auto token = lex_escape_unicode_short::invoke(loc))
            {
                return ok(read_utf8_codepoint(token.unwrap(), loc));
            }
            else
            {
                return err(format_underline("parse_escape_sequence: "
                           "invalid token found in UTF-8 codepoint uXXXX.",
                           {{source_location(loc), "here"}}));
            }
        }
        case 'U':
        {
            if(const auto token = lex_escape_unicode_long::invoke(loc))
            {
                return ok(read_utf8_codepoint(token.unwrap(), loc));
            }
            else
            {
                return err(format_underline("parse_escape_sequence: "
                           "invalid token found in UTF-8 codepoint Uxxxxxxxx",
                           {{source_location(loc), "here"}}));
            }
        }
    }

    const auto msg = format_underline("parse_escape_sequence: "
           "unknown escape sequence appeared.", {{source_location(loc),
           "escape sequence is one of \\, \", b, t, n, f, r, uxxxx, Uxxxxxxxx"}},
           /* Hints = */{"if you want to write backslash as just one backslash, "
           "use literal string like: regex    = '<\\i\\c*\\s*>'"});
    loc.reset(first);
    return err(msg);
}

inline result<std::pair<toml::string, region>, std::string>
parse_ml_basic_string(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_ml_basic_string::invoke(loc))
    {
        auto inner_loc = loc;
        inner_loc.reset(first);

        std::string retval;
        retval.reserve(token.unwrap().size());

        auto delim = lex_ml_basic_string_open::invoke(inner_loc);
        if(!delim)
        {
            throw internal_error(format_underline(
                "parse_ml_basic_string: invalid token",
                {{source_location(inner_loc), "should be \"\"\""}}),
                source_location(inner_loc));
        }
        // immediate newline is ignored (if exists)
        /* discard return value */ lex_newline::invoke(inner_loc);

        delim = none();
        while(!delim)
        {
            using lex_unescaped_seq = repeat<
                either<lex_ml_basic_unescaped, lex_newline>, unlimited>;
            if(auto unescaped = lex_unescaped_seq::invoke(inner_loc))
            {
                retval += unescaped.unwrap().str();
            }
            if(auto escaped = parse_escape_sequence(inner_loc))
            {
                retval += escaped.unwrap();
            }
            if(auto esc_nl = lex_ml_basic_escaped_newline::invoke(inner_loc))
            {
                // ignore newline after escape until next non-ws char
            }
            if(inner_loc.iter() == inner_loc.end())
            {
                throw internal_error(format_underline(
                    "parse_ml_basic_string: unexpected end of region",
                    {{source_location(inner_loc), "not sufficient token"}}),
                    source_location(inner_loc));
            }
            delim = lex_ml_basic_string_close::invoke(inner_loc);
        }
        // `lex_ml_basic_string_close` allows 3 to 5 `"`s to allow 1 or 2 `"`s
        // at just before the delimiter. Here, we need to attach `"`s at the
        // end of the string body, if it exists.
        // For detail, see the definition of `lex_ml_basic_string_close`.
        assert(std::all_of(delim.unwrap().first(), delim.unwrap().last(),
                           [](const char c) noexcept {return c == '\"';}));
        switch(delim.unwrap().size())
        {
            case 3: {break;}
            case 4: {retval += "\"";  break;}
            case 5: {retval += "\"\""; break;}
            default:
            {
                throw internal_error(format_underline(
                    "parse_ml_basic_string: closing delimiter has invalid length",
                    {{source_location(inner_loc), "end of this"}}),
                    source_location(inner_loc));
            }
        }
        return ok(std::make_pair(toml::string(retval), token.unwrap()));
    }
    else
    {
        loc.reset(first);
        return err(format_underline("toml::parse_ml_basic_string: "
                   "the next token is not a valid multiline string",
                   {{source_location(loc), "here"}}));
    }
}

inline result<std::pair<toml::string, region>, std::string>
parse_basic_string(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_basic_string::invoke(loc))
    {
        auto inner_loc = loc;
        inner_loc.reset(first);

        auto quot = lex_quotation_mark::invoke(inner_loc);
        if(!quot)
        {
            throw internal_error(format_underline("parse_basic_string: "
                "invalid token", {{source_location(inner_loc), "should be \""}}),
                source_location(inner_loc));
        }

        std::string retval;
        retval.reserve(token.unwrap().size());

        quot = none();
        while(!quot)
        {
            using lex_unescaped_seq = repeat<lex_basic_unescaped, unlimited>;
            if(auto unescaped = lex_unescaped_seq::invoke(inner_loc))
            {
                retval += unescaped.unwrap().str();
            }
            if(auto escaped = parse_escape_sequence(inner_loc))
            {
                retval += escaped.unwrap();
            }
            if(inner_loc.iter() == inner_loc.end())
            {
                throw internal_error(format_underline(
                    "parse_basic_string: unexpected end of region",
                    {{source_location(inner_loc), "not sufficient token"}}),
                    source_location(inner_loc));
            }
            quot = lex_quotation_mark::invoke(inner_loc);
        }
        return ok(std::make_pair(toml::string(retval), token.unwrap()));
    }
    else
    {
        loc.reset(first); // rollback
        return err(format_underline("toml::parse_basic_string: "
                   "the next token is not a valid string",
                   {{source_location(loc), "here"}}));
    }
}

inline result<std::pair<toml::string, region>, std::string>
parse_ml_literal_string(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_ml_literal_string::invoke(loc))
    {
        location inner_loc(loc.name(), token.unwrap().str());

        const auto open = lex_ml_literal_string_open::invoke(inner_loc);
        if(!open)
        {
            throw internal_error(format_underline(
                "parse_ml_literal_string: invalid token",
                {{source_location(inner_loc), "should be '''"}}),
                source_location(inner_loc));
        }
        // immediate newline is ignored (if exists)
        /* discard return value */ lex_newline::invoke(inner_loc);

        const auto body = lex_ml_literal_body::invoke(inner_loc);

        const auto close = lex_ml_literal_string_close::invoke(inner_loc);
        if(!close)
        {
            throw internal_error(format_underline(
                "parse_ml_literal_string: invalid token",
                {{source_location(inner_loc), "should be '''"}}),
                source_location(inner_loc));
        }
        // `lex_ml_literal_string_close` allows 3 to 5 `'`s to allow 1 or 2 `'`s
        // at just before the delimiter. Here, we need to attach `'`s at the
        // end of the string body, if it exists.
        // For detail, see the definition of `lex_ml_basic_string_close`.

        std::string retval = body.unwrap().str();
        assert(std::all_of(close.unwrap().first(), close.unwrap().last(),
                           [](const char c) noexcept {return c == '\'';}));
        switch(close.unwrap().size())
        {
            case 3: {break;}
            case 4: {retval += "'";  break;}
            case 5: {retval += "''"; break;}
            default:
            {
                throw internal_error(format_underline(
                    "parse_ml_literal_string: closing delimiter has invalid length",
                    {{source_location(inner_loc), "end of this"}}),
                    source_location(inner_loc));
            }
        }
        return ok(std::make_pair(toml::string(retval, toml::string_t::literal),
                                 token.unwrap()));
    }
    else
    {
        loc.reset(first); // rollback
        return err(format_underline("toml::parse_ml_literal_string: "
                   "the next token is not a valid multiline literal string",
                   {{source_location(loc), "here"}}));
    }
}

inline result<std::pair<toml::string, region>, std::string>
parse_literal_string(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_literal_string::invoke(loc))
    {
        location inner_loc(loc.name(), token.unwrap().str());

        const auto open = lex_apostrophe::invoke(inner_loc);
        if(!open)
        {
            throw internal_error(format_underline(
                "parse_literal_string: invalid token",
                {{source_location(inner_loc), "should be '"}}),
                source_location(inner_loc));
        }

        const auto body = repeat<lex_literal_char, unlimited>::invoke(inner_loc);

        const auto close = lex_apostrophe::invoke(inner_loc);
        if(!close)
        {
            throw internal_error(format_underline(
                "parse_literal_string: invalid token",
                {{source_location(inner_loc), "should be '"}}),
                source_location(inner_loc));
        }
        return ok(std::make_pair(
                  toml::string(body.unwrap().str(), toml::string_t::literal),
                  token.unwrap()));
    }
    else
    {
        loc.reset(first); // rollback
        return err(format_underline("toml::parse_literal_string: "
                   "the next token is not a valid literal string",
                   {{source_location(loc), "here"}}));
    }
}

inline result<std::pair<toml::string, region>, std::string>
parse_string(location& loc)
{
    if(loc.iter() != loc.end() && *(loc.iter()) == '"')
    {
        if(loc.iter() + 1 != loc.end() && *(loc.iter() + 1) == '"' &&
           loc.iter() + 2 != loc.end() && *(loc.iter() + 2) == '"')
        {
            return parse_ml_basic_string(loc);
        }
        else
        {
            return parse_basic_string(loc);
        }
    }
    else if(loc.iter() != loc.end() && *(loc.iter()) == '\'')
    {
        if(loc.iter() + 1 != loc.end() && *(loc.iter() + 1) == '\'' &&
           loc.iter() + 2 != loc.end() && *(loc.iter() + 2) == '\'')
        {
            return parse_ml_literal_string(loc);
        }
        else
        {
            return parse_literal_string(loc);
        }
    }
    return err(format_underline("toml::parse_string: ",
                {{source_location(loc), "the next token is not a string"}}));
}

inline result<std::pair<local_date, region>, std::string>
parse_local_date(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_local_date::invoke(loc))
    {
        location inner_loc(loc.name(), token.unwrap().str());

        const auto y = lex_date_fullyear::invoke(inner_loc);
        if(!y || inner_loc.iter() == inner_loc.end() || *inner_loc.iter() != '-')
        {
            throw internal_error(format_underline(
                "toml::parse_inner_local_date: invalid year format",
                {{source_location(inner_loc), "should be `-`"}}),
                source_location(inner_loc));
        }
        inner_loc.advance();
        const auto m = lex_date_month::invoke(inner_loc);
        if(!m || inner_loc.iter() == inner_loc.end() || *inner_loc.iter() != '-')
        {
            throw internal_error(format_underline(
                "toml::parse_local_date: invalid month format",
                {{source_location(inner_loc), "should be `-`"}}),
                source_location(inner_loc));
        }
        inner_loc.advance();
        const auto d = lex_date_mday::invoke(inner_loc);
        if(!d)
        {
            throw internal_error(format_underline(
                "toml::parse_local_date: invalid day format",
                {{source_location(inner_loc), "here"}}),
                source_location(inner_loc));
        }
        return ok(std::make_pair(local_date(
            static_cast<std::int16_t>(from_string<int>(y.unwrap().str(), 0)),
            static_cast<month_t>(
                static_cast<std::int8_t>(from_string<int>(m.unwrap().str(), 0)-1)),
            static_cast<std::int8_t>(from_string<int>(d.unwrap().str(), 0))),
            token.unwrap()));
    }
    else
    {
        loc.reset(first);
        return err(format_underline("toml::parse_local_date: ",
            {{source_location(loc), "the next token is not a local_date"}}));
    }
}

inline result<std::pair<local_time, region>, std::string>
parse_local_time(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_local_time::invoke(loc))
    {
        location inner_loc(loc.name(), token.unwrap().str());

        const auto h = lex_time_hour::invoke(inner_loc);
        if(!h || inner_loc.iter() == inner_loc.end() || *inner_loc.iter() != ':')
        {
            throw internal_error(format_underline(
                "toml::parse_local_time: invalid year format",
                {{source_location(inner_loc), "should be `:`"}}),
                source_location(inner_loc));
        }
        inner_loc.advance();
        const auto m = lex_time_minute::invoke(inner_loc);
        if(!m || inner_loc.iter() == inner_loc.end() || *inner_loc.iter() != ':')
        {
            throw internal_error(format_underline(
                "toml::parse_local_time: invalid month format",
                {{source_location(inner_loc), "should be `:`"}}),
                source_location(inner_loc));
        }
        inner_loc.advance();
        const auto s = lex_time_second::invoke(inner_loc);
        if(!s)
        {
            throw internal_error(format_underline(
                "toml::parse_local_time: invalid second format",
                {{source_location(inner_loc), "here"}}),
                source_location(inner_loc));
        }
        local_time time(
            from_string<int>(h.unwrap().str(), 0),
            from_string<int>(m.unwrap().str(), 0),
            from_string<int>(s.unwrap().str(), 0), 0, 0);

        const auto before_secfrac = inner_loc.iter();
        if(const auto secfrac = lex_time_secfrac::invoke(inner_loc))
        {
            auto sf = secfrac.unwrap().str();
            sf.erase(sf.begin()); // sf.front() == '.'
            switch(sf.size() % 3)
            {
                case 2:  sf += '0';  break;
                case 1:  sf += "00"; break;
                case 0:  break;
                default: break;
            }
            if(sf.size() >= 9)
            {
                time.millisecond = from_string<std::uint16_t>(sf.substr(0, 3), 0u);
                time.microsecond = from_string<std::uint16_t>(sf.substr(3, 3), 0u);
                time.nanosecond  = from_string<std::uint16_t>(sf.substr(6, 3), 0u);
            }
            else if(sf.size() >= 6)
            {
                time.millisecond = from_string<std::uint16_t>(sf.substr(0, 3), 0u);
                time.microsecond = from_string<std::uint16_t>(sf.substr(3, 3), 0u);
            }
            else if(sf.size() >= 3)
            {
                time.millisecond = from_string<std::uint16_t>(sf, 0u);
                time.microsecond = 0u;
            }
        }
        else
        {
            if(before_secfrac != inner_loc.iter())
            {
                throw internal_error(format_underline(
                    "toml::parse_local_time: invalid subsecond format",
                    {{source_location(inner_loc), "here"}}),
                source_location(inner_loc));
            }
        }
        return ok(std::make_pair(time, token.unwrap()));
    }
    else
    {
        loc.reset(first);
        return err(format_underline("toml::parse_local_time: ",
            {{source_location(loc), "the next token is not a local_time"}}));
    }
}

inline result<std::pair<local_datetime, region>, std::string>
parse_local_datetime(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_local_date_time::invoke(loc))
    {
        location inner_loc(loc.name(), token.unwrap().str());
        const auto date = parse_local_date(inner_loc);
        if(!date || inner_loc.iter() == inner_loc.end())
        {
            throw internal_error(format_underline(
                "toml::parse_local_datetime: invalid datetime format",
                {{source_location(inner_loc), "date, not datetime"}}),
                source_location(inner_loc));
        }
        const char delim = *(inner_loc.iter());
        if(delim != 'T' && delim != 't' && delim != ' ')
        {
            throw internal_error(format_underline(
                "toml::parse_local_datetime: invalid datetime format",
                {{source_location(inner_loc), "should be `T` or ` ` (space)"}}),
                source_location(inner_loc));
        }
        inner_loc.advance();
        const auto time = parse_local_time(inner_loc);
        if(!time)
        {
            throw internal_error(format_underline(
                "toml::parse_local_datetime: invalid datetime format",
                {{source_location(inner_loc), "invalid time fomrat"}}),
                source_location(inner_loc));
        }
        return ok(std::make_pair(
            local_datetime(date.unwrap().first, time.unwrap().first),
            token.unwrap()));
    }
    else
    {
        loc.reset(first);
        return err(format_underline("toml::parse_local_datetime: ",
            {{source_location(loc), "the next token is not a local_datetime"}}));
    }
}

inline result<std::pair<offset_datetime, region>, std::string>
parse_offset_datetime(location& loc)
{
    const auto first = loc.iter();
    if(const auto token = lex_offset_date_time::invoke(loc))
    {
        location inner_loc(loc.name(), token.unwrap().str());
        const auto datetime = parse_local_datetime(inner_loc);
        if(!datetime || inner_loc.iter() == inner_loc.end())
        {
            throw internal_error(format_underline(
                "toml::parse_offset_datetime: invalid datetime format",
                {{source_location(inner_loc), "date, not datetime"}}),
                source_location(inner_loc));
        }
        time_offset offset(0, 0);
        if(const auto ofs = lex_time_numoffset::invoke(inner_loc))
        {
            const auto str = ofs.unwrap().str();
            if(str.front() == '+')
            {
                offset = time_offset(from_string<int>(str.substr(1,2), 0),
                                     from_string<int>(str.substr(4,2), 0));
            }
            else
            {
                offset = time_offset(-from_string<int>(str.substr(1,2), 0),
                                     -from_string<int>(str.substr(4,2), 0));
            }
        }
        else if(*inner_loc.iter() != 'Z' && *inner_loc.iter() != 'z')
        {
            throw internal_error(format_underline(
                "toml::parse_offset_datetime: invalid datetime format",
                {{source_location(inner_loc), "should be `Z` or `+HH:MM`"}}),
                source_location(inner_loc));
        }
        return ok(std::make_pair(offset_datetime(datetime.unwrap().first, offset),
                                 token.unwrap()));
    }
    else
    {
        loc.reset(first);
        return err(format_underline("toml::parse_offset_datetime: ",
            {{source_location(loc), "the next token is not a offset_datetime"}}));
    }
}

inline result<std::pair<key, region>, std::string>
parse_simple_key(location& loc)
{
    if(const auto bstr = parse_basic_string(loc))
    {
        return ok(std::make_pair(bstr.unwrap().first.str, bstr.unwrap().second));
    }
    if(const auto lstr = parse_literal_string(loc))
    {
        return ok(std::make_pair(lstr.unwrap().first.str, lstr.unwrap().second));
    }
    if(const auto bare = lex_unquoted_key::invoke(loc))
    {
        const auto reg = bare.unwrap();
        return ok(std::make_pair(reg.str(), reg));
    }
    return err(format_underline("toml::parse_simple_key: ",
            {{source_location(loc), "the next token is not a simple key"}}));
}

// dotted key become vector of keys
inline result<std::pair<std::vector<key>, region>, std::string>
parse_key(location& loc)
{
    const auto first = loc.iter();
    // dotted key -> `foo.bar.baz` where several single keys are chained by
    // dots. Whitespaces between keys and dots are allowed.
    if(const auto token = lex_dotted_key::invoke(loc))
    {
        const auto reg = token.unwrap();
        location inner_loc(loc.name(), reg.str());
        std::vector<key> keys;

        while(inner_loc.iter() != inner_loc.end())
        {
            lex_ws::invoke(inner_loc);
            if(const auto k = parse_simple_key(inner_loc))
            {
                keys.push_back(k.unwrap().first);
            }
            else
            {
                throw internal_error(format_underline(
                    "toml::detail::parse_key: dotted key contains invalid key",
                    {{source_location(inner_loc), k.unwrap_err()}}),
                    source_location(inner_loc));
            }

            lex_ws::invoke(inner_loc);
            if(inner_loc.iter() == inner_loc.end())
            {
                break;
            }
            else if(*inner_loc.iter() == '.')
            {
                inner_loc.advance(); // to skip `.`
            }
            else
            {
                throw internal_error(format_underline("toml::parse_key: "
                    "dotted key contains invalid key ",
                    {{source_location(inner_loc), "should be `.`"}}),
                    source_location(inner_loc));
            }
        }
        return ok(std::make_pair(keys, reg));
    }
    loc.reset(first);

    // simple_key: a single (basic_string|literal_string|bare key)
    if(const auto smpl = parse_simple_key(loc))
    {
        return ok(std::make_pair(std::vector<key>(1, smpl.unwrap().first),
                                 smpl.unwrap().second));
    }
    return err(format_underline("toml::parse_key: an invalid key appeaed.",
                {{source_location(loc), "is not a valid key"}}, {
                "bare keys  : non-empty strings composed only of [A-Za-z0-9_-].",
                "quoted keys: same as \"basic strings\" or 'literal strings'.",
                "dotted keys: sequence of bare or quoted keys joined with a dot."
                }));
}

// forward-decl to implement parse_array and parse_table
template<typename Value>
result<Value, std::string> parse_value(location&);

template<typename Value>
result<std::pair<typename Value::array_type, region>, std::string>
parse_array(location& loc)
{
    using value_type = Value;
    using array_type = typename value_type::array_type;

    const auto first = loc.iter();
    if(loc.iter() == loc.end())
    {
        return err("toml::parse_array: input is empty");
    }
    if(*loc.iter() != '[')
    {
        return err("toml::parse_array: token is not an array");
    }
    loc.advance();

    using lex_ws_comment_newline = repeat<
        either<lex_wschar, lex_newline, lex_comment>, unlimited>;

    array_type retval;
    while(loc.iter() != loc.end())
    {
        lex_ws_comment_newline::invoke(loc); // skip

        if(loc.iter() != loc.end() && *loc.iter() == ']')
        {
            loc.advance(); // skip ']'
            return ok(std::make_pair(retval,
                      region(loc, first, loc.iter())));
        }

        if(auto val = parse_value<value_type>(loc))
        {
            // After TOML v1.0.0-rc.1, array becomes to be able to have values
            // with different types. So here we will omit this by default.
            //
            // But some of the test-suite checks if the parser accepts a hetero-
            // geneous arrays, so we keep this for a while.
#ifdef TOML11_DISALLOW_HETEROGENEOUS_ARRAYS
            if(!retval.empty() && retval.front().type() != val.as_ok().type())
            {
                auto array_start_loc = loc;
                array_start_loc.reset(first);

                throw syntax_error(format_underline("toml::parse_array: "
                    "type of elements should be the same each other.", {
                        {source_location(array_start_loc), "array starts here"},
                        {
                            retval.front().location(),
                            "value has type " + stringize(retval.front().type())
                        },
                        {
                            val.unwrap().location(),
                            "value has different type, " + stringize(val.unwrap().type())
                        }
                    }), source_location(loc));
            }
#endif
            retval.push_back(std::move(val.unwrap()));
        }
        else
        {
            auto array_start_loc = loc;
            array_start_loc.reset(first);

            throw syntax_error(format_underline("toml::parse_array: "
                "value having invalid format appeared in an array", {
                    {source_location(array_start_loc), "array starts here"},
                    {source_location(loc), "it is not a valid value."}
                }), source_location(loc));
        }

        using lex_array_separator = sequence<maybe<lex_ws>, character<','>>;
        const auto sp = lex_array_separator::invoke(loc);
        if(!sp)
        {
            lex_ws_comment_newline::invoke(loc);
            if(loc.iter() != loc.end() && *loc.iter() == ']')
            {
                loc.advance(); // skip ']'
                return ok(std::make_pair(retval,
                          region(loc, first, loc.iter())));
            }
            else
            {
                auto array_start_loc = loc;
                array_start_loc.reset(first);

                throw syntax_error(format_underline("toml::parse_array:"
                    " missing array separator `,` after a value", {
                        {source_location(array_start_loc), "array starts here"},
                        {source_location(loc),             "should be `,`"}
                    }), source_location(loc));
            }
        }
    }
    loc.reset(first);
    throw syntax_error(format_underline("toml::parse_array: "
            "array did not closed by `]`",
            {{source_location(loc), "should be closed"}}),
            source_location(loc));
}

template<typename Value>
result<std::pair<std::pair<std::vector<key>, region>, Value>, std::string>
parse_key_value_pair(location& loc)
{
    using value_type = Value;

    const auto first = loc.iter();
    auto key_reg = parse_key(loc);
    if(!key_reg)
    {
        std::string msg = std::move(key_reg.unwrap_err());
        // if the next token is keyvalue-separator, it means that there are no
        // key. then we need to show error as "empty key is not allowed".
        if(const auto keyval_sep = lex_keyval_sep::invoke(loc))
        {
            loc.reset(first);
            msg = format_underline("toml::parse_key_value_pair: "
                "empty key is not allowed.",
                {{source_location(loc), "key expected before '='"}});
        }
        return err(std::move(msg));
    }

    const auto kvsp = lex_keyval_sep::invoke(loc);
    if(!kvsp)
    {
        std::string msg;
        // if the line contains '=' after the invalid sequence, possibly the
        // error is in the key (like, invalid character in bare key).
        const auto line_end = std::find(loc.iter(), loc.end(), '\n');
        if(std::find(loc.iter(), line_end, '=') != line_end)
        {
            msg = format_underline("toml::parse_key_value_pair: "
                "invalid format for key",
                {{source_location(loc), "invalid character in key"}},
                {"Did you forget '.' to separate dotted-key?",
                "Allowed characters for bare key are [0-9a-zA-Z_-]."});
        }
        else // if not, the error is lack of key-value separator.
        {
            msg = format_underline("toml::parse_key_value_pair: "
                "missing key-value separator `=`",
                {{source_location(loc), "should be `=`"}});
        }
        loc.reset(first);
        return err(std::move(msg));
    }

    const auto after_kvsp = loc.iter(); // err msg
    auto val = parse_value<value_type>(loc);
    if(!val)
    {
        std::string msg;
        loc.reset(after_kvsp);
        // check there is something not a comment/whitespace after `=`
        if(sequence<maybe<lex_ws>, maybe<lex_comment>, lex_newline>::invoke(loc))
        {
            loc.reset(after_kvsp);
            msg = format_underline("toml::parse_key_value_pair: "
                    "missing value after key-value separator '='",
                    {{source_location(loc), "expected value, but got nothing"}});
        }
        else // there is something not a comment/whitespace, so invalid format.
        {
            msg = std::move(val.unwrap_err());
        }
        loc.reset(first);
        return err(msg);
    }
    return ok(std::make_pair(std::move(key_reg.unwrap()),
                             std::move(val.unwrap())));
}

// for error messages.
template<typename InputIterator>
std::string format_dotted_keys(InputIterator first, const InputIterator last)
{
    static_assert(std::is_same<key,
        typename std::iterator_traits<InputIterator>::value_type>::value,"");

    std::string retval(*first++);
    for(; first != last; ++first)
    {
        retval += '.';
        retval += *first;
    }
    return retval;
}

// forward decl for is_valid_forward_table_definition
result<std::pair<std::vector<key>, region>, std::string>
parse_table_key(location& loc);

// The following toml file is allowed.
// ```toml
// [a.b.c]     # here, table `a` has element `b`.
// foo = "bar"
// [a]         # merge a = {baz = "qux"} to a = {b = {...}}
// baz = "qux"
// ```
// But the following is not allowed.
// ```toml
// [a]
// b.c.foo = "bar"
// [a]             # error! the same table [a] defined!
// baz = "qux"
// ```
// The following is neither allowed.
// ```toml
// a = { b.c.foo = "bar"}
// [a]             # error! the same table [a] defined!
// baz = "qux"
// ```
// Here, it parses region of `tab->at(k)` as a table key and check the depth
// of the key. If the key region points deeper node, it would be allowed.
// Otherwise, the key points the same node. It would be rejected.
template<typename Value, typename Iterator>
bool is_valid_forward_table_definition(const Value& fwd,
        Iterator key_first, Iterator key_curr, Iterator key_last)
{
    std::string internal = "";
    if(const auto ptr = detail::get_region(fwd))
    {
        internal = ptr->str();
    }
    location def("internal", std::move(internal));
    if(const auto tabkeys = parse_table_key(def))
    {
        // table keys always contains all the nodes from the root.
        const auto& tks = tabkeys.unwrap().first;
        if(std::size_t(std::distance(key_first, key_last)) == tks.size() &&
           std::equal(tks.begin(), tks.end(), key_first))
        {
            // the keys are equivalent. it is not allowed.
            return false;
        }
        // the keys are not equivalent. it is allowed.
        return true;
    }
    if(const auto dotkeys = parse_key(def))
    {
        // consider the following case.
        // [a]
        // b.c = {d = 42}
        // [a.b.c]
        // e = 2.71
        // this defines the table [a.b.c] twice. no?

        // a dotted key starts from the node representing a table in which the
        // dotted key belongs to.
        const auto& dks = dotkeys.unwrap().first;
        if(std::size_t(std::distance(key_curr, key_last)) == dks.size() &&
           std::equal(dks.begin(), dks.end(), key_curr))
        {
            // the keys are equivalent. it is not allowed.
            return false;
        }
        // the keys are not equivalent. it is allowed.
        return true;
    }
    return false;
}

template<typename Value, typename InputIterator>
result<bool, std::string>
insert_nested_key(typename Value::table_type& root, const Value& v,
                  InputIterator iter, const InputIterator last,
                  region key_reg,
                  const bool is_array_of_table = false)
{
    static_assert(std::is_same<key,
        typename std::iterator_traits<InputIterator>::value_type>::value,"");

    using value_type = Value;
    using table_type = typename value_type::table_type;
    using array_type = typename value_type::array_type;

    const auto first = iter;
    assert(iter != last);

    table_type* tab = std::addressof(root);
    for(; iter != last; ++iter) // search recursively
    {
        const key& k = *iter;
        if(std::next(iter) == last) // k is the last key
        {
            // XXX if the value is array-of-tables, there can be several
            //     tables that are in the same array. in that case, we need to
            //     find the last element and insert it to there.
            if(is_array_of_table)
            {
                if(tab->count(k) == 1) // there is already an array of table
                {
                    if(tab->at(k).is_table())
                    {
                        // show special err msg for conflicting table
                        throw syntax_error(format_underline(concat_to_string(
                            "toml::insert_value: array of table (\"",
                            format_dotted_keys(first, last),
                            "\") cannot be defined"), {
                                {tab->at(k).location(), "table already defined"},
                                {v.location(), "this conflicts with the previous table"}
                            }), v.location());
                    }
                    else if(!(tab->at(k).is_array()))
                    {
                        throw syntax_error(format_underline(concat_to_string(
                            "toml::insert_value: array of table (\"",
                            format_dotted_keys(first, last), "\") collides with"
                            " existing value"), {
                                {tab->at(k).location(),
                                 concat_to_string("this ", tab->at(k).type(),
                                                  " value already exists")},
                                {v.location(),
                                 "while inserting this array-of-tables"}
                            }), v.location());
                    }
                    // the above if-else-if checks tab->at(k) is an array
                    auto& a = tab->at(k).as_array();
                    if(!(a.front().is_table()))
                    {
                        throw syntax_error(format_underline(concat_to_string(
                            "toml::insert_value: array of table (\"",
                            format_dotted_keys(first, last), "\") collides with"
                            " existing value"), {
                                {tab->at(k).location(),
                                 concat_to_string("this ", tab->at(k).type(),
                                                  " value already exists")},
                                {v.location(),
                                 "while inserting this array-of-tables"}
                            }), v.location());
                    }
                    // avoid conflicting array of table like the following.
                    // ```toml
                    // a = [{b = 42}] # define a as an array of *inline* tables
                    // [[a]]          # a is an array of *multi-line* tables
                    // b = 54
                    // ```
                    // Here, from the type information, these cannot be detected
                    // bacause inline table is also a table.
                    // But toml v0.5.0 explicitly says it is invalid. The above
                    // array-of-tables has a static size and appending to the
                    // array is invalid.
                    // In this library, multi-line table value has a region
                    // that points to the key of the table (e.g. [[a]]). By
                    // comparing the first two letters in key, we can detect
                    // the array-of-table is inline or multiline.
                    if(const auto ptr = detail::get_region(a.front()))
                    {
                        if(ptr->str().substr(0,2) != "[[")
                        {
                            throw syntax_error(format_underline(concat_to_string(
                                "toml::insert_value: array of table (\"",
                                format_dotted_keys(first, last), "\") collides "
                                "with existing array-of-tables"), {
                                    {tab->at(k).location(),
                                     concat_to_string("this ", tab->at(k).type(),
                                                      " value has static size")},
                                    {v.location(),
                                     "appending it to the statically sized array"}
                                }), v.location());
                        }
                    }
                    a.push_back(v);
                    return ok(true);
                }
                else // if not, we need to create the array of table
                {
                    value_type aot(array_type(1, v), key_reg);
                    tab->insert(std::make_pair(k, aot));
                    return ok(true);
                }
            } // end if(array of table)

            if(tab->count(k) == 1)
            {
                if(tab->at(k).is_table() && v.is_table())
                {
                    if(!is_valid_forward_table_definition(
                                tab->at(k), first, iter, last))
                    {
                        throw syntax_error(format_underline(concat_to_string(
                            "toml::insert_value: table (\"",
                            format_dotted_keys(first, last),
                            "\") already exists."), {
                                {tab->at(k).location(), "table already exists here"},
                                {v.location(), "table defined twice"}
                            }), v.location());
                    }
                    // to allow the following toml file.
                    // [a.b.c]
                    // d = 42
                    // [a]
                    // e = 2.71
                    auto& t = tab->at(k).as_table();
                    for(const auto& kv : v.as_table())
                    {
                        t[kv.first] = kv.second;
                    }
                    detail::change_region(tab->at(k), key_reg);
                    return ok(true);
                }
                else if(v.is_table()                     &&
                        tab->at(k).is_array()            &&
                        tab->at(k).as_array().size() > 0 &&
                        tab->at(k).as_array().front().is_table())
                {
                    throw syntax_error(format_underline(concat_to_string(
                        "toml::insert_value: array of tables (\"",
                        format_dotted_keys(first, last), "\") already exists."), {
                            {tab->at(k).location(), "array of tables defined here"},
                            {v.location(), "table conflicts with the previous array of table"}
                        }), v.location());
                }
                else
                {
                    throw syntax_error(format_underline(concat_to_string(
                        "toml::insert_value: value (\"",
                        format_dotted_keys(first, last), "\") already exists."), {
                            {tab->at(k).location(), "value already exists here"},
                            {v.location(), "value defined twice"}
                        }), v.location());
                }
            }
            tab->insert(std::make_pair(k, v));
            return ok(true);
        }
        else // k is not the last one, we should insert recursively
        {
            // if there is no corresponding value, insert it first.
            // related: you don't need to write
            // # [x]
            // # [x.y]
            // to write
            // [x.y.z]
            if(tab->count(k) == 0)
            {
                (*tab)[k] = value_type(table_type{}, key_reg);
            }

            // type checking...
            if(tab->at(k).is_table())
            {
                // According to toml-lang/toml:36d3091b3 "Clarify that inline
                // tables are immutable", check if it adds key-value pair to an
                // inline table.
                if(const auto* ptr = get_region(tab->at(k)))
                {
                    // here, if the value is a (multi-line) table, the region
                    // should be something like `[table-name]`.
                    if(ptr->front() == '{')
                    {
                        throw syntax_error(format_underline(concat_to_string(
                            "toml::insert_value: inserting to an inline table (",
                            format_dotted_keys(first, std::next(iter)),
                            ") but inline tables are immutable"), {
                                {tab->at(k).location(), "inline tables are immutable"},
                                {v.location(), "inserting this"}
                            }), v.location());
                    }
                }
                tab = std::addressof((*tab)[k].as_table());
            }
            else if(tab->at(k).is_array()) // inserting to array-of-tables?
            {
                auto& a = (*tab)[k].as_array();
                if(!a.back().is_table())
                {
                    throw syntax_error(format_underline(concat_to_string(
                        "toml::insert_value: target (",
                        format_dotted_keys(first, std::next(iter)),
                        ") is neither table nor an array of tables"), {
                            {a.back().location(), concat_to_string(
                                    "actual type is ", a.back().type())},
                            {v.location(), "inserting this"}
                        }), v.location());
                }
                tab = std::addressof(a.back().as_table());
            }
            else
            {
                throw syntax_error(format_underline(concat_to_string(
                    "toml::insert_value: target (",
                    format_dotted_keys(first, std::next(iter)),
                    ") is neither table nor an array of tables"), {
                        {tab->at(k).location(), concat_to_string(
                                "actual type is ", tab->at(k).type())},
                        {v.location(), "inserting this"}
                    }), v.location());
            }
        }
    }
    return err(std::string("toml::detail::insert_nested_key: never reach here"));
}

template<typename Value>
result<std::pair<typename Value::table_type, region>, std::string>
parse_inline_table(location& loc)
{
    using value_type = Value;
    using table_type = typename value_type::table_type;

    const auto first = loc.iter();
    table_type retval;
    if(!(loc.iter() != loc.end() && *loc.iter() == '{'))
    {
        return err(format_underline("toml::parse_inline_table: ",
            {{source_location(loc), "the next token is not an inline table"}}));
    }
    loc.advance();
    // it starts from "{". it should be formatted as inline-table
    while(loc.iter() != loc.end())
    {
        maybe<lex_ws>::invoke(loc);
        if(loc.iter() != loc.end() && *loc.iter() == '}')
        {
            loc.advance(); // skip `}`
            return ok(std::make_pair(retval,
                        region(loc, first, loc.iter())));
        }

        const auto kv_r = parse_key_value_pair<value_type>(loc);
        if(!kv_r)
        {
            return err(kv_r.unwrap_err());
        }
        const auto&              kvpair  = kv_r.unwrap();
        const std::vector<key>&  keys    = kvpair.first.first;
        const auto&              key_reg = kvpair.first.second;
        const value_type&        val     = kvpair.second;

        const auto inserted =
            insert_nested_key(retval, val, keys.begin(), keys.end(), key_reg);
        if(!inserted)
        {
            throw internal_error("toml::parse_inline_table: "
                "failed to insert value into table: " + inserted.unwrap_err(),
                source_location(loc));
        }

        using lex_table_separator = sequence<maybe<lex_ws>, character<','>>;
        const auto sp = lex_table_separator::invoke(loc);
        if(!sp)
        {
            maybe<lex_ws>::invoke(loc);
            if(loc.iter() != loc.end() && *loc.iter() == '}')
            {
                loc.advance(); // skip `}`
                return ok(std::make_pair(
                            retval, region(loc, first, loc.iter())));
            }
            else if(*loc.iter() == '#' || *loc.iter() == '\r' || *loc.iter() == '\n')
            {
                throw syntax_error(format_underline(
                    "toml::parse_inline_table: missing curly brace `}`",
                    {{source_location(loc), "should be `}`"}}),
                    source_location(loc));
            }
            else
            {
                throw syntax_error(format_underline(
                    "toml::parse_inline_table: missing table separator `,` ",
                    {{source_location(loc), "should be `,`"}}),
                    source_location(loc));
            }
        }
    }
    loc.reset(first);
    throw syntax_error(format_underline("toml::parse_inline_table: "
            "inline table did not closed by `}`",
            {{source_location(loc), "should be closed"}}),
            source_location(loc));
}

inline result<value_t, std::string> guess_number_type(const location& l)
{
    // This function tries to find some (common) mistakes by checking characters
    // that follows the last character of a value. But it is often difficult
    // because some non-newline characters can appear after a value. E.g.
    // spaces, tabs, commas (in an array or inline table), closing brackets
    // (of an array or inline table), comment-sign (#). Since this function
    // does not parse further, those characters are always allowed to be there.
    location loc = l;

    if(lex_offset_date_time::invoke(loc)) {return ok(value_t::offset_datetime);}
    loc.reset(l.iter());

    if(lex_local_date_time::invoke(loc))
    {
        // bad offset may appear after this.
        if(loc.iter() != loc.end() && (*loc.iter() == '+' || *loc.iter() == '-'
                    || *loc.iter() == 'Z' || *loc.iter() == 'z'))
        {
            return err(format_underline("bad offset: should be [+-]HH:MM or Z",
                        {{source_location(loc), "[+-]HH:MM or Z"}},
                        {"pass: +09:00, -05:30", "fail: +9:00, -5:30"}));
        }
        return ok(value_t::local_datetime);
    }
    loc.reset(l.iter());

    if(lex_local_date::invoke(loc))
    {
        // bad time may appear after this.
        // A space is allowed as a delimiter between local time. But there are
        // both cases in which a space becomes valid or invalid.
        // - invalid: 2019-06-16 7:00:00
        // - valid  : 2019-06-16 07:00:00
        if(loc.iter() != loc.end())
        {
            const auto c = *loc.iter();
            if(c == 'T' || c == 't')
            {
                return err(format_underline("bad time: should be HH:MM:SS.subsec",
                        {{source_location(loc), "HH:MM:SS.subsec"}},
                        {"pass: 1979-05-27T07:32:00, 1979-05-27 07:32:00.999999",
                         "fail: 1979-05-27T7:32:00, 1979-05-27 17:32"}));
            }
            if('0' <= c && c <= '9')
            {
                return err(format_underline("bad time: missing T",
                        {{source_location(loc), "T or space required here"}},
                        {"pass: 1979-05-27T07:32:00, 1979-05-27 07:32:00.999999",
                         "fail: 1979-05-27T7:32:00, 1979-05-27 7:32"}));
            }
            if(c == ' ' && std::next(loc.iter()) != loc.end() &&
                ('0' <= *std::next(loc.iter()) && *std::next(loc.iter())<= '9'))
            {
                loc.advance();
                return err(format_underline("bad time: should be HH:MM:SS.subsec",
                        {{source_location(loc), "HH:MM:SS.subsec"}},
                        {"pass: 1979-05-27T07:32:00, 1979-05-27 07:32:00.999999",
                         "fail: 1979-05-27T7:32:00, 1979-05-27 7:32"}));
            }
        }
        return ok(value_t::local_date);
    }
    loc.reset(l.iter());

    if(lex_local_time::invoke(loc)) {return ok(value_t::local_time);}
    loc.reset(l.iter());

    if(lex_float::invoke(loc))
    {
        if(loc.iter() != loc.end() && *loc.iter() == '_')
        {
            return err(format_underline("bad float: `_` should be surrounded by digits",
                        {{source_location(loc), "here"}},
                        {"pass: +1.0, -2e-2, 3.141_592_653_589, inf, nan",
                         "fail: .0, 1., _1.0, 1.0_, 1_.0, 1.0__0"}));
        }
        return ok(value_t::floating);
    }
    loc.reset(l.iter());

    if(lex_integer::invoke(loc))
    {
        if(loc.iter() != loc.end())
        {
            const auto c = *loc.iter();
            if(c == '_')
            {
                return err(format_underline("bad integer: `_` should be surrounded by digits",
                            {{source_location(loc), "here"}},
                            {"pass: -42, 1_000, 1_2_3_4_5, 0xC0FFEE, 0b0010, 0o755",
                             "fail: 1__000, 0123"}));
            }
            if('0' <= c && c <= '9')
            {
                // leading zero. point '0'
                loc.retrace();
                return err(format_underline("bad integer: leading zero",
                            {{source_location(loc), "here"}},
                            {"pass: -42, 1_000, 1_2_3_4_5, 0xC0FFEE, 0b0010, 0o755",
                             "fail: 1__000, 0123"}));
            }
            if(c == ':' || c == '-')
            {
                return err(format_underline("bad datetime: invalid format",
                            {{source_location(loc), "here"}},
                            {"pass: 1979-05-27T07:32:00-07:00, 1979-05-27 07:32:00.999999Z",
                             "fail: 1979-05-27T7:32:00-7:00, 1979-05-27 7:32-00:30"}));
            }
            if(c == '.' || c == 'e' || c == 'E')
            {
                return err(format_underline("bad float: invalid format",
                            {{source_location(loc), "here"}},
                            {"pass: +1.0, -2e-2, 3.141_592_653_589, inf, nan",
                             "fail: .0, 1., _1.0, 1.0_, 1_.0, 1.0__0"}));
            }
        }
        return ok(value_t::integer);
    }
    if(loc.iter() != loc.end() && *loc.iter() == '.')
    {
        return err(format_underline("bad float: invalid format",
                {{source_location(loc), "integer part required before this"}},
                {"pass: +1.0, -2e-2, 3.141_592_653_589, inf, nan",
                 "fail: .0, 1., _1.0, 1.0_, 1_.0, 1.0__0"}));
    }
    if(loc.iter() != loc.end() && *loc.iter() == '_')
    {
        return err(format_underline("bad number: `_` should be surrounded by digits",
                {{source_location(loc), "`_` is not surrounded by digits"}},
                {"pass: -42, 1_000, 1_2_3_4_5, 0xC0FFEE, 0b0010, 0o755",
                 "fail: 1__000, 0123"}));
    }
    return err(format_underline("bad format: unknown value appeared",
                {{source_location(loc), "here"}}));
}

inline result<value_t, std::string> guess_value_type(const location& loc)
{
    switch(*loc.iter())
    {
        case '"' : {return ok(value_t::string);  }
        case '\'': {return ok(value_t::string);  }
        case 't' : {return ok(value_t::boolean); }
        case 'f' : {return ok(value_t::boolean); }
        case '[' : {return ok(value_t::array);   }
        case '{' : {return ok(value_t::table);   }
        case 'i' : {return ok(value_t::floating);} // inf.
        case 'n' : {return ok(value_t::floating);} // nan.
        default  : {return guess_number_type(loc);}
    }
}

template<typename Value>
result<Value, std::string> parse_value(location& loc)
{
    using value_type = Value;

    const auto first = loc.iter();
    if(first == loc.end())
    {
        return err(format_underline("toml::parse_value: input is empty",
                   {{source_location(loc), ""}}));
    }

    const auto type = guess_value_type(loc);
    if(!type)
    {
        return err(type.unwrap_err());
    }
    switch(type.unwrap())
    {
        case value_t::boolean        : {return parse_boolean(loc);        }
        case value_t::integer        : {return parse_integer(loc);        }
        case value_t::floating       : {return parse_floating(loc);       }
        case value_t::string         : {return parse_string(loc);         }
        case value_t::offset_datetime: {return parse_offset_datetime(loc);}
        case value_t::local_datetime : {return parse_local_datetime(loc); }
        case value_t::local_date     : {return parse_local_date(loc);     }
        case value_t::local_time     : {return parse_local_time(loc);     }
        case value_t::array          : {return parse_array<value_type>(loc);       }
        case value_t::table          : {return parse_inline_table<value_type>(loc);}
        default:
        {
            const auto msg = format_underline("toml::parse_value: "
                    "unknown token appeared", {{source_location(loc), "unknown"}});
            loc.reset(first);
            return err(msg);
        }
    }
}

inline result<std::pair<std::vector<key>, region>, std::string>
parse_table_key(location& loc)
{
    if(auto token = lex_std_table::invoke(loc))
    {
        location inner_loc(loc.name(), token.unwrap().str());

        const auto open = lex_std_table_open::invoke(inner_loc);
        if(!open || inner_loc.iter() == inner_loc.end())
        {
            throw internal_error(format_underline(
                "toml::parse_table_key: no `[`",
                {{source_location(inner_loc), "should be `[`"}}),
                source_location(inner_loc));
        }
        // to skip [ a . b . c ]
        //          ^----------- this whitespace
        lex_ws::invoke(inner_loc);
        const auto keys = parse_key(inner_loc);
        if(!keys)
        {
            throw internal_error(format_underline(
                "toml::parse_table_key: invalid key",
                {{source_location(inner_loc), "not key"}}),
                source_location(inner_loc));
        }
        // to skip [ a . b . c ]
        //                    ^-- this whitespace
        lex_ws::invoke(inner_loc);
        const auto close = lex_std_table_close::invoke(inner_loc);
        if(!close)
        {
            throw internal_error(format_underline(
                "toml::parse_table_key: no `]`",
                {{source_location(inner_loc), "should be `]`"}}),
                source_location(inner_loc));
        }

        // after [table.key], newline or EOF(empty table) requried.
        if(loc.iter() != loc.end())
        {
            using lex_newline_after_table_key =
                sequence<maybe<lex_ws>, maybe<lex_comment>, lex_newline>;
            const auto nl = lex_newline_after_table_key::invoke(loc);
            if(!nl)
            {
                throw syntax_error(format_underline(
                    "toml::parse_table_key: newline required after [table.key]",
                    {{source_location(loc), "expected newline"}}),
                    source_location(loc));
            }
        }
        return ok(std::make_pair(keys.unwrap().first, token.unwrap()));
    }
    else
    {
        return err(format_underline("toml::parse_table_key: "
            "not a valid table key", {{source_location(loc), "here"}}));
    }
}

inline result<std::pair<std::vector<key>, region>, std::string>
parse_array_table_key(location& loc)
{
    if(auto token = lex_array_table::invoke(loc))
    {
        location inner_loc(loc.name(), token.unwrap().str());

        const auto open = lex_array_table_open::invoke(inner_loc);
        if(!open || inner_loc.iter() == inner_loc.end())
        {
            throw internal_error(format_underline(
                "toml::parse_array_table_key: no `[[`",
                {{source_location(inner_loc), "should be `[[`"}}),
                source_location(inner_loc));
        }
        lex_ws::invoke(inner_loc);
        const auto keys = parse_key(inner_loc);
        if(!keys)
        {
            throw internal_error(format_underline(
                "toml::parse_array_table_key: invalid key",
                {{source_location(inner_loc), "not a key"}}),
                source_location(inner_loc));
        }
        lex_ws::invoke(inner_loc);
        const auto close = lex_array_table_close::invoke(inner_loc);
        if(!close)
        {
            throw internal_error(format_underline(
                "toml::parse_table_key: no `]]`",
                {{source_location(inner_loc), "should be `]]`"}}),
                source_location(inner_loc));
        }

        // after [[table.key]], newline or EOF(empty table) requried.
        if(loc.iter() != loc.end())
        {
            using lex_newline_after_table_key =
                sequence<maybe<lex_ws>, maybe<lex_comment>, lex_newline>;
            const auto nl = lex_newline_after_table_key::invoke(loc);
            if(!nl)
            {
                throw syntax_error(format_underline("toml::"
                    "parse_array_table_key: newline required after [[table.key]]",
                    {{source_location(loc), "expected newline"}}),
                    source_location(loc));
            }
        }
        return ok(std::make_pair(keys.unwrap().first, token.unwrap()));
    }
    else
    {
        return err(format_underline("toml::parse_array_table_key: "
            "not a valid table key", {{source_location(loc), "here"}}));
    }
}

// parse table body (key-value pairs until the iter hits the next [tablekey])
template<typename Value>
result<typename Value::table_type, std::string>
parse_ml_table(location& loc)
{
    using value_type = Value;
    using table_type = typename value_type::table_type;

    const auto first = loc.iter();
    if(first == loc.end())
    {
        return ok(table_type{});
    }

    // XXX at lest one newline is needed.
    using skip_line = repeat<
        sequence<maybe<lex_ws>, maybe<lex_comment>, lex_newline>, at_least<1>>;
    skip_line::invoke(loc);
    lex_ws::invoke(loc);

    table_type tab;
    while(loc.iter() != loc.end())
    {
        lex_ws::invoke(loc);
        const auto before = loc.iter();
        if(const auto tmp = parse_array_table_key(loc)) // next table found
        {
            loc.reset(before);
            return ok(tab);
        }
        if(const auto tmp = parse_table_key(loc)) // next table found
        {
            loc.reset(before);
            return ok(tab);
        }

        if(const auto kv = parse_key_value_pair<value_type>(loc))
        {
            const auto&              kvpair  = kv.unwrap();
            const std::vector<key>&  keys    = kvpair.first.first;
            const auto&              key_reg = kvpair.first.second;
            const value_type&        val     = kvpair.second;
            const auto inserted =
                insert_nested_key(tab, val, keys.begin(), keys.end(), key_reg);
            if(!inserted)
            {
                return err(inserted.unwrap_err());
            }
        }
        else
        {
            return err(kv.unwrap_err());
        }

        // comment lines are skipped by the above function call.
        // However, since the `skip_line` requires at least 1 newline, it fails
        // if the file ends with ws and/or comment without newline.
        // `skip_line` matches `ws? + comment? + newline`, not `ws` or `comment`
        // itself. To skip the last ws and/or comment, call lexers.
        // It does not matter if these fails, so the return value is discarded.
        lex_ws::invoke(loc);
        lex_comment::invoke(loc);

        // skip_line is (whitespace? comment? newline)_{1,}. multiple empty lines
        // and comments after the last key-value pairs are allowed.
        const auto newline = skip_line::invoke(loc);
        if(!newline && loc.iter() != loc.end())
        {
            const auto before2 = loc.iter();
            lex_ws::invoke(loc); // skip whitespace
            const auto msg = format_underline("toml::parse_table: "
                "invalid line format", {{source_location(loc), concat_to_string(
                "expected newline, but got '", show_char(*loc.iter()), "'.")}});
            loc.reset(before2);
            return err(msg);
        }

        // the skip_lines only matches with lines that includes newline.
        // to skip the last line that includes comment and/or whitespace
        // but no newline, call them one more time.
        lex_ws::invoke(loc);
        lex_comment::invoke(loc);
    }
    return ok(tab);
}

template<typename Value>
result<Value, std::string> parse_toml_file(location& loc)
{
    using value_type = Value;
    using table_type = typename value_type::table_type;

    const auto first = loc.iter();
    if(first == loc.end())
    {
        return ok(value_type(table_type{} /*, empty file has no region ...*/));
    }

    // put the first line as a region of a file
    // Here first != loc.end(), so taking std::next is okay
    const region file(loc, first, std::next(loc.iter()));

    // The first successive comments that are separated from the first value
    // by an empty line are for a file itself.
    // ```toml
    // # this is a comment for a file.
    //
    // key = "the first value"
    // ```
    // ```toml
    // # this is a comment for "the first value".
    // key = "the first value"
    // ```
    std::vector<std::string> comments;
    using lex_first_comments = sequence<
        repeat<sequence<maybe<lex_ws>, lex_comment, lex_newline>, at_least<1>>,
        sequence<maybe<lex_ws>, lex_newline>
        >;
    if(const auto token = lex_first_comments::invoke(loc))
    {
        location inner_loc(loc.name(), token.unwrap().str());
        while(inner_loc.iter() != inner_loc.end())
        {
            maybe<lex_ws>::invoke(inner_loc); // remove ws if exists
            if(lex_newline::invoke(inner_loc))
            {
                assert(inner_loc.iter() == inner_loc.end());
                break; // empty line found.
            }
            auto com = lex_comment::invoke(inner_loc).unwrap().str();
            com.erase(com.begin()); // remove # sign
            comments.push_back(std::move(com));
            lex_newline::invoke(inner_loc);
        }
    }

    table_type data;
    // root object is also a table, but without [tablename]
    if(auto tab = parse_ml_table<value_type>(loc))
    {
        data = std::move(tab.unwrap());
    }
    else // failed (empty table is regarded as success in parse_ml_table)
    {
        return err(tab.unwrap_err());
    }
    while(loc.iter() != loc.end())
    {
        // here, the region of [table] is regarded as the table-key because
        // the table body is normally too big and it is not so informative
        // if the first key-value pair of the table is shown in the error
        // message.
        if(const auto tabkey = parse_array_table_key(loc))
        {
            const auto tab = parse_ml_table<value_type>(loc);
            if(!tab){return err(tab.unwrap_err());}

            const auto& tk   = tabkey.unwrap();
            const auto& keys = tk.first;
            const auto& reg  = tk.second;

            const auto inserted = insert_nested_key(data,
                    value_type(tab.unwrap(), reg),
                    keys.begin(), keys.end(), reg,
                    /*is_array_of_table=*/ true);
            if(!inserted) {return err(inserted.unwrap_err());}

            continue;
        }
        if(const auto tabkey = parse_table_key(loc))
        {
            const auto tab = parse_ml_table<value_type>(loc);
            if(!tab){return err(tab.unwrap_err());}

            const auto& tk   = tabkey.unwrap();
            const auto& keys = tk.first;
            const auto& reg  = tk.second;

            const auto inserted = insert_nested_key(data,
                value_type(tab.unwrap(), reg), keys.begin(), keys.end(), reg);
            if(!inserted) {return err(inserted.unwrap_err());}

            continue;
        }
        return err(format_underline("toml::parse_toml_file: "
            "unknown line appeared", {{source_location(loc), "unknown format"}}));
    }

    Value v(std::move(data), file);
    v.comments() = comments;

    return ok(std::move(v));
}

} // detail

template<typename                     Comment = ::toml::discard_comments,
         template<typename ...> class Table   = std::unordered_map,
         template<typename ...> class Array   = std::vector>
basic_value<Comment, Table, Array>
parse(std::istream& is, const std::string& fname = "unknown file")
{
    using value_type = basic_value<Comment, Table, Array>;

    const auto beg = is.tellg();
    is.seekg(0, std::ios::end);
    const auto end = is.tellg();
    const auto fsize = end - beg;
    is.seekg(beg);

    // read whole file as a sequence of char
    assert(fsize >= 0);
    std::vector<char> letters(static_cast<std::size_t>(fsize));
    is.read(letters.data(), fsize);

    while(!letters.empty() && letters.back() == '\0')
    {
        letters.pop_back();
    }
    assert(letters.empty() || letters.back() != '\0');

    detail::location loc(std::move(fname), std::move(letters));

    // skip BOM if exists.
    // XXX component of BOM (like 0xEF) exceeds the representable range of
    // signed char, so on some (actually, most) of the environment, these cannot
    // be compared to char. However, since we are always out of luck, we need to
    // check our chars are equivalent to BOM. To do this, first we need to
    // convert char to unsigned char to guarantee the comparability.
    if(loc.source()->size() >= 3)
    {
        std::array<unsigned char, 3> BOM;
        std::memcpy(BOM.data(), loc.source()->data(), 3);
        if(BOM[0] == 0xEF && BOM[1] == 0xBB && BOM[2] == 0xBF)
        {
            loc.advance(3); // BOM found. skip.
        }
    }

    const auto data = detail::parse_toml_file<value_type>(loc);
    if(!data)
    {
        throw syntax_error(data.unwrap_err(), source_location(loc));
    }
    return data.unwrap();
}

template<typename                     Comment = ::toml::discard_comments,
         template<typename ...> class Table   = std::unordered_map,
         template<typename ...> class Array   = std::vector>
basic_value<Comment, Table, Array> parse(const std::string& fname)
{
    std::ifstream ifs(fname.c_str(), std::ios_base::binary);
    if(!ifs.good())
    {
        throw std::runtime_error("toml::parse: file open error -> " + fname);
    }
    return parse<Comment, Table, Array>(ifs, fname);
}

#ifdef TOML11_HAS_STD_FILESYSTEM
// This function just forwards `parse("filename.toml")` to std::string version
// to avoid the ambiguity in overload resolution.
//
// Both std::string and std::filesystem::path are convertible from const char*.
// Without this, both parse(std::string) and parse(std::filesystem::path)
// matches to parse("filename.toml"). This breaks the existing code.
//
// This function exactly matches to the invokation with c-string.
// So this function is preferred than others and the ambiguity disappears.
template<typename                     Comment = ::toml::discard_comments,
         template<typename ...> class Table   = std::unordered_map,
         template<typename ...> class Array   = std::vector>
basic_value<Comment, Table, Array> parse(const char* fname)
{
    return parse<Comment, Table, Array>(std::string(fname));
}

template<typename                     Comment = ::toml::discard_comments,
         template<typename ...> class Table   = std::unordered_map,
         template<typename ...> class Array   = std::vector>
basic_value<Comment, Table, Array> parse(const std::filesystem::path& fpath)
{
    std::ifstream ifs(fpath, std::ios_base::binary);
    if(!ifs.good())
    {
        throw std::runtime_error("toml::parse: file open error -> " +
                                 fpath.string());
    }
    return parse<Comment, Table, Array>(ifs, fpath.string());
}
#endif // TOML11_HAS_STD_FILESYSTEM

} // toml
#endif// TOML11_PARSER_HPP

```

`Dependencies/toml11/toml/region.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_REGION_HPP
#define TOML11_REGION_HPP
#include <memory>
#include <vector>
#include <algorithm>
#include <initializer_list>
#include <iterator>
#include <iomanip>
#include <cassert>
#include "color.hpp"

namespace toml
{
namespace detail
{

// helper function to avoid std::string(0, 'c') or std::string(iter, iter)
template<typename Iterator>
std::string make_string(Iterator first, Iterator last)
{
    if(first == last) {return "";}
    return std::string(first, last);
}
inline std::string make_string(std::size_t len, char c)
{
    if(len == 0) {return "";}
    return std::string(len, c);
}

// region_base is a base class of location and region that are defined below.
// it will be used to generate better error messages.
struct region_base
{
    region_base() = default;
    virtual ~region_base() = default;
    region_base(const region_base&) = default;
    region_base(region_base&&     ) = default;
    region_base& operator=(const region_base&) = default;
    region_base& operator=(region_base&&     ) = default;

    virtual bool is_ok()           const noexcept {return false;}
    virtual char front()           const noexcept {return '\0';}

    virtual std::string str()      const {return std::string("unknown region");}
    virtual std::string name()     const {return std::string("unknown file");}
    virtual std::string line()     const {return std::string("unknown line");}
    virtual std::string line_num() const {return std::string("?");}

    // length of the region
    virtual std::size_t size()     const noexcept {return 0;}
    // number of characters in the line before the region
    virtual std::size_t before()   const noexcept {return 0;}
    // number of characters in the line after the region
    virtual std::size_t after()    const noexcept {return 0;}

    virtual std::vector<std::string> comments() const {return {};}
    // ```toml
    // # comment_before
    // key = "value" # comment_inline
    // ```
};

// location represents a position in a container, which contains a file content.
// it can be considered as a region that contains only one character.
//
// it contains pointer to the file content and iterator that points the current
// location.
struct location final : public region_base
{
    using const_iterator  = typename std::vector<char>::const_iterator;
    using difference_type = typename const_iterator::difference_type;
    using source_ptr      = std::shared_ptr<const std::vector<char>>;

    location(std::string name, std::vector<char> cont)
      : source_(std::make_shared<std::vector<char>>(std::move(cont))),
        line_number_(1), source_name_(std::move(name)), iter_(source_->cbegin())
    {}
    location(std::string name, const std::string& cont)
      : source_(std::make_shared<std::vector<char>>(cont.begin(), cont.end())),
        line_number_(1), source_name_(std::move(name)), iter_(source_->cbegin())
    {}

    location(const location&) = default;
    location(location&&)      = default;
    location& operator=(const location&) = default;
    location& operator=(location&&)      = default;
    ~location() = default;

    bool is_ok() const noexcept override {return static_cast<bool>(source_);}
    char front() const noexcept override {return *iter_;}

    // this const prohibits codes like `++(loc.iter())`.
    const const_iterator iter()  const noexcept {return iter_;}

    const_iterator begin() const noexcept {return source_->cbegin();}
    const_iterator end()   const noexcept {return source_->cend();}

    // XXX `location::line_num()` used to be implemented using `std::count` to
    // count a number of '\n'. But with a long toml file (typically, 10k lines),
    // it becomes intolerably slow because each time it generates error messages,
    // it counts '\n' from thousands of characters. To workaround it, I decided
    // to introduce `location::line_number_` member variable and synchronize it
    // to the location changes the point to look. So an overload of `iter()`
    // which returns mutable reference is removed and `advance()`, `retrace()`
    // and `reset()` is added.
    void advance(difference_type n = 1) noexcept
    {
        this->line_number_ += static_cast<std::size_t>(
                std::count(this->iter_, std::next(this->iter_, n), '\n'));
        this->iter_ += n;
        return;
    }
    void retrace(difference_type n = 1) noexcept
    {
        this->line_number_ -= static_cast<std::size_t>(
                std::count(std::prev(this->iter_, n), this->iter_, '\n'));
        this->iter_ -= n;
        return;
    }
    void reset(const_iterator rollback) noexcept
    {
        // since c++11, std::distance works in both ways for random-access
        // iterators and returns a negative value if `first > last`.
        if(0 <= std::distance(rollback, this->iter_)) // rollback < iter
        {
            this->line_number_ -= static_cast<std::size_t>(
                    std::count(rollback, this->iter_, '\n'));
        }
        else // iter < rollback [[unlikely]]
        {
            this->line_number_ += static_cast<std::size_t>(
                    std::count(this->iter_, rollback, '\n'));
        }
        this->iter_ = rollback;
        return;
    }

    std::string str()  const override {return make_string(1, *this->iter());}
    std::string name() const override {return source_name_;}

    std::string line_num() const override
    {
        return std::to_string(this->line_number_);
    }

    std::string line() const override
    {
        return make_string(this->line_begin(), this->line_end());
    }

    const_iterator line_begin() const noexcept
    {
        using reverse_iterator = std::reverse_iterator<const_iterator>;
        return std::find(reverse_iterator(this->iter()),
                         reverse_iterator(this->begin()), '\n').base();
    }
    const_iterator line_end() const noexcept
    {
        return std::find(this->iter(), this->end(), '\n');
    }

    // location is always points a character. so the size is 1.
    std::size_t size() const noexcept override
    {
        return 1u;
    }
    std::size_t before() const noexcept override
    {
        const auto sz = std::distance(this->line_begin(), this->iter());
        assert(sz >= 0);
        return static_cast<std::size_t>(sz);
    }
    std::size_t after() const noexcept override
    {
        const auto sz = std::distance(this->iter(), this->line_end());
        assert(sz >= 0);
        return static_cast<std::size_t>(sz);
    }

    source_ptr const& source() const& noexcept {return source_;}
    source_ptr&&      source() &&     noexcept {return std::move(source_);}

  private:

    source_ptr     source_;
    std::size_t    line_number_;
    std::string    source_name_;
    const_iterator iter_;
};

// region represents a range in a container, which contains a file content.
//
// it contains pointer to the file content and iterator that points the first
// and last location.
struct region final : public region_base
{
    using const_iterator = typename std::vector<char>::const_iterator;
    using source_ptr     = std::shared_ptr<const std::vector<char>>;

    // delete default constructor. source_ never be null.
    region() = delete;

    explicit region(const location& loc)
      : source_(loc.source()), source_name_(loc.name()),
        first_(loc.iter()), last_(loc.iter())
    {}
    explicit region(location&& loc)
      : source_(loc.source()), source_name_(loc.name()),
        first_(loc.iter()), last_(loc.iter())
    {}

    region(const location& loc, const_iterator f, const_iterator l)
      : source_(loc.source()), source_name_(loc.name()), first_(f), last_(l)
    {}
    region(location&& loc, const_iterator f, const_iterator l)
      : source_(loc.source()), source_name_(loc.name()), first_(f), last_(l)
    {}

    region(const region&) = default;
    region(region&&)      = default;
    region& operator=(const region&) = default;
    region& operator=(region&&)      = default;
    ~region() = default;

    region& operator+=(const region& other)
    {
        // different regions cannot be concatenated
        assert(this->begin() == other.begin() && this->end() == other.end() &&
               this->last_   == other.first_);

        this->last_ = other.last_;
        return *this;
    }

    bool is_ok() const noexcept override {return static_cast<bool>(source_);}
    char front() const noexcept override {return *first_;}

    std::string str()  const override {return make_string(first_, last_);}
    std::string line() const override
    {
        if(this->contain_newline())
        {
            return make_string(this->line_begin(),
                    std::find(this->line_begin(), this->last(), '\n'));
        }
        return make_string(this->line_begin(), this->line_end());
    }
    std::string line_num() const override
    {
        return std::to_string(1 + std::count(this->begin(), this->first(), '\n'));
    }

    std::size_t size() const noexcept override
    {
        const auto sz = std::distance(first_, last_);
        assert(sz >= 0);
        return static_cast<std::size_t>(sz);
    }
    std::size_t before() const noexcept override
    {
        const auto sz = std::distance(this->line_begin(), this->first());
        assert(sz >= 0);
        return static_cast<std::size_t>(sz);
    }
    std::size_t after() const noexcept override
    {
        const auto sz = std::distance(this->last(), this->line_end());
        assert(sz >= 0);
        return static_cast<std::size_t>(sz);
    }

    bool contain_newline() const noexcept
    {
        return std::find(this->first(), this->last(), '\n') != this->last();
    }

    const_iterator line_begin() const noexcept
    {
        using reverse_iterator = std::reverse_iterator<const_iterator>;
        return std::find(reverse_iterator(this->first()),
                         reverse_iterator(this->begin()), '\n').base();
    }
    const_iterator line_end() const noexcept
    {
        return std::find(this->last(), this->end(), '\n');
    }

    const_iterator begin() const noexcept {return source_->cbegin();}
    const_iterator end()   const noexcept {return source_->cend();}
    const_iterator first() const noexcept {return first_;}
    const_iterator last()  const noexcept {return last_;}

    source_ptr const& source() const& noexcept {return source_;}
    source_ptr&&      source() &&     noexcept {return std::move(source_);}

    std::string name() const override {return source_name_;}

    std::vector<std::string> comments() const override
    {
        // assuming the current region (`*this`) points a value.
        // ```toml
        // a = "value"
        //     ^^^^^^^- this region
        // ```
        using rev_iter = std::reverse_iterator<const_iterator>;

        std::vector<std::string> com{};
        {
            // find comments just before the current region.
            // ```toml
            // # this should be collected.
            // # this also.
            // a = value # not this.
            // ```

            // # this is a comment for `a`, not array elements.
            // a = [1, 2, 3, 4, 5]
            if(this->first() == std::find_if(this->line_begin(), this->first(),
                [](const char c) noexcept -> bool {return c == '[' || c == '{';}))
            {
                auto iter = this->line_begin(); // points the first character
                while(iter != this->begin())
                {
                    iter = std::prev(iter);

                    // range [line_start, iter) represents the previous line
                    const auto line_start   = std::find(
                            rev_iter(iter), rev_iter(this->begin()), '\n').base();
                    const auto comment_found = std::find(line_start, iter, '#');
                    if(comment_found == iter)
                    {
                        break; // comment not found.
                    }

                    // exclude the following case.
                    // > a = "foo" # comment // <-- this is not a comment for b but a.
                    // > b = "current value"
                    if(std::all_of(line_start, comment_found,
                            [](const char c) noexcept -> bool {
                                return c == ' ' || c == '\t';
                            }))
                    {
                        // unwrap the first '#' by std::next.
                        auto str = make_string(std::next(comment_found), iter);
                        if(str.back() == '\r') {str.pop_back();}
                        com.push_back(std::move(str));
                    }
                    else
                    {
                        break;
                    }
                    iter = line_start;
                }
            }
        }

        if(com.size() > 1)
        {
            std::reverse(com.begin(), com.end());
        }

        {
            // find comments just after the current region.
            // ```toml
            // # not this.
            // a = value # this one.
            // a = [ # not this (technically difficult)
            //
            // ] # and this.
            // ```
            // The reason why it's difficult is that it requires parsing in the
            // following case.
            // ```toml
            // a = [ 10 # this comment is for `10`. not for `a` but `a[0]`.
            // # ...
            // ] # this is apparently a comment for a.
            //
            // b = [
            // 3.14 ] # there is no way to add a comment to `3.14` currently.
            //
            // c = [
            //   3.14 # do this if you need a comment here.
            // ]
            // ```
            const auto comment_found =
                std::find(this->last(), this->line_end(), '#');
            if(comment_found != this->line_end()) // '#' found
            {
                // table = {key = "value"} # what is this for?
                // the above comment is not for "value", but {key="value"}.
                if(comment_found == std::find_if(this->last(), comment_found,
                    [](const char c) noexcept -> bool {
                        return !(c == ' ' || c == '\t' || c == ',');
                    }))
                {
                    // unwrap the first '#' by std::next.
                    auto str = make_string(std::next(comment_found), this->line_end());
                    if(str.back() == '\r') {str.pop_back();}
                    com.push_back(std::move(str));
                }
            }
        }
        return com;
    }

  private:

    source_ptr     source_;
    std::string    source_name_;
    const_iterator first_, last_;
};

} // detail
} // toml
#endif// TOML11_REGION_H

```

`Dependencies/toml11/toml/result.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_RESULT_HPP
#define TOML11_RESULT_HPP
#include "traits.hpp"
#include <type_traits>
#include <stdexcept>
#include <utility>
#include <new>
#include <string>
#include <sstream>
#include <cassert>

namespace toml
{

template<typename T>
struct success
{
    using value_type = T;
    value_type value;

    explicit success(const value_type& v)
        noexcept(std::is_nothrow_copy_constructible<value_type>::value)
        : value(v)
    {}
    explicit success(value_type&& v)
        noexcept(std::is_nothrow_move_constructible<value_type>::value)
        : value(std::move(v))
    {}

    template<typename U>
    explicit success(U&& v): value(std::forward<U>(v)) {}

    template<typename U>
    explicit success(const success<U>& v): value(v.value) {}
    template<typename U>
    explicit success(success<U>&& v): value(std::move(v.value)) {}

    ~success() = default;
    success(const success&) = default;
    success(success&&)      = default;
    success& operator=(const success&) = default;
    success& operator=(success&&)      = default;
};

template<typename T>
struct failure
{
    using value_type = T;
    value_type value;

    explicit failure(const value_type& v)
        noexcept(std::is_nothrow_copy_constructible<value_type>::value)
        : value(v)
    {}
    explicit failure(value_type&& v)
        noexcept(std::is_nothrow_move_constructible<value_type>::value)
        : value(std::move(v))
    {}

    template<typename U>
    explicit failure(U&& v): value(std::forward<U>(v)) {}

    template<typename U>
    explicit failure(const failure<U>& v): value(v.value) {}
    template<typename U>
    explicit failure(failure<U>&& v): value(std::move(v.value)) {}

    ~failure() = default;
    failure(const failure&) = default;
    failure(failure&&)      = default;
    failure& operator=(const failure&) = default;
    failure& operator=(failure&&)      = default;
};

template<typename T>
success<typename std::remove_cv<typename std::remove_reference<T>::type>::type>
ok(T&& v)
{
    return success<
        typename std::remove_cv<typename std::remove_reference<T>::type>::type
        >(std::forward<T>(v));
}
template<typename T>
failure<typename std::remove_cv<typename std::remove_reference<T>::type>::type>
err(T&& v)
{
    return failure<
        typename std::remove_cv<typename std::remove_reference<T>::type>::type
        >(std::forward<T>(v));
}

inline success<std::string> ok(const char* literal)
{
    return success<std::string>(std::string(literal));
}
inline failure<std::string> err(const char* literal)
{
    return failure<std::string>(std::string(literal));
}


template<typename T, typename E>
struct result
{
    using value_type = T;
    using error_type = E;
    using success_type = success<value_type>;
    using failure_type = failure<error_type>;

    result(const success_type& s): is_ok_(true)
    {
        auto tmp = ::new(std::addressof(this->succ)) success_type(s);
        assert(tmp == std::addressof(this->succ));
        (void)tmp;
    }
    result(const failure_type& f): is_ok_(false)
    {
        auto tmp = ::new(std::addressof(this->fail)) failure_type(f);
        assert(tmp == std::addressof(this->fail));
        (void)tmp;
    }
    result(success_type&& s): is_ok_(true)
    {
        auto tmp = ::new(std::addressof(this->succ)) success_type(std::move(s));
        assert(tmp == std::addressof(this->succ));
        (void)tmp;
    }
    result(failure_type&& f): is_ok_(false)
    {
        auto tmp = ::new(std::addressof(this->fail)) failure_type(std::move(f));
        assert(tmp == std::addressof(this->fail));
        (void)tmp;
    }

    template<typename U>
    result(const success<U>& s): is_ok_(true)
    {
        auto tmp = ::new(std::addressof(this->succ)) success_type(s.value);
        assert(tmp == std::addressof(this->succ));
        (void)tmp;
    }
    template<typename U>
    result(const failure<U>& f): is_ok_(false)
    {
        auto tmp = ::new(std::addressof(this->fail)) failure_type(f.value);
        assert(tmp == std::addressof(this->fail));
        (void)tmp;
    }
    template<typename U>
    result(success<U>&& s): is_ok_(true)
    {
        auto tmp = ::new(std::addressof(this->succ)) success_type(std::move(s.value));
        assert(tmp == std::addressof(this->succ));
        (void)tmp;
    }
    template<typename U>
    result(failure<U>&& f): is_ok_(false)
    {
        auto tmp = ::new(std::addressof(this->fail)) failure_type(std::move(f.value));
        assert(tmp == std::addressof(this->fail));
        (void)tmp;
    }

    result& operator=(const success_type& s)
    {
        this->cleanup();
        this->is_ok_ = true;
        auto tmp = ::new(std::addressof(this->succ)) success_type(s);
        assert(tmp == std::addressof(this->succ));
        (void)tmp;
        return *this;
    }
    result& operator=(const failure_type& f)
    {
        this->cleanup();
        this->is_ok_ = false;
        auto tmp = ::new(std::addressof(this->fail)) failure_type(f);
        assert(tmp == std::addressof(this->fail));
        (void)tmp;
        return *this;
    }
    result& operator=(success_type&& s)
    {
        this->cleanup();
        this->is_ok_ = true;
        auto tmp = ::new(std::addressof(this->succ)) success_type(std::move(s));
        assert(tmp == std::addressof(this->succ));
        (void)tmp;
        return *this;
    }
    result& operator=(failure_type&& f)
    {
        this->cleanup();
        this->is_ok_ = false;
        auto tmp = ::new(std::addressof(this->fail)) failure_type(std::move(f));
        assert(tmp == std::addressof(this->fail));
        (void)tmp;
        return *this;
    }

    template<typename U>
    result& operator=(const success<U>& s)
    {
        this->cleanup();
        this->is_ok_ = true;
        auto tmp = ::new(std::addressof(this->succ)) success_type(s.value);
        assert(tmp == std::addressof(this->succ));
        (void)tmp;
        return *this;
    }
    template<typename U>
    result& operator=(const failure<U>& f)
    {
        this->cleanup();
        this->is_ok_ = false;
        auto tmp = ::new(std::addressof(this->fail)) failure_type(f.value);
        assert(tmp == std::addressof(this->fail));
        (void)tmp;
        return *this;
    }
    template<typename U>
    result& operator=(success<U>&& s)
    {
        this->cleanup();
        this->is_ok_ = true;
        auto tmp = ::new(std::addressof(this->succ)) success_type(std::move(s.value));
        assert(tmp == std::addressof(this->succ));
        (void)tmp;
        return *this;
    }
    template<typename U>
    result& operator=(failure<U>&& f)
    {
        this->cleanup();
        this->is_ok_ = false;
        auto tmp = ::new(std::addressof(this->fail)) failure_type(std::move(f.value));
        assert(tmp == std::addressof(this->fail));
        (void)tmp;
        return *this;
    }

    ~result() noexcept {this->cleanup();}

    result(const result& other): is_ok_(other.is_ok())
    {
        if(other.is_ok())
        {
            auto tmp = ::new(std::addressof(this->succ)) success_type(other.as_ok());
            assert(tmp == std::addressof(this->succ));
            (void)tmp;
        }
        else
        {
            auto tmp = ::new(std::addressof(this->fail)) failure_type(other.as_err());
            assert(tmp == std::addressof(this->fail));
            (void)tmp;
        }
    }
    result(result&& other): is_ok_(other.is_ok())
    {
        if(other.is_ok())
        {
            auto tmp = ::new(std::addressof(this->succ)) success_type(std::move(other.as_ok()));
            assert(tmp == std::addressof(this->succ));
            (void)tmp;
        }
        else
        {
            auto tmp = ::new(std::addressof(this->fail)) failure_type(std::move(other.as_err()));
            assert(tmp == std::addressof(this->fail));
            (void)tmp;
        }
    }

    template<typename U, typename F>
    result(const result<U, F>& other): is_ok_(other.is_ok())
    {
        if(other.is_ok())
        {
            auto tmp = ::new(std::addressof(this->succ)) success_type(other.as_ok());
            assert(tmp == std::addressof(this->succ));
            (void)tmp;
        }
        else
        {
            auto tmp = ::new(std::addressof(this->fail)) failure_type(other.as_err());
            assert(tmp == std::addressof(this->fail));
            (void)tmp;
        }
    }
    template<typename U, typename F>
    result(result<U, F>&& other): is_ok_(other.is_ok())
    {
        if(other.is_ok())
        {
            auto tmp = ::new(std::addressof(this->succ)) success_type(std::move(other.as_ok()));
            assert(tmp == std::addressof(this->succ));
            (void)tmp;
        }
        else
        {
            auto tmp = ::new(std::addressof(this->fail)) failure_type(std::move(other.as_err()));
            assert(tmp == std::addressof(this->fail));
            (void)tmp;
        }
    }

    result& operator=(const result& other)
    {
        this->cleanup();
        if(other.is_ok())
        {
            auto tmp = ::new(std::addressof(this->succ)) success_type(other.as_ok());
            assert(tmp == std::addressof(this->succ));
            (void)tmp;
        }
        else
        {
            auto tmp = ::new(std::addressof(this->fail)) failure_type(other.as_err());
            assert(tmp == std::addressof(this->fail));
            (void)tmp;
        }
        is_ok_ = other.is_ok();
        return *this;
    }
    result& operator=(result&& other)
    {
        this->cleanup();
        if(other.is_ok())
        {
            auto tmp = ::new(std::addressof(this->succ)) success_type(std::move(other.as_ok()));
            assert(tmp == std::addressof(this->succ));
            (void)tmp;
        }
        else
        {
            auto tmp = ::new(std::addressof(this->fail)) failure_type(std::move(other.as_err()));
            assert(tmp == std::addressof(this->fail));
            (void)tmp;
        }
        is_ok_ = other.is_ok();
        return *this;
    }

    template<typename U, typename F>
    result& operator=(const result<U, F>& other)
    {
        this->cleanup();
        if(other.is_ok())
        {
            auto tmp = ::new(std::addressof(this->succ)) success_type(other.as_ok());
            assert(tmp == std::addressof(this->succ));
            (void)tmp;
        }
        else
        {
            auto tmp = ::new(std::addressof(this->fail)) failure_type(other.as_err());
            assert(tmp == std::addressof(this->fail));
            (void)tmp;
        }
        is_ok_ = other.is_ok();
        return *this;
    }
    template<typename U, typename F>
    result& operator=(result<U, F>&& other)
    {
        this->cleanup();
        if(other.is_ok())
        {
            auto tmp = ::new(std::addressof(this->succ)) success_type(std::move(other.as_ok()));
            assert(tmp == std::addressof(this->succ));
            (void)tmp;
        }
        else
        {
            auto tmp = ::new(std::addressof(this->fail)) failure_type(std::move(other.as_err()));
            assert(tmp == std::addressof(this->fail));
            (void)tmp;
        }
        is_ok_ = other.is_ok();
        return *this;
    }

    bool is_ok()  const noexcept {return is_ok_;}
    bool is_err() const noexcept {return !is_ok_;}

    operator bool() const noexcept {return is_ok_;}

    value_type&       unwrap() &
    {
        if(is_err())
        {
            throw std::runtime_error("toml::result: bad unwrap: " +
                                     format_error(this->as_err()));
        }
        return this->succ.value;
    }
    value_type const& unwrap() const&
    {
        if(is_err())
        {
            throw std::runtime_error("toml::result: bad unwrap: " +
                                     format_error(this->as_err()));
        }
        return this->succ.value;
    }
    value_type&&      unwrap() &&
    {
        if(is_err())
        {
            throw std::runtime_error("toml::result: bad unwrap: " +
                                     format_error(this->as_err()));
        }
        return std::move(this->succ.value);
    }

    value_type&       unwrap_or(value_type& opt) &
    {
        if(is_err()) {return opt;}
        return this->succ.value;
    }
    value_type const& unwrap_or(value_type const& opt) const&
    {
        if(is_err()) {return opt;}
        return this->succ.value;
    }
    value_type        unwrap_or(value_type opt) &&
    {
        if(is_err()) {return opt;}
        return this->succ.value;
    }

    error_type&       unwrap_err() &
    {
        if(is_ok()) {throw std::runtime_error("toml::result: bad unwrap_err");}
        return this->fail.value;
    }
    error_type const& unwrap_err() const&
    {
        if(is_ok()) {throw std::runtime_error("toml::result: bad unwrap_err");}
        return this->fail.value;
    }
    error_type&&      unwrap_err() &&
    {
        if(is_ok()) {throw std::runtime_error("toml::result: bad unwrap_err");}
        return std::move(this->fail.value);
    }

    value_type&       as_ok() &      noexcept {return this->succ.value;}
    value_type const& as_ok() const& noexcept {return this->succ.value;}
    value_type&&      as_ok() &&     noexcept {return std::move(this->succ.value);}

    error_type&       as_err() &      noexcept {return this->fail.value;}
    error_type const& as_err() const& noexcept {return this->fail.value;}
    error_type&&      as_err() &&     noexcept {return std::move(this->fail.value);}


    // prerequisities
    // F: T -> U
    // retval: result<U, E>
    template<typename F>
    result<detail::return_type_of_t<F, value_type&>, error_type>
    map(F&& f) &
    {
        if(this->is_ok()){return ok(f(this->as_ok()));}
        return err(this->as_err());
    }
    template<typename F>
    result<detail::return_type_of_t<F, value_type const&>, error_type>
    map(F&& f) const&
    {
        if(this->is_ok()){return ok(f(this->as_ok()));}
        return err(this->as_err());
    }
    template<typename F>
    result<detail::return_type_of_t<F, value_type &&>, error_type>
    map(F&& f) &&
    {
        if(this->is_ok()){return ok(f(std::move(this->as_ok())));}
        return err(std::move(this->as_err()));
    }

    // prerequisities
    // F: E -> F
    // retval: result<T, F>
    template<typename F>
    result<value_type, detail::return_type_of_t<F, error_type&>>
    map_err(F&& f) &
    {
        if(this->is_err()){return err(f(this->as_err()));}
        return ok(this->as_ok());
    }
    template<typename F>
    result<value_type, detail::return_type_of_t<F, error_type const&>>
    map_err(F&& f) const&
    {
        if(this->is_err()){return err(f(this->as_err()));}
        return ok(this->as_ok());
    }
    template<typename F>
    result<value_type, detail::return_type_of_t<F, error_type&&>>
    map_err(F&& f) &&
    {
        if(this->is_err()){return err(f(std::move(this->as_err())));}
        return ok(std::move(this->as_ok()));
    }

    // prerequisities
    // F: T -> U
    // retval: U
    template<typename F, typename U>
    detail::return_type_of_t<F, value_type&>
    map_or_else(F&& f, U&& opt) &
    {
        if(this->is_err()){return std::forward<U>(opt);}
        return f(this->as_ok());
    }
    template<typename F, typename U>
    detail::return_type_of_t<F, value_type const&>
    map_or_else(F&& f, U&& opt) const&
    {
        if(this->is_err()){return std::forward<U>(opt);}
        return f(this->as_ok());
    }
    template<typename F, typename U>
    detail::return_type_of_t<F, value_type&&>
    map_or_else(F&& f, U&& opt) &&
    {
        if(this->is_err()){return std::forward<U>(opt);}
        return f(std::move(this->as_ok()));
    }

    // prerequisities
    // F: E -> U
    // retval: U
    template<typename F, typename U>
    detail::return_type_of_t<F, error_type&>
    map_err_or_else(F&& f, U&& opt) &
    {
        if(this->is_ok()){return std::forward<U>(opt);}
        return f(this->as_err());
    }
    template<typename F, typename U>
    detail::return_type_of_t<F, error_type const&>
    map_err_or_else(F&& f, U&& opt) const&
    {
        if(this->is_ok()){return std::forward<U>(opt);}
        return f(this->as_err());
    }
    template<typename F, typename U>
    detail::return_type_of_t<F, error_type&&>
    map_err_or_else(F&& f, U&& opt) &&
    {
        if(this->is_ok()){return std::forward<U>(opt);}
        return f(std::move(this->as_err()));
    }

    // prerequisities:
    // F: func T -> U
    // toml::err(error_type) should be convertible to U.
    // normally, type U is another result<S, F> and E is convertible to F
    template<typename F>
    detail::return_type_of_t<F, value_type&>
    and_then(F&& f) &
    {
        if(this->is_ok()){return f(this->as_ok());}
        return err(this->as_err());
    }
    template<typename F>
    detail::return_type_of_t<F, value_type const&>
    and_then(F&& f) const&
    {
        if(this->is_ok()){return f(this->as_ok());}
        return err(this->as_err());
    }
    template<typename F>
    detail::return_type_of_t<F, value_type&&>
    and_then(F&& f) &&
    {
        if(this->is_ok()){return f(std::move(this->as_ok()));}
        return err(std::move(this->as_err()));
    }

    // prerequisities:
    // F: func E -> U
    // toml::ok(value_type) should be convertible to U.
    // normally, type U is another result<S, F> and T is convertible to S
    template<typename F>
    detail::return_type_of_t<F, error_type&>
    or_else(F&& f) &
    {
        if(this->is_err()){return f(this->as_err());}
        return ok(this->as_ok());
    }
    template<typename F>
    detail::return_type_of_t<F, error_type const&>
    or_else(F&& f) const&
    {
        if(this->is_err()){return f(this->as_err());}
        return ok(this->as_ok());
    }
    template<typename F>
    detail::return_type_of_t<F, error_type&&>
    or_else(F&& f) &&
    {
        if(this->is_err()){return f(std::move(this->as_err()));}
        return ok(std::move(this->as_ok()));
    }

    // if *this is error, returns *this. otherwise, returns other.
    result and_other(const result& other) const&
    {
        return this->is_err() ? *this : other;
    }
    result and_other(result&& other) &&
    {
        return this->is_err() ? std::move(*this) : std::move(other);
    }

    // if *this is okay, returns *this. otherwise, returns other.
    result or_other(const result& other) const&
    {
        return this->is_ok() ? *this : other;
    }
    result or_other(result&& other) &&
    {
        return this->is_ok() ? std::move(*this) : std::move(other);
    }

    void swap(result<T, E>& other)
    {
        result<T, E> tmp(std::move(*this));
        *this = std::move(other);
        other = std::move(tmp);
        return ;
    }

  private:

    static std::string format_error(std::exception const& excpt)
    {
        return std::string(excpt.what());
    }
    template<typename U, typename std::enable_if<!std::is_base_of<
        std::exception, U>::value, std::nullptr_t>::type = nullptr>
    static std::string format_error(U const& others)
    {
        std::ostringstream oss; oss << others;
        return oss.str();
    }

    void cleanup() noexcept
    {
        if(this->is_ok_) {this->succ.~success_type();}
        else             {this->fail.~failure_type();}
        return;
    }

  private:

    bool      is_ok_;
    union
    {
        success_type succ;
        failure_type fail;
    };
};

template<typename T, typename E>
void swap(result<T, E>& lhs, result<T, E>& rhs)
{
    lhs.swap(rhs);
    return;
}

// this might be confusing because it eagerly evaluated, while in the other
// cases operator && and || are short-circuited.
//
// template<typename T, typename E>
// inline result<T, E>
// operator&&(const result<T, E>& lhs, const result<T, E>& rhs) noexcept
// {
//     return lhs.is_ok() ? rhs : lhs;
// }
//
// template<typename T, typename E>
// inline result<T, E>
// operator||(const result<T, E>& lhs, const result<T, E>& rhs) noexcept
// {
//     return lhs.is_ok() ? lhs : rhs;
// }

// ----------------------------------------------------------------------------
// re-use result<T, E> as a optional<T> with none_t

namespace detail
{
struct none_t {};
inline bool operator==(const none_t&, const none_t&) noexcept {return true;}
inline bool operator!=(const none_t&, const none_t&) noexcept {return false;}
inline bool operator< (const none_t&, const none_t&) noexcept {return false;}
inline bool operator<=(const none_t&, const none_t&) noexcept {return true;}
inline bool operator> (const none_t&, const none_t&) noexcept {return false;}
inline bool operator>=(const none_t&, const none_t&) noexcept {return true;}
template<typename charT, typename traitsT>
std::basic_ostream<charT, traitsT>&
operator<<(std::basic_ostream<charT, traitsT>& os, const none_t&)
{
    os << "none";
    return os;
}
inline failure<none_t> none() noexcept {return failure<none_t>{none_t{}};}
} // detail
} // toml11
#endif// TOML11_RESULT_H

```

`Dependencies/toml11/toml/serializer.hpp`:

```hpp
//     Copyright Toru Niina 2019.
// Distributed under the MIT License.
#ifndef TOML11_SERIALIZER_HPP
#define TOML11_SERIALIZER_HPP
#include <cstdio>

#include <limits>

#include "lexer.hpp"
#include "value.hpp"

namespace toml
{

// This function serialize a key. It checks a string is a bare key and
// escapes special characters if the string is not compatible to a bare key.
// ```cpp
// std::string k("non.bare.key"); // the key itself includes `.`s.
// std::string formatted = toml::format_key(k);
// assert(formatted == "\"non.bare.key\"");
// ```
//
// This function is exposed to make it easy to write a user-defined serializer.
// Since toml restricts characters available in a bare key, generally a string
// should be escaped. But checking whether a string needs to be surrounded by
// a `"` and escaping some special character is boring.
template<typename charT, typename traits, typename Alloc>
std::basic_string<charT, traits, Alloc>
format_key(const std::basic_string<charT, traits, Alloc>& key)
{
    // check the key can be a bare (unquoted) key
    detail::location loc(key, std::vector<char>(key.begin(), key.end()));
    detail::lex_unquoted_key::invoke(loc);
    if(loc.iter() == loc.end())
    {
        return key; // all the tokens are consumed. the key is unquoted-key.
    }

    //if it includes special characters, then format it in a "quoted" key.
    std::basic_string<charT, traits, Alloc> serialized("\"");
    for(const char c : key)
    {
        switch(c)
        {
            case '\\': {serialized += "\\\\"; break;}
            case '\"': {serialized += "\\\""; break;}
            case '\b': {serialized += "\\b";  break;}
            case '\t': {serialized += "\\t";  break;}
            case '\f': {serialized += "\\f";  break;}
            case '\n': {serialized += "\\n";  break;}
            case '\r': {serialized += "\\r";  break;}
            default  : {serialized += c;      break;}
        }
    }
    serialized += "\"";
    return serialized;
}

template<typename charT, typename traits, typename Alloc>
std::basic_string<charT, traits, Alloc>
format_keys(const std::vector<std::basic_string<charT, traits, Alloc>>& keys)
{
    std::basic_string<charT, traits, Alloc> serialized;
    if(keys.empty()) {return serialized;}

    for(const auto& ky : keys)
    {
        serialized += format_key(ky);
        serialized += charT('.');
    }
    serialized.pop_back(); // remove the last dot '.'
    return serialized;
}

template<typename Value>
struct serializer
{
    static_assert(detail::is_basic_value<Value>::value,
                  "toml::serializer is for toml::value and its variants, "
                  "toml::basic_value<...>.");

    using value_type           = Value;
    using key_type             = typename value_type::key_type            ;
    using comment_type         = typename value_type::comment_type        ;
    using boolean_type         = typename value_type::boolean_type        ;
    using integer_type         = typename value_type::integer_type        ;
    using floating_type        = typename value_type::floating_type       ;
    using string_type          = typename value_type::string_type         ;
    using local_time_type      = typename value_type::local_time_type     ;
    using local_date_type      = typename value_type::local_date_type     ;
    using local_datetime_type  = typename value_type::local_datetime_type ;
    using offset_datetime_type = typename value_type::offset_datetime_type;
    using array_type           = typename value_type::array_type          ;
    using table_type           = typename value_type::table_type          ;

    serializer(const std::size_t w              = 80u,
               const int         float_prec     = std::numeric_limits<toml::floating>::max_digits10,
               const bool        can_be_inlined = false,
               const bool        no_comment     = false,
               std::vector<toml::key> ks        = {})
        : can_be_inlined_(can_be_inlined), no_comment_(no_comment),
          float_prec_(float_prec), width_(w), keys_(std::move(ks))
    {}
    ~serializer() = default;

    std::string operator()(const boolean_type& b) const
    {
        return b ? "true" : "false";
    }
    std::string operator()(const integer_type i) const
    {
        return std::to_string(i);
    }
    std::string operator()(const floating_type f) const
    {
        const auto fmt = "%.*g";
        const auto bsz = std::snprintf(nullptr, 0, fmt, this->float_prec_, f);
        // +1 for null character(\0)
        std::vector<char> buf(static_cast<std::size_t>(bsz + 1), '\0');
        std::snprintf(buf.data(), buf.size(), fmt, this->float_prec_, f);

        std::string token(buf.begin(), std::prev(buf.end()));
        if(token.back() == '.') // 1. => 1.0
        {
            token += '0';
        }

        const auto e = std::find_if(
            token.cbegin(), token.cend(), [](const char c) noexcept -> bool {
                return c == 'e' || c == 'E';
            });
        const auto has_exponent = (token.cend() != e);
        const auto has_fraction = (token.cend() != std::find(
            token.cbegin(), token.cend(), '.'));

        if(!has_exponent && !has_fraction)
        {
            // the resulting value does not have any float specific part!
            token += ".0";
        }
        return token;
    }
    std::string operator()(const string_type& s) const
    {
        if(s.kind == string_t::basic)
        {
            if(std::find(s.str.cbegin(), s.str.cend(), '\n') != s.str.cend() ||
               std::find(s.str.cbegin(), s.str.cend(), '\"') != s.str.cend())
            {
                // if linefeed or double-quote is contained,
                // make it multiline basic string.
                const auto escaped = this->escape_ml_basic_string(s.str);
                std::string open("\"\"\"");
                std::string close("\"\"\"");
                if(escaped.find('\n') != std::string::npos ||
                   this->width_ < escaped.size() + 6)
                {
                    // if the string body contains newline or is enough long,
                    // add newlines after and before delimiters.
                    open += "\n";
                    close = std::string("\\\n") + close;
                }
                return open + escaped + close;
            }

            // no linefeed. try to make it oneline-string.
            std::string oneline = this->escape_basic_string(s.str);
            if(oneline.size() + 2 < width_ || width_ < 2)
            {
                const std::string quote("\"");
                return quote + oneline + quote;
            }

            // the line is too long compared to the specified width.
            // split it into multiple lines.
            std::string token("\"\"\"\n");
            while(!oneline.empty())
            {
                if(oneline.size() < width_)
                {
                    token += oneline;
                    oneline.clear();
                }
                else if(oneline.at(width_-2) == '\\')
                {
                    token += oneline.substr(0, width_-2);
                    token += "\\\n";
                    oneline.erase(0, width_-2);
                }
                else
                {
                    token += oneline.substr(0, width_-1);
                    token += "\\\n";
                    oneline.erase(0, width_-1);
                }
            }
            return token + std::string("\\\n\"\"\"");
        }
        else // the string `s` is literal-string.
        {
            if(std::find(s.str.cbegin(), s.str.cend(), '\n') != s.str.cend() ||
               std::find(s.str.cbegin(), s.str.cend(), '\'') != s.str.cend() )
            {
                std::string open("'''");
                if(this->width_ + 6 < s.str.size())
                {
                    open += '\n'; // the first newline is ignored by TOML spec
                }
                const std::string close("'''");
                return open + s.str + close;
            }
            else
            {
                const std::string quote("'");
                return quote + s.str + quote;
            }
        }
    }

    std::string operator()(const local_date_type& d) const
    {
        std::ostringstream oss;
        oss << d;
        return oss.str();
    }
    std::string operator()(const local_time_type& t) const
    {
        std::ostringstream oss;
        oss << t;
        return oss.str();
    }
    std::string operator()(const local_datetime_type& dt) const
    {
        std::ostringstream oss;
        oss << dt;
        return oss.str();
    }
    std::string operator()(const offset_datetime_type& odt) const
    {
        std::ostringstream oss;
        oss << odt;
        return oss.str();
    }

    std::string operator()(const array_type& v) const
    {
        if(!v.empty() && v.front().is_table())// v is an array of tables
        {
            // if it's not inlined, we need to add `[[table.key]]`.
            // but if it can be inlined,
            // ```
            // table.key = [
            //   {...},
            //   # comment
            //   {...},
            // ]
            // ```
            if(this->can_be_inlined_)
            {
                std::string token;
                if(!keys_.empty())
                {
                    token += format_key(keys_.back());
                    token += " = ";
                }
                bool failed = false;
                token += "[\n";
                for(const auto& item : v)
                {
                    // if an element of the table has a comment, the table
                    // cannot be inlined.
                    if(this->has_comment_inside(item.as_table()))
                    {
                        failed = true;
                        break;
                    }
                    if(!no_comment_)
                    {
                        for(const auto& c : item.comments())
                        {
                            token += '#';
                            token += c;
                            token += '\n';
                        }
                    }

                    const auto t = this->make_inline_table(item.as_table());

                    if(t.size() + 1 > width_ || // +1 for the last comma {...},
                       std::find(t.cbegin(), t.cend(), '\n') != t.cend())
                    {
                        failed = true;
                        break;
                    }
                    token += t;
                    token += ",\n";
                }
                if(!failed)
                {
                    token += "]\n";
                    return token;
                }
                // if failed, serialize them as [[array.of.tables]].
            }

            std::string token;
            for(const auto& item : v)
            {
                if(!no_comment_)
                {
                    for(const auto& c : item.comments())
                    {
                        token += '#';
                        token += c;
                        token += '\n';
                    }
                }
                token += "[[";
                token += format_keys(keys_);
                token += "]]\n";
                token += this->make_multiline_table(item.as_table());
            }
            return token;
        }
        if(v.empty())
        {
            return std::string("[]");
        }

        // not an array of tables. normal array.
        // first, try to make it inline if none of the elements have a comment.
        if(!this->has_comment_inside(v))
        {
            const auto inl = this->make_inline_array(v);
            if(inl.size() < this->width_ &&
               std::find(inl.cbegin(), inl.cend(), '\n') == inl.cend())
            {
                return inl;
            }
        }

        // if the length exceeds this->width_, print multiline array.
        // key = [
        //   # ...
        //   42,
        //   ...
        // ]
        std::string token;
        std::string current_line;
        token += "[\n";
        for(const auto& item : v)
        {
            if(!item.comments().empty() && !no_comment_)
            {
                // if comment exists, the element must be the only element in the line.
                // e.g. the following is not allowed.
                // ```toml
                // array = [
                // # comment for what?
                // 1, 2, 3, 4, 5
                // ]
                // ```
                if(!current_line.empty())
                {
                    if(current_line.back() != '\n')
                    {
                        current_line += '\n';
                    }
                    token += current_line;
                    current_line.clear();
                }
                for(const auto& c : item.comments())
                {
                    token += '#';
                    token += c;
                    token += '\n';
                }
                token += toml::visit(*this, item);
                if(token.back() == '\n') {token.pop_back();}
                token += ",\n";
                continue;
            }
            std::string next_elem;
            next_elem += toml::visit(*this, item);

            // comma before newline.
            if(next_elem.back() == '\n') {next_elem.pop_back();}

            // if current line does not exceeds the width limit, continue.
            if(current_line.size() + next_elem.size() + 1 < this->width_)
            {
                current_line += next_elem;
                current_line += ',';
            }
            else if(current_line.empty())
            {
                // if current line was empty, force put the next_elem because
                // next_elem is not splittable
                token += next_elem;
                token += ",\n";
                // current_line is kept empty
            }
            else // reset current_line
            {
                assert(current_line.back() == ',');
                token += current_line;
                token += '\n';
                current_line = next_elem;
                current_line += ',';
            }
        }
        if(!current_line.empty())
        {
            if(current_line.back() != '\n') {current_line += '\n';}
            token += current_line;
        }
        token += "]\n";
        return token;
    }

    // templatize for any table-like container
    std::string operator()(const table_type& v) const
    {
        // if an element has a comment, then it can't be inlined.
        // table = {# how can we write a comment for this? key = "value"}
        if(this->can_be_inlined_ && !(this->has_comment_inside(v)))
        {
            std::string token;
            if(!this->keys_.empty())
            {
                token += format_key(this->keys_.back());
                token += " = ";
            }
            token += this->make_inline_table(v);
            if(token.size() < this->width_ &&
               token.end() == std::find(token.begin(), token.end(), '\n'))
            {
                return token;
            }
        }

        std::string token;
        if(!keys_.empty())
        {
            token += '[';
            token += format_keys(keys_);
            token += "]\n";
        }
        token += this->make_multiline_table(v);
        return token;
    }

  private:

    std::string escape_basic_string(const std::string& s) const
    {
        //XXX assuming `s` is a valid utf-8 sequence.
        std::string retval;
        for(const char c : s)
        {
            switch(c)
            {
                case '\\': {retval += "\\\\"; break;}
                case '\"': {retval += "\\\""; break;}
                case '\b': {retval += "\\b";  break;}
                case '\t': {retval += "\\t";  break;}
                case '\f': {retval += "\\f";  break;}
                case '\n': {retval += "\\n";  break;}
                case '\r': {retval += "\\r";  break;}
                default  : {retval += c;      break;}
            }
        }
        return retval;
    }

    std::string escape_ml_basic_string(const std::string& s) const
    {
        std::string retval;
        for(auto i=s.cbegin(), e=s.cend(); i!=e; ++i)
        {
            switch(*i)
            {
                case '\\': {retval += "\\\\"; break;}
                // One or two consecutive "s are allowed.
                // Later we will check there are no three consecutive "s.
                //   case '\"': {retval += "\\\""; break;}
                case '\b': {retval += "\\b";  break;}
                case '\t': {retval += "\\t";  break;}
                case '\f': {retval += "\\f";  break;}
                case '\n': {retval += "\n";   break;}
                case '\r':
                {
                    if(std::next(i) != e && *std::next(i) == '\n')
                    {
                        retval += "\r\n";
                        ++i;
                    }
                    else
                    {
                        retval += "\\r";
                    }
                    break;
                }
                default: {retval += *i; break;}
            }
        }
        // Only 1 or 2 consecutive `"`s are allowed in multiline basic string.
        // 3 consecutive `"`s are considered as a closing delimiter.
        // We need to check if there are 3 or more consecutive `"`s and insert
        // backslash to break them down into several short `"`s like the `str6`
        // in the following example.
        // ```toml
        // str4 = """Here are two quotation marks: "". Simple enough."""
        // # str5 = """Here are three quotation marks: """."""  # INVALID
        // str5 = """Here are three quotation marks: ""\"."""
        // str6 = """Here are fifteen quotation marks: ""\"""\"""\"""\"""\"."""
        // ```
        auto found_3_quotes = retval.find("\"\"\"");
        while(found_3_quotes != std::string::npos)
        {
            retval.replace(found_3_quotes, 3, "\"\"\\\"");
            found_3_quotes = retval.find("\"\"\"");
        }
        return retval;
    }

    // if an element of a table or an array has a comment, it cannot be inlined.
    bool has_comment_inside(const array_type& a) const noexcept
    {
        // if no_comment is set, comments would not be written.
        if(this->no_comment_) {return false;}

        for(const auto& v : a)
        {
            if(!v.comments().empty()) {return true;}
        }
        return false;
    }
    bool has_comment_inside(const table_type& t) const noexcept
    {
        // if no_comment is set, comments would not be written.
        if(this->no_comment_) {return false;}

        for(const auto& kv : t)
        {
            if(!kv.second.comments().empty()) {return true;}
        }
        return false;
    }

    std::string make_inline_array(const array_type& v) const
    {
        assert(!has_comment_inside(v));
        std::string token;
        token += '[';
        bool is_first = true;
        for(const auto& item : v)
        {
            if(is_first) {is_first = false;} else {token += ',';}
            token += visit(serializer((std::numeric_limits<std::size_t>::max)(),
                                      this->float_prec_, true), item);
        }
        token += ']';
        return token;
    }

    std::string make_inline_table(const table_type& v) const
    {
        assert(!has_comment_inside(v));
        assert(this->can_be_inlined_);
        std::string token;
        token += '{';
        bool is_first = true;
        for(const auto& kv : v)
        {
            // in inline tables, trailing comma is not allowed (toml-lang #569).
            if(is_first) {is_first = false;} else {token += ',';}
            token += format_key(kv.first);
            token += '=';
            token += visit(serializer((std::numeric_limits<std::size_t>::max)(),
                                      this->float_prec_, true), kv.second);
        }
        token += '}';
        return token;
    }

    std::string make_multiline_table(const table_type& v) const
    {
        std::string token;

        // print non-table stuff first. because after printing [foo.bar], the
        // remaining non-table values will be assigned into [foo.bar], not [foo]
        for(const auto& kv : v)
        {
            if(kv.second.is_table() || is_array_of_tables(kv.second))
            {
                continue;
            }

            if(!kv.second.comments().empty() && !no_comment_)
            {
                for(const auto& c : kv.second.comments())
                {
                    token += '#';
                    token += c;
                    token += '\n';
                }
            }
            const auto key_and_sep    = format_key(kv.first) + " = ";
            const auto residual_width = (this->width_ > key_and_sep.size()) ?
                                        this->width_ - key_and_sep.size() : 0;
            token += key_and_sep;
            token += visit(serializer(residual_width, this->float_prec_, true),
                           kv.second);
            if(token.back() != '\n')
            {
                token += '\n';
            }
        }

        // normal tables / array of tables

        // after multiline table appeared, the other tables cannot be inline
        // because the table would be assigned into the table.
        // [foo]
        // ...
        // bar = {...} # <- bar will be a member of [foo].
        bool multiline_table_printed = false;
        for(const auto& kv : v)
        {
            if(!kv.second.is_table() && !is_array_of_tables(kv.second))
            {
                continue; // other stuff are already serialized. skip them.
            }

            std::vector<toml::key> ks(this->keys_);
            ks.push_back(kv.first);

            auto tmp = visit(serializer(this->width_, this->float_prec_,
                !multiline_table_printed, this->no_comment_, ks),
                kv.second);

            if((!multiline_table_printed) &&
               std::find(tmp.cbegin(), tmp.cend(), '\n') != tmp.cend())
            {
                multiline_table_printed = true;
            }
            else
            {
                // still inline tables only.
                tmp += '\n';
            }

            if(!kv.second.comments().empty() && !no_comment_)
            {
                for(const auto& c : kv.second.comments())
                {
                    token += '#';
                    token += c;
                    token += '\n';
                }
            }
            token += tmp;
        }
        return token;
    }

    bool is_array_of_tables(const value_type& v) const
    {
        if(!v.is_array()) {return false;}
        const auto& a = v.as_array();
        return !a.empty() && a.front().is_table();
    }

  private:

    bool        can_be_inlined_;
    bool        no_comment_;
    int         float_prec_;
    std::size_t width_;
    std::vector<toml::key> keys_;
};

template<typename C,
         template<typename ...> class M, template<typename ...> class V>
std::string
format(const basic_value<C, M, V>& v, std::size_t w = 80u,
       int fprec = std::numeric_limits<toml::floating>::max_digits10,
       bool no_comment = false, bool force_inline = false)
{
    using value_type = basic_value<C, M, V>;
    // if value is a table, it is considered to be a root object.
    // the root object can't be an inline table.
    if(v.is_table())
    {
        std::ostringstream oss;
        if(!v.comments().empty())
        {
            oss << v.comments();
            oss << '\n'; // to split the file comment from the first element
        }
        const auto serialized = visit(serializer<value_type>(w, fprec, no_comment, false), v);
        oss << serialized;
        return oss.str();
    }
    return visit(serializer<value_type>(w, fprec, force_inline), v);
}

namespace detail
{
template<typename charT, typename traits>
int comment_index(std::basic_ostream<charT, traits>&)
{
    static const int index = std::ios_base::xalloc();
    return index;
}
} // detail

template<typename charT, typename traits>
std::basic_ostream<charT, traits>&
nocomment(std::basic_ostream<charT, traits>& os)
{
    // by default, it is zero. and by defalut, it shows comments.
    os.iword(detail::comment_index(os)) = 1;
    return os;
}

template<typename charT, typename traits>
std::basic_ostream<charT, traits>&
showcomment(std::basic_ostream<charT, traits>& os)
{
    // by default, it is zero. and by defalut, it shows comments.
    os.iword(detail::comment_index(os)) = 0;
    return os;
}

template<typename charT, typename traits, typename C,
         template<typename ...> class M, template<typename ...> class V>
std::basic_ostream<charT, traits>&
operator<<(std::basic_ostream<charT, traits>& os, const basic_value<C, M, V>& v)
{
    using value_type = basic_value<C, M, V>;

    // get status of std::setw().
    const auto w     = static_cast<std::size_t>(os.width());
    const int  fprec = static_cast<int>(os.precision());
    os.width(0);

    // by defualt, iword is initialized byl 0. And by default, toml11 outputs
    // comments. So `0` means showcomment. 1 means nocommnet.
    const bool no_comment = (1 == os.iword(detail::comment_index(os)));

    if(!no_comment && v.is_table() && !v.comments().empty())
    {
        os << v.comments();
        os << '\n'; // to split the file comment from the first element
    }
    // the root object can't be an inline table. so pass `false`.
    const auto serialized = visit(serializer<value_type>(w, fprec, no_comment, false), v);
    os << serialized;

    // if v is a non-table value, and has only one comment, then
    // put a comment just after a value. in the following way.
    //
    // ```toml
    // key = "value" # comment.
    // ```
    //
    // Since the top-level toml object is a table, one who want to put a
    // non-table toml value must use this in a following way.
    //
    // ```cpp
    // toml::value v;
    // std::cout << "user-defined-key = " << v << std::endl;
    // ```
    //
    // In this case, it is impossible to put comments before key-value pair.
    // The only way to preserve comments is to put all of them after a value.
    if(!no_comment && !v.is_table() && !v.comments().empty())
    {
        os << " #";
        for(const auto& c : v.comments()) {os << c;}
    }
    return os;
}

} // toml
#endif// TOML11_SERIALIZER_HPP

```

`Dependencies/toml11/toml/source_location.hpp`:

```hpp
//     Copyright Toru Niina 2019.
// Distributed under the MIT License.
#ifndef TOML11_SOURCE_LOCATION_HPP
#define TOML11_SOURCE_LOCATION_HPP
#include <cstdint>

#include "region.hpp"

namespace toml
{

// A struct to contain location in a toml file.
// The interface imitates std::experimental::source_location,
// but not completely the same.
//
// It would be constructed by toml::value. It can be used to generate
// user-defined error messages.
//
// - std::uint_least32_t line() const noexcept
//   - returns the line number where the region is on.
// - std::uint_least32_t column() const noexcept
//   - returns the column number where the region starts.
// - std::uint_least32_t region() const noexcept
//   - returns the size of the region.
//
// +-- line()       +-- region of interest (region() == 9)
// v            .---+---.
// 12 | value = "foo bar"
//              ^
//              +-- column()
//
// - std::string const& file_name() const noexcept;
//   - name of the file.
// - std::string const& line_str() const noexcept;
//   - the whole line that contains the region of interest.
//
struct source_location
{
  public:

    source_location()
        : line_num_(1), column_num_(1), region_size_(1),
          file_name_("unknown file"), line_str_("")
    {}

    explicit source_location(const detail::region_base* reg)
        : line_num_(1), column_num_(1), region_size_(1),
          file_name_("unknown file"), line_str_("")
    {
        if(reg)
        {
            if(reg->line_num() != detail::region_base().line_num())
            {
                line_num_ = static_cast<std::uint_least32_t>(
                        std::stoul(reg->line_num()));
            }
            column_num_  = static_cast<std::uint_least32_t>(reg->before() + 1);
            region_size_ = static_cast<std::uint_least32_t>(reg->size());
            file_name_   = reg->name();
            line_str_    = reg->line();
        }
    }

    explicit source_location(const detail::region& reg)
        : line_num_(static_cast<std::uint_least32_t>(std::stoul(reg.line_num()))),
          column_num_(static_cast<std::uint_least32_t>(reg.before() + 1)),
          region_size_(static_cast<std::uint_least32_t>(reg.size())),
          file_name_(reg.name()),
          line_str_ (reg.line())
    {}
    explicit source_location(const detail::location& loc)
        : line_num_(static_cast<std::uint_least32_t>(std::stoul(loc.line_num()))),
          column_num_(static_cast<std::uint_least32_t>(loc.before() + 1)),
          region_size_(static_cast<std::uint_least32_t>(loc.size())),
          file_name_(loc.name()),
          line_str_ (loc.line())
    {}

    ~source_location() = default;
    source_location(source_location const&) = default;
    source_location(source_location &&)     = default;
    source_location& operator=(source_location const&) = default;
    source_location& operator=(source_location &&)     = default;

    std::uint_least32_t line()      const noexcept {return line_num_;}
    std::uint_least32_t column()    const noexcept {return column_num_;}
    std::uint_least32_t region()    const noexcept {return region_size_;}

    std::string const&  file_name() const noexcept {return file_name_;}
    std::string const&  line_str()  const noexcept {return line_str_;}

  private:

    std::uint_least32_t line_num_;
    std::uint_least32_t column_num_;
    std::uint_least32_t region_size_;
    std::string         file_name_;
    std::string         line_str_;
};

namespace detail
{

// internal error message generation.
inline std::string format_underline(const std::string& message,
        const std::vector<std::pair<source_location, std::string>>& loc_com,
        const std::vector<std::string>& helps = {},
        const bool colorize = TOML11_ERROR_MESSAGE_COLORIZED)
{
    std::size_t line_num_width = 0;
    for(const auto& lc : loc_com)
    {
        std::uint_least32_t line = lc.first.line();
        std::size_t        digit = 0;
        while(line != 0)
        {
            line  /= 10;
            digit +=  1;
        }
        line_num_width = (std::max)(line_num_width, digit);
    }
    // 1 is the minimum width
    line_num_width = std::max<std::size_t>(line_num_width, 1);

    std::ostringstream retval;

    if(colorize)
    {
        retval << color::colorize; // turn on ANSI color
    }

    // XXX
    // Here, before `colorize` support, it does not output `[error]` prefix
    // automatically. So some user may output it manually and this change may
    // duplicate the prefix. To avoid it, check the first 7 characters and
    // if it is "[error]", it removes that part from the message shown.
    if(message.size() > 7 && message.substr(0, 7) == "[error]")
    {
        retval << color::bold << color::red << "[error]" << color::reset
               << color::bold << message.substr(7) << color::reset << '\n';
    }
    else
    {
        retval << color::bold << color::red << "[error] " << color::reset
               << color::bold << message << color::reset << '\n';
    }

    const auto format_one_location = [line_num_width]
        (std::ostringstream& oss,
         const source_location& loc, const std::string& comment) -> void
        {
            oss << ' ' << color::bold << color::blue
                << std::setw(static_cast<int>(line_num_width))
                << std::right << loc.line() << " | "  << color::reset
                << loc.line_str() << '\n';

            oss << make_string(line_num_width + 1, ' ')
                << color::bold << color::blue << " | " << color::reset
                << make_string(loc.column()-1 /*1-origin*/, ' ');

            if(loc.region() == 1)
            {
                // invalid
                // ^------
                oss << color::bold << color::red << "^---" << color::reset;
            }
            else
            {
                // invalid
                // ~~~~~~~
                const auto underline_len = (std::min)(
                    static_cast<std::size_t>(loc.region()), loc.line_str().size());
                oss << color::bold << color::red
                    << make_string(underline_len, '~') << color::reset;
            }
            oss << ' ';
            oss << comment;
            return;
        };

    assert(!loc_com.empty());

    // --> example.toml
    //   |
    retval << color::bold << color::blue << " --> " << color::reset
           << loc_com.front().first.file_name() << '\n';
    retval << make_string(line_num_width + 1, ' ')
           << color::bold << color::blue << " |\n"  << color::reset;
    // 1 | key value
    //   |    ^--- missing =
    format_one_location(retval, loc_com.front().first, loc_com.front().second);

    // process the rest of the locations
    for(std::size_t i=1; i<loc_com.size(); ++i)
    {
        const auto& prev = loc_com.at(i-1);
        const auto& curr = loc_com.at(i);

        retval << '\n';
        // if the filenames are the same, print "..."
        if(prev.first.file_name() == curr.first.file_name())
        {
            retval << color::bold << color::blue << " ...\n" << color::reset;
        }
        else // if filename differs, print " --> filename.toml" again
        {
            retval << color::bold << color::blue << " --> " << color::reset
                   << curr.first.file_name() << '\n';
            retval << make_string(line_num_width + 1, ' ')
                   << color::bold << color::blue << " |\n"  << color::reset;
        }

        format_one_location(retval, curr.first, curr.second);
    }

    if(!helps.empty())
    {
        retval << '\n';
        retval << make_string(line_num_width + 1, ' ');
        retval << color::bold << color::blue << " |" << color::reset;
        for(const auto& help : helps)
        {
            retval << color::bold << "\nHint: " << color::reset;
            retval << help;
        }
    }
    return retval.str();
}

} // detail
} // toml
#endif// TOML11_SOURCE_LOCATION_HPP

```

`Dependencies/toml11/toml/storage.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_STORAGE_HPP
#define TOML11_STORAGE_HPP
#include "utility.hpp"

namespace toml
{
namespace detail
{

// this contains pointer and deep-copy the content if copied.
// to avoid recursive pointer.
template<typename T>
struct storage
{
    using value_type = T;

    explicit storage(value_type const& v): ptr(toml::make_unique<T>(v)) {}
    explicit storage(value_type&&      v): ptr(toml::make_unique<T>(std::move(v))) {}
    ~storage() = default;
    storage(const storage& rhs): ptr(toml::make_unique<T>(*rhs.ptr)) {}
    storage& operator=(const storage& rhs)
    {
        this->ptr = toml::make_unique<T>(*rhs.ptr);
        return *this;
    }
    storage(storage&&) = default;
    storage& operator=(storage&&) = default;

    bool is_ok() const noexcept {return static_cast<bool>(ptr);}

    value_type&       value() &      noexcept {return *ptr;}
    value_type const& value() const& noexcept {return *ptr;}
    value_type&&      value() &&     noexcept {return std::move(*ptr);}

  private:
    std::unique_ptr<value_type> ptr;
};

} // detail
} // toml
#endif// TOML11_STORAGE_HPP

```

`Dependencies/toml11/toml/string.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_STRING_HPP
#define TOML11_STRING_HPP
#include <cstdint>

#include <algorithm>
#include <string>

#if __cplusplus >= 201703L
#if __has_include(<string_view>)
#include <string_view>
#endif
#endif

namespace toml
{

enum class string_t : std::uint8_t
{
    basic   = 0,
    literal = 1,
};

struct string
{
    string()  = default;
    ~string() = default;
    string(const string& s) = default;
    string(string&& s)      = default;
    string& operator=(const string& s) = default;
    string& operator=(string&& s)      = default;

    string(const std::string& s): kind(string_t::basic), str(s){}
    string(const std::string& s, string_t k):   kind(k), str(s){}
    string(const char* s):        kind(string_t::basic), str(s){}
    string(const char* s,        string_t k):   kind(k), str(s){}

    string(std::string&& s): kind(string_t::basic), str(std::move(s)){}
    string(std::string&& s, string_t k):   kind(k), str(std::move(s)){}

    string& operator=(const std::string& s)
    {kind = string_t::basic; str = s; return *this;}
    string& operator=(std::string&& s)
    {kind = string_t::basic; str = std::move(s); return *this;}

    operator std::string&       () &      noexcept {return str;}
    operator std::string const& () const& noexcept {return str;}
    operator std::string&&      () &&     noexcept {return std::move(str);}

    string& operator+=(const char*        rhs) {str += rhs; return *this;}
    string& operator+=(const char         rhs) {str += rhs; return *this;}
    string& operator+=(const std::string& rhs) {str += rhs; return *this;}
    string& operator+=(const string&      rhs) {str += rhs.str; return *this;}

#if __cplusplus >= 201703L
    explicit string(std::string_view s): kind(string_t::basic), str(s){}
    string(std::string_view s, string_t k): kind(k), str(s){}

    string& operator=(std::string_view s)
    {kind = string_t::basic; str = s; return *this;}

    explicit operator std::string_view() const noexcept
    {return std::string_view(str);}

    string& operator+=(const std::string_view& rhs) {str += rhs; return *this;}
#endif

    string_t    kind;
    std::string str;
};

inline bool operator==(const string& lhs, const string& rhs)
{
    return lhs.kind == rhs.kind && lhs.str == rhs.str;
}
inline bool operator!=(const string& lhs, const string& rhs)
{
    return !(lhs == rhs);
}
inline bool operator<(const string& lhs, const string& rhs)
{
    return (lhs.kind == rhs.kind) ? (lhs.str < rhs.str) : (lhs.kind < rhs.kind);
}
inline bool operator>(const string& lhs, const string& rhs)
{
    return rhs < lhs;
}
inline bool operator<=(const string& lhs, const string& rhs)
{
    return !(rhs < lhs);
}
inline bool operator>=(const string& lhs, const string& rhs)
{
    return !(lhs < rhs);
}

inline bool
operator==(const string& lhs, const std::string& rhs) {return lhs.str == rhs;}
inline bool
operator!=(const string& lhs, const std::string& rhs) {return lhs.str != rhs;}
inline bool
operator< (const string& lhs, const std::string& rhs) {return lhs.str <  rhs;}
inline bool
operator> (const string& lhs, const std::string& rhs) {return lhs.str >  rhs;}
inline bool
operator<=(const string& lhs, const std::string& rhs) {return lhs.str <= rhs;}
inline bool
operator>=(const string& lhs, const std::string& rhs) {return lhs.str >= rhs;}

inline bool
operator==(const std::string& lhs, const string& rhs) {return lhs == rhs.str;}
inline bool
operator!=(const std::string& lhs, const string& rhs) {return lhs != rhs.str;}
inline bool
operator< (const std::string& lhs, const string& rhs) {return lhs <  rhs.str;}
inline bool
operator> (const std::string& lhs, const string& rhs) {return lhs >  rhs.str;}
inline bool
operator<=(const std::string& lhs, const string& rhs) {return lhs <= rhs.str;}
inline bool
operator>=(const std::string& lhs, const string& rhs) {return lhs >= rhs.str;}

inline bool
operator==(const string& lhs, const char* rhs) {return lhs.str == std::string(rhs);}
inline bool
operator!=(const string& lhs, const char* rhs) {return lhs.str != std::string(rhs);}
inline bool
operator< (const string& lhs, const char* rhs) {return lhs.str <  std::string(rhs);}
inline bool
operator> (const string& lhs, const char* rhs) {return lhs.str >  std::string(rhs);}
inline bool
operator<=(const string& lhs, const char* rhs) {return lhs.str <= std::string(rhs);}
inline bool
operator>=(const string& lhs, const char* rhs) {return lhs.str >= std::string(rhs);}

inline bool
operator==(const char* lhs, const string& rhs) {return std::string(lhs) == rhs.str;}
inline bool
operator!=(const char* lhs, const string& rhs) {return std::string(lhs) != rhs.str;}
inline bool
operator< (const char* lhs, const string& rhs) {return std::string(lhs) <  rhs.str;}
inline bool
operator> (const char* lhs, const string& rhs) {return std::string(lhs) >  rhs.str;}
inline bool
operator<=(const char* lhs, const string& rhs) {return std::string(lhs) <= rhs.str;}
inline bool
operator>=(const char* lhs, const string& rhs) {return std::string(lhs) >= rhs.str;}

template<typename charT, typename traits>
std::basic_ostream<charT, traits>&
operator<<(std::basic_ostream<charT, traits>& os, const string& s)
{
    if(s.kind == string_t::basic)
    {
        if(std::find(s.str.cbegin(), s.str.cend(), '\n') != s.str.cend())
        {
            // it contains newline. make it multiline string.
            os << "\"\"\"\n";
            for(auto i=s.str.cbegin(), e=s.str.cend(); i!=e; ++i)
            {
                switch(*i)
                {
                    case '\\': {os << "\\\\"; break;}
                    case '\"': {os << "\\\""; break;}
                    case '\b': {os << "\\b";  break;}
                    case '\t': {os << "\\t";  break;}
                    case '\f': {os << "\\f";  break;}
                    case '\n': {os << '\n';   break;}
                    case '\r':
                    {
                        // since it is a multiline string,
                        // CRLF is not needed to be escaped.
                        if(std::next(i) != e && *std::next(i) == '\n')
                        {
                            os << "\r\n";
                            ++i;
                        }
                        else
                        {
                            os << "\\r";
                        }
                        break;
                    }
                    default: {os << *i; break;}
                }
            }
            os << "\\\n\"\"\"";
            return os;
        }
        // no newline. make it inline.
        os << "\"";
        for(const auto c : s.str)
        {
            switch(c)
            {
                case '\\': {os << "\\\\"; break;}
                case '\"': {os << "\\\""; break;}
                case '\b': {os << "\\b";  break;}
                case '\t': {os << "\\t";  break;}
                case '\f': {os << "\\f";  break;}
                case '\n': {os << "\\n";  break;}
                case '\r': {os << "\\r";  break;}
                default  : {os << c;      break;}
            }
        }
        os << "\"";
        return os;
    }
    // the string `s` is literal-string.
    if(std::find(s.str.cbegin(), s.str.cend(), '\n') != s.str.cend() ||
       std::find(s.str.cbegin(), s.str.cend(), '\'') != s.str.cend() )
    {
        // contains newline or single quote. make it multiline.
        os << "'''\n" << s.str << "'''";
        return os;
    }
    // normal literal string
    os << '\'' << s.str << '\'';
    return os;
}

} // toml
#endif// TOML11_STRING_H

```

`Dependencies/toml11/toml/traits.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_TRAITS_HPP
#define TOML11_TRAITS_HPP
#include <chrono>
#include <forward_list>
#include <string>
#include <tuple>
#include <type_traits>
#include <utility>

#if __cplusplus >= 201703L
#if __has_include(<string_view>)
#include <string_view>
#endif // has_include(<string_view>)
#endif // cplusplus   >= C++17

namespace toml
{
template<typename C, template<typename ...> class T, template<typename ...> class A>
class basic_value;

namespace detail
{
// ---------------------------------------------------------------------------
// check whether type T is a kind of container/map class

struct has_iterator_impl
{
    template<typename T> static std::true_type  check(typename T::iterator*);
    template<typename T> static std::false_type check(...);
};
struct has_value_type_impl
{
    template<typename T> static std::true_type  check(typename T::value_type*);
    template<typename T> static std::false_type check(...);
};
struct has_key_type_impl
{
    template<typename T> static std::true_type  check(typename T::key_type*);
    template<typename T> static std::false_type check(...);
};
struct has_mapped_type_impl
{
    template<typename T> static std::true_type  check(typename T::mapped_type*);
    template<typename T> static std::false_type check(...);
};
struct has_reserve_method_impl
{
    template<typename T> static std::false_type check(...);
    template<typename T> static std::true_type  check(
        decltype(std::declval<T>().reserve(std::declval<std::size_t>()))*);
};
struct has_push_back_method_impl
{
    template<typename T> static std::false_type check(...);
    template<typename T> static std::true_type  check(
        decltype(std::declval<T>().push_back(std::declval<typename T::value_type>()))*);
};
struct is_comparable_impl
{
    template<typename T> static std::false_type check(...);
    template<typename T> static std::true_type  check(
        decltype(std::declval<T>() < std::declval<T>())*);
};

struct has_from_toml_method_impl
{
    template<typename T, typename C,
             template<typename ...> class Tb, template<typename ...> class A>
    static std::true_type  check(
        decltype(std::declval<T>().from_toml(
                std::declval<::toml::basic_value<C, Tb, A>>()))*);

    template<typename T, typename C,
             template<typename ...> class Tb, template<typename ...> class A>
    static std::false_type check(...);
};
struct has_into_toml_method_impl
{
    template<typename T>
    static std::true_type  check(decltype(std::declval<T>().into_toml())*);
    template<typename T>
    static std::false_type check(...);
};

/// Intel C++ compiler can not use decltype in parent class declaration, here
/// is a hack to work around it. https://stackoverflow.com/a/23953090/4692076
#ifdef __INTEL_COMPILER
#define decltype(...) std::enable_if<true, decltype(__VA_ARGS__)>::type
#endif

template<typename T>
struct has_iterator    : decltype(has_iterator_impl::check<T>(nullptr)){};
template<typename T>
struct has_value_type  : decltype(has_value_type_impl::check<T>(nullptr)){};
template<typename T>
struct has_key_type    : decltype(has_key_type_impl::check<T>(nullptr)){};
template<typename T>
struct has_mapped_type : decltype(has_mapped_type_impl::check<T>(nullptr)){};
template<typename T>
struct has_reserve_method : decltype(has_reserve_method_impl::check<T>(nullptr)){};
template<typename T>
struct has_push_back_method : decltype(has_push_back_method_impl::check<T>(nullptr)){};
template<typename T>
struct is_comparable : decltype(is_comparable_impl::check<T>(nullptr)){};

template<typename T, typename C,
         template<typename ...> class Tb, template<typename ...> class A>
struct has_from_toml_method
: decltype(has_from_toml_method_impl::check<T, C, Tb, A>(nullptr)){};

template<typename T>
struct has_into_toml_method
: decltype(has_into_toml_method_impl::check<T>(nullptr)){};

#ifdef __INTEL_COMPILER
#undef decltype
#endif

// ---------------------------------------------------------------------------
// C++17 and/or/not

#if __cplusplus >= 201703L

using std::conjunction;
using std::disjunction;
using std::negation;

#else

template<typename ...> struct conjunction : std::true_type{};
template<typename T>   struct conjunction<T> : T{};
template<typename T, typename ... Ts>
struct conjunction<T, Ts...> :
    std::conditional<static_cast<bool>(T::value), conjunction<Ts...>, T>::type
{};

template<typename ...> struct disjunction : std::false_type{};
template<typename T>   struct disjunction<T> : T {};
template<typename T, typename ... Ts>
struct disjunction<T, Ts...> :
    std::conditional<static_cast<bool>(T::value), T, disjunction<Ts...>>::type
{};

template<typename T>
struct negation : std::integral_constant<bool, !static_cast<bool>(T::value)>{};

#endif

// ---------------------------------------------------------------------------
// type checkers

template<typename T> struct is_std_pair : std::false_type{};
template<typename T1, typename T2>
struct is_std_pair<std::pair<T1, T2>> : std::true_type{};

template<typename T> struct is_std_tuple : std::false_type{};
template<typename ... Ts>
struct is_std_tuple<std::tuple<Ts...>> : std::true_type{};

template<typename T> struct is_std_forward_list : std::false_type{};
template<typename T>
struct is_std_forward_list<std::forward_list<T>> : std::true_type{};

template<typename T> struct is_chrono_duration: std::false_type{};
template<typename Rep, typename Period>
struct is_chrono_duration<std::chrono::duration<Rep, Period>>: std::true_type{};

template<typename T>
struct is_map : conjunction< // map satisfies all the following conditions
    has_iterator<T>,         // has T::iterator
    has_value_type<T>,       // has T::value_type
    has_key_type<T>,         // has T::key_type
    has_mapped_type<T>       // has T::mapped_type
    >{};
template<typename T> struct is_map<T&>                : is_map<T>{};
template<typename T> struct is_map<T const&>          : is_map<T>{};
template<typename T> struct is_map<T volatile&>       : is_map<T>{};
template<typename T> struct is_map<T const volatile&> : is_map<T>{};

template<typename T>
struct is_container : conjunction<
    negation<is_map<T>>,                         // not a map
    negation<std::is_same<T, std::string>>,      // not a std::string
#if __cplusplus >= 201703L
    negation<std::is_same<T, std::string_view>>, // not a std::string_view
#endif
    has_iterator<T>,                             // has T::iterator
    has_value_type<T>                            // has T::value_type
    >{};
template<typename T> struct is_container<T&>                : is_container<T>{};
template<typename T> struct is_container<T const&>          : is_container<T>{};
template<typename T> struct is_container<T volatile&>       : is_container<T>{};
template<typename T> struct is_container<T const volatile&> : is_container<T>{};

template<typename T>
struct is_basic_value: std::false_type{};
template<typename T> struct is_basic_value<T&>                : is_basic_value<T>{};
template<typename T> struct is_basic_value<T const&>          : is_basic_value<T>{};
template<typename T> struct is_basic_value<T volatile&>       : is_basic_value<T>{};
template<typename T> struct is_basic_value<T const volatile&> : is_basic_value<T>{};
template<typename C, template<typename ...> class M, template<typename ...> class V>
struct is_basic_value<::toml::basic_value<C, M, V>>: std::true_type{};

// ---------------------------------------------------------------------------
// C++14 index_sequence

#if __cplusplus >= 201402L

using std::index_sequence;
using std::make_index_sequence;

#else

template<std::size_t ... Ns> struct index_sequence{};

template<typename IS, std::size_t N> struct push_back_index_sequence{};
template<std::size_t N, std::size_t ... Ns>
struct push_back_index_sequence<index_sequence<Ns...>, N>
{
    typedef index_sequence<Ns..., N> type;
};

template<std::size_t N>
struct index_sequence_maker
{
    typedef typename push_back_index_sequence<
        typename index_sequence_maker<N-1>::type, N>::type type;
};
template<>
struct index_sequence_maker<0>
{
    typedef index_sequence<0> type;
};
template<std::size_t N>
using make_index_sequence = typename index_sequence_maker<N-1>::type;

#endif // __cplusplus >= 2014

// ---------------------------------------------------------------------------
// C++14 enable_if_t

#if __cplusplus >= 201402L

using std::enable_if_t;

#else

template<bool B, typename T>
using enable_if_t = typename std::enable_if<B, T>::type;

#endif // __cplusplus >= 2014

// ---------------------------------------------------------------------------
// return_type_of_t

#if __cplusplus >= 201703L

template<typename F, typename ... Args>
using return_type_of_t = std::invoke_result_t<F, Args...>;

#else
// result_of is deprecated after C++17
template<typename F, typename ... Args>
using return_type_of_t = typename std::result_of<F(Args...)>::type;

#endif

// ---------------------------------------------------------------------------
// is_string_literal
//
// to use this, pass `typename remove_reference<T>::type` to T.

template<typename T>
struct is_string_literal:
disjunction<
    std::is_same<const char*, T>,
    conjunction<
        std::is_array<T>,
        std::is_same<const char, typename std::remove_extent<T>::type>
        >
    >{};

// ---------------------------------------------------------------------------
// C++20 remove_cvref_t

template<typename T>
struct remove_cvref
{
    using type = typename std::remove_cv<
        typename std::remove_reference<T>::type>::type;
};

template<typename T>
using remove_cvref_t = typename remove_cvref<T>::type;

}// detail
}//toml
#endif // TOML_TRAITS

```

`Dependencies/toml11/toml/types.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_TYPES_HPP
#define TOML11_TYPES_HPP
#include <unordered_map>
#include <vector>

#include "comments.hpp"
#include "datetime.hpp"
#include "string.hpp"
#include "traits.hpp"

namespace toml
{

template<typename Comment, // discard/preserve_comment
         template<typename ...> class Table, // map-like class
         template<typename ...> class Array> // vector-like class
class basic_value;

using character = char;
using key = std::string;

using boolean        = bool;
using integer        = std::int64_t;
using floating       = double; // "float" is a keyward, cannot use it here.
// the following stuffs are structs defined here, so aliases are not needed.
// - string
// - offset_datetime
// - offset_datetime
// - local_datetime
// - local_date
// - local_time

// default toml::value and default array/table. these are defined after defining
// basic_value itself.
// using value = basic_value<discard_comments, std::unordered_map, std::vector>;
// using array = typename value::array_type;
// using table = typename value::table_type;

enum class value_t : std::uint8_t
{
    empty           =  0,
    boolean         =  1,
    integer         =  2,
    floating        =  3,
    string          =  4,
    offset_datetime =  5,
    local_datetime  =  6,
    local_date      =  7,
    local_time      =  8,
    array           =  9,
    table           = 10,
};

template<typename charT, typename traits>
inline std::basic_ostream<charT, traits>&
operator<<(std::basic_ostream<charT, traits>& os, value_t t)
{
    switch(t)
    {
        case value_t::boolean         : os << "boolean";         return os;
        case value_t::integer         : os << "integer";         return os;
        case value_t::floating        : os << "floating";        return os;
        case value_t::string          : os << "string";          return os;
        case value_t::offset_datetime : os << "offset_datetime"; return os;
        case value_t::local_datetime  : os << "local_datetime";  return os;
        case value_t::local_date      : os << "local_date";      return os;
        case value_t::local_time      : os << "local_time";      return os;
        case value_t::array           : os << "array";           return os;
        case value_t::table           : os << "table";           return os;
        case value_t::empty           : os << "empty";           return os;
        default                       : os << "unknown";         return os;
    }
}

template<typename charT = char,
         typename traits = std::char_traits<charT>,
         typename alloc = std::allocator<charT>>
inline std::basic_string<charT, traits, alloc> stringize(value_t t)
{
    std::basic_ostringstream<charT, traits, alloc> oss;
    oss << t;
    return oss.str();
}

namespace detail
{

// helper to define a type that represents a value_t value.
template<value_t V>
using value_t_constant = std::integral_constant<value_t, V>;

// meta-function that convertes from value_t to the exact toml type that corresponds to.
// It takes toml::basic_value type because array and table types depend on it.
template<value_t t, typename Value> struct enum_to_type                      {using type = void                      ;};
template<typename Value> struct enum_to_type<value_t::empty          , Value>{using type = void                      ;};
template<typename Value> struct enum_to_type<value_t::boolean        , Value>{using type = boolean                   ;};
template<typename Value> struct enum_to_type<value_t::integer        , Value>{using type = integer                   ;};
template<typename Value> struct enum_to_type<value_t::floating       , Value>{using type = floating                  ;};
template<typename Value> struct enum_to_type<value_t::string         , Value>{using type = string                    ;};
template<typename Value> struct enum_to_type<value_t::offset_datetime, Value>{using type = offset_datetime           ;};
template<typename Value> struct enum_to_type<value_t::local_datetime , Value>{using type = local_datetime            ;};
template<typename Value> struct enum_to_type<value_t::local_date     , Value>{using type = local_date                ;};
template<typename Value> struct enum_to_type<value_t::local_time     , Value>{using type = local_time                ;};
template<typename Value> struct enum_to_type<value_t::array          , Value>{using type = typename Value::array_type;};
template<typename Value> struct enum_to_type<value_t::table          , Value>{using type = typename Value::table_type;};

// meta-function that converts from an exact toml type to the enum that corresponds to.
template<typename T, typename Value>
struct type_to_enum : std::conditional<
    std::is_same<T, typename Value::array_type>::value, // if T == array_type,
    value_t_constant<value_t::array>,                   // then value_t::array
    typename std::conditional<                          // else...
        std::is_same<T, typename Value::table_type>::value, // if T == table_type
        value_t_constant<value_t::table>,               // then value_t::table
        value_t_constant<value_t::empty>                // else value_t::empty
        >::type
    >::type {};
template<typename Value> struct type_to_enum<boolean        , Value>: value_t_constant<value_t::boolean        > {};
template<typename Value> struct type_to_enum<integer        , Value>: value_t_constant<value_t::integer        > {};
template<typename Value> struct type_to_enum<floating       , Value>: value_t_constant<value_t::floating       > {};
template<typename Value> struct type_to_enum<string         , Value>: value_t_constant<value_t::string         > {};
template<typename Value> struct type_to_enum<offset_datetime, Value>: value_t_constant<value_t::offset_datetime> {};
template<typename Value> struct type_to_enum<local_datetime , Value>: value_t_constant<value_t::local_datetime > {};
template<typename Value> struct type_to_enum<local_date     , Value>: value_t_constant<value_t::local_date     > {};
template<typename Value> struct type_to_enum<local_time     , Value>: value_t_constant<value_t::local_time     > {};

// meta-function that checks the type T is the same as one of the toml::* types.
template<typename T, typename Value>
struct is_exact_toml_type : disjunction<
    std::is_same<T, boolean        >,
    std::is_same<T, integer        >,
    std::is_same<T, floating       >,
    std::is_same<T, string         >,
    std::is_same<T, offset_datetime>,
    std::is_same<T, local_datetime >,
    std::is_same<T, local_date     >,
    std::is_same<T, local_time     >,
    std::is_same<T, typename Value::array_type>,
    std::is_same<T, typename Value::table_type>
    >{};
template<typename T, typename V> struct is_exact_toml_type<T&, V>               : is_exact_toml_type<T, V>{};
template<typename T, typename V> struct is_exact_toml_type<T const&, V>         : is_exact_toml_type<T, V>{};
template<typename T, typename V> struct is_exact_toml_type<T volatile&, V>      : is_exact_toml_type<T, V>{};
template<typename T, typename V> struct is_exact_toml_type<T const volatile&, V>: is_exact_toml_type<T, V>{};

} // detail
} // toml
#endif// TOML11_TYPES_H

```

`Dependencies/toml11/toml/utility.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_UTILITY_HPP
#define TOML11_UTILITY_HPP
#include <memory>
#include <sstream>
#include <utility>

#include "traits.hpp"

#if __cplusplus >= 201402L
#  define TOML11_MARK_AS_DEPRECATED(msg) [[deprecated(msg)]]
#elif defined(__GNUC__)
#  define TOML11_MARK_AS_DEPRECATED(msg) __attribute__((deprecated(msg)))
#elif defined(_MSC_VER)
#  define TOML11_MARK_AS_DEPRECATED(msg) __declspec(deprecated(msg))
#else
#  define TOML11_MARK_AS_DEPRECATED
#endif

namespace toml
{

#if __cplusplus >= 201402L

using std::make_unique;

#else

template<typename T, typename ... Ts>
inline std::unique_ptr<T> make_unique(Ts&& ... args)
{
    return std::unique_ptr<T>(new T(std::forward<Ts>(args)...));
}

#endif // __cplusplus >= 2014

namespace detail
{
template<typename Container>
void try_reserve_impl(Container& container, std::size_t N, std::true_type)
{
    container.reserve(N);
    return;
}
template<typename Container>
void try_reserve_impl(Container&, std::size_t, std::false_type) noexcept
{
    return;
}
} // detail

template<typename Container>
void try_reserve(Container& container, std::size_t N)
{
    if(N <= container.size()) {return;}
    detail::try_reserve_impl(container, N, detail::has_reserve_method<Container>{});
    return;
}

namespace detail
{
inline std::string concat_to_string_impl(std::ostringstream& oss)
{
    return oss.str();
}
template<typename T, typename ... Ts>
std::string concat_to_string_impl(std::ostringstream& oss, T&& head, Ts&& ... tail)
{
    oss << std::forward<T>(head);
    return concat_to_string_impl(oss, std::forward<Ts>(tail) ... );
}
} // detail

template<typename ... Ts>
std::string concat_to_string(Ts&& ... args)
{
    std::ostringstream oss;
    oss << std::boolalpha << std::fixed;
    return detail::concat_to_string_impl(oss, std::forward<Ts>(args) ...);
}

template<typename T>
T from_string(const std::string& str, T opt)
{
    T v(opt);
    std::istringstream iss(str);
    iss >> v;
    return v;
}

}// toml
#endif // TOML11_UTILITY

```

`Dependencies/toml11/toml/value.hpp`:

```hpp
//     Copyright Toru Niina 2017.
// Distributed under the MIT License.
#ifndef TOML11_VALUE_HPP
#define TOML11_VALUE_HPP
#include <cassert>

#include "comments.hpp"
#include "exception.hpp"
#include "into.hpp"
#include "region.hpp"
#include "source_location.hpp"
#include "storage.hpp"
#include "traits.hpp"
#include "types.hpp"
#include "utility.hpp"

namespace toml
{

namespace detail
{

// to show error messages. not recommended for users.
template<typename Value>
inline region_base const* get_region(const Value& v)
{
    return v.region_info_.get();
}

template<typename Value>
void change_region(Value& v, region reg)
{
    v.region_info_ = std::make_shared<region>(std::move(reg));
    return;
}

template<value_t Expected, typename Value>
[[noreturn]] inline void
throw_bad_cast(const std::string& funcname, value_t actual, const Value& v)
{
    throw type_error(detail::format_underline(
        concat_to_string(funcname, "bad_cast to ", Expected), {
            {v.location(), concat_to_string("the actual type is ", actual)}
        }), v.location());
}

// Throw `out_of_range` from `toml::value::at()` and `toml::find()`
// after generating an error message.
//
// The implementation is a bit complicated and there are many edge-cases.
// If you are not interested in the error message generation, just skip this.
template<typename Value>
[[noreturn]] void
throw_key_not_found_error(const Value& v, const key& ky)
{
    // The top-level table has its region at the first character of the file.
    // That means that, in the case when a key is not found in the top-level
    // table, the error message points to the first character. If the file has
    // its first table at the first line, the error message would be like this.
    // ```console
    // [error] key "a" not found
    //  --> example.toml
    //    |
    //  1 | [table]
    //    | ^------ in this table
    // ```
    // It actually points to the top-level table at the first character,
    // not `[table]`. But it is too confusing. To avoid the confusion, the error
    // message should explicitly say "key not found in the top-level table".
    const auto loc = v.location();
    if(loc.line() == 1 && loc.region() == 1)
    {
        // Here it assumes that top-level table starts at the first character.
        // The region corresponds to the top-level table will be generated at
        // `parse_toml_file` function.
        //     It also assumes that the top-level table size is just one and
        // the line number is `1`. It is always satisfied. And those conditions
        // are satisfied only if the table is the top-level table.
        //
        // 1. one-character dot-key at the first line
        // ```toml
        // a.b = "c"
        // ```
        // toml11 counts whole key as the table key. Here, `a.b` is the region
        // of the table "a". It could be counter intuitive, but it works.
        // The size of the region is 3, not 1. The above example is the shortest
        // dot-key example. The size cannot be 1.
        //
        // 2. one-character inline-table at the first line
        // ```toml
        // a = {b = "c"}
        // ```
        // toml11 consideres the inline table body as the table region. Here,
        // `{b = "c"}` is the region of the table "a". The size of the region
        // is 9, not 1. The shotest inline table still has two characters, `{`
        // and `}`. The size cannot be 1.
        //
        // 3. one-character table declaration at the first line
        // ```toml
        // [a]
        // ```
        // toml11 consideres the whole table key as the table region. Here,
        // `[a]` is the table region. The size is 3, not 1.
        //
        throw std::out_of_range(format_underline(concat_to_string(
            "key \"", ky, "\" not found in the top-level table"), {
                {loc, "the top-level table starts here"}
            }));
    }
    else
    {
        // normal table.
        throw std::out_of_range(format_underline(concat_to_string(
            "key \"", ky, "\" not found"), { {loc, "in this table"} }));
    }
}

// switch by `value_t` at the compile time.
template<value_t T>
struct switch_cast {};
#define TOML11_GENERATE_SWITCH_CASTER(TYPE) \
    template<>                                                           \
    struct switch_cast<value_t::TYPE>                                    \
    {                                                                    \
        template<typename Value>                                         \
        static typename Value::TYPE##_type& invoke(Value& v)             \
        {                                                                \
            return v.as_##TYPE();                                        \
        }                                                                \
        template<typename Value>                                         \
        static typename Value::TYPE##_type const& invoke(const Value& v) \
        {                                                                \
            return v.as_##TYPE();                                        \
        }                                                                \
        template<typename Value>                                         \
        static typename Value::TYPE##_type&& invoke(Value&& v)           \
        {                                                                \
            return std::move(v).as_##TYPE();                             \
        }                                                                \
    };                                                                   \
    /**/
TOML11_GENERATE_SWITCH_CASTER(boolean)
TOML11_GENERATE_SWITCH_CASTER(integer)
TOML11_GENERATE_SWITCH_CASTER(floating)
TOML11_GENERATE_SWITCH_CASTER(string)
TOML11_GENERATE_SWITCH_CASTER(offset_datetime)
TOML11_GENERATE_SWITCH_CASTER(local_datetime)
TOML11_GENERATE_SWITCH_CASTER(local_date)
TOML11_GENERATE_SWITCH_CASTER(local_time)
TOML11_GENERATE_SWITCH_CASTER(array)
TOML11_GENERATE_SWITCH_CASTER(table)

#undef TOML11_GENERATE_SWITCH_CASTER

}// detail

template<typename Comment, // discard/preserve_comment
         template<typename ...> class Table = std::unordered_map,
         template<typename ...> class Array = std::vector>
class basic_value
{
    template<typename T, typename U>
    static void assigner(T& dst, U&& v)
    {
        const auto tmp = ::new(std::addressof(dst)) T(std::forward<U>(v));
        assert(tmp == std::addressof(dst));
        (void)tmp;
    }

    using region_base = detail::region_base;

    template<typename C, template<typename ...> class T,
             template<typename ...> class A>
    friend class basic_value;

  public:

    using comment_type         = Comment;
    using key_type             = ::toml::key;
    using value_type           = basic_value<comment_type, Table, Array>;
    using boolean_type         = ::toml::boolean;
    using integer_type         = ::toml::integer;
    using floating_type        = ::toml::floating;
    using string_type          = ::toml::string;
    using local_time_type      = ::toml::local_time;
    using local_date_type      = ::toml::local_date;
    using local_datetime_type  = ::toml::local_datetime;
    using offset_datetime_type = ::toml::offset_datetime;
    using array_type           = Array<value_type>;
    using table_type           = Table<key_type, value_type>;

  public:

    basic_value() noexcept
        : type_(value_t::empty),
          region_info_(std::make_shared<region_base>(region_base{}))
    {}
    ~basic_value() noexcept {this->cleanup();}

    basic_value(const basic_value& v)
        : type_(v.type()), region_info_(v.region_info_), comments_(v.comments_)
    {
        switch(v.type())
        {
            case value_t::boolean        : assigner(boolean_        , v.boolean_        ); break;
            case value_t::integer        : assigner(integer_        , v.integer_        ); break;
            case value_t::floating       : assigner(floating_       , v.floating_       ); break;
            case value_t::string         : assigner(string_         , v.string_         ); break;
            case value_t::offset_datetime: assigner(offset_datetime_, v.offset_datetime_); break;
            case value_t::local_datetime : assigner(local_datetime_ , v.local_datetime_ ); break;
            case value_t::local_date     : assigner(local_date_     , v.local_date_     ); break;
            case value_t::local_time     : assigner(local_time_     , v.local_time_     ); break;
            case value_t::array          : assigner(array_          , v.array_          ); break;
            case value_t::table          : assigner(table_          , v.table_          ); break;
            default: break;
        }
    }
    basic_value(basic_value&& v)
        : type_(v.type()), region_info_(std::move(v.region_info_)),
          comments_(std::move(v.comments_))
    {
        switch(this->type_) // here this->type_ is already initialized
        {
            case value_t::boolean        : assigner(boolean_        , std::move(v.boolean_        )); break;
            case value_t::integer        : assigner(integer_        , std::move(v.integer_        )); break;
            case value_t::floating       : assigner(floating_       , std::move(v.floating_       )); break;
            case value_t::string         : assigner(string_         , std::move(v.string_         )); break;
            case value_t::offset_datetime: assigner(offset_datetime_, std::move(v.offset_datetime_)); break;
            case value_t::local_datetime : assigner(local_datetime_ , std::move(v.local_datetime_ )); break;
            case value_t::local_date     : assigner(local_date_     , std::move(v.local_date_     )); break;
            case value_t::local_time     : assigner(local_time_     , std::move(v.local_time_     )); break;
            case value_t::array          : assigner(array_          , std::move(v.array_          )); break;
            case value_t::table          : assigner(table_          , std::move(v.table_          )); break;
            default: break;
        }
    }
    basic_value& operator=(const basic_value& v)
    {
        this->cleanup();
        this->region_info_ = v.region_info_;
        this->comments_ = v.comments_;
        this->type_ = v.type();
        switch(this->type_)
        {
            case value_t::boolean        : assigner(boolean_        , v.boolean_        ); break;
            case value_t::integer        : assigner(integer_        , v.integer_        ); break;
            case value_t::floating       : assigner(floating_       , v.floating_       ); break;
            case value_t::string         : assigner(string_         , v.string_         ); break;
            case value_t::offset_datetime: assigner(offset_datetime_, v.offset_datetime_); break;
            case value_t::local_datetime : assigner(local_datetime_ , v.local_datetime_ ); break;
            case value_t::local_date     : assigner(local_date_     , v.local_date_     ); break;
            case value_t::local_time     : assigner(local_time_     , v.local_time_     ); break;
            case value_t::array          : assigner(array_          , v.array_          ); break;
            case value_t::table          : assigner(table_          , v.table_          ); break;
            default: break;
        }
        return *this;
    }
    basic_value& operator=(basic_value&& v)
    {
        this->cleanup();
        this->region_info_ = std::move(v.region_info_);
        this->comments_ = std::move(v.comments_);
        this->type_ = v.type();
        switch(this->type_)
        {
            case value_t::boolean        : assigner(boolean_        , std::move(v.boolean_        )); break;
            case value_t::integer        : assigner(integer_        , std::move(v.integer_        )); break;
            case value_t::floating       : assigner(floating_       , std::move(v.floating_       )); break;
            case value_t::string         : assigner(string_         , std::move(v.string_         )); break;
            case value_t::offset_datetime: assigner(offset_datetime_, std::move(v.offset_datetime_)); break;
            case value_t::local_datetime : assigner(local_datetime_ , std::move(v.local_datetime_ )); break;
            case value_t::local_date     : assigner(local_date_     , std::move(v.local_date_     )); break;
            case value_t::local_time     : assigner(local_time_     , std::move(v.local_time_     )); break;
            case value_t::array          : assigner(array_          , std::move(v.array_          )); break;
            case value_t::table          : assigner(table_          , std::move(v.table_          )); break;
            default: break;
        }
        return *this;
    }

    // overwrite comments ----------------------------------------------------

    basic_value(const basic_value& v, std::vector<std::string> comments)
        : type_(v.type()), region_info_(v.region_info_),
          comments_(std::move(comments))
    {
        switch(v.type())
        {
            case value_t::boolean        : assigner(boolean_        , v.boolean_        ); break;
            case value_t::integer        : assigner(integer_        , v.integer_        ); break;
            case value_t::floating       : assigner(floating_       , v.floating_       ); break;
            case value_t::string         : assigner(string_         , v.string_         ); break;
            case value_t::offset_datetime: assigner(offset_datetime_, v.offset_datetime_); break;
            case value_t::local_datetime : assigner(local_datetime_ , v.local_datetime_ ); break;
            case value_t::local_date     : assigner(local_date_     , v.local_date_     ); break;
            case value_t::local_time     : assigner(local_time_     , v.local_time_     ); break;
            case value_t::array          : assigner(array_          , v.array_          ); break;
            case value_t::table          : assigner(table_          , v.table_          ); break;
            default: break;
        }
    }

    basic_value(basic_value&& v, std::vector<std::string> comments)
        : type_(v.type()), region_info_(std::move(v.region_info_)),
          comments_(std::move(comments))
    {
        switch(this->type_) // here this->type_ is already initialized
        {
            case value_t::boolean        : assigner(boolean_        , std::move(v.boolean_        )); break;
            case value_t::integer        : assigner(integer_        , std::move(v.integer_        )); break;
            case value_t::floating       : assigner(floating_       , std::move(v.floating_       )); break;
            case value_t::string         : assigner(string_         , std::move(v.string_         )); break;
            case value_t::offset_datetime: assigner(offset_datetime_, std::move(v.offset_datetime_)); break;
            case value_t::local_datetime : assigner(local_datetime_ , std::move(v.local_datetime_ )); break;
            case value_t::local_date     : assigner(local_date_     , std::move(v.local_date_     )); break;
            case value_t::local_time     : assigner(local_time_     , std::move(v.local_time_     )); break;
            case value_t::array          : assigner(array_          , std::move(v.array_          )); break;
            case value_t::table          : assigner(table_          , std::move(v.table_          )); break;
            default: break;
        }
    }

    // -----------------------------------------------------------------------
    // conversion between different basic_values.
    template<typename C,
             template<typename ...> class T,
             template<typename ...> class A>
    basic_value(const basic_value<C, T, A>& v)
        : type_(v.type()), region_info_(v.region_info_), comments_(v.comments())
    {
        switch(v.type())
        {
            case value_t::boolean        : assigner(boolean_        , v.boolean_        ); break;
            case value_t::integer        : assigner(integer_        , v.integer_        ); break;
            case value_t::floating       : assigner(floating_       , v.floating_       ); break;
            case value_t::string         : assigner(string_         , v.string_         ); break;
            case value_t::offset_datetime: assigner(offset_datetime_, v.offset_datetime_); break;
            case value_t::local_datetime : assigner(local_datetime_ , v.local_datetime_ ); break;
            case value_t::local_date     : assigner(local_date_     , v.local_date_     ); break;
            case value_t::local_time     : assigner(local_time_     , v.local_time_     ); break;
            case value_t::array          :
            {
                array_type tmp(v.as_array(std::nothrow).begin(),
                               v.as_array(std::nothrow).end());
                assigner(array_, std::move(tmp));
                break;
            }
            case value_t::table          :
            {
                table_type tmp(v.as_table(std::nothrow).begin(),
                               v.as_table(std::nothrow).end());
                assigner(table_, std::move(tmp));
                break;
            }
            default: break;
        }
    }
    template<typename C,
             template<typename ...> class T,
             template<typename ...> class A>
    basic_value(const basic_value<C, T, A>& v, std::vector<std::string> comments)
        : type_(v.type()), region_info_(v.region_info_),
          comments_(std::move(comments))
    {
        switch(v.type())
        {
            case value_t::boolean        : assigner(boolean_        , v.boolean_        ); break;
            case value_t::integer        : assigner(integer_        , v.integer_        ); break;
            case value_t::floating       : assigner(floating_       , v.floating_       ); break;
            case value_t::string         : assigner(string_         , v.string_         ); break;
            case value_t::offset_datetime: assigner(offset_datetime_, v.offset_datetime_); break;
            case value_t::local_datetime : assigner(local_datetime_ , v.local_datetime_ ); break;
            case value_t::local_date     : assigner(local_date_     , v.local_date_     ); break;
            case value_t::local_time     : assigner(local_time_     , v.local_time_     ); break;
            case value_t::array          :
            {
                array_type tmp(v.as_array(std::nothrow).begin(),
                               v.as_array(std::nothrow).end());
                assigner(array_, std::move(tmp));
                break;
            }
            case value_t::table          :
            {
                table_type tmp(v.as_table(std::nothrow).begin(),
                               v.as_table(std::nothrow).end());
                assigner(table_, std::move(tmp));
                break;
            }
            default: break;
        }
    }
    template<typename C,
             template<typename ...> class T,
             template<typename ...> class A>
    basic_value& operator=(const basic_value<C, T, A>& v)
    {
        this->region_info_ = v.region_info_;
        this->comments_    = comment_type(v.comments());
        this->type_        = v.type();
        switch(v.type())
        {
            case value_t::boolean        : assigner(boolean_        , v.boolean_        ); break;
            case value_t::integer        : assigner(integer_        , v.integer_        ); break;
            case value_t::floating       : assigner(floating_       , v.floating_       ); break;
            case value_t::string         : assigner(string_         , v.string_         ); break;
            case value_t::offset_datetime: assigner(offset_datetime_, v.offset_datetime_); break;
            case value_t::local_datetime : assigner(local_datetime_ , v.local_datetime_ ); break;
            case value_t::local_date     : assigner(local_date_     , v.local_date_     ); break;
            case value_t::local_time     : assigner(local_time_     , v.local_time_     ); break;
            case value_t::array          :
            {
                array_type tmp(v.as_array(std::nothrow).begin(),
                               v.as_array(std::nothrow).end());
                assigner(array_, std::move(tmp));
                break;
            }
            case value_t::table          :
            {
                table_type tmp(v.as_table(std::nothrow).begin(),
                               v.as_table(std::nothrow).end());
                assigner(table_, std::move(tmp));
                break;
            }
            default: break;
        }
        return *this;
    }

    // boolean ==============================================================

    basic_value(boolean b)
        : type_(value_t::boolean),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->boolean_, b);
    }
    basic_value& operator=(boolean b)
    {
        this->cleanup();
        this->type_ = value_t::boolean;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->boolean_, b);
        return *this;
    }
    basic_value(boolean b, std::vector<std::string> comments)
        : type_(value_t::boolean),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->boolean_, b);
    }

    // integer ==============================================================

    template<typename T, typename std::enable_if<detail::conjunction<
        std::is_integral<T>, detail::negation<std::is_same<T, boolean>>>::value,
        std::nullptr_t>::type = nullptr>
    basic_value(T i)
        : type_(value_t::integer),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->integer_, static_cast<integer>(i));
    }

    template<typename T, typename std::enable_if<detail::conjunction<
        std::is_integral<T>, detail::negation<std::is_same<T, boolean>>>::value,
        std::nullptr_t>::type = nullptr>
    basic_value& operator=(T i)
    {
        this->cleanup();
        this->type_ = value_t::integer;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->integer_, static_cast<integer>(i));
        return *this;
    }

    template<typename T, typename std::enable_if<detail::conjunction<
        std::is_integral<T>, detail::negation<std::is_same<T, boolean>>>::value,
        std::nullptr_t>::type = nullptr>
    basic_value(T i, std::vector<std::string> comments)
        : type_(value_t::integer),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->integer_, static_cast<integer>(i));
    }

    // floating =============================================================

    template<typename T, typename std::enable_if<
        std::is_floating_point<T>::value, std::nullptr_t>::type = nullptr>
    basic_value(T f)
        : type_(value_t::floating),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->floating_, static_cast<floating>(f));
    }


    template<typename T, typename std::enable_if<
        std::is_floating_point<T>::value, std::nullptr_t>::type = nullptr>
    basic_value& operator=(T f)
    {
        this->cleanup();
        this->type_ = value_t::floating;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->floating_, static_cast<floating>(f));
        return *this;
    }

    template<typename T, typename std::enable_if<
        std::is_floating_point<T>::value, std::nullptr_t>::type = nullptr>
    basic_value(T f, std::vector<std::string> comments)
        : type_(value_t::floating),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->floating_, f);
    }

    // string ===============================================================

    basic_value(toml::string s)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->string_, std::move(s));
    }
    basic_value& operator=(toml::string s)
    {
        this->cleanup();
        this->type_ = value_t::string ;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->string_, s);
        return *this;
    }
    basic_value(toml::string s, std::vector<std::string> comments)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->string_, std::move(s));
    }

    basic_value(std::string s)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->string_, toml::string(std::move(s)));
    }
    basic_value& operator=(std::string s)
    {
        this->cleanup();
        this->type_ = value_t::string ;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->string_, toml::string(std::move(s)));
        return *this;
    }
    basic_value(std::string s, string_t kind)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->string_, toml::string(std::move(s), kind));
    }
    basic_value(std::string s, std::vector<std::string> comments)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->string_, toml::string(std::move(s)));
    }
    basic_value(std::string s, string_t kind, std::vector<std::string> comments)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->string_, toml::string(std::move(s), kind));
    }

    basic_value(const char* s)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->string_, toml::string(std::string(s)));
    }
    basic_value& operator=(const char* s)
    {
        this->cleanup();
        this->type_ = value_t::string ;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->string_, toml::string(std::string(s)));
        return *this;
    }
    basic_value(const char* s, string_t kind)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->string_, toml::string(std::string(s), kind));
    }
    basic_value(const char* s, std::vector<std::string> comments)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->string_, toml::string(std::string(s)));
    }
    basic_value(const char* s, string_t kind, std::vector<std::string> comments)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->string_, toml::string(std::string(s), kind));
    }

#if __cplusplus >= 201703L
    basic_value(std::string_view s)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->string_, toml::string(s));
    }
    basic_value& operator=(std::string_view s)
    {
        this->cleanup();
        this->type_ = value_t::string ;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->string_, toml::string(s));
        return *this;
    }
    basic_value(std::string_view s, std::vector<std::string> comments)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->string_, toml::string(s));
    }
    basic_value(std::string_view s, string_t kind)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->string_, toml::string(s, kind));
    }
    basic_value(std::string_view s, string_t kind, std::vector<std::string> comments)
        : type_(value_t::string),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->string_, toml::string(s, kind));
    }
#endif

    // local date ===========================================================

    basic_value(const local_date& ld)
        : type_(value_t::local_date),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->local_date_, ld);
    }
    basic_value& operator=(const local_date& ld)
    {
        this->cleanup();
        this->type_ = value_t::local_date;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->local_date_, ld);
        return *this;
    }
    basic_value(const local_date& ld, std::vector<std::string> comments)
        : type_(value_t::local_date),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->local_date_, ld);
    }

    // local time ===========================================================

    basic_value(const local_time& lt)
        : type_(value_t::local_time),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->local_time_, lt);
    }
    basic_value(const local_time& lt, std::vector<std::string> comments)
        : type_(value_t::local_time),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->local_time_, lt);
    }
    basic_value& operator=(const local_time& lt)
    {
        this->cleanup();
        this->type_ = value_t::local_time;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->local_time_, lt);
        return *this;
    }

    template<typename Rep, typename Period>
    basic_value(const std::chrono::duration<Rep, Period>& dur)
        : type_(value_t::local_time),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->local_time_, local_time(dur));
    }
    template<typename Rep, typename Period>
    basic_value(const std::chrono::duration<Rep, Period>& dur,
                std::vector<std::string> comments)
        : type_(value_t::local_time),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->local_time_, local_time(dur));
    }
    template<typename Rep, typename Period>
    basic_value& operator=(const std::chrono::duration<Rep, Period>& dur)
    {
        this->cleanup();
        this->type_ = value_t::local_time;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->local_time_, local_time(dur));
        return *this;
    }

    // local datetime =======================================================

    basic_value(const local_datetime& ldt)
        : type_(value_t::local_datetime),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->local_datetime_, ldt);
    }
    basic_value(const local_datetime& ldt, std::vector<std::string> comments)
        : type_(value_t::local_datetime),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->local_datetime_, ldt);
    }
    basic_value& operator=(const local_datetime& ldt)
    {
        this->cleanup();
        this->type_ = value_t::local_datetime;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->local_datetime_, ldt);
        return *this;
    }

    // offset datetime ======================================================

    basic_value(const offset_datetime& odt)
        : type_(value_t::offset_datetime),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->offset_datetime_, odt);
    }
    basic_value(const offset_datetime& odt, std::vector<std::string> comments)
        : type_(value_t::offset_datetime),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->offset_datetime_, odt);
    }
    basic_value& operator=(const offset_datetime& odt)
    {
        this->cleanup();
        this->type_ = value_t::offset_datetime;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->offset_datetime_, odt);
        return *this;
    }
    basic_value(const std::chrono::system_clock::time_point& tp)
        : type_(value_t::offset_datetime),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->offset_datetime_, offset_datetime(tp));
    }
    basic_value(const std::chrono::system_clock::time_point& tp,
                std::vector<std::string> comments)
        : type_(value_t::offset_datetime),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->offset_datetime_, offset_datetime(tp));
    }
    basic_value& operator=(const std::chrono::system_clock::time_point& tp)
    {
        this->cleanup();
        this->type_ = value_t::offset_datetime;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->offset_datetime_, offset_datetime(tp));
        return *this;
    }

    // array ================================================================

    basic_value(const array_type& ary)
        : type_(value_t::array),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->array_, ary);
    }
    basic_value(const array_type& ary, std::vector<std::string> comments)
        : type_(value_t::array),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->array_, ary);
    }
    basic_value& operator=(const array_type& ary)
    {
        this->cleanup();
        this->type_ = value_t::array ;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->array_, ary);
        return *this;
    }

    // array (initializer_list) ----------------------------------------------

    template<typename T, typename std::enable_if<
            std::is_convertible<T, value_type>::value,
        std::nullptr_t>::type = nullptr>
    basic_value(std::initializer_list<T> list)
        : type_(value_t::array),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        array_type ary(list.begin(), list.end());
        assigner(this->array_, std::move(ary));
    }
    template<typename T, typename std::enable_if<
            std::is_convertible<T, value_type>::value,
        std::nullptr_t>::type = nullptr>
    basic_value(std::initializer_list<T> list, std::vector<std::string> comments)
        : type_(value_t::array),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        array_type ary(list.begin(), list.end());
        assigner(this->array_, std::move(ary));
    }
    template<typename T, typename std::enable_if<
            std::is_convertible<T, value_type>::value,
        std::nullptr_t>::type = nullptr>
    basic_value& operator=(std::initializer_list<T> list)
    {
        this->cleanup();
        this->type_ = value_t::array;
        this->region_info_ = std::make_shared<region_base>(region_base{});

        array_type ary(list.begin(), list.end());
        assigner(this->array_, std::move(ary));
        return *this;
    }

    // array (STL Containers) ------------------------------------------------

    template<typename T, typename std::enable_if<detail::conjunction<
            detail::negation<std::is_same<T, array_type>>,
            detail::is_container<T>
        >::value, std::nullptr_t>::type = nullptr>
    basic_value(const T& list)
        : type_(value_t::array),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        static_assert(std::is_convertible<typename T::value_type, value_type>::value,
            "elements of a container should be convertible to toml::value");

        array_type ary(list.size());
        std::copy(list.begin(), list.end(), ary.begin());
        assigner(this->array_, std::move(ary));
    }
    template<typename T, typename std::enable_if<detail::conjunction<
            detail::negation<std::is_same<T, array_type>>,
            detail::is_container<T>
        >::value, std::nullptr_t>::type = nullptr>
    basic_value(const T& list, std::vector<std::string> comments)
        : type_(value_t::array),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        static_assert(std::is_convertible<typename T::value_type, value_type>::value,
            "elements of a container should be convertible to toml::value");

        array_type ary(list.size());
        std::copy(list.begin(), list.end(), ary.begin());
        assigner(this->array_, std::move(ary));
    }
    template<typename T, typename std::enable_if<detail::conjunction<
            detail::negation<std::is_same<T, array_type>>,
            detail::is_container<T>
        >::value, std::nullptr_t>::type = nullptr>
    basic_value& operator=(const T& list)
    {
        static_assert(std::is_convertible<typename T::value_type, value_type>::value,
            "elements of a container should be convertible to toml::value");

        this->cleanup();
        this->type_ = value_t::array;
        this->region_info_ = std::make_shared<region_base>(region_base{});

        array_type ary(list.size());
        std::copy(list.begin(), list.end(), ary.begin());
        assigner(this->array_, std::move(ary));
        return *this;
    }

    // table ================================================================

    basic_value(const table_type& tab)
        : type_(value_t::table),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        assigner(this->table_, tab);
    }
    basic_value(const table_type& tab, std::vector<std::string> comments)
        : type_(value_t::table),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        assigner(this->table_, tab);
    }
    basic_value& operator=(const table_type& tab)
    {
        this->cleanup();
        this->type_ = value_t::table;
        this->region_info_ = std::make_shared<region_base>(region_base{});
        assigner(this->table_, tab);
        return *this;
    }

    // initializer-list ------------------------------------------------------

    basic_value(std::initializer_list<std::pair<key, basic_value>> list)
        : type_(value_t::table),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        table_type tab;
        for(const auto& elem : list) {tab[elem.first] = elem.second;}
        assigner(this->table_, std::move(tab));
    }

    basic_value(std::initializer_list<std::pair<key, basic_value>> list,
                std::vector<std::string> comments)
        : type_(value_t::table),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        table_type tab;
        for(const auto& elem : list) {tab[elem.first] = elem.second;}
        assigner(this->table_, std::move(tab));
    }
    basic_value& operator=(std::initializer_list<std::pair<key, basic_value>> list)
    {
        this->cleanup();
        this->type_ = value_t::table;
        this->region_info_ = std::make_shared<region_base>(region_base{});

        table_type tab;
        for(const auto& elem : list) {tab[elem.first] = elem.second;}
        assigner(this->table_, std::move(tab));
        return *this;
    }

    // other table-like -----------------------------------------------------

    template<typename Map, typename std::enable_if<detail::conjunction<
            detail::negation<std::is_same<Map, table_type>>,
            detail::is_map<Map>
        >::value, std::nullptr_t>::type = nullptr>
    basic_value(const Map& mp)
        : type_(value_t::table),
          region_info_(std::make_shared<region_base>(region_base{}))
    {
        table_type tab;
        for(const auto& elem : mp) {tab[elem.first] = elem.second;}
        assigner(this->table_, std::move(tab));
    }
    template<typename Map, typename std::enable_if<detail::conjunction<
            detail::negation<std::is_same<Map, table_type>>,
            detail::is_map<Map>
        >::value, std::nullptr_t>::type = nullptr>
    basic_value(const Map& mp, std::vector<std::string> comments)
        : type_(value_t::table),
          region_info_(std::make_shared<region_base>(region_base{})),
          comments_(std::move(comments))
    {
        table_type tab;
        for(const auto& elem : mp) {tab[elem.first] = elem.second;}
        assigner(this->table_, std::move(tab));
    }
    template<typename Map, typename std::enable_if<detail::conjunction<
            detail::negation<std::is_same<Map, table_type>>,
            detail::is_map<Map>
        >::value, std::nullptr_t>::type = nullptr>
    basic_value& operator=(const Map& mp)
    {
        this->cleanup();
        this->type_ = value_t::table;
        this->region_info_ = std::make_shared<region_base>(region_base{});

        table_type tab;
        for(const auto& elem : mp) {tab[elem.first] = elem.second;}
        assigner(this->table_, std::move(tab));
        return *this;
    }

    // user-defined =========================================================

    // convert using into_toml() method -------------------------------------

    template<typename T, typename std::enable_if<
        detail::has_into_toml_method<T>::value, std::nullptr_t>::type = nullptr>
    basic_value(const T& ud): basic_value(ud.into_toml()) {}

    template<typename T, typename std::enable_if<
        detail::has_into_toml_method<T>::value, std::nullptr_t>::type = nullptr>
    basic_value(const T& ud, std::vector<std::string> comments)
        : basic_value(ud.into_toml(), std::move(comments))
    {}
    template<typename T, typename std::enable_if<
        detail::has_into_toml_method<T>::value, std::nullptr_t>::type = nullptr>
    basic_value& operator=(const T& ud)
    {
        *this = ud.into_toml();
        return *this;
    }

    // convert using into<T> struct -----------------------------------------

    template<typename T, std::size_t S = sizeof(::toml::into<T>)>
    basic_value(const T& ud): basic_value(::toml::into<T>::into_toml(ud)) {}
    template<typename T, std::size_t S = sizeof(::toml::into<T>)>
    basic_value(const T& ud, std::vector<std::string> comments)
        : basic_value(::toml::into<T>::into_toml(ud), std::move(comments))
    {}
    template<typename T, std::size_t S = sizeof(::toml::into<T>)>
    basic_value& operator=(const T& ud)
    {
        *this = ::toml::into<T>::into_toml(ud);
        return *this;
    }

    // for internal use ------------------------------------------------------
    //
    // Those constructors take detail::region that contains parse result.

    basic_value(boolean b, detail::region reg)
        : type_(value_t::boolean),
          region_info_(std::make_shared<detail::region>(std::move(reg))),
          comments_(region_info_->comments())
    {
        assigner(this->boolean_, b);
    }
    template<typename T, typename std::enable_if<
        detail::conjunction<
            std::is_integral<T>, detail::negation<std::is_same<T, boolean>>
        >::value, std::nullptr_t>::type = nullptr>
    basic_value(T i, detail::region reg)
        : type_(value_t::integer),
          region_info_(std::make_shared<detail::region>(std::move(reg))),
          comments_(region_info_->comments())
    {
        assigner(this->integer_, static_cast<integer>(i));
    }
    template<typename T, typename std::enable_if<
        std::is_floating_point<T>::value, std::nullptr_t>::type = nullptr>
    basic_value(T f, detail::region reg)
        : type_(value_t::floating),
          region_info_(std::make_shared<detail::region>(std::move(reg))),
          comments_(region_info_->comments())
    {
        assigner(this->floating_, static_cast<floating>(f));
    }
    basic_value(toml::string s, detail::region reg)
        : type_(value_t::string),
          region_info_(std::make_shared<detail::region>(std::move(reg))),
          comments_(region_info_->comments())
    {
        assigner(this->string_, std::move(s));
    }
    basic_value(const local_date& ld, detail::region reg)
        : type_(value_t::local_date),
          region_info_(std::make_shared<detail::region>(std::move(reg))),
          comments_(region_info_->comments())
    {
        assigner(this->local_date_, ld);
    }
    basic_value(const local_time& lt, detail::region reg)
        : type_(value_t::local_time),
          region_info_(std::make_shared<detail::region>(std::move(reg))),
          comments_(region_info_->comments())
    {
        assigner(this->local_time_, lt);
    }
    basic_value(const local_datetime& ldt, detail::region reg)
        : type_(value_t::local_datetime),
          region_info_(std::make_shared<detail::region>(std::move(reg))),
          comments_(region_info_->comments())
    {
        assigner(this->local_datetime_, ldt);
    }
    basic_value(const offset_datetime& odt, detail::region reg)
        : type_(value_t::offset_datetime),
          region_info_(std::make_shared<detail::region>(std::move(reg))),
          comments_(region_info_->comments())
    {
        assigner(this->offset_datetime_, odt);
    }
    basic_value(const array_type& ary, detail::region reg)
        : type_(value_t::array),
          region_info_(std::make_shared<detail::region>(std::move(reg))),
          comments_(region_info_->comments())
    {
        assigner(this->array_, ary);
    }
    basic_value(const table_type& tab, detail::region reg)
        : type_(value_t::table),
          region_info_(std::make_shared<detail::region>(std::move(reg))),
          comments_(region_info_->comments())
    {
        assigner(this->table_, tab);
    }

    template<typename T, typename std::enable_if<
        detail::is_exact_toml_type<T, value_type>::value,
        std::nullptr_t>::type = nullptr>
    basic_value(std::pair<T, detail::region> parse_result)
        : basic_value(std::move(parse_result.first), std::move(parse_result.second))
    {}

    // type checking and casting ============================================

    template<typename T, typename std::enable_if<
        detail::is_exact_toml_type<T, value_type>::value,
        std::nullptr_t>::type = nullptr>
    bool is() const noexcept
    {
        return detail::type_to_enum<T, value_type>::value == this->type_;
    }
    bool is(value_t t) const noexcept {return t == this->type_;}

    bool is_uninitialized()   const noexcept {return this->is(value_t::empty          );}
    bool is_boolean()         const noexcept {return this->is(value_t::boolean        );}
    bool is_integer()         const noexcept {return this->is(value_t::integer        );}
    bool is_floating()        const noexcept {return this->is(value_t::floating       );}
    bool is_string()          const noexcept {return this->is(value_t::string         );}
    bool is_offset_datetime() const noexcept {return this->is(value_t::offset_datetime);}
    bool is_local_datetime()  const noexcept {return this->is(value_t::local_datetime );}
    bool is_local_date()      const noexcept {return this->is(value_t::local_date     );}
    bool is_local_time()      const noexcept {return this->is(value_t::local_time     );}
    bool is_array()           const noexcept {return this->is(value_t::array          );}
    bool is_table()           const noexcept {return this->is(value_t::table          );}

    value_t type() const noexcept {return type_;}

    template<value_t T>
    typename detail::enum_to_type<T, value_type>::type&       cast() &
    {
        if(this->type_ != T)
        {
            detail::throw_bad_cast<T>("toml::value::cast: ", this->type_, *this);
        }
        return detail::switch_cast<T>::invoke(*this);
    }
    template<value_t T>
    typename detail::enum_to_type<T, value_type>::type const& cast() const&
    {
        if(this->type_ != T)
        {
            detail::throw_bad_cast<T>("toml::value::cast: ", this->type_, *this);
        }
        return detail::switch_cast<T>::invoke(*this);
    }
    template<value_t T>
    typename detail::enum_to_type<T, value_type>::type&&      cast() &&
    {
        if(this->type_ != T)
        {
            detail::throw_bad_cast<T>("toml::value::cast: ", this->type_, *this);
        }
        return detail::switch_cast<T>::invoke(std::move(*this));
    }

    // ------------------------------------------------------------------------
    // nothrow version

    boolean         const& as_boolean        (const std::nothrow_t&) const& noexcept {return this->boolean_;}
    integer         const& as_integer        (const std::nothrow_t&) const& noexcept {return this->integer_;}
    floating        const& as_floating       (const std::nothrow_t&) const& noexcept {return this->floating_;}
    string          const& as_string         (const std::nothrow_t&) const& noexcept {return this->string_;}
    offset_datetime const& as_offset_datetime(const std::nothrow_t&) const& noexcept {return this->offset_datetime_;}
    local_datetime  const& as_local_datetime (const std::nothrow_t&) const& noexcept {return this->local_datetime_;}
    local_date      const& as_local_date     (const std::nothrow_t&) const& noexcept {return this->local_date_;}
    local_time      const& as_local_time     (const std::nothrow_t&) const& noexcept {return this->local_time_;}
    array_type      const& as_array          (const std::nothrow_t&) const& noexcept {return this->array_.value();}
    table_type      const& as_table          (const std::nothrow_t&) const& noexcept {return this->table_.value();}

    boolean        & as_boolean        (const std::nothrow_t&) & noexcept {return this->boolean_;}
    integer        & as_integer        (const std::nothrow_t&) & noexcept {return this->integer_;}
    floating       & as_floating       (const std::nothrow_t&) & noexcept {return this->floating_;}
    string         & as_string         (const std::nothrow_t&) & noexcept {return this->string_;}
    offset_datetime& as_offset_datetime(const std::nothrow_t&) & noexcept {return this->offset_datetime_;}
    local_datetime & as_local_datetime (const std::nothrow_t&) & noexcept {return this->local_datetime_;}
    local_date     & as_local_date     (const std::nothrow_t&) & noexcept {return this->local_date_;}
    local_time     & as_local_time     (const std::nothrow_t&) & noexcept {return this->local_time_;}
    array_type     & as_array          (const std::nothrow_t&) & noexcept {return this->array_.value();}
    table_type     & as_table          (const std::nothrow_t&) & noexcept {return this->table_.value();}

    boolean        && as_boolean        (const std::nothrow_t&) && noexcept {return std::move(this->boolean_);}
    integer        && as_integer        (const std::nothrow_t&) && noexcept {return std::move(this->integer_);}
    floating       && as_floating       (const std::nothrow_t&) && noexcept {return std::move(this->floating_);}
    string         && as_string         (const std::nothrow_t&) && noexcept {return std::move(this->string_);}
    offset_datetime&& as_offset_datetime(const std::nothrow_t&) && noexcept {return std::move(this->offset_datetime_);}
    local_datetime && as_local_datetime (const std::nothrow_t&) && noexcept {return std::move(this->local_datetime_);}
    local_date     && as_local_date     (const std::nothrow_t&) && noexcept {return std::move(this->local_date_);}
    local_time     && as_local_time     (const std::nothrow_t&) && noexcept {return std::move(this->local_time_);}
    array_type     && as_array          (const std::nothrow_t&) && noexcept {return std::move(this->array_.value());}
    table_type     && as_table          (const std::nothrow_t&) && noexcept {return std::move(this->table_.value());}

    // ========================================================================
    // throw version
    // ------------------------------------------------------------------------
    // const reference {{{

    boolean const& as_boolean() const&
    {
        if(this->type_ != value_t::boolean)
        {
            detail::throw_bad_cast<value_t::boolean>(
                    "toml::value::as_boolean(): ", this->type_, *this);
        }
        return this->boolean_;
    }
    integer const& as_integer() const&
    {
        if(this->type_ != value_t::integer)
        {
            detail::throw_bad_cast<value_t::integer>(
                    "toml::value::as_integer(): ", this->type_, *this);
        }
        return this->integer_;
    }
    floating const& as_floating() const&
    {
        if(this->type_ != value_t::floating)
        {
            detail::throw_bad_cast<value_t::floating>(
                    "toml::value::as_floating(): ", this->type_, *this);
        }
        return this->floating_;
    }
    string const& as_string() const&
    {
        if(this->type_ != value_t::string)
        {
            detail::throw_bad_cast<value_t::string>(
                    "toml::value::as_string(): ", this->type_, *this);
        }
        return this->string_;
    }
    offset_datetime const& as_offset_datetime() const&
    {
        if(this->type_ != value_t::offset_datetime)
        {
            detail::throw_bad_cast<value_t::offset_datetime>(
                    "toml::value::as_offset_datetime(): ", this->type_, *this);
        }
        return this->offset_datetime_;
    }
    local_datetime const& as_local_datetime() const&
    {
        if(this->type_ != value_t::local_datetime)
        {
            detail::throw_bad_cast<value_t::local_datetime>(
                    "toml::value::as_local_datetime(): ", this->type_, *this);
        }
        return this->local_datetime_;
    }
    local_date const& as_local_date() const&
    {
        if(this->type_ != value_t::local_date)
        {
            detail::throw_bad_cast<value_t::local_date>(
                    "toml::value::as_local_date(): ", this->type_, *this);
        }
        return this->local_date_;
    }
    local_time const& as_local_time() const&
    {
        if(this->type_ != value_t::local_time)
        {
            detail::throw_bad_cast<value_t::local_time>(
                    "toml::value::as_local_time(): ", this->type_, *this);
        }
        return this->local_time_;
    }
    array_type const& as_array() const&
    {
        if(this->type_ != value_t::array)
        {
            detail::throw_bad_cast<value_t::array>(
                    "toml::value::as_array(): ", this->type_, *this);
        }
        return this->array_.value();
    }
    table_type const& as_table() const&
    {
        if(this->type_ != value_t::table)
        {
            detail::throw_bad_cast<value_t::table>(
                    "toml::value::as_table(): ", this->type_, *this);
        }
        return this->table_.value();
    }
    // }}}
    // ------------------------------------------------------------------------
    // nonconst reference {{{

    boolean & as_boolean() &
    {
        if(this->type_ != value_t::boolean)
        {
            detail::throw_bad_cast<value_t::boolean>(
                    "toml::value::as_boolean(): ", this->type_, *this);
        }
        return this->boolean_;
    }
    integer & as_integer() &
    {
        if(this->type_ != value_t::integer)
        {
            detail::throw_bad_cast<value_t::integer>(
                    "toml::value::as_integer(): ", this->type_, *this);
        }
        return this->integer_;
    }
    floating & as_floating() &
    {
        if(this->type_ != value_t::floating)
        {
            detail::throw_bad_cast<value_t::floating>(
                    "toml::value::as_floating(): ", this->type_, *this);
        }
        return this->floating_;
    }
    string & as_string() &
    {
        if(this->type_ != value_t::string)
        {
            detail::throw_bad_cast<value_t::string>(
                    "toml::value::as_string(): ", this->type_, *this);
        }
        return this->string_;
    }
    offset_datetime & as_offset_datetime() &
    {
        if(this->type_ != value_t::offset_datetime)
        {
            detail::throw_bad_cast<value_t::offset_datetime>(
                    "toml::value::as_offset_datetime(): ", this->type_, *this);
        }
        return this->offset_datetime_;
    }
    local_datetime & as_local_datetime() &
    {
        if(this->type_ != value_t::local_datetime)
        {
            detail::throw_bad_cast<value_t::local_datetime>(
                    "toml::value::as_local_datetime(): ", this->type_, *this);
        }
        return this->local_datetime_;
    }
    local_date & as_local_date() &
    {
        if(this->type_ != value_t::local_date)
        {
            detail::throw_bad_cast<value_t::local_date>(
                    "toml::value::as_local_date(): ", this->type_, *this);
        }
        return this->local_date_;
    }
    local_time & as_local_time() &
    {
        if(this->type_ != value_t::local_time)
        {
            detail::throw_bad_cast<value_t::local_time>(
                    "toml::value::as_local_time(): ", this->type_, *this);
        }
        return this->local_time_;
    }
    array_type & as_array() &
    {
        if(this->type_ != value_t::array)
        {
            detail::throw_bad_cast<value_t::array>(
                    "toml::value::as_array(): ", this->type_, *this);
        }
        return this->array_.value();
    }
    table_type & as_table() &
    {
        if(this->type_ != value_t::table)
        {
            detail::throw_bad_cast<value_t::table>(
                    "toml::value::as_table(): ", this->type_, *this);
        }
        return this->table_.value();
    }

    // }}}
    // ------------------------------------------------------------------------
    // rvalue reference {{{

    boolean && as_boolean() &&
    {
        if(this->type_ != value_t::boolean)
        {
            detail::throw_bad_cast<value_t::boolean>(
                    "toml::value::as_boolean(): ", this->type_, *this);
        }
        return std::move(this->boolean_);
    }
    integer && as_integer() &&
    {
        if(this->type_ != value_t::integer)
        {
            detail::throw_bad_cast<value_t::integer>(
                    "toml::value::as_integer(): ", this->type_, *this);
        }
        return std::move(this->integer_);
    }
    floating && as_floating() &&
    {
        if(this->type_ != value_t::floating)
        {
            detail::throw_bad_cast<value_t::floating>(
                    "toml::value::as_floating(): ", this->type_, *this);
        }
        return std::move(this->floating_);
    }
    string && as_string() &&
    {
        if(this->type_ != value_t::string)
        {
            detail::throw_bad_cast<value_t::string>(
                    "toml::value::as_string(): ", this->type_, *this);
        }
        return std::move(this->string_);
    }
    offset_datetime && as_offset_datetime() &&
    {
        if(this->type_ != value_t::offset_datetime)
        {
            detail::throw_bad_cast<value_t::offset_datetime>(
                    "toml::value::as_offset_datetime(): ", this->type_, *this);
        }
        return std::move(this->offset_datetime_);
    }
    local_datetime && as_local_datetime() &&
    {
        if(this->type_ != value_t::local_datetime)
        {
            detail::throw_bad_cast<value_t::local_datetime>(
                    "toml::value::as_local_datetime(): ", this->type_, *this);
        }
        return std::move(this->local_datetime_);
    }
    local_date && as_local_date() &&
    {
        if(this->type_ != value_t::local_date)
        {
            detail::throw_bad_cast<value_t::local_date>(
                    "toml::value::as_local_date(): ", this->type_, *this);
        }
        return std::move(this->local_date_);
    }
    local_time && as_local_time() &&
    {
        if(this->type_ != value_t::local_time)
        {
            detail::throw_bad_cast<value_t::local_time>(
                    "toml::value::as_local_time(): ", this->type_, *this);
        }
        return std::move(this->local_time_);
    }
    array_type && as_array() &&
    {
        if(this->type_ != value_t::array)
        {
            detail::throw_bad_cast<value_t::array>(
                    "toml::value::as_array(): ", this->type_, *this);
        }
        return std::move(this->array_.value());
    }
    table_type && as_table() &&
    {
        if(this->type_ != value_t::table)
        {
            detail::throw_bad_cast<value_t::table>(
                    "toml::value::as_table(): ", this->type_, *this);
        }
        return std::move(this->table_.value());
    }
    // }}}

    // accessors =============================================================
    //
    // may throw type_error or out_of_range
    //
    value_type&       at(const key& k)
    {
        if(!this->is_table())
        {
            detail::throw_bad_cast<value_t::table>(
                "toml::value::at(key): ", this->type_, *this);
        }
        if(this->as_table(std::nothrow).count(k) == 0)
        {
            detail::throw_key_not_found_error(*this, k);
        }
        return this->as_table(std::nothrow).at(k);
    }
    value_type const& at(const key& k) const
    {
        if(!this->is_table())
        {
            detail::throw_bad_cast<value_t::table>(
                "toml::value::at(key): ", this->type_, *this);
        }
        if(this->as_table(std::nothrow).count(k) == 0)
        {
            detail::throw_key_not_found_error(*this, k);
        }
        return this->as_table(std::nothrow).at(k);
    }
    value_type&       operator[](const key& k)
    {
        if(this->is_uninitialized())
        {
            *this = table_type{};
        }
        else if(!this->is_table()) // initialized, but not a table
        {
            detail::throw_bad_cast<value_t::table>(
                "toml::value::operator[](key): ", this->type_, *this);
        }
        return this->as_table(std::nothrow)[k];
    }

    value_type&       at(const std::size_t idx)
    {
        if(!this->is_array())
        {
            detail::throw_bad_cast<value_t::array>(
                "toml::value::at(idx): ", this->type_, *this);
        }
        if(this->as_array(std::nothrow).size() <= idx)
        {
            throw std::out_of_range(detail::format_underline(
                "toml::value::at(idx): no element corresponding to the index", {
                    {this->location(), concat_to_string("the length is ",
                        this->as_array(std::nothrow).size(),
                        ", and the specified index is ", idx)}
                }));
        }
        return this->as_array().at(idx);
    }
    value_type const& at(const std::size_t idx) const
    {
        if(!this->is_array())
        {
            detail::throw_bad_cast<value_t::array>(
                "toml::value::at(idx): ", this->type_, *this);
        }
        if(this->as_array(std::nothrow).size() <= idx)
        {
            throw std::out_of_range(detail::format_underline(
                "toml::value::at(idx): no element corresponding to the index", {
                    {this->location(), concat_to_string("the length is ",
                        this->as_array(std::nothrow).size(),
                        ", and the specified index is ", idx)}
                }));
        }
        return this->as_array(std::nothrow).at(idx);
    }

    value_type&       operator[](const std::size_t idx) noexcept
    {
        // no check...
        return this->as_array(std::nothrow)[idx];
    }
    value_type const& operator[](const std::size_t idx) const noexcept
    {
        // no check...
        return this->as_array(std::nothrow)[idx];
    }

    void push_back(const value_type& x)
    {
        if(!this->is_array())
        {
            detail::throw_bad_cast<value_t::array>(
                "toml::value::push_back(value): ", this->type_, *this);
        }
        this->as_array(std::nothrow).push_back(x);
        return;
    }
    void push_back(value_type&& x)
    {
        if(!this->is_array())
        {
            detail::throw_bad_cast<value_t::array>(
                "toml::value::push_back(value): ", this->type_, *this);
        }
        this->as_array(std::nothrow).push_back(std::move(x));
        return;
    }

    template<typename ... Ts>
    value_type& emplace_back(Ts&& ... args)
    {
        if(!this->is_array())
        {
            detail::throw_bad_cast<value_t::array>(
                "toml::value::emplace_back(...): ", this->type_, *this);
        }
        this->as_array(std::nothrow).emplace_back(std::forward<Ts>(args) ...);
        return this->as_array(std::nothrow).back();
    }

    std::size_t size() const
    {
        switch(this->type_)
        {
            case value_t::array:
            {
                return this->as_array(std::nothrow).size();
            }
            case value_t::table:
            {
                return this->as_table(std::nothrow).size();
            }
            case value_t::string:
            {
                return this->as_string(std::nothrow).str.size();
            }
            default:
            {
                throw type_error(detail::format_underline(
                    "toml::value::size(): bad_cast to container types", {
                        {this->location(),
                         concat_to_string("the actual type is ", this->type_)}
                    }), this->location());
            }
        }
    }

    std::size_t count(const key_type& k) const
    {
        if(!this->is_table())
        {
            detail::throw_bad_cast<value_t::table>(
                "toml::value::count(key): ", this->type_, *this);
        }
        return this->as_table(std::nothrow).count(k);
    }

    bool contains(const key_type& k) const
    {
        if(!this->is_table())
        {
            detail::throw_bad_cast<value_t::table>(
                "toml::value::contains(key): ", this->type_, *this);
        }
        return (this->as_table(std::nothrow).count(k) != 0);
    }

    source_location location() const
    {
        return source_location(this->region_info_.get());
    }

    comment_type const& comments() const noexcept {return this->comments_;}
    comment_type&       comments()       noexcept {return this->comments_;}

  private:

    void cleanup() noexcept
    {
        switch(this->type_)
        {
            case value_t::string  : {string_.~string();       return;}
            case value_t::array   : {array_.~array_storage(); return;}
            case value_t::table   : {table_.~table_storage(); return;}
            default              : return;
        }
    }

    // for error messages
    template<typename Value>
    friend region_base const* detail::get_region(const Value& v);

    template<typename Value>
    friend void detail::change_region(Value& v, detail::region reg);

  private:

    using array_storage = detail::storage<array_type>;
    using table_storage = detail::storage<table_type>;

    value_t type_;
    union
    {
        boolean         boolean_;
        integer         integer_;
        floating        floating_;
        string          string_;
        offset_datetime offset_datetime_;
        local_datetime  local_datetime_;
        local_date      local_date_;
        local_time      local_time_;
        array_storage   array_;
        table_storage   table_;
    };
    std::shared_ptr<region_base> region_info_;
    comment_type                 comments_;
};

// default toml::value and default array/table.
using value = basic_value<discard_comments, std::unordered_map, std::vector>;
using array = typename value::array_type;
using table = typename value::table_type;

template<typename C, template<typename ...> class T, template<typename ...> class A>
inline bool
operator==(const basic_value<C, T, A>& lhs, const basic_value<C, T, A>& rhs)
{
    if(lhs.type()     != rhs.type())     {return false;}
    if(lhs.comments() != rhs.comments()) {return false;}

    switch(lhs.type())
    {
        case value_t::boolean  :
        {
            return lhs.as_boolean() == rhs.as_boolean();
        }
        case value_t::integer  :
        {
            return lhs.as_integer() == rhs.as_integer();
        }
        case value_t::floating :
        {
            return lhs.as_floating() == rhs.as_floating();
        }
        case value_t::string   :
        {
            return lhs.as_string() == rhs.as_string();
        }
        case value_t::offset_datetime:
        {
            return lhs.as_offset_datetime() == rhs.as_offset_datetime();
        }
        case value_t::local_datetime:
        {
            return lhs.as_local_datetime() == rhs.as_local_datetime();
        }
        case value_t::local_date:
        {
            return lhs.as_local_date() == rhs.as_local_date();
        }
        case value_t::local_time:
        {
            return lhs.as_local_time() == rhs.as_local_time();
        }
        case value_t::array    :
        {
            return lhs.as_array() == rhs.as_array();
        }
        case value_t::table    :
        {
            return lhs.as_table() == rhs.as_table();
        }
        case value_t::empty    : {return true; }
        default:                 {return false;}
    }
}

template<typename C, template<typename ...> class T, template<typename ...> class A>
inline bool operator!=(const basic_value<C, T, A>& lhs, const basic_value<C, T, A>& rhs)
{
    return !(lhs == rhs);
}

template<typename C, template<typename ...> class T, template<typename ...> class A>
typename std::enable_if<detail::conjunction<
    detail::is_comparable<typename basic_value<C, T, A>::array_type>,
    detail::is_comparable<typename basic_value<C, T, A>::table_type>
    >::value, bool>::type
operator<(const basic_value<C, T, A>& lhs, const basic_value<C, T, A>& rhs)
{
    if(lhs.type() != rhs.type()){return (lhs.type() < rhs.type());}
    switch(lhs.type())
    {
        case value_t::boolean  :
        {
            return lhs.as_boolean() <  rhs.as_boolean() ||
                  (lhs.as_boolean() == rhs.as_boolean() &&
                   lhs.comments() < rhs.comments());
        }
        case value_t::integer  :
        {
            return lhs.as_integer() <  rhs.as_integer() ||
                  (lhs.as_integer() == rhs.as_integer() &&
                   lhs.comments() < rhs.comments());
        }
        case value_t::floating :
        {
            return lhs.as_floating() <  rhs.as_floating() ||
                  (lhs.as_floating() == rhs.as_floating() &&
                   lhs.comments() < rhs.comments());
        }
        case value_t::string   :
        {
            return lhs.as_string() <  rhs.as_string() ||
                  (lhs.as_string() == rhs.as_string() &&
                   lhs.comments() < rhs.comments());
        }
        case value_t::offset_datetime:
        {
            return lhs.as_offset_datetime() <  rhs.as_offset_datetime() ||
                  (lhs.as_offset_datetime() == rhs.as_offset_datetime() &&
                   lhs.comments() < rhs.comments());
        }
        case value_t::local_datetime:
        {
            return lhs.as_local_datetime() <  rhs.as_local_datetime() ||
                  (lhs.as_local_datetime() == rhs.as_local_datetime() &&
                   lhs.comments() < rhs.comments());
        }
        case value_t::local_date:
        {
            return lhs.as_local_date() <  rhs.as_local_date() ||
                  (lhs.as_local_date() == rhs.as_local_date() &&
                   lhs.comments() < rhs.comments());
        }
        case value_t::local_time:
        {
            return lhs.as_local_time() <  rhs.as_local_time() ||
                  (lhs.as_local_time() == rhs.as_local_time() &&
                   lhs.comments() < rhs.comments());
        }
        case value_t::array    :
        {
            return lhs.as_array() <  rhs.as_array() ||
                  (lhs.as_array() == rhs.as_array() &&
                   lhs.comments() < rhs.comments());
        }
        case value_t::table    :
        {
            return lhs.as_table() <  rhs.as_table() ||
                  (lhs.as_table() == rhs.as_table() &&
                   lhs.comments() < rhs.comments());
        }
        case value_t::empty    :
        {
            return lhs.comments() < rhs.comments();
        }
        default:
        {
            return lhs.comments() < rhs.comments();
        }
    }
}

template<typename C, template<typename ...> class T, template<typename ...> class A>
typename std::enable_if<detail::conjunction<
    detail::is_comparable<typename basic_value<C, T, A>::array_type>,
    detail::is_comparable<typename basic_value<C, T, A>::table_type>
    >::value, bool>::type
operator<=(const basic_value<C, T, A>& lhs, const basic_value<C, T, A>& rhs)
{
    return (lhs < rhs) || (lhs == rhs);
}
template<typename C, template<typename ...> class T, template<typename ...> class A>
typename std::enable_if<detail::conjunction<
    detail::is_comparable<typename basic_value<C, T, A>::array_type>,
    detail::is_comparable<typename basic_value<C, T, A>::table_type>
    >::value, bool>::type
operator>(const basic_value<C, T, A>& lhs, const basic_value<C, T, A>& rhs)
{
    return !(lhs <= rhs);
}
template<typename C, template<typename ...> class T, template<typename ...> class A>
typename std::enable_if<detail::conjunction<
    detail::is_comparable<typename basic_value<C, T, A>::array_type>,
    detail::is_comparable<typename basic_value<C, T, A>::table_type>
    >::value, bool>::type
operator>=(const basic_value<C, T, A>& lhs, const basic_value<C, T, A>& rhs)
{
    return !(lhs < rhs);
}

template<typename C, template<typename ...> class T, template<typename ...> class A>
inline std::string format_error(const std::string& err_msg,
        const basic_value<C, T, A>& v, const std::string& comment,
        std::vector<std::string> hints = {},
        const bool colorize = TOML11_ERROR_MESSAGE_COLORIZED)
{
    return detail::format_underline(err_msg, {{v.location(), comment}},
                                    std::move(hints), colorize);
}

template<typename C, template<typename ...> class T, template<typename ...> class A>
inline std::string format_error(const std::string& err_msg,
        const toml::basic_value<C, T, A>& v1, const std::string& comment1,
        const toml::basic_value<C, T, A>& v2, const std::string& comment2,
        std::vector<std::string> hints = {},
        const bool colorize = TOML11_ERROR_MESSAGE_COLORIZED)
{
    return detail::format_underline(err_msg, {
            {v1.location(), comment1}, {v2.location(), comment2}
        }, std::move(hints), colorize);
}

template<typename C, template<typename ...> class T, template<typename ...> class A>
inline std::string format_error(const std::string& err_msg,
        const toml::basic_value<C, T, A>& v1, const std::string& comment1,
        const toml::basic_value<C, T, A>& v2, const std::string& comment2,
        const toml::basic_value<C, T, A>& v3, const std::string& comment3,
        std::vector<std::string> hints = {},
        const bool colorize = TOML11_ERROR_MESSAGE_COLORIZED)
{
    return detail::format_underline(err_msg, {{v1.location(), comment1},
            {v2.location(), comment2}, {v3.location(), comment3}
        }, std::move(hints), colorize);
}

template<typename Visitor, typename C,
         template<typename ...> class T, template<typename ...> class A>
detail::return_type_of_t<Visitor, const toml::boolean&>
visit(Visitor&& visitor, const toml::basic_value<C, T, A>& v)
{
    switch(v.type())
    {
        case value_t::boolean        : {return visitor(v.as_boolean        ());}
        case value_t::integer        : {return visitor(v.as_integer        ());}
        case value_t::floating       : {return visitor(v.as_floating       ());}
        case value_t::string         : {return visitor(v.as_string         ());}
        case value_t::offset_datetime: {return visitor(v.as_offset_datetime());}
        case value_t::local_datetime : {return visitor(v.as_local_datetime ());}
        case value_t::local_date     : {return visitor(v.as_local_date     ());}
        case value_t::local_time     : {return visitor(v.as_local_time     ());}
        case value_t::array          : {return visitor(v.as_array          ());}
        case value_t::table          : {return visitor(v.as_table          ());}
        case value_t::empty          : break;
        default: break;
    }
    throw std::runtime_error(format_error("[error] toml::visit: toml::basic_value "
            "does not have any valid basic_value.", v, "here"));
}

template<typename Visitor, typename C,
         template<typename ...> class T, template<typename ...> class A>
detail::return_type_of_t<Visitor, toml::boolean&>
visit(Visitor&& visitor, toml::basic_value<C, T, A>& v)
{
    switch(v.type())
    {
        case value_t::boolean        : {return visitor(v.as_boolean        ());}
        case value_t::integer        : {return visitor(v.as_integer        ());}
        case value_t::floating       : {return visitor(v.as_floating       ());}
        case value_t::string         : {return visitor(v.as_string         ());}
        case value_t::offset_datetime: {return visitor(v.as_offset_datetime());}
        case value_t::local_datetime : {return visitor(v.as_local_datetime ());}
        case value_t::local_date     : {return visitor(v.as_local_date     ());}
        case value_t::local_time     : {return visitor(v.as_local_time     ());}
        case value_t::array          : {return visitor(v.as_array          ());}
        case value_t::table          : {return visitor(v.as_table          ());}
        case value_t::empty          : break;
        default: break;
    }
    throw std::runtime_error(format_error("[error] toml::visit: toml::basic_value "
            "does not have any valid basic_value.", v, "here"));
}

template<typename Visitor, typename C,
         template<typename ...> class T, template<typename ...> class A>
detail::return_type_of_t<Visitor, toml::boolean&&>
visit(Visitor&& visitor, toml::basic_value<C, T, A>&& v)
{
    switch(v.type())
    {
        case value_t::boolean        : {return visitor(std::move(v.as_boolean        ()));}
        case value_t::integer        : {return visitor(std::move(v.as_integer        ()));}
        case value_t::floating       : {return visitor(std::move(v.as_floating       ()));}
        case value_t::string         : {return visitor(std::move(v.as_string         ()));}
        case value_t::offset_datetime: {return visitor(std::move(v.as_offset_datetime()));}
        case value_t::local_datetime : {return visitor(std::move(v.as_local_datetime ()));}
        case value_t::local_date     : {return visitor(std::move(v.as_local_date     ()));}
        case value_t::local_time     : {return visitor(std::move(v.as_local_time     ()));}
        case value_t::array          : {return visitor(std::move(v.as_array          ()));}
        case value_t::table          : {return visitor(std::move(v.as_table          ()));}
        case value_t::empty          : break;
        default: break;
    }
    throw std::runtime_error(format_error("[error] toml::visit: toml::basic_value "
            "does not have any valid basic_value.", v, "here"));
}

}// toml
#endif// TOML11_VALUE

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 S3pt3mb3r

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
![cpp](https://img.shields.io/badge/C%2B%2B-17-%23ff40d9.svg?style=flat)
![cmake](https://img.shields.io/badge/cmake-3.16-yellow)
![Game](https://img.shields.io/badge/Game-CS%3AGO-blue.svg?style=flat)
![License](http://img.shields.io/badge/license-MIT-yellowgreen.svg?style=flat)

<!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section -->
[![All Contributors](https://img.shields.io/badge/all_contributors-3-orange.svg?style=flat-square)](#contributors-)
<!-- ALL-CONTRIBUTORS-BADGE:END -->

**[日本語版README](https://github.com/s3pt3mb3r/Dainsleif/blob/master/README_jp.md)**

[![Banner](https://user-images.githubusercontent.com/33578715/90916494-b9be7600-e413-11ea-8dee-ffea384afb2e.png)](https://github.com/s3pt3mb3r/Dainsleif)
Image's gifted by my big friend [@suzuharuR](https://twitter.com/suzuharuR)

# :zap: Dainsleif
**Please :star:star this project, it'll be a huge help for me =)**

This is an internal cheat for **_Counter-Strike: Global Offensive_** I've been working on as my training of reverse engineering.

**Disclaimer**: Since I don't intend to make this a malicious software, this isn't considered to be performed in multi player mode. 
**We won't take any responsibility if a problem occurs because of this software.** Keep that in mind.

As of today, Dainsleif is a quite simple and tiny cheat, so it'll be easy to read and understand. This software is published as MIT license in addition.

If you have any request or question, feel free to ask me through [issue](https://github.com/s3pt3mb3r/Dainsleif/issues). **Please be informed if your attitude is inappropriate, we would just tell you to piss off.**
 It may take a certain days because I'm doing this as completely my hobby without profit or reward, you know?
 
# development is suspended
This project will no longer get major update by @s3pt3mb3r due to loss of motivation, so don't expect further improvements.
It might be the exception if huge errors appeared tho. idk.
It's still open for pull requests, and issues.

# :two_hearts: Support me
Any sort of supports will be gratefully appreciated.
You can simply support me by either **starring this project**, **following me** or **sending PR to me**.

# :pushpin: Table of contents

- [:syringe: How to build this hack](#syringe-how-to-build-this-hack)
- [:rotating_light: TROUBLE SHOOTING](#rotating_light-trouble-shooting)
- [:scroll: Menu](#scroll-menu)
- [:computer: Hacks](#computer-hacks)
    - [Aimbot](#aimbot)
    - [Glow hack](#glow-hack)
    - [ESP hack](#esp-hack)
    - [Trigger bot](#trigger-bot)
    - [Anti recoil](#anti-recoil)
    - [Minimap hack](#minimap-hack)
    - [Anti AFK](#anti-afk)
    - [FOV](#fov)
- [:put_litter_in_its_place: Uninstall](#put_litter_in_its_place-uninstall)
- [:busts_in_silhouette: Contributors](#busts_in_silhouette-contributors)
- [:hammer_and_wrench: Features being developed](#hammer_and_wrench-features-being-developed)

# :syringe: How to build this hack

### requirement
- [DirectxSDK](https://www.microsoft.com/en-au/download/details.aspx?id=6812)
- Visual studio 2019

You can select from two ways to build this hack.
I believe all you need in order to build this project except DirectxSDK is already included which is [Minhook](https://github.com/TsudaKageyu/minhook), [ImGui](https://github.com/ocornut/imgui), and [toml11](https://github.com/ToruNiina/toml11).
They're in Dependencies directory.

### Build project

**>>>>> edit(February 23, 2022) <<<<<**

**Visit [Release](https://github.com/s3pt3mb3r/Dainsleif/releases) and download [Dainsleif v1.5](https://github.com/s3pt3mb3r/Dainsleif/releases/tag/v1.5), then build it with Visual Studio 2019 and its all done, ignore everything else below this. It's the easiest way to build this.**

If you have Visual Studio 2019, you must installed `Developer Command Prompt for Visual Studio` at the same time.
Launch it and go to any directory you wanna clone Dainsleif in, and run following commands.

```Shell
$ git clone https://github.com/s3pt3mb3r/Dainsleif.git --recursive
$ cd Dainsleif
```

For compiling the cheat, there is a convenient batch script that automates the process. All you need to do is run it:

```Shell
$ .\compile.bat
```

After finished compiling, `Dainsleif.dll` will be in the debug folder.

**Once you get the `Dainsleif.dll`, you can now inject it to the game with any DLL injector such as [GH injector](https://guidedhacking.com/resources/guided-hacking-dll-injector.4/) :)**

Needless to say, add `-insecure` flag in your launch option in order to taste this cheat without VAC scan. Otherwise you could get banned.

# :rotating_light: TROUBLE SHOOTING

**Something goes wrong? We've prepared [Wiki](https://github.com/s3pt3mb3r/Dainsleif/wiki/Trouble-shooting) for you :sunglasses:**

# :scroll: Menu

You're accessible to the hack menu by pressing <kbd>INSERT</kbd> key on your keyboard. (While the menu is open, input to CSGO will be locked)

You can toggle on/off and tweak parameters in the tabs with the name of each hack.

![Hack menu](https://user-images.githubusercontent.com/33578715/91472649-5aa4a980-e8ca-11ea-8352-21b6400a494b.gif)

You can choose what hacks to be visible with the menu bar.
Several hacks're set to invisible by default.
![menu visible](https://user-images.githubusercontent.com/33578715/91351549-0f7f8d80-e81b-11ea-9216-e7d77a0566d1.png)

# :computer: Hacks

## Aimbot

This is the feature I can guarantee the highest quality in the hacks I offer here.

Turning this function on automatically lets you aim at enemy's head with 100% precision.
It select the closest enemy from where your crosshair is as a target.

Tweaking Smoothness bar affects the smoothness of sticking aim.
By changing the value of the Range bar, you can change the range in which the aimbot will react

![aimbot](https://user-images.githubusercontent.com/33578715/89108283-b31e8d80-d469-11ea-8e55-e4e469d74576.gif)

## Glow hack

This feature allows you to see both opponents and teammate's outline through walls.

![Glow hack](https://user-images.githubusercontent.com/33578715/89087560-48b51100-d3c7-11ea-9ada-8ef04acfa52c.png)

## ESP hack

With this hack turned on:
- Red and green lines from player's foot position towards every enemies and allies are displayed.
- Outline rectangles are drawn on the players

![esp](https://user-images.githubusercontent.com/33578715/92253522-30726d80-ef02-11ea-80d3-fdb7045851d0.png)

## Trigger bot

Once you turn this on, you no longer have to press left click when you engage them.
This feature will complete the job for you.

This is designed to use in conjunction with Aimbot.

## Anti recoil

This is basically a recoil control system.
It automatically calculate the in comming recoil and manipulate your angle to handle it.
But this doesn't guarantee the 100% accuracy.

![Anti recoil](https://user-images.githubusercontent.com/33578715/89087634-769a5580-d3c7-11ea-83b1-dc31345e7424.png)

## Minimap hack

Minimap hack will show you all enemy positions on the mini map as a red dot even if they're not in your sight which would be super cool.

![Minimap hack](https://user-images.githubusercontent.com/33578715/96349413-0c4da300-10e2-11eb-8ba9-b1965b1a7dfb.png)

## Anti AFK

This feature basically make you move randomly every 50 seconds so that you probably not gonna get kicked automatically I guess.

## FOV

You can change your field of view from 60 to 120 degrees.

# :put_litter_in_its_place: Uninstall

Since this cheat creates some setting files, u have to follow this to clear things up.

All setting files are located at `C:\Users\Public\Documents\Dainsleif`, so delete this folder and you're good.
Of course don't forget to delete exe file itself.

# :busts_in_silhouette: Contributors

I couldn't have got this far without them ([emoji key](https://allcontributors.org/docs/en/emoji-key)):

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://github.com/l1m0n3"><img src="https://avatars1.githubusercontent.com/u/13360351?v=4?s=100" width="100px;" alt=""/><br /><sub><b>L1m0n3</b></sub></a><br /><a href="https://github.com/s3pt3mb3r/Dainsleif/commits?author=l1m0n3" title="Code">💻</a> <a href="#maintenance-l1m0n3" title="Maintenance">🚧</a></td>
    <td align="center"><a href="https://github.com/tomsa000"><img src="https://avatars2.githubusercontent.com/u/45645938?v=4?s=100" width="100px;" alt=""/><br /><sub><b>tomsa</b></sub></a><br /><a href="https://github.com/s3pt3mb3r/Dainsleif/commits?author=tomsa000" title="Code">💻</a> <a href="https://github.com/s3pt3mb3r/Dainsleif/issues?q=author%3Atomsa000" title="Bug reports">🐛</a> <a href="#ideas-tomsa000" title="Ideas, Planning, & Feedback">🤔</a></td>
    <td align="center"><a href="https://0xzeno.github.io/"><img src="https://avatars.githubusercontent.com/u/79898692?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Peter Hackersøn</b></sub></a><br /><a href="#maintenance-0xZeno" title="Maintenance">🚧</a> <a href="#ideas-0xZeno" title="Ideas, Planning, & Feedback">🤔</a></td>
  </tr>
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->

**Unintentional contributors:**

- [Osiris project](https://github.com/danielkrupinski/Osiris)
- [Hazedumper project](https://github.com/frk1/hazedumper)
- [Guided Hacking](https://guidedhacking.com)

```

`README_jp.md`:

```md
![cpp](https://img.shields.io/badge/C%2B%2B-17-%23ff40d9.svg?style=flat)
![cmake](https://img.shields.io/badge/cmake-3.16-yellow)
![Game](https://img.shields.io/badge/Game-CS%3AGO-blue.svg?style=flat)
![License](http://img.shields.io/badge/license-MIT-yellowgreen.svg?style=flat)

**[README in English](https://github.com/s3pt3mb3r/Dainsleif/blob/master/README.md)**

![Banner](https://user-images.githubusercontent.com/33578715/90953346-22056a00-e49d-11ea-9b63-56f33187e667.png)
この絵は僕の親友である[@suzuharuR](https://twitter.com/suzuharuR)から頂いたものです。

# :zap: Dainsleif

まず初めに、もしこのプロジェクトが気に入ったら **:star: 星 :star:** をつけてくださると幸いです。

Dainsleifは _Counter-Strike: Global Offensive_ 用のチートプログラムです。
ただし、これはあくまでも僕の個人的な知識欲で作っているものであって実戦(マルチプレイヤーモード)で使うことは想定されていません。
明示的な対策を行っているわけではないのでBANされる可能性が多分にあります。 **このソフトウェアによって発生したいかなる問題に対しても、開発者一同は責任を負いかねます。** 注意してご使用ください。
ただ、ボット戦で使うことは可能ですし、実際のチートと同じ手法で作られていてとてもシンプルなためコードの参考にはなるかと思います。

もしこのプロジェクトについて質問等ありましたら気軽に [issue](https://github.com/s3pt3mb3r/Dainsleif/issues) ください！
暇なのですぐ答えます。

# :two_hearts: サポート
このプロジェクトにStarする、このアカウントをフォローする、プルリクエストを送るなどしていただけるととても励みになります。

# :pushpin: 目次

- [:syringe: ビルド方法](#syringe-ビルド方法)
- [:rotating_light: トラブルシューティング](#rotating_light-トラブルシューティング)
- [:scroll: ハックメニュー](#scroll-ハックメニュー)
- [:computer: ハック](#computer-ハック)
    - [エイムボット](#エイムボットaimbot)
    - [発光ハック](#発光ハックglow-hack)
    - [ESPハック](#ESPハックesp)
    - [トリガーボット](#トリガーボットtrigger-bot)
    - [アンチリコイル](#アンチリコイルanti-recoil)
    - [ミニマップハック](#ミニマップハックminimap-hack)
    - [視野角調整](#視野角調整field-of-view)
    - [アンチ放置キック](#アンチ放置キックanti-afk)
- [:busts_in_silhouette: 共同開発者](#busts_in_silhouette-共同開発者)

# :syringe: ビルド方法

必要なもの
- [DirectxSDK](https://www.microsoft.com/en-au/download/details.aspx?id=6812)
- Visual Studio 2019

DirectxSDKとVisual Studio以外の必要なものはあらかじめ含まれているため用意する必要はありません。

Visual Studioをインストールした際に自動で追加される、Developer Command Prompt for Visual Studioを開いてください。

その上で、お好きなフォルダー内で以下のコマンドを実行してください。

```Shell
$ git clone https://github.com/s3pt3mb3r/Dainsleif.git --recursive
$ cd Dainsleif
```

ビルドに必要なコマンドをバッチファイルにまとめてあるので、あとはそれを叩けば自動でビルドしてくれます。

```Shell
$ .\compile.bat
```

これでdebugフォルダの中に`Dainsleif.dll` が生成されるはずです。

`Dainsleif.dll`を生成出来たら、あとは [GH injector](https://guidedhacking.com/resources/guided-hacking-dll-injector.4/) などのお好きなDLL injectorを使ってインジェクトしてください。

# :rotating_light: トラブルシューティング

ハックがうまく動きませんか？ 大丈夫です、そんなときのために[Wiki](https://github.com/s3pt3mb3r/Dainsleif/wiki/Trouble-shooting)を用意してあります。

# :scroll: ハックメニュー

ハックメニューへは<kbd>INSERT</kbd>キーを押すことでアクセスできます。

各タブを押すことで各ハックのオン/オフや細かい調整ができます。
調整項目はこれから増やしていく予定です。

![Hack menu](https://user-images.githubusercontent.com/33578715/89070761-09c39300-d3a8-11ea-9aac-18cf2749b622.gif)

メニューバーからタブのオンオフを切り替えることができます。
いくつかのハックはデフォルトでオフになっています。
![menu visible](https://user-images.githubusercontent.com/33578715/91351549-0f7f8d80-e81b-11ea-9216-e7d77a0566d1.png)

# :computer: ハック

## エイムボット (Aimbot)

これが、現在のDainsleifの機能の中で一番完成度が高いです。(自負)

この機能をオンにすると、クロスヘアから一番近い敵の頭にエイムが吸い付きます。
Smoothnessという項目を変えると、吸い付きのゆるふわ度を変えることができます。
Rangeの項目を変えると、エイムボットが反応する範囲を変えることができます。

![aimbot](https://user-images.githubusercontent.com/33578715/89108283-b31e8d80-d469-11ea-8e55-e4e469d74576.gif)

## 発光ハック (Glow hack)

この機能をオンにすると、敵と味方の輪郭が光り壁を通して見れるようになります。簡単に言うとウォールハックですね。

敵と味方の光る色はハックメニューから自由にカスタマイズできます。

![Glow hack](https://user-images.githubusercontent.com/33578715/89087560-48b51100-d3c7-11ea-9ada-8ef04acfa52c.png)

## ESPハック (Esp)

これはESPハックです。味方や敵に対して長方形のオーバーレイを表示します。

また、自分から各プレイヤーに対して直線を引きます。

![esp](https://user-images.githubusercontent.com/33578715/92253522-30726d80-ef02-11ea-80d3-fdb7045851d0.png)

## トリガーボット(Trigger bot)

これは、クロスヘアが敵と重なった瞬間に自動的に発砲するようになるハックです。

一応エイムボットと併用して使うことを想定してデザインされています。今後単体でも十分使えるように改良していきます。

## アンチリコイル(Anti recoil)

これは、銃を発砲する際などに発生するリコイルを自動で制御してくれるハックです。

ただ、100%完全に集弾するわけではありません。

実際のスプレー結果↓

![Anti recoil](https://user-images.githubusercontent.com/33578715/89087634-769a5580-d3c7-11ea-83b1-dc31345e7424.png)

## ミニマップハック(Minimap hack)

ミニマップハックは全ての敵をミニマップ上で赤点でとして表示してくれます。
通常のCSGOなら赤点は敵がプレイヤーの視野内に入った場合のみに表示されますが、このハックを使うと視野の外の敵や壁越しの敵を赤点で表示することができます。

![Minimap hack](https://user-images.githubusercontent.com/33578715/96349413-0c4da300-10e2-11eb-8ba9-b1965b1a7dfb.png)

## 視野角調整(Field of view)

このハックでは、本来変更できないプレイヤーの視野角を60～120まで調整できるようにするものです。

## アンチ放置キック(Anti AFK)

このハックをオンにすると、50秒ごとにプレイヤーを自動で動かすことによって放置キックされないようなります。

# :busts_in_silhouette: アンインストール

このチートは設定ファイルを生成するため、綺麗にアンインストールするには以下のフォルダを削除する必要があります。

`C:\Users\Public\Documents\Dainsleif`

もちろんexeファイル本体の削除もお忘れなく。

# :busts_in_silhouette: 共同開発者

彼なしでは間違いなくここまで来れませんでした。感謝します。 ([emoji key](https://allcontributors.org/docs/en/emoji-key)):

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://github.com/l1m0n3"><img src="https://avatars1.githubusercontent.com/u/13360351?v=4" width="100px;" alt=""/><br /><sub><b>L1m0n3</b></sub></a><br /><a href="https://github.com/s3pt3mb3r/Dainsleif/commits?author=l1m0n3" title="Code">💻</a> <a href="#maintenance-l1m0n3" title="Maintenance">🚧</a></td>
  </tr>
</table>

<!-- markdownlint-enable -->
<!-- prettier-ignore-end -->
<!-- ALL-CONTRIBUTORS-LIST:END -->

```

`compile.bat`:

```bat
mkdir build
cd build
cmake .. -A Win32
cmake --build .
dir debug
cd ..
```