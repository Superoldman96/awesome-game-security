Project Path: arc_gmh5225_CSGO-FindMDL_u5jnfu5i

Source Tree:

```txt
arc_gmh5225_CSGO-FindMDL_u5jnfu5i
├── FindMDL Hook
│   ├── CommonIncludes.h
│   ├── FindMDL Hook.vcxproj
│   ├── FindMDL Hook.vcxproj.filters
│   ├── FindMDL Hook.vcxproj.user
│   ├── Hooks.cpp
│   ├── Hooks.h
│   ├── IMDLCache.h
│   ├── Interfaces.cpp
│   ├── Interfaces.h
│   ├── Offsets.cpp
│   ├── Offsets.h
│   ├── Utilities.cpp
│   ├── Utilities.h
│   └── dllmain.cpp
├── FindMDL Hook.sln
├── README.md
└── thumbnail.png

```

`FindMDL Hook.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30804.86
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FindMDL Hook", "FindMDL Hook\FindMDL Hook.vcxproj", "{18C0D96B-0BCE-4465-9D1F-9858272706E2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{18C0D96B-0BCE-4465-9D1F-9858272706E2}.Debug|x64.ActiveCfg = Debug|x64
		{18C0D96B-0BCE-4465-9D1F-9858272706E2}.Debug|x64.Build.0 = Debug|x64
		{18C0D96B-0BCE-4465-9D1F-9858272706E2}.Debug|x86.ActiveCfg = Debug|Win32
		{18C0D96B-0BCE-4465-9D1F-9858272706E2}.Debug|x86.Build.0 = Debug|Win32
		{18C0D96B-0BCE-4465-9D1F-9858272706E2}.Release|x64.ActiveCfg = Release|x64
		{18C0D96B-0BCE-4465-9D1F-9858272706E2}.Release|x64.Build.0 = Release|x64
		{18C0D96B-0BCE-4465-9D1F-9858272706E2}.Release|x86.ActiveCfg = Release|Win32
		{18C0D96B-0BCE-4465-9D1F-9858272706E2}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C4242475-6134-4715-B7BF-7BBA37D4E778}
	EndGlobalSection
EndGlobal

```

`FindMDL Hook/CommonIncludes.h`:

```h
#pragma once

#include <Windows.h>
#include <cstdlib>
#include <cstdio>
#include <math.h>
#include <string>
#include <conio.h>
#include <vector>
```

`FindMDL Hook/FindMDL Hook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{18c0d96b-0bce-4465-9d1f-9858272706e2}</ProjectGuid>
    <RootNamespace>CSGOInternalCheating</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.18362.0</WindowsTargetPlatformVersion>
    <ProjectName>FindMDL Hook</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>D:\Other\Users\Yasin\Applications\Microsoft DirectX SDK\Include;$(IncludePath)</IncludePath>
    <LibraryPath>D:\Other\Users\Yasin\Applications\Microsoft DirectX SDK\Lib\x64;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);_CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <MultiProcessorCompilation>
      </MultiProcessorCompilation>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <ForcedIncludeFiles>
      </ForcedIncludeFiles>
      <DisableLanguageExtensions>false</DisableLanguageExtensions>
      <ConformanceMode>false</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <OptimizeReferences>false</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
      <AdditionalDependencies>d3d9.lib;d3dx9.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;FINDMDLHOOK_EXPORTS;_WINDOWS;_USRDLL;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;FINDMDLHOOK_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;FINDMDLHOOK_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="CommonIncludes.h" />
    <ClInclude Include="Hooks.h" />
    <ClInclude Include="IMDLCache.h" />
    <ClInclude Include="Interfaces.h" />
    <ClInclude Include="Offsets.h" />
    <ClInclude Include="Utilities.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="Hooks.cpp" />
    <ClCompile Include="Interfaces.cpp" />
    <ClCompile Include="Offsets.cpp" />
    <ClCompile Include="Utilities.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`FindMDL Hook/FindMDL Hook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\SDK">
      <UniqueIdentifier>{e39da851-8d9e-4afc-8f59-fcca812d6b79}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Interfaces.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CommonIncludes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Hooks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IMDLCache.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="Utilities.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utilities.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Interfaces.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Hooks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Offsets.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`FindMDL Hook/FindMDL Hook.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`FindMDL Hook/Hooks.cpp`:

```cpp
//Includes
#include "Hooks.h"
#include "Interfaces.h"
#include "Utilities.h"

typedef MDLHandle_t(__thiscall* iFindMdl)(void*, char*);
iFindMdl oFindMDL;
MDLHandle_t __fastcall hkFindMDL(void*, void*, char*);

//Hooks
namespace Hooks
{
	Utilities::Memory::VMTManager VMTModelCache;
};

//Hooks Initialise
void Hooks::Initialise()
{
	VMTModelCache.Initialise((DWORD*)Interfaces::ModelCache);  //Initialise ModelCache interfaces with VMTManager
	oFindMDL = (iFindMdl)VMTModelCache.HookMethod((DWORD)&hkFindMDL, 10); //Hooking FindMDL
}

//Custom Models
MDLHandle_t __fastcall hkFindMDL(void* ecx, void* edx, char* FilePath)
{
	if (strstr(FilePath, "knife_default_ct.mdl") || strstr(FilePath, "knife_default_t.mdl"))
	{
		sprintf(FilePath, "models/weapons/v_minecraft_pickaxe.mdl");
	}

	return oFindMDL(ecx, FilePath);
}
```

`FindMDL Hook/Hooks.h`:

```h
#pragma once

//Includes
#include "Utilities.h"

//Extern Hooks
namespace Hooks
{
	void Initialise();

	extern Utilities::Memory::VMTManager VMTModelCache;
};


```

`FindMDL Hook/IMDLCache.h`:

```h
#ifndef IMDLCACHE_H
#define IMDLCACHE_H

#ifdef _WIN32
#pragma once
#endif

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
struct studiohdr_t;
struct studiohwdata_t;
struct vcollide_t;
struct virtualmodel_t;
struct vertexFileHeader_t;

namespace OptimizedModel
{
	struct FileHeader_t;
}


//-----------------------------------------------------------------------------
// Reference to a loaded studiomdl 
//-----------------------------------------------------------------------------
typedef unsigned short MDLHandle_t;

enum
{
	MDLHANDLE_INVALID = (MDLHandle_t)~0
};


//-----------------------------------------------------------------------------
// Cache data types
//-----------------------------------------------------------------------------
enum MDLCacheDataType_t
{
	// Callbacks to get called when data is loaded or unloaded for these:
	MDLCACHE_STUDIOHDR = 0,
	MDLCACHE_STUDIOHWDATA,
	MDLCACHE_VCOLLIDE,

	// Callbacks NOT called when data is loaded or unloaded for these:
	MDLCACHE_ANIMBLOCK,
	MDLCACHE_VIRTUALMODEL,
	MDLCACHE_VERTEXES,
	MDLCACHE_DECODEDANIMBLOCK,
};

class IMDLCacheNotify
{
public:
	// Called right after the data is loaded
	virtual void OnDataLoaded(MDLCacheDataType_t type, MDLHandle_t handle) = 0;

	// Called right before the data is unloaded
	virtual void OnDataUnloaded(MDLCacheDataType_t type, MDLHandle_t handle) = 0;
};


//-----------------------------------------------------------------------------
// Flags for flushing
//-----------------------------------------------------------------------------
enum MDLCacheFlush_t
{
	MDLCACHE_FLUSH_STUDIOHDR = 0x01,
	MDLCACHE_FLUSH_STUDIOHWDATA = 0x02,
	MDLCACHE_FLUSH_VCOLLIDE = 0x04,
	MDLCACHE_FLUSH_ANIMBLOCK = 0x08,
	MDLCACHE_FLUSH_VIRTUALMODEL = 0x10,
	MDLCACHE_FLUSH_AUTOPLAY = 0x20,
	MDLCACHE_FLUSH_VERTEXES = 0x40,

	MDLCACHE_FLUSH_IGNORELOCK = 0x80000000,
	MDLCACHE_FLUSH_ALL = 0xFFFFFFFF
};

/*
#define MDLCACHE_INTERFACE_VERSION_4 "MDLCache004"
namespace MDLCacheV4
{
abstract_class IMDLCache : public IAppSystem
{
public:
// Used to install callbacks for when data is loaded + unloaded
virtual void SetCacheNotify( IMDLCacheNotify *pNotify ) = 0;
// NOTE: This assumes the "GAME" path if you don't use
// the UNC method of specifying files. This will also increment
// the reference count of the MDL
virtual MDLHandle_t FindMDL( const char *pMDLRelativePath ) = 0;
// Reference counting
virtual int AddRef( MDLHandle_t handle ) = 0;
virtual int Release( MDLHandle_t handle ) = 0;
// Gets at the various data associated with a MDL
virtual studiohdr_t *GetStudioHdr( MDLHandle_t handle ) = 0;
virtual studiohwdata_t *GetHardwareData( MDLHandle_t handle ) = 0;
virtual vcollide_t *GetVCollide( MDLHandle_t handle ) = 0;
virtual unsigned char *GetAnimBlock( MDLHandle_t handle, int nBlock ) = 0;
virtual virtualmodel_t *GetVirtualModel( MDLHandle_t handle ) = 0;
virtual int GetAutoplayList( MDLHandle_t handle, unsigned short **pOut ) = 0;
virtual vertexFileHeader_t *GetVertexData( MDLHandle_t handle ) = 0;
// Brings all data associated with an MDL into memory
virtual void TouchAllData( MDLHandle_t handle ) = 0;
// Gets/sets user data associated with the MDL
virtual void SetUserData( MDLHandle_t handle, void* pData ) = 0;
virtual void *GetUserData( MDLHandle_t handle ) = 0;
// Is this MDL using the error model?
virtual bool IsErrorModel( MDLHandle_t handle ) = 0;
// Flushes the cache, force a full discard
virtual void Flush( int nFlushFlags = MDLCACHE_FLUSH_ALL ) = 0;
// Flushes a particular model out of memory
virtual void Flush( MDLHandle_t handle, int nFlushFlags = MDLCACHE_FLUSH_ALL ) = 0;
// Returns the name of the model (its relative path)
virtual const char *GetModelName( MDLHandle_t handle ) = 0;
// faster access when you already have the studiohdr
virtual virtualmodel_t *GetVirtualModelFast( const studiohdr_t *pStudioHdr, MDLHandle_t handle ) = 0;
// all cache entries that subsequently allocated or successfully checked
// are considered "locked" and will not be freed when additional memory is needed
virtual void BeginLock() = 0;
// reset all protected blocks to normal
virtual void EndLock() = 0;
// returns a pointer to a counter that is incremented every time the cache has been out of the locked state (EVIL)
virtual int *GetFrameUnlockCounterPtr()  = 0;
// Finish all pending async operations
virtual void FinishPendingLoads() = 0;
};
}
*/

//-----------------------------------------------------------------------------
// The main MDL cacher
//-----------------------------------------------------------------------------
#define MDLCACHE_INTERFACE_VERSION "MDLCache004"

class IMDLCache
{
public:
	// Used to install callbacks for when data is loaded + unloaded
	// Returns the prior notify
	virtual void SetCacheNotify(IMDLCacheNotify* pNotify) = 0;

	// NOTE: This assumes the "GAME" path if you don't use
	// the UNC method of specifying files. This will also increment
	// the reference count of the MDL
	virtual MDLHandle_t FindMDL(const char* pMDLRelativePath) = 0;

	// Reference counting
	virtual int AddRef(MDLHandle_t handle) = 0;
	virtual int Release(MDLHandle_t handle) = 0;
	virtual int GetRef(MDLHandle_t handle) = 0;

	// Gets at the various data associated with a MDL
	virtual studiohdr_t* GetStudioHdr(MDLHandle_t handle) = 0;
	virtual studiohwdata_t* GetHardwareData(MDLHandle_t handle) = 0;
	virtual vcollide_t* GetVCollide(MDLHandle_t handle) = 0;
	virtual unsigned char* GetAnimBlock(MDLHandle_t handle, int nBlock) = 0;
	virtual virtualmodel_t* GetVirtualModel(MDLHandle_t handle) = 0;
	virtual int GetAutoplayList(MDLHandle_t handle, unsigned short** pOut) = 0;
	virtual vertexFileHeader_t* GetVertexData(MDLHandle_t handle) = 0;

	// Brings all data associated with an MDL into memory
	virtual void TouchAllData(MDLHandle_t handle) = 0;

	// Gets/sets user data associated with the MDL
	virtual void SetUserData(MDLHandle_t handle, void* pData) = 0;
	virtual void* GetUserData(MDLHandle_t handle) = 0;

	// Is this MDL using the error model?
	virtual bool IsErrorModel(MDLHandle_t handle) = 0;

	// Flushes the cache, force a full discard
	virtual void Flush(MDLCacheFlush_t nFlushFlags = MDLCACHE_FLUSH_ALL) = 0;

	// Flushes a particular model out of memory
	virtual void Flush(MDLHandle_t handle, int nFlushFlags = MDLCACHE_FLUSH_ALL) = 0;

	// Returns the name of the model (its relative path)
	virtual const char* GetModelName(MDLHandle_t handle) = 0;

	// faster access when you already have the studiohdr
	virtual virtualmodel_t* GetVirtualModelFast(const studiohdr_t* pStudioHdr, MDLHandle_t handle) = 0;

	// all cache entries that subsequently allocated or successfully checked 
	// are considered "locked" and will not be freed when additional memory is needed
	virtual void BeginLock() = 0;

	// reset all protected blocks to normal
	virtual void EndLock() = 0;

	// returns a pointer to a counter that is incremented every time the cache has been out of the locked state (EVIL)
	virtual int* GetFrameUnlockCounterPtrOLD() = 0;

	// Finish all pending async operations
	virtual void FinishPendingLoads() = 0;

	virtual vcollide_t* GetVCollideEx(MDLHandle_t handle, bool synchronousLoad = true) = 0;
	virtual bool GetVCollideSize(MDLHandle_t handle, int* pVCollideSize) = 0;

	virtual bool GetAsyncLoad(MDLCacheDataType_t type) = 0;
	virtual bool SetAsyncLoad(MDLCacheDataType_t type, bool bAsync) = 0;

	virtual void BeginMapLoad() = 0;
	virtual void EndMapLoad() = 0;
	virtual void MarkAsLoaded(MDLHandle_t handle) = 0;

	virtual void InitPreloadData(bool rebuild) = 0;
	virtual void ShutdownPreloadData() = 0;

	virtual bool IsDataLoaded(MDLHandle_t handle, MDLCacheDataType_t type) = 0;

	virtual int* GetFrameUnlockCounterPtr(MDLCacheDataType_t type) = 0;

	virtual studiohdr_t* LockStudioHdr(MDLHandle_t handle) = 0;
	virtual void UnlockStudioHdr(MDLHandle_t handle) = 0;

	virtual bool PreloadModel(MDLHandle_t handle) = 0;

	// Hammer uses this. If a model has an error loading in GetStudioHdr, then it is flagged
	// as an error model and any further attempts to load it will just get the error model.
	// That is, until you call this function. Then it will load the correct model.
	virtual void ResetErrorModelStatus(MDLHandle_t handle) = 0;

	virtual void MarkFrame() = 0;
};


//-----------------------------------------------------------------------------
// Critical section helper code
//-----------------------------------------------------------------------------
class CMDLCacheCriticalSection
{
public:
	CMDLCacheCriticalSection(IMDLCache *pCache) : m_pCache(pCache)
	{
		m_pCache->BeginLock();
	}

	~CMDLCacheCriticalSection()
	{
		m_pCache->EndLock();
	}

private:
	IMDLCache* m_pCache;
};

#define MDCACHE_FINE_GRAINED 1

#if defined(MDCACHE_FINE_GRAINED)
#define MDLCACHE_CRITICAL_SECTION_( pCache ) CMDLCacheCriticalSection cacheCriticalSection(pCache)
#define MDLCACHE_COARSE_LOCK_( pCache ) ((void)(0))
#elif defined(MDLCACHE_LEVEL_LOCKED)
#define MDLCACHE_CRITICAL_SECTION_( pCache )  ((void)(0))
#define MDLCACHE_COARSE_LOCK_( pCache ) ((void)(0))
#else
#define MDLCACHE_CRITICAL_SECTION_( pCache ) ((void)(0))
#define MDLCACHE_COARSE_LOCK_( pCache ) CMDLCacheCriticalSection cacheCriticalSection(pCache)
#endif
#define MDLCACHE_CRITICAL_SECTION() MDLCACHE_CRITICAL_SECTION_(mdlcache)
#define MDLCACHE_COARSE_LOCK() MDLCACHE_COARSE_LOCK_(mdlcache)

#endif // IMDLCACHE_H
```

`FindMDL Hook/Interfaces.cpp`:

```cpp
//Includes
#include "Interfaces.h"
#include "Utilities.h"

typedef void* (__cdecl* CreateInterface_t)(const char*, int*);
CreateInterface_t DataCaching = NULL;

//Interfaces
namespace Interfaces
{
	IMDLCache* ModelCache;
};

//Initialise Interfaces
void Interfaces::Initialise()
{
	DataCaching = (CreateInterface_t)GetProcAddress((HMODULE)Offsets::DataCaches, "CreateInterface"); //Getting the process address of the DataCaches offset

	char* pDataCache = (char*)Utilities::Memory::FindTextPattern("datacache.dll", "MDLCache00"); //Getting MDLCache00 memory address on "datacache.dll" module

	ModelCache = (IMDLCache*)DataCaching(pDataCache, NULL);
};
```

`FindMDL Hook/Interfaces.h`:

```h
#pragma once

//Includes
#include "CommonIncludes.h"
#include "IMDLCache.h"
#include "offsets.h"
#include "Interfaces.h"

//Extern Interfaces
namespace Interfaces
{
	void Initialise();

	extern IMDLCache* ModelCache;
};

```

`FindMDL Hook/Offsets.cpp`:

```cpp
#include "Offsets.h"

//Initialise Offsets
void Offsets::Initialise()
{
	DataCaches = Utilities::Memory::WaitOnModuleHandle("datacache.dll");
	dwLocalPlayer = 0xD882B;
};

//Offsets
namespace Offsets
{
	DWORD DataCaches;
	DWORD dwLocalPlayer;
}
```

`FindMDL Hook/Offsets.h`:

```h
#pragma once

//Includes
#include "CommonIncludes.h"
#include "Utilities.h"

//Extern Offsets
namespace Offsets
{
	void Initialise();

	extern DWORD DataCaches;
	extern DWORD dwLocalPlayer;
}
```

`FindMDL Hook/Utilities.cpp`:

```cpp
// Includes
#include "Utilities.h"
#include <fstream>
#include <Psapi.h>

//Utilities Memory
DWORD Utilities::Memory::WaitOnModuleHandle(std::string moduleName)
{
	DWORD ModuleHandle = NULL;
	while (!ModuleHandle)
	{
		ModuleHandle = (DWORD)GetModuleHandle(moduleName.c_str());
		if (!ModuleHandle)
			Sleep(50);
	}
	return ModuleHandle;
}
bool bCompare(const BYTE* Data, const BYTE* Mask, const char* szMask)
{
	for (; *szMask; ++szMask, ++Mask, ++Data)
	{
		if (*szMask == 'x' && *Mask != *Data)
		{
			return false;
		}
	}
	return (*szMask) == 0;
}
DWORD Utilities::Memory::FindPattern(std::string moduleName, BYTE* Mask, char* szMask)
{
	DWORD Address = WaitOnModuleHandle(moduleName.c_str());
	MODULEINFO ModInfo; GetModuleInformation(GetCurrentProcess(), (HMODULE)Address, &ModInfo, sizeof(MODULEINFO));
	DWORD Length = ModInfo.SizeOfImage;
	for (DWORD c = 0; c < Length; c += 1)
	{
		if (bCompare((BYTE*)(Address + c), Mask, szMask))
		{
			return (DWORD)(Address + c);
		}
	}
	return 0;
}
DWORD Utilities::Memory::FindTextPattern(std::string moduleName, char* string)
{
	DWORD Address = WaitOnModuleHandle(moduleName.c_str());
	MODULEINFO ModInfo; GetModuleInformation(GetCurrentProcess(), (HMODULE)Address, &ModInfo, sizeof(MODULEINFO));
	DWORD Length = ModInfo.SizeOfImage;

	int len = strlen(string);
	char* szMask = new char[len + 1];
	for (int i = 0; i < len; i++)
	{
		szMask[i] = 'x';
	}
	szMask[len] = '\0';

	for (DWORD c = 0; c < Length; c += 1)
	{
		if (bCompare((BYTE*)(Address + c), (BYTE*)string, szMask))
		{
			return (DWORD)(Address + c);
		}
	}
	return 0;
}

//VMT Manager
bool Utilities::Memory::VMTManager::Initialise(DWORD* InstancePointer)
{
	Instance = InstancePointer;
	OriginalTable = (DWORD*)*InstancePointer;
	int VMTSize = MethodCount(InstancePointer);
	size_t TableBytes = VMTSize * 4;

	CustomTable = (DWORD*)malloc(TableBytes + 8);
	if (!CustomTable) return false;
	memcpy((void*)CustomTable, (void*)OriginalTable, VMTSize * 4);

	*InstancePointer = (DWORD)CustomTable;

	initComplete = true;
	return true;
}
int	Utilities::Memory::VMTManager::MethodCount(DWORD* InstancePointer)
{
	DWORD* VMT = (DWORD*)*InstancePointer;
	int Index = 0;
	int Amount = 0;
	while (!IsBadCodePtr((FARPROC)VMT[Index]))
	{
		if (!IsBadCodePtr((FARPROC)VMT[Index]))
		{
			Amount++;
			Index++;
		}
	}

	return Amount;
}
DWORD Utilities::Memory::VMTManager::HookMethod(DWORD NewFunction, int Index)
{
	if (initComplete)
	{
		CustomTable[Index] = NewFunction;
		return OriginalTable[Index];
	}
	else
		return NULL;
}
void Utilities::Memory::VMTManager::UnhookMethod(int Index)
{
	if (initComplete)
		CustomTable[Index] = OriginalTable[Index];
	return;
}
void Utilities::Memory::VMTManager::RestoreOriginal()
{
	if (initComplete)
	{
		*Instance = (DWORD)OriginalTable;
	}
	return;
}
void Utilities::Memory::VMTManager::RestoreCustom()
{
	if (initComplete)
	{
		*Instance = (DWORD)CustomTable;
	}
	return;
}
DWORD Utilities::Memory::VMTManager::GetOriginalFunction(int Index)
{
	return OriginalTable[Index];
}
```

`FindMDL Hook/Utilities.h`:

```h
#pragma once

#include "CommonIncludes.h"
#include <time.h>

namespace Utilities
{
	namespace Memory
	{
		// Waits for a module to be available, before returning it's base address
		DWORD WaitOnModuleHandle(std::string moduleName);

		// Attempts to locate the given signature and mask in a memory range
		// Returns the address at which it has been found
		DWORD FindPattern(std::string moduleName, BYTE* Mask, char* szMask);

		// Attempts to locate the given text in a memory range
		// Returns the address at which it has been found
		DWORD FindTextPattern(std::string moduleName, char* string);

		class VMTManager
		{
		private:
			DWORD* CustomTable;
			bool	initComplete;
			DWORD* OriginalTable;
			DWORD* Instance;

			int		MethodCount(DWORD* InstancePointer);

		public:
			bool	Initialise(DWORD* InstancePointer); // Pass a &class

			DWORD	HookMethod(DWORD NewFunction, int Index);
			void	UnhookMethod(int Index);

			void	RestoreOriginal();
			void	RestoreCustom();

			template<typename T>
			T GetMethod(size_t nIndex)
			{
				return (T)OriginalTable[nIndex];
			}

			DWORD	GetOriginalFunction(int Index);
		};
	};
};

template<typename T>
FORCEINLINE T GetMethod(const void* instance, size_t index)
{
	uintptr_t* vmt = *(uintptr_t**)instance;

	return (T)vmt[index];
}


```

`FindMDL Hook/dllmain.cpp`:

```cpp
//Includes
#include <Windows.h>
#include "Utilities.h"
#include "Interfaces.h"
#include "Hooks.h"
#include "Offsets.h"

struct values {
    DWORD localPlayer;
    DWORD gameModule;
}value;

void main()
{
    Offsets::Initialise();
    Interfaces::Initialise();
    Hooks::Initialise();

    value.gameModule = (DWORD)GetModuleHandle("client.dll"); //Get "client.dll" module handle
    value.localPlayer = *(DWORD*)(value.gameModule + Offsets::dwLocalPlayer); //Get local player value 

    //Get local player value again if local player value is null
    if (value.localPlayer == NULL)
    {
        while (value.localPlayer == NULL)
        {
            value.localPlayer = *(DWORD*)(value.gameModule + Offsets::dwLocalPlayer);
        }
    }
}

//DLL Main
BOOL APIENTRY DllMain( HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    {
        DisableThreadLibraryCalls(hModule);
        CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)main, NULL, NULL, NULL);
    }
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```

`README.md`:

```md
# FindMDL Hook
This repository has a internal model changer with FindMDL Hook for Counter-Strike: Global Offensive game. It's fully open source and loadable into the game as a [Dynamic-link library (DLL)](https://en.wikipedia.org/wiki/Dynamic-link_library)

![](https://img.shields.io/badge/language-c++-e76089?style=plastic) ![](https://img.shields.io/badge/game-csgo-yellow?style=plastic) ![](https://img.shields.io/badge/license-GNU-green?style=plastic) ![](https://img.shields.io/badge/arch-x86-d9654f?style=plastic)

![Image of RequestX International Developer Group on Discord](https://github.com/Kruziikrel1/CSGO-FindMDL/blob/main/thumbnail.png)

## How to build FindMDL Hook Project files?
* First of all you should download project files on project page or clone this repository from GitBash or GitHub Desktop on your PC. [FindMDL.zip](https://github.com/Kruziikrel1/CSGO-FindMDL/releases/tag/v0.1)

* If you download project files with manual method you need extract zip file.

* Run .sln file on Visual Studio (2019+).

* Change build configuration to Debug | x86 and press Build button or press <kbd>CTRL+B</kbd> on your keyboard.

* Check out bin folder include that.

* Go to the bottom heading to add your custom models.

## How to load into the game?
* First download any [Dynamic-link library (DLL)](https://en.wikipedia.org/wiki/Dynamic-link_library) injector and open.

* Then select builded [Dynamic-link library (DLL)](https://en.wikipedia.org/wiki/Dynamic-link_library) file and Inject to csgo.exe

* That's all, enjoy it :)

## How to add your custom model?
* First go to "Hooks.cpp" in Source Files.

* Then go to hkFindMDL below the "Custom Models" comment line.

* Paste this code and read comment lines in this code.
```c++
if (strstr(FilePath, "v_.mdl"))  //v_: Name of the model to change
{
	sprintf(FilePath, "models/weapons/v_new_.mdl"); //v_new_: Name of the changing custom model: 
}
```

```