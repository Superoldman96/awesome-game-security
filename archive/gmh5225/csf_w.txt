Project Path: arc_gmh5225_csf_w_kpeslryd

Source Tree:

```txt
arc_gmh5225_csf_w_kpeslryd
├── LICENCE
├── README.md
├── csf_w
│   ├── csf_w.vcxproj
│   ├── csf_w.vcxproj.filters
│   ├── csf_w.vcxproj.user
│   ├── include
│   │   ├── cs
│   │   │   ├── cs_convar.h
│   │   │   ├── cs_engine.h
│   │   │   ├── cs_inputsystem.h
│   │   │   ├── cs_interfaces.h
│   │   │   ├── cs_netvars.h
│   │   │   ├── cs_player.h
│   │   │   └── cs_types.h
│   │   ├── u_config.h
│   │   └── u_process.h
│   └── src
│       ├── aimassist.cpp
│       ├── cs
│       │   ├── cs_convar.cpp
│       │   ├── cs_engine.cpp
│       │   ├── cs_inputsystem.cpp
│       │   ├── cs_interfaces.cpp
│       │   ├── cs_netvars.cpp
│       │   └── cs_player.cpp
│       ├── u_config.cpp
│       └── u_process.cpp
└── csf_w.sln

```

`LICENCE`:

```
free use for non commercial projects
credit me if you like.


```

`README.md`:

```md
# CSF_W32
##### external sdk for csgo
----
## usage
* git clone https://github.com/ekknod/csf_w.git
* cd csf_w
* open csf_w.sln and build
----
## features
* external interfaces
* external netvars
* external convars
----
## video
[![IMAGE ALT TEXT](https://i.ytimg.com/vi/P655rd45cQ8/maxresdefault.jpg)](https://www.youtube.com/watch?v=P655rd45cQ8a "linux csgo csf tutorial")
----
## licence
* free use for non commercial projects
* credit me if you like.

```

`csf_w.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.2041
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "csf_w", "csf_w\csf_w.vcxproj", "{BFDC1E5A-E046-4B80-90C6-7AD93AABCCCB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BFDC1E5A-E046-4B80-90C6-7AD93AABCCCB}.Debug|x64.ActiveCfg = Debug|x64
		{BFDC1E5A-E046-4B80-90C6-7AD93AABCCCB}.Debug|x64.Build.0 = Debug|x64
		{BFDC1E5A-E046-4B80-90C6-7AD93AABCCCB}.Debug|x86.ActiveCfg = Debug|Win32
		{BFDC1E5A-E046-4B80-90C6-7AD93AABCCCB}.Debug|x86.Build.0 = Debug|Win32
		{BFDC1E5A-E046-4B80-90C6-7AD93AABCCCB}.Release|x64.ActiveCfg = Release|x64
		{BFDC1E5A-E046-4B80-90C6-7AD93AABCCCB}.Release|x64.Build.0 = Release|x64
		{BFDC1E5A-E046-4B80-90C6-7AD93AABCCCB}.Release|x86.ActiveCfg = Release|Win32
		{BFDC1E5A-E046-4B80-90C6-7AD93AABCCCB}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9619F919-7443-4B76-8331-ECE16B3274BB}
	EndGlobalSection
EndGlobal

```

`csf_w/csf_w.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{BFDC1E5A-E046-4B80-90C6-7AD93AABCCCB}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>csfw</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="include\cs\cs_convar.h" />
    <ClInclude Include="include\cs\cs_engine.h" />
    <ClInclude Include="include\cs\cs_inputsystem.h" />
    <ClInclude Include="include\cs\cs_interfaces.h" />
    <ClInclude Include="include\cs\cs_netvars.h" />
    <ClInclude Include="include\cs\cs_player.h" />
    <ClInclude Include="include\cs\cs_types.h" />
    <ClInclude Include="include\u_config.h" />
    <ClInclude Include="include\u_process.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\aimassist.cpp" />
    <ClCompile Include="src\cs\cs_convar.cpp" />
    <ClCompile Include="src\cs\cs_engine.cpp" />
    <ClCompile Include="src\cs\cs_inputsystem.cpp" />
    <ClCompile Include="src\cs\cs_interfaces.cpp" />
    <ClCompile Include="src\cs\cs_netvars.cpp" />
    <ClCompile Include="src\cs\cs_player.cpp" />
    <ClCompile Include="src\u_config.cpp" />
    <ClCompile Include="src\u_process.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`csf_w/csf_w.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="include\u_process.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\cs\cs_convar.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\cs\cs_types.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\cs\cs_engine.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\cs\cs_inputsystem.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\cs\cs_interfaces.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\cs\cs_netvars.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\cs\cs_player.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\u_config.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\u_process.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\cs\cs_convar.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\cs\cs_engine.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\cs\cs_inputsystem.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\cs\cs_interfaces.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\cs\cs_netvars.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\cs\cs_player.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\u_config.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\aimassist.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`csf_w/csf_w.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`csf_w/include/cs/cs_convar.h`:

```h
#ifndef CS_CONVAR_H
#define CS_CONVAR_H

#include "cs_types.h"

class cs_convar {
    csptr_t self;
public:
    SHORT_STRING GetName(void);
    void         SetString(const char *v);
    void         SetInt(int v);
    void         SetFloat(float v);
    SHORT_STRING GetString(void);
    int          GetInt(void);
    float        GetFloat(void);
} ;

namespace cvar {

cs_convar find(const char *name);

}

#endif /* CS_CONVAR_H */


```

`csf_w/include/cs/cs_engine.h`:

```h
#ifndef CS_ENGINE_H
#define CS_ENGINE_H

#include "cs_interfaces.h"
#include "cs_netvars.h"
#include "cs_convar.h"
#include "cs_inputsystem.h"
#include "cs_player.h"

/*
 * initializes everything, must be called first
 */
bool cs_initialize(void);

namespace engine {
int       IsRunning(void);
int       GetLocalPlayer(void);
vec3      GetViewAngles(void);
void      SetViewAngles(vec3 v);
int       GetMaxClients(void);
bool      IsInGame(void);
}

namespace entity {
cs_player GetClientEntity(int index);
}

#endif /* CS_ENGINE_H */


```

`csf_w/include/cs/cs_inputsystem.h`:

```h
#ifndef CS_INPUTSYSTEM_H
#define CS_INPUTSYSTEM_H

#include "cs_types.h"

namespace inputsystem {
typedef enum _CS_BUTTONCODE : int {
    MOUSE_1 = 107,
    MOUSE_2 = 108,
    MOUSE_3 = 109,
    MOUSE_4 = 110,
    MOUSE_5 = 111
} CS_BUTTONCODE ;
bool  IsButtonDown(CS_BUTTONCODE button);
vec2i GetMouseAnalog(void);
vec2i GetMouseAnalogDelta(void);
}

#endif /* CS_INPUTSYSTEM_H */


```

`csf_w/include/cs/cs_interfaces.h`:

```h
#ifndef CS_INTERFACES_H
#define CS_INTERFACES_H

#include "cs_types.h"

class cs_virtual_table {
    csptr_t self;
public:
    csptr_t address(void) const;
    csptr_t function(int index);
};

class cs_interface_reg {
    csptr_t self;
public:
    cs_virtual_table find(const char *name);
};

namespace interfaces {
cs_interface_reg find(const wchar_t *module_name);
}

#endif /* CS_INTERFACES_H */


```

`csf_w/include/cs/cs_netvars.h`:

```h
#ifndef CS_NETVARS_H
#define CS_NETVARS_H

#include "cs_types.h"

class cs_netvar_table {
    csptr_t self;
public:
    uint32_t offset(const char *name);
private:
    uint32_t offset_ex(csptr_t, const char *);
} ;

namespace netvars {
cs_netvar_table find(const char *name);
}

#endif /* CS_NETVARS_H */


```

`csf_w/include/cs/cs_player.h`:

```h
#ifndef CS_PLAYER_H
#define CS_PLAYER_H

#include "cs_types.h"

class cs_player {
    csptr_t self;
public:
    int     GetTeam(void);
    int     GetHealth(void);
    int     GetLifeState(void);
    int     GetTickCount(void);
    int     GetShotsFired(void);
    bool    IsScoped(void);
    bool    IsDormant(void);
    csptr_t GetWeapon(void);
    vec3    GetOrigin(void);
    vec3    GetVecView(void);
    vec3    GetEyePos(void);
    vec3    GetVecVelocity(void);
    vec3    GetVecPunch(void);
    int     GetFov(void);
    void    GetBoneMatrix(int index, matrix3x4_t *out);
    bool    IsValid(void);
} ;

#endif /* CS_PLAYER_H */


```

`csf_w/include/cs/cs_types.h`:

```h
#ifndef CS_TYPES_H
#define CS_TYPES_H

#include <inttypes.h>

#ifdef _WIN32
typedef unsigned int csptr_t;
#else
typedef uintptr_t csptr_t;
#endif

typedef struct {
    char value[120];
} SHORT_STRING ;

typedef struct {
    char value[260];
} LONG_STRING ;

typedef struct {
    float x, y, z;
} vec3 ;

typedef struct {
    int x, y;
} vec2i ;

typedef float matrix3x4_t[3][4];

#endif /* CS_TYPES_H */


```

`csf_w/include/u_config.h`:

```h
#ifndef U_CONFIG_H
#define U_CONFIG_H

#ifndef _FILE_DEFINED
#define _FILE_DEFINED
typedef struct _iobuf
{
    void* _Placeholder;
} FILE;
#endif /* _FILE_DEFINED */

class u_config {
    const char *_path;
    FILE       *_fd;
public:
    u_config(const char *path);
    ~u_config(void);
    bool           exists(void);
    void           open_config(const char *mode);
    void           close_config(void);
    void           write_config(void *buffer, size_t length);
    int            GetInt(const char *name);
    float          GetFloat(const char *name);
private:
    bool           SetPos(const char *name);
    bool           GetVal(const char *name, char buffer[32]);
} ;

#endif /* U_CONFIG_H */


```

`csf_w/include/u_process.h`:

```h
#ifndef U_PROCESS_H
#define U_PROCESS_H

#include <inttypes.h>

typedef void *HANDLE, *PVOID;
typedef long NTSTATUS;

class u_process {
    const wchar_t *_name;
    HANDLE        _handle;
    bool          _wow64;
    uintptr_t     _peb;
public:
    u_process(const wchar_t *name) : _name(name), _handle(0) {}
    ~u_process(void) { detach(); }

    bool      attach(void);
    void      detach(void);
    bool      exists(void);
    uintptr_t find_module(const wchar_t *name);
    uintptr_t find_export(uintptr_t module, const char *name);
    NTSTATUS  read(uintptr_t address, void *buffer, size_t length);
    NTSTATUS  write(uintptr_t address, void *buffer, size_t length);
    template<typename t>
    inline t read(uintptr_t address)
    {
        t v;
        read(address, &v, sizeof(t));
        return v;
    }
    template<typename t>
    inline t read_ptr(uintptr_t address)
    {
        return read<t>(read<uintptr_t>(address));
    }
    template<typename t>
    inline t read_ptr32(uintptr_t address)
    {
        return read<t>(read<uint32_t>(address));
    }

    template<typename t>
    inline void write(uintptr_t address, t value)
    {
        write(address, &value, sizeof(t));
    }
    template <typename t>
    inline void write_ptr(uintptr_t address, t value)
    {
        write<t>(read<uintptr_t>(address), value);
    }
    template <typename t>
    inline void write_ptr32(uintptr_t address, t value)
    {
        write<t>(read<uint32_t>(address), value);
    }
} ;

#endif /* U_PROCESS_H */


```

`csf_w/src/aimassist.cpp`:

```cpp
#include "../include/u_config.h"
#include "../include/cs/cs_engine.h"
#include <stdio.h>
#include <string.h>
#include <math.h>

extern "C"
{
typedef int BOOL;
#define NTAPI __stdcall
#define WINAPI __stdcall
#define DECLSPEC_IMPORT __declspec(dllimport)
DECLSPEC_IMPORT void WINAPI Sleep(uint32_t);
DECLSPEC_IMPORT void WINAPI mouse_event(uint32_t, uint32_t, uint32_t, uint32_t, uintptr_t);
}

class config {
    const char *_path;
public:
    struct {
        bool                       enable;
        inputsystem::CS_BUTTONCODE button;
        float                      fov;
        float                      smooth;
    } aimbot ;

    struct {
        bool                       enable;
        inputsystem::CS_BUTTONCODE button;
    } triggerbot ;

    config(const char *path) : _path(path)
    {
        u_config c(path);

        if (!c.exists()) {
            aimbot.enable     = true;
            aimbot.button     = inputsystem::MOUSE_1;
            aimbot.fov        = 2.0f / 180.0f;
            aimbot.smooth     = 2.0f;
            triggerbot.enable = true;
            triggerbot.button = inputsystem::MOUSE_5;
            update();
        } else {
            c.open_config("r");
            aimbot.enable     = c.GetInt("aimbot::enable");
            aimbot.button     = (inputsystem::CS_BUTTONCODE)c.GetInt("aimbot::button");
            aimbot.fov        = c.GetFloat("aimbot::fov") / 180.0f;
            aimbot.smooth     = c.GetFloat("aimbot::smooth");
            triggerbot.enable = c.GetInt("triggerbot::enable");
            triggerbot.button = (inputsystem::CS_BUTTONCODE)c.GetInt("triggerbot::button");
            c.close_config();
        }
        // casts between pointers / enums, really c++ :DDDDDDDDD
    }
    ~config(void)
    {
        if ( exists() ) {
            update();
        }
    }
    inline bool exists(void)
    {
        return u_config(_path).exists();
    }
    inline void update(void)
    {
        u_config c(_path);
        int  length;
        char buffer[512];

        aimbot.fov *= 180.0f;
        length = snprintf(
            buffer,
            sizeof(buffer),
            "aimbot::enable:     %i\n"
            "aimbot::button:     %i\n"
            "aimbot::fov:        %f\n"
            "aimbot::smooth:     %f\n\n"
            "triggerbot::enable: %i\n"
            "triggerbot::button: %i\n\n",
            aimbot.enable,
            aimbot.button,
            aimbot.fov,
            aimbot.smooth,
            triggerbot.enable,
            triggerbot.button
            ) ;
        aimbot.fov /= 180.0f;
        c.open_config("w");
        c.write_config(buffer, length);
        c.close_config();
    }
    inline void print(void)
    {
        aimbot.fov *= 180.0f;
        printf(
            "aimbot::enable:     %i\n"
            "aimbot::button:     %i\n"
            "aimbot::fov:        %f\n"
            "aimbot::smooth:     %f\n\n"
            "triggerbot::enable: %i\n"
            "triggerbot::button: %i\n\n",
            aimbot.enable,
            aimbot.button,
            aimbot.fov,
            aimbot.smooth,
            triggerbot.enable,
            triggerbot.button
            );
        aimbot.fov /= 180.0f;
    }
} ;


static config      _cfg("config.cfg");
static cs_player   _target;
static cs_convar   _sensitivity;
static cs_convar   _mp_teammates_are_enemies;
static float       _flsensitivity;
static int         _current_tick, _previous_tick;

static void sincos(float radians, float *sine, float *cosine)
{
    *sine = (float)sin(radians);
    *cosine = (float)cos(radians);
}

#define RAD2DEG(x) ((float)(x) * (float)(180.f / 3.14159265358979323846f))
#define DEG2RAD(x) ((float)(x) * (float)(3.14159265358979323846f / 180.f))

static void angle_vec(vec3 angles, vec3 *forward)
{
    float sp, sy, cp, cy;
    sincos(DEG2RAD(angles.x), &sp, &cp);
    sincos(DEG2RAD(angles.y), &sy, &cy);
    forward->x = cp * cy;
    forward->y = cp * sy;
    forward->z = -sp;
}

static float vec_dot(vec3 v0, vec3 v1)
{
    return (v0.x * v1.x + v0.y * v1.y + v0.z * v1.z);
}

static float vec_length(vec3 v)
{
    return (v.x * v.x + v.y * v.y + v.z * v.z);
}

static vec3 vec_sub(vec3 p0, vec3 p1)
{
    vec3 r;

    r.x = p0.x - p1.x;
    r.y = p0.y - p1.y;
    r.z = p0.z - p1.z;
    return r;
}

static float vec_length_sqrt(vec3 p0)
{
    return ( float )sqrt(p0.x * p0.x + p0.y * p0.y + p0.z * p0.z);
}

static vec3 vec_delta(vec3 p0, vec3 p1)
{
    vec3  d;
    float l;

    d   = vec_sub(p0, p1);
    l   = (float)vec_length_sqrt(d);
    d.x /= l; d.y /= l; d.z /= l;
    return d;
}

static float vec_distance(vec3 p0, vec3 p1)
{
    return vec_length_sqrt( vec_sub(p0, p1) ) ;
}

static void vec_clamp(vec3 *v)
{
    if ( v->x > 89.0f && v->x <= 180.0f ) {
        v->x = 89.0f;
    }
    if ( v->x > 180.0f ) {
        v->x = v->x - 360.0f;
    }
    if( v->x < -89.0f ) {
        v->x = -89.0f;
    }
    v->y = fmodf(v->y + 180, 360) - 180;
    v->z = 0;
}

static void vec_normalize(vec3 *vec)
{
    float radius;

    radius = 1.f / (float)(sqrt(vec->x*vec->x + vec->y*vec->y + vec->z*vec->z) + 1.192092896e-07f);
    vec->x *= radius, vec->y *= radius, vec->z *= radius;
}

static vec3 vec_transform(vec3 p0, matrix3x4_t p1)
{
    vec3 v;

    v.x = (p0.x * p1[0][0] + p0.y * p1[0][1] + p0.z * p1[0][2]) + p1[0][3];
    v.y = (p0.x * p1[1][0] + p0.y * p1[1][1] + p0.z * p1[1][2]) + p1[1][3];
    v.z = (p0.x * p1[2][0] + p0.y * p1[2][1] + p0.z * p1[2][2]) + p1[2][3];
    return v;
}

vec3 vec_atd(vec3 vangle)
{
    double y[2], p[2];

    vangle.x *= (3.14159265358979323846f / 180.f);
    vangle.y *= (3.14159265358979323846f / 180.f);
    y[0]     = sin(vangle.y), y[1] = cos(vangle.y);
    p[0]     = sin(vangle.x), p[1] = cos(vangle.x);
    vangle.x = (float)(p[1] * y[1]);
    vangle.y = (float)(p[1] * y[0]);
    vangle.z = (float)-p[0];
    return vangle;
}

typedef struct {
    int   bone;
    float radius;
    vec3  min;
    vec3  max;
} HITBOX ;

static HITBOX _hitbox_list[2][6] = {
    {
        {5, 6.200000f, {4.800000f,  0.150000f,  -4.100000f}, {4.800000f,  0.150000f, 4.100000f}},
        {4, 6.500000f, {3.800000f,  0.800000f,  -2.400000f}, {3.800000f,  0.400000f, 2.400000f}},
        {3, 6.000000f, {1.400000f,  0.800000f,  3.100000f},  {1.400000f,  0.800000f, -3.100000f}},
        {0, 6.000000f, {-2.700000f, 1.100000f,  -3.200000f}, {-2.700000f, 1.100000f, 3.200000f}},
        {7, 3.500000f, {-1.300000f, -0.200000f, 0.000000f},  {1.400000f,  0.600000f, 0.000000f}},
        {8, 4.300000f, {-1.100000f, 1.400000f,  0.100000f},  {3.000000f,  0.800000f, 0.100000f}}
    },

    {
        {5, 6.200000f, {4.800000f,  0.150000f,  -4.100000f}, {4.800000f,  0.150000f, 4.100000f}},
        {4, 6.500000f, {3.800000f,  0.800000f,  -2.400000f}, {3.800000f,  0.400000f, 2.400000f}},
        {3, 6.000000f, {1.400000f,  0.800000f,  3.100000f},  {1.400000f,  0.800000f, -3.100000f}},
        {0, 6.000000f, {-2.700000f, 1.100000f,  -3.200000f}, {-2.700000f, 1.100000f, 3.200000f}},
        {7, 3.500000f, {-1.300000f, 0.900000f,  0.000000f},  {1.400000f,  1.300000f, 0.000000f}},
        {8, 3.200000f, {-0.200000f, 1.100000f,  0.000000f},  {3.600000f,  0.100000f, 0.000000f}}
    }
};

static bool vec_min_max(vec3 eye, vec3 dir, vec3 min, vec3 max, float radius)
{
    vec3     delta;
    uint32_t i;
    vec3     q;
    float    v;


    //
    // original maths by superdoc1234
    //
    delta = vec_delta(max, min);
    for ( i = 0; i < vec_distance(min, max); i++ ) {
        q.x = min.x + delta.x * (float)i - eye.x;
        q.y = min.y + delta.y * (float)i - eye.y;
        q.z = min.z + delta.z * (float)i - eye.z;
        if ((v = vec_dot(q, dir)) < 1.0f) {
            return false;
        }
        v = radius * radius - (vec_length(q) - v * v);

        if ( v <= -100.f ) {
            return false;
        }
        if (v >= 1.19209290E-07F) {
            return true;
        }
    }
    return false;
}

static int crosshair_id(vec3 vangle, cs_player self)
{
    vec3        dir, eye;
    int         i;
    cs_player   entity;
    int         id, j;
    matrix3x4_t matrix;
    bool        status;


    dir = vec_atd(vangle);
    eye = self.GetEyePos();
    for (i = 1; i < engine::GetMaxClients(); i++) {
        entity = entity::GetClientEntity(i);
        if (!entity.IsValid())
            continue;
        
        id = entity.GetTeam();
        if (!_mp_teammates_are_enemies.GetInt() && self.GetTeam() == id)
            continue;
        id -= 2;
        for (j = 6; j-- ;) {
            entity.GetBoneMatrix(_hitbox_list[id][j].bone, &matrix);
            status = vec_min_max(
                eye,
                dir,
                vec_transform(_hitbox_list[id][j].min, matrix),
                vec_transform(_hitbox_list[id][j].max, matrix),
                _hitbox_list[id][j].radius
                ) ;

            if (status) {
                return i;
            }
        }
    }
    return 0;
}

static void vec_angles(vec3 forward, vec3 *angles)
{
    float tmp, yaw, pitch;

    if (forward.y == 0.f && forward.x == 0.f) {
        yaw = 0;
        if (forward.z > 0) {
            pitch = 270;
        } else {
            pitch = 90.f;
        }
    } else {
        yaw = (float)(atan2(forward.y, forward.x) * 180.f / 3.14159265358979323846f);
        if (yaw < 0) {
            yaw += 360.f;
        }
        tmp = (float)sqrt(forward.x * forward.x + forward.y * forward.y);
        pitch = (float)(atan2(-forward.z, tmp) * 180.f / 3.14159265358979323846f);
        if (pitch < 0) {
            pitch += 360.f;
        }
    }
    angles->x = pitch;
    angles->y = yaw;
    angles->z = 0.f;
}

static float get_fov(vec3 vangle, vec3 angle)
{
    vec3 a0, a1;

    angle_vec(vangle, &a0);
    angle_vec(angle, &a1);
    return RAD2DEG(acos(vec_dot(a0, a1) / vec_length(a0)));
}

static vec3 get_target_angle(cs_player self, cs_player target)
{
    matrix3x4_t m;
    vec3        c, p;

    target.GetBoneMatrix(8, &m);
    c = self.GetEyePos();
    m[0][3] -= c.x, m[1][3] -= c.y, m[2][3] -= c.z;
    c.x = m[0][3], c.y = m[1][3], c.z = m[2][3];
    vec_normalize(&c);
    vec_angles(c, &c);
    if (self.GetShotsFired() > 1) {
        p = self.GetVecPunch();
        c.x -= p.x * 2.0f, c.y -= p.y * 2.0f, c.z -= p.z * 2.0f;
    }
    vec_clamp(&c);
    return c;
}

static bool get_target(cs_player self, vec3 vangle)
{
    float     best_fov;
    int       i;
    cs_player entity;
    float     fov;

    best_fov = 9999.0f;
    for (i = 1; i < engine::GetMaxClients(); i++) {
        entity = entity::GetClientEntity(i);
        if (!entity.IsValid())
            continue;
        if (!_mp_teammates_are_enemies.GetInt() && self.GetTeam() == entity.GetTeam())
            continue;
        fov = get_fov(vangle, get_target_angle(self, entity));
        if (fov < best_fov) {
            best_fov = fov;
            _target  = entity;
        }
    }
    return best_fov != 9999.0f;
}

static void mouse_move(int x, int y)
{
    mouse_event(0x0001, x, y, 0, 0);
}

static void mouse1_down(void)
{
    mouse_event(0x0002, 0, 0, 0, 0);
}

static void mouse1_up(void)
{
    mouse_event(0x0004, 0, 0, 0, 0);
}

static void aim_at_target(vec3 vangle, vec3 angle)
{
    float x, y, sx, sy;


    y = vangle.x - angle.x, x = vangle.y - angle.y;
    if (y > 89.0f)   y = 89.0f;   else if (y < -89.0f)  y = -89.0f;
    if (x > 180.0f)  x -= 360.0f; else if (x < -180.0f) x += 360.0f;

    if (fabs(x) / 180.0f >= _cfg.aimbot.fov)
        return;
    if (fabs(y) / 89.0f >= _cfg.aimbot.fov)
        return;
    x = ((x / _flsensitivity) / 0.022f);
    y = ((y / _flsensitivity) / -0.022f);
    if (_cfg.aimbot.smooth) {
        sx = 0.0f, sy = 0.0f;
        if (sx < x) {
            sx += 1.0f + (x / _cfg.aimbot.smooth);
        } else if (sx > x) {
            sx -= 1.0f - (x / _cfg.aimbot.smooth);
        }
        if (sy < y) {
            sy += 1.0f + (y / _cfg.aimbot.smooth);
        } else if (sy > y) {
            sy -= 1.0f - (y / _cfg.aimbot.smooth);
        }
    } else {
        sx = x, sy = y;
    }
    if ( _current_tick - _previous_tick > 0 ) {
        _previous_tick = _current_tick;
        mouse_move((int)sx, (int)sy);
    }
}

static void aim(void)
{
    cs_player self;
    vec3      vangle;
    bool      a;


    self           = entity::GetClientEntity(engine::GetLocalPlayer());
    vangle         = engine::GetViewAngles();
    _current_tick  = self.GetTickCount();
    _flsensitivity = _sensitivity.GetFloat();
    if (self.IsScoped()) {
        _flsensitivity = (self.GetFov() / 90.0f) * _flsensitivity;
    }
    if (_cfg.triggerbot.enable && inputsystem::IsButtonDown(_cfg.triggerbot.button)) {
        a = false;
        if (crosshair_id(vangle, self)) {
            mouse1_down();
            Sleep(1);
            mouse1_up();
        }
    } else {
        a = true;
    }
    if (_cfg.aimbot.enable) {

        if (a == true && inputsystem::IsButtonDown(_cfg.aimbot.button)) {
            if (!_target.IsValid() && !get_target(self, vangle))
                return;
            aim_at_target(vangle, get_target_angle(self, _target));
        } else {
            _target = {};
        }
    }
}

int main(int argc, char **argv)
{
    if (!cs_initialize()) {
        printf("[!]game is not running!\n");
        return -1;
    }
    _sensitivity              = cvar::find("sensitivity");
    _mp_teammates_are_enemies = cvar::find("mp_teammates_are_enemies");
    while (engine::IsRunning()) {
        if (engine::IsInGame()) {
            aim();
        }
    }
}


```

`csf_w/src/cs/cs_convar.cpp`:

```cpp
#include "../../include/cs/cs_convar.h"
#include "../../include/cs/cs_interfaces.h"
#include "../../include/u_process.h"
#include <string.h>

extern u_process        cs_p;
extern cs_virtual_table cs_vt_cvar;

SHORT_STRING cs_convar::GetName(void)
{
    return cs_p.read_ptr32<SHORT_STRING>(self + 0xC);
}

void cs_convar::SetString(const char *v)
{
    SHORT_STRING a0;
    memcpy(&a0, v, strlen(v));
    cs_p.write_ptr<SHORT_STRING>(self + 0x24, a0);
}

void cs_convar::SetInt(int v)
{
    cs_p.write<uint32_t>(self + 0x30, v ^ self);
}

void cs_convar::SetFloat(float v)
{
    cs_p.write<uint32_t>(self + 0x2C, *(uint32_t*)&v ^ self);
}

SHORT_STRING cs_convar::GetString(void)
{
    return cs_p.read_ptr32<SHORT_STRING>(self + 0x24);
}

int cs_convar::GetInt(void)
{
    return cs_p.read<int>(self + 0x30) ^ self;
}

float cs_convar::GetFloat(void)
{
    uint32_t v;
    v = cs_p.read<uint32_t>(self + 0x2C) ^ self;
    return *(float*)&v;
}

cs_convar cvar::find(const char *name)
{
    csptr_t a0;

    a0 = cs_p.read_ptr32<csptr_t>(cs_vt_cvar.address() + 0x34);
    while ( (a0 = cs_p.read<csptr_t>(a0 + 0x4)) ) {
        if (!strcmp(name, cs_p.read_ptr32<SHORT_STRING>(a0 + 0xc).value)) {
            return *(cs_convar*)&a0;
        }
    }
    return {};
}


```

`csf_w/src/cs/cs_engine.cpp`:

```cpp
#include "../../include/cs/cs_engine.h"
#include "../../include/u_process.h"
#include <stdio.h>

u_process        cs_p(L"csgo.exe");
cs_virtual_table cs_vt_client;
cs_virtual_table cs_vt_entity;
cs_virtual_table cs_vt_engine;
cs_virtual_table cs_vt_cvar;
cs_virtual_table cs_vt_inputsystem;
csptr_t          cs_nv_dwEntityList;
csptr_t          cs_nv_dwClientState;
uint32_t         cs_nv_m_dwGetLocalPlayer;
uint32_t         cs_nv_m_dwViewAngles;
uint32_t         cs_nv_m_dwMaxClients;
uint32_t         cs_nv_m_dwState;
uint32_t         cs_nv_m_dwButton;
uint32_t         cs_nv_m_dwAnalogDelta;
uint32_t         cs_nv_m_dwAnalog;
uint32_t         cs_nv_m_iHealth;
uint32_t         cs_nv_m_vecViewOffset;
uint32_t         cs_nv_m_lifeState;
uint32_t         cs_nv_m_nTickBase;
uint32_t         cs_nv_m_vecVelocity;
uint32_t         cs_nv_m_vecPunch;
uint32_t         cs_nv_m_iFOV;
uint32_t         cs_nv_m_iTeamNum;
uint32_t         cs_nv_m_vecOrigin;
uint32_t         cs_nv_m_hActiveWeapon;
uint32_t         cs_nv_m_iShotsFired;
uint32_t         cs_nv_m_bIsScoped;
uint32_t         cs_nv_m_dwBoneMatrix;

static void initialize_vt(void);
static void initialize_nv(void);

bool cs_initialize(void)
{
    if (!cs_p.attach()) {
        return false;
    }
    initialize_vt();
    initialize_nv();

    printf(
        "[*]vtables:\n"
        "    VClient:                         0x%lx\n"
        "    VClientEntityList:               0x%lx\n"
        "    VEngineClient:                   0x%lx\n"
        "    VEngineCvar:                     0x%lx\n"
        "    InputSystemVersion:              0x%lx\n"
        "[*]offsets:\n"
        "    dwEntityList:                    0x%lx\n"
        "    dwClientState:                   0x%lx\n"
        "    m_dwGetLocalPlayer:              0x%x\n"
        "    m_dwViewAngles:                  0x%x\n"
        "    m_dwMaxClients:                  0x%x\n"
        "    m_dwState:                       0x%x\n"
        "    m_dwButton:                      0x%x\n"
        "    m_dwAnalog:                      0x%x\n"
        "    m_dwAnalogDelta:                 0x%x\n"
        "[*]netvars:\n"
        "    DT_BasePlayer:                   m_iHealth:           0x%x\n"
        "    DT_BasePlayer:                   m_vecViewOffset:     0x%x\n"
        "    DT_BasePlayer:                   m_lifeState:         0x%x\n"
        "    DT_BasePlayer:                   m_nTickBase:         0x%x\n"
        "    DT_BasePlayer:                   m_vecVelocity:       0x%x\n"
        "    DT_BasePlayer:                   m_vecPunch:          0x%x\n"
        "    DT_BasePlayer:                   m_iFOV:              0x%x\n"
        "    DT_BaseEntity:                   m_iTeamNum:          0x%x\n"
        "    DT_BaseEntity:                   m_vecOrigin:         0x%x\n"
        "    DT_CSPlayer:                     m_hActiveWeapon:     0x%x\n"
        "    DT_CSPlayer:                     m_iShotsFired:       0x%x\n"
        "    DT_CSPlayer:                     m_bIsScoped:         0x%x\n"
        "    DT_BaseAnimating:                m_dwBoneMatrix:      0x%x\n"
        "[*]convar demo:\n"
        "    sensitivity:                     %ff\n"
        "    volume:                          %ff\n"
        "    cl_crosshairsize:                %ff\n"
        "[*]sdk info:\n"
        "   creator:                          ekknod\n"
        "   repo:                             github.com/ekknod/csf\n"
        ,
        cs_vt_client.address(),
        cs_vt_entity.address(),
        cs_vt_engine.address(),
        cs_vt_cvar.address(),
        cs_vt_inputsystem.address(),
        cs_nv_dwEntityList,
        cs_nv_dwClientState,
        cs_nv_m_dwGetLocalPlayer,
        cs_nv_m_dwViewAngles,
        cs_nv_m_dwMaxClients,
        cs_nv_m_dwState,
        cs_nv_m_dwButton,
        cs_nv_m_dwAnalog,
        cs_nv_m_dwAnalogDelta,
        cs_nv_m_iHealth,
        cs_nv_m_vecViewOffset,
        cs_nv_m_lifeState,
        cs_nv_m_nTickBase,
        cs_nv_m_vecVelocity,
        cs_nv_m_vecPunch,
        cs_nv_m_iFOV,
        cs_nv_m_iTeamNum,
        cs_nv_m_vecOrigin,
        cs_nv_m_hActiveWeapon,
        cs_nv_m_iShotsFired,
        cs_nv_m_bIsScoped,
        cs_nv_m_dwBoneMatrix,
        cvar::find("sensitivity").GetFloat(),
        cvar::find("volume").GetFloat(),
        cvar::find("cl_crosshairsize").GetFloat()
        ) ;
    return true;
}

int engine::IsRunning(void)
{
    return cs_p.exists();
}

int engine::GetLocalPlayer(void)
{
    return cs_p.read<int>(cs_nv_dwClientState + cs_nv_m_dwGetLocalPlayer);
}

vec3 engine::GetViewAngles(void)
{
    return cs_p.read<vec3>(cs_nv_dwClientState + cs_nv_m_dwViewAngles);
}

void engine::SetViewAngles(vec3 v)
{
    cs_p.write<vec3>(cs_nv_dwClientState + cs_nv_m_dwViewAngles, v);
}

int engine::GetMaxClients(void)
{
    return cs_p.read<int>(cs_nv_dwClientState + cs_nv_m_dwMaxClients);
}

bool engine::IsInGame(void)
{
    return cs_p.read<unsigned char>(cs_nv_dwClientState + cs_nv_m_dwState) >> 2;
}

cs_player entity::GetClientEntity(int index)
{
    return cs_p.read<cs_player>(cs_nv_dwEntityList + index * 0x10);
}

static void initialize_vt(void)
{
    cs_interface_reg t;

    t = interfaces::find(L"client_panorama.dll");
        cs_vt_client      = t.find("VClient");
        cs_vt_entity      = t.find("VClientEntityList");
    t = interfaces::find(L"engine.dll");
        cs_vt_engine      = t.find("VEngineClient");
    t = interfaces::find(L"vstdlib.dll");
        cs_vt_cvar        = t.find("VEngineCvar");
    t = interfaces::find(L"inputsystem.dll");
        cs_vt_inputsystem = t.find("InputSystemVersion");
}

static csptr_t offset_entitylist(void)
{
    return cs_vt_entity.address() - (cs_p.read<uint32_t>(cs_vt_entity.function(5) + 0x22) - 0x38);
}

static csptr_t offset_clientstate(void)
{
    return cs_p.read_ptr32<csptr_t>(cs_vt_engine.function(18) + 0x16);
}

static void initialize_nv(void)
{
    cs_netvar_table t;


    cs_nv_dwEntityList        = offset_entitylist();
    cs_nv_dwClientState       = offset_clientstate();
    cs_nv_m_dwGetLocalPlayer  = cs_p.read<uint32_t>(cs_vt_engine.function(12) + 0x16);
    cs_nv_m_dwViewAngles      = cs_p.read<uint32_t>(cs_vt_engine.function(19) + 0x1D3);
    cs_nv_m_dwMaxClients      = cs_p.read<uint32_t>(cs_vt_engine.function(20) + 0x07);
    cs_nv_m_dwState           = cs_p.read<uint32_t>(cs_vt_engine.function(26) + 0x07);
    cs_nv_m_dwButton          = cs_p.read<uint32_t>(cs_vt_inputsystem.function(15) + 0x21D);
    cs_nv_m_dwAnalogDelta     = cs_p.read<uint32_t>(cs_vt_inputsystem.function(18) + 0x29);
    cs_nv_m_dwAnalog          = cs_p.read<uint32_t>(cs_vt_inputsystem.function(18) + 0x09);

    t = netvars::find("DT_BasePlayer");  
        cs_nv_m_iHealth       = t.offset("m_iHealth");
        cs_nv_m_vecViewOffset = t.offset("m_vecViewOffset[0]");
        cs_nv_m_lifeState     = t.offset("m_lifeState");
        cs_nv_m_nTickBase     = t.offset("m_nTickBase");
        cs_nv_m_vecVelocity   = t.offset("m_vecVelocity[0]");
        cs_nv_m_vecPunch      = t.offset("m_Local") + 0x70;
        cs_nv_m_iFOV          = t.offset("m_iFOV");
    t = netvars::find("DT_BaseEntity");
        cs_nv_m_iTeamNum      = t.offset("m_iTeamNum");
        cs_nv_m_vecOrigin     = t.offset("m_vecOrigin");
    t = netvars::find("DT_CSPlayer");
        cs_nv_m_hActiveWeapon = t.offset("m_hActiveWeapon");
        cs_nv_m_iShotsFired   = t.offset("m_iShotsFired");
        cs_nv_m_bIsScoped     = t.offset("m_bIsScoped");
    t = netvars::find("DT_BaseAnimating");
        cs_nv_m_dwBoneMatrix  = t.offset("m_nForceBone") + 0x1C;
}


```

`csf_w/src/cs/cs_inputsystem.cpp`:

```cpp
#include "../../include/cs/cs_inputsystem.h"
#include "../../include/u_process.h"
#include "../../include/cs/cs_interfaces.h"

extern u_process        cs_p;
extern cs_virtual_table cs_vt_inputsystem;
extern uint32_t         cs_nv_m_dwButton;
extern uint32_t         cs_nv_m_dwAnalog;
extern uint32_t         cs_nv_m_dwAnalogDelta;

bool inputsystem::IsButtonDown(CS_BUTTONCODE button)
{
    uint32_t v;

    v = cs_p.read<uint32_t>(cs_vt_inputsystem.address() + (((button >> 5 ) * 4) + cs_nv_m_dwButton));
    return (v >> (button & 31)) & 1;
}

vec2i inputsystem::GetMouseAnalog(void)
{
    return cs_p.read<vec2i>(cs_vt_inputsystem.address() + cs_nv_m_dwAnalog);
}

vec2i inputsystem::GetMouseAnalogDelta(void)
{
    return cs_p.read<vec2i>(cs_vt_inputsystem.address() + cs_nv_m_dwAnalogDelta);
}


```

`csf_w/src/cs/cs_interfaces.cpp`:

```cpp
#include "../../include/cs/cs_interfaces.h"
#include "../../include/u_process.h"
#include <string.h>

extern u_process cs_p;

csptr_t cs_virtual_table::address(void) const
{
    return self;
}

csptr_t cs_virtual_table::function(int index)
{
    return cs_p.read<csptr_t>(cs_p.read<csptr_t>(self) + index * 4);
}

cs_virtual_table cs_interface_reg::find(const char *name)
{
    csptr_t a0 = self, a1[30];

    do {
        cs_p.read(cs_p.read<csptr_t>(a0 + 0x4), &a1, sizeof(a1));
        if ((_stricmp((const char *)a1, name) >> 5) == 1) {
            return cs_p.read<cs_virtual_table>(cs_p.read<csptr_t>(a0) + 1);
        }
    } while((a0 = cs_p.read<csptr_t>(a0 + 0x8)));
    throw name;
}

cs_interface_reg interfaces::find(const wchar_t *module_name)
{
    uintptr_t v;

    v = cs_p.find_export(cs_p.find_module(module_name), "CreateInterface");
    if  (v == 0)
        throw module_name;
    return cs_p.read_ptr32<cs_interface_reg>(v - 0x6A);
}


```

`csf_w/src/cs/cs_netvars.cpp`:

```cpp
#include "../../include/cs/cs_netvars.h"
#include "../../include/u_process.h"
#include "../../include/cs/cs_interfaces.h"
#include <string.h>

extern u_process        cs_p;
extern cs_virtual_table cs_vt_client;

uint32_t cs_netvar_table::offset(const char *name)
{
    return offset_ex(self, name);
}

uint32_t cs_netvar_table::offset_ex(csptr_t address, const char *name)
{
    uint32_t  a0;   uint32_t  a1;
    csptr_t   a2;   uint32_t  a3;
    csptr_t   a4;   uint32_t  a5;


    a0 = 0;
    for (a1 = cs_p.read<uint32_t>(address + 0x4); a1--;) {
        a2 = a1 * 60 + cs_p.read<csptr_t>(address);
        a3 = cs_p.read<uint32_t>(a2 + 0x2C);
        if ((a4 = cs_p.read<csptr_t>(a2 + 0x28)) && cs_p.read<uint32_t>(a4 + 0x4)) {
            if ((a5 = offset_ex(a4, name))) {
                a0 += a3 + a5;
            }
        }
        if (strcmp(cs_p.read_ptr32<SHORT_STRING>(a2).value, name) == 0) {
            return a3 + a0;
        }
    }
    return a0;
}

cs_netvar_table netvars::find(const char *name)
{
    csptr_t a0, a1;

    a0 = cs_p.read_ptr32<csptr_t>(cs_vt_client.function(8) + 1);
    do {
        a1 = cs_p.read<csptr_t>(a0 + 0xC);
        if (strcmp(cs_p.read_ptr32<SHORT_STRING>(a1 + 0xC).value, name) == 0) {
            return *(cs_netvar_table*)&a1;
        }
    } while ((a0 = cs_p.read<csptr_t>(a0 + 0x10)));
    throw name;
}


```

`csf_w/src/cs/cs_player.cpp`:

```cpp
#include "../../include/cs/cs_player.h"
#include "../../include/u_process.h"
#include "../../include/cs/cs_interfaces.h"

extern u_process cs_p;
extern csptr_t   cs_nv_dwEntityList;
extern uint32_t  cs_nv_m_iHealth;
extern uint32_t  cs_nv_m_vecViewOffset;
extern uint32_t  cs_nv_m_lifeState;
extern uint32_t  cs_nv_m_nTickBase;
extern uint32_t  cs_nv_m_vecVelocity;
extern uint32_t  cs_nv_m_vecPunch;
extern uint32_t  cs_nv_m_iFOV;
extern uint32_t  cs_nv_m_iTeamNum;
extern uint32_t  cs_nv_m_vecOrigin;
extern uint32_t  cs_nv_m_hActiveWeapon;
extern uint32_t  cs_nv_m_iShotsFired;
extern uint32_t  cs_nv_m_bIsScoped;
extern uint32_t  cs_nv_m_dwBoneMatrix;

int cs_player::GetTeam(void)
{
    return cs_p.read<int>(self + cs_nv_m_iTeamNum);
}

int cs_player::GetHealth(void)
{
    return cs_p.read<int>(self + cs_nv_m_iHealth);
}

int cs_player::GetLifeState(void)
{
    return cs_p.read<int>(self + cs_nv_m_lifeState);
}

int cs_player::GetTickCount(void)
{
    return cs_p.read<int>(self + cs_nv_m_nTickBase);
}

int cs_player::GetShotsFired(void)
{
    return cs_p.read<int>(self + cs_nv_m_iShotsFired);
}

bool cs_player::IsScoped(void)
{
    return cs_p.read<bool>(self + cs_nv_m_bIsScoped);
}

bool cs_player::IsDormant(void)
{
    csptr_t a;

    a = (csptr_t)(self + 0x8);
    return cs_p.read<bool>(a + cs_p.read<uint8_t>((*(cs_virtual_table*)&a).function(9) + 0x8));
}

csptr_t cs_player::GetWeapon(void)
{
    csptr_t v;

    v = cs_p.read<csptr_t>(self + cs_nv_m_hActiveWeapon);
    return cs_p.read<csptr_t>(cs_nv_dwEntityList + ((v & 0xFFF) - 1) * 0x10);
}

vec3 cs_player::GetOrigin(void)
{
    return cs_p.read<vec3>(self + cs_nv_m_vecOrigin);
}

vec3 cs_player::GetVecView(void)
{
    return cs_p.read<vec3>(self + cs_nv_m_vecViewOffset);
}

vec3 cs_player::GetEyePos(void)
{
    vec3 v, o, r;
    v = this->GetVecView();
    o = this->GetOrigin();
    r.x = v.x += o.x; r.y = v.y += o.y; r.z = v.z += o.z;
    return r;
}

vec3 cs_player::GetVecVelocity(void)
{
    return cs_p.read<vec3>(self + cs_nv_m_vecViewOffset);
}

vec3 cs_player::GetVecPunch(void)
{
    return cs_p.read<vec3>(self + cs_nv_m_vecPunch);
}

int cs_player::GetFov(void)
{
    return cs_p.read<int>(self + cs_nv_m_iFOV);
}

void cs_player::GetBoneMatrix(int index, matrix3x4_t *out)
{
    cs_p.read(cs_p.read<csptr_t>(self + cs_nv_m_dwBoneMatrix) + 0x30 * index, out, sizeof(matrix3x4_t));
}

bool cs_player::IsValid(void)
{
    int health = GetHealth();

    return self && GetLifeState() == 0 && health > 0 && health < 1337;
}


```

`csf_w/src/u_config.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include "../include/u_config.h"
#include <inttypes.h>
#include <stdio.h>
#include <io.h>
#include <stdlib.h>

u_config::u_config(const char *path) : _path(path) {}
u_config::~u_config(void) {}

bool u_config::exists(void)
{
    return _access(_path, 0) != -1;
}

void u_config::open_config(const char *mode)
{
    _fd = fopen(_path, mode);
}

void u_config::close_config(void)
{
    fclose(_fd);
}

void u_config::write_config(void *buffer, size_t length)
{
    fwrite(buffer, length, 1, _fd);
}

int u_config::GetInt(const char *name)
{
    char b[32];
    GetVal(name, b);
    return atoi(b);
}

float u_config::GetFloat(const char *name)
{
    char b[32];
    GetVal(name, b);
    return (float)atof(b);
}

bool u_config::SetPos(const char *name)
{
    const char *n;
    char c;

    n = name;
    while ( 1 )
    {
        if (fread(&c, sizeof(c), 1, _fd) == 0)
            break;
        if (*n != c) {
            n = name;
            continue;
        }
        if (*(char*)(n + 1) == '\0') {
            fseek(_fd, 1, SEEK_CUR);
            return true;
        }
        n++;
    }
    return false;
}

bool u_config::GetVal(const char *name, char buffer[32])
{
    long c;
    bool s;
    int  i;


    c = fseek(_fd, 0, SEEK_CUR);
    if ((s = SetPos(name)) == false) {
        goto end;
    }
    i = 0;
    while ( i < 32 ) {
        if (fread(&buffer[i], 1, 1, _fd) == 0)
            break;
        if (buffer[i] == '\n') {
            buffer[i] = '\0';
            s = true;
            break;
        }
        i++;
    }
end:
    fseek(_fd, c, SEEK_SET);
    return s;
}


```

`csf_w/src/u_process.cpp`:

```cpp
#include "../include/u_process.h"
#include <string.h>

#pragma comment(lib, "ntdll.lib")

#ifdef _WIN64
#define SNAP_LENGTH 0x188
#define SNAP_NAME   0x040
#define TEB_WOW64   0x100
#define SNAP_PID    0x128
#define SNAP_START  0x160
#define SNAP_TEB    0x168
#else
#define SNAP_LENGTH 0x110
#define SNAP_NAME   0x03C
#define TEB_WOW64   0x0C0
#define SNAP_PID    0x0D8
#define SNAP_START  0x100
#define SNAP_TEB    0x104
#endif

#define IS_WOW64_ADDRESS(address) (address <= 0xffffffffUL)

struct process_entry {
    const wchar_t *name;
    int           pid;
    uintptr_t     start;
    uintptr_t     teb;
} ;

struct process_snap {
    char *first, *entry;
} ;

extern "C"
{
typedef int BOOL;
typedef void *voidptr_t;
typedef long NTSTATUS;
#define NTAPI __stdcall
#define WINAPI __stdcall
#define DECLSPEC_IMPORT __declspec(dllimport)
DECLSPEC_IMPORT NTSTATUS NTAPI  NtQuerySystemInformation(uint32_t, voidptr_t, uint32_t, uint32_t *);
DECLSPEC_IMPORT NTSTATUS NTAPI  NtClose(HANDLE);
DECLSPEC_IMPORT NTSTATUS NTAPI  NtReadVirtualMemory(HANDLE, PVOID, PVOID, size_t, size_t*);
DECLSPEC_IMPORT NTSTATUS NTAPI  NtWriteVirtualMemory(HANDLE, PVOID, PVOID, size_t, size_t*);
DECLSPEC_IMPORT HANDLE   WINAPI OpenProcess(uint32_t, uint32_t, uint32_t);
DECLSPEC_IMPORT BOOL     WINAPI GetExitCodeProcess(HANDLE, uint32_t*);
}

static void *create_snapshot(void);
static void close_snapshot(void *snapshot);
static bool get_next_process(void *snapshot, struct process_entry *entry);
static uintptr_t teb_to_peb(HANDLE process, uintptr_t teb, bool wow64);

bool u_process::attach(void)
{
    void                 *snap = create_snapshot();
    struct process_entry entry;
  
    if (snap == 0)
        return false;

    while (get_next_process(snap, &entry)) {
        if (!_wcsicmp(entry.name, _name)) {
            _handle = OpenProcess(0x1fffff, 0, entry.pid);
            _wow64  = IS_WOW64_ADDRESS(entry.start);
            _peb    = teb_to_peb(_handle, entry.teb, _wow64);
            break;
        }
    }
    close_snapshot(snap);
    return _handle != 0;
}

void u_process::detach(void)
{
    if (_handle != 0) {
        NtClose(_handle);
    }
}

bool u_process::exists(void)
{
    uint32_t e;
    GetExitCodeProcess(_handle, &e);
    return e == 0x00000103;
}

uintptr_t u_process::find_module(const wchar_t *name)
{
    uintptr_t a0 = 0, a1 = 0, a2 = 0, a3[30];
    uint32_t  rly[5];

    
    if (_wow64) {
        rly[0] = 0x04, rly[1] = 0x0C, rly[2] = 0x14, rly[3] = 0x28, rly[4] = 0x10;
    } else {
        rly[0] = 0x08, rly[1] = 0x18, rly[2] = 0x20, rly[3] = 0x50, rly[4] = 0x20;
    }
    read(_peb + rly[1], &a0, rly[0]);
    read(a0 + rly[2], &a0, rly[0]);
    read(a0 + rly[0], &a1, rly[0]);
    while (a0 != a1) {
        read(a0 + rly[3], &a2, rly[0]);
        read(a2, &a3, sizeof(a3));
        if (_wcsicmp((const wchar_t*)a3, name) == 0) {
            read(a0 + rly[4], &a0, rly[0]);
            return a0;
        }
        if (read(a0, &a0, rly[0]) != 0l)
            break;
    }
    return 0;
}

uintptr_t u_process::find_export(uintptr_t module, const char *name)
{
    uintptr_t a0;
    uint32_t  a1[4], a2[30];

    a0 = module + read<uint16_t>(module + 0x3C);
    a0 = module + read<uint32_t>(a0 + 0x88 - _wow64 * 16);
    read(a0 + 0x18, &a1, sizeof(a1));
    while (a1[0]--) {
        a0 = read<uint32_t>(module + a1[2] + (a1[0] * 4));
        read(module + a0, &a2, sizeof(a2));
        if (!_stricmp((const char *)a2, name)) {
            return (module + read<uint32_t>(module + a1[1] + (read<uint16_t>(module + a1[3] + (a1[0] * 2)) * 4)));
        }
    }
    return 0;
}

NTSTATUS u_process::read(uintptr_t address, void *buffer, size_t length)
{
    return NtReadVirtualMemory(_handle, (PVOID)address, buffer, length, 0);
}

NTSTATUS u_process::write(uintptr_t address, void *buffer, size_t length)
{
    return NtWriteVirtualMemory(_handle, (PVOID)address, buffer, length, 0);
}

static void *create_snapshot(void)
{
    struct process_snap *snap = new process_snap;
    uint32_t length = 0;
    NTSTATUS status;


    status = NtQuerySystemInformation(
        57,
        &length,
        SNAP_LENGTH,
        &length
        );

    if (status != 0xC0000004L) {
        delete [] snap;
        return 0;
    }

    /* this ***** needs more memory than requires sometimes */
    length += 4096;
    snap->first = new char[length];
    status = NtQuerySystemInformation(
        57,
        snap->first,
        length,
        &length
        );

    if (status != 0L) {
        delete [] snap->first;
        delete [] snap;
        return 0;
    } else {
        snap->entry = snap->first;
    }
    return snap;
}

static void close_snapshot(void *snapshot)
{
    struct process_snap *snap = (struct process_snap *)snapshot;

    delete [] snap->first;
    delete [] snap;
}

static bool get_next_process(void *snapshot, struct process_entry *entry)
{
    struct process_snap *snap = (struct process_snap *)snapshot;

    if (*(uint32_t*)snap->entry == 0)
        return false;
    snap->entry  = snap->entry + *(uint32_t*)snap->entry;
    entry->name  = *(const wchar_t**)(snap->entry + SNAP_NAME);
    entry->pid   = *(int*)(snap->entry + SNAP_PID);
    entry->start = *(uintptr_t*)(snap->entry + SNAP_START);
    entry->teb   = *(uintptr_t*)(snap->entry + SNAP_TEB);
    return true;
}

static uintptr_t teb_to_peb(HANDLE process, uintptr_t teb, bool wow64)
{
    uintptr_t peb = 0;
    int       length, offset;

    if (wow64) {
        length = 4, offset = 0x2030;
    } else {
        length = 8, offset = 0x60;
    }
    NtReadVirtualMemory(process, (PVOID)((char*)teb + offset), &peb, length, 0);
    return peb;
}


```