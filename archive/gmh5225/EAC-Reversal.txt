Project Path: arc_gmh5225_EAC-Reversal_kx8g1kp7

Source Tree:

```txt
arc_gmh5225_EAC-Reversal_kx8g1kp7
├── README.md
├── drivers.cpp
├── gameprocess.cpp
├── hwid.cpp
├── injection.cpp
├── integrity.cpp
├── misc.cpp
├── modules.cpp
└── processes.cpp

```

`README.md`:

```md
# EAC-Reversal - Quick and crude reversal

Credits (in no particular order):
- [chance](https://github.com/ch4ncellor)
- [_xeroxz](https://githacks.org/_xeroxz) - Posted recent devirtualized binary of EAC, also publicized his [VMP2 static devirtualizer](https://githacks.org/vmp2/vmdevirt)
- [bright/Sinclairq](https://www.unknowncheats.me/forum/members/3023270.html) - [Detailed writeup](https://back.engineering/10/08/2021/) on EAC manual map execution flow, and other helpful information
- [adrianyy](https://github.com/adrianyy) - Alot of good information (which alot is still suprisingly not outdated) from his personal EAC reversals (This repository is to act as an update of his!)
- [Swiftik, and everyone he credited in his post.](https://www.unknowncheats.me/forum/members/1308837.html?s=94386816e697fc0d1bb4b3d802a7f0b8) - Posted his group reverse publicly, again good information there.
- [agent_dark47 on UC.](https://www.unknowncheats.me/forum/members/11666.html) - Extensive shares with the community pertaining to his adventures with EAC

```

`drivers.cpp`:

```cpp
char EAC::Callbacks::SomeDriverChecks()
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  pOutputResult = 0;
  v14 = -5772;
  pCheckDriverDispatch = 0;
  v13[0] = -683422989;
  v15[0] = 0i64;
  v1 = 0i64;
  LOWORD(v15[1]) = 0;
  v2 = -685061481;
  v13[1] = -2105495067;
  v21 = v13;
  v22 = v15;
  v3 = 8i64;
  do
  {
    *(v22 + v1 * 4) = v21[v1] ^ v2;
    ++v1;
    v2 = __ROL4__(((v2 ^ (v2 << 13)) >> 17) ^ v2 ^ (v2 << 13) ^ (32 * (((v2 ^ (v2 << 13)) >> 17) ^ v2 ^ (v2 << 13))), 1);
  }
  while ( v1 < 2 );
  v21 = v13;
  v22 = v15;
  do
  {
    v4 = v2;
    v2 >>= 8;
    *(v22 + v3) = *(v21 + v3) ^ v4;
    ++v3;
  }
  while ( v3 < 0xA );
  EAC::Memory::memset(&nDriverCTLMinusAddress, 0, 0x108ui64);
  EAC::Memory::InitializeUnicodeStringWithCString(v16, v15);
  pDriverObject = EAC::Memory::GetDriverObject(v16);
  pDriverObject_1 = pDriverObject;
  if ( pDriverObject )
  {
    pCheckDriverDispatch = EAC::Callbacks::CheckDriverDispatch(
                             pDriverObject,
                             v6,
                             &nDriverCTLMinusAddress,
                             &pOutputResult);
    ObfDereferenceObject(pDriverObject_1);
    nDetectionResult = pOutputResult;
  }
  else
  {
    nDetectionResult = 1;
  }
  for ( i = 0i64; i < 256; ++i )
  {
    if ( !a3_8[i] )
      break;
  }
  pAllocated = EAC::Memory::ExAllocatePoolWithRandomTag2(i + 0xA);
  pAllocated_1 = pAllocated;
  if ( pAllocated )                             // send driver information to server aswell?
  {
    EAC::Memory::memset(pAllocated, 0, i + 0xA);
    pAllocated_1->nDriverCTLMinusAddress = nDriverCTLMinusAddress;
    pAllocated_1->dword5 = a3_4;
    pAllocated_1->nDetectionResult = nDetectionResult;
    if ( i )
      EAC::Memory::memmove(&pAllocated_1->oword9, a3_8, i);
    if ( i != 0xFFFFFFFFFFFFFFF6ui64 )
    {
      EAC::Callbacks::ReportViolation(0x125F58F6i64, pAllocated_1, (i + 0xA));
FREE_POOL_LABEL:
      EAC::Memory::ExFreePool(pAllocated_1);
      goto END_RET_LABEL;
    }
  }
  EAC::Callbacks::ReportViolation(0x125F58F6i64, 0i64, 0i64);
  if ( pAllocated_1 )
    goto FREE_POOL_LABEL;
END_RET_LABEL:
  memset(v15, 0, 0xAui64);
  return pCheckDriverDispatch;
}

char __fastcall EAC::Callbacks::CheckDriverDispatch(_DRIVER_OBJECT *pDriverObject, __int64 a2, struct_a3 *a3, _DWORD *pOutDetectionResult)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  bIsOutsideDriverBounds = 0;
  if ( !pDriverObject )
  {
    if ( pOutDetectionResult )
      *pOutDetectionResult = 2;
    return 0;
  }
  pAddressOfDeviceCTLMJ = pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL];
  if ( !pAddressOfDeviceCTLMJ )
  {
    if ( pOutDetectionResult )
      *pOutDetectionResult = 4;
    return 0;
  }
  v8 = EAC::Memory::GetRunningModules();
  v9 = v8;
  if ( !v8 )
  {
    if ( pOutDetectionResult )
      *pOutDetectionResult = 5;
    return 0;
  }
  v11 = 0;
  if ( *v8 )
  {
    while ( 1 )
    {
      v12 = 0x128i64 * v11;
      nAddrOfModule = *(v12 + v8 + 24);
      if ( nAddrOfModule >= MmSystemRangeStart
        && pAddressOfDeviceCTLMJ >= nAddrOfModule
        && pAddressOfDeviceCTLMJ <= nAddrOfModule + *(v12 + v8 + 32) )
      {
        break;
      }
      if ( ++v11 >= *v8 )                       // driver majorfunction was in bounds, we can just leave now.
        goto GOTO_END_OF_FN;
    }
    bIsOutsideDriverBounds = 1;
    if ( a3 )
    {
      v14 = 0i64;
      a3->dword0 = pAddressOfDeviceCTLMJ - nAddrOfModule;
      v15 = &v9[v12 + 48];
      if ( !v15 )
        goto LABEL_34;
      do
      {
        if ( !*(v15 + v14) )
          break;
        ++v14;
      }
      while ( v14 < 0x100 );
      v16 = 0xFFi64;
      if ( v14 < 0xFF )
      {
LABEL_34:
        v16 = 0i64;
        if ( v15 )
        {
          do
          {
            if ( !*(v15 + v16) )
              break;
            ++v16;
          }
          while ( v16 < 0x100 );
        }
      }
      EAC::Memory::memmove(&a3->oword8, v15, v16);
      *(&a3->oword8 + v16) = 0;
      a3->dword4 = *&v9[v12 + 32];
    }
    if ( pOutDetectionResult )
      *pOutDetectionResult = 7;
  }
GOTO_END_OF_FN:
  EAC::Memory::ExFreePool(v9);
  if ( !bIsOutsideDriverBounds && pOutDetectionResult )
    *pOutDetectionResult = 6;
  return bIsOutsideDriverBounds;
}

__int64 __fastcall EAC::Callbacks::DetectProcessHackerDriver(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rsi
  unsigned __int8 *v4; // rdi
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rbp
  bool i; // cf
  ULONG nTimeStamp; // ecx
  unsigned int v10; // [rsp+40h] [rbp+8h] BYREF
  IMAGE_NT_HEADERS64 *pImage; // [rsp+48h] [rbp+10h] BYREF

  v10 = 0;
  v3 = a2 & 0xFFFFFFFFFFFFF000ui64;
  if ( a1 < MmSystemRangeStart
    || (a1 & 0xFFFFFFFFFFFFF000ui64) != a1
    || !v3
    || ((qword_140073200 ^ a1) & 0xFFFFFFFF00000000ui64) != 0 )
  {
    return 0i64;
  }
  v4 = EAC::Memory::ExAllocatePoolWithRandomTag2(4096i64);
  if ( v4 )
  {
    v5 = a1 + v3;
    v6 = a1;
    for ( i = a1 < v5; i && !v10; i = v6 < v5 )
    {
      if ( EAC::Imports::MmCopyMemory(v6, 0x1000ui64, v4) == 4096 )
      {
        sub_14000F6DC(v4, 4096i64, sub_14003F8D8, &v10);
        if ( v6 == a1 )
        {
          if ( EAC::Memory::GetPEHeader(v4, 0x1000ui64, 0i64, &pImage) )
          {
            if ( pImage->FileHeader.NumberOfSections == 7
              && pImage->OptionalHeader.AddressOfEntryPoint == 0x9064
              && pImage->OptionalHeader.SizeOfImage == 0xB000 )
            {
              nTimeStamp = pImage->FileHeader.TimeDateStamp;
              if ( nTimeStamp == 0x56F975FA || nTimeStamp == 0x57089DA8 )
              {
                v10 = 0;
                break;
              }
            }
          }
          if ( !v10 )
            v10 = sub_14003FBB4(v4);
        }
      }
      v6 += 4096i64;
    }
    EAC::Memory::ExFreePool(v4);
  }
  return v10;
}

__int64 __fastcall EAC::Callbacks::FindProcessHackerDriverFile(_FLT_CALLBACK_DATA *a1, __int64 a2)
{
  unsigned int v4; // ebx
  PFLT_IO_PARAMETER_BLOCK v5; // rdx
  SIZE_T v6; // rsi
  PVOID v7; // r14
  PFLT_IO_PARAMETER_BLOCK v8; // rdx
  __int128 FileInformation; // [rsp+50h] [rbp-38h] BYREF
  __int64 v11; // [rsp+60h] [rbp-28h]
  ULONG LengthReturned; // [rsp+90h] [rbp+8h] BYREF
  union _LARGE_INTEGER ByteOffset; // [rsp+A8h] [rbp+20h] BYREF

  v11 = 0i64;
  v4 = 1;
  FileInformation = 0i64;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a1->Iopb->MajorFunction == 255 && !KeGetCurrentIrql() && FltGetRequestorProcess(a1) == PsInitialSystemProcess )
      {
        v5 = a1->Iopb;
        if ( v5->Parameters.Read.Length == 1
          && (v5->Parameters.AcquireForSectionSynchronization.PageProtection & 0xF0) != 0
          && FltQueryInformationFile(
               *(a2 + 24),
               v5->TargetFileObject,
               &FileInformation,
               0x18u,
               FileStandardInformation,
               &LengthReturned) >= 0
          && LengthReturned == 24 )
        {
          v6 = *(&FileInformation + 1);
          if ( *(&FileInformation + 1) <= 0xFFFFFFFFi64 )
          {
            if ( *(&FileInformation + 1) > 0x800000 )
              v6 = 0x800000i64;
            v7 = FltAllocatePoolAlignedWithTag(*(a2 + 24), NonPagedPool, v6, 'godW');
            if ( v7 )
            {
              v8 = a1->Iopb;
              ByteOffset.QuadPart = 0i64;
              if ( FltReadFile(*(a2 + 24), v8->TargetFileObject, &ByteOffset, v6, v7, 4u, &LengthReturned, 0i64, 0i64) >= 0
                && EAC::Callbacks::IsFileProcessHackerDriver(v7, LengthReturned) )
              {
                a1->IoStatus.Status = 0xC0000022;
                v4 = 4;
              }
              FltFreePoolAlignedWithTag(*(a2 + 24), v7, 'godW');
            }
          }
        }
      }
    }
  }
  return v4;
}

__int64 __fastcall EAC::Callbacks::IsFileProcessHackerDriver(unsigned __int8 *a1, unsigned __int64 a2)
{
  __int64 v4; // rcx
  __int64 result; // rax
  ULONG v6; // ecx
  unsigned int v7; // [rsp+30h] [rbp+8h] BYREF
  IMAGE_NT_HEADERS64 *v8; // [rsp+40h] [rbp+18h] BYREF

  v7 = 0;
  if ( !a1 || !a2 )
    return 0i64;
  sub_14000F6DC(a1, a2, sub_14003F8D8, &v7);
  result = v7;
  if ( !v7 )
  {
    result = EAC::Memory::IncreaseImageSizeWeird(v4, a1, a2);
    v7 = result;
    if ( !result )
    {
      result = sub_14003FE78(a1, a2);
      v7 = result;
    }
  }
  if ( result == 9 )
  {
    if ( !EAC::Memory::GetPEHeader(a1, 0x1000ui64, 0i64, &v8) )
      return v7;
    if ( v8->FileHeader.NumberOfSections != 7 )
      return v7;
    if ( v8->OptionalHeader.AddressOfEntryPoint != 0x9064 )
      return v7;
    if ( v8->OptionalHeader.SizeOfImage != 0xB000 )
      return v7;
    v6 = v8->FileHeader.TimeDateStamp;
    if ( v6 != 0x56F975FA && v6 != 0x57089DA8 )
      return v7;
    return 0i64;
  }
  return result;
}

__int64 __fastcall EAC::Callbacks::MoreDriverChecks(_OWORD *a1)
{
  unsigned int v2; // ebx
  unsigned int *v3; // rax
  unsigned int *v4; // rsi
  unsigned int v5; // ebp
  __int64 v6; // rdi
  unsigned __int64 v7; // rax
  char *v8; // rdx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rcx
  __int64 v11; // r8
  char v12; // dl
  _BYTE *v13; // rax
  __int64 v14; // rcx

  v2 = 0;
  KeQueryTimeIncrement();
  v3 = EAC::Memory::GetRunningModules();
  v4 = v3;
  if ( !v3 )
    goto LABEL_35;
  v5 = 0;
  if ( *v3 )
  {
    do
    {
      if ( v2 )
        break;
      v6 = &v4[74 * v5 + 2];
      v2 = EAC::Callbacks::DetectProcessHackerDriver(*(v6 + 16), *(v6 + 24));
      if ( v2 || (v2 = EAC::Memory::GetSomeFilePEHeaderInfo(v6), v2 != 22) )
      {
        if ( v2 == 5 )
        {
          v10 = 0i64;
          v11 = v6 + *(v6 + 38);
          v12 = *(v11 + 40);
          v13 = (v11 + 40);
          if ( v12 )
          {
            do
            {
              ++v13;
              ++v10;
            }
            while ( *v13 );
            if ( v10 >= 16 && v12 == 'p' )
            {
              v14 = 1i64;
              while ( (*(v14 + v11 + 40) - 48) <= 9u )
              {
                if ( ++v14 >= 12 )
                {
                  v2 = 0;
                  break;
                }
              }
            }
          }
        }
      }
      else if ( v6 != 0xFFFFFFFFFFFFFFD8ui64 && a1 )
      {
        v7 = 0i64;
        v8 = (v6 + *(v6 + 38) + 40i64);
        if ( v8 )
        {
          while ( v8[v7] )
          {
            if ( ++v7 >= 256 )
            {
              if ( v7 < 0x104 )
                break;
              v9 = 260i64;
              goto LABEL_16;
            }
          }
        }
        v9 = 0i64;
        if ( v8 )
        {
          do
          {
            if ( !v8[v9] )
              break;
            ++v9;
          }
          while ( v9 < 0x100 );
        }
LABEL_16:
        EAC::Memory::memmove(a1, v8, v9);
      }
      ++v5;
    }
    while ( v5 < *v4 );
  }
  EAC::Memory::ExFreePool(v4);
  if ( !v2 )
  {
LABEL_35:
    if ( EAC::Callbacks::CheckForBlacklistedDriverNames() )
    {
      v2 = 18;
    }
    else if ( EAC::Callbacks::GetDriverAttributesFileList() )
    {
      v2 = 7;
    }
  }
  return v2;
}

__int64 __fastcall EAC::Callbacks::AddDriverHashToServerList(__int64 BaseAddress, unsigned __int64 ImageLength, __int64 DriverInstance, __int64 *ChangedPartList, _DWORD *a5)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v31 = ImageLength;
  v30 = BaseAddress;
  v7 = ImageLength;
  v8 = BaseAddress;
  v9 = -1073741271;
  if ( !KeGetCurrentIrql() )
  {
    if ( BaseAddress )
    {
      if ( ImageLength )
      {
        if ( DriverInstance )
        {
          v10 = *(DriverInstance + 16);
          if ( v10 )
          {
            if ( *(DriverInstance + 24)
              && v10 >= MmSystemRangeStart
              && ChangedPartList
              && a5
              && EAC::Memory::IsWithinMemoryConstraint(DriverInstance, v8)
              && EAC::Memory::IsWithinMemoryConstraint(v11, v8 + v7) )
            {
              *ChangedPartList = 0i64;
              *a5 = 0;
              v12 = EAC::Memory::ExAllocatePoolWithRandomTag2(8 * (v7 >> 12) + 8);
              *ChangedPartList = v12;
              if ( !v12 )
                return v9;
              if ( KeGetCurrentIrql() <= 1u )
              {
                ExAcquireFastMutex(&stru_1400732D0);
                if ( !EAC::Memory::HashDatabaseAllocated && !EAC::Globals::HasInitHash )
                {
                  v13 = EAC::Memory::ExAllocatePoolWithRandomTag2(24576i64);
                  EAC::Memory::HashDatabase = v13;
                  if ( v13 )
                  {
                    EAC::Memory::HashDatabaseAllocated = 1;
                    memset(v13, 0, 0x6000ui64);
                  }
                }
                ExReleaseFastMutex(&stru_1400732D0);
                if ( EAC::Memory::HashDatabaseAllocated )
                {
                  v14 = EAC::Memory::CRC32((DriverInstance + 40), 0x100u, 0);
                  driverHash = 0i64;
                  ExAcquireFastMutex(&stru_1400732D0);
                  if ( EAC::Memory::HashDatabaseAllocated )
                  {
                    v16 = 0i64;
                    if ( EAC::Memory::NumberOfBytes )
                    {
                      v17 = EAC::Memory::HashDatabase + 4;
                      while ( *v17 != v14 )
                      {
                        ++v16;
                        v17 += 6;
                        if ( v16 >= EAC::Memory::NumberOfBytes )
                          goto LABEL_32;
                      }
                      driverHash = EAC::Memory::ExAllocatePoolWithRandomTag2(24i64);
                      if ( driverHash )
                      {
                        v18 = EAC::Memory::HashDatabase;
                        v19 = 3 * v16;
                        *driverHash = *(EAC::Memory::HashDatabase + 8 * v19);
                        *(driverHash + 16) = v18[v19 + 2];
                        v20 = EAC::Memory::ExAllocatePoolWithRandomTag2(4i64 * HIDWORD(v18[v19 + 1]));
                        *(driverHash + 16) = v20;
                        if ( v20 )
                        {
                          EAC::Memory::memmove(
                            v20,
                            *(EAC::Memory::HashDatabase + v19 + 2),
                            4i64 * *(EAC::Memory::HashDatabase + 2 * v19 + 3));
                          if ( *(driverHash + 12) )
                          {
                            v21 = 0i64;
                            do
                            {
                              *(*(driverHash + 16) + 4 * v21) ^= *driverHash;
                              v21 = (v21 + 1);
                            }
                            while ( v21 < *(driverHash + 12) );
                          }
                        }
                        else
                        {
                          EAC::Memory::ExFreePool(driverHash);
                          driverHash = 0i64;
                        }
                      }
                    }
                  }
LABEL_32:
                  ExReleaseFastMutex(&stru_1400732D0);
                  if ( driverHash )
                  {
LABEL_43:
                    v27 = EAC::Memory::GetDriverHash(driverHash, v8, v7, *(DriverInstance + 16), ChangedPartList, a5);
                    v28 = *(driverHash + 16);
                    v9 = v27 == 0 ? 0xC0000005 : 0;
                    if ( v28 )
                      EAC::Memory::ExFreePool(v28);
                    EAC::Memory::ExFreePool(driverHash);
                    if ( (v9 & 0x80000000) == 0 && *a5 )
                      return v9;
                    goto LABEL_47;
                  }
                  driverHash = EAC::Memory::HashDriver(v14, DriverInstance);
                  if ( driverHash )
                  {
                    ExAcquireFastMutex(&stru_1400732D0);
                    if ( EAC::Memory::HashDatabaseAllocated && EAC::Memory::NumberOfBytes < 1024 )
                    {
                      v22 = EAC::Memory::HashDatabase;
                      v23 = 3i64 * EAC::Memory::NumberOfBytes;
                      *(EAC::Memory::HashDatabase + 8 * v23) = *driverHash;
                      v22[v23 + 2] = *(driverHash + 16);
                      v24 = EAC::Memory::ExAllocatePoolWithRandomTag2(4i64 * *(driverHash + 12));
                      v25 = EAC::Memory::NumberOfBytes;
                      *(EAC::Memory::HashDatabase + 3 * EAC::Memory::NumberOfBytes + 2) = v24;
                      if ( v24 )
                      {
                        EAC::Memory::memmove(v24, *(driverHash + 16), 4i64 * *(driverHash + 12));
                        if ( HIDWORD(v22[v23 + 1]) )
                        {
                          v26 = 0i64;
                          do
                          {
                            *(v22[v23 + 2] + 4 * v26) ^= LODWORD(v22[v23]);
                            v26 = (v26 + 1);
                          }
                          while ( v26 < HIDWORD(v22[v23 + 1]) );
                        }
                        EAC::Memory::NumberOfBytes = v25 + 1;
                      }
                      v8 = v30;
                      v7 = v31;
                    }
                    ExReleaseFastMutex(&stru_1400732D0);
                    goto LABEL_43;
                  }
                  v9 = 0xC0000123;
                }
              }
LABEL_47:
              EAC::Memory::ExFreePool(*ChangedPartList);
              return v9;
            }
          }
        }
      }
    }
  }
  return 0xC000000Di64;
}

_QWORD *__fastcall EAC::Memory::HashDriver(int a1, __int64 a2)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v2 = *(a2 + 40);
  v37 = 0;
  v3 = *(a2 + 56);
  v4 = 0i64;
  v32[0] = v2;
  v7 = *(a2 + 72);
  v32[1] = v3;
  v8 = *(a2 + 88);
  v32[2] = v7;
  v9 = *(a2 + 104);
  v32[3] = v8;
  v10 = *(a2 + 120);
  v32[4] = v9;
  v11 = *(a2 + 136);
  v32[5] = v10;
  v32[6] = v11;
  v32[7] = *(a2 + 152);
  v12 = *(a2 + 280);
  v13 = *(a2 + 184);
  v32[8] = *(a2 + 168);
  v14 = *(a2 + 200);
  v32[9] = v13;
  v15 = *(a2 + 216);
  v32[10] = v14;
  v16 = *(a2 + 232);
  v32[11] = v15;
  v17 = *(a2 + 248);
  v32[12] = v16;
  v18 = *(a2 + 264);
  v32[13] = v17;
  v32[14] = v18;
  v33 = v12;
  v34 = *(a2 + 288);
  v35 = *(a2 + 292);
  v36 = *(a2 + 294);
  v30[1] = v32;
  v19 = -1i64;
  do
    ++v19;
  while ( *(v32 + v19) );
  LOWORD(v30[0]) = v19;
  WORD1(v30[0]) = v19 + 1;
  if ( EAC::Memory::CreateUnicodeString(v31, v30) >= 0 )
  {
    v20 = EAC::Memory::IsFileValidPEImage(v31, *(a2 + 16), &v38, 1);
    v21 = v20;
    if ( v20 )
    {
      v22 = 0i64;
      v23 = EAC::Memory::GetSectionSize(v20);
      v24 = v38 % v23;
      v25 = v38 / v23;
      if ( v38 / v23 )
      {
        v22 = EAC::Memory::ExAllocatePoolWithRandomTag2(24i64);
        if ( v22 )
        {
          v26 = EAC::Memory::ExAllocatePoolWithRandomTag2(4i64 * v25);
          v22[2] = v26;
          if ( v26 )
          {
            *(v22 + 1) = a1;
            *v22 = EAC::Memory::GenerateSeed(0, -1);
            *(v22 + 2) = v23;
            *(v22 + 3) = v25;
            do
            {
              v27 = EAC::Memory::CRC32(&v21[v23 * v4], v23, 0);
              LODWORD(v4) = v4 + 1;
              *(v28 + v22[2]) = v27;
            }
            while ( v4 < v25 );
          }
          else
          {
            EAC::Memory::ExFreePool(v22);
            v22 = 0i64;
          }
        }
      }
      v4 = v22;
      sub_14003CCAC(v21, v24);
    }
    EAC::Memory::FreeUnicdeString(v31);
  }
  return v4;
}

LONG_PTR __fastcall EAC::Callbacks::ScanForKernelPatches(__int64 a1, __int64 a2)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v4 = 0;
  m_bHasNTOSKrnlBeenPatched = EAC::Callbacks::CheckForNTOSKRNLPatches() - 1;
  if ( !m_bHasNTOSKrnlBeenPatched )
  {
    v4 = 0xC0020007;
    goto LABEL_35;
  }
  if ( m_bHasNTOSKrnlBeenPatched == 1 )
  {
    v4 = 0xC0020008;
    goto LABEL_35;
  }
  if ( MEMORY[0xFFFFF7800000026C] <= 6u && (MEMORY[0xFFFFF7800000026C] != 6 || (MEMORY[0xFFFFF78000000270] - 2) > 1) )
    goto LABEL_28;
  if ( !EAC::Memory::GetBootGUID(v38, v41) )
  {
    EAC::Callbacks::ReportViolation_1(a2, 0x5AADB103i64, 0i64, 0i64, 0i64);
LABEL_28:
    sub_14002F998(a2, 0x40010006i64);
    v4 = sub_14004D884(a1, a2);
    goto LABEL_29;
  }
  if ( v39 )
  {
    strcpy(v23, "5Ê\\\x1Bê8L");
    *&v44[48] = 0i64;
    *&v44[56] = 0;
    v6 = -1286774945;
    v24 = 80942024;
    v7 = 0i64;
    v25 = 594688901;
    v26 = -299880827;
    v27 = -1561828364;
    v28 = -1767145028;
    v29 = -1192192300;
    v30 = -526128710;
    v31 = 1008280262;
    v32 = -1032869015;
    v33 = 1233558148;
    v34 = -2057461693;
    v35 = 1825154181;
    v36 = -2016214440;
    *v44 = 0i64;
    *&v44[16] = 0i64;
    *&v44[32] = 0i64;
    do
    {
      v6 = __ROL4__(214013 * v6 + 2531011, 4);
      *&v44[v7] = *&v23[v7] ^ v6;
      v7 += 4i64;
    }
    while ( v7 < 0x3C );
    v8 = 1;
    if ( !EAC::Memory::CompareUnicodeStr(v38, v44) )
      goto LABEL_15;
    v37[0] = 1666580416;
    *&v43[48] = 0i64;
    *&v43[56] = 0;
    v9 = -1709524677;
    v37[1] = -1558651321;
    v37[2] = 629101256;
    v10 = 0i64;
    v37[3] = 467525598;
    v37[4] = -1984057362;
    v37[5] = 736416474;
    v37[6] = -1549857426;
    v37[7] = -1801439344;
    v37[8] = 431986060;
    v37[9] = -1755171940;
    v37[10] = -958271565;
    v37[11] = 1854764083;
    v37[12] = -693829820;
    v37[13] = -1894837076;
    v37[14] = 529568623;
    *v43 = 0i64;
    *&v43[16] = 0i64;
    *&v43[32] = 0i64;
    do
    {
      v9 = __ROL4__(((v9 ^ (v9 >> 7)) << 9) ^ v9 ^ (v9 >> 7) ^ ((((v9 ^ (v9 >> 7)) << 9) ^ v9 ^ (v9 >> 7)) >> 13), 4);
      *&v43[v10 * 4] = v37[v10] ^ v9;
      ++v10;
    }
    while ( v10 < 15 );
    v8 = 3;
    if ( EAC::Memory::CompareUnicodeStr(v38, v43) )
    {
      LOBYTE(v4) = 1;
    }
    else
    {
LABEL_15:
      if ( (v8 & 2) == 0 )
      {
LABEL_17:
        memset(v44, 0, sizeof(v44));
        EAC::Memory::FreeUnicdeString(v38);
        v4 = v4 != 0 ? 0xC0020010 : 0;
        goto LABEL_18;
      }
    }
    memset(v43, 0, sizeof(v43));
    goto LABEL_17;
  }
LABEL_18:
  if ( v42 )
  {
    v21[0] = -437452254;
    v22 = 25715;
    v21[1] = 991072209;
    *&v40[1] = 0i64;
    v11 = 0i64;
    WORD4(v40[1]) = 0;
    v12 = -442957236;
    v21[2] = 55889785;
    v21[3] = 1113584501;
    v21[4] = -1296637238;
    v13 = 24i64;
    v21[5] = 799280214;
    v40[0] = 0i64;
    do
    {
      v14 = v21[v11] ^ v12;
      v12 = __ROL4__(1140671485 * v12 + 12820163, 1);
      *(v40 + v11 * 4) = v14;
      ++v11;
    }
    while ( v11 < 6 );
    do
    {
      v15 = v12;
      v12 >>= 8;
      *(v40 + v13) = *(v21 + v13) ^ v15;
      ++v13;
    }
    while ( v13 < 0x1A );
    v16 = EAC::Memory::CompareUnicodeStr(v41, v40);
    memset(v40, 0, 0x1Aui64);
    if ( v16 )
      v4 = 0xC0020011;
    EAC::Memory::FreeUnicdeString(v41);
  }
  if ( !v4 )
    goto LABEL_28;
LABEL_29:
  if ( v4 != 0x40031000 )
  {
LABEL_35:
    v19 = v4;
    v18 = a2;
    goto LABEL_36;
  }
  sub_140025304(a2);
  v17 = sub_140009F70(a2);
  v18 = a2;
  if ( !v17 )
  {
    v19 = 3221356569i64;
LABEL_36:
    EAC::Callbacks::ReportViolation_0(v18, v19);
    return sub_140027958();
  }
  sub_14002F6A8(a2, 0x40031000);
  return sub_140027958();
}

__int64 EAC::Callbacks::CheckForNTOSKRNLPatches()
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v0 = 0i64;
  LODWORD(FileSize) = 0;
  v1 = 2;
  ntoskrnlBase = EAC::Memory::GetNTOSKRNLBaseAddress();
  if ( ntoskrnlBase && EAC::Memory::GetNTOSKRNLPath(ModulePath, 1) )
  {
    if ( MEMORY[0xFFFFF7800000026C] <= 6u && (MEMORY[0xFFFFF7800000026C] != 6 || (MEMORY[0xFFFFF78000000270] - 2) > 1) )
      goto LABEL_10;
    v7[0] = 1035157922;
    v7[1] = -1211973253;
    v7[2] = 890527115;
    v7[3] = -1604919530;
    v7[4] = 335976341;
    v7[5] = 768738782;
    v7[6] = 1965411501;
    v7[7] = 387677515;
    v7[8] = -584117672;
    v7[9] = 323241621;
    v7[10] = -1563280376;
    v7[11] = 2025074343;
    v7[12] = 2050208706;
    v7[13] = 239808795;
    v7[14] = 1411383000;
    v7[15] = -198881325;
    v7[16] = 331163443;
    EAC::Memory::memset(Dst, 0, 0x44ui64);
    v3 = 276658416;
    v13 = v7;
    v14 = Dst;
    do
    {
      v3 = ~(((v3 ^ (v3 << 13)) >> 7) ^ v3 ^ (v3 << 13) ^ ((((v3 ^ (v3 << 13)) >> 7) ^ v3 ^ (v3 << 13)) << 17));
      *(v14->m128_i32 + v0) = *(v13 + v0) ^ v3;
      v0 += 4i64;
    }
    while ( v0 < 0x44 );
    LOBYTE(v0) = 1;
    if ( EAC::Memory::CompareUnicodeStr(ModulePath, Dst) )// ntoskrnl.exe
    {
      v4 = 1;
    }
    else
    {
LABEL_10:
      v4 = 0;
      if ( (v0 & 1) == 0 )
        goto LABEL_13;
    }
    memset(Dst, 0, 0x44ui64);
    if ( v4 )
    {
      v1 = 1;
LABEL_26:
      EAC::Memory::FreeUnicdeString(ModulePath);
      return v1;
    }
LABEL_13:
    if ( EAC::Memory::ForceReadFile(ModulePath, &pAllocatedHeap, &FileSize) )
    {
      pAllocatedHeapAddr = pAllocatedHeap;
      if ( FileSize >= 0x1000 )
        v1 = !EAC::Memory::GetPEHeader(ntoskrnlBase, 0x1000ui64, &FileSize, &MemoryHeader)
          || !EAC::Memory::GetPEHeader(pAllocatedHeapAddr, 0x1000ui64, &FileSize, &DiskHeader)
          || MemoryHeader->FileHeader.NumberOfSections != DiskHeader->FileHeader.NumberOfSections
          || MemoryHeader->FileHeader.TimeDateStamp != DiskHeader->FileHeader.TimeDateStamp
          || MemoryHeader->OptionalHeader.AddressOfEntryPoint != DiskHeader->OptionalHeader.AddressOfEntryPoint
          || MemoryHeader->OptionalHeader.CheckSum != DiskHeader->OptionalHeader.CheckSum
          || MemoryHeader->OptionalHeader.SizeOfImage != DiskHeader->OptionalHeader.SizeOfImage;
      if ( pAllocatedHeapAddr )
        EAC::Memory::ExFreePool(pAllocatedHeapAddr);
    }
    goto LABEL_26;
  }
  return v1;
}


```

`gameprocess.cpp`:

```cpp
void __fastcall EAC::Callbacks::ScanGameProcess(ULONG64 *a1, char a2, __int64 a3, int a4, int a5, int a6, int a7)
{
  int v7; // er8
  ULONG64 v8; // rdx

  if ( (a2 & 1) != 0 )
  {
    EAC::Callbacks::CheckForManualMappedModule(a1);
  }
  else
  {
    if ( (a2 & 4) != 0 )
    {
      v7 = *(*a1 + 26) >> 14;
      LOBYTE(v7) = (*(*a1 + 26) & 0x4000) != 0;
      LODWORD(v8) = 0;
    }
    else
    {
      v8 = a1[1];
      v7 = 0;
    }
    (sub_14001A790)(a1, v8, v7, a4, a5, a6, a7);
  }
}

void __fastcall EAC::Callbacks::ProtectGameProcess(unsigned int *a1)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v2 = 0;
  v68 = 0;
  v3 = 0i64;
  v4 = 0i64;
  v58[0] = 0;
  KeQueryTimeIncrement();
  if ( !a1 || *a1 == 197 )
    return;
  v5 = EAC::Memory::ExAllocatePoolWithRandomTag2(0x4000i64);
  v62 = v5;
  if ( !v5 )
    goto LABEL_85;
  v3 = EAC::Memory::ExAllocatePoolWithRandomTag2(1024i64);
  v63 = v3;
  if ( !v3 )
    goto LABEL_85;
  v6 = EAC::Memory::ExAllocatePoolWithRandomTag2(0x8000i64);
  v4 = v6;
  v64 = v6;
  if ( !v6 )
    goto LABEL_85;
  v59 = v6 + 2;
  v61 = v6 + 0x8000;
  if ( !EAC::Callbacks::KeStackAttachProcess(*(a1 + 1), v67) )
    goto LABEL_83;
  for ( i = 0i64; !*(a1 + 544) && EAC::Imports::NtQueryVirtualMemory(-1i64, i, 0i64, &i, 48i64); i += v54 )
  {
    v7 = (v54 + 4095) & 0xFFFFFFFFFFFFF000ui64;
    if ( !v7 )
      v7 = 4096i64;
    v54 = v7;
    v8 = v53;
    if ( v53 != i )
      goto LABEL_19;
    if ( v57 == 0x1000000 )
    {
      if ( !v53 || !EAC::Memory::PebImageByBaseWin64(v53) && !EAC::Memory::PebImageByBaseWow64(v8) )
      {
        v9 = EAC::Imports::GetProcessBaseAddress(*(a1 + 1));
        if ( v53 != v9 )
        {
          sub_140031F70(a1, &i);
          goto LABEL_35;
        }
      }
LABEL_19:
      if ( v57 == 0x1000000 && (v56 & 0x100) != 0 )
      {
        EAC::Callbacks::DetectLoadedModulesInGame(a1, 0x342B6272u, v53, 0i64);
        v34 = -1969993559;
        v35 = -1144243536;
        v36 = 242064136;
        v37 = 187676638;
        v38 = -1991878171;
        v39 = 96452294;
        v40 = -149557856;
        v41 = -694104463;
        v42 = -1557300779;
        v43 = -566847724;
        v44 = 510674766;
        v45 = 839459207;
        v46 = -379320832;
        v47 = 1465384362;
        v48 = 969356546;
        v49 = 1556836777;
        v50 = 307426473;
        v10 = v2 | 1;
        v12 = 0;
        if ( EAC::Memory::DecryptStr16(&v34, v66) )
        {
          v11 = *(a1 + 67);
          if ( v11 )
          {
            if ( !*(v11 + 32) )
              v12 = 1;
          }
        }
        v68 = v10 & 0xFFFFFFFE;
        memset(v66, 0, 0x44ui64);
        if ( v12 )
        {
          v34 = -1969993559;
          v35 = -1144243536;
          v36 = 242064136;
          v37 = 187676638;
          v38 = -1991878171;
          v39 = 96452294;
          v40 = -149557856;
          v41 = -694104463;
          v42 = -1557300779;
          v43 = -566847724;
          v44 = 510674766;
          v45 = 839459207;
          v46 = -379320832;
          v47 = 1465384362;
          v48 = 969356546;
          v49 = 1556836777;
          v50 = 307426473;
          v13 = EAC::Memory::DecryptStr16(&v34, v66);
          LODWORD(v33) = v55;
          LODWORD(v32) = v57;
          sub_14002B218(*(a1 + 67), v13, v54, v56, v32, v33);
          memset(v66, 0, 0x44ui64);
        }
        goto LABEL_35;
      }
    }
    if ( EAC::Imports::MmGetPhysicalForVirtual(i) )
    {
      v14 = *(a1 + 23);
      if ( v14 >= i && v14 < v54 + i )
        continue;
    }
    else if ( v54 <= 0x1000 || !EAC::Imports::MmGetPhysicalForVirtual(i - 4096 + v54) )
    {
      continue;
    }
LABEL_35:
    v15 = v54;
    v60 = v54;
    v65 = v54;
    v16 = v54;
    if ( v54 > 0x100000 )
      v16 = 0x100000i64;
    v54 = v16;
    EAC::Callbacks::IsInUsermodeAddressSpace(i, v16, 1);
    v17 = sub_14000F73C(&i, v5, 1024);
    v20 = v17;
    v69 = v17;
    if ( v17 )
    {
      nHASH = EAC::Memory::GetSomeHash(v18, 2, v5, v17);
      v22 = nHASH;
      if ( (nHASH != 0x1523ABE1 || v57 == 0x20000)// whitelisted module hashes? lol
        && (nHASH != 0x3EF9544D || v56 == 64)
        && (nHASH != 0x7D73439 || v57 == 0x20000) )
      {
        if ( nHASH == 0x1D73F827 )
        {
          if ( v57 == 0x1000000
            || (v23 = *a1, v23 <= 0x3E) && (v24 = 0x4002000800121000i64, _bittest64(&v24, v23))
            || v23 == 81
            || v23 == 89 )
          {
            v22 = 0;
          }
        }
        if ( v22 )
          goto SKIP_LOOP_LABEL;
      }
      v22 = 0;
      for ( j = 0; ; ++j )
      {
        v58[2] = j;
        if ( j >= v20 )
          break;
        v26 = 0;
        v27 = 0;
        v51 = 0i64;
        v28 = 0;
        for ( k = 0i64; ; k = (k + 1) )
        {
          v58[1] = k;
          LODWORD(v51) = v5[4 * j + 2];
          v29 = k == v51;
          if ( k >= v51 )
            break;
          v30 = *(k + *&v5[4 * j]);
          if ( v30 == 120 )
          {
            v26 |= 1u;
            v28 = 0;
            v51 = ++v27;
            if ( v27 == 3 )
              v26 |= 4u;
          }
          else
          {
            if ( v30 != 63 )
            {
              v29 = k == v51;
              break;
            }
            v26 |= 2u;
            v27 = 0;
            LODWORD(v51) = 0;
            HIDWORD(v51) = ++v28;
            if ( v28 == 2 )
              v26 |= 8u;
          }
        }
        if ( v29 && v26 == 15 )
        {
          v22 = 693986245;
          v20 = v69;
          break;
        }
        v20 = v69;
      }
      if ( v22 )
SKIP_LOOP_LABEL:
        sub_140031DC8(v22, &i, v5, v20, a1);
      v15 = v60;
    }
    if ( v54 > 0x1000 )
      v59 = EAC::Callbacks::SomeDisassemblerShitWrapper(&i, v3, k, v59, v61, v58);
    v2 = v68;
    v54 = v15;
  }
  EAC::Callbacks::KeUnstackDetachProcess(*(a1 + 1), v67);
  v31 = a1[10];
  if ( (v31 == 64 && i < 0x7FFFFFF0000i64 || v31 == 32 && i < 0x7FFE0000)
    && EAC::Imports::PsGetProcessExitProcessCalled(*(a1 + 1))
    && !*(a1 + 544) )
  {
    EAC::Callbacks::ReportViolation_1(a1, 0x49C7C002i64, &i, 8i64, 0i64);
  }
LABEL_83:
  if ( v58[0] )
  {
    *v4 = v58[0];
    EAC::Callbacks::ReportViolation_1(a1, 0x7A8B5AF5i64, v4, (v59 - v4), 0i64);
  }
LABEL_85:
  if ( v4 )
    EAC::Memory::ExFreePool(v4);
  if ( v3 )
    EAC::Memory::ExFreePool(v3);
  if ( v5 )
    EAC::Memory::ExFreePool(v5);
}

void __fastcall EAC::Callbacks::DetectLoadedModulesInGame(__int64 a1, unsigned int a2, unsigned __int64 a3, __int64 a4)
{
  unsigned __int16 *v4; // rsi
  __int64 v7; // rax
  __int16 v8; // bx
  __int64 v9; // rax
  int v10; // eax
  unsigned int v11; // er12
  _OWORD *v12; // rax
  __int64 v13; // r14
  char *i; // rax
  __int64 v15; // rdx
  unsigned int v16; // ebx
  __int64 v17[2]; // [rsp+50h] [rbp-88h] BYREF
  char v18[16]; // [rsp+60h] [rbp-78h] BYREF
  char *v19; // [rsp+70h] [rbp-68h] BYREF
  char *v20; // [rsp+78h] [rbp-60h]
  unsigned __int64 v21; // [rsp+88h] [rbp-50h]
  int v22; // [rsp+98h] [rbp-40h]

  if ( a1 )
  {
    v4 = a4;
    if ( a3 )
    {
      if ( !a4 || !*(a4 + 8) || !*a4 || !*(a4 + 2) )
        v4 = (v18 & -(EAC::Memory::GetMappedFilename(-1i64, a3, v18) != 0));
      v7 = EAC::Imports::PsGetCurrentProcess();
      v8 = EAC::Imports::PsGetCurrentProcessID(v7);
      v9 = EAC::Imports::PsGetCurrentProcess();
      v10 = EAC::Imports::PsGetProcessWow64(v9);
      v11 = 0x8000;
      v12 = EAC::Memory::CopyProcessInformation(a3, 0x1000ui64, 0x8000ui64, 0, v10, v4, v8, v17);
      v13 = v12;
      v17[1] = v12;
      if ( v12 )
      {
        *(v12 + 22) = 0;
        for ( i = a3; ; i = &v19[v21] )
        {
          v19 = i;
          if ( !v11 )
            break;
          if ( !EAC::Imports::NtQueryVirtualMemory(-1i64, i, 0i64, &v19, 48i64) )
            break;
          if ( v20 != a3 )
            break;
          v15 = (v21 + 4095) & 0xFFFFFFFFFFFFF000ui64;
          v21 = v15;
          if ( !v15 )
            break;
          EAC::Callbacks::IsInUsermodeAddressSpace(v19, v15, 1);
          if ( v22 == 0x1000000 && v19 == v20 )
          {
            *(v13 + 26) |= 2u;
            if ( !EAC::Memory::GetImageBase(v19, v21) )
              *(v13 + 26) |= 0x80u;
          }
          v16 = v11;
          if ( v11 > v21 )
            v16 = v21;
          EAC::Memory::memmove((v17[0] + *(v13 + 22)), v19, v16);
          *(v13 + 22) += v16;
          v11 -= v16;
        }
        EAC::Callbacks::ReportViolation_1(a1, a2, v13, (*(v13 + 10) + *(v13 + 22)), 0i64);
        EAC::Memory::ExFreePool(v13);
      }
      if ( v4 == v18 )
        EAC::Memory::FreeUnicdeString(v18);
    }
  }
}

void __fastcall EAC::Callbacks::DetectLoadedModulesInGame2(__int64 pStr, __int64 a2, unsigned int a3)
{
  __int64 v4; // r14
  unsigned __int64 v6; // r12
  _OWORD *v7; // rax
  __int64 v8; // rbx
  __int64 v9; // rsi
  unsigned int v10; // er13
  __int64 v11; // rdi
  unsigned __int64 v12; // r15
  __int64 v13; // [rsp+80h] [rbp+8h]
  __int64 v14; // [rsp+98h] [rbp+20h] BYREF

  if ( pStr )
  {
    v13 = pStr;
    v4 = a2;
    if ( *(pStr + 32) )
    {
      if ( a2 )
      {
        if ( a3 )
        {
          v6 = 0x8000i64;
          v7 = EAC::Memory::CopyProcessInformation(*(pStr + 16), *(pStr + 24), 0x8000ui64, 4, 64, pStr, 0, &v14);
          v8 = v7;
          if ( v7 )
          {
            if ( *(pStr + 28) )
              *(v7 + 26) |= 0x400u;
            v9 = 0i64;
            v10 = 0;
            if ( a3 )
            {
              v11 = v14;
              do
              {
                v12 = (*(v4 + 8) + 1);
                if ( v12 > v6 )
                  break;
                EAC::Memory::memmove((v9 + v11), *v4, v12);
                v9 += v12;
                v6 -= v12;
                ++v10;
                v4 += 16i64;
              }
              while ( v10 < a3 );
              if ( v9 )
              {
                EAC::Callbacks::ReportViolation(*(v13 + 32), v8, (v9 + *(v8 + 10)));
                memset(v8, 0, (v9 + *(v8 + 10)));
              }
            }
            EAC::Memory::ExFreePool(v8);
          }
        }
      }
    }
  }
}

void EAC::Callbacks::CloseGameProcess()
{
  if ( EAC::Globals::GameProcessID )
  {
    EAC::Callbacks::TerminateUsermodeProcess(EAC::Globals::GameProcessID, 0);
    EAC::Globals::GameProcessID = 0i64;
  }
  if ( Event )
  {
    ObfDereferenceObject(Event);
    Event = 0i64;
  }
  EAC::Globals::ProcessID = 0i64;
}

char __fastcall EAC::Callbacks::ResetGameProcessID(__int64 a1)
{
  char result; // al

  if ( !a1 || a1 != EAC::Globals::GameProcessID )
    return 0;
  EAC::Globals::ProcessID = 0i64;
  result = 1;
  EAC::Globals::GameProcessID = 0i64;
  return result;
}

```

`hwid.cpp`:

```cpp
char __fastcall EAC::HWID::GetMACAddress(__int64 a1, void *a2)
{
  char v2; // bl
  int v4; // [rsp+20h] [rbp-28h] BYREF
  void *v5; // [rsp+28h] [rbp-20h]
  char v6; // [rsp+30h] [rbp-18h]

  v2 = 0;
  v4 = a1;
  v5 = a2;
  v6 = 0;
  if ( !a2 || a1 != 6 )
    return 0;
  if ( EAC::HWID::GetFirstNetworkDeviceMacAddress(a1, a2, &v4) )
  {
    if ( v6 )
      v2 = 1;
  }
  return v2;
}

char __fastcall EAC::HWID::GetFirstNetworkDeviceMacAddress(__int64 a1, void *a2, __int64 a3)
{
  __int64 v4; // r14
  char v5; // si
  int (__fastcall *v6)(void *, _QWORD, __int64, PVOID *); // rax
  __int64 v7; // r8
  char *v8; // rcx
  char *v9; // rbx
  __int64 v10; // r8
  unsigned __int32 v11; // edx
  unsigned __int64 v12; // rdi
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rax
  __int64 i; // r14
  char *v17; // rbx
  __int64 v18; // r8
  unsigned int v19; // edx
  unsigned __int64 v20; // rdi
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rax
  __int64 v24; // rdi
  char *v25; // rdx
  __int64 v26; // r9
  char v27; // al
  __int64 v28; // rdx
  int v30[4]; // [rsp+20h] [rbp-50h]
  int v31[4]; // [rsp+30h] [rbp-40h]
  char v32[16]; // [rsp+40h] [rbp-30h] BYREF
  __int128 v33; // [rsp+50h] [rbp-20h] BYREF
  __int128 v34; // [rsp+60h] [rbp-10h] BYREF
  PVOID P; // [rsp+B8h] [rbp+48h] BYREF
  __int128 *v36; // [rsp+C8h] [rbp+58h]

  P = a2;
  v4 = 0i64;
  v5 = 1;
  if ( KeGetCurrentIrql() )
    return 0;
  v6 = EAC::Memory::ResolveImportWrapper(*IoGetDeviceInterfaces, IoGetDeviceInterfaces, 0i64);
  if ( !v6 || v6(&unk_14006E450, 0i64, v7, &P) < 0 )
    return 0;
  v8 = P;
  do
  {
    v9 = &v8[2 * v4];
    if ( !*v9 )
      break;
    v10 = -1i64;
    do
      ++v10;
    while ( *&v9[2 * v10] );
    v30[0] = -1172472817;
    v30[1] = -1869928664;
    v33 = 0i64;
    v30[2] = 2023745324;
    v11 = 861309531;
    v30[3] = 858689899;
    v12 = 0i64;
    v36 = &v33;
    do
    {
      v11 = _byteswap_ulong(((v11 ^ (v11 >> 7)) << 9) ^ v11 ^ (v11 >> 7) ^ ((((v11 ^ (v11 >> 7)) << 9) ^ v11 ^ (v11 >> 7)) >> 13));
      *(v36 + v12 * 4) = v30[v12] ^ v11;
      ++v12;
    }
    while ( v12 < 4 );
    v13 = sub_140007C9C(v9, &v33);
    memset(&v33, 0, sizeof(v33));
    if ( v13 == v9 )
    {
      EAC::Memory::InitializeUnicodeStringWithCString(v32, v9);
      v5 = EAC::HWID::GetMacAddressSecondary(0i64, v32, a3, v14);
    }
    v8 = P;
    v15 = -1i64;
    do
      ++v15;
    while ( *(P + v4 + v15) );
    v4 += v15 + 1;
  }
  while ( v5 );
  for ( i = 0i64; v5; i += v23 + 1 )
  {
    v17 = &v8[2 * i];
    if ( !*v17 )
      break;
    v18 = -1i64;
    do
      ++v18;
    while ( *&v17[2 * v18] );
    v31[0] = -893088486;
    v31[1] = 781382351;
    v34 = 0i64;
    v31[2] = 489497106;
    v19 = 1526199263;
    v31[3] = 1870561;
    v20 = 0i64;
    v36 = &v34;
    do
    {
      v19 = ~(((v19 ^ (v19 << 13)) >> 17) ^ v19 ^ (v19 << 13) ^ (32 * (((v19 ^ (v19 << 13)) >> 17) ^ v19 ^ (v19 << 13))));
      *(v36 + v20 * 4) = v31[v20] ^ v19;
      ++v20;
    }
    while ( v20 < 4 );
    v21 = sub_140007C9C(v17, &v34);
    memset(&v34, 0, sizeof(v34));
    if ( v21 == v17 )
    {
      EAC::Memory::InitializeUnicodeStringWithCString(v32, v17);
      v5 = EAC::HWID::GetMacAddressSecondary(1i64, v32, a3, v22);
    }
    v8 = P;
    v23 = -1i64;
    do
      ++v23;
    while ( *(P + i + v23) );
  }
  v24 = 0i64;
  if ( v5 )
  {
    do
    {
      v25 = &v8[2 * v24];
      if ( !*v25 )
        break;
      EAC::Memory::InitializeUnicodeStringWithCString(v32, v25);
      v27 = EAC::HWID::GetMacAddressSecondary(2i64, v32, a3, v26);
      v8 = P;
      v28 = -1i64;
      do
        ++v28;
      while ( *(P + v24 + v28) );
      v24 += v28 + 1;
    }
    while ( v27 );
  }
  ExFreePoolWithTag(v8, 0);
  return 1;
}

char __fastcall EAC::HWID::CollectProcessorFeatures(__int64 a1)
{
  unsigned int v2; // ebx
  __int128 *v4; // r8
  __int16 *v5; // rdx
  __int64 v6; // rax
  wchar_t *v7; // rcx
  __int128 v8; // [rsp+20h] [rbp-A8h] BYREF
  int v9; // [rsp+30h] [rbp-98h]
  __m128 v10[8]; // [rsp+40h] [rbp-88h] BYREF

  v9 = 0;
  v8 = 0i64;
  EAC::Memory::memset(v10, 0, 0x80ui64);
  v2 = 0;
  if ( !a1 )
    return 0;
  EAC::HWID::HashVar(0xFFFFF78000000274ui64, 0x40u, &v8);// ProcessorFeatures
  v4 = &v8;
  v5 = &v10[0].m128_i16[1];
  do
  {
    v6 = *v4;
    ++v2;
    v4 = (v4 + 1);
    v7 = off_1400534C0[v6];
    *(v5 - 1) = *v7;
    *v5 = v7[1];
    v5 += 2;
  }
  while ( v2 < 0x14 );
  return CreateUnicodeStringFromPWSTR(a1, v10);
}

char __fastcall EAC::HWID::HashFileInfromation(__int64 CurrentProcess, struct_pHWIDStruct *pHWIDStruct)
{
  __int64 bGetFileOnDisk; // rcx
  struct_pScanned_1 *pScanned; // rax
  struct_pScanned_1 *_pScanned; // rdi
  char v8[56]; // [rsp+20h] [rbp-38h] BYREF

  // Not sure if this is even a HWID related function.. It's probably them just sending process info to their servers.
  if ( !CurrentProcess || !pHWIDStruct || !EAC::Imports::PsGetProcessExitProcessCalled(CurrentProcess) )
    return 0;
  memset(pHWIDStruct, 0, 0x338ui64);
  if ( EAC::Callbacks::KeStackAttachProcess(CurrentProcess, v8) )
  {
    LOBYTE(bGetFileOnDisk) = 1;
    pScanned = EAC::Calbacks::ScanProcess(bGetFileOnDisk);
    _pScanned = pScanned;
    if ( pScanned )
    {
      pHWIDStruct->byte100 = *(pScanned->pInfoStruct + 30i64);
      EAC::Memory::CopyUnicodeStringToAnsiBuffer(pHWIDStruct, 256i64, &pScanned->unsigned___int1618);
      pHWIDStruct->dword104 = *(_pScanned->pInfoStruct + 0x250i64);
      pHWIDStruct->dword10C = *(_pScanned->pInfoStruct + 0x240i64);
      pHWIDStruct->dword108 = *(_pScanned->pInfoStruct + 0x234i64);
      pHWIDStruct->dword130 = *(_pScanned->pInfoStruct + 0x24Ci64);
      pHWIDStruct->dword134 = *(_pScanned->pInfoStruct + 0x248i64);
      EAC::Memory::CopyRawDataFromDebugDirectory(*(_pScanned->pInfoStruct + 14i64), &pHWIDStruct[1], 256);
      pHWIDStruct->nMicrosoftFileHash = EAC::HWID::HashMicrosoftFilesWrapper(*(_pScanned->pInfoStruct + 0xEi64));
      pHWIDStruct->qword120 = EAC::HWID::HashMoreFileShitNotSureWhatWrapper(*(_pScanned->pInfoStruct + 0xEi64));
      pHWIDStruct->qword128 = EAC::HWID::HashDosHeadersWrapper(*(_pScanned->pInfoStruct + 0xEi64));
      EAC::Memory::FreePoolAndUnicodeString(_pScanned);
    }
    EAC::Callbacks::KeUnstackDetachProcess(CurrentProcess, v8);
  }
  return 1;
}

char __fastcall EAC::HWID::SetNTOSKRNLOptionalHeaderHash(unsigned __int64 pCurrentFileBeingReadInMemory, unsigned int a2, _OWORD *pOutput)
{
  char bGrabbedHWID; // di
  __int64 v6; // rsi
  _IMAGE_NT_HEADERS64 *v7; // rax
  IMAGE_DATA_DIRECTORY *v8; // r8
  unsigned __int64 v9; // rax
  __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rcx
  unsigned int v13; // er14
  _IMAGE_NT_HEADERS64 *v14; // rdx
  char *v15; // rax
  unsigned int v16; // ecx
  __int64 v17; // rbx

  bGrabbedHWID = 0;
  if ( pOutput )
  {
    if ( pCurrentFileBeingReadInMemory )
    {
      v6 = a2;
      v7 = EAC::Memory::GetImageBase(pCurrentFileBeingReadInMemory, a2);
      if ( v7 )
      {
        v8 = &v7->OptionalHeader.DataDirectory[4];
        if ( v7->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC )
          v8 = &v7->OptionalHeader.DataDirectory[6];
        if ( v8->VirtualAddress )
        {
          if ( v8->Size )
          {
            v9 = sub_14004EC8C(v8->VirtualAddress, v7, pCurrentFileBeingReadInMemory);
            if ( v9 >= pCurrentFileBeingReadInMemory && v9 + 28 > v9 )
            {
              v11 = pCurrentFileBeingReadInMemory + v6;
              if ( v9 + 28 <= v11 )
              {
                v12 = *(v9 + 20);
                if ( v12 )
                {
                  v13 = *(v9 + 16);
                  if ( v13 )
                  {
                    if ( *(v9 + 12) == 2 )
                    {
                      v14 = sub_14004EC8C(v12, v10, pCurrentFileBeingReadInMemory);
                      if ( v14 >= pCurrentFileBeingReadInMemory )
                      {
                        v15 = v14 + v13;
                        if ( v15 > v14 && v15 <= v11 && v14->Signature == 'SDSR' )
                        {
                          v16 = 255;
                          if ( v13 - 25 < 0xFF )
                            v16 = v13 - 25;
                          v17 = v16;
                          EAC::Memory::memmove(pOutput, &v14->OptionalHeader, v16);
                          *(pOutput + v17) = 0;
                          bGrabbedHWID = 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return bGrabbedHWID;
}

unsigned __int64 __fastcall EAC::HWID::HashMicrosoftFiles(unsigned __int64 a1, unsigned int CONSTANT_4096)
{
  __m128 *v4; // rsi
  _IMAGE_NT_HEADERS64 *pOptionalHeaders; // rcx
  __int64 nSizeOfCode; // rbx
  _IMAGE_NT_HEADERS64 *v7; // rdx
  ULONG *nNumberOfSymbols; // rcx
  __int128 pHashed; // [rsp+28h] [rbp-E0h] BYREF
  unsigned int nLiterallyZero; // [rsp+38h] [rbp-D0h]
  __m128 pOriginalStruct_MaybeIdk[32]; // [rsp+48h] [rbp-C0h] BYREF

  EAC::Memory::memset(pOriginalStruct_MaybeIdk, 0, 0x200ui64);
  v4 = pOriginalStruct_MaybeIdk;
  nLiterallyZero = 0;
  pHashed = 0i64;
  if ( a1 )
  {
    if ( CONSTANT_4096 >= 512 )
    {
      pOptionalHeaders = EAC::Memory::GetImageBase(a1, CONSTANT_4096);
      if ( pOptionalHeaders )
      {
        while ( pOptionalHeaders > a1 )
        {
          pOptionalHeaders = (pOptionalHeaders - 4);
          if ( pOptionalHeaders->Signature == 'hciR' )// (END MARKER)
          {
            if ( pOptionalHeaders > a1 )
            {
              nSizeOfCode = *&pOptionalHeaders->FileHeader.Machine;
              v7 = pOptionalHeaders;
              while ( pOptionalHeaders > a1 )
              {
                pOptionalHeaders = (pOptionalHeaders - 4);
                if ( (pOptionalHeaders->Signature ^ nSizeOfCode) == 'SnaD' )// (START MARKER)
                {
                  if ( pOptionalHeaders <= a1 )
                    return 0i64;
                  if ( *&pOptionalHeaders->FileHeader.Machine != nSizeOfCode )
                    return 0i64;
                  if ( pOptionalHeaders->FileHeader.TimeDateStamp != nSizeOfCode )
                    return 0i64;
                  if ( pOptionalHeaders->FileHeader.PointerToSymbolTable != nSizeOfCode )
                    return 0i64;
                  nNumberOfSymbols = &pOptionalHeaders->FileHeader.NumberOfSymbols;
                  if ( (((v7 - nNumberOfSymbols) >> 2) - 2) > 126 )
                    return 0i64;
                  while ( nNumberOfSymbols < v7 )
                  {
                    v4->m128_i32[0] = *nNumberOfSymbols ^ nSizeOfCode;
                    v4 = (v4 + 4);
                    ++nNumberOfSymbols;
                  }
                  EAC::HWID::HashVar(pOriginalStruct_MaybeIdk, v4 - pOriginalStruct_MaybeIdk, &pHashed);
                  return nLiterallyZero ^ DWORD2(pHashed) ^ pHashed | ((nSizeOfCode ^ HIDWORD(pHashed) ^ DWORD1(pHashed)) << 32);
                }
              }
            }
            return 0i64;
          }
        }
      }
    }
  }
  return 0i64;
}

unsigned __int64 __fastcall EAC::HWID::HashDosHeaders(__int64 a1, unsigned int CONSTANT_4096)
{
  _IMAGE_NT_HEADERS64 *pNtHeaders; // rax
  __int64 ntype; // rcx
  __int128 v5; // [rsp+20h] [rbp-28h] BYREF
  unsigned int v6; // [rsp+30h] [rbp-18h]

  v6 = 0;
  v5 = 0i64;
  if ( !a1 )
    return 0i64;
  if ( CONSTANT_4096 < 512 )
    return 0i64;
  pNtHeaders = EAC::Memory::GetImageBase(a1, CONSTANT_4096);
  if ( !pNtHeaders )
    return 0i64;
  ntype = 120i64;
  if ( pNtHeaders->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC )
    ntype = 136i64;
  EAC::HWID::HashVar(pNtHeaders + ntype, 0x80u, &v5);
  return ((HIDWORD(v5) ^ DWORD1(v5)) << 32) | v6 ^ DWORD2(v5) ^ v5;
}

char __fastcall EAC::HWID::HashNTOSKRNLInformation(__int64 pInputStruct, struct_a2 *pOutputStruct)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v2 = 0i64;
  P = 0i64;
  FileLength = 0;
  bHasPassedAlotOfChecksWtf = 0;
  UNICODESTR = 0i64;
  if ( !pOutputStruct || !pInputStruct || !*(pInputStruct + 8) || !*pInputStruct || !*(pInputStruct + 2) )
    return 0;
  memset(pOutputStruct, 0, 0x338ui64);
  EAC::Memory::CopyUnicodeStringToAnsiBuffer(pOutputStruct, 256i64, pInputStruct);
  if ( EAC::Memory::CopyOverUnicodeString(v5, &UNICODESTR) )// \SystemRoot\system32\ntoskrnl.exe
  {
    if ( EAC::Memory::ForceReadFile(&UNICODESTR, &P, &FileLength) )// calls ZwReadFile and sets parameters with info
    {
      Size = FileLength;
      pCurrentFileBeingReadInMemory = P;
      v41 = FileLength;
      if ( P && FileLength )
      {
        bHasCompletedScan = 0;
        v9 = P + FileLength;
        P = v9;
        if ( FileLength )                       // all this block of code does is set bHasPassedAlotOfChecksWtf after checking if file is valid enough
        {
          v10 = 0i64;
          pNTHeaders_1 = EAC::Memory::GetImageBase(pCurrentFileBeingReadInMemory, FileLength);
          if ( pNTHeaders_1 )
          {
            v12 = 152i64;
            if ( pNTHeaders_1->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC )
              v12 = 168i64;
            pDOSHeaders_1 = (pNTHeaders_1 + v12);
            if ( pDOSHeaders_1 )
            {
              if ( pDOSHeaders_1 >= pCurrentFileBeingReadInMemory
                && pDOSHeaders_1 + 2 > pDOSHeaders_1
                && pDOSHeaders_1 + 2 <= v9 )
              {
                v14 = pDOSHeaders_1[1];
                if ( v14 )
                {
                  e_magic = *pDOSHeaders_1;
                  if ( *pDOSHeaders_1 )
                  {
                    for ( i = 0; i < v14; i += *&nCurrentSectionSignatureMaybe->e_magic )
                    {
                      nCurrentSectionSignatureMaybe = (pCurrentFileBeingReadInMemory + e_magic + i);
                      if ( nCurrentSectionSignatureMaybe < pCurrentFileBeingReadInMemory
                        || &nCurrentSectionSignatureMaybe->e_maxalloc <= nCurrentSectionSignatureMaybe
                        || &nCurrentSectionSignatureMaybe->e_maxalloc > P
                        || !*&nCurrentSectionSignatureMaybe->e_magic )
                      {
                        break;
                      }
                      if ( nCurrentSectionSignatureMaybe->e_crlc == 2 )
                      {
                        v10 = pCurrentFileBeingReadInMemory + e_magic + i;
                        bHasCompletedScan = 1;
                        break;
                      }
                    }
                    if ( bHasCompletedScan )
                    {
                      v18 = *v10;
                      v19 = (v10 + 8);
                      v20 = v18 - 8;
                      if ( v19 >= pCurrentFileBeingReadInMemory )
                      {
                        v21 = &v19[v20];
                        if ( v21 > v19 && v21 <= &v41[pCurrentFileBeingReadInMemory] )
                        {
                          v22 = EAC::Memory::ExAllocatePoolWithRandomTag2(72i64);
                          v2 = v22;
                          if ( v22 )
                          {
                            v44 = 0i64;
                            v41 = v19;
                            LODWORD(P) = v20;
                            memset(v22, 0, 0x48ui64);
                            v42 = 0i64;
                            v43 = 0i64;
                            if ( v19
                              && v20
                              && (memset(v22, 0, 0x48ui64), sub_140049E28(1, &v41, &P, &v42))
                              && v42 == 16
                              && sub_140049E28(1, &v41, &P, &v42)
                              && v42 == 6
                              && v43 == 9
                              && **(&v42 + 1) == 0x7010DF78648862Ai64
                              && *(*(&v42 + 1) + 8i64) == 2
                              && sub_140049E28(1, &v41, &P, &v42)
                              && !v42
                              && sub_140049E28(1, &v41, &P, &v42)
                              && v42 == 16
                              && v43
                              && sub_140035494(*(&v42 + 1), v43, v2) )
                            {
                              bHasPassedAlotOfChecksWtf = 1;
                            }
                            else
                            {
                              EAC::Memory::ExFreePool(v2);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          Size = FileLength;
        }
        if ( bHasPassedAlotOfChecksWtf )
        {
          EAC::Memory::CopyUnicodeStringToAnsiBuffer(&pOutputStruct[1].gap1[239], 256i64, &v2[1].Length);
          if ( !RtlCompareUnicodeString(v2 + 1, v2, 0) )
            pOutputStruct->byte101 = 1;
          if ( v2 )
          {
            v23 = v2->Buffer;
            if ( v23 )
            {
              EAC::Memory::ExFreePool(v23);
              *v2 = 0i64;
            }
            EAC::Memory::FreeUnicdeString(&v2[1]);
            EAC::Memory::ExFreePool(v2);
          }
        }
      }
      Size2 = Size;
      v25 = EAC::Memory::GetImageBase(pCurrentFileBeingReadInMemory, Size);
      v26 = v25;
      if ( v25 )
      {
        Magic = v25->OptionalHeader.Magic;
        bHasPassedAlotOfChecksWtf = 1;
        if ( Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC )
          nImageArchitectureType = 32;
        else
          nImageArchitectureType = Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC ? 0 : 64;
        pOutputStruct->nImageArchitectureType = nImageArchitectureType;
        EAC::Memory::memset(v46, 0, 0x200ui64);
        v29 = v46;
        LODWORD(v43) = 0;
        v42 = 0i64;
        if ( pCurrentFileBeingReadInMemory )
        {
          if ( Size >= 0x200 )
          {
            pDOSHeaders = EAC::Memory::GetImageBase(pCurrentFileBeingReadInMemory, Size);
            if ( pDOSHeaders )
            {
              while ( pDOSHeaders > pCurrentFileBeingReadInMemory )
              {
                pDOSHeaders = (pDOSHeaders - 4);
                if ( *&pDOSHeaders->e_magic == 'hciR' )
                {
                  if ( pDOSHeaders <= pCurrentFileBeingReadInMemory )
                    break;
                  v31 = *&pDOSHeaders->e_cp;
                  v32 = pDOSHeaders;
                  do
                  {
                    if ( pDOSHeaders <= pCurrentFileBeingReadInMemory )
                      goto BREAK_LABEL_MEME;
                    pDOSHeaders = (pDOSHeaders - 4);
                  }
                  while ( (*&pDOSHeaders->e_magic ^ v31) != 'SnaD' );
                  if ( pDOSHeaders <= pCurrentFileBeingReadInMemory
                    || *&pDOSHeaders->e_cp != v31
                    || *&pDOSHeaders->e_cparhdr != v31
                    || *&pDOSHeaders->e_maxalloc != v31
                    || (v33 = &pDOSHeaders->e_sp, (((v32 - v33) >> 2) - 2) > 0x7E) )
                  {
BREAK_LABEL_MEME:
                    Size2 = Size;
                    break;
                  }
                  while ( v33 < v32 )
                  {
                    v29->m128_i32[0] = *v33 ^ v31;
                    v29 = (v29 + 4);
                    v33 += 2;
                  }
                  EAC::HWID::HashVar(v46, v29 - v46, &v42);
                  nEndOfHash = (v31 ^ HIDWORD(v42) ^ DWORD1(v42)) << 32;
                  Size2 = Size;
                  nRichHeadersHash = v43 ^ DWORD2(v42) ^ v42 | nEndOfHash;
                  goto DONT_NULL_OUT_RICHHEADERS_VAR;
                }
              }
            }
          }
        }
        nRichHeadersHash = 0i64;
DONT_NULL_OUT_RICHHEADERS_VAR:
        bIs64Bit = pOutputStruct->nImageArchitectureType == 64;
        pOutputStruct->nRichHeadersHash = nRichHeadersHash;
        if ( bIs64Bit )
          pOutputStruct->nHashOfSomeWeirdShit = EAC::HWID::HashMoreFileShitNotSureWhat(
                                                  pCurrentFileBeingReadInMemory,
                                                  Size,
                                                  0);
        pOutputStruct->nImageAddressOfEntryPoint = v26->OptionalHeader.AddressOfEntryPoint;
        pOutputStruct->nImageSizeofCode = v26->OptionalHeader.SizeOfCode;
        LODWORD(v43) = 0;
        v42 = 0i64;
        if ( pCurrentFileBeingReadInMemory
          && Size >= 0x200
          && (pNTHeaders = EAC::Memory::GetImageBase(pCurrentFileBeingReadInMemory, Size2)) != 0i64 )
        {
          v37 = 0x78i64;
          if ( pNTHeaders->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC )
            v37 = 0x88i64;
          EAC::HWID::HashVar(pNTHeaders + v37, 0x80u, &v42);
          nHash = ((HIDWORD(v42) ^ DWORD1(v42)) << 32) | v43 ^ DWORD2(v42) ^ v42;
        }
        else
        {
          nHash = 0i64;
        }
        pOutputStruct->nNTHeadersHash = nHash;
        EAC::HWID::SetNTOSKRNLOptionalHeaderHash(
          pCurrentFileBeingReadInMemory,
          Size,
          &pOutputStruct->nNTOSKRNLOptionalHash);
        pOutputStruct->nImageChecksum = v26->OptionalHeader.CheckSum;
        pOutputStruct->nImageSizeOf = v26->OptionalHeader.SizeOfImage;
        pOutputStruct->nImageTimeDateStamp = v26->FileHeader.TimeDateStamp;
      }
      else
      {
        bHasPassedAlotOfChecksWtf = 0;
      }
      pOutputStruct->ImageSize = Size;
      if ( pCurrentFileBeingReadInMemory )
        EAC::Memory::ExFreePool(pCurrentFileBeingReadInMemory);
    }
    EAC::Memory::FreeUnicdeString(&UNICODESTR);
  }
  return bHasPassedAlotOfChecksWtf;
}

unsigned __int64 __fastcall EAC::HWID::HashMoreFileShitNotSureWhat(unsigned __int64 a1, unsigned int a2, char a3)
{
  unsigned __int64 v5; // rbx
  unsigned __int64 result; // rax
  __int64 v7; // r15
  __int64 v8; // rax
  __int64 v9; // rdx
  unsigned int *v10; // rsi
  __int64 v11; // rax
  unsigned __int64 v12; // r14
  unsigned __int64 v13; // r9
  unsigned int *v14; // rcx
  unsigned int v15; // edx
  __int128 v16; // [rsp+30h] [rbp-38h] BYREF
  unsigned int v17; // [rsp+40h] [rbp-28h]

  v5 = 0i64;
  result = 0i64;
  v16 = 0i64;
  v17 = 0;
  if ( a1 && a2 )
  {
    v7 = a2;
    v8 = EAC::Memory::GetImageBase(a1, a2);
    if ( v8 && EAC::Memory::GetProcessArchitectureType(v8) == 64 )
    {
      v10 = (v9 + 144);
      if ( *(v9 + 24) != 267 )
        v10 = (v9 + 160);
      v11 = *v10;
      if ( v11 )
      {
        v12 = v10[1];
        if ( v12 )
        {
          v13 = a3 ? v11 + a1 : sub_14004EC8C(v11, v9, a1);
          if ( v13 >= a1 && v12 + v13 > v13 && v12 + v13 <= v7 + a1 && v12 == 12 * (v12 / 12) )
          {
            v14 = v13;
            v15 = 0;
            while ( v14 < v13 + 12 * (v12 / 12) )
            {
              if ( v15 > *v14 )
                goto LABEL_21;
              v15 = *v14;
              v14 += 3;
            }
            EAC::HWID::HashVar(v13, v12, &v16);
            v5 = v17 ^ DWORD2(v16) ^ v16 | ((HIDWORD(v16) ^ DWORD1(v16) ^ v10[1]) << 32);
          }
        }
      }
    }
LABEL_21:
    result = v5;
  }
  return result;
}

```

`injection.cpp`:

```cpp
bool __fastcall EAC::Callbacks::BeginWindowsInjection(__int64 a1)
{
  _UNICODE_STRING *v1; // r14
  bool v3; // bl
  char v4; // di
  unsigned int v5; // edx
  unsigned __int64 v6; // rdi
  unsigned __int64 i; // r8
  char v8; // cl
  int v9; // eax
  char v10; // dl
  __m128 *pBuffer; // rax
  __int64 v13; // rdx
  __m128 *v14; // rdi
  bool v15; // al
  int v16[21]; // [rsp+20h] [rbp-79h]
  __int16 v17; // [rsp+74h] [rbp-25h]
  char v18[122]; // [rsp+76h] [rbp-23h] BYREF

  v1 = (a1 + 16);
  v3 = 0;
  v4 = 0;
  if ( !EAC::Memory::ExAllocatePoolWithRandomTag2Wrapper(a1 + 16, 0x1000u) )
    goto LABEL_6;
  v16[0] = -1161486776;
  v17 = -7342;
  v16[1] = 2131784440;
  v16[2] = -1779023309;
  v16[3] = 1647530064;
  v16[4] = 883744188;
  v16[5] = 724101881;
  v16[6] = 2011759064;
  v16[7] = 496383216;
  v16[8] = -1184496954;
  v16[9] = 36685397;
  v16[10] = 930039539;
  v16[11] = -836592059;
  v16[12] = 1150566866;
  v16[13] = -919534435;
  v16[14] = 2032694796;
  v16[15] = 8270150;
  v16[16] = -1979060004;
  v16[17] = 771305898;
  v16[18] = -1362328921;
  v16[19] = -1669975869;
  v16[20] = 1112865952;
  EAC::Memory::memset(v18, 0, 0x56ui64);
  v5 = -1164567020;
  v6 = 84i64;
  for ( i = 0i64; i < 21; ++i )
  {
    *&v18[i * 4] = v16[i] ^ v5;
    v5 = __ROL4__(((v5 ^ (v5 << 13)) >> 7) ^ v5 ^ (v5 << 13) ^ ((((v5 ^ (v5 << 13)) >> 7) ^ v5 ^ (v5 << 13)) << 17), 4);
  }
  do
  {
    v8 = v5;
    v5 >>= 8;
    v18[v6] = *(v16 + v6) ^ v8;
    ++v6;
  }
  while ( v6 < 0x56 );
  v4 = 1;
  v9 = EAC::Memory::RtlUnicodeStringPrintf(v1, v18, __rdtsc());
  v10 = 0;
  if ( v9 < 0 )
LABEL_6:
    v10 = 1;
  if ( (v4 & 1) != 0 )
    memset(v18, 0, 0x56ui64);
  if ( v10 )
    return 0;
  pBuffer = EAC::Memory::GetImageBuffer(&unk_140066E90, 21992i64);
  v14 = pBuffer;
  if ( pBuffer )
  {
    if ( EAC::Memory::ForceWriteFile(v1, v13, pBuffer) )
    {
      *(a1 + 8) = 1;
      v15 = EAC::Callbacks::LoadLibraryInjection(a1, 1) >= 0;
      *(a1 + 9) = v15;
      v3 = v15;
    }
    EAC::Memory::memset(v14, 0, 0x55E8ui64);
    EAC::Memory::ExFreePool(v14);
  }
  return v3;
}

char __fastcall EAC::Callbacks::BeginWindowsInjectionWrapper(PVOID Object)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v1 = 0;
  v2 = 0;
  if ( !Object || !EAC::Globals::UnknownInjectionBoolean )
    goto LABEL_20;
  ExAcquireFastMutex(&stru_140073E70);
  v4 = 0i64;
  v5 = &EAC::Globals::LoadLibraryInjectionStruct;
  while ( *v5 != Object )
  {
    ++v4;
    v5 += 4;
    if ( v4 >= 0x10 )
    {
      v6 = 0i64;
      goto LABEL_7;
    }
  }
  v6 = &EAC::Globals::LoadLibraryInjectionStruct + 32 * v4;
  if ( v6 )
  {
    v1 = v6[9];
    v9 = v6;
    goto LABEL_15;
  }
LABEL_7:
  v7 = 0i64;
  v8 = &EAC::Globals::LoadLibraryInjectionStruct;
  while ( *v8 )
  {
    ++v7;
    v8 += 4;
    if ( v7 >= 0x10 )
    {
      v9 = 0i64;
      goto LABEL_14;
    }
  }
  v10 = 32 * v7;
  *(&EAC::Globals::LoadLibraryInjectionStruct + v10 + 8) = 0i64;
  v9 = &EAC::Globals::LoadLibraryInjectionStruct + v10;
  *(&EAC::Globals::LoadLibraryInjectionStruct + v10 + 16) = 0i64;
  *(&EAC::Globals::LoadLibraryInjectionStruct + v10 + 24) = 0i64;
  *(&EAC::Globals::LoadLibraryInjectionStruct + v10) = Object;
  if ( (&EAC::Globals::LoadLibraryInjectionStruct + v10) )
    goto LABEL_15;
LABEL_14:
  v2 = 1;
LABEL_15:
  ExReleaseFastMutex(&stru_140073E70);
  if ( v6 )
    return v1;
  if ( !v2 && (ObfReferenceObject(Object), EAC::Callbacks::BeginWindowsInjection(v9)) )
    result = 1;
  else
LABEL_20:
    result = 0;
  return result;
}

__int64 __fastcall EAC::Callbacks::LoadLibraryInjection(struct_a1_1 *pInputStruct, char a2)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v34 = a2;
  v4 = 0xC0000001;
  LODWORD(v18) = 0xC0000001;
  v25 = 0i64;
  if ( !sub_140021608(&pInputStruct->unsigned___int1610, &v26) )
    return 0xC000000Di64;
  if ( EAC::Callbacks::KeStackAttachProcess(pInputStruct->HANDLE, v32) )
  {
    v8 = EAC::Imports::NtAllocateVirtualMemoryWrapper(v6, 4096i64, v7, 64);
    v9 = v8;
    v25 = v8;
    if ( !v8 )
      goto FREE_MEMORY_AND_UNSTACK_LABEL;
    EAC::Memory::CheckAddressBounds(v8, 4096i64);
    *v9 = xmmword_14006C490;
    *(v9 + 16) = xmmword_14006C4A0;
    *(v9 + 32) = xmmword_14006C4B0;
    *(v9 + 48) = xmmword_14006C4C0;
    v23[0] = 183270618;
    v23[1] = -1577622027;
    v23[2] = 851333393;
    v23[3] = 212456202;
    v23[4] = 1264994537;
    v23[5] = -444005607;
    v24 = 17185;
    v10 = EAC::Memory::DecryptStr5(v23, v30);
    v11 = EAC::Callbacks::GetUsermodeModuleWrapper(v10);
    memset(v30, 0, 0x1Aui64);
    if ( !v11 )
      goto FREE_MEMORY_AND_UNSTACK_LABEL;
    if ( a2 )
    {
      v21[0] = 0x984BB8DA;
      v21[1] = -1983652296;
      v21[2] = -1640782585;
      v22 = 43;
      v12 = 1;
      str = EAC::Memory::DecryptStr3(v21, v29);
    }
    else
    {
      HIDWORD(v18) = 974224348;
      v19 = 1879373332;
      v20 = -573867558;
      v12 = 2;
      str = EAC::Memory::DecryptStr4(&v18 + 4, v28);
    }
    *(v9 + 64) = sub_14004F1A4(v14, str);
    if ( (v12 & 2) != 0 )
    {
      v12 &= 0xFDu;
      memset(v28, 0, sizeof(v28));
    }
    if ( (v12 & 1) != 0 )
      memset(v29, 0, 0xDui64);
    if ( !*(v9 + 64) )
      goto FREE_MEMORY_AND_UNSTACK_LABEL;
    if ( v34 )
    {
      *(v9 + 72) = v9 + 80;
      EAC::Memory::memmove((v9 + 80), v27, v26);
    }
    else if ( !sub_140007B70(v33, 64i64, &v26)
           || (v15 = EAC::Callbacks::GetUsermodeModuleWrapper(v33), (*(v9 + 72) = v15) == 0i64) )
    {
FREE_MEMORY_AND_UNSTACK_LABEL:
      if ( v9 )
        EAC::Imports::NtFreeVirtualMemoryWrapper(v9);
      EAC::Callbacks::KeUnstackDetachProcess(pInputStruct->HANDLE, v32);
      return v4;
    }
    if ( EAC::Globals::RtlCreateUserThread )
    {
      v16 = EAC::Globals::RtlCreateUserThread(-1i64, 0i64, 0i64, 0i64, 0i64, 0i64, v9, v9 + 64, &Handle, 0i64);
    }
    else
    {
      if ( !EAC::Globals::RtlCreateUserThreadAlternative )
      {
        v4 = 0xC0000002;
        LODWORD(v18) = 0xC0000002;
LABEL_24:
        if ( v4 >= 0 )
        {
          ZwWaitForSingleObject(Handle, 0, 0i64);
          v4 = EAC::Imports::NtQueryInformationThread(Handle, 0, v31, 0x30u);
          LODWORD(v18) = v4;
          if ( v4 >= 0 )
          {
            v17 = LOWORD(v31[0]) | 0xC0070000;
            if ( v31[0] <= 0 )
              v17 = v31[0];
            v4 = v31[0] != 0 ? v17 : 0;
            LODWORD(v18) = v4;
          }
          EAC::Imports::NtClose(Handle);
        }
        goto FREE_MEMORY_AND_UNSTACK_LABEL;
      }
      v16 = EAC::Globals::RtlCreateUserThreadAlternative(
              -1i64,
              0i64,
              0i64,
              0i64,
              0i64,
              0i64,
              0i64,
              v9,
              v9 + 64,
              &Handle,
              0i64,
              0i64,
              v18);
    }
    v4 = v16;
    LODWORD(v18) = v16;
    goto LABEL_24;
  }
  return v4;
}

__int64 EAC::Callbacks::WindowsInjectionNumber2()
{
  struct_a1_1 *pInputStruct; // rbx
  __int64 v1; // rdi
  __int64 result; // rax

  if ( EAC::Globals::UnknownInjectionBoolean )
  {
    pInputStruct = &EAC::Globals::LoadLibraryInjectionStruct;
    v1 = 16i64;
    do
    {
      if ( pInputStruct->HANDLE )
      {
        if ( pInputStruct->gap8[1] )
          EAC::Callbacks::LoadLibraryInjection(pInputStruct, 0);
        result = EAC::Callbacks::DeleteFileByString(pInputStruct);
      }
      pInputStruct = (pInputStruct + 32);
      --v1;
    }
    while ( v1 );
  }
  return result;
}

// Most credits to mm injection reversal goes to @Sinclairq.
__int64 __fastcall EAC::Callbacks::GatherShellcodeToMap(struct_a1 *pInputStruct, __int64 a2, __int64 a3)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  pOutputStruct = 0i64;
  if ( pInputStruct )
  {
    BaseAddress = EAC::Imports::NtAllocateVirtualMemoryWrapper(pInputStruct, 4096i64, a3, 64);
    pOutputStruct = BaseAddress;
    if ( BaseAddress )
    {
      EAC::Memory::CheckAddressBounds(BaseAddress, 4096i64);
      if ( pInputStruct->ImageType == 64 )
      {                                         // Thanks to @Sinclairq for convieniently writing the shellcode all neatly like this
        *v7 = EAC::Globals::ShellcodeBuffer64Bit;//                      0x48, 0x83, 0xEC, 0x28,        // SUB RSP, 0x28
                                                //                         0x4D, 0x31, 0xC0, // XOR R8, R8
                                                //                         0x48, 0x31, 0xD2, // XOR RDX, RDX
                                                //                         0x48, 0xFF, 0xC2, // INC RDX
                                                //                         0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 0
                                                //                         0xFF, 0xD0,        // CALL RAX
                                                //                         0x48, 0x83, 0xC4, 0x28, // ADD RSP, 0x28
                                                //                         0xC3 // RETN
        v7[23] = -1;
        *&v7[15] = pInputStruct->DllEntryPoint;
        *pOutputStruct = *v7;
        *(pOutputStruct + 16) = *&v7[16];
        *(pOutputStruct + 24) = 0xC48348D0;
        *(pOutputStruct + 28) = 0xC328;
      }
      else
      {
        v8 = EAC::Globals::ShellcodeBuffer32Bit;//                         0x6A, 0x00,        // PUSH 0
                                                //                         0x6A, 0x01,        // PUSH 1
                                                //                         0xFF, 0x74, 0xE4, 0x0C, // PUSH [RSP+0xC]
                                                //                         0xB8, 0x00, 0x00, 0x00, 0x00, // MOV EAX, 0
                                                //                         0xFF, 0xD0,        // CALL EAX
                                                //                         0xC2, 0x04, 0x00 // RETN 4
        *(&v8 + 9) = pInputStruct->DllEntryPoint;
        *pOutputStruct = v8;
        *(pOutputStruct + 16) = 4;
      }
    }
  }
  return pOutputStruct;
}

char __fastcall EAC::Callbacks::StartManualMap(ULONG64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax

  v2 = EAC::Imports::PsGetCurrentProcess();
  v3 = EAC::Imports::PsGetCurrentProcessID(v2);
  if ( !EAC::Globals::GameProcessID || v3 != EAC::Globals::GameProcessID )
    return 0;
  v4 = EAC::Imports::PsGetCurrentProcess();
  if ( a1 == EAC::Imports::GetProcessBaseAddress(v4) && !_InterlockedCompareExchange(&dword_140073D94, 1, 0) )
  {
    EAC::Callbacks::ManualMapImage();
    EAC::Callbacks::StoreImageDataForLaterValidation(a1);
    if ( Event )
      KeSetEvent(Event, 0, 0);
  }
  return 1;
}

void EAC::Callbacks::ManualMapImage()
{
  __m128 *pBuffer; // rdi
  bool v1; // bl
  ULONG_PTR RegionSize; // [rsp+50h] [rbp+8h] BYREF
  __int64 v3; // [rsp+58h] [rbp+10h] BYREF

  stru_140073DE8.Count = 1;
  stru_140073DE8.Owner = 0i64;
  stru_140073DE8.Contention = 0;
  KeInitializeEvent(&stru_140073DE8.Event, SynchronizationEvent, 0);
  EAC::Globals_BaseAddress = 0i64;
  RegionSize = 208128i64;
  if ( ZwAllocateVirtualMemory(0xFFFFFFFFFFFFFFFFi64, &EAC::Globals_BaseAddress, 0i64, &RegionSize, 0x3000u, 4u) >= 0 )
  {
    EAC::Callbacks::IsInUsermodeAddressSpace(EAC::Globals_BaseAddress, RegionSize, 1);
    EAC::Memory::memset(EAC::Globals_BaseAddress, 0, RegionSize);
    pBuffer = EAC::Memory::GetImageBuffer(&unk_140060E70, 24576i64);
    if ( pBuffer )
    {
      v1 = EAC::Callbacks::MapImage(
             pBuffer,
             0x6000ui64,
             &EAC::Globals_BaseAddressOfMappedModule,
             &v3,
             &EAC::Globals::EntryPointOfMappedModule,
             0i64,
             0i64);
      EAC::Memory::memset(pBuffer, 0, 0x6000ui64);
      EAC::Memory::ExFreePool(pBuffer);
      if ( v1 )
      {
        EAC::Memory::memset(EAC::Globals_BaseAddressOfMappedModule, 0, 0x1000ui64);
        EAC::Globals::StoredBaseAddressOfMappedModule = EAC::Globals_BaseAddressOfMappedModule;
      }
    }
  }
}

bool __fastcall EAC::Callbacks::MapImage(char *ImageBase, unsigned __int64 ImageSize, __int64 *MappedBase, _QWORD *MappedSize, _QWORD *MappedEntryPoint, _DWORD *ExceptionDirectory, _DWORD *ExceptionDirectorySize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v7 = 0i64;
  v25 = 0i64;
  if ( !ImageBase || !ImageSize || !MappedBase || !MappedSize || !MappedEntryPoint )
    return 0;
  *MappedBase = 0i64;
  *MappedSize = 0i64;
  *MappedEntryPoint = 0i64;
  if ( ExceptionDirectory )
    *ExceptionDirectory = 0;
  if ( ExceptionDirectorySize )
    *ExceptionDirectorySize = 0;
  if ( EAC::Memory::GetPEHeader(ImageBase, ImageSize, &a3a, &v24) )
  {
    v8 = v24;
    v9 = v24->FileHeader.Machine;
    if ( v9 == 332 )
    {
      v10 = 32;
      v11 = v24->OptionalHeader.SizeOfImage;
      v22 = v11;
LABEL_18:
      v30 = v11;
      Buffer = EAC::Memory::ExAllocatePoolWithRandomTag2(v11);
      v7 = Buffer;
      v25 = Buffer;
      if ( Buffer )
      {
        EAC::Memory::memmove(Buffer, ImageBase, ImageSize);
        v13 = EAC::Memory::GenerateSeed(4, 16) << 12;
        LODWORD(v24) = v13;
        v26 = v13;
        Size = EAC::Memory::GenerateSeed(4, 16) << 12;
        v27 = Size;
        v14 = v11 + Size + v13;
        v16 = EAC::Imports::NtAllocateVirtualMemoryWrapper(v14, v14, v15, 4);
        v17 = v16;
        v28 = v16;
        if ( v16 )
        {
          if ( EAC::Imports::NtProtectVirtualMemoryWrapper(v16, v14, 64, v23) )
          {
            EAC::Callbacks::IsInUsermodeAddressSpace(v17, v13, 1);
            EAC::Callbacks::RandomizeRegion(v17, v13);
            if ( EAC::Imports::NtProtectVirtualMemoryWrapper(v17, v13, 32, v23) )
            {
              v18 = &v17[v22 + v13];
              EAC::Callbacks::IsInUsermodeAddressSpace(v18, Size, 1);
              EAC::Callbacks::RandomizeRegion(v18, Size);
              if ( EAC::Imports::NtProtectVirtualMemoryWrapper(v18, Size, 2, v23) )
              {
                v19 = &v17[v24];
                v28 = v19;
                v20 = &v7[*(a3a + 60)];
                v24 = v20;
                EAC::Callbacks::ResolveRelocations(v19, v7, v10, v20);
                if ( v10 == 64 )
                  *(v20 + 48) = v19;
                else
                  *(v20 + 52) = v19;
                if ( EAC::Callbacks::MapSections(v19, v7, v20) )
                {
                  EAC::Memory::CorrectSectionProtection(v19, v20);
                  *MappedBase = v19;
                  *MappedSize = v30;
                  *MappedEntryPoint = v19 + *(v20 + 40);
                }
              }
            }
          }
        }
      }
      goto END;
    }
    if ( v9 == 0x8664 )
    {
      v10 = 64;
      v11 = v24->OptionalHeader.SizeOfImage;
      v22 = v11;
      if ( ExceptionDirectory )
        *ExceptionDirectory = v24->OptionalHeader.DataDirectory[3].VirtualAddress;
      if ( ExceptionDirectorySize )
        *ExceptionDirectorySize = v8->OptionalHeader.DataDirectory[3].Size;
      goto LABEL_18;
    }
  }
END:
  if ( v7 )
    EAC::Memory::ExFreePool(v7);
  return *MappedEntryPoint != 0i64;
}

char __fastcall EAC::Callbacks::StoreImageDataForLaterValidation(ULONG64 a1)
{
  struct_v2 *pEntryPoint; // rax
  struct_v2 *v2; // rbx
  int v4; // [rsp+58h] [rbp+10h] BYREF
  __int64 v5; // [rsp+60h] [rbp+18h] BYREF
  struct_v2 *v6; // [rsp+68h] [rbp+20h] BYREF

  pEntryPoint = EAC::Memory::GetUsermodeProcessEntryPoint(a1);
  v2 = pEntryPoint;
  if ( pEntryPoint )
  {
    v6 = pEntryPoint;
    v5 = 23i64;
    LODWORD(pEntryPoint) = EAC::Imports::NtProtectVirtualMemory(-1i64, &v6, &v5, 0x40u, &v4);
    if ( pEntryPoint >= 0 )
    {
      EAC::Callbacks::IsInUsermodeAddressSpace(v2, 23i64, 1);
      v2->oword0 = xmmword_140060E58;
      v2->dword10 = 0;
      v2->word14 = 0xD0FF;
      v2->byte16 = 0xC3;
      *(&v2->oword0 + 1) = EAC::Globals::StoredBaseAddressOfMappedModule;
      *(&v2->oword0 + 6) = EAC::Globals_BaseAddress;
      *(&v2->oword0 + 11) = EAC::Globals_BaseAddressOfMappedModule;
      v2->dword10 = EAC::Globals::EntryPointOfMappedModule;
      byte_140073BE7 = 1;
      LOBYTE(pEntryPoint) = EAC::Imports::NtProtectVirtualMemoryWrapper(v2, 23i64, v4, &v4);
    }
  }
  return pEntryPoint;
}

void __fastcall EAC::Callbacks::MapAnotherImage(_QWORD *a1)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( a1 )
  {
    if ( EAC::Imports::PsGetCurrentProcess() == a1[1] )
    {
      v2 = EAC::Imports::PsGetCurrentProcess();
      v3 = sub_14000D244(v2);
      if ( v3 )
      {
        if ( !*(v3 + 2) )
        {
          *&v13 = 0x173C5BB8ECB50821i64;
          *(&v13 + 1) = 0xE19624F85FCC66AFui64;
          v14 = -434358038;
          v15 = 1143605379;
          v16 = -20;
          v4 = EAC::Memory::DecryptStr22(&v13, v17);
          v5 = EAC::Callbacks::GetUsermodeModuleWrapper(v4);
          memset(v17, 0, 0x1Aui64);
          if ( v5 )
          {
            v17[0] = -144606394;
            v17[1] = 1841444895;
            v17[2] = 1227386293;
            LOBYTE(v17[3]) = 96;
            v6 = EAC::Memory::DecryptStr13(v17, &v13);
            v7 = v6;
            v8 = a1[23];
            v9 = a1[22];
            if ( v9 && v8 && v6 )
            {
              if ( EAC::Memory::GetProcessArchitectureTypeWrapper(a1[23]) == 64 )
                EAC::Callbacks::MapAnotherImage64Bit(v9, v8, v7);
              else
                EAC::Callbacks::MapAnotherImage32Bit(v9, v8, v7);
            }
            memset(&v13, 0, 0xDui64);
            EAC::Callbacks::IsInUsermodeAddressSpace(a1[44], 60i64, 1);
            v10 = a1[44];
            v18 = *v10;
            v19 = *(v10 + 16);
            v13 = *(v10 + 32);
            v20 = *(v10 + 48);
            v11 = *(v10 + 56);
            *&v19 = 0i64;
            DWORD2(v19) = 0;
            EAC::Callbacks::IsInUsermodeAddressSpace(a1[23], 4096i64, 1);
            EAC::Callbacks::RandomizeRegion(a1[23], 4096i64);
            v12 = a1[44];
            *v12 = 0i64;
            *(v12 + 16) = v19;
            *(v12 + 32) = v13;
            *(v12 + 48) = v20;
            *(v12 + 56) = v11;
          }
        }
      }
    }
  }
}


```

`integrity.cpp`:

```cpp
// Thanks to https://github.com/ch4ncellor/EAC-Reversal/issues/1
char EAC::Callbacks::ValidateExports()
{
  char v0; // bl
  __int64 PsProcessType; // rbp
  __int64 MmGetSystemRoutineAddress; // rdi
  __int64 ZwDeleteKey; // rsi
  __int64 PsProcessTypeHMAP; // r14
  __int64 ZwDeleteKeyHMAP; // r15
  __int64 MmGetSystemRoutineAddressHMAP; // rax

  v0 = 0;
  PsProcessType = EAC::Memory::FindExport(&PsProcessTypeHash);
  MmGetSystemRoutineAddress = EAC::Memory::FindExport(&MmGetSystemRoutineAddressHash);
  ZwDeleteKey = EAC::Memory::FindExport(&ZwDeleteKeyHash);
  PsProcessTypeHMAP = EAC::Memory::LookupImportHMAP(1i64);
  ZwDeleteKeyHMAP = EAC::Memory::LookupImportHMAP(2i64);
  MmGetSystemRoutineAddressHMAP = EAC::Memory::LookupImportHMAP(0i64);
  if ( PsProcessType
    && MmGetSystemRoutineAddress
    && ZwDeleteKey
    && ZwDeleteKey == ZwDeleteKeyHMAP
    && PsProcessType == PsProcessTypeHMAP
    && MmGetSystemRoutineAddress == MmGetSystemRoutineAddressHMAP )
  {
    return 1;
  }
  EAC::Callbacks::ReportViolation(0xE7F46F3i64, 0i64, 0i64);
  return v0;
}

LONG_PTR __fastcall EAC::Callbacks::ValidatePreviouslyMappedImage(char **a1, int a2, void *a3, __int64 a4)
{
  LONG_PTR result; // rax
  char *v8; // r14
  void *v9; // rcx
  unsigned __int64 v10; // r8
  void *v11; // rdx
  unsigned __int64 i; // r8
  bool v13; // [rsp+30h] [rbp-88h]
  PVOID v14; // [rsp+38h] [rbp-80h] BYREF
  PVOID Object[3]; // [rsp+40h] [rbp-78h] BYREF
  _LARGE_INTEGER Timeout; // [rsp+58h] [rbp-60h] BYREF
  _OWORD *v17; // [rsp+60h] [rbp-58h]
  char v18[56]; // [rsp+68h] [rbp-50h] BYREF
  void *retaddr; // [rsp+B8h] [rbp+0h] BYREF
  PVOID v20; // [rsp+D0h] [rbp+18h] BYREF
  __int64 v21; // [rsp+D8h] [rbp+20h]

  result = &retaddr;
  v21 = a4;
  v20 = a3;
  v17 = a4;
  v13 = 0;
  Object[0] = 0i64;
  v14 = 0i64;
  if ( a4 )
  {
    result = EAC::Memory::memset((a4 + 8), 0, 0xA98ui64);
    *a4 = 1;
    *(a4 + 4) = 6;
    if ( a1 && a1[1] && *a1 && *(a1 + 1) && a2 )
    {
      result = MEMORY[0xFFFFF7800000026C];
      if ( MEMORY[0xFFFFF7800000026C] < 6u
        || MEMORY[0xFFFFF7800000026C] == 6 && (result = 0xFFFFF78000000270ui64, !MEMORY[0xFFFFF78000000270]) )
      {
        *(a4 + 4) = 0;
      }
      else
      {
        result = EAC::Globals::GameProcessID;
        if ( EAC::Globals::GameProcessID && byte_140073BE7 )
        {
          result = EAC::Imports::PsLookupProcessByProcessID(EAC::Globals::GameProcessID, &v20);
          if ( result >= 0 )
          {
            v8 = sub_14003E130();
            Object[2] = v8;
            if ( v8 && EAC::Callbacks::KeStackAttachProcess(v20, v18) )
            {
              if ( EAC::Globals::StoredBaseAddressOfMappedModule )
              {
                EAC::Callbacks::IsInUsermodeAddressSpace(EAC::Globals::StoredBaseAddressOfMappedModule, 4i64, 1);
                v9 = *EAC::Globals::StoredBaseAddressOfMappedModule;
                if ( v9 )
                {
                  if ( ObReferenceObjectByHandle(v9, 2u, ExEventObjectType, 1, Object, 0i64) >= 0 )
                  {
                    EAC::Callbacks::IsInUsermodeAddressSpace(v8, 0xCB4i64, 1);
                    if ( ObReferenceObjectByHandle(*(v8 + 1), 0x100000u, ExEventObjectType, 1, &v14, 0i64) >= 0 )
                    {
                      *(v8 + 2) = a2;
                      v10 = 518i64;
                      if ( *a1 < 0x206ui64 )
                        v10 = *a1;
                      EAC::Memory::memmove(v8 + 12, a1[1], v10);
                      *(v8 + 265) = 0;
                      v11 = 0i64;
                      for ( i = 0i64; ; ++i )
                      {
                        Object[1] = v11;
                        if ( i >= 0x208 )
                          break;
                        v8[v11 + 12] += 64 - 96 * v11;
                        v11 = (i + 1);
                      }
                      EAC::Memory::memset((v8 + 532), 0, 0xAA0ui64);
                      *(v8 + 133) = 1;
                      *(v8 + 134) = 7;
                      *v8 = 1;
                      v13 = 1;
                    }
                    else
                    {
                      v14 = 0i64;
                    }
                  }
                  else
                  {
                    Object[0] = 0i64;
                  }
                }
              }
              EAC::Callbacks::KeUnstackDetachProcess(v20, v18);
              *(a4 + 4) = 7;
              if ( v13 )
              {
                KeSetEvent(Object[0], 0, 1u);
                Timeout.QuadPart = -300000000i64;
                v13 = KeWaitForSingleObject(v14, UserRequest, 0, 0, &Timeout) == 0;
              }
              if ( v14 )
                ObfDereferenceObject(v14);
              if ( Object[0] )
                ObfDereferenceObject(Object[0]);
            }
            if ( v13 )
            {
              if ( EAC::Callbacks::KeStackAttachProcess(v20, v18) )
              {
                EAC::Callbacks::IsInUsermodeAddressSpace(v8, 3252i64, 1);
                EAC::Memory::memmove(v17, v8 + 532, 0xAA0ui64);
                EAC::Memory::memset((v8 + 532), 0, 0xAA0ui64);
                EAC::Callbacks::KeUnstackDetachProcess(v20, v18);
              }
            }
            result = ObfDereferenceObject(v20);
          }
        }
        else
        {
          *(a4 + 4) = 6;
        }
      }
    }
    else
    {
      *(a4 + 4) = 4;
    }
  }
  return result;
}

void __fastcall EAC::Callbacks::DetectAPCLevelIRQL(__int64 a1)
{
  __int64 v1; // rdx
  __int64 v3; // rbx
  void *v4; // rbp
  struct _FAST_MUTEX *v5; // rcx
  __int64 v6; // rbx

  if ( !a1 )
    return;
  v1 = *(a1 + 536);
  v3 = v1;
  if ( !v1 )
    goto LABEL_5;
  if ( KeGetCurrentIrql() <= APC_LEVEL )
  {
    *(v1 + 32) = 1;
    v3 = *(a1 + 536);
LABEL_5:
    if ( !v3 )
      return;
  }
  if ( KeGetCurrentIrql() <= APC_LEVEL )
  {
    ExAcquireFastMutex((v3 + 40));
    v4 = *v3;
    v5 = (v3 + 40);
    v6 = *(v3 + 8);
    ExReleaseFastMutex(v5);
    if ( v6 )
    {
      EAC::Callbacks::ReportViolation_1(a1, 0x50FB7A72i64, v4, (2 * v6 + 2), 0i64);
      memset(v4, 0, 2i64 * (v6 + 1));
    }
  }
}

```

`misc.cpp`:

```cpp
bool EAC::Callbacks::EnableTSX()
{
  unsigned __int64 v0; // r9
  unsigned __int64 newtsx; // rax

  v0 = __readmsr(0x122u);
  _disable();
  __writemsr(0x122u, v0 & 0xFFFFFFFFFFFFFFFEui64);//  MSR_IA32_TSX_CTRL
  newtsx = __readmsr(0x122u);
  __writemsr(0x122u, v0);                       //  MSR_IA32_TSX_CTRL
  _enable();
  return (newtsx & 1) == 0;
}

char __fastcall EAC::Memory::VMRead_Wrapper(__int64 _RCX, __int64 _RDX)
{
  char v2; // cf
  char v3; // zf

  __asm { vmread  qword ptr [rdx], rcx }
  return v2 + v2 + v3;
}

char EAC::Callbacks::DetectHyperVisor()
{
  char v1; // [rsp+50h] [rbp+8h] BYREF

  EAC::Memory::VMRead_Wrapper(0i64, &v1);
  return 1;
}

unsigned __int64 EAC::Callbacks::GetstHyperIface()
{
  return __readmsr(0x40000001u);                // Hypervisor interface
}

bool EAC::Callbacks::DSEFixDetection()
{
  int nFlags; // ebx
  _DWORD *pooltagInformation; // rax
  void *v2; // rdx
  unsigned int v3; // er9
  unsigned int v4; // er8
  _DWORD *entry; // rcx
  int v6; // eax

  nFlags = 0;
  pooltagInformation = EAC::Callbacks::QuerySystemInformation(0x16u, 0x10000u, 0x100000u, 0i64);
  v2 = pooltagInformation;
  if ( pooltagInformation )
  {
    v3 = *pooltagInformation;
    v4 = 0;
    if ( *pooltagInformation )
    {
      entry = pooltagInformation + 3;
      do
      {
        if ( nFlags == 3 )
          break;
        v6 = *(entry - 1);
        if ( v6 == 'rcIC' )
        {
          if ( *entry > entry[1] )
            nFlags |= 1u;
        }
        else if ( v6 == 'csIC' && *entry > entry[1] )// called by CiValidateImageHeader
        {
          nFlags |= 2u;
        }
        ++v4;
        entry += 10;
      }
      while ( v4 < v3 );
    }
    EAC::Memory::ExFreePool(v2);
  }
  else
  {
    nFlags = 3;
  }
  return nFlags == 3;
}

char __fastcall EAC::Callbacks::WriteGameCrashInfoToRegistry(PVOID ValueData)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  LOBYTE(v2) = 0;
  HIDWORD(v30) = 0;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  if ( ValueData )
  {
    v2 = EAC::Imports::PsGetCurrentProcess();
    if ( v2 == *(ValueData + 1) )
    {
      v3 = EAC::Imports::PsGetCurrentProcess();
      v4 = EAC::Memory::ResolveImportWrapper(qword_140074158, &qword_140074158, 0i64);
      LODWORD(v2) = v4 ? v4(v3) : 0xC0000002;
      v28 = v2;
      if ( v2 || *(ValueData + 137) )
      {
        v30 = MEMORY[0xFFFFF78000000014];
        v5 = IoGetCurrentProcess();
        v26[0] = PsGetProcessCreateTimeQuadPart(v5);
        v29 = EAC::Memory::GetCurrentTime(*(ValueData + 6));
        v27 = *(ValueData + 4);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameState",
          4u,
          ValueData + 548,
          4u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashGameID",
          4u,
          ValueData,
          4u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashPID",
          4u,
          &v27,
          4u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashCreateTime",
          0xBu,
          v26,
          8u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashExitTime",
          0xBu,
          &v30,
          8u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashExitStatus",
          4u,
          &v28,
          4u);
        LOBYTE(v2) = RtlWriteRegistryValue(
                       0,
                       L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                       L"ErrRpt_GameCrashInfo01",
                       4u,
                       &v29,
                       4u);
        v6 = *(ValueData + 23);
        v7 = v6 + *(ValueData + 24);
        v8 = *(ValueData + 44);
        if ( v8 )
        {
          LOBYTE(v2) = EAC::Callbacks::IsInUsermodeAddressSpace(v8, 60i64, 1);
          v9 = *(ValueData + 44);
          v10 = 0i64;
          v18 = 0i64;
          if ( v9 )
          {
            for ( i = 0i64; ; ++i )
            {
              v26[1] = i;
              if ( i >= 8 )
                break;
              LOBYTE(v2) = *(v9 + 4 * i + 28) ^ 0x90;
              *(&v18 + i) = v2;
              v10 = v18;
            }
          }
          if ( v10 )
          {
            LOBYTE(v2) = EAC::Callbacks::IsInUsermodeAddressSpace(v10, 40i64, 1);
            v12 = *(v10 + 24);
            v13 = *(v10 + 32);
            if ( v12 )
            {
              LOBYTE(v2) = EAC::Callbacks::IsInUsermodeAddressSpace(*(v10 + 24), 64i64, 1);
              if ( *v12 )
              {
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo02",
                  4u,
                  (v12 + 12),
                  4u);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo03",
                  0xBu,
                  (v12 + 16),
                  8u);
                v14 = *(v12 + 16);
                if ( v14 <= v6 || v14 > v7 )
                  v15 = 0i64;
                else
                  v15 = v14 - v6;
                v19 = v15;
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo04",
                  0xBu,
                  &v19,
                  8u);
                if ( *(v12 + 28) )
                  v20 = *(v12 + 32);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo05",
                  0xBu,
                  &v20,
                  8u);
                if ( *(v12 + 28) >= 2u )
                  v21 = *(v12 + 40);
                LOBYTE(v2) = RtlWriteRegistryValue(
                               0,
                               L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                               L"ErrRpt_GameCrashInfo06",
                               0xBu,
                               &v21,
                               8u);
              }
            }
            if ( v13 )
            {
              LOBYTE(v2) = EAC::Callbacks::IsInUsermodeAddressSpace(v13, 52i64, 1);
              if ( *v13 )
              {
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo07",
                  4u,
                  (v13 + 12),
                  4u);
                v16 = *(v13 + 16);
                if ( v16 )
                {
                  v22 = *(v13 + 20);
                  v16 = *(v13 + 16);
                }
                if ( v16 >= 2 )
                {
                  v23 = *(v13 + 28);
                  v16 = *(v13 + 16);
                }
                if ( v16 >= 3 )
                {
                  v24 = *(v13 + 36);
                  v16 = *(v13 + 16);
                }
                if ( v16 >= 4 )
                  v25 = *(v13 + 44);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo08",
                  0xBu,
                  &v22,
                  8u);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo09",
                  0xBu,
                  &v23,
                  8u);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo10",
                  0xBu,
                  &v24,
                  8u);
                LOBYTE(v2) = RtlWriteRegistryValue(
                               0,
                               L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                               L"ErrRpt_GameCrashInfo11",
                               0xBu,
                               &v25,
                               8u);
              }
            }
          }
        }
      }
    }
  }
  return v2;
}

__int64 __fastcall EAC::Callbacks::TimingCheck()
{
  __int64 v0; // r12
  __int64 v1; // r13
  __int64 v2; // r14
  __int64 v3; // r15
  __int64 v4; // r10
  __int64 v5; // r11
  __int64 v6; // r9
  __int64 v7; // rdi
  unsigned __int64 v8; // r8
  unsigned __int64 v14; // rax
  __int64 v15; // rbx
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // kr00_8
  _QWORD v20[17]; // [rsp-A8h] [rbp-F8h] BYREF
  _QWORD v21[8]; // [rsp-20h] [rbp-70h] BYREF
  __int128 v22; // [rsp+20h] [rbp-30h]
  __int128 v23; // [rsp+30h] [rbp-20h]
  __int64 v24; // [rsp+40h] [rbp-10h]
  __int64 vars0; // [rsp+50h] [rbp+0h] BYREF

  v22 = 0i64;
  v24 = 0i64;
  v23 = 0i64;
  v4 = KeGetCurrentIrql();
  __writecr8(0xFui64);
  v5 = *(&v23 + 1);
  v6 = v24 + 100;
  v7 = v6;
  do
  {
    v8 = __rdtsc();
    _RAX = 1i64;
    __asm { cpuid }
    *&v22 = __PAIR64__(_RBX, _RAX);
    *(&v22 + 1) = __PAIR64__(_RDX, _RCX);
    v14 = __rdtsc();
    v5 += ((HIDWORD(v14) << 32) | v14) - v8;
    --v7;
  }
  while ( v7 );
  v15 = v24;
  *(&v23 + 1) = v5;
  do
  {
    v16 = __rdtsc();
    v17 = __rdtsc();
    v15 += ((HIDWORD(v17) << 32) | v17) - v16;
    --v6;
  }
  while ( v6 );
  v24 = v15;
  __writecr8(v4);
  v21[3] = -1074443376i64;
  v21[2] = -2003135156i64;
  v18 = __readeflags();
  v21[1] = v18;
  v21[0] = 15i64;
  v20[16] = v21;
  v20[15] = HIDWORD(v17) << 32;
  v20[14] = v5;
  v20[13] = v4;
  v20[12] = 0i64;
  v20[11] = v1;
  v20[10] = qword_140052A70;
  v20[9] = v4;
  v20[8] = v15;
  v20[7] = &vars0;
  v20[6] = v0;
  v20[5] = 0i64;
  v20[4] = v8;
  v20[3] = v2;
  v20[2] = v3;
  v20[1] = 0i64;
  v20[0] = 0i64;
  return sub_1418A2D0C(v20);
}

void __fastcall EAC::Callbacks::HandleUsermodeOperation(__int64 a1, __int64 a2, _DWORD *a3)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  pProcess = 0i64;
  nCallbackType = 0i64;
  v5 = *(a2 + 32);
  if ( !v5 )
    goto LABEL_49;
  v6 = *(a2 + 16);
  if ( v6 <= 8 )
    goto LABEL_49;
  if ( *(a1 + 112) != v5 )
    goto LABEL_49;
  if ( *(a2 + 8) != v6 )
    goto LABEL_49;
  EAC::Callbacks::IsInUsermodeAddressSpace(v5, v6, 1);
  v7 = EAC::Memory::ExAllocatePoolWithRandomTag2(v6);
  nCallbackType = v7;
  if ( !v7 )
    goto LABEL_49;
  EAC::Memory::memmove(v7, v5, v6);
  pProcess = EAC::Memory::GetPEPROCESS(*(nCallbackType + 4));
  if ( !pProcess )
    goto LABEL_49;
  EAC::Imports::PsGetCurrentProcess();
  if ( !sub_140012D18() )
    goto LABEL_49;
  if ( *nCallbackType == 1 )
  {
    if ( v6 != 40 )
      goto LABEL_49;
    v12 = EAC::Memory::AllocateMemoryInProcess(pProcess[1], nCallbackType);
  }
  else if ( *nCallbackType == 2 )
  {
    if ( v6 != 40 )
      goto LABEL_49;
    v12 = sub_140045628(pProcess[1], nCallbackType);
  }
  else if ( *nCallbackType == 3 )
  {
    if ( v6 != 40 )
      goto LABEL_49;
    v12 = sub_14004573C(pProcess[1], nCallbackType);
  }
  else if ( *nCallbackType == 4 )
  {
    if ( v6 != 32 )
      goto LABEL_49;
    v12 = EAC::Memory::ProtectMemoryInProcess(pProcess[1], nCallbackType);
  }
  else if ( *nCallbackType == 5 )
  {
    if ( v6 != 28 )
      goto LABEL_49;
    v12 = EAC::Memory::FreeMemoryInProcess(pProcess[1], nCallbackType);
  }
  else
  {
    if ( *nCallbackType != 6 )
    {
      if ( *nCallbackType == 7 )
      {
        if ( v6 != 36 )
          goto LABEL_49;
        v8 = pProcess[1];
        v9 = 0;
        v15 = 0i64;
        if ( !v8 )
          goto LABEL_25;
        if ( !*(nCallbackType + 8) || !*(nCallbackType + 20) || !*(nCallbackType + 28) )
          goto LABEL_49;
        if ( !EAC::Callbacks::KeStackAttachProcess(v8, v13) )
          goto LABEL_25;
        if ( EAC::Imports::ZwQueryVirtualMemory(
               -1i64,
               *(nCallbackType + 8),
               *(nCallbackType + 16),
               *(nCallbackType + 20),
               *(nCallbackType + 28),
               &v15) >= 0 )
        {
          *(nCallbackType + 32) = v15;
          v9 = 1;
        }
      }
      else
      {
        if ( *nCallbackType != 8 || v6 != 36 )
          goto LABEL_49;
        v8 = pProcess[1];
        v9 = 0;
        if ( !v8 )
          goto LABEL_25;
        if ( !*(nCallbackType + 12) || !*(nCallbackType + 20) || !*(nCallbackType + 24) || *(nCallbackType + 32) )
          goto LABEL_49;
        if ( !EAC::Callbacks::KeStackAttachProcess(v8, v13) )
          goto LABEL_25;
        v9 = EAC::Imports::NtSetInformationVirtualMemory(
               v10,
               *(nCallbackType + 8),
               *(nCallbackType + 20),
               *(nCallbackType + 12),
               *(nCallbackType + 24),
               *(nCallbackType + 32)) >= 0;
      }
      EAC::Callbacks::KeUnstackDetachProcess(v8, v13);
LABEL_25:
      v11 = !v9;
      goto LABEL_47;
    }
    if ( v6 != 36 )
      goto LABEL_49;
    v12 = EAC::Memory::ZwFlushVirtualMemoryWrapper(pProcess[1], nCallbackType);
  }
  v11 = v12 == 0;
LABEL_47:
  if ( !v11 )
  {
    EAC::Memory::memmove(v5, nCallbackType, v6);
    *a3 = v6;
  }
LABEL_49:
  if ( nCallbackType )
    EAC::Memory::ExFreePool(nCallbackType);
  if ( pProcess )
    EAC::Memory::ReleasePEPROCESS(pProcess);
}

bool __fastcall EAC::Callbacks::CheckForPhysicalHandle(__int64 a1)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( !a1 )
    return 0;
  v2 = qword_140073320 == 0;
  *a1 = 0i64;
  *(a1 + 16) = 0i64;
  if ( v2 || _InterlockedCompareExchange(&dword_140074238, 1, 0) )
    return 0;
  v3 = EAC::Callbacks::QuerySystemInformation(0x10u, 0x80000u, 0x1000000u, 0i64);
  if ( !v3 )
    goto LABEL_41;
  v21[0] = 1916479917;
  v22 = 7074;
  v4 = 44i64;
  v21[1] = -1077771171;
  *&physMemDecrypted[2] = 0i64;
  DWORD2(physMemDecrypted[2]) = 0;
  v5 = 1920936433;
  WORD6(physMemDecrypted[2]) = 0;
  v6 = 0i64;
  v21[2] = -456920151;
  v21[3] = 1354280435;
  v21[4] = -1213991906;
  v21[5] = -252238082;
  v21[6] = -16337681;
  v21[7] = 1002680223;
  v21[8] = 38635846;
  v21[9] = -1183450918;
  v21[10] = -1816555846;
  physMemDecrypted[0] = 0i64;
  physMemDecrypted[1] = 0i64;
  v29 = v21;
  v30 = physMemDecrypted;
  do
  {
    *(v30 + v6 * 4) = v29[v6] ^ v5;
    ++v6;
    v5 = __ROR4__(((v5 ^ (v5 << 13)) >> 17) ^ v5 ^ (v5 << 13) ^ (32 * (((v5 ^ (v5 << 13)) >> 17) ^ v5 ^ (v5 << 13))), 1);
  }
  while ( v6 < 11 );
  v29 = v21;
  v30 = physMemDecrypted;
  do
  {
    v7 = v5;
    v5 >>= 8;
    *(v30 + v4) = *(v29 + v4) ^ v7;
    ++v4;
  }
  while ( v4 < 0x2E );
  EAC::Memory::InitializeUnicodeStringWithCString(szPhysMem, physMemDecrypted);// \Device\PhysicalMemory
  ObjectAttributes.Length = 48;
  ObjectAttributes.ObjectName = szPhysMem;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  *&ObjectAttributes.SecurityDescriptor = 0i64;
  if ( ZwOpenSection(&SectionHandle, 1u, &ObjectAttributes) >= 0 )
  {
    v8 = EAC::Imports::ObReferenceObjectByHandle(SectionHandle, 1u, 0i64, 0, &EAC::Globals::Object, 0i64);
    v9 = EAC::Globals::Object;
    if ( v8 < 0 )
      v9 = 0i64;
    EAC::Globals::Object = v9;
    ZwClose(SectionHandle);
  }
  v10 = 0i64;
  memset(physMemDecrypted, 0, 0x2Eui64);
  if ( !*v3 )
    goto LABEL_37;
  sectionObjectType = EAC::Globals::Object;
  v12 = (v3 + 2);
  v13 = 0;
  while ( 1 )
  {
    if ( v12[1] != sectionObjectType || !sectionObjectType || *v12 == 4 )
      goto LABEL_21;
    v14 = *(v12 + 3);
    v15 = EAC::Memory::ResolveImportWrapper(qword_140073D58, &qword_140073D58, 0i64);
    if ( !v15 || !v15(v14) )
      break;
    sectionObjectType = EAC::Globals::Object;
LABEL_21:
    ++v10;
    v12 += 3;
    if ( v10 >= *v3 )
      goto LABEL_38;
  }
  v16 = EAC::Memory::GetProcessImageFilename(*v12, v24);
  if ( v16 )
    v13 = sub_140021608(v24, v26);
  v17 = -v13;
  v18 = (v26 & -(v17 != 0));
  if ( !*(a1 + 4) )
  {
    *a1 = 1;
    *(a1 + 4) = 13;
    if ( v18 )
    {
      if ( *((v26 & -(v17 != 0)) + 8) && *v18 && *((v26 & -(v17 != 0)) + 2) && !*(a1 + 8) )
      {
        if ( a1 == 0xFFFFFFFFFFFFFFF0ui64 )
          v19 = 0;
        else
          v19 = EAC::Memory::AllocateCopyUnicodeString(a1 + 0x10, v18, *v18);
        *(a1 + 8) = v19;
      }
    }
  }
  if ( v16 )
    EAC::Memory::FreeUnicdeString(v24);
LABEL_37:
  sectionObjectType = EAC::Globals::Object;
LABEL_38:
  if ( sectionObjectType )
  {
    ObfDereferenceObject(sectionObjectType);
    EAC::Globals::Object = 0i64;
  }
  EAC::Memory::ExFreePool(v3);
LABEL_41:
  _InterlockedExchange(&dword_140074238, 0);
  return *(a1 + 4) != 0;
}

```

`modules.cpp`:

```cpp
void __fastcall EAC::Callbacks::CheckForManualMappedModule(ULONG64 *pAnomalyHashStruct)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( pAnomalyHashStruct )
  {
    v11 = 0i64;
    v2 = pAnomalyHashStruct[1];
    if ( v2 )
    {
      EAC::Callbacks::IsInUsermodeAddressSpace(pAnomalyHashStruct[1], 4096i64, 1);
      if ( EAC::Memory::GetPEHeader(v2, 0x1000ui64, 0i64, &v12) )
      {
        v3 = v12;
        v4 = &v12->OptionalHeader + v12->FileHeader.SizeOfOptionalHeader;
        for ( i = 0; i < v3->FileHeader.NumberOfSections && *(pAnomalyHashStruct + 10) != 32; ++i )
        {
          EAC::Callbacks::IsInUsermodeAddressSpace(v4, 40i64, 1);
          v6 = *(v4 + 3);
          if ( v6 )
          {
            v7 = *(v4 + 2);
            if ( v7 )
            {
              if ( (*(v4 + 9) & 0x2000000) == 0 )
              {
                v8 = *v4;
                if ( (*v4 != 'ler.' || *(v4 + 2) != 'co') && v8 != 'slt.' )
                {
                  if ( v8 != 'rsr.' || (v9 = 1, v4[4] != 'c') )
                    v9 = 0;
                  BYTE12(v11) = v9;
                  v10 = v9;
                  if ( (*(*pAnomalyHashStruct + 26) & 0x60) != 0 )
                    v10 = 1;
                  BYTE12(v11) = v10;
                  *&v11 = v2 + v6;
                  DWORD2(v11) = v7;
                  EAC::Callbacks::IsInUsermodeAddressSpace(v2 + v6, v7, 1);
                  EAC::Callbacks::SetHashOfAnomaly(&v11, pAnomalyHashStruct);
                }
              }
            }
          }
          v4 += 40;
        }
      }
    }
  }
}

char __fastcall EAC::Callbacks::CheckForBlacklistedModuleNamesWrapper(__int64 a1)
{
  char v2; // si
  __int64 v3; // rax
  PVOID *v4; // rbx
  unsigned int v5; // edi
  __int64 *v6; // r14
  __int64 v7; // rdi

  v2 = 0;
  v3 = EAC::Memory::ExAllocatePoolWithRandomTag2(4096i64);
  v4 = v3;
  if ( v3 )
  {
    v5 = sub_14000D368(v3);
    if ( v5 )
    {
      ObfDereferenceObject(*v4);
      if ( v5 > 1 )
      {
        v6 = (v4 + 1);
        v7 = v5 - 1;
        do
        {
          if ( !v2 && !sub_140006810(a1) )
            v2 = EAC::Callbacks::CheckForBlacklistedModuleNames(*v6);
          ObfDereferenceObject(*v6++);
          --v7;
        }
        while ( v7 );
      }
    }
    EAC::Memory::ExFreePool(v4);
  }
  return v2;
}

char __fastcall EAC::Callbacks::CheckForBlacklistedModuleNames(__int64 a1)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  bDidFindBlacklistedModule = 0;
  if ( !EAC::Callbacks::KeStackAttachProcess(a1, v64) )
    return bDidFindBlacklistedModule;
  v42[0] = 404169542;
  v43 = 24194;
  v3 = 20i64;
  v42[1] = 1671252913;
  *&v55[16] = 0;
  *&v55[20] = 0;
  v4 = 409084674;
  v42[2] = 1997423613;
  v42[3] = -2365392;
  v5 = 0i64;
  v42[4] = 1080899897;
  *v55 = 0i64;
  do
  {
    *&v55[v5 * 4] = v42[v5] ^ v4;
    ++v5;
    v4 = _byteswap_ulong(((v4 ^ (v4 << 13)) >> 17) ^ v4 ^ (v4 << 13) ^ (32
                                                                      * (((v4 ^ (v4 << 13)) >> 17) ^ v4 ^ (v4 << 13))));
  }
  while ( v5 < 5 );
  do
  {
    v6 = v4;
    v4 >>= 8;
    v55[v3] = *(v42 + v3) ^ v6;
    ++v3;
  }
  while ( v3 < 0x16 );
  v7 = 1;
  if ( EAC::Callbacks::GetUsermodeModuleWrapper(v55) )// Dumper.dll
  {
    v40[0] = 570211008;
    v41 = -31209;
    v40[1] = -1022839618;
    *&v54[16] = 0;
    v8 = 563133063;
    v40[2] = -738526335;
    v40[3] = 1285740581;
    v9 = 0i64;
    *v54 = 0i64;
    do
    {
      *&v54[v9 * 4] = v40[v9] ^ v8;
      ++v9;
      v8 = -2531012 - 214013 * v8;
    }
    while ( v9 < 4 );
    for ( i = 16i64; i < 0x12; ++i )
    {
      v11 = v8;
      v8 >>= 8;
      v54[i] = *(v40 + i) ^ v11;
    }
    v7 = 3;
    if ( EAC::Callbacks::GetUsermodeModuleWrapper(v54) )// Glob.dll
    {
      v48[0] = 316787955;
      *&v59[16] = 0i64;
      v48[1] = 679437834;
      v48[2] = -1174755841;
      v12 = 392827509;
      v48[3] = -496974842;
      v13 = 0i64;
      v48[4] = 692469395;
      v48[5] = -508318795;
      *v59 = 0i64;
      do
      {
        v12 = _byteswap_ulong(((v12 ^ (v12 >> 7)) << 9) ^ v12 ^ (v12 >> 7) ^ ((((v12 ^ (v12 >> 7)) << 9) ^ v12 ^ (v12 >> 7)) >> 13));
        *&v59[v13 * 4] = v48[v13] ^ v12;
        ++v13;
      }
      while ( v13 < 6 );
      v7 = 7;
      if ( EAC::Callbacks::GetUsermodeModuleWrapper(v59) )// mswsock.dll
      {
        v49[0] = 1462885684;
        *&v58[16] = 0i64;
        v49[1] = -402286035;
        v49[2] = -1169349665;
        v14 = 2101152273;
        v49[3] = -538151392;
        v15 = 0i64;
        v49[4] = -274603261;
        v49[5] = 488391802;
        *v58 = 0i64;
        do
        {
          v14 = __ROR4__(
                  ((v14 ^ (v14 << 13)) >> 7) ^ v14 ^ (v14 << 13) ^ ((((v14 ^ (v14 << 13)) >> 7) ^ v14 ^ (v14 << 13)) << 17),
                  4);
          *&v58[v15 * 4] = v49[v15] ^ v14;
          ++v15;
        }
        while ( v15 < 6 );
        v7 = 15;
        if ( EAC::Callbacks::GetUsermodeModuleWrapper(v58) )//  perl512.dll
        {
          v16 = 1;
LABEL_19:
          v7 &= 0xFFFFFFF7;
          memset(v58, 0, sizeof(v58));
          goto LABEL_20;
        }
      }
    }
  }
  v16 = 0;
  if ( (v7 & 8) != 0 )
    goto LABEL_19;
LABEL_20:
  if ( (v7 & 4) != 0 )
  {
    v7 &= 0xFFFFFFFB;
    memset(v59, 0, sizeof(v59));
  }
  if ( (v7 & 2) != 0 )
  {
    v7 &= 0xFFFFFFFD;
    memset(v54, 0, sizeof(v54));
  }
  v17 = v7 & 0xFFFFFFFE;
  memset(v55, 0, sizeof(v55));
  if ( v16 )
    goto LABEL_54;
  v46[0] = -1918767450;
  v47 = 30032;
  v46[1] = 1716648254;
  v18 = v17 | 0x10;
  v46[2] = -2001414969;
  *&v61[32] = 0;
  v19 = -1915949360;
  v46[3] = -682439642;
  v46[4] = 1479981800;
  v20 = 0i64;
  v46[5] = 747063356;
  v46[6] = -796488994;
  v46[7] = 1471440201;
  *v61 = 0i64;
  *&v61[16] = 0i64;
  do
  {
    v21 = v46[v20] ^ v19;
    v19 = __ROR4__(23449 * v19 + 10042149, 2);
    *&v61[v20 * 4] = v21;
    ++v20;
  }
  while ( v20 < 8 );
  for ( j = 32i64; j < 0x22; ++j )
  {
    v23 = v19;
    v19 >>= 8;
    v61[j] = *(v46 + j) ^ v23;
  }
  if ( EAC::Callbacks::GetUsermodeModuleWrapper(v61) )// vmclientcore.dll
    goto LABEL_44;
  *&v57[16] = 0i64;
  *&v57[24] = 0;
  v18 |= 0x20u;
  v51[0] = 1064449107;
  *v57 = 0i64;
  v51[1] = 1638685829;
  v24 = -1269883487;
  v51[2] = 1103840582;
  v25 = 0i64;
  v51[3] = -554947786;
  v51[4] = -679930175;
  v51[5] = -277811938;
  v51[6] = 434714035;
  do
  {
    v24 = ~(((v24 ^ (v24 << 13)) >> 7) ^ v24 ^ (v24 << 13) ^ ((((v24 ^ (v24 << 13)) >> 7) ^ v24 ^ (v24 << 13)) << 17));
    *&v57[v25 * 4] = v51[v25] ^ v24;
    ++v25;
  }
  while ( v25 < 7 );
  if ( EAC::Callbacks::GetUsermodeModuleWrapper(v57) )// vmwarewui.dll
    goto LABEL_44;
  v44[0] = -1427003179;
  v45 = 16042;
  v18 |= 0x40u;
  v44[1] = -1341968668;
  *&v56[16] = 0i64;
  *&v56[24] = 0;
  v26 = -1432835933;
  *&v56[28] = 0;
  v27 = 0i64;
  v44[2] = 421141858;
  v44[3] = 670852926;
  v44[4] = -1407531516;
  v44[5] = 386858880;
  v44[6] = -1587770893;
  *v56 = 0i64;
  do
  {
    *&v56[v27 * 4] = v44[v27] ^ v26;
    ++v27;
    v26 = -4486779 - 60741 * v26;
  }
  while ( v27 < 7 );
  for ( k = 28i64; k < 0x1E; ++k )
  {
    v29 = v26;
    v26 >>= 8;
    v56[k] = *(v44 + k) ^ v29;
  }
  if ( EAC::Callbacks::GetUsermodeModuleWrapper(v56) )// virtualbox.dll
    goto LABEL_44;
  v52[0] = 1246573564;
  v52[1] = -1435646966;
  v62[0] = 0i64;
  v52[2] = -1583470474;
  v18 |= 0x80u;
  v62[1] = 0i64;
  v52[3] = 1413339661;
  v30 = -678343082;
  v52[4] = 266555639;
  v31 = 0i64;
  v52[5] = 963523025;
  v52[6] = -972779894;
  v52[7] = 1931803890;
  do
  {
    v30 = _byteswap_ulong(((v30 ^ (v30 << 13)) >> 7) ^ v30 ^ (v30 << 13) ^ ((((v30 ^ (v30 << 13)) >> 7) ^ v30 ^ (v30 << 13)) << 17));
    *(v62 + v31 * 4) = v52[v31] ^ v30;
    ++v31;
  }
  while ( v31 < 8 );
  if ( EAC::Callbacks::GetUsermodeModuleWrapper(v62) )//  qtcorevbox4.dll
    goto LABEL_44;
  *&v60[16] = 0i64;
  v50[0] = 1622598650;
  *v60 = 0i64;
  v50[1] = -434380297;
  v18 |= 0x100u;
  v50[2] = 450310602;
  v32 = 967813938;
  v50[3] = -1230501162;
  v33 = 0i64;
  v50[4] = 130594042;
  v50[5] = 877756042;
  do
  {
    v32 = _byteswap_ulong(14767 * v32 + 11512626);
    *&v60[v33 * 4] = v50[v33] ^ v32;
    ++v33;
  }
  while ( v33 < 6 );
  v34 = EAC::Callbacks::GetUsermodeModuleWrapper(v60);// vboxvmm.dll
  v35 = 0;
  if ( v34 )
LABEL_44:
    v35 = 1;
  if ( _bittest(&v18, 8u) )
    memset(v60, 0, sizeof(v60));
  if ( (v18 & 0x80u) != 0 )
  {
    LOBYTE(v18) = v18 & 0x7F;
    memset(v62, 0, sizeof(v62));
  }
  if ( (v18 & 0x40) != 0 )
    memset(v56, 0, sizeof(v56));
  if ( (v18 & 0x20) != 0 )
    memset(v57, 0, sizeof(v57));
  memset(v61, 0, sizeof(v61));
  if ( v35 )
  {
LABEL_54:
    bDidFindBlacklistedModule = 1;
  }
  else
  {
    v53[0] = 1037675329;
    v53[1] = -1518926285;
    v63[0] = 0i64;
    v53[2] = 21725712;
    v36 = 476297892;
    v63[1] = 0i64;
    v53[3] = -814997594;
    v37 = 0i64;
    v53[4] = -1828532299;
    v53[5] = -1535047739;
    v53[6] = -1866569114;
    v53[7] = 1065021894;
    do
    {
      v36 = -(((v36 ^ (v36 << 13)) >> 7) ^ v36 ^ (v36 << 13) ^ ((((v36 ^ (v36 << 13)) >> 7) ^ v36 ^ (v36 << 13)) << 17));
      *(v63 + v37 * 4) = v53[v37] ^ v36;
      ++v37;
    }
    while ( v37 < 8 );
    v38 = EAC::Callbacks::GetUsermodeModuleWrapper(v63);//  netredirect.dll
    bDidFindBlacklistedModule = 0;
    memset(v63, 0, sizeof(v63));
    if ( v38 )
      bDidFindBlacklistedModule = 1;
  }
  EAC::Callbacks::KeUnstackDetachProcess(a1, v64);
  return bDidFindBlacklistedModule;
}

char EAC::Callbacks::CheckModuleExtension(unsigned __int64 a1, char a2, unsigned int *a3, __int64 a4, ...)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  va_start(va1, a4);
  va_start(Pa, a4);
  Pa = va_arg(va1, PVOID);
  v47 = va_arg(va1, _WORD *);
  v45 = a4;
  v44 = a2;
  v36 = 0;
  EAC::Memory::memset(&v40, 0, 0x98ui64);
  Pa = 0i64;
  v8 = 0i64;
  v9 = 0i64;
  if ( !a1 || !a3 || !a4 )
    return 0;
  if ( a2 == 32 )
  {
    v11 = a3[32];
    v12 = a3[33];
  }
  else
  {
    if ( a2 != 64 )
      return 0;
    v11 = a3[36];
    v12 = a3[37];
  }
  v13 = a3[20];
  v39 = v13;
  v14 = (a1 + v11);
  v15 = v13 + a1;
  v38 = v13 + a1;
  if ( !v13 || v12 < 0x14ui64 || v14 <= a1 || v14 + v12 > v15 )
    return 0;
  v40.m128_i32[3] = 0xEFCDAB89;
  v41 = -1732584194;
  v42 = 271733878;
  v40.m128_i32[0] = 0;
  *(v40.m128_u64 + 4) = 0x6745230100000000i64;
  while ( 1 )
  {
    v16 = v14[3];
    if ( !v16 )
      break;
    if ( v16 <= v13 )
    {
      if ( sub_140018490(a1 + v16, Pa) )
      {
        v18 = Pa;
        v19 = -1i64;
        do
          ++v19;
        while ( *(Pa + v19) );
        if ( v19 > 4 )
        {
          nModuleExtension = *(Pa + v19 - 4);
          if ( nModuleExtension == 'xco.' || nModuleExtension == 'sys.' || nModuleExtension == 'lld.' )
            *(Pa + v19 - 4) = 0;
        }
        v21 = *v14;
        if ( v21 || (v21 = v14[4], v21) )
          v9 = (a1 + v21);
        if ( v9 && v9 < v15 )
        {
          if ( v44 == 32 )
          {
            v22 = v9;
            while ( 1 )
            {
              v23 = v22;
              v24 = *v22;
              if ( !*v22 )
                break;
              ++v22;
              v25 = !*v22 && !v14[8];
              v26 = *v23;
              if ( v24 >= 0 )
                v27 = sub_1400186B4(v18, (a1 + v26 + 2), v43);
              else
                v27 = sub_1400185A0(v18, v26, v43, v17, v25);
              if ( v27 )
              {
                v28 = -1i64;
                do
                  ++v28;
                while ( v43[v28] );
                sub_14002930C(&v40, v43, v28);
                ++v8;
              }
            }
          }
          else if ( v44 == 64 )
          {
            for ( i = v9; ; i = v31 )
            {
              v30 = *i;
              if ( !*i )
                break;
              v31 = i + 1;
              v32 = !i[1] && !v14[8];
              if ( v30 >= 0 )
                v33 = sub_1400186B4(v18, (a1 + v30 + 2), v43);
              else
                v33 = sub_1400185A0(v18, v30, v43, v17, v32);
              if ( v33 )
              {
                v34 = -1i64;
                do
                  ++v34;
                while ( v43[v34] );
                sub_14002930C(&v40, v43, v34);
                ++v8;
              }
            }
          }
        }
        EAC::Memory::ExFreePool(v18);
        v15 = v38;
      }
      v13 = v39;
    }
    v14 += 5;
  }
  if ( v8 )
  {
    sub_1400293C8(&v40, v45);
    if ( v47 )
      *v47 = v8;
    v36 = 1;
  }
  return v36;
}


```

`processes.cpp`:

```cpp
char __fastcall EAC::Callbacks::ProcessEnumerationScan(unsigned int *a1)
{
  __int64 v2; // rdi
  __int64 v4; // rcx
  unsigned int v5; // ecx
  char v6; // [rsp+20h] [rbp-48h]
  char v7[56]; // [rsp+30h] [rbp-38h] BYREF
  PVOID Object; // [rsp+78h] [rbp+10h] BYREF

  v6 = 0;
  v2 = 0i64;
  if ( !a1 )
    return 0;
  EAC::Callbacks::IsInUsermodeAddressSpace(a1, 16i64, 1);
  if ( !*a1 || !*(a1 + 1) || !a1[3] )
    return 0;
  if ( EAC::Imports::PsLookupProcessByProcessID(*a1, &Object) >= 0 )
  {
    if ( EAC::Callbacks::KeStackAttachProcess(Object, v7) )
    {
      LOBYTE(v4) = 1;
      v2 = EAC::Callbacks::ScanProcess(v4);
      EAC::Callbacks::KeUnstackDetachProcess(Object, v7);
    }
    ObfDereferenceObject(Object);
  }
  if ( v2 )
  {
    EAC::Callbacks::IsInUsermodeAddressSpace(*(a1 + 1), a1[3], 1);
    v5 = *(*v2 + 10i64);
    if ( v5 >= a1[3] )
      v5 = a1[3];
    EAC::Memory::memmove(*(a1 + 1), *v2, v5);
    v6 = 1;
    EAC::Memory::FreePoolAndUnicodeString(v2);
  }
  return v6;
}

struct_v6 *__fastcall EAC::Callbacks::ScanProcess(__int64 a1)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  bGetFileOnDisk = a1;
  bHasSetNeededData = 0;
  Process = EAC::Imports::PsGetCurrentProcess();
  pID = EAC::Imports::PsGetCurrentProcessID(Process);
  v5 = EAC::Memory::ExAllocatePoolWithRandomTag2(816i64);
  pStruct = v5;
  if ( v5 )
  {
    EAC::Memory::memset(v5, 0, 0x330ui64);
    v7 = EAC::Imports::GetProcessBaseAddress(Process);
    pStruct->qword8 = v7;
    if ( v7 || (v8 = EAC::Callbacks::GetUsermodeModuleWrapper(0i64), (pStruct->qword8 = v8) != 0i64) )
    {
      if ( EAC::Imports::IsWin32ConsoleSubsystem(Process) )
      {
        processFlags2 = 0x8001;
      }
      else if ( EAC::Imports::HasCOMDescriptor(pStruct->qword8) )
      {
        processFlags2 = 9;
      }
      else
      {
        v21[0] = 0x17B95E6A;
        v21[1] = 0xB5A7A4BD;
        v21[2] = 0x62CDCB21;
        v21[3] = 0xA77AB98D;
        v21[4] = 0xDE91C109;
        v21[5] = 0xE534B047;
        v22 = -19593;
        v11 = EAC::Memory::DecryptStringBuffer(v21, v20);
        v12 = EAC::Callbacks::GetUsermodeModuleWrapper(v11);
        memset(v20, 0, 0x1Aui64);
        v9 = 0i64;
        if ( v12 )
        {
          processFlags2 = 17;                   // msvbvm60.dll
        }
        else
        {
          v20[0] = 0x12D3327D;
          v20[1] = 0xCBBDD298;
          v20[2] = -1184356958;
          v20[3] = 0x10D2A830;
          v20[4] = 1441356086;
          v20[5] = -160030657;
          v13 = EAC::Memory::DecryptStringBuffer2(v20, v21);
          v14 = EAC::Callbacks::GetUsermodeModuleWrapper(v13);
          memset(v21, 0, sizeof(v21));
          v9 = 0i64;
          processFlags2 = 1;
          if ( v14 )
            processFlags2 = 0x1001;             // perl512.dll
        }
      }
      processFlags = processFlags2;
      v15 = pStruct->qword8;
      if ( EAC::Memory::IsDbgUiRemoteBreakinPatchedToCallLdrShutdownProcess(v9)
        || EAC::Memory::DoesProcessHaveAntiDebug(v15) )
      {
        processFlags2 |= 0x20u;
        processFlags = processFlags2;
      }
      if ( EAC::Callbacks::IsProcessVMProtected(pStruct->qword8) )
      {
        processFlags2 |= 0x40u;
        processFlags = processFlags2;
      }
      if ( EAC::Callbacks::HasDetectedPacker(pStruct->qword8, &nOutResult) )
        processFlags = (nOutResult != 0 ? 0x20000 : 0x10000) | processFlags2;
      EAC::Callbacks::SomeMaliciousIdentifierChecks(&processFlags);
      if ( bGetFileOnDisk
        && (EAC::Imports::GetDeviceName(Process, &pStruct[1].qword0 + 7)
         || EAC::Memory::GetMappedFilename(-1i64, pStruct->qword8, &pStruct[1].qword0 + 7)
         || EAC::Memory::GetProcessImageFilename(pID, &pStruct[1].qword0 + 7))
        || EAC::Memory::GetProcessPathOrCommandline(Process, 1, &pStruct[1].qword0 + 7) )
      {
        pStruct->bIsProgramOnDisk = 1;
        if ( EAC::Callbacks::IsMaliciousProgram(&pStruct[1].qword0 + 7) )
        {
          processFlags |= 0x40000u;
        }
        else if ( EAC::Callbacks::IsFileInSystemDirectory(&pStruct[1].qword0 + 7) )
        {
          processFlags |= 0x200u;
        }
      }
      EAC::Callbacks::IsInUsermodeAddressSpace(pStruct->qword8, 4096i64, 1);
      v16 = ((&pStruct[1].qword0 + 7) & -(pStruct->bIsProgramOnDisk != 0));
      v17 = EAC::Imports::PsGetProcessWow64(Process);
      pInfo = EAC::Memory::CopyProcessInformation(pStruct->qword8, 0x1000ui64, 0i64, processFlags, v17, v16, pID, 0i64);
      pStruct->qword0 = pInfo;
      if ( pInfo )
      {
        if ( !pStruct->bIsProgramOnDisk && EAC::Imports::GetProcessFileName(Process, v20) )
          EAC::Memory::CopyString(pStruct->qword0 + 0x20i64, 256i64, v20);
        bHasSetNeededData = 1;
      }
    }
  }
  if ( !bHasSetNeededData && pStruct )
  {
    EAC::Memory::FreePoolAndUnicodeString(pStruct);
    pStruct = 0i64;
  }
  return pStruct;
}

char __fastcall EAC::Memory::DoesProcessHaveAntiDebug(ULONG64 a1)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v2 = 0;
  v3 = 0;
  if ( !a1 )
    return 0;
  EAC::Callbacks::IsInUsermodeAddressSpace(a1, 4096i64, 1);
  if ( EAC::Memory::GetPEHeader(a1, 0x1000ui64, 0i64, &v12) )
  {
    v5 = v12;
    if ( *(v12 + 40) )
    {
      v6 = (*(v12 + 20) + v12 + 24);
      for ( i = 0; ; ++i )
      {
        if ( i >= *(v5 + 6) )
          return v2;
        EAC::Callbacks::IsInUsermodeAddressSpace(v6, 40i64, 1);
        v8 = v6->OptionalHeader.SizeOfUninitializedData;
        if ( v8 == 0x60000020 )                 // unpacked file
          break;
        if ( v8 == 0xE0000040 )                 // UPX packed exe? https://i.imgur.com/85R5QvD.png
        {
          if ( v6->Signature == '    ' && *&v6->FileHeader.Machine == '    ' )// cleared shit
            goto LABEL_11;
          for ( j = 0; ; ++j )
          {
            v11 = j == 8;
            if ( j >= 8 )
              break;
            if ( (*(&v6->Signature + j) - 97) > 25u )
            {
              v11 = j == 8;
              break;
            }
          }
          if ( v11 )
          {
            v9 = ++v3 == 2;
LABEL_10:
            if ( v9 )
              goto LABEL_11;
            goto LABEL_22;
          }
        }
LABEL_22:
        v6 = (v6 + 40);
      }
      if ( v6->Signature != '   ' )
        goto LABEL_22;
      v9 = *&v6->FileHeader.Machine == '    ';  // cleared shit
      goto LABEL_10;
    }
LABEL_11:
    v2 = 1;
  }
  return v2;
}

char __fastcall EAC::Callbacks::IsProcessVMProtected(ULONG64 BaseAddress)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v2 = 0;
  if ( !BaseAddress )
    return 0;
  EAC::Callbacks::IsInUsermodeAddressSpace(BaseAddress, 4096i64, 1);
  if ( EAC::Memory::GetPEHeader(BaseAddress, 0x1000ui64, 0i64, &v7) )
  {
    v4 = v7;
    v5 = (&v7->OptionalHeader + v7->FileHeader.SizeOfOptionalHeader);
    for ( i = 0; i < v4->FileHeader.NumberOfSections; ++i )
    {
      EAC::Callbacks::IsInUsermodeAddressSpace(v5, 40i64, 1);
      if ( *(&v5->e_magic + 1) == '0pmv' )
        return 1;
      v5 = (v5 + 40);
    }
  }
  return v2;
}

char __fastcall EAC::Callbacks::HasDetectedPacker(ULONG64 a1, _BYTE *a2)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v4 = 0;
  if ( a1 && a2 )
  {
    *a2 = 0;
    EAC::Callbacks::IsInUsermodeAddressSpace(a1, 4096i64, 1);
    if ( !EAC::Memory::GetPEHeader(a1, 0x1000ui64, 0i64, &v27) )
      return v4;
    v5 = v27;
    sectionName = (&v27->OptionalHeader.Magic + v27->FileHeader.SizeOfOptionalHeader);
    for ( i = 0; i < v5->FileHeader.NumberOfSections; ++i )
    {
      EAC::Callbacks::IsInUsermodeAddressSpace(sectionName, 40i64, 1);
      if ( *sectionName == '0XPU' )             // upx lol
        return 1;
      sectionName += 10;
    }
    v8 = EAC::Callbacks::IsEntrypointInUsermodeAddressSpace(a1, v5);
    if ( !v8 )
      return v4;
    nMachine = v5->FileHeader.Machine;
    if ( nMachine == 332 )
    {
      v10 = 32;
    }
    else
    {
      if ( nMachine == 0x8664 || nMachine == 0xAA64 )
      {
        if ( *v8 != 'UWVS' )
          return v4;
        v11 = &v8[sub_140020E6C(v8 + 4, v21) + 4];
        if ( (v26 & 0x1000) != 0 )
          return v4;
        if ( (v26 & 0x40000000) == 0 )
          return v4;
        if ( v22 != -115 )
          return v4;
        if ( v23 != 53 )
          return v4;
        sub_140020E6C(v11, v21);
        if ( (v26 & 0x1000) != 0 || (v26 & 0x40000000) == 0 || v22 != -115 || v24 != 7 )
          return v4;
        v12 = v25 == 6;
        goto LABEL_34;
      }
      v10 = 0;
    }
    if ( v10 != 32 )
      return v4;
    v13 = &v8[sub_14004CDFC(v8, v16)];
    if ( (v20 & 0x1000) != 0 )
      return v4;
    if ( v17 != 96 )
      return v4;
    v14 = &v13[sub_14004CDFC(v13, v16)];
    if ( (v20 & 0x1000) != 0 )
      return v4;
    if ( v17 != -66 )
      return v4;
    sub_14004CDFC(v14, v16);
    if ( (v20 & 0x1000) != 0 || v17 != -115 || v18 != 7 )
      return v4;
    v12 = v19 == 6;
LABEL_34:
    if ( v12 )
    {
      v4 = 1;
      *a2 = 1;
    }
    return v4;
  }
  return 0;
}

_OWORD *__fastcall EAC::Memory::CopyProcessInformation(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3, int a4, int a5, unsigned __int16 *a6, __int16 pID, _QWORD *a8)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v42 = a1;
  v9 = a2;
  v11 = 0i64;
  if ( a3 > 0x8000 )
    return 0i64;
  v12 = EAC::Memory::ExAllocatePoolWithRandomTag2(4704i64);
  v13 = v12;
  v40 = v12;
  if ( !v12 )
    return 0i64;
  EAC::Memory::memset(v12, 0, 0x260ui64);
  *&v13->char0 = 10;
  v13->dword4 = 1346718061;
  v13->word8 = 2;
  v13->qwordE = a1;
  v13->dword16 = v9;
  v13->dword1A = a4;
  v14 = 64;
  if ( a5 )
    v14 = a5;
  v13->byte1E = v14;
  v13->word220 = pID;
  if ( a6 )
  {
    v15 = *(a6 + 1);
    if ( v15 )
    {
      v16 = *a6;
      if ( v16 )
      {
        v17 = a6[1];
        if ( v17 )
        {
          v18 = &v13->word20;
          v19 = 0;
          if ( (v16 & 1) != 0 || (v17 & 1) != 0 || v16 > v17 || v17 == 0xFFFF )
            v19 = 0xC000000D;
          if ( v19 < 0 )
          {
            *v18 = 0;
          }
          else
          {
            v20 = v16 >> 1;
            v21 = 256i64;
            v22 = v15 - v18;
            do
            {
              if ( !(v20 + v21 - 256) )
                break;
              *v18 = *(v18 + v22);
              ++v18;
              --v21;
            }
            while ( v21 );
            v23 = v18 - 1;
            if ( v21 )
              v23 = v18;
            *v23 = 0;
          }
          if ( sub_140021608(a6, v37) )
            v13->byte1F = (*a6 - v37[0]) >> 1;
        }
      }
    }
  }
  v24 = &v13->oword260;
  if ( a1 && a2 >= 0x1000 && EAC::Memory::IsAddressLoadedInUsermodeMemory(a1, a2, &v13->gap222[18]) )
  {
    v25 = v13->word238;
    if ( v25 == 332 )
    {
      v26 = 32;
    }
    else if ( v25 == 0x8664 || v25 == 0xAA64 )
    {
      v26 = 64;
    }
    else
    {
      v26 = 0;
    }
    v13->byte1E = v26;
    if ( a1 < MmHighestUserAddress )
    {
      EAC::Callbacks::IsInUsermodeAddressSpace(a1, a2, 1);
      if ( EAC::Memory::GetPEHeader(a1, a2, 0i64, &v36) )
      {
        v27 = v36;
        EAC::Callbacks::CheckModuleExtension(v42, v13->byte1E, v36, v13->gap222);
        v39 = &v13->oword260;
        v28 = (v27 + *(v27 + 10) + 24);
        v38 = v28;
        v29 = 0;
        while ( v29 < *(v27 + 3) )
        {
          EAC::Callbacks::IsInUsermodeAddressSpace(v28, 40i64, 1);
          *v24 = *v28;
          ++v13->word254;
          ++v29;
          v28 += 5;
          v38 = v28;
          v24 = (v24 + 8);
          v39 = v24;
        }
        if ( EAC::Memory::CopyRawDataFromDebugDirectory(v42, v41, 128) )
        {
          v37[1] = v41;
          v30 = -1i64;
          do
            ++v30;
          while ( v41[v30] );
          v36 = v30;
          LOWORD(v37[0]) = v30;
          WORD1(v37[0]) = v30 + 1;
          EAC::Memory::memmove(v24, v41, v30);
          LODWORD(v24) = v30 + v24;
          v13->word25A = v30;
        }
      }
      else
      {
        v13->dword1A |= 0x80u;
      }
    }
    v31 = a3;
  }
  else
  {
    v13->dword1A |= 0x80u;
    v31 = a3;
  }
  v32 = v24 - v13;
  v13->unsigned_intA = v32;
  if ( v32 + v31 >= v32 )
  {
    v33 = EAC::Memory::ExAllocatePoolWithRandomTag2(v32 + v31);
    v11 = v33;
    if ( v33 )
    {
      EAC::Memory::memmove(v33, &v13->char0, v13->unsigned_intA);
      if ( v31 )
      {
        if ( a8 )
          *a8 = v11 + *(v11 + 10);
      }
    }
  }
  EAC::Memory::ExFreePool(v13);
  return v11;
}

char __fastcall EAC::Memory::IsImageOnDisk(__int64 a1, __int64 a2)
{
  char v2; // bl

  v2 = 0;
  if ( a1
    && a2
    && (EAC::Imports::GetDeviceName(a1, a2)
     || EAC::Callbacks::GetProcessName(a1, a2)
     || EAC::Memory::GetProcessPathOrCommandline(a1, 0, a2)) )
  {
    v2 = 1;
  }
  return v2;
}

char EAC::Callbacks::CheckRunningPrograms()
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v0 = 0;
  v1 = 0;
  v2 = 0;
  v3 = EAC::Memory::ExAllocatePoolWithRandomTag2(2048i64);
  v4 = v3;
  if ( !v3 )
    goto LABEL_23;
  v5 = EAC::Memory::GetRunningProcesses(v3, 0x100u);
  if ( v5 )
  {
    v6 = v4;
    while ( 1 )
    {
      if ( *v6 )
      {
        if ( EAC::Imports::PsLookupProcessByProcessID(*v6, &Object) >= 0 )
        {
          v7 = EAC::Imports::GetProcessFileName(Object, v55);
          ObfDereferenceObject(Object);
          if ( v7 )
          {
            v60 = 1551606071;
            v52 = 0i64;
            v8 = v1 | 1;
            v61 = 1300367728;
            v9 = -1293282290;
            for ( i = 0i64; i < 8; i += 4i64 )
            {
              v9 = __ROR4__(214013 * v9 + 2531011, 3);
              *(&v52 + i) = *(&v60 + i) ^ v9;
            }
            if ( EAC::Memory::CompareStrings(v55, &v52, 7ui64) )
              goto LABEL_15;
            v62 = 1587912774;
            v51 = 0i64;
            v8 |= 2u;
            v63 = 0x8CB32030;
            v11 = 0x97070F92;
            for ( j = 0i64; j < 8; j += 4i64 )
            {
              v11 = ~(((v11 ^ (v11 >> 7)) << 9) ^ v11 ^ (v11 >> 7) ^ ((((v11 ^ (v11 >> 7)) << 9) ^ v11 ^ (v11 >> 7)) >> 13));
              *(&v51 + j) = *(&v62 + j) ^ v11;
            }
            if ( EAC::Memory::CompareStrings(v55, &v51, 7ui64)// dbgview
                                                // devenv
                                                // tv_
              || (v8 |= 4u, strcpy(v59, "tv_"), EAC::Memory::CompareStrings(v55, v59, 3ui64)) )
            {
LABEL_15:
              v13 = 1;
            }
            else
            {
              v13 = 0;
            }
            if ( (v8 & 4) != 0 )
            {
              v8 &= 0xFFFFFFFB;
              memset(v59, 0, 4ui64);
            }
            if ( (v8 & 2) != 0 )
            {
              v8 &= 0xFFFFFFFD;
              memset(&v51, 0, sizeof(v51));
            }
            v1 = v8 & 0xFFFFFFFE;
            memset(&v52, 0, sizeof(v52));
            if ( v13 )
              break;
          }
        }
      }
      ++v0;
      ++v6;
      if ( v0 >= v5 )
        goto LABEL_22;
    }
    v2 = 1;
  }
LABEL_22:
  EAC::Memory::ExFreePool(v4);
  if ( !v2 )
  {
LABEL_23:
    v14 = EAC::Memory::GetRunningModules();
    v15 = v14;
    if ( v14 )
    {
      v16 = 0;
      if ( *v14 )
      {
        while ( 1 )
        {
          v17 = 74i64 * v16;
          if ( *&v15[v17 + 6] >= MmSystemRangeStart )
          {
            v18 = HIWORD(v15[v17 + 11]);
            v19 = &v15[v17 + 12];
            v20 = (v19 + v18) == 0i64;
            v21 = v19 + v18;
            String1.Buffer = v21;
            if ( v20 )
            {
              *&String1.Length = 0;
            }
            else
            {
              v22 = -1i64;
              do
                ++v22;
              while ( v21[v22] );
              String1.Length = v22;
              String1.MaximumLength = v22 + 1;
            }
            v42[0] = -1641674219;
            v23 = v1 | 8;
            v42[1] = -1284726641;
            *v48 = 0i64;
            v24 = -398366639;
            v48[8] = 0;
            v25 = 0i64;
            v43 = -64;
            do
            {
              v26 = v42[v25] ^ v24;
              v24 = __ROL4__(214013 * v24 + 2531011, 1);
              *&v48[v25 * 4] = v26;
              ++v25;
            }
            while ( v25 < 2 );
            v48[8] = v43 ^ v24;
            String2.Buffer = v48;
            v27 = -1i64;
            do
              ++v27;
            while ( v48[v27] );
            String2.Length = v27;
            String2.MaximumLength = v27 + 1;
            if ( !RtlCompareString(&String1, &String2, 1u) )// Dbgv.sys
              goto LABEL_51;
            v46[0] = -1717625671;
            v23 |= 0x10u;
            v46[1] = 1890075069;
            *v50 = 0i64;
            v28 = -623882519;
            *&v50[8] = 0;
            v29 = 0i64;
            *&v50[12] = 0;
            v46[2] = 1862005061;
            v47 = 31770;
            do
            {
              *&v50[v29 * 4] = v46[v29] ^ v28;
              ++v29;
              v28 = __ROL4__(
                      ((v28 ^ (v28 >> 7)) << 9) ^ v28 ^ (v28 >> 7) ^ ((((v28 ^ (v28 >> 7)) << 9) ^ v28 ^ (v28 >> 7)) >> 13),
                      2);
            }
            while ( v29 < 3 );
            for ( k = 12i64; k < 0xE; ++k )
            {
              v31 = v28;
              v28 >>= 8;
              v50[k] = *(v46 + k) ^ v31;
            }
            v57.Buffer = v50;
            v32 = -1i64;
            do
              ++v32;
            while ( v50[v32] );
            v57.Length = v32;
            v57.MaximumLength = v32 + 1;
            if ( !RtlCompareString(&String1, &v57, 1u) )// PROCMON23.sys
              goto LABEL_51;
            v44[0] = -448893557;
            v23 |= 0x20u;
            v44[1] = -928826563;
            *v49 = 0i64;
            v33 = -749400081;
            *&v49[8] = 0;
            v34 = 0i64;
            v45 = 15396;
            do
            {
              v35 = v44[v34] ^ v33;
              v33 = ~(214013 * v33 + 2531011);
              *&v49[v34 * 4] = v35;
              ++v34;
            }
            while ( v34 < 2 );
            for ( l = 8i64; l < 0xA; ++l )
            {
              v37 = v33;
              v33 >>= 8;
              v49[l] = *(v44 + l) ^ v37;
            }
            v58.Buffer = v49;
            v38 = -1i64;
            do
              ++v38;
            while ( v49[v38] );
            v58.Length = v38;
            v58.MaximumLength = v38 + 1;
            v39 = RtlCompareString(&String1, &v58, 1u);//  dbk64.sys
            v40 = 0;
            if ( !v39 )
LABEL_51:
              v40 = 1;
            if ( (v23 & 0x20) != 0 )
            {
              v23 &= 0xFFFFFFDF;
              memset(v49, 0, sizeof(v49));
            }
            if ( (v23 & 0x10) != 0 )
            {
              v23 &= 0xFFFFFFEF;
              memset(v50, 0, sizeof(v50));
            }
            v1 = v23 & 0xFFFFFFF7;
            memset(v48, 0, sizeof(v48));
            if ( v40 )
              break;
          }
          if ( ++v16 >= *v15 )
            goto LABEL_60;
        }
        v2 = 1;
      }
LABEL_60:
      EAC::Memory::ExFreePool(v15);
    }
  }
  return v2;
}

char *__fastcall EAC::Callbacks::DetectUsermodeAnomalies(unsigned int a1, __int64 a2, _OWORD *a3, __int64 a4, char *a5, unsigned int a6)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v20 = a3;
  v7 = EAC::Imports::PsGetCurrentProcess();
  result = EAC::Imports::GetProcessBaseAddress(v7);
  v9 = result;
  if ( result < MmHighestUserAddress )
  {
    v10 = (v19 & -(EAC::Callbacks::GetProcessName(v7, v19) != 0));
    v11 = EAC::Imports::PsGetCurrentProcessID(v7);
    v12 = EAC::Imports::PsGetCurrentProcess();
    v13 = EAC::Imports::PsGetProcessWow64(v12);
    v14 = a5;
    if ( a5 && a6 )
      v15 = a6 + 4096;
    else
      v15 = 4096;
    v16 = EAC::Memory::CopyProcessInformation(v9, 0x1000ui64, v15, 1, v13, v10, v11, &v20);
    v17 = v16;
    if ( v16 )
    {
      *(v16 + 22) = 0;
      if ( v9 )
      {
        EAC::Callbacks::IsInUsermodeAddressSpace((v9 + 4096), 4096i64, 1);
        EAC::Memory::memmove(v20, v9 + 4096, 0x1000ui64);
      }
      if ( !v14 )
        goto LABEL_14;
      if ( a6 && v20 )
        EAC::Memory::memmove(v20 + 256, v14, a6);
      v18 = a6;
      if ( !a6 )
LABEL_14:
        v18 = 0;
      EAC::Callbacks::ReportViolation(a1, v17, v18 + *(v17 + 10) + 4096);
      memset(v17, 0, (*(v17 + 10) + 4096));
      EAC::Memory::ExFreePool(v17);
    }
    result = v19;
    if ( v10 == v19 )
      result = EAC::Memory::FreeUnicdeString(v19);
  }
  return result;
}

__int64 __fastcall EAC::Callbacks::CheckForBlacklistedProcessNames(__int64 a1, _DWORD *a2, int a3, unsigned int a4)
{
  char v5; // bl
  char v8; // r14
  int v9; // edx
  unsigned __int64 v10; // rdi
  char v11; // dl
  unsigned int v12; // ecx
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  unsigned int v16; // ecx
  bool v17; // zf
  unsigned int v18; // edx
  unsigned __int64 v19; // rdi
  unsigned __int64 i; // rdi
  char v21; // cl
  char v22; // dl
  unsigned int v23; // edx
  unsigned __int64 v24; // rdi
  int v25; // ecx
  unsigned __int64 j; // rdi
  char v27; // cl
  char v28; // dl
  unsigned int v29; // ecx
  int v30; // edx
  int v31; // edi
  int v32; // ecx
  int v33; // edx
  unsigned int v34; // edx
  unsigned __int64 v35; // rdi
  int v37[2]; // [rsp+38h] [rbp-49h]
  __int16 v38; // [rsp+40h] [rbp-41h]
  char v39; // [rsp+42h] [rbp-3Fh]
  int v40[3]; // [rsp+43h] [rbp-3Eh]
  char v41; // [rsp+4Fh] [rbp-32h]
  int v42[3]; // [rsp+50h] [rbp-31h]
  __int16 v43; // [rsp+5Ch] [rbp-25h]
  char v44; // [rsp+5Eh] [rbp-23h]
  int v45[3]; // [rsp+5Fh] [rbp-22h]
  _BYTE v46[11]; // [rsp+6Bh] [rbp-16h] BYREF
  _BYTE v47[13]; // [rsp+76h] [rbp-Bh] BYREF
  _BYTE v48[15]; // [rsp+83h] [rbp+2h] BYREF
  _BYTE v49[12]; // [rsp+92h] [rbp+11h] BYREF
  char v50[24]; // [rsp+A0h] [rbp+1Fh] BYREF

  v5 = 0;
  if ( !EAC::Imports::GetProcessFileName(a1, v50) )
    return a4;
  v8 = 1;
  if ( !a2 || *a2 != 0x52 && *a2 != 0x118 && *a2 != 0x119 && *a2 != 0x11B && *a2 != 0x17F && *a2 != 0x1EA )
    goto LABEL_13;
  v45[0] = -1709991619;
  *v49 = 0i64;
  v9 = 1210365784;
  *&v49[8] = 0;
  v10 = 0i64;
  v45[1] = 1457018111;
  v45[2] = 18902803;
  do
  {
    v9 = ~(1103515245 * v9 + 12345);
    *&v49[v10 * 4] = v45[v10] ^ v9;
    ++v10;
  }
  while ( v10 < 3 );
  v5 = 1;
  if ( EAC::Memory::CompareStrings(v50, v49, 0xBui64) )
  {
    v11 = 1;
  }
  else
  {
LABEL_13:
    v11 = 0;
    if ( (v5 & 1) == 0 )
      goto LABEL_26;
  }
  v5 &= 0xFEu;
  memset(v49, 0, sizeof(v49));
  if ( v11 )
  {
    v12 = a4 | 2;
    if ( (a3 & 2) == 0 )
      v12 = a4;
    v13 = v12 | 8;
    if ( (a3 & 8) == 0 )
      v13 = v12;
    v14 = v13 | 0x10;
    if ( (a3 & 0x10) == 0 )
      v14 = v13;
    v15 = v14 | 0x20;
    if ( (a3 & 0x20) == 0 )
      v15 = v14;
    v16 = v15 | 0x200;
    if ( (a3 & 0x200) == 0 )
      v16 = v15;
    a4 = v16 | 0x400;
    v17 = (a3 & 0x400) == 0;
LABEL_64:
    if ( v17 )
      a4 = v16;
    return a4;
  }
  if ( *a2 != 20 )
    goto LABEL_33;
LABEL_26:
  v37[0] = -1987792738;
  *v46 = 0i64;
  v5 |= 2u;
  *&v46[8] = 0;
  v18 = -640686133;
  v46[10] = 0;
  v19 = 0i64;
  v37[1] = 392935476;
  v38 = 14253;
  v39 = -74;
  do
  {
    *&v46[v19 * 4] = v37[v19] ^ v18;
    ++v19;
    v18 = __ROR4__(
            ((v18 ^ (v18 >> 7)) << 9) ^ v18 ^ (v18 >> 7) ^ ((((v18 ^ (v18 >> 7)) << 9) ^ v18 ^ (v18 >> 7)) >> 13),
            4);
  }
  while ( v19 < 2 );
  for ( i = 8i64; i < 0xB; ++i )
  {
    v21 = v18;
    v18 >>= 8;
    v46[i] = *(v37 + i) ^ v21;
  }
  if ( EAC::Memory::CompareStrings(v50, v46, 0xAui64) )
    v22 = 1;
  else
LABEL_33:
    v22 = 0;
  if ( (v5 & 2) != 0 )
  {
    v5 &= 0xFDu;
    memset(v46, 0, sizeof(v46));
  }
  if ( v22 )
  {
    v16 = a4 | 0x400;
    if ( (a3 & 0x400) == 0 )
      v16 = a4;
    a4 = v16 | 0x10;
    v17 = (a3 & 0x10) == 0;
    goto LABEL_64;
  }
  if ( *a2 != 330 )
    goto LABEL_47;
  v42[0] = 827781030;
  *v48 = 0i64;
  v5 |= 4u;
  *&v48[8] = 0;
  v23 = 1445236465;
  *&v48[12] = 0;
  v24 = 0i64;
  v48[14] = 0;
  v42[1] = -1132862917;
  v42[2] = 347640278;
  v43 = 26589;
  v44 = 98;
  do
  {
    v25 = v42[v24] ^ v23;
    v23 = __ROR4__(1103515245 * v23 + 12345, 3);
    *&v48[v24 * 4] = v25;
    ++v24;
  }
  while ( v24 < 3 );
  for ( j = 12i64; j < 0xF; ++j )
  {
    v27 = v23;
    v23 >>= 8;
    v48[j] = *(v42 + j) ^ v27;
  }
  if ( EAC::Memory::CompareStrings(v50, v48, 0xEui64) )
    v28 = 1;
  else
LABEL_47:
    v28 = 0;
  if ( (v5 & 4) != 0 )
  {
    v5 &= 0xFBu;
    memset(v48, 0, sizeof(v48));
  }
  if ( v28 )
  {
    v29 = a4 | 0x40;
    if ( (a3 & 0x40) == 0 )
      v29 = a4;
    v30 = v29 | 0x400;
    if ( (a3 & 0x400) == 0 )
      v30 = v29;
    v31 = v30 | 0x1000;
    if ( (a3 & 0x1000) == 0 )
      v31 = v30;
    v32 = v31 | 0x800;
    if ( (a3 & 0x800) == 0 )
      v32 = v31;
    v33 = v32 | 1;
    if ( (a3 & 1) == 0 )
      v33 = v32;
    v16 = v33 | 0x10;
    if ( (a3 & 0x10) == 0 )
      v16 = v33;
    a4 = v16 | 0x100000;
    v17 = (a3 & 0x100000) == 0;
    goto LABEL_64;
  }
  if ( MEMORY[0xFFFFF7800000026C] != 10 && EAC::Memory::GetBuildNumber() < 10240 )// if not windows 10
    goto LABEL_73;
  if ( (a3 & 0x400) == 0 )
    goto LABEL_73;
  v40[0] = -756454645;
  *v47 = 0i64;
  v5 |= 8u;
  *&v47[8] = 0;
  v34 = -1584920471;
  v47[12] = 0;
  v35 = 0i64;
  v40[1] = 1749006771;
  v40[2] = 72172906;
  v41 = -4;
  do
  {
    *&v47[v35 * 4] = v40[v35] ^ v34;
    ++v35;
    v34 = -(((v34 ^ (v34 << 13)) >> 7) ^ v34 ^ (v34 << 13) ^ ((((v34 ^ (v34 << 13)) >> 7) ^ v34 ^ (v34 << 13)) << 17));
  }
  while ( v35 < 3 );
  v47[12] = v41 ^ v34;
  if ( !EAC::Memory::CompareStrings(v50, v47, 0xCui64) )
LABEL_73:
    v8 = 0;
  if ( (v5 & 8) != 0 )
    memset(v47, 0, sizeof(v47));
  if ( v8 )
    a4 |= 0x400u;
  return a4;
}

char __fastcall EAC::Callbacks::CheckForFrapsEXE(ULONG64 a1)
{
  char v2; // bl
  ULONG v3; // eax
  IMAGE_NT_HEADERS64 *v5; // [rsp+48h] [rbp+10h] BYREF

  v2 = 0;
  if ( a1 )
  {
    EAC::Callbacks::IsInUsermodeAddressSpace(a1, 4096i64, 1);
    if ( EAC::Memory::GetPEHeader(a1, 0x1000ui64, 0i64, &v5) )
    {
      if ( v5->FileHeader.Characteristics == 271 && v5->FileHeader.NumberOfSections == 5 )
      {
        v3 = v5->FileHeader.TimeDateStamp;
        if ( v3 == 0x4EA2A728 || v3 == 0x503F67EC || v3 == 0x512C56A2 || v3 == 0x55EAA341 )
          v2 = 1;
      }
    }
  }
  return v2;
}

```