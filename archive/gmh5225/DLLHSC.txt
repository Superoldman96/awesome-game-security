Project Path: arc_gmh5225_DLLHSC_bv14_u68

Source Tree:

```txt
arc_gmh5225_DLLHSC_bv14_u68
├── DLLHSC
│   ├── DLLHSC
│   │   ├── DLLHSC.cpp
│   │   ├── DLLHSC.vcxproj
│   │   ├── DLLHSC.vcxproj.filters
│   │   ├── DLLHSC.vcxproj.user
│   │   ├── detours.h
│   │   ├── lib.X64
│   │   │   ├── detours.lib
│   │   │   └── detours.pdb
│   │   ├── lib.X86
│   │   │   ├── detours.lib
│   │   │   └── detours.pdb
│   │   └── utility.h
│   ├── DLLHSC.sln
│   ├── Hooking
│   │   ├── Hooking.vcxproj
│   │   ├── Hooking.vcxproj.filters
│   │   ├── Hooking.vcxproj.user
│   │   └── main.cpp
│   └── Payload
│       ├── Payload.vcxproj
│       ├── Payload.vcxproj.filters
│       ├── Payload.vcxproj.user
│       └── main.cpp
├── LICENSE
├── README.md
└── screenshots
    ├── README.md
    ├── dependency.PNG
    ├── dllhsc-l.PNG
    ├── dllhsc-lm.PNG
    └── dllhsc-rt.PNG

```

`DLLHSC/DLLHSC.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29123.88
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DLLHSC", "DLLHSC\DLLHSC.vcxproj", "{F423385A-BA54-419E-BC1D-85C36D5B3357}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "payload", "Payload\Payload.vcxproj", "{853A379A-F397-46D7-AA5A-416423C4A554}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "detour", "Hooking\Hooking.vcxproj", "{75A41684-E690-488E-8B31-0D33A991DED1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F423385A-BA54-419E-BC1D-85C36D5B3357}.Debug|x64.ActiveCfg = Debug|x64
		{F423385A-BA54-419E-BC1D-85C36D5B3357}.Debug|x64.Build.0 = Debug|x64
		{F423385A-BA54-419E-BC1D-85C36D5B3357}.Debug|x86.ActiveCfg = Debug|x64
		{F423385A-BA54-419E-BC1D-85C36D5B3357}.Debug|x86.Build.0 = Debug|x64
		{F423385A-BA54-419E-BC1D-85C36D5B3357}.Release|x64.ActiveCfg = Release|x64
		{F423385A-BA54-419E-BC1D-85C36D5B3357}.Release|x64.Build.0 = Release|x64
		{F423385A-BA54-419E-BC1D-85C36D5B3357}.Release|x86.ActiveCfg = Release|Win32
		{F423385A-BA54-419E-BC1D-85C36D5B3357}.Release|x86.Build.0 = Release|Win32
		{853A379A-F397-46D7-AA5A-416423C4A554}.Debug|x64.ActiveCfg = Debug|x64
		{853A379A-F397-46D7-AA5A-416423C4A554}.Debug|x64.Build.0 = Debug|x64
		{853A379A-F397-46D7-AA5A-416423C4A554}.Debug|x86.ActiveCfg = Debug|Win32
		{853A379A-F397-46D7-AA5A-416423C4A554}.Debug|x86.Build.0 = Debug|Win32
		{853A379A-F397-46D7-AA5A-416423C4A554}.Release|x64.ActiveCfg = Release|x64
		{853A379A-F397-46D7-AA5A-416423C4A554}.Release|x64.Build.0 = Release|x64
		{853A379A-F397-46D7-AA5A-416423C4A554}.Release|x86.ActiveCfg = Release|Win32
		{853A379A-F397-46D7-AA5A-416423C4A554}.Release|x86.Build.0 = Release|Win32
		{75A41684-E690-488E-8B31-0D33A991DED1}.Debug|x64.ActiveCfg = Debug|x64
		{75A41684-E690-488E-8B31-0D33A991DED1}.Debug|x64.Build.0 = Debug|x64
		{75A41684-E690-488E-8B31-0D33A991DED1}.Debug|x86.ActiveCfg = Debug|Win32
		{75A41684-E690-488E-8B31-0D33A991DED1}.Debug|x86.Build.0 = Debug|Win32
		{75A41684-E690-488E-8B31-0D33A991DED1}.Release|x64.ActiveCfg = Release|x64
		{75A41684-E690-488E-8B31-0D33A991DED1}.Release|x64.Build.0 = Release|x64
		{75A41684-E690-488E-8B31-0D33A991DED1}.Release|x86.ActiveCfg = Release|Win32
		{75A41684-E690-488E-8B31-0D33A991DED1}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {DCDB2AE0-B509-453F-AEEF-6F0A60881F96}
	EndGlobalSection
EndGlobal

```

`DLLHSC/DLLHSC/DLLHSC.cpp`:

```cpp
#include <windows.h>
#include <shlwapi.h>
#include <stdio.h>
#include <string>
#include <strsafe.h>
#include <tchar.h>
#include <stringapiset.h>
#include <Winuser.h>
#include <psapi.h>
#include "detours.h"
#include "utility.h"

#pragma comment(lib, "shlwapi.lib")
#ifdef _WIN32
#pragma comment(lib, "lib.X86/detours.lib")
#endif
#ifdef _WIN64
#pragma comment(lib, "lib.X64/detours.lib")
#endif

struct KnownDLLs {
	BYTE** list;
	DWORD size;
};
struct ImportedModules {
	CHAR** modulenames;
	DWORD count;
};
struct Manifest {
	CHAR* location;
	DWORD size;
};

void menu()
{
	// prints this menu and exits
	printf("NAME\n");
	printf("\tdllhsc - DLL Hijack SCanner\n\n");
	printf("SYNOPSIS\n");
	printf("\tdllhsc.exe -h\n\n");
	printf("\tdllhsc.exe -e <executable image path> (-l|-lm|-rt) [-t seconds]\n\n");
	printf("DESCRIPTION\n");
	printf("\tDLLHSC scans a given executable image for DLL Hijacking and reports the results\n\n");
	printf("\tIt requires elevated privileges\n\n");
	printf("OPTIONS\n");
	printf("\t-h, --help\n");
	printf("\t\tdisplay this help menu and exit\n\n");
	printf("\t-e, --executable-image\n");
	printf("\t\texecutable image to scan\n\n");
	printf("\t-l, --lightweight\n");
	printf("\t\tparse the import table, attempt to launch a payload and report the results\n\n");
	printf("\t-lm, --list-modules\n");
	printf("\t\tlist loaded modules that do not exist in the application's directory\n\n");
	printf("\t-rt, --runtime-load\n");
	printf("\t\tdisplay modules loaded in run-time by hooking LoadLibrary and LoadLibraryEx APIs\n\n");
	printf("\t-t, --timeout\n");
	printf("\t\tnumber of seconds to wait for checking any popup error windows - defaults to 10 seconds\n");
}

CHAR* FindFirstOccurence(CHAR* input, CHAR* keyword)
{
	// returns a pointer to the beginning of the substring(keyword) or 0 if the substring is not found
	CHAR* offsetaddr = 0;
	
	// if keyword is smaller than the input, exit
	if ( strlen(keyword) > strlen(input))
	{
		return offsetaddr;
	}

	CHAR* slidingwindow = new CHAR[strlen(keyword) + 1];
	size_t limit = strlen(input) - strlen(keyword) + 1;
	for (size_t i = 0; i < limit; i++)
	{
		strncpy_s(slidingwindow, strlen(keyword) + 1, input, strlen(keyword));
		if (!(_stricmp(slidingwindow, keyword)))
		{
			offsetaddr = input;
			break;
		}
		input++;
	}
	return offsetaddr;
}

CHAR* helper(CHAR* input, CHAR* output)
{
	// parses double quote terminated string into null terminated string
	int i = 0;
	if (input == NULL)
	{
		output[i] = '*';
		output[i + 1] = '\0';
		return output;
	}

	while (input[i] != '\"')
	{
		output[i] = input[i];
		i++;
	}
	output[i] = '\0';

	return output;
}

BOOL CheckElevatePrivilege()
{
	HANDLE hProccessToken = INVALID_HANDLE_VALUE;

	BOOL result = ::OpenProcessToken((HANDLE)-1, TOKEN_QUERY, &hProccessToken);
	if(!result || hProccessToken == INVALID_HANDLE_VALUE)
		return FALSE;

	TOKEN_ELEVATION TokenInformation = {0};
	DWORD dwReturnLength = sizeof(TOKEN_ELEVATION);
	::GetTokenInformation(hProccessToken, TokenElevation, &TokenInformation, dwReturnLength, &dwReturnLength);
	::CloseHandle(hProccessToken);
	return TokenInformation.TokenIsElevated != 0;
}

KnownDLLs RegReadKnownDLLs()
{
	// lpValueName = module/DLL name
	HKEY hKey;
	LPCSTR lpSubKey = "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs";

	KnownDLLs knowndlls = { 0 };

	// get a handle to the registry key
	DWORD regstat = RegOpenKeyExA(HKEY_LOCAL_MACHINE, lpSubKey, 0, KEY_READ, &hKey);
	if (regstat)
	{
		printf("[-] RegOpenKeyExA: %d\n", GetLastError());
		return knowndlls;
	}

	// get number of Values, MaxValueNameLen and MaxValueLen the key has
	DWORD lpcbMaxValueNameLen, lpcbMaxValueLen;
	if (RegQueryInfoKeyA(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &knowndlls.size, &lpcbMaxValueNameLen, &lpcbMaxValueLen, NULL, NULL))
	{
		printf("[-] RegQueryInfoKeyA: %d\n", GetLastError());
		return knowndlls;
	}
		
	CHAR* lpValueName = new CHAR[lpcbMaxValueNameLen + 1];
	knowndlls.list = new BYTE*[knowndlls.size];
	for (unsigned int dwIndex = 0; dwIndex < knowndlls.size; dwIndex++)
	{
		knowndlls.list[dwIndex] = new BYTE[lpcbMaxValueLen];
		DWORD lpcchValueName = lpcbMaxValueNameLen + 1;
		DWORD lpcbData = lpcbMaxValueLen;
		DWORD lpType;
		RegEnumValueA(hKey, dwIndex, lpValueName, &lpcchValueName, NULL, &lpType, knowndlls.list[dwIndex], &lpcbData);
	}
	delete []lpValueName;

	return knowndlls;
}

CHAR* LoadFileMemory(CHAR* exepath)
{
	// loads a file into memory and returns a pointer to the buffer

	// get file handle
	HANDLE hFile = 0;
	hFile = CreateFileA(exepath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		//printf("[-] in LoadFileMemory CreateFileA has failed: %d\n", GetLastError());
		if (GetLastError() == ERROR_FILE_NOT_FOUND)
		{
			//printf("[-] in load memory The file you specified doesn't exist\n");
		}
		return 0;
	}

	// get file size
	DWORD nNumberOfBytesToRead = GetFileSize(hFile, NULL);

	// read file bytes
	CHAR* lpBuffer = 0;
	lpBuffer = new CHAR[nNumberOfBytesToRead+1];
	if (!ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, NULL, NULL))
	{
		printf("[-] FileRead has failed: %d\n", GetLastError());
		return 0;
	}
	lpBuffer[nNumberOfBytesToRead] = '\0';

	CloseHandle(hFile);

	return lpBuffer;
}

DWORD RVAtoOffset(DWORD RVA, DWORD NumberOfSections, IMAGE_SECTION_HEADER* hdrSection)
{
	IMAGE_SECTION_HEADER* tmphdrSection;
	tmphdrSection = hdrSection;

	if (RVA == 0)
	{
		return RVA;
	}

	for (unsigned int i = 0; i < NumberOfSections; i++)
	{
		if (RVA >= tmphdrSection->VirtualAddress && RVA < tmphdrSection->VirtualAddress + tmphdrSection->Misc.VirtualSize)
		{
			break;
		}
		tmphdrSection++;
	}

	return (RVA - tmphdrSection->VirtualAddress + tmphdrSection->PointerToRawData);
}

template <typename T>
ImportedModules ParseImportedModules(CHAR* lpBuffer, T* hdrNT)
{
	// parses the Imported modules
	// returns a struct that contains the names and the number of imported modules for 32bit arch
	IMAGE_SECTION_HEADER* hdrSection = IMAGE_FIRST_SECTION(hdrNT);
	IMAGE_IMPORT_DESCRIPTOR* ImgImportDescriptor;

	ImportedModules imodules = { 0 };

	if (hdrNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size != 0)
	{
		ImgImportDescriptor = (IMAGE_IMPORT_DESCRIPTOR*)(lpBuffer + RVAtoOffset(hdrNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress, hdrNT->FileHeader.NumberOfSections, hdrSection));

		IMAGE_IMPORT_DESCRIPTOR* tmpImgImportDescriptor = ImgImportDescriptor;
		while (tmpImgImportDescriptor->Name != NULL)
		{
			// number of imported modules
			imodules.count++;
			tmpImgImportDescriptor++;
		}

		imodules.modulenames = new CHAR * [imodules.count];
		for (unsigned int i = 0; i < imodules.count; i++)
		{
			imodules.modulenames[i] = new CHAR[40];
			imodules.modulenames[i] = (CHAR*)(lpBuffer + RVAtoOffset(ImgImportDescriptor->Name, hdrNT->FileHeader.NumberOfSections, hdrSection));
			ImgImportDescriptor++;
		}

		// return number of modules parsed
		return imodules;
	}
	else
	{
		// 0 modules parsed, return 0
		return imodules;
	}
}

template <typename T>
Manifest GetPointerToManifest(CHAR* lpBuffer, T* hdrNT)
{
	// returns a pointer to Manifest file
	IMAGE_SECTION_HEADER* hdrSection = IMAGE_FIRST_SECTION(hdrNT);
	IMAGE_RESOURCE_DIRECTORY* ImgResourceDir, * ImgResourceDirSecond, * ImgResourceDirThird;

	Manifest manifest = { 0 };

	ImgResourceDir = (IMAGE_RESOURCE_DIRECTORY*)(lpBuffer + RVAtoOffset(hdrNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress, hdrNT->FileHeader.NumberOfSections, hdrSection));

	IMAGE_RESOURCE_DIRECTORY_ENTRY* ImgResourceDirEntry = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(ImgResourceDir + 1);
	DWORD counter = ImgResourceDir->NumberOfNamedEntries;

	while (counter > 0)
	{
		ImgResourceDirEntry++;
		counter--;
	}

	for (unsigned int i = 0; i < ImgResourceDir->NumberOfIdEntries; i++)
	{
		// ImgResourceDirEntry->Name = 24 -> Configuration Files
		if (ImgResourceDirEntry->Name == 24)
		{
			ImgResourceDirSecond = (IMAGE_RESOURCE_DIRECTORY*)((ULONGLONG)ImgResourceDir + (0x0fffffff & ImgResourceDirEntry->OffsetToData));
			ImgResourceDirEntry = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(ImgResourceDirSecond + 1);

			ImgResourceDirThird = (IMAGE_RESOURCE_DIRECTORY*)((ULONGLONG)ImgResourceDir + (0x0fffffff & ImgResourceDirEntry->OffsetToData));
			ImgResourceDirEntry = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(ImgResourceDirThird + 1);

			IMAGE_RESOURCE_DATA_ENTRY* ImgResourceDataEntry = (IMAGE_RESOURCE_DATA_ENTRY*)((ULONGLONG)ImgResourceDir + (0x0fffffff & ImgResourceDirEntry->OffsetToData));

			manifest.location = lpBuffer + RVAtoOffset(ImgResourceDataEntry->OffsetToData, hdrNT->FileHeader.NumberOfSections, hdrSection);
			manifest.size = ImgResourceDataEntry->Size;
		}
		ImgResourceDirEntry++;
	}

	return manifest;
}

CHAR* newRemoveFileSpec(CHAR* inputpath)
{
	// function that removes the filename from the provided path
	// functionality similar to PathCchRemoveFileSpec API
	size_t i = strlen(inputpath);

	do
	{
		i--;
	} while (inputpath[i] != '\\');

	CHAR* apppath = new CHAR[i + 2];
	for (size_t j = 0; j < i + 1; j++)
	{
		apppath[j] = inputpath[j];
	}
	apppath[i + 1] = '\0';

	// return the new path (ends with \)
	return apppath;
}

BOOL inKnownDLLs(CHAR* modulename, KnownDLLs knowndlls)
{
	// checks if the provided module exists in KnownDLLs
	unsigned int j = 0;

	do 
	{
		if (!_stricmp(modulename, (CHAR *)knowndlls.list[j]))
		{
			return TRUE;
		}
		j++;
	} while (j < knowndlls.size);
	
	return FALSE;
}

CHAR* ManifestToWinSxSPath(CHAR* manifestbuffer, size_t arch)
{
	// returns the WinSxS directory wildcard
	// schemas-microsoft-com:asm.v1

	CHAR dependentAssemblykeyword[] = "<dependentAssembly>";
	CHAR dependentAssemblyEnd[] = "</dependentAssembly>";
	//CHAR assemblyidkeyword[] = "<assemblyIdentity";
	const CHAR* attributes[6] = { "processorArchitecture=\"", "name=\"", "publicKeyToken=\"", "version=\"", "language=\"", "type=\"" };

	CHAR* path = 0;
	if (manifestbuffer == 0)
	{
		return path;
	}

	CHAR* startaddress = 0;
	startaddress = FindFirstOccurence(manifestbuffer, dependentAssemblykeyword);
	if (startaddress == 0)
	{
		return path;
	}

	CHAR* upperlimit;
	CHAR* offset = startaddress;
	CHAR** attributesvalues = new CHAR * [6];
	while (offset < manifestbuffer + strlen(manifestbuffer) - strlen(dependentAssemblykeyword))
	{
		upperlimit = 0;
		if (startaddress != 0)
		{
			upperlimit = FindFirstOccurence(startaddress + strlen(dependentAssemblykeyword), dependentAssemblyEnd);
			CHAR* tmp = new CHAR[upperlimit - startaddress];
			strncpy_s(tmp, upperlimit - startaddress, startaddress + strlen(dependentAssemblykeyword), upperlimit - startaddress - strlen(dependentAssemblykeyword));
			for (int j = 0; j < 6; j++)
			{
				attributesvalues[j] = new CHAR[50];
				CHAR* matched = FindFirstOccurence(tmp, (CHAR*)attributes[j]);
				if (matched != 0) helper(matched + strlen(attributes[j]), attributesvalues[j]);
				else helper(matched, attributesvalues[j]);
			}
		}
		offset = offset + strlen(dependentAssemblykeyword);
		startaddress = FindFirstOccurence(offset, dependentAssemblykeyword);
	}

	// path structure: processorArchitecture_name_publicKeyToken_version_language_<unknown>\modulename.dll
	// <unknown>: star
	// version: star
	// language: star

	CHAR* tmp = new CHAR[MAX_PATH];
	tmp[0] = '\0';
	char underscore[] = "_";
	char star[] = "*";

	if (strncmp(attributesvalues[0], star, 1) && (arch == 32))
	{
		CHAR archSxS[] = "x86";
		tmp = ConcatString(tmp, archSxS);
	}
	else if (strncmp(attributesvalues[0], star, 1) && (arch == 64))
	{
		CHAR archSxS[] = "amd64";
		tmp = ConcatString(tmp, archSxS);
	}
	else
	{
		tmp = ConcatString(tmp, star);
	}
	tmp = ConcatString(tmp, underscore);

	for (int i = 1; i < 3; i++)
	{
		tmp = ConcatString(tmp, attributesvalues[i]);
		tmp = ConcatString(tmp, underscore);
	}
	tmp = ConcatString(tmp, star);
	tmp = ConcatString(tmp, underscore);
	tmp = ConcatString(tmp, attributesvalues[4]);
	tmp = ConcatString(tmp, underscore);
	tmp = ConcatString(tmp, star);

	CHAR base[] = "C:\\Windows\\WinSxs\\";
	path = ConcatString(base, tmp);

	return path;
}

BOOL CheckWinSxSDependency(CHAR* path, CHAR* modulename)
{
	CHAR base[] = "C:\\Windows\\WinSxS\\";
	
	WIN32_FIND_DATAA lpFindFileData = { 0 };
	HANDLE hFileListing = FindFirstFileA(path, &lpFindFileData);
	if (hFileListing == INVALID_HANDLE_VALUE)
	{
		printf("[-] FindFirstFileA has failed: %d. Exiting...\n", GetLastError());
		exit(1);
	}

	if (lpFindFileData.cFileName)
	{
		CHAR backslash[] = "\\";
		CHAR* filepath = ConcatString(base, lpFindFileData.cFileName);
		filepath = ConcatString(filepath, backslash);
		filepath = ConcatString(filepath, modulename);

		return PathFileExistsA(filepath);
	}

	/*
	while (FindNextFileA(hFileListing, &lpFindFileData) != 0)
	{
		//printf("--> %s\n", lpFindFileData.cFileName);
		//dependency = TRUE;
	}
	*/

	return FALSE;
}

CHAR* SourcePayloadPath(CHAR* filename)
{
	// returns the path of the running process

	CHAR* lpFilename = new CHAR[MAX_PATH];
	if (!GetModuleFileNameA(NULL, lpFilename, MAX_PATH))
	{
		return 0;
	}
	lpFilename = newRemoveFileSpec(lpFilename);

	return ConcatString(lpFilename, filename);
}

BOOL ColoredText(CHAR* intext, WORD color)
{
	// save current attributes
	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
	GetConsoleScreenBufferInfo(hConsole, &consoleInfo);
	WORD saved_attributes;
	saved_attributes = consoleInfo.wAttributes;

	SetConsoleTextAttribute(hConsole, color);
	printf("%s", intext);

	// restore original attributes
	SetConsoleTextAttribute(hConsole, saved_attributes);

	return TRUE;
}

int ListModules(CHAR* exeimgpath)
{
	KnownDLLs knowndlls = RegReadKnownDLLs();

	STARTUPINFOA lpStartupInfo = { 0 };
	lpStartupInfo.cb = sizeof(STARTUPINFOA);
	// do not show window
	lpStartupInfo.dwFlags = STARTF_USESHOWWINDOW;
	lpStartupInfo.wShowWindow = SW_HIDE;
	
	BOOL status = FALSE;
	PROCESS_INFORMATION lpProcessInformation = { 0 };
	status = CreateProcessA(exeimgpath, NULL, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &lpStartupInfo, &lpProcessInformation);
	if (!status)
	{
		printf("[-] CreateProcessA has failed: %d\n", GetLastError());
		return 1;
	}

	Sleep(1000);
	//DWORD sync = WaitForSingleObject(lpProcessInformation.hThread, INFINITE);

	status = FALSE;
	HMODULE hModule[1024];
	DWORD cbNeeded;
	status = EnumProcessModules(lpProcessInformation.hProcess, hModule, sizeof(hModule), &cbNeeded);
	if (!status)
	{
		printf("[-] EnumProcessModules has failed with error code: %d\n", GetLastError());
		printf("\t This may indicate that the process has crashed before listing the modules.\n");
		return 1;
	}

	printf("[+] Loaded Modules mapped in the process address space that don't exist in KnownDLLs:\n");
	for (unsigned int i = 0; i < cbNeeded / sizeof(HMODULE); i++)
	{
		CHAR lpFilename[256];
		DWORD statusModule = 0;
		statusModule = GetModuleFileNameExA(lpProcessInformation.hProcess, hModule[i], lpFilename, MAX_PATH);
		if (!status)
		{
			printf("[-] GetModuleFileNameExA has failed: %d\n", GetLastError());
			return 1;
		}

		if (strncmp(exeimgpath, lpFilename, strlen(exeimgpath)) && strncmp("c:\\windows\\winsxs\\", CharLowerA(lpFilename), 18))
		{
			// only print modules that do not exists in the KnownDLLs list
			if (!inKnownDLLs(lpFilename+20, knowndlls))
			{
				// potential hijack candidates
				printf("\t%s\n", lpFilename);
			}
		}
	}

	TerminateProcess(lpProcessInformation.hProcess, 0);

	CloseHandle(lpProcessInformation.hProcess);
	CloseHandle(lpProcessInformation.hThread);

	return 0;
}

void DeletePayloadFile(CHAR* candidateDLLfilepath)
{
	if (!DeleteFileA(candidateDLLfilepath))
	{
		printf("[-] Delete payload DLL has failed: %d. Exiting...\n", GetLastError());
		exit(1);
	}
}

BOOL CheckMessageBox(CHAR* exeimgpath)
{
	CHAR ordinal[] = " - Ordinal Not Found";
	CHAR entrypoint[] = " - Entry Point Not Found";
	CHAR* first = PathFindFileNameA(exeimgpath);

	CHAR* lpWindowName1 = ConcatString(first, ordinal);
	CHAR* lpWindowName2 = ConcatString(first, entrypoint);
	HWND WndOrdinal = 0;
	HWND WndEntryPoint = 0;
	BOOL msgboxpopup = FALSE;

	WndOrdinal = FindWindowA(NULL, lpWindowName1);
	WndEntryPoint = FindWindowA(NULL, lpWindowName2);

	//CHAR* textt = new CHAR[512];
	while (WndOrdinal != 0)
	{
		SendMessage(WndOrdinal, WM_CLOSE, NULL, NULL);
		msgboxpopup = TRUE;
		WndOrdinal = FindWindowA(NULL, lpWindowName1);
	}

	while (WndEntryPoint != 0)
	{
		SendMessage(WndEntryPoint, WM_CLOSE, NULL, NULL);
		msgboxpopup = TRUE;
		WndEntryPoint = FindWindowA(NULL, lpWindowName2);
	}

	return msgboxpopup;
}

BOOL HijackHunt(PCHAR exeimgpath, DWORD timeout)
{
	PCHAR lpBuffer = LoadFileMemory(exeimgpath);
	if (lpBuffer == 0)
	{
		printf("[-] Executable image was not loaded in memory. Exiting...\n");
		return FALSE;
	}

	KnownDLLs knowndlls = RegReadKnownDLLs();

	IMAGE_DOS_HEADER* hdrDOS = (IMAGE_DOS_HEADER*)lpBuffer;
	IMAGE_NT_HEADERS* hdrNT1 = (IMAGE_NT_HEADERS*)(lpBuffer + hdrDOS->e_lfanew);

	ImportedModules imodules = { 0 };
	Manifest manifest = { 0 };

	size_t arch = 0;
	// parse imported modules based on the architecture and get a pointer to manifest
	if (hdrNT1->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64)
	{
		arch = 64;
		IMAGE_NT_HEADERS64* hdrNT = (IMAGE_NT_HEADERS64*)(lpBuffer + hdrDOS->e_lfanew);

		imodules = ParseImportedModules(lpBuffer, hdrNT);

		// check if the image contains a manifest file
		if (hdrNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size != 0)
		{
			// get a pointer to the manifest
			manifest = GetPointerToManifest(lpBuffer, hdrNT);
		}
	}
	else if (hdrNT1->FileHeader.Machine == IMAGE_FILE_MACHINE_I386)
	{
		arch = 32;
		IMAGE_NT_HEADERS32* hdrNT = (IMAGE_NT_HEADERS32*)(lpBuffer + hdrDOS->e_lfanew);

		imodules = ParseImportedModules(lpBuffer, hdrNT);

		if (hdrNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size != 0)
		{
			// get pointer to manifest file
			manifest = GetPointerToManifest(lpBuffer, hdrNT);
		}
	}
	else
	{
		printf("[-] Unrecognized PE format. Exiting...\n");
		exit(1);
	}

	// if no import modules identified exit
	if (!imodules.count)
	{
		printf("[+] No imported modules identified. Exiting...\n");
		exit(1);
	}

	CHAR* apppath = newRemoveFileSpec(exeimgpath);

	BOOL finding = FALSE;
	for (unsigned int i = 0; i < imodules.count; i++)
	{
		// check if the imported DLL is in the KnownDLLs registry key for each of the imported modules
		if (!inKnownDLLs(imodules.modulenames[i], knowndlls))
		{
			CHAR* candidateDLLfilepath = 0;
			candidateDLLfilepath = ConcatString(apppath, imodules.modulenames[i]);
			
			// check WinSxS dependency
			CHAR* pathWinSxS = ManifestToWinSxSPath(manifest.location, arch);
			if ((pathWinSxS) && CheckWinSxSDependency(pathWinSxS, imodules.modulenames[i]))
			{
				continue;
			}

			// failsafe
			if (PathFileExistsA(candidateDLLfilepath))
			{
				printf("[!] DLL %s already exists in this directory.\n", candidateDLLfilepath);
				continue;
			}

			// if it doesn't exist, rename the payload DLL to the imported DLL and check if it's launched
			// make a 64 and a 32 bit payload, that once gets loaded will write a file in the C:\Uers\%USERNAME%\AppData\Local\Temp
			// copy the payload to the directory from which the application was launched
			// assuming the payload32.dll and payload64 are both located in the same directory
			if (arch == 32)
			{
				CHAR payloaddll[14] = "payload32.dll";
				if (!CopyFileA(SourcePayloadPath(payloaddll), ConcatString(apppath, imodules.modulenames[i]), TRUE))
				{
					printf("[-] CopyFileA for 32bit architecture has failed: %d\n", GetLastError());
				}
			}
			else if (arch == 64)
			{
				CHAR payloaddll[14] = "payload64.dll";
				if (!CopyFileA(SourcePayloadPath(payloaddll), ConcatString(apppath, imodules.modulenames[i]), TRUE))
				{
					printf("[-] CopyFileA for 64bit architecture has failed: %d\n", GetLastError());
				}
			}
			else printf("[-] Error in Switch. ARCH is zero.\n");

			STARTUPINFOA lpStartupInfo = { 0 };
			lpStartupInfo.cb = sizeof(STARTUPINFOA);
			// do not show window
			lpStartupInfo.dwFlags = STARTF_USESHOWWINDOW;
			lpStartupInfo.wShowWindow = SW_HIDE;
			PROCESS_INFORMATION lpProcessInformation;

			if (!CreateProcessA(exeimgpath, NULL, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, apppath, &lpStartupInfo, &lpProcessInformation))
			{
				printf("[-] The launch of the tested process has failed: %d. Exiting...\n", GetLastError());
				DeletePayloadFile(candidateDLLfilepath);
				exit(1);
			}

			int timewait = 5000;
			BOOL msgboxpopup = FALSE;
			// ensure process is initialized and any error boxes are generated
			DWORD starttimer = GetTickCount();
			DWORD waitreturn = WaitForInputIdle(lpProcessInformation.hProcess, timewait);
			if (waitreturn)
			{
				// debug
				//printf("[*] WaitForInputIdle timeout\n");
				while ((GetTickCount() - starttimer) < timeout)
				{
					msgboxpopup = CheckMessageBox(exeimgpath);
					if (msgboxpopup)
					{
						//printf("[*] messagebox found\n");
						break;
					}
					Sleep(1000);
				}
			}

			// terminate the process
			if (!TerminateProcess(lpProcessInformation.hProcess, 0))
			{
				// debug
				//printf("[-] Termination of the tested process has failed: %d. Exiting...\n", GetLastError());
			}

			// ensure the process is terminated
			WaitForSingleObject(lpProcessInformation.hProcess, INFINITE);

			// delete the payload DLL
			DeletePayloadFile(candidateDLLfilepath);

			// chech if the payload was executed successfully (if the PoC file was created)
			CHAR what[] = "report";
			CHAR logfilename[11] = "DLLHSC.tmp";
			if (PathFileExistsA(PopulatePoCPath(logfilename)))
			{
				// critical finding
				printf("\t[");
				ColoredText(what, FOREGROUND_RED);
				printf("] PoC file was found.This indicates that if %s is replaced with a payload DLL, the payload gets executed immediately\n", candidateDLLfilepath);
				finding = TRUE;

				// delete the PoC file that was in C:\Users\%USERNAME%\AppData\Local\Temp\DLLHSC.tmp
				if (!DeleteFileA(PopulatePoCPath(logfilename)))
				{
					printf("[-] PoC file delete has failed: %d\n", GetLastError());
					exit(1);
				}
			}
			else if (msgboxpopup)
			{
				// medium finding
			 	printf("\t[");
				ColoredText(what, FOREGROUND_GREEN | FOREGROUND_RED);
				printf("] Message box was popped up, indicating the DLL %s may be replaced and execute the payload upon dependencies are met.\n", candidateDLLfilepath);
				finding = TRUE;
			}
			else
			{
				// not exploitable
				printf("\t[");
				ColoredText(what, FOREGROUND_GREEN);
				printf("] The %s is NOT exploitable.\n", candidateDLLfilepath);
				finding = TRUE;
			}
		}
	}

	if (finding == FALSE)
	{
		printf("[+] No DLL that could be placed in the application directory was found\n");
	}

	return TRUE;
}

int HookLoadLibrary(CHAR* exeimgpath)
{
	// string ASCII to Unicode
	DWORD pathlen = MultiByteToWideChar(CP_UTF8, 0, exeimgpath, -1, NULL, 0);
	WCHAR* exeimgpathW = new WCHAR[pathlen];
	MultiByteToWideChar(CP_UTF8, 0, exeimgpath, -1, exeimgpathW, pathlen);

	DWORD nBufferLength = GetCurrentDirectory(0, NULL);
	WCHAR detourDLLfilename[] = L"\\detour.dll";

	WCHAR* detourDLLPathW = new WCHAR[nBufferLength + wcslen(detourDLLfilename)];
	
	GetCurrentDirectory(nBufferLength + (DWORD)wcslen(detourDLLfilename) + 1, detourDLLPathW);

	StringCchCatW(detourDLLPathW, nBufferLength + wcslen(detourDLLfilename), detourDLLfilename);

	pathlen = WideCharToMultiByte(CP_UTF8, 0, detourDLLPathW, -1, NULL, 0, NULL, NULL);
	CHAR* detourDLLPathA = new CHAR[pathlen];
	WideCharToMultiByte(CP_UTF8, 0, detourDLLPathW, -1, detourDLLPathA, pathlen, NULL, NULL);
	
	STARTUPINFOW lpStartupInfo = { 0 };
	lpStartupInfo.cb = sizeof(STARTUPINFOW);
	// do not show window
	lpStartupInfo.dwFlags = STARTF_USESHOWWINDOW;
	lpStartupInfo.wShowWindow = SW_HIDE;
	PROCESS_INFORMATION lpProcessInformation = { 0 };
	DetourCreateProcessWithDllEx(exeimgpathW, NULL, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &lpStartupInfo, &lpProcessInformation, detourDLLPathA, NULL);

	Sleep(1000);
	TerminateProcess(lpProcessInformation.hProcess, 0);
	// wait for the process to terminate
	WaitForSingleObject(lpProcessInformation.hProcess, INFINITE);

	// print Run-Time loaded modules
	CHAR* pBuffer = 0;
	CHAR logfilename[] = "DLLHSCRTLOG.tmp";
	pBuffer = LoadFileMemory(PopulatePoCPath(logfilename));

	printf("[+] The application is loading in run-time the following modules:\n\n");
	printf("%s", pBuffer);

	// delete the DLLHSCRTLOG.tmp
	if (!DeleteFileA(PopulatePoCPath(logfilename)))
	{
		printf("[-] Delete DLLHSCRTLOG.tmp has failed: %d. Exiting...\n", GetLastError());
		return 1;
	}

	return 0;
}

// main
INT main(INT argc, PCHAR argv[])
{
	// elevation error message
	if (!CheckElevatePrivilege())
	{
		printf("[!] Process has to be started elevated. Exiting...\n");
		return -1;
	}

	if (argc < 2)
	{
		::printf("[-] Not enough arguments sepcified\n");
		return -1;
	}

	printf("[+] Application has started\n");

	// parse flags
	PCHAR exeimgpath = NULL;
	BOOL EXEset = FALSE;
	BOOL listmodules = FALSE;
	BOOL lightweight = FALSE;
	BOOL runtime = FALSE;
	DWORD timeout = 10 * 1000;

	WORD i = 1;
	for (; i < argc; i++)
	{
		std::string input = argv[i];

		if (!input.compare("-h") || !input.compare("--help"))
		{
			menu();
			return 0;
		}

		if ( !input.compare("-e") || !input.compare("--executable-image") )
		{
			exeimgpath = argv[i + 1];
			EXEset = TRUE;
			if (::GetFileAttributesA(exeimgpath) && ::GetLastError() == ERROR_FILE_NOT_FOUND)
			{
				printf("[-] The provided image does not exist. Please provide an image that exists\n");
				return -1;
			}
			i++;
			continue;
		}

		if ( !input.compare("-l") || !input.compare("--lightweight") )
		{
			lightweight = TRUE;
			continue;
		}

		if ( !input.compare("-lm") || !input.compare("--list-modules") )
		{
			listmodules = TRUE;
			continue;
		}

		if ( !input.compare("-rt") || !input.compare("--runtime-load") )
		{
			runtime = TRUE;
			continue;
		}

		if ( !input.compare("-t") || !input.compare("--timeout") )
		{
			timeout = atoi(argv[i + 1]) * 1000;
			if (timeout <= 5000)
			{
				printf("[-] A timeout >= 6 is required for accurate results. Exiting...\n");
				return -1;
			}
			i++;
			continue;
		}
	}

	if (!EXEset)
	{
		printf("[-] Executable image flag hasn't been specified. Exiting...\n");
		return -1;
	}

	if (lightweight) 
	{
		HijackHunt(exeimgpath, timeout);
	}
	if (listmodules)
	{
		ListModules(exeimgpath);
	}
	if (runtime)
	{
		HookLoadLibrary(exeimgpath);
	}

	printf("[+] Scan has ended");

	return 0;
}
```

`DLLHSC/DLLHSC/DLLHSC.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DLLHSC.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="detours.h" />
    <ClInclude Include="utility.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{F423385A-BA54-419E-BC1D-85C36D5B3357}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>DLLHSC</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <UACExecutionLevel>HighestAvailable</UACExecutionLevel>
      <EnableUAC>false</EnableUAC>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DLLHSC/DLLHSC/DLLHSC.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DLLHSC.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="utility.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="detours.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DLLHSC/DLLHSC/DLLHSC.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>-e C:\Users\test\Desktop\DLLHSC-testEXEs\GoogleCrashHandler.exe -l -t 15</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommandArguments>-e C:\Users\test\Desktop\DLLHSC-testEXEs\GoogleCrashHandler.exe -l -t 15</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LocalDebuggerCommandArguments>-e C:\Users\test\Desktop\DLLHSC-testEXEs\GoogleCrashHandler.exe -l -t 15</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerCommandArguments>-e C:\Users\test\Desktop\DLLHSC-testEXEs\GoogleCrashHandler.exe -l -t 15</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`DLLHSC/DLLHSC/detours.h`:

```h
/////////////////////////////////////////////////////////////////////////////
//
//  Core Detours Functionality (detours.h of detours.lib)
//
//  Microsoft Research Detours Package, Version 4.0.1
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

#define DETOURS_VERSION     0x4c0c1   // 0xMAJORcMINORcPATCH

//////////////////////////////////////////////////////////////////////////////
//

#undef DETOURS_X64
#undef DETOURS_X86
#undef DETOURS_IA64
#undef DETOURS_ARM
#undef DETOURS_ARM64
#undef DETOURS_BITS
#undef DETOURS_32BIT
#undef DETOURS_64BIT

#if defined(_X86_)
#define DETOURS_X86
#define DETOURS_OPTION_BITS 64

#elif defined(_AMD64_)
#define DETOURS_X64
#define DETOURS_OPTION_BITS 32

#elif defined(_IA64_)
#define DETOURS_IA64
#define DETOURS_OPTION_BITS 32

#elif defined(_ARM_)
#define DETOURS_ARM

#elif defined(_ARM64_)
#define DETOURS_ARM64

#else
#error Unknown architecture (x86, amd64, ia64, arm, arm64)
#endif

#ifdef _WIN64
#undef DETOURS_32BIT
#define DETOURS_64BIT 1
#define DETOURS_BITS 64
// If all 64bit kernels can run one and only one 32bit architecture.
//#define DETOURS_OPTION_BITS 32
#else
#define DETOURS_32BIT 1
#undef DETOURS_64BIT
#define DETOURS_BITS 32
// If all 64bit kernels can run one and only one 32bit architecture.
//#define DETOURS_OPTION_BITS 32
#endif

#define VER_DETOURS_BITS    DETOUR_STRINGIFY(DETOURS_BITS)

//////////////////////////////////////////////////////////////////////////////
//

#if (_MSC_VER < 1299)
typedef LONG LONG_PTR;
typedef ULONG ULONG_PTR;
#endif

///////////////////////////////////////////////// SAL 2.0 Annotations w/o SAL.
//
//  These definitions are include so that Detours will build even if the
//  compiler doesn't have full SAL 2.0 support.
//
#ifndef DETOURS_DONT_REMOVE_SAL_20

#ifdef DETOURS_TEST_REMOVE_SAL_20
#undef _Analysis_assume_
#undef _Benign_race_begin_
#undef _Benign_race_end_
#undef _Field_range_
#undef _Field_size_
#undef _In_
#undef _In_bytecount_
#undef _In_count_
#undef _In_opt_
#undef _In_opt_bytecount_
#undef _In_opt_count_
#undef _In_opt_z_
#undef _In_range_
#undef _In_reads_
#undef _In_reads_bytes_
#undef _In_reads_opt_
#undef _In_reads_opt_bytes_
#undef _In_reads_or_z_
#undef _In_z_
#undef _Inout_
#undef _Inout_opt_
#undef _Inout_z_count_
#undef _Out_
#undef _Out_opt_
#undef _Out_writes_
#undef _Outptr_result_maybenull_
#undef _Readable_bytes_
#undef _Success_
#undef _Writable_bytes_
#undef _Pre_notnull_
#endif

#if defined(_Deref_out_opt_z_) && !defined(_Outptr_result_maybenull_)
#define _Outptr_result_maybenull_ _Deref_out_opt_z_
#endif

#if defined(_In_count_) && !defined(_In_reads_)
#define _In_reads_(x) _In_count_(x)
#endif

#if defined(_In_opt_count_) && !defined(_In_reads_opt_)
#define _In_reads_opt_(x) _In_opt_count_(x)
#endif

#if defined(_In_opt_bytecount_) && !defined(_In_reads_opt_bytes_)
#define _In_reads_opt_bytes_(x) _In_opt_bytecount_(x)
#endif

#if defined(_In_bytecount_) && !defined(_In_reads_bytes_)
#define _In_reads_bytes_(x) _In_bytecount_(x)
#endif

#ifndef _In_
#define _In_
#endif

#ifndef _In_bytecount_
#define _In_bytecount_(x)
#endif

#ifndef _In_count_
#define _In_count_(x)
#endif

#ifndef _In_opt_
#define _In_opt_
#endif

#ifndef _In_opt_bytecount_
#define _In_opt_bytecount_(x)
#endif

#ifndef _In_opt_count_
#define _In_opt_count_(x)
#endif

#ifndef _In_opt_z_
#define _In_opt_z_
#endif

#ifndef _In_range_
#define _In_range_(x,y)
#endif

#ifndef _In_reads_
#define _In_reads_(x)
#endif

#ifndef _In_reads_bytes_
#define _In_reads_bytes_(x)
#endif

#ifndef _In_reads_opt_
#define _In_reads_opt_(x)
#endif

#ifndef _In_reads_opt_bytes_
#define _In_reads_opt_bytes_(x)
#endif

#ifndef _In_reads_or_z_
#define _In_reads_or_z_
#endif

#ifndef _In_z_
#define _In_z_
#endif

#ifndef _Inout_
#define _Inout_
#endif

#ifndef _Inout_opt_
#define _Inout_opt_
#endif

#ifndef _Inout_z_count_
#define _Inout_z_count_(x)
#endif

#ifndef _Out_
#define _Out_
#endif

#ifndef _Out_opt_
#define _Out_opt_
#endif

#ifndef _Out_writes_
#define _Out_writes_(x)
#endif

#ifndef _Outptr_result_maybenull_
#define _Outptr_result_maybenull_
#endif

#ifndef _Writable_bytes_
#define _Writable_bytes_(x)
#endif

#ifndef _Readable_bytes_
#define _Readable_bytes_(x)
#endif

#ifndef _Success_
#define _Success_(x)
#endif

#ifndef _Pre_notnull_
#define _Pre_notnull_
#endif

#ifdef DETOURS_INTERNAL

#pragma warning(disable:4615) // unknown warning type (suppress with older compilers)

#ifndef _Benign_race_begin_
#define _Benign_race_begin_
#endif

#ifndef _Benign_race_end_
#define _Benign_race_end_
#endif

#ifndef _Field_size_
#define _Field_size_(x)
#endif

#ifndef _Field_range_
#define _Field_range_(x,y)
#endif

#ifndef _Analysis_assume_
#define _Analysis_assume_(x)
#endif

#endif // DETOURS_INTERNAL
#endif // DETOURS_DONT_REMOVE_SAL_20

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;

#ifdef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    const GUID name
#endif // INITGUID
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PVOID)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PVOID)(LONG_PTR)-1)
#define DETOUR_SECTION_HEADER_SIGNATURE         0x00727444   // "Dtr\0"

extern const GUID DETOUR_EXE_RESTORE_GUID;
extern const GUID DETOUR_EXE_HELPER_GUID;

#define DETOUR_TRAMPOLINE_SIGNATURE             0x21727444  // Dtr!
typedef struct _DETOUR_TRAMPOLINE DETOUR_TRAMPOLINE, *PDETOUR_TRAMPOLINE;

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;

    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;

    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       cbPrePE;

    DWORD       nOriginalClrFlags;
    DWORD       reserved1;
    DWORD       reserved2;
    DWORD       reserved3;

    // Followed by cbPrePE bytes of data.
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;

typedef struct _DETOUR_CLR_HEADER
{
    // Header versioning
    ULONG                   cb;
    USHORT                  MajorRuntimeVersion;
    USHORT                  MinorRuntimeVersion;

    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY    MetaData;
    ULONG                   Flags;

    // Followed by the rest of the IMAGE_COR20_HEADER
} DETOUR_CLR_HEADER, *PDETOUR_CLR_HEADER;

typedef struct _DETOUR_EXE_RESTORE
{
    DWORD               cb;
    DWORD               cbidh;
    DWORD               cbinh;
    DWORD               cbclr;

    PBYTE               pidh;
    PBYTE               pinh;
    PBYTE               pclr;

    IMAGE_DOS_HEADER    idh;
    union {
        IMAGE_NT_HEADERS    inh;
        IMAGE_NT_HEADERS32  inh32;
        IMAGE_NT_HEADERS64  inh64;
        BYTE                raw[sizeof(IMAGE_NT_HEADERS64) +
                                sizeof(IMAGE_SECTION_HEADER) * 32];
    };
    DETOUR_CLR_HEADER   clr;

} DETOUR_EXE_RESTORE, *PDETOUR_EXE_RESTORE;

typedef struct _DETOUR_EXE_HELPER
{
    DWORD               cb;
    DWORD               pid;
    DWORD               nDlls;
    CHAR                rDlls[4];
} DETOUR_EXE_HELPER, *PDETOUR_EXE_HELPER;

#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

/////////////////////////////////////////////////////////////// Helper Macros.
//
#define DETOURS_STRINGIFY(x)    DETOURS_STRINGIFY_(x)
#define DETOURS_STRINGIFY_(x)    #x

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(
    _In_opt_ PVOID pContext,
    _In_opt_ LPCSTR pszFile,
    _Outptr_result_maybenull_ LPCSTR *ppszOutFile);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(
    _In_opt_ PVOID pContext,
    _In_ LPCSTR pszOrigFile,
    _In_ LPCSTR pszFile,
    _Outptr_result_maybenull_ LPCSTR *ppszOutFile);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(
    _In_opt_ PVOID pContext,
    _In_ ULONG nOrigOrdinal,
    _In_ ULONG nOrdinal,
    _Out_ ULONG *pnOutOrdinal,
    _In_opt_ LPCSTR pszOrigSymbol,
    _In_opt_ LPCSTR pszSymbol,
    _Outptr_result_maybenull_ LPCSTR *ppszOutSymbol);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_COMMIT_CALLBACK)(
    _In_opt_ PVOID pContext);

typedef BOOL (CALLBACK *PF_DETOUR_ENUMERATE_EXPORT_CALLBACK)(_In_opt_ PVOID pContext,
                                                             _In_ ULONG nOrdinal,
                                                             _In_opt_ LPCSTR pszName,
                                                             _In_opt_ PVOID pCode);

typedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FILE_CALLBACK)(_In_opt_ PVOID pContext,
                                                        _In_opt_ HMODULE hModule,
                                                        _In_opt_ LPCSTR pszFile);

typedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FUNC_CALLBACK)(_In_opt_ PVOID pContext,
                                                        _In_ DWORD nOrdinal,
                                                        _In_opt_ LPCSTR pszFunc,
                                                        _In_opt_ PVOID pvFunc);

// Same as PF_DETOUR_IMPORT_FUNC_CALLBACK but extra indirection on last parameter.
typedef BOOL (CALLBACK *PF_DETOUR_IMPORT_FUNC_CALLBACK_EX)(_In_opt_ PVOID pContext,
                                                           _In_ DWORD nOrdinal,
                                                           _In_opt_ LPCSTR pszFunc,
                                                           _In_opt_ PVOID* ppvFunc);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////////// Transaction APIs.
//
LONG WINAPI DetourTransactionBegin(VOID);
LONG WINAPI DetourTransactionAbort(VOID);
LONG WINAPI DetourTransactionCommit(VOID);
LONG WINAPI DetourTransactionCommitEx(_Out_opt_ PVOID **pppFailedPointer);

LONG WINAPI DetourUpdateThread(_In_ HANDLE hThread);

LONG WINAPI DetourAttach(_Inout_ PVOID *ppPointer,
                         _In_ PVOID pDetour);

LONG WINAPI DetourAttachEx(_Inout_ PVOID *ppPointer,
                           _In_ PVOID pDetour,
                           _Out_opt_ PDETOUR_TRAMPOLINE *ppRealTrampoline,
                           _Out_opt_ PVOID *ppRealTarget,
                           _Out_opt_ PVOID *ppRealDetour);

LONG WINAPI DetourDetach(_Inout_ PVOID *ppPointer,
                         _In_ PVOID pDetour);

BOOL WINAPI DetourSetIgnoreTooSmall(_In_ BOOL fIgnore);
BOOL WINAPI DetourSetRetainRegions(_In_ BOOL fRetain);
PVOID WINAPI DetourSetSystemRegionLowerBound(_In_ PVOID pSystemRegionLowerBound);
PVOID WINAPI DetourSetSystemRegionUpperBound(_In_ PVOID pSystemRegionUpperBound);

////////////////////////////////////////////////////////////// Code Functions.
//
PVOID WINAPI DetourFindFunction(_In_ LPCSTR pszModule,
                                _In_ LPCSTR pszFunction);
PVOID WINAPI DetourCodeFromPointer(_In_ PVOID pPointer,
                                   _Out_opt_ PVOID *ppGlobals);
PVOID WINAPI DetourCopyInstruction(_In_opt_ PVOID pDst,
                                   _Inout_opt_ PVOID *ppDstPool,
                                   _In_ PVOID pSrc,
                                   _Out_opt_ PVOID *ppTarget,
                                   _Out_opt_ LONG *plExtra);
BOOL WINAPI DetourSetCodeModule(_In_ HMODULE hModule,
                                _In_ BOOL fLimitReferencesToModule);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HMODULE WINAPI DetourGetContainingModule(_In_ PVOID pvAddr);
HMODULE WINAPI DetourEnumerateModules(_In_opt_ HMODULE hModuleLast);
PVOID WINAPI DetourGetEntryPoint(_In_opt_ HMODULE hModule);
ULONG WINAPI DetourGetModuleSize(_In_opt_ HMODULE hModule);
BOOL WINAPI DetourEnumerateExports(_In_ HMODULE hModule,
                                   _In_opt_ PVOID pContext,
                                   _In_ PF_DETOUR_ENUMERATE_EXPORT_CALLBACK pfExport);
BOOL WINAPI DetourEnumerateImports(_In_opt_ HMODULE hModule,
                                   _In_opt_ PVOID pContext,
                                   _In_opt_ PF_DETOUR_IMPORT_FILE_CALLBACK pfImportFile,
                                   _In_opt_ PF_DETOUR_IMPORT_FUNC_CALLBACK pfImportFunc);

BOOL WINAPI DetourEnumerateImportsEx(_In_opt_ HMODULE hModule,
                                     _In_opt_ PVOID pContext,
                                     _In_opt_ PF_DETOUR_IMPORT_FILE_CALLBACK pfImportFile,
                                     _In_opt_ PF_DETOUR_IMPORT_FUNC_CALLBACK_EX pfImportFuncEx);

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourFindPayload(_In_opt_ HMODULE hModule,
                               _In_ REFGUID rguid,
                               _Out_ DWORD *pcbData);

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourFindPayloadEx(_In_ REFGUID rguid,
                                 _Out_ DWORD * pcbData);

DWORD WINAPI DetourGetSizeOfPayloads(_In_opt_ HMODULE hModule);

///////////////////////////////////////////////// Persistent Binary Functions.
//

PDETOUR_BINARY WINAPI DetourBinaryOpen(_In_ HANDLE hFile);

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourBinaryEnumeratePayloads(_In_ PDETOUR_BINARY pBinary,
                                           _Out_opt_ GUID *pGuid,
                                           _Out_ DWORD *pcbData,
                                           _Inout_ DWORD *pnIterator);

_Writable_bytes_(*pcbData)
_Readable_bytes_(*pcbData)
_Success_(return != NULL)
PVOID WINAPI DetourBinaryFindPayload(_In_ PDETOUR_BINARY pBinary,
                                     _In_ REFGUID rguid,
                                     _Out_ DWORD *pcbData);

PVOID WINAPI DetourBinarySetPayload(_In_ PDETOUR_BINARY pBinary,
                                    _In_ REFGUID rguid,
                                    _In_reads_opt_(cbData) PVOID pData,
                                    _In_ DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(_In_ PDETOUR_BINARY pBinary, _In_ REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayloads(_In_ PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(_In_ PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(_In_ PDETOUR_BINARY pBinary,
                                    _In_opt_ PVOID pContext,
                                    _In_opt_ PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    _In_opt_ PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    _In_opt_ PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    _In_opt_ PF_DETOUR_BINARY_COMMIT_CALLBACK pfCommit);
BOOL WINAPI DetourBinaryWrite(_In_ PDETOUR_BINARY pBinary, _In_ HANDLE hFile);
BOOL WINAPI DetourBinaryClose(_In_ PDETOUR_BINARY pBinary);

/////////////////////////////////////////////////// Create Process & Load Dll.
//
typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)(
    _In_opt_ LPCSTR lpApplicationName,
    _Inout_opt_ LPSTR lpCommandLine,
    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
    _In_ BOOL bInheritHandles,
    _In_ DWORD dwCreationFlags,
    _In_opt_ LPVOID lpEnvironment,
    _In_opt_ LPCSTR lpCurrentDirectory,
    _In_ LPSTARTUPINFOA lpStartupInfo,
    _Out_ LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)(
    _In_opt_ LPCWSTR lpApplicationName,
    _Inout_opt_ LPWSTR lpCommandLine,
    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
    _In_ BOOL bInheritHandles,
    _In_ DWORD dwCreationFlags,
    _In_opt_ LPVOID lpEnvironment,
    _In_opt_ LPCWSTR lpCurrentDirectory,
    _In_ LPSTARTUPINFOW lpStartupInfo,
    _Out_ LPPROCESS_INFORMATION lpProcessInformation);

BOOL WINAPI DetourCreateProcessWithDllA(_In_opt_ LPCSTR lpApplicationName,
                                        _Inout_opt_ LPSTR lpCommandLine,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        _In_ BOOL bInheritHandles,
                                        _In_ DWORD dwCreationFlags,
                                        _In_opt_ LPVOID lpEnvironment,
                                        _In_opt_ LPCSTR lpCurrentDirectory,
                                        _In_ LPSTARTUPINFOA lpStartupInfo,
                                        _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                        _In_ LPCSTR lpDllName,
                                        _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllW(_In_opt_ LPCWSTR lpApplicationName,
                                        _Inout_opt_ LPWSTR lpCommandLine,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        _In_ BOOL bInheritHandles,
                                        _In_ DWORD dwCreationFlags,
                                        _In_opt_ LPVOID lpEnvironment,
                                        _In_opt_ LPCWSTR lpCurrentDirectory,
                                        _In_ LPSTARTUPINFOW lpStartupInfo,
                                        _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                        _In_ LPCSTR lpDllName,
                                        _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourCreateProcessWithDll      DetourCreateProcessWithDllW
#define PDETOUR_CREATE_PROCESS_ROUTINE  PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDll      DetourCreateProcessWithDllA
#define PDETOUR_CREATE_PROCESS_ROUTINE  PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourCreateProcessWithDllExA(_In_opt_ LPCSTR lpApplicationName,
                                          _Inout_opt_ LPSTR lpCommandLine,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                          _In_ BOOL bInheritHandles,
                                          _In_ DWORD dwCreationFlags,
                                          _In_opt_ LPVOID lpEnvironment,
                                          _In_opt_ LPCSTR lpCurrentDirectory,
                                          _In_ LPSTARTUPINFOA lpStartupInfo,
                                          _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                          _In_ LPCSTR lpDllName,
                                          _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllExW(_In_opt_ LPCWSTR lpApplicationName,
                                          _Inout_opt_  LPWSTR lpCommandLine,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                          _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                          _In_ BOOL bInheritHandles,
                                          _In_ DWORD dwCreationFlags,
                                          _In_opt_ LPVOID lpEnvironment,
                                          _In_opt_ LPCWSTR lpCurrentDirectory,
                                          _In_ LPSTARTUPINFOW lpStartupInfo,
                                          _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                          _In_ LPCSTR lpDllName,
                                          _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourCreateProcessWithDllEx    DetourCreateProcessWithDllExW
#else
#define DetourCreateProcessWithDllEx    DetourCreateProcessWithDllExA
#endif // !UNICODE

BOOL WINAPI DetourCreateProcessWithDllsA(_In_opt_ LPCSTR lpApplicationName,
                                         _Inout_opt_ LPSTR lpCommandLine,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                         _In_ BOOL bInheritHandles,
                                         _In_ DWORD dwCreationFlags,
                                         _In_opt_ LPVOID lpEnvironment,
                                         _In_opt_ LPCSTR lpCurrentDirectory,
                                         _In_ LPSTARTUPINFOA lpStartupInfo,
                                         _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                         _In_ DWORD nDlls,
                                         _In_reads_(nDlls) LPCSTR *rlpDlls,
                                         _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllsW(_In_opt_ LPCWSTR lpApplicationName,
                                         _Inout_opt_ LPWSTR lpCommandLine,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                         _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                         _In_ BOOL bInheritHandles,
                                         _In_ DWORD dwCreationFlags,
                                         _In_opt_ LPVOID lpEnvironment,
                                         _In_opt_ LPCWSTR lpCurrentDirectory,
                                         _In_ LPSTARTUPINFOW lpStartupInfo,
                                         _Out_ LPPROCESS_INFORMATION lpProcessInformation,
                                         _In_ DWORD nDlls,
                                         _In_reads_(nDlls) LPCSTR *rlpDlls,
                                         _In_opt_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourCreateProcessWithDlls     DetourCreateProcessWithDllsW
#else
#define DetourCreateProcessWithDlls     DetourCreateProcessWithDllsA
#endif // !UNICODE

BOOL WINAPI DetourProcessViaHelperA(_In_ DWORD dwTargetPid,
                                    _In_ LPCSTR lpDllName,
                                    _In_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourProcessViaHelperW(_In_ DWORD dwTargetPid,
                                    _In_ LPCSTR lpDllName,
                                    _In_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourProcessViaHelper          DetourProcessViaHelperW
#else
#define DetourProcessViaHelper          DetourProcessViaHelperA
#endif // !UNICODE

BOOL WINAPI DetourProcessViaHelperDllsA(_In_ DWORD dwTargetPid,
                                        _In_ DWORD nDlls,
                                        _In_reads_(nDlls) LPCSTR *rlpDlls,
                                        _In_ PDETOUR_CREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI DetourProcessViaHelperDllsW(_In_ DWORD dwTargetPid,
                                        _In_ DWORD nDlls,
                                        _In_reads_(nDlls) LPCSTR *rlpDlls,
                                        _In_ PDETOUR_CREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define DetourProcessViaHelperDlls      DetourProcessViaHelperDllsW
#else
#define DetourProcessViaHelperDlls      DetourProcessViaHelperDllsA
#endif // !UNICODE

BOOL WINAPI DetourUpdateProcessWithDll(_In_ HANDLE hProcess,
                                       _In_reads_(nDlls) LPCSTR *rlpDlls,
                                       _In_ DWORD nDlls);

BOOL WINAPI DetourUpdateProcessWithDllEx(_In_ HANDLE hProcess,
                                         _In_ HMODULE hImage,
                                         _In_ BOOL bIs32Bit,
                                         _In_reads_(nDlls) LPCSTR *rlpDlls,
                                         _In_ DWORD nDlls);

BOOL WINAPI DetourCopyPayloadToProcess(_In_ HANDLE hProcess,
                                       _In_ REFGUID rguid,
                                       _In_reads_bytes_(cbData) PVOID pvData,
                                       _In_ DWORD cbData);
BOOL WINAPI DetourRestoreAfterWith(VOID);
BOOL WINAPI DetourRestoreAfterWithEx(_In_reads_bytes_(cbData) PVOID pvData,
                                     _In_ DWORD cbData);
BOOL WINAPI DetourIsHelperProcess(VOID);
VOID CALLBACK DetourFinishHelperProcess(_In_ HWND,
                                        _In_ HINSTANCE,
                                        _In_ LPSTR,
                                        _In_ INT);

//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus

//////////////////////////////////////////////// Detours Internal Definitions.
//
#ifdef __cplusplus
#ifdef DETOURS_INTERNAL

#define NOTHROW
// #define NOTHROW (nothrow)

//////////////////////////////////////////////////////////////////////////////
//
#if (_MSC_VER < 1299)
#include <imagehlp.h>
typedef IMAGEHLP_MODULE IMAGEHLP_MODULE64;
typedef PIMAGEHLP_MODULE PIMAGEHLP_MODULE64;
typedef IMAGEHLP_SYMBOL SYMBOL_INFO;
typedef PIMAGEHLP_SYMBOL PSYMBOL_INFO;

static inline
LONG InterlockedCompareExchange(_Inout_ LONG *ptr, _In_ LONG nval, _In_ LONG oval)
{
    return (LONG)::InterlockedCompareExchange((PVOID*)ptr, (PVOID)nval, (PVOID)oval);
}
#else
#pragma warning(push)
#pragma warning(disable:4091) // empty typedef
#include <dbghelp.h>
#pragma warning(pop)
#endif

#ifdef IMAGEAPI // defined by DBGHELP.H
typedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(_In_ LPAPI_VERSION AppVersion);

typedef BOOL (NTAPI *PF_SymInitialize)(_In_ HANDLE hProcess,
                                       _In_opt_ LPCSTR UserSearchPath,
                                       _In_ BOOL fInvadeProcess);
typedef DWORD (NTAPI *PF_SymSetOptions)(_In_ DWORD SymOptions);
typedef DWORD (NTAPI *PF_SymGetOptions)(VOID);
typedef DWORD64 (NTAPI *PF_SymLoadModule64)(_In_ HANDLE hProcess,
                                            _In_opt_ HANDLE hFile,
                                            _In_ LPSTR ImageName,
                                            _In_opt_ LPSTR ModuleName,
                                            _In_ DWORD64 BaseOfDll,
                                            _In_opt_ DWORD SizeOfDll);
typedef BOOL (NTAPI *PF_SymGetModuleInfo64)(_In_ HANDLE hProcess,
                                            _In_ DWORD64 qwAddr,
                                            _Out_ PIMAGEHLP_MODULE64 ModuleInfo);
typedef BOOL (NTAPI *PF_SymFromName)(_In_ HANDLE hProcess,
                                     _In_ LPSTR Name,
                                     _Out_ PSYMBOL_INFO Symbol);

typedef struct _DETOUR_SYM_INFO
{
    HANDLE                  hProcess;
    HMODULE                 hDbgHelp;
    PF_ImagehlpApiVersionEx pfImagehlpApiVersionEx;
    PF_SymInitialize        pfSymInitialize;
    PF_SymSetOptions        pfSymSetOptions;
    PF_SymGetOptions        pfSymGetOptions;
    PF_SymLoadModule64      pfSymLoadModule64;
    PF_SymGetModuleInfo64   pfSymGetModuleInfo64;
    PF_SymFromName          pfSymFromName;
} DETOUR_SYM_INFO, *PDETOUR_SYM_INFO;

PDETOUR_SYM_INFO DetourLoadImageHlp(VOID);

#endif // IMAGEAPI

#if defined(_INC_STDIO) && !defined(_CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS)
#error detours.h must be included before stdio.h (or at least define _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS earlier)
#endif
#define _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS 1

#ifndef DETOUR_TRACE
#if DETOUR_DEBUG
#define DETOUR_TRACE(x) printf x
#define DETOUR_BREAK()  __debugbreak()
#include <stdio.h>
#include <limits.h>
#else
#define DETOUR_TRACE(x)
#define DETOUR_BREAK()
#endif
#endif

#if 1 || defined(DETOURS_IA64)

//
// IA64 instructions are 41 bits, 3 per bundle, plus 5 bit bundle template => 128 bits per bundle.
//

#define DETOUR_IA64_INSTRUCTIONS_PER_BUNDLE (3)

#define DETOUR_IA64_TEMPLATE_OFFSET (0)
#define DETOUR_IA64_TEMPLATE_SIZE   (5)

#define DETOUR_IA64_INSTRUCTION_SIZE (41)
#define DETOUR_IA64_INSTRUCTION0_OFFSET (DETOUR_IA64_TEMPLATE_SIZE)
#define DETOUR_IA64_INSTRUCTION1_OFFSET (DETOUR_IA64_TEMPLATE_SIZE + DETOUR_IA64_INSTRUCTION_SIZE)
#define DETOUR_IA64_INSTRUCTION2_OFFSET (DETOUR_IA64_TEMPLATE_SIZE + DETOUR_IA64_INSTRUCTION_SIZE + DETOUR_IA64_INSTRUCTION_SIZE)

C_ASSERT(DETOUR_IA64_TEMPLATE_SIZE + DETOUR_IA64_INSTRUCTIONS_PER_BUNDLE * DETOUR_IA64_INSTRUCTION_SIZE == 128);

__declspec(align(16)) struct DETOUR_IA64_BUNDLE
{
  public:
    union
    {
        BYTE    data[16];
        UINT64  wide[2];
    };

    enum {
        A_UNIT  = 1u,
        I_UNIT  = 2u,
        M_UNIT  = 3u,
        B_UNIT  = 4u,
        F_UNIT  = 5u,
        L_UNIT  = 6u,
        X_UNIT  = 7u,
    };
    struct DETOUR_IA64_METADATA
    {
        ULONG       nTemplate       : 8;    // Instruction template.
        ULONG       nUnit0          : 4;    // Unit for slot 0
        ULONG       nUnit1          : 4;    // Unit for slot 1
        ULONG       nUnit2          : 4;    // Unit for slot 2
    };

  protected:
    static const DETOUR_IA64_METADATA s_rceCopyTable[33];

    UINT RelocateBundle(_Inout_ DETOUR_IA64_BUNDLE* pDst, _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra) const;

    bool RelocateInstruction(_Inout_ DETOUR_IA64_BUNDLE* pDst,
                             _In_ BYTE slot,
                             _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra) const;

    // 120 112 104 96 88 80 72 64 56 48 40 32 24 16  8  0
    //  f.  e.  d. c. b. a. 9. 8. 7. 6. 5. 4. 3. 2. 1. 0.

    //                                      00
    // f.e. d.c. b.a. 9.8. 7.6. 5.4. 3.2. 1.0.
    // 0000 0000 0000 0000 0000 0000 0000 001f : Template [4..0]
    // 0000 0000 0000 0000 0000 03ff ffff ffe0 : Zero [ 41..  5]
    // 0000 0000 0000 0000 0000 3c00 0000 0000 : Zero [ 45.. 42]
    // 0000 0000 0007 ffff ffff c000 0000 0000 : One  [ 82.. 46]
    // 0000 0000 0078 0000 0000 0000 0000 0000 : One  [ 86.. 83]
    // 0fff ffff ff80 0000 0000 0000 0000 0000 : Two  [123.. 87]
    // f000 0000 0000 0000 0000 0000 0000 0000 : Two  [127..124]
    BYTE    GetTemplate() const;
    // Get 4 bit opcodes.
    BYTE    GetInst0() const;
    BYTE    GetInst1() const;
    BYTE    GetInst2() const;
    BYTE    GetUnit(BYTE slot) const;
    BYTE    GetUnit0() const;
    BYTE    GetUnit1() const;
    BYTE    GetUnit2() const;
    // Get 37 bit data.
    UINT64  GetData0() const;
    UINT64  GetData1() const;
    UINT64  GetData2() const;

    // Get/set the full 41 bit instructions.
    UINT64  GetInstruction(BYTE slot) const;
    UINT64  GetInstruction0() const;
    UINT64  GetInstruction1() const;
    UINT64  GetInstruction2() const;
    void    SetInstruction(BYTE slot, UINT64 instruction);
    void    SetInstruction0(UINT64 instruction);
    void    SetInstruction1(UINT64 instruction);
    void    SetInstruction2(UINT64 instruction);

    // Get/set bitfields.
    static UINT64 GetBits(UINT64 Value, UINT64 Offset, UINT64 Count);
    static UINT64 SetBits(UINT64 Value, UINT64 Offset, UINT64 Count, UINT64 Field);

    // Get specific read-only fields.
    static UINT64 GetOpcode(UINT64 instruction); // 4bit opcode
    static UINT64 GetX(UINT64 instruction); // 1bit opcode extension
    static UINT64 GetX3(UINT64 instruction); // 3bit opcode extension
    static UINT64 GetX6(UINT64 instruction); // 6bit opcode extension

    // Get/set specific fields.
    static UINT64 GetImm7a(UINT64 instruction);
    static UINT64 SetImm7a(UINT64 instruction, UINT64 imm7a);
    static UINT64 GetImm13c(UINT64 instruction);
    static UINT64 SetImm13c(UINT64 instruction, UINT64 imm13c);
    static UINT64 GetSignBit(UINT64 instruction);
    static UINT64 SetSignBit(UINT64 instruction, UINT64 signBit);
    static UINT64 GetImm20a(UINT64 instruction);
    static UINT64 SetImm20a(UINT64 instruction, UINT64 imm20a);
    static UINT64 GetImm20b(UINT64 instruction);
    static UINT64 SetImm20b(UINT64 instruction, UINT64 imm20b);

    static UINT64 SignExtend(UINT64 Value, UINT64 Offset);

    BOOL    IsMovlGp() const;

    VOID    SetInst(BYTE Slot, BYTE nInst);
    VOID    SetInst0(BYTE nInst);
    VOID    SetInst1(BYTE nInst);
    VOID    SetInst2(BYTE nInst);
    VOID    SetData(BYTE Slot, UINT64 nData);
    VOID    SetData0(UINT64 nData);
    VOID    SetData1(UINT64 nData);
    VOID    SetData2(UINT64 nData);
    BOOL    SetNop(BYTE Slot);
    BOOL    SetNop0();
    BOOL    SetNop1();
    BOOL    SetNop2();

  public:
    BOOL    IsBrl() const;
    VOID    SetBrl();
    VOID    SetBrl(UINT64 target);
    UINT64  GetBrlTarget() const;
    VOID    SetBrlTarget(UINT64 target);
    VOID    SetBrlImm(UINT64 imm);
    UINT64  GetBrlImm() const;

    UINT64  GetMovlGp() const;
    VOID    SetMovlGp(UINT64 gp);

    VOID    SetStop();

    UINT    Copy(_Out_ DETOUR_IA64_BUNDLE *pDst, _Inout_opt_ DETOUR_IA64_BUNDLE* pBundleExtra = NULL) const;
};
#endif // DETOURS_IA64

#ifdef DETOURS_ARM

#define DETOURS_PFUNC_TO_PBYTE(p)  ((PBYTE)(((ULONG_PTR)(p)) & ~(ULONG_PTR)1))
#define DETOURS_PBYTE_TO_PFUNC(p)  ((PBYTE)(((ULONG_PTR)(p)) | (ULONG_PTR)1))

#endif // DETOURS_ARM

//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define DETOUR_OFFLINE_LIBRARY(x)                                       \
PVOID WINAPI DetourCopyInstruction##x(_In_opt_ PVOID pDst,              \
                                      _Inout_opt_ PVOID *ppDstPool,     \
                                      _In_ PVOID pSrc,                  \
                                      _Out_opt_ PVOID *ppTarget,        \
                                      _Out_opt_ LONG *plExtra);         \
                                                                        \
BOOL WINAPI DetourSetCodeModule##x(_In_ HMODULE hModule,                \
                                   _In_ BOOL fLimitReferencesToModule); \

DETOUR_OFFLINE_LIBRARY(X86)
DETOUR_OFFLINE_LIBRARY(X64)
DETOUR_OFFLINE_LIBRARY(ARM)
DETOUR_OFFLINE_LIBRARY(ARM64)
DETOUR_OFFLINE_LIBRARY(IA64)

#undef DETOUR_OFFLINE_LIBRARY

//////////////////////////////////////////////////////////////////////////////
//
// Helpers for manipulating page protection.
//

_Success_(return != FALSE)
BOOL WINAPI DetourVirtualProtectSameExecuteEx(_In_  HANDLE hProcess,
                                              _In_  PVOID pAddress,
                                              _In_  SIZE_T nSize,
                                              _In_  DWORD dwNewProtect,
                                              _Out_ PDWORD pdwOldProtect);

_Success_(return != FALSE)
BOOL WINAPI DetourVirtualProtectSameExecute(_In_  PVOID pAddress,
                                            _In_  SIZE_T nSize,
                                            _In_  DWORD dwNewProtect,
                                            _Out_ PDWORD pdwOldProtect);
#ifdef __cplusplus
}
#endif // __cplusplus

//////////////////////////////////////////////////////////////////////////////

#define MM_ALLOCATION_GRANULARITY 0x10000

//////////////////////////////////////////////////////////////////////////////

#endif // DETOURS_INTERNAL
#endif // __cplusplus

#endif // _DETOURS_H_
//
////////////////////////////////////////////////////////////////  End of File.

```

`DLLHSC/DLLHSC/utility.h`:

```h
#pragma once

CHAR* ConcatString(CHAR* path, CHAR* filename)
{
	size_t len1 = strlen(path);
	size_t len2 = strlen(filename);
	size_t outputlen = len1 + len2 + 1;

	CHAR* output = new CHAR[outputlen];
	strcpy_s(output, outputlen, path);
	strcat_s(output, outputlen, filename);

	return output;
}

CHAR* PopulatePoCPath(CHAR* fname)
{
	// populates and returns the path C:\Users\%USERNAME%\AppData\Local\Temp\DLLHSC.tmp
	CHAR* lpBuffer = new CHAR[MAX_PATH];
	DWORD len = GetTempPathA(MAX_PATH, lpBuffer);

	if (!len)
	{
		printf("[-] GetTempPathA has failed: %d\n", GetLastError());
		exit(1);
	}

	return ConcatString(lpBuffer, fname);
}
```

`DLLHSC/Hooking/Hooking.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{75A41684-E690-488E-8B31-0D33A991DED1}</ProjectGuid>
    <RootNamespace>Hooking</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>detour</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DLLHSC/Hooking/Hooking.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`DLLHSC/Hooking/Hooking.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`DLLHSC/Hooking/main.cpp`:

```cpp
#pragma once
#include <windows.h>
#include <stdio.h>
#include "..\DLLHSC\detours.h"
#include "..\DLLHSC\utility.h"

#ifdef _WIN32
#pragma comment(lib, "..\\DLLHSC\\lib.X86\\detours.lib")
#endif

#ifdef _WIN64
#pragma comment(lib, "..\\DLLHSC\\lib.X64\\detours.lib")
#endif

__declspec(dllexport) VOID CALLBACK DetourFinishHelperProcess() {}

HMODULE(WINAPI* LoadLibraryADelegate)(LPCSTR) = LoadLibraryA;
HMODULE(WINAPI* LoadLibraryExADelegate)(LPCSTR, HANDLE, DWORD) = LoadLibraryExA;
HMODULE(WINAPI* LoadLibraryWDelegate)(LPCWSTR) = LoadLibraryW;
HMODULE(WINAPI* LoadLibraryExWDelegate)(LPCWSTR, HANDLE, DWORD) = LoadLibraryExW;

HANDLE g_hMutex = INVALID_HANDLE_VALUE;
HANDLE g_hFile = INVALID_HANDLE_VALUE;

BOOL CreateRTLog(LPCSTR lpBuffer)
{
	if (g_hFile == INVALID_HANDLE_VALUE)
		return FALSE;

	DWORD dwMove = ::SetFilePointer(g_hFile, 1, NULL, FILE_END);
	if (dwMove == INVALID_SET_FILE_POINTER)
		return FALSE;

	PCHAR tmp = new CHAR[strlen(lpBuffer) + 2];
	::strcpy_s(tmp, strlen(lpBuffer) + 2, lpBuffer);
	::strcat_s(tmp, strlen(lpBuffer) + 2, "\n\0");

	DWORD dwCharWritten = 0;
	BOOL writestatus = ::WriteFile(g_hFile, tmp, (DWORD)strlen(tmp), &dwCharWritten, NULL);
	
	delete[] tmp;
	return writestatus;
}

BOOL CreateRTLogW(LPCWSTR lpBuffer)
{
	DWORD dwPathLen = ::WideCharToMultiByte(CP_UTF8, 0, lpBuffer, -1, NULL, 0, NULL, NULL);
	PCHAR lpBufferA = new CHAR[dwPathLen];
	WideCharToMultiByte(CP_UTF8, 0, lpBuffer, -1, lpBufferA, dwPathLen, NULL, NULL);

	return CreateRTLog(lpBufferA);
}

HMODULE WINAPI HookedLoadLibraryA(LPCSTR lpLibFileName)
{
	DWORD dwWait = ::WaitForSingleObject(g_hMutex, INFINITE);
	if (dwWait == WAIT_OBJECT_0)
	{
		CreateRTLog(lpLibFileName);
		::ReleaseMutex(g_hMutex);
	}
	return LoadLibraryADelegate(lpLibFileName);
}

HMODULE WINAPI HookedLoadLibraryExA(LPCSTR lpFileName, HANDLE hFile, DWORD dwFlags)
{
	DWORD dwWait = ::WaitForSingleObject(g_hMutex, INFINITE);
	if ((dwWait == WAIT_OBJECT_0) && (dwFlags != 0x800))
	{
		CreateRTLog(lpFileName);
		::ReleaseMutex(g_hMutex);
	}
	return LoadLibraryExADelegate(lpFileName, hFile, dwFlags);
}

HMODULE WINAPI HookedLoadLibraryW(LPCWSTR lpLibFileName)
{
	DWORD dwWait = ::WaitForSingleObject(g_hMutex, INFINITE);
	if (dwWait == WAIT_OBJECT_0)
	{
		CreateRTLogW(lpLibFileName);
		::ReleaseMutex(g_hMutex);
	}
	return LoadLibraryWDelegate(lpLibFileName);
}

HMODULE WINAPI HookedLoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
{
	DWORD dwWait = ::WaitForSingleObject(g_hMutex, INFINITE);
	if ((dwWait == WAIT_OBJECT_0) && (dwFlags != 0x800))
	{
		CreateRTLogW(lpLibFileName);
		::ReleaseMutex(g_hMutex);
	}
	return LoadLibraryExWDelegate(lpLibFileName, hFile, dwFlags);
}

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID p)
{
	UNREFERENCED_PARAMETER(hInstance);
	UNREFERENCED_PARAMETER(p);

	switch (dwReason)
	{
	case DLL_PROCESS_ATTACH:
	{
		CHAR logfilename[] = "DLLHSCRTLOG.tmp";
		g_hMutex = ::CreateMutexW(NULL, false, L"SecWrite1234");
		g_hFile = ::CreateFileA(PopulatePoCPath(logfilename), FILE_APPEND_DATA, 0x1, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

		::DetourRestoreAfterWith();
		::DetourTransactionBegin();
		::DetourUpdateThread(GetCurrentThread());
		::DetourAttach(&(PVOID&)LoadLibraryADelegate, HookedLoadLibraryA);
		::DetourAttach(&(PVOID&)LoadLibraryExADelegate, HookedLoadLibraryExA);
		::DetourAttach(&(PVOID&)LoadLibraryWDelegate, HookedLoadLibraryW);
		::DetourAttach(&(PVOID&)LoadLibraryExWDelegate, HookedLoadLibraryExW);

		LONG lError = ::DetourTransactionCommit();
		if (lError != NO_ERROR)
			return FALSE;
		break;
	}
	case DLL_PROCESS_DETACH:
	{
		::DetourRestoreAfterWith();
		::DetourTransactionBegin();
		::DetourUpdateThread(GetCurrentThread());
		::DetourAttach(&(PVOID&)LoadLibraryADelegate, HookedLoadLibraryA);
		::DetourAttach(&(PVOID&)LoadLibraryExADelegate, HookedLoadLibraryExA);
		::DetourAttach(&(PVOID&)LoadLibraryWDelegate, HookedLoadLibraryW);
		::DetourAttach(&(PVOID&)LoadLibraryExWDelegate, HookedLoadLibraryExW);

		LONG lError = ::DetourTransactionCommit();
		if (lError != NO_ERROR)
			return FALSE;
		::CloseHandle(g_hFile);
		break;
	}
	}
	return TRUE;
}
```

`DLLHSC/Payload/Payload.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{853A379A-F397-46D7-AA5A-416423C4A554}</ProjectGuid>
    <RootNamespace>Payload</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>payload</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DLLHSC/Payload/Payload.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`DLLHSC/Payload/Payload.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`DLLHSC/Payload/main.cpp`:

```cpp
#include <windows.h>
#include <stdio.h>

__declspec(dllexport) BOOL __stdcall poc_write()
{
	// create a logfile in user's temp
	// this file will be used as a proof of payload execution

	PCHAR lpBuffer = new CHAR[MAX_PATH];
	if (::GetTempPathA(MAX_PATH, lpBuffer) != 0)
		return FALSE;

	CHAR szLogFilename[11] = "DLLHSC.tmp";
	SIZE_T numberofelements = ::strlen(lpBuffer) + ::strlen(szLogFilename) + 1;
	PCHAR szLogFilePath = new CHAR[numberofelements];
	::strcpy_s(szLogFilePath, numberofelements, lpBuffer);
	::strcat_s(szLogFilePath, numberofelements, szLogFilename);

	HANDLE hFile = ::CreateFileA(
		szLogFilePath,
		GENERIC_ALL,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL,
		CREATE_NEW,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);

	if (hFile == INVALID_HANDLE_VALUE)
		return FALSE;

	::CloseHandle(hFile);
	return TRUE;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
	UNREFERENCED_PARAMETER(hinstDLL);
	UNREFERENCED_PARAMETER(lpReserved);

	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		poc_write();
		break;
	case DLL_THREAD_ATTACH:
	case DLL_PROCESS_DETACH:
	case DLL_THREAD_DETACH:
		break;
	}

	return TRUE;
}

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Context Information Security

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# DLLHSC

DLL Hijack SCanner - A tool to generate leads and automate the discovery of candidates for DLL Search Order Hijacking 

## Index of this page

- [Contents of this repository](#contents-of-this-repository)
- [Modes of operation](#modes-of-operation)
- [Compile and Run Guidance](#compile-and-run-guidance)
- [Help menu](#help-menu)
- [Example Runs](#example-runs)
- [Feedback](#feedback)

## Contents of this repository

This repository hosts the Visual Studio project file for the tool (DLLHSC), the project file for the API hooking functionality (detour), the project file for the payload and last but not least the compiled executables for x86 and x64 architecture (in the release section of this repo). The code was written and compiled with **Visual Studio Community 2019**.

If you choose to compile the tool from source, you will need to compile the projects DLLHSC, detour and payload. The DLLHSC implements the core functionality of this tool. The detour project generates a DLL that is used to hook APIs. And the payload project generates the DLL that is used as a proof of concept to check if the tested executable can load it via search order hijacking. The generated payload has to be placed in the same directory with DLLHSC and detour named *payload32.dll* for x86 and *payload64.dll* for x64 architecture.

## Modes of operation

The tool implements 3 modes of operation which are explained below.

### Lightweight Mode

Loads the executable image in memory, parses the Import table and then
replaces any DLL referred in the Import table with a payload DLL.

The tool places in the application directory only a module (DLL) the is
not present in the application directory, does not belong to WinSxS and
does not belong to the KnownDLLs.

The payload DLL upon execution, creates a file in the following path:
`C:\Users\%USERNAME%\AppData\Local\Temp\DLLHSC.tmp` as a proof of
execution. The tool launches the application and reports if the payload
DLL was executed by checking if the temporary file exists. As some
executables import functions from the DLLs they load, error message
boxes may be shown up when the provided DLL fails to export these
functions and thus meet the dependencies of the provided image. However,
the message boxes indicate the DLL may be a good candidate for payload
execution if the dependencies are met. In this case, additional analysis
is required. The title of these message boxes may contain the strings:
`Ordinal Not Found` or `Entry Point Not Found`. DLLHSC looks for windows
that contain these strings, closes them as soon as they shown up and
reports the results.

### List Modules Mode

Creates a process with the provided executable image, enumerates the
modules that are loaded in the address space of this process and reports
the results after applying filters.

The tool only reports the modules loaded from the System directory and do
not belong to the KnownDLLs. The results are leads that require additional
analysis. The analyst can then place the reported modules in the application
directory and check if the application loads the provided module instead.

### Run-Time Mode

Hooks the LoadLibrary and LoadLibraryEx APIs via [Microsoft
Detours](https://github.com/microsoft/Detours) and reports the modules
that are loaded in run-time.

Each time the scanned application calls LoadLibrary and LoadLibraryEx,
the tool intercepts the call and writes the requested module in the file
`C:\Users\%USERNAME%\AppData\Local\Temp\DLLHSCRTLOG.tmp`. If the
LoadLibraryEx is specifically called with the flag
LOAD_LIBRARY_SEARCH_SYSTEM32, no output is written to the file. After
all interceptions have finished, the tool reads the file and prints the
results. Of interest for further analysis are modules that do not exist
in the KnownDLLs registry key, modules that do not exist in the System
directory and modules with no full path (for these modules loader
applies the normal search order).

## Compile and Run Guidance

Should you choose to compile the tool from source it is recommended to do so on Visual Code Studio 2019. In order the tool to function properly, the projects *DLLHSC*, *detour* and *payload* have to be compiled for the same architecture and then placed in the same directory. Please note that the DLL generated from the project *payload* has to be renamed to *payload32.dll* for 32-bit architecture or *payload64.dll* for 64-bit architecture. 

## Help menu

The help menu for this application

```
NAME
        dllhsc - DLL Hijack SCanner

SYNOPSIS
        dllhsc.exe -h

        dllhsc.exe -e <executable image path> (-l|-lm|-rt) [-t seconds]

DESCRIPTION
        DLLHSC scans a given executable image for DLL Hijacking and reports the results

        It requires elevated privileges

OPTIONS
        -h, --help
                display this help menu and exit

        -e, --executable-image
                executable image to scan

        -l, --lightweight
                parse the import table, attempt to launch a payload and report the results

        -lm, --list-modules
                list loaded modules that do not exist in the application's directory

        -rt, --runtime-load
                display modules loaded in run-time by hooking LoadLibrary and LoadLibraryEx APIs

        -t, --timeout
                number of seconds to wait for checking any popup error windows - defaults to 10 seconds

```

## Example Runs

This section provides examples on how you can run DLLHSC and the results it reports. For this purpose, the legitimate Microsoft utility *OleView.exe* (MD5: D1E6767900C85535F300E08D76AAC9AB) was used. For better results, it is recommended that the provided executable image is scanned within its installation directory.

The flag `-l` parses the import table of the provided executable, applies filters and attempts to weaponize the imported modules by placing a payload DLL in the application's current directory. The scanned executable may pop an error box when dependencies for the payload DLL (exported functions) are not met. In this case, an error message box is poped. DLLHSC by default checks for 10 seconds if a message box was opened or for as many seconds as specified by the user with the flag `-t`. An error message box indicates that if dependencies are met, the module can be weaponized.

The following screenshot shows the error message box generated when `OleView.dll` loads the payload DLL :

![dependency](screenshots/dependency.PNG)

The tool waits for a maximum timeframe of 10 seconds or `-t` seconds to make sure the process initialization has finished and any message box has been generated. It then detects the message box, closes it and reports the result:

![imported_modules](screenshots/dllhsc-l.PNG)

The flag `-lm` launches the provided executable and prints the modules it loads that do not belong in the KnownDLLs list neither are WinSxS dependencies. This mode is aimed to give an idea of DLLs that may be used as payload and it only exists to generate leads for the analyst.

![loaded_modules](screenshots/dllhsc-lm.PNG)

The flag `-rt` prints the modules the provided executable image loads in its address space when launched as a process. This is achieved by hooking the *LoadLibrary* and *LoadLibraryEx* APIs via Microsoft Detours.

![runtime_loaded_modules](screenshots/dllhsc-rt.PNG)

## Feedback

For any feedback on this tool, please use the GitHub Issues section.

```

`screenshots/README.md`:

```md
This directory contains screenshots for the main README

```