Project Path: arc_gmh5225_BattleFN-cheat-analysis_9sywlbgd

Source Tree:

```txt
arc_gmh5225_BattleFN-cheat-analysis_9sywlbgd
├── README.md
├── cheat modules
│   ├── BattleFN_external.exe
│   ├── BattleFN_loader.exe
│   ├── BattleFN_unprotected.exe
│   ├── DLLVMhk.dll
│   ├── mapped_driver.sys
│   ├── mapper_driver.sys
│   └── vmdrv.sys
├── cheat-analysis.pdf
├── easy-kernelmapper
│   └── mmap_driver.bat
└── easy-rw-PoC
    ├── driver_loader.cpp
    ├── driver_loader.h
    ├── easy-rw.vcxproj
    └── main.cpp

```

`README.md`:

```md
# A Formal Analysis of The Average (Detected) Fortnite Cheat

[Click here for read the analysis](https://github.com/0dayatday0/BattleFN-cheat-analysis/blob/main/cheat-analysis.pdf) 

Average Fortnite cheat paster trying to save his ass in front of his scammed clients:
![MrXiaoBullshit](https://cdn.discordapp.com/attachments/867531432179007488/906216104689541150/unknown.png)

# Use the stupidness of a paster in your favour!

# easy-kernelmapper - Manual map your driver with a batch using a valid signed driver

The cheat pseudo-developer was so dumb to sign a driver with a valid certificate that manual map any driver present in C:\driver.sys.

## Instructions
Put in a folder together the following files:

mmap_driver.bat

mapper_driver.sys - from the cheat modules repo directory

mapped_driver.sys - your driver to manual map

Run the batch as administrator et voilà

**If the sc start returns error 647 (The driver was not loaded because it failed its initialization call), it means that the driver successfully loaded. The reason it returns this error it's described in the analysis paper**

No need to take care of cleaning up the mapper as it already self-unload and delete the service registry key.

## Notes
No additional note to add beside how someone can be that clueless in what hes doing



# easy-rw - PoC for reading/writing process memory using BattleFN's cheat kernel modules

This is a PoC that can let you have r/w access to any process that is backed by any anticheat which strip handles rights, using standard Windows APIs.

I made this for two purposes:

1: To show off the analysis being a really accurate resume of the whole BattleFN working mechanism (in contrast to the developers lies where he says that it misses the most important point just to try to save his product)

2: Incase you want a copy and paste ready window to access any protected process memory, you can use that. You'll probably end in making a less detected cheat then its one, using the same stuff he pasted. 

## Instructions
Build it just by opening the Visual Studio project file.

Copy onto the just builded executable the following files from "cheat modules" repo directory:

vmdrv.sys

mapper_driver.sys

mapped_driver.sys

DLLVMhk.dll

Open a command prompt as administrator and run the command:
**"easy-rw.exe \<process id\>"**

If it success, it will write to the console the first 2 bytes of the image of the process you specified (4D 5A)

## Notes

There's just one thing to explain which isn't wrote in the PDF:

    typedef void(*initialize_process_pid_prototype)(HANDLE pid);
    initialize_process_pid_prototype initialize_process_pid_function = 
		(initialize_process_pid_prototype)GetProcAddress(LoadLibraryW(L"gdi32.dll"), "D3DKMTVailDisconnect");
    initialize_process_pid_function(process);

The user-mode module the external cheat process uses hook also an API that the host process must call in order to make the User Mode - Kernel Mode communication working.
In order to perform memory operations, you have to set a global variable present in the DLL that describe the process handle the process should use the driver to read or write memory.
The cheat does it by calling gdi32!D3DKMTVailDisconnect (the API being hooked) with the target process handle as parameter.
If you don't do that, the usermode DLL DLLVMhk wont issue IOCTLs to the driver.

The pseudo-developer Mr Xiao probably did that in order to try to stop the attempt to let others use his bad coded kernel modules.

![access-noseh](https://cdn.upload.systems/uploads/EZH5SIlS.png)

```

`easy-kernelmapper/mmap_driver.bat`:

```bat
echo F|xcopy /y "mapper_driver.sys" "C:\mapper_driver.sys"
echo F|xcopy /y "mapped_driver.sys" "C:\driver.sys"
sc delete kernel_mapper
sc create kernel_mapper binpath="C:\mapper_driver.sys" type=kernel
sc start kernel_mapper
sc delete kernel_mapper
del /f /q "C:\driver.sys"
del /f /q "C:\mapper_driver.sys"

```

`easy-rw-PoC/driver_loader.cpp`:

```cpp
#include <Windows.h>
#include <string>

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

extern "C" NTSTATUS RtlAdjustPrivilege
(
	ULONG    Privilege,
	BOOLEAN  Enable,
	BOOLEAN  CurrentThread,
	PBOOLEAN Enabled
);

extern "C" NTSTATUS ZwLoadDriver(
	PUNICODE_STRING DriverServiceName
);

#define SeLoadDriverPrivilege 10ull

bool acquire_privilege(DWORD privilege)
{
	BOOLEAN enabled = FALSE;
	return NT_SUCCESS(RtlAdjustPrivilege(privilege, TRUE, FALSE, &enabled)) || enabled;
}

bool add_service_registry_key(const wchar_t* driver_name, const wchar_t* driver_path)
{
	std::wstring registry_path = std::wstring(L"System\\CurrentControlSet\\Services\\") + driver_name;

	HKEY key;
	if (RegCreateKeyExW(HKEY_LOCAL_MACHINE, registry_path.c_str(), 0, NULL, 0, KEY_ALL_ACCESS, NULL, &key, 0) != ERROR_SUCCESS)
		return false;
	
	if (RegSetValueExW(key, L"ImagePath", 0, REG_EXPAND_SZ, (PBYTE)driver_path, (DWORD)(wcslen(driver_path) * sizeof(wchar_t))) != ERROR_SUCCESS)
	{
		RegCloseKey(key);
		return false;
	}

	DWORD data = 1;
	if (RegSetValueExW(key, L"Type", 0, REG_DWORD, (PBYTE)&data, sizeof(DWORD)) != ERROR_SUCCESS)
	{
		RegCloseKey(key);
		return false;
	}

	if (RegSetValueExW(key, L"ErrorControl", 0, REG_DWORD, (PBYTE)&data, sizeof(DWORD)) != ERROR_SUCCESS)
	{
		RegCloseKey(key);
		return false;
	}

	data = 3;
	if (RegSetValueExW(key, L"Start", 0, REG_DWORD, (PBYTE)&data, sizeof(DWORD)) != ERROR_SUCCESS)
	{
		RegCloseKey(key);
		return false;
	}

	RegCloseKey(key);
	return true;
}

bool remove_service_registry_key(const wchar_t* driver_name)
{
	std::wstring service_path = std::wstring(L"System\\CurrentControlSet\\Services\\") + driver_name;

	LSTATUS status = RegDeleteKeyW(HKEY_LOCAL_MACHINE,
		service_path.c_str());

	if (status == ERROR_SUCCESS || status == ERROR_FILE_NOT_FOUND)
		return true;

	return false;
}


bool load_driver(const wchar_t* driver_name, const wchar_t* driver_path, NTSTATUS& load_status)
{
	static bool driver_privilege_acquired = false;

	if (!driver_privilege_acquired)
	{
		if (!acquire_privilege(SeLoadDriverPrivilege))
			return false;

		driver_privilege_acquired = true;
	}

	if (!remove_service_registry_key(driver_name))
		return false;

	if (!add_service_registry_key(driver_name, driver_path))
		return false;

	std::wstring service_registry_path = std::wstring(L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\") + driver_name;

	UNICODE_STRING service_registry_us;
	service_registry_us.Buffer = (wchar_t*)service_registry_path.c_str();
	service_registry_us.Length = (USHORT)(service_registry_path.size()) * 2;
	service_registry_us.MaximumLength = (USHORT)(service_registry_path.size() + 1) * 2;

	load_status = ZwLoadDriver(&service_registry_us);

	return NT_SUCCESS(load_status);
}
```

`easy-rw-PoC/driver_loader.h`:

```h
#pragma once

#include <Windows.h>

bool load_driver(const wchar_t* driver_name, const wchar_t* driver_path, NTSTATUS& load_status);

```

`easy-rw-PoC/easy-rw.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{9f6d2b1e-8a30-4be7-ad2b-85a69b5d30fd}</ProjectGuid>
    <RootNamespace>easyrw</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;UMDF_USING_NTSTATUS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>HighestAvailable</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="driver_loader.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver_loader.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`easy-rw-PoC/main.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include <fstream>
#include <TlHelp32.h>
#include <Psapi.h>
#include <ntstatus.h>
#include <iomanip>
#include "driver_loader.h"

bool file_exist(const std::string& file_path)
{
	std::ifstream file(file_path);
	return file.good();
}

bool search_for_vmdrv()
{
	LPVOID drivers[1024];
	DWORD size;

	if (K32EnumDeviceDrivers(drivers, sizeof(drivers), &size) &&
		size < sizeof(drivers))
	{
		wchar_t driver_name[MAX_PATH];

		int drivers_count = size / sizeof(drivers[0]);

		for (int i = 0; i < drivers_count; i++)
		{
			if (K32GetDeviceDriverBaseNameW(drivers[i], driver_name, MAX_PATH))
			{
				if (!_wcsicmp(driver_name, L"vmdrv.sys"))
					return true;
			}
		}
	}
	return false;
}

bool get_process_image_base(HANDLE process, DWORD_PTR& image_base)
{
	HMODULE process_base;
	DWORD size_needed;
	if (EnumProcessModules(process, &process_base, sizeof(process_base), &size_needed))
	{
		image_base = (DWORD_PTR)process_base;
		return true;
	}
	return false;
}

int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		std::cout << "Usage: easy-rw.exe <process pid>" << std::endl;
		return 0;
	}

	DWORD process_pid = atoi(argv[1]);

	std::cout << "easy-rw PoC" << std::endl;

	// check for needed modules existence
	if (!file_exist("mapped_driver.sys") ||
		!file_exist("mapper_driver.sys") ||
		!file_exist("vmdrv.sys") ||
		!file_exist("DLLVMhk.dll"))
	{
		std::cout << "Error: one of the needed components not found in the directory" << std::endl;
		return 0;
	}

	bool vmdrv_present = search_for_vmdrv();
	bool load_drivers = true;
	if (vmdrv_present)
	{
		std::cout << "Warning: vmdrv is already loaded. Do you want to load the other drivers?" << std::endl;
		std::cout << "Press Y and enter for yes, any other key and enter otherwise" << std::endl;
		std::cout << "If you already opened this PoC before and the loading of all the drivers was successfull, you can skip this" << std::endl;

		std::string answer;
		std::cin >> answer;

		if (answer != "Y" && answer != "y")
			load_drivers = false;
	}

	if (load_drivers)
	{
		NTSTATUS driver_load_status;

		// get current path
		wchar_t current_path[MAX_PATH];
		GetCurrentDirectory(MAX_PATH, current_path);

		if (!vmdrv_present)
		{
			// load vmdrv.sys
			std::wstring vmdrv_path = std::wstring(L"\\??\\") + std::wstring(current_path) + L"\\vmdrv.sys";
			if (!load_driver(L"VOICEMOD_Driver", vmdrv_path.c_str(), driver_load_status))
			{
				std::cout << "Failed loading vmdrv.sys" << std::endl;
				return 0;
			}
		}

		std::cout << "vmdrv.sys successfully loaded" << std::endl;

		// copy the driver to manualmap in C:\\

		if (!CopyFileW(L"mapped_driver.sys", L"C:\\driver.sys", FALSE))
		{
			std::cout << "Failed moving mapped_driver.sys to C:\\" << std::endl;
			return 0;
		}

		std::cout << "successfully copied mapped_driver.sys onto C:\\" << std::endl;

		// load mapper_driver.sys
		std::wstring mapper_driver_path = std::wstring(L"\\??\\") + std::wstring(current_path) + L"\\mapper_driver.sys";
		driver_load_status = 0;
		if (load_driver(L"mapper_driver", mapper_driver_path.c_str(), driver_load_status) 
			|| driver_load_status != STATUS_FAILED_DRIVER_ENTRY)
		{
			std::cout << "Failed loading mapper driver." << std::endl;
			return 0;
		}

		std::cout << "mapper_driver.sys successfully loaded" << std::endl;

		DeleteFileW(L"C:\\driver.sys");
	}

	// load DLLVMHk.dll
	HMODULE DLLVMHk_handle = LoadLibraryW(L"DLLVMhk.dll");

	if (DLLVMHk_handle == NULL)
	{
		std::cout << "Failed loading DLLVMHk module" << std::endl;
		return 0;
	}

	std::cout << "DLLVMhk successfully loaded in the process" << std::endl;

	// open a HANDLE to the process
	HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process_pid);
	if (process == NULL)
	{
		std::cout << "Failed opening a handle to the process (perhaps wrong PID?)" << std::endl;
		return 0;
	}

	// Initialize the process handle for DLLVMhkt
	typedef void(*initialize_process_pid_prototype)(HANDLE pid);
	initialize_process_pid_prototype initialize_process_pid_function = 
		(initialize_process_pid_prototype)GetProcAddress(LoadLibraryW(L"gdi32.dll"), "D3DKMTVailDisconnect");
	initialize_process_pid_function(process);

	// get process image base
	DWORD_PTR process_image_base;
	if (!get_process_image_base(process, process_image_base))
	{
		std::cout << "Failed in getting process image base" << std::endl;
		CloseHandle(process);
		return 0;
	}

	std::cout << "process image base: 0x" << std::hex << std::setfill('0') << std::setw(2) << std::uppercase << process_image_base << std::endl;

	// read the MZ bytes to check if everything is working fine
	BYTE MZ_bytes[2];
	SIZE_T read_bytes = 0;
	if (!ReadProcessMemory(process, (LPCVOID)process_image_base, MZ_bytes, sizeof(MZ_bytes), &read_bytes))
	{
		std::cout << "Failed to read process image base" << std::endl;
		CloseHandle(process);
		return 0;
	}

	std::cout << "Printing read bytes: " << std::hex << std::setfill('0') << std::setw(2) << (int)MZ_bytes[0] << " " << (int)MZ_bytes[1] << std::endl;

	std::cout << "Success!" << std::endl;

	// done
	CloseHandle(process);

	return 0;
}

```